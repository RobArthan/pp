% %Z% $Date$ $Revision$ $RCSfile$ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Tool Enhancement Integration Tests}  %% Mandatory field
\def\TPPheadtitle{Compliance Tool Enhancement Integration Tests}
\TPPref{ISS/HAT/DAZ/INT508}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives a Compliance Notation script with examples of the enhancements.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1%
] Initial Draft.
\item[Issue 1.7]
Clarifying diagnostic output.
\item[Issue 1.8]
Corrected bug revealed by bug fixing elsewhere in code.
\item[Issue 1.9]
Changed to one compilation unit per script.
\item[Issue 1.10]
Removed a rogue $summarize\_mt\_results$.
\item[Issue 1.11 - 1.12]
IUCT WP 2 changes.
\item[Issue 1.13]
IUCT WP 4 changes.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool Enhancements as specified in \cite{ISS/HAT/DAZ/HLD501} and \cite{ISS/HAT/DAZ/USR501}.

\subsection{Introduction}


\section{THE LITERATE SCRIPTS}


\subsection{Setting up of the enivronment}

Set up flags so the compliance tool works correctly .

=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX

Load the test harness.

=SML
diag_line "These tests will generate loading, warning and error messages that can be ignored.";
diag_line "Only messages from the test harness should be considered.";
use_file "dtd013";
use_file "imp013";
=TEX

\subsection{Useful functions}

Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = (get_descendants "cn" less "cn")
					diff get_cache_theories();
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
The following function is handy in cases where we can rely on the subgoal package to do all the checking needed.
=SML
fun thm_chk () = (
	let	val th = pop_thm();
	in	fn () => ((map diag_line o PrettyPrinter.format_thm) th; ())
	end
);
=TEX
\pagebreak
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 1: Annotations}
=TEX
Mostly, the automatically checkable criteria for success in these tests are that the script should load without errors and the SPARK program generation should not fail. 
=SML
clean_up();
new_script{name = "annotations.1", state = initial_cn_state};
=TEX
\subsubsection{Annotation as Declaration}
πCN
procedure S is
    X: INTEGER;
    procedure T is
    --# hide T
    begin
        X := 2 * X;
    end T;
begin
    null;
end S;
∞
=SML
store_mt_results_show mt_run[
	("annotation.1.1a", print_spark_program, (), ())
];
=TEX
\subsubsection{Annotation as Statement}
=SML
val state1 = get_cn_state();
new_script{name = "annotations.1a", state = state1};
πCN
package Q is
  A : INTEGER;
end Q;
=SML
val state1A = get_cn_state();
new_script{name = "annotations.1aA", state = state1A};
πCN
package body Q is

begin
--# hide Q
	A := 0;
end Q;
∞
=SML
store_mt_results_show mt_run[
	("annotation.1.1b", print_spark_program, (), ())
];
=TEX
\subsubsection{Annotation in Subprogram Body}
=SML
val state2 = get_cn_state();
new_script{name = "annotations.1b", state = state2};
πCN
procedure A is
    X: INTEGER;
    procedure B
    --# global X;
    --# derives X from X;
    is
    begin
        X := 2 * X;
    end B;
    function C return INTEGER
    --# global X;
    is
    begin
        return X;
    end C;
begin
    null;
end A;
∞
=SML
store_mt_results_show mt_run[
	("annotation.1.1c", print_spark_program, (), ())
];
=TEX
=TEX
\subsubsection{Annotation in Package Specification}
=SML
val state3 = get_cn_state();
new_script{name = "annotations.1c", state = state3};
πCN
package PK
--# own B;
is
    B : INTEGER;
    function f (x : INTEGER) return INTEGER;
end PK;
∞
=SML
store_mt_results_show mt_run[
	("annotation.1.1d", print_spark_program, (), ())
];
=TEX
\subsubsection{Annotation in Package Body}
=SML
val state4 = get_cn_state();
new_script{name = "annotations.1d", state = state4};
πCN
package body PK
--# own B;
is
    function f (x : INTEGER) return INTEGER
    is begin return x; end f;
end PK; 
∞
=SML
store_mt_results_show mt_run[
	("annotation.1.1e", print_spark_program, (), ())
];
=TEX
\subsubsection{Annotation in Compilation Units}
=SML
val state6 = get_cn_state();
new_script{name = "annotations.1e", state = state6};
πCN
package PK1
is
    C : constant INTEGER := 8;
end PK1;
∞
=SML
store_mt_results_show mt_run[
	("annotation.1.1f", print_spark_program, (), ())
];
=TEX
=SML
val state7 = get_cn_state();
new_script{name = "annotations.1f", state = state7};
πCN
with PK1;
--# inherit PK1;
package PK2
is
    D : constant INTEGER := PK1.C - 1;
end PK2;
∞
=SML
store_mt_results_show mt_run[
	("annotation.1.1g", print_spark_program, (), ())
];
=TEX
\subsubsection{Annotation in Package Body Stub}
This is allowed in the grammar (to remove an SLRP conflict) but should
be rejected by the parser:
=SML
val state8 = get_cn_state();
new_script{name = "annotations.1.2", state = state8};
=SML
fun ann_in_pack_body_stub () =
πCN
procedure PP is
package body PK
--# own B;
is separate;
begin null; end PP;
∞
=SML
store_mt_results_show mt_run_fail[
	("annotation.1.2", ann_in_pack_body_stub, (),
			gen_fail_msg "cn_parser" 503204[] )
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 2: Real Types}
=SML
clean_up();
new_script{name = "reals.1", state = initial_cn_state};
πCN
procedure SWAP_REALS is
    type FIX is delta 0.1 range 5.1 .. 10.0;
    A, B, TEMP : FIX;
begin
 Ñ A, B, TEMP [A = Bâ0 ± B = Aâ0]
end SWAP_REALS;
∞
πCN
 √ TEMP := A; A := B; B := TEMP;
∞
=SML
set_goal([], get_conjecture "-" "vc_1_1");
a(prove_tac[]);
val reals_1 = thm_chk();
store_mt_results_show mt_run[
	("reals.1", reals_1, (), ())
];
=TEX
=SML
clean_up();
new_script{name = "reals.2", state = initial_cn_state};
πCN
package SR is
    type FIX is delta 0.1 range 5.1 .. 10.0;
    procedure SWAP_REALS (A, B : in out FIX)
     Ñ A, B [A = Bâ0 ± B = Aâ0];
end SR;
∞
=SML
val state9 = get_cn_state();
new_script{name = "reals.2a", state = state9};
πCN
with SR;
procedure P is
    X, Y : SR.FIX;
begin
 Ñ X, Y [X = Yâ0 ± Y = Xâ0]
end P;
∞
πCN
 √ SR.SWAP_REALS(X, Y);
∞
=SML
set_goal([], get_conjecture "-" "vc_1_2");
a(prove_tac[]);
val reals_2 = thm_chk();
store_mt_results_show mt_run[
	("reals.2", reals_2, (), ())
];
=TEX
The following is an additional test on the volume I material which was affected by this enhancement.
Subsequent had to split into packages $P$ and $P1$ due to restrictions on
functions refering to each other in their specifications.
=SML
clean_up();
new_script{name = "reals.3", state = initial_cn_state};
=TEX

πCN
package P1 is
  function F (X : integer) return integer
  ò  [F(X) = 2*X];
end P1;
∞
=SML
val state10 = get_cn_state();
new_script{name = "reals.3a", state = state10};
πCN
with P1;
package P is
  function G(X:integer) return integer
  ò  [G(X) = 3*P1oF(X)]	;
end P;
∞
=SML
val state10 = get_cn_state();
new_script{name = "reals.3b", state = state10};
πCN
with P;
  function H (X : integer) return integer
  ò  [H(X) = 12*X]
  is begin
    return P.G(P1.F(X));
  end H;
∞

=SML
set_goal([ÒINTEGER = UÆ], get_conjecture "-" "vcH_1");
a(MAP_EVERY (ante_tac o z_get_spec)[ÒPoGÆ, ÒP1oFÆ]);
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(PC_T1"z_lin_arith"prove_tac[]);
val reals_3 = thm_chk();
store_mt_results_show mt_run[
	("reals.3", reals_3, (), ())
];
=TEX
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 3: Multi-dimensional Arrays}
=SML
clean_up();
new_script{name = "multi-dim-arrays.1", state = initial_cn_state};
πCN
procedure P is
    type THREE is range 1 ..3;
    type ARR is array (THREE, THREE) of THREE;
    X: constant ARR := ARR'((1, 2, 3), (3, 4, 5), (5, 6, 7));
begin
    null;
end P;
∞
=SML
print_spark_program();
set_goal([], ÒX ç ARRÆ);
a(rewrite_tac (map z_get_spec(get_consts"-")));
val multi_dim_arrays_1 = thm_chk();
store_mt_results_show mt_run[
	("multi-dim-arrays.1", multi_dim_arrays_1, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 4: NATURAL Etc.}
=SML
clean_up();
new_script{name = "naturals-etc", state = initial_cn_state};
=SML
fun naturals_etc_1 () = 
πCN
procedure P is
    type THREE is range 1 ..3;
    type NAT_ARR is array (THREE) of NATURAL;
    type POS_ARR is array (THREE) of POSITIVE;
    type LONG_ARR is array (THREE) of LONG_INTEGER;
    type SHORT_ARR is array (THREE) of SHORT_INTEGER;
begin
    null;
end P;
∞
=SML
store_mt_results_show mt_run[
	("naturals-etc.1", naturals_etc_1, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 5: Visibility Rules}
=SML
clean_up();
new_script{name = "visibility.1", state = initial_cn_state};
fun show_cn_thys () = (
	map (fn thy => (thy, get_parents thy)) (get_descendants "cn")
);
πCN
package P1 is
 C1 : constant INTEGER := 1;
end P1;
∞
=SML
val state11 = get_cn_state();
new_script{name = "visibility.1a", state = state11};

=SML
fun visibility_1 () =
πCN
with P1;
package P2 is
 C2 : constant INTEGER := 1;
 function F2 (X : INTEGER) return INTEGER
  ò [F2(X) = X + 1];
end P2;
∞
=TEX
=SML
store_mt_results_show mt_run[
	("visibility.1", visibility_1, (), ())
];
=SML
new_script{name = "visibility.2", state = get_cn_state()};
fun visibility_2 () =
πCN
package body P2 is
 function F2 (X : INTEGER) return INTEGER
   ò [F2(X) = X + 1]
 is  begin return X + P1.C1; end F2;
end P2;
∞
=TEX
=SML
store_mt_results_show mt_run[
	("visibility.2", visibility_2, (), ())
];
=SML
set_pc"cn";
set_goal([], get_conjecture"-" "vcP2body_1");
a(REPEAT strip_tac);
val vis_2_1  = thm_chk();
set_goal([], get_conjecture"-" "vcP2body_2");
a(REPEAT strip_tac);
val vis_2_2  = thm_chk();
set_goal([], get_conjecture"-" "vcP2body_3");
a(rewrite_tac[z_get_specÒP1oC1Æ] THEN REPEAT strip_tac);
val vis_2_3  = thm_chk();
store_mt_results_show mt_run[
	("visibility.2.1", vis_2_1, (), ()),
	("visibility.2.2", vis_2_2, (), ()),
	("visibility.2.3", vis_2_3, (), ())
];
=TEX
=SML
clean_up();
new_script{name="visibility.3", state=initial_cn_state};

πCN
package A is
    V : INTEGER;
end A;
∞

=SML
val state12 = get_cn_state();
new_script{name = "visibility.3a", state = state12};
πCN
with A;
package B is
    procedure INIT
    Ñ AoV [AoV = 0];
end B;
∞

=SML
val state13 = get_cn_state();
new_script{name = "visibility.3b", state = state13};
πCN
package body B is
    procedure INIT
    Ñ AoV [AoV = 0]
    is
    begin
        A.V := 0;
    end INIT;
end B;
∞
=SML
val state14 = get_cn_state();
new_script{name = "visibility.3c", state = state14};
πCN
with A, B;
procedure C
Ñ AoV [AoV = 0]
is
begin
    B.INIT;
end C;
∞
=SML
set_goal([], (list_mk_± o map (snd o snd) o get_conjectures)"-");
a(PC_T1"cn" prove_tac[]);
val vis_3  = thm_chk();
store_mt_results_show mt_run[
	("visibility.3", vis_3, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 6: Pragmas}
The automatically checkable criteria for success in these tests are that the script should load without errors and the SPARK program generation should not fail. 
\subsubsection{Pragma as Compilation Unit}
=SML
clean_up();
new_script{name = "pragmas.1", state = initial_cn_state};
πCN
pragma system_name("MIX");
∞
=SML
store_mt_results_show mt_run[
	("pragmas.1", print_spark_program, (), ())
];
=TEX
=TEX
\subsubsection{Pragma List inside Compilation Unit}
πCN
pragma memory_size(4000);
pragma storage_unit(41);
package Constants
is
    bits_per_byte : constant INTEGER := 8;
    type BYTE is range 0 .. 255;
    type WORD is record sign : BOOLEAN; b1, b2, b3, b4, b5 : BYTE; end record;
    type INDEX is record sign : BOOLEAN; b1, b2 : BYTE; end record;
end Constants;
∞
=SML
store_mt_results_show mt_run[
	("pragmas.1a", print_spark_program, (), ())
];
=TEX
=SML
val state15 = get_cn_state();
new_script{name = "pragmas.1a", state = state15};
πCN
with Constants;
pragma elaborate(Constants);
package Registers
is
    rA, rX : WORD;
    rI1, rI2, rI3, rI4, rI5, rI6, rJ : INDEX;
end Registers;
∞
=SML
store_mt_results_show mt_run[
	("pragmas.1b", print_spark_program, (), ())
];
=TEX
=TEX
\subsubsection{Pragma as Declaration}
=SML
val state16 = get_cn_state();
new_script{name = "pragmas.1b", state = state16};
πCN
with Constants, Registers;
package Init
is
     procedure reset ;
     pragma inline(reset);
end Init;
∞
=SML
store_mt_results_show mt_run[
	("pragmas.1c", print_spark_program, (), ())
];
=TEX
=TEX
\subsubsection{Pragma as Statement}
=SML
val state17 = get_cn_state();
new_script{name = "pragmas.1c", state = state17};
πCN
with Constants, Registers;
package body Init
is
     procedure reset
     is
     begin
         pragma list(off);
         rA := 0;
         rX := 0;
         rI1 := 0;
         rI2 := 0;
         rI3 := 0;
         rI4 := 0;
         rI5 := 0;
         rI6 := 0;
         rJ := 0;
         pragma list(on);
    end reset;
end Init;
∞
=TEX
=SML
store_mt_results_show mt_run[
	("pragmas.1d", print_spark_program, (), ())
];
=TEX
\subsubsection{Pragma in a Using Declaration}
=SML
clean_up();
new_script{name="pragmas.2", state=initial_cn_state};
=TEX
πZ
‹ fun 100 sum _, size _
∞

πZAX
‹	sum_ : bag ˙ ≠ ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	sum ˚ ˝ = 0 ±
‹	(µ b : bag ˙; n : ˙ ∑ sum (b Ç ˚n˝) = sum b + n)
∞
πZAX
‹	size_: bag ˙ ≠ ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	size ˚ ˝ = 0 ±
‹	(µ b : bag ˙; n : ˙ ∑ size (b Ç ˚n˝) = size b + 1)
∞
πCN
package PRC_IN_PCK_RFN is

	auxiliary B : bag ˙;

	procedure MEAN (M : out INTEGER)
	Ñ M [B Ω ˚ ˝, M = sum B intdiv size (B)];

end PRC_IN_PCK_RFN;
∞
=SML
store_mt_results_show mt_run[
	("pragmas.2a", print_spark_program, (), ())
];
=TEX
=SML
val state18 = get_cn_state();
new_script1{name = "pragmas.2a", state = state18,
	library_theories=["pragmas.2"]};
ˇBag_Inv¸¸¸¸¸¸¸¸¸¸¸¸
‹	B : bag ˙;
‹	S, N : INTEGER
˜¸¸¸¸¸¸
‹	S = sum B;
‹	N = size B
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πCN
package body PRC_IN_PCK_RFN is

	using
         pragma list (on);
           S, N : INTEGER;
         pragma list(off);
        implement B by Bag_Inv;

	procedure MEAN (M : out INTEGER)
	Ñ M, S, N [N Ω 0, M = S intdiv N ± S = Sâ0 ± N = Nâ0]
	is
	begin
		M := S / N;
	end MEAN;

begin
	S := 0;

end PRC_IN_PCK_RFN;
∞
=TEX
=SML
store_mt_results_show mt_run[
	("pragmas.2", print_spark_program, (), ())
];
=TEX
\subsubsection{Interface Pragma}
=SML
clean_up();
new_script{name = "pragmas.3", state = initial_cn_state};
πCN
procedure jim(X : IN OUT INTEGER)
     Ñ X[X > 0]
is
     procedure fred (A : IN OUT INTEGER)
	Ñ A[A = 1];
    pragma interface(C, fred);
begin
    fred(X);
end jim;
∞
=SML
set_pc"cn";
set_goal([], get_conjecture"-" "vcJIM_2");
a(LEMMA_TÒµ X : INTEGER | true ± X = 1 ∑ X > 0Æ accept_tac
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
val pragmas_3_1  = thm_chk();
store_mt_results_show mt_run[
	("pragmas.3.1", pragmas_3_1, (), ()),
	("pragmas.3.2", print_spark_program, (), ())

];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 7: With Clauses}
=SML
clean_up();
new_script{name = "with-clauses.1", state = initial_cn_state};
πCN
package PACK1 is
 C : constant INTEGER := 10;
end PACK1;
∞

=SML
val state19 = get_cn_state();
new_script{name = "with-clauses.1a", state = state19};
πCN
with PACK1;
package PACK2 is
 D : constant INTEGER := PACK1.C;
 procedure Q (X : out INTEGER)
  Ñ X [X = 20];
end PACK2;
∞
=SML
val state20 = get_cn_state();
new_script{name = "with-clauses.1b", state = state20};
πCN
with PACK2;
procedure P (X : out INTEGER)
  Ñ X [X = PACK2oD + 10]
 is begin PACK2.Q(X); end P;
∞
=SML
set_pc"cn";
set_goal([], get_conjecture"-" "vcP_1");
a(REPEAT strip_tac);
val with_1_1  = thm_chk();
set_goal([], get_conjecture"-" "vcP_2");
a(rewrite_tac(map z_get_spec[ÒPACK2oDÆ, ÒPACK1oCÆ]) THEN REPEAT strip_tac);
val with_1_2  = thm_chk();
store_mt_results_show mt_run[
	("with-clauses.1.1", with_1_1, (), ()),
	("with-clauses.1.2", with_1_2, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 8: CHARACTER Etc.}
=SML
clean_up();
new_script{name = "character-etc", state = initial_cn_state};
=SML
fun character_etc_1 () = 
πCN
procedure P is
    subtype STRING_LENGTH is INTEGER range 9 .. 13;
    subtype MY_STRING is STRING(STRING_LENGTH);
begin
    null;
end P;
∞
=SML
store_mt_results_show mt_run[
	("character-etc.1", character_etc_1, (), ())
];
=TEX
\subsection{Enhancement 9: VC Browser Mods}
This has to be tested interactively.
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 10: Renaming}
\subsubsection{Renaming Operator Symbols}
=SML
clean_up();
new_script{name = "renaming.1", state = initial_cn_state};
πCN
package PACK is
    type INT is range 10 .. 20;
end PACK;
∞
=SML
val state21 = get_cn_state();
new_script{name = "renaming.1a", state = state21};
πCN
with PACK;
procedure MAIN is
     function ">=" (left, right : PACK.INT) return BOOLEAN renames PACK.">=";
     I : PACK.INT;
begin
  Ñ I [I æ 15]
end MAIN;
∞

πCN
  √ I := 16;
∞
=SML
set_pc"cn";
set_goal([], get_conjecture"-" "vc_1_1");
a(REPEAT strip_tac);
val renaming_1_1  = thm_chk();
store_mt_results_show mt_run[
	("renaming.1.1", renaming_1_1, (), ())
];
=SML
val state22 = get_cn_state();
new_script{name = "renaming.1b", state = state22};
=SML
fun renaming_err() =
πCN
with PACK;
procedure WRONG is
     function "<" (left, right : PACK.INT) return BOOLEAN renames PACK.">=";
     I : PACK.INT;
begin
  Ñ I [I æ 15]
end WRONG;
∞
=SML
store_mt_results_show mt_run_fail[
	("renaming.1.2", renaming_err, (), gen_fail_msg"cn_parser" 503204 [])
];
=TEX
\subsubsection{Renaming Other Functions}
=SML
clean_up();
new_script{name = "renaming.2", state = initial_cn_state};
πCN
package PACK is
    function F (X : INTEGER) return INTEGER
      ò [F(X) = 5];
end PACK;
∞
=SML
val state23 = get_cn_state();
new_script{name = "renaming.2a", state = state23};
πCN
with PACK;
procedure MAIN is 
    function F (X : INTEGER) return INTEGER renames PACK.F;
    Z : INTEGER;
begin
    Ñ Z [Z = 9]
end MAIN;
∞
πCN
  √ Z := F(Z) + 4;
∞

=SML
set_pc"cn";
set_goal([], get_conjecture"-" "vc_1_1");
a(rewrite_tac(map z_get_spec[ÒFÆ, ÒPACKoFÆ]));
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac(map z_get_spec[ÒPACKoFÆ]));
val renaming_2  = thm_chk();
store_mt_results_show mt_run[
	("renaming.2", renaming_2, (), ())
];
=TEX
\subsubsection{Renaming Procedures}
=SML
clean_up();
new_script{name = "renaming.3", state = initial_cn_state};
πCN
package PACK is
    procedure P (X : out INTEGER)
      Ñ X [5 º X < 6];
end PACK;
∞
=SML
val state24 = get_cn_state();
new_script{name = "renaming.3a", state = state24};
πCN
with PACK;
procedure MAIN is 
    procedure P (X : out INTEGER) renames PACK.P;
    Z : INTEGER;
begin
    Ñ Z [Z = 9]
end MAIN;
∞
πCN
  √ P(Z); Z:= 3*Z - 6;
∞

=SML
set_pc"cn";
set_goal([], get_conjecture"-" "vc_1_1");
a(REPEAT strip_tac);
val renaming_3_1  = thm_chk();
set_goal([], get_conjecture"-" "vc_1_2");
a(PC_T1 "z_lin_arith" prove_tac[]);
val renaming_3_2  = thm_chk();
store_mt_results_show mt_run[
	("renaming.3.1", renaming_3_1, (), ()),
	("renaming.3.2", renaming_3_2, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 11: Qualified Expressions}
=SML
clean_up();
new_script{name = "qualified-expressions.1", state = initial_cn_state};
πCN
procedure P is
 D : constant INTEGER := INTEGER'(42);
begin
 null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒD = 42Æ);
a(accept_tac(z_get_specÒDÆ));
val qual_exp_1  = thm_chk();
store_mt_results_show mt_run[
	("qualified-expressions.1", qual_exp_1, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 12: Type Conversions}
=SML
clean_up();
new_script{name = "type-conversions.1", state = initial_cn_state};
πCN
procedure TYPE_CONVS is
    type SHORT_INT is range -32768 .. 32767;
    type LONG_INT is range -2147483648  .. 2147483647;
    subtype SUB is INTEGER range 50 .. 100;
    X : LONG_INT;
    Y : INTEGER;
begin
 Ñ X, Y [ Y = 75 ]
end TYPE_CONVS;
∞

πCN
  √
    X := 70;
    Y := SHORT_INT(X);
    Y := SUB(SHORT_INT(5 + INTEGER(X)));
∞
=SML
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(prove_tac[]);
val type_conv_1  = thm_chk();
store_mt_results_show mt_run[
	("type-conversions.1", type_conv_1, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 13: Use Binding Displays}
=SML
clean_up();
new_script{name = "binding_display.1", state = initial_cn_state};
πCN
procedure BD is
    type REC1 is record A, B : INTEGER; end record;
    type REC2 is record X, Y : INTEGER; Z : REC1; end record;
    type REC3 is record W, V : REC1; U : REC2; end record;
    v1 : constant REC1 := REC1'(B=>42, A=>99);
    v2 : constant REC1 := REC1'(42, 99);
    v3 : constant REC2 := REC2'(1,2, REC1'(3, 4));
    v4 : constant REC3 := REC3'(W=>v1, U=>v3, V=>v2);
begin
    null;
end BD;
∞
=SML
set_goal([], ÒV4.U = V3 ± V4.V = V2 ± V4.W = V1Æ);
a(PC_T1 "cn" prove_tac(map z_get_spec[ÒV1Æ, ÒV2Æ, ÒV3Æ, ÒV4Æ]));
val binding_display_1  = thm_chk();
store_mt_results_show mt_run[
	("binding-display.1", binding_display_1, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 14: Record Assignments}
=SML
clean_up();
new_script{name = "record-assign.1", state = initial_cn_state};
πCN
procedure P is
    type DAY is (MON, TUE, WED);
    type REC is record X : INTEGER; D : DAY; end record;
    type ARR is array(DAY) of REC;
    A : ARR;
begin
 Ñ A [(A MON).D = TUE]
end P;
∞
πCN
 √ A (MON).D := TUE;
∞
=SML
set_pc"z_library_ext";
set_goal([], Ò[X, Y](µf : X ≠ Y; x:U; y : U∑(f ´ {x Ì y})x = y)Æ);
a(REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 ÒyÆ);
val z_´_lemma = pop_thm();
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(rewrite_tac[z_get_specÒARRÆ] THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_´_lemma]);
val record_assign_1  = thm_chk();
store_mt_results_show mt_run[
	("record-assign.1",record_assign_1, (), ())
];
=TEX
=SML
clean_up();
new_script{name = "record-assign.2", state = initial_cn_state};
πCN
procedure BD is
    type REC1 is record A, B : INTEGER; end record;
    type REC2 is record X, Y : INTEGER; Z : REC1; end record;
    type REC3 is record W, V : REC1; U : REC2; end record;
    v1a : constant REC1 := REC1'(B=>42, A=>99);
    v1b : constant REC1 := REC1'(42, 99);
    v2 : constant REC2 := REC2'(1,2, REC1'(3, 4));
    v3 : constant REC3 := REC3'(W=>v1a, U=>v2, V=>v1b);
    a1 : REC1;
    a2 : REC2;
    a3 : REC3;
begin
    Ñ A1, A2, A3[
		A1 = (A¶42, B¶42) ±
		A2 = (X¶100, Y¶100, Z¶A1) ±
		A3 = (W¶A1, V¶V1A, U¶A2)
   ]
end BD;
∞
πCN
 √
    a1.A := v1a.B;
    a1.B := v1b.A;
    a2 := v2;
    a2.X := 100 * a2.X;
    a2.Y := 50 * a2.Y;
    a2.Z.A := 42;
    a2.Z.B := a2.Y - 58;
    a3.W.A := 42;
    a3.W.B := 42;
    a3.V.A := v1a.A;
    a3.V.B := a3.W.B;
    a3.U := a2;
∞
=SML
val old_pp_f_d = set_int_control("pp_format_depth", 8);
val old_pp_tl_d = set_int_control("pp_top_level_depth", 8);
val def_thms = map z_get_spec(get_consts"-");
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT strip_tac THEN_TRY SOLVED_T (rewrite_tac def_thms));
val record_assign_2 = thm_chk();
store_mt_results_show mt_run[
	("record-assign.2",record_assign_2, (), ())
];
set_int_control("pp_format_depth", old_pp_f_d);
set_int_control("pp_top_level_depth", old_pp_tl_d);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 15: And-then/Or-else}
=SML
clean_up ();
new_script{name = "and-then.1", state = initial_cn_state};
πCN
procedure P
Ñ [true]
is
	v1 : constant BOOLEAN := 1 = 2 and 2 = 3;
	v2 : constant BOOLEAN := 1 = 2 or 2 = 3;
	w1 : constant BOOLEAN := 1 = 2 and then 2 = 3;
	w2 : constant BOOLEAN := 1 = 2 or else 2 = 3;
begin
 null;
end P;
∞
The proof below takes care not to exploit the fact that all four constants evaluate to false.
=SML
set_goal([], ÒV1 = W1 ± V2 = W2Æ);
a(pure_rewrite_tac(map z_get_spec[ÒV1Æ, ÒV2Æ, ÒW1Æ, ÒW2Æ]));
a(PC_T1"hol" prove_tac[]);
val and_then_1 = thm_chk();
store_mt_results_show mt_run[
	("and_then.1", and_then_1, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 16: Hypertext Links}
Tested elsewhere.
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 17: Subtype Attributes}
=SML
clean_up();
new_script{name = "subtype_attrs.1", state = initial_cn_state};
πCN
procedure P is
    type INT is range 9 .. 67;
    subtype SUB is INT range 16 .. 50;
    X: constant SUB := (SUB'LAST - SUB'FIRST) / 2;
begin
    null;
end P;
∞
=SML
set_goal([], Ò
	SUBvSUCC = INTvSUCC ±
	SUBvPRED = INTvPRED ±
	SUBvPOS = INTvPOS ±
	SUBvVAL = INTvVAL ±
	16 < X < 50
Æ);
a(PC_T1 "cn" rewrite_tac (map z_get_spec(get_consts"-")));
val subtype_attrs_1 = thm_chk();
store_mt_results_show mt_run[
	("subtype-attrs.1",subtype_attrs_1, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 18: Subtype Range Checks}
=SML
clean_up();
new_script{name = "range-checks.1", state = initial_cn_state};
=SML
fun range_checks_1 () =
πCN
procedure Q is
    type INT is range 100 ..50;
    X: SUB;
begin
     Ñ X [X = 200]
end Q;
∞
=SML
store_mt_results_show mt_run_fail[
	("range-checks.1", range_checks_1, (), gen_fail_msg 
		"basic_decl_otherwise" 507041 [])
];
=TEX

=SML
val state25 = get_cn_state();
new_script{name = "range-checks.1a", state = state25};
=SML
πCN
procedure R is
    type THREE is (ZERO, ONE, TWO);
    subtype SUB2 is THREE range ONE .. TWO; -- OK; No VC
    type ARR is array (THREE) of SUB2;
    type INT3 is range 1 .. ARR'LENGTH; -- OK; No VC
    subtype SUB3 is THREE range ZERO .. THREE'SUCC(ONE); -- VC
begin
     NULL;
end R;
∞
z_print_theory"-";
=TEX
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 19: Unconstrained Arrays}
=SML
clean_up();
new_script{name = "unconstrained-arrays.1", state = initial_cn_state};
=SML
πCN
procedure Q is
    type UNCON is array(INTEGER range <>) of INTEGER;
begin
     NULL;
end Q;
∞
z_get_specÒUNCONÆ;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 20: Arbitrary Replacements}
The automatically checkable criteria for success in these tests are that the script should load without errors and the SPARK program generation should not fail. 
=SML
clean_up();
new_script{name = "arbitrary_replacements.1", state = initial_cn_state};
πCN
 ß compilation unit ¢ (1)
∞
πCN
 (1) !È-- This is some commentary
        -- for inclusion at the head of the output file
        -- note the second two lines have 8 leading spaces
		 	-- and this one starts tab-tab-space-tab
∞
πCN
package  P is
    X:INTEGER;
private
 ß private part ¢ (2)
end P;
∞
πCN
 (2) !Ètype T is access INTEGER;
∞
=SML
store_mt_results_show mt_run[
	("arbitrary_replacements.1d", print_spark_program, (), ())
];
=TEX
=SML
val state26 = get_cn_state();
new_script{name = "arbitrary_replacements.1a", state = state26};
πCN
package  Q is
 ß visible part ¢ (3)
end Q;
∞
πCN
 (3) !Ètype Q is access P.T;
∞
=SML
store_mt_results_show mt_run[
	("arbitrary_replacements.1c", print_spark_program, (), ())
];
=TEX
=SML
val state27 = get_cn_state();
new_script{name = "arbitrary_replacements.1b", state = state27};
πCN
procedure R is
 ß declaration ¢ (4)
begin null; end R;
∞
πCN
 (4) !Ètype U is access Q.Q;
∞
=SML
store_mt_results_show mt_run[
	("arbitrary_replacements.1b", print_spark_program, (), ())
];
=TEX
=SML
val state27 = get_cn_state();
new_script{name = "arbitrary_replacements.1c", state = state27};
πCN
procedure S is
begin
 ß statement ¢ (5)
end S;
∞
πCN
 (5) !È<<LABEL>>
∞
=SML
store_mt_results_show mt_run[
	("arbitrary_replacements.1a", print_spark_program, (), ())
];
=TEX
=SML
val state28 = get_cn_state();
new_script{name = "arbitrary_replacements.1d", state = state28};
πCN
procedure T is
begin
 Ñ  [true, false]    (6)
end T;
∞
πCN
 (6) !È goto label;
∞
=SML
store_mt_results_show mt_run[
	("arbitrary_replacements.1", print_spark_program, (), ())
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX

\end{document}

