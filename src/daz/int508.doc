% %Z% $Date$ $Revision$ $RCSfile$ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Tool Enhancement Integration Tests}  %% Mandatory field
\def\TPPheadtitle{Compliance Tool Enhancement Integration Tests}
\TPPref{ISS/HAT/DAZ/INT508}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives a Compliance Notation script with examples of the enhancements.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1%
] Initial Draft.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool Enhancements as specified in \cite{ISS/HAT/DAZ/HLD501} and \cite{ISS/HAT/DAZ/USR501}.

\subsection{Introduction}


\section{THE LITERATE SCRIPTS}


\subsection{Setting up of the enivronment}

Set up flags so the compliance tool works correctly .

=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX

Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX

\subsection{Useful functions}

Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = get_descendants "cn" less "cn";
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
Functions for recording some statistics of theories.

=SML
type theory_stats = {np : int, ng : int, na : int, nd : int, nc : int};
local
    fun noof_parents thy = (length o get_parents) thy;
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
in
    fun get_theory_stats (thy : string) : theory_stats =
    let
        val np = noof_parents thy;
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
    in
        {np = np, ng = ng, na = na, nd = nd, nc = nc}
    end;
end;
=TEX

\pagebreak
\subsection{Enhancement 6: Pragmas}
\subsubsection{Pragma as Compilation Unit}
=SML
force_delete_theory"pragmas.1" handle Fail _ => ();
new_script{name = "pragmas.1", state = initial_cn_state};
¹CN
pragma system_name("MIX");
°
=TEX
\subsubsection{Pragma List inside Compilation Unit}
¹CN
pragma memory_size(4000);
pragma storage_unit(41);
package Constants
is
    bits_per_byte : constant INTEGER := 8;
    type BYTE is range 0 .. 255;
    type WORD is record sign : BOOLEAN; b1, b2, b3, b4, b5 : BYTE; end record;
    type INDEX is record sign : BOOLEAN; b1, b2 : BYTE; end record;
end Constants;
°
¹CN
with Constants;
pragma elaborate(Constants);
package Registers
is
    rA, rX : WORD;
    rI1, rI2, rI3, rI4, rI5, rI6, rJ : INDEX;
end Registers;
°
=TEX
\subsubsection{Pragma as Declaration}
¹CN
with Constants, Registers;
package Init
is
     procedure reset ;
     pragma inline(reset);
end Init;
°
=TEX
\subsubsection{Pragma as Statement}
¹CN
with Constants, Registers;
package body Init
is
     procedure reset
     is
     begin
         pragma list(off);
         rA := 0;
         rX := 0;
         rI1 := 0;
         rI2 := 0;
         rI3 := 0;
         rI4 := 0;
         rI5 := 0;
         rI6 := 0;
         rJ := 0;
         pragma list(on);
    end reset;
end Init;
°
=TEX
\subsubsection{Pragma in a Using Declaration}
=SML
open_theory"cn";
new_script{name="pragmas.2", state=initial_cn_state};
=TEX
¹Z
Ü fun 100 sum _, size _
°

¹ZAX
Ü	sum_ : bag ú ­ ú
÷üüüüüüüüüüü
Ü	sum û ý = 0 ±
Ü	(µ b : bag ú; n : ú · sum (b ‚ ûný) = sum b + n)
°
¹ZAX
Ü	size_: bag ú ­ ú
÷üüüüüüüüüüü
Ü	size û ý = 0 ±
Ü	(µ b : bag ú; n : ú · size (b ‚ ûný) = size b + 1)
°
¹CN
package PRC_IN_PCK_RFN is

	auxiliary B : bag ú;

	procedure MEAN (M : out INTEGER)
	„ M [B ½ û ý, M = sum B intdiv size (B)];

end PRC_IN_PCK_RFN;
°
ÿBag_Invüüüüüüüüüüüü
Ü	B : bag ú;
Ü	S, N : INTEGER
÷üüüüüü
Ü	S = sum B;
Ü	N = size B
ˆüüüüüüüüüüüüüüüü
¹CN
package body PRC_IN_PCK_RFN is

	using
         pragma list (on);
           S, N : INTEGER;
         pragma list(off);
        implement B by Bag_Inv;

	procedure MEAN (M : out INTEGER)
	„ M, S, N [N ½ 0, M = S intdiv N ± S = S‰0 ± N = N‰0]
	is
	begin
		M := S / N;
	end MEAN;

begin
	S := 0;

end PRC_IN_PCK_RFN;
°
=SML
output_spark_program{out_file="TST.RESULTS.1"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 20: Arbitrary Replacements}
=SML
force_delete_theory"arbitrary_replacements.1" handle Fail _ => ();
new_script{name = "arbitrary_replacements.1", state = initial_cn_state};
¹CN
 § compilation unit ¢ (1)
°
¹CN
 (1) !é-- This is some commentary
        -- for inclusion at the head of the output file
        -- note the second two lines have 8 leading spaces
		 	-- and this one starts tab-tab-space-tab
°
=IGN
print_spark_program();
(cn_recogniser("¹", "CN", [Lex.Text"(1) !\233-- This is some commentary        \10-- for inclusion at the head of the output file        \10-- note the second two lines have 8 leading spaces\10"], "°"));
¹CN
package  P is
    X:INTEGER;
private
 § private part ¢ (2)
end P;
°
¹CN
 (2) !étype T is access INTEGER;
°
¹CN
package  Q is
 § visible part ¢ (3)
end Q;
°
¹CN
 (3) !étype Q is access P.T;
°
¹CN
procedure R is
 § declaration ¢ (4)
begin null; end R;
°
¹CN
 (4) !étype U is access Q.Q;
°
¹CN
procedure S is
begin
 § statement ¢ (5)
end S;
°
¹CN
 (5) !é<<LABEL>>
°
¹CN
procedure T is
begin
 „  [true, false]    (6)
end T;
°
¹CN
 (6) !é goto label;
°
=SML
output_spark_program{out_file="TST.RESULTS.2"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 1: Annotations}
=SML
force_delete_theory"annotations.1" handle Fail _ => ();
new_script{name = "annotations.1", state = initial_cn_state};
=TEX
\subsubsection{Annotation as Declaration}
¹CN
procedure S is
    X: INTEGER;
    procedure T is
    --# hide T
    begin
        X := 2 * X;
    end T;
begin
    null;
end S;
°
\subsubsection{Annotation as Statement}
¹CN
package Q is
  A : INTEGER;
end Q;
package body Q is

begin
--# hide Q
	A := 0;
end Q;
°
\subsubsection{Annotation in Subprogram Body}
¹CN
procedure A is
    X: INTEGER;
    procedure B
    --# global X;
    --# derives X from X;
    is
    begin
        X := 2 * X;
    end B;
    function C return INTEGER
    --# global X;
    is
    begin
        return X;
    end C;
begin
    null;
end A;
°
=TEX
\subsubsection{Annotation in Package Specification}
¹CN
package PK
--# own B;
is
    B : INTEGER;
    function f (x : INTEGER) return INTEGER;
end PK;
°
\subsubsection{Annotation in Package Body}
¹CN
package body PK
--# own B;
is
    function f (x : INTEGER) return INTEGER
    is begin return x; end f;
end PK; 
°
\subsubsection{Annotation in Compilation Units}
¹CN
package PK1
is
    A : constant INTEGER := 8;
end PK1;
°
¹CN
with PK1;
--# inherit PK1;
package PK2
is
    B : constant INTEGER := A - 1;
end PK2;
°
\subsubsection{Annotation in Package Body Stub}
This is allowed in the grammar (to remove an SLRP conflict) but should
be rejected by the parser:
=SML
fun ann_in_pack_body_stub () =
¹CN
procedure PP is
package body PK
--# own B;
is separate;
begin null; end PP;
°
=SML
(ann_in_pack_body_stub(); false) handle Fail _ => true;
=TEX
=SML
output_spark_program{out_file="TST.RESULTS.3"};
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 5: Visibility Rules}
=SML
clean_up();
new_script{name = "visibility.1", state = initial_cn_state};
fun show_cn_thys () = (
	map (fn thy => (thy, get_parents thy)) (get_descendants "cn")
);
¹CN
package P1 is
 C1 : constant INTEGER := 1;
end P1;
°

¹CN
with P1;
package P2 is
 C2 : constant INTEGER := 1;
 function F2 (X : INTEGER) return INTEGER
  „ [F2(X) = X + 1];
end P2;
°
=SML
new_script{name = "visibility.2", state = get_cn_state()};
¹CN
package body P2 is
 function F2 (X : INTEGER) return INTEGER
   „ [F2(X) = X + 1]
 is  begin return X + P1.C1; end F2;
end P2;
°
=SML
print_z_document"-";
show_cn_thys();
set_pc"cn";
set_goal([], get_conjecture"-" "vcP2body_1");
a(REPEAT strip_tac);
val vcP2body_1_thm  = save_pop_thm"vcP2body_1_thm";
set_goal([], get_conjecture"-" "vcP2body_2");
a(REPEAT strip_tac);
val vcP2body_2_thm  = save_pop_thm"vcP2body_2_thm";
set_goal([], get_conjecture"-" "vcP2body_3");
a(rewrite_tac[z_get_specñP1oC1®] THEN REPEAT strip_tac);
val vcP2body_3_thm  = save_pop_thm"vcP2body_3_thm";
=TEX
=SML
clean_up();
new_script{name="visibility.3", state=initial_cn_state};

¹CN
package A is
    V : INTEGER;
end A;
°

¹CN
with A;
package B is
    procedure INIT
    „ AoV [AoV = 0];
end B;
°
¹CN
package body B is
    procedure INIT
    „ AoV [AoV = 0]
    is
    begin
        A.V := 0;
    end INIT;
end B;
°
¹CN
with A, B;
procedure C
„ AoV [AoV = 0]
is
begin
    B.INIT;
end C;
°
=SML
map (pc_rule1"cn"prove_rule[] o snd o snd) (get_conjectures"-");
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 7: With Clauses}
=SML
clean_up();
new_script{name = "with-clauses.1", state = initial_cn_state};
¹CN
package PACK1 is
 C : constant INTEGER := 10;
end PACK1;
°

¹CN
with PACK1;
package PACK2 is
 D : constant INTEGER := PACK1.C;
 procedure Q (X : out INTEGER)
  „ X [X = 20];
end PACK2;
°
¹CN
with PACK2;
procedure P (X : out INTEGER)
  „ X [X = PACK2oD + 10]
 is begin PACK2.Q(X); end P;
°
=SML
print_z_document"-";
show_cn_thys();
set_pc"cn";
set_goal([], get_conjecture"-" "vcP_1");
a(REPEAT strip_tac);
val vcP_1_thm  = save_pop_thm"vcP_1_thm";
set_goal([], get_conjecture"-" "vcP_2");
a(rewrite_tac(map z_get_spec[ñPACK2oD®, ñPACK1oC®]) THEN REPEAT strip_tac);
val vcP_2_thm  = save_pop_thm"vcP_2_thm";
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 10: Renaming}
\subsubsection{Renaming Operator Symbols}
=SML
(map force_delete_theory (get_descendants"cn" less "cn"); ()) handle Fail _ => ();
new_script{name = "renaming.1", state = initial_cn_state};
¹CN
package PACK is
    type INT is range 10 .. 20;
end PACK;
°
¹CN
with PACK;
procedure MAIN is
     function ">=" (left, right : PACK.INT) return BOOLEAN renames PACK.">=";
     I : PACK.INT;
begin
  „ I [I ¾ 15]
end MAIN;
°

¹CN
  Ã I := 16;
°
=SML
print_z_document"-";
show_cn_thys();
set_pc"cn";

set_goal([], get_conjecture"-" "vc_1_1");
a(REPEAT strip_tac);
val vc_1_1_thm  = save_pop_thm"vc_1_1_thm";
=SML
fun renaming_err() =
¹CN
with PACK;
procedure WRONG is
     function "<" (left, right : PACK.INT) return BOOLEAN renames PACK.">=";
     I : PACK.INT;
begin
  „ I [I ¾ 15]
end WRONG;
°
=SML
(renaming_err(); false) handle Fail _ => true;
=TEX
\subsubsection{Renaming Other Functions}
=SML
(map force_delete_theory (get_descendants"cn" less "cn"); ()) handle Fail _ => ();
new_script{name = "renaming.2", state = initial_cn_state};
¹CN
package PACK is
    function F (X : INTEGER) return INTEGER
      „ [F(X) = 5];
end PACK;
°
¹CN
with PACK;
procedure MAIN is 
    function F (X : INTEGER) return INTEGER renames PACK.F;
    Z : INTEGER;
begin
    „ Z [Z = 9]
end MAIN;
°
¹CN
  Ã Z := F(Z) + 4;
°

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-" "vc_1_1");
a(rewrite_tac(map z_get_spec[ñF®, ñPACKoF®]));
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac(map z_get_spec[ñPACKoF®]));
val vc_1_1_thm  = save_pop_thm"vc_1_1_thm";
=TEX
\subsubsection{Renaming Procedures}
=SML
(map force_delete_theory (get_descendants"cn" less "cn"); ()) handle Fail _ => ();
new_script{name = "renaming.3", state = initial_cn_state};
¹CN
package PACK is
    procedure P (X : out INTEGER)
      „ X [5 ¼ X < 6];
end PACK;
°
¹CN
with PACK;
procedure MAIN is 
    procedure P (X : out INTEGER) renames PACK.P;
    Z : INTEGER;
begin
    „ Z [Z = 9]
end MAIN;
°
¹CN
  Ã P(Z); Z:= 3*Z - 6;
°

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-" "vc_1_1");
a(REPEAT strip_tac);
val vc_1_1_thm  = save_pop_thm"vc_1_1_thm";

set_goal([], get_conjecture"-" "vc_1_2");
a(PC_T1 "z_lin_arith" prove_tac[]);
val vc_1_2_thm  = save_pop_thm"vc_1_2_thm";
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 17: Subtype Attributes}
=SML
force_delete_theory"subtype_attrs.1" handle Fail _ => ();
new_script{name = "subtype_attrs.1", state = initial_cn_state};
¹CN
procedure P is
    type INT is range 9 .. 67;
    subtype SUB is INT range 16 .. 50;
    X: SUB;
begin
    null;
end P;
°
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 13: Use Binding Displays}
=SML
force_delete_theory"binding_display.1" handle Fail _ => ();
new_script{name = "binding_display.1", state = initial_cn_state};
¹CN
procedure BD is
    type REC1 is record A, B : INTEGER; end record;
    type REC2 is record X, Y : INTEGER; Z : REC1; end record;
    type REC3 is record W, V : REC1; U : REC2; end record;
    v1 : constant REC1 := REC1'(B=>42, A=>99);
    v2 : constant REC1 := REC1'(42, 99);
    v3 : constant REC2 := REC2'(1,2, REC1'(3, 4));
    v4 : constant REC3 := REC3'(W=>v1, U=>v3, V=>v2);
begin
    null;
end BD;
°
=SML
print_z_document"-";
ñV1  REC1 ± V2  REC1 ± V3  REC2 ± V4  REC3®;
val bd_rule = pc_rule1"cn"prove_rule(map z_get_spec[ñV1®, ñV2®, ñV3®, ñV4®]);
bd_ruleñV4.U = V3®;
bd_ruleñV4.V = V2®;
bd_ruleñV4.W = V1®;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 14: Record Assignments}
=SML
force_delete_theory"record-assign.1" handle Fail _ => ();
new_script{name = "record-assign.1", state = initial_cn_state};
¹CN
procedure P is
    type DAY is (MON, TUE, WED);
    type REC is record X : INTEGER; D : DAY; end record;
    type ARR is array(DAY) of REC;
    A : ARR;
begin
 „ A [(A MON).D = TUE]
end P;
°
¹CN
 Ã A (MON).D := TUE;
°
=SML
print_z_document"-";
set_pc"z_library_ext";
set_goal([], ñ[X, Y](µf : X ­ Y; x:U; y : U·(f « {x í y})x = y)®);
a(REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 ñy®);
val z_«_lemma = pop_thm();
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(rewrite_tac[z_get_specñARR®] THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_«_lemma]);
val vc_1_1_thm = pop_thm();
=TEX
=SML
force_delete_theory"record-assign.2" handle Fail _ => ();
new_script{name = "record-assign.2", state = initial_cn_state};
¹CN
procedure BD is
    type REC1 is record A, B : INTEGER; end record;
    type REC2 is record X, Y : INTEGER; Z : REC1; end record;
    type REC3 is record W, V : REC1; U : REC2; end record;
    v1a : constant REC1 := REC1'(B=>42, A=>99);
    v1b : constant REC1 := REC1'(42, 99);
    v2 : constant REC2 := REC2'(1,2, REC1'(3, 4));
    v3 : constant REC3 := REC3'(W=>v1a, U=>v2, V=>v1b);
    a1 : REC1;
    a2 : REC2;
    a3 : REC3;
begin
    „ A1, A2, A3[
		A1 = (A¦42, B¦42) ±
		A2 = (X¦100, Y¦100, Z¦A1) ±
		A3 = (W¦A1, V¦V1A, U¦A2)
   ]
end BD;
°
¹CN
 Ã
    a1.A := v1a.B;
    a1.B := v1b.A;
    a2 := v2;
    a2.X := 100 * a2.X;
    a2.Y := 50 * a2.Y;
    a2.Z.A := 42;
    a2.Z.B := a2.Y - 58;
    a3.W.A := 42;
    a3.W.B := 42;
    a3.V.A := v1a.A;
    a3.V.B := a3.W.B;
    a3.U := a2;
°
=SML
fun term_complexity tm = (
	case dest_simple_term tm of
		Var _ => 1
	|	Const _ => 1
	|	App (tm1, tm2) => term_complexity tm1 + term_complexity tm2 + 1
	|	SimpleÌ(_, tm1) => term_complexity tm1 + 1
);
term_complexity (get_conjecture "-" "vc_1_1");
set_int_control("pp_format_depth", 8);
set_int_control("pp_top_level_depth", 8);
val def_thms = map z_get_spec(get_consts"-");
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT strip_tac THEN_TRY SOLVED_T (rewrite_tac def_thms));
val vc_1_1_thm = pop_thm();
set_int_control("pp_format_depth", ~1);
set_int_control("pp_top_level_depth", ~1);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Enhancement 15: And-then/Or-else}
=SML
force_delete_theory"and-then.1" handle Fail _ => ();
new_script{name = "and-then.1", state = initial_cn_state};
¹CN
procedure P
„ [true]
is
	v1 : constant BOOLEAN := 1 = 2 and 2 = 3;
	v2 : constant BOOLEAN := 1 = 2 or 2 = 3;
	w1 : constant BOOLEAN := 1 = 2 and then 2 = 3;
	w2 : constant BOOLEAN := 1 = 2 or else 2 = 3;
begin
 null;
end P;
°
=SML
print_z_document"-";
set_pc"z_library_ext";
set_goal([], ñ[X, Y](µf : X ­ Y; x:U; y : U·(f « {x í y})x = y)®);
=TEX
=IGN
print_z_document"-";
prove_rule[z_get_specñV1A®]ñV1A.A - V1A.B = 57 ±	 V1A.A + V1A.B = 141®;
a(rewrite_tac[z_get_specñV1A®]);
=TEX

\pagebreak

\end{document}

