% %Z% $Date$ $Revision$ $RCSfile$ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SPARK Output Tests}  %% Mandatory field
\def\TPPheadtitle{SPARK Output Tests}
\TPPref{ISS/HAT/DAZ/INT510}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{G.M.~Prout & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives Compliance Notation script which exercise the SPARK output function using an Ada compiler to check the results.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1] Initial Draft.
\end{description}

\subsection{Changes Forecast}
Tests to be added as time permits.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501} and \cite{ISS/HAT/DAZ/USR501}.

\subsection{Introduction}
This document gives Compliance Notation script which exercise the SPARK output function using an Ada compiler to check the results.


\section{THE LITERATE SCRIPTS}


\subsection{Setting up of the environment}


Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX

\section{WEB CLAUSES}\label{WEBCLAUSES}
=SML
clean_up();
new_script{name="int511A", state=initial_cn_state};
=TEX
We now work through the production for $web\_clause$.
The first alternative (a Z paragraph) is not relevant.
So we start with a compilation:

¹CN
 package int511PACK1 is
        X: INTEGER;
 end int511PACK1;
 § compilation unit k-slot ¢			( 1 )
°
Now a compilation replacement.
¹CN
 (1) é with int511PACK1;
  procedure int511PROC1
  is
  begin
       int511PACK1.X := 0;
  end int511PROC1;
°
Now prepare for private and visible part replacements:
¹CN
 package int511PACK2 is
   type priv_ty is private;
   C : constant INTEGER;
   § visible part k-slot ¢			( 2 )
 private
   § private part k-slot ¢			( 3 )
 end int511PACK2;
°
Private part replacement:
¹CN
 (3) é type priv_ty is range 1 .. 10;
        C : constant INTEGER := 99;
°
Visible part replacement:
¹CN
 (2) é X : INTEGER;
°
Now prepare for declaration and statement replacement and statement refinement:
¹CN
 procedure int511PROC2 is
	§ declaration k-slot ¢			( 4 )
 begin
   „ [false, true]  (5)
 end int511PROC2;
°
Statement refinement:
¹CN
 (5) Ã „ [true, true] (6)
°
Declaration replacement:
¹CN
 (4) é A : INTEGER;
°
Statement replacement (for a spec label):
¹CN
 (6) é A := 0;
      § statement k-slot ¢			( 7 )
°
Statement replacement (for a statement k-slot label):
¹CN
 (7) é null;
°
The implicit label mechanism is well-tested elsewhere, so we skip those alternatives.
=SML
output_spark_program{out_file="int511A.ada"};
=TEX
\section{Representation Clauses}
=SML
clean_up();
new_script{name="int511B", state=initial_cn_state};
=TEX
The example address clause in the following is commented out, because such clauses are necessarily implementation-dependent, and there seems to be little point in concocting something satisfactory for a particular compiler which is unlikely to work with another one.
¹CN
 procedure int511PROC3 is
   type COLOUR is (WHITE, RED, YELLOW, GREEN, BLUE, BROWN, BLACK);
   BYTE : CONSTANT INTEGER := 8;
   for COLOUR'SIZE use 1*BYTE;
   type MIX_CODE is (ADD, SUB, MUL, LDA, STA, STZ);
   for MIX_CODE use (ADD => 1, SUB => 2, MUL => 3, LDA => 4, STA => 5, STZ => 6);
   type MASK is range 0 .. 2**BYTE-1;
   type PSR is record STATUS : MASK; OVERFLOW : BOOLEAN; end record;
   for PSR use
       record at mod BYTE;
            STATUS at 0*BYTE range 0 .. BYTE - 1;
            OVERFLOW at 1*BYTE range BYTE - 1 .. BYTE - 1;
       end record;
   VAR : INTEGER;
--   for VAR use at 16#00000000#;    
 begin
   null;
 end int511PROC3;
°
=SML
output_spark_program{out_file="int511B.ada"};
=TEX
\section{STUBS AND SUBUNITS}
=SML
clean_up();
new_script{name="int511C", state=initial_cn_state};
=TEX
Procedure and function stubs:
¹CN
 procedure int511PROC4 is
    APPLE : constant INTEGER := 99;
    FRUIT : INTEGER;
    procedure int511PROC5 is separate;
    function int511FUNC1 (I : INTEGER) return INTEGER is separate;
 begin
    null;
 end int511PROC4;
°
=SML
val state_c1 = get_cn_state();
new_script{name="int511C1", state=state_c1};
¹CN
 separate (int511PROC4)
    procedure int511PROC5 is begin FRUIT := APPLE; end int511PROC5;
°
=SML
val state_c2 = get_cn_state();
new_script{name="int511C2", state=state_c2};
¹CN
 separate (int511PROC4)
    function int511FUNC1 (I : INTEGER) return INTEGER is
    begin return APPLE; end int511FUNC1;
°
output_spark_program{out_file="int511A.ada"};

=SML
=SML
val state_c3 = get_cn_state();
set_cn_state state_c1;
output_spark_program{out_file="int511C1.ada"};
set_cn_state state_c2;
output_spark_program{out_file="int511C2.ada"};
set_cn_state state_c3;
output_spark_program{out_file="int511C3.ada"};
=TEX
\section{COMPILATION UNITS}
=SML
clean_up();
new_script{name="int511D", state=initial_cn_state};
=TEX
Section \ref{WEBCLAUSES} has covered package specifications and main programs with simple context clauses already.
We just need to check pragmas:
¹CN
 package int511PACK3 is
        X: INTEGER;
 end int511PACK3;
°
¹CN
 with int511PACK3;
  pragma ELABORATE(int511PACK3);
  procedure int511PROC5
  is
  begin
       int511PACK3.X := 0;
  end int511PROC5;
°
=TEX
\section{PACKAGE IMPLEMENTATIONS}
=SML
clean_up();
new_script{name="int511E", state=initial_cn_state};
=TEX
¹Z
Ü fun 100 sum _, size _
°

¹ZAX
Ü	sum_ : bag ú ­ ú
÷üüüüüüüüüüü
Ü	sum û ı = 0 ±
Ü	(µ b : bag ú; n : ú · sum (b ‚ ûnı) = sum b + n)
°
¹ZAX
Ü	size_: bag ú ­ ú
÷üüüüüüüüüüü
Ü	size û ı = 0 ±
Ü	(µ b : bag ú; n : ú · size (b ‚ ûnı) = size b + 1)
°
¹CN
package int511PACK4 is

	auxiliary B : bag ú;

	procedure MEAN (M : out INTEGER)
	„ M [B ½ û ı, M = sum B intdiv size (B)];

end int511PACK4;
°
ÿBag_Invüüüüüüüüüüüü
Ü	B : bag ú;
Ü	S, N : INTEGER
÷üüüüüü
Ü	S = sum B;
Ü	N = size B
ˆüüüüüüüüüüüüüüüü
¹CN
package body int511PACK4 is

	using S, N : INTEGER; implement B by Bag_Inv;

	procedure MEAN (M : out INTEGER)
	„ M, S, N [N ½ 0, M = S intdiv N ± S = S‰0 ± N = N‰0]
	is
	begin
		M := S / N;
	end MEAN;

begin
	S := 0;

end int511PACK4;
°

=SML
output_spark_program{out_file="int511E.ada"};
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\end{document}

