% %Z% $Date$ $Revision$ $RCSfile$ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SPARK Output Tests}  %% Mandatory field
\def\TPPheadtitle{SPARK Output Tests}
\TPPref{ISS/HAT/DAZ/INT510}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{G.M.~Prout & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives Compliance Notation script which exercise the SPARK output function using an Ada compiler to check the results.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1-$Revision$%
] Initial Drafts.
\end{description}

\subsection{Changes Forecast}
Tests to be added as time permits.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501} and \cite{ISS/HAT/DAZ/USR501}.

\subsection{Introduction}
This document gives Compliance Notation script which exercise the SPARK output function using an Ada compiler to check the results.


\section{THE LITERATE SCRIPTS}


\subsection{Setting up of the environment}


Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX

\section{WEB CLAUSES}\label{WEBCLAUSES}
=SML
clean_up();
new_script{name="int511A", state=initial_cn_state};
=TEX
We now work through the production for $web\_clause$.
The first alternative (a Z paragraph) is not relevant.
So we start with a compilation:

¹CN
 package int511PACK1 is
        X: INTEGER;
 end int511PACK1;
 § compilation unit k-slot ¢			( 1 )
°
Now a compilation replacement.
¹CN
 (1) é with int511PACK1;
  procedure int511PROC1
  is
  begin
       int511PACK1.X := 0;
  end int511PROC1;
°
Now prepare for private and visible part replacements:
¹CN
 package int511PACK2 is
   type priv_ty is private;
   C : constant INTEGER;
   § visible part k-slot ¢			( 2 )
 private
   § private part k-slot ¢			( 3 )
 end int511PACK2;
°
Private part replacement:
¹CN
 (3) é type priv_ty is range 1 .. 10;
        C : constant INTEGER := 99;
°
Visible part replacement:
¹CN
 (2) é X : INTEGER;
°
Now prepare for declaration and statement replacement and statement refinement:
¹CN
 procedure int511PROC2 is
	§ declaration k-slot ¢			( 4 )
 begin
   „ [false, true]  (5)
 end int511PROC2;
°
Statement refinement:
¹CN
 (5) Ã „ [true, true] (6)
°
Declaration replacement:
¹CN
 (4) é A : INTEGER;
°
Statement replacement (for a spec label):
¹CN
 (6) é A := 0;
      § statement k-slot ¢			( 7 )
°
Statement replacement (for a statement k-slot label):
¹CN
 (7) é null;
°
The implicit label mechanism is well-tested elsewhere, so we skip those alternatives.
=SML
output_spark_program{out_file="int511A.ada"};
=TEX
\section{REPRESENTATION CLAUSES}
=SML
clean_up();
new_script{name="int511B", state=initial_cn_state};
=TEX
The example address clause in the following is commented out, because such clauses are necessarily implementation-dependent, and there seems to be little point in concocting something satisfactory for a particular compiler which is unlikely to work with another one.
¹CN
 procedure int511PROC3 is
   type COLOUR is (WHITE, RED, YELLOW, GREEN, BLUE, BROWN, BLACK);
   BYTE : CONSTANT INTEGER := 8;
   for COLOUR'SIZE use 1*BYTE;
   type MIX_CODE is (ADD, SUB, MUL, LDA, STA, STZ);
   for MIX_CODE use (ADD => 1, SUB => 2, MUL => 3, LDA => 4, STA => 5, STZ => 6);
   type MASK is range 0 .. 2**BYTE-1;
   type PSR is record STATUS : MASK; OVERFLOW : BOOLEAN; end record;
   for PSR use
       record at mod BYTE;
            STATUS at 0*BYTE range 0 .. BYTE - 1;
            OVERFLOW at 1*BYTE range BYTE - 1 .. BYTE - 1;
       end record;
   VAR : INTEGER;
--   for VAR use at 16#00000000#;    
 begin
   null;
 end int511PROC3;
°
=SML
output_spark_program{out_file="int511B.ada"};
=TEX
\section{STUBS AND SUBUNITS}
=SML
clean_up();
new_script{name="int511C", state=initial_cn_state};
=TEX
Procedure and function stubs:
¹CN
 procedure int511PROC4 is
    APPLE : constant INTEGER := 99;
    FRUIT : INTEGER;
    procedure int511PROC5 is separate;
    function int511FUNC1 (I : INTEGER) return INTEGER is separate;
 begin
    null;
 end int511PROC4;
°
=SML
val state_c1 = get_cn_state();
new_script{name="int511C1", state=state_c1};
¹CN
 separate (int511PROC4)
    procedure int511PROC5 is begin FRUIT := APPLE; end int511PROC5;
°
=SML
val state_c2 = get_cn_state();
new_script{name="int511C2", state=state_c2};
¹CN
 separate (int511PROC4)
    function int511FUNC1 (I : INTEGER) return INTEGER is
    begin return APPLE; end int511FUNC1;
°
output_spark_program{out_file="int511A.ada"};

=SML
=SML
val state_c3 = get_cn_state();
set_cn_state state_c1;
output_spark_program{out_file="int511C1.ada"};
set_cn_state state_c2;
output_spark_program{out_file="int511C2.ada"};
set_cn_state state_c3;
output_spark_program{out_file="int511C3.ada"};
=TEX
\section{COMPILATION UNITS}
=SML
clean_up();
new_script{name="int511D", state=initial_cn_state};
=TEX
Section \ref{WEBCLAUSES} has covered package specifications and main programs with simple context clauses already.
We just need to check pragmas:
¹CN
 package int511PACK3 is
        X: INTEGER;
 end int511PACK3;
°
¹CN
 with int511PACK3;
  pragma ELABORATE(int511PACK3);
  procedure int511PROC5
  is
  begin
       int511PACK3.X := 0;
  end int511PROC5;
°
=TEX
\section{PACKAGE IMPLEMENTATIONS}
=SML
clean_up();
new_script{name="int511E", state=initial_cn_state};
=TEX
¹Z
Ü fun 100 sum _, size _
°

¹ZAX
Ü	sum_ : bag ú ­ ú
÷üüüüüüüüüüü
Ü	sum û ý = 0 ±
Ü	(µ b : bag ú; n : ú · sum (b ‚ ûný) = sum b + n)
°
¹ZAX
Ü	size_: bag ú ­ ú
÷üüüüüüüüüüü
Ü	size û ý = 0 ±
Ü	(µ b : bag ú; n : ú · size (b ‚ ûný) = size b + 1)
°
¹CN
package int511PACK4 is

	auxiliary B : bag ú;

	procedure MEAN (M : out INTEGER)
	„ M [B ½ û ý, M = sum B intdiv size (B)];

end int511PACK4;
°
ÿBag_Invüüüüüüüüüüüü
Ü	B : bag ú;
Ü	S, N : INTEGER
÷üüüüüü
Ü	S = sum B;
Ü	N = size B
ˆüüüüüüüüüüüüüüüü
¹CN
package body int511PACK4 is

	using S, N : INTEGER; implement B by Bag_Inv;

	procedure MEAN (M : out INTEGER)
	„ M, S, N [N ½ 0, M = S intdiv N ± S = S‰0 ± N = N‰0]
	is
	begin
		M := S / N;
	end MEAN;

begin
	S := 0;

end int511PACK4;
°

=SML
output_spark_program{out_file="int511E.ada"};
=TEX
\section{SUBPROGRAM DECLARATIONS}
=SML
clean_up();
new_script{name="int511F", state=initial_cn_state};
=TEX
¹CN
 package int511PACK5 is
   procedure no_pars „[true];
   procedure one_par (X: in out INTEGER)
    „X[X > X‰0];
   procedure three_pars (X, Y, Z: in out INTEGER)
    „X, Y, Z[X+Y+Z > X‰0];
   procedure four_pars (X: in out INTEGER; A, B, C: in INTEGER)
    „X[X > A+B+C];
   function fno_pars return INTEGER;
   function six_pars
        (X, Y : INTEGER; A, B : INTEGER; C, D  : INTEGER) return BOOLEAN
    „[SIX_PARS(X, Y, A, B, C, D) = TRUE ¤ X > Y ² A > B ² C > D] ;
 end int511PACK5;
°
¹CN
 package body int511PACK5 is
   procedure no_pars „[true]
   is begin null ; end no_pars;
   procedure one_par (X: in out INTEGER)
    „X[X > X‰0]
   is begin X := X + 1; end one_par;
   procedure three_pars (X, Y, Z: in out INTEGER)
    „X, Y, Z[X+Y+Z > X‰0]
   is begin X := (X - Y - Z) + 1; end three_pars;
   procedure four_pars (X: in out INTEGER; A, B, C: in INTEGER)
    „X[X > A+B+C]
   is begin X := A + B + C + 1; end four_pars;
   function fno_pars return INTEGER
   is begin return 42 ; end fno_pars;
   function six_pars
        (X, Y : INTEGER; A, B : INTEGER; C, D  : INTEGER) return BOOLEAN
    „[SIX_PARS(X, Y, A, B, C, D) = TRUE ¤ X > Y ² A > B ² C > D]
   is begin return X > Y or A > B or C > D; end six_pars;
 end int511PACK5;
°
=SML
output_spark_program{out_file="int511F.ada"};
=TEX
=TEX
\section{STATEMENTS}
Statement k-slots have already been covered.

Assignments and if-then-else:
=SML
clean_up();
new_script{name="int511G1", state=initial_cn_state};
¹CN
 procedure int511PROC6(X, Y : in out INTEGER)
 is
    type IND is range 1 .. 2;
    type ARR is array(IND) of INTEGER;
    type REC is record X, Y : INTEGER; end record;
    A : ARR;
    R : REC;
 begin
    null;
    X := Y;
    if (X > 9)
    then X := 9;
    else Y := 42;
    end if;
    if X > Y
    then X := 42;
    elsif X < Y
    then Y := 9;
    end if;
    A(1) := X;
    A(2) := Y;
    R.X := X;
    R.Y := Y;
 end int511PROC6;
°

=SML
output_spark_program{out_file="int511G1.ada"};
=TEX
Case statement:
=SML
clean_up();
new_script{name="int511G2", state=initial_cn_state};
¹CN
 procedure int511PROC7
 is
    type INT8 is range 1 .. 8;
    type ABC is (AA, BB, CC);
    type Z is (M);
    I : INT8;
    A : ABC;
    V : Z;
 begin
    V := M;
    case V is
       when M => A := AA;
    end case;
    case A is
       when AA => I := 1;
       when BB | CC => I := 2;
    end case;
    case I is
       when 1 .. 4 | 5 | 6 | 8 => V := M;
       when others => A := BB;
    end case;
 end int511PROC7;
°
=SML
output_spark_program{out_file="int511G2.ada"};
=TEX
Loop, exit and return statements:
=SML
clean_up();
new_script{name="int511G3", state=initial_cn_state};
¹CN
 function int511PROC8 return INTEGER
 is
    type INT8 is range 1 .. 8;
    X : INTEGER;
 begin
E1: loop
        exit when 1 = 1;
    end loop E1;
    till û true ý
    loop
        if true
        then exit;
        end if;
    end loop;
W1: while false
    loop
        null;
    end loop W1;
    while false
    loop
        null;
    end loop;
L1: for I in INT8
    loop
        X := INTEGER(I);
    end loop L1;
    for I in INT8
    loop
        X := INTEGER(I);
    end loop;
    for I in reverse INT8
    loop
        X := INTEGER(I);
    end loop;
    for I in INTEGER range 1 .. 10
    loop
        X := INTEGER(I);
    end loop;
    for I in reverse INTEGER range 1 .. 10
    loop
        X := INTEGER(I);
    end loop;
    return 999;
 end int511PROC8;
°
=SML
output_spark_program{out_file="int511G3.ada"};
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\end{document}

