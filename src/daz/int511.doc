% %Z% $Revision: 1.14 $ $RCSfile: int511.doc,v $ $Date: 2000/09/07 14:15:59 $ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SPARK Output Tests}  %% Mandatory field
\def\TPPheadtitle{SPARK Output Tests}
\TPPref{ISS/HAT/DAZ/INT510}  %% Mandatory field
\def\SCCSversion{$Revision: 1.14 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/09/07 14:15:59 $%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{G.M.~Prout & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives Compliance Notation script which exercise the SPARK output function using an Ada compiler to check the results.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1-1.5] Initial Drafts.
\item[Issue 1.6] First issue for system build.
\item[Issue 1.7] IUCT WP7 changes, and one compilation unit per script.
\item[Issue 1.8] IUCT WP 2 changes.
\item[Issues 1.9-1.10] Typos corrected.
\item[Issues 1.11] IUCT WP 4 syntax change.
\item[Issue 1.12] Addressing changes in gcc version, and timing problems.
\item[Issue 1.13] Tidied and restructured interface to gnat.
\item[Issue 1.14] Allowed for bizarre behaviour of {\tt which} on Solaris.
\item[Issue 1.15] CTLE II R2/1: global variable unsoundness.
\end{description}

\subsection{Changes Forecast}
Tests to be added as time permits.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501} and \cite{ISS/HAT/DAZ/USR501}.

\subsection{Introduction}
This document gives Compliance Notation scripts which exercise the SPARK output function using an Ada compiler to check the results.

At the end of the document is some {\tt sh} and ML code which together compiles the generated SPARK using the {\tt gnat} compiler and then reports on any failures using the usual module test mechanisms.
There is no automatic check that the right SPARK has been generated, only that what has been generated is legal Ada.

\subsection{Test Cases}

The test cases are grouped according to a top-down analysis of the Compliance Notation grammar.
In terms of the order the grammar is presented in in \cite{DRA/CIS/CSE3/TR/94/27/2.1}, this means working from back to front for the main groups, and then (generally) from front to back within each group.
The groups are as follows:

\begin{tabular}{l}
WEB CLAUSES\\
REPRESENTATION CLAUSES\\
STUBS AND SUBUNITS\\
COMPILATION UNITS\\
PACKAGE IMPLEMENTATIONS\\
SUBPROGRAM DECLARATIONS\\
STATEMENTS\\
EXPRESSIONS\\
BODIES AND STUBS\\
BASIC DECLARATIONS\\
PRAGMAS\\
\end{tabular}

\subsection{Setting up of the environment}


Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX
Function to run a shell command line.
=SML
fun system (cmd : string) : unit = 
let	val (s1, s2) = ExtendedIO.execute cmd;
	val buf :string ref = ref "";
in	while (buf := ExtendedIO.input_line s1; !buf <> "")
       do  BasicIO.output(std_out, !buf);
	close_in s1;
	close_out s2
end;
=TEX
\section{WEB CLAUSES}\label{WEBCLAUSES}
=SML
clean_up();
new_script{name="int511A1", state=initial_cn_state};
=TEX
We now work through the production for $web\_clause$.
The first alternative (a Z paragraph) is not relevant.
So we start with a compilation:

¹CN
 package int511PACK1 is
        X: INTEGER;
 end int511PACK1;
°
=SML
set_string_control("case_of_spark_keywords", "upper");
output_spark_program{out_file="int511A1a.ada"};
val stateA1 = get_cn_state();
new_script{name="int511A1a", state=stateA1};

¹Z
Ü [ A_GIVEN_SET ]
°

=TEX
Now a compilation replacement.
¹CN
 § compilation unit k-slot ¢			( 1 )
°
Now a compilation replacement.
¹CN
 (1) é with int511PACK1;
  procedure int511PROC1
  is
  begin
       int511PACK1.X := 0;
  end int511PROC1;
°
Now prepare for private and visible part replacements:
=SML
output_spark_program{out_file="int511A1b.ada"};
system"cat int511A1a.ada int511A1b.ada > int511A1.ada ; rm -f int511A1a.ada int511A1b.ada";
val int511A1state = get_cn_state();
new_script{name="int511A2", state= int511A1state};
¹CN
 package int511PACK2 is
   type priv_ty is private;
   C : constant INTEGER;
   § visible part k-slot ¢			( 2 )
 private
   § private part k-slot ¢			( 3 )
 end int511PACK2;
°
Private part replacement:
¹CN
 (3) é type priv_ty is range 1 .. 10;
        C : constant INTEGER := 99;
°
Visible part replacement:
¹CN
 (2) é X : INTEGER;
°
Now prepare for declaration and statement replacement and statement refinement:
=SML
output_spark_program{out_file="int511A2.ada"};
val int511A2state = get_cn_state();
new_script{name="int511A3", state= int511A2state};
=TEX
¹CN
 procedure int511PROC2 is
	§ declaration k-slot ¢			( 4 )
 begin
   „ [false, true]  (5)
 end int511PROC2;
°
Statement refinement:
¹CN
 (5) Ã „ [true, true] (6)
°
Declaration replacement:
¹CN
 (4) é A : INTEGER;
°
Statement replacement (for a spec label):
¹CN
 (6) é A := 0;
      § statement k-slot ¢			( 7 )
°
Statement replacement (for a statement k-slot label):
¹CN
 (7) é null;
°
The implicit label mechanism is well-tested elsewhere, so we skip those alternatives.
=SML
output_spark_program{out_file="int511A3.ada"};
system"cat int511A1.ada int511A2.ada int511A3.ada > int511A.ada ; rm -f int511A1.ada int511A2.ada int511A3.ada";
=TEX
\section{REPRESENTATION CLAUSES}
=SML
clean_up();
new_script{name="int511B", state=initial_cn_state};
=TEX
The example address clause in the following is commented out, because such clauses are necessarily implementation-dependent, and there seems to be little point in concocting something satisfactory for a particular compiler which is unlikely to work with another one.
¹CN
 procedure int511PROC3 is
   type COLOUR is (WHITE, RED, YELLOW, GREEN, BLUE, BROWN, BLACK);
   BYTE : CONSTANT INTEGER := 8;
   for COLOUR'SIZE use 1*BYTE;
   type MIX_CODE is (ADD, SUB, MUL, LDA, STA, STZ);
   for MIX_CODE use (ADD => 1, SUB => 2, MUL => 3, LDA => 4, STA => 5, STZ => 6);
   type MASK is range 0 .. 2**BYTE-1;
   type PSR is record STATUS : MASK; OVERFLOW : BOOLEAN; end record;
   for PSR use
       record at mod BYTE;
            STATUS at 0*BYTE range 0 .. BYTE - 1;
            OVERFLOW at 1*BYTE range BYTE - 1 .. BYTE - 1;
       end record;
   VAR : INTEGER := 0;
--   for VAR use at 16#00000000#;    
 begin
   null;
 end int511PROC3;
°
=SML
set_string_control("case_of_spark_keywords", "as input");
output_spark_program{out_file="int511B.ada"};
=TEX
\section{STUBS AND SUBUNITS}
=SML
clean_up();
new_script{name="int511C", state=initial_cn_state};
=TEX
Procedure and function stubs:
¹CN
 procedure int511PROC4 is
    APPLE : constant INTEGER := 99;
    FRUIT : INTEGER := 0;
    procedure int511PROC5 is separate;
    function int511FUNC1 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    int511PROC5;
 end int511PROC4;
°
=SML
val state_c1 = get_cn_state();
new_script{name="int511C1", state=state_c1};
¹CN
 separate (int511PROC4)
    procedure int511PROC5 is begin FRUIT := APPLE; end int511PROC5;
°
=SML
val state_c2 = get_cn_state();
new_script{name="int511C2", state=state_c2};
¹CN
 separate (int511PROC4)
    function int511FUNC1 (I : INTEGER) return INTEGER is
    begin return APPLE; end int511FUNC1;
°
=SML
val state_c3 = get_cn_state();
set_cn_state state_c1;
output_spark_program{out_file="int511C1.ada"};
set_cn_state state_c2;
output_spark_program{out_file="int511C2.ada"};
set_cn_state state_c3;
output_spark_program{out_file="int511C3.ada"};
system"cat int511C1.ada int511C2.ada int511C3.ada > int511C.ada ; rm -f int511C1.ada int511C2.ada int511C3.ada";
=TEX
\section{COMPILATION UNITS}
=SML
clean_up();
new_script{name="int511D1", state=initial_cn_state};
=TEX
Section \ref{WEBCLAUSES} has covered package specifications and main programs with simple context clauses already.
We just need to check pragmas:
¹CN
 package int511PACK3 is
        X: INTEGER;
 end int511PACK3;
°
=SML
output_spark_program{out_file="int511D1.ada"};
val int511D1state = get_cn_state();
new_script{name="int511D2", state=int511D1state};
¹CN
 with int511PACK3;
  pragma ELABORATE(int511PACK3);
  procedure int511PROC5
  is
  begin
       int511PACK3.X := 0;
  end int511PROC5;
°
=SML
output_spark_program{out_file="int511D2.ada"};
system"cat int511D1.ada int511D2.ada > int511D.ada ; rm -f int511D1.ada int511D2.ada";
=TEX
\section{PACKAGE IMPLEMENTATIONS}
=SML
clean_up();
new_script{name="int511E1", state=initial_cn_state};
=TEX
¹Z
Ü fun 100 sum _, size _
°

¹ZAX
Ü	sum_ : bag ú ­ ú
÷üüüüüüüüüüü
Ü	sum û ı = 0 ±
Ü	(µ b : bag ú; n : ú · sum (b ‚ ûnı) = sum b + n)
°
¹ZAX
Ü	size_: bag ú ­ ú
÷üüüüüüüüüüü
Ü	size û ı = 0 ±
Ü	(µ b : bag ú; n : ú · size (b ‚ ûnı) = size b + 1)
°
¹CN
package int511PACK4 is

	auxiliary B : bag ú;

	procedure MEAN (M : out INTEGER)
	„ M ˜ B [B ½ û ı, M = sum B intdiv size (B)];

end int511PACK4;
°
=SML
output_spark_program{out_file="int511E1.ada"};
val int511E1state = get_cn_state();
new_script1{name="int511E2", state=int511E1state, library_theories = ["int511E1"]};
ÿBag_Invüüüüüüüüüüüü
Ü	B : bag ú;
Ü	S, N : INTEGER
÷üüüüüü
Ü	S = sum B;
Ü	N = size B
ˆüüüüüüüüüüüüüüüü
¹CN
package body int511PACK4 is

	using S, N : INTEGER; implement B by Bag_Inv;

	procedure MEAN (M : out INTEGER)
	„ M, S, N [N ½ 0, M = S intdiv N ± S = S‰0 ± N = N‰0]
	is
	begin
		M := S / N;
	end MEAN;

begin
	S := 0;
	N := 1;
end int511PACK4;
°

=SML
output_spark_program{out_file="int511E2.ada"};
system"cat int511E1.ada int511E2.ada > int511E.ada ; rm -f int511E1.ada int511E2.ada";
=TEX
\section{SUBPROGRAM DECLARATIONS}
=SML
clean_up();
new_script{name="int511F1", state=initial_cn_state};
=TEX
¹CN
 package int511PACK5 is
   procedure no_pars „[true];
   procedure one_par (X: in out INTEGER)
    „X[X > X‰0];
   procedure three_pars (X, Y, Z: in out INTEGER)
    „X, Y, Z[X+Y+Z > X‰0];
   procedure four_pars (X: in out INTEGER; A, B, C: in INTEGER)
    „X[X > A+B+C];
   function fno_pars return INTEGER;
   function six_pars
        (X, Y : INTEGER; A, B : INTEGER; C, D  : INTEGER) return BOOLEAN
    ˜[SIX_PARS(X, Y, A, B, C, D) = TRUE ¤ X > Y ² A > B ² C > D] ;
 end int511PACK5;
°
=SML
output_spark_program{out_file="int511F1.ada"};
val int511F1state = get_cn_state();
new_script{name="int511F2", state=int511F1state};
¹CN
 package body int511PACK5 is
   procedure no_pars „[true]
   is begin null ; end no_pars;
   procedure one_par (X: in out INTEGER)
    „X[X > X‰0]
   is begin X := X + 1; end one_par;
   procedure three_pars (X, Y, Z: in out INTEGER)
    „X, Y, Z[X+Y+Z > X‰0]
   is begin X := (X - Y - Z) + 1; end three_pars;
   procedure four_pars (X: in out INTEGER; A, B, C: in INTEGER)
    „X[X > A+B+C]
   is begin X := A + B + C + 1; end four_pars;
   function fno_pars return INTEGER
   is begin return 42 ; end fno_pars;
   function six_pars
        (X, Y : INTEGER; A, B : INTEGER; C, D  : INTEGER) return BOOLEAN
    ˜[SIX_PARS(X, Y, A, B, C, D) = TRUE ¤ X > Y ² A > B ² C > D]
   is begin return X > Y or A > B or C > D; end six_pars;
 end int511PACK5;
°
=SML
output_spark_program{out_file="int511F2.ada"};
system"cat int511F1.ada int511F2.ada > int511F.ada ; rm -f int511F1.ada int511F2.ada";
=TEX
\section{STATEMENTS}
Statement k-slots have already been covered.

Assignments, if-then-else and procedure call:
=SML
clean_up();
new_script{name="int511G1", state=initial_cn_state};
¹CN
 procedure int511PROC6(X, Y : in out INTEGER)
 is
    type IND is range 1 .. 2;
    type ARR is array(IND) of INTEGER;
    type REC is record X, Y : INTEGER; end record;
    A : ARR;
    R : REC;
    procedure P (Z : INTEGER) is
    begin
        A(1) := Y;
    end P;
    procedure Q (Z, T : INTEGER) is
    begin
        A(2) := Z + T;
    end Q;
 begin
    null;
    X := Y;
    if (X > 9)
    then X := 9;
    else Y := 42;
    end if;
    if X > Y
    then X := 42;
    elsif X < Y
    then Y := 9;
    end if;
    P(Z => X);
    Q(X, Y);
    R.X := X;
    R.Y := Y;
 end int511PROC6;
°

=SML
output_spark_program{out_file="int511G1.ada"};
=TEX
Case statement:
=SML
clean_up();
new_script{name="int511G2", state=initial_cn_state};
¹CN
 procedure int511PROC7
 is
    type INT8 is range 1 .. 8;
    type ABC is (AA, BB, CC);
    type Z is (M);
    I : INT8;
    A : ABC;
    V : Z;
 begin
    V := M;
    case V is
       when M => A := AA;
    end case;
    case A is
       when AA => I := 1;
       when BB | CC => I := 2;
    end case;
    case I is
       when 1 .. 4 | 5 | 6 | 8 => V := M;
       when others => A := BB;
    end case;
 end int511PROC7;
°
=SML
output_spark_program{out_file="int511G2.ada"};
=TEX
Loop, exit and return statements:
=SML
clean_up();
new_script{name="int511G3", state=initial_cn_state};
¹CN
 function int511FUNC8 return INTEGER
 is
    type INT8 is range 1 .. 8;
    X : INTEGER;
 begin
E1: loop
        exit when 1 = 1;
    end loop E1;
    till û true ı
    loop
        if true
        then exit;
        end if;
    end loop;
W1: while false
    loop
        null;
    end loop W1;
    while false
    loop
        null;
    end loop;
L1: for I in INT8
    loop
        X := INTEGER(I);
    end loop L1;
    for I in INT8
    loop
        X := INTEGER(I);
    end loop;
    for I in reverse INT8
    loop
        X := INTEGER(I);
    end loop;
    for I in INTEGER range 1 .. 10
    loop
        X := INTEGER(I);
    end loop;
    for I in reverse INTEGER range 1 .. 10
    loop
        X := INTEGER(I);
    end loop;
    return 999;
 end int511FUNC8;
°
=SML
output_spark_program{out_file="int511G3.ada"};
system"cat int511G1.ada int511G2.ada int511G3.ada > int511G.ada ; rm -f int511G1.ada int511G2.ada int511G3.ada ";
=TEX
\section{EXPRESSIONS}
Auxiliary expressions have already been done in the data refinement example above.

Primaries, type conversions and qualified expressions:
=SML
clean_up();
new_script{name="int511H1", state=initial_cn_state};
¹CN
 procedure int511PROC9(A, B, C : in out INTEGER; Y : out NATURAL;
                U, V : in out STRING)
 is
    D : CHARACTER;
    function f (X : INTEGER) return INTEGER
    is
    begin
       return X * 99;
    end f;
    type IND is range 1 ..3;
    type ARR is ARRAY(IND, IND) of INTEGER;
    W : ARR;
 begin
     C := 42 + A;
     D := ' ';
     U := "ABC";
     A := B;
     B := f(C);
     Y := NATURAL(C);
     C := INTEGER'(NATURAL'FIRST);
     B := (B + C);
     W := ARR'((1,2,3), (3,4,5), (6,7,8));
 end int511PROC9;
°
=SML
output_spark_program{out_file="int511H1.ada"};
=TEX
Simple expressions
=SML
clean_up();
new_script{name="int511H2", state=initial_cn_state};
¹CN
 procedure int511PROC10(A, B, C : in out INTEGER; Y : out BOOLEAN)
 is
	X : BOOLEAN;
 begin
    X := A = B or B /= C or A < C or A <= C or A > C or A >= B;
    Y := A in 1 .. 20 or B not in 1 .. 20 or
             (A in NATURAL and C not in NATURAL);
 end int511PROC10;
°
=SML
output_spark_program{out_file="int511H2.ada"};
=TEX
Relational expressions:
=SML
clean_up();
new_script{name="int511H3", state=initial_cn_state};
¹CN
 procedure int511PROC11(A, B, C : in out INTEGER; Y : out BOOLEAN)
 is
	X : BOOLEAN;
 begin
    X := A = B or B /= C or A < C or A <= C or A > C or A >= B;
    Y := A in 1 .. 20 or B not in 1 .. 20 or
             (A in NATURAL and C not in NATURAL);
 end int511PROC11;
°
=SML
output_spark_program{out_file="int511H3.ada"};
=TEX
Logical expressions:
=SML
clean_up();
new_script{name="int511H4", state=initial_cn_state};
¹CN
 procedure int511PROC12(A, B, C : in out BOOLEAN)
 is
	X : BOOLEAN;
 begin
    X := A and B;
    A := X and then B;
    B := X or B;
    X := A or else B;
    A := A xor B;
    A := ((A and B) or C) and (B xor A);
 end int511PROC12;
°
=SML
output_spark_program{out_file="int511H4.ada"};
=TEX
Names and aggregates:
=SML
clean_up();
new_script{name="int511H51", state=initial_cn_state};
¹CN
package int511PACK6 is
     EMERGENCY : constant INTEGER := 999;
     function F (X : INTEGER) return INTEGER;
end int511PACK6;
°
=SML
output_spark_program{out_file="int511H51.ada"};
val int511H51state = get_cn_state();
new_script{name="int511H52", state=int511H51state};

¹CN
with int511PACK6;
procedure int511PROC13
 is
    type IND2 is range 1 .. 2;
    type IND3 is range 2 .. 4;
    type PAIR is ARRAY(IND2) of NATURAL;
    type PAIR3 is ARRAY(IND3) of PAIR;
    P : PAIR;
    P3 : PAIR3;
    type GAUSS_QUAT is record RE, IMI, IMJ, IMK : INTEGER; end record;
    GQ : GAUSS_QUAT;
    function g(X : INTEGER) return GAUSS_QUAT
    is begin return GAUSS_QUAT'(X, X, X, X);
    end g;
 begin
    P := PAIR'(45, 46);
    P3 := PAIR3'(P, P, P);
    P := PAIR'(others => 9);
    P3 := PAIR3'(P, others => PAIR'(99, 100));
    P := PAIR'(8, others => 9);
    P3 := PAIR3'(2 | 4 => P, 3 => PAIR'(1, 2));
    P3 := PAIR3'(2 .. 3 => P, 4..4 => PAIR'(1, 2));
    GQ := GAUSS_QUAT'(1,2,3,4);
    GQ := GAUSS_QUAT'(RE | IMJ => 1, others => 2);
    GQ := GAUSS_QUAT'(RE | IMJ => 4, IMI | IMK => 3);
    GQ := GAUSS_QUAT'(others => 0);
    GQ.RE := P3(2)(2);
    P(1) := GQ.IMI;
    P(2) := g(42).IMI;
    P3(2)(2) := int511PACK6.F(int511PACK6.EMERGENCY);
 end int511PROC13;
°
=SML
output_spark_program{out_file="int511H52.ada"};
system"cat int511H51.ada int511H52.ada > int511H5.ada ; rm -f int511H51.ada int511H52.ada";
system"cat int511H1.ada int511H2.ada int511H3.ada int511H4.ada int511H5.ada > int511G.ada";
system "rm -f int511H1.ada int511H2.ada int511H3.ada int511H4.ada int511H5.ada";
=TEX
\section{BODIES AND STUBS}
Already covered.
\section{BASIC DECLARATIONS}

Only type definitions and constant declarations with more than one constant have not been fully covered above.

Type definitions:
=SML
clean_up();
new_script{name="int511I", state=initial_cn_state};
¹CN
package int511PACK7 is
   type FRUIT is (APPLE, BANANA, CHERRY, DATE, ELDERBERRY, FIG);
   BRAMLEY, COX, GRANNY_SMITH : constant FRUIT := APPLE;
   type HAPAX is (IT);
   type SIGN is range -1 .. 1;
   type TRIAD is array (SIGN) of FRUIT;
--# --   Following disallowed by gnat:
--# --   type SIGN2 is range TRIAD'RANGE;
   type HUNDREDTHS is digits 2;
   type PERCENT is digits 4 range 0.0 .. 99.99;
--# --   Following disallowed by with gnat:
--# --   type FIXHUNDREDTHS is delta 0.1;
   type FIXPERCENT is delta 0.01 range 0.0 .. 99.99;
   subtype ST1 is HUNDREDTHS range 1.0 .. 2.0;
   subtype ST2 is HUNDREDTHS digits 1 range 1.1 .. 1.7;
   subtype ST3 is FIXPERCENT delta 0.5 range 1.1 .. 2.2;
   type TRI_TRIAD is array(SIGN) of TRIAD;
   type SQUARE is array(SIGN, SIGN) of FRUIT;
   type CUBE is array(SIGN, SIGN, SIGN) of FRUIT;
   subtype N4 is NATURAL range 1 .. 4;
   type UNCON1 is array(N4 range <>) of FRUIT;
   type UNCON2 is array(N4 range <>, N4 range <>) of FRUIT;
   type UNCON3 is array(N4 range <>, N4 range <>, N4 range <>) of FRUIT;
   subtype N2 is N4 range 2 .. 3;
   subtype CON1 is UNCON1(N2);
   subtype CON2 is UNCON2(N2, N2);
   subtype CON3 is UNCON3(N2, N2, N2);
   type REC1 is record INDICATOR : SIGN; end record;
   type REC4 is record I1, I2, I3 : SIGN; F1, F2, F3, F4 : FRUIT; end record;
end int511PACK7;
°
=SML
set_string_control("case_of_spark_keywords", "lower");
output_spark_program{out_file="int511I.ada"};
=TEX
\section{PRAGMAS}

Only type definitions and constant declarations with more than one constant have not been fully covered above.

Type definitions:
=SML
clean_up();
new_script{name="int511J", state=initial_cn_state};
¹CN
pragma LIST(OFF);
--# -- This annotation should be in the SPARK program but not in the listing
package int511PACK8 is
   X : INTEGER;
   procedure P;
end int511PACK8;
°
=SML
set_string_control("case_of_spark_keywords", "as input");
output_spark_program{out_file="int511J1.ada"};
val int511J1state = get_cn_state();
new_script{name="int511J2", state=int511J1state};

¹CN

With int511pack8;
Pragma List(On);
Procedure int511proc14
Is
    Pragma List(Off);
    Type INT Is Range -100 .. 100;
    y : INT;
    Pragma List(On);
    Pragma Page;
    Pragma Suppress(Range_Check, On=>y);
Begin
    Pragma List(Off);
    y := 100;
    Pragma List(On);
    int511pack8.x := Integer(y);
    int511pack8.p;
End int511proc14;
°

=SML
output_spark_program{out_file="int511J2.ada"};
system"cat int511J1.ada int511J2.ada > int511J.ada ; rm -f int511J1.ada int511J2.ada";
=TEX


\section{EPILOGUE}
We use {\tt test} to test the standard output from {\tt findfile} below
to see if {\tt gnatchop} is on the path. This is because {\tt which}
(a) returns 0 (success) when it cannot find the program on Solaris
and (b) behaves strangely (e.g., hangs) when not called from {\tt csh}.
=DUMP int511.sh
#!/bin/sh
PROBLEMS=
GNATARGS='-gnatlvs'
MLFILE=int511.errorfiles.ML
if	test -f `findfile gnatchop $PATH`
then
	for file in int511*.ada
	do	echo gnatchopping $file
		gnatchop -w $file >/dev/null
		if [ $? != 0 -o ! -s $file ]
		then PROBLEMS=$PROBLEMS" "$file
	       fi
	done
	for src in int511?*.ads
	do	echo checking file $src
		if	gcc -c $GNATARGS $src 2>&1
		then	echo $src syntax-checked OK
		else	echo $src failed to syntax-check
			PROBLEMS="$PROBLEMS $src"
		fi
	done
	for src in int511?*.adb
	do	echo checking file $src
		if	gcc -c $GNATARGS $src 2>&1
		then	echo $src syntax-checked OK
		else	echo $src failed to syntax-check
			PROBLEMS="$PROBLEMS $src"
		fi
	done
	rm -f int511*.adb int511*.ads int511*.ali int511*.o
	if	[ "x$PROBLEMS" != x ]
	then	echo  Errors reported for:$PROBLEMS
	fi
		{	echo 'val error_files = '
			for i in $PROBLEMS
			do	echo '"'$i'"::'
			done
			echo 'nil;' ; } >$MLFILE
else	rm -f int511.ada
	cat  int511*.ada > int512.ada
	echo '***' The module test generated a warning: GNAT is not available
	echo '***' Please inspect the file int511.ada for errors
	echo 'val error_files = [];' >$MLFILE
fi
=TEX
=SML
system "sh int511.sh 2>&1";
=TEX
=SML
val error_files = ["int511.sh"];
use_file"int511.errorfiles.ML";
store_mt_results (fn _ => (map (fn x => (x, false)) error_files)) ();
diag_line (summarize_mt_results());
=TEX
\end{document}

