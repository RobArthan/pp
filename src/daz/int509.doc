=IGN
********************************************************************************
int509.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Date: 2002/10/17 16:04:45 $ $Revision: 1.16 $ $RCSfile: int509.doc,v $ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SPARK Constructs}  %% Mandatory field
\def\TPPheadtitle{SPARK Constructs}
\TPPref{ISS/HAT/DAZ/INT509}  %% Mandatory field
\def\SCCSversion{$Revision: 1.16 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/10/17 16:04:45 $%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{G.M.~Prout & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives a Compliance Notation script with examples of each kind of SPARK expression, basic declaration and statement.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1 - 1.2%
] Initial Drafts.
\item[Issues 1.3 - 1.4%
] Enhancements added.
\item[Issue 1.5] Accommodated fix to bug 12 (V0.6).
\item[Issue 1.6-1.7]
Updated for IUCT WP 7 changes.
\item[Issue 1.8] Changes for IUCT WP 4.
\item[Issue 1.9] Made it work with June 200 enhancements.
\item[Issue 1.10] CTLE II --- characters and strings now supported formally, so tests need to be more careful.
\item[Issue 1.11] CTLE II --- real types now supported formally.
\item[Issue 1.12] More tests on type conversions.
\item[Issue 1.13] Removed use of ICL logo font.
\item[Issue 1.14] Copyright and banner updates for open source release.
\item[Issue 1.15] DAZ-specific updates to banner for open source release
\item[Issue 1.16] DAZ-specific updates to banner for open source release
\item[Issue 1.17] The Z universal set is now called É
\end{description}

\subsection{Changes Forecast}
Tests to be added as time permits.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501} and \cite{ISS/HAT/DAZ/USR501}.

\subsection{Introduction}

This document contains specific tests for the translation of Spark expressions, basic declarations and statements i.e., exercising each use of the expressions and basic declarations listed in sections 5 and 6 of volume 3 of \cite{DRA/CIS/CSE3/TR/94/27/2.1} and the statements listed in section 4 of volume 2 of \cite{DRA/CIS/CSE3/TR/94/27/2.1}. The test names correspond to the sections of \cite{DRA/CIS/CSE3/TR/94/27/2.1} in which the constructs are specified.

\section{THE LITERATE SCRIPTS}


\subsection{Setting up of the environment}

Set up flags so the compliance tool works correctly .

=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX

Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX

\subsection{Useful functions}

Function to clean up before doing a test.
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX
Functions for recording some statistics of theories.

=SML
type theory_stats = {np : int, ng : int, na : int, nd : int, nc : int};
local
    fun noof_parents thy = (length o get_parents) thy;
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
in
    fun get_theory_stats (thy : string) : theory_stats =
    let
        val np = noof_parents thy;
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
    in
        {np = np, ng = ng, na = na, nd = nd, nc = nc}
    end;
end;
=TEX
Function for saving and naming theorems: 
=SML
fun chk_thm () : unit = (
        let val thm = pop_thm();
                fun save th i = (
                        save_thm(string_of_int i, th)
                        handle Fail _ => save th (i+1)
                );
        in      save thm 1; ()
        end
);
=TEX
Function to check that number of vcs in a theory matches the number of proven theorems:
=SML
fun chk_vcs () : bool = (
        length (get_conjectures "-") = length (get_thms"-")
);
=TEX
\pagebreak
Lemmas which are useful when proving vcs generated from specifications which have arrays in them:
=SML
set_pc"z_library_ext";
set_goal([], Ò[X, Y](µf : X ≠ Y; x: É; y : É∑(f ´ {x Ì y})x = y)Æ);
a(REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 2 ÒyÆ);
val z_´_lemma = pop_thm();
=TEX
=SML
set_pc"z_library";
set_goal([], Ò[X, Y](µf : X ≠ Y; x2:X;x1: É; y : É | ≥x2=x1 ∑
	(f ´ {x1 Ì y})x2 = f x2)Æ);
a(REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tacÒ(x2, f_a) ç fÆ THEN1 PC_T1 "z_library_ext" asm_prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [z_fun_app_clauses]);
(* *** Goal "2" *** *)
(*a(ALL_ASM_FC_T rewrite_tac [z_≠_app_thm]);*)
a(asm_fc_tac[z_≠_app_thm]);
a(asm_fc_tac[z_≠_app_thm]);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
val z_´_lemma1 = pop_thm();
=TEX

\pagebreak
\section{EXPRESSIONS} \label{EXP}
\subsection{Identifier} 
=SML
clean_up();
new_script{name="test5.2", state=initial_cn_state};
=TEX
πCN
procedure P is
   C1 : constant INTEGER := 9;
   C2 : constant INTEGER := C1;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC2 = C1Æ);
a(rewrite_tac[z_get_spec ÒC2Æ]);
=TEX
=SML
store_mt_results mt_run [("5.2",chk_thm,(),())];
=TEX

\subsection{Aggregates} 
\subsubsection{Positional Array} 
=SML
clean_up();
new_script{name="test5.3", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 2 .. 4;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(THU, FRI, SAT);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = succ Á 1 - ARRvFIRST Í ª ßTHU, FRI, SAT¢Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.3",chk_thm,(),())];
=TEX
\subsubsection{Positional Array With Others} 

=SML
clean_up();
new_script{name="test5.4", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 1 .. 7;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(THU, FRI, SAT, others => SUN);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (ARRvRANGE ∏ {SUN}) ´ (succ Á 1 - ARRvFIRST Í ª ßTHU, FRI, SAT¢)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.4",chk_thm,(),())];
=TEX

\subsubsection{Positional Array With Just Others} 

=SML
clean_up();
new_script{name="test5.5", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 2 .. 4;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(others => SUN);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = ARRvRANGE ∏ {SUN}Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.5",chk_thm,(),())];
=TEX

\subsubsection{Named Array} 

=SML
clean_up();
new_script{name="test5.6", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   C : constant ARR := ARR'(MON .. THU | FRI => WED, SAT | SUN => TUE);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = ((MON .. THU) ¿ {FRI} ∏ {WED}) ¿ ({SAT, SUN} ∏ {TUE})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.6",chk_thm,(),())];
=TEX

\subsubsection{Named Array With Others} 

=SML
clean_up();
new_script{name="test5.7", state=initial_cn_state};
=TEX

πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 1 .. 7;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(1 .. 5 => WED, others => TUE);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (ARRvRANGE ∏ {TUE}) ´ (1 .. 5 ∏ {WED})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.7",chk_thm,(),())];
=TEX
\subsubsection{Positional Record} 

=SML
clean_up();
new_script{name="test5.8", state=initial_cn_state};
=TEX

πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
		
   C : constant REC := REC'(WED,SUN,ARR'(others => THU));
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 
	(START ¶ WED, FINISH ¶ SUN, YESTERDAY ¶ ARRvRANGE ∏ {THU})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.8",chk_thm,(),())];
=TEX

\subsubsection{Named Record} 

=SML
clean_up();
new_script{name="test5.9", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
		
   C : constant REC := REC'(START => THU,
				FINISH => FRI,
				YESTERDAY => ARR'(others => SUN));
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 
	(START ¶ THU, FINISH ¶ FRI, YESTERDAY ¶ ARRvRANGE ∏ {SUN})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.9",chk_thm,(),())];
=TEX

\subsection{Unary} 
=SML
clean_up();
new_script{name="test5.10", state=initial_cn_state};
=TEX
πCN
procedure P is
   C1 : constant INTEGER := abs (-6);
   C2 : constant BOOLEAN := not FALSE;
  
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC1 = abs ~ 6 ± C2 = not FALSEÆ);
a(rewrite_tac[z_get_spec ÒC1Æ,z_get_spec ÒC2Æ]);
=TEX
=SML
store_mt_results mt_run [("5.10", chk_thm,(),())];
=TEX

\subsection{Binary} 
=SML
clean_up();
new_script{name="test5.11a", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant BOOLEAN := ((5<5 and 6<=4) or (2>1 and then -1>=0)) 
				or else (3=3 xor 2 /=3);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (5 less 5 and 6 less_eq 4) 
			or (2 greater 1 and ~1 greater_eq 0) 
			or (3 eq 3 xor 2 noteq 3)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.11a",chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11b", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := 5-3+2*7;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (5 - 3) + 2 * 7Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.11b", chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11c", state=initial_cn_state};
=TEX
πCN
procedure P is
   C1 : constant INTEGER := (17 / 3) * 3 + (17 rem 3);
   C2 : constant INTEGER := (-17 / 3) * 3 + (-17 mod 3);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC1 = (17 intdiv 3) * 3 + 17 rem 3 ±
		C2 = ~ (17 intdiv 3) * 3 + ~ (17 intmod 3)Æ);
a(rewrite_tac[z_get_spec ÒC1Æ,z_get_spec ÒC2Æ]);
=TEX
=SML
store_mt_results mt_run [("5.11c", chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11d", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := 2 ** 3;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 2 ** 3Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.11d",chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11e", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEKDAY is DAY range MON..FRI;
   C : constant BOOLEAN := SUN in WEEKDAY or SUN not in WEEKDAY;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = SUN mem WEEKDAY or SUN notmem WEEKDAYÆ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.11e",chk_thm,(),())];
=TEX
\subsection{Membership of a Range} 
=SML
clean_up();
new_script{name="test5.12", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant BOOLEAN := 6 in 5..10 or 6 not in 5..10;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 6 mem 5 .. 10 or 6 notmem 5 .. 10Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.12", chk_thm,(),())];
=TEX
\subsection{Attributes} 
=SML
clean_up();
new_script{name="test5.13", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEK is DAY range MON..SUN;
   subtype WEEKDAY is DAY range MON..FRI;
   subtype ALTWEEKDAY is WEEKDAY;
   subtype INDEX is INTEGER range 1 .. 4;
   type ARR is array (INDEX) of DAY;
   C1 : constant DAY := WEEKDAY'FIRST;
   C2 : constant DAY := WEEKDAY'LAST;
   C3 : constant DAY := WEEKDAY'SUCC(FRI);
   C4 : constant DAY := WEEKDAY'PRED(WED);
   C5 : constant INTEGER := WEEKDAY'POS(TUE);
   C6 : constant DAY := WEEKDAY'VAL(6);
   C7 : constant DAY := ARR'FIRST;
   C8 : constant DAY := ARR'LAST;
   C9 : constant INTEGER := ARR'LENGTH;
   C10 : constant DAY := ALTWEEKDAY'FIRST;
   C11 : constant DAY := ALTWEEKDAY'LAST;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC1=WEEKDAYvFIRST±C2=WEEKDAYvLAST±C3=WEEKDAYvSUCC(FRI)
	±C4=WEEKDAYvPRED(WED)±C5=WEEKDAYvPOS(TUE)
	±C6=WEEKDAYvVAL(6)±C7=ARRvFIRST±C8=ARRvLAST±C9=ARRvLENGTH ±
	C10 = C1 ± C11 = C2Æ);
a(rewrite_tac(map z_get_spec[ÒC1Æ,ÒC2Æ,ÒC3Æ,ÒC4Æ,ÒC5Æ,ÒC6Æ,ÒC7Æ,ÒC8Æ,ÒC9Æ,
	ÒC10Æ, ÒC11Æ, ÒALTWEEKDAYvFIRSTÆ, ÒALTWEEKDAYvLASTÆ ]));
=TEX
=SML
store_mt_results mt_run [("5.13",chk_thm,(),())];
=TEX

\subsection{Indexed Components}
=SML
clean_up();
new_script{name="test5.14", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 1 .. 7;
   type ARR is array (INDEX) of DAY;
   TOMORROW : constant ARR := ARR'(TUE,WED,THU,FRI,SAT,SUN,MON);
   C : constant DAY := TOMORROW(DAY'FIRST);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=TOMORROW(DAYvFIRST)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.14",chk_thm,(),())];
=TEX
\subsection{Selected Components}
=SML
clean_up();
new_script{name="test5.15", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   R : constant REC := REC'(WED,FRI,ARR'(others => SUN));		
   C : constant DAY := R.FINISH;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=R.FINISHÆ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=SML
store_mt_results mt_run [("5.15",chk_thm,(),())];
=TEX
\subsection{Function Calls}
=SML
clean_up();
new_script{name="test5.16", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   function MAX (x,y: DAY) return DAY ò [ true ];
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record;
   R : constant REC := REC'(WED,FRI,ARR'(others => SUN)); 	 
   C : constant DAY := MAX(THU,R.FINISH);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=MAX(THU,R.FINISH)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX 
=SML
store_mt_results mt_run [("5.16",chk_thm,(),())];
=TEX
\subsection{Qualified Expressionss}
=SML
clean_up();
new_script{name="test5.17", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   C : constant DAY := DAY'(THU);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=THUÆ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.17",chk_thm,(),())];
=TEX
\subsection{Type Conversions}
=SML
clean_up();
new_script{name="test5.18", state=initial_cn_state};
=TEX
πCN
procedure P is
   subtype COUNT is INTEGER range 1.. 10;
   type SLICE is digits 6 range 1.0 .. 10.0;
   C1 : constant COUNT := COUNT(4);
   C2 : constant INTEGER := INTEGER(4);
   C3 : constant SLICE := SLICE(C1);
   C4 : constant FLOAT := FLOAT(C1);
   C5 : constant COUNT := COUNT(C3);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC1=4 ± C2 = 4 ± C3 = real 4 ± C4 = real 4 ± C5 = real_to_integer(real 4)Æ);
a(rewrite_tac(z_get_specÒinteger_to_realÆ::map z_get_spec (get_consts"-"))); 
=TEX
=SML
store_mt_results mt_run [("5.18", chk_thm,(),())];
=TEX 
\subsection{Integer Literals}
=SML
clean_up();
new_script{name="test5.19", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := 4;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=4Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.19",chk_thm,(),())];
=TEX
\subsection{Auxiliary Expressions}
=SML
clean_up();
new_script{name="test5.20", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := ˚6˝;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=6Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
=TEX
=SML
store_mt_results mt_run [("5.20",chk_thm,(),())];
=TEX
\section{BASIC DECLARATIONS}
\subsection{Constants}
These have been extensively tested in  Section \ref{EXP}. An explicit example of a constant of type string array, part of the enhanced Compliance Notation, is tested here.

=SML
clean_up();
new_script{name="test6.2", state=initial_cn_state};
=TEX

πCN
procedure P is
   subtype INDEX is INTEGER range 1..2;
   type STRING_ARRAY is array(INDEX) of STRING;
   A : constant STRING_ARRAY := STRING_ARRAY'("abc", "xyz");
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒA = ßstring_lit "abc", string_lit "xyz"¢Æ);
a(rewrite_tac(
	pc_rule1 "z_library_ext" prove_rule[] Òµr: É∑(id_) ª r  = rÆ::
	z_succÁ0Í_thm::
	map z_get_spec[ÒAÆ, ÒSTRING_ARRAYvFIRSTÆ, ÒINDEXvFIRSTÆ, Ò˙Æ]));
=TEX
=SML
store_mt_results mt_run [("6.2",chk_thm,(),())];
=TEX

\subsection{Enumeration Types} 
=SML
clean_up();
new_script{name="test6.3", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒMON = 0 ± TUE = 1 ± WED = 2 ± THU = 3 
	± FRI = 4 ± SAT = 5 ± SUN = 6 
	± DAY  = MON .. SUN ± DAYvFIRST = MON ± DAYvLAST = SUN
	± DAYvSUCC = (DAY \ {DAYvLAST}) Ú succ ± DAYvPRED = DAYvSUCC Á~Í
	± DAYvVAL = DAYvPOS Á~ÍÆ);
a(rewrite_tac(map z_get_spec (get_consts"test6.3")));
=TEX
=SML
store_mt_results mt_run [("6.3",chk_thm,(),())];
=TEX
\subsection{Array Types}
=SML
clean_up();
new_script{name="test6.4", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type HOURS is range 0..23;
   type ARR1 is array (DAY) of DAY;
   type ARR2 is array (DAY,HOURS) of DAY;
   type UNCON1 is array (DAY range <>) of DAY;
   type UNCON2 is array (DAY range <>,HOURS range <>) of DAY;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒARR1 = DAY ≠ DAY ± 
		ARR1vFIRST = DAYvFIRST ± ARR1vLAST = DAYvLAST ±
		ARR1vLENGTH = # DAY ± ARR1vRANGE = DAY ±
		UNCON1 ç  (DAY ﬂ DAY) ± UNCON2 ç  (DAY ∏ HOURS ﬂ DAY)Æ);
a(rewrite_tac(map z_get_spec (get_consts"test6.4")));
=TEX
=SML
store_mt_results mt_run [("6.4",chk_thm,(),())];
=TEX
\subsection{Record Types}
=SML
clean_up();
new_script{name="test6.5", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒREC = [START : DAY; FINISH : DAY; YESTERDAY : ARR]Æ);
a(rewrite_tac(map z_get_spec (get_consts"test6.5")));
=TEX
=SML
store_mt_results mt_run [("6.5",chk_thm,(),())];
=TEX
\subsection{Integer Types}
=SML
clean_up();
new_script{name="test6.6", state=initial_cn_state};
=TEX
πCN
procedure P is
   type HOURS is range 0..23;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒHOURS = 0..23 ± HOURSvFIRST = 0 ± HOURSvLAST = 23
	± HOURSvSUCC ç ˙ ﬂ ˙ ± HOURSvPRED ç ˙ ﬂ ˙
	± HOURSvPOS ç ˙ ﬂ ˙ ± HOURSvVAL ç ˙ ﬂ ˙Æ);
a(rewrite_tac(map z_get_spec (get_consts"test6.6")));
=TEX
=SML
store_mt_results mt_run [("6.6",chk_thm,(),())];
=TEX
\subsection{Real Types}
=SML
clean_up();
new_script{name="test6.7", state=initial_cn_state};
=TEX
πCN
procedure P is
   type FIX is delta 0.1 range 5.1 .. 10.0;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒFIX = 51 e (~ 1) ..âR 1 e 1Æ);
a(rewrite_tac[z_get_specÒFIXÆ]);
=TEX
=SML
store_mt_results mt_run [("6.7",chk_thm,(),())];
=TEX
\subsection{Subtypes}
=SML
clean_up();
new_script{name="test6.8.1", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEKDAY is DAY range MON..FRI;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒWEEKDAY = MON .. FRI 
		± WEEKDAYvFIRST = MON ± WEEKDAYvLAST = FRI
		± WEEKDAYvSUCC = DAYvSUCC ± WEEKDAYvPRED = DAYvPRED
		± WEEKDAYvPOS = DAYvPOS ± WEEKDAYvVAL = DAYvVALÆ);
a(rewrite_tac(map z_get_spec (get_consts"test6.8.1")));
=TEX
=SML
store_mt_results mt_run [("6.8.1",chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test6.8.2", state=initial_cn_state};
=TEX
πCN
procedure P is
   type FIX is delta 0.1 range 5.1 .. 10.0;
   subtype SUBFIX1 is FIX range 7.0 .. 9.0;
   subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], Ò
	SUBFIX1 = 7 e 0 ..âR 9 e 0
±	SUBFIX1vFIRST = 7 e 0
±	SUB1 = real_to_integer (72 e (~ 1)) .. 10
±	SUB1vLAST = 10
±	SUBFIX1vDELTA = 1 e ~1Æ);
a(rewrite_tac(map z_get_spec (get_consts"test6.8.2")));
=TEX
=SML
store_mt_results mt_run [("6.8.2",chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test6.8.3", state=initial_cn_state};
=TEX
πCN
procedure P is
   type FLOAT1 is digits 4  range -5.1 .. 10.0;
   type FIX is delta 0.3 range 0.0 .. 10.0;
   subtype SUBFLOAT1 is FLOAT1 digits 4 range -0.8 .. 0.8;
   subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], Ò
	SUBFLOAT1 = ~âR 8 e (~ 1) ..âR 8 e (~ 1)
±	SUBFIX2 = 6 e 0 ..âR 1 e 1
±	FLOAT1vDIGITS = SUBFLOAT1vDIGITS = 4
±	FIXvDELTA = SUBFIX2vDELTA = 3 e ~1Æ);
a(rewrite_tac(map z_get_spec (get_consts"test6.8.3")));
=TEX
=SML
store_mt_results mt_run [("6.8.3",chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test6.8.4", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEKDAY is DAY range MON..FRI;
   type UNCON is array (DAY range <>) of DAY;
   subtype SUB is UNCON(WEEKDAY);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒSUB = {array : UNCON | dom array = WEEKDAY} 
		± SUBvFIRST = WEEKDAYvFIRST ± SUBvLAST = WEEKDAYvLAST
		± SUBvLENGTH = # WEEKDAY ± SUBvRANGE = WEEKDAYÆ);
a(rewrite_tac(map z_get_spec (get_consts"test6.8.4")));
=TEX
=SML
store_mt_results mt_run [("6.8.4",chk_thm,(),())];
=TEX
=SML
clean_up();
new_script{name="test6.8.5", state=initial_cn_state};
=TEX
πCN
procedure P is
   type HOURS is range 0..23;
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEKDAY is DAY range MON..FRI;
   type UNCON2 is array (DAY range <>,HOURS range<>) of DAY;
   subtype SUB2 is UNCON2(WEEKDAY,HOURS);
begin 
   null;
end P;
∞

=SML
set_pc"cn";
set_goal([], ÒSUB2 = {array : UNCON2 | dom array = WEEKDAY ∏ HOURS}Æ);
a(rewrite_tac[z_get_spec ÒSUB2Æ]);
=TEX
=SML
store_mt_results mt_run [("6.8.5",chk_thm,(),())];
=TEX

\pagebreak
\section{STATEMENTS} \label{STA}
\subsection{Null}
=SML
clean_up();
new_script{name="test4.2", state=initial_cn_state};
=TEX
πCN
procedure P is
begin 
   	Ñ [true]	
end P;
∞

πCN
 √
	null;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òtrue ¥ trueÆ accept_tac);
a strip_tac;
=TEX
=SML
store_mt_results mt_run [("4.2",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.2vcs",chk_vcs,(),true)];
=TEX
\subsection{Assignment}
=SML
clean_up();
new_script{name="test4.3.1", state=initial_cn_state};
=TEX
πCN
procedure P is
	X : INTEGER;
begin 
   	Ñ X[X=5]	
end P;
∞

πCN
 √
	X := 5;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òtrue ¥ 5 = 5Æ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.3.1",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.3.1vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.3.2", state=initial_cn_state};
=TEX
πCN
procedure P is
	subtype INDEX is INTEGER range 0..9;
	type ARR is array (INDEX) of INTEGER;
	A : ARR;
begin 
   	Ñ A[A(3)=6]	
end P;
∞

πCN
 √
	A(3) := 6;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_TÒµ A : ARR ∑ (A ´ {3 Ì 6}) 3 = 6Æ accept_tac);
a(rewrite_tac[z_get_specÒARRÆ] THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_´_lemma]);
=TEX
=SML
store_mt_results mt_run [("4.3.2",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.3.2vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.3.3", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON, TUE, WED);
    type REC is record A : INTEGER; B : DAY; C : DAY; end record;
    R : REC;
begin
 Ñ R [R.B=WED]	
end P;
∞

πCN
 √
	R.B := WED;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(rewrite_tac[z_gen_pred_elim (dest_z_tupleÒ(É, É, É)Æ) (z_get_specÒRECuBÆ)]);
=TEX
=SML
store_mt_results mt_run [("4.3.3",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.3.3vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.3.4", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON, TUE, WED);
    type REC is record X : INTEGER; Y : DAY; end record;
    type ARR is array(DAY) of REC;
    type REC1 is record X : INTEGER; Y: ARR; end record;
    A : ARR;
    R : REC1;
begin
 Ñ A,R [(A MON).Y = TUE ± ((R.Y) WED).X = 3]	
end P;
∞
πCN
 √
	 A(MON).Y := TUE;
	 R.Y(WED).X := 3;
∞
=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ R : REC1; A : ARR
             ∑ ((A ´ {MON Ì RECuY (A MON, TUE)}) MON).Y = TUE
               ± ((REC1uY (R, R.Y ´ {WED Ì RECuX (R.Y WED, 3)})).Y WED).X = 3Æ accept_tac);
a(rewrite_tac[z_gen_pred_elim (dest_z_tupleÒ(É, É)Æ) (z_get_specÒRECuXÆ),
	z_gen_pred_elim (dest_z_tupleÒ(É, É)Æ) (z_get_specÒREC1uYÆ),
	z_get_specÒARRÆ,z_get_specÒREC1Æ]);
a(REPEAT strip_tac THEN ALL_FC_T rewrite_tac[z_´_lemma]);
=TEX
=SML
store_mt_results mt_run [("4.3.4",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.3.4vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.3.5", state=initial_cn_state};
=TEX
πCN
procedure P is
	X : INTEGER := 1;
begin 
   	Ñ X[X =1, X=5]	
end P;
∞

πCN
 √
	X := 5;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ X : INTEGER | X = 1 ∑ 5 = 5Æ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.3.5",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.3.5vcs",chk_vcs,(),true)];
=TEX
\subsection{Specification} \label{SPEC}
=SML
clean_up();
new_script{name="test4.4.1", state=initial_cn_state};
=TEX

πCN
procedure P is
    X,Y : INTEGER;
begin
 Ñ X,Y [X > 5 ± Y > 5]	
end P;
∞

πCN
 √
	X := 10; Ñ Y [X = 10, X = 10 ± Y > 5]	
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òtrue ¥ 10=10Æ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.4.1a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ X, Y : INTEGER | true ± X = 10 ± Y > 5 ∑ X > 5 ± Y > 5Æ
	 accept_tac);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.4.1b",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.4.1vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.4.2", state=initial_cn_state};
=TEX

πCN
procedure P is
    X,Y : INTEGER;
begin
 Ñ X,Y [X > 5 ± Y > 5]	
end P;
∞

πCN
 √
	Ñ Y [Y > 5]
	X := 10;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òtrue ¥ trueÆ accept_tac);
a strip_tac;
=TEX
=SML
store_mt_results mt_run [("4.4.2a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ Y : INTEGER | true ± Y > 5 ∑ 10 > 5 ± Y > 5Æ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.4.2b",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.4.2vcs",chk_vcs,(),true)];
=TEX
\subsection{Semicolon}
Semicolon statement has been comprehensibly tested in Section \ref{SPEC}.
\subsection{If}
=SML
clean_up();
new_script{name="test4.6.1", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON, TUE, WED,THU,FRI,SAT,SUN);
    D : DAY; 
begin
 Ñ D [D = MON]	
end P;
∞

πCN
 √
	if D > MON then D := MON;end if;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ D : DAY | true ± D greater MON = TRUE ∑ MON = MONÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.6.1a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ D : DAY | true ± D greater MON = FALSE ∑ D = MONÆ accept_tac);
a(rewrite_tac[z_get_specÒMONÆ,z_get_specÒDAYÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.6.1b",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.6.1vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.6.2", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON, TUE, WED,THU,FRI,SAT,SUN);
    D : DAY; 
begin
 Ñ D [D > FRI]	
end P;
∞

πCN
 √
	if D = SAT or D = SUN then null; else D := SAT;end if;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ D : DAY | true ± D eq SAT or D eq SUN = TRUE ∑ D > FRIÆ
	 accept_tac);
a(rewrite_tac[z_get_specÒFRIÆ,z_get_specÒSATÆ,z_get_specÒSUNÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.6.2a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ D : DAY | true ± D eq SAT or D eq SUN = FALSE ∑ SAT>FRIÆ
	accept_tac);
a(rewrite_tac[z_get_specÒFRIÆ,z_get_specÒSATÆ]);
=TEX
=SML
store_mt_results mt_run [("4.6.2b",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.6.2vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.6.3", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON, TUE, WED,THU,FRI,SAT,SUN);
    D : DAY; 
begin
 Ñ D [D > FRI]	
end P;
∞

πCN
 √
	if D = SAT  then null; elsif D = SUN then null; else D := SAT;end if;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ D : DAY | true ± D eq SAT = TRUE ∑ D > FRIÆ accept_tac);
a(rewrite_tac[z_get_specÒFRIÆ,z_get_specÒSATÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.6.3a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ D : DAY | true ± D eq SAT = FALSE ± D eq SUN = TRUE ∑ D > FRIÆ
	 accept_tac);
a(rewrite_tac[z_get_specÒFRIÆ,z_get_specÒSATÆ,z_get_specÒSUNÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.6.3b",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_3");
a(LEMMA_T Òµ D : DAY | true ± D eq SAT = FALSE ± D eq SUN = FALSE ∑ 
	SAT > FRIÆ accept_tac);
a(rewrite_tac[z_get_specÒFRIÆ,z_get_specÒSATÆ,z_get_specÒSUNÆ]);
=TEX
=SML
store_mt_results mt_run [("4.6.3c",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.6.3vcs",chk_vcs,(),true)];
=TEX
\subsection{Case}
=SML
clean_up();
new_script{name="test4.7.1", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON,TUE,WED,THU,FRI,SAT,SUN);
    subtype WEEKEND is DAY range SAT..SUN;
    D : DAY; 
begin
 Ñ D [D = SAT ≤ D = SUN]	
end P;
∞

πCN
 √
	case D is
		when MON => D := SAT;
		when TUE => D := SAT;
		when WED => D := SAT;
		when THU => D := SAT;
		when FRI => D := SAT;
		when SAT => null;
		when SUN => null;
	end case;
∞
=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ D : DAY | true ± D ç {MON} ∑ SAT = SAT ≤ SAT = SUNÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.1a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ D : DAY | true ± D ç {TUE} ∑ SAT = SAT ≤ SAT = SUNÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.1b",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_3");
a(LEMMA_T Òµ D : DAY | true ± D ç {WED} ∑ SAT = SAT ≤ SAT = SUNÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.1c",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_4");
a(LEMMA_T Òµ D : DAY | true ± D ç {THU} ∑ SAT = SAT ≤ SAT = SUNÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.1d",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_5");
a(LEMMA_T Òµ D : DAY | true ± D ç {FRI} ∑ SAT = SAT ≤ SAT = SUNÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.1e",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_6");
a(LEMMA_T Òµ D : DAY | true ± D ç {SAT} ∑ D = SAT ≤ D = SUNÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.1f",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_7");
a(LEMMA_T Òµ D : DAY | true ± D ç {SUN} ∑ D = SAT ≤ D = SUNÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.1g",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.7.1vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.7.2", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON,TUE,WED,THU,FRI,SAT,SUN);
    D : DAY; 
begin
 Ñ D [D = SAT ≤ D = SUN]	
end P;
∞

πCN
 √
	case D is
		when MON..FRI => D := SAT;
		when SAT..SUN => null;
	end case;
∞
=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ D : DAY | true ± D ç MON .. FRI ∑ SAT = SAT ≤ SAT = SUNÆ
	 accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.2a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ D : DAY | true ± D ç SAT .. SUN ∑ D = SAT ≤ D = SUNÆ accept_tac);
a(rewrite_tac[z_get_specÒSATÆ,z_get_specÒSUNÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.7.2b",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.7.2vcs",chk_vcs,(),true)];
=TEX
=SML
clean_up();
new_script{name="test4.7.3", state=initial_cn_state};
=TEX
πCN
procedure P is
    type DAY is (MON,TUE,WED,THU,FRI,SAT,SUN);
    D : DAY; 
begin
 Ñ D [D = SAT]	
end P;
∞

πCN
 √
	case D is
		when SAT => null;
	end case;
∞
=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ D : DAY | true ± D ç {SAT} ∑ D = SATÆ accept_tac);
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.7.3",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.7.3vcs",chk_vcs,(),true)];
=TEX
\subsection{Undecorated Loop and Exit}
=SML
clean_up();
new_script{name="test4.8.1", state=initial_cn_state};
=TEX
πCN
procedure P is
   subtype INDEX is INTEGER range 1 .. 10;
   type ARR is array (INDEX) of INTEGER;
   I : INTEGER;	
   A : ARR;
begin
 Ñ A,I [µ j : 1 .. 10  ∑ A j = 0]
end P;
∞

πCN
 √
	I := 1;
	till ˚µ j : 1 .. 10  ∑ A j = 0˝
	loop
	Ñ A,I [I º 11 ± (µ j : 1 .. I-1  ∑ A j = 0),I º 11 ± (µ j : 1 .. I-1  ∑ A j = 0)]
	end loop;
∞

πCN
 √
	exit when I = 11;

	Ñ A,I [I º 10 ± (µ j : 1 .. I-1  ∑ A j = 0),I º 11 ± (µ j : 1 .. I-1  ∑ A j = 0)]
	
∞

πCN
 √
	A(I) := 0;
	I := I+1;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ A : ARR ∑ 1 º 11 ± (µ j : 1 .. 1 - 1 ∑ A j = 0)Æaccept_tac);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.8.1a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ A : ARR; I : INTEGER
             | true ± I º 11 ± (µ j : 1 .. I - 1 ∑ A j = 0)
             ∑ I º 11 ± (µ j : 1 .. I - 1 ∑ A j = 0)Æaccept_tac);
a(prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.8.1b",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_3");
a(LEMMA_TÒµ A : ARR
             | true ± (µ j : 1 .. 10 ∑ A j = 0)
             ∑ µ j : 1 .. 10 ∑ A j = 0Æaccept_tac);
a(z_µ_tac THEN taut_tac);
=TEX
=SML
store_mt_results mt_run [("4.8.1c",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_2_1");
a(LEMMA_T Òµ A : ARR; I : INTEGER
             | (I º 11 ± (µ j : 1 .. I - 1 ∑ A j = 0)) ± I eq 11 = TRUE
             ∑ µ j : 1 .. 10 ∑ A j = 0Æ	accept_tac);
a(rewrite_tac[] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(all_asm_ante_tac THEN rewrite_tac[] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.8.1d",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_2_2");
a(LEMMA_T Òµ A : ARR; I : INTEGER
             | (I º 11 ± (µ j : 1 .. I - 1 ∑ A j = 0)) ± I eq 11 = FALSE
             ∑ I º 10 ± (µ j : 1 .. I - 1 ∑ A j = 0)Æ	accept_tac);
a(prove_tac[]);
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.8.1e",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_2_3");
a(LEMMA_T Òµ A, Aâ0 : ARR; I, Iâ0 : INTEGER
             | (Iâ0 º 11
               ± (µ j : 1 .. Iâ0 - 1 ∑ Aâ0 j = 0))
               ± I º 11
               ± (µ j : 1 .. I - 1 ∑ A j = 0)
             ∑ I º 11 ± (µ j : 1 .. I - 1 ∑ A j = 0)Æ	accept_tac);
a(z_µ_tac THEN taut_tac);
=TEX
=SML
store_mt_results mt_run [("4.8.1f",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_3_1");
a(LEMMA_T Òµ A : ARR; I : INTEGER
             | I º 10 ± (µ j : 1 .. I - 1 ∑ A j = 0)
             ∑ I + 1 º 11 ± (µ j : 1 .. (I + 1) - 1 ∑ (A ´ {I Ì 0}) j = 0)Æ	accept_tac);
a(rewrite_tac[z_get_specÒARRÆ]THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_TÒj = I ≤ j ç 1 .. I + ~ 1 Æ (≤_THEN asm_tac));
(* *** Goal "2.1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_´_lemma]);
(* *** Goal "2.3" *** *)
a(z_spec_nth_asm_tac 4 ÒjÆ);
(* *** Goal "2.3.1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.2" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.3" *** *)
a(lemma_tacÒ≥ j = I ± jçINDEXÆ THEN1 rewrite_tac[z_get_specÒINDEXÆ] 
	THEN1 PC_T1 "z_lin_arith"asm_prove_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac [z_´_lemma1]);
=TEX
=SML
store_mt_results mt_run [("4.8.1g",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.8.1vcs",chk_vcs,(),true)];
=TEX
\subsection{While Loop}
=SML
clean_up();
new_script{name="test4.9.1", state=initial_cn_state};
=TEX

πCN
procedure P is
   subtype INDEX is INTEGER range 1 .. 10;
   type ARR is array (INDEX) of INTEGER;
   I : INTEGER;	
   A : ARR;
begin
 Ñ A,I [µ j : 1 .. 10  ∑ A j = 0]
end P;
∞

πCN
 √
	I := 1;
	while (I <= 10) 
	loop
	Ñ A,I [I º 10 ± (µ j : 1 .. I-1  ∑ A j = 0), 
		 I º 11 ± (µ j : 1 .. I-1  ∑ A j = 0)]
	end loop;
∞

πCN
 √
	A(I) := 0;
	I := I + 1;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ A : ARR
             | true ± 1 less_eq 10 = TRUE
             ∑ 1 º 10 ± (µ j : 1 .. 1 - 1 ∑ A j = 0)Æaccept_tac);
a(PC_T1 "z_lin_arith" prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.9.1a",chk_thm,(),())];
=TEX
=SML
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ A : ARR | true ± 1 less_eq 10 = FALSE ∑ µ j : 1 .. 10 ∑ A j = 0Æ
	accept_tac);
a(prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.9.1b",chk_thm,(),())];
=TEX
=SML
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_3");
a(LEMMA_T Òµ A : ARR; I : INTEGER
             | true
               ± (I º 11
               ± (µ j : 1 .. I - 1 ∑ A j = 0))
               ± I less_eq 10 = TRUE
             ∑ I º 10 ± (µ j : 1 .. I - 1 ∑ A j = 0)Æaccept_tac);
a(z_µ_tac THEN ¥_tac THEN ±_tac THEN asm_prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.9.1c",chk_thm,(),())];
=TEX
=SML
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_4");
a(LEMMA_T Òµ A : ARR; I : INTEGER
             | true
               ± (I º 11
               ± (µ j : 1 .. I - 1 ∑ A j = 0))
               ± I less_eq 10 = FALSE
             ∑ µ j : 1 .. 10 ∑ A j = 0Æaccept_tac);
a(prove_tac[]);
a(z_spec_nth_asm_tac 4 ÒjÆ);
(* *** Goal "1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tacÒI = 11Æ THEN_T PC_T1 "z_lin_arith" asm_prove_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.9.1d",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_2_1");
a(LEMMA_T Òµ A : ARR; I : INTEGER
             | I º 10 ± (µ j : 1 .. I - 1 ∑ A j = 0)
             ∑ I + 1 º 11 ± (µ j : 1 .. (I + 1) - 1 ∑ (A ´ {I Ì 0}) j = 0)Æ
	accept_tac);
a(rewrite_tac[z_get_specÒARRÆ]THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_TÒj = I ≤ j ç 1 .. I + ~ 1 Æ (≤_THEN asm_tac));
(* *** Goal "2.1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[z_´_lemma]);
(* *** Goal "2.3" *** *)
a(z_spec_nth_asm_tac 4 ÒjÆ);
(* *** Goal "2.3.1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.2" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2.3.3" *** *)
a(lemma_tacÒ≥ j = I ± jçINDEXÆ THEN1 rewrite_tac[z_get_specÒINDEXÆ] 
	THEN1 PC_T1 "z_lin_arith"asm_prove_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac [z_´_lemma1]);
=TEX
=SML
store_mt_results mt_run [("4.9.1e",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.9.1vcs",chk_vcs,(),true)];
=TEX
\subsection{For Loop}
=SML
clean_up();
new_script{name="test4.10.1", state=initial_cn_state};
=TEX

πCN
procedure P is
   subtype INDEX is INTEGER range 1 .. 10;
   type ARR is array (INDEX) of INTEGER;
   I : INTEGER;	
   A : ARR;
begin
 Ñ A,I [µ j : 1 .. 10  ∑ A j = 0]
end P;
∞

πCN
 √
	for I in INDEX loop
	Ñ A,I [µ j : 1 .. I-1  ∑ A j = 0, (µ j : 1 .. I-1  ∑ A j = 0) ± A I = 0]
	end loop;
∞

πCN
 √
	A(I) := 0;
∞

=SML
print_z_document"-";
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a(LEMMA_T Òµ A : ARR
             | true ± INDEXvFIRST º INDEXvLAST
             ∑ µ j : 1 .. INDEXvFIRST - 1 ∑ A j = 0Æaccept_tac);
a(rewrite_tac[z_get_specÒINDEXvFIRSTÆ]THEN REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.10.1a",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_2");
a(LEMMA_T Òµ A : ARR
             | true ± INDEXvFIRST > INDEXvLAST
             ∑ µ j : 1 .. 10 ∑ A j = 0Æaccept_tac);
a(rewrite_tac[z_get_specÒINDEXvFIRSTÆ,z_get_specÒINDEXvLASTÆ]
	THEN PC_T1 "z_lin_arith" REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.10.1b",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_3");
a(LEMMA_T Òµ A : ARR; I : INTEGER; I : INDEX
             | true ± I Ω INDEXvLAST ± (µ j : 1 .. I - 1 ∑ A j = 0) ± A I = 0
             ∑ µ j : 1 .. (I + 1) - 1 ∑ A j = 0Æaccept_tac);
a(REPEAT strip_tac);
a(lemma_tacÒj º I - 1 ≤ j = IÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 5 ÒjÆ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(asm_ante_tacÒj º I - 1Æ THEN1 asm_ante_tacÒI - 1 < jÆ );
a(PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.10.1c",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_1_4");
a(LEMMA_T Òµ A : ARR
             | true ± (µ j : 1 .. INDEXvLAST - 1 ∑ A j = 0) ± A INDEXvLAST = 0
             ∑ µ j : 1 .. 10 ∑ A j = 0Æaccept_tac);
a(rewrite_tac[z_get_specÒINDEXvLASTÆ]THEN REPEAT strip_tac);
a(lemma_tacÒj º 9 ≤ j = 10Æ THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 5 ÒjÆ THEN_T PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
=TEX
=SML
store_mt_results mt_run [("4.10.1d",chk_thm,(),())];
=TEX
=SML
set_goal([], get_conjecture"-""vc_2_1");
a(LEMMA_T Òµ A : ARR; I : INTEGER; I : INDEX
             | µ j : 1 .. I - 1 ∑ A j = 0
             ∑ (µ j : 1 .. I - 1 ∑ (A ´ {I Ì 0}) j = 0) ± (A ´ {I Ì 0}) I = 0Æ
	accept_tac);
a(rewrite_tac[z_get_specÒARRÆ]THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 3 ÒjÆ);
(* *** Goal "1.1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "1.3" *** *)
a(lemma_tacÒ≥ j = I ± jç INDEXÆTHEN1 GET_NTH_ASM_T 5 ante_tac THEN1
	rewrite_tac[z_get_specÒINDEXÆ]THEN1 PC_T1 "z_lin_arith"asm_prove_tac[]);
a(ALL_ASM_FC_T asm_rewrite_tac [z_´_lemma1]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_´_lemma]);
=TEX
=SML
store_mt_results mt_run [("4.10.1e",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.10.1vcs",chk_vcs,(),true)];
=TEX
\subsection{Procedure Call}
=SML
clean_up();
new_script{name="test4.15.1", state=initial_cn_state};
=TEX

πCN
procedure P is
   I,J : INTEGER;	
	procedure PLUS_TEN (X : in INTEGER; Y : out INTEGER)
	Ñ Y [Y = X + 10]
	is
	begin
	 	Y := X + 10;
	end PLUS_TEN;
begin
 Ñ J [J = I + 10]
end P;
∞

πCN
√
PLUS_TEN(I,J);
∞

=SML
set_pc"cn";
set_goal([], get_conjecture"-""vcP_1");
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.15.1a",chk_thm,(),())];
=TEX
=SML
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_1");
a strip_tac;
=TEX
=SML
store_mt_results mt_run [("4.15.1b",chk_thm,(),())];
=TEX
=SML
set_pc"cn";
set_goal([], get_conjecture"-""vc_1_2");
a(REPEAT strip_tac);
=TEX
=SML
store_mt_results mt_run [("4.15.1c",chk_thm,(),())];
=TEX
=SML
store_mt_results mt_run [("4.15.1vcs",chk_vcs,(),true)];
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\end{document}

