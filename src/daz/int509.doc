% %Z% $Date$ $Revision$ $RCSfile$ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SPARK Expression and Basic Declaration Examples}  %% Mandatory field
\def\TPPheadtitle{SPARK Expression and Basic Declaration Examples}
\TPPref{ISS/HAT/DAZ/INT509}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{G.M.~Prout & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives a Compliance Notation script with examples of each kind of SPARK expression and basic declaration.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1%
] Initial Draft.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501} and \cite{ISS/HAT/DAZ/USR501}.

\subsection{Introduction}

This document contains specific tests for the translation of Spark expressions and basic declarartions i.e., exercising each use of the expressions and basic declarations listed in sections 5 and 6 of volume 3 of \cite{DRA/CIS/CSE3/TR/94/27/2.1}

\section{THE LITERATE SCRIPTS}


\subsection{Setting up of the environment}

Set up flags so the compliance tool works correctly .

=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX

Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX

\subsection{Useful functions}

Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = get_descendants "cn" less "cn";
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
Functions for recording some statistics of theories.

=SML
type theory_stats = {np : int, ng : int, na : int, nd : int, nc : int};
local
    fun noof_parents thy = (length o get_parents) thy;
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
in
    fun get_theory_stats (thy : string) : theory_stats =
    let
        val np = noof_parents thy;
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
    in
        {np = np, ng = ng, na = na, nd = nd, nc = nc}
    end;
end;
=TEX
\pagebreak
\section{EXPRESSIONS} \label{EXP}
\subsection{Identifier} 
=SML
clean_up();
new_script{name="test5.2", state=initial_cn_state};
=TEX
πCN
procedure P is
   C1 : constant INTEGER := 9;
   C2 : constant INTEGER := C1;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC2 = C1Æ);
a(rewrite_tac[z_get_spec ÒC2Æ]);
fun chk_test5_2 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.2",chk_test5_2,(),())];
=TEX

\subsection{Aggregates} 
\subsubsection{Positional Array Aggregates} 
=SML
clean_up();
new_script{name="test5.3", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 2 .. 4;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(THU, FRI, SAT);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = succ Á 1 - ARRvFIRST Í ª ßTHU, FRI, SAT¢Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_3 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.3",chk_test5_3,(),())];
=TEX
\subsubsection{Positional Array Aggregates with others} 

=SML
clean_up();
new_script{name="test5.4", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 1 .. 7;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(THU, FRI, SAT, others => SUN);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (ARRvRANGE ∏ {SUN}) ´ (succ Á 1 - ARRvFIRST Í ª ßTHU, FRI, SAT¢)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_4 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.4",chk_test5_4,(),())];
=TEX

\subsubsection{Positional Array Aggregates with just others} 

=SML
clean_up();
new_script{name="test5.5", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 2 .. 4;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(others => SUN);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = ARRvRANGE ∏ {SUN}Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_5 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.5",chk_test5_5,(),())];
=TEX

\subsubsection{Named Array Aggregates} 

=SML
clean_up();
new_script{name="test5.6", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   C : constant ARR := ARR'(MON .. THU | FRI => WED, SAT | SUN => TUE);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = ((MON .. THU) ¿ {FRI} ∏ {WED}) ¿ ({SAT, SUN} ∏ {TUE})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_6 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.6",chk_test5_6,(),())];
=TEX

\subsubsection{Named Array Aggregates with others} 

=SML
clean_up();
new_script{name="test5.7", state=initial_cn_state};
=TEX

πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 1 .. 7;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(1 .. 5 => WED, others => TUE);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (ARRvRANGE ∏ {TUE}) ´ (1 .. 5 ∏ {WED})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_7 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.7",chk_test5_7,(),())];
=TEX
\subsubsection{Positional Record Aggregates} 

=SML
clean_up();
new_script{name="test5.8", state=initial_cn_state};
=TEX

πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
		
   C : constant REC := REC'(WED,SUN,ARR'(others => THU));
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 
	(START ¶ WED, FINISH ¶ SUN, YESTERDAY ¶ ARRvRANGE ∏ {THU})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_8 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.8",chk_test5_8,(),())];
=TEX

\subsubsection{Named Record Aggregates} 

=SML
clean_up();
new_script{name="test5.9", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
		
   C : constant REC := REC'(START => THU,
				FINISH => FRI,
				YESTERDAY => ARR'(others => SUN));
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 
	(START ¶ THU, FINISH ¶ FRI, YESTERDAY ¶ ARRvRANGE ∏ {SUN})Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_9 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.9",chk_test5_9,(),())];
=TEX

\subsection{Unary} 
=SML
clean_up();
new_script{name="test5.10", state=initial_cn_state};
=TEX
πCN
procedure P is
   C1 : constant INTEGER := abs (-6);
   C2 : constant BOOLEAN := not FALSE;
  
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC1 = abs ~ 6 ± C2 = not FALSEÆ);
a(rewrite_tac[z_get_spec ÒC1Æ,z_get_spec ÒC2Æ]);
fun chk_test5_10 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.10", chk_test5_10,(),())];
=TEX

\subsection{Binary} 
=SML
clean_up();
new_script{name="test5.11a", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant BOOLEAN := ((5<5 and 6<=4) or (2>1 and then -1>=0)) 
				or else (3=3 xor 2 /=3);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (5 less 5 and 6 less_eq 4) 
			or (2 greater 1 and ~1 greater_eq 0) 
			or (3 eq 3 xor 2 noteq 3)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_11a () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.11a",chk_test5_11a,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11b", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := 5-3+2*7;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = (5 - 3) + 2 * 7Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_11b () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.11b", chk_test5_11b,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11c", state=initial_cn_state};
=TEX
πCN
procedure P is
   C1 : constant INTEGER := (17 / 3) * 3 + (17 rem 3);
   C2 : constant INTEGER := (-17 / 3) * 3 + (-17 mod 3);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC1 = (17 intdiv 3) * 3 + 17 rem 3 ±
		C2 = ~ (17 intdiv 3) * 3 + ~ (17 intmod 3)Æ);
a(rewrite_tac[z_get_spec ÒC1Æ,z_get_spec ÒC2Æ]);
fun chk_test5_11c () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.11c", chk_test5_11c,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11d", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := 2 ** 3;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 2 ** 3Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_11d () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.11d",chk_test5_11d,(),())];
=TEX
=SML
clean_up();
new_script{name="test5.11e", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEKDAY is DAY range MON..FRI;
   C : constant BOOLEAN := SUN in WEEKDAY or SUN not in WEEKDAY;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = SUN mem WEEKDAY or SUN notmem WEEKDAYÆ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_11e () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.11e",chk_test5_11e,(),())];
=TEX
\subsection{Membership of a Range} 
=SML
clean_up();
new_script{name="test5.12", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant BOOLEAN := 6 in 5..10 or 6 not in 5..10;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC = 6 mem 5 .. 10 or 6 notmem 5 .. 10Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_12 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.12", chk_test5_12,(),())];
=TEX
\subsection{Attributes} 
** NOTE Range attributes are not handled formally. 
=SML
clean_up();
new_script{name="test5.13", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEK is DAY range MON..SUN;
   subtype WEEKDAY is DAY range MON..FRI;
   subtype INDEX is INTEGER range 1 .. 4;
   type ARR is array (INDEX) of DAY;
   C1 : constant DAY := WEEKDAY'FIRST;
   C2 : constant DAY := WEEKDAY'LAST;
   C3 : constant DAY := WEEKDAY'SUCC(FRI);
   C4 : constant DAY := WEEKDAY'PRED(WED);
   C5 : constant INTEGER := WEEKDAY'POS(TUE);
   C6 : constant DAY := WEEKDAY'VAL(6);
   C7 : constant DAY := ARR'FIRST;
   C8 : constant DAY := ARR'LAST;
   C9 : constant INTEGER := ARR'LENGTH;
-- C10 : constant BOOLEAN := 5 in ARR'RANGE;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC1=WEEKDAYvFIRST±C2=WEEKDAYvLAST±C3=WEEKDAYvSUCC(FRI)
	±C4=WEEKDAYvPRED(WED)±C5=WEEKDAYvPOS(TUE)
	±C6=WEEKDAYvVAL(6)±C7=ARRvFIRST±C8=ARRvLAST±C9=ARRvLENGTHÆ);
a(rewrite_tac(map z_get_spec[ÒC1Æ,ÒC2Æ,ÒC3Æ,ÒC4Æ,ÒC5Æ,ÒC6Æ,ÒC7Æ,ÒC8Æ,ÒC9Æ]));
fun chk_test5_13 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.13",chk_test5_13,(),())];
=TEX

\subsection{Indexed Components}
=SML
clean_up();
new_script{name="test5.14", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 1 .. 7;
   type ARR is array (INDEX) of DAY;
   TOMORROW : constant ARR := ARR'(TUE,WED,THU,FRI,SAT,SUN,MON);
   C : constant DAY := TOMORROW(DAY'FIRST);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=TOMORROW(DAYvFIRST)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_14 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.14",chk_test5_14,(),())];
=TEX
\subsection{Selected Components}
=SML
clean_up();
new_script{name="test5.15", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   R : constant REC := REC'(WED,FRI,ARR'(others => SUN));		
   C : constant DAY := R.FINISH;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=R.FINISHÆ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_15 () = (pop_thm();());
=SML
store_mt_results mt_run [("5.15",chk_test5_15,(),())];
=TEX
\subsection{Function Calls}
=SML
clean_up();
new_script{name="test5.16", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   function MAX (x,y: DAY) return DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record;
   R : constant REC := REC'(WED,FRI,ARR'(others => SUN)); 	 
   C : constant DAY := MAX(THU,R.FINISH);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=MAX(THU,R.FINISH)Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_16 () = (pop_thm();());
=TEX 
=SML
store_mt_results mt_run [("5.16",chk_test5_16,(),())];
=TEX
\subsection{Qualified Expressionss}
=SML
clean_up();
new_script{name="test5.17", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   C : constant DAY := DAY'(THU);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=THUÆ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_17 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.17",chk_test5_17,(),())];
=TEX
\subsection{Type Conversions}
** NOTE Type conversions are not handled formally. 
=SML
clean_up();
new_script{name="test5.18", state=initial_cn_state};
=TEX
πCN
procedure P is
   subtype COUNT is INTEGER range 1.. 10;
-- C : constant COUNT := COUNT(4);
begin 
   null;
end P;
∞
=SML
(* set_pc"cn"; *)
(* set_goal([], ÒC=4Æ); *)
(* a(rewrite_tac[z_get_spec ÒCÆ]); *)
(* fun chk_test5_18 () = (pop_thm();()); *)
=TEX
=SML
(* store_mt_results mt_run [("5.18", chk_test5_18,(),())]; *)
=TEX 
\subsection{Integer Literals}
=SML
clean_up();
new_script{name="test5.19", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := 4;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=4Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_19 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.19",chk_test5_19,(),())];
=TEX
\subsection{Auxiliary Expressions}
=SML
clean_up();
new_script{name="test5.20", state=initial_cn_state};
=TEX
πCN
procedure P is
   C : constant INTEGER := ˚6˝;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒC=6Æ);
a(rewrite_tac[z_get_spec ÒCÆ]);
fun chk_test5_20 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("5.20",chk_test5_20,(),())];
=TEX
\section{BASIC DECLARATIONS}
\subsection{Constants}
These have been extensively tested in  Section \ref{EXP}. An explicit example of a constant of type string array, part of the enhanced Compliance Notation, is tested here.

=SML
clean_up();
new_script{name="test6.2", state=initial_cn_state};
=TEX

** NOTE String arrays are not handled formally. 

\subsubsection{Enumeration Types} 
=SML
clean_up();
new_script{name="test6.3", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒMON = 0 ± TUE = 1 ± WED = 2 ± THU = 3 
	± FRI = 4 ± SAT = 5 ± SUN = 6 
	± DAY  = MON .. SUN ± DAYvFIRST = MON ± DAYvLAST = SUN
	± DAYvSUCC = (DAY \ {DAYvLAST}) Ú succ ± DAYvPRED = DAYvSUCC Á~Í
	± DAYvVAL = DAYvPOS Á~ÍÆ);
a(rewrite_tac(map z_get_spec (get_consts"test6.3")));
fun chk_test6_3 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("6.3",chk_test6_3,(),())];
=TEX
\subsubsection{Array Types}
** NOTE Multi-dimensional arrays not yet handled formally. Unconstrained arrays handled in a different way.
=SML
clean_up();
new_script{name="test6.4", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type HOURS is range 0..23;
   type ARR1 is array (DAY) of DAY;
-- type ARR2 is array (DAY,HOURS) of DAY;
   type UNCON1 is array (DAY range <>) of DAY;
-- type UNCON2 is array (DAY range <>,HOURS range <>) of DAY;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒARR1 = DAY ≠ DAY 
		± ARR1vFIRST = DAYvFIRST ± ARR1vLAST = DAYvLAST
		± ARR1vLENGTH = # DAY ± ARR1vRANGE = DAYÆ);
a(rewrite_tac(map z_get_spec (get_consts"test6.4")));
fun chk_test6_4 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("6.4",chk_test6_4,(),())];
=TEX
\subsubsection{Record Types}
=SML
clean_up();
new_script{name="test6.5", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   type ARR is array (DAY) of DAY;
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒREC = [START : DAY; FINISH : DAY; YESTERDAY : ARR]Æ);
a(rewrite_tac(map z_get_spec (get_consts"test6.5")));
fun chk_test6_5 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("6.5",chk_test6_5,(),())];
=TEX
\subsubsection{Integer Types}
** NOTE SUCC, PRED, POS and VAL not yet handled formally. 
=SML
clean_up();
new_script{name="test6.6", state=initial_cn_state};
=TEX
πCN
procedure P is
   type HOURS is range 0..23;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒHOURS = 0..23 ± HOURSvFIRST = 0 ± HOURSvLAST = 23Æ);
a(rewrite_tac(map z_get_spec (get_consts"test6.6")));
fun chk_test6_6 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("6.6",chk_test6_6,(),())];
=TEX
\subsubsection{Real Types}
** NOTE Real types not yet handled formally. 
\subsubsection{Subtypes}
** NOTE Only subtypes with a range constraint such as in Section 6.8.1 or an index constraint such as in Section 6.8.4 are dealt with formally.
=SML
clean_up();
new_script{name="test6.8.1", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEKDAY is DAY range MON..FRI;
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒWEEKDAY = MON .. FRI 
		± WEEKDAYvFIRST = MON ± WEEKDAYvLAST = FRI
		± WEEKDAYvSUCC = DAYvSUCC ± WEEKDAYvPRED = DAYvPRED
		± WEEKDAYvPOS = DAYvPOS ± WEEKDAYvVAL = DAYvVALÆ);
a(rewrite_tac(map z_get_spec (get_consts"test6.8.1")));
fun chk_test6_8_1 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("6.8.1",chk_test6_8_1,(),())];
=TEX
** NOTE Unconstrained defn will change
=SML
clean_up();
new_script{name="test6.8.4", state=initial_cn_state};
=TEX
πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype WEEKDAY is DAY range MON..FRI;
   type UNCON is array (DAY range <>) of DAY;
   subtype SUB is UNCON(WEEKDAY);
begin 
   null;
end P;
∞
=SML
set_pc"cn";
set_goal([], ÒSUB = {UNC : UNCON | dom UNC = WEEKDAY} 
		± SUBvFIRST = WEEKDAYvFIRST ± SUBvLAST = WEEKDAYvLAST
		± SUBvLENGTH = # WEEKDAY ± SUBvRANGE = WEEKDAYÆ);
a(rewrite_tac(map z_get_spec (get_consts"test6.8.4")));
fun chk_test6_8_4 () = (pop_thm();());
=TEX
=SML
store_mt_results mt_run [("6.8.4",chk_test6_8_4,(),())];
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX


\pagebreak

\end{document}

