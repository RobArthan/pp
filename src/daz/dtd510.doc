% dtd510.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: SPARK Output Function} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD510} %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{D.J.~King & HAT Team}
\TPPabstract{
This document contains the detailed design for the DAZ SPARK Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.16] Initial Drafts.
\item[Issue 1.17 (13th October 1994)] Added auxiliary expression support.
\item[Issue 1.18 (14th October 1994)] Removed variant records from the implementation.
\item[Issue 1.19 (3rd November 1994)] Changed SUBUNIT to COMP\_SUBUNIT.
\item[Issue 1.20 (14th November 1994)] rationalised signature wrapping.
\item[Issues 1.21-1.22] Minor corrections before document inspection.
\item[Issue 1.23] Reworked according to desk check report 019.
\item[Issue 1.24] Updated the distribution list.
\item[Issue 1.25] Corrected test policy statement.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the Compliance Tool SPARK Output Function and responds to the high level design in \cite{ISS/HAT/DAZ/HLD503}.

The implementation is in \cite{ISS/HAT/DAZ/IMP510}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This detailed design document contains one signature, $CNSparkOutput$.  This provides facilities for printing out the various categories of abstract syntax.  None of the functions in it are intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} describes the top level functions which use this signature.

\subsubsection{Dependencies}

The functions in $CNSparkOutput$ depend on data types introduced in the structure $CNTypes$ which is defined in \cite{ISS/HAT/DAZ/DTD502}.

\subsection{Compliance}

The requirement is that the functions in this document support the correct printing of Spark programs which can be compiled using an Ada compiler.

\section{PRINTING ABSTRACT SYNTAX}

\subsection{The Signature}
=DOC
signature ÛCNSparkOutputİ = sig
local
	open CNTypes;
in
=DESCRIBE
This signature contains functions which format abstract syntax into strings. It is used by the functions in the signature $SPARKOutput$ to print entire SPARK programs from the compliance tool environment when compliance notation has been entered.
=USES
None of the functions in this signature are intended to be called directly by the user.
=ENDDOC

\subsection{Functions to Print Abstract Syntax}
=DOC
val ÛPPTabSizeİ : int ref 
type ÛPP_FMT_INFOİ
val Ûset_PPTab_sizeİ : int -> unit 
val Ûget_PPTab_sizeİ : unit -> int 
val Ûfmt_spacesİ : int -> string 
val Ûfmt_tabsİ : int -> string
val Ûfmt_info_string_listİ :
	(PP_FMT_INFO * string) list -> string   

=DESCRIBE
These functions deal with the low-level output of characters.
=ENDDOC

=DOC
val Ûfmt_idİ : ID -> string
val Ûfmt_tmarkİ : TMARK -> string 
val Ûfmt_termİ : TERM -> string 
val Ûfmt_labelİ : LABEL -> string 
val Ûfmt_unary_opİ : UNARY_OP -> string 
val Ûfmt_binary_opİ : BIN_OP -> string 
val Ûfmt_modeİ : MODE -> string 
val Ûfmt_loop_directionİ : LOOP_DIRECTION -> string 
val Ûfmt_operator_symbolİ : OPERATOR_SYMBOL -> OPERATOR_SYMBOL
val Ûfmt_z_predİ : Z_PRED -> string 
val Ûfmt_z_expİ : Z_EXP -> string 
val Ûfmt_z_idİ : Z_ID -> string 
val Ûfmt_attribİ : ATTRIB -> string 
val Ûfmt_int_litİ : INT_LIT -> string 
=DESCRIBE
These functions prints the leaves of the abstract syntax; they don't call any others.
=ENDDOC

=DOC 
val Ûfmt_id_listİ : ID list -> string 
val Ûfmt_tmark_listİ : TMARK list -> string
=DESCRIBE
Lists of identifiers
=ENDDOC

=DOC
val Ûfmt_rangelohiİ : EXP RANGELOHI -> string
val Ûfmt_rangeİ : EXP RANGE -> string
val Ûfmt_discrete_range_constrainedİ :
	EXP DISCRETE_RANGE_CONSTRAINED -> string
val Ûfmt_discrete_rangeİ : DISCRETE_RANGE -> string
val Ûfmt_agg_choiceİ : AGG_CHOICE -> string
val Ûfmt_agg_choice_listİ : AGG_CHOICE list -> string
val Ûfmt_named_assocİ : (AGG_CHOICE, EXP) NAMED_ASSOC -> string
val Ûfmt_named_assoc_listİ :
	(AGG_CHOICE, EXP) NAMED_ASSOC list -> string
val Ûfmt_othersİ : EXP OTHERS -> string
val Ûfmt_agg_posİ : EXP AGG_POS -> string
val Ûfmt_agg_pos_othersİ : EXP AGG_POS_OTHERS -> string
val Ûfmt_agg_othersİ : EXP AGG_OTHERS -> string
val Ûfmt_agg_namedİ : (AGG_CHOICE, EXP) AGG_NAMED -> string
val Ûfmt_agg_named_othersİ :
	(AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> string
val Ûfmt_unary_expİ : EXP UNARY_EXP -> string
val Ûfmt_bin_expİ : EXP BIN_EXP -> string
val Ûfmt_attrib_desigİ : ATTRIB_DESIG -> string
val Ûfmt_attributeİ : (EXP, ATTRIB_DESIG) ATTRIBUTE -> string
val Ûfmt_indexed_compİ : EXP INDEXED_COMP -> string
val Ûfmt_selected_compİ : EXP SELECTED_COMP -> string
val Ûfmt_qualified_expressionİ : EXP QUALIFIED_EXPRESSION -> string
val Ûfmt_expİ : EXP -> string
val Ûfmt_exp_listİ : EXP list -> string
val Ûfmt_static_expİ : STATIC_EXP -> string 
val Ûfmt_static_rangelohiİ : STATIC_EXP RANGELOHI -> string 
val Ûfmt_static_rangeİ : STATIC_EXP RANGE -> string 
val Ûfmt_condİ : COND -> string 
val Ûfmt_actualsİ : (AGG_CHOICE, EXP) ACTUALS -> string 
=DESCRIBE
Functions dealing with expressions.
=ENDDOC

=DOC
val Ûfmt_specİ : SPEC -> string 
val Ûfmt_proc_callİ : (AGG_CHOICE, EXP) PROC_CALL -> string 
=DESCRIBE
Functions dealing with a spec statement an a procedure call.
=ENDDOC

=DOC
val Ûfmt_k_slotİ : PP_FMT_INFO -> K_SLOT -> (PP_FMT_INFO * string) list
val Ûfmt_assignİ : PP_FMT_INFO -> ASSIGN -> (PP_FMT_INFO * string) list
val Ûfmt_spec_no_ivarsİ :
	PP_FMT_INFO -> SPEC_NO_IVARS -> (PP_FMT_INFO * string) list 
val Ûfmt_exit_whenİ :
	PP_FMT_INFO -> EXIT_WHEN -> (PP_FMT_INFO * string) list 
val Ûfmt_returnİ :
	PP_FMT_INFO -> RETURN -> (PP_FMT_INFO * string) list
val Ûfmt_proc_call_no_ivarsİ :
	PP_FMT_INFO -> (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS ->
	(PP_FMT_INFO * string) list
val Ûfmt_elsifİ : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
val Ûfmt_if_then_elseİ :
	PP_FMT_INFO -> STMT IF_THEN_ELSE -> (PP_FMT_INFO * string) list
val Ûfmt_case_choiceİ : CASE_CHOICE -> string
val Ûfmt_case_choice_listİ : CASE_CHOICE list -> string
val Ûfmt_case_altİ :
	PP_FMT_INFO -> STMT CASE_ALTERNATIVE ->
	(PP_FMT_INFO * string) list
val Ûfmt_case_alt_listİ :
	PP_FMT_INFO -> STMT CASE_ALTERNATIVE list ->
	(PP_FMT_INFO * string) list
val Ûfmt_caseİ :
	PP_FMT_INFO -> STMT CASE -> (PP_FMT_INFO * string) list
val Ûfmt_unnamed_loopİ :
	PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_named_loopİ :
	PP_FMT_INFO -> STMT NAMED_LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_loop_bodyİ :
	PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_whileİ :
	PP_FMT_INFO -> STMT WHILE -> (PP_FMT_INFO * string) list
val Ûfmt_for_staticİ :
	PP_FMT_INFO -> STMT FOR_STATIC -> (PP_FMT_INFO * string) list
val Ûfmt_for_tmarkİ :
	PP_FMT_INFO -> STMT FOR_TMARK -> (PP_FMT_INFO * string) list
val Ûfmt_stmtİ : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
=DESCRIBE
Functions dealing with statements.
=ENDDOC

=DOC
val Ûfmt_log_conİ :
	PP_FMT_INFO -> (LOG_CON * STMT) -> (PP_FMT_INFO * string) list 
=DESCRIBE
Logical constructs.
=ENDDOC

=DOC 
val Ûfmt_statementİ :
	PP_FMT_INFO -> STATEMENT -> (PP_FMT_INFO * string) list 
=DESCRIBE
Top level statements.
=ENDDOC

=DOC
val Ûfmt_var_declİ :
	PP_FMT_INFO -> VAR_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_var_decl_listİ :
	PP_FMT_INFO -> VAR_DECL list -> (PP_FMT_INFO * string) list 
=DESCRIBE
Variable declarations.
=ENDDOC

=DOC
val Ûfmt_const_declİ :
	PP_FMT_INFO -> EXP CONST_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_deferred_const_declİ :
	PP_FMT_INFO -> DEFERRED_CONST_DECL ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Constant and Deferred constant declarations.
=ENDDOC

=DOC
val Ûfmt_floating_point_constraintİ : EXP FLOATING_POINT_CONSTRAINT -> string
val Ûfmt_floating_type_defİ :
	PP_FMT_INFO -> ID * EXP FLOATING_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Floating point types.
=ENDDOC

=DOC
val Ûfmt_fixed_point_constraintİ : EXP FIXED_POINT_CONSTRAINT -> string 
val Ûfmt_fixed_type_defİ :
	PP_FMT_INFO -> ID * EXP FIXED_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Fixed point types.
=ENDDOC

=DOC 
val Ûfmt_enum_type_defİ :
	PP_FMT_INFO -> ID * ENUM_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Enumerated types.
=ENDDOC

=DOC
val Ûfmt_array_defİ :
	PP_FMT_INFO -> ID * ARRAY_DEF ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Array types.
=ENDDOC

=DOC
val Ûfmt_record_type_defİ :
	PP_FMT_INFO ->
	ID * RECORD_TYPE_DEF ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Record types.
=ENDDOC

=DOC
val Ûfmt_type_defİ :
	PP_FMT_INFO -> ID * TYPE_DEF ->
	(PP_FMT_INFO * string) list 
val Ûfmt_type_declİ :
	PP_FMT_INFO -> TYPE_DEF TYPE_DECL -> (PP_FMT_INFO * string) list 
=DESCRIBE
Type declarations.
=ENDDOC

=DOC
val Ûfmt_constraintİ : CONSTRAINT -> string 
val Ûfmt_sub_indİ : CONSTRAINT SUB_IND -> string 
val Ûfmt_subtype_declİ :
	PP_FMT_INFO -> CONSTRAINT SUBTYPE_DECL ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Subtype declarations.
=ENDDOC

=DOC 
val Ûfmt_private_type_declİ :
	PP_FMT_INFO -> PRIVATE_TYPE_DECL -> (PP_FMT_INFO * string) list
=DESCRIBE
Private type declarations.
=ENDDOC

=DOC 
val Ûfmt_basic_declİ :
	PP_FMT_INFO -> BASIC_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_basic_decl_listİ :
	PP_FMT_INFO -> BASIC_DECL list -> (PP_FMT_INFO * string) list
=DESCRIBE
Basic declarations.
=ENDDOC

=DOC
val Ûfmt_parameter_specificationİ : PARAMETER_SPECIFICATION -> string 
val Ûfmt_parameter_specification_list1İ :
	PARAMETER_SPECIFICATION list -> string
val Ûfmt_parameter_specification_listİ :
	PARAMETER_SPECIFICATION list -> string
=DESCRIBE
Procedure and Function parameter specifications.
=ENDDOC

=DOC
val Ûfmt_procedure_specificationİ :
	PP_FMT_INFO -> PROCEDURE_SPECIFICATION ->
	(PP_FMT_INFO * string) list
val Ûfmt_function_specificationİ :
	PP_FMT_INFO -> FUNCTION_SPECIFICATION ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Procedures and Function specifications.
=ENDDOC

=DOC
val Ûfmt_subprogram_specificationİ :
	PP_FMT_INFO -> SUBPROGRAM_SPECIFICATION ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Subprograms.
=ENDDOC

=DOC
val Ûfmt_function_renamingİ :
	PP_FMT_INFO -> FUNCTION_RENAMING -> (PP_FMT_INFO * string) list
val Ûfmt_subprogram_renamingİ :
	PP_FMT_INFO -> SUBPROGRAM_RENAMING ->
	(PP_FMT_INFO * string) list 
val Ûfmt_renaming_declarationİ :
	PP_FMT_INFO -> RENAMING_DECLARATION ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Renaming declarations.
=ENDDOC

=DOC 
val Ûfmt_component_clauseİ :
	PP_FMT_INFO -> COMPONENT_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_component_clause_listİ :
	PP_FMT_INFO -> COMPONENT_CLAUSE list ->
	(PP_FMT_INFO * string) list 
val Ûfmt_length_clauseİ :
	PP_FMT_INFO -> LENGTH_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_enumeration_representation_clauseİ :
	PP_FMT_INFO -> ENUMERATION_REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list
val Ûfmt_record_representation_clauseİ :
	PP_FMT_INFO -> RECORD_REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list
val Ûfmt_address_clauseİ :
	PP_FMT_INFO -> ADDRESS_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_representation_clauseİ :
	PP_FMT_INFO -> REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Representation clauses.
=ENDDOC

=DOC 
val Ûfmt_procedure_declarationİ :
	PP_FMT_INFO -> PROCEDURE_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_function_declarationİ :
	PP_FMT_INFO -> FUNCTION_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_procedure_stubİ :
	PP_FMT_INFO -> PROCEDURE_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_function_stubİ :
	PP_FMT_INFO -> FUNCTION_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_auxiliaryİ :
	PP_FMT_INFO -> AUX_VAR -> (PP_FMT_INFO * string) list 
val Ûfmt_usingİ :
	PP_FMT_INFO -> USING_DEC -> (PP_FMT_INFO * string) list 
val Ûfmt_package_stubİ :
	PP_FMT_INFO -> ID -> (PP_FMT_INFO * string) list 
val Ûfmt_package_declarationİ :
	PP_FMT_INFO -> DECLARATION PACKAGE_DECLARATION ->
	(PP_FMT_INFO * string) list
val Ûfmt_declarationİ :
	PP_FMT_INFO -> DECLARATION -> (PP_FMT_INFO * string) list
val Ûfmt_declaration_listİ :
	PP_FMT_INFO -> DECLARATION list -> (PP_FMT_INFO * string) list
val Ûfmt_procedure_bodyİ :
	PP_FMT_INFO -> DECLARATION PROCEDURE_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_function_bodyİ :
	PP_FMT_INFO -> DECLARATION FUNCTION_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_package_bodyİ :
	PP_FMT_INFO -> DECLARATION PACKAGE_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_proper_bodyİ :
	PP_FMT_INFO -> PROPER_BODY -> (PP_FMT_INFO * string) list
=DESCRIBE
Declarations.
=ENDDOC

=DOC
val Ûfmt_compilation_subunitİ :
	PP_FMT_INFO -> COMP_SUBUNIT -> (PP_FMT_INFO * string) list
=DESCRIBE
Compliation subunits.
=ENDDOC

=DOC 
val Ûfmt_context_clauseİ :
	PP_FMT_INFO -> ID list -> (PP_FMT_INFO * string) list 
val Ûfmt_compilation_unitİ :
	PP_FMT_INFO -> COMPILATION_UNIT -> (PP_FMT_INFO * string) list 
val Ûfmt_context_compilation_unitİ :
	PP_FMT_INFO -> CONTEXT_COMPILATION_UNIT ->
	(PP_FMT_INFO * string) list
val Ûfmt_kslot_compilation_unitİ :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT ->
	(PP_FMT_INFO * string) list
val Ûfmt_kslot_compilation_unit_listİ :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT list ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Compilation units.
=ENDDOC

=DOC
val Ûfmt_replaced_by_compİ :
	PP_FMT_INFO -> REPLACED_BY_COMP -> (PP_FMT_INFO * string) list 
val Ûfmt_replaced_by_private_partİ:
	PP_FMT_INFO -> REPLACED_BY_PRIVATE_PART ->
	(PP_FMT_INFO * string) list
val Ûfmt_replaced_by_visible_partİ :
	PP_FMT_INFO -> REPLACED_BY_VISIBLE_PART ->
	(PP_FMT_INFO * string) list
val Ûfmt_replaced_by_declİ :
	PP_FMT_INFO -> REPLACED_BY_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_refined_byİ :
	PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val Ûfmt_replaced_byİ :
	PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val Ûfmt_web_clauseİ :
	PP_FMT_INFO -> WEB_CLAUSE -> (PP_FMT_INFO * string) list 
=DESCRIBE
Web clauses.
=ENDDOC

\section{SPARK PROGRAM OUTPUT}
=DOC
val Ûformat_web_clauseİ :
	PP_FMT_INFO -> WEB_CLAUSE -> unit   
val Ûprint_web_clauseİ : WEB_CLAUSE -> unit
val Ûprint_spark_programİ : unit -> unit
val Ûoutput_spark_programİ : {out_file : string} -> unit
=DESCRIBE
The function $print\_spark\_program$ generates and prints the SPARK program from the contents of the Compliance Tool environment. The SPARK program is created by filling in the K-Slots and specification statements in a literate script with their expansions and printing the output onto the screen in SPARK syntax such that it could be subsequently compiled using an Ada compiler.

$output\_spark\_program$ does the same as $print\_spark\_program$ but allows the user to specify a file to which the program will then be written.
Both of these functions cause a number of checks to be imposed.
=FAILURE
510001	The following name clashes have been detected in the SPARK program:
510002	?0 clashes with ?1
510003	Name clashes detected in the SPARK program
=ENDDOC

\subsection{Epilogue}
=SML
end (* local ... in *);
end (* signature CNSparkOutput *);
=TEX

\section{TEST POLICY}
The functions in this document do not lend themselves to the module test framework (since their correct operation depends on the contents of output files).
The integration tests described in \cite{ISS/HAT/DAX/HLD503} will exercise these functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



