=IGN
********************************************************************************
dtd510.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% dtd510.doc %Z% $Date: 2002/11/10 18:40:47 $ $Revision: 1.43 $ $RCSfile: dtd510.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: SPARK Output Function} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD510} %% Mandatory field
\def\SCCSversion{$Revision: 1.43 $%
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/11/10 18:40:47 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{D.J.~King & HAT Team}
\TPPabstract{
This document contains the detailed design for the DAZ SPARK Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DERA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.16] Initial Drafts.
\item[Issue 1.17 (13th October 1994)] Added auxiliary expression support.
\item[Issue 1.18 (14th October 1994)] Removed variant records from the implementation.
\item[Issue 1.19 (3rd November 1994)] Changed SUBUNIT to COMP\_SUBUNIT.
\item[Issue 1.20 (14th November 1994)] rationalised signature wrapping.
\item[Issues 1.21-1.22] Minor corrections before document inspection.
\item[Issue 1.23] Reworked according to desk check report 019.
\item[Issue 1.24] Updated the distribution list.
\item[Issue 1.25] Corrected test policy statement.
\item[Issue 1.26] Tidy-up.
\item[Issue 1.27] Tidier error reporting.
\item[Issue 1.28] Corrected {\LaTeX} error.
\item[Issue 1.29] Reissue to match changes in version 1.61 of implementation doecument,
changing from string lists to direct output.
Many functions have been removed as they are not used externally to the structure.
\item[Issue 1.30] Revealed more functions required elsewhere.
\item[Issue 1.31] Clarified use of $cn\_automatic\_line\_splitting$.
\item[Issue 1.32] Changes for NJML port.
\item[Issue 1.34] Added control over case of keywords.
\item[Issue 1.35] Removed local declarations for Poly/ML port.
\item[Issue 1.36] New error message.
\item[Issue 1.38] Removed use of ICL logo font.
\item[Issue 1.39] Exposed interfaces needed by the VC browser.
\item[Issue 1.40] Copyright and banner updates for open source release.
\item[Issue 1.41, 1.42] DAZ-specific updates to banner for open source release
\item[Issue 1.43] Uniform treatment of block statements.
\item[Issue 1.44] R0055: warnings for non-SPARK constructs.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the Compliance Tool SPARK Output Function and responds to the high level design in \cite{ISS/HAT/DAZ/HLD503}.

The implementation is in \cite{ISS/HAT/DAZ/IMP510}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This detailed design document contains one signature, $CNSparkOutput$.  This provides facilities for printing out the various categories of abstract syntax.  None of the functions in it are intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} describes the top level functions which use this signature.

\subsubsection{Dependencies}

The functions in $CNSparkOutput$ depend on data types introduced in the structure $CNTypes$ which is defined in \cite{ISS/HAT/DAZ/DTD502}.

\subsection{Compliance}

The requirement is that the functions in this document support the correct printing of Spark programs which can be compiled using an Ada compiler.

\section{PRINTING ABSTRACT SYNTAX}

\subsection{The Signature}
=DOC
signature €CNSparkOutput› = sig
=DESCRIBE
This signature contains functions which format abstract syntax into strings. It is used by the functions in the signature $SPARKOutput$ to print entire SPARK programs from the compliance tool environment when compliance notation has been entered.
=USES
None of the functions in this signature are intended to be called directly by the user.
=ENDDOC
As in other signatures, local declarations would be nicer than includes
if they were allowed here:
=SML
include (* CNTypes *) CNTypes1;
=TEX
\subsection{Functions to Print Abstract Syntax}
=DOC
type €PP_FMT_INFO›
	(* = {outf : string -> unit, fmt_repl : (LABEL -> unit) OPT} *);
val €make_output_fun› : outstream -> string -> unit;
=DESCRIBE
{\it PP\_FMT\_INFO}
is the type used to pass formatting and output information to the
various functions that format Ada abstract syntax.

{\it make\_output\_fun} may be used to derive a suitable value for the
{\it outf} component of a {\it PP\_FMT\_INFO} from an output stream.
=ENDDOC

=DOC

=DOC
val €fmt_spec› : PP_FMT_INFO ->  (bool * SPEC) -> unit 
=DESCRIBE
Formatting a spec statement.
The boolean parameter indicates whether or not the spec statement is an assertion.
=ENDDOC

=DOC
val €fmt_var_decl› :
	PP_FMT_INFO -> VAR_DECL -> unit 
val €fmt_si_var_decl› :
	int -> PP_FMT_INFO -> SI_VAR_DECL -> unit 
val €fmt_var_decl_list› :
	PP_FMT_INFO -> VAR_DECL list -> unit 
val €fmt_si_comp_decl_list› :
	PP_FMT_INFO -> SI_VAR_DECL list -> unit 
=DESCRIBE
Formatting functions for variable declarations in the basic and derived abstract syntax.
=ENDDOC

=DOC 
val €fmt_basic_decl› :
	PP_FMT_INFO -> BASIC_DECL -> unit 
val €fmt_basic_decl_list› :
	PP_FMT_INFO -> BASIC_DECL list -> unit
val €fmt_si_basic_decl› :
	PP_FMT_INFO -> SI_BASIC_DECL -> unit 
val €fmt_si_basic_decl_list› :
	PP_FMT_INFO -> SI_BASIC_DECL list -> unit
=DESCRIBE
Formattting functions for basic declarations in the basic and derived abstract syntax.
=ENDDOC

=DOC 
val €fmt_z_pred› :
	PP_FMT_INFO -> Z_PRED -> unit 
=DESCRIBE
Z predicates.
=ENDDOC

=DOC
val €fmt_declaration› : PP_FMT_INFO -> DECLARATION -> unit;
val €fmt_statement› : PP_FMT_INFO -> STATEMENT -> unit;
=DESCRIBE
Declarations, statements and blocks
=ENDDOC

=DOC 
val €fmt_kslot_compilation_unit› :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT ->
	unit
val €fmt_kslot_compilation_unit_list› :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT list ->
	unit
=DESCRIBE
Compilation units.
=ENDDOC

=DOC
val €fmt_replaced_by_comp› :
	PP_FMT_INFO -> REPLACED_BY_COMP -> unit 
val €fmt_replaced_by_private_part›:
	PP_FMT_INFO -> REPLACED_BY_PRIVATE_PART ->
	unit
val €fmt_replaced_by_visible_part› :
	PP_FMT_INFO -> REPLACED_BY_VISIBLE_PART ->
	unit
val €fmt_replaced_by_decl› :
	PP_FMT_INFO -> REPLACED_BY_DECL -> unit 
val €fmt_refined_by› :
	PP_FMT_INFO -> REFINED_BY -> unit 
val €fmt_replaced_by› :
	PP_FMT_INFO -> REFINED_BY -> unit 
val €fmt_web_clause› :
	PP_FMT_INFO -> WEB_CLAUSE -> unit 
=DESCRIBE
Web clauses.
=ENDDOC


\section{SPARK PROGRAM OUTPUT}
=DOC
val €format_web_clause› :
	(LABEL -> REPLACEMENT OPT) OPT -> WEB_CLAUSE -> unit   
val €print_web_clause› : WEB_CLAUSE -> unit
val €print_spark_program› : unit -> unit
val €output_spark_program› : {out_file : string} -> unit
val €strings_from_fmt› : (PP_FMT_INFO -> 'a -> unit) -> 'a -> string list 
=DESCRIBE
The function $print\_spark\_program$ generates and prints the SPARK program from the contents of the Compliance Tool environment. The SPARK program is created by filling in the K-Slots and specification statements in a literate script with their expansions and printing the output onto the screen in SPARK syntax such that it could be subsequently compiled using an Ada compiler.

$output\_spark\_program$ does the same as $print\_spark\_program$ but allows the user to specify a file to which the program will then be written.
Both of these functions cause a number of checks to be imposed.

$strings\_from\_fmt$ takes any of the previously mentioned $fmt$ functions
in the signature, and an appropriate syntactic structure.
It returns a list of strings that are the SPARK fragment represented by the
structure, with the list of strings representing a list of unindented lines, broken
at logical line boundaries (e.g. at semi-colons at the end of statements).
=SEEALSO
$cn\_automatic\_line\_splitting$ for an integer control that governs
the output line lengths.
=FAILURE
510001	The following name clashes have been detected in the SPARK program:
510002	?0 clashes with ?1
510003	Name clashes detected in the SPARK program
510004	Invalid control value "?0" not one of "upper", "lower" or "as input"
510005	VC soundness checks have failed
510999	Internal error: unexpected language construct: ?0
=ENDDOC

=DOC
(* €cn_automatic_line_splitting› - integer control declared by new_int_control, default 80 *)
=DESCRIBE
This control sets the maximum line length for output from 
$format\_web\_clause$,  
$print\_web\_clause$,
$print\_spark\_program$, and
$output\_spark\_program$.
These programs always split lines at logical break points (e.g. at semi-colons at the end of statements).
However, they will also split lines that are longer than the value set by this control
(if it is non-zero), chosing to split at a syntactically allowed location.
If the control is set to 0 then no automatic line-splitting is done
(except in Z terms, which will be split during formatting to match the current line length setting).
The default value of the control is 80.
=ENDDOC
=DOC
(* €cn_spark_syntax_warnings› - integer control declared by new_flag; default false *)
=DESCRIBE
Thiis flag controls whether or not Ada comments are to be inserted in the output
produced by the functions
$format\_web\_clause$,  
$print\_web\_clause$,
$print\_spark\_program$, and
$output\_spark\_program$
to warn about uses of Ada syntax that is not in the SPARK subset.
Note that the checks are only made on the Ada concrete syntax, ignoring comments, there is
no checking that required SPARK annotations are present or correct and no semantic
checks are made.
=FAILURE
510100	-- WARNING: ?0
510101	Subtype indications with constraints are not allowed in object declarations in SPARK
510102	Named number declarations are not allowed in SPARK
510103	Discriminant parts are not allowed in SPARK
510104	Discriminant constraints are not allowed in SPARK
510105	Fixed point constraints are not allowed in subtype declarations in SPARK
510106	Floating point constraints are not allowed in subtype declarations in SPARK
510107	Attributes are not allowed as range constraints in integer type declarations in SPARK
510108	Attributes are not allowed as range constraints in real type declarations in SPARK
510109	Subtype indications with constraints are not allowed as array component subtypes in SPARK
510110	Subtype indications with constraints are not allowed in index constraints in SPARK
510111	Subtype indications with constraints are not allowed as record component subtypes in SPARK
510112	Renaming declarations occurring after other kinds of declarations are not allowed in SPARK
510113	Use clauses are not allowed in SPARK
510114	Aggregates that are enclosed in qualified expression are not allowed in SPARK
510115	Ranges without subtype marks are not allowed as loop parameter specifications in SPARK
510116	Block statements are not allowed in SPARK
510117	Exit statements with loop names are not allowed in SPARK
510118	Return statements with no return expression are not allowed in SPARK
510119	Default parameters are not allowed in SPARK
510120	Renaming declarations of this form are not allowed in SPARK
510121	Auxiliary expressions are not allowed in Ada
=ENDDOC
\subsection{Epilogue}
=SML
end (* signature CNSparkOutput *);
=TEX

\section{TEST POLICY}
The functions in this document do not lend themselves to the module test framework (since their correct operation depends on the contents of output files).
The integration tests described in \cite{ISS/HAT/DAZ/HLD503} will exercise these functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



