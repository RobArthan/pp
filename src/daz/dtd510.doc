=IGN
********************************************************************************
dtd510.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% dtd510.doc %Z% $Date: 2003/05/27 16:14:24 $ $Revision: 1.51 $ $RCSfile: dtd510.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: SPARK Output Function} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD510} %% Mandatory field
\def\SCCSversion{$Revision: 1.51 $%
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date: 2003/05/27 16:14:24 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{D.J.~King & HAT Team}
\TPPabstract{
This document contains the detailed design for the DAZ SPARK Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DERA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.16] Initial Drafts.
\item[Issue 1.17 (13th October 1994)] Added auxiliary expression support.
\item[Issue 1.18 (14th October 1994)] Removed variant records from the implementation.
\item[Issue 1.19 (3rd November 1994)] Changed SUBUNIT to COMP\_SUBUNIT.
\item[Issue 1.20 (14th November 1994)] rationalised signature wrapping.
\item[Issues 1.21-1.22] Minor corrections before document inspection.
\item[Issue 1.23] Reworked according to desk check report 019.
\item[Issue 1.24] Updated the distribution list.
\item[Issue 1.25] Corrected test policy statement.
\item[Issue 1.26] Tidy-up.
\item[Issue 1.27] Tidier error reporting.
\item[Issue 1.28] Corrected {\LaTeX} error.
\item[Issue 1.29] Reissue to match changes in version 1.61 of implementation doecument,
changing from string lists to direct output.
Many functions have been removed as they are not used externally to the structure.
\item[Issue 1.30] Revealed more functions required elsewhere.
\item[Issue 1.31] Clarified use of $cn\_automatic\_line\_splitting$.
\item[Issue 1.32] Changes for NJML port.
\item[Issue 1.34] Added control over case of keywords.
\item[Issue 1.35] Removed local declarations for Poly/ML port.
\item[Issue 1.36] New error message.
\item[Issue 1.38] Removed use of ICL logo font.
\item[Issue 1.39] Exposed interfaces needed by the VC browser.
\item[Issue 1.40] Copyright and banner updates for open source release.
\item[Issue 1.41, 1.42] DAZ-specific updates to banner for open source release
\item[Issue 1.43] Uniform treatment of block statements.
\item[Issues 1.44--1.49] R0055: warnings for non-SPARK constructs.
\item[Issue 1.50] R0092: improved generality of the pretty-printing API.
\item[Issue 1.51] Addressed comments on documentation from QinetiQ.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the Compliance Tool SPARK Output Function and responds to the high level design in \cite{ISS/HAT/DAZ/HLD503}.

The implementation is in \cite{ISS/HAT/DAZ/IMP510}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This detailed design document contains one signature, $CNSparkOutput$.  This provides facilities for printing out the various categories of abstract syntax.  None of the functions in it are intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} describes the top level functions which use this signature.

\subsubsection{Dependencies}

The functions in $CNSparkOutput$ depend on data types introduced in the structure $CNTypes$ which is defined in \cite{ISS/HAT/DAZ/DTD502}.

\subsection{Compliance}

The requirement is that the functions in this document support the correct printing of Spark programs which can be compiled using an Ada compiler.

\section{PRINTING ABSTRACT SYNTAX}

\subsection{The Signature}
=DOC
signature €CNSparkOutput› = sig
=DESCRIBE
This signature contains functions which format abstract syntax into strings. It is used by the functions in the signature $SPARKOutput$ to print entire SPARK programs from the compliance tool environment when compliance notation has been entered.
=USES
None of the functions in this signature are intended to be called directly by the user.
=ENDDOC
As in other signatures, local declarations would be nicer than includes
if they were allowed here:
=SML
include (* CNTypes *) CNTypes1;
=TEX
\subsection{Functions to Print Abstract Syntax}
=DOC
type €PP_FMT_INFO›
	(* = {outf : string -> unit, fmt_repl : (LABEL -> unit) OPT} *);
val €make_output_fun› : outstream -> string -> unit;
val €make_output_fun1› : (string -> unit) -> string -> unit;
=DESCRIBE
{\it PP\_FMT\_INFO}
is the type used to pass formatting and output information to the
various functions that format Ada abstract syntax.

{\it make\_output\_fun} may be used to derive a suitable value for the
{\it outf} component of a {\it PP\_FMT\_INFO} from an output stream.
The resulting function will indent the output according to the nesting
of Ada constructs and will break long lines as guided by the integer
control {\it cn\_automatic\_line\_splitting}.
{\it make\_output\_fun1} is similarly but uses a function supplied as an argument
to do the actual output of a string, e.g., to assemble it in a buffer in memory.
=ENDDOC

=DOC

=DOC
val €fmt_spec› : PP_FMT_INFO ->  (bool * SPEC) -> unit 
=DESCRIBE
Formatting a spec statement.
The boolean parameter indicates whether or not the spec statement is an assertion.
=ENDDOC

=DOC
val €fmt_var_decl› :
	PP_FMT_INFO -> VAR_DECL -> unit 
val €fmt_si_var_decl› :
	int -> PP_FMT_INFO -> SI_VAR_DECL -> unit 
val €fmt_var_decl_list› :
	PP_FMT_INFO -> VAR_DECL list -> unit 
val €fmt_si_var_decl_list› :
	int -> PP_FMT_INFO -> SI_VAR_DECL list -> unit 
=DESCRIBE
Formatting functions for variable declarations in the basic and derived abstract syntax.
These may also be used to format record component declarations.

The first parameter to {\it fmt\_si\_var\_decl} and {\it fmt\_si\_var\_decl\_list}
is a message number used to determine which message to produce if
{\it cn\_spark\_syntax\_warnings} is set true and the declaration contains a
non-SPARK construct. The parameter should be 510101 if the argument
is a variable declaration and 510112 if its a record component declaration. 

=ENDDOC

=DOC 
val €fmt_basic_decl› :
	PP_FMT_INFO -> BASIC_DECL -> unit 
val €fmt_basic_decl_list› :
	PP_FMT_INFO -> BASIC_DECL list -> unit
val €fmt_si_basic_decl› :
	PP_FMT_INFO -> SI_BASIC_DECL -> unit 
val €fmt_si_basic_decl_list› :
	PP_FMT_INFO -> SI_BASIC_DECL list -> unit
=DESCRIBE
Formattting functions for basic declarations in the basic and derived abstract syntax.
=ENDDOC

=DOC 
val €fmt_z_pred› :
	PP_FMT_INFO -> Z_PRED -> unit 
=DESCRIBE
Z predicates.
=ENDDOC

=DOC
val €fmt_declaration› : PP_FMT_INFO -> DECLARATION -> unit;
val €fmt_statement› : PP_FMT_INFO -> STATEMENT -> unit;
=DESCRIBE
Declarations, statements and blocks
=ENDDOC

=DOC 
val €fmt_kslot_compilation_unit› :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT ->
	unit
val €fmt_kslot_compilation_unit_list› :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT list ->
	unit
=DESCRIBE
Compilation units.
=ENDDOC

=DOC
val €fmt_replaced_by_comp› :
	PP_FMT_INFO -> REPLACED_BY_COMP -> unit 
val €fmt_replaced_by_private_part›:
	PP_FMT_INFO -> REPLACED_BY_PRIVATE_PART ->
	unit
val €fmt_replaced_by_visible_part› :
	PP_FMT_INFO -> REPLACED_BY_VISIBLE_PART ->
	unit
val €fmt_replaced_by_decl› :
	PP_FMT_INFO -> REPLACED_BY_DECL -> unit 
val €fmt_refined_by› :
	PP_FMT_INFO -> REFINED_BY -> unit 
val €fmt_replaced_by› :
	PP_FMT_INFO -> REFINED_BY -> unit 
val €fmt_web_clause› :
	PP_FMT_INFO -> WEB_CLAUSE -> unit 
=DESCRIBE
Web clauses.
=ENDDOC


\section{SPARK PROGRAM OUTPUT}
=DOC
val €format_web_clause› :
	(LABEL -> REPLACEMENT OPT) OPT -> WEB_CLAUSE -> unit   
val €print_web_clause› : WEB_CLAUSE -> unit
val €print_spark_program› : unit -> unit
val €output_spark_program› : {out_file : string} -> unit
val €strings_from_fmt› : (PP_FMT_INFO -> 'a -> unit) -> 'a -> string list 
val €strings_from_fmt1› : (PP_FMT_INFO -> 'a -> unit) -> 'a -> string list 
=DESCRIBE
The function $print\_spark\_program$ generates and prints the SPARK program from the contents of the Compliance Tool environment. The SPARK program is created by filling in the K-Slots and specification statements in a literate script with their expansions and printing the output onto the screen in SPARK syntax such that it could be subsequently compiled using an Ada compiler.

$output\_spark\_program$ does the same as $print\_spark\_program$ but allows the user to specify a file to which the program will then be written.
Both of these functions cause a number of checks to be imposed.

$strings\_from\_fmt$ takes any of the previously mentioned $fmt$ functions
in the signature, and an appropriate syntactic structure.
It returns a list of strings that are the SPARK fragment represented by the
structure, with the list of strings representing a list of unindented lines, broken
at logical line boundaries (e.g. at semi-colons at the end of statements).

{\it strings\_from\_fmt1} is like {\it strings\_from\_fmt} but with indentation reflecting
the nesting of the syntactic structure and with  long lines  broken as guided by the integer
control {\it cn\_automatic\_line\_splitting}.

=SEEALSO
$cn\_automatic\_line\_splitting$ for an integer control that governs
the output line lengths.
=FAILURE
510001	The following name clashes have been detected in the SPARK program:
510002	?0 clashes with ?1
510003	Name clashes detected in the SPARK program
510004	Invalid control value "?0" not one of "upper", "lower" or "as input"
510005	VC soundness checks have failed
510006	*** SOUNDNESS CHECK FAILURE : ?2 [?1.?0]
510999	Internal error: unexpected language construct: ?0
=ENDDOC

=DOC
(* €cn_automatic_line_splitting› - integer control declared by new_int_control, default 80 *)
(* €cn_tab_width› - integer control declared by new_int_control, default 2 *)
(* €cn_left_margin› - integer control declared by new_int_control, default 0 *)
=DESCRIBE
These controls define parameters for output from 
$format\_web\_clause$,  
$print\_web\_clause$,
$print\_spark\_program$,
$output\_spark\_program$ and
{\it strings\_from\_fmt1}.

These functions always split lines at logical break points (e.g. at semicolons at the end of statements).
However, they will also split lines that are longer than the value set by the control
{\it cn\_automatic\_line\_spliting} 
(if it is non-zero), chosing to split at a syntactically allowed location.
If the control is set to 0 then no automatic line-splitting is done
(except in Z terms, which will be split during formatting to match the current line length setting).
The default value of the control is 80.

{\it cn\_tab\_width} controls the number of spaces used to indent a nested structure
such as the statement in the then part of an if statement. {\it cn\_left\_margin} specifies
an indentation to be applied on every line and is given in the units specified by {\it cn\_tab\_width}.
E.g., if {\it cn\_tab\_width} is 2 and {\it cn\_left\_margin} is 4, every line will be indented by at
least 8 spaces, and each nested structure will be indented 2 spaces more than the structure
immediately containing it.
=ENDDOC
=DOC
(* €cn_spark_syntax_warnings› - integer control declared by new_flag; default false *)
=DESCRIBE
Thiis flag controls whether or not Ada comments are to be inserted in the output
produced by the functions
$format\_web\_clause$,  
$print\_web\_clause$,
$print\_spark\_program$, and
$output\_spark\_program$
to warn about uses of Ada syntax that is not in the SPARK subset.
Note that the checks are only made on the Ada concrete syntax, ignoring comments, there is
no checking that required SPARK annotations are present or correct and no context-sensitive
checks are made.
The checks are based on the syntax given in John Barnes' book {\it High Integrity Ada The SPARK Approach}
ISBN 0-201-17517-7.
=ENDDOC
=FAILURE
510100	-- WARNING: ?0
510101	Subtype indications with constraints are not allowed in variable declarations in SPARK
510102	Subtype indications with constraints are not allowed in constant declarations in SPARK
510104	Discriminant parts are not allowed in SPARK
510105	Fixed point constraints are not allowed in subtype declarations in SPARK
510106	Floating point constraints are not allowed in subtype declarations in SPARK
510107	Attributes are not allowed as range constraints in integer type declarations
510108	Attributes are not allowed as range constraints in real type declarations
510110	Subtype indications with constraints are not allowed as array component subtypes in SPARK
510111	Ranges and subtype indications with constraints are not allowed as index constraints in SPARK
510112	Subtype indications with constraints are not allowed as record component subtypes in SPARK
510113	Renaming declarations occurring after other kinds of declaration are not allowed in SPARK
510114	Use clauses are not allowed in SPARK
510115	Aggregates that are not enclosed in a qualified expression are not allowed in SPARK
510116	Ranges without subtype marks are not allowed as loop parameter specifications in SPARK
510117	Block statements are not allowed in SPARK
510118	Exit statements with loop names are not allowed in SPARK
510119	Return statements with no return expression are not allowed in SPARK
510120	Default parameters are not allowed in SPARK
510121	Renaming declarations of this form are not allowed in SPARK
510122	Auxiliary expressions are not allowed in Ada
=TEX
\subsection{Epilogue}
=SML
end (* signature CNSparkOutput *);
=TEX

\section{TEST POLICY}
The functions in this document do not lend themselves to the module test framework (since their correct operation depends on the contents of output files).
The integration tests described in \cite{ISS/HAT/DAZ/HLD503} will exercise these functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



