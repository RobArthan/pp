% dtd510.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: SPARK Output Function} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD510} %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{D.J.~King & HAT Team}
\TPPabstract{
This document contains the detailed design for the DAZ SPARK Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	C.~O'Halloran, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.15] Initial Drafts.
\item[Issue 1.17 (13 October 1994)] Added auxiliary expression support.

\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Compliance Tool SPARK Output Function and responds to the high level design in \cite{ISS/HAT/DAZ/HLD503}.

The implementation is in \cite{ISS/HAT/DAZ/IMP510}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This detailed design document contains two signatures. The first is $CNSparkOutput$ which provides facilities for printing out the various categories of abstract syntax. It is not intended to be called by the user. The second signature is $SPARKOutput$ and this provides a user with access to the functions which output the SPARK program, either onto the screen or into a file.

%\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{PRINTING ABSTRACT SYNTAX}

\subsection{The Signature}
=DOC
signature ÛCNSparkOutputÝ = sig
local
	open CNTypes;
in
=DESCRIBE
This signature contains functions which format abstract syntax into strings. It is used by the functions in the signature $SPARKOutput$ to print entire SPARK programs from the compliance tool environment when compliance notation has been entered.
=USES
The functions in this signature are not intended to be called directly by the user.
=ENDDOC

\subsection{Functions to Print Abstract Syntax}
=DOC
val ÛPPTabSizeÝ : int ref 
type ÛPP_FMT_INFOÝ
val Ûset_PPTab_sizeÝ : int -> unit 
val Ûget_PPTab_sizeÝ : unit -> int 
val Ûfmt_spacesÝ : int -> string 
val Ûfmt_tabsÝ : int -> string
val Ûfmt_info_string_listÝ :
	(PP_FMT_INFO * string) list -> string   

=DESCRIBE
These functions deal with the low-level output of characters.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_idÝ : ID -> string
val Ûfmt_tmarkÝ : TMARK -> string 
val Ûfmt_termÝ : TERM -> string 
val Ûfmt_labelÝ : LABEL -> string 
val Ûfmt_unary_opÝ : UNARY_OP -> string 
val Ûfmt_binary_opÝ : BIN_OP -> string 
val Ûfmt_modeÝ : MODE -> string 
val Ûfmt_loop_directionÝ : LOOP_DIRECTION -> string 
val Ûfmt_operator_symbolÝ : OPERATOR_SYMBOL -> OPERATOR_SYMBOL
val Ûfmt_z_predÝ : Z_PRED -> string 
val Ûfmt_z_expÝ : Z_EXP -> string 
val Ûfmt_z_idÝ : Z_ID -> string 
val Ûfmt_attribÝ : ATTRIB -> string 
val Ûfmt_int_litÝ : INT_LIT -> string 
=DESCRIBE
These functions print leaves of the abstract syntax; they don't call any others.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_id_listÝ : ID list -> string 
val Ûfmt_tmark_listÝ : TMARK list -> string
=DESCRIBE
Lists of identifiers
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_rangelohiÝ : EXP RANGELOHI -> string
val Ûfmt_rangeÝ : EXP RANGE -> string
val Ûfmt_discrete_range_constrainedÝ :
	EXP DISCRETE_RANGE_CONSTRAINED -> string
val Ûfmt_discrete_rangeÝ : DISCRETE_RANGE -> string
val Ûfmt_agg_choiceÝ : AGG_CHOICE -> string
val Ûfmt_agg_choice_listÝ : AGG_CHOICE list -> string
val Ûfmt_named_assocÝ : (AGG_CHOICE, EXP) NAMED_ASSOC -> string
val Ûfmt_named_assoc_listÝ :
	(AGG_CHOICE, EXP) NAMED_ASSOC list -> string
val Ûfmt_othersÝ : EXP OTHERS -> string
val Ûfmt_agg_posÝ : EXP AGG_POS -> string
val Ûfmt_agg_pos_othersÝ : EXP AGG_POS_OTHERS -> string
val Ûfmt_agg_othersÝ : EXP AGG_OTHERS -> string
val Ûfmt_agg_namedÝ : (AGG_CHOICE, EXP) AGG_NAMED -> string
val Ûfmt_agg_named_othersÝ :
	(AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> string
val Ûfmt_unary_expÝ : EXP UNARY_EXP -> string
val Ûfmt_bin_expÝ : EXP BIN_EXP -> string
val Ûfmt_attrib_desigÝ : ATTRIB_DESIG -> string
val Ûfmt_attributeÝ : (EXP, ATTRIB_DESIG) ATTRIBUTE -> string
val Ûfmt_indexed_compÝ : EXP INDEXED_COMP -> string
val Ûfmt_selected_compÝ : EXP SELECTED_COMP -> string
val Ûfmt_qualified_expressionÝ : EXP QUALIFIED_EXPRESSION -> string
val Ûfmt_expÝ : EXP -> string
val Ûfmt_exp_listÝ : EXP list -> string
val Ûfmt_static_expÝ : STATIC_EXP -> string 
val Ûfmt_static_rangelohiÝ : STATIC_EXP RANGELOHI -> string 
val Ûfmt_static_rangeÝ : STATIC_EXP RANGE -> string 
val Ûfmt_condÝ : COND -> string 
val Ûfmt_actualsÝ : (AGG_CHOICE, EXP) ACTUALS -> string 
=DESCRIBE
Functions dealing with expressions.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_specÝ : SPEC -> string 
val Ûfmt_proc_callÝ : (AGG_CHOICE, EXP) PROC_CALL -> string 
=DESCRIBE
A couple of minor functions before we do statements.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_k_slotÝ : PP_FMT_INFO -> K_SLOT -> (PP_FMT_INFO * string) list
val Ûfmt_assignÝ : PP_FMT_INFO -> ASSIGN -> (PP_FMT_INFO * string) list
val Ûfmt_spec_no_ivarsÝ :
	PP_FMT_INFO -> SPEC_NO_IVARS -> (PP_FMT_INFO * string) list 
val Ûfmt_exit_whenÝ :
	PP_FMT_INFO -> EXIT_WHEN -> (PP_FMT_INFO * string) list 
val Ûfmt_returnÝ :
	PP_FMT_INFO -> RETURN -> (PP_FMT_INFO * string) list
val Ûfmt_proc_call_no_ivarsÝ :
	PP_FMT_INFO -> (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS ->
	(PP_FMT_INFO * string) list
val Ûfmt_elsifÝ : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
val Ûfmt_if_then_elseÝ :
	PP_FMT_INFO -> STMT IF_THEN_ELSE -> (PP_FMT_INFO * string) list
val Ûfmt_case_choiceÝ : CASE_CHOICE -> string
val Ûfmt_case_choice_listÝ : CASE_CHOICE list -> string
val Ûfmt_case_altÝ :
	PP_FMT_INFO -> STMT CASE_ALTERNATIVE ->
	(PP_FMT_INFO * string) list
val Ûfmt_case_alt_listÝ :
	PP_FMT_INFO -> STMT CASE_ALTERNATIVE list ->
	(PP_FMT_INFO * string) list
val Ûfmt_caseÝ :
	PP_FMT_INFO -> STMT CASE -> (PP_FMT_INFO * string) list
val Ûfmt_unnamed_loopÝ :
	PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_named_loopÝ :
	PP_FMT_INFO -> STMT NAMED_LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_loop_bodyÝ :
	PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_whileÝ :
	PP_FMT_INFO -> STMT WHILE -> (PP_FMT_INFO * string) list
val Ûfmt_for_staticÝ :
	PP_FMT_INFO -> STMT FOR_STATIC -> (PP_FMT_INFO * string) list
val Ûfmt_for_tmarkÝ :
	PP_FMT_INFO -> STMT FOR_TMARK -> (PP_FMT_INFO * string) list
val Ûfmt_stmtÝ : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
=DESCRIBE
Functions dealing with statements.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_log_conÝ :
	PP_FMT_INFO -> (LOG_CON * STMT) -> (PP_FMT_INFO * string) list 
=DESCRIBE
Logical constructs.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_statementÝ :
	PP_FMT_INFO -> STATEMENT -> (PP_FMT_INFO * string) list 
=DESCRIBE
Top level statements.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_var_declÝ :
	PP_FMT_INFO -> VAR_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_var_decl_listÝ :
	PP_FMT_INFO -> VAR_DECL list -> (PP_FMT_INFO * string) list 
=DESCRIBE
Variable declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_const_declÝ :
	PP_FMT_INFO -> EXP CONST_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_deferred_const_declÝ :
	PP_FMT_INFO -> DEFERRED_CONST_DECL ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Constant and Deferred constant declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_floating_point_constraintÝ : EXP FLOATING_POINT_CONSTRAINT -> string
val Ûfmt_floating_type_defÝ :
	PP_FMT_INFO -> ID * EXP FLOATING_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Floating point types.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_fixed_point_constraintÝ : EXP FIXED_POINT_CONSTRAINT -> string 
val Ûfmt_fixed_type_defÝ :
	PP_FMT_INFO -> ID * EXP FIXED_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Fixed point types.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_enum_type_defÝ :
	PP_FMT_INFO -> ID * ENUM_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Enumerated types.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_array_defÝ :
	PP_FMT_INFO -> ID * ARRAY_DEF ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Array types.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_record_type_defÝ :
	PP_FMT_INFO ->
	ID * RECORD_TYPE_DEF ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Record types.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_type_defÝ :
	PP_FMT_INFO -> ID * TYPE_DEF ->
	(PP_FMT_INFO * string) list 
val Ûfmt_type_declÝ :
	PP_FMT_INFO -> TYPE_DEF TYPE_DECL -> (PP_FMT_INFO * string) list 
=DESCRIBE
Type declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_constraintÝ : CONSTRAINT -> string 
val Ûfmt_sub_indÝ : CONSTRAINT SUB_IND -> string 
val Ûfmt_subtype_declÝ :
	PP_FMT_INFO -> CONSTRAINT SUBTYPE_DECL ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Subtype declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_private_type_declÝ :
	PP_FMT_INFO -> PRIVATE_TYPE_DECL -> (PP_FMT_INFO * string) list
=DESCRIBE
Private type declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_basic_declÝ :
	PP_FMT_INFO -> BASIC_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_basic_decl_listÝ :
	PP_FMT_INFO -> BASIC_DECL list -> (PP_FMT_INFO * string) list
=DESCRIBE
Basic declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_parameter_specificationÝ : PARAMETER_SPECIFICATION -> string 
val Ûfmt_parameter_specification_list1Ý :
	PARAMETER_SPECIFICATION list -> string
val Ûfmt_parameter_specification_listÝ :
	PARAMETER_SPECIFICATION list -> string
=DESCRIBE
Procedure and Function parameter specifications.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_procedure_specificationÝ :
	PP_FMT_INFO -> PROCEDURE_SPECIFICATION ->
	(PP_FMT_INFO * string) list
val Ûfmt_function_specificationÝ :
	PP_FMT_INFO -> FUNCTION_SPECIFICATION ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Procedures and Function specifications.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_subprogram_specificationÝ :
	PP_FMT_INFO -> SUBPROGRAM_SPECIFICATION ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Subprograms
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_function_renamingÝ :
	PP_FMT_INFO -> FUNCTION_RENAMING -> (PP_FMT_INFO * string) list
val Ûfmt_subprogram_renamingÝ :
	PP_FMT_INFO -> SUBPROGRAM_RENAMING ->
	(PP_FMT_INFO * string) list 
val Ûfmt_renaming_declarationÝ :
	PP_FMT_INFO -> RENAMING_DECLARATION ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Renaming declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_component_clauseÝ :
	PP_FMT_INFO -> COMPONENT_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_component_clause_listÝ :
	PP_FMT_INFO -> COMPONENT_CLAUSE list ->
	(PP_FMT_INFO * string) list 
val Ûfmt_length_clauseÝ :
	PP_FMT_INFO -> LENGTH_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_enumeration_representation_clauseÝ :
	PP_FMT_INFO -> ENUMERATION_REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list
val Ûfmt_record_representation_clauseÝ :
	PP_FMT_INFO -> RECORD_REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list
val Ûfmt_address_clauseÝ :
	PP_FMT_INFO -> ADDRESS_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_representation_clauseÝ :
	PP_FMT_INFO -> REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Representation clauses.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_procedure_declarationÝ :
	PP_FMT_INFO -> PROCEDURE_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_function_declarationÝ :
	PP_FMT_INFO -> FUNCTION_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_procedure_stubÝ :
	PP_FMT_INFO -> PROCEDURE_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_function_stubÝ :
	PP_FMT_INFO -> FUNCTION_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_auxiliaryÝ :
	PP_FMT_INFO -> AUX_VAR -> (PP_FMT_INFO * string) list 
val Ûfmt_usingÝ :
	PP_FMT_INFO -> USING_DEC -> (PP_FMT_INFO * string) list 
val Ûfmt_package_stubÝ :
	PP_FMT_INFO -> ID -> (PP_FMT_INFO * string) list 
val Ûfmt_package_declarationÝ :
	PP_FMT_INFO -> DECLARATION PACKAGE_DECLARATION ->
	(PP_FMT_INFO * string) list
val Ûfmt_declarationÝ :
	PP_FMT_INFO -> DECLARATION -> (PP_FMT_INFO * string) list
val Ûfmt_declaration_listÝ :
	PP_FMT_INFO -> DECLARATION list -> (PP_FMT_INFO * string) list
val Ûfmt_procedure_bodyÝ :
	PP_FMT_INFO -> DECLARATION PROCEDURE_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_function_bodyÝ :
	PP_FMT_INFO -> DECLARATION FUNCTION_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_package_bodyÝ :
	PP_FMT_INFO -> DECLARATION PACKAGE_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_proper_bodyÝ :
	PP_FMT_INFO -> PROPER_BODY -> (PP_FMT_INFO * string) list
=DESCRIBE
Declarations.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_compilation_subunitÝ :
	PP_FMT_INFO -> COMP_SUBUNIT -> (PP_FMT_INFO * string) list
=DESCRIBE
Compliation subunits.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC 
val Ûfmt_context_clauseÝ :
	PP_FMT_INFO -> ID list -> (PP_FMT_INFO * string) list 
val Ûfmt_compilation_unitÝ :
	PP_FMT_INFO -> COMPILATION_UNIT -> (PP_FMT_INFO * string) list 
val Ûfmt_context_compilation_unitÝ :
	PP_FMT_INFO -> CONTEXT_COMPILATION_UNIT ->
	(PP_FMT_INFO * string) list
val Ûfmt_kslot_compilation_unitÝ :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT ->
	(PP_FMT_INFO * string) list
val Ûfmt_kslot_compilation_unit_listÝ :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT list ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Compilation units.
=USES
Not intended to be called by the user directly.
=ENDDOC

=DOC
val Ûfmt_replaced_by_compÝ :
	PP_FMT_INFO -> REPLACED_BY_COMP -> (PP_FMT_INFO * string) list 
val Ûfmt_replaced_by_private_partÝ:
	PP_FMT_INFO -> REPLACED_BY_PRIVATE_PART ->
	(PP_FMT_INFO * string) list
val Ûfmt_replaced_by_visible_partÝ :
	PP_FMT_INFO -> REPLACED_BY_VISIBLE_PART ->
	(PP_FMT_INFO * string) list
val Ûfmt_replaced_by_declÝ :
	PP_FMT_INFO -> REPLACED_BY_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_refined_byÝ :
	PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val Ûfmt_replaced_byÝ :
	PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val Ûfmt_web_clauseÝ :
	PP_FMT_INFO -> WEB_CLAUSE -> (PP_FMT_INFO * string) list 
=DESCRIBE
Web clauses
=USES
Not intended to be called by the user directly.
=ENDDOC

\section{SPARK PROGRAM OUTPUT}
=DOC
val Ûformat_web_clauseÝ :
	PP_FMT_INFO -> WEB_CLAUSE -> unit   
val Ûprint_web_clauseÝ : WEB_CLAUSE -> unit
val Ûprint_spark_programÝ : unit -> unit
val Ûoutput_spark_programÝ : {out_file : string} -> unit
=DESCRIBE
The function $print\_spark\_program$ generates and prints the SPARK program from the contents of the Compliance Tool environment. The SPARK program is created by filling in the k-slots and specification statements in a literate script with their expansions and printing the output onto the screen in SPARK syntax such that it could be subsequently compiled using an Ada compiler.

$output\_spark\_program$ does the same as $print\_spark\_program$ but allows the user to specify a file to which the program will then be written.
=ENDDOC

\subsection{Epilogue}
=SML
end (* local ... in *);
end (* signature CNSparkOutput *);
=TEX

\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}. The test module
is \cite{ISS/HAT/DAZ/MDT503}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



