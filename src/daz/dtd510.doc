% dtd510.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: SPARK Output Function} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD510} %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the DAZ SPARK Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}
\item[Issue 1.1, \FormatDate{94/03/28}] Initial Draft.
\item[Issue 1.2, \FormatDate{94/03/28}] Added signature information.
\item[Issue 1.3, \FormatDate{94/03/29}] Minor bug fixes.
\item[Issue 1.4, \FormatDate{94/03/30}] Added fmt\_variant\_alt\_list.
\item[Issue 1.5, \FormatDate{94/03/30}] Changed types of ranges.
\item[Issue 1.6, \FormatDate{94/04/07}] Change so now returns a (inxt * string) list.
\item[Issue 1.7, \FormatDate{94/04/08}]
Formatting routines now take FmtInfo as an argument rather than as part
of a pair.
\item[Issues 1.8 to 1.11, \FormatDate{94/06/28}]
Added print_spark_program.
\item[Issue 1.12, \FormatDate{94/07/04}]
Added output_spark_program, output_spark_program1
 
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the DAZ SPARK Output Function.
The implementation is in \cite{ISS/HAT/DAZ/IMP510}.


\subsection{Introduction}

\subsubsection{Purpose and Background}

\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{CN PRETTY PRINTER}

\subsection{Preamble}
=DOC
signature €CNPrettyPrinterSupport› = sig
local
	open CNTypes;
in
=DESCRIBE
This is the signature for the structure containing the output function for SPARK.
=ENDDOC

\section{SPARK Output Function}
=DOC
val €PPTabSize› : int ref 
type €PP_FMT_INFO›
val €set_PPTab_size› : int -> unit 
val €get_PPTab_size› : unit -> int 
val €fmt_spaces› : int -> string 
val €fmt_tabs› : int -> string
val €fmt_info_string_list› : (PP_FMT_INFO * string) list -> string   

=DESCRIBE
These functions deal with the low-level output of characters.
=ENDDOC

=DOC
val €fmt_id› : ID -> string
val €fmt_tmark› : TMARK -> string 
val €fmt_term› : TERM -> string 
val €fmt_label› : LABEL -> string 
val €fmt_unary_op› : UNARY_OP -> string 
val €fmt_binary_op› : BIN_OP -> string 
val €fmt_mode› : MODE -> string 
val €fmt_loop_direction› : LOOP_DIRECTION -> string 
val €fmt_operator_symbol› : OPERATOR_SYMBOL -> OPERATOR_SYMBOL
=DESCRIBE
These are the leaf functions, they don't call any others.
=ENDDOC

=DOC 
val €fmt_id_list› : ID list -> string 
val €fmt_tmark_list› : TMARK list -> string
=DESCRIBE
Lists of leaf functions.
=ENDDOC

=DOC 
val €fmt_z_pred› : Z_PRED -> string 
val €fmt_z_exp› : Z_EXP -> string 
val €fmt_z_id› : Z_ID -> string 
val €fmt_attrib› : ATTRIB -> string 
val €fmt_int_lit› : INT_LIT -> string 
=DESCRIBE
Equivalences to leaf functions.
=ENDDOC

=DOC
val €fmt_rangelohi› : EXP RANGELOHI -> string
val €fmt_range› : EXP RANGE -> string
val €fmt_discrete_range_constrained› : EXP DISCRETE_RANGE_CONSTRAINED -> string
val €fmt_discrete_range› : DISCRETE_RANGE -> string
val €fmt_agg_choice› : AGG_CHOICE -> string
val €fmt_agg_choice_list› : AGG_CHOICE list -> string
val €fmt_named_assoc› : (AGG_CHOICE, EXP) NAMED_ASSOC -> string
val €fmt_named_assoc_list› : (AGG_CHOICE, EXP) NAMED_ASSOC list -> string
val €fmt_others› : EXP OTHERS -> string
val €fmt_agg_pos› : EXP AGG_POS -> string
val €fmt_agg_pos_others› : EXP AGG_POS_OTHERS -> string
val €fmt_agg_others› : EXP AGG_OTHERS -> string
val €fmt_agg_named› : (AGG_CHOICE, EXP) AGG_NAMED -> string
val €fmt_agg_named_others› : (AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> string
(* val €fmt_rec_agg_named› : (AGG_CHOICE, EXP) REC_AGG_NAMED -> string *)
val €fmt_unary_exp› : EXP UNARY_EXP -> string
val €fmt_bin_exp› : EXP BIN_EXP -> string
val €fmt_attrib_desig› : ATTRIB_DESIG -> string
val €fmt_attribute› : (EXP, ATTRIB_DESIG) ATTRIBUTE -> string
val €fmt_indexed_comp› : EXP INDEXED_COMP -> string
val €fmt_selected_comp› : EXP SELECTED_COMP -> string
val €fmt_qualified_expression› : EXP QUALIFIED_EXPRESSION -> string
val €fmt_exp› : EXP -> string
val €fmt_exp_list› : EXP list -> string
val €fmt_static_exp› : STATIC_EXP -> string 
val €fmt_static_rangelohi› : STATIC_EXP RANGELOHI -> string 
val €fmt_static_range› : STATIC_EXP RANGE -> string 
val €fmt_cond› : COND -> string 
val €fmt_actuals› : (AGG_CHOICE, EXP) ACTUALS -> string 
=DESCRIBE
Functions dealing with expressions.
=ENDDOC

=DOC
val €fmt_spec› : SPEC -> string 
val €fmt_proc_call› : (AGG_CHOICE, EXP) PROC_CALL -> string 
=DESCRIBE
A couple of minor functions before we do statements.
=ENDDOC

=DOC
val €fmt_k_slot› : PP_FMT_INFO -> K_SLOT -> (PP_FMT_INFO * string) list
val €fmt_assign› : PP_FMT_INFO -> ASSIGN -> (PP_FMT_INFO * string) list
val €fmt_spec_no_ivars› : PP_FMT_INFO -> SPEC_NO_IVARS -> (PP_FMT_INFO * string) list 
val €fmt_exit_when› : PP_FMT_INFO -> EXIT_WHEN -> (PP_FMT_INFO * string) list 
val €fmt_return› : PP_FMT_INFO -> RETURN -> (PP_FMT_INFO * string) list
val €fmt_proc_call_no_ivars› : PP_FMT_INFO -> (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS -> (PP_FMT_INFO * string) list
val €fmt_elsif› : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
val €fmt_if_then_else› : PP_FMT_INFO -> STMT IF_THEN_ELSE -> (PP_FMT_INFO * string) list
val €fmt_case_choice› : CASE_CHOICE -> string
val €fmt_case_choice_list› : CASE_CHOICE list -> string
val €fmt_case_alt› : PP_FMT_INFO -> STMT CASE_ALTERNATIVE -> (PP_FMT_INFO * string) list
val €fmt_case_alt_list› : PP_FMT_INFO -> STMT CASE_ALTERNATIVE list -> (PP_FMT_INFO * string) list
val €fmt_case› : PP_FMT_INFO -> STMT CASE -> (PP_FMT_INFO * string) list
val €fmt_unnamed_loop› : PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val €fmt_named_loop› : PP_FMT_INFO -> STMT NAMED_LOOP -> (PP_FMT_INFO * string) list
val €fmt_loop_body› : PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val €fmt_while› : PP_FMT_INFO -> STMT WHILE -> (PP_FMT_INFO * string) list
val €fmt_for_static› : PP_FMT_INFO -> STMT FOR_STATIC -> (PP_FMT_INFO * string) list
val €fmt_for_tmark› : PP_FMT_INFO -> STMT FOR_TMARK -> (PP_FMT_INFO * string) list
val €fmt_stmt› : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
=DESCRIBE
Functions dealing with statements.
=ENDDOC

=DOC
val €fmt_log_con› : PP_FMT_INFO -> (LOG_CON * STMT) -> (PP_FMT_INFO * string) list 
=DESCRIBE
Logical constructs.
=ENDDOC

=DOC 
val €fmt_statement› : PP_FMT_INFO -> STATEMENT -> (PP_FMT_INFO * string) list 
=DESCRIBE
Top level statements.
=ENDDOC

=DOC
val €fmt_var_decl› : PP_FMT_INFO -> VAR_DECL -> (PP_FMT_INFO * string) list 
val €fmt_var_decl_list› : PP_FMT_INFO -> VAR_DECL list -> (PP_FMT_INFO * string) list 
=DESCRIBE
Variable declarations.
=ENDDOC

=DOC
val €fmt_const_decl› : PP_FMT_INFO -> EXP CONST_DECL -> (PP_FMT_INFO * string) list 
val €fmt_deferred_const_decl› : PP_FMT_INFO -> DEFERRED_CONST_DECL -> (PP_FMT_INFO * string) list 
=DESCRIBE
Constant and Deferred constant declarations.
=ENDDOC

=DOC
val €fmt_variant_alt_list› : ID list -> string
val €fmt_variant› : PP_FMT_INFO -> COMPONENT VARIANT -> (PP_FMT_INFO * string) list
val €fmt_variant_list› : PP_FMT_INFO -> COMPONENT VARIANT list -> (PP_FMT_INFO * string) list
val €fmt_variant_part› : PP_FMT_INFO -> COMPONENT VARIANT_PART -> (PP_FMT_INFO * string) list
val €fmt_declaration_variant› : PP_FMT_INFO -> COMPONENT DECLARATION_VARIANT -> (PP_FMT_INFO * string) list
val €fmt_component› : PP_FMT_INFO -> COMPONENT -> (PP_FMT_INFO * string) list
val €fmt_component_list› : PP_FMT_INFO -> COMPONENT list -> (PP_FMT_INFO * string) list
=DESCRIBE
A couple of minor functions before we do type definitions.
=ENDDOC

=DOC
val €fmt_discr_part› : DISCR_PART -> string
=DESCRIBE
Discriminant part.
=ENDDOC

=DOC
val €fmt_floating_point_constraint› : EXP FLOATING_POINT_CONSTRAINT -> string
val €fmt_floating_type_def› : PP_FMT_INFO -> ID * DISCR_PART * EXP FLOATING_TYPE_DEF -> (PP_FMT_INFO * string) list 
=DESCRIBE
Floating point types.
=ENDDOC

=DOC
val €fmt_fixed_point_constraint› : EXP FIXED_POINT_CONSTRAINT -> string 
val €fmt_fixed_type_def› : PP_FMT_INFO -> ID * DISCR_PART * EXP FIXED_TYPE_DEF -> (PP_FMT_INFO * string) list 
=DESCRIBE
Fixed point types.
=ENDDOC

=DOC 
val €fmt_enum_type_def› : PP_FMT_INFO -> ID * DISCR_PART * ENUM_TYPE_DEF -> (PP_FMT_INFO * string) list 
=DESCRIBE
Enumerated types.
=ENDDOC

=DOC
val €fmt_array_def› : PP_FMT_INFO -> ID * DISCR_PART * ARRAY_DEF -> (PP_FMT_INFO * string) list
=DESCRIBE
Array types.
=ENDDOC

=DOC
val €fmt_record_type_def› : PP_FMT_INFO -> ID * DISCR_PART * COMPONENT RECORD_TYPE_DEF -> (PP_FMT_INFO * string) list
=DESCRIBE
Record types.
=ENDDOC

=DOC
val €fmt_type_def› : PP_FMT_INFO -> ID * DISCR_PART * TYPE_DEF -> (PP_FMT_INFO * string) list 
val €fmt_type_decl› : PP_FMT_INFO -> TYPE_DEF TYPE_DECL -> (PP_FMT_INFO * string) list 
=DESCRIBE
Type declarations.
=ENDDOC

=DOC
val €fmt_constraint› : CONSTRAINT -> string 
val €fmt_sub_ind› : CONSTRAINT SUB_IND -> string 
val €fmt_subtype_decl› : PP_FMT_INFO -> CONSTRAINT SUBTYPE_DECL -> (PP_FMT_INFO * string) list 
=DESCRIBE
Subtype declarations.
=ENDDOC

=DOC 
val €fmt_private_type_decl› : PP_FMT_INFO -> PRIVATE_TYPE_DECL -> (PP_FMT_INFO * string) list
=DESCRIBE
Private type declarations.
=ENDDOC

=DOC 
val €fmt_basic_decl› : PP_FMT_INFO -> BASIC_DECL -> (PP_FMT_INFO * string) list 
=DESCRIBE
Basic declarations.
=ENDDOC

=DOC
val €fmt_parameter_specification› : PARAMETER_SPECIFICATION -> string 
val €fmt_parameter_specification_list1› : PARAMETER_SPECIFICATION list -> string
val €fmt_parameter_specification_list› : PARAMETER_SPECIFICATION list -> string
=DESCRIBE
Procedure and Function parameter specifications.
=ENDDOC

=DOC
val €fmt_procedure_specification› : PP_FMT_INFO -> PROCEDURE_SPECIFICATION -> (PP_FMT_INFO * string) list
val €fmt_function_specification› : PP_FMT_INFO -> FUNCTION_SPECIFICATION -> (PP_FMT_INFO * string) list
=DESCRIBE
Procedures and Function specifications.
=ENDDOC

=DOC
val €fmt_subprogram_specification› : PP_FMT_INFO -> SUBPROGRAM_SPECIFICATION -> (PP_FMT_INFO * string) list
=DESCRIBE
Subprograms
=ENDDOC

=DOC
val €fmt_function_renaming› : PP_FMT_INFO -> FUNCTION_RENAMING -> (PP_FMT_INFO * string) list
val €fmt_subprogram_renaming› : PP_FMT_INFO -> SUBPROGRAM_RENAMING -> (PP_FMT_INFO * string) list 
val €fmt_renaming_declaration› : PP_FMT_INFO -> RENAMING_DECLARATION -> (PP_FMT_INFO * string) list 
=DESCRIBE
Renaming declarations.
=ENDDOC

=DOC 
val €fmt_component_clause› : PP_FMT_INFO -> COMPONENT_CLAUSE -> (PP_FMT_INFO * string) list 
val €fmt_component_clause_list› : PP_FMT_INFO -> COMPONENT_CLAUSE list -> (PP_FMT_INFO * string) list 
val €fmt_length_clause› : PP_FMT_INFO -> LENGTH_CLAUSE -> (PP_FMT_INFO * string) list 
val €fmt_enumeration_representation_clause› : PP_FMT_INFO -> ENUMERATION_REPRESENTATION_CLAUSE -> (PP_FMT_INFO * string) list
val €fmt_record_representation_clause› : PP_FMT_INFO -> RECORD_REPRESENTATION_CLAUSE -> (PP_FMT_INFO * string) list
val €fmt_address_clause› : PP_FMT_INFO -> ADDRESS_CLAUSE -> (PP_FMT_INFO * string) list 
val €fmt_representation_clause› : PP_FMT_INFO -> REPRESENTATION_CLAUSE -> (PP_FMT_INFO * string) list 
=DESCRIBE
Representation clauses.
=ENDDOC

=DOC 
val €fmt_procedure_declaration› : PP_FMT_INFO -> PROCEDURE_DECLARATION -> (PP_FMT_INFO * string) list 
val €fmt_function_declaration› : PP_FMT_INFO -> FUNCTION_DECLARATION -> (PP_FMT_INFO * string) list 
val €fmt_procedure_stub› : PP_FMT_INFO -> PROCEDURE_DECLARATION -> (PP_FMT_INFO * string) list 
val €fmt_function_stub› : PP_FMT_INFO -> FUNCTION_DECLARATION -> (PP_FMT_INFO * string) list 
val €fmt_package_stub› : PP_FMT_INFO -> ID -> (PP_FMT_INFO * string) list 
val €fmt_package_declaration› : PP_FMT_INFO -> DECLARATION PACKAGE_DECLARATION -> (PP_FMT_INFO * string) list
val €fmt_declaration› : PP_FMT_INFO -> DECLARATION -> (PP_FMT_INFO * string) list
val €fmt_declaration_list› : PP_FMT_INFO -> DECLARATION list -> (PP_FMT_INFO * string) list
val €fmt_procedure_body› : PP_FMT_INFO -> DECLARATION PROCEDURE_BODY -> (PP_FMT_INFO * string) list
val €fmt_function_body› : PP_FMT_INFO -> DECLARATION FUNCTION_BODY -> (PP_FMT_INFO * string) list
val €fmt_package_body› : PP_FMT_INFO -> DECLARATION PACKAGE_BODY -> (PP_FMT_INFO * string) list
val €fmt_proper_body› : PP_FMT_INFO -> PROPER_BODY -> (PP_FMT_INFO * string) list
=DESCRIBE
Declarations.
=ENDDOC

=DOC
val €fmt_compilation_subunit› : PP_FMT_INFO -> SUBUNIT -> (PP_FMT_INFO * string) list
=DESCRIBE
Compliation subunits.
=ENDDOC

=DOC 
val €fmt_context_clause› : PP_FMT_INFO -> ID list -> (PP_FMT_INFO * string) list 
val €fmt_compilation_unit› : PP_FMT_INFO -> COMPILATION_UNIT -> (PP_FMT_INFO * string) list 
val €fmt_context_compilation_unit› : PP_FMT_INFO -> CONTEXT_COMPILATION_UNIT -> (PP_FMT_INFO * string) list
val €fmt_kslot_compilation_unit› : PP_FMT_INFO -> KSLOT_COMPILATION_UNIT -> (PP_FMT_INFO * string) list
val €fmt_kslot_compilation_unit_list› : PP_FMT_INFO -> KSLOT_COMPILATION_UNIT list -> (PP_FMT_INFO * string) list
=DESCRIBE
Compilation units.
=ENDDOC

=DOC
val €fmt_replaced_by_comp› : PP_FMT_INFO -> REPLACED_BY_COMP -> (PP_FMT_INFO * string) list 
val €fmt_replaced_by_private_part›: PP_FMT_INFO -> REPLACED_BY_PRIVATE_PART -> (PP_FMT_INFO * string) list
val €fmt_replaced_by_visible_part› : PP_FMT_INFO -> REPLACED_BY_VISIBLE_PART -> (PP_FMT_INFO * string) list
val €fmt_replaced_by_decl› : PP_FMT_INFO -> REPLACED_BY_DECL -> (PP_FMT_INFO * string) list 
val €fmt_refined_by› : PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val €fmt_replaced_by› : PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val €fmt_web_clause› : PP_FMT_INFO -> WEB_CLAUSE -> (PP_FMT_INFO * string) list 
=DESCRIBE
Web clauses
=ENDDOC

\subsection{Epilogue}

=DOC
end (* local ... in *);
end (* signature CNPrettyPrinter *);
=DESCRIBE
=ENDDOC

\section{SPARK OUTPUT SIGNATURE}
\subsection{Preamble}
=DOC
signature €SPARKOutput› = sig
local
	open CNTypes;
in
=DESCRIBE
This is the signature for the structure containing the output function for SPARK.
=ENDDOC


=DOC
type €PP_FMT_INFO›
val €format_web_clause› : PP_FMT_INFO -> WEB_CLAUSE -> unit   
val €print_web_clause› : WEB_CLAUSE -> unit
val €print_spark_program› : unit -> unit
val €output_spark_program› : {out_file:string} -> unit
val €output_spark_program1› : {out_file:string} -> unit
=DESCRIBE
Web clauses
=ENDDOC

\section{EPILOGUE}
=DOC
end (* local ... in *);
end (* signature SPARKOutput *);
=DESCRIBE
=ENDDOC
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}. The test module
is \cite{ISS/HAT/DAZ/MDT503}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



