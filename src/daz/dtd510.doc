% dtd510.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: SPARK Output Function} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD510} %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{D.J.~King & HAT Team}
\TPPabstract{
This document contains the detailed design for the DAZ SPARK Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.16] Initial Drafts.
\item[Issue 1.17 (13th October 1994)] Added auxiliary expression support.
\item[Issue 1.18 (14th October 1994)] Removed variant records from the implementation.
\item[Issue 1.19 (3rd November 1994)] Changed SUBUNIT to COMP\_SUBUNIT.
\item[Issue 1.20 (14th November 1994)] rationalised signature wrapping.
\item[Issues 1.21-1.22] Minor corrections before document inspection.
\item[Issue 1.23] Reworked according to desk check report 019.
\item[Issue 1.24] Updated the distribution list.
\item[Issue 1.25] Corrected test policy statement.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the Compliance Tool SPARK Output Function and responds to the high level design in \cite{ISS/HAT/DAZ/HLD503}.

The implementation is in \cite{ISS/HAT/DAZ/IMP510}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This detailed design document contains one signature, $CNSparkOutput$.  This provides facilities for printing out the various categories of abstract syntax.  None of the functions in it are intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} describes the top level functions which use this signature.

\subsubsection{Dependencies}

The functions in $CNSparkOutput$ depend on data types introduced in the structure $CNTypes$ which is defined in \cite{ISS/HAT/DAZ/DTD502}.

\subsection{Compliance}

The requirement is that the functions in this document support the correct printing of Spark programs which can be compiled using an Ada compiler.

\section{PRINTING ABSTRACT SYNTAX}

\subsection{The Signature}
=DOC
signature ÛCNSparkOutputÝ = sig
local
	open CNTypes;
in
=DESCRIBE
This signature contains functions which format abstract syntax into strings. It is used by the functions in the signature $SPARKOutput$ to print entire SPARK programs from the compliance tool environment when compliance notation has been entered.
=USES
None of the functions in this signature are intended to be called directly by the user.
=ENDDOC

\subsection{Functions to Print Abstract Syntax}
=DOC
val ÛPPTabSizeÝ : int ref 
type ÛPP_FMT_INFOÝ
val Ûset_PPTab_sizeÝ : int -> unit 
val Ûget_PPTab_sizeÝ : unit -> int 
val Ûfmt_spacesÝ : int -> string 
val Ûfmt_tabsÝ : int -> string
val Ûfmt_info_string_listÝ :
	(PP_FMT_INFO * string) list -> string   

=DESCRIBE
These functions deal with the low-level output of characters.
=ENDDOC

=DOC
val Ûfmt_idÝ : ID -> string
val Ûfmt_tmarkÝ : TMARK -> string 
val Ûfmt_termÝ : TERM -> string 
val Ûfmt_labelÝ : LABEL -> string 
val Ûfmt_unary_opÝ : UNARY_OP -> string 
val Ûfmt_binary_opÝ : BIN_OP -> string 
val Ûfmt_modeÝ : MODE -> string 
val Ûfmt_loop_directionÝ : LOOP_DIRECTION -> string 
val Ûfmt_operator_symbolÝ : OPERATOR_SYMBOL -> OPERATOR_SYMBOL
val Ûfmt_z_predÝ : Z_PRED -> string 
val Ûfmt_z_expÝ : Z_EXP -> string 
val Ûfmt_z_idÝ : Z_ID -> string 
val Ûfmt_attribÝ : ATTRIB -> string 
val Ûfmt_int_litÝ : INT_LIT -> string 
=DESCRIBE
These functions prints the leaves of the abstract syntax; they don't call any others.
=ENDDOC

=DOC 
val Ûfmt_id_listÝ : ID list -> string 
val Ûfmt_tmark_listÝ : TMARK list -> string
=DESCRIBE
Lists of identifiers
=ENDDOC

=DOC
val Ûfmt_rangelohiÝ : EXP RANGELOHI -> string
val Ûfmt_rangeÝ : EXP RANGE -> string
val Ûfmt_discrete_range_constrainedÝ :
	EXP DISCRETE_RANGE_CONSTRAINED -> string
val Ûfmt_discrete_rangeÝ : DISCRETE_RANGE -> string
val Ûfmt_agg_choiceÝ : AGG_CHOICE -> string
val Ûfmt_agg_choice_listÝ : AGG_CHOICE list -> string
val Ûfmt_named_assocÝ : (AGG_CHOICE, EXP) NAMED_ASSOC -> string
val Ûfmt_named_assoc_listÝ :
	(AGG_CHOICE, EXP) NAMED_ASSOC list -> string
val Ûfmt_othersÝ : EXP OTHERS -> string
val Ûfmt_agg_posÝ : EXP AGG_POS -> string
val Ûfmt_agg_pos_othersÝ : EXP AGG_POS_OTHERS -> string
val Ûfmt_agg_othersÝ : EXP AGG_OTHERS -> string
val Ûfmt_agg_namedÝ : (AGG_CHOICE, EXP) AGG_NAMED -> string
val Ûfmt_agg_named_othersÝ :
	(AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> string
val Ûfmt_unary_expÝ : EXP UNARY_EXP -> string
val Ûfmt_bin_expÝ : EXP BIN_EXP -> string
val Ûfmt_attrib_desigÝ : ATTRIB_DESIG -> string
val Ûfmt_attributeÝ : (EXP, ATTRIB_DESIG) ATTRIBUTE -> string
val Ûfmt_indexed_compÝ : EXP INDEXED_COMP -> string
val Ûfmt_selected_compÝ : EXP SELECTED_COMP -> string
val Ûfmt_qualified_expressionÝ : EXP QUALIFIED_EXPRESSION -> string
val Ûfmt_expÝ : EXP -> string
val Ûfmt_exp_listÝ : EXP list -> string
val Ûfmt_static_expÝ : STATIC_EXP -> string 
val Ûfmt_static_rangelohiÝ : STATIC_EXP RANGELOHI -> string 
val Ûfmt_static_rangeÝ : STATIC_EXP RANGE -> string 
val Ûfmt_condÝ : COND -> string 
val Ûfmt_actualsÝ : (AGG_CHOICE, EXP) ACTUALS -> string 
=DESCRIBE
Functions dealing with expressions.
=ENDDOC

=DOC
val Ûfmt_specÝ : SPEC -> string 
val Ûfmt_proc_callÝ : (AGG_CHOICE, EXP) PROC_CALL -> string 
=DESCRIBE
Functions dealing with a spec statement an a procedure call.
=ENDDOC

=DOC
val Ûfmt_k_slotÝ : PP_FMT_INFO -> K_SLOT -> (PP_FMT_INFO * string) list
val Ûfmt_assignÝ : PP_FMT_INFO -> ASSIGN -> (PP_FMT_INFO * string) list
val Ûfmt_spec_no_ivarsÝ :
	PP_FMT_INFO -> SPEC_NO_IVARS -> (PP_FMT_INFO * string) list 
val Ûfmt_exit_whenÝ :
	PP_FMT_INFO -> EXIT_WHEN -> (PP_FMT_INFO * string) list 
val Ûfmt_returnÝ :
	PP_FMT_INFO -> RETURN -> (PP_FMT_INFO * string) list
val Ûfmt_proc_call_no_ivarsÝ :
	PP_FMT_INFO -> (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS ->
	(PP_FMT_INFO * string) list
val Ûfmt_elsifÝ : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
val Ûfmt_if_then_elseÝ :
	PP_FMT_INFO -> STMT IF_THEN_ELSE -> (PP_FMT_INFO * string) list
val Ûfmt_case_choiceÝ : CASE_CHOICE -> string
val Ûfmt_case_choice_listÝ : CASE_CHOICE list -> string
val Ûfmt_case_altÝ :
	PP_FMT_INFO -> STMT CASE_ALTERNATIVE ->
	(PP_FMT_INFO * string) list
val Ûfmt_case_alt_listÝ :
	PP_FMT_INFO -> STMT CASE_ALTERNATIVE list ->
	(PP_FMT_INFO * string) list
val Ûfmt_caseÝ :
	PP_FMT_INFO -> STMT CASE -> (PP_FMT_INFO * string) list
val Ûfmt_unnamed_loopÝ :
	PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_named_loopÝ :
	PP_FMT_INFO -> STMT NAMED_LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_loop_bodyÝ :
	PP_FMT_INFO -> STMT LOOP -> (PP_FMT_INFO * string) list
val Ûfmt_whileÝ :
	PP_FMT_INFO -> STMT WHILE -> (PP_FMT_INFO * string) list
val Ûfmt_for_staticÝ :
	PP_FMT_INFO -> STMT FOR_STATIC -> (PP_FMT_INFO * string) list
val Ûfmt_for_tmarkÝ :
	PP_FMT_INFO -> STMT FOR_TMARK -> (PP_FMT_INFO * string) list
val Ûfmt_stmtÝ : PP_FMT_INFO -> STMT -> (PP_FMT_INFO * string) list
=DESCRIBE
Functions dealing with statements.
=ENDDOC

=DOC
val Ûfmt_log_conÝ :
	PP_FMT_INFO -> (LOG_CON * STMT) -> (PP_FMT_INFO * string) list 
=DESCRIBE
Logical constructs.
=ENDDOC

=DOC 
val Ûfmt_statementÝ :
	PP_FMT_INFO -> STATEMENT -> (PP_FMT_INFO * string) list 
=DESCRIBE
Top level statements.
=ENDDOC

=DOC
val Ûfmt_var_declÝ :
	PP_FMT_INFO -> VAR_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_var_decl_listÝ :
	PP_FMT_INFO -> VAR_DECL list -> (PP_FMT_INFO * string) list 
=DESCRIBE
Variable declarations.
=ENDDOC

=DOC
val Ûfmt_const_declÝ :
	PP_FMT_INFO -> EXP CONST_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_deferred_const_declÝ :
	PP_FMT_INFO -> DEFERRED_CONST_DECL ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Constant and Deferred constant declarations.
=ENDDOC

=DOC
val Ûfmt_floating_point_constraintÝ : EXP FLOATING_POINT_CONSTRAINT -> string
val Ûfmt_floating_type_defÝ :
	PP_FMT_INFO -> ID * EXP FLOATING_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Floating point types.
=ENDDOC

=DOC
val Ûfmt_fixed_point_constraintÝ : EXP FIXED_POINT_CONSTRAINT -> string 
val Ûfmt_fixed_type_defÝ :
	PP_FMT_INFO -> ID * EXP FIXED_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Fixed point types.
=ENDDOC

=DOC 
val Ûfmt_enum_type_defÝ :
	PP_FMT_INFO -> ID * ENUM_TYPE_DEF ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Enumerated types.
=ENDDOC

=DOC
val Ûfmt_array_defÝ :
	PP_FMT_INFO -> ID * ARRAY_DEF ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Array types.
=ENDDOC

=DOC
val Ûfmt_record_type_defÝ :
	PP_FMT_INFO ->
	ID * RECORD_TYPE_DEF ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Record types.
=ENDDOC

=DOC
val Ûfmt_type_defÝ :
	PP_FMT_INFO -> ID * TYPE_DEF ->
	(PP_FMT_INFO * string) list 
val Ûfmt_type_declÝ :
	PP_FMT_INFO -> TYPE_DEF TYPE_DECL -> (PP_FMT_INFO * string) list 
=DESCRIBE
Type declarations.
=ENDDOC

=DOC
val Ûfmt_constraintÝ : CONSTRAINT -> string 
val Ûfmt_sub_indÝ : CONSTRAINT SUB_IND -> string 
val Ûfmt_subtype_declÝ :
	PP_FMT_INFO -> CONSTRAINT SUBTYPE_DECL ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Subtype declarations.
=ENDDOC

=DOC 
val Ûfmt_private_type_declÝ :
	PP_FMT_INFO -> PRIVATE_TYPE_DECL -> (PP_FMT_INFO * string) list
=DESCRIBE
Private type declarations.
=ENDDOC

=DOC 
val Ûfmt_basic_declÝ :
	PP_FMT_INFO -> BASIC_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_basic_decl_listÝ :
	PP_FMT_INFO -> BASIC_DECL list -> (PP_FMT_INFO * string) list
=DESCRIBE
Basic declarations.
=ENDDOC

=DOC
val Ûfmt_parameter_specificationÝ : PARAMETER_SPECIFICATION -> string 
val Ûfmt_parameter_specification_list1Ý :
	PARAMETER_SPECIFICATION list -> string
val Ûfmt_parameter_specification_listÝ :
	PARAMETER_SPECIFICATION list -> string
=DESCRIBE
Procedure and Function parameter specifications.
=ENDDOC

=DOC
val Ûfmt_procedure_specificationÝ :
	PP_FMT_INFO -> PROCEDURE_SPECIFICATION ->
	(PP_FMT_INFO * string) list
val Ûfmt_function_specificationÝ :
	PP_FMT_INFO -> FUNCTION_SPECIFICATION ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Procedures and Function specifications.
=ENDDOC

=DOC
val Ûfmt_subprogram_specificationÝ :
	PP_FMT_INFO -> SUBPROGRAM_SPECIFICATION ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Subprograms.
=ENDDOC

=DOC
val Ûfmt_function_renamingÝ :
	PP_FMT_INFO -> FUNCTION_RENAMING -> (PP_FMT_INFO * string) list
val Ûfmt_subprogram_renamingÝ :
	PP_FMT_INFO -> SUBPROGRAM_RENAMING ->
	(PP_FMT_INFO * string) list 
val Ûfmt_renaming_declarationÝ :
	PP_FMT_INFO -> RENAMING_DECLARATION ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Renaming declarations.
=ENDDOC

=DOC 
val Ûfmt_component_clauseÝ :
	PP_FMT_INFO -> COMPONENT_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_component_clause_listÝ :
	PP_FMT_INFO -> COMPONENT_CLAUSE list ->
	(PP_FMT_INFO * string) list 
val Ûfmt_length_clauseÝ :
	PP_FMT_INFO -> LENGTH_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_enumeration_representation_clauseÝ :
	PP_FMT_INFO -> ENUMERATION_REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list
val Ûfmt_record_representation_clauseÝ :
	PP_FMT_INFO -> RECORD_REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list
val Ûfmt_address_clauseÝ :
	PP_FMT_INFO -> ADDRESS_CLAUSE -> (PP_FMT_INFO * string) list 
val Ûfmt_representation_clauseÝ :
	PP_FMT_INFO -> REPRESENTATION_CLAUSE ->
	(PP_FMT_INFO * string) list 
=DESCRIBE
Representation clauses.
=ENDDOC

=DOC 
val Ûfmt_procedure_declarationÝ :
	PP_FMT_INFO -> PROCEDURE_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_function_declarationÝ :
	PP_FMT_INFO -> FUNCTION_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_procedure_stubÝ :
	PP_FMT_INFO -> PROCEDURE_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_function_stubÝ :
	PP_FMT_INFO -> FUNCTION_DECLARATION ->
	(PP_FMT_INFO * string) list 
val Ûfmt_auxiliaryÝ :
	PP_FMT_INFO -> AUX_VAR -> (PP_FMT_INFO * string) list 
val Ûfmt_usingÝ :
	PP_FMT_INFO -> USING_DEC -> (PP_FMT_INFO * string) list 
val Ûfmt_package_stubÝ :
	PP_FMT_INFO -> ID -> (PP_FMT_INFO * string) list 
val Ûfmt_package_declarationÝ :
	PP_FMT_INFO -> DECLARATION PACKAGE_DECLARATION ->
	(PP_FMT_INFO * string) list
val Ûfmt_declarationÝ :
	PP_FMT_INFO -> DECLARATION -> (PP_FMT_INFO * string) list
val Ûfmt_declaration_listÝ :
	PP_FMT_INFO -> DECLARATION list -> (PP_FMT_INFO * string) list
val Ûfmt_procedure_bodyÝ :
	PP_FMT_INFO -> DECLARATION PROCEDURE_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_function_bodyÝ :
	PP_FMT_INFO -> DECLARATION FUNCTION_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_package_bodyÝ :
	PP_FMT_INFO -> DECLARATION PACKAGE_BODY ->
	(PP_FMT_INFO * string) list
val Ûfmt_proper_bodyÝ :
	PP_FMT_INFO -> PROPER_BODY -> (PP_FMT_INFO * string) list
=DESCRIBE
Declarations.
=ENDDOC

=DOC
val Ûfmt_compilation_subunitÝ :
	PP_FMT_INFO -> COMP_SUBUNIT -> (PP_FMT_INFO * string) list
=DESCRIBE
Compliation subunits.
=ENDDOC

=DOC 
val Ûfmt_context_clauseÝ :
	PP_FMT_INFO -> ID list -> (PP_FMT_INFO * string) list 
val Ûfmt_compilation_unitÝ :
	PP_FMT_INFO -> COMPILATION_UNIT -> (PP_FMT_INFO * string) list 
val Ûfmt_context_compilation_unitÝ :
	PP_FMT_INFO -> CONTEXT_COMPILATION_UNIT ->
	(PP_FMT_INFO * string) list
val Ûfmt_kslot_compilation_unitÝ :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT ->
	(PP_FMT_INFO * string) list
val Ûfmt_kslot_compilation_unit_listÝ :
	PP_FMT_INFO -> KSLOT_COMPILATION_UNIT list ->
	(PP_FMT_INFO * string) list
=DESCRIBE
Compilation units.
=ENDDOC

=DOC
val Ûfmt_replaced_by_compÝ :
	PP_FMT_INFO -> REPLACED_BY_COMP -> (PP_FMT_INFO * string) list 
val Ûfmt_replaced_by_private_partÝ:
	PP_FMT_INFO -> REPLACED_BY_PRIVATE_PART ->
	(PP_FMT_INFO * string) list
val Ûfmt_replaced_by_visible_partÝ :
	PP_FMT_INFO -> REPLACED_BY_VISIBLE_PART ->
	(PP_FMT_INFO * string) list
val Ûfmt_replaced_by_declÝ :
	PP_FMT_INFO -> REPLACED_BY_DECL -> (PP_FMT_INFO * string) list 
val Ûfmt_refined_byÝ :
	PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val Ûfmt_replaced_byÝ :
	PP_FMT_INFO -> REFINED_BY -> (PP_FMT_INFO * string) list 
val Ûfmt_web_clauseÝ :
	PP_FMT_INFO -> WEB_CLAUSE -> (PP_FMT_INFO * string) list 
=DESCRIBE
Web clauses.
=ENDDOC

\section{SPARK PROGRAM OUTPUT}
=DOC
val Ûformat_web_clauseÝ :
	PP_FMT_INFO -> WEB_CLAUSE -> unit   
val Ûprint_web_clauseÝ : WEB_CLAUSE -> unit
val Ûprint_spark_programÝ : unit -> unit
val Ûoutput_spark_programÝ : {out_file : string} -> unit
=DESCRIBE
The function $print\_spark\_program$ generates and prints the SPARK program from the contents of the Compliance Tool environment. The SPARK program is created by filling in the K-Slots and specification statements in a literate script with their expansions and printing the output onto the screen in SPARK syntax such that it could be subsequently compiled using an Ada compiler.

$output\_spark\_program$ does the same as $print\_spark\_program$ but allows the user to specify a file to which the program will then be written.
Both of these functions cause a number of checks to be imposed.
=FAILURE
510001	The following name clashes have been detected in the SPARK program:
510002	?0 clashes with ?1
510003	Name clashes detected in the SPARK program
=ENDDOC

\subsection{Epilogue}
=SML
end (* local ... in *);
end (* signature CNSparkOutput *);
=TEX

\section{TEST POLICY}
The functions in this document do not lend themselves to the module test framework (since their correct operation depends on the contents of output files).
The integration tests described in \cite{ISS/HAT/DAX/HLD503} will exercise these functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



