%  dtd510.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD510}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the DAZ SPARK Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1, \FormatDate{94/03/28}] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the DAZ SPARK Output Function.

\subsection{Introduction}

\subsubsection{Purpose and Background}

\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}

\section{PREAMBLE}
=DOC
open CNTypes;
signature ÛSPARKOutputÝ = sig
=DESCRIBE
This is the signature for the structure containing the output function for SPARK.
=ENDDOC

\section{SPARK Output Function}
=DOC
val PPTabSize = ref 2 : int ref   
val set_PPTab_size = fn : int -> unit   
val get_PPTab_size = fn : unit -> int   
val fmt_spaces = fn : int -> string   
val fmt_tabs = fn : int -> string   val fmt_id = fn : ID -> string
=DESCRIBE
These functions deal with the low-level output of characters.
=ENDDOC

=DOC
val fmt_tmark = fn : TMARK -> string   
val fmt_term = fn : TERM -> string   
val fmt_label = fn : LABEL -> string   
val fmt_unary_op = fn : UNARY_OP -> string   
val fmt_binary_op = fn : BIN_OP -> string   
val fmt_mode = fn : MODE -> string   
val fmt_loop_direction = fn : LOOP_DIRECTION -> string   
val fmt_operator_symbol = fn : OPERATOR_SYMBOL -> OPERATOR_SYMBOL
=DESCRIBE
These are the leaf functions, they don't call any others.
=ENDDOC

=DOC  
val fmt_id_list = fn : ID list -> string   
val fmt_tmark_list = fn : TMARK list -> string
=DESCRIBE
Lists of leaf functions.
=ENDDOC

=DOC 
val fmt_z_pred = fn : Z_PRED -> string   
val fmt_z_exp = fn : Z_EXP -> string   
val fmt_z_id = fn : Z_ID -> string   
val fmt_attrib = fn : ATTRIB -> string   
val fmt_int_lit = fn : INT_LIT -> string 
=DESCRIBE
Equivalences to leaf functions.
=ENDDOC

=DOC
val fmt_range = fn : EXP RANGE -> string
val fmt_discrete_range_constrained = fn :
   EXP DISCRETE_RANGE_CONSTRAINED -> string
val fmt_discrete_range = fn : DISCRETE_RANGE -> string
val fmt_agg_choice = fn : AGG_CHOICE -> string
val fmt_agg_choice_list = fn : AGG_CHOICE list -> string
val fmt_named_assoc = fn : (AGG_CHOICE, EXP) NAMED_ASSOC -> string
val fmt_named_assoc_list = fn : (AGG_CHOICE, EXP) NAMED_ASSOC list -> string
val fmt_others = fn : EXP OTHERS -> string
val fmt_agg_pos = fn : EXP AGG_POS -> string
val fmt_agg_pos_others = fn : EXP AGG_POS_OTHERS -> string
val fmt_agg_others = fn : EXP AGG_OTHERS -> string
val fmt_agg_named = fn : (AGG_CHOICE, EXP) AGG_NAMED -> string
val fmt_agg_named_others = fn : (AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> string
val fmt_rec_agg_named = fn : (AGG_CHOICE, EXP) REC_AGG_NAMED -> string
val fmt_unary_exp = fn : EXP UNARY_EXP -> string
val fmt_bin_exp = fn : EXP BIN_EXP -> string
val fmt_attrib_desig = fn : ATTRIB_DESIG -> string
val fmt_attribute = fn : (EXP, ATTRIB_DESIG) ATTRIBUTE -> string
val fmt_indexed_comp = fn : EXP INDEXED_COMP -> string
val fmt_selected_comp = fn : EXP SELECTED_COMP -> string
val fmt_qualified_expression = fn : EXP QUALIFIED_EXPRESSION -> string
val fmt_exp = fn : EXP -> string
val fmt_exp_list = fn : EXP list -> string
=DESCRIBE
Functions dealing with expressions.
=ENDDOC

=DOC
val fmt_spec = fn : SPEC -> string   
val fmt_static_exp = fn : STATIC_EXP -> string   
val fmt_static_range = fn : STATIC_EXP RANGE -> string   
val fmt_cond = fn : COND -> string   
val fmt_actuals = fn : (AGG_CHOICE, EXP) ACTUALS -> string   
val fmt_proc_call = fn : (AGG_CHOICE, EXP) PROC_CALL * int -> string   
val fmt_k_slot = fn : K_SLOT * int -> string 
=DESCRIBE
A couple of minor functions before we do statements.
=ENDDOC

=DOC
val fmt_assign = fn : ASSIGN * int -> string   val fmt_spec_no_ivars = fn : SPEC_NO_IVARS * int -> string   
val fmt_exit_when = fn : EXIT_WHEN * int -> string   
val fmt_return = fn : RETURN * int -> string
val fmt_proc_call_no_ivars = fn :
   (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS * int -> string
val fmt_elsif = fn : STMT * int -> string
val fmt_if_then_else = fn : STMT IF_THEN_ELSE * int -> string
val fmt_case_choice = fn : CASE_CHOICE -> string
val fmt_case_choice_list = fn : CASE_CHOICE list -> string
val fmt_case_alt = fn : STMT CASE_ALTERNATIVE * int -> string
val fmt_case_alt_list = fn : STMT CASE_ALTERNATIVE list * int -> string
val fmt_case = fn : STMT CASE * int -> string
val fmt_unnamed_loop = fn : STMT LOOP * int -> string
val fmt_named_loop = fn : STMT NAMED_LOOP * int -> string
val fmt_loop_body = fn : STMT LOOP * int -> string
val fmt_while = fn : STMT WHILE * int -> string
val fmt_for_static = fn : STMT FOR_STATIC * int -> string
val fmt_for_tmark = fn : STMT FOR_TMARK * int -> string
val fmt_stmt = fn : STMT * int -> string
=DESCRIBE
Functions dealing with statements.
=ENDDOC

=DOC
val fmt_log_con = fn : (LOG_CON * STMT) * int -> string 
=DESCRIBE
Logical constructs.
=ENDDOC

=DOC  
val fmt_statement = fn : STATEMENT * int -> string   
=DESCRIBE
Top level statements.
=ENDDOC

=DOC
val fmt_var_decl = fn : VAR_DECL * int -> string   
val fmt_var_decl_list = fn : VAR_DECL list * int -> string   
=DESCRIBE
Variable declarations.
=ENDDOC

=DOC
val fmt_const_decl = fn : EXP CONST_DECL * int -> string   
val fmt_deferred_const_decl = fn : DEFERRED_CONST_DECL * int -> string 
=DESCRIBE
Constant and Deferred constant declarations.
=ENDDOC

=DOC  
val fmt_variant = fn : COMPONENT VARIANT * int -> string
val fmt_variant_list = fn : COMPONENT VARIANT list * int -> string
val fmt_variant_part = fn : COMPONENT VARIANT_PART * int -> string
val fmt_declaration_variant = fn :
   COMPONENT DECLARATION_VARIANT * int -> string
val fmt_component = fn : COMPONENT * int -> string
val fmt_component_list = fn : COMPONENT list * int -> string
=DESCRIBE
A couple of minor functions before we do type definitions.
=ENDDOC

=DOC
val fmt_discr_part = fn : DISCR_PART -> string
=DESCRIBE
Discriminant part.
=ENDDOC

=DOC
val fmt_floating_point_constraint = fn : EXP FLOATING_POINT_CONSTRAINT ->
string
val fmt_floating_type_def = fn : EXP FLOATING_TYPE_DEF -> string   
=DESCRIBE
Floating point types.
=ENDDOC

=DOC
val fmt_fixed_point_constraint = fn : EXP FIXED_POINT_CONSTRAINT -> string   
val fmt_fixed_type_def = fn : EXP FIXED_TYPE_DEF -> string  
=DESCRIBE
Fixed point types.
=ENDDOC

=DOC 
val fmt_enum_type_def = fn : ENUM_TYPE_DEF -> string   
=DESCRIBE
Enumerated types.
=ENDDOC

=DOC
val fmt_array_def = fn : ARRAY_DEF -> string
=DESCRIBE
Array types.
=ENDDOC

=DOC
val fmt_record_type_def = fn : COMPONENT RECORD_TYPE_DEF * int -> string
=DESCRIBE
Record types.
=ENDDOC

=DOC
val fmt_type_def = fn : TYPE_DEF * int -> string   
val fmt_type_decl = fn : TYPE_DEF TYPE_DECL * int -> string   
=DESCRIBE
Type declarations.
=ENDDOC

=DOC
val fmt_constraint = fn : CONSTRAINT -> string   
val fmt_sub_ind = fn : CONSTRAINT SUB_IND -> string   
val fmt_subtype_decl = fn : CONSTRAINT SUBTYPE_DECL * int -> string 
=DESCRIBE
Subtype declarations.
=ENDDOC

=DOC  
val fmt_private_type_decl = fn : PRIVATE_TYPE_DECL * int -> string
=DESCRIBE
Private type declarations.
=ENDDOC

=DOC 
val fmt_basic_decl = fn : BASIC_DECL * int -> string   
=DESCRIBE
Basic declarations.
=ENDDOC

=DOC
val fmt_parameter_specification = fn : PARAMETER_SPECIFICATION -> string   
val fmt_parameter_specification_list1 = fn : PARAMETER_SPECIFICATION list ->
string
val fmt_parameter_specification_list = fn : PARAMETER_SPECIFICATION list ->
string
=DESCRIBE
Procedure and Function parameter specifications.
=ENDDOC

=DOC
val fmt_procedure_specification = fn : PROCEDURE_SPECIFICATION * int ->
string
val fmt_function_specification = fn : FUNCTION_SPECIFICATION * int -> string
=DESCRIBE
Procedures and Function specifications.
=ENDDOC

=DOC
val fmt_subprogram_specification = fn : SUBPROGRAM_SPECIFICATION * int ->
string
=DESCRIBE
Subprograms
=ENDDOC

=DOC
val fmt_function_renaming = fn : FUNCTION_RENAMING * int -> string

val fmt_subprogram_renaming = fn : SUBPROGRAM_RENAMING * int -> string   
val fmt_renaming_declaration = fn : RENAMING_DECLARATION * int -> string  
=DESCRIBE
Renaming declarations.
=ENDDOC

=DOC 
val fmt_component_clause = fn : COMPONENT_CLAUSE * int -> string   
val fmt_component_clause_list = fn : COMPONENT_CLAUSE list * int -> string   
val fmt_length_clause = fn : LENGTH_CLAUSE * int -> string   
val fmt_enumeration_representation_clause = fn : ENUMERATION_REPRESENTATION_CLAUSE
* int -> string
val fmt_record_representation_clause = fn : RECORD_REPRESENTATION_CLAUSE *
int -> string
val fmt_address_clause = fn : ADDRESS_CLAUSE * int -> string   
val fmt_representation_clause = fn : REPRESENTATION_CLAUSE * int -> string 
=DESCRIBE
Representation clauses.
=ENDDOC

=DOC  
val fmt_procedure_declaration = fn : PROCEDURE_DECLARATION * int -> string   
val fmt_function_declaration = fn : FUNCTION_DECLARATION * int -> string   
val fmt_procedure_stub = fn : PROCEDURE_DECLARATION * int -> string   
val fmt_function_stub = fn : FUNCTION_DECLARATION * int -> string   
val fmt_package_stub = fn : ID * int -> string   
val fmt_package_declaration = fn : DECLARATION PACKAGE_DECLARATION * int ->
string
val fmt_declaration = fn : DECLARATION * int -> string
val fmt_declaration_list = fn : DECLARATION list * int -> string
val fmt_procedure_body = fn : DECLARATION PROCEDURE_BODY * int -> string
val fmt_function_body = fn : DECLARATION FUNCTION_BODY * int -> string
val fmt_package_body = fn : DECLARATION PACKAGE_BODY * int -> string
val fmt_proper_body = fn : PROPER_BODY * int -> string
=DESCRIBE
Declarations.
=ENDDOC

=DOC
val fmt_compilation_subunit = fn : SUBUNIT * int -> string
=DESCRIBE
Compliation subunits.
=ENDDOC

=DOC  
val fmt_context_clause = fn : ID list * int -> string   
val fmt_compilation_unit = fn : COMPILATION_UNIT * int -> string   
val fmt_context_compilation_unit = fn : CONTEXT_COMPILATION_UNIT * int ->
string
val fmt_kslot_compilation_unit = fn : KSLOT_COMPILATION_UNIT * int -> string

val fmt_kslot_compilation_unit_list = fn : KSLOT_COMPILATION_UNIT list * int
-> string
=DESCRIBE
Compilation units.
=ENDDOC

=DOC
val fmt_replaced_by_comp = fn : REPLACED_BY_COMP * int -> string   
val fmt_replaced_by_private_part = fn : REPLACED_BY_PRIVATE_PART * int ->
string
val fmt_replaced_by_visible_part = fn : REPLACED_BY_VISIBLE_PART * int ->
string
val fmt_replaced_by_decl = fn : REPLACED_BY_DECL * int -> string   
val fmt_refined_by = fn : REFINED_BY * int -> string   
val fmt_replaced_by = fn : REFINED_BY * int -> string   
val fmt_web_clause = fn : WEB_CLAUSE * int -> string 
=DESCRIBE
Web clauses
=ENDDOC

=DOC  
val web = fn : WEB_CLAUSE -> unit  
=DESCRIBE
Function to pretty print a Web Clause.
=ENDDOC

\section{EPILOGUE}
=DOC
end; (* signature SPARKOutput *)
=DESCRIBE
=ENDDOC
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.  The test module
is \cite{ISS/HAT/DAZ/MDT503}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



