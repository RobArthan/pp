=IGN
********************************************************************************
int514.doc: this file is part of the Ada Compliance Tool system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Date: 2002/10/17 15:10:58 $ $Revision: 1.14 $ $RCSfile: int514.doc,v $
=TEX
% TQtemplate.tex
% use_file "daz_init";
% use_file "int514";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Tests for Compliance Notation Environments}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT514}  %% Mandatory field
\def\SCCSversion{1.6%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{97/07/21%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn & IUCT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & IUCT Team1}
\TPPabstract{%
This document contains tests for the environments in the Compliance Notation Tool.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1-1.2] First drafts.
\item[Issue 1.3] Stopped any mention of $pack\_spec\_with\_modules$ in listing.
\item[Issue 1.4] Added theory environment tests for prefixed theories.
\item[Issue 1.5] Changes for WP 9.
\item[Issue 1.6,1.7] IUCT WP 4 syntax changes.
\item[Issue 1.9] Reinstated missing `=SML' that was suppressing some checks.
\item[Issue 1.10,1.11] CTLE II changes invalidated a number of tests.
\item[Issue 1.12] Constants and types in packages are now in reverse order.
\item[Issue 1.13] Removed use of ICL logo font.
\item[Issue 1.14] Copyright and banner updates for open source release.
\item[Issue 1.15] DAZ-specific updates to banner for open source release
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains test data for the Compliance Tool.
\subsection{Introduction}
This document contains specific tests to check the environments of the
Compliance Notation tool.
This mainly checks interactions between the modules defined
in \cite{ISS/HAT/DAZ/DTD507} and \cite{ISS/HAT/DAZ/DTD508}.

We are interested in two kinds of environments in these tests:
first the package and block environments, and second the theory environments.
The later is of concern when we prefix a theory as a result of processing a ``with'' clause - we need to determine whether everything has been properly 
translated.

$pack\_spec\_with\_modules$ is a component of packages, which happens to
get caught be the module test harness - so we hide it using $local$.


\section{PRELIMINARIES}

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = get_descendants "cn" less "cn"
					diff get_cache_theories();
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
=SML
val get_z_generator_state = CNZGenerator.get_z_generator_state;

open CNTypes CNTypes1 CNTypes2;
=TEX
=SML
fun pack_type_decls (pack : PACKAGE) = (
let	fun aux (BDTypeDecl {name = n,...} :: x) = aux x @ [n]
	| aux (_ :: x) = aux x
	| aux [] = [];
in
	aux (#consts_types pack)
end);
fun pack_const_decls (pack : PACKAGE) = (
let	fun aux (BDConstDecl {consts = cs,...} :: x) = aux x @ cs
	| aux (_ :: x) = aux x
	| aux [] = [];
in
	aux (#consts_types pack)
end);
=TEX
\section{Start of a new script}
=SML
clean_up();
new_script{name = "empty", state = initial_cn_state};
local
val zgs_empty = get_z_generator_state();
in
val dummy = store_mt_results_show mt_run [
	("empty_length_blocks", Combinators.I, length (#blocks zgs_empty), 1),
	("empty_length_dec_env", Combinators.I, length (#dec_env zgs_empty), 0),
	("empty_length_pack_env", Combinators.I, length (#pack_env zgs_empty), 0),
	("empty_length_repl_env", Combinators.I, length (#repl_env zgs_empty), 0),
	("empty_length_spec_env", Combinators.I, length (#spec_env zgs_empty), 0),
	("empty_length_spark_prog", Combinators.I, length (#spark_prog zgs_empty), 0),
	("empty_length_subunit_env", Combinators.I, length (#subunit_env zgs_empty), 0)
];
val dummy = store_mt_results_show mt_run [
	("empty_script_name", (fn () => (#script_name zgs_empty)), (),
		"empty")
];
val dummy = let
val block1_empty = hd (#blocks zgs_empty);
in
store_mt_results_show mt_run [
	("empty_decflags", (fn () => (#flags(#declab block1_empty))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false,
	      body_flag = false})
]
end;
end; (* zgs_empty *)
=TEX
\section{PACKAGE SPECIFICATION}
=SML
clean_up();
new_script{name = "ps", state = initial_cn_state};
¹CN
package PACK is
   § a k-slot ¢ (1)
   type INT_TYPE is range 5 .. 90;
   X : INT_TYPE;
   Y : constant INT_TYPE := 5;
   procedure P(FX : out INTEGER);
   procedure P1(FX : out INTEGER)
   „ FX ˜ X[ X > 10, FX > 0 ];
   function F(FY : in INTEGER) return INTEGER;
   function F1(FY : in INTEGER) return INTEGER
   ˜ X [F1 X (FY) > FY];
   auxiliary s : seq î;

   type AINT_TYPE is range 10 .. 80;
   X1, X2 : AINT_TYPE;
   Y1, Y2 : constant AINT_TYPE := 5;
   procedure Q;
   procedure Q1
   „ X1 [ X1 > 20 ];
   function G return INTEGER;
   function G1 return INTEGER
   ˜ X [G1 X > 0];
    auxiliary s1 : seq î;
  
   § another k-slot ¢ (2)
end PACK;
° 
=SML
local
val zgs_ps = get_z_generator_state();
in
val dummy = store_mt_results_show mt_run [
	("ps_length_blocks", Combinators.I, length (#blocks zgs_ps), 1),
	("ps_length_dec_env", Combinators.I, length (#dec_env zgs_ps), 2),
	("ps_length_pack_env", Combinators.I, length (#pack_env zgs_ps), 1),
	("ps_length_repl_env", Combinators.I, length (#repl_env zgs_ps), 2),
	("ps_length_spec_env", Combinators.I, length (#spec_env zgs_ps), 0),
	("ps_length_spark_prog", Combinators.I, length (#spark_prog zgs_ps), 1),
	("ps_length_subunit_env", Combinators.I, length (#subunit_env zgs_ps), 0)
];
val dummy = store_mt_results_show mt_run [
	("ps_script_name", (fn () => (#script_name zgs_ps)), (),
		"ps")
];
val dummy = let
val block1_ps = hd (#blocks zgs_ps);
in
store_mt_results_show mt_run [
	("ps_decflags", (fn () => (#flags(#declab block1_ps))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false,
	      body_flag = false})
]
end;
=TEX
=SML
local
val (name_ps, pack_ps) = hd(#pack_env zgs_ps);
in
=TEX
=SML
val dummy = store_mt_results_show mt_run [
	("ps_pack_name", Combinators.I,  name_ps, "PACK")
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_vc_vars", flat o map (fn {vars = v,...}=> v),  
		#vc_vars pack_ps, ["X", "X1", "X2"])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_consts", pack_const_decls, pack_ps, 
		["Y", "Y1", "Y2"])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_types", pack_type_decls, pack_ps, 
		["INT_TYPE", "AINT_TYPE"])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_fprocs", map (fn {name = v,...}=> v),  
		#formal_procs pack_ps, ["P1", "Q1"])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pack_ps, [["FX"], ["X1"]])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pack_ps, [[["FX"]], []])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_ffuns", map (fn {informal_fun = {name = v,...} ,...}=> v),  
		#formal_funs pack_ps, ["F1", "G1"])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_ffuns_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_funs pack_ps, [[], []])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_ffuns_g", map (fn {globals=globals, ...}=> globals),  
		#formal_funs pack_ps, [["X"], ["X"]])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_ffuns_fids", map 
		(fn {informal_fun = {formal_pars=fids,...},...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_funs pack_ps, [[["FY"]], []])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_ifuns", map (fn {name = v,...}=> v),  
		#informal_funs pack_ps, ["F", "G"])
];
val dummy = store_mt_results_show mt_run [
	("ps_pack_ifuns_fids", map 
		(fn {formal_pars=fids,...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#informal_funs pack_ps, [[["FY"]], []])
];

=TEX
=SML
end; (* of local name_ps *)
end; (* of local zgs_ps *)
=TEX
\section{FILLING IN K-SLOTS}
=SML
val state1 = get_cn_state();
¹CN
(1) é Z : INTEGER;
°
¹CN
(2) é  procedure P2(FX : out INTEGER)
   „ FX ˜ X [ X > 10, FX > 0 ];
°
=SML
local
val zgs_slabel = get_z_generator_state();
in
val dummy = store_mt_results_show mt_run [
	("slabel_length_blocks", Combinators.I, length (#blocks zgs_slabel), 1),
	("slabel_length_dec_env", Combinators.I, length (#dec_env zgs_slabel), 0),
	("slabel_length_pack_env", Combinators.I, length (#pack_env zgs_slabel), 1),
	("slabel_length_repl_env", Combinators.I, length (#repl_env zgs_slabel), 2),
	("slabel_length_spec_env", Combinators.I, length (#spec_env zgs_slabel), 0),
	("slabel_length_spark_prog", Combinators.I, length (#spark_prog zgs_slabel), 1),
	("slabel_length_subunit_env", Combinators.I, length (#subunit_env zgs_slabel), 0)
];
val dummy = store_mt_results_show mt_run [
	("slabel_script_name", (fn () => (#script_name zgs_slabel)), (),
		"ps")
];
val dummy = let
val block1_slabel = hd (#blocks zgs_slabel);
in
store_mt_results_show mt_run [
	("slabel_decflags", (fn () => (#flags(#declab block1_slabel))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false,
               body_flag = false})
]
end;
=TEX
=SML
local
val (name_slabel, pack_slabel) = hd(#pack_env zgs_slabel);
in
=TEX
=SML
val dummy = store_mt_results_show mt_run [
	("slabel_pack_name", Combinators.I,  name_slabel, "PACK")
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_vc_vars", flat o map (fn {vars = v,...}=> v),  
		#vc_vars pack_slabel, ["X", "X1", "X2", "Z"])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_consts", pack_const_decls, pack_slabel, 
		["Y", "Y1", "Y2"])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_types", pack_type_decls, pack_slabel, 
		["INT_TYPE", "AINT_TYPE"])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_fprocs", map (fn {name = v,...}=> v),  
		#formal_procs pack_slabel, ["P1", "Q1", "P2"])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pack_slabel, [["FX"], ["X1"], ["FX"]])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pack_slabel, [[["FX"]], [], [["FX"]]])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_ffuns", map (fn {informal_fun = {name = v,...} ,...}=> v),  
		#formal_funs pack_slabel, ["F1", "G1"])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_ffuns_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_funs pack_slabel, [[], []])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_ffuns_fids", map 
		(fn {informal_fun = {formal_pars=fids,...},...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_funs pack_slabel, [[["FY"]], []])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_ifuns", map (fn {name = v,...}=> v),  
		#informal_funs pack_slabel, ["F", "G"])
];
val dummy = store_mt_results_show mt_run [
	("slabel_pack_ifuns_fids", map 
		(fn {formal_pars=fids,...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#informal_funs pack_slabel, [[["FY"]], []])
];
=TEX
=SML
val slabel_inscope = (#in_scope(#declab(hd(#blocks zgs_slabel))));
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_vc_pars", Combinators.I,  
		#vc_pars slabel_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_vc_vars", flat o map (fn {vars = v,...} => v),  
		#vc_vars slabel_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_dec_labels", Combinators.I,  
		#dec_labels slabel_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_vc_aux_vars", map 
		(fst o dest_var o hd o fst o dest_z_dec),  
		#vc_aux_vars slabel_inscope, 
		[])
];
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_vc_log_cons", map string_of_term,  
		#vc_log_cons slabel_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_formal_procs", 
		map (fn {name = n,...}=> n),  
		#formal_procs slabel_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs slabel_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("slabel_inscope_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs slabel_inscope, [])
];
=TEX

=SML
end; (* local name_slabel *)
end; (* of local zgs_label *)
=TEX

=SML
store_mt_results_show mt_run [
	("slabel_consts", map (fst o dest_const),  
		(rev(get_consts "ps")), map (fn x => implode["z'", x]) [
"INT_TYPE", "INT_TYPEvFIRST", "INT_TYPEvLAST",
"INT_TYPEvSUCC", "INT_TYPEvPRED", "INT_TYPEvPOS", 
"INT_TYPEvVAL", "Y", "AINT_TYPE", "AINT_TYPEvFIRST",
"AINT_TYPEvLAST", "AINT_TYPEvSUCC", "AINT_TYPEvPRED",
"AINT_TYPEvPOS", "AINT_TYPEvVAL", "Y1", "Y2"])
];
=TEX

\section{AFTER WITH}
=SML
val state2 = get_cn_state();
new_script{name="afterwith", state = state2};
¹CN
with PACK;
package PACK1 is
	X : INTEGER;
end PACK1;
° 
=SML
local
val zgs_afterwith = get_z_generator_state();
in
val dummy = store_mt_results_show mt_run [
	("afterwith_length_blocks", Combinators.I, length (#blocks zgs_afterwith), 1),
	("afterwith_length_dec_env", Combinators.I, length (#dec_env zgs_afterwith), 0),
	("afterwith_length_pack_env", Combinators.I, length (#pack_env zgs_afterwith), 2),
	("afterwith_length_repl_env", Combinators.I, length (#repl_env zgs_afterwith), 0),
	("afterwith_length_spec_env", Combinators.I, length (#spec_env zgs_afterwith), 0),
	("afterwith_length_spark_prog", Combinators.I, length (#spark_prog zgs_afterwith), 1),
	("afterwith_length_subunit_env", Combinators.I, length (#subunit_env zgs_afterwith), 0)
];
val dummy = store_mt_results_show mt_run [
	("afterwith_script_name", (fn () => (#script_name zgs_afterwith)), (),
		"afterwith")
];
val dummy = let
val block1_afterwith = hd (#blocks zgs_afterwith);
in
store_mt_results_show mt_run [
	("afterwith_decflags", (fn () => (#flags(#declab block1_afterwith))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false,
               body_flag = false})
]
end;
=TEX
=SML
local
val pack_afterwith = force_value(
	s_lookup "PACK1" (#pack_env zgs_afterwith));
in
=TEX
=SML
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_vc_vars", flat o map (fn {vars = v,...}=> v),  
		#vc_vars pack_afterwith, ["X"])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_consts", pack_const_decls, pack_afterwith, 
		[])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_types", pack_type_decls, pack_afterwith, 
		[])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_fprocs", map (fn {name = v,...}=> v),  
		#formal_procs pack_afterwith, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pack_afterwith, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pack_afterwith, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_ffuns", map (fn {informal_fun = {name = v,...} ,...}=> v),  
		#formal_funs pack_afterwith, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_ffuns_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_funs pack_afterwith, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_ffuns_fids", map 
		(fn {informal_fun = {formal_pars=fids,...},...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_funs pack_afterwith, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_ifuns", map (fn {name = v,...}=> v),  
		#informal_funs pack_afterwith, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_pack_ifuns_fids", map 
		(fn {formal_pars=fids,...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#informal_funs pack_afterwith, [])
];
=TEX
=SML
val afterwith_inscope = (#in_scope(#declab(hd(#blocks zgs_afterwith))));
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_vc_pars", Combinators.I,  
		#vc_pars afterwith_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_vc_vars", flat o map (fn {vars = v,...} => v),  
		#vc_vars afterwith_inscope,
		["PACKoX", "PACKoX1", "PACKoX2", "PACKoZ"])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_dec_labels", Combinators.I,  
		#dec_labels afterwith_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_vc_aux_vars", map 
		(fst o dest_var o hd o fst o dest_z_dec),  
		#vc_aux_vars afterwith_inscope, 
		["PACKos", "PACKos1"])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_vc_log_cons", map string_of_term,  
		#vc_log_cons afterwith_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_formal_procs", 
		map (fn {name = n,...}=> n),  
		#formal_procs afterwith_inscope, 
		["PACKoP1", "PACKoQ1", "PACKoP2"])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs afterwith_inscope, [["FX"],["PACKoX1"],["FX"]])
];
val dummy = store_mt_results_show mt_run [
	("afterwith_inscope_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs afterwith_inscope, [[["FX"]],[],[["FX"]]])
];
=TEX
=SML
end; (* pack_afterwith *)
end; (* of local zgs_afterwith *)
=TEX
=SML
store_mt_results_show mt_run [
	("afterwith_consts", map (fst o dest_const),  
		(rev(get_consts "PACKspec")), map (fn x => implode["z'", x]) [
"PACKoINT_TYPE", "PACKoINT_TYPEvFIRST", "PACKoINT_TYPEvLAST",
"PACKoINT_TYPEvSUCC", "PACKoINT_TYPEvPRED", "PACKoINT_TYPEvPOS", 
"PACKoINT_TYPEvVAL", "PACKoY", "PACKoAINT_TYPE", "PACKoAINT_TYPEvFIRST",
"PACKoAINT_TYPEvLAST", "PACKoAINT_TYPEvSUCC", "PACKoAINT_TYPEvPRED",
"PACKoAINT_TYPEvPOS", "PACKoAINT_TYPEvVAL", "PACKoY1", "PACKoY2", "PACKoF",
"PACKoG", "PACKoF1", "PACKoG1"])
];
=TEX
\section{PACKAGE BODY}
=IGN
force_delete_theory "pb";
=SML
new_script{name = "pb", state = state2};
¹CN
package body PACK is
   § a k-slot ¢ (3)
--   type INT_TYPE is range 5 .. 90;
   type BINT_TYPE is range 5 .. 90;
--   X : INT_TYPE;
   X3 : BINT_TYPE;
--   Y : constant INT_TYPE := 5;
   Y3 : constant INT_TYPE := 5;
   procedure P(FX : out INTEGER) is
   begin
	X := X3;
   end P;

   procedure P1(FX : out INTEGER)
   „ FX ˜ X [ X > 10, FX > 0 ] is
   begin
	FX := X - 10;
   end P1;
   function F(FY : in INTEGER) return INTEGER is
   begin
	return (FY * Y3);
   end F;
   function F1(FY : in INTEGER) return INTEGER
   ˜ X [F1 X (FY) > FY] is
   begin
	return ((FY * FY) + Y3);
   end F1;

--   type AINT_TYPE is range 10 .. 80;
--   X1, X2 : AINT_TYPE;
--   Y1, Y2 : constant AINT_TYPE := 5;
   procedure Q is
   begin
	X2 := Y2;
   end Q;
   procedure Q1
   „ X1 [ X1 > 20 ] is
   begin
	X1:= 20;
   end Q1;
   function G return INTEGER is
   begin
	return 5;
   end G;
   function G1 return INTEGER
   ˜ X [G1 X > 0] is
   begin
	return 5;
   end G1;
  
   § another k-slot ¢ (4)
begin
   X2 := F(X2);
   P(X1);
end PACK;
° 
=SML
local
val zgs_pb = get_z_generator_state();
in
val dummy = store_mt_results_show mt_run [
	("pb_length_blocks", Combinators.I, length (#blocks zgs_pb), 1),
	("pb_length_dec_env", Combinators.I, length (#dec_env zgs_pb), 2),
	("pb_length_pack_env", Combinators.I, length (#pack_env zgs_pb), 1),
	("pb_length_repl_env", Combinators.I, length (#repl_env zgs_pb), 2),
	("pb_length_spec_env", Combinators.I, length (#spec_env zgs_pb), 0),
	("pb_length_spark_prog", Combinators.I, length (#spark_prog zgs_pb), 1),
	("pb_length_subunit_env", Combinators.I, length (#subunit_env zgs_pb), 0)
];
val dummy = store_mt_results_show mt_run [
	("pb_script_name", (fn () => (#script_name zgs_pb)), (),
		"pb")
];
val dummy = let
val block1_pb = hd (#blocks zgs_pb);
in
store_mt_results_show mt_run [
	("pb_decflags", (fn () => (#flags(#declab block1_pb))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false,
               body_flag = false})
]
end;
=TEX
=SML
val pb_inscope = (#in_scope(#declab(hd(#blocks zgs_pb))));
val dummy = store_mt_results_show mt_run [
	("pb_inscope_vc_pars", Combinators.I,  
		#vc_pars pb_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pb_inscope_vc_vars", flat o map (fn {vars = v,...} => v),  
		#vc_vars pb_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pb_inscope_dec_labels", Combinators.I,  
		#dec_labels pb_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pb_inscope_vc_aux_vars", map 
		(fst o dest_var o hd o fst o dest_z_dec),  
		#vc_aux_vars pb_inscope, 
		[])
];
val dummy = store_mt_results_show mt_run [
	("pb_inscope_vc_log_cons", map string_of_term,  
		#vc_log_cons pb_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pb_inscope_formal_procs", 
		map (fn {name = n,...}=> n),  
		#formal_procs pb_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pb_inscope_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pb_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pb_inscope_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pb_inscope, [])
];
=TEX
=SML
end; (* of local zgs_pb *)
=TEX
=SML
store_mt_results_show mt_run [
	("pb_consts", map (fst o dest_const),  
		(rev(get_consts "pb")), map (fn x => implode["z'", x]) [
"BINT_TYPE", "BINT_TYPEvFIRST", "BINT_TYPEvLAST",
"BINT_TYPEvSUCC", "BINT_TYPEvPRED", "BINT_TYPEvPOS", 
"BINT_TYPEvVAL", "Y3", "F", "F1",
"G", "G1"])
];
=TEX
=SML
length(get_conjectures "pb");
store_mt_results_show mt_run [
	("pb_conjectures", length, get_conjectures "pb", 12)
];
=TEX 
=SML
set_pc "cn";
(length o mapfilter (prove_rule [] o snd o snd))( get_conjectures "pb");
store_mt_results_show mt_run [
	("pb_prove_conjectures", length o mapfilter (prove_rule [] o snd o snd), get_conjectures "pb", 8)
];
=TEX
\section{AFTER FILLING IN BODY K-SLOTS}
¹CN
(3) é Z1 : INTEGER;
°
¹CN
(4) é  procedure P2(FX : out INTEGER)
   „ FX ˜ X [ X > 10, FX > 0 ] is
   begin
	FX := X + 1;
   end P2;
°
=SML
local
val zgs_pbk = get_z_generator_state();
in
val dummy = store_mt_results_show mt_run [
	("pbk_length_blocks", Combinators.I, length (#blocks zgs_pbk), 1),
	("pbk_length_dec_env", Combinators.I, length (#dec_env zgs_pbk), 0),
	("pbk_length_pack_env", Combinators.I, length (#pack_env zgs_pbk), 1),
	("pbk_length_repl_env", Combinators.I, length (#repl_env zgs_pbk), 2),
	("pbk_length_spec_env", Combinators.I, length (#spec_env zgs_pbk), 0),
	("pbk_length_spark_prog", Combinators.I, length (#spark_prog zgs_pbk), 1),
	("pbk_length_subunit_env", Combinators.I, length (#subunit_env zgs_pbk), 0)
];
val dummy = store_mt_results_show mt_run [
	("pbk_script_name", (fn () => (#script_name zgs_pbk)), (),
		"pb")
];
val dummy = let
val block1_pbk = hd (#blocks zgs_pbk);
in
store_mt_results_show mt_run [
	("pbk_decflags", (fn () => (#flags(#declab block1_pbk))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false,
               body_flag = false})
]
end;
=TEX
=SML
local
val  pack_pbk = force_value (s_lookup "PACK" (#pack_env zgs_pbk));
in
=TEX
=SML
val dummy = store_mt_results_show mt_run [
	("pbk_pack_vc_vars", flat o map (fn {vars = v,...}=> v),  
		#vc_vars pack_pbk, ["X", "X1", "X2", "Z"])
];
val dummy = store_mt_results_show mt_run [
	("pbk_pack_fprocs", map (fn {name = v,...}=> v),  
		#formal_procs pack_pbk, ["P1", "Q1", "P2"])
];
=TEX

=SML
val pbk_inscope = (#in_scope(#declab(hd(#blocks zgs_pbk))));
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_vc_pars", Combinators.I,  
		#vc_pars pbk_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_vc_vars", flat o map (fn {vars = v,...} => v),  
		#vc_vars pbk_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_dec_labels", Combinators.I,  
		#dec_labels pbk_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_vc_aux_vars", map 
		(fst o dest_var o hd o fst o dest_z_dec),  
		#vc_aux_vars pbk_inscope, 
		[])
];
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_vc_log_cons", map string_of_term,  
		#vc_log_cons pbk_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_formal_procs", 
		map (fn {name = n,...}=> n),  
		#formal_procs pbk_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pbk_inscope, [])
];
val dummy = store_mt_results_show mt_run [
	("pbk_inscope_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pbk_inscope, [])
];
=TEX
=SML
end; (* local pack_pbk *)
end; (* local zgs_pbk *)
=TEX
=SML
store_mt_results_show mt_run [
	("pbk_consts", map (fst o dest_const),  
		(rev(get_consts "pb")), map (fn x => implode["z'", x]) [
"BINT_TYPE", "BINT_TYPEvFIRST", "BINT_TYPEvLAST",
"BINT_TYPEvSUCC", "BINT_TYPEvPRED", "BINT_TYPEvPOS", 
"BINT_TYPEvVAL", "Y3", "F", "F1",
"G", "G1"])
];
=TEX
=SML
length(get_conjectures "pb");
store_mt_results_show mt_run [
	("pbk_conjectures", length, get_conjectures "pb", 15)
];
=TEX 
=SML
set_pc "cn";
(length o mapfilter (prove_rule [] o snd o snd))( get_conjectures "pb");
store_mt_results_show mt_run [
	("pbk_prove_conjectures", length o mapfilter (prove_rule [] o snd o snd), get_conjectures "pb", 10)
];
=TEX
\section{PREFIXING THEORIES}
First the range of Ada type translations (primarily taken from Volume 3 of the 
specs.):
=SML
clean_up();
new_script{name="plain", state=initial_cn_state};
¹CN
package plain is
type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
subtype WEEKDAY is DAY range MON .. FRI;
PAY_DAY : constant WEEKDAY := FRI;
type STRING_ARRAY is array(DAY) of STRING;
A: constant STRING_ARRAY := STRING_ARRAY'("abc", "xyz");
V1: DAY;
V2 : INTEGER;
type ARR is array (DAY) of DAY;
type HOURS is range 0..23;
type ARR2 is array(DAY, HOURS) of DAY;
type UNCON is array(DAY range <>) of DAY;
type UNCON2 is array(DAY range<>, HOURS range<>) of DAY;
type REC is 
record 
	START : DAY;
	FINISH : DAY;
	YESTERDAY : ARR;
end record;
type FIX is delta 0.1 range 5.1 .. 10.0;
subtype SUBFIX1 is FIX range 7.0 .. 9.0;
subtype SUB is UNCON(WEEKDAY);
subtype SUB2 is UNCON2(WEEKDAY, HOURS);
end plain;
°
=SML
val plain_state = get_cn_state();
new_script {name="uses_plain", state = plain_state};
¹CN
with PLAIN;
package uses_plain is
V1 : PLAIN.DAY := PLAIN.DAY'FIRST;
V2 : PLAIN.WEEKDAY:= PLAIN.WEEKDAY'FIRST;
V3 : PLAIN.WEEKDAY := PLAIN.PAY_DAY;
V4 : PLAIN.STRING_ARRAY := PLAIN.A;
V5 : PLAIN.ARR;
V6 : PLAIN.HOURS := PLAIN.HOURS'FIRST;
V7 : PLAIN.ARR2;
V8 : PLAIN.UNCON;
V9 : PLAIN.UNCON2;
V10: PLAIN.REC;
V11: PLAIN.FIX;
V12: PLAIN.SUBFIX1;
V13: PLAIN.SUB;
V14: PLAIN.SUB2; 
procedure P 
 „ V5 ˜ V7, V8, V9, V10, V11, V12, V13, V14
[ V5(PLAINoMON) > 0 ± 
	 V7 (PLAINoTUE, PLAINoHOURSvLAST) > 0 ±
	 V8 (PLAINoMON) = PLAINoMON ±
	 V9 (PLAINoTUE, PLAINoHOURSvLAST) > 0 ±
	 V10.START = PLAINoMON ±
	 V11 = V12 ±
	 V13(PLAINoMON) = PLAINoSUBvFIRST ±
	 V14 (PLAINoMON, PLAINoHOURSvLAST) = V8(PLAINoMON)];
end uses_plain;
°
Test prefixed theory for similarity:
=SML
new_theory "temp";
new_parent "plain";
new_parent "PLAINspec";
=TEX
=SML
store_mt_results_show mt_run [
("prefix1_types", map (fn(n,_) => "PLAINo" ^ n) o map dest_ctype o get_types,
	"plain", map (fst o dest_ctype) (get_types "PLAINspec")
)
];
store_mt_results_show mt_run [
("prefix1_consts", map (fn(n,_,_) => "PLAINo" ^ n) o map dest_z_gvar o get_consts,
	"plain", map ((fn(n,_,_) => n) o dest_z_gvar) (get_consts "PLAINspec")
)
];
store_mt_results_show mt_run [
("prefix1_axioms", 
	map (fn n => "PLAINo" ^ n) o flat o map fst o get_axioms,
	"plain", (flat o map fst o get_axioms) "PLAINspec")
];
store_mt_results_show mt_run [
("prefix1_defns", 
	map (fn n => "PLAINo" ^ n) o flat o map fst o get_defns,
	"plain", (flat o map fst o get_defns) "PLAINspec")
];
=TEX
Now for Z paragraphs:
=SML
clean_up();
new_script{name="plain1", state=initial_cn_state};
=TEX
¹Z
Ü [ GIVEN ]
°
¹Z
Ü [ GIVEN1, GIVEN2 ]
°
¹ZAX
Ü fn1 : GIVEN ß GIVEN1;
Ü fn2 : GIVEN ß GIVEN2
÷üüüüüü
Ü dom fn1 = dom fn2
°
ÿ SCH1 üüüüüüüüüüü
Ü a, b : ú
÷üüüüüü
Ü a = b
ˆüüüüüüüüüüüüüü
ÿ SCH2[X] üüüüüüüüüüü
Ü a, b : X
÷üüüüüü
Ü a = b
ˆüüüüüüüüüüüüüü
[X]œœœœœœœœœœœ
Ü fn3 : SCH2[X] ß ú;
Ü fn4 : SCH2[X] ß î
÷üüüüüü
Ü dom fn3 = dom fn4
ˆüüüüüüüüüüüüüü
¹Z
Ü T1[X, Y] ¦ X ¸ Y
°
¹Z
Ü T2 ::= Con1 | Con2 §ú¢
°
¹Z
rel _ myinfix1 _
°
[X]œœœœœœœœœœœ
Ü _ myinfix1 _ : X ª X
÷üüüüüü
Ü µ x, y : X · (x = y) ´ (x myinfix1 y) 
ˆüüüüüüüüüüüüüü

¹CN
package plain1 is
X : INTEGER;
end plain1;
°
=SML
val plain1_state = get_cn_state();
new_script{name="using_plain1", state = plain1_state};
¹CN
with plain1;
package using_plain1 is
 §Procedure P¢			(100)
end using_plain1;
°
=TEX
Note that the fixity declaration caused by the $with$ does not take effect
``fast enough'' for the following text to be done in place, because 
fixity instructions affect the ability to input the Z embedded in the Compliance
Notation.
¹CN
(100) é 
procedure P 
 „ [µ a : GIVEN; b : GIVEN1; c : GIVEN2; d : dom fn1; n : dom fn2; 
	f : SCH1; g : SCH2[ú]; h : dom (fn3[ú]) ;
	i : dom (fn4[ú]); j : T1[ú, ú]; k : T2; l, m : { Con1, Con2 1} ·
	(l, m)   (_ myinfix1 _)[T2]
   ];
°
=SML
fun p1_types() = (let val dummy = open_theory "plain1";
			val res = (map (fst o dest_ctype) o get_types) "plain1";
			val dummy1 = open_theory "using_plain1";
		in
			res
		end);

store_mt_results_show mt_run [
("prefix2_types", p1_types,
	(), map (fst o dest_ctype) (get_types "PLAIN1spec")
)
];
=TEX
=SML
fun p1_consts() = (let val dummy = open_theory "plain1";
			val res = (map ((fn(n,_,_) => n) o dest_z_gvar) o get_consts) "plain1";
			val dummy1 = open_theory "using_plain1";
		in
			res
		end);

store_mt_results_show mt_run [
("prefix2_consts", p1_consts,
	(), map ((fn(n,_,_) => n) o dest_z_gvar) (get_consts "PLAIN1spec")
)
];
=TEX
=SML
fun p1_axioms() = (let val dummy = open_theory "plain1";
			val res = (flat o map fst o get_axioms) "plain1";
			val dummy1 = open_theory "using_plain1";
		in
			res
		end);
store_mt_results_show mt_run [
("prefix2_axioms", 
	p1_axioms,
	(), (flat o map fst o get_axioms) "PLAIN1spec")
];
=TEX
=SML
fun p1_defns() = (let val dummy = open_theory "plain1";
			val res = (flat o map fst o get_defns) "plain1";
			val dummy1 = open_theory "using_plain1";
		in
			res
		end);
store_mt_results_show mt_run [
("prefix2_defns", 
	p1_defns,
	(), (flat o map fst o get_defns) "PLAIN1spec")
];
=TEX

=IGN
open_theory "using_plain1";
open_theory "PLAIN1spec";
z_print_theory "PLAIN1spec";

open_theory "plain1";
z_print_theory "plain1";
=TEX
=SML
val c = ñT2®;
fun test_spec_works (old_thy : string) (new_thy : string) (c : TERM)  = (
let	val dummy1 = open_theory old_thy;
	val goal = ([],concl (z_get_spec c)); 
	val dummy2 = open_theory new_thy;
	val lspec = z_get_spec c;
	val rwspec = rewrite_rule 
		[z_get_spec ¬Z'Decl®, z_get_spec ¬Z'Dec®] lspec
		handle (Fail _) => lspec;
	val lspecs = [lspec, rwspec];
	val thm = tac_proof(goal,
		prove_tac [lspec] THEN fc_tac [lspec])
		handle (Fail _) => 
		tac_proof(goal,
		prove_tac lspecs THEN REPEAT(CHANGED_T(asm_fc_tac lspecs)));
in
	true
end
handle (Fail _) =>
(diag_line ("Spec. of " ^string_of_term c ^ " cannot be proven");
false));
=IGN
map (test_spec_works "plain1" "PLAIN1spec") (get_consts "PLAIN1spec");
=TEX
=SML
store_mt_results_show mt_run [
("prefix2_proofs", 
	(fn x => all x (fn y=> y)) o 
		map (test_spec_works  "plain1" "PLAIN1spec"),
	(get_consts "PLAIN1spec"), 
	true)
];
=TEX
Now for a very simple mix:
Now for Z paragraphs:
=SML
clean_up();
new_script{name="mix1", state=initial_cn_state};
¹ZAX
Ü fn1 : ú ß ú
÷üüüüüü
Ü dom fn1 = {1, 2, 3, 4, 5}
°
¹CN
package mix1 is
subtype T5 is INTEGER range 1 .. 5;
V5 : T5;
procedure F5 
 „ V5 [ fn1 V5 > 0 ];
end mix1;
°
¹ZAX
Ü fn2 : T5 ß ú
÷üüüüüü
Ü dom fn2 = {1, 2, 3, 4, 5}
°
=SML
val mix_state1 = get_cn_state();
new_script{name="mix2", state=mix_state1};
¹CN
with mix1;
package mix2 is
subtype T5 is MIX1.T5;
procedure F25 (X : in T5)
 „ MIX1oV5 [ fn1 MIX1oV5 > 0, fn2 MIX1oV5 > 0 ];
end mix2;
°
=SML
val mix_state2 = get_cn_state();
new_script{name="using_mix1", state=mix_state2};
=TEX
Simple success is all we require, so:
=SML
fun mix () =
¹CN
references mix1;
package body mix2 is
procedure F25 
 „ MIX1oV5 [ fn1 MIX1oV5 > 0, fn2 MIX1oV5 > 0 ] is
begin
	MIX1.V5 := 1;
end F25;
end mix2;
°
=SML
store_mt_results_show mt_run [
("mix_body", 
	mix, (), ())
];
=TEX
=SML
fun m1_types() = (let val dummy = open_theory "mix1";
			val res = (map (fst o dest_ctype) o get_types) "mix1";
			val dummy1 = open_theory "using_mix1";
		in
			res
		end);

store_mt_results_show mt_run [
("prefix3_types", m1_types,
	(), map (fst o dest_ctype) (get_types "MIX1spec")
)
];
=TEX
=SML
fun m1_consts() = (let val dummy = open_theory "mix1";
			val res = ((map (fn n => if (n mem ["fn1", "fn2"])
					then n
					else "MIX1o" ^ n)) o
				map ((fn(n,_,_) => n) o dest_z_gvar) o get_consts) "mix1";
			val dummy1 = open_theory "using_mix1";
		in
			res
		end);

store_mt_results_show mt_run [
("prefix3_consts", m1_consts,
	(), map ((fn(n,_,_) => n) o dest_z_gvar) (get_consts "MIX1spec")
)
];
=TEX
=SML
fun m1_axioms() = (let val dummy = open_theory "mix1";
			val res = ((map (fn n => if (n mem ["fn1", "fn2"])
					then n
					else "MIX1o" ^ n)) o
				flat o map fst o get_axioms) "mix1";
			val dummy1 = open_theory "using_mix1";
		in
			res
		end);
store_mt_results_show mt_run [
("prefix3_axioms", 
	m1_axioms,
	(), (flat o map fst o get_axioms) "MIX1spec")
];
=TEX
=SML
fun m1_defns() = (let val dummy = open_theory "mix1";
			val res = ((map (fn n => if (n mem ["fn1", "fn2"])
					then n
					else "MIX1o" ^ n)) o
			flat o map fst o get_defns) "mix1";
			val dummy1 = open_theory "using_mix1";
		in
			res
		end);
store_mt_results_show mt_run [
("prefix3_defns", 
	m1_defns,
	(), (flat o map fst o get_defns) "MIX1spec")
];
=TEX

\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\pagebreak
\end{document}
=IGN
