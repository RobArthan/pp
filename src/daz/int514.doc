% %Z% $Revision$ $RCSfile$ $Date$
=TEX
% TQtemplate.tex
% use_file "daz_init";
% use_file "int514";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Bugfix Tests}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT514}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn & IUCT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & IUCT Team1}
\TPPabstract{%
This document contains tests for the environments in the Compliance Notation Tool.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1] First draft.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains test data for the Compliance Tool.
\subsection{Introduction}
This document contains specific tests to check the enviroments of the
Compliance Notation tool.

\section{PRELIMINARIES}

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = get_descendants "cn" less "cn"
					diff get_cache_theories();
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
=SML
open CNZGenerator;
open CNTypes CNTypes1 CNTypes2;
=TEX
=SML
fun pack_type_decls (pack : PACKAGE) = (
let	fun aux (BDTypeDecl {name = n,...} :: x) = n :: aux x
	| aux (_ :: x) = aux x
	| aux [] = [];
in
	aux (#consts_types pack)
end);
fun pack_const_decls (pack : PACKAGE) = (
let	fun aux (BDConstDecl {consts = cs,...} :: x) = cs @ aux x
	| aux (_ :: x) = aux x
	| aux [] = [];
in
	aux (#consts_types pack)
end);
=TEX
\section{Start of a new script}
=SML
clean_up();
new_script{name = "empty", state = initial_cn_state};
val zgs_empty = get_z_generator_state();

store_mt_results_show mt_run [
	("empty_length_blocks", Combinators.I, length (#blocks zgs_empty), 1),
	("empty_length_dec_env", Combinators.I, length (#dec_env zgs_empty), 0),
	("empty_length_pack_env", Combinators.I, length (#pack_env zgs_empty), 0),
	("empty_length_repl_env", Combinators.I, length (#repl_env zgs_empty), 0),
	("empty_length_spec_env", Combinators.I, length (#spec_env zgs_empty), 0),
	("empty_length_spark_prog", Combinators.I, length (#spark_prog zgs_empty), 0),
	("empty_length_subunit_env", Combinators.I, length (#subunit_env zgs_empty), 0)
];
store_mt_results_show mt_run [
	("empty_script_name", (fn () => (#script_name zgs_empty)), (),
		"empty")
];
let
val block1_empty = hd (#blocks zgs_empty);
in
store_mt_results_show mt_run [
	("empty_decflags", (fn () => (#flags(#declab block1_empty))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false})
]
end;
=TEX
\section{PACKAGE SPECIFICATION}
=SML
clean_up();
new_script{name = "ps", state = initial_cn_state};
¹CN
package PACK is
   § a k-slot ¢ (1)
   type INT_TYPE is range 5 .. 90;
   X : INT_TYPE;
   Y : constant INT_TYPE := 5;
   procedure P(FX : out INTEGER);
   procedure P1(FX : out INTEGER)
   „ FX [ X > 10, FX > 0 ];
   function F(FY : in INTEGER) return INTEGER;
   function F1(FY : in INTEGER) return INTEGER
   „ F1 [F1(FY) > FY];
   auxiliary s : seq î;

   type AINT_TYPE is range 10 .. 80;
   X1, X2 : AINT_TYPE;
   Y1, Y2 : constant AINT_TYPE := 5;
   procedure Q;
   procedure Q1
   „ X1 [ X1 > 20 ];
   function G return INTEGER;
   function G1 return INTEGER
   „ G1 [G1 > 0];
    auxiliary s1 : seq î;
  
   § another k-slot ¢ (2)
end PACK;
° 
=SML
val zgs_ps = get_z_generator_state();

store_mt_results_show mt_run [
	("ps_length_blocks", Combinators.I, length (#blocks zgs_ps), 1),
	("ps_length_dec_env", Combinators.I, length (#dec_env zgs_ps), 2),
	("ps_length_pack_env", Combinators.I, length (#pack_env zgs_ps), 1),
	("ps_length_repl_env", Combinators.I, length (#repl_env zgs_ps), 2),
	("ps_length_spec_env", Combinators.I, length (#spec_env zgs_ps), 0),
	("ps_length_spark_prog", Combinators.I, length (#spark_prog zgs_ps), 1),
	("ps_length_subunit_env", Combinators.I, length (#subunit_env zgs_ps), 0)
];
store_mt_results_show mt_run [
	("ps_script_name", (fn () => (#script_name zgs_ps)), (),
		"ps")
];
let
val block1_ps = hd (#blocks zgs_ps);
in
store_mt_results_show mt_run [
	("ps_decflags", (fn () => (#flags(#declab block1_ps))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false})
]
end;
=TEX
=SML
val (name_ps, pack_ps) = hd(#pack_env zgs_ps);
=TEX
=SML
store_mt_results_show mt_run [
	("ps_pack_name", Combinators.I,  name_ps, "PACK")
];
store_mt_results_show mt_run [
	("ps_pack_vc_vars", flat o map (fn {vars = v,...}=> v),  
		#vc_vars pack_ps, ["X", "X1", "X2"])
];
store_mt_results_show mt_run [
	("ps_pack_with_modules", Combinators.I,  
		#pack_spec_with_modules pack_ps, [])
];
store_mt_results_show mt_run [
	("ps_pack_consts", pack_const_decls, pack_ps, 
		["Y", "Y1", "Y2"])
];
store_mt_results_show mt_run [
	("ps_pack_types", pack_type_decls, pack_ps, 
		["INT_TYPE", "AINT_TYPE"])
];
store_mt_results_show mt_run [
	("ps_pack_fprocs", map (fn {name = v,...}=> v),  
		#formal_procs pack_ps, ["P1", "Q1"])
];
store_mt_results_show mt_run [
	("ps_pack_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pack_ps, [["FX"], ["X1"]])
];
store_mt_results_show mt_run [
	("ps_pack_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pack_ps, [[["FX"]], []])
];
store_mt_results_show mt_run [
	("ps_pack_ffuns", map (fn {informal_fun = {name = v,...} ,...}=> v),  
		#formal_funs pack_ps, ["F1", "G1"])
];
store_mt_results_show mt_run [
	("ps_pack_ffuns_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_funs pack_ps, [["F1"], ["G1"]])
];
store_mt_results_show mt_run [
	("ps_pack_ffuns_fids", map 
		(fn {informal_fun = {formal_pars=fids,...},...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_funs pack_ps, [[["FY"]], []])
];
store_mt_results_show mt_run [
	("ps_pack_ifuns", map (fn {name = v,...}=> v),  
		#informal_funs pack_ps, ["F", "G"])
];
store_mt_results_show mt_run [
	("ps_pack_ifuns_fids", map 
		(fn {formal_pars=fids,...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#informal_funs pack_ps, [[["FY"]], []])
];

=TEX
\section{FILLING IN K-SLOTS}
Until WP 9 is done, nothing much changes when k-slots are filled in
in package specifications.
=SML
val state1 = get_cn_state();
¹CN
(1) é Z : INTEGER;
°
¹CN
(2) é  procedure P1(FX : out INTEGER)
   „ FX [ X > 10, FX > 0 ];
°
=SML
val zgs_slabel = get_z_generator_state();

store_mt_results_show mt_run [
	("slabel_length_blocks", Combinators.I, length (#blocks zgs_slabel), 1),
	("slabel_length_dec_env", Combinators.I, length (#dec_env zgs_slabel), 2),
	("slabel_length_pack_env", Combinators.I, length (#pack_env zgs_slabel), 1),
	("slabel_length_repl_env", Combinators.I, length (#repl_env zgs_slabel), 2),
	("slabel_length_spec_env", Combinators.I, length (#spec_env zgs_slabel), 0),
	("slabel_length_spark_prog", Combinators.I, length (#spark_prog zgs_slabel), 1),
	("slabel_length_subunit_env", Combinators.I, length (#subunit_env zgs_slabel), 0)
];
store_mt_results_show mt_run [
	("slabel_script_name", (fn () => (#script_name zgs_slabel)), (),
		"ps")
];
let
val block1_slabel = hd (#blocks zgs_slabel);
in
store_mt_results_show mt_run [
	("slabel_decflags", (fn () => (#flags(#declab block1_slabel))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false})
]
end;
=TEX
=SML
val (name_slabel, pack_slabel) = hd(#pack_env zgs_slabel);
=TEX
=SML
store_mt_results_show mt_run [
	("slabel_pack_name", Combinators.I,  name_slabel, "PACK")
];
store_mt_results_show mt_run [
	("slabel_pack_vc_vars", flat o map (fn {vars = v,...}=> v),  
		#vc_vars pack_slabel, ["X", "X1", "X2"])
];
store_mt_results_show mt_run [
	("slabel_pack_consts", pack_const_decls, pack_slabel, 
		["Y", "Y1", "Y2"])
];
store_mt_results_show mt_run [
	("slabel_pack_types", pack_type_decls, pack_slabel, 
		["INT_TYPE", "AINT_TYPE"])
];
store_mt_results_show mt_run [
	("slabel_pack_fprocs", map (fn {name = v,...}=> v),  
		#formal_procs pack_slabel, ["P1", "Q1"])
];
store_mt_results_show mt_run [
	("slabel_pack_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pack_slabel, [["FX"], ["X1"]])
];
store_mt_results_show mt_run [
	("slabel_pack_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pack_slabel, [[["FX"]], []])
];
store_mt_results_show mt_run [
	("slabel_pack_ffuns", map (fn {informal_fun = {name = v,...} ,...}=> v),  
		#formal_funs pack_slabel, ["F1", "G1"])
];
store_mt_results_show mt_run [
	("slabel_pack_ffuns_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_funs pack_slabel, [["F1"], ["G1"]])
];
store_mt_results_show mt_run [
	("slabel_pack_ffuns_fids", map 
		(fn {informal_fun = {formal_pars=fids,...},...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_funs pack_slabel, [[["FY"]], []])
];
store_mt_results_show mt_run [
	("slabel_pack_ifuns", map (fn {name = v,...}=> v),  
		#informal_funs pack_slabel, ["F", "G"])
];
store_mt_results_show mt_run [
	("slabel_pack_ifuns_fids", map 
		(fn {formal_pars=fids,...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#informal_funs pack_slabel, [[["FY"]], []])
];
=TEX
=SML
val slabel_inscope = (#in_scope(#declab(hd(#blocks zgs_slabel))));
store_mt_results_show mt_run [
	("slabel_inscope_vc_pars", Combinators.I,  
		#vc_pars slabel_inscope, [])
];
store_mt_results_show mt_run [
	("slabel_inscope_vc_vars", flat o map (fn {vars = v,...} => v),  
		#vc_vars slabel_inscope, ["Z"])
];
store_mt_results_show mt_run [
	("slabel_inscope_dec_labels", Combinators.I,  
		#dec_labels slabel_inscope, [])
];
store_mt_results_show mt_run [
	("slabel_inscope_vc_aux_vars", map 
		(fst o dest_var o hd o fst o dest_z_dec),  
		#vc_aux_vars slabel_inscope, 
		[])
];
store_mt_results_show mt_run [
	("slabel_inscope_vc_log_cons", map string_of_term,  
		#vc_log_cons slabel_inscope, [])
];
store_mt_results_show mt_run [
	("slabel_inscope_formal_procs", 
		map (fn {name = n,...}=> n),  
		#formal_procs slabel_inscope, [])
];
store_mt_results_show mt_run [
	("slabel_inscope_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs slabel_inscope, [])
];
store_mt_results_show mt_run [
	("slabel_inscope_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs slabel_inscope, [])
];
=TEX

=SML
store_mt_results_show mt_run [
	("slabel_consts", map (fst o dest_const),  
		(rev(get_consts "ps")), map (fn x => implode["z'", x]) [
"INT_TYPE", "INT_TYPEvFIRST", "INT_TYPEvLAST",
"INT_TYPEvSUCC", "INT_TYPEvPRED", "INT_TYPEvPOS", 
"INT_TYPEvVAL", "Y", "AINT_TYPE", "AINT_TYPEvFIRST",
"AINT_TYPEvLAST", "AINT_TYPEvSUCC", "AINT_TYPEvPRED",
"AINT_TYPEvPOS", "AINT_TYPEvVAL", "Y1", "Y2"])
];
=TEX

\section{AFTER WITH}
=SML
val state2 = get_cn_state();
new_script{name="afterwith", state = state2};
¹CN
with PACK;
package PACK1 is
	X : INTEGER;
end PACK1;
° 
=SML
val zgs_afterwith = get_z_generator_state();

store_mt_results_show mt_run [
	("afterwith_length_blocks", Combinators.I, length (#blocks zgs_afterwith), 1),
	("afterwith_length_dec_env", Combinators.I, length (#dec_env zgs_afterwith), 0),
	("afterwith_length_pack_env", Combinators.I, length (#pack_env zgs_afterwith), 2),
	("afterwith_length_repl_env", Combinators.I, length (#repl_env zgs_afterwith), 0),
	("afterwith_length_spec_env", Combinators.I, length (#spec_env zgs_afterwith), 0),
	("afterwith_length_spark_prog", Combinators.I, length (#spark_prog zgs_afterwith), 1),
	("afterwith_length_subunit_env", Combinators.I, length (#subunit_env zgs_afterwith), 0)
];
store_mt_results_show mt_run [
	("afterwith_script_name", (fn () => (#script_name zgs_afterwith)), (),
		"afterwith")
];
let
val block1_afterwith = hd (#blocks zgs_afterwith);
in
store_mt_results_show mt_run [
	("afterwith_decflags", (fn () => (#flags(#declab block1_afterwith))), (),
		{fun_flag = false,
               stub_flag = false,
               till_flag = false,
               subunit_flag = false,
               declabel_flag = false,
               pack_body_flag = false,
               pack_spec_flag = false,
               speclabel_flag = false,
               formal_body_flag = false})
]
end;
=TEX
=SML
val pack_afterwith = force_value(
	s_lookup "PACK1" (#pack_env zgs_afterwith));
=TEX
=SML
store_mt_results_show mt_run [
	("afterwith_pack_vc_vars", flat o map (fn {vars = v,...}=> v),  
		#vc_vars pack_afterwith, ["X"])
];
store_mt_results_show mt_run [
	("afterwith_pack_with_modules", Combinators.I,  
		#pack_spec_with_modules pack_afterwith, ["PACK"])
];
store_mt_results_show mt_run [
	("afterwith_pack_consts", pack_const_decls, pack_afterwith, 
		[])
];
store_mt_results_show mt_run [
	("afterwith_pack_types", pack_type_decls, pack_afterwith, 
		[])
];
store_mt_results_show mt_run [
	("afterwith_pack_fprocs", map (fn {name = v,...}=> v),  
		#formal_procs pack_afterwith, [])
];
store_mt_results_show mt_run [
	("afterwith_pack_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs pack_afterwith, [])
];
store_mt_results_show mt_run [
	("afterwith_pack_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs pack_afterwith, [])
];
store_mt_results_show mt_run [
	("afterwith_pack_ffuns", map (fn {informal_fun = {name = v,...} ,...}=> v),  
		#formal_funs pack_afterwith, [])
];
store_mt_results_show mt_run [
	("afterwith_pack_ffuns_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_funs pack_afterwith, [])
];
store_mt_results_show mt_run [
	("afterwith_pack_ffuns_fids", map 
		(fn {informal_fun = {formal_pars=fids,...},...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_funs pack_afterwith, [])
];
store_mt_results_show mt_run [
	("afterwith_pack_ifuns", map (fn {name = v,...}=> v),  
		#informal_funs pack_afterwith, [])
];
store_mt_results_show mt_run [
	("afterwith_pack_ifuns_fids", map 
		(fn {formal_pars=fids,...} => 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#informal_funs pack_afterwith, [])
];
=TEX
=SML
val afterwith_inscope = (#in_scope(#declab(hd(#blocks zgs_afterwith))));
store_mt_results_show mt_run [
	("afterwith_inscope_vc_pars", Combinators.I,  
		#vc_pars afterwith_inscope, [])
];
store_mt_results_show mt_run [
	("afterwith_inscope_vc_vars", flat o map (fn {vars = v,...} => v),  
		#vc_vars afterwith_inscope, ["PACKoX", "PACKoX1", "PACKoX2"])
];
store_mt_results_show mt_run [
	("afterwith_inscope_dec_labels", Combinators.I,  
		#dec_labels afterwith_inscope, [])
];
store_mt_results_show mt_run [
	("afterwith_inscope_vc_aux_vars", map 
		(fst o dest_var o hd o fst o dest_z_dec),  
		#vc_aux_vars afterwith_inscope, 
		["PACKos", "PACKos1"])
];
store_mt_results_show mt_run [
	("afterwith_inscope_vc_log_cons", map string_of_term,  
		#vc_log_cons afterwith_inscope, [])
];
store_mt_results_show mt_run [
	("afterwith_inscope_formal_procs", 
		map (fn {name = n,...}=> n),  
		#formal_procs afterwith_inscope, ["PACKoP1", "PACKoQ1"])
];
store_mt_results_show mt_run [
	("afterwith_inscope_fprocs_w", map (fn {spec = {w=w,...},...}=> w),  
		#formal_procs afterwith_inscope, [["FX"],["PACKoX1"]])
];
store_mt_results_show mt_run [
	("afterwith_inscope_fprocs_fids", map (fn {formal_ids=fids,...}=> 
			map (fn {var_decl={vars=v,...},...} => v) fids),  
		#formal_procs afterwith_inscope, [[["FX"]],[]])
];
=TEX
=SML
store_mt_results_show mt_run [
	("afterwith_consts", map (fst o dest_const),  
		(rev(get_consts "PACKspec")), map (fn x => implode["z'", x]) [
"PACKoINT_TYPE", "PACKoINT_TYPEvFIRST", "PACKoINT_TYPEvLAST",
"PACKoINT_TYPEvSUCC", "PACKoINT_TYPEvPRED", "PACKoINT_TYPEvPOS", 
"PACKoINT_TYPEvVAL", "PACKoY", "PACKoAINT_TYPE", "PACKoAINT_TYPEvFIRST",
"PACKoAINT_TYPEvLAST", "PACKoAINT_TYPEvSUCC", "PACKoAINT_TYPEvPRED",
"PACKoAINT_TYPEvPOS", "PACKoAINT_TYPEvVAL", "PACKoY1", "PACKoY2", "PACKoF",
"PACKoG", "PACKoF1", "PACKoG1"])
];
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\pagebreak
\end{document}
=IGN
