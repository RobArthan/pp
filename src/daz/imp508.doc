% imp508.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP508}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD504}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX

\subsection{PREAMBLE}

SML
structure ÛCNBasicDeclsAndExprsÝ : CNBasicDeclsAndExprs  = struct
local
	open CaseIndependence CNTypes CNEnvironmentTypes ZProofMode;
in
=TEX
=SML
fun Ûbasic_decl_errorÝ (s : string) : 'a = (
	fail s 0 []
);
=TEX
=SML
val ÛheadÝ = hd
and ÛlastÝ = hd o rev;
=TEX
\section{ABSTRACT SYNTAX OF Z}
\subsection{Z Expressions}

We need the following types:
=SML
	val a = ”'a®;
	val Ûð'aÝ : TYPE = mk_z_power_type a;
	val b = ”'b®;
	val Ûð'bÝ : TYPE = mk_z_power_type b;
	val ú = mk_ctype("ú", []);
=TEX
=SML
=TEX
=SML
fun Ûcn_substÝ (ts : (TERM * string) list) (tm : TERM) : TERM = (
let	val freevars = frees tm;
	val fvs = map dest_var freevars;
	val newtys = map (fn (tm,c) => (c, type_of tm)) ts;
	val tymap = map (fn (n, ty) => (ty,lassoc3 fvs n)) newtys;
	val tymap' = (fn (t1,t2) => type_match
		(mk_ctype ("A",t1)) (mk_ctype("A",t2))) (split tymap);
	val tm_inst = inst [] tymap' tm;
	val namemap = map (fn (tm, s) => (tm, mk_var(s, lassoc3 newtys s))) ts;
in
	subst namemap tm_inst
end);
=TEX

=SML
val Ûz_succÝ : Z_EXP = ñsucc x®;
=TEX

=SML
val Ûz_dotdotÝ : TERM = ña .. b®;
fun Ûmake_dotdotÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_dotdot
);
=TEX

=SML
val Ûz_sizeÝ : TERM = ñ# a®;
fun Ûmake_sizeÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_size
);
=TEX

=SML
val Ûz_­Ý : TERM = ña ­ b®;
fun Ûmake_­Ý (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_­
);
=TEX

=SML
val Ûz_òÝ : TERM = ña ò b®;
fun Ûmake_òÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_ò
);
=TEX

=SML
val Ûz_iinvÝ : TERM = ña ç~ê®;
fun Ûmake_invÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_iinv
);
=TEX

=SML
val Ûz_id_relÝ : TERM = ñid a®;
fun Ûmake_id_relÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_id_rel
);
=TEX

=SML
=TEX
=SML
fun ÛzidÝ (id :Z_ID) : Z_EXP = mk_z_lvar(id, a, []);
=TEX
=SML
val Ûz_numÝ : int -> Z_EXP = (mk_z_int o string_of_int);
=TEX
=SML
val Ûz_rngÝ : (Z_EXP * Z_EXP) -> Z_EXP = make_dotdot;
=TEX
=SML
val Ûz_dom_resÝ : (Z_EXP * Z_EXP) -> Z_EXP = make_ò;
=TEX
=SML
val Ûz_invÝ : Z_EXP -> Z_EXP = make_inv;
=TEX
=SML
val Ûz_id_relÝ : Z_EXP -> Z_EXP = make_id_rel;
=TEX
=SML
val Ûz_sizeÝ : Z_EXP -> Z_EXP = make_size;
=TEX
=SML
fun Ûz_setÝ (exps : Z_EXP list) : Z_EXP = (
	mk_z_setd(”'a®, exps)
);
=TEX
=SML
val Ûz_tfunÝ : (Z_EXP * Z_EXP) -> Z_EXP = make_­;
=TEX
=SML
fun Ûz_set_minusÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	mk_z_app(ñ(_ \ _)®, mk_z_tuple[exp1,exp2])
);
=TEX
=SML
fun Ûz_eq_eqÝ (id : Z_ID, exp : Z_EXP) : PARAINFO = (
	AbbDefInfo (id, [], exp)
);
=TEX

\section{TRANSLATING SPARK BASIC DECLARATIONS}

\subsection{Translating Constants}

=TEX
=SML
fun Ûtrans_idÝ id = (

let	fun aux (c::rest) = (
		case c of
		"." => "o"::aux rest
		|"'" => "v"::aux rest
		|_ => (to_upper c)::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
);
=TEX
=SML
fun trans_exp exp = (
	ñú®
);
=TEX
=SML
fun basic_decl_const {consts=consts, tm=tm, expr=expr} = (
	map (fn c => z_eq_eq(trans_id c, trans_exp expr)) consts
);
=TEX
\subsection{Translating Types}
=SML
val	zfst = trans_id "first"
and	zlst = trans_id "last"
and	zsuc = trans_id "succ"
and	zpred = trans_id "pred"
and	zpos = trans_id "pos"
and	zval = trans_id "val"
and	zlength = trans_id "length"
and	zrange = trans_id "range";
=TEX
=SML
infix 3 ^^;
fun zid1 Û^^Ý zid2 = (
	zid1^"v"^zid2
);
=TEX
=SML
fun Ûenum_attribÝ (zid‰1, zid‰2, zid‰3) = (
let	val zexp = z_set_minus (zid zid‰1, z_set[zid (zid‰1^^zlst)]);
in
	[z_eq_eq (zid‰1 ^^ zfst, zid zid‰2),
	z_eq_eq (zid‰1 ^^ zlst, zid zid‰3),
	z_eq_eq (zid‰1 ^^ zsuc, z_dom_res (zexp, z_succ)),
	z_eq_eq(zid‰1 ^^ zpred, z_inv(zid (zid‰1 ^^ zsuc))),
	z_eq_eq(zid‰1 ^^ zpos, z_id_rel (zid zid‰1)),
	z_eq_eq(zid‰1 ^^ zval, z_inv(zid(zid‰1 ^^ zpos)))]
end);
=TEX
=SML
fun Ûbasic_decl_enumÝ ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val {vals=vals} =
		case type_def of
		TDEnumTypeDef td => td
		|_ => basic_decl_error "basic_decl_enum";
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map z_num (interval 0 ((length vals)-1));
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid(head zvals), zid(last zvals)))] @
	enum_attrib(zname, head zvals, last zvals)
end);
=TEX
=SML
fun Ûint_type_attribÝ (zid‰1, RRange{lo=lo, hi=hi}) = (
	[z_eq_eq(zid‰1 ^^ zfst, trans_exp lo),
	z_eq_eq(zid‰1 ^^ zlst, trans_exp hi)]
) | int_type_attrib _ = basic_decl_error "int_type_attrib";
=TEX
=SML
fun Ûbasic_decl_int_typeÝ ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val (lo, hi) =
		case type_def of
		TDIntTypeDef (RRange{lo=lo,hi=h}) => (lo, h)
		|_ => basic_decl_error "basic_decl_enum";
	val zname = trans_id name;
in
	[z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi))] @
		int_type_attrib(zname, RRange{lo=lo,hi=hi})
end);
=TEX
=SML
fun Ûarray_attribÝ (zid‰1 : Z_ID, zid‰2 : Z_ID) : PARAINFO list = (
	[z_eq_eq(zid‰1 ^^ zfst, zid (zid‰2 ^^ zfst)),
	z_eq_eq(zid‰1 ^^ zlst, zid (zid‰2 ^^ zlst)),
	z_eq_eq(zid‰1 ^^ zlength, z_size (zid zid‰2)),
	z_eq_eq(zid‰1 ^^ zrange, zid zid‰2)]
);
=TEX
=SML
fun Ûbasic_decl_con_arrayÝ ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val {index=index, comp=comp} =
		case type_def of
		TDConArrayDef td => td
		|_ => basic_decl_error "basic_decl_con_array";
	val zname = trans_id name;
	val zindex = trans_id index;
	val zcomp = trans_id comp;
in
	[z_eq_eq(zname, z_tfun(zid zindex, zid zcomp))] @
		array_attrib(zname, zindex)
end);
=TEX

\subsection{Translating Subtypes}

\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{Translating Identifiers}

\subsection{Translating Integer Literals}

\subsection{Translating Aggregates}

\subsection{Translating Unary Expressions}

\subsection{Translating Binary Expressions}

\sbusection{Translating Attributes}

\subsection{Translating Indexed Components}

\subsection{Translating Selected Components}

\subsection{Translating Functions Calls}

\subsection{Translating Auxiliary Expressions}

\subsection{Epilogue}

=SML
end (* of local...in *);
end (* structure CNBasicDeclsAndExprs *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

=IGN

 ¹CN
(4)é
p: constant integer := 3;
°

 ¹CN
(4)é
type day is (mon,tue,wed,thu,fri,sat, sun);
°

 ¹CN
(4)é
type hours is range 0..23;
°

