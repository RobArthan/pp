% imp508.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP508}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD504}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX

\subsection{PREAMBLE}

SML
structure ÛCNBasicDeclsAndExprsÝ : CNBasicDeclsAndExprs  = struct
local
	open CaseIndependence CNTypes CNEnvironmentTypes ZProofMode;
in
=TEX
=SML
fun name_to_tmark (e : EXP) : TMARK = (
	case e of
	EId id =>
		id
	|EInt n =>
		n
	|ESelectedComp {prefix=p, selector=s} =>
		(name_to_tmark p)^"."^s
	|EIndexedComp {prefix=p, index=i} =>
		(name_to_tmark p)^"("^(name_to_tmark i)^")"
	|EAttribute {prefix=p, attribute_desig=ad} =>
		(name_to_tmark p)^"'"^
		(
			case ad of
			ADAttrib a => a
			|ADAttribArg (a, e) => a^"("^(name_to_tmark e)^")"
		)
	|_ => "__unknown"
);
=TEX
=SML
fun Ûbasic_decl_errorÝ (s : string) : 'a = (
	fail s 0 []
);
=TEX
=SML
val ÛheadÝ = hd
and ÛlastÝ = hd o rev;
=TEX
\section{ABSTRACT SYNTAX OF Z}

\subsection{Z Declarations}

Z Declarations are modelled in \cite{ISS/HAT/DAZ/DTD513}.

\subsection{Z Unary Expressions}
=SML
val		Ûz_unary_minusÝ =	ñ(~ _)®
	and	Ûz_bool_notÝ =		ñ(not _)®
	and	Ûz_absÝ =		ñ(Abs _)®;
=TEX
\subsection{Z Binary Expressions}
=SML
val 		Ûz_bool_andÝ =		ñ(_ and _)®
	and	Ûz_bool_orÝ =		ñ(_ or _)®
	and	Ûz_bool_xorÝ =		ñ(_ xor _)®
	and	Ûz_bool_eqÝ =		ñ(_ eq _)®
	and	Ûz_bool_noteqÝ =	ñ(_ noteq _)®
	and	Ûz_bool_lessÝ =		ñ(_ less _)®
	and	Ûz_bool_less_eqÝ =	ñ(_ less_eq _)®
	and	Ûz_bool_greaterÝ =	ñ(_ greater _)®
	and	Ûz_bool_greater_eqÝ =	ñ(_ greater_eq _)®
	and	Ûz_addÝ =		ñ(_ + _)®
	and	Ûz_minusÝ =		ñ(_ - _)®
	and	Ûz_timesÝ =		ñ(_ * _)®
	and	Ûz_intdivÝ =		ñ(_ intdiv _)®
	and	Ûz_modÝ =		ñ(_ mod _)®
	and	Ûz_remÝ =		ñ(_ rem _)®
	and	Ûz_exponÝ =		ñ(_ ** _)®
	and	Ûz_bool_memÝ =		ñ(_ mem _)®
	and	Ûz_bool_notmemÝ =	ñ(_ notmem _)®
=TEX

\subsection{Z Expressions}
The following function allows the Z constructor functions to be presented in a way which is visually appealing.
=SML
fun Ûcn_substÝ (ts : (TERM * string) list) (tm : TERM) : TERM = (
let	val freevars = frees tm;
	val fvs = map dest_var freevars;
	val newtys = map (fn (tm,c) => (c, type_of tm)) ts;
	val tymap = map (fn (n, ty) => (ty,lassoc3 fvs n)) newtys;
	val tymap' = (fn (t1,t2) => type_match
		(mk_ctype ("A",t1)) (mk_ctype("A",t2))) (split tymap);
	val tm_inst = inst [] tymap' tm;
	val namemap = map (fn (tm, s) => (tm, mk_var(s, lassoc3 newtys s))) ts;
in
	subst namemap tm_inst
end);
=TEX


=SML
val ÛzsuccÝ : Z_EXP = ñsucc®;
=TEX
=SML
val Ûblip_aÝ = ”'a®;
fun ÛzidÝ (id :Z_ID) : Z_EXP = mk_z_lvar(id, blip_a, []);
=TEX
=SML
val Ûz_numÝ : int -> Z_EXP = (mk_z_int o string_of_int);
=TEX
=SML
val Ûz_tfun_termÝ : TERM = ña ­ b®;
fun Ûz_tfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_tfun_term
);
=TEX
=SML
val Ûz_pfun_termÝ : TERM = ña ß b®;
fun Ûz_pfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_pfun_term
);
=TEX
=SML
val Ûz_rng_termÝ : TERM = ña .. b®;
fun Ûz_rngÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term
);
=TEX
=SML
val Ûz_dom_termÝ : TERM = ñdom a®;
fun Ûz_domÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_dom_term
);
=TEX
=SML
val Ûz_dom_res_termÝ : TERM = ña ò b®;
fun Ûz_dom_resÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_dom_res_term
);
=TEX
=SML
val Ûz_inv_termÝ : TERM = ña ç~ê®;
fun Ûz_invÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_inv_term
);
=TEX
=SML
val Ûz_id_rel_termÝ : TERM = ñid a®;
fun Ûz_id_relÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_id_rel_term
);
=TEX
=SML
val Ûz_size_termÝ : TERM = ñ# a®;
fun Ûz_sizeÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_size_term
);
=TEX
=SML
val Ûz_empty_set_termÝ : TERM = ñ{}®;
fun Ûz_setÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_setd(type_of e, exps)
) | z_set _ = z_empty_set_term;
=TEX
=SML
val Ûz_set_minus_termÝ : TERM = ña \ b®;
fun Ûz_set_minusÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_set_minus_term
);
=TEX
=SML
fun Ûz_set_compÝ ((d,e) : Z_DECL, p : Z_EXP) : Z_EXP = (
let	val dexp = mk_z_lvar(d, type_of e, []);
	val decl = mk_z_decl[mk_z_dec ([dexp],e)];
in
	mk_z_seta (decl, p, dexp)
end
);
=TEX
=SML
val Ûz_power_termÝ : TERM = ña ç b ê®;
fun Ûz_powerÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_power_term
);
=TEX
=SML
val Ûz_rel_comp_termÝ : TERM = ña » b®;
fun Ûz_rel_compÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_rel_comp_term
);
=TEX
=SML
val Ûz_empty_seq_termÝ : TERM = ñ§¢®;
fun Ûz_seqÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_§¢(type_of e, exps)
) | z_seq _ = z_empty_seq_term;
=TEX
=SML
val Ûz_cross_termÝ : TERM = ña ¸ b®;
fun Ûz_crossÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_cross_term
);
=TEX
=SML
val Ûz_override_termÝ : TERM = ña « b®;
fun Ûz_overrideÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_override_term
);
=TEX
=SML
val Ûz_union_termÝ : TERM = ña À b®;
fun Ûz_many_unionÝ ((exps as e1::e2::rest) : Z_EXP list) : Z_EXP = (
	cn_subst [(e1, "a"), (z_many_union (e2::rest), "b")] z_union_term
) | z_many_union [e] = e
  | z_many_union _ = fail "z_many_union" 508001 [fn()=>"weird error"];
=TEX
=SML
fun Ûz_muÝ (id : Z_ID, p : Z_PRED) : Z_EXP = (
let	val name = (fst o dest_const)(mk_z_gvar(id, blip_a, []));
	val ty = case get_const_type name of
		Value ty => ty
		|Nil => fail "z_mu" 508001 [];
	val dexp = mk_z_gvar(id, ty, []);
	val decl = mk_z_decl[mk_z_schema_dec (dexp, "")];
in
	mk_z_Í (decl, p, dexp)
end
);
=TEX
=SML
val Ûz_unary_expÝ : (Z_EXP * Z_EXP) -> Z_EXP = mk_z_app;
=TEX
=SML
fun Ûz_bin_expÝ (left : Z_EXP, bop : Z_EXP, right : Z_EXP) : Z_EXP = (
	mk_z_app (bop, mk_z_tuple[left, right])
);
=TEX
=SML
fun Ûz_fun_callÝ (exp :Z_EXP, exps : Z_EXP list) : Z_EXP = (
	mk_z_app (exp, mk_z_tuple exps)
);
=TEX
=SML
val Ûz_selectionÝ : (Z_EXP * Z_ID) -> Z_EXP = mk_z_sel‰s;
=TEX
=SML
val Ûz_maplet_termÝ : TERM = ña í b®;
fun Ûz_mapletÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_maplet_term
);
=TEX
=SML
fun Ûother_z_expÝ (exp : Z_EXP) : Z_EXP = exp;
=TEX

\subsection{Z Predicates}
=SML
fun Ûz_eqÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	mk_z_eq (exp1, exp2)
);
=SML
fun Ûz_many_andÝ ((exps as e1::e2::rest) : Z_EXP list) : Z_EXP = (
	mk_z_± (e1, z_many_and (e2::rest))
) | z_many_and [e] = e
  | z_many_and _ = fail "z_many_and" 508001 [fn()=>"weird error"];
=TEX

\subsection{Z Paragraphs}
=SML
fun Ûz_eq_eqÝ (id : Z_ID, exp : Z_EXP) : PARAINFO = (
	AbbDefInfo (id, [], exp)
);
=TEX

\section{TRANSLATING SPARK EXPRESSIONS}

=SML
val		ÛzfstÝ = trans_id "FIRST"
	and	ÛzlstÝ = trans_id "LAST"
	and	ÛzsucÝ = trans_id "SUCC"
	and	ÛzpredÝ = trans_id "PRED"
	and	ÛzposÝ = trans_id "POS"
	and	ÛzvalÝ = trans_id "VAL"
	and	ÛzlengthÝ = trans_id "LENGTH"
	and	ÛzrangeÝ = trans_id "RANGE";
=TEX

\subsection{Translating Identifiers}
=SML
fun Ûtrans_idÝ (id : ID) : ID = (

let	fun aux (c::rest) = (
		case c of
		"." => "o"::aux rest
		|"'" => "v"::aux rest
		|_ => (to_upper c)::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
)
=TEX
=SML
and Ûexp_idÝ (ident : ID) : Z_EXP = (
	zid (trans_id ident)
)
=TEX
\subsection{Translating Aggregates (Positional Array)}
=SML
and Ûexp_array_agg_posÝ ({tmark, comps} : EXP AGG_POS) : Z_EXP = (
let	val zop = z_minus;
	val zleft = z_num 1;
	val zright = zid(trans_id tmark ^^ zfst);
	val zseq = map trans_exp comps;
in
	z_rel_comp(z_power(zsucc, z_bin_exp(zleft,zop, zright)), z_seq zseq)
end
)
=TEX
\subsection{Translating Aggregates (Positional Array with Others)}
=SML
and Ûexp_array_agg_pos_othersÝ ({agg_pos as {tmark,comps}, others} : EXP AGG_POS_OTHERS) : Z_EXP = (
	z_override(trans_exp (EArrayAggOthers {tmark=tmark,others=others}),
		trans_exp (EArrayAggPos agg_pos))
)
=TEX
\subsection{Translating Aggregates (Positional Array with Just Others)}
=SML
and Ûexp_array_agg_othersÝ ({tmark,others={others=ot}} : EXP AGG_OTHERS) : Z_EXP = (
	z_cross(zid(trans_id tmark ^^ zrange), z_set [trans_exp ot])
)
=TEX
\subsection{Translating Aggregates (Named Array)}
=SML
and Ûtrans_named_assocÝ ({choice,comp} : (AGG_CHOICE,EXP) NAMED_ASSOC) : Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		ACAggChoiceRange (DRRange(RRange{lo,hi})) =>
			z_rng(trans_exp lo, trans_exp hi)::aux_range rest
		|ACAggChoiceRange (DRRange _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|ACAggChoiceRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(trans_exp lo, trans_exp hi)::aux_range rest
		|ACAggChoiceRange (DRConstrained _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp =>
			trans_exp exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choice;
	val zsingles = aux_singles choice;
in
	z_cross (z_many_union(zranges @ [z_set zsingles]), z_set [trans_exp comp])
end
)
=TEX
=SML
and Ûexp_array_agg_namedÝ ({named_assocs} : (AGG_CHOICE,EXP) AGG_NAMED) : Z_EXP = (
	z_many_union (map trans_named_assoc named_assocs)
)
=TEX
\subsection{Translating Aggregates (Named Array with Others)}
=SML
and Ûexp_array_agg_named_othersÝ ({tmark,agg_named,others} : (AGG_CHOICE,EXP) AGG_NAMED_OTHERS) : Z_EXP = (
	z_override(trans_exp (EArrayAggOthers {tmark=tmark,others=others}),
		trans_exp (EArrayAggNamed agg_named))
)
=TEX
\subsection{Translating Aggregates (Positional Record)}
TBS - Proper code required for the following which is a stub.
=SML
and Ûretrieve_type_defÝ (tmark : TMARK) : TYPE_DEF = (
	TDRecordTypeDef{comps=[CNone]}
)
=TEX
=SML
and Ûexp_rec_agg_posÝ ({tmark, comps} : EXP AGG_POS) : Z_EXP = (
let	val rcomps = case retrieve_type_def tmark of
			TDRecordTypeDef {comps} => comps
			|_ => fail "exp_rec_agg_pos" 508001
				[fn()=>"not a record type"];
	fun get_decls (comp::rest) = (
		case comp of
		CDeclaration vdl => (
			let	val vars = flat(map (fn {vars,tmark} => vars) vdl);
			in
				vars@get_decls rest
			end)
		|_ => fail "exp_rec_agg_pos" 508001
				[fn()=>"variant records not supported"]
	) | get_decls _ = [];
	val zeqs = map (fn (d,c) =>
			z_eq(zid(trans_id d), trans_exp c))
			(combine (get_decls rcomps) comps);
	val zp = z_many_and zeqs;
in
	z_mu (trans_id tmark, zp)
end
)
=TEX
\subsection{Translating Aggregates (Named Record)}
=SML
and Ûexp_rec_agg_namedÝ ({tmark, named_assocs} : (AGG_CHOICE,EXP) REC_AGG_NAMED) : Z_EXP = (
let	fun expand_assocs comp (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp => (name_to_tmark exp, comp)
						::expand_assocs comp rest
		|_ => fail "exp_rec_agg_pos" 508001
				[fn()=>"range attributes not supported"]
	) | expand_assocs _ _ = [];

	fun do_assoc {choice, comp} = (
	let	val chcplist = expand_assocs comp choice;
	in
		map (fn (ch, comp) =>
			z_eq (zid (trans_id ch), trans_exp comp)) chcplist
	end
	);
	val zeqs = flat (map do_assoc named_assocs);
	val zp = z_many_and zeqs;
in
	z_mu (trans_id tmark, zp)
end
)
=TEX

\subsection{Translating Unary Expressions}
=SML
and Ûtrans_unary_opÝ (uop : UNARY_OP) = (
	case uop of
	UOSparkUnaryMinus => z_unary_minus
	|UOSparkNot => z_bool_not
	|UOSparkAbs => z_abs
	|_ => fail "trans_unary_op" 508001 []
)
=TEX
=SML
and Ûexp_unary_expÝ ({uop, right} : EXP UNARY_EXP) : Z_EXP = (
	case uop of
	UOSparkUnaryAdd => trans_exp right
	|_ => 	z_unary_exp (trans_unary_op uop, trans_exp right)
)
=TEX

\subsection{Translating Binary Expressions}
=SML
and Ûtrans_bin_opÝ (bop : BIN_OP) = (
	case bop of
	BOSparkAnd => z_bool_and
	|BOSparkAndThen => fail "trans_bin_op" 508001 [fn()=>"not supported"]
	|BOSparkOr => z_bool_or
	|BOSparkOrElse => fail "trans_bin_op" 508001 [fn()=>"not supported"]
	|BOSparkXor => z_bool_xor
	|BOSparkEq => z_bool_eq
	|BOSparkNotEq => z_bool_noteq
	|BOSparkLess => z_bool_less
	|BOSparkLessEq => z_bool_less_eq
	|BOSparkGreater => z_bool_greater
	|BOSparkGreaterEq => z_bool_greater_eq
	|BOSparkAdd => z_add
	|BOSparkMinus => z_minus
	|BOSparkTimes => z_times
	|BOSparkIntdiv => z_intdiv
	|BOSparkMod => z_mod
	|BOSparkRem => z_rem
	|BOSparkExpon => z_expon
	|BOSparkMem => z_bool_mem
	|BOSparkNotMem => z_bool_notmem
	|BOSparkConcat => fail "trans_bin_op" 508001 [fn()=>"not supported"]
)
=TEX
=SML
and Ûexp_bin_expÝ ({left, bop, right} : EXP BIN_EXP) : Z_EXP = (
	z_bin_exp (trans_exp left, trans_bin_op bop, trans_exp right)
)
=TEX
\subsection{Translating Membership of a Range}
=SML
and Ûtrans_rangeÝ ((RRange range) : EXP RANGE) : EXP RANGELOHI = (
	range
) | trans_range _ = fail "trans_range" 508001 [fn()=>"not supported"]
=TEX
=SML
and Ûexp_mem_rangeÝ ({left, mop, range} : EXP MEM_RANGE) : Z_EXP = (
let	val {lo=lo, hi=hi} = trans_range range;
	val zright = z_rng(trans_exp lo, trans_exp hi);
in
	z_bin_exp (trans_exp left, trans_bin_op mop, zright)
end
)
=TEX

\subsection{Translating Attributes}
TBS - name to tmark should not really be required...
=SML
and Ûexp_attribÝ ({prefix, attribute_desig=ADAttrib att} : (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
	zid (trans_id (name_to_tmark prefix) ^^ trans_id att)
)
=TEX
The following covers $Exp\_Attrib\_Arg$
=SML
  | Ûexp_attribÝ ({prefix, attribute_desig=ADAttribArg(att,arg)} : (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
let	val zfun = zid(trans_id (name_to_tmark prefix) ^^ trans_id att);
	val zargs = [trans_exp arg];
in
	z_fun_call (zfun, zargs)
end
)
=TEX
\subsection{Translating Indexed Components}
=SML
and Ûexp_indexed_compÝ ({prefix, index} : EXP INDEXED_COMP) : Z_EXP = (
	z_fun_call (trans_exp prefix, [trans_exp index])
)
=TEX
\subsection{Translating Selected Components}
=SML
and Ûexp_selected_compÝ ({prefix, selector} : EXP SELECTED_COMP) : Z_EXP = (
	z_selection (trans_exp prefix, trans_id selector)
)
=TEX
\subsection{Translating Functions Calls}
=SML
and Ûexp_fun_callÝ ({fun_name, args} : EXP FUN_CALL) : Z_EXP = (
	z_fun_call (zid (trans_id fun_name), map trans_exp args)
)
=TEX
\subsection{Translating Integer Literals}
TBS - trans_int needs to translate ada integers.
=SML
and Ûtrans_intÝ (n : INT_LIT) : int = (
	nat_of_string n
)
=TEX
=SML
and Ûexp_int_litÝ (n : INT_LIT) : Z_EXP = (
	z_num (trans_int n)
)
=TEX
\subsection{Translating Auxiliary Expressions}
=SML
and Ûexp_auxiliary_expÝ (ae : Z_EXP) : Z_EXP = (
	ae
)
=TEX
\subsection{The function $trans\_exp$}
=SML
and Ûtrans_expÝ (exp as (EId id) : EXP) : Z_EXP = exp_id id
  | trans_exp (exp as (EInt n)) = exp_int_lit n
  | trans_exp (exp as (EArrayAggPos ap)) = exp_array_agg_pos ap
  | trans_exp (exp as (EArrayAggPosOthers ap)) = exp_array_agg_pos_others ap
  | trans_exp (exp as (EArrayAggOthers ao)) = exp_array_agg_others ao
  | trans_exp (exp as (EArrayAggNamed an)) = exp_array_agg_named an
  | trans_exp (exp as (EArrayAggNamedOthers an)) = exp_array_agg_named_others an
  | trans_exp (exp as (ERecAggPos ap)) = exp_rec_agg_pos ap
  | trans_exp (exp as (ERecAggNamed an)) = exp_rec_agg_named an
  | trans_exp (exp as (EUnaryExp ue)) = exp_unary_exp ue
  | trans_exp (exp as (EBinExp be)) = exp_bin_exp be
  | trans_exp (exp as (EMemRange be)) = exp_mem_range be
  | trans_exp (exp as (EAttribute at)) = exp_attrib at
  | trans_exp (exp as (EIndexedComp ic)) = exp_indexed_comp ic
  | trans_exp (exp as (ESelectedComp sc)) = exp_selected_comp sc
  | trans_exp (exp as (EFunCall fc)) = exp_fun_call fc
  | trans_exp (exp as (EAuxiliaryExp ae)) = exp_auxiliary_exp ae
  | trans_exp (exp as (EQualifiedExp q)) =
	fail "trans_exp" 508001 [fn()=>"qualified expressions not supported"]
  | trans_exp (exp as (EBracketed e)) = trans_exp e
  | trans_exp (exp as (EStringLiteral c)) =
	fail "trans_exp" 508001 [fn()=>"string literals not supported"]
  | trans_exp (exp as (ECharacterLiteral c)) =
	fail "trans_exp" 508001 [fn()=>"character literals not supported"]
;
=TEX

\section{TRANSLATING SPARK BASIC DECLARATIONS}

\subsection{Translating Constants}

=TEX
=SML
=TEX
=SML
fun basic_decl_const {consts=consts, tm=tm, expr=expr} = (
	map (fn c => z_eq_eq(trans_id c, trans_exp expr)) consts
);
=TEX
\subsection{Translating Types}
=SML
infix 3 ^^;
fun zid1 Û^^Ý zid2 = (
	zid1^"v"^zid2
);
=TEX
=SML
fun Ûenum_attribÝ (zid‰1, zid‰2, zid‰3) = (
let	val zexp = z_set_minus (zid zid‰1, z_set[zid (zid‰1^^zlst)]);
in
	[z_eq_eq (zid‰1 ^^ zfst, zid zid‰2),
	z_eq_eq (zid‰1 ^^ zlst, zid zid‰3),
	z_eq_eq (zid‰1 ^^ zsuc, z_dom_res (zexp, zsucc)),
	z_eq_eq(zid‰1 ^^ zpred, z_inv(zid (zid‰1 ^^ zsuc))),
	z_eq_eq(zid‰1 ^^ zpos, z_id_rel (zid zid‰1)),
	z_eq_eq(zid‰1 ^^ zval, z_inv(zid(zid‰1 ^^ zpos)))]
end);
=TEX
=SML
fun Ûbasic_decl_enumÝ ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val {vals=vals} =
		case type_def of
		TDEnumTypeDef td => td
		|_ => basic_decl_error "basic_decl_enum";
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map z_num (interval 0 ((length vals)-1));
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid(head zvals), zid(last zvals)))] @
	enum_attrib(zname, head zvals, last zvals)
end);
=TEX
=SML
fun Ûint_type_attribÝ (zid‰1, RRange{lo=lo, hi=hi}) = (
	[z_eq_eq(zid‰1 ^^ zfst, trans_exp lo),
	z_eq_eq(zid‰1 ^^ zlst, trans_exp hi)]
) | int_type_attrib _ = basic_decl_error "int_type_attrib";
=TEX
=SML
fun Ûbasic_decl_int_typeÝ ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val (lo, hi) =
		case type_def of
		TDIntTypeDef (RRange{lo=lo,hi=h}) => (lo, h)
		|_ => basic_decl_error "basic_decl_enum";
	val zname = trans_id name;
in
	[z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi))] @
		int_type_attrib(zname, RRange{lo=lo,hi=hi})
end);
=TEX
=SML
fun Ûarray_attribÝ (zid‰1 : Z_ID, zid‰2 : Z_ID) : PARAINFO list = (
	[z_eq_eq(zid‰1 ^^ zfst, zid (zid‰2 ^^ zfst)),
	z_eq_eq(zid‰1 ^^ zlst, zid (zid‰2 ^^ zlst)),
	z_eq_eq(zid‰1 ^^ zlength, z_size (zid zid‰2)),
	z_eq_eq(zid‰1 ^^ zrange, zid zid‰2)]
);
=TEX
SML
fun Ûbasic_decl_con_arrayÝ ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val {index=index, comp=comp} =
		case type_def of
		TDConArrayDef td => td
		|_ => basic_decl_error "basic_decl_con_array";
	val zname = trans_id name;
	val zindex = trans_id index;
	val zcomp = trans_id comp;
in
	[z_eq_eq(zname, z_tfun(zid zindex, zid zcomp))] @
		array_attrib(zname, zindex)
end);
=TEX

\subsection{Translating Subtypes}

\subsection{Epilogue}

=SML
end (* of local...in *);
end (* structure CNBasicDeclsAndExprs *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

=IGN

 ¹CN
(4)é
p: constant integer := 3;
°

 ¹CN
(4)é
type day is (mon,tue,wed,thu,fri,sat, sun);
°

 ¹CN
(4)é
type hours is range 0..23;
°

