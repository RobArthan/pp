% imp508.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP508}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD504}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX

\section{PREAMBLE}

=SML
structure €CNBasicDeclsAndExprs› (*: CNBasicDeclsAndExprs *)  = struct
local
	open CaseIndependence CNTypes CNEnvironmentTypes ZProofMode;
in
=TEX

\section{MISCELLANEOUS SUPPORTING FUNCTIONS}

=SML
datatype €ENV_INFO› =
			€EIEnvFunction›
		|	€EIEnvRecordAgg›
		|	€EIEnvVar›
		|	€EIEnvOther›;
type CN_ENV = Z_ID -> TYPE * ENV_INFO;
=TEX

=SML
fun €name_to_tmark› (e : EXP) : TMARK = (
	case e of
	EId id =>
		id
	|EInt n =>
		n
	|ESelectedComp {prefix=p, selector=s} =>
		(name_to_tmark p)^"."^s
	|EIndexedComp {prefix=p, index=i} =>
		(name_to_tmark p)^"("^(name_to_tmark i)^")"
	|EAttribute {prefix=p, attribute_desig=ad} =>
		(name_to_tmark p)^"'"^
		(
			case ad of
			ADAttrib a => a
			|ADAttribArg (a, e) => a^"("^(name_to_tmark e)^")"
		)
	|_ => "__unknown"
);
=TEX


=SML
infix 3 ^^;
fun zid1 €^^› zid2 = (
	zid1^"v"^zid2
);
=TEX
TBS - The next function is extra.
=SML
fun €join_tmarks› ((s1::s2::rest) : string list) : string = (
	s1^"y"^join_tmarks (s2::rest)
) | join_tmarks (s::_) = s
  | join_tmarks _ = "";
=TEX
=SML
fun €z_decls_to_exp› (zdecls : Z_DECL list) : Z_EXP = (
let	fun dec (d,e) = mk_z_dec ([mk_z_lvar(d, type_of e, [])],e);
in
	mk_z_decl(map dec zdecls)
end
);
=TEX
=SML
fun €trans_range› ((RRange range) : EXP RANGE) : EXP RANGELOHI = (
	range
) | trans_range _ = fail "trans_range" 508001 [fn()=>"not supported"];
=TEX
=SML
fun €basic_decl_error› (s : string) : 'a = (
	fail s 0 []
);
=TEX
=SML
val €head› = hd
and €last› = hd o rev;
=TEX
\section{ABSTRACT SYNTAX OF Z}

\subsection{Z Declarations}

Z Declarations are modelled in \cite{ISS/HAT/DAZ/DTD513}.

\subsection{Z Unary Expressions}
=SML
val		€z_unary_minus› =	Ò(~ _)Æ
	and	€z_bool_not› =		Ò(not _)Æ
	and	€z_abs› =		Ò(Abs _)Æ;
=TEX
\subsection{Z Binary Expressions}
=SML
val 		€z_bool_and› =		Ò(_ and _)Æ
	and	€z_bool_or› =		Ò(_ or _)Æ
	and	€z_bool_xor› =		Ò(_ xor _)Æ
	and	€z_bool_eq› =		Ò(_ eq _)Æ
	and	€z_bool_noteq› =	Ò(_ noteq _)Æ
	and	€z_bool_less› =		Ò(_ less _)Æ
	and	€z_bool_less_eq› =	Ò(_ less_eq _)Æ
	and	€z_bool_greater› =	Ò(_ greater _)Æ
	and	€z_bool_greater_eq› =	Ò(_ greater_eq _)Æ
	and	€z_add› =		Ò(_ + _)Æ
	and	€z_minus› =		Ò(_ - _)Æ
	and	€z_times› =		Ò(_ * _)Æ
	and	€z_intdiv› =		Ò(_ intdiv _)Æ
	and	€z_mod› =		Ò(_ mod _)Æ
	and	€z_rem› =		Ò(_ rem _)Æ
	and	€z_expon› =		Ò(_ ** _)Æ
	and	€z_bool_mem› =		Ò(_ mem _)Æ
	and	€z_bool_notmem› =	Ò(_ notmem _)Æ
=TEX

\subsection{Z Expressions}
The following function allows the Z constructor functions to be presented in a way which is visually appealing.
=SML
fun €cn_subst› (ts : (TERM * string) list) (tm : TERM) : TERM = (
let	val freevars = frees tm;
	val fvs = map dest_var freevars;
	val newtys = map (fn (tm,c) => (c, type_of tm)) ts;
	val tymap = map (fn (n, ty) => (ty,lassoc3 fvs n)) newtys;
	val tymap' = (fn (t1,t2) => type_match
		(mk_ctype ("A",t1)) (mk_ctype("A",t2))) (split tymap);
	val tm_inst = inst [] tymap' tm;
	val namemap = map (fn (tm, s) => (tm, mk_var(s, lassoc3 newtys s))) ts;
in
	subst namemap tm_inst
end);
=TEX


=SML
val €zsucc› : Z_EXP = ÒsuccÆ;
=TEX
=SML
fun €zid› (env : CN_ENV) (id :Z_ID) : Z_EXP = (
	case env id of
	(ty, EIEnvVar) => mk_z_lvar(id, ty, [])
	|(ty, _) => mk_z_gvar(id, ty, [])
);
=TEX
=SML
val €z_num› : int -> Z_EXP = (mk_z_int o string_of_int);
=TEX
=SML
val €z_tfun_term› : TERM = Òa ≠ bÆ;
fun €z_tfun› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_tfun_term
);
=TEX
=SML
val €z_pfun_term› : TERM = Òa ﬂ bÆ;
fun €z_pfun› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_pfun_term
);
=TEX
=SML
val €z_rng_term› : TERM = Òa .. bÆ;
fun €z_rng› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term
);
=TEX
=SML
val €z_dom_term› : TERM = Òdom aÆ;
fun €z_dom› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_dom_term
);
=TEX
=SML
val €z_dom_res_term› : TERM = Òa Ú bÆ;
fun €z_dom_res› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_dom_res_term
);
=TEX
=SML
val €z_inv_term› : TERM = Òa Á~ÍÆ;
fun €z_inv› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_inv_term
);
=TEX
=SML
val €z_id_rel_term› : TERM = Òid aÆ;
fun €z_id_rel› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_id_rel_term
);
=TEX
=SML
val €z_size_term› : TERM = Ò# aÆ;
fun €z_size› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_size_term
);
=TEX
=SML
val €z_empty_set_term› : TERM = Ò{}Æ;
fun €z_set› ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_setd(type_of e, exps)
) | z_set _ = z_empty_set_term;
=TEX
=SML
val €z_set_minus_term› : TERM = Òa \ bÆ;
fun €z_set_minus› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_set_minus_term
);
=TEX
=SML
fun €z_set_comp› ((d,e) : Z_DECL, p : Z_EXP) : Z_EXP = (
let	val dexp = mk_z_lvar(d, type_of e, []);
	val decl = mk_z_decl[mk_z_dec ([dexp],e)];
in
	mk_z_seta (decl, p, dexp)
end
);
=TEX
=SML
val €z_power_term› : TERM = Òa Á b ÍÆ;
fun €z_power› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_power_term
);
=TEX
=SML
val €z_rel_comp_term› : TERM = Òa ª bÆ;
fun €z_rel_comp› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_rel_comp_term
);
=TEX
=SML
val €z_empty_seq_term› : TERM = Òß¢Æ;
fun €z_seq› ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_ß¢(type_of e, exps)
) | z_seq _ = z_empty_seq_term;
=TEX
=SML
val €z_cross_term› : TERM = Òa ∏ bÆ;
fun €z_cross› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_cross_term
);
=TEX
=SML
val €z_override_term› : TERM = Òa ´ bÆ;
fun €z_override› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_override_term
);
=TEX
=SML
val €z_union_term› : TERM = Òa ¿ bÆ;
fun €z_many_union› ((exps as e1::e2::rest) : Z_EXP list) : Z_EXP = (
	cn_subst [(e1, "a"), (z_many_union (e2::rest), "b")] z_union_term
) | z_many_union [e] = e
  | z_many_union _ = fail "z_many_union" 508001 [fn()=>"weird error"];
=TEX
=SML
fun €z_mu› (id : Z_ID, p : Z_PRED) : Z_EXP = (
let	val name = (fst o dest_const)(mk_z_gvar(id, mk_vartype "'a", []));
	val ty = case get_const_type name of
		Value ty => ty
		|Nil => fail "z_mu" 508001 [];
	val dexp = mk_z_gvar(id, ty, []);
	val decl = mk_z_decl[mk_z_schema_dec (dexp, "")];
in
	mk_z_Õ (decl, p, dexp)
end
);
=TEX
=SML
val €z_unary_exp› : (Z_EXP * Z_EXP) -> Z_EXP = mk_z_app;
=TEX
=SML
fun €z_bin_exp› (left : Z_EXP, bop : Z_EXP, right : Z_EXP) : Z_EXP = (
	mk_z_app (bop, mk_z_tuple[left, right])
);
=TEX
=SML
fun €z_fun_call› (exp :Z_EXP, exps : Z_EXP list) : Z_EXP = (
	mk_z_app (exp, mk_z_tuple exps)
);
=TEX
=SML
val €z_selection› : (Z_EXP * Z_ID) -> Z_EXP = mk_z_selâs;
=TEX
=SML
val €z_maplet_term› : TERM = Òa Ì bÆ;
fun €z_maplet› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_maplet_term
);
=TEX
=SML
fun €other_z_exp› (exp : Z_EXP) : Z_EXP = exp;
=TEX

\subsection{Z Predicates}
=SML
fun €z_eq› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	mk_z_eq (exp1, exp2)
);
=SML
fun €z_many_and› ((exps as e1::e2::rest) : Z_EXP list) : Z_EXP = (
	mk_z_± (e1, z_many_and (e2::rest))
) | z_many_and [e] = e
  | z_many_and _ = fail "z_many_and" 508001 [fn()=>"weird error"];
=TEX

\subsection{Z Paragraphs}
=SML
fun €z_eq_eq› (id : Z_ID, exp : Z_EXP) : PARAINFO = (
	AbbDefInfo (id, [], exp)
);
=TEX

=SML
val €z_true› = ÒtrueÆ;

fun €z_schema› (name : Z_ID, decls : Z_DECL list) : PARAINFO = (
	AbbDefInfo (name, [], mk_z_h_schema(z_decls_to_exp decls, z_true))
);
=TEX

\section{INTEGER LITERALS}\label{INTEGERLITERALS}

The translation of integer literals is non-trivial and several supporting functions for the translation of integer literals are introduced in this section. The function $trans\_int$ is introduced at the end of this section.
=SML
local
=TEX
\subsection{Support for $trans\_int$}

=SML
open	CaseIndependence;
open	Lex;
open	PolyML.Alternative_Div_and_Mod

type €NUMBERS› = string list;
type €NUMERIC› = {base : NUMBERS, m : NUMBERS, n : NUMBERS, expon : NUMBERS};
=TEX

\subsubsection{Phase 1: Recognising Numeric Literals}

In the exponent part when there is a sign, it is just copied into the number. The parser has already ensured that $+$ and $-$ can only appear at the start of an exponent, so a further check is not required here.
=SML
fun €recog_exponent_part› (dec as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS) : (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
	else case c of

		"_" =>	recog_exponent_part (dec, rest)
		|"+" => recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
		|"-" => recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
		|_ =>	(dec, c::rest)

) | recog_exponent_part (other, []) = (
	(other, [])
);
=TEX
=SML
fun €recog_decimal_part› (dec as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS) : (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_decimal_part ({base=base,m=m, n=n@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_decimal_part (dec, rest)
		|"e" => recog_exponent_part (dec, rest)
		|"E" => recog_exponent_part (dec, rest)
		|_ =>	(dec, c::rest)

) | recog_decimal_part (other, []) = (
	(other, [])
);
=TEX
=SML
fun €recog_based_dec_part› (nb as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS) : (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based_dec_part ({base=base,m=m, n=n@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_based_dec_part (nb, rest)
		|"#" => recog_numeric (nb, rest)
		|_ =>	(nb, c::rest)

) | recog_based_dec_part (other, []) = (
	fail "recog_based_dec_part" 508001 [fn()=>"incomplete based integer"]
)
=TEX

=SML
and €recog_based› (nb as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS) : (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based ({base=base,m=m@[c], n=n, expon=expon}, rest)
	else case c of

		"_" =>	recog_based (nb, rest)
		|"." => recog_based_dec_part (nb, rest)
		|"#" => recog_numeric (nb, rest)
		|_ =>	(nb, c::rest)

) | recog_based (other, []) = (
	fail "recog_based" 508001 [fn()=>"incomplete based integer"]
)
=TEX

=TEX
=SML
and €recog_numeric› (num as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS) : (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_numeric ({base=base,m=m@[c], n=n, expon=expon}, rest)
	else case c of

		"_" =>	recog_numeric (num, rest)
		|"." =>	recog_decimal_part (num, rest)
		|"e" => recog_exponent_part (num, rest)
		|"E" => recog_exponent_part (num, rest)
		|"#" => recog_based ({base=m,m=[],n=n,expon=expon}, rest)
		|_ =>	(num, c::rest)
) | recog_numeric other = other;
=TEX
\subsubsection{Phase 2 : Generating Integer Literals}

The following gives a lookup table for extended digits to values upto 16.

i.e., $[("0", 0), ("1", 1),...("F", 15)]$.
=SML
val €extended_digits› : (string * int) list = (
	combine
		(map string_of_int (interval 0 9)@["A","B","C","D","E","F"])
		(interval 0 15)
);
=TEX
=SML
fun €based_to_int› (base : int) (sl : NUMBERS) = (
let	val valid = extended_digits to (base-1);
	val sl' = map to_upper sl;
	val f = lassoc3 valid;
	fun aux (c::rest) = (
		f c + base * aux rest
	) | aux _ = 0;
in
	(aux o rev) sl' handle _ =>
			fail "based_to_int" 508001 [fn()=>"invalid base digit"]
end);
=TEX
=SML
fun €signed_nat_of_numbers› (sl : NUMBERS) : int = (
let	val f = nat_of_string o implode;
in
	case sl of
	("+"::n) => f n
	|("-"::n) => ~(f n)
	|_ => f sl
end);
=TEX
=SML
fun €basepow› (_ : int) (0 : int) : int = 1
  | basepow base n = base * basepow base (n-1);
=TEX
=SML
fun €convert_base_exp› ((base, m, expon) : (int*int*int)) : int = (
	if expon > 0
	then	m * basepow base expon
	else	let	val d = basepow base (~expon);
			val res = m div d;
		in
			if res * d = m
			then
				res
			else
				fail "convert_base_exp" 508001 [fn()=>"cannot convert"]
		end
);
=TEX
=SML
fun €no_of_digits_in› (base : int) (n : int) : int = (
	if quot (n, base) > 0
	then
		1 + no_of_digits_in base (n div base)
	else
		1
);
=TEX
=SML
fun €convert_base_dec_exp› ((base, m, n, expon) : (int*int*int*int)) : int = (
let	val nd = (no_of_digits_in base n) - 1;
	val df = expon - nd;
	val offset = basepow base nd;
in
	if df >= 0
	then
		 convert_base_exp (base, (m * offset + n - offset), df)
	else
		fail "nil_aux" 508001 [fn()=>"cannot convert"]
end);
=TEX
In the following, ``1'' is prefixed to the decimal part in order to preserve leadnig zeros when converting to an integer. It is removed in $convert\_base\_dec\_exp$.
=SML
fun €numeric_to_int_lit› ({base,m,n,expon} : NUMERIC) : int = (
let	val nbase = (nat_of_string o implode) base handle _ => 10;
	val f = if nbase = 10
		then
			fn a => (case a of
				(_::_) => (nat_of_string o implode) a
				| _ => 0
			)
		else
			based_to_int nbase;
	val nm = f m;
	val nn = f ("1"::n);
	val nexpon = signed_nat_of_numbers expon handle _ => 0;
in
	case (nbase,nm,nn,nexpon) of
	(10, _, 0, 0) => nm
	|(_, _, 0, _) => convert_base_exp (nbase,nm,nexpon)
	|_ => convert_base_dec_exp (nbase,nm,nn,nexpon)

end);
=TEX
\subsection{The Function $trans\_int$}
=SML
in (* of local ... in *)
=TEX
=SML
fun €trans_int› (i : INT_LIT) : int = (
	(numeric_to_int_lit o fst o recog_numeric)
		({base=[],m=[],n=[],expon=[]}, explode i)
);
=TEX
=SML
end (* of local ... in *);
=TEX

\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{Translating Identifiers}
=SML
fun €trans_id› (id : ID) : ID = (

let	fun aux (c::rest) = (
		case c of
		"." => "o"::aux rest
		|"'" => "v"::aux rest
		|_ => (to_upper c)::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
);
=TEX
=SML
val		€zfst› = trans_id "FIRST"
	and	€zlst› = trans_id "LAST"
	and	€zsuc› = trans_id "SUCC"
	and	€zpred› = trans_id "PRED"
	and	€zpos› = trans_id "POS"
	and	€zval› = trans_id "VAL"
	and	€zlength› = trans_id "LENGTH"
	and	€zrange› = trans_id "RANGE";
=TEX
=SML
fun €exp_id› (env : CN_ENV) (ident : ID) : Z_EXP = (
	zid env (trans_id ident)
)
=TEX
\subsection{Translating Aggregates (Positional Array)}
=SML
and €exp_array_agg_pos› (env : CN_ENV) ({tmark, comps} : EXP AGG_POS) : Z_EXP = (
let	val zop = z_minus;
	val zleft = z_num 1;
	val zright = zid env (trans_id tmark ^^ zfst);
	val zseq = map (trans_exp env) comps;
in
	z_rel_comp(z_power(zsucc, z_bin_exp(zleft,zop, zright)), z_seq zseq)
end
)
=TEX
\subsection{Translating Aggregates (Positional Array with Others)}
=SML
and €exp_array_agg_pos_others› (env : CN_ENV) ({agg_pos as {tmark,comps}, others} : EXP AGG_POS_OTHERS) : Z_EXP = (
	z_override(trans_exp env (EArrayAggOthers {tmark=tmark,others=others}),
		trans_exp env (EArrayAggPos agg_pos))
)
=TEX
\subsection{Translating Aggregates (Positional Array with Just Others)}
=SML
and €exp_array_agg_others› (env : CN_ENV) ({tmark,others={others=ot}} : EXP AGG_OTHERS) : Z_EXP = (
	z_cross(zid env (trans_id tmark ^^ zrange), z_set [trans_exp env ot])
)
=TEX
\subsection{Translating Aggregates (Named Array)}
=SML
and €trans_named_assoc› (env : CN_ENV) ({choice,comp} : (AGG_CHOICE,EXP) NAMED_ASSOC) : Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		ACAggChoiceRange (DRRange(RRange{lo,hi})) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|ACAggChoiceRange (DRRange _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|ACAggChoiceRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|ACAggChoiceRange (DRConstrained _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp =>
			trans_exp env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choice;
	val zsingles = aux_singles choice;
in
	z_cross (z_many_union(zranges @ [z_set zsingles]), z_set [trans_exp env comp])
end
)
=TEX
=SML
and €exp_array_agg_named› (env : CN_ENV) ({named_assocs} : (AGG_CHOICE,EXP) AGG_NAMED) : Z_EXP = (
	z_many_union (map (trans_named_assoc env) named_assocs)
)
=TEX
\subsection{Translating Aggregates (Named Array with Others)}
=SML
and €exp_array_agg_named_others› (env : CN_ENV) ({tmark,agg_named,others} : (AGG_CHOICE,EXP) AGG_NAMED_OTHERS) : Z_EXP = (
	z_override(trans_exp env (EArrayAggOthers {tmark=tmark,others=others}),
		trans_exp env (EArrayAggNamed agg_named))
)
=TEX
\subsection{Translating Aggregates (Positional Record)}
TBS - Proper code required for the following which is a stub.
=SML
and €retrieve_type_def› (tmark : TMARK) : TYPE_DEF = (
	TDRecordTypeDef{comps=[CNone]}
)
=TEX
=SML
and €exp_rec_agg_pos› (env : CN_ENV) ({tmark, comps} : EXP AGG_POS) : Z_EXP = (
let	val rcomps = case retrieve_type_def tmark of
			TDRecordTypeDef {comps} => comps
			|_ => fail "exp_rec_agg_pos" 508001
				[fn()=>"not a record type"];
	fun get_decls (comp::rest) = (
		case comp of
		CDeclaration vdl => (
			let	val vars = flat(map (fn {vars,tmark} => vars) vdl);
			in
				vars@get_decls rest
			end)
		|_ => fail "exp_rec_agg_pos" 508001
				[fn()=>"variant records not supported"]
	) | get_decls _ = [];
	val zeqs = map (fn (d,c) =>
			z_eq(zid env (trans_id d), trans_exp env c))
			(combine (get_decls rcomps) comps);
	val zp = z_many_and zeqs;
in
	z_mu (trans_id tmark, zp)
end
)
=TEX
\subsection{Translating Aggregates (Named Record)}
TBS - explain the following...
=SML
and €do_assocs› (env : CN_ENV) ((assoc::rest) : (AGG_CHOICE,EXP) NAMED_ASSOC list) : Z_EXP list = (
let	fun expand_assocs comp (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp => (name_to_tmark exp, comp)
						::expand_assocs comp rest
		|_ => fail "exp_rec_agg_pos" 508001
				[fn()=>"range attributes not supported"]
	) | expand_assocs _ _ = [];

	fun one_assoc {choice, comp} = (
	let	val chcplist = expand_assocs comp choice;
	in
		map (fn (ch, comp) =>
			z_eq (zid env (trans_id ch), trans_exp env comp)) chcplist
	end);
in
	one_assoc assoc@do_assocs env rest
end
) | do_assocs _ _ = []
=TEX
=SML
and €exp_rec_agg_named› (env : CN_ENV) ({tmark, named_assocs} : (AGG_CHOICE,EXP) REC_AGG_NAMED) : Z_EXP = (
let	val zeqs = do_assocs env named_assocs;
	val zp = z_many_and zeqs;
in
	z_mu (trans_id tmark, zp)
end
)
=TEX

\subsection{Translating Unary Expressions}
=SML
and €trans_unary_op› (uop : UNARY_OP) = (
	case uop of
	UOSparkUnaryMinus => z_unary_minus
	|UOSparkNot => z_bool_not
	|UOSparkAbs => z_abs
	|_ => fail "trans_unary_op" 508001 []
)
=TEX
=SML
and €exp_unary_exp› (env : CN_ENV) ({uop, right} : EXP UNARY_EXP) : Z_EXP = (
	case uop of
	UOSparkUnaryAdd => trans_exp env right
	|_ => 	z_unary_exp (trans_unary_op uop, trans_exp env right)
)
=TEX

\subsection{Translating Binary Expressions}
=SML
and €trans_bin_op› (bop : BIN_OP) = (
	case bop of
	BOSparkAnd => z_bool_and
	|BOSparkAndThen => fail "trans_bin_op" 508001 [fn()=>"not supported"]
	|BOSparkOr => z_bool_or
	|BOSparkOrElse => fail "trans_bin_op" 508001 [fn()=>"not supported"]
	|BOSparkXor => z_bool_xor
	|BOSparkEq => z_bool_eq
	|BOSparkNotEq => z_bool_noteq
	|BOSparkLess => z_bool_less
	|BOSparkLessEq => z_bool_less_eq
	|BOSparkGreater => z_bool_greater
	|BOSparkGreaterEq => z_bool_greater_eq
	|BOSparkAdd => z_add
	|BOSparkMinus => z_minus
	|BOSparkTimes => z_times
	|BOSparkIntdiv => z_intdiv
	|BOSparkMod => z_mod
	|BOSparkRem => z_rem
	|BOSparkExpon => z_expon
	|BOSparkMem => z_bool_mem
	|BOSparkNotMem => z_bool_notmem
	|BOSparkConcat => fail "trans_bin_op" 508001 [fn()=>"not supported"]
)
=TEX
=SML
and €exp_bin_exp› (env : CN_ENV) ({left, bop, right} : EXP BIN_EXP) : Z_EXP = (
	z_bin_exp (trans_exp env left, trans_bin_op bop, trans_exp env right)
)
=TEX
\subsection{Translating Membership of a Range}
=SML
and €exp_mem_range› (env : CN_ENV) ({left, mop, range} : EXP MEM_RANGE) : Z_EXP = (
let	val {lo=lo, hi=hi} = trans_range range;
	val zright = z_rng(trans_exp env lo, trans_exp env hi);
in
	z_bin_exp (trans_exp env left, trans_bin_op mop, zright)
end
)
=TEX

\subsection{Translating Attributes}
TBS - name to tmark should not really be required...
=SML
and €exp_attrib› (env : CN_ENV) ({prefix, attribute_desig=ADAttrib att} : (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
	zid env (trans_id (name_to_tmark prefix) ^^ trans_id att)
)
=TEX
The following covers $Exp\_Attrib\_Arg$
=SML
  | €exp_attrib› env ({prefix, attribute_desig=ADAttribArg(att,arg)} : (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
let	val zfun = zid env (trans_id (name_to_tmark prefix) ^^ trans_id att);
	val zargs = [trans_exp env arg];
in
	z_fun_call (zfun, zargs)
end
)
=TEX
\subsection{Translating Indexed Components}
=SML
and €exp_indexed_comp› (env : CN_ENV) ({prefix, index} : EXP INDEXED_COMP) : Z_EXP = (
	case index of
	EArrayAggPos {comps,...} =>
		z_fun_call (trans_exp env prefix, map (trans_exp env) comps)
	|_ => fail "exp_indexed_comp" 508001 [fn()=>"badly formed indexed component"]
)
=TEX
\subsection{Translating Selected Components}
=SML
and €exp_selected_comp› (env : CN_ENV) ({prefix, selector} : EXP SELECTED_COMP) : Z_EXP = (
	z_selection (trans_exp env prefix, trans_id selector)
)
=TEX
\subsection{Translating Functions Calls}
=SML
and €exp_fun_call› (env : CN_ENV) ({fun_name, args} : EXP FUN_CALL) : Z_EXP = (
	z_fun_call (zid env (trans_id fun_name), map (trans_exp env) args)
)
=TEX
\subsection{Translating Integer Literals}
The function $trans\_int$ is defined in section \ref{INTEGERLITERALS}.
=SML
and €exp_int_lit› (n : INT_LIT) : Z_EXP = (
	z_num (trans_int n)
)
=TEX
\subsection{Translating Auxiliary Expressions}
=SML
and €exp_auxiliary_exp› (ae : Z_EXP) : Z_EXP = (
	ae
)
=TEX
\subsection{Translating Qualified Expressions}
This is additional to the specification...

=SML
and €exp_qualified_exp› (env : CN_ENV) ({exp, tmark} : EXP QUALIFIED_EXPRESSION) : Z_EXP = (
	case exp of
	EArrayAggPos{comps,...} => (
		exp_array_agg_pos env {comps=comps, tmark=tmark}
	)| EArrayAggPosOthers{agg_pos={comps,...}, others} => (
		exp_array_agg_pos_others env 
			{agg_pos={comps=comps,tmark=tmark},others=others}
	)| EArrayAggOthers{others,...} => (
		exp_array_agg_others env {others=others,tmark=tmark}
	)| EArrayAggNamed an => (
		exp_array_agg_named  env an
	)| EArrayAggNamedOthers {agg_named, others,...} => (
		exp_array_agg_named_others env 
			{agg_named=agg_named, others=others, tmark=tmark}
	)|_ => fail "exp_qualified_exp" 508001 [fn()=>"badly formed qualified expression"]
)
=TEX
\subsection{The Function $trans\_exp$}
=SML
and €trans_exp› (env : CN_ENV) ((EId id) : EXP) : Z_EXP = exp_id env id
  | trans_exp env (EInt n) = exp_int_lit n
  | trans_exp env (EArrayAggPos ap) = exp_array_agg_pos env ap
  | trans_exp env (EArrayAggPosOthers ap) = exp_array_agg_pos_others env ap
  | trans_exp env (EArrayAggOthers ao) = exp_array_agg_others env ao
  | trans_exp env (EArrayAggNamed an) = exp_array_agg_named env an
  | trans_exp env (EArrayAggNamedOthers an) = exp_array_agg_named_others env an
  | trans_exp env (ERecAggPos ap) = exp_rec_agg_pos env ap
  | trans_exp env (ERecAggNamed an) = exp_rec_agg_named env an
  | trans_exp env (EUnaryExp ue) = exp_unary_exp env ue
  | trans_exp env (EBinExp be) = exp_bin_exp env be
  | trans_exp env (EMemRange be) = exp_mem_range env be
  | trans_exp env (EAttribute at) = exp_attrib env at
  | trans_exp env (EIndexedComp ic) = exp_indexed_comp env ic
  | trans_exp env (ESelectedComp sc) = exp_selected_comp env sc
  | trans_exp env (EFunCall fc) = exp_fun_call env fc
  | trans_exp env (EAuxiliaryExp ae) = exp_auxiliary_exp ae
  | trans_exp env (EQualifiedExp qe) = exp_qualified_exp env qe
  | trans_exp env (EBracketed e) = trans_exp env e
  | trans_exp env (EStringLiteral c) =
	fail "trans_exp" 508001 [fn()=>"string literals not supported"]
  | trans_exp env (ECharacterLiteral c) =
	fail "trans_exp" 508001 [fn()=>"character literals not supported"]
;
=TEX

\section{TRANSLATING SPARK BASIC DECLARATIONS}

\subsection{Translating Constants}

=SML
fun €basic_decl_const› (env : CN_ENV) {consts=consts, tm=tm, expr=expr} = (
	map (fn c => z_eq_eq(trans_id c, trans_exp env expr)) consts
);
=TEX
\subsection{Translating Enumeration Types}
=SML
val €˙_ty› = î˙Æ;
val €˙_ty› = type_of Ò˙Æ;
val €˙˙_ty› = type_of Ò˙ ∏ ˙Æ;
=TEX
=SML
fun €enum_attrib› (env : CN_ENV) (zidâ1, zidâ2, zidâ3) = (
let	fun env' id = 
		if id = (zidâ1 ^^ zlst)
		then	(˙_ty, EIEnvOther)
		else if id mem [zidâ1 ^^ zsuc, zidâ1 ^^ zpos]
		then	(˙˙_ty,EIEnvOther)
		else	env id;
	val zexp = z_set_minus (zid env' zidâ1, z_set[zid env' (zidâ1^^zlst)]);
in
	[z_eq_eq (zidâ1 ^^ zfst, zid env' zidâ2),
	z_eq_eq (zidâ1 ^^ zlst, zid env' zidâ3),
	z_eq_eq (zidâ1 ^^ zsuc, z_dom_res (zexp, zsucc)),
	z_eq_eq(zidâ1 ^^ zpred, z_inv(zid env' (zidâ1 ^^ zsuc))),
	z_eq_eq(zidâ1 ^^ zpos, z_id_rel (zid env' zidâ1)),
	z_eq_eq(zidâ1 ^^ zval, z_inv(zid env' (zidâ1 ^^ zpos)))]
end);
=TEX
=SML
fun €basic_decl_enum› (env : CN_ENV) (name : ID) (td : ENUM_TYPE_DEF) = (
let	val {vals} = td;
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map z_num (interval 0 ((length vals)-1));
	fun env' id = (
		if id mem zvals
		then
			(˙_ty, EIEnvOther)
		else if id = zname
		then
			(˙_ty, EIEnvOther)
		else
			env id
	);
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid env' (head zvals), zid env' (last zvals)))] @
	enum_attrib env' (zname, head zvals, last zvals)
end);
=TEX
\subsection{Translating Array Types}
=SML
fun €array_attrib› (env : CN_ENV) (zidâ1 : Z_ID, zidâ2 : Z_ID) : PARAINFO list = (
	[z_eq_eq(zidâ1 ^^ zfst, zid env (zidâ2 ^^ zfst)),
	z_eq_eq(zidâ1 ^^ zlst, zid env (zidâ2 ^^ zlst)),
	z_eq_eq(zidâ1 ^^ zlength, z_size (zid env zidâ2)),
	z_eq_eq(zidâ1 ^^ zrange, zid env zidâ2)]
);
=TEX
=SML
fun €basic_decl_con_array› (env : CN_ENV) (name : ID) (td : ARRAY_DEF) = (
let	val {index=index, comp=comp} = td;
	val zname = trans_id name;
	val zindex = join_tmarks (map trans_id index);
	val zcomp = trans_id comp;
in
	[z_eq_eq(zname, z_tfun(zid env zindex, zid env zcomp))] @
		array_attrib env (zname, zindex)
end);
=TEX
=SML
fun €basic_decl_uncon_array› (env : CN_ENV) (name : ID) (td : ARRAY_DEF) = (
let	val {index=index, comp=comp} = td;
	val zname = trans_id name;
	val zindex = join_tmarks (map trans_id index);
	val zcomp = trans_id comp;
in
	[z_eq_eq(zname, z_pfun(zid env zindex, zid env zcomp))]
end);
=TEX

\subsection{Translating Record Types}
TBS - explanation of the following...
=SML
fun €trans_decls› (env : CN_ENV) ({vars, tmark} : VAR_DECL) : Z_DECL list = (
let	val zexp = zid env (trans_id tmark);
in
	map (fn d => (trans_id d, zexp)) vars
end);
=TEX
=SML
fun €rec_vars› ({comps} : COMPONENT RECORD_TYPE_DEF) : VAR_DECL list  = (
let	fun aux component = (
		case component of
		CDeclaration vardecls => vardecls
		|_ => fail "rec_vars" 508001 [fn()=>"variant records not supported"]
	);
in
	flat(map aux comps)
end);
=TEX
=SML
fun €basic_decl_record› (env : CN_ENV) (name : ID) (td : COMPONENT RECORD_TYPE_DEF) = (
let	val z_sname = trans_id name;
	val z_decls = flat(map (trans_decls env) (rec_vars td));
in
	[z_schema(z_sname, z_decls)]
end);
=TEX
\subsection{Translating Integer Types}
=SML
fun €int_type_attrib› (env : CN_ENV) (zidâ1, RRange{lo=lo, hi=hi}) = (
	[z_eq_eq(zidâ1 ^^ zfst, trans_exp env lo),
	z_eq_eq(zidâ1 ^^ zlst, trans_exp env hi)]
) | int_type_attrib _ _ = basic_decl_error "int_type_attrib";
=TEX
=SML
fun €basic_decl_int_type› (env : CN_ENV) (name : ID) (range : EXP RANGE) = (
let	val (lo, hi) =
		case range of
		RRange{lo,hi} => (lo, hi)
		|_ => basic_decl_error "basic_decl_int_type";
	val zname = trans_id name;
in
	[z_eq_eq(zname, z_rng(trans_exp env lo, trans_exp env hi))] @
		int_type_attrib env (zname, RRange{lo=lo,hi=hi})
end);
=TEX

\subsection{Translating Subtypes}
=SML
fun €range_con_attrib› (env : CN_ENV) (zidâ1 : Z_ID, zidâ2 : Z_ID, {lo,hi} : EXP RANGELOHI) : PARAINFO list = (
	[z_eq_eq (zidâ1 ^^ zfst, trans_exp env lo),
	z_eq_eq (zidâ1 ^^ zlst, trans_exp env hi),
	z_eq_eq (zidâ1 ^^ zsuc, zid env (zidâ2 ^^ zsuc)),
	z_eq_eq (zidâ1 ^^ zpred, zid env (zidâ2 ^^ zpred)),
	z_eq_eq (zidâ1 ^^ zpos, zid env (zidâ2 ^^ zpos)),
	z_eq_eq (zidâ1 ^^ zval, zid env (zidâ2 ^^ zval))]
);
=TEX

=SML
fun €basic_decl_subtype_range_con› (env : CN_ENV) (name : ID) (tmark : TMARK) (range : EXP RANGE) = (
let	val (lo, hi) =
		case range of
		RRange{lo,hi} => (lo, hi)
		|_ => fail "range_con_attrib" 508001 [fn()=>"range attributes not supported"];
	val zname = trans_id name;
	val ztmark = trans_id tmark;
in
	[z_eq_eq(zname, z_rng(trans_exp env lo, trans_exp env hi))] @
		range_con_attrib env (zname, ztmark, {lo=lo,hi=hi})
end
);
=TEX

=SML
fun €basic_decl_subtype_index_con› (env : CN_ENV) (name : ID) (tmark : TMARK) (ci : EXP list) = (
let	val zname = trans_id name;
	val index = map name_to_tmark ci;
	val zindex = join_tmarks (map trans_id index);
	val zexp = zid env (trans_id tmark);
	val zvar =  "u"
	val zdecl = (zvar, zexp);
	val zp = z_eq (z_dom (zid env zvar), zid env zindex);
in
	[z_eq_eq (zname, z_set_comp (zdecl, zp))] @
	array_attrib env (zname, zindex)
end
);
=TEX

\subsection{The Function $trans\_basic\_decl$}
=SML
fun €trans_basic_decl› (env : CN_ENV) ((BDConstDecl cd) : BASIC_DECL) : PARAINFO list = (
	basic_decl_const env cd
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDEnumTypeDef td,...}) = (
	basic_decl_enum env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDIntTypeDef range,...}) = (
	basic_decl_int_type env name range
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDConArrayDef td,...}) = (
	basic_decl_con_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDUnconArrayDef td,...}) = (
	basic_decl_uncon_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDRecordTypeDef td,...}) = (
	basic_decl_record env name td
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CRange cr},...}) = (
	basic_decl_subtype_range_con env name tmark cr
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CIndex ci},...}) = (
	basic_decl_subtype_index_con env name tmark ci
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFloating _},...}) = (
	fail "trans_basic_decl" 508001 [fn()=>"floating point not supported"]
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFixed _},...}) = (
	fail "trans_basic_decl" 508001 [fn()=>"fixed point not supported"]
) | trans_basic_decl env (BDTypeDecl {type_def=TDFloatingTypeDef _,...}) = (
	fail "trans_basic_decl" 508001 [fn()=>"floating point not supported"]
) | trans_basic_decl env (BDTypeDecl {type_def=TDFixedTypeDef _,...}) = (
	fail "trans_basic_decl" 508001 [fn()=>"fixed point not supported"]
) | trans_basic_decl env (BDDeferredConstDecl _) = (
	fail "trans_basic_decl" 508001 [fn()=>"deferred constants not supported"]
) | trans_basic_decl env (BDVarDecl _) = (
	fail "trans_basic_decl" 508001 [fn()=>"unexpected variable declaration"]
) | trans_basic_decl env (BDPrivateTypeDecl _) = (
	fail "trans_basic_decl" 508001 [fn()=>"private types not supported"]
);
=TEX


\subsection{Epilogue}

=SML
end (* of local...in *);
end (* structure CNBasicDeclsAndExprs *);
open CNBasicDeclsAndExprs;
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
