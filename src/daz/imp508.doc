% imp508.doc   %Z% $Date: 2000/06/17 14:46:15 $ $Revision: 1.60 $ $RCSfile: imp508.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP508}  %% Mandatory field
\def\SCCSversion{$Revision: 1.60 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/06/17 14:46:15 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the implementation for the Basic Declaration and Expression Generator for processing Compliance Notation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.15] Initial Drafts.
\item[Issue 1.16 (16th June 1994)] First draft for review.
\item[Issue 1.27 (31 October 1994)] Added $z\_true$ and $z\_exists$ as per version 1.1 of Volume 3 of DRA's specification.
\item[Issue 1.30 (9th November 1994)]
Adjusted $ENV\_INFO$ and allowed for type conversions.
\item[Issue 1.32] Updated document references.
\item[Issue 1.33] Accomodated changes to toolkit extensions agreed at the 4th critical review (see \cite{ISS/HAT/DAZ/min005}: $mod$ becomes $intmod$, $Abs$ becomes $abs$).
\item[Issue 1.34] Fixed bug 6 (batch 2).
\item[Issue 1.35] Accomodated changes to data types required for enhancements.
\item[Issue 1.36] Enhancement 11 (and bug 9 (batch 2)).
\item[Issue 1.37] Enhancements 13 and 14.
\item[Issue 1.38] Enhancement 15.
\item[Issue 1.39-1.41] Enhancements to basic declarations.
\item[Issue 1.42] Enhancement 12 (type conversions) and rejig of enhancement 11.
\item[Issues 1.43-1.45] Enhancements 3 and 18.
\item[Issue 1.46 (14th December 1995)] Changes according to desk check report 024.
\item[Issue 1.47 ] Fixes to bugs 8 and 10 (V0.6) and error reporting.
\item[Issue 1.48 ] Fixes to bug 1 (V0.7).
\item[Issue 1.49] IUCT WP 7 changes.
\item[Issue 1.50] IUCT WP 4 changes.
\item[Issue 1.51,1.52] Fixing bugs in IUCT WP 4 changes.
\item[Issue 1.53] Improved an error message.
\item[Issue 1.54] Updated references.
\item[Issue 1.54] Updates for SML97.
\item[Issue 1.55] Updates for new INTEGER type.
\item[Issue 1.56] Enhancement R3.
\item[Issue 1.57] Enhancement R2.
\item[Issues 1.58-1.61] Enhancement R1.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Algorithms}
The algorithms to generate the basic declarations and expressions are specified in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

%\subsection{Dependencies}
%\subsection{Known Deficencies}
%\subsection{Possible Enhancements}
=TEX

\section{PREAMBLE}

=SML
infix 3 ^^;
=TEX
=SML
structure ÛCNBasicDeclsAndExprsÝ : CNBasicDeclsAndExprs = struct
	open CNParser CNTypes ZGeneratedConstants ZParagraphs;
	open ZUserInterfaceSupport ZTypesAndTermsSupport;
=TEX
\section{CUSTOMIZED ENVIRONMENT HANDLING}

=SML
datatype ÛENV_INFOÝ =
			ÛEIEnvFunctionÝ of Z_ID list * ID list
		|	ÛEIEnvVarÝ of TMARK
		|	ÛEIEnvAuxVarÝ of Z_DECL
		|	ÛEIEnvRecordTypeÝ of ID list
		|	ÛEIEnvOtherTypeÝ
		|	ÛEIEnvOtherÝ;
=TEX
=SML
type ÛCN_ENVÝ = Z_ID -> (TYPE * ENV_INFO) OPT;
=TEX

\section{SUPPORTING FUNCTIONS}
\subsection{Miscellaneous}
As discussed with DRA during the (first) enhancements programme, the treatment
of constructs which cannot be handled formally changed between releases 0.5 and 0.6.
Now that the user can bypass the formal processing of such a construct (as an arbitrary ada insertion), there is no need to attempt to continue processing when such a construct appears here, except in cases where failure to translate a construct is used to redirect the flow of control.
In order to encourage better messages, the exception $Informal$ and associated functions have been removed and the usual {\Product} error mechanisms are used instead.
=TEX
=SML
fun zid1 Û^^Ý zid2 = (
	zid1^"v"^zid2
);
=TEX
=SML
fun Ûdest_rangeÝ ((RRange range) : EXP RANGE) : EXP RANGELOHI = (
	range
) | dest_range _ = fail "dest_range" 508020 [];
=TEX
=TEX

The following are not asked for in the specification but are convenient to have available at various points in the code.
=SML
val Ûú_tyÝ = ”ú®;
val Ûðú_tyÝ = type_of ñú®;
val Ûúú_tyÝ = type_of ñú ¸ ú®;
=TEX
\section{Evaluation of Constant Expressions}
Constant expressions need to be evaluated in the translation of array attributes with
arguments and in deciding whether a VC needs to be generated 
For various reasons, it has been agreed that attributes that are functions will not be statically evaluated.

=TEX
First of all we define a conversion which will expand the definition of a constant integer or set of integers providing the definition is a simple equation and providing the constant does not appear in the list provided as an extra argument (this is used to avoid looping in the presence of somewhat mailiciously conceived definitions).

=SML
fun Ûcn_const_convÝ (consts : TERM list) : CONV = (fn tm =>
	(if	tm term_mem consts
	then	fail_conv
	else	COND_C
		(fn tm => is_const tm andalso
			let val ty = type_of tm; in ty =: ú_ty orelse ty =: ðú_ty end)
		(fn tm => simple_eq_match_conv (z_get_spec tm) tm)
		fail_conv
	) tm
);
=TEX
Now conversions to handle a few other cases which are not directly handled by available tools.
The conversion for \verb"#" is required for array length attributes.
=SML
val Ûz_minus_minus_thmÝ = pc_rule1 "z_library" prove_rule[] ¬µi ·ñ~ ~i = i®®;

val Ûz_minus_minus_convÝ = simple_eq_match_conv z_minus_minus_thm;

val Ûz_hash_thmÝ = asm_rule ¬µi j·ñ#(i .. j) = (j - i) + 1®®;

val Ûz_hash_convÝ : CONV = simple_eq_match_conv z_hash_thm;
=TEX
Now a conversional for propagating a conversion into the operands of a unary or binary Z function.
=SML
fun ÛMY_Z_RANDS_CÝ (c : CONV) : CONV = (fn tm =>
	(	((dest_z_tuple o snd o dest_z_app) tm;
			RAND_C (RAND_C c AND_OR_C RATOR_C(RAND_C c)))
				handle Fail _ => RAND_C c	) tm
	
);
=TEX
We put these pieces together to give the following conversion which does the required static evaluation of integer expressions.
The parameter to the conversion is used to record which constants have had their definitions unwound somewhere in the branch of the expression tree currently being attacked and is used to avoid infinite recursion (e.g., if someone has used HOL to produce something which looks like a Z global variable with a definition like $X = X$ or $X = X + 0$.
=SML
fun Ûcn_eval_convÝ (consts : TERM list) : CONV = (fn tm => (
		MY_Z_RANDS_C (cn_eval_conv consts)
		AND_OR_C
		(fn t => (cn_const_conv consts
			THEN_TRY_C cn_eval_conv (consts term_grab t)) t)
		AND_OR_C (FIRST_C [
				z_hash_conv,
				z_subtract_minus_conv,
				z_minus_minus_conv]
			THEN_TRY_C cn_eval_conv consts)
		AND_OR_C FIRST_C [
			z_plus_conv,
			z_times_conv,
			cn_intmod_conv	,
			cn_intdiv_conv	,
			cn_rem_conv,
			cn_star_star_conv,
			z_abs_conv
		])	tm
);
=TEX
The following is the interface used in handling attributes.
The handling of ranges uses the above function directly.
=SML
fun Ûeval_attr_argÝ (ze : Z_EXP) : int = (
	let	val n = (dest_z_signed_int o snd o dest_eq o
				snd o dest_thm o TRY_C(cn_eval_conv[])) ze; 
	in	if 	n @> integer_of_int 0
		then	int_of_integer n
		else	fail "" 0 [] (* immediately caught *)
	end	handle	Fail _ => term_fail "eval_attr_arg" 508029 [ze]
);
=TEX
\section{SUPPORT FOR Z ABSTRACT SYNTAX}
\subsection{Z Unary Expressions}
=SML
val		Ûz_unary_minusÝ =	ñ(~ _)®
	and	Ûz_bool_notÝ =		ñ(not _)®
	and	Ûz_absÝ =		ñ(abs _)®;
=TEX
\subsection{Z Binary Expressions}
=SML
val 		Ûz_bool_andÝ =		ñ(_ and _)®
	and	Ûz_bool_orÝ =		ñ(_ or _)®
	and	Ûz_bool_xorÝ =		ñ(_ xor _)®
	and	Ûz_bool_eqÝ =		ñ(_ eq _)®
	and	Ûz_bool_noteqÝ =	ñ(_ noteq _)®
	and	Ûz_bool_lessÝ =		ñ(_ less _)®
	and	Ûz_bool_less_eqÝ =	ñ(_ less_eq _)®
	and	Ûz_bool_greaterÝ =	ñ(_ greater _)®
	and	Ûz_bool_greater_eqÝ =	ñ(_ greater_eq _)®
	and	Ûz_addÝ =		ñ(_ + _)®
	and	Ûz_minusÝ =		ñ(_ - _)®
	and	Ûz_timesÝ =		ñ(_ * _)®
	and	Ûz_intdivÝ =		ñ(_ intdiv _)®
	and	Ûz_modÝ =		ñ(_ intmod _)®
	and	Ûz_remÝ =		ñ(_ rem _)®
	and	Ûz_exponÝ =		ñ(_ ** _)®
	and	Ûz_bool_memÝ =	
				ñ(_ mem _)®
	and	Ûz_bool_notmemÝ =
				ñ(_ notmem _)®;
=TEX

\subsection{Z Expressions}
The following function allows many of the Z constructor functions to be presented in a way which is visually appealing.
=SML
fun Ûcn_substÝ (ts : (TERM * string) list) (tm : TERM) : TERM = (
let	val freevars = frees tm;
	val fvs = map dest_var freevars;
	val newtys = map (fn (tm,c) => (c, type_of tm)) ts;
	val tymap = map (fn (n, ty) => (ty,lassoc3 fvs n)) newtys;
	val tymap' = (fn (t1,t2) => type_match
		(mk_ctype ("TYPE",t1)) (mk_ctype("TYPE",t2))) (split tymap);
	val tm_inst = inst [] tymap' tm;
	val namemap = map (fn (tm, s) => (tm, mk_var(s, lassoc3 newtys s))) ts;
in
	subst namemap tm_inst
end);
=TEX


=SML
val ÛzsuccÝ : Z_EXP = ñsucc®;
=TEX
=SML
fun ÛzidÝ (env : CN_ENV) (id : Z_ID) : Z_EXP = (
	find (TypeInference.get_ti_context ()) (fn t => fst(dest_var t) = id)
	handle Fail _ => 
	case env id of
	Value (ty, EIEnvVar _) => mk_z_lvar(id, ty, [])
	|Value (ty, EIEnvAuxVar _) => mk_z_lvar(id, ty, [])
	|Value (ty, _) => mk_z_gvar(id, ty, [])
	|Nil => fail "zid" 508021 [fn()=>id]
);
=TEX
=SML
val Ûz_numÝ : INTEGER -> Z_EXP = (mk_z_int o string_of_integer);
=TEX
=SML
val Ûz_tfun_termÝ : TERM = ña ­ b®;
fun Ûz_tfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_tfun_term
);
=TEX
=SML
val Ûz_pfun_termÝ : TERM = ña ß b®;
fun Ûz_pfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_pfun_term
);
=TEX
=SML
val Ûz_rng_termÝ : TERM = ña .. b®;
fun Ûz_rngÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term
);
=TEX
=SML
val Ûz_dom_termÝ : TERM = ñdom a®;
fun Ûz_domÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_dom_term
);
=TEX
=SML
val Ûz_dom_res_termÝ : TERM = ña ò b®;
fun Ûz_dom_resÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_dom_res_term
);
=TEX
=SML
val Ûz_inv_termÝ : TERM = ña ç~ê®;
fun Ûz_invÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_inv_term
);
=TEX
=SML
val Ûz_id_rel_termÝ : TERM = ñid a®;
fun Ûz_id_relÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_id_rel_term
);
=TEX
=SML
val Ûz_size_termÝ : TERM = ñ# a®;
fun Ûz_sizeÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_size_term
);
=TEX
=SML
val Ûz_empty_set_termÝ : TERM = ñ{}®;
fun Ûz_setÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_setd(type_of e, exps)
) | z_set _ = z_empty_set_term;
=TEX
=SML
val Ûz_set_minus_termÝ : TERM = ña \ b®;
fun Ûz_set_minusÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_set_minus_term
);
=TEX
=SML
fun Ûz_set_compÝ (zdecl : Z_DECL, p : Z_EXP) : Z_EXP = (
let	val dec = (fst o dest_z_dec) zdecl
			handle _ =>
			  error "z_set_comp" 508023 [fn()=>string_of_term zdecl];
	val zdexp = case dec of
		[dec] => dec
		|_ => mk_z_tuple dec;
	val tm = mk_z_seta (mk_z_decl [zdecl], p, zdexp);
	val side = seta_gen_semantic_const tm;
in
	tm
end
);
=TEX
=SML
val Ûz_power_termÝ : TERM = ña ç b ê®;
fun Ûz_powerÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_power_term
);
=TEX
=SML
val Ûz_rel_comp_termÝ : TERM = ña » b®;
fun Ûz_rel_compÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_rel_comp_term
);
=TEX
=SML
val Ûz_empty_seq_termÝ : TERM = ñ§¢®;
fun Ûz_seqÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_§¢(type_of e, exps)
) | z_seq _ = z_empty_seq_term;
=TEX
=SML
val Ûz_cross_termÝ : TERM = ña ¸ b®;
fun Ûz_crossÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_cross_term
);
=TEX
=SML
fun Ûz_many_crossÝ (tms : Z_EXP list) : Z_EXP = (
	case	tms of
		[tm] => tm
	|	_ => (
		let	val prod = mk_z_¸ tms;
		in	¸_gen_semantic_const prod;
			prod
		end
	)
);
=TEX
=SML
val Ûz_override_termÝ : TERM = ña « b®;
fun Ûz_overrideÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_override_term
);
=TEX
=SML
val Ûz_union_termÝ : TERM = ña À b®;
fun Ûz_many_unionÝ (exps : Z_EXP list) : Z_EXP = (
let	fun non_empty (e::rest) = (
		if (((length o snd o dest_z_setd) e) = 0 handle _ => false)
		then
			non_empty rest
		else
			e::non_empty rest
	) | non_empty _ = [];
	fun aux (exps as e1::e2::rest) = (
		cn_subst [(e1, "a"), (aux (e2::rest), "b")] z_union_term
	) | aux [e] = e
	  | aux _ = error "z_many_union" 508024 [];
in
	(aux o non_empty) exps
end
);
=TEX
=SML
fun Ûz_bindingÝ (cmpvals : (string * Z_EXP) list) : Z_EXP = (
	let	val bdg = mk_z_binding cmpvals;
	in	binding_gen_semantic_const bdg;
		bdg
	end
);
=TEX
=SML
fun Ûz_tupleÝ ([exp] : Z_EXP list) : Z_EXP = (
	exp
) | z_tuple (exps : Z_EXP list) : Z_EXP = (
	let	val tuple = mk_z_tuple exps;
	in	tuple_gen_semantic_const tuple;
		tuple
	end
);
=TEX
=SML
fun mk_and_chk_z_app (fx as (f: Z_EXP, x : Z_EXP)) : Z_EXP = (
	mk_z_app fx handle Fail _ => (
		let	val ty = hd(dest_z_tuple_type
					(dest_z_power_type (type_of f)));
			val tysubs = type_match (type_of x) ty;
			val f' = inst [] tysubs f;
		in	mk_z_app (f', x)
		end
	) handle Fail _ => term_fail "trans_exp" 508071 [f, x]
);
=TEX
=SML
val Ûz_unary_expÝ : (Z_EXP * Z_EXP) -> Z_EXP = mk_and_chk_z_app;
=TEX
=SML
fun Ûz_bin_expÝ (left : Z_EXP, bop : Z_EXP, right : Z_EXP) : Z_EXP = (
	mk_and_chk_z_app (bop, mk_z_tuple[left, right])
);
=TEX
=SML
fun Ûz_fun_callÝ (exp :Z_EXP, exps : Z_EXP list) : Z_EXP = (
	case exps of
	[] =>	exp
	|[e] =>		mk_and_chk_z_app (exp, e)
	|_ => (
		let	val tup = mk_z_tuple exps;
			val side = tuple_gen_semantic_const tup;
		in
			mk_and_chk_z_app (exp, tup)
		end
	)
);
=TEX
=SML
val Ûz_selectionÝ : (Z_EXP * Z_ID) -> Z_EXP = mk_z_sel‰s;
=TEX
=SML
val Ûz_maplet_termÝ : TERM = ña í b®;
fun Ûz_mapletÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_maplet_term
);
=TEX
=SML
val Ûz_powersetÝ : Z_EXP -> Z_EXP = mk_z_ð;
=TEX
=SML
fun Ûother_z_expÝ (exp : Z_EXP) : Z_EXP = exp;
=TEX

\subsection{Z Predicates}
=SML
val Ûz_trueÝ : Z_PRED = mk_z_true;
=TEX
=SML
val Ûz_eqÝ : (Z_EXP * Z_EXP) -> Z_PRED = mk_z_eq;
=TEX
=SML
val Ûz_andÝ : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_±;
=TEX
=SML
fun Ûz_many_andÝ ((exps as e1::e2::rest) : Z_PRED list) : Z_PRED = (
	mk_z_± (e1, z_many_and (e2::rest))
) | z_many_and [e] = e
  | z_many_and _ = error "z_many_and" 508024 [];
=TEX
=SML
val Ûz_elemÝ : (Z_EXP * Z_EXP) -> Z_EXP = mk_z_;
=TEX

=SML
val Ûz_noteq_termÝ : TERM = ña ½ b®;
fun Ûz_noteqÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_noteq_term
);
=TEX

=SML
val Ûz_less_eq_termÝ : TERM = ña ¼ b®;
fun Ûz_less_eqÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_less_eq_term
);
=TEX

=SML
val Ûz_greater_termÝ : TERM = ña > b®;
fun Ûz_greaterÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_greater_term
);
=TEX

=SML
fun Ûz_forallÝ (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_µ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
fun Ûz_existsÝ (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_¶ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
val Ûz_impÝ : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_´;
=TEX

=SML
val Ûz_memÝ : (Z_EXP * Z_EXP) -> Z_PRED = mk_z_;
=TEX

=SML
fun Ûother_z_predÝ (z_pred : Z_PRED) : Z_PRED = z_pred;
=TEX

\subsection{Z Paragraphs}
=SML
fun Ûz_axÝ (id : Z_ID, exp : Z_EXP, preds : Z_PRED list) : PARAINFO = (
	let	val ty = dest_z_power_type (type_of exp);
		val decl = mk_z_decl[mk_z_dec([mk_var(id, ty)], exp)];
		val pred = case preds of
				[] => Nil
			|	_ => Value (list_mk_± preds);
	in	AxDesInfo([], decl, pred, [(id, ty)])
	end
);
=TEX
=SML
fun Ûz_eq_eqÝ (id : Z_ID, exp : Z_EXP) : PARAINFO = (
	AbbDefInfo (id, [], exp)
);
=TEX
=SML
fun Ûz_givenÝ (id : Z_ID) : PARAINFO = (
	GivenSetInfo ([id], Nil)
);
=TEX
=SML

fun Ûz_schemaÝ (name : Z_ID, decls : Z_DECL list) : PARAINFO = (
let	val z_sch = mk_z_h_schema(mk_z_decl decls, z_true);
	val side = schema_gen_semantic_const z_sch;
in
	AbbDefInfo (name, [], z_sch)
end
);
=TEX
\section{INTEGER LITERALS}\label{INTEGERLITERALS}

The translation of integer literals is non-trivial and several supporting functions for the translation of integer literals are introduced in this section. The function $trans\_int$ is introduced at the end of this section.
=SML
local
=TEX
\subsection{Support for $trans\_int$}

=SML
open	CaseIndependence;
open	Lex;
type ÛNUMBERSÝ = string list;
type ÛNUMERICÝ =
		{base : NUMBERS, m : NUMBERS, n : NUMBERS, expon : NUMBERS};
=TEX

\subsubsection{Phase 1: Recognising Numeric Literals}

In the exponent part when there is a sign, it is just copied into the number. The parser has already ensured that $+$ and $-$ can only appear at the start of an exponent, so a further check is not required here.
=SML
fun Ûrecog_exponent_partÝ (dec as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
	else case c of

		"_" =>	recog_exponent_part (dec, rest)
		|"+" => recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
		|"-" => recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
		|_ =>	(dec, c::rest)

) | recog_exponent_part (other, []) = (
	(other, [])
);
=TEX
=SML
fun Ûrecog_decimal_partÝ (dec as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		 : (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_decimal_part ({base=base,m=m, n=n@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_decimal_part (dec, rest)
		|"e" => recog_exponent_part (dec, rest)
		|"E" => recog_exponent_part (dec, rest)
		|_ =>	(dec, c::rest)

) | recog_decimal_part (other, []) = (
	(other, [])
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûrecog_based_dec_partÝ (nb as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based_dec_part ({base=base,m=m, n=n@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_based_dec_part (nb, rest)
		|"#" => recog_numeric (nb, rest)
		|_ =>	(nb, c::rest)

) | recog_based_dec_part (other, []) = (
	fail "trans_int" 0 []
)
=TEX
The failure case below is caught by $trans\_int$.
=SML
and Ûrecog_basedÝ (nb as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based ({base=base,m=m@[c], n=n, expon=expon}, rest)
	else case c of

		"_" =>	recog_based (nb, rest)
		|"." => recog_based_dec_part (nb, rest)
		|"#" => recog_numeric (nb, rest)
		|_ =>	(nb, c::rest)

) | recog_based (other, []) = (
	fail "recog_based" 0 []
)
=TEX

=TEX
=SML
and Ûrecog_numericÝ (num as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_numeric ({base=base,m=m@[c], n=n, expon=expon}, rest)
	else case c of

		"_" =>	recog_numeric (num, rest)
		|"." =>	recog_decimal_part (num, rest)
		|"e" => recog_exponent_part (num, rest)
		|"E" => recog_exponent_part (num, rest)
		|"#" => recog_based ({base=m,m=[],n=n,expon=expon}, rest)
		|_ =>	(num, c::rest)
) | recog_numeric other = other;
=TEX
\subsubsection{Phase 2: Generating Integer Literals}

The following gives a lookup table for extended digits to values upto 16.

i.e., $[("0", 0), ("1", 1),...("F", 15)]$.
=SML
val Ûextended_digitsÝ : (string * INTEGER) list = (
	combine
		(map string_of_int (interval 0 9)@["A","B","C","D","E","F"])
		(map integer_of_int (interval 0 15))
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
val ten = @@"10";
fun Ûbased_to_integerÝ (base:int) (sl:string list) : INTEGER = (
	if base = 10
	then	(natural_of_string o implode) sl handle _ => zero
	else	let	val valid = extended_digits to (base-1);
			val sl' = map CaseIndependence.to_upper sl;
			val f = lassoc3 valid;
			val ibase = integer_of_int base;
			fun aux (c::rest) = (
				f c @+ ibase @* aux rest
			) | aux _ = zero;
		in
			(aux o rev) sl' handle _ =>
				fail "based_to_integer" 0 []
		end
);
=TEX
=SML
fun Ûsigned_nat_of_numbersÝ (sl : NUMBERS) : int = (
	let	val f = nat_of_string o implode;
	in
		case sl of
		("+"::n) => f n
		|("-"::n) => ~(f n)
		|_ => f sl
	end
);
=TEX
=SML
fun ÛbasepowÝ (base : int) (n : int) : INTEGER = (
	let	val ibase = integer_of_int base;
		fun aux n = (
			if	n = 0
			then	one
			else	ibase @* aux (n-1)
		);
	in	aux n
	end
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûconvert_base_expÝ ((base, m, expon) : (int*INTEGER*int)) : INTEGER = (
	if expon > 0
	then	m @* basepow base expon
	else	let	val d = basepow base (~expon);
			val res = m idiv d;
		in
			if res @* d = m
			then	res
			else	fail "convert_base_exp" 0 []
		end
);
=TEX
=SML
fun Ûno_of_digits_inÝ (base : int) (n : INTEGER) : int = (
	let	val ibase = integer_of_int base;
		fun aux n = (
			if	n idiv ibase @> zero
			then	1 + no_of_digits_in base (n idiv ibase)
			else	1
		);
	in	aux (iabs n)
	end
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûconvert_base_dec_expÝ ((base, m, n, expon) :
		int*INTEGER*INTEGER*int) : INTEGER = (
	let	val nd = (no_of_digits_in base n) - 1;
		val df = expon - nd;
		val offset = basepow base nd;
	in
		if	df >= 0
		then	convert_base_exp (base, (m @* offset @+ n @- offset), df)
		else	fail "nil_aux" 0 []
	end
);
=TEX
In the following, ``1'' is prefixed to the decimal part in order to preserve leading zeros when converting to an integer. It is removed in $convert\_base\_dec\_exp$.
=SML
fun Ûnumeric_to_int_litÝ ({base,m,n,expon} : NUMERIC) : INTEGER = (
let	val nbase = (nat_of_string o implode) base handle _ => 10;
	fun add_prefix (n as (_::_)) = "1"::n
	  | add_prefix _ = [];
	val nm = based_to_integer nbase m;
	val nn = ((based_to_integer nbase) o add_prefix) n;
	val nexpon = signed_nat_of_numbers expon handle _ => 0;
in
	if	nbase = 10 andalso nn = zero andalso nexpon = 0
	then	nm
	else if nn = zero
	then	convert_base_exp (nbase,nm,nexpon)
	else	convert_base_dec_exp (nbase,nm,nn,nexpon)

end);
=TEX
\subsection{The Function $trans\_int$}
=SML
in (* of local ... in *)
=TEX
=SML
fun Ûtrans_intÝ (i : INT_LIT) : INTEGER = (
	( (numeric_to_int_lit o fst o recog_numeric)
		({base=[],m=[],n=[],expon=[]}, explode i)
	) handle Fail _ => fail "trans_int" 508025 [fn()=>i]
);
=TEX
=SML
end (* of local ... in *);
=TEX
=TEX

\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{Translating Identifiers}
=SML
fun Ûtrans_idÝ (id : ID) : Z_ID = (

let	fun aux (c::rest) = (
		case c of
		"." => "o"::aux rest
		|"'" => "v"::aux rest
		|_ => c::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
);
=TEX
=SML
val		ÛzfstÝ = trans_id "FIRST"
	and	ÛzlstÝ = trans_id "LAST"
	and	ÛzsucÝ = trans_id "SUCC"
	and	ÛzpredÝ = trans_id "PRED"
	and	ÛzposÝ = trans_id "POS"
	and	ÛzvalÝ = trans_id "VAL"
	and	ÛzlengthÝ = trans_id "LENGTH"
	and	ÛzrangeÝ = trans_id "RANGE";
=TEX
=SML
fun ÛdimenÝ (zid : Z_ID, n : int) : Z_ID  = (
	if n > 0 then zid ^ "v" ^ string_of_int n else zid
);
=TEX
=SML
fun Ûexp_idÝ (env : CN_ENV) (ident : ID) : Z_EXP = (
	zid env (trans_id ident)
);
=TEX
\subsection{Translating Aggregates (Positional Array)}
=SML
type ÛARRAY_AGG_ENVÝ = {tname : TMARK, this : int, max : int};
=TEX
=SML
fun Ûarray_dimÝ (env : CN_ENV) (tmark : TMARK) : int = (
	let	val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark);
	in	(length o dest_z_tuple_type o hd o dest_z_tuple_type o
			dest_z_power_type o dest_z_power_type) ztype
	end	handle Fail _ => 1
);
=TEX
=SML
fun Ûarray_firstÝ (env : CN_ENV) ({this, max, tname} : ARRAY_AGG_ENV) : Z_EXP = (
	if	max = 1
	then	zid env (trans_id tname ^^ zfst)
	else	zid env (dimen(trans_id tname ^^ zfst, this))
);
=TEX
=SML
fun Ûarray_rangeÝ (env : CN_ENV) ({this, max, tname} : ARRAY_AGG_ENV) : Z_EXP = (
	if	max = 1
	then	zid env (trans_id tname ^^ zrange)
	else	zid env (dimen(trans_id tname ^^ zrange, this))
);
=TEX
=SML
fun Ûz_array_aggÝ (num : int) : Z_ID = (
	"array_agg" ^ (string_of_int num)
);
=TEX
=SML
fun Ûmk_array_aggÝ  (num : int, zex : Z_EXP) : Z_EXP = (
	if	num = 1
	then	zex
	else	let	val fun_name = z_array_agg num;
			val ty = force_value(get_const_type (bind_gvar_name fun_name));
			val (gty, rty) = dest_­_type ty;
			val us = map mk_u (dest_z_tuple_type gty);
			val fun_exp = mk_z_gvar(fun_name, rty, us);
			val (arg_ty, res_ty) = case dest_z_tuple_type
						(dest_z_power_type (type_of fun_exp)) of
					[ty1, ty2] => (ty1, ty2)
				|	_ => fail "" 0 [] (* caught immediately *);
			val ty_map = type_match (type_of zex) arg_ty;
		in	mk_z_app(inst [] ty_map fun_exp, zex)
		end	handle Fail _ => term_fail "mk_array_agg" 508058 [zex]
);
=TEX
=SML
fun Ûexp_array_agg_posÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, comps} : EXP AGG_POS) : Z_EXP = (
let	val zop = z_minus;
	val zleft = z_num one;
	val zright = array_first env aa_env;
	val aa_env' = {this = this + 1, max = max, tname = tname};
	val zseq = map (trans_array_agg_exp env aa_env') comps;
in
	z_rel_comp(z_power(zsucc, z_bin_exp(zleft,zop, zright)), z_seq zseq)
end
)
=TEX
\subsection{Translating Aggregates (Positional Array with Others)}
=SML
and Ûexp_array_agg_pos_othersÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({agg_pos as {tmark, comps},
		others} : EXP AGG_POS_OTHERS) : Z_EXP = (
	z_override(
		trans_array_agg_exp env aa_env (EArrayAggOthers {tmark=tmark,others=others}),
		trans_array_agg_exp env aa_env (EArrayAggPos agg_pos))
)
=TEX
\subsection{Translating Aggregates (Positional Array with Just Others)}
=SML
and Ûexp_array_agg_othersÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, others={others=ot}} : EXP AGG_OTHERS) : Z_EXP = (
let	val aa_env' = {this = this + 1, max = max, tname = tname};
in
	z_cross(array_range env aa_env, z_set [trans_array_agg_exp env aa_env' ot])
end
)
=TEX
\subsection{Translating Aggregates (Named Array)}
=SML
and Ûtrans_named_assocÝ	(env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
				({choice,comp} : (AGG_CHOICE,EXP) NAMED_ASSOC)
					: Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		ACAggChoiceRange (DRRange(RRange{lo,hi})) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|ACAggChoiceRange (DRRange _) =>
			fail "trans_named_assoc" 508020 []
		|ACAggChoiceRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|ACAggChoiceRange (DRConstrained _) =>
			fail "trans_named_assoc" 508020 []
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp =>
			trans_exp env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choice;
	val zsingles = z_set (aux_singles choice);
	val aa_env' = {this = this + 1, max = max, tname = tname};
in
	z_cross (z_many_union(zranges @ [zsingles]), z_set[trans_array_agg_exp env aa_env' comp])
end
)
=TEX
=SML
and Ûexp_array_agg_namedÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, named_assocs} : (AGG_CHOICE,EXP) AGG_NAMED) : Z_EXP = (
	z_many_union (map (trans_named_assoc env aa_env) named_assocs)
)
=TEX
\subsection{Translating Aggregates (Named Array with Others)}
=SML
and Ûexp_array_agg_named_othersÝ (env : CN_ENV) (aa_env : ARRAY_AGG_ENV)
		({agg_named as {tmark, ...}, others}
		: (AGG_CHOICE,EXP) AGG_NAMED_OTHERS) : Z_EXP = (
	z_override(trans_array_agg_exp env aa_env (EArrayAggOthers {tmark=tmark, others=others}),
		trans_array_agg_exp env aa_env (EArrayAggNamed agg_named))
)
=TEX
\subsection{Translating Aggregates (Positional Record)}
=SML
and Ûexp_rec_agg_pos_zÝ
		(env : CN_ENV) ((tmark as Value tm, comps) : TMARK OPT * Z_EXP list)
		: Z_EXP = (
let	val record_components = (
		case env tm of
			Value (_, EIEnvRecordType (cmps as _::_)) => cmps
		|	_ => fail "exp_rec_agg_pos_z" 508026 [fn()=>tm]
	);
	val zbinds = combine record_components comps
		handle Fail _ => fail "exp_rec_agg_pos" 508027 [fn()=>tm];
in
	z_binding zbinds
end
) | exp_rec_agg_pos_z _ _ = fail "trans_exp" 508054 []
=TEX
\subsection{Translating Aggregates (Named Record)}
=SML
and Ûexp_rec_agg_namedÝ (env : CN_ENV) ({tmark as Value tm, named_assocs}
		: (AGG_CHOICE,EXP) REC_AGG_NAMED) : Z_EXP = (
let	fun named_assoc_to_ids_exp {choice, comp} = (
	let	fun aux (ch::rest) comp = (
			case ch of
			ACAggChoiceSingle exp => (
					(name_to_tmark exp, 
					 trans_exp env comp)::aux rest comp
			) |_ => fail "exp_rec_agg_named" 508052 []
		) | aux _ _ = [];
	in
		aux choice comp 
	end);
	val zbinds = flat (map named_assoc_to_ids_exp named_assocs);
in	z_binding zbinds
end
) | exp_rec_agg_named _ _ = fail "trans_exp" 508054 []
=TEX
\subsection{Translating Aggregates (Generally)}
Note that the failure case below will never happen, since caller must always
have looked inside the expression to get the type mark out.
The test using less-than rather than not-equals defends the code from
non-termination if something weird goes wrong in {\it array\_dim}.
=SML
and Ûtrans_array_agg_expÝ (env : CN_ENV)
	(aa_env as {this, max, ...} : ARRAY_AGG_ENV) (e : EXP) : Z_EXP = (
	if	this < max + 1
	then	case e of
		EArrayAggPos ap => exp_array_agg_pos env aa_env ap
	|	EArrayAggPosOthers apo =>  exp_array_agg_pos_others env aa_env apo
	|	EArrayAggOthers ao =>  exp_array_agg_others env aa_env ao
	|	EArrayAggNamed an =>  exp_array_agg_named env aa_env an
	|	EArrayAggNamedOthers ano => exp_array_agg_named_others env aa_env ano
	|	_ => fail "trans_array_agg_exp" 508054 []
	else	trans_exp env e
)
=TEX
\subsection{Translating Unary Expressions}
=SML
and Ûtrans_unary_opÝ (uop : UNARY_OP) = (
	case uop of
	UOSparkUnaryMinus => z_unary_minus
	|UOSparkNot => z_bool_not
	|UOSparkAbs => z_abs
	|USSparkUnaryAdd => error "trans_unary_op" 508028 []
)
=TEX
=SML
and Ûexp_unary_expÝ (env : CN_ENV) ({uop, right} : EXP UNARY_EXP) : Z_EXP = (
	case uop of
	UOSparkUnaryAdd => trans_exp env right
	|_ => 	z_unary_exp (trans_unary_op uop, trans_exp env right)
)
=TEX

\subsection{Translating Binary Expressions}
=SML
and Ûtrans_bin_opÝ (bop : BIN_OP) = (
	case bop of
	BOSparkAnd => z_bool_and
	|BOSparkAndThen => z_bool_and
	|BOSparkOr => z_bool_or
	|BOSparkOrElse => z_bool_or
	|BOSparkXor => z_bool_xor
	|BOSparkEq => z_bool_eq
	|BOSparkNotEq => z_bool_noteq
	|BOSparkLess => z_bool_less
	|BOSparkLessEq => z_bool_less_eq
	|BOSparkGreater => z_bool_greater
	|BOSparkGreaterEq => z_bool_greater_eq
	|BOSparkAdd => z_add
	|BOSparkMinus => z_minus
	|BOSparkTimes => z_times
	|BOSparkIntdiv => z_intdiv
	|BOSparkMod => z_mod
	|BOSparkRem => z_rem
	|BOSparkExpon => z_expon
	|BOSparkMem => z_bool_mem
	|BOSparkNotMem => z_bool_notmem
	|BOSparkConcat => fail "trans_bin_op" 508031 []
)
=TEX
=SML
and Ûexp_bin_expÝ (env : CN_ENV) ({left, bop, right} : EXP BIN_EXP) : Z_EXP = (
	z_bin_exp (trans_exp env left, trans_bin_op bop, trans_exp env right)
)
=TEX
\subsection{Translating Membership of a Range}
=SML
and Ûexp_mem_rangeÝ (env : CN_ENV) ({left, mop, range} : EXP MEM_RANGE)
		: Z_EXP = (
let	val {lo=lo, hi=hi} = dest_range range;
	val zright = z_rng(trans_exp env lo, trans_exp env hi);
in
	z_bin_exp (trans_exp env left, trans_bin_op mop, zright)
end
)
=TEX

\subsection{Translating Attributes}
=SML
and Ûexp_attribÝ (env : CN_ENV) ({prefix, attribute_desig=ADAttrib att}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
	zid env (trans_id (name_to_tmark prefix) ^^ trans_id att)
)
=TEX
The following covers $Exp\_Attrib\_Arg$
=SML
  | Ûexp_attribÝ env ({prefix, attribute_desig=ADAttribArg(att,arg)}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
	if	trans_id att mem [zfst, zlst, zlength, zrange]
	then
		let	val zarg = trans_exp env arg;
			val tmk = name_to_tmark prefix;
		in
			zid env (dimen(trans_id tmk ^^ trans_id att, eval_attr_arg zarg))
		end
	else
		let	val zfun = zid env (trans_id (name_to_tmark prefix) ^^ trans_id att);
			val zargs = [trans_exp env arg];
		in
			z_fun_call (zfun, zargs)
		end
)
=TEX
\subsection{Translating Indexed Components}
=SML
and Ûexp_indexed_compÝ (env : CN_ENV)
	({prefix, index as EArrayAggPos{comps, tmark as Nil}} : EXP INDEXED_COMP)
		: Z_EXP = (
let	val zfun = trans_exp env prefix;
	val zargs = map (trans_exp env) comps;
in
	z_fun_call (zfun, zargs)
end
) |  Ûexp_indexed_compÝ _ _ = (
	fail "exp_indexed_comp" 508056 []
)
=TEX
\subsection{Translating Selected Components}
=SML
and Ûexp_selected_compÝ (env : CN_ENV) ({prefix, selector} : EXP SELECTED_COMP)
		: Z_EXP = (
	z_selection (trans_exp env prefix, trans_id selector)
)
=TEX
\subsection{Translating Functions Calls}
=SML
and Ûfun_globalsÝ (env : CN_ENV) (zn : Z_ID) : Z_ID list = (
	case env zn of
		Value(_, EIEnvFunction (gs, _)) => gs
	| _=>	fail "fun_globals" 508081 [fn()=>zn]
)
=TEX
=SML
and Ûtrans_fun_nameÝ (env : CN_ENV) (n : ID) : Z_EXP = (
	let	val zn = trans_id n;
	in	case fun_globals env zn of
			[] => zid env zn
		|	gs => z_fun_call (zid env zn, map (zid env) gs)
	end
)
=TEX
=SML
and Ûexp_fun_callÝ (env : CN_ENV) ({fun_name, args} : EXP FUN_CALL) : Z_EXP = (
	case args of
		[] => trans_fun_name env fun_name
	|	_ => 
	z_fun_call (trans_fun_name env fun_name, map (trans_exp env) args)
)
=TEX
\subsection{Translating Qualified Expressions}
=SML
and Ûexp_qualifiedÝ (env : CN_ENV) ({tmark, exp} : EXP QUALIFIED_EXPRESSION)
	: Z_EXP = (
	trans_exp env exp
)
=TEX
=TEX
\subsection{Translating Type Conversions}
=SML
and Ûexp_type_convÝ (env : CN_ENV) ({tmark, exp} : EXP TYPE_CONVERSION) 
	: Z_EXP = (
	let	val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark]);
		val te = trans_exp env exp;
	in	if	ztype =: ðú_ty andalso type_of te =: ú_ty
		then	te
		else	fail "exp_type_conv" 508053 []
	end
)
=TEX
\subsection{Translating Integer Literals}
The function $trans\_int$ is defined in section \ref{INTEGERLITERALS}.
=SML
and Ûexp_int_litÝ (n : INT_LIT) : Z_EXP = (
	z_num (trans_int n)
)
=TEX
\subsection{Translating Auxiliary Expressions}
=SML
and Ûexp_auxiliary_expÝ (ae : Z_TM) : Z_EXP = (
	z_predexp_of_z_tm ae
)
=TEX
\subsection{The Function $trans\_exp$}
=SML
and Ûtrans_expÝ (env : CN_ENV) ((EId id) : EXP) : Z_EXP = exp_id env id
  | trans_exp env (EInt n) = exp_int_lit n
  | trans_exp env (e as EArrayAggPos _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggPosOthers _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggOthers _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggNamed _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggNamedOthers _) = exp_array_agg env e
  | trans_exp env (ERecAggPos {tmark, comps}) =
		exp_rec_agg_pos_z env (tmark, map (trans_exp env) comps)
  | trans_exp env (ERecAggNamed an) = exp_rec_agg_named env an
  | trans_exp env (EUnaryExp ue) = exp_unary_exp env ue
  | trans_exp env (EBinExp be) = exp_bin_exp env be
  | trans_exp env (EMemRange be) = exp_mem_range env be
  | trans_exp env (EAttribute at) = exp_attrib env at
  | trans_exp env (EIndexedComp ic) = exp_indexed_comp env ic
  | trans_exp env (ESelectedComp sc) = exp_selected_comp env sc
  | trans_exp env (EFunCall fc) = exp_fun_call env fc
  | trans_exp env (EAuxiliaryExp ae) = exp_auxiliary_exp ae
  | trans_exp env (EQualifiedExp qe) = exp_qualified env qe
  | trans_exp env (ETypeConversion tc) = exp_type_conv env tc
  | trans_exp env (EBracketed e) = trans_exp env e
  | trans_exp env (EStringLiteral c) = fail "trans_exp" 508033 []
  | trans_exp env (ECharacterLiteral c) = fail "trans_exp" 508034 []
and Ûexp_array_aggÝ (env : CN_ENV) (e : EXP) : Z_EXP = (
	let	val tname = (
			case e of
			EArrayAggPos {tmark as Value tmk, ...} => tmk
		|	EArrayAggPosOthers {agg_pos as {tmark as Value tmk, ...}, ...} => tmk
		|	EArrayAggOthers {tmark as Value tmk, ...} => tmk
		|	EArrayAggNamed {tmark as Value tmk, ...} => tmk
		|	EArrayAggNamedOthers {agg_named as {tmark as Value tmk, ...}, ...} => tmk
		|	_ => fail "exp_array_agg" 508054 []);
		val this = 1;
		val max = array_dim env tname;
	in	mk_array_agg
		(max, trans_array_agg_exp env {tname = tname, this = this, max = max} e)
	end
);
=TEX
The following variant of $trans\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a comment message is printed out and $Nil$ is returned.
=SML
fun Ûtrans_exp1Ý (env : CN_ENV) (exp : EXP) : Z_EXP OPT = (
	Value (trans_exp env exp)
	handle Fail msg  => (
		comment "trans_exp1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX

\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}

=SML
fun Ûnamed_assocs_to_expsÝ (names : ID list)
		(ns : (AGG_CHOICE,EXP) NAMED_ASSOC list) : EXP list = (
let	val lns = length ns;
	val table =	if lns = length names
			then	combine names (interval 0 (length ns - 1))
			else	fail "named_assocs_to_exps" 508043 [];
	fun aux1 ((ACAggChoiceSingle exp)::rest) = (
		(	lassoc3 table (name_to_tmark exp)
				handle _ => fail "named_assocs_to_exps" 508044
					[fn()=>name_to_tmark exp]
		)::aux1 rest
	) | aux1 ((ACAggChoiceRange _)::_) = (
		fail "named_assocs_to_exps" 508045 []
	) | aux1 _ = [];
	fun aux2 ({choice=cs,comp}::rest) = (
	let	val chmap = map (fn choice => (choice, comp))(aux1 cs);
	in
		chmap::(aux2 rest)
	end) | aux2 _ = [];
	val s = flat (aux2 ns);
	fun order (a:int,_) (b,_) = a-b;
	val nssorted = Sort.sort order s;
	fun aux3 count ((i, exp)::rest) = (
		if count=i
		then
			exp::aux3 (count+1) rest
		else
			fail "named_assocs_to_exps" 508043 []
	) | aux3 _ _ = [];
in
	aux3 0 nssorted
end);
=TEX

=SML
val Ûinformal_functionÝ : Z_ID = "INFORMAL_FUNCTION";
fun Ûadjust_idÝ (env : CN_ENV) (id : ID)  = (
	case (env (trans_id id)) of
		Value (ty, EIEnvFunction _) => 
			if	(fst(dest_ctype ty) <> informal_function)
			then	EFunCall{fun_name=id, args=[]}
			else	fail "adjust_id" 508049 [fn()=>id]
	| _ => EId id
)
and Ûadjust_rangelohiÝ (env : CN_ENV) ({lo=l, hi=h} : EXP RANGELOHI) = (
	{lo=adjust_exp env l, hi=adjust_exp env h}
)
and Ûadjust_rangeÝ (env : CN_ENV) (RRange x : EXP RANGE) = (
	RRange (adjust_rangelohi env x)
) | adjust_range env (RRangeAttr x : EXP RANGE) = (
	RRangeAttr (adjust_exp env x)
)
and Ûadjust_discrete_range_constrainedÝ (env : CN_ENV) ({tmark=t, range=r} :
		EXP DISCRETE_RANGE_CONSTRAINED) = (
	{tmark=t, range=adjust_range env r}
)
and Ûadjust_discrete_rangeÝ (env : CN_ENV) (DRRange x : DISCRETE_RANGE) = (
	DRRange (adjust_range env x)
) | adjust_discrete_range env (DRConstrained x : DISCRETE_RANGE) = (
	DRConstrained(adjust_discrete_range_constrained env x)
)
and Ûadjust_agg_choiceÝ (env : CN_ENV) (ACAggChoiceRange x : AGG_CHOICE) = (
	ACAggChoiceRange (adjust_discrete_range env x)
) | adjust_agg_choice env(ACAggChoiceSingle x : AGG_CHOICE) = (
	ACAggChoiceSingle (adjust_exp env x)
)
and Ûadjust_named_assocÝ (env : CN_ENV) ({choice=c, comp=e}
		: (AGG_CHOICE, EXP) NAMED_ASSOC) = (
	{choice=map (adjust_agg_choice env) c, comp=adjust_exp env e}
)
and Ûadjust_othersÝ (env : CN_ENV) ({others=oth} : EXP OTHERS) = (
	{others=adjust_exp env oth}
)
and Ûadjust_agg_posÝ (env : CN_ENV)
		({tmark=tmark as Value t, comps=c} : EXP AGG_POS) = (
	case env t of
	Value (ty, EIEnvRecordType _) => (
			ERecAggPos {tmark=tmark, comps=map (adjust_exp env) c}
        ) |_ => (
			EArrayAggPos {tmark=tmark, comps=map (adjust_exp env) c}
	)
) | adjust_agg_pos  (env : CN_ENV)
		({tmark=Nil, comps=c} : EXP AGG_POS) = (
	EArrayAggPos {tmark=Nil, comps=map (adjust_exp env) c}
)
and Ûadjust_agg_pos_othersÝ (env : CN_ENV) ({agg_pos = {tmark=t, comps=c} :
		EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) = (
	EArrayAggPosOthers {	agg_pos={	tmark=t,
						comps=map (adjust_exp env) c},
				others=adjust_others env oth}
)
and Ûadjust_agg_othersÝ	(env : CN_ENV)
				({tmark=t, others=oth} : EXP AGG_OTHERS) = (
         EArrayAggOthers{tmark=t, others=adjust_others env oth}
)
and Ûadjust_agg_namedÝ (env : CN_ENV) ({tmark=t, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
	EArrayAggNamed {tmark=t, named_assocs=map (adjust_named_assoc env) n}
)
and Ûadjust_agg_named1Ý (env : CN_ENV)
		({tmark=tmark as Value t, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
let	val n' = map (adjust_named_assoc env) n;
in
	case env t of
	Value (ty, EIEnvRecordType _) => (
			ERecAggNamed {tmark=tmark, named_assocs=n'}
        ) |_ => (
			EArrayAggNamed {tmark=tmark, named_assocs=n'}
	)
end
) | adjust_agg_named1 (env : CN_ENV)
		({tmark= Nil, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
let	val n' = map (adjust_named_assoc env) n;
in
	EArrayAggNamed {tmark=Nil, named_assocs=n'}
end
)
and Ûadjust_agg_named_othersÝ (env : CN_ENV) ({agg_named=a, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) = (
let	val adjagg = case adjust_agg_named1 env a of
		EArrayAggNamed ag => (
			ag
		) | _ => fail "adjust_exp" 508046 []
in
	EArrayAggNamedOthers{agg_named=adjagg,others=adjust_others env oth}
end
)
and Ûadjust_unary_expÝ (env : CN_ENV) ({uop=u, right=r} : EXP UNARY_EXP) = (
	EUnaryExp{uop=u, right=adjust_exp env r}
)
and Ûadjust_bin_expÝ (env : CN_ENV) ({bop=b, left=l, right=r} : EXP BIN_EXP) = (
	EBinExp{left=adjust_exp env l, bop=b, right=adjust_exp env r}
)
and Ûadjust_attrib_desigÝ (env : CN_ENV) (ADAttrib x : ATTRIB_DESIG) = (
	ADAttrib x
) | adjust_attrib_desig env (ADAttribArg (a,e) : ATTRIB_DESIG) = (
	ADAttribArg (a, adjust_exp env e)
)
and Ûadjust_mem_rangeÝ	(env : CN_ENV)
				({mop=m, left=l, range=r} : EXP MEM_RANGE) = (
	EMemRange{left=adjust_exp env l, mop=m, range=adjust_range env r}
)
and Ûadjust_attributeÝ (env : CN_ENV) ({prefix=p, attribute_desig=a} :
		(EXP, ATTRIB_DESIG) ATTRIBUTE) = (
	EAttribute{prefix=adjust_exp env p, attribute_desig=adjust_attrib_desig env a}
)
and Ûadjust_indexed_compÝ	(env : CN_ENV)
				({prefix=p, index=i} : EXP INDEXED_COMP) = (
let	val prename = name_to_tmark p;
in
	case (env prename, i) of
=TEX
Is it a function call?
=SML
	(Value (ty, EIEnvFunction _), EArrayAggPos{comps,...}) => (
		if	(fst(dest_ctype ty) <> informal_function)
		then	EFunCall{fun_name=prename, args=map (adjust_exp env) comps}
		else	fail "adjust_id" 508049 [fn()=>prename]
	) |(Value (ty, EIEnvFunction (_, names)), EArrayAggNamed{named_assocs, ...}) => (
	let	val args = named_assocs_to_exps names named_assocs;
	in	if	(fst(dest_ctype ty) <> informal_function)
		then	EFunCall
			{fun_name=prename, args=map (adjust_exp env) args}
		else	fail "adjust_id" 508049 [fn()=>prename]
	end
=TEX
Is it a type conversion?
=SML
	) |(Value (_, EIEnvRecordType _), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
	) |(Value (_, EIEnvOtherType), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
=TEX
No... It must be an indexed component for real. So check for errors...
=SML
	) |(_, EArrayAggPos {comps=[], ...}) => (
		fail "adjust_indexed_comp" 508035 [fn()=> name_to_tmark p]

	) |(_, EArrayAggPos{comps=comps, tmark=Nil}) => (
		EIndexedComp{prefix=adjust_exp env p,
			index = EArrayAggPos{comps = map (adjust_exp env) comps, tmark = Nil}}

	) |(_, EArrayAggPos _) => (
		fail "adjust_indexed_comp" 508055 [fn()=> name_to_tmark p]

	) |(_, EArrayAggNamed _) => (
		fail "adjust_indexed_comp" 508047 [fn()=>name_to_tmark p]

	) |_ => (
		fail "adjust_indexed_comp" 508048 [fn()=>prename]

	)
end
)
and Ûadjust_selected_compÝ env ({prefix=p, selector=s} : EXP SELECTED_COMP) = (
	case p of
	EId id => (
		case env id of
		Value (ty, _) => (
			(	(dest_z_schema_type ty);
				ESelectedComp{prefix=adjust_exp (env : CN_ENV) p,
							selector=s}	)
			handle Fail _ => adjust_exp env (EId (id^"."^s))
		)| _ =>
			adjust_exp env (EId (id^"."^s))

	) | _ => 	(
		ESelectedComp{prefix=adjust_exp (env : CN_ENV) p, selector=s}
	)
)
and Ûadjust_qualified_expressionÝ
				(env : CN_ENV)
				({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	case e of
	EArrayAggPos{comps = [comp],...} => (
		EQualifiedExp{tmark = t, exp = adjust_exp env comp}
	)| EArrayAggPos{comps,...} => (
		adjust_agg_pos env {comps=comps, tmark=Value t}
	)| EArrayAggPosOthers{agg_pos={comps,...}, others} => (
		adjust_agg_pos_others env 
			{agg_pos={comps=comps,tmark=Value t},others=others}
	)| EArrayAggOthers{others,...} => (
		adjust_agg_others env {others=others,tmark=Value t}
	)| EArrayAggNamed {named_assocs = n, tmark= _} => (
		 adjust_agg_named1 env {named_assocs = n, tmark = Value t}
	)| EArrayAggNamedOthers
			{agg_named as {named_assocs = n, tmark = _}, others} => (
		adjust_agg_named_others env 
			{	agg_named={named_assocs = n, tmark = Value t},
				others=others}
	)|_ => error "adjust_qualified_exp" 508042 []
)
=TEX
In the following, both named and positional record aggregates and function calls
need no adjustment since these constructs can only be produced by adjust\_exp.
If they occur in the input then it adjust\_exp will already have been called
and need not be called again.
=SML
and Ûadjust_expÝ (env : CN_ENV) (exp as (EId id : EXP)) = (
	adjust_id env id
) | adjust_exp env (exp as (EInt _)) = (
	exp
) | adjust_exp env (exp as (EArrayAggPos x)) = (
	adjust_agg_pos env x
) | adjust_exp env (exp as (EArrayAggPosOthers x)) = (
	adjust_agg_pos_others env x
) | adjust_exp env (exp as (EArrayAggOthers x)) = (
	adjust_agg_others env x
) | adjust_exp env (exp as (EArrayAggNamed x)) = (
	adjust_agg_named env x
) | adjust_exp env (exp as (EArrayAggNamedOthers x)) = (
	adjust_agg_named_others  env x
) | adjust_exp env (exp as (ERecAggPos x)) = (
	exp
) | adjust_exp env (exp as (ERecAggNamed x)) = (
	exp
) | adjust_exp env (exp as (EUnaryExp x)) = (
	adjust_unary_exp env x
) | adjust_exp env (exp as (EBinExp x)) = (
	adjust_bin_exp env x
) | adjust_exp env (exp as (EMemRange x)) = (
	adjust_mem_range env x
) | adjust_exp env (exp as (EAttribute x)) = (
	adjust_attribute env x
) | adjust_exp env (exp as (EIndexedComp x)) = (
	adjust_indexed_comp env x
) | adjust_exp env (exp as (ESelectedComp x)) = (
	adjust_selected_comp env x
) | adjust_exp env (exp as (EFunCall _)) = (
	exp
) | adjust_exp env (exp as (EAuxiliaryExp _)) = (
	exp
) | adjust_exp env (exp as (EQualifiedExp x)) = (
	adjust_qualified_expression env x
) | adjust_exp env (exp as (ETypeConversion _)) = (
	exp
) | adjust_exp env (exp as (EBracketed x)) = (
	adjust_exp env x
) | adjust_exp env (exp as (EStringLiteral _)) = (
	exp
) | adjust_exp env (exp as (ECharacterLiteral _)) = (
	exp
);
=TEX
The following variant of $adjust\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a comment message is printed out and $Nil$ is returned.
=SML
fun Ûadjust_exp1Ý (env : CN_ENV) (exp : EXP) : EXP OPT = (
	Value (adjust_exp env exp)
	handle Fail msg  => (
		comment "adjust_exp1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX

\section{CHECKING FOR EMPTY RANGES}
The code in this section implements check 14 from section 17.1 of volume I of the specifications.
This requires evaluation of static expressions which is most conveniently done using proof.

The following function generates the VC for checking that a type or subtype defined by a range constraint is non-empty.
=SML
val Ûx_varÝ = ñ(x º ð ú)®;
val Ûvc_patternÝ = ñ‘x_var® ½ š®;
 
fun Ûrange_check_vcÝ (n : Z_ID) = (
	subst[(mk_z_gvar(n, ðú_ty, []), x_var)] vc_pattern
);
=TEX
The following function reports an error if the range bounds can be evaluated and the range proves to be empty;
if the range can be evaluated and is non-empty then the function returns an empty list of paragraphs;
if the range cannot be evaluated a paragraph containing a VC is returned.

The somewhat strange way of expressing the decision-making arises from the desire to include the two equations in the message in the error case.
=SML
fun Ûrange_check_vcsÝ
	(n : Z_ID) (lo : TERM) (hi : TERM) : PARAINFO list = (
	(let	val lo_eqn = (concl o TRY_C(cn_eval_conv[])) lo;
		val hi_eqn = (concl o TRY_C(cn_eval_conv[])) hi;
		val nlo = (dest_z_signed_int o snd o dest_eq) lo_eqn;
		val nhi = (dest_z_signed_int o snd o dest_eq) hi_eqn;
		fun show t = (
			let	val (x, _) = dest_eq t;
			in	if	is_z_signed_int x
				then	x
				else	t
			end
		);
	in	if	nlo @<= nhi
		then	(fn _ => [])
		else	(fn _ =>
				term_fail  "trans_basic_decl"
					508060 [show lo_eqn, show hi_eqn])
	end	handle Fail _ => (fn _ =>
			(comment "trans_basic_decl"508061 [fn _ => n];
			[ConjectureInfo(Value n, [], range_check_vc n)])
	))	()
);
=TEX

\section{TRANSLATING SPARK BASIC DECLARATIONS}

\subsection{Translating Constants}

=SML
fun Ûbasic_decl_constÝ
		(env : CN_ENV)
		({consts=consts, tm=tm, expr=expr} : EXP CONST_DECL)
		: PARAINFO list= (
	let	val ae = adjust_exp1 env expr;
		val te = case ae of Value e => trans_exp1 env e | _ => Nil;
	in	case te of
			Value te =>
				map
				(fn const => z_eq_eq(trans_id const, te))
				consts
		|	Nil => (
			let	fun do1 const = (
					let	val zexp = zid env (trans_id tm);
						val zvar = trans_id const;
					in	z_ax(zvar, zexp, [])
					end
				);
			in	map do1 consts
			end		
		)
	end
);
=TEX
\subsection{Translating Enumeration Types}
=SML
fun Ûenum_attribÝ (env : CN_ENV) (zid‰1 : Z_ID, zid‰2 : Z_ID, zid‰3 : Z_ID) = (
let	fun env' id = 
		if id = (zid‰1 ^^ zlst)
		then	Value (ú_ty, EIEnvOther)
		else if id mem [zid‰1 ^^ zsuc, zid‰1 ^^ zpos]
		then	Value (úú_ty,EIEnvOther)
		else	env id;
	val zexp = z_set_minus (zid env' zid‰1, z_set [zid env' (zid‰1 ^^ zlst)]);
in
	[z_eq_eq (zid‰1 ^^ zfst, zid env' zid‰2),
	z_eq_eq (zid‰1 ^^ zlst, zid env' zid‰3),
	z_eq_eq (zid‰1 ^^ zsuc, z_dom_res (zexp, zsucc)),
	z_eq_eq(zid‰1 ^^ zpred, z_inv(zid env' (zid‰1 ^^ zsuc))),
	z_eq_eq(zid‰1 ^^ zpos, z_id_rel (zid env' zid‰1)),
	z_eq_eq(zid‰1 ^^ zval, z_inv(zid env' (zid‰1 ^^ zpos)))]
end);
=TEX
=SML
fun Ûbasic_decl_enumÝ (env : CN_ENV) (name : ID) (td : ENUM_TYPE_DEF) = (
let	val {vals} = td;
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map (z_num o integer_of_int) (interval 0 ((length vals)-1));
	fun env' id = (
		if id mem zvals
		then
			Value (ú_ty, EIEnvOther)
		else if id = zname
		then
			Value (ðú_ty, EIEnvOther)
		else
			env id
	);
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid env' (hd zvals), zid env' ((hd o rev) zvals)))] @
	enum_attrib env' (zname, hd zvals, (hd o rev) zvals)
end);
=TEX
\subsection{Translating Array Types}
=SML
fun Ûarray_attrib_auxÝ (env : CN_ENV) (zid‰1 : Z_ID) (zid‰2 : Z_ID, i : int) : PARAINFO list = (
	[z_eq_eq(dimen(zid‰1 ^^ zfst, i), zid env (zid‰2 ^^ zfst)),
	z_eq_eq(dimen(zid‰1 ^^ zlst, i), zid env (zid‰2 ^^ zlst)),
	z_eq_eq(dimen(zid‰1 ^^ zlength, i), z_size (zid env zid‰2)),
	z_eq_eq(dimen(zid‰1 ^^ zrange, i), zid env zid‰2)]
);
=TEX
The handler below catches failures from {\it hd}.
=SML
fun Ûarray_attribÝ (env : CN_ENV) (zid : Z_ID, zids : Z_ID list) : PARAINFO list = (
	let	val aux = array_attrib_aux env zid;
		val zids_is = combine zids (interval 1 (length zids));
	in	aux (hd zids, 0) @
		flat (map aux zids_is)
	end	handle Fail _ => fail "array_attrib" 508035 [] 
);
=TEX
=SML
fun Ûbasic_decl_con_arrayÝ (env : CN_ENV) (name : ID)
		({index=index, comp=comp} : ARRAY_DEF) : PARAINFO list = (
	let	val zname = trans_id name;
		val zindex = z_many_cross (map (zid env o trans_id) index);
		val zcomp = trans_id comp;
	in
		[z_eq_eq(zname, z_tfun(zindex, zid env zcomp))] @
		array_attrib env (zname, index)
	end
);
=TEX
=SML
=TEX
=SML
fun Ûbasic_decl_uncon_arrayÝ (env : CN_ENV) (name : ID)
		({index=[head_index], comp=comp} : ARRAY_DEF) : PARAINFO list = (
	let	val zname = trans_id name;
		val zindex = trans_id head_index;
		val zcomp = trans_id comp;
		val zexp = z_powerset(z_pfun(zid env zindex, zid env zcomp));
	in
		[z_ax(zname, zexp, [])]
	end
) | basic_decl_uncon_array env name
	({index=index, comp=comp} : ARRAY_DEF) = (
	let	val zname = trans_id name;
		val zindex = z_many_cross (map (zid env o trans_id) index);
		val zcomp = trans_id comp;
		val zexp = z_powerset(z_pfun(zindex, zid env zcomp));
	in
		[z_ax(zname, zexp, [])]
	end
);
=TEX

\subsection{Translating Record Types}
=SML
fun Ûconv_var_declÝ ({vars=vs, tmark=t} : VAR_DECL)
		: {var : ID, tmark : TMARK} list = (
	 map (fn id => {var=id, tmark=t}) vs
);
=TEX
=SML
fun Ûtrans_decl_auxÝ (env : CN_ENV) ({vars, tmark} : VAR_DECL) : Z_DECL * (Z_ID list) = (
let	val zvs = map trans_id vars;
	val zexp = zid env (trans_id tmark);
	val zvars = map (fn zv => mk_z_lvar (zv,
						(dest_z_power_type o type_of) zexp,
						[])) zvs;
in
	(mk_z_dec (zvars, zexp), zvs)
end);
fun Ûtrans_declÝ (env : CN_ENV) : VAR_DECL -> Z_DECL = fst o trans_decl_aux env;
=TEX
=SML
local
fun Ûmk_update_defsÝ (tyname : Z_ID) (comps : Z_ID list list) : PARAINFO = (
	let	val n_comps = length comps;
		val gen_formals = map (fn i => "g" ^ string_of_int i) (interval 1 n_comps);
		fun do_sch_decs [] _ = []
		|   do_sch_decs comps gen_formals = (
			let	val c = hd comps;
				val n = hd gen_formals;
				val ty = mk_z_var_type n;
				fun mk_v v = mk_z_lvar(v, ty, []);
			in	(map mk_v c, mk_z_lvar(n, mk_z_power_type ty, []))
			end	:: do_sch_decs (tl comps) (tl gen_formals)
		);
		val sch_decs = do_sch_decs comps gen_formals;
		val decl = mk_z_decl(map mk_z_dec sch_decs);
		val h_schema = mk_z_h_schema (decl, mk_t);
		val _ = schema_gen_semantic_const h_schema;
		fun upd_name c = tyname ^ "u" ^ c;
		fun do_sig_decs [] _ = []
		|   do_sig_decs comps decs = (
			let	val c = hd comps;
				val (_, x) = hd decs;
				val set = z_tfun(mk_z_¸[h_schema, x], h_schema);
				val ty = dest_z_power_type (type_of set);
				fun mk_v v = mk_z_lvar(upd_name v, ty, []);
			in	(map mk_v c, set)
			end	:: do_sig_decs (tl comps) (tl decs)
		);
		val sig_decs = do_sig_decs comps sch_decs;
		val sig_decl = mk_z_decl(map mk_z_dec sig_decs);
		fun do_µ_decs _ [] = []
		|   do_µ_decs n ((_, x)::more) = (
			let	val ty = dest_z_power_type (type_of x);
				val v = mk_z_lvar("x" ^ string_of_int n, ty, []);
			in	([v], x)
			end	:: do_µ_decs (n+1) more
		);
		val r = mk_z_lvar("r", dest_z_power_type(type_of h_schema), []);
		val r_dec = ([r],	h_schema);
		val var_decs = do_µ_decs 1 sch_decs;
		val µ_decl = mk_z_decl(map mk_z_dec (r_dec :: var_decs));
		fun bind_one sel var comp = (
			if	sel = comp
			then	(comp, var)
			else	(comp, mk_z_sel‰s(r, comp))
		);
		fun do_binding _ _  [] = []
		|   do_binding var sel cmps = (
			let	val cmpl = hd cmps;
			in	map (bind_one sel var) cmpl
			end	@ do_binding var sel (tl cmps)
		);
		fun do_eq var arg (f, c) = (
			mk_z_eq(mk_z_app(f, arg), z_binding(do_binding var c comps))
		); 
		fun do_eqs [] _ _ = []
		|   do_eqs sigdecs vardecs cmps = (
			let	val (fs, _) = hd sigdecs;
				val cs = hd cmps;
				val var = hd(fst(hd vardecs));
				val arg = mk_z_tuple[r, var];
			in	map (do_eq var arg) (combine fs cs)
			end	@ do_eqs (tl sigdecs) (tl vardecs) (tl cmps)
		);
		val eqs = list_mk_±(do_eqs sig_decs var_decs comps);
		val pred = mk_z_µ(µ_decl, mk_t, eqs);
		val idtys = map dest_var (flat (map fst sig_decs));
	in	AxDesInfo(gen_formals, sig_decl, Value pred, idtys)
	end
);
in
fun Ûrecord_update_defsÝ (zname : Z_ID, zcomps : Z_ID list list) : PARAINFO = (
	mk_update_defs zname zcomps
);
end;
=TEX
=SML
fun Ûbasic_decl_recordÝ (env : CN_ENV) (name : ID)
		({decl} : RECORD_TYPE_DEF) : PARAINFO list = (
let	val z_sname = trans_id name;
	val (z_decls, zcomps) = split(map (trans_decl_aux env) decl);
in
	[z_schema(z_sname, z_decls), record_update_defs(z_sname, zcomps)]
end);
=TEX
\subsection{Translating Integer Types}

=SML
local
	val zid_zints = ñú®;
	val z_exp = z_pfun(zid_zints, zid_zints);
in
fun Ûint_type_attribÝ (env : CN_ENV) (zid1, range) = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val zvar1 = zid1 ^^ zsuc;
		val zvar2 = zid1 ^^ zpred;
		val zvar3 = zid1 ^^ zpos;
		val zvar4 = zid1 ^^ zval;
	in
		[z_eq_eq(zid1 ^^ zfst, trans_exp env lo),
		z_eq_eq(zid1 ^^ zlst, trans_exp env hi),
		z_ax(zvar1, z_exp, []),
		z_ax(zvar2, z_exp, []),
		z_ax(zvar3, z_exp, []),
		z_ax(zvar4, z_exp, [])]
	end
);
end;
=TEX
=SML
fun Ûbasic_decl_int_typeÝ (env : CN_ENV) (name : ID) (range : EXP RANGE)
	: PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val tlo = trans_exp env lo;
		val thi = trans_exp env hi;
		val zname = trans_id name;
		val vcs = range_check_vcs name tlo thi;
	in
		(z_eq_eq(zname, z_rng(tlo, thi)) ::
			int_type_attrib env (zname, RRange{lo=lo,hi=hi})) @ vcs
	end
);
=TEX
\subsection{Translating Real Types}

=TEX
=SML
fun Ûbasic_decl_real_typeÝ (name : ID) : PARAINFO list = (
	let	val zname = trans_id name;
	in	[z_given zname]
	end
);
=TEX

\subsection{Translating Subtypes}
=SML
fun Ûrange_con_attribÝ (env : CN_ENV) (zid‰1 : Z_ID, zid‰2 : Z_ID, {lo,hi}
		: EXP RANGELOHI) : PARAINFO list = (
	[z_eq_eq (zid‰1 ^^ zfst, trans_exp env lo),
	z_eq_eq (zid‰1 ^^ zlst, trans_exp env hi),
	z_eq_eq (zid‰1 ^^ zsuc, zid env (zid‰2 ^^ zsuc)),
	z_eq_eq (zid‰1 ^^ zpred, zid env (zid‰2 ^^ zpred)),
	z_eq_eq (zid‰1 ^^ zpos, zid env (zid‰2 ^^ zpos)),
	z_eq_eq (zid‰1 ^^ zval, zid env (zid‰2 ^^ zval))]
);
=TEX
The following function does the processing which is commont to cases of
a subtype which gives rise to an axiomatic description rather than an abbreviation definition.
=SML
fun Ûbasic_decl_subtype_axdesÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
	: PARAINFO list = (
	let	val zvar = trans_id name;
		val ztmark = trans_id tmark;
		val zexp = z_powerset (zid env tmark)
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark];
	in	[z_ax(zvar, zexp, [])]
	end
);
=TEX
In the following, the first cases alternative implements
=INLINEFT
Basic_Decl_Range_Con_1
=TEX
\ and the second implements
=INLINEFT
Basic_Decl_Range_Con_2
=TEX
.
=SML
fun Ûbasic_decl_subtype_range_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		(range : EXP RANGE) : PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val zname = trans_id name;
		val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark]);
		val te_lo = trans_exp1 env lo;
		val te_hi = trans_exp1 env hi;
	in	case (ztype =: ðú_ty, te_lo, te_hi) of
			(true, Value l, Value h) =>
				let	val vcs = range_check_vcs name l h
				in	z_eq_eq(zname, z_rng(l, h)) ::
					range_con_attrib env
					(zname, ztmark, {lo=lo,hi=hi}) @ vcs
				end
		|	_ =>	basic_decl_subtype_axdes env name tmark
	end
);
=TEX
=SML
val Ûbasic_decl_subtype_floating_fixed_conÝ : CN_ENV -> ID
	-> TMARK -> PARAINFO list = basic_decl_subtype_axdes;
=SML
fun Ûbasic_decl_subtype_index_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		(ci : EXP list) : PARAINFO list = (
let	val zname = trans_id name;
	val zexp = zid env (trans_id tmark);
	val zvar_ty = dest_z_power_type(type_of zexp)
		handle Fail _ => fail "trans_basic_decl" 508051 [fn () => tmark];
	val var =  "array";
	val env' = fn id => if id = "array" then Value (zvar_ty, EIEnvVar tmark)
					else env id; 
	val index = map name_to_tmark ci;
	val zindex = map trans_id index;
	val zp = z_eq (z_dom (zid env' var), z_many_cross(map (zid env) zindex));
	val set_comp = z_set_comp (trans_decl env' {vars=[var],tmark=tmark}, zp)
	val abb_def = z_eq_eq (zname, set_comp);
in	abb_def :: array_attrib env (zname, zindex)
end
);
=TEX
The following is based on material taken from the Ada Reference Manual.
It is based on all Ada attributes, not just those mentioned in the list in
Volume 3, section 3.13 of the specification of the Compliance Notation.
=SML
val Ûada_attributes_listÝ : ID list = [
	"ADDRESS",
	"AFT",
	"BASE",
	"CALLABLE",
	"CONSTRAINED",
	"DELTA",
	"DIGITS",
	"EMAX",
	"EPSILON",
	"FIRST",
	"FORE",
	"IMAGE",
	"LARGE",
	"LAST",
	"LENGTH",
	"MACHINE_OVERFLOWS",
	"MACHINE_ROUNDS",
	"MANTISSA",
	"POS",
	"PRED",
	"RANGE",
	"SAFE_EMAX",
	"SAFE_LARGE",
	"SAFE_SMALL",
	"SIZE",
	"SMALL",
	"STORAGE_SIZE",
	"SUCC",
	"TERMINATED",
	"VAL",
	"VALUE",
	"WIDTH"
	];
=TEX
=SML
fun Ûtype_attrsÝ (t : ID) = (
let	val tthy = get_const_theory (bind_gvar_name t);
	val tthyconsts = get_consts tthy;
	val tthyconsts_names = map (fst o dest_const) tthyconsts;
	val transt = trans_id t;
in
	ada_attributes_list drop 
		(fn attr => not((bind_gvar_name transt ^^ attr) mem tthyconsts_names))
end
handle (Fail _) => [] (* presumably from get_const_theory *)
);
=IGN
type_attrs "NATURAL";
=TEX

=SML
fun Ûbasic_decl_subtype_no_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		: PARAINFO list = (
let	val zname = trans_id name;
	val zexp = zid env (trans_id tmark);
	val zvar_ty = dest_z_power_type(type_of zexp)
		handle Fail _ => fail "trans_basic_decl" 508051 [fn () => tmark];
	val abb_def = z_eq_eq (zname, zexp);
	val tas = type_attrs tmark;
	val tas_paras = map (fn attr => z_eq_eq(zname ^^ attr, 
		zid env (trans_id tmark ^^ attr))) tas;
in	
	(abb_def :: tas_paras)
end);
=TEX

\subsection{The Function $trans\_basic\_decl$}
=SML
fun Ûtrans_basic_declÝ (env : CN_ENV) ((BDConstDecl {consts,tm,expr}) : BASIC_DECL)
		: PARAINFO list = (
	basic_decl_const env {consts=consts, tm=tm, expr=expr}
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDEnumTypeDef td,...}) = (
	basic_decl_enum env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDIntTypeDef range,...}) = (
	basic_decl_int_type env name range
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDConArrayDef td,...}) = (
	basic_decl_con_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDUnconArrayDef td,...}) = (
	basic_decl_uncon_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDRecordTypeDef td,...}) = (
	basic_decl_record env name td
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CRange cr},...}) = (
	basic_decl_subtype_range_con env name tmark cr
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CIndex ci},...}) = (
	basic_decl_subtype_index_con env name tmark ci
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFloating _},...}) = (
	basic_decl_subtype_floating_fixed_con env name tmark
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFixed _},...}) = (
	basic_decl_subtype_floating_fixed_con env name tmark
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CNoCon},...}) = (
	basic_decl_subtype_no_con env name tmark
) | trans_basic_decl env (BDTypeDecl {name, type_def as TDFloatingTypeDef _}) = (
	basic_decl_real_type name
) | trans_basic_decl env (BDTypeDecl {name, type_def as TDFixedTypeDef _}) = (
	basic_decl_real_type name
) | trans_basic_decl env (BDDeferredConstDecl _) = (
	fail "trans_basic_decl" 508039 []
) | trans_basic_decl env (BDVarDecl _) = (
	fail "trans_basic_decl" 508040 []
) | trans_basic_decl env (BDVarDeclInit _) = (
	fail "trans_basic_decl" 508040 []
) | trans_basic_decl env (BDPrivateTypeDecl _) = (
	fail "trans_basic_decl" 508041 []
) | trans_basic_decl env (BDPragma _) = (
	[]
) | trans_basic_decl env (BDAnnotation _) = (
	[]
);
=TEX
=SML
fun Ûtrans_basic_decl1Ý (env : CN_ENV) (bd : BASIC_DECL)
			: PARAINFO list OPT = (
	Value (trans_basic_decl env bd)
	handle Fail msg  => (
		comment "trans_basic_decl1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX
\section{Support for Multidimensional Arrays}
=SML
fun Ûarray_agg_defÝ (num : int) : unit = (
if	num >= 2
then
let	val fun_name = z_array_agg num;
in	case get_const_type (bind_gvar_name fun_name) of
		Value _ => ()
	|	Nil =>
	let	fun mk_gvar name = (
			let val ty = mk_z_power_type(mk_z_var_type name);
			in	mk_z_lvar(name, ty, [])
			end
		);
		val ns = map string_of_int (interval 1 num);
		val g_ns = map (mk_gvar o (fn n => "g" ^ n)) ns;
		val g = mk_gvar "g";
		val prod = z_many_cross g_ns;
		val uncurried_tm = z_tfun(prod, g);
		fun mk_curried_tm [] = g
		|   mk_curried_tm (g_n::more) = z_tfun(g_n, mk_curried_tm more);
		val curried_tm = mk_curried_tm g_ns;
		val sig_tm = z_tfun(curried_tm, uncurried_tm);
		val sig_ty = dest_z_power_type (type_of sig_tm);
		val fun_var = mk_z_lvar(fun_name, sig_ty, []);
		val sig_decl = mk_z_decl[mk_z_dec([fun_var], sig_tm)];
		val f = mk_z_lvar("f", dest_z_power_type(type_of curried_tm), []);
		fun mk_x_n (v, n) = (
			mk_z_lvar("x" ^ n, dest_z_power_type (type_of v), [])
		);
		val x_ns = map mk_x_n (combine g_ns ns);
		val tuple = mk_z_tuple x_ns;
		val lhs = mk_z_app(mk_z_app(fun_var, f), tuple);
		fun mk_rhs t [] = t
		|   mk_rhs t (x_n::more) = mk_rhs (mk_z_app(t, x_n)) more;
		val rhs = mk_rhs f x_ns;
		val eqn = mk_z_eq(lhs, rhs);
		fun dec_of_var (v, e) = mk_z_dec([v], e);
		val x_decs = map dec_of_var (combine x_ns g_ns); 
		val pred = mk_z_µ(mk_z_decl(dec_of_var(f, curried_tm)::x_decs), mk_t, eqn);
		val idtys = [dest_var fun_var];
	in	update_theory_db_with_parainfo
		(AxDesInfo(map (fst o dest_var) (g_ns @ [g]), sig_decl, Value pred, idtys))
	end
end
else fail "array_agg_def" 508059 []
);
=TEX
\section{EPILOGUE}

=SML
end (* structure CNBasicDeclsAndExprs *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
