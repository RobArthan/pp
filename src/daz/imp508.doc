% imp508.doc   %Z% $Date: 2000/10/31 11:40:57 $ $Revision: 1.71 $ $RCSfile: imp508.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP508}  %% Mandatory field
\def\SCCSversion{$Revision: 1.71 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/10/31 11:40:57 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the implementation for the Basic Declaration and Expression Generator for processing Compliance Notation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.15] Initial Drafts.
\item[Issue 1.16 (16th June 1994)] First draft for review.
\item[Issue 1.27 (31 October 1994)] Added $z\_true$ and $z\_exists$ as per version 1.1 of Volume 3 of DRA's specification.
\item[Issue 1.30 (9th November 1994)]
Adjusted $ENV\_INFO$ and allowed for type conversions.
\item[Issue 1.32] Updated document references.
\item[Issue 1.33] Accomodated changes to toolkit extensions agreed at the 4th critical review (see \cite{ISS/HAT/DAZ/min005}: $mod$ becomes $intmod$, $Abs$ becomes $abs$).
\item[Issue 1.34] Fixed bug 6 (batch 2).
\item[Issue 1.35] Accomodated changes to data types required for enhancements.
\item[Issue 1.36] Enhancement 11 (and bug 9 (batch 2)).
\item[Issue 1.37] Enhancements 13 and 14.
\item[Issue 1.38] Enhancement 15.
\item[Issue 1.39-1.41] Enhancements to basic declarations.
\item[Issue 1.42] Enhancement 12 (type conversions) and rejig of enhancement 11.
\item[Issues 1.43-1.45] Enhancements 3 and 18.
\item[Issue 1.46 (14th December 1995)] Changes according to desk check report 024.
\item[Issue 1.47 ] Fixes to bugs 8 and 10 (V0.6) and error reporting.
\item[Issue 1.48 ] Fixes to bug 1 (V0.7).
\item[Issue 1.49] IUCT WP 7 changes.
\item[Issue 1.50] IUCT WP 4 changes.
\item[Issue 1.51,1.52] Fixing bugs in IUCT WP 4 changes.
\item[Issue 1.53] Improved an error message.
\item[Issue 1.54] Updated references.
\item[Issue 1.54] Updates for SML97.
\item[Issue 1.55] Updates for new INTEGER type.
\item[Issue 1.56] Enhancement R3 --- Assignments to record components.
\item[Issue 1.57] Enhancement R2 --- multiple logical constant definitions.
\item[Issues 1.58-1.61] Enhancement R1 --- multi-dimensional arrays.
\item[Issues 1.62] Enhancement CTLE II R1/2 --- ``Others'' in case statements.
\item[Issues 1.63] Enhancement CTLE II R1/4 --- logical operators on arrays of booleans, including all the basics of overload resolution.
\item[Issues 1.64, 1.65] Enhancement CTLE II R1/8 --- characters and strings
\item[Issues 1.66] Enhancement CTLE II R1/5 --- range attributes as ranges
\item[Issues 1.67] Enhancement CTLE II R1/9 --- SPARK 83 attributes
\item[Issues 1.68] Enhancement CTLE II R1/11 --- nested packages
\item[Issues 1.69,1.70] Enhancement CTLE II R1/1 --- real types
\item[Issues 1.71,1.72] Fixed logic errors in {\it exp\_attrib} and errors in CTLE II R1/5 and R1/6.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Algorithms}
The algorithms to generate the basic declarations and expressions are specified in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

%\subsection{Dependencies}
%\subsection{Known Deficencies}
%\subsection{Possible Enhancements}
=TEX

\section{PREAMBLE}

=SML
infix 3 ^^;
=TEX
=SML
structure ÛCNBasicDeclsAndExprsÝ : CNBasicDeclsAndExprs = struct
	open CNParser CNTypes ZGeneratedConstants ZParagraphs;
	open ZUserInterfaceSupport ZTypesAndTermsSupport;
=TEX
\section{CUSTOMIZED ENVIRONMENT HANDLING}

=SML
datatype ÛENV_INFOÝ =
			ÛEIEnvFunctionÝ of Z_ID list * ID list * TMARK
		|	ÛEIEnvVarÝ of TMARK
		|	ÛEIEnvAuxVarÝ of Z_DECL
		|	ÛEIEnvRecordTypeÝ of ID list
		|	ÛEIEnvOtherTypeÝ
		|	ÛEIEnvConstantÝ of TMARK
		|	ÛEIEnvRetryÝ of Z_ID
		|	ÛEIEnvOtherÝ;
=TEX
=SML
type ÛCN_ENVÝ = Z_ID -> (TYPE * ENV_INFO) OPT;
=TEX

\section{SUPPORTING FUNCTIONS}
\subsection{Miscellaneous}
As discussed with DRA during the (first) enhancements programme, the treatment
of constructs which cannot be handled formally changed between releases 0.5 and 0.6.
Now that the user can bypass the formal processing of such a construct (as an arbitrary ada insertion), there is no need to attempt to continue processing when such a construct appears here, except in cases where failure to translate a construct is used to redirect the flow of control.
In order to encourage better messages, the exception $Informal$ and associated functions have been removed and the usual {\Product} error mechanisms are used instead.
=TEX
=SML
fun zid1 Û^^Ý zid2 = (
	zid1^"v"^zid2
);
=TEX
=SML
fun Ûdest_rangeÝ ((RRange range) : EXP RANGE) : EXP RANGELOHI = (
	range
) | dest_range (RRangeAttr (EAttribute {prefix,
		attribute_desig = ADAttrib "RANGE"})) = (
	{lo = EAttribute {prefix = prefix, attribute_desig = ADAttrib "FIRST"},
	 hi = EAttribute {prefix = prefix, attribute_desig = ADAttrib "LAST"} }
) | dest_range (RRangeAttr (EAttribute {prefix,
		attribute_desig = ADAttribArg("RANGE", e)})) = (
	{lo = EAttribute {prefix = prefix, attribute_desig = ADAttribArg("FIRST", e)},
	 hi = EAttribute {prefix = prefix, attribute_desig = ADAttribArg("LAST", e)} }
) | dest_range _  = fail "dest_range" 508020 [];
=TEX
=TEX

The following were not asked for in the specification
but are convenient to have available at various points in the code.
=SML
val Ûz_int_typeÝ = type_ofñ0®;
val Ûz_int_set_typeÝ = type_of ñú®;
val Ûz_int_int_rel_typeÝ = type_of ñú ¸ ú®;
val Ûú_tmÝ = ñú®;
=TEX
=SML
val Ûz_real_typeÝ = type_ofñ0 e 0®;
val Ûz_real_set_typeÝ = type_ofñ{0 e 0}®;
val Û%calR%_tmÝ = ñ%calR%®;
=TEX
\section{Evaluation of Constant Expressions}
Constant expressions need to be evaluated in the translation of array attributes with
arguments and in deciding whether a VC needs to be generated 
For various reasons, it has been agreed that attributes that are functions will not be statically evaluated.

=TEX
First of all we define a conversion which will expand the definition of a constant integer or set of integers providing the definition is a simple equation and providing the constant does not appear in the list provided as an extra argument (this is used to avoid looping in the presence of somewhat mailiciously conceived definitions).

=SML
fun Ûcn_const_convÝ (consts : TERM list) : CONV = (fn tm =>
	(if	tm term_mem consts
	then	fail_conv
	else	COND_C
		(fn tm => is_const tm andalso
			let val ty = type_of tm; in ty =: z_int_type orelse ty =: z_int_set_type end)
		(fn tm => simple_eq_match_conv (z_get_spec tm) tm)
		fail_conv
	) tm
);
=TEX
Now conversions to handle a few other cases which are not directly handled by available tools.
The conversion for \verb"#" is required for array length attributes.
=SML
val Ûz_minus_minus_thmÝ = pc_rule1 "z_library" prove_rule[] ¬µi ·ñ~ ~i = i®®;

val Ûz_minus_minus_convÝ = simple_eq_match_conv z_minus_minus_thm;

val Ûz_hash_thmÝ = asm_rule ¬µi j·ñ#(i .. j) = (j - i) + 1®®;

val Ûz_hash_convÝ : CONV = simple_eq_match_conv z_hash_thm;
=TEX
Now a conversional for propagating a conversion into the operands of a unary or binary Z function.
=SML
fun ÛMY_Z_RANDS_CÝ (c : CONV) : CONV = (fn tm =>
	(	((dest_z_tuple o snd o dest_z_app) tm;
			RAND_C (RAND_C c AND_OR_C RATOR_C(RAND_C c)))
				handle Fail _ => RAND_C c	) tm
	
);
=TEX
We put these pieces together to give the following conversion which does the required static evaluation of integer expressions.
The parameter to the conversion is used to record which constants have had their definitions unwound somewhere in the branch of the expression tree currently being attacked and is used to avoid infinite recursion (e.g., if someone has used HOL to produce something which looks like a Z global variable with a definition like $X = X$ or $X = X + 0$).
=SML
fun Ûcn_eval_convÝ (consts : TERM list) : CONV = (fn tm => (
		MY_Z_RANDS_C (cn_eval_conv consts)
		AND_OR_C
		(fn t => (cn_const_conv consts
			THEN_TRY_C cn_eval_conv (consts term_grab t)) t)
		AND_OR_C (FIRST_C [
				z_hash_conv,
				z_subtract_minus_conv,
				z_minus_minus_conv]
			THEN_TRY_C cn_eval_conv consts)
		AND_OR_C FIRST_C [
			z_plus_conv,
			z_times_conv,
			cn_intmod_conv	,
			cn_intdiv_conv	,
			cn_rem_conv,
			cn_star_star_conv,
			z_abs_conv
		])	tm
);
=TEX
The handling of ranges uses the above function directly.
The following is the interface used in handling attributes.
=SML
fun Ûeval_attr_argÝ (ze : Z_EXP) : int = (
	let	val n = (dest_z_signed_int o snd o dest_eq o
				snd o dest_thm o TRY_C(cn_eval_conv[])) ze; 
	in	if 	n @> integer_of_int 0
		then	int_of_integer n
		else	term_fail "eval_attr_arg" 508030 [ze]
	end	handle	Fail _ => term_fail "eval_attr_arg" 508029 [ze]
);
=TEX
\section{SUPPORT FOR Z ABSTRACT SYNTAX}
\subsection{Z Unary Expressions}
=SML
val		Ûz_unary_minusÝ =		ñ(~ _)®;
val		Ûz_bool_notÝ =		ñ(not _)®;
val		Ûz_absÝ =		ñ(abs _)®;
val		Ûz_char_litÝ =		ñ(char_lit _)®;
val		Ûz_string_litÝ =		ñ(string_lit _)®;
val		Ûz_real_unary_minusÝ =	ñ(~R _)®;
val		Ûz_real_absÝ =		ñ(absR _)®;
=TEX
\subsection{Z Binary Expressions}
=SML
val 		Ûz_bool_andÝ =		ñ(_ and _)®;
val		Ûz_bool_orÝ =		ñ(_ or _)®;
val		Ûz_bool_xorÝ =		ñ(_ xor _)®;
val		Ûz_bool_eqÝ =		ñ(_ eq _)®;
val		Ûz_bool_noteqÝ =		ñ(_ noteq _)®;
val		Ûz_bool_lessÝ =		ñ(_ less _)®;
val		Ûz_bool_less_eqÝ =	ñ(_ less_eq _)®;
val		Ûz_bool_greaterÝ =	ñ(_ greater _)®;
val		Ûz_bool_greater_eqÝ =	ñ(_ greater_eq _)®;
val		Ûz_addÝ =		ñ(_ + _)®;
val		Ûz_minusÝ =		ñ(_ - _)®;
val		Ûz_timesÝ =		ñ(_ * _)®;
val		Ûz_intdivÝ =		ñ(_ intdiv _)®;
val		Ûz_modÝ =		ñ(_ intmod _)®;
val		Ûz_remÝ =		ñ(_ rem _)®;
val		Ûz_exponÝ =		ñ(_ ** _)®;
val		Ûz_bool_memÝ =		ñ(_ mem _)®;
val		Ûz_bool_notmemÝ =		ñ(_ notmem _)®;
val		Ûz_array_notÝ =		ñ(array_not _)®;
val		Ûz_array_andÝ =		ñ(_ array_and _)®;
val		Ûz_array_orÝ =		ñ(_ array_or _)®;
val		Ûz_array_xorÝ =		ñ(_ array_xor _)®;
val		Ûz_array_greaterÝ =	ñ(_ array_greater _)®;
val		Ûz_array_greater_eqÝ =	ñ(_ array_greater_eq _)®;
val		Ûz_array_lessÝ =		ñ(_ array_less _)®;
val		Ûz_array_less_eqÝ =	ñ(_ array_less_eq _)®;
val		Ûz_array_array_catÝ =	ñ(_ &0 _)®;
val		Ûz_array_elem_catÝ =	ñ(_ &1 _)®;
val		Ûz_elem_array_catÝ =	ñ(_ &2 _)®;
val		Ûz_real_addÝ =		ñ(_ +R _)®;
val		Ûz_real_minusÝ =		ñ(_ -R _)®;
val		Ûz_real_timesÝ =		ñ(_ *R _)®;
val		Ûz_real_divÝ =		ñ(_ /R _)®;
val		Ûz_real_exponÝ =		ñ(_ ^R _)®;
val		Ûz_bool_real_lessÝ =	ñ(_ real_less _)®;
val		Ûz_bool_real_less_eqÝ =	ñ(_ real_less_eq _)®;
val		Ûz_bool_real_greaterÝ =	ñ(_ real_greater _)®;
val		Ûz_bool_real_greater_eqÝ =	ñ(_ real_greater_eq _)®;
=TEX

\subsection{Z Expressions}
The following function allows many of the Z constructor functions to be presented in a way which is visually appealing.
The {\it ts} argument represents a substitution, e.g., 
=INLINEFT
[(ñ1®, "a"), (ñ6®, "b")]
=TEX
; the second argument represents a template term containing an instance
of the Z term we want to construct using the variables from the substitution
as operands, e.g.,
=INLINEFT
ña .. b®
=TEX
; the result is the desired term, e.g.,
=INLINEFT
ñ1 .. 6®
=TEX
.
The types of the template operator are instantiated as necessary
to match the type of the required actual operands.

=SML
fun Ûcn_substÝ (ts : (TERM * string) list) (tm : TERM) : TERM = (
let	val freevars = frees tm;
	val fvs = map dest_var freevars;
	val newtys = map (fn (tm,c) => (c, type_of tm)) ts;
	val tymap = map (fn (n, ty) => (ty,lassoc3 fvs n)) newtys;
	val tymap' = (fn (t1,t2) => type_match
		(mk_ctype ("TYPE",t1)) (mk_ctype("TYPE",t2))) (split tymap);
	val tm_inst = inst [] tymap' tm;
	val namemap = map (fn (tm, s) => (tm, mk_var(s, lassoc3 newtys s))) ts;
in
	subst namemap tm_inst
end);
=TEX


=SML
val ÛzsuccÝ : Z_EXP = ñsucc®;
=TEX
In {\it zid}, the auxiliary function {\it aux} implements the retry technique
that supports access to variables in enclosing package or subprogram bodies.
Only one level of retry is supported (since the SPARK rules don't allow nesting
of package names in this context).
=SML
fun ÛzidÝ (env : CN_ENV) (id : Z_ID) : Z_EXP = (
	let	fun aux retry id1 = (
			find (TypeInference.get_ti_context ()) (fn t => fst(dest_var t) = id)
			handle Fail _ => 
			case env id1 of
				Value (ty, EIEnvRetry id2) => 
					if retry
					then aux false id2
					else fail "zid" 508021 [fn()=>id]
			|	Value (ty, EIEnvVar _) => mk_z_lvar(id1, ty, [])
			|	Value (ty, EIEnvAuxVar _) => mk_z_lvar(id1, ty, [])
			|	Value (ty, _) => mk_z_gvar(id, ty, [])
			|	Nil => fail "zid" 508021 [fn()=>id]
		);
	in	aux true id
	end
);
=TEX
=SML
val Ûz_numÝ : INTEGER -> Z_EXP = mk_z_signed_int;
=TEX
The following could be improved when more support for Z reals is
available.
=SML
val Ûz_real_termÝ : TERM = ña e b®;
fun Ûz_realÝ (i : INTEGER, e : INTEGER) : Z_EXP = (
	cn_subst
	[(mk_z_signed_int i, "a"), (mk_z_signed_int e, "b")]
	z_real_term
);
=TEX
=SML
val Ûz_real_to_integer_termÝ : TERM = ñreal_to_integer a®;
fun Ûz_real_to_integerÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_real_to_integer_term
);
=TEX
=SML
val Ûz_integer_to_real_termÝ : TERM = ñinteger_to_real a®;
fun Ûz_integer_to_realÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_integer_to_real_term
);
=TEX
=SML
val Ûz_stringÝ : string -> Z_EXP = mk_z_string;
=TEX
=SML
val Ûz_tfun_termÝ : TERM = ña ­ b®;
fun Ûz_tfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_tfun_term
);
=TEX
=SML
val Ûz_pfun_termÝ : TERM = ña ß b®;
fun Ûz_pfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_pfun_term
);
=TEX
=SML
val Ûz_rng_term1Ý : TERM = ña .. b®;
val Ûz_rng_term2Ý : TERM = ña ..R b®;
fun Ûz_rngÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term1
	handle Fail _ =>
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term2
);
=TEX
=SML
val Ûz_dom_termÝ : TERM = ñdom a®;
fun Ûz_domÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_dom_term
);
=TEX
=SML
val Ûz_dom_res_termÝ : TERM = ña ò b®;
fun Ûz_dom_resÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_dom_res_term
);
=TEX
=SML
val Ûz_inv_termÝ : TERM = ña ç~ê®;
fun Ûz_invÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_inv_term
);
=TEX
=SML
val Ûz_id_rel_termÝ : TERM = ñid a®;
fun Ûz_id_relÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_id_rel_term
);
=TEX
=SML
val Ûz_size_termÝ : TERM = ñ# a®;
fun Ûz_sizeÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_size_term
);
=TEX
=SML
val Ûz_empty_set_termÝ : TERM = ñ{}®;
fun Ûz_setÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_setd(type_of e, exps)
) | z_set _ = z_empty_set_term;
=TEX
=SML
val Ûz_set_minus_termÝ : TERM = ña \ b®;
fun Ûz_set_minusÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_set_minus_term
);
=TEX
=SML
fun Ûz_set_compÝ (zdecl : Z_DECL, p : Z_EXP) : Z_EXP = (
let	val dec = (fst o dest_z_dec) zdecl
			handle _ =>
			  error "z_set_comp" 508023 [fn()=>string_of_term zdecl];
	val zdexp = case dec of
		[dec] => dec
		|_ => mk_z_tuple dec;
	val tm = mk_z_seta (mk_z_decl [zdecl], p, zdexp);
	val side = seta_gen_semantic_const tm;
in
	tm
end
);
=TEX
=SML
val Ûz_power_termÝ : TERM = ña ç b ê®;
fun Ûz_powerÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_power_term
);
=TEX
=SML
val Ûz_rel_comp_termÝ : TERM = ña » b®;
fun Ûz_rel_compÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_rel_comp_term
);
=TEX
=SML
val Ûz_empty_seq_termÝ : TERM = ñ§¢®;
fun Ûz_seqÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_§¢(type_of e, exps)
) | z_seq _ = z_empty_seq_term;
=TEX
=SML
val Ûz_cross_termÝ : TERM = ña ¸ b®;
fun Ûz_crossÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_cross_term
);
=TEX
=SML
fun Ûz_many_crossÝ (tms : Z_EXP list) : Z_EXP = (
	case	tms of
		[tm] => tm
	|	_ => (
		let	val prod = mk_z_¸ tms;
		in	¸_gen_semantic_const prod;
			prod
		end
	)
);
=TEX
=SML
val Ûz_override_termÝ : TERM = ña « b®;
fun Ûz_overrideÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_override_term
);
=TEX
=SML
val Ûz_union_termÝ : TERM = ña À b®;
fun Ûz_many_unionÝ (exps : Z_EXP list) : Z_EXP = (
let	fun non_empty (e::rest) = (
		if (((length o snd o dest_z_setd) e) = 0 handle _ => false)
		then
			non_empty rest
		else
			e::non_empty rest
	) | non_empty _ = [];
	fun aux (exps as e1::e2::rest) = (
		cn_subst [(e1, "a"), (aux (e2::rest), "b")] z_union_term
	) | aux [e] = e
	  | aux _ = error "z_many_union" 508024 [];
in
	(aux o non_empty) exps
end
);
=TEX
=SML
fun Ûz_bindingÝ (cmpvals : (string * Z_EXP) list) : Z_EXP = (
	let	val bdg = mk_z_binding cmpvals;
	in	binding_gen_semantic_const bdg;
		bdg
	end
);
=TEX
=SML
fun Ûz_tupleÝ ([exp] : Z_EXP list) : Z_EXP = (
	exp
) | z_tuple (exps : Z_EXP list) : Z_EXP = (
	let	val tuple = mk_z_tuple exps;
	in	tuple_gen_semantic_const tuple;
		tuple
	end
);
=TEX
The following function constructions a Z application given a function
and its argument (which will be a pair if we are constructing an application
of a binary operator).
If necesary, the type of the function is instantiated to match that of the argument.
=SML
fun mk_and_chk_z_app (fx as (f: Z_EXP, x : Z_EXP)) : Z_EXP = (
	mk_z_app fx handle Fail _ => (
		let	val ty = hd(dest_z_tuple_type
					(dest_z_power_type (type_of f)));
			val tysubs = type_match (type_of x) ty;
			val f' = inst [] tysubs f;
		in	mk_z_app (f', x)
		end
	) handle Fail _ => term_fail "trans_exp" 508071 [f, x]
);
=TEX
=SML
val Ûz_unary_expÝ : (Z_EXP * Z_EXP) -> Z_EXP = mk_and_chk_z_app;
=TEX
=SML
fun Ûz_bin_expÝ (left : Z_EXP, bop : Z_EXP, right : Z_EXP) : Z_EXP = (
	mk_and_chk_z_app (bop, mk_z_tuple[left, right])
);
=TEX
=SML
fun Ûz_fun_callÝ (exp :Z_EXP, exps : Z_EXP list) : Z_EXP = (
	case exps of
	[] =>	exp
	|[e] =>		mk_and_chk_z_app (exp, e)
	|_ => (
		let	val tup = mk_z_tuple exps;
			val side = tuple_gen_semantic_const tup;
		in
			mk_and_chk_z_app (exp, tup)
		end
	)
);
=TEX
=SML
val Ûz_selectionÝ : (Z_EXP * Z_ID) -> Z_EXP = mk_z_sels;
=TEX
=SML
val Ûz_maplet_termÝ : TERM = ña í b®;
fun Ûz_mapletÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_maplet_term
);
=TEX
=SML
val Ûz_powersetÝ : Z_EXP -> Z_EXP = mk_z_ð;
=TEX
=SML
fun Ûother_z_expÝ (exp : Z_EXP) : Z_EXP = exp;
=TEX

\subsection{Z Predicates}
=SML
val Ûz_trueÝ : Z_PRED = mk_z_true;
=TEX
=SML
val Ûz_eqÝ : (Z_EXP * Z_EXP) -> Z_PRED = mk_z_eq;
=TEX
=SML
val Ûz_andÝ : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_±;
=TEX
=SML
fun Ûz_many_andÝ ((exps as e1::e2::rest) : Z_PRED list) : Z_PRED = (
	mk_z_± (e1, z_many_and (e2::rest))
) | z_many_and [e] = e
  | z_many_and _ = error "z_many_and" 508024 [];
=TEX
=SML
val Ûz_elemÝ : (Z_EXP * Z_EXP) -> Z_EXP = mk_z_;
=TEX
=SML
val Ûz_notelem_termÝ : TERM = ña  b®;
fun Ûz_notelemÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_notelem_term
);
=SML
val Ûz_noteq_termÝ : TERM = ña ½ b®;
fun Ûz_noteqÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_noteq_term
);
=TEX

=SML
val Ûz_less_eq_termÝ : TERM = ña ¼ b®;
fun Ûz_less_eqÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_less_eq_term
);
=TEX

=SML
val Ûz_greater_termÝ : TERM = ña > b®;
fun Ûz_greaterÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_greater_term
);
=TEX

=SML
fun Ûz_forallÝ (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_µ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
fun Ûz_existsÝ (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_¶ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
val Ûz_impÝ : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_´;
=TEX

=SML
val Ûz_memÝ : (Z_EXP * Z_EXP) -> Z_PRED = mk_z_;
=TEX

=SML
fun Ûother_z_predÝ (z_pred : Z_PRED) : Z_PRED = z_pred;
=TEX

\subsection{Z Paragraphs}
=SML
fun Ûz_axÝ (id : Z_ID, exp : Z_EXP, preds : Z_PRED list) : PARAINFO = (
	let	val ty = dest_z_power_type (type_of exp);
		val decl = mk_z_decl[mk_z_dec([mk_var(id, ty)], exp)];
		val pred = case preds of
				[] => Nil
			|	_ => Value (list_mk_± preds);
	in	AxDesInfo([], decl, pred, [(id, ty)])
	end
);
=TEX
=SML
fun Ûz_eq_eqÝ (id : Z_ID, exp : Z_EXP) : PARAINFO = (
	AbbDefInfo (id, [], exp)
);
=TEX
=SML
fun Ûz_givenÝ (id : Z_ID) : PARAINFO = (
	GivenSetInfo ([id], Nil)
);
=TEX
=SML

fun Ûz_schemaÝ (name : Z_ID, decls : Z_DECL list) : PARAINFO = (
let	val z_sch = mk_z_h_schema(mk_z_decl decls, z_true);
	val side = schema_gen_semantic_const z_sch;
in
	AbbDefInfo (name, [], z_sch)
end
);
=TEX
\section{SUPPORT FOR TRANSLATION OF EXPRESSIONS}
It is convenient to take some of the work for translation of
expressions first rather than interleaved the main  mutual recursion
for {\it trans\_exp}. This section contains this material.

\subsection{{\it tmark\_of\_prefix}}
{\it tmark\_of\_prefix} requires some auxiliary functions. The first batch
of these pick apart the defining axiom for a Z term
that is the translation of a SPARK type mark and return
the term that is the translation of a the type mark
for a component selected from the original SPARK type.
=SML
fun Ûdo_array_defÝ (tm : Z_EXP) : Z_EXP = (
	let	val t1 = snd(dest_eq tm);
		val (_, _, ts) = dest_z_gvar t1;
	in	hd(tl ts)
	end
);
=TEX
=SML
fun Ûdo_uncon_array_defÝ (tm : Z_EXP) : Z_EXP = (
	let	val t1 = dest_z_ð(snd(dest_z_(fst(dest_± tm))));
		val (_, _, ts) = dest_z_gvar t1;
	in	hd(tl ts)
	end
);
=TEX
=SML
fun Ûdo_subtype_con_defÝ (tm : Z_EXP) : Z_EXP = (
	let	val t1 = snd(dest_eq tm);
		val (decl, _, _) = dest_z_seta t1;

	in	(snd o dest_z_dec o hd o dest_z_decl) decl
	end
);
=TEX
=SML
fun Ûdo_subtype_uncon_defÝ (tm : Z_EXP) : Z_EXP = (
	snd(dest_eq tm)
);
=TEX
=SML
fun Ûdo_rec_defÝ (tm : Z_EXP) (sel : string) : Z_EXP = (
	let	val t1 = snd(dest_eq tm);
		val decs = (dest_z_decl o fst o dest_z_h_schema) t1;
		fun do_decs decs = (
			let	val (ts, t) = dest_z_dec (hd decs);
			in	if	any ts (fn t => fst(dest_var t) = sel)
				then	t
				else	do_decs (tl decs)
			end
		)
	in	do_decs decs
	end
);
=TEX
The data type {\it SEL} represents a single component selection.
For arrays, the index value is not relevant to the type calculation
for a record selection, we need to know the component name:
=SML
datatype ÛSELÝ = ArraySel | RecordSel of ID;
=TEX
The next auxiliary function takes a list of selectors and applies
them to a Z expression representing a base type to give the
Z expression for the selected type (as the translation of a type
mark --- if we don't get a global variable, then the SPARK program
is ill-formed in some way.)
=SML
fun Ûindexed_typeÝ (base : Z_EXP) (sels : SEL list) : Z_EXP = (
	case sels of
	[] 	=>	(base
	) | ArraySel :: more
		=> (
		let	val def = snd (dest_thm (z_get_spec base));
			fun go tm = (
				(do_array_def tm) handle Fail _ =>
				(do_uncon_array_def tm) handle Fail _ =>
				(go 	((do_subtype_con_def tm) handle Fail _ =>
					 (do_subtype_uncon_def tm)))
			);
		in	indexed_type (go def) more
		end
	) | RecordSel s :: more
		=> (
		let	val def = snd (dest_thm (z_get_spec base));
			fun go tm = (
				(do_rec_def tm s) handle Fail _ =>
				(go (do_subtype_uncon_def tm))
			);
		in	indexed_type (go def) more
		end
	)
);
=TEX
Using {\it indexed\_type} we can now define {\it tmark\_of\_prefix}
as required by the formal specification.
=SML
fun Ûtmark_of_prefixÝ (env : CN_ENV) (zpfx : Z_EXP) : Z_ID = (
	let	fun strip_prefix sels tm = (
			case dest_z_term tm of
				ZApp(t, _) => strip_prefix (ArraySel :: sels) t
			|	ZSels(t, s) => strip_prefix (RecordSel s :: sels) t
			|	ZLVar(s, _, _) => (s, sels)
			|	ZGVar(s, _, _) => (s, sels)
			|	_ => term_fail "tmark_of_prefix" 508028 [zpfx]
		);
		val (var, sels) = strip_prefix [] zpfx;
		val (base_tmark, sels') = case env var of
			Value(_, EIEnvVar x) => (x, sels)
		|	Value(_, EIEnvConstant x) => (x, sels)
		|	Value(_, EIEnvFunction (_, _, x)) => (
				(x, tl sels)
				handle Fail _ => fail "tmark_of_prefix" 508028 []
		) |	_ => fail "tmark_of_prefix" 508028 [];
	in	case dest_z_term(indexed_type (mk_z_gvar(base_tmark, BOOL, [])) sels') of
			ZGVar(tmark, _, _) => tmark
		|	_ => fail "tmark_of_prefix" 508028 []
	end
);
=TEX
\subsection{Calculating Base Types}
=SML
local
val Ûz_uÝ = ñU®;
fun Ûbase_defÝ (n : Z_EXP) : Z_EXP = (
	let	val rhs = snd(dest_z_eq(snd(dest_thm(z_get_spec n))));
	in	(term_match rhs z_u; n)
		handle Fail _ =>
	let	fun aux r = (
			let	val (decl, _, _) = dest_z_seta r;
			in	(snd o dest_z_dec o hd o dest_z_decl) decl
			end	handle Fail _ => r
		);
		val supertype = aux rhs;
	in	if	is_z_gvar supertype
		then	base_def supertype
		else	n
	end
	end	handle Fail _ => n
);
in
fun Ûbase_typeÝ (t : Z_EXP) : TMARK OPT = (
	let	val n = base_def t;
		val ty = dest_z_power_type (type_of n);
		val (v, _, _)  = dest_z_gvar n;
	in	if	is_z_power_type ty orelse is_z_schema_type ty
		then	Value v
		else	let	val vsucc = mk_z_gvar(v ^ "vSUCC", BOOL, []);
			in	if	is_eq(snd(dest_thm(z_get_spec vsucc)))
				then	Value v
				else	Nil
			end
	end	handle Fail _ => Nil

);
end;
=TEX
\subsection{Integer Literals}\label{IntegerLiterals}

The translation of integer literals is non-trivial and several supporting functions for the translation of integer literals are introduced in this section. The function $trans\_int$ is introduced at the end of this section.
=SML
local
=TEX
\subsubsection{Support for $trans\_int$}

=SML
open	CaseIndependence;
open	Lex;
type ÛNUMBERSÝ = string list;
type ÛNUMERICÝ =
		{base : NUMBERS, m : NUMBERS, expon : NUMBERS};
=TEX

\subsubsection{Phase 1: Recognising Integer Literals}

Integer literals may not contain a point and must have a minus sign in the exponent.

Failures in the supporting functions below are all caught and handled in
{\it trans\_int} (which can include the literal being translated in its error message).

In the exponent part when there is a sign, it is just copied into the number. The parser has already ensured that $+$ and $-$ can only appear at the start of an exponent, so a further check is not required here.
=SML
fun Ûrecog_exponent_partÝ (dec as {base,m,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_exponent_part ({base=base,m=m, expon=expon@[c]}, rest)
	else case c of

		"_" =>	recog_exponent_part (dec, rest)
		|"+" => recog_exponent_part ({base=base,m=m, expon=expon@[c]}, rest)
		|_ =>	fail "trans_int" 508025 []

) | recog_exponent_part (other, []) = (
	(other, [])
);
=TEX
=SML
fun Ûrecog_basedÝ (nb as {base,m,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based ({base=base,m=m@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_based (nb, rest)
		|"#" => recog_numeric true (nb, rest)
		|_ =>	fail "trans_int" 508025 []

) | recog_based (other, []) = (
	fail "recog_based" 0 []
)
=SML
and Ûrecog_numericÝ (have_base : bool) (num as {base,m,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_numeric have_base ({base=base,m=m@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_numeric have_base (num, rest)
		|"e" => recog_exponent_part (num, rest)
		|"E" => recog_exponent_part (num, rest)
		|_ =>	if not have_base andalso c = "#"
			then	recog_based ({base=m, m=[], expon=expon}, rest)
			else	fail "trans_int" 508025 []
) | recog_numeric _ other = other;
=TEX
\subsubsection{Phase 2: Generating Integer Literals}

The following gives a lookup table for extended digits to values upto 16.

i.e., $[("0", 0), ("1", 1),...("F", 15)]$.
=SML
val Ûextended_digitsÝ : (string * INTEGER) list = (
	combine
		(map string_of_int (interval 0 9)@["A","B","C","D","E","F"])
		(map integer_of_int (interval 0 15))
);
=TEX
=SML
val ten = @@"10";
fun Ûbased_to_integerÝ (base:int) (sl:string list) : INTEGER = (
	if base = 10
	then	(natural_of_string o implode) sl handle _ => zero
	else	let	val valid = extended_digits to (base-1);
			val sl' = map CaseIndependence.to_upper sl;
			val f = lassoc3 valid;
			val ibase = integer_of_int base;
			fun aux (c::rest) = (
				f c @+ ibase @* aux rest
			) | aux _ = zero;
		in
			(aux o rev) sl' handle _ =>
				fail "trans_int" 508025 []
		end
);
=TEX
=SML
fun Ûsigned_nat_of_numbersÝ (sl : NUMBERS) : int = (
	let	val f = nat_of_string o implode;
	in
		case sl of
		("+"::n) => f n
		|("-"::n) => ~(f n)
		|_ => f sl
	end
);
=TEX
=SML
fun ÛbasepowÝ (base : int) (n : int) : INTEGER = (
	let	val ibase = integer_of_int base;
		fun aux n = (
			if	n = 0
			then	one
			else	ibase @* aux (n-1)
		);
	in	aux n
	end
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûconvert_base_expÝ ((base, m, expon) : (int*INTEGER*int)) : INTEGER = (
	if expon >= 0
	then	m @* basepow base expon
	else	fail "trans_int" 508025 []
);
=TEX
=SML
=TEX
=SML
fun Ûnumeric_to_int_litÝ ({base,m,expon} : NUMERIC) : INTEGER = (
let	val nbase = (nat_of_string o implode) base handle _ => 10;
	val nm = based_to_integer nbase m;
	val nexpon = signed_nat_of_numbers expon handle _ => 0;
in
	if	nbase = 10 andalso nexpon = 0
	then	nm
	else	convert_base_exp (nbase,nm,nexpon)
end);
=TEX
\subsubsection{The Function $trans\_int$}
=SML
in (* of local ... in *)
=TEX
=SML
fun Ûtrans_intÝ (i : INT_REAL_LIT) : INTEGER = (
	( (numeric_to_int_lit o fst o recog_numeric false)
		({base=[], m=[], expon=[]}, explode i)
	) handle Fail _ => fail "trans_int" 508025 [fn()=>i]
);
=TEX
=SML
end (* of local ... in *);
=TEX
=TEX
\subsubsection{The Function $exp\_int\_lit$}
=SML
fun Ûexp_int_litÝ (n : INT_REAL_LIT) : Z_EXP = (
	z_num (trans_int n)
);
=TEX
=TEX
\subsection{Real Literals}{\label{RealLiterals}
\subsubsection{The Function $trans\_real$}
=SML
local
	open Lex;
in
fun trans_real (r : INT_REAL_LIT) : INTEGER * INTEGER = (
	let	fun adjust ([] : string list, exp : int) = (
			(["0"], 0)
		) | adjust ("0"::more, exp) = (
			adjust(more, exp + 1)
		) | adjust (other, exp) = (
			(other, exp)
		);
		fun exponent (acc, exp) [] = (
			fail "trans_real" 508025 [fn _ => r]
		) | exponent (acc, exp) chs = (
			let	val (acc', exp') = adjust (acc, exp);
				val i = integer_of_string (implode(rev acc'));
				val e = integer_of_string (implode chs);
			in	(i, e @+ integer_of_int exp')
			end	handle Fail _ => fail "trans_real" 508025 [fn _ => r]
		);
		fun  after_point (acc, exp) (ch :: chs) = (
			if	is_digit ch
			then	after_point (ch::acc, exp - 1) chs
			else if	ch = "E" orelse ch = "e"
			then	exponent (acc, exp) chs
			else	fail "trans_real" 508025 [fn _ => r]
		) | after_point (acc, exp) [] = (
			let	val (acc', exp') = adjust (acc, exp);
				val i = integer_of_string (implode(rev acc'));
			in	(i, integer_of_int exp')
			end	handle Fail _ => fail "trans_real" 508025 [fn _ => r]
			
		);
		fun before_point acc ("." :: chs) = (
			after_point (acc, 0) chs
		) | before_point acc (ch :: chs) = (
			if	is_digit ch
			then	before_point (ch::acc) chs
			else	fail "trans_real" 508025 [fn _ => r]
		) | before_point acc [] = (
			after_point (acc, 0) []
		);
	in	before_point [] (explode r)
	end
);
end;
=TEX
\subsubsection{The Function $exp\_real\_lit$}
=SML
fun Ûexp_real_litÝ (n : INT_REAL_LIT) : Z_EXP = (
	z_real (trans_real n)
);
=TEX
\subsection{Character Literals}{\label{CharacterLiterals}
\subsubsection{The Function $exp\_char\_lit$}
=SML
fun Ûexp_char_litÝ (n : CHAR_LIT) : Z_EXP = (
	z_unary_exp(z_char_lit, z_string n)
);
=TEX
\subsection{String Literals}{\label{StringLiterals}
\subsubsection{The Function $exp\_string\_lit$}
=SML
fun Ûexp_string_litÝ (n : STRING_LIT) : Z_EXP = (
	z_unary_exp(z_string_lit, z_string n)
);
=TEX
\subsection{Unary Operators}
The empty list for unary addition means that no operator is required.
=SML
fun Ûunary_opsÝ (uop : UNARY_OP) : Z_EXP list = (
	case uop of
	UOSparkUnaryMinus => [z_unary_minus, z_real_unary_minus]
	|UOSparkNot => [z_bool_not, z_array_not]
	|UOSparkAbs => [z_abs, z_real_abs]
	|USSparkUnaryAdd => []
);
=TEX
The following implements overload resolution for unary operators.
Note that we let {\it z\_unary\_exp} report the error if
none of the alternatives is well-typed (the case of an empty operand
to {\it try\_it} is for the special case of unary addition).

Also note that the expression returned is the actual translation of
the whole unary operator application, not just the operator.

=SML
fun Ûtrans_unary_opÝ (uop : UNARY_OP, zright : Z_EXP) : Z_EXP = (
	let	val ops = unary_ops uop;
		fun try_it [] = zright
		|   try_it [rator] = (
			z_unary_exp(rator, zright)
		) | try_it (rator::more) = (
			z_unary_exp(rator, zright)
			handle Fail _ => try_it more
		);
	in	try_it ops
	end
);
=TEX
\subsection{Binary Operators}
=SML
fun Ûbin_opsÝ (bop : BIN_OP) : Z_EXP list = (
	case bop of
	BOSparkAnd => [z_bool_and, z_array_and]
	|BOSparkAndThen => [z_bool_and]
	|BOSparkOr => [z_bool_or, z_array_or]
	|BOSparkOrElse => [z_bool_or]
	|BOSparkXor => [z_bool_xor, z_array_xor]
	|BOSparkEq => [z_bool_eq]
	|BOSparkNotEq => [z_bool_noteq]
	|BOSparkLess => [z_bool_less, z_array_less, z_bool_real_less]
	|BOSparkLessEq => [z_bool_less_eq, z_array_less_eq, z_bool_real_less_eq]
	|BOSparkGreater => [z_bool_greater, z_array_greater, z_bool_real_greater]
	|BOSparkGreaterEq => [z_bool_greater_eq, z_array_greater_eq, z_bool_real_greater_eq]
	|BOSparkAdd => [z_add, z_real_add]
	|BOSparkMinus => [z_minus, z_real_minus]
	|BOSparkTimes => [z_times, z_real_times]
	|BOSparkDiv => [z_intdiv, z_real_div]
	|BOSparkMod => [z_mod]
	|BOSparkRem => [z_rem]
	|BOSparkExpon => [z_expon, z_real_expon]
	|BOSparkMem => [z_bool_mem]
	|BOSparkNotMem => [z_bool_notmem]
	|BOSparkConcat => [z_array_array_cat, z_array_elem_cat, z_elem_array_cat]
);
=TEX
The following implements overload resolution for binary operators.

As for unary operators, the expression returned is the actual translation of
the whole binary operator application, not just the operator.
=SML
fun Ûtrans_bin_opÝ (bop : BIN_OP, zleft : Z_EXP, zright : Z_EXP) : Z_EXP = (
	let	val ops = bin_ops bop;
		fun try_it [] = fail "trans_bin_op" 508031 []
		|   try_it [rator] = (
			z_bin_exp(zleft, rator, zright)
		) | try_it (rator::more) = (
			z_bin_exp(zleft, rator, zright)
			handle Fail _ => try_it more
		);
	in	try_it ops
	end
);
=TEX
\subsection{Support for Translating Attributes}
The following is based on material taken from the Ada Reference Manual.
It is based on all Ada attributes, not just those mentioned in the list in
Volume 3, section 3.13 of the specification of the Compliance Notation.
The second element gives the Z ``type'' of the translated attribute, for attributes
that are in category B. The second element is {\it Nil} for attributes
that are either supported in category A (in which case the type can be determined
from the definitions in the Z document) or are in category C (in
which case the attribute can only be translated into Z if the user has supplied
a Z paragraph to define it).
=SML
val Ûada_attribute_typesÝ : (ID * TERM OPT) list = [
	("ADDRESS", Nil ),
	("AFT", Value ú_tm ),
	("BASE", Nil ),
	("CALLABLE", Nil ),
	("CONSTRAINED", Nil ),
	("DELTA", Nil ),
	("DIGITS", Nil ),
	("EMAX", Value ú_tm ),
	("EPSILON", Nil ),
	("FIRST", Nil ),
	("FORE", Value ú_tm ),
	("IMAGE", Nil ),
	("LARGE", Nil ),
	("LAST", Nil ),
	("LENGTH", Nil ),
	("MACHINE_EMAX", Value ú_tm ),
	("MACHINE_EMIN", Value ú_tm ),
	("MACHINE_MANTISSA", Value ú_tm ),
	("MACHINE_OVERFLOWS", Value ú_tm ),
	("MACHINE_RADIX", Value ú_tm ),
	("MACHINE_ROUNDS", Value ú_tm ),
	("MANTISSA", Value ú_tm ),
	("POS", Nil ),
	("PRED", Nil ),
	("RANGE", Nil ),
	("SAFE_EMAX", Value ú_tm ),
	("SAFE_LARGE", Nil ),
	("SAFE_SMALL", Nil ),
	("SIZE", Value ú_tm ),
	("SMALL", Nil ),
	("STORAGE_SIZE", Nil ),
	("SUCC", Nil ),
	("TERMINATED", Nil ),
	("VAL", Nil ),
	("VALUE", Nil ),
	("WIDTH", Nil )
];
=TEX
=SML
val Ûattr_type_dictÝ : TERM S_DICT = 
	map (fn (s, t) => (s, force_value t)) (
		ada_attribute_types drop (fn (_, Nil) => true | _ => false));
=TEX
The following function is used to dismantle the prefix in something like:
{\it P'BASE'FIRST}.
=SML
fun Ûstrip_attr_prefixÝ (pfx : EXP) : EXP * ATTRIB list = (
	let	fun aux acc (EAttribute{prefix, attribute_desig=ADAttrib att}) = (
			aux (att::acc) prefix
		) | aux acc other = (other, acc);
	in	aux [] pfx
	end			
);
=TEX
\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{Translating Identifiers}
=SML
fun Ûtrans_idÝ (id : ID) : Z_ID = (

let	fun aux (c::rest) = (
		case c of
		"." => "o"::aux rest
		|"'" => "v"::aux rest
		|_ => c::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
);
=TEX
=SML
val		ÛzbaseÝ = trans_id "BASE";
val		ÛzfstÝ = trans_id "FIRST";
val		ÛzlstÝ = trans_id "LAST";
val		ÛzsucÝ = trans_id "SUCC";
val		ÛzpredÝ = trans_id "PRED";
val		ÛzposÝ = trans_id "POS";
val		ÛzvalÝ = trans_id "VAL";
val		ÛzlengthÝ = trans_id "LENGTH";
val		ÛzrangeÝ = trans_id "RANGE";
val		ÛzdigitsÝ = trans_id "DIGITS";
val		ÛzdeltaÝ = trans_id "DELTA";
=TEX
=SML
fun ÛdimenÝ (zid : Z_ID, n : int) : Z_ID  = (
	if n > 0 then zid ^ "v" ^ string_of_int n else zid
);
=TEX
=SML
fun Ûexp_idÝ (env : CN_ENV) (ident : ID) : Z_EXP = (
	zid env (trans_id ident)
);
=TEX
\subsection{Translating Aggregates (Positional Array)}
=SML
type ÛARRAY_AGG_ENVÝ = {tname : TMARK, this : int, max : int};
=TEX
=SML
fun Ûarray_dimÝ (env : CN_ENV) (tmark : TMARK) : int = (
	let	val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark);
	in	(length o dest_z_tuple_type o hd o dest_z_tuple_type o
			dest_z_power_type o dest_z_power_type) ztype
	end	handle Fail _ => 1
);
=TEX
=SML
fun Ûarray_firstÝ (env : CN_ENV) ({this, max, tname} : ARRAY_AGG_ENV) : Z_EXP = (
	if	max = 1
	then	zid env (trans_id tname ^^ zfst)
	else	zid env (dimen(trans_id tname ^^ zfst, this))
);
=TEX
=SML
fun Ûarray_rangeÝ (env : CN_ENV) ({this, max, tname} : ARRAY_AGG_ENV) : Z_EXP = (
	if	max = 1
	then	zid env (trans_id tname ^^ zrange)
	else	zid env (dimen(trans_id tname ^^ zrange, this))
);
=TEX
=SML
fun Ûz_array_aggÝ (num : int) : Z_ID = (
	"array_agg" ^ (string_of_int num)
);
=TEX
=SML
fun Ûmk_array_aggÝ  (num : int, zex : Z_EXP) : Z_EXP = (
	if	num = 1
	then	zex
	else	let	val fun_name = z_array_agg num;
			val ty = force_value(get_const_type (bind_gvar_name fun_name));
			val (gty, rty) = dest_­_type ty;
			val us = map mk_u (dest_z_tuple_type gty);
			val fun_exp = mk_z_gvar(fun_name, rty, us);
			val (arg_ty, res_ty) = case dest_z_tuple_type
						(dest_z_power_type (type_of fun_exp)) of
					[ty1, ty2] => (ty1, ty2)
				|	_ => fail "" 0 [] (* caught immediately *);
			val ty_map = type_match (type_of zex) arg_ty;
		in	mk_z_app(inst [] ty_map fun_exp, zex)
		end	handle Fail _ => term_fail "mk_array_agg" 508058 [zex]
);
=TEX
=SML
fun Ûexp_array_agg_posÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, comps} : EXP AGG_POS) : Z_EXP = (
let	val zop = z_minus;
	val zleft = z_num one;
	val zright = array_first env aa_env;
	val aa_env' = {this = this + 1, max = max, tname = tname};
	val zseq = map (trans_array_agg_exp env aa_env') comps;
in
	z_rel_comp(z_power(zsucc, z_bin_exp(zleft,zop, zright)), z_seq zseq)
end
)
=TEX
\subsection{Translating Aggregates (Positional Array with Others)}
=SML
and Ûexp_array_agg_pos_othersÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({agg_pos as {tmark, comps},
		others} : EXP AGG_POS_OTHERS) : Z_EXP = (
	z_override(
		trans_array_agg_exp env aa_env (EArrayAggOthers {tmark=tmark,others=others}),
		trans_array_agg_exp env aa_env (EArrayAggPos agg_pos))
)
=TEX
\subsection{Translating Aggregates (Positional Array with Just Others)}
=SML
and Ûexp_array_agg_othersÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, others={others=ot}} : EXP AGG_OTHERS) : Z_EXP = (
let	val aa_env' = {this = this + 1, max = max, tname = tname};
in
	z_cross(array_range env aa_env, z_set [trans_array_agg_exp env aa_env' ot])
end
)
=TEX
\subsection{Translating Aggregates (Named Array)}
=SML
and Ûtrans_named_assocÝ	(env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
				({choice,comp} : (AGG_CHOICE,EXP) NAMED_ASSOC)
					: Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		ACAggChoiceRange (DRRange range) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
			end
		|ACAggChoiceRange (DRConstrained{range=range,...}) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
			end
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp =>
			trans_exp env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choice;
	val zsingles = z_set (aux_singles choice);
	val aa_env' = {this = this + 1, max = max, tname = tname};
in
	z_cross (z_many_union(zranges @ [zsingles]), z_set[trans_array_agg_exp env aa_env' comp])
end
)
=TEX
=SML
and Ûexp_array_agg_namedÝ (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, named_assocs} : (AGG_CHOICE,EXP) AGG_NAMED) : Z_EXP = (
	z_many_union (map (trans_named_assoc env aa_env) named_assocs)
)
=TEX
\subsection{Translating Aggregates (Named Array with Others)}
=SML
and Ûexp_array_agg_named_othersÝ (env : CN_ENV) (aa_env : ARRAY_AGG_ENV)
		({agg_named as {tmark, ...}, others}
		: (AGG_CHOICE,EXP) AGG_NAMED_OTHERS) : Z_EXP = (
	z_override(trans_array_agg_exp env aa_env (EArrayAggOthers {tmark=tmark, others=others}),
		trans_array_agg_exp env aa_env (EArrayAggNamed agg_named))
)
=TEX
\subsection{Translating Aggregates (Positional Record)}
=SML
and Ûexp_rec_agg_pos_zÝ
		(env : CN_ENV) ((tmark as Value tm, comps) : TMARK OPT * Z_EXP list)
		: Z_EXP = (
let	val record_components = (
		case env tm of
			Value (_, EIEnvRecordType (cmps as _::_)) => cmps
		|	_ => fail "exp_rec_agg_pos_z" 508026 [fn()=>tm]
	);
	val zbinds = combine record_components comps
		handle Fail _ => fail "exp_rec_agg_pos" 508027 [fn()=>tm];
in
	z_binding zbinds
end
) | exp_rec_agg_pos_z _ _ = fail "trans_exp" 508054 []
=TEX
\subsection{Translating Aggregates (Named Record)}
=SML
and Ûexp_rec_agg_namedÝ (env : CN_ENV) ({tmark as Value tm, named_assocs}
		: (AGG_CHOICE,EXP) REC_AGG_NAMED) : Z_EXP = (
let	fun named_assoc_to_ids_exp {choice, comp} = (
	let	fun aux (ch::rest) comp = (
			case ch of
			ACAggChoiceSingle exp => (
					(name_to_tmark exp, 
					 trans_exp env comp)::aux rest comp
			) |_ => fail "exp_rec_agg_named" 508052 []
		) | aux _ _ = [];
	in
		aux choice comp 
	end);
	val zbinds = flat (map named_assoc_to_ids_exp named_assocs);
in	z_binding zbinds
end
) | exp_rec_agg_named _ _ = fail "trans_exp" 508054 []
=TEX
\subsection{Translating Aggregates (Generally)}
Note that the failure case below will never happen, since caller must always
have looked inside the expression to get the type mark out.
The test using less-than rather than not-equals defends the code from
non-termination if something weird goes wrong in {\it array\_dim}.
=SML
and Ûtrans_array_agg_expÝ (env : CN_ENV)
	(aa_env as {this, max, ...} : ARRAY_AGG_ENV) (e : EXP) : Z_EXP = (
	if	this < max + 1
	then	case e of
		EArrayAggPos ap => exp_array_agg_pos env aa_env ap
	|	EArrayAggPosOthers apo =>  exp_array_agg_pos_others env aa_env apo
	|	EArrayAggOthers ao =>  exp_array_agg_others env aa_env ao
	|	EArrayAggNamed an =>  exp_array_agg_named env aa_env an
	|	EArrayAggNamedOthers ano => exp_array_agg_named_others env aa_env ano
	|	_ => fail "trans_array_agg_exp" 508054 []
	else	trans_exp env e
)
=TEX
\subsection{Translating Unary Expressions}
=SML
and Ûexp_unary_expÝ (env : CN_ENV) ({uop, right} : EXP UNARY_EXP) : Z_EXP = (
	trans_unary_op(uop, trans_exp env right)
)
=TEX

\subsection{Translating Binary Expressions}
=SML
and Ûexp_bin_expÝ (env : CN_ENV) ({left, bop, right} : EXP BIN_EXP) : Z_EXP = (
	 trans_bin_op(bop, trans_exp env left, trans_exp env right)
)
=TEX
\subsection{Translating Membership of a Range}
=SML
and Ûexp_mem_rangeÝ (env : CN_ENV) ({left, mop, range as RRange _} : EXP MEM_RANGE)
		: Z_EXP = (
let	val {lo=lo, hi=hi} = dest_range range;
	val zright = z_rng(trans_exp env lo, trans_exp env hi);
in
	trans_bin_op(mop, trans_exp env left, zright)
end
) | exp_mem_range (env : CN_ENV) ({left, mop, range as RRangeAttr e} : EXP MEM_RANGE)
		: Z_EXP = (
let	val  zright = trans_exp env e;
in
	trans_bin_op(mop, trans_exp env left, zright)
end
)
=TEX

\subsection{Translating Attributes}
=SML
and Ûexp_attribÝ (env : CN_ENV) ({prefix, attribute_desig=ADAttrib att}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
let	val (p, atts) = strip_attr_prefix prefix;
in let	val result = (case atts of
		[]	 => (
		let	val ze = zid env (trans_id (name_to_tmark prefix) ^^ trans_id att);
		in	dest_z_gvar ze; ze
		end	handle Fail _ => (
		let	val zp = trans_exp env p;
			val tmk = tmark_of_prefix env zp;
			val ze = zid env (tmk ^^ trans_id att);
		in	dest_z_gvar ze; ze
		end	handle Fail _ => (
				fail "exp_attrib" 508028 []
			))
	)|	["BASE"] => (
		let	val ze = trans_exp env p;
			val tmk = force_value(base_type ze);
		in	zid env (tmk ^^ trans_id att)
		end	handle Fail _ => (
		let	val ze = zid env (trans_id (name_to_tmark p) ^^ zbase ^^ trans_id att);
		in	dest_z_gvar ze; ze
		end	handle Fail _ => (
				fail "exp_attrib" 508028 []
			))
	)|	_ => (fail "exp_attrib" 508028 []
	));
in	result
end	handle Fail _ => (
		let	val attr_ty = force_value (s_lookup att attr_type_dict);
			val zp = trans_exp env p;
			val (zn, _, _) = dest_z_gvar zp
				handle Fail _ => dest_z_lvar zp;
			val sfx = fold (op ^^) (map trans_id atts) (trans_id att);
			val za = zn ^^ sfx;
		in	update_theory_db_with_parainfo (z_ax(za, attr_ty, []));
			zid env za
		end	handle Fail _ =>
				fail "exp_attrib" 508028 []
	)	
end)
=TEX
The following covers $Exp\_Attrib\_Arg$
=SML
  | Ûexp_attribÝ env ({prefix, attribute_desig=ADAttribArg(att,arg)}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
	let	val no_arg = {prefix=prefix, attribute_desig=ADAttrib att};
		val zfun = exp_attrib env no_arg;
	in
	if	trans_id att mem [zfst, zlst, zlength, zrange]
	then
		let	val zarg = trans_exp env arg;
			val (tmk, _, _) = dest_z_gvar zfun;
		in
			zid env (dimen(trans_id tmk, eval_attr_arg zarg))
		end	handle Fail _ => (
			term_fail "exp_attrib" 508028 []
			)
	else
		let	val zargs = [trans_exp env arg];
		in
			z_fun_call (zfun, zargs)
		end
	end
)
=TEX
\subsection{Translating Indexed Components}
=SML
and Ûexp_indexed_compÝ (env : CN_ENV)
	({prefix, index as EArrayAggPos{comps, tmark as Nil}} : EXP INDEXED_COMP)
		: Z_EXP = (
let	val zfun = trans_exp env prefix;
	val zargs = map (trans_exp env) comps;
in
	z_fun_call (zfun, zargs)
end
) |  Ûexp_indexed_compÝ _ _ = (
	fail "exp_indexed_comp" 508056 []
)
=TEX
\subsection{Translating Selected Components}
=SML
and Ûexp_selected_compÝ (env : CN_ENV) ({prefix, selector} : EXP SELECTED_COMP)
		: Z_EXP = (
	z_selection (trans_exp env prefix, trans_id selector)
)
=TEX
\subsection{Translating Functions Calls}
=SML
and Ûfun_globalsÝ (env : CN_ENV) (zn : Z_ID) : Z_ID list = (
	case env zn of
		Value(_, EIEnvFunction (gs, _, _)) => gs
	| _=>	fail "fun_globals" 508081 [fn()=>zn]
)
=TEX
=SML
and Ûtrans_fun_nameÝ (env : CN_ENV) (n : ID) : Z_EXP = (
	let	val zn = trans_id n;
	in	case fun_globals env zn of
			[] => zid env zn
		|	gs => z_fun_call (zid env zn, map (zid env) gs)
	end
)
=TEX
=SML
and Ûexp_fun_callÝ (env : CN_ENV) ({fun_name, args} : EXP FUN_CALL) : Z_EXP = (
	case args of
		[] => trans_fun_name env fun_name
	|	_ => 
	z_fun_call (trans_fun_name env fun_name, map (trans_exp env) args)
)
=TEX
\subsection{Translating Qualified Expressions}
=SML
and Ûexp_qualifiedÝ (env : CN_ENV) ({tmark, exp} : EXP QUALIFIED_EXPRESSION)
	: Z_EXP = (
	trans_exp env exp
)
=TEX
=TEX
\subsection{Translating Type Conversions}
=SML
and Ûexp_type_convÝ (env : CN_ENV) ({tmark, exp} : EXP TYPE_CONVERSION) 
	: Z_EXP = (
	let	val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark]);
		val te = trans_exp env exp;
	in	if	ztype =: z_int_set_type andalso type_of te =: z_int_type
		then	te
		else if	ztype =: z_real_set_type andalso type_of te =: z_real_type
		then	te
		else if	ztype =: z_int_set_type andalso type_of te =: z_real_type
		then	z_real_to_integer te
		else if	ztype =: z_real_set_type andalso type_of te =: z_int_type
		then	z_integer_to_real te
		else	fail "exp_type_conv" 508053 []
	end
)
=TEX
\subsection{Translating Integer Literals}
The function $exp\_int\_lit$ is defined in section \ref{IntegerLiterals}.
\subsection{Translating Character Literals}
The function $exp\_char\_lit$ is defined in section \ref{CharacterLiterals}.
\subsection{Translating String Literals}
The function $exp\_string\_lit$ is defined in section \ref{StringLiterals}.
\subsection{Translating Auxiliary Expressions}
=SML
and Ûexp_auxiliary_expÝ (ae : Z_TM) : Z_EXP = (
	z_predexp_of_z_tm ae
)
=TEX
\subsection{The Function $trans\_exp$}
=SML
and Ûtrans_expÝ (env : CN_ENV) ((EId id) : EXP) : Z_EXP = exp_id env id
  | trans_exp env (EIntReal n) = (
		(exp_int_lit n) handle Fail _ => exp_real_lit n
) | trans_exp env (e as EArrayAggPos _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggPosOthers _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggOthers _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggNamed _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggNamedOthers _) = exp_array_agg env e
  | trans_exp env (ERecAggPos {tmark, comps}) =
		exp_rec_agg_pos_z env (tmark, map (trans_exp env) comps)
  | trans_exp env (ERecAggNamed an) = exp_rec_agg_named env an
  | trans_exp env (EUnaryExp ue) = exp_unary_exp env ue
  | trans_exp env (EBinExp be) = exp_bin_exp env be
  | trans_exp env (EMemRange be) = exp_mem_range env be
  | trans_exp env (EAttribute at) = exp_attrib env at
  | trans_exp env (EIndexedComp ic) = exp_indexed_comp env ic
  | trans_exp env (ESelectedComp sc) = exp_selected_comp env sc
  | trans_exp env (EFunCall fc) = exp_fun_call env fc
  | trans_exp env (EAuxiliaryExp ae) = exp_auxiliary_exp ae
  | trans_exp env (EQualifiedExp qe) = exp_qualified env qe
  | trans_exp env (ETypeConversion tc) = exp_type_conv env tc
  | trans_exp env (EBracketed e) = trans_exp env e
  | trans_exp env (ECharacterLiteral c) = exp_char_lit c
  | trans_exp env (EStringLiteral s) = exp_string_lit s
and Ûexp_array_aggÝ (env : CN_ENV) (e : EXP) : Z_EXP = (
	let	val tname = (
			case e of
			EArrayAggPos {tmark as Value tmk, ...} => tmk
		|	EArrayAggPosOthers {agg_pos as {tmark as Value tmk, ...}, ...} => tmk
		|	EArrayAggOthers {tmark as Value tmk, ...} => tmk
		|	EArrayAggNamed {tmark as Value tmk, ...} => tmk
		|	EArrayAggNamedOthers {agg_named as {tmark as Value tmk, ...}, ...} => tmk
		|	_ => fail "exp_array_agg" 508054 []);
		val this = 1;
		val max = array_dim env tname;
	in	mk_array_agg
		(max, trans_array_agg_exp env {tname = tname, this = this, max = max} e)
	end
);
=TEX
The following variant of $trans\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a comment message is printed out and $Nil$ is returned.
=SML
fun Ûtrans_exp1Ý (env : CN_ENV) (exp : EXP) : Z_EXP OPT = (
	Value (trans_exp env exp)
	handle Fail msg  => (
		comment "trans_exp1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX

\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}

=SML
fun Ûnamed_assocs_to_expsÝ (names : ID list)
		(ns : (AGG_CHOICE,EXP) NAMED_ASSOC list) : EXP list = (
let	val lns = length ns;
	val table =	if lns = length names
			then	combine names (interval 0 (length ns - 1))
			else	fail "named_assocs_to_exps" 508043 [];
	fun aux1 ((ACAggChoiceSingle exp)::rest) = (
		(	lassoc3 table (name_to_tmark exp)
				handle _ => fail "named_assocs_to_exps" 508044
					[fn()=>name_to_tmark exp]
		)::aux1 rest
	) | aux1 ((ACAggChoiceRange _)::_) = (
		fail "named_assocs_to_exps" 508045 []
	) | aux1 _ = [];
	fun aux2 ({choice=cs,comp}::rest) = (
	let	val chmap = map (fn choice => (choice, comp))(aux1 cs);
	in
		chmap::(aux2 rest)
	end) | aux2 _ = [];
	val s = flat (aux2 ns);
	fun order (a:int,_) (b,_) = a-b;
	val nssorted = Sort.sort order s;
	fun aux3 count ((i, exp)::rest) = (
		if count=i
		then
			exp::aux3 (count+1) rest
		else
			fail "named_assocs_to_exps" 508043 []
	) | aux3 _ _ = [];
in
	aux3 0 nssorted
end);
=TEX

=SML
val Ûinformal_functionÝ : Z_ID = "INFORMAL_FUNCTION";
fun Ûadjust_idÝ (env : CN_ENV) (id : ID)  = (
	case (env (trans_id id)) of
		Value (ty, EIEnvFunction _) => 
			if	(fst(dest_ctype ty) <> informal_function)
			then	EFunCall{fun_name=id, args=[]}
			else	fail "adjust_id" 508049 [fn()=>id]
	| _ => EId id
)
and Ûadjust_rangelohiÝ (env : CN_ENV) ({lo=l, hi=h} : EXP RANGELOHI) = (
	{lo=adjust_exp env l, hi=adjust_exp env h}
)
and Ûadjust_rangeÝ (env : CN_ENV) (RRange x : EXP RANGE) = (
	RRange (adjust_rangelohi env x)
) | adjust_range env (RRangeAttr x : EXP RANGE) = (
	RRangeAttr (adjust_exp env x)
)
and Ûadjust_discrete_range_constrainedÝ (env : CN_ENV) ({tmark=t, range=r} :
		EXP DISCRETE_RANGE_CONSTRAINED) = (
	{tmark=t, range=adjust_range env r}
)
and Ûadjust_discrete_rangeÝ (env : CN_ENV) (DRRange x : DISCRETE_RANGE) = (
	DRRange (adjust_range env x)
) | adjust_discrete_range env (DRConstrained x : DISCRETE_RANGE) = (
	DRConstrained(adjust_discrete_range_constrained env x)
)
and Ûadjust_agg_choiceÝ (env : CN_ENV) (ACAggChoiceRange x : AGG_CHOICE) = (
	ACAggChoiceRange (adjust_discrete_range env x)
) | adjust_agg_choice env(ACAggChoiceSingle x : AGG_CHOICE) = (
	let	val n = name_to_tmark x;
	in
		case env n of
		Value (_, EIEnvOtherType) => (
			ACAggChoiceRange(DRConstrained{range=RRange {
				lo=EAttribute {attribute_desig=ADAttrib "FIRST",prefix=x},
				hi=EAttribute {attribute_desig=ADAttrib "LAST", prefix=x}},
				tmark=n})
		) |	_ => ACAggChoiceSingle (adjust_exp env x)
	end
)
and Ûadjust_named_assocÝ (env : CN_ENV) ({choice=c, comp=e}
		: (AGG_CHOICE, EXP) NAMED_ASSOC) = (
	{choice=map (adjust_agg_choice env) c, comp=adjust_exp env e}
)
and Ûadjust_othersÝ (env : CN_ENV) ({others=oth} : EXP OTHERS) = (
	{others=adjust_exp env oth}
)
and Ûadjust_agg_posÝ (env : CN_ENV)
		({tmark=tmark as Value t, comps=c} : EXP AGG_POS) = (
	case env t of
	Value (ty, EIEnvRecordType _) => (
			ERecAggPos {tmark=tmark, comps=map (adjust_exp env) c}
        ) |_ => (
			EArrayAggPos {tmark=tmark, comps=map (adjust_exp env) c}
	)
) | adjust_agg_pos  (env : CN_ENV)
		({tmark=Nil, comps=c} : EXP AGG_POS) = (
	EArrayAggPos {tmark=Nil, comps=map (adjust_exp env) c}
)
and Ûadjust_agg_pos_othersÝ (env : CN_ENV) ({agg_pos = {tmark=t, comps=c} :
		EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) = (
	EArrayAggPosOthers {	agg_pos={	tmark=t,
						comps=map (adjust_exp env) c},
				others=adjust_others env oth}
)
and Ûadjust_agg_othersÝ	(env : CN_ENV)
				({tmark=t, others=oth} : EXP AGG_OTHERS) = (
         EArrayAggOthers{tmark=t, others=adjust_others env oth}
)
and Ûadjust_agg_namedÝ (env : CN_ENV) ({tmark=t, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
	EArrayAggNamed {tmark=t, named_assocs=map (adjust_named_assoc env) n}
)
and Ûadjust_agg_named1Ý (env : CN_ENV)
		({tmark=tmark as Value t, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
let	val n' = map (adjust_named_assoc env) n;
in
	case env t of
	Value (ty, EIEnvRecordType _) => (
			ERecAggNamed {tmark=tmark, named_assocs=n'}
        ) |_ => (
			EArrayAggNamed {tmark=tmark, named_assocs=n'}
	)
end
) | adjust_agg_named1 (env : CN_ENV)
		({tmark= Nil, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
let	val n' = map (adjust_named_assoc env) n;
in
	EArrayAggNamed {tmark=Nil, named_assocs=n'}
end
)
and Ûadjust_agg_named_othersÝ (env : CN_ENV) ({agg_named=a, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) = (
let	val adjagg = case adjust_agg_named1 env a of
		EArrayAggNamed ag => (
			ag
		) | _ => fail "adjust_exp" 508046 []
in
	EArrayAggNamedOthers{agg_named=adjagg,others=adjust_others env oth}
end
)
and Ûadjust_unary_expÝ (env : CN_ENV) ({uop=u, right=r} : EXP UNARY_EXP) = (
	EUnaryExp{uop=u, right=adjust_exp env r}
)
and Ûadjust_bin_expÝ (env : CN_ENV) ({bop=b, left=l, right=r} : EXP BIN_EXP) = (
	EBinExp{left=adjust_exp env l, bop=b, right=adjust_exp env r}
)
and Ûadjust_attrib_desigÝ (env : CN_ENV) (ADAttrib x : ATTRIB_DESIG) = (
	ADAttrib x
) | adjust_attrib_desig env (ADAttribArg (a,e) : ATTRIB_DESIG) = (
	ADAttribArg (a, adjust_exp env e)
)
and Ûadjust_mem_rangeÝ	(env : CN_ENV)
				({mop=m, left=l, range=r} : EXP MEM_RANGE) = (
	EMemRange{left=adjust_exp env l, mop=m, range=adjust_range env r}
)
and Ûadjust_attributeÝ (env : CN_ENV) ({prefix=p, attribute_desig=a} :
		(EXP, ATTRIB_DESIG) ATTRIBUTE) = (
	EAttribute{prefix=adjust_exp env p, attribute_desig=adjust_attrib_desig env a}
)
and Ûadjust_indexed_compÝ	(env : CN_ENV)
				({prefix=p, index=i} : EXP INDEXED_COMP) = (
let	val prename = name_to_tmark p;
in
	case (env prename, i) of
=TEX
Is it a function call?
=SML
	(Value (ty, EIEnvFunction _), EArrayAggPos{comps,...}) => (
		if	(fst(dest_ctype ty) <> informal_function)
		then	EFunCall{fun_name=prename, args=map (adjust_exp env) comps}
		else	fail "adjust_id" 508049 [fn()=>prename]
	) |(Value (ty, EIEnvFunction (_, names, _)), EArrayAggNamed{named_assocs, ...}) => (
	let	val args = named_assocs_to_exps names named_assocs;
	in	if	(fst(dest_ctype ty) <> informal_function)
		then	EFunCall
			{fun_name=prename, args=map (adjust_exp env) args}
		else	fail "adjust_id" 508049 [fn()=>prename]
	end
=TEX
Is it a type conversion?
=SML
	) |(Value (_, EIEnvRecordType _), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
	) |(Value (_, EIEnvOtherType), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
=TEX
No... It must be an indexed component for real. So check for errors...
=SML
	) |(_, EArrayAggPos {comps=[], ...}) => (
		fail "adjust_indexed_comp" 508035 [fn()=> name_to_tmark p]

	) |(_, EArrayAggPos{comps=comps, tmark=Nil}) => (
		EIndexedComp{prefix=adjust_exp env p,
			index = EArrayAggPos{comps = map (adjust_exp env) comps, tmark = Nil}}

	) |(_, EArrayAggPos _) => (
		fail "adjust_indexed_comp" 508055 [fn()=> name_to_tmark p]

	) |(_, EArrayAggNamed _) => (
		fail "adjust_indexed_comp" 508047 [fn()=>name_to_tmark p]

	) |_ => (
		fail "adjust_indexed_comp" 508048 [fn()=>prename]

	)
end
)
and Ûadjust_selected_compÝ env ({prefix=p, selector=s} : EXP SELECTED_COMP) = (
	case p of
	EId id => (
		case env id of
		Value (ty, _) => (
			(	(dest_z_schema_type ty);
				ESelectedComp{prefix=adjust_exp (env : CN_ENV) p,
							selector=s}	)
			handle Fail _ => adjust_exp env (EId (id^"."^s))
		)| _ =>
			adjust_exp env (EId (id^"."^s))

	) | _ => 	(
		ESelectedComp{prefix=adjust_exp (env : CN_ENV) p, selector=s}
	)
)
and Ûadjust_qualified_expressionÝ
				(env : CN_ENV)
				({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	case e of
	EArrayAggPos{comps = [comp],...} => (
		EQualifiedExp{tmark = t, exp = adjust_exp env comp}
	)| EArrayAggPos{comps,...} => (
		adjust_agg_pos env {comps=comps, tmark=Value t}
	)| EArrayAggPosOthers{agg_pos={comps,...}, others} => (
		adjust_agg_pos_others env 
			{agg_pos={comps=comps,tmark=Value t},others=others}
	)| EArrayAggOthers{others,...} => (
		adjust_agg_others env {others=others,tmark=Value t}
	)| EArrayAggNamed {named_assocs = n, tmark= _} => (
		 adjust_agg_named1 env {named_assocs = n, tmark = Value t}
	)| EArrayAggNamedOthers
			{agg_named as {named_assocs = n, tmark = _}, others} => (
		adjust_agg_named_others env 
			{	agg_named={named_assocs = n, tmark = Value t},
				others=others}
	)|_ => error "adjust_qualified_exp" 508042 []
)
=TEX
In the following, both named and positional record aggregates and function calls
need no adjustment since these constructs can only be produced by adjust\_exp.
If they occur in the input then it adjust\_exp will already have been called
and need not be called again.
=SML
and Ûadjust_expÝ (env : CN_ENV) (exp as (EId id : EXP)) = (
	adjust_id env id
) | adjust_exp env (exp as (EIntReal _)) = (
	exp
) | adjust_exp env (exp as (EArrayAggPos x)) = (
	adjust_agg_pos env x
) | adjust_exp env (exp as (EArrayAggPosOthers x)) = (
	adjust_agg_pos_others env x
) | adjust_exp env (exp as (EArrayAggOthers x)) = (
	adjust_agg_others env x
) | adjust_exp env (exp as (EArrayAggNamed x)) = (
	adjust_agg_named env x
) | adjust_exp env (exp as (EArrayAggNamedOthers x)) = (
	adjust_agg_named_others  env x
) | adjust_exp env (exp as (ERecAggPos x)) = (
	exp
) | adjust_exp env (exp as (ERecAggNamed x)) = (
	exp
) | adjust_exp env (exp as (EUnaryExp x)) = (
	adjust_unary_exp env x
) | adjust_exp env (exp as (EBinExp x)) = (
	adjust_bin_exp env x
) | adjust_exp env (exp as (EMemRange x)) = (
	adjust_mem_range env x
) | adjust_exp env (exp as (EAttribute x)) = (
	adjust_attribute env x
) | adjust_exp env (exp as (EIndexedComp x)) = (
	adjust_indexed_comp env x
) | adjust_exp env (exp as (ESelectedComp x)) = (
	adjust_selected_comp env x
) | adjust_exp env (exp as (EFunCall _)) = (
	exp
) | adjust_exp env (exp as (EAuxiliaryExp _)) = (
	exp
) | adjust_exp env (exp as (EQualifiedExp x)) = (
	adjust_qualified_expression env x
) | adjust_exp env (exp as (ETypeConversion _)) = (
	exp
) | adjust_exp env (exp as (EBracketed x)) = (
	adjust_exp env x
) | adjust_exp env (exp as (EStringLiteral _)) = (
	exp
) | adjust_exp env (exp as (ECharacterLiteral _)) = (
	exp
);
=TEX
The following variant of $adjust\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a comment message is printed out and $Nil$ is returned.
=SML
fun Ûadjust_exp1Ý (env : CN_ENV) (exp : EXP) : EXP OPT = (
	Value (adjust_exp env exp)
	handle Fail msg  => (
		comment "adjust_exp1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX

\section{CHECKING FOR EMPTY RANGES}
The code in this section implements check 14 from section 17.1 of volume I of the specifications.
This requires evaluation of static expressions which is most conveniently done using proof.

The following function generates the VC for checking that a type or subtype defined by a range constraint is non-empty.
=SML
val Ûx_varÝ = ñ(x º ð ú)®;
val Ûvc_patternÝ = ñx_var® ½ ®;
fun Ûrange_check_vcÝ (n : Z_ID) : Z_EXP = (
	subst[(mk_z_gvar(n, z_int_set_type, []), x_var)] vc_pattern
);
=TEX
The following function reports an error if the range bounds can be evaluated and the range proves to be empty;
if the range can be evaluated and is non-empty then the function returns an empty list of paragraphs;
if the range cannot be evaluated a paragraph containing a VC is returned.

The somewhat strange way of expressing the decision-making arises from the desire to include the two equations in the message in the error case.
=SML
fun Ûrange_check_vcsÝ
	(n : Z_ID) (lo : TERM) (hi : TERM) : PARAINFO list = (
	(let	val lo_eqn = (concl o TRY_C(cn_eval_conv[])) lo;
		val hi_eqn = (concl o TRY_C(cn_eval_conv[])) hi;
		val nlo = (dest_z_signed_int o snd o dest_eq) lo_eqn;
		val nhi = (dest_z_signed_int o snd o dest_eq) hi_eqn;
		fun show t = (
			let	val (x, _) = dest_eq t;
			in	if	is_z_signed_int x
				then	x
				else	t
			end
		);
	in	if	nlo @<= nhi
		then	(fn _ => [])
		else	(fn _ =>
				term_fail  "trans_basic_decl"
					508060 [show lo_eqn, show hi_eqn])
	end	handle Fail _ => (fn _ =>
			(comment "trans_basic_decl"508061 [fn _ => n];
			[ConjectureInfo(Value n, [], range_check_vc n)])
	))	()
);
=TEX

\section{TRANSLATING SPARK BASIC DECLARATIONS}

\subsection{Translating Constants}

=SML
fun Ûbasic_decl_constÝ
		(env : CN_ENV)
		({consts=consts, tm=tm, expr=expr} : EXP CONST_DECL)
		: PARAINFO list= (
	let	val ae = adjust_exp1 env expr;
		val te = case ae of Value e => trans_exp1 env e | _ => Nil;
	in	case te of
			Value te =>
				map
				(fn const => z_eq_eq(trans_id const, te))
				consts
		|	Nil => (
			let	fun do1 const = (
					let	val zexp = zid env (trans_id tm);
						val zvar = trans_id const;
					in	z_ax(zvar, zexp, [])
					end
				);
			in	map do1 consts
			end		
		)
	end
);
=TEX
\subsection{Translating Enumeration Types}
=SML
fun Ûenum_attribÝ (env : CN_ENV) (zid1 : Z_ID, zid2 : Z_ID, zid3 : Z_ID) = (
let	fun env' id = 
		if id = (zid1 ^^ zlst)
		then	Value (z_int_type, EIEnvOther)
		else if id mem [zid1 ^^ zsuc, zid1 ^^ zpos]
		then	Value (z_int_int_rel_type,EIEnvOther)
		else	env id;
	val zexp = z_set_minus (zid env' zid1, z_set [zid env' (zid1 ^^ zlst)]);
in
	[z_eq_eq (zid1 ^^ zfst, zid env' zid2),
	z_eq_eq (zid1 ^^ zlst, zid env' zid3),
	z_eq_eq (zid1 ^^ zsuc, z_dom_res (zexp, zsucc)),
	z_eq_eq(zid1 ^^ zpred, z_inv(zid env' (zid1 ^^ zsuc))),
	z_eq_eq(zid1 ^^ zpos, z_id_rel (zid env' zid1)),
	z_eq_eq(zid1 ^^ zval, z_inv(zid env' (zid1 ^^ zpos)))]
end);
=TEX
=SML
fun Ûbasic_decl_enumÝ (env : CN_ENV) (name : ID) (td : ENUM_TYPE_DEF) = (
let	val {vals} = td;
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map (z_num o integer_of_int) (interval 0 ((length vals)-1));
	fun env' id = (
		if id mem zvals
		then
			Value (z_int_type, EIEnvOther)
		else if id = zname
		then
			Value (z_int_set_type, EIEnvOther)
		else
			env id
	);
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid env' (hd zvals), zid env' ((hd o rev) zvals)))] @
	enum_attrib env' (zname, hd zvals, (hd o rev) zvals)
end);
=TEX
\subsection{Translating Array Types}
=SML
fun Ûarray_attrib_auxÝ (env : CN_ENV) (zid1 : Z_ID) (zid2 : Z_ID, i : int) : PARAINFO list = (
	[z_eq_eq(dimen(zid1 ^^ zfst, i), zid env (zid2 ^^ zfst)),
	z_eq_eq(dimen(zid1 ^^ zlst, i), zid env (zid2 ^^ zlst)),
	z_eq_eq(dimen(zid1 ^^ zlength, i), z_size (zid env zid2)),
	z_eq_eq(dimen(zid1 ^^ zrange, i), zid env zid2)]
);
=TEX
The handler below catches failures from {\it hd}.
=SML
fun Ûarray_attribÝ (env : CN_ENV) (zid : Z_ID, zids : Z_ID list) : PARAINFO list = (
	let	val aux = array_attrib_aux env zid;
		val zids_is = combine zids (interval 1 (length zids));
	in	aux (hd zids, 0) @
		flat (map aux zids_is)
	end	handle Fail _ => fail "array_attrib" 508035 [] 
);
=TEX
=SML
fun Ûbasic_decl_con_arrayÝ (env : CN_ENV) (name : ID)
		({index=index, comp=comp} : ARRAY_DEF) : PARAINFO list = (
	let	val zname = trans_id name;
		val zindex = z_many_cross (map (zid env o trans_id) index);
		val zcomp = trans_id comp;
	in
		[z_eq_eq(zname, z_tfun(zindex, zid env zcomp))] @
		array_attrib env (zname, index)
	end
);
=TEX
=SML
=TEX
=SML
fun Ûbasic_decl_uncon_arrayÝ (env : CN_ENV) (name : ID)
		({index=[head_index], comp=comp} : ARRAY_DEF) : PARAINFO list = (
	let	val zname = trans_id name;
		val zindex = trans_id head_index;
		val zcomp = trans_id comp;
		val zexp = z_powerset(z_pfun(zid env zindex, zid env zcomp));
	in
		[z_ax(zname, zexp, [])]
	end
) | basic_decl_uncon_array env name
	({index=index, comp=comp} : ARRAY_DEF) = (
	let	val zname = trans_id name;
		val zindex = z_many_cross (map (zid env o trans_id) index);
		val zcomp = trans_id comp;
		val zexp = z_powerset(z_pfun(zindex, zid env zcomp));
	in
		[z_ax(zname, zexp, [])]
	end
);
=TEX

\subsection{Translating Record Types}
=SML
fun Ûconv_var_declÝ ({vars=vs, tmark=t} : VAR_DECL)
		: {var : ID, tmark : TMARK} list = (
	 map (fn id => {var=id, tmark=t}) vs
);
=TEX
=SML
fun Ûtrans_decl_auxÝ (env : CN_ENV) ({vars, tmark} : VAR_DECL) : Z_DECL * (Z_ID list) = (
let	val zvs = map trans_id vars;
	val zexp = zid env (trans_id tmark);
	val zvars = map (fn zv => mk_z_lvar (zv,
						(dest_z_power_type o type_of) zexp,
						[])) zvs;
in
	(mk_z_dec (zvars, zexp), zvs)
end);
fun Ûtrans_declÝ (env : CN_ENV) : VAR_DECL -> Z_DECL = fst o trans_decl_aux env;
=TEX
=SML
local
fun Ûmk_update_defsÝ (tyname : Z_ID) (comps : Z_ID list list) : PARAINFO = (
	let	val n_comps = length comps;
		val gen_formals = map (fn i => "g" ^ string_of_int i) (interval 1 n_comps);
		fun do_sch_decs [] _ = []
		|   do_sch_decs comps gen_formals = (
			let	val c = hd comps;
				val n = hd gen_formals;
				val ty = mk_z_var_type n;
				fun mk_v v = mk_z_lvar(v, ty, []);
			in	(map mk_v c, mk_z_lvar(n, mk_z_power_type ty, []))
			end	:: do_sch_decs (tl comps) (tl gen_formals)
		);
		val sch_decs = do_sch_decs comps gen_formals;
		val decl = mk_z_decl(map mk_z_dec sch_decs);
		val h_schema = mk_z_h_schema (decl, mk_t);
		val _ = schema_gen_semantic_const h_schema;
		fun upd_name c = tyname ^ "u" ^ c;
		fun do_sig_decs [] _ = []
		|   do_sig_decs comps decs = (
			let	val c = hd comps;
				val (_, x) = hd decs;
				val set = z_tfun(mk_z_¸[h_schema, x], h_schema);
				val ty = dest_z_power_type (type_of set);
				fun mk_v v = mk_z_lvar(upd_name v, ty, []);
			in	(map mk_v c, set)
			end	:: do_sig_decs (tl comps) (tl decs)
		);
		val sig_decs = do_sig_decs comps sch_decs;
		val sig_decl = mk_z_decl(map mk_z_dec sig_decs);
		fun do_µ_decs _ [] = []
		|   do_µ_decs n ((_, x)::more) = (
			let	val ty = dest_z_power_type (type_of x);
				val v = mk_z_lvar("x" ^ string_of_int n, ty, []);
			in	([v], x)
			end	:: do_µ_decs (n+1) more
		);
		val r = mk_z_lvar("r", dest_z_power_type(type_of h_schema), []);
		val r_dec = ([r],	h_schema);
		val var_decs = do_µ_decs 1 sch_decs;
		val µ_decl = mk_z_decl(map mk_z_dec (r_dec :: var_decs));
		fun bind_one sel var comp = (
			if	sel = comp
			then	(comp, var)
			else	(comp, mk_z_sels(r, comp))
		);
		fun do_binding _ _  [] = []
		|   do_binding var sel cmps = (
			let	val cmpl = hd cmps;
			in	map (bind_one sel var) cmpl
			end	@ do_binding var sel (tl cmps)
		);
		fun do_eq var arg (f, c) = (
			mk_z_eq(mk_z_app(f, arg), z_binding(do_binding var c comps))
		); 
		fun do_eqs [] _ _ = []
		|   do_eqs sigdecs vardecs cmps = (
			let	val (fs, _) = hd sigdecs;
				val cs = hd cmps;
				val var = hd(fst(hd vardecs));
				val arg = mk_z_tuple[r, var];
			in	map (do_eq var arg) (combine fs cs)
			end	@ do_eqs (tl sigdecs) (tl vardecs) (tl cmps)
		);
		val eqs = list_mk_±(do_eqs sig_decs var_decs comps);
		val pred = mk_z_µ(µ_decl, mk_t, eqs);
		val idtys = map dest_var (flat (map fst sig_decs));
	in	AxDesInfo(gen_formals, sig_decl, Value pred, idtys)
	end
);
in
fun Ûrecord_update_defsÝ (zname : Z_ID, zcomps : Z_ID list list) : PARAINFO = (
	mk_update_defs zname zcomps
);
end;
=TEX
=SML
fun Ûbasic_decl_recordÝ (env : CN_ENV) (name : ID)
		({decl} : RECORD_TYPE_DEF) : PARAINFO list = (
let	val z_sname = trans_id name;
	val (z_decls, zcomps) = split(map (trans_decl_aux env) decl);
in
	[z_schema(z_sname, z_decls), record_update_defs(z_sname, zcomps)]
end);
=TEX
\subsection{Translating Integer Types}

=SML
local
	val z_exp = z_pfun(ú_tm, ú_tm);
in
fun Ûint_type_attribÝ (env : CN_ENV) (zid1, range) = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val zvar1 = zid1 ^^ zsuc;
		val zvar2 = zid1 ^^ zpred;
		val zvar3 = zid1 ^^ zpos;
		val zvar4 = zid1 ^^ zval;
	in
		[z_eq_eq(zid1 ^^ zfst, trans_exp env lo),
		z_eq_eq(zid1 ^^ zlst, trans_exp env hi),
		z_ax(zvar1, z_exp, []),
		z_ax(zvar2, z_exp, []),
		z_ax(zvar3, z_exp, []),
		z_ax(zvar4, z_exp, [])]
	end
);
end;
=TEX
=SML
fun Ûbasic_decl_int_typeÝ (env : CN_ENV) (name : ID) (range : EXP RANGE)
	: PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val tlo = trans_exp env lo;
		val thi = trans_exp env hi;
		val zname = trans_id name;
		val vcs = range_check_vcs name tlo thi;
	in	if	not(type_of tlo =: z_int_type)
		then	term_fail "basic_decl_int_type" 508066 [tlo]
		else if	not(type_of thi =: z_int_type)
		then	term_fail "basic_decl_int_type" 508066 [thi]
		else	((z_eq_eq(zname, z_rng(tlo, thi)) ::
			  int_type_attrib env (zname, RRange{lo=lo,hi=hi})) @ vcs)
	end
);
=TEX
\subsection{Translating Real Types}

=TEX
=SML
fun Ûbasic_decl_fixed_typeÝ (env : CN_ENV) (name : ID)
	({exp = delta, range = Value r} : EXP FIXED_TYPE_DEF)
	: PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env r);
		val tlo = trans_exp env lo;
		val thi = trans_exp env hi;
		val tdelta = trans_exp env delta;
		val zname = trans_id name;
		(* val vcs = range_check_vcs name tlo thi; *)
	in	[ z_eq_eq(zname, z_rng(tlo, thi)),
		  z_eq_eq(zname ^^ zdelta, tdelta),
		  z_eq_eq(zname ^^ zfst, tlo),
		  z_eq_eq(zname ^^ zlst, thi) ]
	end
) | basic_decl_fixed_type _ _ _ = fail "basic_decl_fixed_type" 508065 [];
=TEX
=SML
fun Ûbasic_decl_floating_typeÝ (env : CN_ENV) (name : ID)
	({exp = digits, range = Value r} : EXP FIXED_TYPE_DEF)
	: PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env r);
		val tlo = trans_exp env lo;
		val thi = trans_exp env hi;
		val tdigits = trans_exp env digits;
		val zname = trans_id name;
		(* val vcs = range_check_vcs name tlo thi; *)
	in	[ z_eq_eq(zname, z_rng(tlo, thi)),
		  z_eq_eq(zname ^^ zdigits, tdigits),
		  z_eq_eq(zname ^^ zfst, tlo),
		  z_eq_eq(zname ^^ zlst, thi) ]
	end
) | basic_decl_floating_type env name {exp = digits, range = Nil} = (
	let	val tdigits = trans_exp env digits;
		val zname = trans_id name;
		val tfst = zname ^^ zfst;
		val tlst = zname ^^zlst;
		val trng = z_rng(
			mk_z_gvar(tfst, z_real_type, []),
			mk_z_gvar(tlst, z_real_type, []));
		(* val vcs = range_check_vcs name tlo thi; *)
	in	[ z_ax(tfst, %calR%_tm, []),
		  z_ax(tlst, %calR%_tm, []),
		  z_eq_eq(zname, trng),
		  z_eq_eq(zname ^^ zdigits, tdigits)]
	end
);
=TEX

\subsection{Translating Subtypes}
=SML
fun Ûrange_con_attribÝ (env : CN_ENV) (zid1 : Z_ID, zid2 : Z_ID, {lo,hi}
		: EXP RANGELOHI) : PARAINFO list = (
	[z_eq_eq (zid1 ^^ zfst, trans_exp env lo),
	z_eq_eq (zid1 ^^ zlst, trans_exp env hi),
	z_eq_eq (zid1 ^^ zsuc, zid env (zid2 ^^ zsuc)),
	z_eq_eq (zid1 ^^ zpred, zid env (zid2 ^^ zpred)),
	z_eq_eq (zid1 ^^ zpos, zid env (zid2 ^^ zpos)),
	z_eq_eq (zid1 ^^ zval, zid env (zid2 ^^ zval))]
);
=TEX
The following function does the processing which is commont to cases of
a subtype which gives rise to an axiomatic description rather than an abbreviation definition.
=SML
fun Ûbasic_decl_subtype_axdesÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
	: PARAINFO list = (
	let	val zvar = trans_id name;
		val ztmark = trans_id tmark;
		val zexp = z_powerset (zid env tmark)
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark];
	in	[z_ax(zvar, zexp, [])]
	end
);
=TEX
Here and in the Z generator we need to know the names of the recognised attributes:
=SML
val Ûada_attributes_listÝ : ID list = map fst ada_attribute_types;
=TEX
=SML
fun Ûtype_attrsÝ (unwanted : ID list) (t : ID) = (
let	val tthy = get_const_theory (bind_gvar_name t);
	val tthyconsts = get_consts tthy;
	val tthyconsts_names = map (fst o dest_const) tthyconsts;
	val transt = trans_id t;
in
	(ada_attributes_list diff unwanted) drop
		(fn attr => not((bind_gvar_name transt ^^ attr) mem tthyconsts_names))
end
handle (Fail _) => [] (* presumably from get_const_theory *)
);
=IGN
type_attrs []"NATURAL";
=TEX
=TEX
In the following, the two `then' parts in the first case alternative implements
=INLINEFT
Basic_Decl_Range_Con_1
=TEX
\ and
=INLINEFT
Basic_Decl_Range_Con_3
=TEX

\ and the final `else' part and the second case alternative implement
=INLINEFT
Basic_Decl_Range_Con_2
=TEX
.
=SML
fun Ûbasic_decl_subtype_range_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		(range : EXP RANGE) : PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val zname = trans_id name;
		val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark]);
		val te_lo = trans_exp1 env lo;
		val te_hi = trans_exp1 env hi;
	in	case (te_lo, te_hi) of
			(Value l, Value h) =>
			if	ztype =: z_int_set_type
			then	let	val vcs = range_check_vcs name l h;
				in	z_eq_eq(zname, z_rng(l, h)) ::
					range_con_attrib env
					(zname, ztmark, {lo=lo,hi=hi}) @ vcs
				end
			else if	ztype =: z_real_set_type
			then	let	(* val vcs = range_check_vcs name l h *);
					val unwanted = ["FIRST", "LAST"];
					val tas = type_attrs unwanted tmark;
					val tas_paras = map
						(fn attr =>
						z_eq_eq(zname ^^ attr,
						 zid env (trans_id tmark ^^ attr))) tas;
				in	z_eq_eq(zname, z_rng(l, h)) ::
					tas_paras @
					[ z_eq_eq(zname ^^ zfst, l),
					  z_eq_eq(zname ^^ zlst, h) ]
				end
			else	basic_decl_subtype_axdes env name tmark
		|	_ =>	basic_decl_subtype_axdes env name tmark
	end
);
=TEX
=SML
val Ûbasic_decl_subtype_fixed_conÝ : CN_ENV -> ID
	-> EXP FIXED_POINT_CONSTRAINT -> PARAINFO list
	= basic_decl_fixed_type;
val Ûbasic_decl_subtype_floating_conÝ : CN_ENV -> ID
	-> EXP FLOATING_POINT_CONSTRAINT -> PARAINFO list
	= basic_decl_floating_type;
=SML
=TEX
The following function is used to check whether a subtype has base type
{\it STRING} and, if so, to check the lower index bound.
=SML
local
val z_one = ñ1®;
in
fun Ûstring_bound_checkÝ (env : CN_ENV) (name : ID) ([ix] : TMARK list) (ztmark : Z_EXP)
		 : PARAINFO list = (
	case base_type ztmark of
	Value "STRING" =>
		let	val zbnd = zid env (trans_id ix ^^ zfst);
			val zval = (snd o dest_eq o concl o TRY_C(cn_eval_conv[])) zbnd;
		in	if	is_z_signed_int zval
			then	if	zval =$ z_one
				then	[]
				else	fail "string_bound_check" 508075 [fn _ => name]
			else	(comment "string_bound_check" 508076 [fn _ => name];
				[ConjectureInfo(Value name, [], mk_z_eq(zbnd, z_one))])
		end
	| _ => []
) | string_bound_check _ _ _ _ = [];
end;
=TEX
=SML
fun Ûbasic_decl_subtype_index_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		(ci : EXP list) : PARAINFO list = (
let	val zname = trans_id name;
	val zexp = zid env (trans_id tmark);
	val zvar_ty = dest_z_power_type(type_of zexp)
		handle Fail _ => fail "trans_basic_decl" 508051 [fn () => tmark];
	val var =  "array";
	val env' = fn id => if id = "array" then Value (zvar_ty, EIEnvVar tmark)
					else env id; 
	val index = map name_to_tmark ci;
	val zindex = map trans_id index;
	val zp = z_eq (z_dom (zid env' var), z_many_cross(map (zid env) zindex));
	val set_comp = z_set_comp (trans_decl env' {vars=[var],tmark=tmark}, zp)
	val abb_def = z_eq_eq (zname, set_comp);
in	abb_def :: array_attrib env (zname, zindex) @
	string_bound_check env name index zexp
end
);

=SML
fun Ûbasic_decl_subtype_no_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		: PARAINFO list = (
let	val zname = trans_id name;
	val zexp = zid env (trans_id tmark);
	val zvar_ty = dest_z_power_type(type_of zexp)
		handle Fail _ => fail "trans_basic_decl" 508051 [fn () => tmark];
	val abb_def = z_eq_eq (zname, zexp);
	val tas = type_attrs [] tmark;
	val tas_paras = map (fn attr => z_eq_eq(zname ^^ attr, 
		zid env (trans_id tmark ^^ attr))) tas;
in	
	(abb_def :: tas_paras)
end);
=TEX

\subsection{The Function $trans\_basic\_decl$}
=SML
fun Ûtrans_basic_declÝ (env : CN_ENV) ((BDConstDecl {consts,tm,expr}) : BASIC_DECL)
		: PARAINFO list = (
	basic_decl_const env {consts=consts, tm=tm, expr=expr}
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDEnumTypeDef td,...}) = (
	basic_decl_enum env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDIntTypeDef range,...}) = (
	basic_decl_int_type env name range
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDConArrayDef td,...}) = (
	basic_decl_con_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDUnconArrayDef td,...}) = (
	basic_decl_uncon_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDRecordTypeDef td,...}) = (
	basic_decl_record env name td
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CRange cr},...}) = (
	basic_decl_subtype_range_con env name tmark cr
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CIndex ci},...}) = (
	basic_decl_subtype_index_con env name tmark ci
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFixed cf},...}) = (
	basic_decl_subtype_fixed_con env name cf
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFloating cf},...}) = (
	basic_decl_subtype_floating_con env name cf
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CNoCon},...}) = (
	basic_decl_subtype_no_con env name tmark
) | trans_basic_decl env (BDTypeDecl {name, type_def as TDFixedTypeDef td}) = (
	basic_decl_fixed_type env name td
) | trans_basic_decl env (BDTypeDecl {name, type_def as TDFloatingTypeDef td}) = (
	basic_decl_floating_type env name td
) | trans_basic_decl env (BDDeferredConstDecl _) = (
	fail "trans_basic_decl" 508039 []
) | trans_basic_decl env (BDVarDecl _) = (
	fail "trans_basic_decl" 508040 []
) | trans_basic_decl env (BDVarDeclInit _) = (
	fail "trans_basic_decl" 508040 []
) | trans_basic_decl env (BDPrivateTypeDecl _) = (
	fail "trans_basic_decl" 508041 []
) | trans_basic_decl env (BDPragma _) = (
	[]
) | trans_basic_decl env (BDAnnotation _) = (
	[]
);
=TEX
=SML
fun Ûtrans_basic_decl1Ý (env : CN_ENV) (bd : BASIC_DECL)
			: PARAINFO list OPT = (
	Value (trans_basic_decl env bd)
	handle Fail msg  => (
		comment "trans_basic_decl1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX
\section{Support for Multidimensional Arrays}
=SML
fun Ûarray_agg_defÝ (num : int) : unit = (
if	num >= 2
then
let	val fun_name = z_array_agg num;
in	case get_const_type (bind_gvar_name fun_name) of
		Value _ => ()
	|	Nil =>
	let	fun mk_gvar name = (
			let val ty = mk_z_power_type(mk_z_var_type name);
			in	mk_z_lvar(name, ty, [])
			end
		);
		val ns = map string_of_int (interval 1 num);
		val g_ns = map (mk_gvar o (fn n => "g" ^ n)) ns;
		val g = mk_gvar "g";
		val prod = z_many_cross g_ns;
		val uncurried_tm = z_tfun(prod, g);
		fun mk_curried_tm [] = g
		|   mk_curried_tm (g_n::more) = z_tfun(g_n, mk_curried_tm more);
		val curried_tm = mk_curried_tm g_ns;
		val sig_tm = z_tfun(curried_tm, uncurried_tm);
		val sig_ty = dest_z_power_type (type_of sig_tm);
		val fun_var = mk_z_lvar(fun_name, sig_ty, []);
		val sig_decl = mk_z_decl[mk_z_dec([fun_var], sig_tm)];
		val f = mk_z_lvar("f", dest_z_power_type(type_of curried_tm), []);
		fun mk_x_n (v, n) = (
			mk_z_lvar("x" ^ n, dest_z_power_type (type_of v), [])
		);
		val x_ns = map mk_x_n (combine g_ns ns);
		val tuple = mk_z_tuple x_ns;
		val lhs = mk_z_app(mk_z_app(fun_var, f), tuple);
		fun mk_rhs t [] = t
		|   mk_rhs t (x_n::more) = mk_rhs (mk_z_app(t, x_n)) more;
		val rhs = mk_rhs f x_ns;
		val eqn = mk_z_eq(lhs, rhs);
		fun dec_of_var (v, e) = mk_z_dec([v], e);
		val x_decs = map dec_of_var (combine x_ns g_ns); 
		val pred = mk_z_µ(mk_z_decl(dec_of_var(f, curried_tm)::x_decs), mk_t, eqn);
		val idtys = [dest_var fun_var];
	in	update_theory_db_with_parainfo
		(AxDesInfo(map (fst o dest_var) (g_ns @ [g]), sig_decl, Value pred, idtys))
	end
end
else fail "array_agg_def" 508059 []
);
=TEX
\section{EPILOGUE}

=SML
end (* structure CNBasicDeclsAndExprs *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
