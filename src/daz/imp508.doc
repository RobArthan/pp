% imp508.doc   %Z% $Date: 2000/10/31 11:40:57 $ $Revision: 1.71 $ $RCSfile: imp508.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP508}  %% Mandatory field
\def\SCCSversion{$Revision: 1.71 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/10/31 11:40:57 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the implementation for the Basic Declaration and Expression Generator for processing Compliance Notation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.15] Initial Drafts.
\item[Issue 1.16 (16th June 1994)] First draft for review.
\item[Issue 1.27 (31 October 1994)] Added $z\_true$ and $z\_exists$ as per version 1.1 of Volume 3 of DRA's specification.
\item[Issue 1.30 (9th November 1994)]
Adjusted $ENV\_INFO$ and allowed for type conversions.
\item[Issue 1.32] Updated document references.
\item[Issue 1.33] Accomodated changes to toolkit extensions agreed at the 4th critical review (see \cite{ISS/HAT/DAZ/min005}: $mod$ becomes $intmod$, $Abs$ becomes $abs$).
\item[Issue 1.34] Fixed bug 6 (batch 2).
\item[Issue 1.35] Accomodated changes to data types required for enhancements.
\item[Issue 1.36] Enhancement 11 (and bug 9 (batch 2)).
\item[Issue 1.37] Enhancements 13 and 14.
\item[Issue 1.38] Enhancement 15.
\item[Issue 1.39-1.41] Enhancements to basic declarations.
\item[Issue 1.42] Enhancement 12 (type conversions) and rejig of enhancement 11.
\item[Issues 1.43-1.45] Enhancements 3 and 18.
\item[Issue 1.46 (14th December 1995)] Changes according to desk check report 024.
\item[Issue 1.47 ] Fixes to bugs 8 and 10 (V0.6) and error reporting.
\item[Issue 1.48 ] Fixes to bug 1 (V0.7).
\item[Issue 1.49] IUCT WP 7 changes.
\item[Issue 1.50] IUCT WP 4 changes.
\item[Issue 1.51,1.52] Fixing bugs in IUCT WP 4 changes.
\item[Issue 1.53] Improved an error message.
\item[Issue 1.54] Updated references.
\item[Issue 1.54] Updates for SML97.
\item[Issue 1.55] Updates for new INTEGER type.
\item[Issue 1.56] Enhancement R3 --- Assignments to record components.
\item[Issue 1.57] Enhancement R2 --- multiple logical constant definitions.
\item[Issues 1.58-1.61] Enhancement R1 --- multi-dimensional arrays.
\item[Issues 1.62] Enhancement CTLE II R1/2 --- ``Others'' in case statements.
\item[Issues 1.63] Enhancement CTLE II R1/4 --- logical operators on arrays of booleans, including all the basics of overload resolution.
\item[Issues 1.64, 1.65] Enhancement CTLE II R1/8 --- characters and strings
\item[Issues 1.66] Enhancement CTLE II R1/5 --- range attributes as ranges
\item[Issues 1.67] Enhancement CTLE II R1/9 --- SPARK 83 attributes
\item[Issues 1.68] Enhancement CTLE II R1/11 --- nested packages
\item[Issues 1.69,1.70] Enhancement CTLE II R1/1 --- real types
\item[Issues 1.71,1.72] Fixed logic errors in {\it exp\_attrib} and errors in CTLE II R1/5 and R1/6.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Algorithms}
The algorithms to generate the basic declarations and expressions are specified in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

%\subsection{Dependencies}
%\subsection{Known Deficencies}
%\subsection{Possible Enhancements}
=TEX

\section{PREAMBLE}

=SML
infix 3 ^^;
=TEX
=SML
structure €CNBasicDeclsAndExprs› : CNBasicDeclsAndExprs = struct
	open CNParser CNTypes ZGeneratedConstants ZParagraphs;
	open ZUserInterfaceSupport ZTypesAndTermsSupport;
=TEX
\section{CUSTOMIZED ENVIRONMENT HANDLING}

=SML
datatype €ENV_INFO› =
			€EIEnvFunction› of Z_ID list * ID list * TMARK
		|	€EIEnvVar› of TMARK
		|	€EIEnvAuxVar› of Z_DECL
		|	€EIEnvRecordType› of ID list
		|	€EIEnvOtherType›
		|	€EIEnvConstant› of TMARK
		|	€EIEnvRetry› of Z_ID
		|	€EIEnvOther›;
=TEX
=SML
type €CN_ENV› = Z_ID -> (TYPE * ENV_INFO) OPT;
=TEX

\section{SUPPORTING FUNCTIONS}
\subsection{Miscellaneous}
As discussed with DRA during the (first) enhancements programme, the treatment
of constructs which cannot be handled formally changed between releases 0.5 and 0.6.
Now that the user can bypass the formal processing of such a construct (as an arbitrary ada insertion), there is no need to attempt to continue processing when such a construct appears here, except in cases where failure to translate a construct is used to redirect the flow of control.
In order to encourage better messages, the exception $Informal$ and associated functions have been removed and the usual {\Product} error mechanisms are used instead.
=TEX
=SML
fun zid1 €^^› zid2 = (
	zid1^"v"^zid2
);
=TEX
=SML
fun €dest_range› ((RRange range) : EXP RANGE) : EXP RANGELOHI = (
	range
) | dest_range (RRangeAttr (EAttribute {prefix,
		attribute_desig = ADAttrib "RANGE"})) = (
	{lo = EAttribute {prefix = prefix, attribute_desig = ADAttrib "FIRST"},
	 hi = EAttribute {prefix = prefix, attribute_desig = ADAttrib "LAST"} }
) | dest_range (RRangeAttr (EAttribute {prefix,
		attribute_desig = ADAttribArg("RANGE", e)})) = (
	{lo = EAttribute {prefix = prefix, attribute_desig = ADAttribArg("FIRST", e)},
	 hi = EAttribute {prefix = prefix, attribute_desig = ADAttribArg("LAST", e)} }
) | dest_range _  = fail "dest_range" 508020 [];
=TEX
=TEX

The following were not asked for in the specification
but are convenient to have available at various points in the code.
=SML
val €z_int_type› = type_ofÒ0Æ;
val €z_int_set_type› = type_of Ò˙Æ;
val €z_int_int_rel_type› = type_of Ò˙ ∏ ˙Æ;
val €˙_tm› = Ò˙Æ;
=TEX
=SML
val €z_real_type› = type_ofÒ0 e 0Æ;
val €z_real_set_type› = type_ofÒ{0 e 0}Æ;
val €%calR%_tm› = Ò%calR%Æ;
=TEX
\section{Evaluation of Constant Expressions}
Constant expressions need to be evaluated in the translation of array attributes with
arguments and in deciding whether a VC needs to be generated 
For various reasons, it has been agreed that attributes that are functions will not be statically evaluated.

=TEX
First of all we define a conversion which will expand the definition of a constant integer or set of integers providing the definition is a simple equation and providing the constant does not appear in the list provided as an extra argument (this is used to avoid looping in the presence of somewhat mailiciously conceived definitions).

=SML
fun €cn_const_conv› (consts : TERM list) : CONV = (fn tm =>
	(if	tm term_mem consts
	then	fail_conv
	else	COND_C
		(fn tm => is_const tm andalso
			let val ty = type_of tm; in ty =: z_int_type orelse ty =: z_int_set_type end)
		(fn tm => simple_eq_match_conv (z_get_spec tm) tm)
		fail_conv
	) tm
);
=TEX
Now conversions to handle a few other cases which are not directly handled by available tools.
The conversion for \verb"#" is required for array length attributes.
=SML
val €z_minus_minus_thm› = pc_rule1 "z_library" prove_rule[] ¨µi ∑Ò~ ~i = iÆÆ;

val €z_minus_minus_conv› = simple_eq_match_conv z_minus_minus_thm;

val €z_hash_thm› = asm_rule ¨µi j∑Ò#(i .. j) = (j - i) + 1ÆÆ;

val €z_hash_conv› : CONV = simple_eq_match_conv z_hash_thm;
=TEX
Now a conversional for propagating a conversion into the operands of a unary or binary Z function.
=SML
fun €MY_Z_RANDS_C› (c : CONV) : CONV = (fn tm =>
	(	((dest_z_tuple o snd o dest_z_app) tm;
			RAND_C (RAND_C c AND_OR_C RATOR_C(RAND_C c)))
				handle Fail _ => RAND_C c	) tm
	
);
=TEX
We put these pieces together to give the following conversion which does the required static evaluation of integer expressions.
The parameter to the conversion is used to record which constants have had their definitions unwound somewhere in the branch of the expression tree currently being attacked and is used to avoid infinite recursion (e.g., if someone has used HOL to produce something which looks like a Z global variable with a definition like $X = X$ or $X = X + 0$).
=SML
fun €cn_eval_conv› (consts : TERM list) : CONV = (fn tm => (
		MY_Z_RANDS_C (cn_eval_conv consts)
		AND_OR_C
		(fn t => (cn_const_conv consts
			THEN_TRY_C cn_eval_conv (consts term_grab t)) t)
		AND_OR_C (FIRST_C [
				z_hash_conv,
				z_subtract_minus_conv,
				z_minus_minus_conv]
			THEN_TRY_C cn_eval_conv consts)
		AND_OR_C FIRST_C [
			z_plus_conv,
			z_times_conv,
			cn_intmod_conv	,
			cn_intdiv_conv	,
			cn_rem_conv,
			cn_star_star_conv,
			z_abs_conv
		])	tm
);
=TEX
The handling of ranges uses the above function directly.
The following is the interface used in handling attributes.
=SML
fun €eval_attr_arg› (ze : Z_EXP) : int = (
	let	val n = (dest_z_signed_int o snd o dest_eq o
				snd o dest_thm o TRY_C(cn_eval_conv[])) ze; 
	in	if 	n @> integer_of_int 0
		then	int_of_integer n
		else	term_fail "eval_attr_arg" 508030 [ze]
	end	handle	Fail _ => term_fail "eval_attr_arg" 508029 [ze]
);
=TEX
\section{SUPPORT FOR Z ABSTRACT SYNTAX}
\subsection{Z Unary Expressions}
=SML
val		€z_unary_minus› =		Ò(~ _)Æ;
val		€z_bool_not› =		Ò(not _)Æ;
val		€z_abs› =		Ò(abs _)Æ;
val		€z_char_lit› =		Ò(char_lit _)Æ;
val		€z_string_lit› =		Ò(string_lit _)Æ;
val		€z_real_unary_minus› =	Ò(~âR _)Æ;
val		€z_real_abs› =		Ò(absâR _)Æ;
=TEX
\subsection{Z Binary Expressions}
=SML
val 		€z_bool_and› =		Ò(_ and _)Æ;
val		€z_bool_or› =		Ò(_ or _)Æ;
val		€z_bool_xor› =		Ò(_ xor _)Æ;
val		€z_bool_eq› =		Ò(_ eq _)Æ;
val		€z_bool_noteq› =		Ò(_ noteq _)Æ;
val		€z_bool_less› =		Ò(_ less _)Æ;
val		€z_bool_less_eq› =	Ò(_ less_eq _)Æ;
val		€z_bool_greater› =	Ò(_ greater _)Æ;
val		€z_bool_greater_eq› =	Ò(_ greater_eq _)Æ;
val		€z_add› =		Ò(_ + _)Æ;
val		€z_minus› =		Ò(_ - _)Æ;
val		€z_times› =		Ò(_ * _)Æ;
val		€z_intdiv› =		Ò(_ intdiv _)Æ;
val		€z_mod› =		Ò(_ intmod _)Æ;
val		€z_rem› =		Ò(_ rem _)Æ;
val		€z_expon› =		Ò(_ ** _)Æ;
val		€z_bool_mem› =		Ò(_ mem _)Æ;
val		€z_bool_notmem› =		Ò(_ notmem _)Æ;
val		€z_array_not› =		Ò(array_not _)Æ;
val		€z_array_and› =		Ò(_ array_and _)Æ;
val		€z_array_or› =		Ò(_ array_or _)Æ;
val		€z_array_xor› =		Ò(_ array_xor _)Æ;
val		€z_array_greater› =	Ò(_ array_greater _)Æ;
val		€z_array_greater_eq› =	Ò(_ array_greater_eq _)Æ;
val		€z_array_less› =		Ò(_ array_less _)Æ;
val		€z_array_less_eq› =	Ò(_ array_less_eq _)Æ;
val		€z_array_array_cat› =	Ò(_ &â0 _)Æ;
val		€z_array_elem_cat› =	Ò(_ &â1 _)Æ;
val		€z_elem_array_cat› =	Ò(_ &â2 _)Æ;
val		€z_real_add› =		Ò(_ +âR _)Æ;
val		€z_real_minus› =		Ò(_ -âR _)Æ;
val		€z_real_times› =		Ò(_ *âR _)Æ;
val		€z_real_div› =		Ò(_ /âR _)Æ;
val		€z_real_expon› =		Ò(_ ^âR _)Æ;
val		€z_bool_real_less› =	Ò(_ real_less _)Æ;
val		€z_bool_real_less_eq› =	Ò(_ real_less_eq _)Æ;
val		€z_bool_real_greater› =	Ò(_ real_greater _)Æ;
val		€z_bool_real_greater_eq› =	Ò(_ real_greater_eq _)Æ;
=TEX

\subsection{Z Expressions}
The following function allows many of the Z constructor functions to be presented in a way which is visually appealing.
The {\it ts} argument represents a substitution, e.g., 
=INLINEFT
[(Ò1Æ, "a"), (Ò6Æ, "b")]
=TEX
; the second argument represents a template term containing an instance
of the Z term we want to construct using the variables from the substitution
as operands, e.g.,
=INLINEFT
Òa .. bÆ
=TEX
; the result is the desired term, e.g.,
=INLINEFT
Ò1 .. 6Æ
=TEX
.
The types of the template operator are instantiated as necessary
to match the type of the required actual operands.

=SML
fun €cn_subst› (ts : (TERM * string) list) (tm : TERM) : TERM = (
let	val freevars = frees tm;
	val fvs = map dest_var freevars;
	val newtys = map (fn (tm,c) => (c, type_of tm)) ts;
	val tymap = map (fn (n, ty) => (ty,lassoc3 fvs n)) newtys;
	val tymap' = (fn (t1,t2) => type_match
		(mk_ctype ("TYPE",t1)) (mk_ctype("TYPE",t2))) (split tymap);
	val tm_inst = inst [] tymap' tm;
	val namemap = map (fn (tm, s) => (tm, mk_var(s, lassoc3 newtys s))) ts;
in
	subst namemap tm_inst
end);
=TEX


=SML
val €zsucc› : Z_EXP = ÒsuccÆ;
=TEX
In {\it zid}, the auxiliary function {\it aux} implements the retry technique
that supports access to variables in enclosing package or subprogram bodies.
Only one level of retry is supported (since the SPARK rules don't allow nesting
of package names in this context).
=SML
fun €zid› (env : CN_ENV) (id : Z_ID) : Z_EXP = (
	let	fun aux retry id1 = (
			find (TypeInference.get_ti_context ()) (fn t => fst(dest_var t) = id)
			handle Fail _ => 
			case env id1 of
				Value (ty, EIEnvRetry id2) => 
					if retry
					then aux false id2
					else fail "zid" 508021 [fn()=>id]
			|	Value (ty, EIEnvVar _) => mk_z_lvar(id1, ty, [])
			|	Value (ty, EIEnvAuxVar _) => mk_z_lvar(id1, ty, [])
			|	Value (ty, _) => mk_z_gvar(id, ty, [])
			|	Nil => fail "zid" 508021 [fn()=>id]
		);
	in	aux true id
	end
);
=TEX
=SML
val €z_num› : INTEGER -> Z_EXP = mk_z_signed_int;
=TEX
The following could be improved when more support for Z reals is
available.
=SML
val €z_real_term› : TERM = Òa e bÆ;
fun €z_real› (i : INTEGER, e : INTEGER) : Z_EXP = (
	cn_subst
	[(mk_z_signed_int i, "a"), (mk_z_signed_int e, "b")]
	z_real_term
);
=TEX
=SML
val €z_real_to_integer_term› : TERM = Òreal_to_integer aÆ;
fun €z_real_to_integer› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_real_to_integer_term
);
=TEX
=SML
val €z_integer_to_real_term› : TERM = Òinteger_to_real aÆ;
fun €z_integer_to_real› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_integer_to_real_term
);
=TEX
=SML
val €z_string› : string -> Z_EXP = mk_z_string;
=TEX
=SML
val €z_tfun_term› : TERM = Òa ≠ bÆ;
fun €z_tfun› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_tfun_term
);
=TEX
=SML
val €z_pfun_term› : TERM = Òa ﬂ bÆ;
fun €z_pfun› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_pfun_term
);
=TEX
=SML
val €z_rng_term1› : TERM = Òa .. bÆ;
val €z_rng_term2› : TERM = Òa ..âR bÆ;
fun €z_rng› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term1
	handle Fail _ =>
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term2
);
=TEX
=SML
val €z_dom_term› : TERM = Òdom aÆ;
fun €z_dom› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_dom_term
);
=TEX
=SML
val €z_dom_res_term› : TERM = Òa Ú bÆ;
fun €z_dom_res› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_dom_res_term
);
=TEX
=SML
val €z_inv_term› : TERM = Òa Á~ÍÆ;
fun €z_inv› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_inv_term
);
=TEX
=SML
val €z_id_rel_term› : TERM = Òid aÆ;
fun €z_id_rel› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_id_rel_term
);
=TEX
=SML
val €z_size_term› : TERM = Ò# aÆ;
fun €z_size› (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_size_term
);
=TEX
=SML
val €z_empty_set_term› : TERM = Ò{}Æ;
fun €z_set› ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_setd(type_of e, exps)
) | z_set _ = z_empty_set_term;
=TEX
=SML
val €z_set_minus_term› : TERM = Òa \ bÆ;
fun €z_set_minus› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_set_minus_term
);
=TEX
=SML
fun €z_set_comp› (zdecl : Z_DECL, p : Z_EXP) : Z_EXP = (
let	val dec = (fst o dest_z_dec) zdecl
			handle _ =>
			  error "z_set_comp" 508023 [fn()=>string_of_term zdecl];
	val zdexp = case dec of
		[dec] => dec
		|_ => mk_z_tuple dec;
	val tm = mk_z_seta (mk_z_decl [zdecl], p, zdexp);
	val side = seta_gen_semantic_const tm;
in
	tm
end
);
=TEX
=SML
val €z_power_term› : TERM = Òa Á b ÍÆ;
fun €z_power› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_power_term
);
=TEX
=SML
val €z_rel_comp_term› : TERM = Òa ª bÆ;
fun €z_rel_comp› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_rel_comp_term
);
=TEX
=SML
val €z_empty_seq_term› : TERM = Òß¢Æ;
fun €z_seq› ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_ß¢(type_of e, exps)
) | z_seq _ = z_empty_seq_term;
=TEX
=SML
val €z_cross_term› : TERM = Òa ∏ bÆ;
fun €z_cross› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_cross_term
);
=TEX
=SML
fun €z_many_cross› (tms : Z_EXP list) : Z_EXP = (
	case	tms of
		[tm] => tm
	|	_ => (
		let	val prod = mk_z_∏ tms;
		in	∏_gen_semantic_const prod;
			prod
		end
	)
);
=TEX
=SML
val €z_override_term› : TERM = Òa ´ bÆ;
fun €z_override› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_override_term
);
=TEX
=SML
val €z_union_term› : TERM = Òa ¿ bÆ;
fun €z_many_union› (exps : Z_EXP list) : Z_EXP = (
let	fun non_empty (e::rest) = (
		if (((length o snd o dest_z_setd) e) = 0 handle _ => false)
		then
			non_empty rest
		else
			e::non_empty rest
	) | non_empty _ = [];
	fun aux (exps as e1::e2::rest) = (
		cn_subst [(e1, "a"), (aux (e2::rest), "b")] z_union_term
	) | aux [e] = e
	  | aux _ = error "z_many_union" 508024 [];
in
	(aux o non_empty) exps
end
);
=TEX
=SML
fun €z_binding› (cmpvals : (string * Z_EXP) list) : Z_EXP = (
	let	val bdg = mk_z_binding cmpvals;
	in	binding_gen_semantic_const bdg;
		bdg
	end
);
=TEX
=SML
fun €z_tuple› ([exp] : Z_EXP list) : Z_EXP = (
	exp
) | z_tuple (exps : Z_EXP list) : Z_EXP = (
	let	val tuple = mk_z_tuple exps;
	in	tuple_gen_semantic_const tuple;
		tuple
	end
);
=TEX
The following function constructions a Z application given a function
and its argument (which will be a pair if we are constructing an application
of a binary operator).
If necesary, the type of the function is instantiated to match that of the argument.
=SML
fun mk_and_chk_z_app (fx as (f: Z_EXP, x : Z_EXP)) : Z_EXP = (
	mk_z_app fx handle Fail _ => (
		let	val ty = hd(dest_z_tuple_type
					(dest_z_power_type (type_of f)));
			val tysubs = type_match (type_of x) ty;
			val f' = inst [] tysubs f;
		in	mk_z_app (f', x)
		end
	) handle Fail _ => term_fail "trans_exp" 508071 [f, x]
);
=TEX
=SML
val €z_unary_exp› : (Z_EXP * Z_EXP) -> Z_EXP = mk_and_chk_z_app;
=TEX
=SML
fun €z_bin_exp› (left : Z_EXP, bop : Z_EXP, right : Z_EXP) : Z_EXP = (
	mk_and_chk_z_app (bop, mk_z_tuple[left, right])
);
=TEX
=SML
fun €z_fun_call› (exp :Z_EXP, exps : Z_EXP list) : Z_EXP = (
	case exps of
	[] =>	exp
	|[e] =>		mk_and_chk_z_app (exp, e)
	|_ => (
		let	val tup = mk_z_tuple exps;
			val side = tuple_gen_semantic_const tup;
		in
			mk_and_chk_z_app (exp, tup)
		end
	)
);
=TEX
=SML
val €z_selection› : (Z_EXP * Z_ID) -> Z_EXP = mk_z_selâs;
=TEX
=SML
val €z_maplet_term› : TERM = Òa Ì bÆ;
fun €z_maplet› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_maplet_term
);
=TEX
=SML
val €z_powerset› : Z_EXP -> Z_EXP = mk_z_;
=TEX
=SML
fun €other_z_exp› (exp : Z_EXP) : Z_EXP = exp;
=TEX

\subsection{Z Predicates}
=SML
val €z_true› : Z_PRED = mk_z_true;
=TEX
=SML
val €z_eq› : (Z_EXP * Z_EXP) -> Z_PRED = mk_z_eq;
=TEX
=SML
val €z_and› : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_±;
=TEX
=SML
fun €z_many_and› ((exps as e1::e2::rest) : Z_PRED list) : Z_PRED = (
	mk_z_± (e1, z_many_and (e2::rest))
) | z_many_and [e] = e
  | z_many_and _ = error "z_many_and" 508024 [];
=TEX
=SML
val €z_elem› : (Z_EXP * Z_EXP) -> Z_EXP = mk_z_ç;
=TEX
=SML
val €z_notelem_term› : TERM = Òa é bÆ;
fun €z_notelem› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_notelem_term
);
=SML
val €z_noteq_term› : TERM = Òa Ω bÆ;
fun €z_noteq› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_noteq_term
);
=TEX

=SML
val €z_less_eq_term› : TERM = Òa º bÆ;
fun €z_less_eq› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_less_eq_term
);
=TEX

=SML
val €z_greater_term› : TERM = Òa > bÆ;
fun €z_greater› (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_greater_term
);
=TEX

=SML
fun €z_forall› (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_µ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
fun €z_exists› (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_∂ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
val €z_imp› : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_¥;
=TEX

=SML
val €z_mem› : (Z_EXP * Z_EXP) -> Z_PRED = mk_z_ç;
=TEX

=SML
fun €other_z_pred› (z_pred : Z_PRED) : Z_PRED = z_pred;
=TEX

\subsection{Z Paragraphs}
=SML
fun €z_ax› (id : Z_ID, exp : Z_EXP, preds : Z_PRED list) : PARAINFO = (
	let	val ty = dest_z_power_type (type_of exp);
		val decl = mk_z_decl[mk_z_dec([mk_var(id, ty)], exp)];
		val pred = case preds of
				[] => Nil
			|	_ => Value (list_mk_± preds);
	in	AxDesInfo([], decl, pred, [(id, ty)])
	end
);
=TEX
=SML
fun €z_eq_eq› (id : Z_ID, exp : Z_EXP) : PARAINFO = (
	AbbDefInfo (id, [], exp)
);
=TEX
=SML
fun €z_given› (id : Z_ID) : PARAINFO = (
	GivenSetInfo ([id], Nil)
);
=TEX
=SML

fun €z_schema› (name : Z_ID, decls : Z_DECL list) : PARAINFO = (
let	val z_sch = mk_z_h_schema(mk_z_decl decls, z_true);
	val side = schema_gen_semantic_const z_sch;
in
	AbbDefInfo (name, [], z_sch)
end
);
=TEX
\section{SUPPORT FOR TRANSLATION OF EXPRESSIONS}
It is convenient to take some of the work for translation of
expressions first rather than interleaved the main  mutual recursion
for {\it trans\_exp}. This section contains this material.

\subsection{{\it tmark\_of\_prefix}}
{\it tmark\_of\_prefix} requires some auxiliary functions. The first batch
of these pick apart the defining axiom for a Z term
that is the translation of a SPARK type mark and return
the term that is the translation of a the type mark
for a component selected from the original SPARK type.
=SML
fun €do_array_def› (tm : Z_EXP) : Z_EXP = (
	let	val t1 = snd(dest_eq tm);
		val (_, _, ts) = dest_z_gvar t1;
	in	hd(tl ts)
	end
);
=TEX
=SML
fun €do_uncon_array_def› (tm : Z_EXP) : Z_EXP = (
	let	val t1 = dest_z_(snd(dest_z_ç(fst(dest_± tm))));
		val (_, _, ts) = dest_z_gvar t1;
	in	hd(tl ts)
	end
);
=TEX
=SML
fun €do_subtype_con_def› (tm : Z_EXP) : Z_EXP = (
	let	val t1 = snd(dest_eq tm);
		val (decl, _, _) = dest_z_seta t1;

	in	(snd o dest_z_dec o hd o dest_z_decl) decl
	end
);
=TEX
=SML
fun €do_subtype_uncon_def› (tm : Z_EXP) : Z_EXP = (
	snd(dest_eq tm)
);
=TEX
=SML
fun €do_rec_def› (tm : Z_EXP) (sel : string) : Z_EXP = (
	let	val t1 = snd(dest_eq tm);
		val decs = (dest_z_decl o fst o dest_z_h_schema) t1;
		fun do_decs decs = (
			let	val (ts, t) = dest_z_dec (hd decs);
			in	if	any ts (fn t => fst(dest_var t) = sel)
				then	t
				else	do_decs (tl decs)
			end
		)
	in	do_decs decs
	end
);
=TEX
The data type {\it SEL} represents a single component selection.
For arrays, the index value is not relevant to the type calculation
for a record selection, we need to know the component name:
=SML
datatype €SEL› = ArraySel | RecordSel of ID;
=TEX
The next auxiliary function takes a list of selectors and applies
them to a Z expression representing a base type to give the
Z expression for the selected type (as the translation of a type
mark --- if we don't get a global variable, then the SPARK program
is ill-formed in some way.)
=SML
fun €indexed_type› (base : Z_EXP) (sels : SEL list) : Z_EXP = (
	case sels of
	[] 	=>	(base
	) | ArraySel :: more
		=> (
		let	val def = snd (dest_thm (z_get_spec base));
			fun go tm = (
				(do_array_def tm) handle Fail _ =>
				(do_uncon_array_def tm) handle Fail _ =>
				(go 	((do_subtype_con_def tm) handle Fail _ =>
					 (do_subtype_uncon_def tm)))
			);
		in	indexed_type (go def) more
		end
	) | RecordSel s :: more
		=> (
		let	val def = snd (dest_thm (z_get_spec base));
			fun go tm = (
				(do_rec_def tm s) handle Fail _ =>
				(go (do_subtype_uncon_def tm))
			);
		in	indexed_type (go def) more
		end
	)
);
=TEX
Using {\it indexed\_type} we can now define {\it tmark\_of\_prefix}
as required by the formal specification.
=SML
fun €tmark_of_prefix› (env : CN_ENV) (zpfx : Z_EXP) : Z_ID = (
	let	fun strip_prefix sels tm = (
			case dest_z_term tm of
				ZApp(t, _) => strip_prefix (ArraySel :: sels) t
			|	ZSelâs(t, s) => strip_prefix (RecordSel s :: sels) t
			|	ZLVar(s, _, _) => (s, sels)
			|	ZGVar(s, _, _) => (s, sels)
			|	_ => term_fail "tmark_of_prefix" 508028 [zpfx]
		);
		val (var, sels) = strip_prefix [] zpfx;
		val (base_tmark, sels') = case env var of
			Value(_, EIEnvVar x) => (x, sels)
		|	Value(_, EIEnvConstant x) => (x, sels)
		|	Value(_, EIEnvFunction (_, _, x)) => (
				(x, tl sels)
				handle Fail _ => fail "tmark_of_prefix" 508028 []
		) |	_ => fail "tmark_of_prefix" 508028 [];
	in	case dest_z_term(indexed_type (mk_z_gvar(base_tmark, BOOL, [])) sels') of
			ZGVar(tmark, _, _) => tmark
		|	_ => fail "tmark_of_prefix" 508028 []
	end
);
=TEX
\subsection{Calculating Base Types}
=SML
local
val €z_u› = ÒUÆ;
fun €base_def› (n : Z_EXP) : Z_EXP = (
	let	val rhs = snd(dest_z_eq(snd(dest_thm(z_get_spec n))));
	in	(term_match rhs z_u; n)
		handle Fail _ =>
	let	fun aux r = (
			let	val (decl, _, _) = dest_z_seta r;
			in	(snd o dest_z_dec o hd o dest_z_decl) decl
			end	handle Fail _ => r
		);
		val supertype = aux rhs;
	in	if	is_z_gvar supertype
		then	base_def supertype
		else	n
	end
	end	handle Fail _ => n
);
in
fun €base_type› (t : Z_EXP) : TMARK OPT = (
	let	val n = base_def t;
		val ty = dest_z_power_type (type_of n);
		val (v, _, _)  = dest_z_gvar n;
	in	if	is_z_power_type ty orelse is_z_schema_type ty
		then	Value v
		else	let	val vsucc = mk_z_gvar(v ^ "vSUCC", BOOL, []);
			in	if	is_eq(snd(dest_thm(z_get_spec vsucc)))
				then	Value v
				else	Nil
			end
	end	handle Fail _ => Nil

);
end;
=TEX
\subsection{Integer Literals}\label{IntegerLiterals}

The translation of integer literals is non-trivial and several supporting functions for the translation of integer literals are introduced in this section. The function $trans\_int$ is introduced at the end of this section.
=SML
local
=TEX
\subsubsection{Support for $trans\_int$}

=SML
open	CaseIndependence;
open	Lex;
type €NUMBERS› = string list;
type €NUMERIC› =
		{base : NUMBERS, m : NUMBERS, expon : NUMBERS};
=TEX

\subsubsection{Phase 1: Recognising Integer Literals}

Integer literals may not contain a point and must have a minus sign in the exponent.

Failures in the supporting functions below are all caught and handled in
{\it trans\_int} (which can include the literal being translated in its error message).

In the exponent part when there is a sign, it is just copied into the number. The parser has already ensured that $+$ and $-$ can only appear at the start of an exponent, so a further check is not required here.
=SML
fun €recog_exponent_part› (dec as {base,m,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_exponent_part ({base=base,m=m, expon=expon@[c]}, rest)
	else case c of

		"_" =>	recog_exponent_part (dec, rest)
		|"+" => recog_exponent_part ({base=base,m=m, expon=expon@[c]}, rest)
		|_ =>	fail "trans_int" 508025 []

) | recog_exponent_part (other, []) = (
	(other, [])
);
=TEX
=SML
fun €recog_based› (nb as {base,m,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based ({base=base,m=m@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_based (nb, rest)
		|"#" => recog_numeric true (nb, rest)
		|_ =>	fail "trans_int" 508025 []

) | recog_based (other, []) = (
	fail "recog_based" 0 []
)
=SML
and €recog_numeric› (have_base : bool) (num as {base,m,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_numeric have_base ({base=base,m=m@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_numeric have_base (num, rest)
		|"e" => recog_exponent_part (num, rest)
		|"E" => recog_exponent_part (num, rest)
		|_ =>	if not have_base andalso c = "#"
			then	recog_based ({base=m, m=[], expon=expon}, rest)
			else	fail "trans_int" 508025 []
) | recog_numeric _ other = other;
=TEX
\subsubsection{Phase 2: Generating Integer Literals}

The following gives a lookup table for extended digits to values upto 16.

i.e., $[("0", 0), ("1", 1),...("F", 15)]$.
=SML
val €extended_digits› : (string * INTEGER) list = (
	combine
		(map string_of_int (interval 0 9)@["A","B","C","D","E","F"])
		(map integer_of_int (interval 0 15))
);
=TEX
=SML
val ten = @@"10";
fun €based_to_integer› (base:int) (sl:string list) : INTEGER = (
	if base = 10
	then	(natural_of_string o implode) sl handle _ => zero
	else	let	val valid = extended_digits to (base-1);
			val sl' = map CaseIndependence.to_upper sl;
			val f = lassoc3 valid;
			val ibase = integer_of_int base;
			fun aux (c::rest) = (
				f c @+ ibase @* aux rest
			) | aux _ = zero;
		in
			(aux o rev) sl' handle _ =>
				fail "trans_int" 508025 []
		end
);
=TEX
=SML
fun €signed_nat_of_numbers› (sl : NUMBERS) : int = (
	let	val f = nat_of_string o implode;
	in
		case sl of
		("+"::n) => f n
		|("-"::n) => ~(f n)
		|_ => f sl
	end
);
=TEX
=SML
fun €basepow› (base : int) (n : int) : INTEGER = (
	let	val ibase = integer_of_int base;
		fun aux n = (
			if	n = 0
			then	one
			else	ibase @* aux (n-1)
		);
	in	aux n
	end
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun €convert_base_exp› ((base, m, expon) : (int*INTEGER*int)) : INTEGER = (
	if expon >= 0
	then	m @* basepow base expon
	else	fail "trans_int" 508025 []
);
=TEX
=SML
=TEX
=SML
fun €numeric_to_int_lit› ({base,m,expon} : NUMERIC) : INTEGER = (
let	val nbase = (nat_of_string o implode) base handle _ => 10;
	val nm = based_to_integer nbase m;
	val nexpon = signed_nat_of_numbers expon handle _ => 0;
in
	if	nbase = 10 andalso nexpon = 0
	then	nm
	else	convert_base_exp (nbase,nm,nexpon)
end);
=TEX
\subsubsection{The Function $trans\_int$}
=SML
in (* of local ... in *)
=TEX
=SML
fun €trans_int› (i : INT_REAL_LIT) : INTEGER = (
	( (numeric_to_int_lit o fst o recog_numeric false)
		({base=[], m=[], expon=[]}, explode i)
	) handle Fail _ => fail "trans_int" 508025 [fn()=>i]
);
=TEX
=SML
end (* of local ... in *);
=TEX
=TEX
\subsubsection{The Function $exp\_int\_lit$}
=SML
fun €exp_int_lit› (n : INT_REAL_LIT) : Z_EXP = (
	z_num (trans_int n)
);
=TEX
=TEX
\subsection{Real Literals}{\label{RealLiterals}
\subsubsection{The Function $trans\_real$}
=SML
local
	open Lex;
in
fun trans_real (r : INT_REAL_LIT) : INTEGER * INTEGER = (
	let	fun adjust ([] : string list, exp : int) = (
			(["0"], 0)
		) | adjust ("0"::more, exp) = (
			adjust(more, exp + 1)
		) | adjust (other, exp) = (
			(other, exp)
		);
		fun exponent (acc, exp) [] = (
			fail "trans_real" 508025 [fn _ => r]
		) | exponent (acc, exp) chs = (
			let	val (acc', exp') = adjust (acc, exp);
				val i = integer_of_string (implode(rev acc'));
				val e = integer_of_string (implode chs);
			in	(i, e @+ integer_of_int exp')
			end	handle Fail _ => fail "trans_real" 508025 [fn _ => r]
		);
		fun  after_point (acc, exp) (ch :: chs) = (
			if	is_digit ch
			then	after_point (ch::acc, exp - 1) chs
			else if	ch = "E" orelse ch = "e"
			then	exponent (acc, exp) chs
			else	fail "trans_real" 508025 [fn _ => r]
		) | after_point (acc, exp) [] = (
			let	val (acc', exp') = adjust (acc, exp);
				val i = integer_of_string (implode(rev acc'));
			in	(i, integer_of_int exp')
			end	handle Fail _ => fail "trans_real" 508025 [fn _ => r]
			
		);
		fun before_point acc ("." :: chs) = (
			after_point (acc, 0) chs
		) | before_point acc (ch :: chs) = (
			if	is_digit ch
			then	before_point (ch::acc) chs
			else	fail "trans_real" 508025 [fn _ => r]
		) | before_point acc [] = (
			after_point (acc, 0) []
		);
	in	before_point [] (explode r)
	end
);
end;
=TEX
\subsubsection{The Function $exp\_real\_lit$}
=SML
fun €exp_real_lit› (n : INT_REAL_LIT) : Z_EXP = (
	z_real (trans_real n)
);
=TEX
\subsection{Character Literals}{\label{CharacterLiterals}
\subsubsection{The Function $exp\_char\_lit$}
=SML
fun €exp_char_lit› (n : CHAR_LIT) : Z_EXP = (
	z_unary_exp(z_char_lit, z_string n)
);
=TEX
\subsection{String Literals}{\label{StringLiterals}
\subsubsection{The Function $exp\_string\_lit$}
=SML
fun €exp_string_lit› (n : STRING_LIT) : Z_EXP = (
	z_unary_exp(z_string_lit, z_string n)
);
=TEX
\subsection{Unary Operators}
The empty list for unary addition means that no operator is required.
=SML
fun €unary_ops› (uop : UNARY_OP) : Z_EXP list = (
	case uop of
	UOSparkUnaryMinus => [z_unary_minus, z_real_unary_minus]
	|UOSparkNot => [z_bool_not, z_array_not]
	|UOSparkAbs => [z_abs, z_real_abs]
	|USSparkUnaryAdd => []
);
=TEX
The following implements overload resolution for unary operators.
Note that we let {\it z\_unary\_exp} report the error if
none of the alternatives is well-typed (the case of an empty operand
to {\it try\_it} is for the special case of unary addition).

Also note that the expression returned is the actual translation of
the whole unary operator application, not just the operator.

=SML
fun €trans_unary_op› (uop : UNARY_OP, zright : Z_EXP) : Z_EXP = (
	let	val ops = unary_ops uop;
		fun try_it [] = zright
		|   try_it [rator] = (
			z_unary_exp(rator, zright)
		) | try_it (rator::more) = (
			z_unary_exp(rator, zright)
			handle Fail _ => try_it more
		);
	in	try_it ops
	end
);
=TEX
\subsection{Binary Operators}
=SML
fun €bin_ops› (bop : BIN_OP) : Z_EXP list = (
	case bop of
	BOSparkAnd => [z_bool_and, z_array_and]
	|BOSparkAndThen => [z_bool_and]
	|BOSparkOr => [z_bool_or, z_array_or]
	|BOSparkOrElse => [z_bool_or]
	|BOSparkXor => [z_bool_xor, z_array_xor]
	|BOSparkEq => [z_bool_eq]
	|BOSparkNotEq => [z_bool_noteq]
	|BOSparkLess => [z_bool_less, z_array_less, z_bool_real_less]
	|BOSparkLessEq => [z_bool_less_eq, z_array_less_eq, z_bool_real_less_eq]
	|BOSparkGreater => [z_bool_greater, z_array_greater, z_bool_real_greater]
	|BOSparkGreaterEq => [z_bool_greater_eq, z_array_greater_eq, z_bool_real_greater_eq]
	|BOSparkAdd => [z_add, z_real_add]
	|BOSparkMinus => [z_minus, z_real_minus]
	|BOSparkTimes => [z_times, z_real_times]
	|BOSparkDiv => [z_intdiv, z_real_div]
	|BOSparkMod => [z_mod]
	|BOSparkRem => [z_rem]
	|BOSparkExpon => [z_expon, z_real_expon]
	|BOSparkMem => [z_bool_mem]
	|BOSparkNotMem => [z_bool_notmem]
	|BOSparkConcat => [z_array_array_cat, z_array_elem_cat, z_elem_array_cat]
);
=TEX
The following implements overload resolution for binary operators.

As for unary operators, the expression returned is the actual translation of
the whole binary operator application, not just the operator.
=SML
fun €trans_bin_op› (bop : BIN_OP, zleft : Z_EXP, zright : Z_EXP) : Z_EXP = (
	let	val ops = bin_ops bop;
		fun try_it [] = fail "trans_bin_op" 508031 []
		|   try_it [rator] = (
			z_bin_exp(zleft, rator, zright)
		) | try_it (rator::more) = (
			z_bin_exp(zleft, rator, zright)
			handle Fail _ => try_it more
		);
	in	try_it ops
	end
);
=TEX
\subsection{Support for Translating Attributes}
The following is based on material taken from the Ada Reference Manual.
It is based on all Ada attributes, not just those mentioned in the list in
Volume 3, section 3.13 of the specification of the Compliance Notation.
The second element gives the Z ``type'' of the translated attribute, for attributes
that are in category B. The second element is {\it Nil} for attributes
that are either supported in category A (in which case the type can be determined
from the definitions in the Z document) or are in category C (in
which case the attribute can only be translated into Z if the user has supplied
a Z paragraph to define it).
=SML
val €ada_attribute_types› : (ID * TERM OPT) list = [
	("ADDRESS", Nil ),
	("AFT", Value ˙_tm ),
	("BASE", Nil ),
	("CALLABLE", Nil ),
	("CONSTRAINED", Nil ),
	("DELTA", Nil ),
	("DIGITS", Nil ),
	("EMAX", Value ˙_tm ),
	("EPSILON", Nil ),
	("FIRST", Nil ),
	("FORE", Value ˙_tm ),
	("IMAGE", Nil ),
	("LARGE", Nil ),
	("LAST", Nil ),
	("LENGTH", Nil ),
	("MACHINE_EMAX", Value ˙_tm ),
	("MACHINE_EMIN", Value ˙_tm ),
	("MACHINE_MANTISSA", Value ˙_tm ),
	("MACHINE_OVERFLOWS", Value ˙_tm ),
	("MACHINE_RADIX", Value ˙_tm ),
	("MACHINE_ROUNDS", Value ˙_tm ),
	("MANTISSA", Value ˙_tm ),
	("POS", Nil ),
	("PRED", Nil ),
	("RANGE", Nil ),
	("SAFE_EMAX", Value ˙_tm ),
	("SAFE_LARGE", Nil ),
	("SAFE_SMALL", Nil ),
	("SIZE", Value ˙_tm ),
	("SMALL", Nil ),
	("STORAGE_SIZE", Nil ),
	("SUCC", Nil ),
	("TERMINATED", Nil ),
	("VAL", Nil ),
	("VALUE", Nil ),
	("WIDTH", Nil )
];
=TEX
=SML
val €attr_type_dict› : TERM S_DICT = 
	map (fn (s, t) => (s, force_value t)) (
		ada_attribute_types drop (fn (_, Nil) => true | _ => false));
=TEX
The following function is used to dismantle the prefix in something like:
{\it P'BASE'FIRST}.
=SML
fun €strip_attr_prefix› (pfx : EXP) : EXP * ATTRIB list = (
	let	fun aux acc (EAttribute{prefix, attribute_desig=ADAttrib att}) = (
			aux (att::acc) prefix
		) | aux acc other = (other, acc);
	in	aux [] pfx
	end			
);
=TEX
\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{Translating Identifiers}
=SML
fun €trans_id› (id : ID) : Z_ID = (

let	fun aux (c::rest) = (
		case c of
		"." => "o"::aux rest
		|"'" => "v"::aux rest
		|_ => c::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
);
=TEX
=SML
val		€zbase› = trans_id "BASE";
val		€zfst› = trans_id "FIRST";
val		€zlst› = trans_id "LAST";
val		€zsuc› = trans_id "SUCC";
val		€zpred› = trans_id "PRED";
val		€zpos› = trans_id "POS";
val		€zval› = trans_id "VAL";
val		€zlength› = trans_id "LENGTH";
val		€zrange› = trans_id "RANGE";
val		€zdigits› = trans_id "DIGITS";
val		€zdelta› = trans_id "DELTA";
=TEX
=SML
fun €dimen› (zid : Z_ID, n : int) : Z_ID  = (
	if n > 0 then zid ^ "v" ^ string_of_int n else zid
);
=TEX
=SML
fun €exp_id› (env : CN_ENV) (ident : ID) : Z_EXP = (
	zid env (trans_id ident)
);
=TEX
\subsection{Translating Aggregates (Positional Array)}
=SML
type €ARRAY_AGG_ENV› = {tname : TMARK, this : int, max : int};
=TEX
=SML
fun €array_dim› (env : CN_ENV) (tmark : TMARK) : int = (
	let	val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark);
	in	(length o dest_z_tuple_type o hd o dest_z_tuple_type o
			dest_z_power_type o dest_z_power_type) ztype
	end	handle Fail _ => 1
);
=TEX
=SML
fun €array_first› (env : CN_ENV) ({this, max, tname} : ARRAY_AGG_ENV) : Z_EXP = (
	if	max = 1
	then	zid env (trans_id tname ^^ zfst)
	else	zid env (dimen(trans_id tname ^^ zfst, this))
);
=TEX
=SML
fun €array_range› (env : CN_ENV) ({this, max, tname} : ARRAY_AGG_ENV) : Z_EXP = (
	if	max = 1
	then	zid env (trans_id tname ^^ zrange)
	else	zid env (dimen(trans_id tname ^^ zrange, this))
);
=TEX
=SML
fun €z_array_agg› (num : int) : Z_ID = (
	"array_agg" ^ (string_of_int num)
);
=TEX
=SML
fun €mk_array_agg›  (num : int, zex : Z_EXP) : Z_EXP = (
	if	num = 1
	then	zex
	else	let	val fun_name = z_array_agg num;
			val ty = force_value(get_const_type (bind_gvar_name fun_name));
			val (gty, rty) = dest_≠_type ty;
			val us = map mk_u (dest_z_tuple_type gty);
			val fun_exp = mk_z_gvar(fun_name, rty, us);
			val (arg_ty, res_ty) = case dest_z_tuple_type
						(dest_z_power_type (type_of fun_exp)) of
					[ty1, ty2] => (ty1, ty2)
				|	_ => fail "" 0 [] (* caught immediately *);
			val ty_map = type_match (type_of zex) arg_ty;
		in	mk_z_app(inst [] ty_map fun_exp, zex)
		end	handle Fail _ => term_fail "mk_array_agg" 508058 [zex]
);
=TEX
=SML
fun €exp_array_agg_pos› (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, comps} : EXP AGG_POS) : Z_EXP = (
let	val zop = z_minus;
	val zleft = z_num one;
	val zright = array_first env aa_env;
	val aa_env' = {this = this + 1, max = max, tname = tname};
	val zseq = map (trans_array_agg_exp env aa_env') comps;
in
	z_rel_comp(z_power(zsucc, z_bin_exp(zleft,zop, zright)), z_seq zseq)
end
)
=TEX
\subsection{Translating Aggregates (Positional Array with Others)}
=SML
and €exp_array_agg_pos_others› (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({agg_pos as {tmark, comps},
		others} : EXP AGG_POS_OTHERS) : Z_EXP = (
	z_override(
		trans_array_agg_exp env aa_env (EArrayAggOthers {tmark=tmark,others=others}),
		trans_array_agg_exp env aa_env (EArrayAggPos agg_pos))
)
=TEX
\subsection{Translating Aggregates (Positional Array with Just Others)}
=SML
and €exp_array_agg_others› (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, others={others=ot}} : EXP AGG_OTHERS) : Z_EXP = (
let	val aa_env' = {this = this + 1, max = max, tname = tname};
in
	z_cross(array_range env aa_env, z_set [trans_array_agg_exp env aa_env' ot])
end
)
=TEX
\subsection{Translating Aggregates (Named Array)}
=SML
and €trans_named_assoc›	(env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
				({choice,comp} : (AGG_CHOICE,EXP) NAMED_ASSOC)
					: Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		ACAggChoiceRange (DRRange range) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
			end
		|ACAggChoiceRange (DRConstrained{range=range,...}) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
			end
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp =>
			trans_exp env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choice;
	val zsingles = z_set (aux_singles choice);
	val aa_env' = {this = this + 1, max = max, tname = tname};
in
	z_cross (z_many_union(zranges @ [zsingles]), z_set[trans_array_agg_exp env aa_env' comp])
end
)
=TEX
=SML
and €exp_array_agg_named› (env : CN_ENV) (aa_env as {this, max, tname} : ARRAY_AGG_ENV)
	({tmark as _, named_assocs} : (AGG_CHOICE,EXP) AGG_NAMED) : Z_EXP = (
	z_many_union (map (trans_named_assoc env aa_env) named_assocs)
)
=TEX
\subsection{Translating Aggregates (Named Array with Others)}
=SML
and €exp_array_agg_named_others› (env : CN_ENV) (aa_env : ARRAY_AGG_ENV)
		({agg_named as {tmark, ...}, others}
		: (AGG_CHOICE,EXP) AGG_NAMED_OTHERS) : Z_EXP = (
	z_override(trans_array_agg_exp env aa_env (EArrayAggOthers {tmark=tmark, others=others}),
		trans_array_agg_exp env aa_env (EArrayAggNamed agg_named))
)
=TEX
\subsection{Translating Aggregates (Positional Record)}
=SML
and €exp_rec_agg_pos_z›
		(env : CN_ENV) ((tmark as Value tm, comps) : TMARK OPT * Z_EXP list)
		: Z_EXP = (
let	val record_components = (
		case env tm of
			Value (_, EIEnvRecordType (cmps as _::_)) => cmps
		|	_ => fail "exp_rec_agg_pos_z" 508026 [fn()=>tm]
	);
	val zbinds = combine record_components comps
		handle Fail _ => fail "exp_rec_agg_pos" 508027 [fn()=>tm];
in
	z_binding zbinds
end
) | exp_rec_agg_pos_z _ _ = fail "trans_exp" 508054 []
=TEX
\subsection{Translating Aggregates (Named Record)}
=SML
and €exp_rec_agg_named› (env : CN_ENV) ({tmark as Value tm, named_assocs}
		: (AGG_CHOICE,EXP) REC_AGG_NAMED) : Z_EXP = (
let	fun named_assoc_to_ids_exp {choice, comp} = (
	let	fun aux (ch::rest) comp = (
			case ch of
			ACAggChoiceSingle exp => (
					(name_to_tmark exp, 
					 trans_exp env comp)::aux rest comp
			) |_ => fail "exp_rec_agg_named" 508052 []
		) | aux _ _ = [];
	in
		aux choice comp 
	end);
	val zbinds = flat (map named_assoc_to_ids_exp named_assocs);
in	z_binding zbinds
end
) | exp_rec_agg_named _ _ = fail "trans_exp" 508054 []
=TEX
\subsection{Translating Aggregates (Generally)}
Note that the failure case below will never happen, since caller must always
have looked inside the expression to get the type mark out.
The test using less-than rather than not-equals defends the code from
non-termination if something weird goes wrong in {\it array\_dim}.
=SML
and €trans_array_agg_exp› (env : CN_ENV)
	(aa_env as {this, max, ...} : ARRAY_AGG_ENV) (e : EXP) : Z_EXP = (
	if	this < max + 1
	then	case e of
		EArrayAggPos ap => exp_array_agg_pos env aa_env ap
	|	EArrayAggPosOthers apo =>  exp_array_agg_pos_others env aa_env apo
	|	EArrayAggOthers ao =>  exp_array_agg_others env aa_env ao
	|	EArrayAggNamed an =>  exp_array_agg_named env aa_env an
	|	EArrayAggNamedOthers ano => exp_array_agg_named_others env aa_env ano
	|	_ => fail "trans_array_agg_exp" 508054 []
	else	trans_exp env e
)
=TEX
\subsection{Translating Unary Expressions}
=SML
and €exp_unary_exp› (env : CN_ENV) ({uop, right} : EXP UNARY_EXP) : Z_EXP = (
	trans_unary_op(uop, trans_exp env right)
)
=TEX

\subsection{Translating Binary Expressions}
=SML
and €exp_bin_exp› (env : CN_ENV) ({left, bop, right} : EXP BIN_EXP) : Z_EXP = (
	 trans_bin_op(bop, trans_exp env left, trans_exp env right)
)
=TEX
\subsection{Translating Membership of a Range}
=SML
and €exp_mem_range› (env : CN_ENV) ({left, mop, range as RRange _} : EXP MEM_RANGE)
		: Z_EXP = (
let	val {lo=lo, hi=hi} = dest_range range;
	val zright = z_rng(trans_exp env lo, trans_exp env hi);
in
	trans_bin_op(mop, trans_exp env left, zright)
end
) | exp_mem_range (env : CN_ENV) ({left, mop, range as RRangeAttr e} : EXP MEM_RANGE)
		: Z_EXP = (
let	val  zright = trans_exp env e;
in
	trans_bin_op(mop, trans_exp env left, zright)
end
)
=TEX

\subsection{Translating Attributes}
=SML
and €exp_attrib› (env : CN_ENV) ({prefix, attribute_desig=ADAttrib att}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
let	val (p, atts) = strip_attr_prefix prefix;
in let	val result = (case atts of
		[]	 => (
		let	val ze = zid env (trans_id (name_to_tmark prefix) ^^ trans_id att);
		in	dest_z_gvar ze; ze
		end	handle Fail _ => (
		let	val zp = trans_exp env p;
			val tmk = tmark_of_prefix env zp;
			val ze = zid env (tmk ^^ trans_id att);
		in	dest_z_gvar ze; ze
		end	handle Fail _ => (
				fail "exp_attrib" 508028 []
			))
	)|	["BASE"] => (
		let	val ze = trans_exp env p;
			val tmk = force_value(base_type ze);
		in	zid env (tmk ^^ trans_id att)
		end	handle Fail _ => (
		let	val ze = zid env (trans_id (name_to_tmark p) ^^ zbase ^^ trans_id att);
		in	dest_z_gvar ze; ze
		end	handle Fail _ => (
				fail "exp_attrib" 508028 []
			))
	)|	_ => (fail "exp_attrib" 508028 []
	));
in	result
end	handle Fail _ => (
		let	val attr_ty = force_value (s_lookup att attr_type_dict);
			val zp = trans_exp env p;
			val (zn, _, _) = dest_z_gvar zp
				handle Fail _ => dest_z_lvar zp;
			val sfx = fold (op ^^) (map trans_id atts) (trans_id att);
			val za = zn ^^ sfx;
		in	update_theory_db_with_parainfo (z_ax(za, attr_ty, []));
			zid env za
		end	handle Fail _ =>
				fail "exp_attrib" 508028 []
	)	
end)
=TEX
The following covers $Exp\_Attrib\_Arg$
=SML
  | €exp_attrib› env ({prefix, attribute_desig=ADAttribArg(att,arg)}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
	let	val no_arg = {prefix=prefix, attribute_desig=ADAttrib att};
		val zfun = exp_attrib env no_arg;
	in
	if	trans_id att mem [zfst, zlst, zlength, zrange]
	then
		let	val zarg = trans_exp env arg;
			val (tmk, _, _) = dest_z_gvar zfun;
		in
			zid env (dimen(trans_id tmk, eval_attr_arg zarg))
		end	handle Fail _ => (
			term_fail "exp_attrib" 508028 []
			)
	else
		let	val zargs = [trans_exp env arg];
		in
			z_fun_call (zfun, zargs)
		end
	end
)
=TEX
\subsection{Translating Indexed Components}
=SML
and €exp_indexed_comp› (env : CN_ENV)
	({prefix, index as EArrayAggPos{comps, tmark as Nil}} : EXP INDEXED_COMP)
		: Z_EXP = (
let	val zfun = trans_exp env prefix;
	val zargs = map (trans_exp env) comps;
in
	z_fun_call (zfun, zargs)
end
) |  €exp_indexed_comp› _ _ = (
	fail "exp_indexed_comp" 508056 []
)
=TEX
\subsection{Translating Selected Components}
=SML
and €exp_selected_comp› (env : CN_ENV) ({prefix, selector} : EXP SELECTED_COMP)
		: Z_EXP = (
	z_selection (trans_exp env prefix, trans_id selector)
)
=TEX
\subsection{Translating Functions Calls}
=SML
and €fun_globals› (env : CN_ENV) (zn : Z_ID) : Z_ID list = (
	case env zn of
		Value(_, EIEnvFunction (gs, _, _)) => gs
	| _=>	fail "fun_globals" 508081 [fn()=>zn]
)
=TEX
=SML
and €trans_fun_name› (env : CN_ENV) (n : ID) : Z_EXP = (
	let	val zn = trans_id n;
	in	case fun_globals env zn of
			[] => zid env zn
		|	gs => z_fun_call (zid env zn, map (zid env) gs)
	end
)
=TEX
=SML
and €exp_fun_call› (env : CN_ENV) ({fun_name, args} : EXP FUN_CALL) : Z_EXP = (
	case args of
		[] => trans_fun_name env fun_name
	|	_ => 
	z_fun_call (trans_fun_name env fun_name, map (trans_exp env) args)
)
=TEX
\subsection{Translating Qualified Expressions}
=SML
and €exp_qualified› (env : CN_ENV) ({tmark, exp} : EXP QUALIFIED_EXPRESSION)
	: Z_EXP = (
	trans_exp env exp
)
=TEX
=TEX
\subsection{Translating Type Conversions}
=SML
and €exp_type_conv› (env : CN_ENV) ({tmark, exp} : EXP TYPE_CONVERSION) 
	: Z_EXP = (
	let	val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark]);
		val te = trans_exp env exp;
	in	if	ztype =: z_int_set_type andalso type_of te =: z_int_type
		then	te
		else if	ztype =: z_real_set_type andalso type_of te =: z_real_type
		then	te
		else if	ztype =: z_int_set_type andalso type_of te =: z_real_type
		then	z_real_to_integer te
		else if	ztype =: z_real_set_type andalso type_of te =: z_int_type
		then	z_integer_to_real te
		else	fail "exp_type_conv" 508053 []
	end
)
=TEX
\subsection{Translating Integer Literals}
The function $exp\_int\_lit$ is defined in section \ref{IntegerLiterals}.
\subsection{Translating Character Literals}
The function $exp\_char\_lit$ is defined in section \ref{CharacterLiterals}.
\subsection{Translating String Literals}
The function $exp\_string\_lit$ is defined in section \ref{StringLiterals}.
\subsection{Translating Auxiliary Expressions}
=SML
and €exp_auxiliary_exp› (ae : Z_TM) : Z_EXP = (
	z_predexp_of_z_tm ae
)
=TEX
\subsection{The Function $trans\_exp$}
=SML
and €trans_exp› (env : CN_ENV) ((EId id) : EXP) : Z_EXP = exp_id env id
  | trans_exp env (EIntReal n) = (
		(exp_int_lit n) handle Fail _ => exp_real_lit n
) | trans_exp env (e as EArrayAggPos _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggPosOthers _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggOthers _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggNamed _) = exp_array_agg env e
  | trans_exp env (e as EArrayAggNamedOthers _) = exp_array_agg env e
  | trans_exp env (ERecAggPos {tmark, comps}) =
		exp_rec_agg_pos_z env (tmark, map (trans_exp env) comps)
  | trans_exp env (ERecAggNamed an) = exp_rec_agg_named env an
  | trans_exp env (EUnaryExp ue) = exp_unary_exp env ue
  | trans_exp env (EBinExp be) = exp_bin_exp env be
  | trans_exp env (EMemRange be) = exp_mem_range env be
  | trans_exp env (EAttribute at) = exp_attrib env at
  | trans_exp env (EIndexedComp ic) = exp_indexed_comp env ic
  | trans_exp env (ESelectedComp sc) = exp_selected_comp env sc
  | trans_exp env (EFunCall fc) = exp_fun_call env fc
  | trans_exp env (EAuxiliaryExp ae) = exp_auxiliary_exp ae
  | trans_exp env (EQualifiedExp qe) = exp_qualified env qe
  | trans_exp env (ETypeConversion tc) = exp_type_conv env tc
  | trans_exp env (EBracketed e) = trans_exp env e
  | trans_exp env (ECharacterLiteral c) = exp_char_lit c
  | trans_exp env (EStringLiteral s) = exp_string_lit s
and €exp_array_agg› (env : CN_ENV) (e : EXP) : Z_EXP = (
	let	val tname = (
			case e of
			EArrayAggPos {tmark as Value tmk, ...} => tmk
		|	EArrayAggPosOthers {agg_pos as {tmark as Value tmk, ...}, ...} => tmk
		|	EArrayAggOthers {tmark as Value tmk, ...} => tmk
		|	EArrayAggNamed {tmark as Value tmk, ...} => tmk
		|	EArrayAggNamedOthers {agg_named as {tmark as Value tmk, ...}, ...} => tmk
		|	_ => fail "exp_array_agg" 508054 []);
		val this = 1;
		val max = array_dim env tname;
	in	mk_array_agg
		(max, trans_array_agg_exp env {tname = tname, this = this, max = max} e)
	end
);
=TEX
The following variant of $trans\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a comment message is printed out and $Nil$ is returned.
=SML
fun €trans_exp1› (env : CN_ENV) (exp : EXP) : Z_EXP OPT = (
	Value (trans_exp env exp)
	handle Fail msg  => (
		comment "trans_exp1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX

\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}

=SML
fun €named_assocs_to_exps› (names : ID list)
		(ns : (AGG_CHOICE,EXP) NAMED_ASSOC list) : EXP list = (
let	val lns = length ns;
	val table =	if lns = length names
			then	combine names (interval 0 (length ns - 1))
			else	fail "named_assocs_to_exps" 508043 [];
	fun aux1 ((ACAggChoiceSingle exp)::rest) = (
		(	lassoc3 table (name_to_tmark exp)
				handle _ => fail "named_assocs_to_exps" 508044
					[fn()=>name_to_tmark exp]
		)::aux1 rest
	) | aux1 ((ACAggChoiceRange _)::_) = (
		fail "named_assocs_to_exps" 508045 []
	) | aux1 _ = [];
	fun aux2 ({choice=cs,comp}::rest) = (
	let	val chmap = map (fn choice => (choice, comp))(aux1 cs);
	in
		chmap::(aux2 rest)
	end) | aux2 _ = [];
	val s = flat (aux2 ns);
	fun order (a:int,_) (b,_) = a-b;
	val nssorted = Sort.sort order s;
	fun aux3 count ((i, exp)::rest) = (
		if count=i
		then
			exp::aux3 (count+1) rest
		else
			fail "named_assocs_to_exps" 508043 []
	) | aux3 _ _ = [];
in
	aux3 0 nssorted
end);
=TEX

=SML
val €informal_function› : Z_ID = "INFORMAL_FUNCTION";
fun €adjust_id› (env : CN_ENV) (id : ID)  = (
	case (env (trans_id id)) of
		Value (ty, EIEnvFunction _) => 
			if	(fst(dest_ctype ty) <> informal_function)
			then	EFunCall{fun_name=id, args=[]}
			else	fail "adjust_id" 508049 [fn()=>id]
	| _ => EId id
)
and €adjust_rangelohi› (env : CN_ENV) ({lo=l, hi=h} : EXP RANGELOHI) = (
	{lo=adjust_exp env l, hi=adjust_exp env h}
)
and €adjust_range› (env : CN_ENV) (RRange x : EXP RANGE) = (
	RRange (adjust_rangelohi env x)
) | adjust_range env (RRangeAttr x : EXP RANGE) = (
	RRangeAttr (adjust_exp env x)
)
and €adjust_discrete_range_constrained› (env : CN_ENV) ({tmark=t, range=r} :
		EXP DISCRETE_RANGE_CONSTRAINED) = (
	{tmark=t, range=adjust_range env r}
)
and €adjust_discrete_range› (env : CN_ENV) (DRRange x : DISCRETE_RANGE) = (
	DRRange (adjust_range env x)
) | adjust_discrete_range env (DRConstrained x : DISCRETE_RANGE) = (
	DRConstrained(adjust_discrete_range_constrained env x)
)
and €adjust_agg_choice› (env : CN_ENV) (ACAggChoiceRange x : AGG_CHOICE) = (
	ACAggChoiceRange (adjust_discrete_range env x)
) | adjust_agg_choice env(ACAggChoiceSingle x : AGG_CHOICE) = (
	let	val n = name_to_tmark x;
	in
		case env n of
		Value (_, EIEnvOtherType) => (
			ACAggChoiceRange(DRConstrained{range=RRange {
				lo=EAttribute {attribute_desig=ADAttrib "FIRST",prefix=x},
				hi=EAttribute {attribute_desig=ADAttrib "LAST", prefix=x}},
				tmark=n})
		) |	_ => ACAggChoiceSingle (adjust_exp env x)
	end
)
and €adjust_named_assoc› (env : CN_ENV) ({choice=c, comp=e}
		: (AGG_CHOICE, EXP) NAMED_ASSOC) = (
	{choice=map (adjust_agg_choice env) c, comp=adjust_exp env e}
)
and €adjust_others› (env : CN_ENV) ({others=oth} : EXP OTHERS) = (
	{others=adjust_exp env oth}
)
and €adjust_agg_pos› (env : CN_ENV)
		({tmark=tmark as Value t, comps=c} : EXP AGG_POS) = (
	case env t of
	Value (ty, EIEnvRecordType _) => (
			ERecAggPos {tmark=tmark, comps=map (adjust_exp env) c}
        ) |_ => (
			EArrayAggPos {tmark=tmark, comps=map (adjust_exp env) c}
	)
) | adjust_agg_pos  (env : CN_ENV)
		({tmark=Nil, comps=c} : EXP AGG_POS) = (
	EArrayAggPos {tmark=Nil, comps=map (adjust_exp env) c}
)
and €adjust_agg_pos_others› (env : CN_ENV) ({agg_pos = {tmark=t, comps=c} :
		EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) = (
	EArrayAggPosOthers {	agg_pos={	tmark=t,
						comps=map (adjust_exp env) c},
				others=adjust_others env oth}
)
and €adjust_agg_others›	(env : CN_ENV)
				({tmark=t, others=oth} : EXP AGG_OTHERS) = (
         EArrayAggOthers{tmark=t, others=adjust_others env oth}
)
and €adjust_agg_named› (env : CN_ENV) ({tmark=t, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
	EArrayAggNamed {tmark=t, named_assocs=map (adjust_named_assoc env) n}
)
and €adjust_agg_named1› (env : CN_ENV)
		({tmark=tmark as Value t, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
let	val n' = map (adjust_named_assoc env) n;
in
	case env t of
	Value (ty, EIEnvRecordType _) => (
			ERecAggNamed {tmark=tmark, named_assocs=n'}
        ) |_ => (
			EArrayAggNamed {tmark=tmark, named_assocs=n'}
	)
end
) | adjust_agg_named1 (env : CN_ENV)
		({tmark= Nil, named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
let	val n' = map (adjust_named_assoc env) n;
in
	EArrayAggNamed {tmark=Nil, named_assocs=n'}
end
)
and €adjust_agg_named_others› (env : CN_ENV) ({agg_named=a, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) = (
let	val adjagg = case adjust_agg_named1 env a of
		EArrayAggNamed ag => (
			ag
		) | _ => fail "adjust_exp" 508046 []
in
	EArrayAggNamedOthers{agg_named=adjagg,others=adjust_others env oth}
end
)
and €adjust_unary_exp› (env : CN_ENV) ({uop=u, right=r} : EXP UNARY_EXP) = (
	EUnaryExp{uop=u, right=adjust_exp env r}
)
and €adjust_bin_exp› (env : CN_ENV) ({bop=b, left=l, right=r} : EXP BIN_EXP) = (
	EBinExp{left=adjust_exp env l, bop=b, right=adjust_exp env r}
)
and €adjust_attrib_desig› (env : CN_ENV) (ADAttrib x : ATTRIB_DESIG) = (
	ADAttrib x
) | adjust_attrib_desig env (ADAttribArg (a,e) : ATTRIB_DESIG) = (
	ADAttribArg (a, adjust_exp env e)
)
and €adjust_mem_range›	(env : CN_ENV)
				({mop=m, left=l, range=r} : EXP MEM_RANGE) = (
	EMemRange{left=adjust_exp env l, mop=m, range=adjust_range env r}
)
and €adjust_attribute› (env : CN_ENV) ({prefix=p, attribute_desig=a} :
		(EXP, ATTRIB_DESIG) ATTRIBUTE) = (
	EAttribute{prefix=adjust_exp env p, attribute_desig=adjust_attrib_desig env a}
)
and €adjust_indexed_comp›	(env : CN_ENV)
				({prefix=p, index=i} : EXP INDEXED_COMP) = (
let	val prename = name_to_tmark p;
in
	case (env prename, i) of
=TEX
Is it a function call?
=SML
	(Value (ty, EIEnvFunction _), EArrayAggPos{comps,...}) => (
		if	(fst(dest_ctype ty) <> informal_function)
		then	EFunCall{fun_name=prename, args=map (adjust_exp env) comps}
		else	fail "adjust_id" 508049 [fn()=>prename]
	) |(Value (ty, EIEnvFunction (_, names, _)), EArrayAggNamed{named_assocs, ...}) => (
	let	val args = named_assocs_to_exps names named_assocs;
	in	if	(fst(dest_ctype ty) <> informal_function)
		then	EFunCall
			{fun_name=prename, args=map (adjust_exp env) args}
		else	fail "adjust_id" 508049 [fn()=>prename]
	end
=TEX
Is it a type conversion?
=SML
	) |(Value (_, EIEnvRecordType _), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
	) |(Value (_, EIEnvOtherType), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
=TEX
No... It must be an indexed component for real. So check for errors...
=SML
	) |(_, EArrayAggPos {comps=[], ...}) => (
		fail "adjust_indexed_comp" 508035 [fn()=> name_to_tmark p]

	) |(_, EArrayAggPos{comps=comps, tmark=Nil}) => (
		EIndexedComp{prefix=adjust_exp env p,
			index = EArrayAggPos{comps = map (adjust_exp env) comps, tmark = Nil}}

	) |(_, EArrayAggPos _) => (
		fail "adjust_indexed_comp" 508055 [fn()=> name_to_tmark p]

	) |(_, EArrayAggNamed _) => (
		fail "adjust_indexed_comp" 508047 [fn()=>name_to_tmark p]

	) |_ => (
		fail "adjust_indexed_comp" 508048 [fn()=>prename]

	)
end
)
and €adjust_selected_comp› env ({prefix=p, selector=s} : EXP SELECTED_COMP) = (
	case p of
	EId id => (
		case env id of
		Value (ty, _) => (
			(	(dest_z_schema_type ty);
				ESelectedComp{prefix=adjust_exp (env : CN_ENV) p,
							selector=s}	)
			handle Fail _ => adjust_exp env (EId (id^"."^s))
		)| _ =>
			adjust_exp env (EId (id^"."^s))

	) | _ => 	(
		ESelectedComp{prefix=adjust_exp (env : CN_ENV) p, selector=s}
	)
)
and €adjust_qualified_expression›
				(env : CN_ENV)
				({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	case e of
	EArrayAggPos{comps = [comp],...} => (
		EQualifiedExp{tmark = t, exp = adjust_exp env comp}
	)| EArrayAggPos{comps,...} => (
		adjust_agg_pos env {comps=comps, tmark=Value t}
	)| EArrayAggPosOthers{agg_pos={comps,...}, others} => (
		adjust_agg_pos_others env 
			{agg_pos={comps=comps,tmark=Value t},others=others}
	)| EArrayAggOthers{others,...} => (
		adjust_agg_others env {others=others,tmark=Value t}
	)| EArrayAggNamed {named_assocs = n, tmark= _} => (
		 adjust_agg_named1 env {named_assocs = n, tmark = Value t}
	)| EArrayAggNamedOthers
			{agg_named as {named_assocs = n, tmark = _}, others} => (
		adjust_agg_named_others env 
			{	agg_named={named_assocs = n, tmark = Value t},
				others=others}
	)|_ => error "adjust_qualified_exp" 508042 []
)
=TEX
In the following, both named and positional record aggregates and function calls
need no adjustment since these constructs can only be produced by adjust\_exp.
If they occur in the input then it adjust\_exp will already have been called
and need not be called again.
=SML
and €adjust_exp› (env : CN_ENV) (exp as (EId id : EXP)) = (
	adjust_id env id
) | adjust_exp env (exp as (EIntReal _)) = (
	exp
) | adjust_exp env (exp as (EArrayAggPos x)) = (
	adjust_agg_pos env x
) | adjust_exp env (exp as (EArrayAggPosOthers x)) = (
	adjust_agg_pos_others env x
) | adjust_exp env (exp as (EArrayAggOthers x)) = (
	adjust_agg_others env x
) | adjust_exp env (exp as (EArrayAggNamed x)) = (
	adjust_agg_named env x
) | adjust_exp env (exp as (EArrayAggNamedOthers x)) = (
	adjust_agg_named_others  env x
) | adjust_exp env (exp as (ERecAggPos x)) = (
	exp
) | adjust_exp env (exp as (ERecAggNamed x)) = (
	exp
) | adjust_exp env (exp as (EUnaryExp x)) = (
	adjust_unary_exp env x
) | adjust_exp env (exp as (EBinExp x)) = (
	adjust_bin_exp env x
) | adjust_exp env (exp as (EMemRange x)) = (
	adjust_mem_range env x
) | adjust_exp env (exp as (EAttribute x)) = (
	adjust_attribute env x
) | adjust_exp env (exp as (EIndexedComp x)) = (
	adjust_indexed_comp env x
) | adjust_exp env (exp as (ESelectedComp x)) = (
	adjust_selected_comp env x
) | adjust_exp env (exp as (EFunCall _)) = (
	exp
) | adjust_exp env (exp as (EAuxiliaryExp _)) = (
	exp
) | adjust_exp env (exp as (EQualifiedExp x)) = (
	adjust_qualified_expression env x
) | adjust_exp env (exp as (ETypeConversion _)) = (
	exp
) | adjust_exp env (exp as (EBracketed x)) = (
	adjust_exp env x
) | adjust_exp env (exp as (EStringLiteral _)) = (
	exp
) | adjust_exp env (exp as (ECharacterLiteral _)) = (
	exp
);
=TEX
The following variant of $adjust\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a comment message is printed out and $Nil$ is returned.
=SML
fun €adjust_exp1› (env : CN_ENV) (exp : EXP) : EXP OPT = (
	Value (adjust_exp env exp)
	handle Fail msg  => (
		comment "adjust_exp1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX

\section{CHECKING FOR EMPTY RANGES}
The code in this section implements check 14 from section 17.1 of volume I of the specifications.
This requires evaluation of static expressions which is most conveniently done using proof.

The following function generates the VC for checking that a type or subtype defined by a range constraint is non-empty.
=SML
val €x_var› = Ò(x ∫  ˙)Æ;
val €vc_pattern› = Òëx_varÆ Ω öÆ;
fun €range_check_vc› (n : Z_ID) : Z_EXP = (
	subst[(mk_z_gvar(n, z_int_set_type, []), x_var)] vc_pattern
);
=TEX
The following function reports an error if the range bounds can be evaluated and the range proves to be empty;
if the range can be evaluated and is non-empty then the function returns an empty list of paragraphs;
if the range cannot be evaluated a paragraph containing a VC is returned.

The somewhat strange way of expressing the decision-making arises from the desire to include the two equations in the message in the error case.
=SML
fun €range_check_vcs›
	(n : Z_ID) (lo : TERM) (hi : TERM) : PARAINFO list = (
	(let	val lo_eqn = (concl o TRY_C(cn_eval_conv[])) lo;
		val hi_eqn = (concl o TRY_C(cn_eval_conv[])) hi;
		val nlo = (dest_z_signed_int o snd o dest_eq) lo_eqn;
		val nhi = (dest_z_signed_int o snd o dest_eq) hi_eqn;
		fun show t = (
			let	val (x, _) = dest_eq t;
			in	if	is_z_signed_int x
				then	x
				else	t
			end
		);
	in	if	nlo @<= nhi
		then	(fn _ => [])
		else	(fn _ =>
				term_fail  "trans_basic_decl"
					508060 [show lo_eqn, show hi_eqn])
	end	handle Fail _ => (fn _ =>
			(comment "trans_basic_decl"508061 [fn _ => n];
			[ConjectureInfo(Value n, [], range_check_vc n)])
	))	()
);
=TEX

\section{TRANSLATING SPARK BASIC DECLARATIONS}

\subsection{Translating Constants}

=SML
fun €basic_decl_const›
		(env : CN_ENV)
		({consts=consts, tm=tm, expr=expr} : EXP CONST_DECL)
		: PARAINFO list= (
	let	val ae = adjust_exp1 env expr;
		val te = case ae of Value e => trans_exp1 env e | _ => Nil;
	in	case te of
			Value te =>
				map
				(fn const => z_eq_eq(trans_id const, te))
				consts
		|	Nil => (
			let	fun do1 const = (
					let	val zexp = zid env (trans_id tm);
						val zvar = trans_id const;
					in	z_ax(zvar, zexp, [])
					end
				);
			in	map do1 consts
			end		
		)
	end
);
=TEX
\subsection{Translating Enumeration Types}
=SML
fun €enum_attrib› (env : CN_ENV) (zidâ1 : Z_ID, zidâ2 : Z_ID, zidâ3 : Z_ID) = (
let	fun env' id = 
		if id = (zidâ1 ^^ zlst)
		then	Value (z_int_type, EIEnvOther)
		else if id mem [zidâ1 ^^ zsuc, zidâ1 ^^ zpos]
		then	Value (z_int_int_rel_type,EIEnvOther)
		else	env id;
	val zexp = z_set_minus (zid env' zidâ1, z_set [zid env' (zidâ1 ^^ zlst)]);
in
	[z_eq_eq (zidâ1 ^^ zfst, zid env' zidâ2),
	z_eq_eq (zidâ1 ^^ zlst, zid env' zidâ3),
	z_eq_eq (zidâ1 ^^ zsuc, z_dom_res (zexp, zsucc)),
	z_eq_eq(zidâ1 ^^ zpred, z_inv(zid env' (zidâ1 ^^ zsuc))),
	z_eq_eq(zidâ1 ^^ zpos, z_id_rel (zid env' zidâ1)),
	z_eq_eq(zidâ1 ^^ zval, z_inv(zid env' (zidâ1 ^^ zpos)))]
end);
=TEX
=SML
fun €basic_decl_enum› (env : CN_ENV) (name : ID) (td : ENUM_TYPE_DEF) = (
let	val {vals} = td;
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map (z_num o integer_of_int) (interval 0 ((length vals)-1));
	fun env' id = (
		if id mem zvals
		then
			Value (z_int_type, EIEnvOther)
		else if id = zname
		then
			Value (z_int_set_type, EIEnvOther)
		else
			env id
	);
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid env' (hd zvals), zid env' ((hd o rev) zvals)))] @
	enum_attrib env' (zname, hd zvals, (hd o rev) zvals)
end);
=TEX
\subsection{Translating Array Types}
=SML
fun €array_attrib_aux› (env : CN_ENV) (zidâ1 : Z_ID) (zidâ2 : Z_ID, i : int) : PARAINFO list = (
	[z_eq_eq(dimen(zidâ1 ^^ zfst, i), zid env (zidâ2 ^^ zfst)),
	z_eq_eq(dimen(zidâ1 ^^ zlst, i), zid env (zidâ2 ^^ zlst)),
	z_eq_eq(dimen(zidâ1 ^^ zlength, i), z_size (zid env zidâ2)),
	z_eq_eq(dimen(zidâ1 ^^ zrange, i), zid env zidâ2)]
);
=TEX
The handler below catches failures from {\it hd}.
=SML
fun €array_attrib› (env : CN_ENV) (zid : Z_ID, zids : Z_ID list) : PARAINFO list = (
	let	val aux = array_attrib_aux env zid;
		val zids_is = combine zids (interval 1 (length zids));
	in	aux (hd zids, 0) @
		flat (map aux zids_is)
	end	handle Fail _ => fail "array_attrib" 508035 [] 
);
=TEX
=SML
fun €basic_decl_con_array› (env : CN_ENV) (name : ID)
		({index=index, comp=comp} : ARRAY_DEF) : PARAINFO list = (
	let	val zname = trans_id name;
		val zindex = z_many_cross (map (zid env o trans_id) index);
		val zcomp = trans_id comp;
	in
		[z_eq_eq(zname, z_tfun(zindex, zid env zcomp))] @
		array_attrib env (zname, index)
	end
);
=TEX
=SML
=TEX
=SML
fun €basic_decl_uncon_array› (env : CN_ENV) (name : ID)
		({index=[head_index], comp=comp} : ARRAY_DEF) : PARAINFO list = (
	let	val zname = trans_id name;
		val zindex = trans_id head_index;
		val zcomp = trans_id comp;
		val zexp = z_powerset(z_pfun(zid env zindex, zid env zcomp));
	in
		[z_ax(zname, zexp, [])]
	end
) | basic_decl_uncon_array env name
	({index=index, comp=comp} : ARRAY_DEF) = (
	let	val zname = trans_id name;
		val zindex = z_many_cross (map (zid env o trans_id) index);
		val zcomp = trans_id comp;
		val zexp = z_powerset(z_pfun(zindex, zid env zcomp));
	in
		[z_ax(zname, zexp, [])]
	end
);
=TEX

\subsection{Translating Record Types}
=SML
fun €conv_var_decl› ({vars=vs, tmark=t} : VAR_DECL)
		: {var : ID, tmark : TMARK} list = (
	 map (fn id => {var=id, tmark=t}) vs
);
=TEX
=SML
fun €trans_decl_aux› (env : CN_ENV) ({vars, tmark} : VAR_DECL) : Z_DECL * (Z_ID list) = (
let	val zvs = map trans_id vars;
	val zexp = zid env (trans_id tmark);
	val zvars = map (fn zv => mk_z_lvar (zv,
						(dest_z_power_type o type_of) zexp,
						[])) zvs;
in
	(mk_z_dec (zvars, zexp), zvs)
end);
fun €trans_decl› (env : CN_ENV) : VAR_DECL -> Z_DECL = fst o trans_decl_aux env;
=TEX
=SML
local
fun €mk_update_defs› (tyname : Z_ID) (comps : Z_ID list list) : PARAINFO = (
	let	val n_comps = length comps;
		val gen_formals = map (fn i => "g" ^ string_of_int i) (interval 1 n_comps);
		fun do_sch_decs [] _ = []
		|   do_sch_decs comps gen_formals = (
			let	val c = hd comps;
				val n = hd gen_formals;
				val ty = mk_z_var_type n;
				fun mk_v v = mk_z_lvar(v, ty, []);
			in	(map mk_v c, mk_z_lvar(n, mk_z_power_type ty, []))
			end	:: do_sch_decs (tl comps) (tl gen_formals)
		);
		val sch_decs = do_sch_decs comps gen_formals;
		val decl = mk_z_decl(map mk_z_dec sch_decs);
		val h_schema = mk_z_h_schema (decl, mk_t);
		val _ = schema_gen_semantic_const h_schema;
		fun upd_name c = tyname ^ "u" ^ c;
		fun do_sig_decs [] _ = []
		|   do_sig_decs comps decs = (
			let	val c = hd comps;
				val (_, x) = hd decs;
				val set = z_tfun(mk_z_∏[h_schema, x], h_schema);
				val ty = dest_z_power_type (type_of set);
				fun mk_v v = mk_z_lvar(upd_name v, ty, []);
			in	(map mk_v c, set)
			end	:: do_sig_decs (tl comps) (tl decs)
		);
		val sig_decs = do_sig_decs comps sch_decs;
		val sig_decl = mk_z_decl(map mk_z_dec sig_decs);
		fun do_µ_decs _ [] = []
		|   do_µ_decs n ((_, x)::more) = (
			let	val ty = dest_z_power_type (type_of x);
				val v = mk_z_lvar("x" ^ string_of_int n, ty, []);
			in	([v], x)
			end	:: do_µ_decs (n+1) more
		);
		val r = mk_z_lvar("r", dest_z_power_type(type_of h_schema), []);
		val r_dec = ([r],	h_schema);
		val var_decs = do_µ_decs 1 sch_decs;
		val µ_decl = mk_z_decl(map mk_z_dec (r_dec :: var_decs));
		fun bind_one sel var comp = (
			if	sel = comp
			then	(comp, var)
			else	(comp, mk_z_selâs(r, comp))
		);
		fun do_binding _ _  [] = []
		|   do_binding var sel cmps = (
			let	val cmpl = hd cmps;
			in	map (bind_one sel var) cmpl
			end	@ do_binding var sel (tl cmps)
		);
		fun do_eq var arg (f, c) = (
			mk_z_eq(mk_z_app(f, arg), z_binding(do_binding var c comps))
		); 
		fun do_eqs [] _ _ = []
		|   do_eqs sigdecs vardecs cmps = (
			let	val (fs, _) = hd sigdecs;
				val cs = hd cmps;
				val var = hd(fst(hd vardecs));
				val arg = mk_z_tuple[r, var];
			in	map (do_eq var arg) (combine fs cs)
			end	@ do_eqs (tl sigdecs) (tl vardecs) (tl cmps)
		);
		val eqs = list_mk_±(do_eqs sig_decs var_decs comps);
		val pred = mk_z_µ(µ_decl, mk_t, eqs);
		val idtys = map dest_var (flat (map fst sig_decs));
	in	AxDesInfo(gen_formals, sig_decl, Value pred, idtys)
	end
);
in
fun €record_update_defs› (zname : Z_ID, zcomps : Z_ID list list) : PARAINFO = (
	mk_update_defs zname zcomps
);
end;
=TEX
=SML
fun €basic_decl_record› (env : CN_ENV) (name : ID)
		({decl} : RECORD_TYPE_DEF) : PARAINFO list = (
let	val z_sname = trans_id name;
	val (z_decls, zcomps) = split(map (trans_decl_aux env) decl);
in
	[z_schema(z_sname, z_decls), record_update_defs(z_sname, zcomps)]
end);
=TEX
\subsection{Translating Integer Types}

=SML
local
	val z_exp = z_pfun(˙_tm, ˙_tm);
in
fun €int_type_attrib› (env : CN_ENV) (zid1, range) = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val zvar1 = zid1 ^^ zsuc;
		val zvar2 = zid1 ^^ zpred;
		val zvar3 = zid1 ^^ zpos;
		val zvar4 = zid1 ^^ zval;
	in
		[z_eq_eq(zid1 ^^ zfst, trans_exp env lo),
		z_eq_eq(zid1 ^^ zlst, trans_exp env hi),
		z_ax(zvar1, z_exp, []),
		z_ax(zvar2, z_exp, []),
		z_ax(zvar3, z_exp, []),
		z_ax(zvar4, z_exp, [])]
	end
);
end;
=TEX
=SML
fun €basic_decl_int_type› (env : CN_ENV) (name : ID) (range : EXP RANGE)
	: PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val tlo = trans_exp env lo;
		val thi = trans_exp env hi;
		val zname = trans_id name;
		val vcs = range_check_vcs name tlo thi;
	in	if	not(type_of tlo =: z_int_type)
		then	term_fail "basic_decl_int_type" 508066 [tlo]
		else if	not(type_of thi =: z_int_type)
		then	term_fail "basic_decl_int_type" 508066 [thi]
		else	((z_eq_eq(zname, z_rng(tlo, thi)) ::
			  int_type_attrib env (zname, RRange{lo=lo,hi=hi})) @ vcs)
	end
);
=TEX
\subsection{Translating Real Types}

=TEX
=SML
fun €basic_decl_fixed_type› (env : CN_ENV) (name : ID)
	({exp = delta, range = Value r} : EXP FIXED_TYPE_DEF)
	: PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env r);
		val tlo = trans_exp env lo;
		val thi = trans_exp env hi;
		val tdelta = trans_exp env delta;
		val zname = trans_id name;
		(* val vcs = range_check_vcs name tlo thi; *)
	in	[ z_eq_eq(zname, z_rng(tlo, thi)),
		  z_eq_eq(zname ^^ zdelta, tdelta),
		  z_eq_eq(zname ^^ zfst, tlo),
		  z_eq_eq(zname ^^ zlst, thi) ]
	end
) | basic_decl_fixed_type _ _ _ = fail "basic_decl_fixed_type" 508065 [];
=TEX
=SML
fun €basic_decl_floating_type› (env : CN_ENV) (name : ID)
	({exp = digits, range = Value r} : EXP FIXED_TYPE_DEF)
	: PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env r);
		val tlo = trans_exp env lo;
		val thi = trans_exp env hi;
		val tdigits = trans_exp env digits;
		val zname = trans_id name;
		(* val vcs = range_check_vcs name tlo thi; *)
	in	[ z_eq_eq(zname, z_rng(tlo, thi)),
		  z_eq_eq(zname ^^ zdigits, tdigits),
		  z_eq_eq(zname ^^ zfst, tlo),
		  z_eq_eq(zname ^^ zlst, thi) ]
	end
) | basic_decl_floating_type env name {exp = digits, range = Nil} = (
	let	val tdigits = trans_exp env digits;
		val zname = trans_id name;
		val tfst = zname ^^ zfst;
		val tlst = zname ^^zlst;
		val trng = z_rng(
			mk_z_gvar(tfst, z_real_type, []),
			mk_z_gvar(tlst, z_real_type, []));
		(* val vcs = range_check_vcs name tlo thi; *)
	in	[ z_ax(tfst, %calR%_tm, []),
		  z_ax(tlst, %calR%_tm, []),
		  z_eq_eq(zname, trng),
		  z_eq_eq(zname ^^ zdigits, tdigits)]
	end
);
=TEX

\subsection{Translating Subtypes}
=SML
fun €range_con_attrib› (env : CN_ENV) (zidâ1 : Z_ID, zidâ2 : Z_ID, {lo,hi}
		: EXP RANGELOHI) : PARAINFO list = (
	[z_eq_eq (zidâ1 ^^ zfst, trans_exp env lo),
	z_eq_eq (zidâ1 ^^ zlst, trans_exp env hi),
	z_eq_eq (zidâ1 ^^ zsuc, zid env (zidâ2 ^^ zsuc)),
	z_eq_eq (zidâ1 ^^ zpred, zid env (zidâ2 ^^ zpred)),
	z_eq_eq (zidâ1 ^^ zpos, zid env (zidâ2 ^^ zpos)),
	z_eq_eq (zidâ1 ^^ zval, zid env (zidâ2 ^^ zval))]
);
=TEX
The following function does the processing which is commont to cases of
a subtype which gives rise to an axiomatic description rather than an abbreviation definition.
=SML
fun €basic_decl_subtype_axdes› (env : CN_ENV) (name : ID) (tmark : TMARK)
	: PARAINFO list = (
	let	val zvar = trans_id name;
		val ztmark = trans_id tmark;
		val zexp = z_powerset (zid env tmark)
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark];
	in	[z_ax(zvar, zexp, [])]
	end
);
=TEX
Here and in the Z generator we need to know the names of the recognised attributes:
=SML
val €ada_attributes_list› : ID list = map fst ada_attribute_types;
=TEX
=SML
fun €type_attrs› (unwanted : ID list) (t : ID) = (
let	val tthy = get_const_theory (bind_gvar_name t);
	val tthyconsts = get_consts tthy;
	val tthyconsts_names = map (fst o dest_const) tthyconsts;
	val transt = trans_id t;
in
	(ada_attributes_list diff unwanted) drop
		(fn attr => not((bind_gvar_name transt ^^ attr) mem tthyconsts_names))
end
handle (Fail _) => [] (* presumably from get_const_theory *)
);
=IGN
type_attrs []"NATURAL";
=TEX
=TEX
In the following, the two `then' parts in the first case alternative implements
=INLINEFT
Basic_Decl_Range_Con_1
=TEX
\ and
=INLINEFT
Basic_Decl_Range_Con_3
=TEX

\ and the final `else' part and the second case alternative implement
=INLINEFT
Basic_Decl_Range_Con_2
=TEX
.
=SML
fun €basic_decl_subtype_range_con› (env : CN_ENV) (name : ID) (tmark : TMARK)
		(range : EXP RANGE) : PARAINFO list = (
	let	val {lo, hi} = dest_range (adjust_range env range);
		val zname = trans_id name;
		val ztmark = trans_id tmark;
		val ztype = type_of(zid env ztmark
			handle Fail _ =>
			fail "trans_basic_decl" 508051 [fn () => tmark]);
		val te_lo = trans_exp1 env lo;
		val te_hi = trans_exp1 env hi;
	in	case (te_lo, te_hi) of
			(Value l, Value h) =>
			if	ztype =: z_int_set_type
			then	let	val vcs = range_check_vcs name l h;
				in	z_eq_eq(zname, z_rng(l, h)) ::
					range_con_attrib env
					(zname, ztmark, {lo=lo,hi=hi}) @ vcs
				end
			else if	ztype =: z_real_set_type
			then	let	(* val vcs = range_check_vcs name l h *);
					val unwanted = ["FIRST", "LAST"];
					val tas = type_attrs unwanted tmark;
					val tas_paras = map
						(fn attr =>
						z_eq_eq(zname ^^ attr,
						 zid env (trans_id tmark ^^ attr))) tas;
				in	z_eq_eq(zname, z_rng(l, h)) ::
					tas_paras @
					[ z_eq_eq(zname ^^ zfst, l),
					  z_eq_eq(zname ^^ zlst, h) ]
				end
			else	basic_decl_subtype_axdes env name tmark
		|	_ =>	basic_decl_subtype_axdes env name tmark
	end
);
=TEX
=SML
val €basic_decl_subtype_fixed_con› : CN_ENV -> ID
	-> EXP FIXED_POINT_CONSTRAINT -> PARAINFO list
	= basic_decl_fixed_type;
val €basic_decl_subtype_floating_con› : CN_ENV -> ID
	-> EXP FLOATING_POINT_CONSTRAINT -> PARAINFO list
	= basic_decl_floating_type;
=SML
=TEX
The following function is used to check whether a subtype has base type
{\it STRING} and, if so, to check the lower index bound.
=SML
local
val z_one = Ò1Æ;
in
fun €string_bound_check› (env : CN_ENV) (name : ID) ([ix] : TMARK list) (ztmark : Z_EXP)
		 : PARAINFO list = (
	case base_type ztmark of
	Value "STRING" =>
		let	val zbnd = zid env (trans_id ix ^^ zfst);
			val zval = (snd o dest_eq o concl o TRY_C(cn_eval_conv[])) zbnd;
		in	if	is_z_signed_int zval
			then	if	zval =$ z_one
				then	[]
				else	fail "string_bound_check" 508075 [fn _ => name]
			else	(comment "string_bound_check" 508076 [fn _ => name];
				[ConjectureInfo(Value name, [], mk_z_eq(zbnd, z_one))])
		end
	| _ => []
) | string_bound_check _ _ _ _ = [];
end;
=TEX
=SML
fun €basic_decl_subtype_index_con› (env : CN_ENV) (name : ID) (tmark : TMARK)
		(ci : EXP list) : PARAINFO list = (
let	val zname = trans_id name;
	val zexp = zid env (trans_id tmark);
	val zvar_ty = dest_z_power_type(type_of zexp)
		handle Fail _ => fail "trans_basic_decl" 508051 [fn () => tmark];
	val var =  "array";
	val env' = fn id => if id = "array" then Value (zvar_ty, EIEnvVar tmark)
					else env id; 
	val index = map name_to_tmark ci;
	val zindex = map trans_id index;
	val zp = z_eq (z_dom (zid env' var), z_many_cross(map (zid env) zindex));
	val set_comp = z_set_comp (trans_decl env' {vars=[var],tmark=tmark}, zp)
	val abb_def = z_eq_eq (zname, set_comp);
in	abb_def :: array_attrib env (zname, zindex) @
	string_bound_check env name index zexp
end
);

=SML
fun €basic_decl_subtype_no_con› (env : CN_ENV) (name : ID) (tmark : TMARK)
		: PARAINFO list = (
let	val zname = trans_id name;
	val zexp = zid env (trans_id tmark);
	val zvar_ty = dest_z_power_type(type_of zexp)
		handle Fail _ => fail "trans_basic_decl" 508051 [fn () => tmark];
	val abb_def = z_eq_eq (zname, zexp);
	val tas = type_attrs [] tmark;
	val tas_paras = map (fn attr => z_eq_eq(zname ^^ attr, 
		zid env (trans_id tmark ^^ attr))) tas;
in	
	(abb_def :: tas_paras)
end);
=TEX

\subsection{The Function $trans\_basic\_decl$}
=SML
fun €trans_basic_decl› (env : CN_ENV) ((BDConstDecl {consts,tm,expr}) : BASIC_DECL)
		: PARAINFO list = (
	basic_decl_const env {consts=consts, tm=tm, expr=expr}
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDEnumTypeDef td,...}) = (
	basic_decl_enum env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDIntTypeDef range,...}) = (
	basic_decl_int_type env name range
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDConArrayDef td,...}) = (
	basic_decl_con_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDUnconArrayDef td,...}) = (
	basic_decl_uncon_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDRecordTypeDef td,...}) = (
	basic_decl_record env name td
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CRange cr},...}) = (
	basic_decl_subtype_range_con env name tmark cr
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CIndex ci},...}) = (
	basic_decl_subtype_index_con env name tmark ci
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFixed cf},...}) = (
	basic_decl_subtype_fixed_con env name cf
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFloating cf},...}) = (
	basic_decl_subtype_floating_con env name cf
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CNoCon},...}) = (
	basic_decl_subtype_no_con env name tmark
) | trans_basic_decl env (BDTypeDecl {name, type_def as TDFixedTypeDef td}) = (
	basic_decl_fixed_type env name td
) | trans_basic_decl env (BDTypeDecl {name, type_def as TDFloatingTypeDef td}) = (
	basic_decl_floating_type env name td
) | trans_basic_decl env (BDDeferredConstDecl _) = (
	fail "trans_basic_decl" 508039 []
) | trans_basic_decl env (BDVarDecl _) = (
	fail "trans_basic_decl" 508040 []
) | trans_basic_decl env (BDVarDeclInit _) = (
	fail "trans_basic_decl" 508040 []
) | trans_basic_decl env (BDPrivateTypeDecl _) = (
	fail "trans_basic_decl" 508041 []
) | trans_basic_decl env (BDPragma _) = (
	[]
) | trans_basic_decl env (BDAnnotation _) = (
	[]
);
=TEX
=SML
fun €trans_basic_decl1› (env : CN_ENV) (bd : BASIC_DECL)
			: PARAINFO list OPT = (
	Value (trans_basic_decl env bd)
	handle Fail msg  => (
		comment "trans_basic_decl1" 508050 [fn _ => get_message msg];
		Nil
	)
);
=TEX
\section{Support for Multidimensional Arrays}
=SML
fun €array_agg_def› (num : int) : unit = (
if	num >= 2
then
let	val fun_name = z_array_agg num;
in	case get_const_type (bind_gvar_name fun_name) of
		Value _ => ()
	|	Nil =>
	let	fun mk_gvar name = (
			let val ty = mk_z_power_type(mk_z_var_type name);
			in	mk_z_lvar(name, ty, [])
			end
		);
		val ns = map string_of_int (interval 1 num);
		val g_ns = map (mk_gvar o (fn n => "g" ^ n)) ns;
		val g = mk_gvar "g";
		val prod = z_many_cross g_ns;
		val uncurried_tm = z_tfun(prod, g);
		fun mk_curried_tm [] = g
		|   mk_curried_tm (g_n::more) = z_tfun(g_n, mk_curried_tm more);
		val curried_tm = mk_curried_tm g_ns;
		val sig_tm = z_tfun(curried_tm, uncurried_tm);
		val sig_ty = dest_z_power_type (type_of sig_tm);
		val fun_var = mk_z_lvar(fun_name, sig_ty, []);
		val sig_decl = mk_z_decl[mk_z_dec([fun_var], sig_tm)];
		val f = mk_z_lvar("f", dest_z_power_type(type_of curried_tm), []);
		fun mk_x_n (v, n) = (
			mk_z_lvar("x" ^ n, dest_z_power_type (type_of v), [])
		);
		val x_ns = map mk_x_n (combine g_ns ns);
		val tuple = mk_z_tuple x_ns;
		val lhs = mk_z_app(mk_z_app(fun_var, f), tuple);
		fun mk_rhs t [] = t
		|   mk_rhs t (x_n::more) = mk_rhs (mk_z_app(t, x_n)) more;
		val rhs = mk_rhs f x_ns;
		val eqn = mk_z_eq(lhs, rhs);
		fun dec_of_var (v, e) = mk_z_dec([v], e);
		val x_decs = map dec_of_var (combine x_ns g_ns); 
		val pred = mk_z_µ(mk_z_decl(dec_of_var(f, curried_tm)::x_decs), mk_t, eqn);
		val idtys = [dest_var fun_var];
	in	update_theory_db_with_parainfo
		(AxDesInfo(map (fst o dest_var) (g_ns @ [g]), sig_decl, Value pred, idtys))
	end
end
else fail "array_agg_def" 508059 []
);
=TEX
\section{EPILOGUE}

=SML
end (* structure CNBasicDeclsAndExprs *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
