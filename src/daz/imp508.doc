% imp508.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP508}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the implementation for the Basic Declaration and Expression Genertor for processing Compliance Notation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.15] Initial Drafts.
\item[Issue 1.16 (16th June 1994)] First draft for review.
\item[Issue 1.27 (31 October 1994)] Added $z\_true$ and $z\_exists$ as per version 1.1 of Volume 3 of DRA's specification.
\item[Issue 1.30 (9th November 1994)]
Adjusted $ENV\_INFO$ and allowed for type conversions.
\item[Issue 1.32] Updated document references.
\item[Issue 1.33] Accomodated changes to toolkit extensions agreed at the 4th critical review (see \cite{ISS/HAT/DAZ/min005}: $mod$ becomes $intmod$, $Abs$ becomes $abs$).
\item[Issue 1.34] Accomodated changes to data types required for enhancements.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD508}.
\subsection{Algorithms}
The algorithms to generate the basic declarations and expressions are specified in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/1.2}.

%\subsection{Dependencies}
%\subsection{Known Deficencies}
%\subsection{Possible Enhancements}
=TEX

\section{PREAMBLE}

=SML
infix 3 ^^;
=TEX
=SML
structure ÛCNBasicDeclsAndExprsÝ : CNBasicDeclsAndExprs = struct
	open CNParser CNTypes ZGeneratedConstants ZParagraphs;
	open ZUserInterfaceSupport;
=TEX

\section{CUSTOMIZED ENVIRONMENT HANDLING}

=SML
datatype ÛENV_INFOÝ =
			ÛEIEnvFunctionÝ of ID list
		|	ÛEIEnvVarÝ of TMARK
		|	ÛEIEnvAuxVarÝ
		|	ÛEIEnvRecordTypeÝ
		|	ÛEIEnvOtherTypeÝ
		|	ÛEIEnvOtherÝ;
=TEX
=SML
type ÛCN_ENVÝ = Z_ID -> (TYPE * ENV_INFO) OPT;
=TEX

\section{MISCELLANEOUS SUPPORTING FUNCTIONS}

When a construct is found for which is not supported formally, we choose to continue processing informally rather that halt the processing of the literate script. The local exception $Informal$ is raised if this condition is detected. This is caught by $trans\_exp1$ which returns an optional value and is $Nil$ if continuing to process informally. 
=SML
exception ÛInformalÝ;

fun Ûgo_informalÝ
		(s : string)
		(i : int)
		(fns : (unit -> string) list) : 'a = (
	comment s i fns;
	raise Informal
);
=TEX
=SML
fun zid1 Û^^Ý zid2 = (
	zid1^"v"^zid2
);
=TEX
=SML
fun Ûtrans_rangeÝ ((RRange range) : EXP RANGE) : EXP RANGELOHI = (
	range
) | trans_range _ = go_informal "trans_range" 508020 [];
=TEX
=SML
val ÛheadÝ = hd
and ÛlastÝ = hd o rev;
=TEX


\section{SUPPORT FOR Z ABSTRACT SYNTAX}

\subsection{Z Unary Expressions}
=SML
val		Ûz_unary_minusÝ =	ñ(~ _)®
	and	Ûz_bool_notÝ =		ñ(not _)®
	and	Ûz_absÝ =		ñ(abs _)®;
=TEX
\subsection{Z Binary Expressions}
=SML
val 		Ûz_bool_andÝ =		ñ(_ and _)®
	and	Ûz_bool_orÝ =		ñ(_ or _)®
	and	Ûz_bool_xorÝ =		ñ(_ xor _)®
	and	Ûz_bool_eqÝ =		ñ(_ eq _)º((BOOLEAN ¸ BOOLEAN)­BOOLEAN)®
	and	Ûz_bool_noteqÝ =	ñ(_ noteq _)º((BOOLEAN ¸ BOOLEAN)­BOOLEAN)®
	and	Ûz_bool_lessÝ =		ñ(_ less _)®
	and	Ûz_bool_less_eqÝ =	ñ(_ less_eq _)®
	and	Ûz_bool_greaterÝ =	ñ(_ greater _)®
	and	Ûz_bool_greater_eqÝ =	ñ(_ greater_eq _)®
	and	Ûz_addÝ =		ñ(_ + _)®
	and	Ûz_minusÝ =		ñ(_ - _)®
	and	Ûz_timesÝ =		ñ(_ * _)®
	and	Ûz_intdivÝ =		ñ(_ intdiv _)®
	and	Ûz_modÝ =		ñ(_ intmod _)®
	and	Ûz_remÝ =		ñ(_ rem _)®
	and	Ûz_exponÝ =		ñ(_ ** _)®
	and	Ûz_bool_memÝ =	
				ñ(_ mem _)º((BOOLEAN ¸ ð BOOLEAN)­BOOLEAN)®
	and	Ûz_bool_notmemÝ =
				ñ(_ notmem _)º((BOOLEAN ¸ ð BOOLEAN)­BOOLEAN)®;
=TEX

\subsection{Z Expressions}
The following function allows the Z constructor functions to be presented in a way which is visually appealing.
=SML
fun Ûcn_substÝ (ts : (TERM * string) list) (tm : TERM) : TERM = (
let	val freevars = frees tm;
	val fvs = map dest_var freevars;
	val newtys = map (fn (tm,c) => (c, type_of tm)) ts;
	val tymap = map (fn (n, ty) => (ty,lassoc3 fvs n)) newtys;
	val tymap' = (fn (t1,t2) => type_match
		(mk_ctype ("TYPE",t1)) (mk_ctype("TYPE",t2))) (split tymap);
	val tm_inst = inst [] tymap' tm;
	val namemap = map (fn (tm, s) => (tm, mk_var(s, lassoc3 newtys s))) ts;
in
	subst namemap tm_inst
end);
=TEX


=SML
val ÛzsuccÝ : Z_EXP = ñsucc®;
=TEX
=SML
fun ÛzidÝ (env : CN_ENV) (id : Z_ID) : Z_EXP = (
	find (TypeInference.get_ti_context ()) (fn t => fst(dest_var t) = id)
	handle Fail _ => 
	case env id of
	Value (ty, EIEnvVar _) => mk_z_lvar(id, ty, [])
	|Value (ty, EIEnvAuxVar) => mk_z_lvar(id, ty, [])
	|Value (ty, _) => mk_z_gvar(id, ty, [])
	|Nil => fail "zid" 508021 [fn()=>id]
);
=TEX
=SML
val Ûz_numÝ : int -> Z_EXP = (mk_z_int o string_of_int);
=TEX
=SML
val Ûz_tfun_termÝ : TERM = ña ­ b®;
fun Ûz_tfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_tfun_term
);
=TEX
=SML
val Ûz_pfun_termÝ : TERM = ña ß b®;
fun Ûz_pfunÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_pfun_term
);
=TEX
=SML
val Ûz_rng_termÝ : TERM = ña .. b®;
fun Ûz_rngÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_rng_term
);
=TEX
=SML
val Ûz_dom_termÝ : TERM = ñdom a®;
fun Ûz_domÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_dom_term
);
=TEX
=SML
val Ûz_dom_res_termÝ : TERM = ña ò b®;
fun Ûz_dom_resÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"),(exp2, "b")] z_dom_res_term
);
=TEX
=SML
val Ûz_inv_termÝ : TERM = ña ç~ê®;
fun Ûz_invÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_inv_term
);
=TEX
=SML
val Ûz_id_rel_termÝ : TERM = ñid a®;
fun Ûz_id_relÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_id_rel_term
);
=TEX
=SML
val Ûz_size_termÝ : TERM = ñ# a®;
fun Ûz_sizeÝ (exp : Z_EXP) : Z_EXP = (
	cn_subst [(exp, "a")] z_size_term
);
=TEX
=SML
val Ûz_empty_set_termÝ : TERM = ñ{}®;
fun Ûz_setÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_setd(type_of e, exps)
) | z_set _ = z_empty_set_term;
=TEX
=SML
val Ûz_set_minus_termÝ : TERM = ña \ b®;
fun Ûz_set_minusÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_set_minus_term
);
=TEX
=SML
fun Ûz_set_compÝ (zdecl : Z_DECL, p : Z_EXP) : Z_EXP = (
let	val dec = (fst o dest_z_dec) zdecl
			handle _ =>
			  fail "z_set_comp" 508023 [fn()=>string_of_term zdecl];
	val zdexp = case dec of
		[dec] => dec
		|_ => mk_z_tuple dec;
	val tm = mk_z_seta (mk_z_decl [zdecl], p, zdexp);
	val side = seta_gen_semantic_const tm;
in
	tm
end
);
=TEX
=SML
val Ûz_power_termÝ : TERM = ña ç b ê®;
fun Ûz_powerÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_power_term
);
=TEX
=SML
val Ûz_rel_comp_termÝ : TERM = ña » b®;
fun Ûz_rel_compÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_rel_comp_term
);
=TEX
=SML
val Ûz_empty_seq_termÝ : TERM = ñ§¢®;
fun Ûz_seqÝ ((exps as e::rest) : Z_EXP list) : Z_EXP = (
	mk_z_§¢(type_of e, exps)
) | z_seq _ = z_empty_seq_term;
=TEX
=SML
val Ûz_cross_termÝ : TERM = ña ¸ b®;
fun Ûz_crossÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_cross_term
);
=TEX
=SML
val Ûz_override_termÝ : TERM = ña « b®;
fun Ûz_overrideÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_override_term
);
=TEX
=SML
val Ûz_union_termÝ : TERM = ña À b®;
fun Ûz_many_unionÝ (exps : Z_EXP list) : Z_EXP = (
let	fun non_empty (e::rest) = (
		if (((length o snd o dest_z_setd) e) = 0 handle _ => false)
		then
			non_empty rest
		else
			e::non_empty rest
	) | non_empty _ = [];
	fun aux (exps as e1::e2::rest) = (
		cn_subst [(e1, "a"), (aux (e2::rest), "b")] z_union_term
	) | aux [e] = e
	  | aux _ = fail "z_many_union" 508024 [];
in
	(aux o non_empty) exps
end
);
=TEX
=SML
fun Ûz_muÝ (env : CN_ENV) (id : Z_ID, p : Z_PRED) : Z_EXP = (
let	val ty = case env id of
		Value (ty, _) => ty
		|Nil =>	fail "z_mu" 508021 [fn()=>id];

	val dexp = mk_z_gvar(id, ty, []);
	val decl = mk_z_decl[mk_z_schema_dec (dexp, "")];
	val tm = mk_z_Í (decl, p, mk_z_Ê (dexp, ""));
	val side = Í_gen_semantic_const tm;
in
	tm
end
);
=TEX
=SML
val Ûz_unary_expÝ : (Z_EXP * Z_EXP) -> Z_EXP = mk_z_app;
=TEX
=SML
fun Ûz_bin_expÝ (left : Z_EXP, bop : Z_EXP, right : Z_EXP) : Z_EXP = (
	mk_z_app (bop, mk_z_tuple[left, right])
);
=TEX
=SML
fun Ûz_fun_callÝ (exp :Z_EXP, exps : Z_EXP list) : Z_EXP = (
	case exps of
	[] =>	exp
	|[e] =>		mk_z_app (exp, e)
	|_ => (
		let	val tup = mk_z_tuple exps;
			val side = tuple_gen_semantic_const tup;
		in
			mk_z_app (exp, tup)
		end
	)
);
=TEX
=SML
val Ûz_selectionÝ : (Z_EXP * Z_ID) -> Z_EXP = mk_z_sel‰s;
=TEX
=SML
val Ûz_maplet_termÝ : TERM = ña í b®;
fun Ûz_mapletÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_EXP = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_maplet_term
);
=TEX
=SML
fun Ûother_z_expÝ (exp : Z_EXP) : Z_EXP = exp;
=TEX

\subsection{Z Predicates}
=SML
val Ûz_trueÝ : Z_PRED = mk_z_true;
=TEX
=SML
val Ûz_eqÝ : (Z_EXP * Z_EXP) -> Z_PRED = mk_z_eq;
=TEX
=SML
val Ûz_andÝ : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_±;
=TEX
=SML
fun Ûz_many_andÝ ((exps as e1::e2::rest) : Z_PRED list) : Z_PRED = (
	mk_z_± (e1, z_many_and (e2::rest))
) | z_many_and [e] = e
  | z_many_and _ = fail "z_many_and" 508024 [];
=TEX
=SML
val Ûz_elemÝ : (Z_EXP * Z_EXP) -> Z_EXP = mk_z_;
=TEX

=SML
val Ûz_noteq_termÝ : TERM = ña ½ b®;
fun Ûz_noteqÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_noteq_term
);
=TEX

=SML
val Ûz_less_eq_termÝ : TERM = ña ¼ b®;
fun Ûz_less_eqÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_less_eq_term
);
=TEX

=SML
val Ûz_greater_termÝ : TERM = ña > b®;
fun Ûz_greaterÝ (exp1 : Z_EXP, exp2 : Z_EXP) : Z_PRED = (
	cn_subst [(exp1, "a"), (exp2, "b")] z_greater_term
);
=TEX

=SML
fun Ûz_forallÝ (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_µ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
fun Ûz_existsÝ (zdecls : Z_DECL list, zp : Z_PRED) : Z_PRED = (
	mk_z_¶ (mk_z_decl zdecls, z_true, zp)
);
=TEX

=SML
val Ûz_impÝ : (Z_PRED * Z_PRED) -> Z_PRED = mk_z_´;
=TEX

=SML
fun Ûother_z_predÝ (z_pred : Z_PRED) : Z_PRED = z_pred;
=TEX

\subsection{Z Paragraphs}
=SML
fun Ûz_eq_eqÝ (id : Z_ID, exp : Z_EXP) : PARAINFO = (
	AbbDefInfo (id, [], exp)
);
=TEX

=SML

fun Ûz_schemaÝ (name : Z_ID, decls : Z_DECL list) : PARAINFO = (
let	val z_sch = mk_z_h_schema(mk_z_decl decls, z_true);
	val side = schema_gen_semantic_const z_sch;
in
	AbbDefInfo (name, [], z_sch)
end
);
=TEX

\section{INTEGER LITERALS}\label{INTEGERLITERALS}

The translation of integer literals is non-trivial and several supporting functions for the translation of integer literals are introduced in this section. The function $trans\_int$ is introduced at the end of this section.
=SML
local
=TEX
\subsection{Support for $trans\_int$}

=SML
open	CaseIndependence;
open	Lex;
open	PolyML.Alternative_Div_and_Mod

type ÛNUMBERSÝ = string list;
type ÛNUMERICÝ =
		{base : NUMBERS, m : NUMBERS, n : NUMBERS, expon : NUMBERS};
=TEX

\subsubsection{Phase 1: Recognising Numeric Literals}

In the exponent part when there is a sign, it is just copied into the number. The parser has already ensured that $+$ and $-$ can only appear at the start of an exponent, so a further check is not required here.
=SML
fun Ûrecog_exponent_partÝ (dec as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
	else case c of

		"_" =>	recog_exponent_part (dec, rest)
		|"+" => recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
		|"-" => recog_exponent_part ({base=base,m=m, n=n, expon=expon@[c]}, rest)
		|_ =>	(dec, c::rest)

) | recog_exponent_part (other, []) = (
	(other, [])
);
=TEX
=SML
fun Ûrecog_decimal_partÝ (dec as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		 : (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_decimal_part ({base=base,m=m, n=n@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_decimal_part (dec, rest)
		|"e" => recog_exponent_part (dec, rest)
		|"E" => recog_exponent_part (dec, rest)
		|_ =>	(dec, c::rest)

) | recog_decimal_part (other, []) = (
	(other, [])
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûrecog_based_dec_partÝ (nb as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based_dec_part ({base=base,m=m, n=n@[c], expon=expon}, rest)
	else case c of

		"_" =>	recog_based_dec_part (nb, rest)
		|"#" => recog_numeric (nb, rest)
		|_ =>	(nb, c::rest)

) | recog_based_dec_part (other, []) = (
	fail "trans_int" 0 []
)
=TEX
The failure case below is caught by $trans\_int$.
=SML
and Ûrecog_basedÝ (nb as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_alnum c
	then	recog_based ({base=base,m=m@[c], n=n, expon=expon}, rest)
	else case c of

		"_" =>	recog_based (nb, rest)
		|"." => recog_based_dec_part (nb, rest)
		|"#" => recog_numeric (nb, rest)
		|_ =>	(nb, c::rest)

) | recog_based (other, []) = (
	fail "recog_based" 0 []
)
=TEX

=TEX
=SML
and Ûrecog_numericÝ (num as {base,m,n,expon} : NUMERIC, (c::rest) : NUMBERS)
		: (NUMERIC * NUMBERS) = (
	if is_digit c
	then	recog_numeric ({base=base,m=m@[c], n=n, expon=expon}, rest)
	else case c of

		"_" =>	recog_numeric (num, rest)
		|"." =>	recog_decimal_part (num, rest)
		|"e" => recog_exponent_part (num, rest)
		|"E" => recog_exponent_part (num, rest)
		|"#" => recog_based ({base=m,m=[],n=n,expon=expon}, rest)
		|_ =>	(num, c::rest)
) | recog_numeric other = other;
=TEX
\subsubsection{Phase 2: Generating Integer Literals}

The following gives a lookup table for extended digits to values upto 16.

i.e., $[("0", 0), ("1", 1),...("F", 15)]$.
=SML
val Ûextended_digitsÝ : (string * int) list = (
	combine
		(map string_of_int (interval 0 9)@["A","B","C","D","E","F"])
		(interval 0 15)
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûbased_to_intÝ (10 : int) (sl : NUMBERS) = (
	(nat_of_string o implode) sl handle _ => 0
) | Ûbased_to_intÝ base sl = (
let	val valid = extended_digits to (base-1);
	val sl' = map CaseIndependence.to_upper sl;
	val f = lassoc3 valid;
	fun aux (c::rest) = (
		f c + base * aux rest
	) | aux _ = 0;
in
	(aux o rev) sl' handle _ =>
		fail "based_to_int" 0 []
end);
=TEX
=SML
fun Ûsigned_nat_of_numbersÝ (sl : NUMBERS) : int = (
let	val f = nat_of_string o implode;
in
	case sl of
	("+"::n) => f n
	|("-"::n) => ~(f n)
	|_ => f sl
end);
=TEX
=SML
fun ÛbasepowÝ (_ : int) (0 : int) : int = 1
  | basepow base n = base * basepow base (n-1);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûconvert_base_expÝ ((base, m, expon) : (int*int*int)) : int = (
	if expon > 0
	then	m * basepow base expon
	else	let	val d = basepow base (~expon);
			val res = m div d;
		in
			if res * d = m
			then
				res
			else
				fail "convert_base_exp" 0 []
		end
);
=TEX
=SML
fun Ûno_of_digits_inÝ (base : int) (n : int) : int = (
	if quot (n, base) > 0
	then
		1 + no_of_digits_in base (n div base)
	else
		1
);
=TEX
The failure case below is caught by $trans\_int$.
=SML
fun Ûconvert_base_dec_expÝ ((base, m, n, expon) : (int*int*int*int)) : int = (
let	val nd = (no_of_digits_in base n) - 1;
	val df = expon - nd;
	val offset = basepow base nd;
in
	if df >= 0
	then
		 convert_base_exp (base, (m * offset + n - offset), df)
	else
		fail "nil_aux" 0 []
end);
=TEX
In the following, ``1'' is prefixed to the decimal part in order to preserve leadnig zeros when converting to an integer. It is removed in $convert\_base\_dec\_exp$.
=SML
fun Ûnumeric_to_int_litÝ ({base,m,n,expon} : NUMERIC) : int = (
let	val nbase = (nat_of_string o implode) base handle _ => 10;
	fun add_prefix (n as (_::_)) = "1"::n
	  | add_prefix _ = [];
	val nm = based_to_int nbase m;
	val nn = ((based_to_int nbase) o add_prefix) n;
	val nexpon = signed_nat_of_numbers expon handle _ => 0;
in
	case (nbase,nm,nn,nexpon) of
	(10, _, 0, 0) => nm
	|(_, _, 0, _) => convert_base_exp (nbase,nm,nexpon)
	|_ => convert_base_dec_exp (nbase,nm,nn,nexpon)

end);
=TEX
\subsection{The Function $trans\_int$}
=SML
in (* of local ... in *)
=TEX
=SML
fun Ûtrans_intÝ (i : INT_LIT) : int = (
	( (numeric_to_int_lit o fst o recog_numeric)
		({base=[],m=[],n=[],expon=[]}, explode i)
	) handle Fail _ => fail "trans_int" 508025 [fn()=>i]
);
=TEX
=SML
end (* of local ... in *);
=TEX

\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{Translating Identifiers}
=SML
fun Ûtrans_idÝ (id : ID) : Z_ID = (

let	fun aux (c::rest) = (
		case c of
		"." => "o"::aux rest
		|"'" => "v"::aux rest
		|_ => c::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
);
=TEX
=SML
val		ÛzfstÝ = trans_id "FIRST"
	and	ÛzlstÝ = trans_id "LAST"
	and	ÛzsucÝ = trans_id "SUCC"
	and	ÛzpredÝ = trans_id "PRED"
	and	ÛzposÝ = trans_id "POS"
	and	ÛzvalÝ = trans_id "VAL"
	and	ÛzlengthÝ = trans_id "LENGTH"
	and	ÛzrangeÝ = trans_id "RANGE";
=TEX
=SML
fun Ûexp_idÝ (env : CN_ENV) (ident : ID) : Z_EXP = (
	zid env (trans_id ident)
)
=TEX
\subsection{Translating Aggregates (Positional Array)}
=SML
and Ûexp_array_agg_posÝ (env : CN_ENV) ({tmark, comps} : EXP AGG_POS) : Z_EXP = (
let	val zop = z_minus;
	val zleft = z_num 1;
	val zright = zid env (trans_id tmark ^^ zfst);
	val zseq = map (trans_exp env) comps;
in
	z_rel_comp(z_power(zsucc, z_bin_exp(zleft,zop, zright)), z_seq zseq)
end
)
=TEX
\subsection{Translating Aggregates (Positional Array with Others)}
=SML
and Ûexp_array_agg_pos_othersÝ (env : CN_ENV) ({agg_pos as {tmark,comps},
		others} : EXP AGG_POS_OTHERS) : Z_EXP = (
	z_override(trans_exp env (EArrayAggOthers {tmark=tmark,others=others}),
		trans_exp env (EArrayAggPos agg_pos))
)
=TEX
\subsection{Translating Aggregates (Positional Array with Just Others)}
=SML
and Ûexp_array_agg_othersÝ (env : CN_ENV) ({tmark,
		others={others=ot}} : EXP AGG_OTHERS) : Z_EXP = (
	z_cross(zid env (trans_id tmark ^^ zrange), z_set [trans_exp env ot])
)
=TEX
\subsection{Translating Aggregates (Named Array)}
=SML
and Ûtrans_named_assocÝ	(env : CN_ENV)
				({choice,comp} : (AGG_CHOICE,EXP) NAMED_ASSOC)
					: Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		ACAggChoiceRange (DRRange(RRange{lo,hi})) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|ACAggChoiceRange (DRRange _) =>
			go_informal "trans_named_assoc" 508020 []
		|ACAggChoiceRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|ACAggChoiceRange (DRConstrained _) =>
			go_informal "trans_named_assoc" 508020 []
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		ACAggChoiceSingle exp =>
			trans_exp env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choice;
	val zsingles = z_set (aux_singles choice);
in
	z_cross (z_many_union(zranges @ [zsingles]), z_set [trans_exp env comp])
end
)
=TEX
=SML
and Ûexp_array_agg_namedÝ (env : CN_ENV) ({named_assocs}
		: (AGG_CHOICE,EXP) AGG_NAMED) : Z_EXP = (
	z_many_union (map (trans_named_assoc env) named_assocs)
)
=TEX
\subsection{Translating Aggregates (Named Array with Others)}
=SML
and Ûexp_array_agg_named_othersÝ (env : CN_ENV) ({tmark,agg_named,others}
		: (AGG_CHOICE,EXP) AGG_NAMED_OTHERS) : Z_EXP = (
	z_override(trans_exp env (EArrayAggOthers {tmark=tmark,others=others}),
		trans_exp env (EArrayAggNamed agg_named))
)
=TEX
\subsection{Translating Aggregates (Positional Record)}
=SML
and Ûretrieve_record_componentsÝ (env : CN_ENV) (tmark : TMARK) :
		(TMARK * TYPE) list = (
	(dest_z_schema_type o dest_z_power_type o type_of o (zid env))
	tmark
	handle _ => fail "retrieve_record_components" 508026 [fn()=>tmark]
)
=TEX
=SML
and Ûexp_rec_agg_pos_zÝ (env : CN_ENV) ((tmark, comps) : TMARK * Z_EXP list)
		: Z_EXP = (
let	val record_components = retrieve_record_components env tmark;
	fun env' id = (
		case lassoc5 record_components id of
		Value ty => Value (ty, EIEnvVar tmark)
		|Nil => env id
	);
	val ap_components = combine ((map fst) record_components) comps
		handle _ => fail "exp_rec_agg_pos" 508027 [fn()=>tmark];
	val zp = z_many_and (
		map
		(fn (decl_i_var, comps_i) =>
		   z_eq(zid env' (trans_id decl_i_var), comps_i))
			ap_components
	);

in
	z_mu env' (trans_id tmark, zp)
end
)
=TEX
\subsection{Translating Aggregates (Named Record)}
=SML
and Ûid_exs_of_named_assocsÝ (nas : (AGG_CHOICE,EXP) NAMED_ASSOC list)
		: (TMARK * EXP) list = (
let	fun named_assoc_to_id_exs {choice, comp} = (
	let	fun aux (ch::rest) comp = (
			case ch of
			ACAggChoiceSingle exp => (
					(name_to_tmark exp, comp)::aux rest comp
			) |_ => go_informal "exp_rec_agg_named" 508020 []
		) | aux _ _ = [];
	in
		aux choice comp 
	end);
in
	flat (map named_assoc_to_id_exs nas)
end
)
=TEX
=SML
and Ûexp_rec_agg_namedÝ (env : CN_ENV) ({tmark, named_assocs}
		: (AGG_CHOICE,EXP) REC_AGG_NAMED) : Z_EXP = (
let	val record_components = retrieve_record_components env tmark;
	fun env' id = (
		case lassoc5 record_components id of
		Value ty => Value (ty, EIEnvVar tmark)
		|Nil => env id
	);
	val zp = z_many_and (
		map
		(fn (ident, ex) => z_eq(zid env' (trans_id ident), trans_exp env' ex))
		(id_exs_of_named_assocs named_assocs)
	);
in
	z_mu env' (trans_id tmark, zp)
end
)
=TEX

\subsection{Translating Unary Expressions}
=SML
and Ûtrans_unary_opÝ (uop : UNARY_OP) = (
	case uop of
	UOSparkUnaryMinus => z_unary_minus
	|UOSparkNot => z_bool_not
	|UOSparkAbs => z_abs
	|USSparkUnaryAdd => fail "trans_unary_op" 508028 []
)
=TEX
=SML
and Ûexp_unary_expÝ (env : CN_ENV) ({uop, right} : EXP UNARY_EXP) : Z_EXP = (
	case uop of
	UOSparkUnaryAdd => trans_exp env right
	|_ => 	z_unary_exp (trans_unary_op uop, trans_exp env right)
)
=TEX

\subsection{Translating Binary Expressions}
=SML
and Ûtrans_bin_opÝ (bop : BIN_OP) = (
	case bop of
	BOSparkAnd => z_bool_and
	|BOSparkAndThen =>
		go_informal "trans_bin_op" 508029 []
	|BOSparkOr => z_bool_or
	|BOSparkOrElse =>
		go_informal "trans_bin_op" 508030 []
	|BOSparkXor => z_bool_xor
	|BOSparkEq => z_bool_eq
	|BOSparkNotEq => z_bool_noteq
	|BOSparkLess => z_bool_less
	|BOSparkLessEq => z_bool_less_eq
	|BOSparkGreater => z_bool_greater
	|BOSparkGreaterEq => z_bool_greater_eq
	|BOSparkAdd => z_add
	|BOSparkMinus => z_minus
	|BOSparkTimes => z_times
	|BOSparkIntdiv => z_intdiv
	|BOSparkMod => z_mod
	|BOSparkRem => z_rem
	|BOSparkExpon => z_expon
	|BOSparkMem => z_bool_mem
	|BOSparkNotMem => z_bool_notmem
	|BOSparkConcat => go_informal "trans_bin_op" 508031 []
)
=TEX
=SML
and Ûexp_bin_expÝ (env : CN_ENV) ({left, bop, right} : EXP BIN_EXP) : Z_EXP = (
	z_bin_exp (trans_exp env left, trans_bin_op bop, trans_exp env right)
)
=TEX
\subsection{Translating Membership of a Range}
=SML
and Ûexp_mem_rangeÝ (env : CN_ENV) ({left, mop, range} : EXP MEM_RANGE)
		: Z_EXP = (
let	val {lo=lo, hi=hi} = trans_range range;
	val zright = z_rng(trans_exp env lo, trans_exp env hi);
in
	z_bin_exp (trans_exp env left, trans_bin_op mop, zright)
end
)
=TEX

\subsection{Translating Attributes}
=SML
and Ûexp_attribÝ (env : CN_ENV) ({prefix, attribute_desig=ADAttrib att}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
	zid env (trans_id (name_to_tmark prefix) ^^ trans_id att)
)
=TEX
The following covers $Exp\_Attrib\_Arg$
=SML
  | Ûexp_attribÝ env ({prefix, attribute_desig=ADAttribArg(att,arg)}
		: (EXP,ATTRIB_DESIG) ATTRIBUTE) : Z_EXP = (
let	val zfun = zid env (trans_id (name_to_tmark prefix) ^^ trans_id att);
	val zargs = [trans_exp env arg];
in
	z_fun_call (zfun, zargs)
end
)
=TEX
\subsection{Translating Indexed Components}
=SML
and Ûexp_indexed_compÝ (env : CN_ENV) ({prefix, index} : EXP INDEXED_COMP)
		: Z_EXP = (
let	val zfun = trans_exp env prefix;
	val zargs = [trans_exp env index];
in
	z_fun_call (zfun, zargs)
end
)
=TEX
\subsection{Translating Selected Components}
=SML
and Ûexp_selected_compÝ (env : CN_ENV) ({prefix, selector} : EXP SELECTED_COMP)
		: Z_EXP = (
	z_selection (trans_exp env prefix, trans_id selector)
)
=TEX
\subsection{Translating Functions Calls}
=SML
and Ûexp_fun_callÝ (env : CN_ENV) ({fun_name, args} : EXP FUN_CALL) : Z_EXP = (
	z_fun_call (zid env (trans_id fun_name), map (trans_exp env) args)
)
=TEX
\subsection{Translating Integer Literals}
The function $trans\_int$ is defined in section \ref{INTEGERLITERALS}.
=SML
and Ûexp_int_litÝ (n : INT_LIT) : Z_EXP = (
	z_num (trans_int n)
)
=TEX
\subsection{Translating Auxiliary Expressions}
=SML
and Ûexp_auxiliary_expÝ (ae : Z_TM) : Z_EXP = (
	z_predexp_of_z_tm ae
)
=TEX
\subsection{The Function $trans\_exp$}
=SML
and Ûtrans_expÝ (env : CN_ENV) ((EId id) : EXP) : Z_EXP = exp_id env id
  | trans_exp env (EInt n) = exp_int_lit n
  | trans_exp env (EArrayAggPos ap) = exp_array_agg_pos env ap
  | trans_exp env (EArrayAggPosOthers ap) = exp_array_agg_pos_others env ap
  | trans_exp env (EArrayAggOthers ao) = exp_array_agg_others env ao
  | trans_exp env (EArrayAggNamed an) = exp_array_agg_named env an
  | trans_exp env (EArrayAggNamedOthers an) = exp_array_agg_named_others env an
  | trans_exp env (ERecAggPos {tmark, comps}) =
		exp_rec_agg_pos_z env (tmark, map (trans_exp env) comps)
  | trans_exp env (ERecAggNamed an) = exp_rec_agg_named env an
  | trans_exp env (EUnaryExp ue) = exp_unary_exp env ue
  | trans_exp env (EBinExp be) = exp_bin_exp env be
  | trans_exp env (EMemRange be) = exp_mem_range env be
  | trans_exp env (EAttribute at) = exp_attrib env at
  | trans_exp env (EIndexedComp ic) = exp_indexed_comp env ic
  | trans_exp env (ESelectedComp sc) = exp_selected_comp env sc
  | trans_exp env (EFunCall fc) = exp_fun_call env fc
  | trans_exp env (EAuxiliaryExp ae) = exp_auxiliary_exp ae
  | trans_exp env (EQualifiedExp qe) = fail "trans_exp" 508032 []
  | trans_exp env (ETypeConversion tc) = fail "trans_exp" 508036 []
  | trans_exp env (EBracketed e) = trans_exp env e
  | trans_exp env (EStringLiteral c) = go_informal "trans_exp" 508033 []
  | trans_exp env (ECharacterLiteral c) = go_informal "trans_exp" 508034 []
;
=TEX
The following variant of $trans\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a warning message is printed out and $Nil$ is returned.
=SML
fun Ûtrans_exp1Ý (env : CN_ENV) (exp : EXP) : Z_EXP OPT = (
	Value (trans_exp env exp)
	handle Informal => Nil
);
=TEX

\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}

=SML
fun Ûnamed_assocs_to_expsÝ (names : ID list)
		(ns : (AGG_CHOICE,EXP) NAMED_ASSOC list) : EXP list = (
let	val lns = length ns;
	val table =	if lns = length names
			then	combine names (interval 0 (length ns - 1))
			else	fail "named_assocs_to_exps" 508043 [];
	fun aux1 ((ACAggChoiceSingle exp)::rest) = (
		(	lassoc3 table (name_to_tmark exp)
				handle _ => fail "named_assocs_to_exps" 508044
					[fn()=>name_to_tmark exp]
		)::aux1 rest
	) | aux1 ((ACAggChoiceRange _)::_) = (
		fail "named_assocs_to_exps" 508045 []
	) | aux1 _ = [];
	fun aux2 ({choice=cs,comp}::rest) = (
	let	val chmap = map (fn choice => (choice, comp))(aux1 cs);
	in
		chmap::(aux2 rest)
	end) | aux2 _ = [];
	val s = flat (aux2 ns);
	fun order (a:int,_) (b,_) = a-b;
	val nssorted = Sort.sort order s;
	fun aux3 count ((i, exp)::rest) = (
		if count=i
		then
			exp::aux3 (count+1) rest
		else
			fail "named_assocs_to_exps" 508043 []
	) | aux3 _ _ = [];
in
	aux3 0 nssorted
end);
=TEX

=SML
fun Ûadjust_rangelohiÝ (env : CN_ENV) ({lo=l, hi=h} : EXP RANGELOHI) = (
	{lo=adjust_exp env l, hi=adjust_exp env h}
)
and Ûadjust_rangeÝ (env : CN_ENV) (RRange x : EXP RANGE) = (
	RRange (adjust_rangelohi env x)
) | adjust_range env (RRangeAttr x : EXP RANGE) = (
	RRangeAttr (adjust_exp env x)
)
and Ûadjust_discrete_range_constrainedÝ (env : CN_ENV) ({tmark=t, range=r} :
		EXP DISCRETE_RANGE_CONSTRAINED) = (
	{tmark=t, range=adjust_range env r}
)
and Ûadjust_discrete_rangeÝ (env : CN_ENV) (DRRange x : DISCRETE_RANGE) = (
	DRRange (adjust_range env x)
) | adjust_discrete_range env (DRConstrained x : DISCRETE_RANGE) = (
	DRConstrained(adjust_discrete_range_constrained env x)
)
and Ûadjust_agg_choiceÝ (env : CN_ENV) (ACAggChoiceRange x : AGG_CHOICE) = (
	ACAggChoiceRange (adjust_discrete_range env x)
) | adjust_agg_choice env(ACAggChoiceSingle x : AGG_CHOICE) = (
	ACAggChoiceSingle (adjust_exp env x)
)
and Ûadjust_named_assocÝ (env : CN_ENV) ({choice=c, comp=e}
		: (AGG_CHOICE, EXP) NAMED_ASSOC) = (
	{choice=map (adjust_agg_choice env) c, comp=adjust_exp env e}
)
and Ûadjust_othersÝ (env : CN_ENV) ({others=oth} : EXP OTHERS) = (
	{others=adjust_exp env oth}
)
and Ûadjust_agg_posÝ (env : CN_ENV) ({tmark=t, comps=c} : EXP AGG_POS) = (
	case env t of
	Value (ty, EIEnvRecordType) => (
			ERecAggPos {tmark=t, comps=map (adjust_exp env) c}
        ) |_ => (
			EArrayAggPos {tmark=t, comps=map (adjust_exp env) c}
	)
)
and Ûadjust_agg_pos_othersÝ (env : CN_ENV) ({agg_pos = {tmark=t, comps=c} :
		EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) = (
	EArrayAggPosOthers {	agg_pos={	tmark=t,
						comps=map (adjust_exp env) c},
				others=adjust_others env oth}
)
and Ûadjust_agg_othersÝ	(env : CN_ENV)
				({tmark=t, others=oth} : EXP AGG_OTHERS) = (
         EArrayAggOthers{tmark=t, others=adjust_others env oth}
)
and Ûadjust_agg_namedÝ (env : CN_ENV) ({named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
	EArrayAggNamed {named_assocs=map (adjust_named_assoc env) n}
)
and Ûadjust_agg_named1Ý (env : CN_ENV) (t : TMARK) ({named_assocs=n}
		: (AGG_CHOICE, EXP) AGG_NAMED) = (
let	val n' = map (adjust_named_assoc env) n;
in
	case env t of
	Value (ty, EIEnvRecordType) => (
			ERecAggNamed {tmark=t, named_assocs=n'}
        ) |_ => (
			EArrayAggNamed {named_assocs=n'}
	)
end
)
and Ûadjust_agg_named_othersÝ (env : CN_ENV) ({tmark=t, agg_named=a, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) = (
let	val adjagg = case adjust_agg_named1 env t a of
		EArrayAggNamed ag => (
			ag
		) | _ => fail "adjust_exp" 508046 []
in
	EArrayAggNamedOthers{tmark=t, agg_named=adjagg,others=adjust_others env oth}
end
)
and Ûadjust_unary_expÝ (env : CN_ENV) ({uop=u, right=r} : EXP UNARY_EXP) = (
	EUnaryExp{uop=u, right=adjust_exp env r}
)
and Ûadjust_bin_expÝ (env : CN_ENV) ({bop=b, left=l, right=r} : EXP BIN_EXP) = (
	EBinExp{left=adjust_exp env l, bop=b, right=adjust_exp env r}
)
and Ûadjust_attrib_desigÝ (env : CN_ENV) (ADAttrib x : ATTRIB_DESIG) = (
	ADAttrib x
) | adjust_attrib_desig env (ADAttribArg (a,e) : ATTRIB_DESIG) = (
	ADAttribArg (a, adjust_exp env e)
)
and Ûadjust_mem_rangeÝ	(env : CN_ENV)
				({mop=m, left=l, range=r} : EXP MEM_RANGE) = (
	EMemRange{left=adjust_exp env l, mop=m, range=adjust_range env r}
)
and Ûadjust_attributeÝ (env : CN_ENV) ({prefix=p, attribute_desig=a} :
		(EXP, ATTRIB_DESIG) ATTRIBUTE) = (
	EAttribute{prefix=adjust_exp env p, attribute_desig=adjust_attrib_desig env a}
)
and Ûadjust_indexed_compÝ	(env : CN_ENV)
				({prefix=p, index=i} : EXP INDEXED_COMP) = (
let	val prename = name_to_tmark p;
in
	case (env prename, i) of
=TEX
Is it a function call?
=SML
	(Value (_, EIEnvFunction _), EArrayAggPos{comps,...}) => (
		EFunCall{fun_name=prename, args=map (adjust_exp env) comps}
	) |(Value (_, EIEnvFunction names), EArrayAggNamed{named_assocs}) => (
	let	val args = named_assocs_to_exps names named_assocs;
	in
		EFunCall{fun_name=prename, args=map (adjust_exp env) args}
	end
=TEX
Is it a type conversion?
=SML
	) |(Value (_, EIEnvRecordType), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
	) |(Value (_, EIEnvOtherType), EArrayAggPos{comps=[comp],...}) => (
		ETypeConversion{tmark=prename, exp= (adjust_exp env) comp}
=TEX
No... It must be an indexed component for real. So check for errors...
=SML
	) |(_, EArrayAggPos{comps=[comp],...}) => (
		EIndexedComp{prefix=adjust_exp env p,
					index = adjust_exp env comp}

	) |(_, EArrayAggPos _) => (
		go_informal "adjust_indexed_comp" 508035 []

	) |(_, EArrayAggNamed _) => (
		fail "adjust_indexed_comp" 508047 [fn()=>name_to_tmark p]

	) |_ => (
		fail "adjust_indexed_comp" 508048 [fn()=>prename]

	)
end
)
and Ûadjust_selected_compÝ env ({prefix=p, selector=s} : EXP SELECTED_COMP) = (
	case p of
	EId id => (
		case env id of
		Value (ty, _) => (
			(	(dest_z_schema_type ty);
				ESelectedComp{prefix=adjust_exp (env : CN_ENV) p,
							selector=s}	)
			handle Fail _ => adjust_exp env (EId (id^"."^s))
		)| _ =>
			adjust_exp env (EId (id^"."^s))

	) | _ => 	(
		ESelectedComp{prefix=adjust_exp (env : CN_ENV) p, selector=s}
	)
)
and Ûadjust_qualified_expressionÝ
				(env : CN_ENV)
				({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	case e of
	EArrayAggPos{comps,...} => (
		adjust_agg_pos env {comps=comps, tmark=t}
	)| EArrayAggPosOthers{agg_pos={comps,...}, others} => (
		adjust_agg_pos_others env 
			{agg_pos={comps=comps,tmark=t},others=others}
	)| EArrayAggOthers{others,...} => (
		adjust_agg_others env {others=others,tmark=t}
	)| EArrayAggNamed an => (
		 adjust_agg_named1 env t an
	)| EArrayAggNamedOthers {agg_named, others,...} => (
		adjust_agg_named_others env 
			{agg_named=agg_named, others=others, tmark=t}
	)|_ => fail "adjust_qualified_exp" 508042 []
)
=TEX
In the following, both named and positional record aggregates and function calls
need no adjustment since these constructs can only be produced by adjust\_exp.
If they occur in the input then it adjust\_exp will already have been called
and need not be called again.
=SML
and Ûadjust_expÝ (env : CN_ENV) (exp as (EId id : EXP)) = (
	EId id
) | adjust_exp env (exp as (EInt _)) = (
	exp
) | adjust_exp env (exp as (EArrayAggPos x)) = (
	adjust_agg_pos env x
) | adjust_exp env (exp as (EArrayAggPosOthers x)) = (
	adjust_agg_pos_others env x
) | adjust_exp env (exp as (EArrayAggOthers x)) = (
	adjust_agg_others env x
) | adjust_exp env (exp as (EArrayAggNamed x)) = (
	adjust_agg_named env x
) | adjust_exp env (exp as (EArrayAggNamedOthers x)) = (
	adjust_agg_named_others  env x
) | adjust_exp env (exp as (ERecAggPos x)) = (
	exp
) | adjust_exp env (exp as (ERecAggNamed x)) = (
	exp
) | adjust_exp env (exp as (EUnaryExp x)) = (
	adjust_unary_exp env x
) | adjust_exp env (exp as (EBinExp x)) = (
	adjust_bin_exp env x
) | adjust_exp env (exp as (EMemRange x)) = (
	adjust_mem_range env x
) | adjust_exp env (exp as (EAttribute x)) = (
	adjust_attribute env x
) | adjust_exp env (exp as (EIndexedComp x)) = (
	adjust_indexed_comp env x
) | adjust_exp env (exp as (ESelectedComp x)) = (
	adjust_selected_comp env x
) | adjust_exp env (exp as (EFunCall _)) = (
	exp
) | adjust_exp env (exp as (EAuxiliaryExp _)) = (
	exp
) | adjust_exp env (exp as (EQualifiedExp x)) = (
	adjust_qualified_expression env x
) | adjust_exp env (exp as (ETypeConversion _)) = (
	exp
) | adjust_exp env (exp as (EBracketed x)) = (
	adjust_exp env x
) | adjust_exp env (exp as (EStringLiteral _)) = (
	exp
) | adjust_exp env (exp as (ECharacterLiteral _)) = (
	exp
);
=TEX
The following variant of $adjust\_exp$ returns an optional Z expression. If the SPARK expression can only be handled informally then a warning message is printed out and $Nil$ is returned.
=SML
fun Ûadjust_exp1Ý (env : CN_ENV) (exp : EXP) : EXP OPT = (
	Value (adjust_exp env exp)
	handle Informal => Nil
);
=TEX


\section{TRANSLATING SPARK BASIC DECLARATIONS}

\subsection{Translating Constants}

=SML
fun Ûbasic_decl_constÝ
		(env : CN_ENV)
		({consts=consts, tm=tm, expr=expr} : EXP CONST_DECL) = (
	map (fn c => z_eq_eq(trans_id c, trans_exp env expr)) consts
);
=TEX
\subsection{Translating Enumeration Types}
=SML
val Ûú_tyÝ = ”ú®;
val Ûðú_tyÝ = type_of ñú®;
val Ûúú_tyÝ = type_of ñú ¸ ú®;
=TEX
=SML
fun Ûenum_attribÝ (env : CN_ENV) (zid‰1, zid‰2, zid‰3) = (
let	fun env' id = 
		if id = (zid‰1 ^^ zlst)
		then	Value (ú_ty, EIEnvOther)
		else if id mem [zid‰1 ^^ zsuc, zid‰1 ^^ zpos]
		then	Value (úú_ty,EIEnvOther)
		else	env id;
	val zexp = z_set_minus (zid env' zid‰1, z_set [zid env' (zid‰1 ^^ zlst)]);
in
	[z_eq_eq (zid‰1 ^^ zfst, zid env' zid‰2),
	z_eq_eq (zid‰1 ^^ zlst, zid env' zid‰3),
	z_eq_eq (zid‰1 ^^ zsuc, z_dom_res (zexp, zsucc)),
	z_eq_eq(zid‰1 ^^ zpred, z_inv(zid env' (zid‰1 ^^ zsuc))),
	z_eq_eq(zid‰1 ^^ zpos, z_id_rel (zid env' zid‰1)),
	z_eq_eq(zid‰1 ^^ zval, z_inv(zid env' (zid‰1 ^^ zpos)))]
end);
=TEX
=SML
fun Ûbasic_decl_enumÝ (env : CN_ENV) (name : ID) (td : ENUM_TYPE_DEF) = (
let	val {vals} = td;
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map z_num (interval 0 ((length vals)-1));
	fun env' id = (
		if id mem zvals
		then
			Value (ú_ty, EIEnvOther)
		else if id = zname
		then
			Value (ðú_ty, EIEnvOther)
		else
			env id
	);
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid env' (head zvals), zid env' (last zvals)))] @
	enum_attrib env' (zname, head zvals, last zvals)
end);
=TEX
\subsection{Translating Array Types}
=SML
fun Ûarray_attribÝ (env : CN_ENV) (zid‰1 : Z_ID, zid‰2 : Z_ID) : PARAINFO list = (
	[z_eq_eq(zid‰1 ^^ zfst, zid env (zid‰2 ^^ zfst)),
	z_eq_eq(zid‰1 ^^ zlst, zid env (zid‰2 ^^ zlst)),
	z_eq_eq(zid‰1 ^^ zlength, z_size (zid env zid‰2)),
	z_eq_eq(zid‰1 ^^ zrange, zid env zid‰2)]
);
=TEX
=SML
fun Ûbasic_decl_con_arrayÝ (env : CN_ENV) (name : ID) (td : ARRAY_DEF) = (
let	val {index=index, comp=comp} = td;
	val ind = case index of
			[ind] => ind
			|_ => go_informal "basic_decl_con_array" 508035 [];
	val zname = trans_id name;
	val zindex = trans_id ind;
	val zcomp = trans_id comp;
in
	[z_eq_eq(zname, z_tfun(zid env zindex, zid env zcomp))] @
		array_attrib env (zname, zindex)
end);
=TEX
=SML
fun Ûbasic_decl_uncon_arrayÝ (env : CN_ENV) (name : ID) (td : ARRAY_DEF) = (
let	val {index=index, comp=comp} = td;
	val ind = case index of
			[ind] => ind
			|_ => go_informal "basic_decl_uncon_array" 508035 []
	val zname = trans_id name;
	val zindex = trans_id ind;
	val zcomp = trans_id comp;
in
	[z_eq_eq(zname, z_pfun(zid env zindex, zid env zcomp))]
end);
=TEX

\subsection{Translating Record Types}
=SML
fun Ûconv_var_declÝ ({vars=vs, tmark=t} : VAR_DECL)
		: {var : ID, tmark : TMARK} list = (
	 map (fn id => {var=id, tmark=t}) vs
);
=TEX
=SML
fun Ûtrans_declÝ (env : CN_ENV) ({vars, tmark} : VAR_DECL) : Z_DECL = (
let	val zvs = map trans_id vars;
	val zexp = zid env (trans_id tmark);
	val zvars = map (fn zv => mk_z_lvar (zv,
						(dest_z_power_type o type_of) zexp,
						[])) zvs;
in
	mk_z_dec (zvars, zexp)
end);
=TEX
=SML
fun Ûbasic_decl_recordÝ (env : CN_ENV) (name : ID)
		({decl} : RECORD_TYPE_DEF) = (
let	val z_sname = trans_id name;
	val z_decls = map (trans_decl env) decl;
in
	[z_schema(z_sname, z_decls)]
end);
=TEX
\subsection{Translating Integer Types}
=SML
fun Ûint_type_attribÝ (env : CN_ENV) (zid‰1, range) = (
let	val {lo, hi} = trans_range range;
in
	[z_eq_eq(zid‰1 ^^ zfst, trans_exp env lo),
	z_eq_eq(zid‰1 ^^ zlst, trans_exp env hi)]
end
);
=TEX
=SML
fun Ûbasic_decl_int_typeÝ (env : CN_ENV) (name : ID) (range : EXP RANGE) = (
let	val {lo, hi} = trans_range range;
	val zname = trans_id name;
in
	[z_eq_eq(zname, z_rng(trans_exp env lo, trans_exp env hi))] @
		int_type_attrib env (zname, RRange{lo=lo,hi=hi})
end
);
=TEX

\subsection{Translating Subtypes}
=SML
fun Ûrange_con_attribÝ (env : CN_ENV) (zid‰1 : Z_ID, zid‰2 : Z_ID, {lo,hi}
		: EXP RANGELOHI) : PARAINFO list = (
	[z_eq_eq (zid‰1 ^^ zfst, trans_exp env lo),
	z_eq_eq (zid‰1 ^^ zlst, trans_exp env hi),
	z_eq_eq (zid‰1 ^^ zsuc, zid env (zid‰2 ^^ zsuc)),
	z_eq_eq (zid‰1 ^^ zpred, zid env (zid‰2 ^^ zpred)),
	z_eq_eq (zid‰1 ^^ zpos, zid env (zid‰2 ^^ zpos)),
	z_eq_eq (zid‰1 ^^ zval, zid env (zid‰2 ^^ zval))]
);
=TEX

=SML
fun Ûbasic_decl_subtype_range_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		(range : EXP RANGE) = (
let	val (lo, hi) =
		case range of
		RRange{lo,hi} => (lo, hi)
		|_ => go_informal "basic_decl_subtype_range_con" 508020 [];
	val zname = trans_id name;
	val ztmark = trans_id tmark;
in
	[z_eq_eq(zname, z_rng(trans_exp env lo, trans_exp env hi))] @
		range_con_attrib env (zname, ztmark, {lo=lo,hi=hi})
end
);
=TEX

=SML
fun Ûbasic_decl_subtype_index_conÝ (env : CN_ENV) (name : ID) (tmark : TMARK)
		(ci : EXP list) = (
let	val zname = trans_id name;
	val index = map name_to_tmark ci;
	val ind = case index of
			[ind] => ind
			|_ => go_informal "basic_decl_subtype_index_con" 508035 []
	val zindex = trans_id ind;
	val zexp = zid env (trans_id tmark);
	val var =  "UNC";
	val zvar_ty = dest_z_power_type(type_of zexp);
	val env' = fn id => if id = "UNC" then Value (zvar_ty, EIEnvVar tmark)
					else env id; 
	val zp = z_eq (z_dom (zid env' var), zid env' zindex);
in
	[z_eq_eq (zname, z_set_comp (trans_decl env' {vars=[var],tmark=tmark}, zp))] @
	array_attrib env' (zname, zindex)
end
);
=TEX

\subsection{The Function $trans\_basic\_decl$}
=SML
fun Ûtrans_basic_declÝ (env : CN_ENV) ((BDConstDecl {consts,tm,expr}) : BASIC_DECL)
		: PARAINFO list = (
	basic_decl_const env {consts=consts, tm=tm, expr=adjust_exp env expr}
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDEnumTypeDef td,...}) = (
	basic_decl_enum env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDIntTypeDef range,...}) = (
	basic_decl_int_type env name range
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDConArrayDef td,...}) = (
	basic_decl_con_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDUnconArrayDef td,...}) = (
	basic_decl_uncon_array env name td
) | trans_basic_decl env (BDTypeDecl {name,type_def=TDRecordTypeDef td,...}) = (
	basic_decl_record env name td
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CRange cr},...}) = (
	basic_decl_subtype_range_con env name tmark cr
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CIndex ci},...}) = (
	basic_decl_subtype_index_con env name tmark ci
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFloating _},...}) = (
	go_informal "trans_basic_decl" 508037 []
) | trans_basic_decl env (BDSubtypeDecl {name,sub_ind={tmark,con=CFixed _},...}) = (
	go_informal "trans_basic_decl" 508038 []
) | trans_basic_decl env (BDTypeDecl {type_def=TDFloatingTypeDef _,...}) = (
	go_informal "trans_basic_decl" 508037 []
) | trans_basic_decl env (BDTypeDecl {type_def=TDFixedTypeDef _,...}) = (
	go_informal "trans_basic_decl" 508038 []
) | trans_basic_decl env (BDDeferredConstDecl _) = (
	go_informal "trans_basic_decl" 508039 []
) | trans_basic_decl env (BDVarDecl _) = (
	go_informal "trans_basic_decl" 508040 []
) | trans_basic_decl env (BDPrivateTypeDecl _) = (
	go_informal "trans_basic_decl" 508041 []
) | trans_basic_decl env (BDPragma _) = (
	[]
) | trans_basic_decl env (BDAnnotation _) = (
	[]
);
=TEX
=SML
fun Ûtrans_basic_decl1Ý (env : CN_ENV) (bd : BASIC_DECL)
			: PARAINFO list OPT = (
	Value (trans_basic_decl env bd)
	handle Informal => Nil
);
=TEX


\section{EPILOGUE}

=SML
end (* structure CNBasicDeclsAndExprs *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
