=IGN
********************************************************************************
usr503.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
Lemma 1 Ltd.% $Date: 2006/09/16 13:43:11 $ $Revision: 1.26 $ $RCSfile: usr503.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[11pt,hol1,fleqn,USR,epsf]{book}
% change depth of section numbering
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
% temporary measure while waiting for LaTeXe to come along
\def\LaTeXe{\LaTeX$2_{\varepsilon}$}
\def\Hide#1{}
% Set the following macros as necessary as release
% numbers change.
\def\texrelease{\TeX\ version 3.1415}
\def\latexrelease{\LaTeXe}
\def\arch{sun4}
\def\solarisrelease{Solaris 2.3}
\def\polyrelease{Poly/ML 3.01X}
\def\quicktexloc{{\tt /QLaTeX}} % NB one location needs this hard wired in
\def\daztool{Compliance Tool}
% just useful macros
\def\ltm{$^{\rm TM}$}
\def\Note#1{{\small\bf[ #1 ]}}
=IGN
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Tool Proof Tutorial}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/USR503}  %% Mandatory field
\def\SCCSversion{$Revision: 1.26 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/09/16 13:43:11 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{G.M.~Prout & HAT Team\\R.D.~Arthan & HAT Team}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Manager}
\TPPabstract{
This document is a Tutorial Guide for the {\daztool} Proof Facilities.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
\begin{tabular}[t]{lr}
A. Smith & DRA\\
Library & WIN01\\
\end{tabular}}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
\def\Hide#1{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPheadcentre{}
%\def\TPPheadcentreproject{}
%\def\TPPheadrhs{}
\let\TPPfootlhs=\TPPfootrhs
\def\TPPfootcentre{$\vcenter{\halign{\hfil\strut##\hfil\cr
COPYRIGHT  \copyright\ Lemma 1 Ltd.\cr}}$}
=TEX
\ftlmargin 0.0in
\ftrmargin 0.0in

\def\SCCSversion{$Revision: 1.26 $%
}
\def\SCCSdate{\FormatDate{$Date: 2006/09/16 13:43:11 $%
}}

\USRmanual{Compliance Tool Proof Tutorial}
\USRref{USR503}
\USRisbns{1514277700}
\USRisbnl{978-1514277706}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}
\makeUSRfrontpage

\underscoreoff

\chapter*{CONTENTS}

\tableofcontents
%\listoffigures

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document gives guidance on the use of the {\daztool} proof facilities supplied with {\Product}.

\section{Readership}
This document is intended to be read by users of the {\daztool} who  wish  to  produce machine-checked proofs of some or all of the VCs generated by the tool. These users are expected to have experience of using {\Product} for proofs in Z; in particular they should be familiar with the material in the \ZTUTORIAL.

\section{Related Publications}

A bibliography is given towards the end of this document.

\begin{itemize}

\item
How to use the {\daztool} is described in :

{\CNUSERGUIDE}.

\item
The syntax and semantics of the Compliance Notation as supported by the {\daztool} is described in:

{\CNNOTATION}

\item
A description of \Product{} may be found in:

{\SOFTSERV},

which also contains a full list of other \Product{} documentation.

\item
How to use \Product{} for formal reasoning about
Z specifications may be found in:

{\ZTUTORIAL}.

\end{itemize}

\section{Area Covered}

The user might typically have already undertaken the following tasks:
\begin{enumerate}
\item
Installed the {\daztool} on his workstation, by following the procedure described in the \CNINSTALLATION
\item
Loaded a sequence of Compliance Notation scripts into the tool and generated the Z documents from the scripts, by following the procedure described in the \CNUSERGUIDE
\end{enumerate}

This tutorial  should then assist the user in working with the VCs, i.e. attempting to prove them, using {\Product} and {\daztool} facilities.
A
Compliance Notation example concerning the computational aspects of a simple calculator is included in this tutorial, see chapter \ref{CALCEX}. Proofs
are provided for some of the VCs generated by this example  to illustrate
the techniques advocated in chapter \ref{VCPRFS}.
\section{Prerequisites} \label{PREREQ}

This Tutorial is designed to assist a {\daztool} user in the production of machine-checked proofs of the VCs generated by the tool. It is {\em not} intended to be an introduction to the Z language, or to the Compliance Notation, or indeed to the {\daztool} itself.

Familiarity with the Compliance Notation  is very desirable, although not essential since VC proofs may be conducted independently without prior knowledge of the specification from which the VCs have been generated. Familiarity with the {\daztool} and with the use of {\Product} for proofs in Z is essential. It is assumed that a user intent on using the {\daztool} for proving VCs  will  be familiar with the material in both the  \ZTUTORIAL\ and the \CNUSERGUIDE.


The \CNNOTATION\ describes the
syntax and semantics  of the Compliance Notation. The \CNUSERGUIDE\  gives an introduction to the use of the {\daztool} for loading a Compliance Notation Script and generating the Z document which contains the VCs.
The \ZTUTORIAL\ gives an introduction to the use of {\Product} for specification and proof in Z.

The {\Product} user documentation is supplied as part of the {\Product} release  included with the {\daztool} and is available for on-line reference.



\section{Acknowledgements}
=IGN
The below are taken from Motif 1.2 Users Guide, July 1993
=TEX
Sun Microsystems is a registered trademark of Sun Microsystems Inc.  Sun-3, OpenWindows, Sun-4, SPARCstation, SunOS and Solaris are trademarks of Sun Microsystems Inc.

Motif is a registered trademark of the Open Software Foundation, Inc.

UNIX is a registered trademark of UNIX System Laboratories, Inc.

Poly/ML is an implementation of Standard ML with a few non-standard extensions.  Poly/ML, and its documentation, is copyright Abstract Hardware Limited.

\TeX{} is copyright the American Mathematical Society and by Donald E. Knuth.
The \LaTeXe\ distribution tape is copyright the \LaTeX\ 3 project and its individual authors.

The X Windows System is a trademark of the Massachusetts Institute of Technology.
\chapter{INTRODUCTION}
This tutorial has been designed to assist in the proof of VCs generated by the
{\daztool}. It is divided into three main areas:
\begin{itemize}
\item
Chapter \ref{ZPROOF} provides a review of how to do proof in Z. Familiarity
with the \ZTUTORIAL\ is considered to be essential before embarking
on VC proofs, see section \ref{PREREQ}, but the \ZTUTORIAL\ covers a lot more than proof in Z. The material
presented in chapter \ref{ZPROOF} concentrates on the
proof aspects of \ProductZ\ . There are also some explicit examples in Z of
material covered fully in the \HTUTORIAL\ but only briefly mentioned in the \ZTUTORIAL. For example, linear arithmetic proofs in \ProductZ\ are
very similar to those in \ProductHOL\, and as such are not covered in detail in
the \ZTUTORIAL.

\item
Chapter \ref{VCPRFS} overviews the extra proof support available in the {\daztool} and describes how to use these facilities to tackle VC proofs.
\item
Chapter \ref{CALCEX} provides an example sequence of literate scripts concerning the computational aspects of a simple calculator. Selected VCs generated from these scripts
are then proven, illustrating the use of techniques described in section
 \ref{VCPRFS}.
\end{itemize}

For reference purposes, a complete listing of the calculator example
theories is in appendix \ref{CALCTH}. The SPARK program generated by the calculator example literate scripts is in appendix \ref{CALCSPARK}.

As with many mathematical activities, proving VCs
is best learnt by doing
rather than reading. The recommended way of using this document is to work through the
examples in an interactive session with the {\daztool}. The source
of this document is provided as part
of the {\daztool} release (as \verb"$PPINSTALLDIR/docs/usr503.doc")
to help you do this.
=TEX
\chapter{REVIEW OF PROOF IN Z}\label{ZPROOF}
\Hide{%
=SML
open_theory"cn";
set_pc"z_library1";
new_script {name="EX", unit_type="proc"};
=TEX
}
This chapter provides an overview of the material in the \ZTUTORIAL\ which describes how to use {\ProductZ} for doing proofs. It is assumed, in particular,
 that you have
 some familiarity with:
\begin{itemize}
\item
how to do backwards proofs, using $set_goal$ and work with the theorems
you have proved using $pop_thm$ and $save_pop_thm$
\item
 proof contexts. The following have been used in the examples:

\begin{tabular}{p{2in}l l}
&$set_pc$, $push_pc$, $pop_pc$\\
&$z_library1$, $z_library1_ext$\\
&$z_lin_arith$\\
&$z_predicates$\\
\end{tabular}

The example proofs in this chapter are all conducted in the proof
context $z_library1$.
\item
tactics and tacticals, etc. The following have been used in the examples:

\begin{tabular}{p{2in}l l}
tactics:&\\
&$strip_tac$, $z_‚àÄ_tac$\\
&$asm_rewrite_tac$\\
&$lemma_tac$, $cases_tac$\\
&$z_spec_asm_tac$\\
&$ante_tac$, $discard_tac$\\
&$fc_tac$, $all_fc_tac$, $asm_fc_tac$, $all_asm_fc_tac$\\
&$eq_sym_asm_tac$, $eq_sym_nth_asm_tac$\\
&$var_elim_asm_tac$, $var_elim_nth_asm_tac$\\
&$all_var_elim_asm_tac$, $all_var_elim_asm_tac1$\\
&$z_app_eq_tac$\\
&$z_‚â§_induction_tac$\\
\end{tabular}

\begin{tabular}{p{2in}l l}
tacticals:&\\
&$REPEAT$\\
&$ALL_FC_T$, $ALL_FC_T1$\\
&$‚áí_T$\\
&$THEN$, $THEN1$\\
&$PC_T1$\\
&$LEMMA_T$\\
&$DROP_NTH_ASM_T$, $LIST_DROP_NTH_ASM_T$
\end{tabular}

\begin{tabular}{p{2in}l l}
canonicalisation functions:&\\
&$fc_‚áî_canon$\\
\end{tabular}

\item
about forward inference: $rewrite_rule$ and $‚àß_right_elim$ have been used
 in the examples
\item
how to access the specification with $z_get_spec$
\end{itemize}

You will find detailed information on all the above in the \REFERENCE.

A full account of using {\ProductZ} for proofs may be found in  the  \ZTUTORIAL,
which, in turn, refers to the \HTUTORIAL. There are some topics, for
example linear arithmetic, which are fully covered in the \HTUTORIAL\ but
to which no special treatment coverage is given in the \ZTUTORIAL. This is because
there is nothing extra to add about working in Z as opposed to HOL.


While it is assumed that you are  familiar with the material presented in these
tutorials, for convenience, a summary of the main methods advocated for dealing with Z proofs is given here. The recommended way of revising the material in
this chapter is to read and try out the examples as
you go along. You may
also find it instructive to attempt the Z exercises from chapter 7
of the \ZTUTORIAL, the solutions to which are in
 chapter 8
of that tutorial.

The revision material is divided into the following sections:
\begin{itemize}
\item[\ref {TWOTACTIC}] Proof by the ``two tactic'' method.
\item[\ref {STRIP}] Stripping.
\item[\ref {AUTOMATIC}] Automatic Proof.
\item[\ref {FORWARD}] Forward Chaining.
\item[\ref {EQUATIONS}] Predicate Calculus with Equality.
\item[\ref {REWRITE}] Rewriting.
\item[\ref {FUNCTIONS}] Function Application.
\item[\ref {LEMMAS}] Proving Lemmas ``on the fly''.
\item[\ref {CASES}] Case Analysis.
\item[\ref {INDUCTION}] Induction.
\end{itemize}



\section{The Two Tactic Method}\label{TWOTACTIC}

This method is given a high priority in the \ZTUTORIAL, although more for
pedagogical reasons than because it is a particularly natural way to tackle a proof. Proof by stripping, see section \ref{STRIP}, is effective in discharging a goal only where the reasoning is mainly propositional.
Where the proof will depend either on appropriate specialisation of universally quantified assumptions, or on the choice of a suitable witness for proving an existential conclusion, stripping will not suffice.

The two tactic method injects into the proof process based on stripping, user directed specialisation of universal assumptions.
In the context of a proof by contradiction (in which existential conclusions will not arise) this is sufficient to discharge any goals which are reduced to reasoning in the  first order predicate calculus.
The method is  sometimes unnatural because it destroys much
of the logical structure of the
original goal.  Schematically the method is:
=GFT SML
set_goal([],conjecture);
a contr_tac; 						(* once suffices *)
a (z_spec_asm_tac ‚ì© assumption ‚åù ‚ì© value‚åù);	(* as many times as necessary *)
=TEX
The choice of universal assumptions and of the values to specialise them to depends on the user identifying one or more specialisations which will result in the derivation of a contradiction from the assumptions.
For example, this method transforms a goal with an existentially quantified
conclusion into one with a universally quantified assumption:
=SML
set_goal([],‚ì©[X](‚àÄx,y:X ‚¶Å(‚àÉx:X ‚¶Å x = y))‚åù);
a contr_tac; 						
a (z_spec_asm_tac ‚ì© ‚àÄ x : X ‚¶Å ¬¨ x = y ‚åù ‚ì©y‚åù);	
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX



\section{Stripping}\label{STRIP}
This method is complete for propositional logic. The tactic $strip_tac$ performs a variety of simplifications, and is often usefully applied at the outset of  embarking on a proof.  The simplifications achieved by
=INLINEFT
strip_tac
=TEX
{} include the following:
\begin{itemize}
\item moving the antecedent of an implication from the conclusion to the assumptions of the goal
\item proving tautologies
\item removing leading universal quantifiers
\item using, where possible, relevant assumptions in the assumption-list.
\end{itemize}
This is often a more natural way to start a proof because it retains
some of the structure of the original goal. For example, the proof above in section \ref{TWOTACTIC} could have been achieved
by stripping  then applying  $z_‚àÉ_tac$ with a suitable witness then stripping
the trivial result:

=SML
set_goal([],‚ì©[X](‚àÄx,y:X ‚¶Å(‚àÉx:X ‚¶Å x = y))‚åù);
a(REPEAT strip_tac);
a(z_‚àÉ_tac‚ì©y‚åù);						
a(REPEAT strip_tac);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\section{Automatic Proof}\label{AUTOMATIC}


An automatic proof procedure, in the form of $prove_tac$, is provided for each proof context. In most proof contexts this is  capable of solving results which are
reducible to simple theorems of the predicate calculus.
For example, the proof context $z_library1_ext$ reduces the subset relation
to a universally quantified membership statement:
=SML
set_goal([],‚ì©A ‚äÜ B ‚àß B ‚äÜ C ‚áí A ‚äÜ C‚åù);
a(PC_T1"z_library1_ext"prove_tac[]);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
=SML
set_goal([],‚ì©{x,y:‚Ñ§ | x<y} ‚äÜ {x,y:‚Ñ§ | x<y ‚à® x>y+99}‚åù);
a(PC_T1"z_library1_ext"prove_tac[]);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

Even when the application of $prove_tac$ fails to prove a goal, it may have resulted in more simplification than would be obtained by other methods.
It is also conceivable that if $prove_tac$ fails
to achieve a proof it may  unnecessarily  split the goal into subgoals.
In this case it would probably be better to undo the application of $prove_tac$ and try another approach to solving the goal.

\subsection{Linear Arithmetic Proof Context}
The proof context $z_lin_arith$ contains an automatic
proof procedure for linear arithmetic. This means terms built up from:
\begin{itemize}
\item
``Atoms'' (numeric literals, variables of type ‚Ñ§, etc.)
\item
Multiplication by numeric literals
\item
Addition
\item
$=,‚â§,‚â•,<,>$
\item
Logical operators
\end{itemize}
So, for example, the following are all proved by an application of $prove_tac$ in the proof context $z_lin_arith$:
=SML
set_goal([],‚ì©(‚àÄx,y,z:‚Ñ§ | x ‚â§ y ‚àß x + y < z + x ‚¶Å x < z)‚åù);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX
=SML
set_goal([],‚ì©(‚àÄx,z:‚Ñ§ | (‚àÉ y:Z ‚¶Å x ‚â• y ‚àß ¬¨ y < z )‚¶Å x ‚â• z)‚åù);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX
=SML
set_goal([],‚ì©(‚àÄx,y:‚Ñ§ | x + 2*y < 2*x ‚¶Å y + y < x)‚åù);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX
=SML
set_goal([],‚ì©(‚àÄx,y:‚Ñ§ ‚¶Å ¬¨ (2*x + y = 4 ‚àß 4*x + 2*y = 7))‚åù);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX

\section{Forward Chaining} \label{FORWARD}

Forward chaining facilities often provide an easier way of achieving proofs requiring instantiation of universal assumptions.

$all_asm_fc_tac$ will attempt to instantiate universally quantified assumptions which are effectively implications to values which will enable forward inference to take place.
This is achieved by matching the antecedent of the implication against other assumptions.

Consider the example in section \ref{TWOTACTIC}. After the application of $contr_tac$, you can derive the required contradiction using $all_asm_fc_tac$
with less effort than having to specialise the universally quantified assumption:

=SML
set_goal([],‚ì©[X](‚àÄx,y:X ‚¶Å(‚àÉx:X ‚¶Å x = y))‚åù);
a contr_tac; 	
a (all_asm_fc_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

If forward chaining fails to solve a goal,  it may  generate irrelevant new assumptions, and so it should be used judiciously.

A related tactic suitable for use with Z is $all_fc_tac$, which chains forward using implications derived from a list of theorems supplied as an argument, matching these against the assumptions, using the assumptions to match the antecedents of the implications.

$fc_tac$ and $asm_fc_tac$ are also useful (see \REFERENCE), but these are liable to introduce HOL universal quantifiers, leaving a mixed language subgoal.

\section{Predicate Calculus with Equality}\label{EQUATIONS}

A variety of additional proof facilities are available to make use of equations.

\begin{enumerate}
\item $asm_rewrite_tac$

may be used to cause equations in the assumptions to rewrite the conclusion of a subgoal.
This may sometimes prove sufficient to complete a proof.

\item $eq_sym_asm_tac$ or $eq_sym_nth_asm_tac$

may be used to turn round an equation in an assumption which is the wrong way round to achieve the required rewrite.

\item
$var_elim_asm_tac$ or $var_elim_nth_asm_tac$

may be used to completely eliminate from the subgoal occurrences of a variable which appears on one side of an equation in the specified assumption.
This causes the conclusion and all the other assumptions to be rewritten with the equation, eliminating occurrences of it.
The assumption will then be discarded.
These tactics will work whichever way round the equation appears in the assumption.

\item $all_var_elim_asm_tac$, $all_var_elim_asm_tac1$

automatically eliminate from the assumptions all equations of a sufficiently simple kind, by rewriting every term in the subgoal with them and then discarding the equations.
They avoid eliminating equations where this might cause a looping rewrite.
The first variant only eliminates equations where both sides are either variables or constants, the second variant will eliminate any equation of which one side is a variable which does not appear on the other side.

\end{enumerate}


\section{Rewriting}\label{REWRITE}

Rewriting using any collection of theorems from which equations are derivable is supported by the standard HOL rewriting facilities ($rewrite_tac$ etc.), see the \REFERENCE\ for details, using Z specific preprocessing of the rewrite theorems (supplied in the Z proof contexts).

Many Z paragraphs give rise to predicates which can be used without further preparation by these standard rewriting facilities.
This applies to given sets, abbreviation definitions and schema definitions.

Axiomatic descriptions, and generic axiomatic descriptions will result in equations which are likely to be effectively conditional.
In such cases it is necessary to establish the applicability of the rewrite before it can be undertaken.

One way of achieving this is by forward chaining using the conditional equation after establishing the relevant condition.
The relevant conditions are usually the membership assertions corresponding to the declaration part of the outer universal quantifier on the theorem to be used for rewriting.

For example, to prove the goal:
=SML
set_goal([], ‚ì© ‚àÄ i:‚Ñï ‚¶Å abs i = abs ~i‚åù);
=TEX
using theorem $z_abs_thm$ (which is :
=INLINEFT
‚ä¢ ‚àÄ i : ‚Ñï ‚¶Å abs i = i ‚àß abs ~ i = i
=TEX
).
First strip the goal:
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  1 *)  ‚ì©0 ‚â§ i‚åù

(* ?‚ä¢ *)  ‚ì©abs i = abs ~ i‚åù
...
=TEX
Then forward chain using the theorem and rewrite with the results:
=SML
a (ALL_FC_T rewrite_tac [z_abs_thm]);
save_pop_thm "abs_eq_abs_minus_thm";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
In more complicated cases the proof of the required conditions may be non-trivial, often because reasoning about membership of expressions formed with function application is involved. The next section describes the proof support available for use in such cases.
\section{Function Application}\label{FUNCTIONS}
Reasoning at a low level, $z_app_eq_tac$ may be used to reduce an equation involving an application to sufficient conditions for its truth, in terms of the membership of the function, e.g.:
=SML
set_goal([],‚ì© f a = v‚åù);
a z_app_eq_tac;
=GFT ProofPower output
...
(* ?‚ä¢ *)  ‚ì©(‚àÄ f_a : ùïå | (a, f_a) ‚àà f ‚¶Å f_a = v) ‚àß (a, v) ‚àà f‚åù
...
=TEX
The first conjunct of this result is needed to ensure that $f$ is functional at $a$ (i.e. maps $a$ to only one value).
In the case that $f$ is known to be a function, the theorem $z_fun_app_clauses$ may be used with forward chaining, avoiding the need to prove that $f$ is functional at $a$.
=GFT
val z_fun_app_clauses =
  ‚ä¢ ‚àÄ f : ùïå; x : ùïå; y : ùïå; X : ùïå; Y : ùïå
    ‚¶Å (f ‚àà X ‚á∏ Y
          ‚à® f ‚àà X ‚§î Y
          ‚à® f ‚àà X ‚§Ä Y
          ‚à® f ‚àà X ‚Üí Y
          ‚à® f ‚àà X ‚Ü£ Y
          ‚à® f ‚àà X ‚Ü† Y
          ‚à® f ‚àà X ‚§ñ Y)
        ‚àß (x, y) ‚àà f
      ‚áí f x = y : THM
=TEX
In this case the result $(a,v)\ ‚àà\ f$ would have to be proven and added to the assumptions before undertaking the forward chaining, e.g.:
=SML
drop_main_goal();
set_goal([], ‚ì©[X,Y](‚àÄ f : X ‚Üí Y; x:X; y:Y  ‚¶Å (x, y) ‚àà f ‚áí f x = y)‚åù);
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  4 *)  ‚ì©f ‚àà X ‚Üí Y‚åù
(*  3 *)  ‚ì©x ‚àà X‚åù
(*  2 *)  ‚ì©y ‚àà Y‚åù
(*  1 *)  ‚ì©(x, y) ‚àà f‚åù

(* ?‚ä¢ *)  ‚ì©f x = y‚åù
=SML
a (all_fc_tac [z_fun_app_clauses]);
pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

A common problem is to have to establish that the value of some expression formed by application falls within some particular set.
This is often needed to establish the conditions necessary for use of a rewriting equation on the expression.

In these circumstances the theorem $z_fun_‚àà_clauses$ may be used:
=GFT
val z_fun_‚àà_clauses = ‚ä¢ ‚àÄ f : ùïå; x : ùïå; X : ùïå; Y : ùïå
 ‚¶Å ((f ‚àà X ‚Üí Y ‚à® f ‚àà X ‚Ü£ Y ‚à® f ‚àà X ‚Ü† Y ‚à® f ‚àà X ‚§ñ Y) ‚àß x ‚àà X
 	‚áí f x ‚àà Y)
 ‚àß ((f ‚àà X ‚á∏ Y ‚à® f ‚àà X ‚§î Y ‚à® f ‚àà X ‚§Ä Y) ‚àß x ‚àà dom f
 	‚áí f x ‚àà Y) : THM
=TEX
The claim that a global variable is a member of a function space will often be obtained from the specification of the constant (as part of the predicate implicit in the declaration part of the specification).
Where the function is an expression the result is likely to have been established by forward inference using similar methods.

For example, consider the following specifications:
‚ìàZ
[T]
‚ñ†

‚ìàZAX
‚îÇCONSTSPEC : ‚Ñô‚ãé1 T ‚Ü† ‚Ñï
‚îú
‚îÇtrue
‚ñ†
where we are required to demonstrate that $CONSTSPEC$ applied to something in  $T$ is in the set $‚Ñï$. From $z_fun_‚àà_clauses$ we have that given an
=INLINEFT
f ‚àà X ‚Ü† Y
=TEX
\ and an
=INLINEFT
x ‚àà X
=TEX
, then we can conclude that
=INLINEFT
f x ‚àà Y
=TEX
. The current proof context, $z_library1$, will be
too agressive  for our purposes because it will expand the definition
of  $P‚ãé1$, the $X$ in this case. So, we will use the proof context $z_predicates$ for this example:

=SML
push_pc"z_predicates";
set_goal([], ‚ì©(‚àÄ x:‚Ñô‚ãé1 T‚¶Å CONSTSPEC x ‚àà ‚Ñï)‚åù);
a(REPEAT strip_tac);
=GFT ProofPower output
...
(*  1 *)  ‚ì©x ‚àà ‚Ñô‚ãé1 T‚åù

(* ?‚ä¢ *)  ‚ì©CONSTSPEC x ‚àà ‚Ñï‚åù
...
=TEX
We need the fact about $CONSTSPEC$ which is found in its defining declaration  to make the required inference.

This is added to the assumptions as follows:
=SML
a (strip_asm_tac (z_get_spec ‚ì©CONSTSPEC‚åù));
=GFT ProofPower output
...
(*  2 *)  ‚ì©x ‚àà ‚Ñô‚ãé1 T‚åù
(*  1 *)  ‚ì©CONSTSPEC ‚àà ‚Ñô‚ãé1 T ‚Ü† ‚Ñï‚åù

(* ?‚ä¢ *)  ‚ì©CONSTSPEC x ‚àà ‚Ñï‚åù
...
=TEX
Next we forward chain using the theorem $z_fun_‚àà_clauses$, which suffices to discharge the goal.
=SML
a (all_fc_tac[z_fun_‚àà_clauses]);
pop_thm();
pop_pc();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

\section{Using Lemmas} \label{LEMMAS}
Use of the tactic $lemma_tac$ may give a more natural feel to a proof. It allows
you to state and prove a lemma ``on the fly''. This will generate at least
two subgoals - one the statement of the lemma and the rest the result of stripping
the lemma into the assumptions. For example:
=SML
set_goal([],‚ì©(‚àÄx,y :‚Ñ§ | x  ‚â§ y ‚¶Å P (x,y)) ‚àß x = y ‚áí P (x,y)‚åù);
a(REPEAT strip_tac);
=TEX
=GFT ProofPower output
...
(*  2 *)  ‚ì©‚àÄ x, y : ‚Ñ§ | x ‚â§ y ‚¶Å P (x, y)‚åù
(*  1 *)  ‚ì©x = y‚åù

(* ?‚ä¢ *)  ‚ì©P (x, y)‚åù
...
=TEX
=SML
a(lemma_tac‚ì©x ‚â§ y‚åù);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  3 *)  ‚ì©‚àÄ x, y : ‚Ñ§ | x ‚â§ y ‚¶Å P (x, y)‚åù
(*  2 *)  ‚ì©x = y‚åù
(*  1 *)  ‚ì©x ‚â§ y‚åù

(* ?‚ä¢ *)  ‚ì©P (x, y)‚åù


(* *** Goal "1" *** *)

(*  2 *)  ‚ì©‚àÄ x, y : ‚Ñ§ | x ‚â§ y ‚¶Å P (x, y)‚åù
(*  1 *)  ‚ì©x = y‚åù

(* ?‚ä¢ *)  ‚ì©x ‚â§ y‚åù
=TEX
Rewriting with the assumptions will solve the
first goal:
=SML
a(asm_rewrite_tac[]);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)
...
=TEX
and forward chaining will solve the second:
=SML
a(all_asm_fc_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX
In this example, one tactic solved the lemma. If you apply this with
$THEN1$, you can avoid the subgoal split:
=SML
set_goal([],‚ì©(‚àÄx,y :‚Ñ§ |x  ‚â§ y ‚¶Å P (x,y)) ‚àß x = y ‚áí P (x,y)‚åù);
a(REPEAT strip_tac);
a(lemma_tac‚ì©x ‚â§ y‚åù THEN1 asm_rewrite_tac[]);
=GFT ProofPower output
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  3 *)  ‚ì©‚àÄ x, y : ‚Ñ§ | x ‚â§ y ‚¶Å P (x, y)‚åù
(*  2 *)  ‚ì©x = y‚åù
(*  1 *)  ‚ì©x ‚â§ y‚åù

(* ?‚ä¢ *)  ‚ì©P (x, y)‚åù
...
=TEX
=SML
a(all_asm_fc_tac[]);
pop_thm();
=TEX
Applying $lemma_tac$ is equivalent to applying $LEMMA_T\ strip_asm_tac$. $LEMMA_T$
has an argument of type $THM\ ->\ TACTIC$ telling you what to do with
the new assumption. Sometimes, you really want to put the lemma into the
assumptions in exactly the way you have formulated it: $LEMMA_T\ asm_tac$
will achieve this. Another common thing you might want to do is to rewrite your
goal with the new assumption: $LEMMA_T\ rewrite_thm_tac$ will achieve this.


\section{Case Analysis} \label{CASES}
The tactic $cases_tac\ condition$ lets you reason by cases
according as a chosen $condition$ is true or false. Consider
the example from section \ref{LEMMAS} that was progressed with $lemma_tac$.
This time, we will use $cases_tac$ which will generate a contradiction
in the case where the condition is false:
=SML
set_goal([],‚ì©(‚àÄx,y :‚Ñ§ |x ‚â§ y ‚¶Å P (x,y)) ‚àß x = y ‚áí P (x,y)‚åù);
a(REPEAT strip_tac);
=TEX
=GFT ProofPower output
...
(*  2 *)  ‚ì©‚àÄ x, y : ‚Ñ§ | x ‚â§ y ‚¶Å P (x, y)‚åù
(*  1 *)  ‚ì©x = y‚åù

(* ?‚ä¢ *)  ‚ì©P (x, y)‚åù
...
=TEX
=SML
a(cases_tac‚ì©x ‚â§ y‚åù);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
(* *** Goal "2" *** *)

(*  3 *)  ‚ì©‚àÄ x, y : ‚Ñ§ | x ‚â§ y ‚¶Å P (x, y)‚åù
(*  2 *)  ‚ì©x = y‚åù
(*  1 *)  ‚ì©¬¨ x ‚â§ y‚åù

(* ?‚ä¢ *)  ‚ì©P (x, y)‚åù


(* *** Goal "1" *** *)

(*  3 *)  ‚ì©‚àÄ x, y : ‚Ñ§ | x ‚â§ y ‚¶Å P (x, y)‚åù
(*  2 *)  ‚ì©x = y‚åù
(*  1 *)  ‚ì©x ‚â§ y‚åù

(* ?‚ä¢ *)  ‚ì©P (x, y)‚åù
=TEX
This time, forward chaining proves the first subgoal:
=SML
a(all_asm_fc_tac[]);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)
...
=TEX
Eliminating $x$ should derive the expected contradiction to solve subgoal 2:
=SML
a(all_var_elim_asm_tac1);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\section{Induction}\label{INDUCTION}
Induction tactics for integers are available. The easiest one
to use is $z_‚â§_induction_tac$. Consider the following goal, for example:
=SML
set_goal([],‚ì©‚àÄ i,j:‚Ñ§ | 0 ‚â§  i ‚àß 0 ‚â§ j ‚¶Å 0 ‚â§ i*j‚åù);
a(REPEAT strip_tac);
=TEX
=GFT ProofPower putput
...
(*  2 *)  ‚ì©0 ‚â§ i‚åù
(*  1 *)  ‚ì©0 ‚â§ j‚åù

(* ?‚ä¢ *)  ‚ì©0 ‚â§ i * j‚åù
=TEX

Now apply the induction tactic:
=SML
a(z_‚â§_induction_tac‚ì©i‚åù);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  3 *)  ‚ì©0 ‚â§ j‚åù
(*  2 *)  ‚ì©0 ‚â§ i‚åù
(*  1 *)  ‚ì©0 ‚â§ i * j‚åù

(* ?‚ä¢ *)  ‚ì©0 ‚â§ (i + 1) * j‚åù


(* *** Goal "1" *** *)

(*  1 *)  ‚ì©0 ‚â§ j‚åù

(* ?‚ä¢ *)  ‚ì©0 ‚â§ 0 * j‚åù
=TEX
Subgoal 1 is proved by rewriting with the assumptions.
=SML
a(asm_rewrite_tac[]);
=TEX
Although the original goal was not a linear
arithmetic result, induction has reduced the problem to one
of linear arithmetic. Subgoal 2  can be proved in the  proof context
$z_lin_arith$:
=SML
a(PC_T1"z_lin_arith"asm_prove_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\chapter{PROVING VCS} \label{VCPRFS}

As ordinary Z goals, VCs may be proved using all of the normal facilities provided by {\Product} for proof in Z. Chapter \ref {ZPROOF}
 provides an overview, based on the \ZTUTORIAL, of the recommended techniques for using {\ProductZ} for doing proofs.
In addition, many VCs use Z toolkit extensions which
 are contained in the theory $cn$.
Some custom support is provided in the {\daztool} to assist with reasoning in this theory, most notably the proof contexts $cn1$, $cn_ext$ and $cn$.
There are
also some purpose built tactics available, e.g. $cn_vc_simp_tac$ and
$cn_‚àà_type_tac$ which have been designed for use with VC proofs. The main objective
of this chapter is to show you how to use these tactics with facilities available in the proof context $cn1$
to strip away the ``{\daztool} specific'' bits of a VC proof
to transform it into an ``ordinary'' Z proof. From there, hopefully the material in section \ref{ZPROOF}
 will guide you in progressing your proof.



\section{Getting Started} \label{STARTED}

It is assumed that you are using the {\daztool} and are
in a position to access the VCs, i.e. you are either in the same theory as your specification, or in a theory which has your specification as a parent.
(\CNUSERGUIDE\  gives a comprehensive account of the Compliance Notation functions, in particular how to access the VCs generated by the tool from a literate script).

Processing a Compliance Notation script gives rise to definitions and axioms that are not necessarily in a form that makes for easy reasoning. Before you tackle the VC proofs, there is some {\daztool} support available  that
generates some theorems for you that should facilitate rewriting when proving the VCs.
First  call the function $all_cn_make_script_support$ with your choice of name as string argument. For example:
=GFT
val my_thms = all_cn_make_script_support "mycn";
=TEX
generates all these supporting theorems, binds them (in a list)
to the ML variable
 $my_thms$, and generates the supporting proof context $mycn$.
After a few seconds, you will see a raft of theorems scroll
by in the journal window. Each of
the definitions and axioms generated by processing the Compliance
Notation give rise to one or two supporting theorems. There is always
one rewriting theorem, and if this does not contain all the type information implicit in the definition, there will be another signature
 theorem. These theorems are at least as good as what you get with $z_get_spec$, and in many cases
are in a much better form for rewriting.

All supporting theorems are stored in
the current theory, and are prefixed by $cn_$. The rewriting
theorems finish with $_thm$, and the signature theorems finish with $_sig_thm$.
The theorems are also bound to ML variables of the same name. Such theorems
will have been generated from all the definitions in your theory.
For example, the type $OPERATION$
in the package $TC$ in the calculator example, see section \ref{CALCEX},
gives rise to the definition $TCoOPERATION$, for which one supporting
theorem has been generated:
=GFT
cn_TCoOPERATION_thm	
	‚ä¢ TCoOPERATION = TCoPLUS .. TCoEQUALS
=TEX
and an attribute definition $TCoOPERATIONvPOS$, for which two supporting
theorems have been generated:
=GFT
cn_TCoOPERATIONvPOS_thm	
	‚ä¢ ‚àÄ i : TCoOPERATION ‚¶Å TCoOPERATIONvPOS i = i
cn_TCoOPERATIONvPOS_sig_thm	
	‚ä¢ TCoOPERATIONvPOS ‚àà TCoOPERATION ‚Üí TCoOPERATION
=TEX

The supporting proof context $mycn$ created for you is the proof context $cn1$
extended by these supporting theorems. It is not the intention that you
should normally set $mycn$ as a proof context, because it would typically be too aggressive. The effect of rewriting in proof context $mycn$ would be
to unwind everything in a goal with its basic definition. However, there are
some cases when this is exactly what you want to do, for example, when numerical values in a specification are significant. In this case, you would probably
have set the proof context to $cn1$ at the start of the proof, and then at some appropriate stage applied the following:
=GFT
a(PC_T1 "mycn" rewrite_tac[]);
=TEX

The theory $cn$ contains the {\daztool} Z toolkit extensions.
The recommended user interface to the conversions etc. described there is via the proof context $cn1$. In this proof context  the SPARK boolean and relational operators are converted fairly directly into Z.  Additional theorems in the theory $cn$ are also available for reasoning about the numeric operators $intdiv$, $intmod$ and $rem$.
The more aggressive proof contexts, $cn$ and  $cn_ext$, are also available. These, and all the other custom proof tools are described in section 6.1 of the \CNUSERGUIDE. For references purposes, a full listing of the theory $cn$ is also provided in that user guide.

\section{{\daztool} Proofs}

Application of the tactic $cn_vc_simp_tac$, see section 6.1 of \CNUSERGUIDE, is the favoured way of beginning a VC proof. In all but the
most obscure cases this should simplify the goal, and may even be sufficient to achieve a proof. $cn_vc_simp_tac$ first rewrites the conclusion of the goal
with the rewriting rules of the current proof context, some associativity
theorems, and any theorems of your choice. Outer universal quantifiers are stripped away and any resulting redundancy in the goal removed. For example,
 using the proof context $cn1$, $cn_vc_simp_tac$, will transform the goal:

=GFT
?‚ä¢	‚àÄ	x : INTEGER; y : INTEGER; z : INTEGER
	|	(x + y) + 1 eq z = TRUE ‚àß (x ‚â• 0 ‚àß y ‚â• 0) ‚àß x ‚â• 0
	‚¶Å	x ‚â• 0 ‚àß z greater_eq 0 = TRUE
=TEX
into:
=GFT
?‚ä¢		x ‚àà INTEGER ‚àß y ‚àà INTEGER ‚àß z ‚àà INTEGER
	‚àß	x + y + 1 = z ‚àß 0 ‚â§ x ‚àß 0 ‚â§ y
	‚áí	0 ‚â§ z	
=TEX

You should now be in a position to prove the VCs.
The names of the VCs can be obtained from the current theory using $get_conjectures\ "-"$.

First, set the proof context,
typically $cn1$, and  set
the VC, called, say, $vcn_n$,  as a {\ProductZ} goal.

=GFT SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcn_n");
=TEX
Now apply the simplification tactic $cn_vc_simp_tac$. This may achieve
the proof; if not and you believe that the goal is simply a predicate calculus result, perhaps
with a bit of linear arithmetic,
 then you may
care to attack it with $prove_tac$ (in the linear arithmetic proof context if
applicable). In general, though,  this type of automatic proof procedure
would not be appropriate. Next, you might try the following (until the goal is achieved):
\ftlmargin=0.4in
\begin{itemize}
\item
Apply $REPEAT\ strip_tac$. If this results in the generation of
additional subgoals,  you
may  want
to ``undo 1''  and then perform more controlled stripping.
For example
=SML
set_pc"cn1";
set_goal([],‚ì©(‚àÄ x : X; y : X
             | P(x) ‚àß Q(x)  ‚àß x eq y = TRUE
             ‚¶Å P(y) ‚àß Q(y))‚åù);
a(cn_vc_simp_tac[]);
=TEX
=GFT ProofPower output

(* *** Goal "" *** *)

(* ?‚ä¢ *)  ‚ì©x ‚àà X ‚àß y ‚àà X ‚àß P x ‚àß Q x ‚àß x = y ‚áí P y ‚àß Q y‚åù

=TEX
$REPEAT\ strip_tac$
 will generate two subgoals from the conjunction
in the right hand side of the implication
obtained by $cn_vc_simp_tac$:
=SML
a(REPEAT strip_tac);
=TEX
=GFT ProofPower output

Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  5 *)  ‚ì©x ‚àà X‚åù
(*  4 *)  ‚ì©y ‚àà X‚åù
(*  3 *)  ‚ì©P x‚åù
(*  2 *)  ‚ì©Q x‚åù
(*  1 *)  ‚ì©x = y‚åù

(* ?‚ä¢ *)  ‚ì©Q y‚åù

(* *** Goal "1" *** *)

(*  5 *)  ‚ì©x ‚àà X‚åù
(*  4 *)  ‚ì©y ‚àà X‚åù
(*  3 *)  ‚ì©P x‚åù
(*  2 *)  ‚ì©Q x‚åù
(*  1 *)  ‚ì©x = y‚åù

(* ?‚ä¢ *)  ‚ì©P y‚åù

=TEX
Whereas $‚áí_tac$ will strip the left hand side of the implication
into the assumptions without affecting the right hand side:
=SML
undo 1;
a ‚áí_tac;
=TEX
=GFT ProofPower output

Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  5 *)  ‚ì©x ‚àà X‚åù
(*  4 *)  ‚ì©y ‚àà X‚åù
(*  3 *)  ‚ì©P x‚åù
(*  2 *)  ‚ì©Q x‚åù
(*  1 *)  ‚ì©x = y‚åù

(* ?‚ä¢ *)  ‚ì©P y ‚àß Q y‚åù
=TEX

\item
Stripping may not suceed if it generates an assumption
which is an equation with a variable on one side of the equals. Eliminating that variable throughout, with a variation on the theme of $var_elim_asm_tac$, before
using $asm_rewrite_tac$ or $asm_fc_tac$ may solve the goal.
The  example  above illustrates this. Eliminating $x$
from assumption $1$ then rewriting with the assumptions should complete proof:
=SML
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\item
A For Loop Statement may give rise to a VC with an assumption which is quantified over a range $i\ ..\ i-1$. Such an assumption is false, and the application of $asm_prove_tac$ in the linear arithmetic proof context will suffice to prove the VC:

=INLINEFT
PC_T1"z_lin_arith"asm_prove_tac[]
=TEX

\item
Rewriting is usually the next thing to try. There are
two ``levels'' of definitions that can be unwound:
\begin{itemize}
\item
the SPARK definitions in the specification, e.g. the attributes
$TCoDIGITvFIRST$ and $TCoDIGITvLAST$
in the calculator example, section \ref{CALCEX}
\item
the Z in the specification, e.g. the Z schema $DO_DIGIT$
in the calculator example
\end{itemize}
Perhaps you could progress your proof by rewriting explicitly with the supporting theorems
 $cn_TCoDIGITvFIRST_thm$, or $cn_DO_DIGIT_thm$ that were generated for you
as described in section \ref{STARTED}.

It is worth remembering that forward chaining is often required
in order to obtain usable rewrites from Z definitions. For example, the
theorem available from
the definition of $fact$ in the calculator example, section \ref{CALCEX}, is:
=GFT
‚ä¢ fact ‚àà ‚Ñï ‚Üí ‚Ñï
    ‚àß fact 0 = 1
    ‚àß (‚àÄ m : ‚Ñï ‚¶Å fact (m + 1) = (m + 1) * fact m)
=TEX
To use the third conjunct of this theorem, it is necessary to have an
assumption of the form $m\ ‚àà\ ‚Ñï$ so that you can forward chain, with, say, $fc_tac$, to obtain the result that
=INLINEFT
fact (m + 1) = (m + 1) * fact m
=TEX
. It is also not uncommon to have the following pattern in
a  Z axiomatic definition:
=GFT
‚îÇSOMEPROPERTY : X ‚Üí ‚Ñô Y
‚îú
‚îÇ‚àÄ x : X; y : Y  ‚¶Å y ‚àà SOMEPROPERTY x ‚áî SOMEPREDICATE
=TEX
Suppose you are required to prove the goal:
=GFT
a ‚àà SOMEPROPERTY b
=TEX
Then, useful rewriting may be achieved by forward chaining using
=GFT
ALL_FC_T1 fc_‚áî_canon rewrite_tac[z_get_spec‚ì©SOMEPROPERTY‚åù]
=TEX
\item
Some insight as to ``what to do next'' may be gleaned from chapter  \ref{ZPROOF}
. The degree of difficulty experienced in proving VCs rather depends on
the refinement steps which generated the VCs in the first place.
A complex sequence of intermediate refinements gives rise to complex VCs,
whereas refinements which rely heavily on the underlying Z may require you to unwind a lot of definitions.

It is worth remembering at this time that there is always the possibility that
the VC you are trying to prove may not be true, or more likely, may not be provable. You
may save yourself pain  if, before you embark on the proof using the tool,
you spend a few minutes at the outset inspecting the VC to convince yourself that you have a fair chance of achieving
a proof. Problems will occur if the pre- condition of a
refinement statement is too weak, or the  post- condition  too strong,
 to prove the VC.

\end{itemize}

Typically you may find it advantageous to prove subsidiary  lemmas before embarking upon a VC proof.
These will be either  general purpose lemmas that are not available in {\ProductZ} but can easily be proven with the proof support available, or they will be application specific. Such lemmas are proven separately either because they are results that are found to be needed repeatedly during the process of proving the VCs, or because proving them in isolation is simpler than proving them in the context of a VC proof. Actually, in practice, it is common to experience a sense of {\em deja vu} when in the middle of a proof. You find that you need a result that you have already proved in an earlier VC proof, and it is at that stage that you decide to backtrack and  extract the bits from the previous proof as a separate lemma.
Section \ref{ADDTS} provides examples of the sort of subsidiary lemmas that might typically be useful.

\ftlmargin=0in


\section{Additional Techniques} \label{ADDTS}

The  \CNNOTATION\
describes how particular SPARK constructs are translated into Z. Some of these
constructs give rise to idioms requiring special styles of proof.

\subsection{Array Component Assignments} \label{ARRAY}

Functional overrides occur in the VCs  from SPARK array assignments. These assignments
can be to an arbitrary level of nesting. Suppose in your VC proofs,
the following lemma would be useful:

=GFT
‚äï_lemma
[X, Y, Z](‚àÄf : X ‚Üí Y ‚Üí Z; x:X;y2:Y;y1:ùïå;z:ùïå| ¬¨y2=y1‚¶Å
	(f ‚äï {x ‚Ü¶ f x ‚äï {y1 ‚Ü¶ z}})x y2= f x y2)
=TEX

Although this does not exist as a theorem in {\ProductZ}, it is
straightforward for you to prove as a separate lemma
using $z_fun_‚àà_clauses$, as described
in section \ref{FUNCTIONS}, together with the theorems
$z_‚äï_‚Ü¶_app_thm$ and $z_‚äï_‚Ü¶_app_thm1$:
=GFT
z_‚äï_‚Ü¶_app_thm
‚ä¢ ‚àÄ f : ùïå; x : ùïå; y : ùïå ‚¶Å (f ‚äï {x ‚Ü¶ y}) x = y
=TEX
=GFT
z_‚äï_‚Ü¶_app_thm1
‚ä¢  [X,Y](‚àÄ f : X ‚Üí Y; x2 : X; x1 : ùïå; y : ùïå | ¬¨ x2 = x1 ‚¶Å
	 (f ‚äï {x1 ‚Ü¶ y}) x2 = f x2)
=TEX
=SML
set_goal([],‚ì©[X, Y, Z](‚àÄf : X ‚Üí Y ‚Üí Z; x:X;y2:Y;y1:ùïå;z:ùïå| ¬¨y2=y1‚¶Å
	(f ‚äï {x ‚Ü¶ f x ‚äï {y1 ‚Ü¶ z}})x y2= f x y2)‚åù);
a(REPEAT strip_tac);
a(rewrite_tac[z_‚äï_‚Ü¶_app_thm]);
a(all_asm_fc_tac[z_fun_‚àà_clauses]);
a(ALL_ASM_FC_T rewrite_tac[z_‚äï_‚Ü¶_app_thm1]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
=IGN
The sort of application specific lemmas you might require clearly depends on the sort of SPARK constructs that have been used. Two typical examples are:
=TEX

\subsection{Set Membership of Record Components} \label{SETREC}

The form of this class of lemma is
=INLINEFT
X.field ‚àà set
=TEX
, which arises from indexing into an array of
records in SPARK. The tactic $cn_‚àà_type_tac$ is available
to simplify the  proof of this type of lemma. A typical example of the set in
question is  $BOOLEAN$. For example,
consider the following specification snippet from a Compliance Notation script:
=GFT
subtype SWITCHTYPE is INTEGER range 1 .. 3;
 type SWITCHDATA is
    record
       STATE : BOOLEAN;  -- on or off
       NEXTSWITCH : SWITCHTYPE;
    end record;

 type SWITCHBOARD is array (SWITCHTYPE) of SWITCHDATA;
=TEX

\Hide{%
‚ìàCN
 procedure EX is

 subtype SWITCHTYPE is INTEGER range 1 .. 3;
 type SWITCHDATA is
    record
       STATE : BOOLEAN;  -- on or off
       NEXTSWITCH : SWITCHTYPE;
    end record;

 type SWITCHBOARD is array (SWITCHTYPE) of SWITCHDATA;

 begin
 	null;
 end EX;				
‚ñ†
}
Suppose the VCs have been generated and the supporting proof context made, as described in section \ref{STARTED}:
=SML
val switch_thms = all_cn_make_script_support "switch_cn";
=TEX
Now, suppose we find that for the VC proofs we need to recast something of the form
=GFT
not (sb s).STATE = Boolean false
=TEX
more naturally as
=GFT
(sb s).STATE = Boolean true
=TEX
To do this, we first need to prove that $(sb s).STATE$ is a member of
$BOOLEAN$:
=SML
set_goal([],‚ì©‚àÄ sb:SWITCHBOARD; s: SWITCHTYPE‚¶Å(sb s).STATE ‚àà BOOLEAN‚åù);
a(REPEAT strip_tac);
=TEX
=GFT ProofPower output
(*  2 *)  ‚ì©sb ‚àà SWITCHBOARD‚åù
(*  1 *)  ‚ì©s ‚àà SWITCHTYPE‚åù

(* ?‚ä¢ *)  ‚ì©(sb s).STATE ‚àà BOOLEAN‚åù
=TEX
Now if we apply $cn_‚àà_type_tac$ in the supporting proof context $switch_cn$,
the goal will be achieved:
=SML
a(PC_T1"switch_cn"cn_‚àà_type_tac[]);
val switch_‚àà_thm = pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

We can now prove the recasting result using $switch_‚àà_thm$
together with  $cn_boolean_clauses1$ from the theory $cn$:
=GFT
‚ä¢ (‚àÄ x : BOOLEAN ‚¶Å not x = Boolean (¬¨ x = Boolean true))
    ‚àß (‚àÄ x, y : BOOLEAN
      ‚¶Å x and y = Boolean (x = Boolean true ‚àß y = Boolean true))
    ‚àß (‚àÄ x, y : BOOLEAN
      ‚¶Å x or y = Boolean (x = Boolean true ‚à® y = Boolean true))
    ‚àß (‚àÄ x, y : BOOLEAN
      ‚¶Å x xor y = Boolean (¬¨ x = Boolean true ‚áî y = Boolean true))
=TEX
=SML
set_goal([],‚ì©‚àÄ sb:SWITCHBOARD; s: SWITCHTYPE ‚¶Å
	not (sb s).STATE = Boolean false ‚áî  (sb s).STATE = Boolean true‚åù);
a(z_‚àÄ_tac THEN REPEAT ‚áí_tac);
a(all_asm_fc_tac[switch_‚àà_thm]);
a(ALL_ASM_FC_T rewrite_tac[cn_boolean_clauses1]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\subsection{Record a Member of Record Set}
The form of this class of lemma is
=INLINEFT
(x ‚âú x1,y ‚âú y1,...) ‚àà set of recs
=TEX
, which arises from assignment to an array of
records in SPARK. Using the switchboard example of the previous section, we could be required to prove the following, say,:
=SML
set_goal([],‚ì©(STATE ‚âú Boolean true, NEXTSWITCH ‚âú 2) ‚àà SWITCHDATA‚åù);
=TEX
Again, applying $cn_‚àà_type_tac$ in the proof context $switch_cn$
will prove the goal:
=SML
a(PC_T1"switch_cn"cn_‚àà_type_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
As this is a one line proof, you may choose not to prove the result as a separate lemma. It rather depends on how many times the result is needed
during the course of the VC proofs, and whether it matters to you
that the application of this tactic in the supporting proof context may
take some time (depending on the size of your specification).

=TEX
\subsection{Real Numbers}

Ada fixed point and floating point types (collectively referred to as
real types) are represented in Z using the
real numbers of pure mathematics as implemented in the {\ProductZ} theory
{\it z\_reals}. In addition, the theory {\it cn} provides some operations
on real numbers that are specific to the Compliance Notation (e.g., the operator
{\it \_e\_} that is used in the translation of real literals).

Several proof contexts are available to assist in working with Ada real types.
These are listed in the following table:

\begin{center}
\begin{tabular}{|l|p{4.5in}|}\hline
Name & Description \\\hline\hline
{\it 'z\_reals} & This is a component proof context that provides general purpose
rules for the theory {\it z\_reals}. \\\hline
{\it z\_‚Ñù\_lin_arith} & This is a complete proof context whose main purpose
is to provide a decision procedure for the linear fragment of the theory of reals. \\\hline
{\it 'cn\_reals} & This is a component proof context that provides rules that
eliminate the special operators on reals in the theory {\it cn} in favour of the
underlying Z operators. Note that it does not expand the {\it \_e\_} operator
except in the special case where the exponent is 0.
A theorem {\it cn\_e\_thm} is provided for use as a rewrite rule
to expand other uses of the {\it \_e\_} operator.\\\hline
\end{tabular}
\end{center}

\Hide{
=SML
new_script{name = "REAL_EG", unit_type="spec"};
=TEX
}

To see these proof contexts in use, consider the following example of a package
specification and body. (For berevity, we have suppressed the {\it new\_script}
commmands).

‚ìàCN
 package real_eg is
   type angle is delta 1.0 / 360.0 range 0.0 .. 1.0 - 1.0 / 360.0;
   procedure interpolate(a, b: in angle; c : out angle);
 end real_eg;
‚ñ†

\Hide{
=SML
new_script{name = "REAL_EG", unit_type="body"};
=TEX
}

‚ìàCN
 package body real_eg is
   procedure interpolate(a, b: in angle; c : out angle)
   Œî C [A +‚ãéR REAL_EGoANGLEvDELTA <‚ãéR B, A <‚ãéR C <‚ãéR B]
   is
   begin
      if  a + angle'delta < b
      then c := a + angle'delta;
      end if;
   end interpolate;
 end real_eg;
‚ñ†

This produces the following VCs (in the theory
=INLINEFT
REAL_EGoINTERPOLATE'proc
=TEX
):

=GFT
‚îÇ vcREAL_EGoINTERPOLATE_1 ?‚ä¢
‚îÇ     ‚àÄ A, B : REAL_EGoANGLE
‚îÇ       | A +‚ãéR REAL_EGoANGLEvDELTA <‚ãéR B ‚àß A +‚ãéR REAL_EGoANGLEvDELTA real_less B = TRUE
‚îÇ       ‚¶Å A <‚ãéR A +‚ãéR REAL_EGoANGLEvDELTA ‚àß A +‚ãéR REAL_EGoANGLEvDELTA <‚ãéR B
=TEX
=GFT
‚îÇ vcREAL_EGoINTERPOLATE_2 ?‚ä¢
‚îÇ     ‚àÄ A, B, C : REAL_EGoANGLE
‚îÇ       | A +‚ãéR REAL_EGoANGLEvDELTA <‚ãéR B ‚àß A +‚ãéR REAL_EGoANGLEvDELTA real_less B = FALSE
‚îÇ       ‚¶Å A <‚ãéR C ‚àß C <‚ãéR B
=TEX

To prove them, we work in the proof context obtained by merging
{\it 'cn\_reals} and {\it 'z\_reals} with the standard complete proof context
for the {\it cn} theory, {\it cn1}:

=SML
open_theory "REAL_EGoINTERPOLATE'proc";
push_merge_pcs["'cn_reals", "'z_reals", "cn1"];
=TEX
We will go through the proof of the first VC. (The second VC is proved
immediately with {\it cn\_vc\_simp\_tac}).
=SML
set_goal([], get_conjecture"-""vcREAL_EGoINTERPOLATE_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
=TEX
This results in the following:
=GFT
...

(* ?‚ä¢ *)  ‚ì©0.0 <‚ãéR REAL_EGoANGLEvDELTA‚åù
=TEX
Here the assumptions are not relevant, we are simply being asked to prove that
{\it REAL_EGoANGLEvDELTA} is positive. We now appeal to the definition of {\it REAL_EGoANGLEvDELTA}:
=SML
a(rewrite_tac[z_get_spec‚ì©REAL_EGoANGLEvDELTA‚åù]);
=TEX
This results in:
=GFT
...

(* ?‚ä¢ *)  ‚ì©real 0 <‚ãéR 1.0 /‚ãéR 360.0‚åù
=TEX
Using the computational rules in the proof context {\it 'z\_‚Ñù\_lin\_arith} complete the proof:
=SML
a(PC_T1 "z_‚Ñù_lin_arith" prove_tac[]);
=TEX
\Hide{
=SML
val vcREAL_EGoINTERPOLATE_1 = save_pop_thm "vcREAL_EGoINTERPOLATE_1";
=TEX
}
\Hide{
=SML
set_goal([], get_conjecture"-""vcREAL_EGoINTERPOLATE_2");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
val vcREAL_EGoINTERPOLATE_2 = save_pop_thm "vcREAL_EGoINTERPOLATE_2";
val _ = pop_pc();
=TEX
}



\ftlmargin=0in

\pagebreak
\chapter{CALCULATOR EXAMPLE} \label{CALCEX}
This Compliance Notation
 example is concerned with the computational aspects of a simple calculator.
Section \ref{LITERATE} provides the literate scripts for the example and section
\ref{CALCVCS} overviews the VCs generated  then provides proofs for
a subset of them. For reference purposes, a complete set of VC proofs is
available in a separate document, \cite{ISS/HAT/DAZ/WRK513}. A listing of the theories generated by the
calculator example is available
in appendix \ref{CALCTH}. In addition,
a listing of the generated SPARK program  is available
in appendix \ref{CALCSPARK}.

\Hide{%
=SML
open_theory"cn";
new_script {name="TC", unit_type="spec"};
=TEX
}

\pagebreak

\section{The Literate Scripts} \label{LITERATE}
Though we hide the detail in this document, remember that there will be one literate script per compilation unit (such as a package specification or body).

\subsection{Basic Definitions}
In this section, we define types and constants which will be of use throughout the rest of the scripts.

The SPARK package $TC$  below helps record the following facts:

\begin{itemize}
\item
The calculator deals with signed integers expressed using up to six decimal digits.

\item
It has a numeric keypad and 6 operation buttons labelled $+$, $-$, $\times$, $+/-$, $\sqrt{ }$, $!$, and $=$.
\end{itemize}

‚ìàCN
package TC is

    BASE : constant INTEGER := 10;
    PRECISION : constant INTEGER := 6;
    MAX_NUMBER : constant INTEGER := BASE ** PRECISION - 1;
    MIN_NUMBER : constant INTEGER := -MAX_NUMBER;

    subtype DIGIT is INTEGER range 0 .. BASE - 1;

    subtype NUMBER is INTEGER range MIN_NUMBER .. MAX_NUMBER;

    type OPERATION is
      (PLUS, MINUS, TIMES, CHANGE_SIGN, SQUARE_ROOT, FACTORIAL, EQUALS);

end TC;
‚ñ†

\newpage
\subsection{The State}
In this section, we define a package which contains all the state variables of the calculator.

The package $GV$ below defines the global variables we will use to implement the following informal description of part of the calculator's behaviour:

\begin{itemize}
\item
The calculator has two numeric state variables: the display, which contains the number currently being entered, and the accumulator, which contains the last result calculated.
\item
The user is considered to be in the process of entering a number whenever a digit button is pressed, and entry of a number is terminated by pressing one of the operation keys.
\item
When a binary operation key is pressed, the operation is remembered so that
the appropriate value can be calculated when the second operand has been entered.
\end{itemize}

As it is a new package, and thus a new compilation unit,
we will require a new script (though here, and elsewhere in this
document, we hide the details of this action).
\Hide{%
=SML
new_script {name="GV", unit_type="spec"};
=TEX
}

‚ìàCN
with TC;
package GV is

    DISPLAY, ACCUMULATOR : TC.NUMBER;

    LAST_OP : TC.OPERATION;

    IN_NUMBER : BOOLEAN;

end GV;
‚ñ†

\newpage
\subsection{The Operations}

In this section, we define a package which contains procedures corresponding to pressing the calculator buttons.

\subsubsection{Package Specification}

We now want to introduce a package $OPS$ which implements the following informal description of how the calculator responds to button presses:

\begin{itemize}
\item
The behaviour when a digit button is pressed depends on whether a number is currently being entered into the display. If a number is being entered, then the digit is taken as part of the number. If a number is not being entered (e.g., if an operation button has just been pressed), then the digit is taken as the most significant digit of a new number in the display.
\item
When a binary operation button is pressed, any outstanding calculation is carried out and the answer (which will be the first operand of the operation) is  displayed; the calculator is then ready for the user to enter the other operand of the operation.
\item
When a unary operation button is pressed, the result of performing that operation to the displayed number is computed and displayed; the accumulator is unchanged, but entry of the displayed number is considered to be complete.
\item
When the button marked $=$ is pressed, any outstanding calculation is carried out and the answer is displayed.
\end{itemize}

The package implementing this is defined in section \ref{PackageOPS} below after we have dealt with some preliminaries.


\paragraph{Z Preliminaries}
\Hide{%
=SML
open_theory "GV'spec";
new_theory "calc_prelims";
=TEX
}
To abbreviate the description of the package, we do some work in Z first, corresponding to the various sorts of button press.

Note that the use of
=INLINEFT
‚Ñ§
=TEX
\ rather than
=INLINEFT
TCoNUMBER
=TEX
\ reflects the fact that we are ignoring questions of arithmetic overflow here.
If we used the Z set which accurately represents the SPARK type, then we would have to add in pre-conditions saying that the operations do not overflow.
The following schema defines what happens when a digit button is pressed.

‚îå DO_DIGIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ GVoDISPLAY‚ãé0, GVoDISPLAY : ‚Ñ§;
‚îÇ GVoIN_NUMBER‚ãé0, GVoIN_NUMBER : BOOLEAN;
‚îÇ D : TCoDIGIT
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ	GVoIN_NUMBER‚ãé0 = TRUE ‚áí GVoDISPLAY = GVoDISPLAY‚ãé0*TCoBASE + D;
‚îÇ	GVoIN_NUMBER‚ãé0 = FALSE ‚áí  GVoDISPLAY = D;
‚îÇ	GVoIN_NUMBER = TRUE
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

We now define sets $UNARY$ and $BINARY$ which partition the two sorts of operation key.
Note that $=$ can be considered as a sort of binary operation (which given operands $x$ and $y$ returns $x$).
‚ìàZ
‚îÇ UNARY ‚âú {TCoCHANGE_SIGN, TCoFACTORIAL, TCoSQUARE_ROOT}
‚ñ†

‚ìàZ
‚îÇ BINARY ‚âú TCoOPERATION \ UNARY
‚ñ†
We need to define a function for computing factorials in order to define the response to the factorial operation button.

‚ìàZAX
‚îÇ	fact : ‚Ñï ‚Üí ‚Ñï
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ	fact 0 = 1 ;
‚îÇ 	‚àÄm:‚Ñï‚¶Å fact(m+1) = (m + 1) * fact m
‚ñ†
Unary operations behave as specified by the following schema.
In which we do specify explicitly  that the accumulator and last operation values are unchanged for clarity and for simplicity later on (when we group the unary and binary operations together).

‚îå DO_UNARY_OPERATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ GVoACCUMULATOR‚ãé0, GVoACCUMULATOR : ‚Ñ§;
‚îÇ GVoDISPLAY‚ãé0, GVoDISPLAY : ‚Ñ§;
‚îÇ GVoLAST_OP‚ãé0, GVoLAST_OP : ‚Ñ§;
‚îÇ GVoIN_NUMBER : BOOLEAN;
‚îÇ O : UNARY
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ	GVoIN_NUMBER = FALSE;
‚îÇ	GVoACCUMULATOR = GVoACCUMULATOR‚ãé0;
‚îÇ	GVoLAST_OP = GVoLAST_OP‚ãé0;
‚îÇ	O = TCoCHANGE_SIGN ‚áí GVoDISPLAY = ~GVoDISPLAY‚ãé0;
‚îÇ	O = TCoFACTORIAL ‚àß GVoDISPLAY‚ãé0 ‚â• 0 ‚áí
‚îÇ			GVoDISPLAY = fact GVoDISPLAY‚ãé0;
‚îÇ	O = TCoSQUARE_ROOT  ‚àß GVoDISPLAY‚ãé0 ‚â• 0 ‚áí
‚îÇ			GVoDISPLAY ** 2 ‚â§ GVoDISPLAY‚ãé0 < (GVoDISPLAY + 1) ** 2
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
\pagebreak

The binary operations are specified by the following schema.
‚îå DO_BINARY_OPERATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ GVoACCUMULATOR‚ãé0, GVoACCUMULATOR : ‚Ñ§;
‚îÇ GVoDISPLAY‚ãé0, GVoDISPLAY : ‚Ñ§;
‚îÇ GVoLAST_OP‚ãé0, GVoLAST_OP : ‚Ñ§;
‚îÇ GVoIN_NUMBER : BOOLEAN;
‚îÇ O : BINARY
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ	GVoIN_NUMBER = FALSE;
‚îÇ	GVoDISPLAY = GVoACCUMULATOR;
‚îÇ	GVoLAST_OP = O;
‚îÇ	GVoLAST_OP‚ãé0 = TCoEQUALS ‚áí
‚îÇ			GVoACCUMULATOR = GVoDISPLAY‚ãé0;
‚îÇ	GVoLAST_OP‚ãé0 = TCoPLUS ‚áí
‚îÇ			GVoACCUMULATOR = GVoACCUMULATOR‚ãé0 + GVoDISPLAY‚ãé0;
‚îÇ	GVoLAST_OP‚ãé0 = TCoMINUS ‚áí
‚îÇ			GVoACCUMULATOR = GVoACCUMULATOR‚ãé0 - GVoDISPLAY‚ãé0;
‚îÇ	GVoLAST_OP‚ãé0 = TCoTIMES ‚áí
‚îÇ			GVoACCUMULATOR = GVoACCUMULATOR‚ãé0 * GVoDISPLAY‚ãé0
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
The disjunction of the schemas for the unary and binary operations is then what is needed to define the response to pressing an arbitrary button press.
‚ìàZ
‚îÇ DO_OPERATION ‚âú DO_UNARY_OPERATION ‚à® DO_BINARY_OPERATION
‚ñ†
\newpage
\subsubsection{The SPARK Package}\label{PackageOPS}
\Hide{%
=SML
new_script1 {name="OPS", unit_type="spec", library_theories=["calc_prelims"]};
=TEX
}
We now use the schemas of the previous section to define the package $OPS$.
‚ìàCN
with TC, GV;
package OPS is
procedure DIGIT_BUTTON (D : in TC.DIGIT)
        Œî GVoDISPLAY, GVoIN_NUMBER [ DO_DIGIT ] ;
procedure OPERATION_BUTTON (O : in TC.OPERATION)
        Œî GVoACCUMULATOR, GVoDISPLAY,
                GVoIN_NUMBER, GVoLAST_OP [ DO_OPERATION ] ;
end OPS;
‚ñ†
\subsubsection{Package Implementation}
\paragraph{Package Body}\label{PBODY}
The following specification of the package body is derived from the package specification in the obvious way. We leave a k-slot for any extra declarations we may need.
\Hide{%
=SML
new_script {name="OPS", unit_type="body"};
=TEX
}

‚ìàCN
$references TC, GV;
package body OPS is
procedure DIGIT_BUTTON (D : in TC.DIGIT)
        Œî GVoDISPLAY, GVoIN_NUMBER [ DO_DIGIT ]
    is begin
        Œî GVoDISPLAY, GVoIN_NUMBER [ DO_DIGIT ]			(3001)
    end DIGIT_BUTTON;
procedure OPERATION_BUTTON (O : in TC.OPERATION)
        Œî GVoACCUMULATOR, GVoDISPLAY,
                 GVoIN_NUMBER, GVoLAST_OP [ DO_OPERATION ]
    is
     ‚ü® Extra Declarations ‚ü©						( 500 )
    begin
        Œî GVoACCUMULATOR, GVoDISPLAY,
                 GVoIN_NUMBER, GVoLAST_OP [ DO_OPERATION ]		(3002)
    end OPERATION_BUTTON;
end OPS;
‚ñ†
\paragraph{Supporting Functions} \label{FUNS}
We choose to separate out the computation of factorials and square roots into separate functions which replace the k-slot labelled 500.
In both cases, we prepare for the necessary algorithms.
Our approach for both functions is to introduce and initialise appropriately a variable called $RESULT$, demand that this be set to the desired function return value and return that value.

=SML
open_scope"OPS.OPERATION_BUTTON";
‚ìàCN
 (500) ‚â°
    function FACT (M : NATURAL) return NATURAL
        Œû [ FACT(M) = fact(M) ]
    is
        RESULT : NATURAL;
    begin
        RESULT := 1;
        Œî RESULT [M ‚â• 0 ‚àß RESULT = 1, RESULT = fact M ]	(1001)
        return RESULT;
    end FACT;

    function SQRT (M : NATURAL) return NATURAL
        Œû [SQRT(M) ** 2 ‚â§ M < (SQRT(M) + 1) ** 2]
    is
        RESULT : NATURAL;
       ‚ü® other local vars ‚ü©		(2)
    begin
       RESULT := 0;
       Œî RESULT [RESULT = 0, RESULT ** 2 ‚â§ M < (RESULT + 1) ** 2]	(2001)
      return RESULT;
    end SQRT;
‚ñ†

\paragraph{Algorithm for Factorial} \label{FACT}
Factorial is implemented by a for-loop with loop-counter $J$ and an invariant requiring that as $J$ steps from $2$ up to $M$, $RESULT$ is kept equal to the factorial of $J$:
=SML
open_scope "OPS.OPERATION_BUTTON.FACT";
‚ìàCN
  (1001) ‚äë
    for J in INTEGER range 2 .. M
    loop
        Œî RESULT [J ‚â• 1 ‚àß RESULT = fact (J-1), RESULT = fact J] (1002)
    end loop;
‚ñ†
Now we can complete the implementation of the factorial function by providing the loop body:

‚ìàCN
  (1002) ‚äë
       RESULT := J * RESULT;
‚ñ†
\paragraph{Algorithm for Square Root} \label{SQRT}
For square root, we need two extra variables to implement a binary search for the square root.
=SML
open_scope"OPS.OPERATION_BUTTON.SQRT";
‚ìàCN
(2) ‚â°
    MID, HI : INTEGER;
‚ñ†
The following just says that we propose to achieve the desired effect on $RESULT$ using $MID$ and $HI$ as well.
‚ìàCN
(2001) ‚äë
        Œî RESULT, MID, HI
            [RESULT = 0, RESULT ** 2 ‚â§ M < (RESULT + 1) ** 2] (2002)
‚ñ†
Now we give the initialisation for $HI$ and describe the loop which will find the square root:

‚ìàCN
(2002) ‚äë
       HI := M + 1;
       $till ‚ü¶RESULT ** 2 ‚â§ M < (RESULT + 1) ** 2‚üß
       loop
           Œî RESULT, MID, HI
               [RESULT ** 2 ‚â§ M < HI ** 2, RESULT ** 2 ‚â§ M < HI ** 2] (2003)
       end loop;
‚ñ†
Now we implement the exit for the loop and specify the next step:
‚ìàCN
(2003) ‚äë
       exit when RESULT + 1 = HI;
       Œî RESULT, MID, HI
            [RESULT ** 2 ‚â§ M < HI ** 2, RESULT ** 2 ‚â§ M < HI ** 2] (2004)
‚ñ†
Now we can fill in the last part of the loop:
‚ìàCN
(2004)    ‚äë
    MID := (RESULT + HI + 1) / 2;
    if      MID ** 2 > M
    then    HI := MID;
    else    RESULT := MID;
    end if;
‚ñ†
\paragraph{Digit Button Algorithm} \label{DIGBUT}
We now continue with the body of the digit button procedure.
An if-statement handling the two cases for updating the display, followed by an assignment to the flag should meet the bill here.
=SML
open_scope"OPS.DIGIT_BUTTON";
‚ìàCN
 (3001) ‚äë
    if    GV.IN_NUMBER
    then  GV.DISPLAY := GV.DISPLAY * TC.BASE + D;
    else  GV.DISPLAY := D;
    end if;
    GV.IN_NUMBER := true;
‚ñ†
\paragraph{Operation Button Algorithm} \label{OPBUT}
We now complete the implementation and verification of the package $OPS$ by giving the body of the procedure for handling the operation buttons.
=SML
open_scope "OPS.OPERATION_BUTTON";
‚ìàCN
 (3002) ‚äë
    if      O = TC.CHANGE_SIGN
    then    GV.DISPLAY := -GV.DISPLAY;
    elsif   O = TC.FACTORIAL
    then    GV.DISPLAY := FACT(GV.DISPLAY);
    elsif   O = TC.SQUARE_ROOT
    then    GV.DISPLAY := SQRT(GV.DISPLAY);
    else    if      GV.LAST_OP = TC.EQUALS
            then    GV.ACCUMULATOR := GV.DISPLAY;
            elsif   GV.LAST_OP = TC.PLUS
            then   GV.ACCUMULATOR := GV.ACCUMULATOR + GV.DISPLAY;
            elsif   GV.LAST_OP = TC.MINUS
            then   GV.ACCUMULATOR := GV.ACCUMULATOR - GV.DISPLAY;
            elsif   GV.LAST_OP = TC.TIMES
            then   GV.ACCUMULATOR := GV.ACCUMULATOR * GV.DISPLAY;
            end if;
            GV.DISPLAY := GV.ACCUMULATOR;
            GV.LAST_OP := O;
    end if;
    GV.IN_NUMBER := false;
‚ñ†
=TEX
\pagebreak

\section{Proving the VCs} \label{CALCVCS}
The {\daztool} has generated 37 VCs. The following list
outlines where each group
of VCs has come from, and proofs of a representative selection from
these groups are given below.

\begin{tabular}{l l l l}\\
\\
8& from the introduction of the package body:&$vcOPS_1$&\\
&&$vcOPS_2$&\\
&&$vcOPS_3$&\\
&&$vcOPS_4$&\\
&&$vcOPSoDIGIT_BUTTON_1$&\\
&&$vcOPSoDIGIT_BUTTON_2$&\\
&&$vcOPSoOPERATION_BUTTON_1$&\\
&&$vcOPSoOPERATION_BUTTON_2$&\\
&&&\\
4&from the introduction of supporting functions:&$vcOPSoOPERATION_BUTTONoFACT_1$&\\
&&$vcOPSoOPERATION_BUTTONoFACT_2$&\\
&&$vcOPSoOPERATION_BUTTONoSQRT_1$&\\
&&$vcOPSoOPERATION_BUTTONoSQRT_2$&\\
&&&\\
5&from the refinement steps in the body of $FACT$:&$vc1001_1$&\\
&&$vc1001_2$&\\
&&$vc1001_3$&\\
&&$vc1001_4$&\\
&&$vc1002_1$&\\
&&&\\
10&from the refinement steps in the body of $SQRT$:&$vc2001_1$&\\
&&$vc2001_2$&\\
&&$vc2002_1$&\\
&&$vc2002_2$&\\
&&$vc2002_3$&\\
&&$vc2003_1$&\\
&&$vc2003_2$&\\
&&$vc2003_3$&\\
&&$vc2004_1$&\\
&&$vc2004_2$&\\
&&&\\
2&from if-statement in the  digit button procedure:&$vc3001_1$&\\
&&$vc3001_2$&\\
&&&\\
8&from if-statement in the operations button procedure:&$vc3002_1$&1-3 from unary ops\\
&&$vc3002_2$&\\
&&$vc3002_3$&\\
&&$vc3002_4$&4-8 from binary ops\\
&&$vc3002_5$&\\
&&$vc3002_6$&\\
&&$vc3002_7$&\\
&&$vc3002_8$&\\
\end{tabular}

\pagebreak
\subsection{Preliminaries} \label{PRELIM}
The first thing to do is to generate the supporting theorems and supporting
proof context for the calculator example, as described in
section \ref{STARTED}.
We do this in the theory {\em calc_prelims}.
=SML
open_theory "calc_prelims";
val calc_thms = all_cn_make_script_support "calc_prelims";
=TEX
We will conduct the VC proofs in the proof context $cn1$; any  subsidiary
 general purpose results that we may need will be proved in
 the proof context $z_library1$.

\subsection{Package Body VCs}
Eight VCs are produced from the
introduction of the package body, see section \ref{PBODY}. These are trivial because the package body is derived directly from the package
specification. For example:
=GFT
vcOPS_1
	true ‚áí true
=TEX

=GFT
vcOPS_2
	‚àÄ GVoDISPLAY, GVoDISPLAY‚ãé0 : TCoNUMBER;
             GVoIN_NUMBER, GVoIN_NUMBER‚ãé0 : BOOLEAN;
             D : TCoDIGIT | true ‚àß DO_DIGIT ‚¶Å DO_DIGIT
=TEX
$cn_vc_simp_tac$ will solve all of these  VCs. For example:
=SML
open_scope "OPS";
set_pc"cn1";
set_goal([],get_conjecture"-""vcOPS_2");
a(cn_vc_simp_tac[]);
save_pop_thm"vcOPS_2";
=TEX

\subsection{Function Definition VCs}
These four VCs result from the requirement to show that the function bodies
of $FACT$ and $SQRT$ achieve the statement of their specifications, see section \ref{FUNS}. For example:
=GFT
vc500_1
‚àÄ M : NATURAL ‚¶Å M ‚â• 0 ‚àß 1 = 1
=TEX

=GFT
vc500_2
FACT : NATURAL ‚Üí NATURAL; RESULT : NATURAL; M : NATURAL
             | true ‚àß RESULT = fact M ‚àß FACT M = RESULT
             ‚¶Å FACT M = fact M
=TEX
The proof of $vc500_1$  requires the following general purpose
lemma about SPARK natural numbers:

=SML
open_theory "calc_prelims";
push_pc"z_library1";
set_goal([], ‚ì©‚àÄm : NATURAL‚¶Å m ‚â• 0‚åù);
a(rewrite_tac[z_get_spec‚ì©NATURAL‚åù] THEN REPEAT strip_tac);
val natural_thm = save_pop_thm"natural_thm";
=TEX
Now $cn_vc_simp_tac$ followed by forward chaining with $natural_thm$
will solve $vcOPSoOPERATION_BUTTONoFACT_1$:
=SML
open_scope "OPS.OPERATION_BUTTON.FACT";
set_goal([],get_conjecture"-""vcOPSoOPERATION_BUTTONoFACT_1");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN all_fc_tac[natural_thm]);
save_pop_thm"vcOPSoOPERATION_BUTTONoFACT_1";
=TEX

After simplifying and stripping, $vcOPSoOPERATION_BUTTONoFACT_2$ is an example of predicate calculus with equality, see section \ref{EQUATIONS}, and is straightforward to prove using
variable elimination, or just rewriting with the assumptions:
=SML
set_goal([],get_conjecture"-""vcOPSoOPERATION_BUTTONoFACT_2");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
save_pop_thm"vcOPSoOPERATION_BUTTONoFACT_2";
=TEX

\subsection{$FACT$ Refinement Steps VCs}
The implementation of factorial  produces five VCs, see section \ref{FACT}. For example:
=GFT
vc1001_1
‚àÄ RESULT : NATURAL; M : NATURAL
  | (M ‚â• 0 ‚àß RESULT = 1) ‚àß 2 ‚â§ M
  ‚¶Å 2 ‚â• 1 ‚àß RESULT = fact (2 - 1)
=TEX

=GFT
vc1001_2
‚àÄ RESULT : NATURAL; M : NATURAL
  | (M ‚â• 0 ‚àß RESULT = 1) ‚àß 2 > M
  ‚¶Å RESULT = fact M
=TEX

First, a general purpose
 lemma about the first two values of factorial (needed because our algorithm avoids the unnecessary pass through the loop with $J = 1$). The theorem $cn_fact_thm$ is one of the supporting theorems generated in section \ref{PRELIM}.
=SML
open_theory"calc_prelims";
push_pc"z_library1";
set_goal([], ‚ì©fact 0 = 1 ‚àß fact 1 = 1‚åù);
a(rewrite_tac[cn_fact_thm, rewrite_rule[cn_fact_thm]
	((z_‚àÄ_elim‚ì©0‚åù o ‚àß_right_elim) cn_fact_thm)]);
val fact_thm  = save_pop_thm"fact_thm";
pop_pc();
=TEX
To prove $vc1001_1$, simplify the VC, then strip and rewrite with $fact_thm$
and the assumptions:
=SML
open_scope "OPS.OPERATION_BUTTON.FACT";
set_pc"cn1";
set_goal([],get_conjecture"-""vc1001_1");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[fact_thm]);
save_pop_thm"vc1001_1";
=TEX

For $vc1001_2$, first simplify and then strip:

=SML
set_goal([],get_conjecture"-""vc1001_2");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac);
=TEX

=GFT ProofPower output
(* *** Goal "" *** *)

(*  5 *)  ‚ì©RESULT ‚àà NATURAL‚åù
(*  4 *)  ‚ì©M ‚àà NATURAL‚åù
(*  3 *)  ‚ì©0 ‚â§ M‚åù
(*  2 *)  ‚ì©RESULT = 1‚åù
(*  1 *)  ‚ì©¬¨ 2 ‚â§ M‚åù

(* ?‚ä¢ *)  ‚ì©RESULT = fact M‚åù

=TEX
Assumption 1 gives you $M\ =\ 0$ or $M\ =\ 1$, you will need
the linear arithmetic proof context for this, then rewriting with $fact_thm$
completes the proof:
=SML
a(lemma_tac‚ì©M = 0 ‚à® M = 1‚åù
	THEN1 PC_T1"z_lin_arith"asm_prove_tac[]
	THEN asm_rewrite_tac[fact_thm]);
save_pop_thm"vc1001_2";
=TEX


\subsection{$SQRT$ Refinement Steps VCs}
The implementation of square root  produces ten VCs, see section \ref{SQRT}. Eight of them are trivial
and are proved by $cn_vc_simp_tac$. For example:

=GFT
vc2002_2
‚àÄ HI : INTEGER; RESULT, RESULT‚ãé0 : NATURAL; M : NATURAL
  | RESULT‚ãé0 = 0 ‚àß RESULT ** 2 ‚â§ M ‚àß M < HI ** 2
  ‚¶Å RESULT ** 2 ‚â§ M ‚àß M < HI ** 2
=TEX
=SML
open_scope "OPS.OPERATION_BUTTON.SQRT";
set_pc "cn1";
set_goal([],get_conjecture"-""vc2002_2");
a(cn_vc_simp_tac[]);
save_pop_thm"vc2002_2";
=TEX


$vc2003_1$ also requires stripping and variable elimination to achieve a proof.
Extra work is needed in the proof of $vc2002_1$:
=GFT
vc2002_1
‚àÄ RESULT : NATURAL; M : NATURAL
             | RESULT = 0
             ‚¶Å RESULT ** 2 ‚â§ M ‚àß M < (M + 1) ** 2
=TEX
This depends on some facts about the exponentiation operator,
which you would probably provide as separate lemmas:
=SML
push_pc"z_library1";
set_goal([], ‚ì©‚àÄx: ‚Ñ§‚¶Å  x ** 1 = x‚åù);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[](
    z_‚àÄ_elim‚ì©(x ‚âú x, y ‚âú 0)‚åù (‚àß_right_elim(z_get_spec‚ì©(_**_)‚åù)))]);
val star_star_1_thm = save_pop_thm"star_star_1_thm";
=TEX
=SML
set_goal([], ‚ì©‚àÄx: ‚Ñ§‚¶Å  x ** 2 = x * x‚åù);
a(REPEAT strip_tac);
a(rewrite_tac[star_star_1_thm, rewrite_rule[](
    z_‚àÄ_elim‚ì©(x ‚âú x, y ‚âú 1)‚åù (‚àß_right_elim(z_get_spec‚ì©(_**_)‚åù)))]);
val star_star_2_thm = save_pop_thm"star_star_2_thm";
pop_pc();
=TEX
To prove $vc2002_1$, first simplify the goal, strip the
assumptions and eliminate $RESULT$:

=SML
set_goal([], get_conjecture "-" "vc2002_1");
a(cn_vc_simp_tac[]);
a(REPEAT ‚áí_tac THEN all_var_elim_asm_tac1);
=TEX
=GFT ProofPower output
...
(*  2 *)  ‚ì©M ‚àà NATURAL‚åù
(*  1 *)  ‚ì©0 ‚àà NATURAL‚åù

(* ?‚ä¢ *)  ‚ì©0 ** 2 ‚â§ M ‚àß ¬¨ (M + 1) ** 2 ‚â§ M‚åù
=TEX
Throw away the irrelevant assumption then forward chain with $natural_thm$:
=SML
a(POP_ASM_T discard_tac THEN all_fc_tac[natural_thm]);
=TEX
=GFT ProofPower output
...
(*  2 *)  ‚ì©M ‚àà NATURAL‚åù
(*  1 *)  ‚ì©0 ‚â§ M‚åù

(* ?‚ä¢ *)  ‚ì©0 ** 2 ‚â§ M ‚àß ¬¨ (M + 1) ** 2 ‚â§ M‚åù
=TEX
We no longer need assumption 2. Then rewriting with the assumptions and $star_star_2_thm$ will deal
with the first conjunct in the goal and expand the second:
=SML
a(DROP_NTH_ASM_T 2 discard_tac);
a(asm_rewrite_tac[star_star_2_thm]);
=TEX
The proof is progressed by induction on $M$:
=SML
a(z_‚â§_induction_tac‚ì©M‚åù);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  2 *)  ‚ì©0 ‚â§ i‚åù
(*  1 *)  ‚ì©¬¨ (i + 1) * (i + 1) ‚â§ i‚åù

(* ?‚ä¢ *)  ‚ì©¬¨ ((i + 1) + 1) * ((i + 1) + 1) ‚â§ i + 1‚åù


(* *** Goal "1" *** *)

(* ?‚ä¢ *)  ‚ì©¬¨ (0 + 1) * (0 + 1) ‚â§ 0‚åù
=TEX
The first subgoal is proved by rewriting in the current proof context. The
second is proved automatically in the linear arithmetic proof context:
=SML
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
save_pop_thm "vc2002_1";
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX
\subsection{Digit Button VCs}
Two VCs result from the if_statement in the digit button procedure, see section \ref{DIGBUT}. For example:
=GFT
‚àÄ GVoDISPLAY : TCoNUMBER; GVoIN_NUMBER : BOOLEAN; D : TCoDIGIT
             | true ‚àß GVoIN_NUMBER = TRUE
             ‚¶Å (D ‚âú D, GVoDISPLAY ‚âú GVoDISPLAY * TCoBASE + D,
                   GVoDISPLAY‚ãé0 ‚âú GVoDISPLAY, GVoIN_NUMBER ‚âú TRUE,
                   GVoIN_NUMBER‚ãé0 ‚âú GVoIN_NUMBER)
               ‚àà DO_DIGIT
=TEX
Both are proven by simplifying, stripping and then rewriting with
the definition of $DO_DIGIT$:

=SML
open_scope "OPS.DIGIT_BUTTON";
set_pc "cn1";
set_goal([],get_conjecture"-""vc3001_1");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[cn_DO_DIGIT_thm]);
save_pop_thm"vc3001_1";
=TEX


\subsection{Operations Button VCs}
Eight VCs result from the branches in the operations button procedure, 3 unary and 5 binary, see section \ref{OPBUT}. For example, the unary operation produces:
=GFT
vc3002_1
‚àÄ GVoDISPLAY, GVoACCUMULATOR : TCoNUMBER;
    GVoLAST_OP : TCoOPERATION;
    O : TCoOPERATION
  | true ‚àß O eq TCoCHANGE_SIGN = TRUE
  ‚¶Å (GVoACCUMULATOR ‚âú GVoACCUMULATOR,
	 GVoACCUMULATOR‚ãé0 ‚âú GVoACCUMULATOR,
        GVoDISPLAY ‚âú ~ GVoDISPLAY, GVoDISPLAY‚ãé0 ‚âú GVoDISPLAY,
        GVoIN_NUMBER ‚âú FALSE, GVoLAST_OP ‚âú GVoLAST_OP,
        GVoLAST_OP‚ãé0 ‚âú GVoLAST_OP, O ‚âú O)
    ‚àà DO_OPERATION
=TEX
To prove this VC, we do need to unwind the basic definitions, so we will
use the list of supporting theorems $calc_thms$ that we generated before starting
out on the proofs, section \ref{PRELIM}. (We could equally well have chosen
to rewrite in the supporting proof context $calc_cn$ with no
additional theorems.) This proof gives an example of where $REPEAT\ strip_tac$
would be too brutal because it would generate many subgoals.

=SML
open_scope "OPS.OPERATION_BUTTON";
set_pc "cn1";
set_goal([], get_conjecture"-""vc3002_1");
a(cn_vc_simp_tac calc_thms);
a ‚áí_tac;
a(asm_rewrite_tac[]);
save_pop_thm"vc3002_1";
=TEX


The remaining two unary operations VCs require us to make the (reasonable) assumption that a non-negative number of the precision handled by the calculator will fit in a SPARK $NATURAL$.
This amounts to the following axiom:
‚ìàZ
‚îÇ TCoMAX_NUMBER ‚â§ INTEGERvLAST
‚ñ†
=SML
val number_ax = get_axiom"-""Constraint 1";
=TEX
To prove $vc3002_2$, apply the same tactics as for $vc3002_1$:
=SML
set_goal([], get_conjecture"-""vc3002_2");
a(cn_vc_simp_tac calc_thms);
a ‚áí_tac;
a(asm_rewrite_tac[]);
=TEX
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* 10 *)  ‚ì©~ 999999 ‚â§ GVoACCUMULATOR‚åù
(*  9 *)  ‚ì©GVoACCUMULATOR ‚â§ 999999‚åù
(*  8 *)  ‚ì©~ 999999 ‚â§ GVoDISPLAY‚åù
(*  7 *)  ‚ì©GVoDISPLAY ‚â§ 999999‚åù
(*  6 *)  ‚ì©0 ‚â§ GVoLAST_OP‚åù
(*  5 *)  ‚ì©GVoLAST_OP ‚â§ 6‚åù
(*  4 *)  ‚ì©0 ‚â§ O‚åù
(*  3 *)  ‚ì©O ‚â§ 6‚åù
(*  2 *)  ‚ì©¬¨ O = 3‚åù
(*  1 *)  ‚ì©O = 5‚åù

(* ?‚ä¢ *)  ‚ì©0 ‚â§ GVoDISPLAY ‚áí FACT GVoDISPLAY = fact GVoDISPLAY‚åù

=TEX
Then remove the redundant assumptions and strip the goal:
=SML
a(LIST_DROP_NTH_ASM_T[1,2,3,4,5,6,8,9,10] (MAP_EVERY discard_tac));
a strip_tac;
=TEX
=GFT ProofPower output
...
(* *** Goal "" *** *)

(*  2 *)  ‚ì©GVoDISPLAY ‚â§ 999999‚åù
(*  1 *)  ‚ì©0 ‚â§ GVoDISPLAY‚åù

(* ?‚ä¢ *)  ‚ì©FACT GVoDISPLAY = fact GVoDISPLAY‚åù
=TEX
All we need now is to add to the assumptions the fact that
$GVoDISPLAY\ ‚àà\ NATURAL$, then forward chain with the definition of $FACT$.
Notice that during the proof of the lemma we switch to the proof context
$calc_cn$ which contains the supporting theorems generated in section
\ref{PRELIM}.
=SML
a(lemma_tac ‚ì©GVoDISPLAY ‚àà NATURAL‚åù);
(* *** Goal "1" *** *)
a(ante_tac number_ax);
a(PC_T1"calc_prelims"asm_rewrite_tac[z_get_spec‚ì©NATURAL‚åù]);
a(DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_get_spec‚ì©FACT‚åù]);
save_pop_thm"vc3002_2";
=TEX
The proof of $vc3002_3$ will be almost identical, except that the last
step will be to forward chain with the definition of $SQRT$.

Because the binary operations only involve built-in arithmetic operators, they are a little easier to verify than the unary ones. For example the VC:
=GFT
vc3002_4
‚àÄ GVoDISPLAY, GVoACCUMULATOR : TCoNUMBER;
    GVoLAST_OP : TCoOPERATION;
    O : TCoOPERATION
  | true
    ‚àß O eq TCoCHANGE_SIGN = FALSE
    ‚àß O eq TCoFACTORIAL = FALSE
    ‚àß O eq TCoSQUARE_ROOT = FALSE
    ‚àß GVoLAST_OP eq TCoEQUALS = TRUE
  ‚¶Å (GVoACCUMULATOR ‚âú GVoDISPLAY, GVoACCUMULATOR‚ãé0 ‚âú GVoACCUMULATOR,
        GVoDISPLAY ‚âú GVoDISPLAY, GVoDISPLAY‚ãé0 ‚âú GVoDISPLAY,
        GVoIN_NUMBER ‚âú FALSE, GVoLAST_OP ‚âú O, GVoLAST_OP‚ãé0 ‚âú GVoLAST_OP,
        O ‚âú O)
    ‚àà DO_OPERATION
=TEX
will be proved by the following:
=SML
set_goal([], get_conjecture"-""vc3002_4");
a(PC_T1"calc_prelims"cn_vc_simp_tac[]);
a(‚áí_tac THEN asm_rewrite_tac[]);
save_pop_thm"vc3002_4";
=TEX
The same proof will suffice for the remaining four binary operation VCs.


\appendix

\chapter {EXAMPLE THEORY LISTINGS} \label{CALCTH}
\Hide{%
=SML
set_flag("pp_show_index",true);
open_theory"EX'proc";
z_output_theory{theory="EX'proc",out_file="usr503x1.thl.doc"};
open_theory"REAL_EG'spec";
z_output_theory{theory="REAL_EG'spec",out_file="usr503x2.thl.doc"};
open_theory"REAL_EG'body";
z_output_theory{theory="REAL_EG'body",out_file="usr503x3.thl.doc"};
open_theory"REAL_EGoINTERPOLATE'proc";
z_output_theory{theory="REAL_EGoINTERPOLATE'proc",out_file="usr503x4.thl.doc"};
open_theory"TC'spec";
z_output_theory{theory="TC'spec",out_file="usr503x5.thl.doc"};
open_theory"GV'spec";
z_output_theory{theory="GV'spec",out_file="usr503x6.thl.doc"};
open_theory"calc_prelims";
z_output_theory{theory="calc_prelims",out_file="usr503x7.thl.doc"};
open_theory"OPS'spec";
z_output_theory{theory="OPS'spec",out_file="usr503x8.thl.doc"};
open_theory"OPS'body";
z_output_theory{theory="OPS'body",out_file="usr503x9.thl.doc"};
open_theory"OPSoDIGIT_BUTTON'proc";
z_output_theory{theory="OPSoDIGIT_BUTTON'proc",out_file="usr503x10.thl.doc"};
open_theory"OPSoOPERATION_BUTTON'proc";
z_output_theory{theory="OPSoOPERATION_BUTTON'proc",out_file="usr503x11.thl.doc"};
open_theory"OPSoOPERATION_BUTTONoFACT'func";
z_output_theory{theory="OPSoOPERATION_BUTTONoFACT'func",out_file="usr503x12.thl.doc"};
open_theory"OPSoOPERATION_BUTTONoSQRT'func";
z_output_theory{theory="OPSoOPERATION_BUTTONoSQRT'func",out_file="usr503x13.thl.doc"};
=TEX
}
The examples in this document give rise to 13 theories as follows:

\input{usr503x1.thl.tex}
\input{usr503x2.thl.tex}
\input{usr503x3.thl.tex}
\input{usr503x4.thl.tex}
\input{usr503x5.thl.tex}
\input{usr503x6.thl.tex}
\input{usr503x7.thl.tex}
\input{usr503x8.thl.tex}
\input{usr503x9.thl.tex}
\input{usr503x10.thl.tex}
\input{usr503x11.thl.tex}
\input{usr503x12.thl.tex}
\input{usr503x13.thl.tex}

\pagebreak
\chapter {CALCULATOR EXAMPLE ADA PROGRAM} \label{CALCSPARK}

=GFT
package TC
is
  BASE : constant INTEGER := 10;
  PRECISION : constant INTEGER := 6;
  MAX_NUMBER : constant INTEGER := BASE ** PRECISION - 1;
  MIN_NUMBER : constant INTEGER := - MAX_NUMBER;
  subtype DIGIT is INTEGER range 0..BASE - 1;
  subtype NUMBER is INTEGER range MIN_NUMBER..MAX_NUMBER;
  type OPERATION is (PLUS, MINUS, TIMES, CHANGE_SIGN, SQUARE_ROOT, FACTORIAL,
  EQUALS);
end TC;

with TC;
package GV
is
  DISPLAY, ACCUMULATOR : TC.NUMBER;
  LAST_OP : TC.OPERATION;
  IN_NUMBER : BOOLEAN;
end GV;

with TC, GV;
package OPS
is
  procedure DIGIT_BUTTON (D : in TC.DIGIT);
    -- Spec ...
  procedure OPERATION_BUTTON (O : in TC.OPERATION);
    -- Spec ...
end OPS;
=TEX
\pagebreak
=GFT
package body OPS
is
  procedure DIGIT_BUTTON (D : in TC.DIGIT)
    -- Spec ...
  is
  begin
    if GV.IN_NUMBER
    then
      GV.DISPLAY := GV.DISPLAY * TC.BASE + D;
    else
      GV.DISPLAY := D;
    end if;
    GV.IN_NUMBER := true;
  end DIGIT_BUTTON;
  procedure OPERATION_BUTTON (O : in TC.OPERATION)
    -- Spec ...
  is
    function FACT (M : NATURAL) return NATURAL
      -- Spec ...
    is
      RESULT : NATURAL;
    begin
      RESULT := 1;
      for J in INTEGER range 2..M
      loop
        RESULT := J * RESULT;
      end loop;
      return RESULT;
    end FACT;
=TEX
\pagebreak
=GFT
    function SQRT (M : NATURAL) return NATURAL
      -- Spec ...
    is
      RESULT : NATURAL;
      MID, HI : INTEGER;
    begin
      RESULT := 0;
      HI := M + 1;
      -- $TILL ...
      loop
        exit when RESULT + 1 = HI;
        MID := (RESULT + HI + 1) / 2;
        if MID ** 2 > M
        then
          HI := MID;
        else
          RESULT := MID;
        end if;
      end loop;
      return RESULT;
    end SQRT;
  begin
    if O = TC.CHANGE_SIGN
    then
      GV.DISPLAY := - GV.DISPLAY;
    elsif O = TC.FACTORIAL
    then
      GV.DISPLAY := FACT (GV.DISPLAY);
    elsif O = TC.SQUARE_ROOT
    then
      GV.DISPLAY := SQRT (GV.DISPLAY);
    else
      if GV.LAST_OP = TC.EQUALS
      then
        GV.ACCUMULATOR := GV.DISPLAY;
      elsif GV.LAST_OP = TC.PLUS
      then
        GV.ACCUMULATOR := GV.ACCUMULATOR + GV.DISPLAY;
      elsif GV.LAST_OP = TC.MINUS
      then
        GV.ACCUMULATOR := GV.ACCUMULATOR - GV.DISPLAY;
      elsif GV.LAST_OP = TC.TIMES
      then
        GV.ACCUMULATOR := GV.ACCUMULATOR * GV.DISPLAY;
      end if;
      GV.DISPLAY := GV.ACCUMULATOR;
      GV.LAST_OP := O;
    end if;
    GV.IN_NUMBER := false;
  end OPERATION_BUTTON;
end OPS;
=TEX

\pagebreak

\chapter*{REFERENCES}

\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
{\raggedright
\bibliography{fmu,daz}}

\pagebreak
\twocolumn
\chapter*{INDEX}
\addcontentsline{toc}{chapter}{INDEX}
\small

\printindex

\end{document}


