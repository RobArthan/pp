% dtd516.doc   %Z% $Date: 2000/07/03 13:57:03 $ $Revision: 1.16 $ $RCSfile: dtd516.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\daztool{Compliance Tool}
\def\REFERENCE{\cite{DS/FMU/IED/USR006}}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Tool User Interface}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD516}  %% Mandatory field
\def\SCCSversion{$Revision: 1.16 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/07/03 13:57:03 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & DAZ Team}
\raggedright{\TPPabstract{This document contains the signature for the commands required to operate the compliance tool.}}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A,~Smith, DRA \\
	Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1-1.5] First drafts.
\item[Issues 1.6-1.7] Reworked according to desk check report 018.
\item[Issue 1.8] Corrected usage message in one of the documentation boxes.
\item[Issue 1.9] Added $output\_hypertext\_edit\_script$ to the signature.
\item[Issue 1.10] Updated distribution list.
\item[Issue 1.11] Added $new\_script1$.
\item[Issue 1.12] Typo.
\item[Issue 1.13, 1.14] Tidying.
\item[Issue 1.15] Enhancement R1 --- multidimensional arrays. This adds
{\it array\_agg\_def} to the user interface.
\item[Issue 1.16] Added descriptions of all flags and string controls for the user guide.
\item[Issue 1.17] CTLE I R1/11 --- nested packages.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document provides the user with an interface to all the functions required to operate the compliance tool and is written in response to \cite{ISS/HAT/DAZ/HLD503}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a signature which comprises the functions necessary for a user to operate the compliance tool. It supports the following functionality:
\begin{description}
\item
Specify a new literate script
\item
Generate a SPARK program, either into the {\Product} journal window or into a file.
\item
Generate a Z document, either into the journal window or a file.
\item
Invoke a navigation system to map between VCs and the web clauses from which they originate. 
\end{description}
\subsubsection{Known Deficiencies}
None known.
\subsection{Possible Enhancements}
None.

\section{THE SIGNATURE}
=DOC
signature ÛComplianceToolÝ  = sig
=DESCRIBE
This is the signature for the commands which a user requires to operate the compliance tool.
=ENDDOC

\section{CREATING NEW LITERATE SCRIPTS}
=DOC
type ÛCN_STATEÝ
val Ûinitial_cn_stateÝ : CN_STATE
val Ûget_cn_stateÝ : unit -> CN_STATE
val Ûset_cn_stateÝ : CN_STATE -> unit
val Ûnew_scriptÝ : {name : string, state : CN_STATE} -> unit
val Ûnew_script1Ý :
	{name : string, state : CN_STATE, library_theories : string list} -> unit
val Ûnew_continuation_scriptÝ : {name : string, state : CN_STATE} -> unit
val Ûnew_continuation_script1Ý :
	{name : string, state : CN_STATE, library_theories : string list} -> unit
=DESCRIBE
{\it new\_script} takes as an argument the name of a literate script. It initialises the compliance tool environment with the state supplied as its argument {\it state$ and creates a new theory of the same name, into which the Z document generated by the subsequent literate script is placed.
The data structure containing the SPARK program is set to its initial empty value.

{\it new\_script1} acts the same as {\it {\it new\_script} except that its list
of library theories will be made the parents of the script theory,
and any theory produced during processing the script.	

{\it new\_continuation\_script} and {\it new\_continuation\_script} are
just like {\it new\_script} {\it new\_script1}, except that the data
structure containing the SPARK program is retained.

$initial\_cn\_state$ is the state of the Compliance Tool where all the environments are set to empty. It is convenient to use the $initial\_cn\_state$ as an argument to $new\_script$ when no previous script has been processed.

$get\_cn\_state$ and $set\_cn\_state$ gets and sets the state of the Compliance Tool.
=ENDDOC
\section{GENERATING A SPARK PROGRAM}
=DOC
val Ûprint_spark_programÝ : unit -> unit
val Ûoutput_spark_programÝ : {out_file : string} -> unit
=DESCRIBE
The function $print\_spark\_program$ generates and prints the SPARK program from the contents of the {\daztool} environment. The SPARK program is created by filling in the k-slots and specification statements in a literate script with their expansions and printing the output onto the screen in SPARK syntax such that it could be subsequently compiled using an Ada compiler.

$output\_spark\_program$ does the same as $print\_spark\_program$ but allows the user to specify a file to which the program will then be written. 

=USES
For example, if a literate script called ``primes'' has just been entered into the {\daztool}  then the following command will output the corresponding SPARK to a file called $primes.ada$.

\begin{verbatim}
output_spark_document{out_file="primes.ada"}
\end{verbatim}

=ENDDOC
\section{GENERATING A Z DOCUMENT}
=DOC
val Ûprint_z_documentÝ : string -> unit
val Ûoutput_z_documentÝ : {script : string, out_file : string} -> unit
=DESCRIBE
$print\_z\_document$ prints the Z document from the named script to the standard output. The listing is in a format suitable for its re-entry into a {\Product} session.

$output\_z\_program$ is similar to $print\_z\_document$, but the the Z document is written to the named output file $out\_file$.

=USES
For example, if a literate script called ``primes'' has been entered into the {\daztool}  then the following command will output the corresponding Z document to a file called $primes.zdoc$.

\begin{verbatim}
output_z_document{script="primes", out_file="primes.zdoc"}
\end{verbatim}

=ENDDOC

\section{NAVIGATION}

=DOC
val Ûbrowse_vcsÝ : unit -> unit
=DESCRIBE
This invokes an interactive browsing tool for mapping VCs onto web clauses, and vice versa.
=ENDDOC

\section{GENERATING AN EDIT SCRIPT FOR HYPERTEXT}

=DOC
val Ûoutput_hypertext_edit_scriptÝ : {out_file : string} -> unit
=DESCRIBE
This function produces an edit script from a processed literate script. The edit script is placed in a file with name $out\_file$.

The edit script will introduce hypertext links between specification statements or K-Slots, and their corresponding expansion paragraphs. 
=ENDDOC

\section{SUBSTITUTION IN VCS}
=DOC
(* Flag Ûcn_use_let_in_vcsÝ - boolean control, default false *)
=DESCRIBE
This is the name of flag (see {\it set\_flag} in \REFERENCE).
The flag controls the way substitution of expressions for variables is treated during VC generation.

If the flag is false (the default), then the substitution is carried out using the HOL $subst$ function and then conversions are used to transform the result into Z: this results in a Z term in which the variables have actually been replaced by their substitutes, and declarations and other constructs have been adjusted as necessary to avoid variable capture.

If the flag is set true (using $set\_flag$), then an HOL $let$ construct is used to give the semantics of substitution without actually replacing any variables with their substitutes.
The result is {\em not} Z, but may help to abbreviate the VC and make its structure clearer.
=ENDDOC
\section{DIAGNOSTICS FOR TYPE-CHECKING}
=DOC
(* Flag Ûcn_show_typing_contextÝ - boolean control, default false *)
=DESCRIBE
This is the name of flag (see {\it set\_flag} in \REFERENCE).
When set to true the flag will cause the tool to display
the typing context used when type-checking each Z expression
encountered in Compliance Notation clauses.
The display gives a list of the theories that are in scope (omitting {\it z\_library}
and its ancestors) and a list of the variables that are have their
type fixed by the context (e.g., variables corresponding to SPARK program variables).

This flag is primarily a diagnostic aid for development of the tool, but
may be of help to an end user in some cases.
=ENDDOC
\section{CASE OF KEYWORDS IN SPARK PROGRAM}
=DOC
(* Ûcase_of_spark_keywordsÝ - string control, default "upper" *)
=DESCRIBE
This is the name of a string control (see {\it set\_string\_control} in \REFERENCE).
This controls the case of Ada reserved words in the output from {\it print\_spark\_program}
and {\it output\_spark\_program}.
There are three allowed values for the string control: {\tt "upper"}, {\tt "lower"} and
{\tt "as input"}.
The values {\tt "upper"} and {\tt "lower"} makes the tool generate upper-case and lower-case reserved words respectively;
the value {\tt "as input"} makes the tool use the same case for a reserved
word as was used at its first appearance in the original Compliance Notation script.
=ENDDOC

\subsection{SUPPORT FOR MULTIDIMENSIONAL ARRAYS}
=DOC
val Ûarray_agg_defÝ : int -> unit
=DESCRIBE
This function is used to generate the definitions that support multidimensional array
aggregates. These definitions are built-in for arrays of up to 20 dimensions, so you
do not need to use this function unless you have array aggregates of more than 20
dimensions. The function should be called after first opening either the theory ``cn''
or the cache theory for your database.
=FAILURE
508059	the argument to array_agg_def must be at least 2
=ENDDOC


\section{EPILOGUE}

=SML
end (* signature ComplianceTool *);
=TEX

\section{TEST POLICY}
The functions in this document are used to invoke interactive tools and are not appropriate for off-line testing. Therefore there are no corresponding module tests.

These are to be tested during system/integration tests as discussed in \cite{ISS/HAT/DAZ/HLD502}.
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
