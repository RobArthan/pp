% dtd511.doc %Z% $Date: 2001/12/12 14:51:25 $ $Revision: 1.19 $ $RCSfile: dtd511.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Z Output Function} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD511} %% Mandatory field
\def\SCCSversion{$Revision: 1.19 $%
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date: 2001/12/12 14:51:25 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{A.C.~Hayward&WIN01}
\TPPauthorisation{D.J.~King & DAZ Team}
\TPPabstract{
This document contains the detailed design for the Z Document Output Function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.4 (\FormatDate{94/07/12})]
Initial Drafts.
\item[Issue 1.5 (\FormatDate{94/09/20})]
Added descriptive text.
\item[Issue 1.6 (\FormatDate{94/11/14})]
Caters for use of $new\_conjecture$.
\item[Issue 1.7 (\FormatDate{94/12/09})]
Minor corrections before document inspection.
\item[Issue 1.8] Reworked according to desk check report 020.
\item[Issues 1.9 - 1.12 (\FormatDate{94/12/12})]
Changes to include the printing of package and subunit specification theories.
\item[Issue 1.13]
Final Issue for {\Product} 0.5.
\item[Issue 1.14]
Changed references for ISS/HAT/DAZ/WRK501.
\item[Issue 1.15] Updated the distribution list.
\item[Issue 1.16] Corrected test policy statement.
\item[Issue 1.17] Typo in a reference.
\item[Issue 1.18] Update for SML97.
\item[Issue 1.19] Removed local declarations for Poly/ML port.
\item[Issue 1.20] Allowed for datatypes for new Z fixity syntax.
\end{description}
\subsection{Changes Forecast}
None.

\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the compliance notation Z Output Functions.  The implementation is in \cite{ISS/HAT/DAZ/IMP511}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This document contains a signature providing functions to output the Z document based on the environment information constructed during the input of a Compliance Notation literate script. It also provides many supporting functions for formatting pieces of Z.

This detailed design document contains one signature, $CNZOutput$. None of the functions in it is intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} describes the top level functions which use this signature.

%\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Compliance}

This design must meet the requirements in \cite{ISS/HAT/DAZ/HLD503}. There is no further compliance argument appropriate. 

\section{Z OUTPUT SIGNATURE}

\subsection{Preamble}
=DOC
signature ÛCNZOutputÝ = sig
=DESCRIBE
This is the signature for the structure containing the output function for Z.
=ENDDOC
\subsection{Dictionary}
The Z Output function works in two stages. In the first stage we scan through the theory database, picking up the information we require and holding it in a sorted list or dictionary.  This is ordered by the order items were placed into the theory database, and it is in this order we print things out.

The exception in fixity information.  The theory database doesn't tell us when this was introduced, so we place it at the beginning to be sure.

Information from seven sources is collected for the Z document.  Axioms, conjectures, fixity and definations is collected with $get\_XXX$ on the current theory.  Information relating to subunit specification theories and package specification theories is stored as user data in the theory.

In the Z Generator, described in \cite{ISS/HAT/DAZ/DTD507}, package specification and subunit specification theories are generated at the appropriate places while processing a literate script.  Markers are placed in the user data of the script theory indicating what theories have been created and at what stage during the script using the keys $CN'createsubunit$ and $CN`createpackage$.  These specification theories can be related to a script theory by becoming parents.  When this occurs and entry in made in the user data with the key $CN'newparent$.

When we come to print out the Z Document we gather this information from the user data to store in our sorted list of things to print.

=DOC
val Ûdest_ud_stringÝ : USER_DATUM -> string * USER_DATUM list   
val Ûdest_ud_intÝ : USER_DATUM -> int * USER_DATUM list   
=DESCRIBE
These functions destroy objects of the type $USER\_DATUM$.
=ENDDOC

=DOC
type ÛZ_DOC_PARAGRAPHÝ
=DESCRIBE
This datatype is used to store information relating to the output of the Z document in a dictionary.
=ENDDOC

=DOC
val Ûadd_sorted_to_listÝ : (int * 'a) list -> int * 'a -> (int * 'a) list
=DESCRIBE
This function adds a new element to a list in ascending order.
=ENDDOC

=DOC
val Ûdelete_sortedÝ : (int * 'a) list -> int -> (int * 'a) list   
=DESCRIBE
This function removes all the elements in the list with indices before a given value.
=ENDDOC

=DOC
val Ûadd_sort_defnÝ : (int * Z_DOC_PARAGRAPH) list ->
string list * THM -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_axiomÝ : (int * Z_DOC_PARAGRAPH) list ->
string list * THM -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_vcÝ : (int * Z_DOC_PARAGRAPH) list ->
string list * (int * TERM) -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_fixÝ : (int * Z_DOC_PARAGRAPH) list ->
ZUserInterfaceSupport.CLASS * ZUserInterfaceSupport.TEMPLATE -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_create_specÝ : (int * Z_DOC_PARAGRAPH) list ->
int * string -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_create_subunitÝ : (int * Z_DOC_PARAGRAPH) list ->
int * (string * int) -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_new_parentÝ : (int * Z_DOC_PARAGRAPH) list ->
int * string -> (int * Z_DOC_PARAGRAPH) list
=DESCRIBE
These functions add a single element of each type to our dictionary.
=ENDDOC

=DOC
val Ûadd_sort_defnsÝ : (int * Z_DOC_PARAGRAPH) list ->
(string list * THM) list -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_axiomsÝ : (int * Z_DOC_PARAGRAPH) list ->
(string list * THM) list -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_vcsÝ : (int * Z_DOC_PARAGRAPH) list ->
(string list * (int * TERM)) list -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_fixsÝ : (int * Z_DOC_PARAGRAPH) list ->
(ZUserInterfaceSupport.CLASS * ZUserInterfaceSupport.TEMPLATE) list -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_create_specsÝ : (int * Z_DOC_PARAGRAPH) list ->
USER_DATUM list -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_create_subunitsÝ : (int * Z_DOC_PARAGRAPH) list ->
USER_DATUM list -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_sort_new_parentsÝ : (int * Z_DOC_PARAGRAPH) list ->
USER_DATUM list -> (int * Z_DOC_PARAGRAPH) list
=DESCRIBE
These functions add a list of elements to our dictionary.
=ENDDOC

=DOC
val Ûget_create_specsÝ : string -> USER_DATUM list   
val Ûget_create_subunitsÝ : string -> USER_DATUM list   
val Ûget_new_parentsÝ : string -> USER_DATUM list   
=DESCRIBE
These functions retrieve some of the information we require from the user data of a given theory.
=ENDDOC

=DOC
val Ûadd_defnsÝ : (int * Z_DOC_PARAGRAPH) list ->
string -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_axiomsÝ : (int * Z_DOC_PARAGRAPH) list ->
string -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_vcsÝ : (int * Z_DOC_PARAGRAPH) list ->
string -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_fixsÝ : (int * Z_DOC_PARAGRAPH) list ->
string -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_create_specsÝ : (int * Z_DOC_PARAGRAPH) list ->
string -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_create_subunitsÝ : (int * Z_DOC_PARAGRAPH) list ->
string -> (int * Z_DOC_PARAGRAPH) list
val Ûadd_new_parentsÝ : (int * Z_DOC_PARAGRAPH) list ->
string -> (int * Z_DOC_PARAGRAPH) list
=DESCRIBE
These functions take a theory name as an argument, and add the relevant parts from that theory to our dictionary.
=ENDDOC

\subsection{Formatting}
In the second stage, we take the elements of our dictionary in turn and pretty print them.

=DOC
val Ûz_thm_ruleÝ : THM -> THM
=DESCRIBE
z\_thm\_rule is used to strip the Z Paragraph header information from a theorem.
=ENDDOC

=DOC
val Ûz_output_tab_widthÝ : int
val Ûz_output_mk_tabÝ : int -> string
val Ûz_output_tabÝ : string
val Ûz_output_llÝ : int
=DESCRIBE
Information needed for the formatting functions.
=ENDDOC

=DOC
val Ûfmt_string_listÝ : string list -> string
val Ûconcat_string_listÝ : string list -> string
val Ûfmt_semi_colonÝ : string list -> string list
val Ûfmt_bodyÝ : string list -> string list
val Ûfmt_prefix_tabÝ : string list -> string list
val Ûdest_z_many_±Ý : TERM -> TERM list
=DESCRIBE
Generally useful functions.
=ENDDOC

=DOC
val Ûfmt_varÝ : Z_TERM * TERM -> string
val Ûfmt_var_listÝ : TERM list -> string
val Ûfmt_decÝ : TERM -> string list
val Ûfmt_dec_listÝ : TERM list -> string list
=DESCRIBE
Formatting functions for Declarations.
=FAILURE
511001	Theory contains a declaration which cannot be printed as Z: ?0
=ENDDOC

=DOC
val Ûfmt_pred_listÝ : TERM list -> string list
=DESCRIBE
Formatting functions for Predicates.
=ENDDOC

=DOC
val Ûfmt_schbox_nameÝ : TERM -> string list
val Ûfmt_schboxÝ : THM -> string list
=DESCRIBE
Formatting functions for Z Schema Boxes
=ENDDOC

=DOC
val Ûfmt_abbdefÝ : THM -> string list
=DESCRIBE
Formatting functions for Z Abbreviation Definations
=ENDDOC

=DOC
val Ûfmt_defnsÝ : THM -> string list
=DESCRIBE
Formatting functions for Definations.
=FAILURE
511002	Theory contains a definition which cannot be printed as Z: ?0
=ENDDOC

=DOC
val Ûfmt_axiomsÝ : THM -> string list
=DESCRIBE
Formatting functions for Axioms.
=ENDDOC

=DOC
val Ûfmt_vcsÝ : string * TERM -> string list
=DESCRIBE
Formatting functions for Verification Conditions.
=ENDDOC

=DOC
val Ûfmt_fixsÝ : ZUserInterfaceSupport.CLASS * ZUserInterfaceSupport.TEMPLATE -> string list
=DESCRIBE
Formatting functions for Fixity Paragraphs.
=ENDDOC

The following function is used if a package specification theory was generated by the literate script.  If so then we output a $new\_theory$ command, print the contents of the new theory and then return to the original theory.  Note that package specifications cannot be nested.

=DOC
val Ûfmt_create_specÝ : string -> string list   
=DESCRIBE
Formatting function for the creation of package specification theories.
=FAILURE
511003	Unable to create document from package specification theory : ?0
=ENDDOC

The following function is used if a package specification theory was generated by the literate script.  This is done by a $duplicate\_theory$.  To avoid repetitious output we output a $duplicate\_theory$ command, and only print new additions to the specification theory by calling $fmt\_z\_document$ with level set to after the objects introduced by the $duplicate\_theory$.

=DOC
val Ûfmt_create_subunitÝ : (string * int) -> string list 
=DESCRIBE
Formatting function for the creation of subunit specification theories.
=FAILURE
511004	Unable to create document from subunit specification theory : ?0
=ENDDOC

=DOC
val Ûfmt_new_parentÝ : string -> string list
=DESCRIBE
Formatting function for the creation of a new parent for the current theory.
=ENDDOC
   
=DOC
val Ûfmt_paragraphÝ : Z_DOC_PARAGRAPH -> string list
val Ûfmt_paragraphsÝ : (int * Z_DOC_PARAGRAPH) list -> string list
=DESCRIBE
Formatting functions for Z Paragraphs.
=ENDDOC

The string argument of the following function gives the theory name.  This is followed by an integer.  Only objects in our dictionary with indecies after this integer are printed.  This is used by $fmt\_subunit\_spec$ to avoid printing repetitious output.  The boolean flag tells us whether we are printing the script theory or a theory generated by the script theory.

=DOC
val Ûfmt_z_documentÝ : string -> int -> bool -> string list
=DESCRIBE
This function creates the whole Z Document from a given theory, and returns it as a string suitable for diag\_line or output.
=FAILURE
511005	Unable to create document theory : ?0
=ENDDOC

=TEX

\subsection{Output Functions}
=DOC
val Ûprint_z_documentÝ : string -> unit
val Ûoutput_z_documentÝ : {out_file : string, script : string} -> unit
=DESCRIBE
These are the top-level printing functions and are called by the Compliance Tool user interface module in ISS/HAT/DAZ/DTD516.
=ENDDOC

\subsection{Epilogue}
=SML
end (* signature CNZOutput *);
=TEX

=TEX
\section{TEST POLICY}
The functions in this document do not lend themselves to the module test framework (since their correct operation depends on the contents of output files).
The integration tests described in \cite{ISS/HAT/DAZ/HLD503} will exercise these functions.
=IGN

*** for possible future inclusion in the test documentation ***

The test module is \cite{ISS/HAT/DAZ/WRK501}.  To run the test:

\begin{verbatim}
use_file "wrk501";
output_z_document {out_file="wrk501.thy.old", script="wrk501"};
open_theory "daz_toolkit_extensions";
delete_theory "wrk501";
new_theory "delete_me";
open_theory "delete_me";
use_file "wrk501.thy.old";
output_z_document {out_file="wrk501.thy.new", script="delete_me"};
\end{verbatim}

and then at a unix prompt:

\begin{verbatim}
diff wrk501.thy.old wrk501.thy.new > wrk501.diff
\end{verbatim}

Load the file wrk501.diff into an editor, like Xpp and check for the differences.
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



