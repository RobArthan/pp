% %Z% $Date$ $Revision$ $RCSfile$
=TEX

% TQtemplate.tex
% use_file "daz_init";
% use_file "int502";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{IUCT: Tests for Enhancements}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT513}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & BRA01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{K.Blackburn & BRA01}
\TPPabstract{%
This document gives scripts to test the new features implemented under the industrial upgrades contract (CSM/677).
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1] First Draft
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains test data for the Industrial Upgrades to the Compliance Tool beeing carried out for DERA under contract CSM/677.
The specification changes for the upgrades are given in \cite{ISS/HAT/DAZ/HLD504}.

\subsection{Introduction}
This document contains specific tests for each of the 10 changes to the Compliance Tool identified as WP1 to WP10 in \cite{ISS/HAT/DAZ/PLN017}.
Note that in the changes to the specifications given in \cite{ISS/HAT/DAZ/HLD504}, WP2 and WP10 are identified, giving only 9 packages of  specification and implementation;
however, it is felt appropriate to provide independent tests for WP10 reflecting the spirit of the requirement.

Sections \ref{WP1} to \ref{WP10} define the tests for changes WP1 to WP10 respectively.
In some cases (e.g., the bug-fix work package, WP8), the module tests give adequate coverage and so a reference to the module test document suffices.

\newpage
\subsection{Preliminaries}

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = get_descendants "z_library"
					less "cn" less "z_library"
					diff get_cache_theories();
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
Sometimes the success of a test just depends on whether or not
a computation fails:
=SML
fun check_fail (f: unit -> 'a) : bool = (
		(f (); false)
	handle Fail msg => (
		diag_line (get_message_text msg);
		true
	)
);
val check_ok : (unit -> 'a) -> bool = not o check_fail;
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{WP 1. Z schemas in Ada specifications}\label{WP1}
\subsubsection{Test Objectives}
The test is required to exercise the new function
=INLINEFT
new_script1
=TEX
.
This function allows a library of Z declarations (given as a list
of {\Product} theory names) to be accessed by a literate scripts.
The test script is in 5 parts as as follows:

\begin{tabular}{|l|l|}\hline
{\bf Part} & {\bf Description}\\\hline\hline
1.1 & We check a simple case of normal operation \\\hline

1.2 & Check what happens if the list of theories is empty \\\hline

1.3 & Check that all members of the list are brought into scope \\\hline

1.4 & Check what happens with duplicates in the list \\\hline

1.5 & Check what happens with non-existent theories in the list \\\hline
\end{tabular}

\subsubsection{Test Script}
\paragraph{Part 1.1}\

First we introduce a new theory as a child of the theory ``cn'' to be usedxc as the library theory in the rest of the test.
=SML
clean_up();
open_theory"z_library";
new_theory "int513.1.1.A";
=TEX
ÿ Swap üüüüüüüüüüü
Ü X‰0, X, Y‰0, Y : ú
÷üüüüüü
Ü X = Y‰0 ± Y = X‰0
ˆüüüüüüüüüüüüüü
Now we define a package containing a procedure defined in terms of the schema in the library theory.
=SML
new_script1{
	name="int513.1.1.B",
	state=initial_cn_state,
	library_theories=["int513.1.1.A"]};
=TEX
¹CN
 package INT513_1_1_B
 is
    procedure SWAP (X, Y : in out INTEGER)
     „ X, Y [ Swap ];
 end INT513_1_1_B;
°
Now we should be able to use the package in another compilation unit:
=SML
new_script1{
	name="int513.1.1.C",
	state=get_cn_state(),
	library_theories=["int513.1.1.A"]};
=TEX
¹CN
 with INT513_1_1_B;
 procedure INT513_1_1_C
 is
    A, B : INTEGER;
 begin
    „ A, B [ Swap[A‰0/X‰0, A/X, B‰0/Y‰0, B/Y] ] (1)
 end INT513_1_1_C;
°
¹CN
 (1) Ã INT513_1_1_B.SWAP(A, B);
°
The resulting VCs should be provable.
=SML
fun int513_1_1_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), cn_vc_simp_tac[])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.1", check_ok, int513_1_1_prove_vcs, true)
];
=TEX
\paragraph{Part 1.2}\

An empty list of library theories should just work.
=SML
fun int513_1_2() = (
	new_script1{
		name="int513.2.A",
		state=initial_cn_state,
		library_theories=[]}
);
=TEX
=SML
clean_up();
store_mt_results_show
mt_run [
    ("int513.1.2", check_ok, int513_1_2, true)
];
=TEX
\paragraph{Part 1.3}\

This just double checks that it does look at all of the list by
creating 10 library theories and checking that they all become parents of the
script theory.
=SML
fun int513_1_3_make_theory (i : int) : string = (
	let	val x = "int513_1_3_" ^ string_of_int i;
	in	open_theory "z_library";
		new_theory x;
		x
	end
);
clean_up();
val int513_1_3_thys = map int513_1_3_make_theory (interval 1 10);
=SML
new_script1{
	name="int513.1.3.A",
	state=initial_cn_state,
	library_theories=int513_1_3_thys};
fun int513_1_3_chk () = (
	int513_1_3_thys diff get_parents"-" = []
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.3", int513_1_3_chk, (), true)
];
=TEX
\paragraph{Part 1.4}\

Duplicates are accepted.
=SML
clean_up();
open_theory"z_library";
new_theory"int513.1.4.A";
fun int513_1_4() = (
	new_script1{
		name="int513.1.4.B",
		state=initial_cn_state,
		library_theories=["int513.1.4.A", "int513.1.4.A"]}
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.4", check_ok, int513_1_4, true)
];
=TEX
=TEX
\paragraph{Part 1.5}\

Non-existent theories are not accepted.
=SML
clean_up();
open_theory"z_library";
fun int513_1_5() = (
	new_script1{
		name="int513.1.5.A",
		state=initial_cn_state,
		library_theories=["No Such Theory!"]}
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.5", check_fail, int513_1_5, true)
];
=TEX

\subsection{WP 2. Earlier type checking of package specifications}\label{WP2}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 3. Variable scope and specification statements}\label{WP3}
TBA (Project stage 3)
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 4. Ada functions with global dependencies}\label{WP4}
TBA (Project stage 3)
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 5. Scope of auxiliaries}\label{WP5}
TBA (Project stage 3)
\subsubsection{Test Objectives}
We exercise the line-breaking facility on an example containing
a number of convoluted and long Ada constructs.
\subsubsection{Test Script}
=SML
clean_up();
new_script{name="int513.5", state=initial_cn_state};
¹CN
procedure MAIN
is
  type LONG_RECORD is record 
    FIELD_WITH_LONG_NAME01 : INTEGER;
    FIELD_WITH_LONG_NAME02 : INTEGER;
    FIELD_WITH_LONG_NAME03 : INTEGER;
    FIELD_WITH_LONG_NAME04 : INTEGER;
    FIELD_WITH_LONG_NAME05 : INTEGER;
    FIELD_WITH_LONG_NAME06 : INTEGER;
    FIELD_WITH_LONG_NAME07 : INTEGER;
    FIELD_WITH_LONG_NAME08 : INTEGER;
    FIELD_WITH_LONG_NAME09 : INTEGER;
    FIELD_WITH_LONG_NAME10 : INTEGER;
    FIELD_WITH_LONG_NAME11 : INTEGER;
    FIELD_WITH_LONG_NAME12 : INTEGER;
    FIELD_WITH_LONG_NAME13 : INTEGER;
    FIELD_WITH_LONG_NAME14 : INTEGER;
    FIELD_WITH_LONG_NAME15 : INTEGER;
    FIELD_WITH_LONG_NAME16 : INTEGER;
    FIELD_WITH_LONG_NAME17 : INTEGER;
    FIELD_WITH_LONG_NAME18 : INTEGER;
    FIELD_WITH_LONG_NAME19 : INTEGER;
    FIELD_WITH_LONG_NAME20 : INTEGER;
  end record;
  VARIABLE_WITH_LONG_NAME : LONG_RECORD
-- := LONG_RECORD'(
--    FIELD_WITH_LONG_NAME01 => 881 ,
--    FIELD_WITH_LONG_NAME02 => 882 ,
--    FIELD_WITH_LONG_NAME03 => 883 ,
--    FIELD_WITH_LONG_NAME04 => 884 ,
--    FIELD_WITH_LONG_NAME05 => 885 ,
--    FIELD_WITH_LONG_NAME06 => 886 ,
--    FIELD_WITH_LONG_NAME07 => 887 ,
--    FIELD_WITH_LONG_NAME08 => 888 ,
--    FIELD_WITH_LONG_NAME09 => 889 ,
--    FIELD_WITH_LONG_NAME10 => 890 ,
--    FIELD_WITH_LONG_NAME11 => 891 ,
--    FIELD_WITH_LONG_NAME12 => 892 ,
--    FIELD_WITH_LONG_NAME13 => 893 ,
--    FIELD_WITH_LONG_NAME14 => 894 ,
--    FIELD_WITH_LONG_NAME15 => 895 ,
--    FIELD_WITH_LONG_NAME16 => 896 ,
--    FIELD_WITH_LONG_NAME17 => 897 ,
--    FIELD_WITH_LONG_NAME18 => 898 ,
--    FIELD_WITH_LONG_NAME19 => 899 ,
--    FIELD_WITH_LONG_NAME20 => 900)
      ;
begin
  VARIABLE_WITH_LONG_NAME := 
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME01 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME02 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME03 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME04 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME05 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME06 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME07 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME08 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME09 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME10 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME11 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME12 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME13 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME14 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME15 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME16 / (
    VARIABLE_WITH_LONG_NAME.VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME17 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME18 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME19 / (
    VARIABLE_WITH_LONG_NAME.FIELD_WITH_LONG_NAME20
    ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) );
end MAIN;
°
=SML
set_int_control("cn_automatic_line_splitting", 1);
output_spark_program{out_file="int513.5.1.ada"};
set_int_control("cn_automatic_line_splitting", 72);
output_spark_program{out_file="int513.5.2.ada"};
set_int_control("cn_automatic_line_splitting", 10000000);
output_spark_program{out_file="int513.5.3.ada"};
=DUMP int513.5.sh
for i in int513.5.*.ada
do
	b=`basename $i .ada`
	sed <$i >$b.sml -e '1i\
\%SFT%CN' -e '$a\
\%EFT%'
done
=TEX
=SML
val _ = (
	let	val  (s1, s2) = ExtendedIO.execute"sh int513.5.sh 2>&1";
		val buf :string ref = ref "";
	in 	while (buf := ExtendedIO.input_line s1; !buf <> "")
		do  BasicIO.output(std_out, !buf);
		close_in s1;
		close_out s2
	end
);
fun int513_reload (name : string) = (
	new_script{name = name, state=initial_cn_state};
	use_file (name ^ ".sml");
	output_spark_program{out_file=name^".cmp"}
);
clean_up();
int513_reload "int513.5.1";
int513_reload "int513.5.2";
int513_reload "int513.5.3";
fun int513_cmp (file1 : string, file2 : string) : bool = (
	let	val ch1 = BasicIO.open_in file1;
		val ch2 = BasicIO.open_in file2;
		val contents1 = BasicIO.input(ch1, 1000000);
		val contents2 = BasicIO.input(ch2, 1000000);
	in	close_in ch1; close_in ch2; contents1 = contents2
	end
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.5.3.1", int513_cmp, ("int513.5.3.ada", "int513.5.1.cmp"), true),
    ("int513.5.3.2", int513_cmp, ("int513.5.3.ada", "int513.5.2.cmp"), true),
    ("int513.5.3.3", int513_cmp, ("int513.5.3.ada", "int513.5.3.cmp"), true)
];
 
=TEX
\subsection{WP 6. Long lines in generated Ada}\label{WP6}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 7. SPARK language omissions}\label{WP7}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 8. DAZ bugs}\label{WP8}
Tests for the bugs fixed under WP8 are given in \cite{OSS/HAT/DAZ/INT502}.

\subsection{WP 9. Knuth slots}\label{WP9}
TBA (Project stage 3)
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 10. Type Generation}\label{WP10}
\subsubsection{Test Objectives}
The requirement here was to allow the Z translation
of the types of a package to be made available for use
in Z paragraphs before a with clause for the package
has been processed. These Z paragraphs should also
be available in prefixed form for use in the scope
of a with clause for the package.
The enhancement has required quite a lot of rework (and bug-fixing)
in the handling of package spec theories.

The test script is in 3 parts as as follows:

\begin{tabular}{|l|l|}\hline
{\bf Part} & {\bf Description}\\\hline\hline
10.1 & Test usability of Z in the package spec theory in client of packge\\\hline

10.3 & Check prefixing of various constructs in package (program variables) \\\hline

10.3 & Check prefixing of various constructs in package (auxiliary variables) \\\hline
\end{tabular}

\subsubsection{Test Script}
\paragraph{Part 10.1}\

=SML
clean_up();
new_script{name="int513.10.1.A", state=initial_cn_state};
¹CN
package INT513_10_1_A is
  type CRUMB is range 0 .. 3;
end INT513_10_1_A;
°
¹ZAX
Ü oo, oi, io, ii : CRUMB
÷üüüüüü
Ü	oo = CRUMBvFIRST
Ü±	oi = CRUMBvSUCC oo
Ü±	io = CRUMBvPRED ii
Ü±	ii = CRUMBvLAST
°
=SML
new_script{name="int513.10.1.B", state=get_cn_state()};
¹CN
with INT513_10_1_A;
function INT513_10_1_B (X : INT513_10_1_A.CRUMB) return INT513_10_1_A.CRUMB
„ [INT513_10_1_B X = ii - X]
is
   § variables ¢ (1)
begin
 return 3 - X;
end INT513_10_1_B;
°
=TEX
We should be able to proved the resulting VC (because we
should have a copy of the definition of $ii$ available in
the package spec theory):
=SML
delete_pc"int513.10.1" handle Fail _ => ();
val _ = all_cn_make_script_support"int513.10.1";
fun int513_10_1_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), 
	PC_T1 "int513.10.1"cn_vc_simp_tac[])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.10.1", check_ok, int513_10_1_prove_vcs, true)
];
=TEX
\paragraph{Part 10.2}\

=SML
clean_up();
new_script{name="int513.10.2.A", state=initial_cn_state};
¹ZAX
Ü sum : seq ú ­ ú;
Ü average : seq‰1 ú ­ ú
÷üüüüüü
Ü sum §¢ = 0 ;
Ü µx:ú; s:seq ú· sum (§x¢ës) = x + sum s ;
Ü µs:seq‰1 ú· average s = (sum s + 1) div #s
°

¹CN
package INT513_10_2_A
is
  type BIT is range 0 .. 1;
  type BYTE is range 0 .. 255;
  OFF : constant BYTE := 0;
  ON  : constant BYTE := 1;
  R, G, B : BYTE;
  function AVERAGE (X, Y, Z : in BYTE) return BYTE
  „ [ AVERAGE (X, Y, Z) = average §X, Y, Z¢ ];
  procedure SET_AVERAGE
  „ R, G, B [ R = G = B = average §R‰0, G‰0, B‰0¢ ];
end INT513_10_2_A;
°
=SML
val int513_10_2_A_state = get_cn_state();
new_script{name="int513.10.2.B", state=int513_10_2_A_state};
¹CN
with INT513_10_2_A;
procedure INT513_10_2_B(RR, GG, BB : INT513_10_2_A.BYTE)
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
is
begin
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
end INT513_10_2_B;
°
We implement this two ways: first using the procedure and then using
the function.
¹CN
 Ã
 INT513_10_2_A.R := RR;
 INT513_10_2_A.G := GG;
 INT513_10_2_A.B := BB;
 „ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
 [ INT513_10_2_AoR = RR ± INT513_10_2_AoG = GG ± INT513_10_2_AoB = BB,
   INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
   average§RR, GG, BB¢]
°
¹CN
 Ã INT513_10_2_A.SET_AVERAGE;
°
=SML
fun int513_10_2_B_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), 
	cn_vc_simp_tac[]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.10.2.1", check_ok, int513_10_2_B_prove_vcs, true)
];
=TEX
We now do the version with the function:
=SML
new_script{name="int513.10.2.C", state=int513_10_2_A_state};
¹CN
with INT513_10_2_A;
procedure INT513_10_2_C(RR, GG, BB : INT513_10_2_A.BYTE)
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
is
begin
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
end INT513_10_2_C;
°
¹CN
 Ã
 INT513_10_2_A.R := INT513_10_2_A.AVERAGE(RR, GG, BB);
 INT513_10_2_A.G := INT513_10_2_A.R;
 INT513_10_2_A.B := INT513_10_2_A.R;
°
=SML
fun int513_10_2_C_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), 
	cn_vc_simp_tac[]
	THEN REPEAT strip_tac THEN
	ALL_ASM_FC_T rewrite_tac[z_get_specñINT513_10_2_AoAVERAGE®])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.10.2.2", check_ok, int513_10_2_C_prove_vcs, true)
];

=TEX
\paragraph{Part 10.3}\
=SML
clean_up();
new_script{name="int513.10.3.A", state=initial_cn_state};
¹CN
package INT513_10_3_A
is
  type DATA is range 0 .. 9;
  auxiliary DataSet : ð DATA;
  procedure ADD(X : DATA)
  „ DataSet [ X Ž DataSet, DataSet = DataSet‰0 À {X} ] ;
  procedure REMOVE(X : DATA)
  „ DataSet [ X  DataSet, DataSet = DataSet‰0 \ {X} ] ;
  procedure IS_THERE(X : DATA; B : out BOOLEAN)
  „ [ X  DataSet ± B = TRUE ² X Ž DataSet ± B = FALSE] ;
end INT513_10_3_A;
°
=SML
val int513_10_3_A_state = get_cn_state();
new_script{name="int513.10.3.B", state=int513_10_3_A_state};
¹CN
with INT513_10_3_A;
procedure INT513_10_3_B
„ INT513_10_3_AoDataSet
[ INT513_10_3_AoDataSet = š ]
is
 § local variables ¢ (1)
begin
  for I in INT513_10_3_A.DATA
  loop
    „ INT513_10_3_AoDataSet[
       µj : INT513_10_3_AoDATAvFIRST .. (I - 1)· j Ž INT513_10_3_AoDataSet,
       µj : INT513_10_3_AoDATAvFIRST .. I· j Ž INT513_10_3_AoDataSet ] (2)
  end loop;
end INT513_10_3_B;
°
¹CN
 (1) é B : BOOLEAN;
°
¹CN
 (2) Ã
    con S: ð INT513_10_3_AoDATA· „ INT513_10_3_AoDataSet [
       S = INT513_10_3_AoDataSet, INT513_10_3_AoDataSet = S \ {I} ] (3)
°

¹CN
 (3) Ã
    INT513_10_3_A.IS_THERE(I, B);
    if B
    then
    „ INT513_10_3_AoDataSet[
       S = INT513_10_3_AoDataSet ± I  INT513_10_3_AoDataSet,
       INT513_10_3_AoDataSet = S \ {I} ] (4)
    end if;
°
¹CN
 (4) Ã
    INT513_10_3_A.REMOVE(I);
°
=TEX
=SML
delete_pc"int513.10.3" handle Fail _ => ();
val _ = all_cn_make_script_support"int513.10.3";
set_pc"cn1";
=TEX
=SML
set_goal([], get_conjecture"-""vcINT513_10_3_B_1");
a(PC_T1"int513.10.3" cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val vcINT513_10_3_B_1 = save_pop_thm "vcINT513_10_3_B_1";
=TEX
=SML
set_goal([], get_conjecture"-""vcINT513_10_3_B_2");
a(PC_T1"int513.10.3" cn_vc_simp_tac[]);
val vcINT513_10_3_B_2 = save_pop_thm "vcINT513_10_3_B_2";
=TEX
=SML
set_goal([], get_conjecture"-""vcINT513_10_3_B_3");
a(PC_T1"int513.10.3" cn_vc_simp_tac[]);
val vcINT513_10_3_B_3 = save_pop_thm "vcINT513_10_3_B_3";
=TEX
=SML
set_goal([], get_conjecture"-""vcINT513_10_3_B_4");
a(PC_T1"int513.10.3" cn_vc_simp_tac[]);
a(PC_T1"z_library_ext" REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val vcINT513_10_3_B_4 = save_pop_thm "vcINT513_10_3_B_4";
=TEX
=SML
set_goal([], get_conjecture"-""vc2_1");
a(cn_vc_simp_tac[]);
val vc2_1 = save_pop_thm "vc2_1";
=TEX
=SML
set_goal([], get_conjecture"-""vc2_2");
a(PC_T1"int513.10.3" cn_vc_simp_tac[] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(cases_tac ñj ¼ I + ~ 1®);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN POP_ASM_T ante_tac
	THEN PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tacñj = I® THEN1 PC_T1 "z_lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1 THEN PC_T1 "z_library_ext" prove_tac[]);
val vc2_2 = save_pop_thm "vc2_2";
=TEX
=SML
set_goal([], get_conjecture"-""vc3_1");
a(cn_vc_simp_tac[]);
val vc3_1 = save_pop_thm "vc3_1";
=TEX
=SML
set_goal([], get_conjecture"-""vc3_2");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
val vc3_2 = save_pop_thm "vc3_2";
=TEX
=SML
set_goal([], get_conjecture"-""vc3_3");
a(PC_T1"int513.10.3" cn_vc_simp_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN PC_T1 "z_sets_ext" REPEAT strip_tac);
a(contr_tac THEN all_var_elim_asm_tac1);
val vc3_3 = save_pop_thm "vc3_3";
=TEX
=SML
set_goal([], get_conjecture"-""vc3_4");
a(cn_vc_simp_tac[]);
val vc3_4 = save_pop_thm "vc3_4";
=TEX
=SML
set_goal([], get_conjecture"-""vc4_1");
a(REPEAT strip_tac);
val vc4_1 = save_pop_thm "vc4_1";
=TEX
=SML
set_goal([], get_conjecture"-""vc4_2");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN strip_tac);
val vc4_2 = save_pop_thm "vc4_2";
=TEX
=SML
fun int513_10_3_check_thms () = (
	let	val names = flat (map fst (get_conjectures"-"));
		fun do1 (name : string) = (
			let	val cnj = get_conjecture "-" name;
				val (h, t) = dest_thm (get_thm "-" name);
			in	is_nil h andalso cnj ~=$ t
			end
		);
	in	all (map do1 names) Combinators.I
	end
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.10.3.1", int513_10_3_check_thms, (), true)
];
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\pagebreak
\end{document}
=IGN
