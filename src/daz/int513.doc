% %Z% $Date$ $Revision$ $RCSfile$
=TEX

% TQtemplate.tex
% use_file "daz_init";
% use_file "int502";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{IUCT: Tests for Enhancements}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT513}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & BRA01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{K.Blackburn & BRA01}
\TPPabstract{%
This document gives scripts to test the new features implemented under the industrial upgrades contract (CSM/677).
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1] First Draft
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains test data for the Industrial Upgrades to the Compliance Tool beeing carried out for DERA under contract CSM/677.
The specification changes for the upgrades are given in \cite{ISS/HAT/DAZ/HLD504}.

\subsection{Introduction}
This document contains specific tests for each of the 10 changes to the Compliance Tool identified as WP1 to WP10 in \cite{ISS/HAT/DAZ/PLN017}.
Note that in the changes to the specifications given in \cite{ISS/HAT/DAZ/HLD504}, WP2 and WP10 are identified, giving only 9 packages of  specification and implementation;
however, it is felt appropriate to provide independent tests for WP10 reflecting the spirit of the requirement.

Sections \ref{WP1} to \ref{WP10} define the tests for changes WP1 to WP10 respectively.
In some cases (e.g., the bug-fix work package, WP8), the module tests give adequate coverage and so a reference to the module test document suffices.

\newpage
\subsection{Preliminaries}

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = get_descendants "z_library"
					less "cn" less "z_library"
					diff get_cache_theories();
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
Sometimes the success of a test just depends on whether or not
a computation fails:
=SML
fun check_fail (f: unit -> 'a) : bool = (
		(f (); false)
	handle Fail msg => (
		diag_line (get_message_text msg);
		true
	)
);
val check_ok : (unit -> 'a) -> bool = not o check_fail;
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{WP 1. Z schemas in Ada specifications}\label{WP1}
\subsubsection{Test Objectives}
The test is required to exercise the new function
=INLINEFT
new_script1
=TEX
.
This function allows a library of Z declarations (given as a list
of {\Product} theory names) to be accessed by a literate scripts.
The test script is in 5 parts as as follows:

\begin{tabular}{|l|l|}\hline
{\bf Part} & {\bf Description}\\\hline\hline
1.1 & We check a simple case of normal operation \\\hline

1.2 & Check what happens if the list of theories is empty \\\hline

1.3 & Check that all members of the list are brought into scope \\\hline

1.4 & Check what happens with duplicates in the list \\\hline

1.5 & Check what happens with non-existent theories in the list \\\hline
\end{tabular}

\subsubsection{Test Script}
\paragraph{Part 1.1}\

First we introduce a new theory as a child of the theory ``cn'' to be usedxc as the library theory in the rest of the test.
=SML
clean_up();
open_theory"z_library";
new_theory "int513.1.1.A";
=TEX
ÿ Swap üüüüüüüüüüü
Ü X‰0, X, Y‰0, Y : ú
÷üüüüüü
Ü X = Y‰0 ± Y = X‰0
ˆüüüüüüüüüüüüüü
Now we define a package containing a procedure defined in terms of the schema in the library theory.
=SML
new_script1{
	name="int513.1.1.B",
	state=initial_cn_state,
	library_theories=["int513.1.1.A"]};
=TEX
¹CN
 package INT513_1_1_B
 is
    procedure SWAP (X, Y : in out INTEGER)
     „ X, Y [ Swap ];
 end INT513_1_1_B;
°
Now we should be able to use the package in another compilation unit:
=SML
new_script1{
	name="int513.1.1.C",
	state=get_cn_state(),
	library_theories=["int513.1.1.A"]};
=TEX
¹CN
 with INT513_1_1_B;
 procedure INT513_1_1_C
 is
    A, B : INTEGER;
 begin
    „ A, B [ Swap[A‰0/X‰0, A/X, B‰0/Y‰0, B/Y] ] (1)
 end INT513_1_1_C;
°
¹CN
 (1) Ã INT513_1_1_B.SWAP(A, B);
°
The resulting VCs should be provable.
=SML
fun int513_1_1_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), cn_vc_simp_tac[])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.1", check_ok, int513_1_1_prove_vcs, true)
];
=TEX
\paragraph{Part 1.2}\

An empty list of library theories should just work.
=SML
fun int513_1_2() = (
	new_script1{
		name="int513.2.A",
		state=initial_cn_state,
		library_theories=[]}
);
=TEX
=SML
clean_up();
store_mt_results_show
mt_run [
    ("int513.1.2", check_ok, int513_1_2, true)
];
=TEX
\paragraph{Part 1.3}\

This just double checks that it does look at all of the list by
creating 10 library theories and checking that they all become parents of the
script theory.
=SML
fun int513_1_3_make_theory (i : int) : string = (
	let	val x = "int513_1_3_" ^ string_of_int i;
	in	open_theory "z_library";
		new_theory x;
		x
	end
);
clean_up();
val int513_1_3_thys = map int513_1_3_make_theory (interval 1 10);
=SML
new_script1{
	name="int513.1.3.A",
	state=initial_cn_state,
	library_theories=int513_1_3_thys};
fun int513_1_3_chk () = (
	int513_1_3_thys diff get_parents"-" = []
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.3", int513_1_3_chk, (), true)
];
=TEX
\paragraph{Part 1.4}\

Duplicates are accepted.
=SML
clean_up();
open_theory"z_library";
new_theory"int513.1.4.A";
fun int513_1_4() = (
	new_script1{
		name="int513.1.4.B",
		state=initial_cn_state,
		library_theories=["int513.1.4.A", "int513.1.4.A"]}
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.4", check_ok, int513_1_4, true)
];
=TEX
=TEX
\paragraph{Part 1.5}\

Non-existent theories are not accepted.
=SML
clean_up();
open_theory"z_library";
fun int513_1_5() = (
	new_script1{
		name="int513.1.5.A",
		state=initial_cn_state,
		library_theories=["No Such Theory!"]}
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.1.5", check_fail, int513_1_5, true)
];
=TEX

\subsection{WP 2. Earlier type checking of package specifications}\label{WP2}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 3. Variable scope and specification statements}\label{WP3}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 4. Ada functions with global dependencies}\label{WP4}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 5. Scope of auxiliaries}\label{WP5}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 6. Long lines in generated Ada}\label{WP6}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 7. SPARK language omissions}\label{WP7}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 8. DAZ bugs}\label{WP8}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 9. Knuth slots}\label{WP9}
\subsubsection{Test Objectives}
\subsubsection{Test Script}

\subsection{WP 10. Type Generation}\label{WP10}
\subsubsection{Test Objectives}
The requirement here was to allow the Z translation
of the types of a package to be made available for use
in Z paragraphs before a with clause for the package
has been processed. These Z paragraphs should also
be available in prefixed form for use in the scope
of a with clause for the package.
The enhancement has required quite a lot of rework (and bug-fixing)
in the handling of package spec theories.

The test script is in 3 parts as as follows:

\begin{tabular}{|l|l|}\hline
{\bf Part} & {\bf Description}\\\hline\hline
10.1 & Test usability of Z in the package spec theory in client of packge\\\hline

10.3 & Check prefixing of various constructs in package (program variables) \\\hline

1.3 & Check prefixing of various constructs in package (auxiliary variables) \\\hline
\end{tabular}

\subsubsection{Test Script}
\paragraph{Part 10.1}\

=SML
clean_up();
new_script{name="int513.10.1.A", state=initial_cn_state};
¹CN
package INT513_10_1_A is
  type CRUMB is range 0 .. 3;
end INT513_10_1_A;
°
¹ZAX
Ü oo, oi, io, ii : CRUMB
÷üüüüüü
Ü	oo = CRUMBvFIRST
Ü±	oi = CRUMBvSUCC oo
Ü±	io = CRUMBvPRED ii
Ü±	ii = CRUMBvLAST
°
=SML
new_script{name="int513.10.1.B", state=get_cn_state()};
¹CN
with INT513_10_1_A;
function INT513_10_1_B (X : INT513_10_1_A.CRUMB) return INT513_10_1_A.CRUMB
„ [INT513_10_1_B X = ii - X]
is
   § variables ¢ (1)
begin
 return 3 - X;
end INT513_10_1_B;
°
=TEX
We should be able to proved the resulting VC (because we
should have a copy of the definition of $ii$ available in
the package spec theory):
=SML
delete_pc"int513.10.1" handle Fail _ => ();
val _ = all_cn_make_script_support"int513.10.1";
fun int513_10_1_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), 
	PC_T1 "int513.10.1"cn_vc_simp_tac[])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.10.1", check_ok, int513_10_1_prove_vcs, true)
];
=TEX
\paragraph{Part 10.2}\

=SML
clean_up();
new_script{name="int513.10.2.A", state=initial_cn_state};
¹ZAX
Ü sum : seq ú ­ ú;
Ü average : seq‰1 ú ­ ú
÷üüüüüü
Ü sum §¢ = 0 ;
Ü µx:ú; s:seq ú· sum (§x¢ës) = x + sum s ;
Ü µs:seq‰1 ú· average s = (sum s + 1) div #s
°

¹CN
package INT513_10_2_A
is
  type BIT is range 0 .. 1;
  type BYTE is range 0 .. 255;
  OFF : constant BYTE := 0;
  ON  : constant BYTE := 1;
  R, G, B : BYTE;
  function AVERAGE (X, Y, Z : in BYTE) return BYTE
  „ [ AVERAGE (X, Y, Z) = average §X, Y, Z¢ ];
  procedure SET_AVERAGE
  „ R, G, B [ R = G = B = average §R‰0, G‰0, B‰0¢ ];
end INT513_10_2_A;
°
=SML
val int513_10_2_A_state = get_cn_state();
new_script{name="int513.10.2.B", state=int513_10_2_A_state};
¹CN
with INT513_10_2_A;
procedure INT513_10_2_B(RR, GG, BB : INT513_10_2_A.BYTE)
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
is
begin
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
end INT513_10_2_B;
°
We implement this two ways: first using the procedure and then using
the function.
¹CN
 Ã
 INT513_10_2_A.R := RR;
 INT513_10_2_A.G := GG;
 INT513_10_2_A.B := BB;
 „ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
 [ INT513_10_2_AoR = RR ± INT513_10_2_AoG = GG ± INT513_10_2_AoB = BB,
   INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
   average§RR, GG, BB¢]
°
¹CN
 Ã INT513_10_2_A.SET_AVERAGE;
°
=SML
fun int513_10_2_B_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), 
	cn_vc_simp_tac[]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.10.2.1", check_ok, int513_10_2_B_prove_vcs, true)
];
=TEX
We now do the version with the function:
=SML
new_script{name="int513.10.2.C", state=int513_10_2_A_state};
¹CN
with INT513_10_2_A;
procedure INT513_10_2_C(RR, GG, BB : INT513_10_2_A.BYTE)
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
is
begin
„ INT513_10_2_AoR, INT513_10_2_AoB, INT513_10_2_AoG
[ INT513_10_2_AoR = INT513_10_2_AoB = INT513_10_2_AoB =
  average§RR, GG, BB¢]
end INT513_10_2_C;
°
¹CN
 Ã
 INT513_10_2_A.R := INT513_10_2_A.AVERAGE(RR, GG, BB);
 INT513_10_2_A.G := INT513_10_2_A.R;
 INT513_10_2_A.B := INT513_10_2_A.R;
°
=SML
fun int513_10_2_C_prove_vcs () = (
	(map (fn (_, (_, t)) => tac_proof(([], t), 
	cn_vc_simp_tac[]
	THEN REPEAT strip_tac THEN
	ALL_ASM_FC_T rewrite_tac[z_get_specñINT513_10_2_AoAVERAGE®])))
	(get_conjectures "-")
);
=TEX
=SML
store_mt_results_show
mt_run [
    ("int513.10.2.2", check_ok, int513_10_2_C_prove_vcs, true)
];

=TEX
\paragraph{Part 10.2}\

TBA
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\pagebreak
\end{document}
=IGN
