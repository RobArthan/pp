% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
% sed -n "/^=DOC/,/^=ENDDOC/p" <dtd516.doc | sieve tex > usr501E.tex
\documentstyle[11pt,hol1,fleqn,USR,epsf]{book}
% temporary measure while waiting for LaTeXe to come along
\def\LaTeXe{\LaTeX$2_{\varepsilon}$}
\def\Hide#1{}
% Set the following macros as necessary as release
% numbers change.
\def\texrelease{\TeX\ version 3.1415}
\def\latexrelease{\LaTeXe}
\def\arch{sun4}
\def\solarisrelease{Solaris 2.3}
\def\motifrelease{Motif 1.2}
\def\polyrelease{Poly/ML 3.01}
\def\quicktexloc{{\tt /QLaTeX}} % NB one location needs this hard wired in
\def\daztool{Compliance Tool}
% just useful macros
\def\ltm{$^{\rm TM}$}
\def\Note#1{{\small\bf[ #1 ]}}
=IGN
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Tool --- Description}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/USR504}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{D.J.~King & Project Manager}
\TPPabstract{
This document is the Description Manual for the Compliance Tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
\begin{tabular}[t]{lr}
C.O"Halloran & DRA\\
DAZ Project Library & WIN01\\
\end{tabular}}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadcentre{}
%\def\TPPheadcentreproject{}
%\def\TPPheadrhs{}
\let\TPPfootlhs=\TPPfootrhs
\def\TPPfootcentre{$\vcenter{\halign{\hfil\strut##\hfil\cr
COPYRIGHT  \copyright\ ICL 1996\cr}}$}
=TEX
\ftlmargin 0.0in
\ftrmargin 0.0in

\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$%
}}

\USRmanual{Compliance Notation --- Language Description}
\USRref{USR504}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}
\makeUSRfrontpage

\underscoreoff

\chapter*{CONTENTS}

\tableofcontents
\listoftables

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document describes the syntax and semantics of the Compliance Notation as supported by the Compliance Tool supplied as an extension to {\Product}.

\section{Readership}
This document provides reference material intended to be read by users of the Compliance Tool.

\section{Related Publications}

A bibliography is given on page \pageref{BIBLIOG} of this document.

\begin{itemize}

\item
An overview of the of the Compliance notation can be found in the DRA document:

{\em A commentary on the Specification of the Compliance Notation for SPARK and Z} \cite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.1}.

\item
The formal specification of the Compliance notation may be found in the DRA document:

{\em Specification of the Compliance Notation for SPARK and Z (3 volumes)} \cite{DRA/CIS/CSE3/TR/94/27/2.1}.

\item
The SPARK subset of Ada is described in the PVL document:

{\em SPARK --- The SPADE Ada Kernel} \cite{pvl92}.

\item
The use of the Compliance Tool is described in:

{\CNUSERGUIDE}.

\item
A description of \Product{} may be found in:

{\em \ {\SOFTSERV}},

which also contains a list of other \Product{} documentation.


\end{itemize}


\section{Prerequisites}

It is assumed that the reader is familiar with Ada and Z.
 
\section{Acknowledgements}

ICL gratefully acknowledges its debt to the many researchers (both academic and industrial) who have provided intellectual capital on which ICL has drawn in the development of {\Product} and the Compliance Tool.

We are particularly indebted to Program Validation Limited (PVL) who designed the SPARK subset of Ada and to the Defence Research Agency, Malvern (DRA) who designed the Compliance Notation and sponsored the development of the Compliance Tool.

=TEX
\chapter{INTRODUCTION}\label{INTRODUCTION}

The Compliance Notation allows Ada programs to be presented in a literate programming style in which the order of presentation of program fragments is chosen by the writer rather than fixed by the Ada syntax rules.
A program presented in the Compliance Notation may be interspersed with formal specifications of the program's behaviour written in the specification language Z.
If the program conforms to the SPARK subset of Ada, a Z document can be produced automatically from its presentation using the Compliance Notation.
This Z document contains Z paragraphs representing the Ada types, functions and constants defined in the SPARK program, together with conjectures, known as verification conditions (VCs), whose proof constitutes a correctness proof for the program against its specification.

The level of mathematical rigour in a Compliance Notation script is under the user's control.
At one extreme, no formal material at all need be included; at the other extreme, every subprogram can be formally specified and verified.
Most practical uses of the Compliance Notation will lie between these extremes.

The notation includes a feature allowing the syntactic rules of SPARK to be bypassed completely so that Ada features, such as generic packages, which are outside the scope of SPARK, can be used.

The Compliance Notation is supported by the Compliance Tool, an extension to {\Product}.
In addition to syntax-checking, type-checking and document preparation functions, the Compliance Tool supports extraction of the Ada program from a Compliance Notation script and the generation of the Z document.
All the facilities of {\Product} are available for proving VCs. These facilities are augmented with a range of theorems and proof procedures which are customised for VC proofs.
The use of the Compliance Tool is described in \CNUSERGUIDE. 

This document describes the syntax and semantics of the Compliance Notation.
The description of the syntax follows the structure of of the Ada Language Reference Manual, \cite{AJPO83}, referred to as ALRM in the rest of this document.
The description of the semantics is informal, but is based on the formal specifications of the Compliance Notation prepared by the Defence Research Agency \cite{DRA/CIS/CSE3/TR/94/27/2.1}.


\chapter{COMPLIANCE NOTATION SYNTAX}\label{SYNTAX}
\section{Introduction}
In this chapter, the syntax of the Compliance Notation is described.
The Compliance Notation as described here uses the {\ProductZ} dialect of Z.
The syntax of {\ProductZ} is described in \DESCRIPTION.

Sections \ref{2} to \ref{14} give the bulk of the description following the structure of chapters 2 to 14 of ALRM.

BNF syntax in this document is given using the same notation as in ALRM, except that reserved words are shown in double quotation marks rather than in a bold font.
Bold font is used for non-terminal symbols at their point of introduction. An index including these symbols is given at the end of this document. 

Section \ref{15} describes the {\em web clauses} which comprise the outermost level of the notation (the level at which Compliance Notation constructs are interleaved with narrative text in a script).

In the description of the syntax, the following terminology is used:

\begin{enumerate}
\item A construct {\em is not handled formally} if the Compliance Notation allows the syntax for the construct in parts of the script which do not have formal specification, but does not support formal reasoning about the construct.
\item A construct is {\em not supported} if the Compliance Notation does not allow the syntax for the construct.
\end{enumerate}

Unsupported constructs can be included in a script by means of the arbitrary Ada replacement facility (see \ref{15}).

\section{Lexical Elements}\label{2}
\subsection{Character Set}\label{2.1}
The character set for the Compliance Notation is the ISO seven-bit coded character set augmented with symbols required by the Z notation and certain special symbols described in section \ref{2.2} below.

\subsection{Lexical Elements, Separators, and Delimiters}\label{2.2}
The lexical elements of the Compliance Notation are the union of those for Ada as described in \cite{AJPO83} and those for {\ProductZ} as described in {\DESCRIPTION} augmented with a small list of symbols with special significance.

The special symbols are listed in table \ref{SS}:

\begin{table}[ht]
\begin{center}
{\ShowAllImages
\begin{tabular}{|l|l|}\hline
Symbol & Name \\\hline\hline
=INLINEFT
 πCN
=TEX
& Compliance Notation start symbol \\\hline
=INLINEFT
 ∞
=TEX
& Compliance Notation end symbol\\\hline
=INLINEFT
 √
=TEX
& Refinement symbol \\\hline
=INLINEFT
 È
=TEX
& Replacement symbol \\\hline
=INLINEFT
 !È
=TEX
& Arbitrary Ada symbol \\\hline
=INLINEFT
 ß
=TEX
& Left k-slot  symbol \\\hline
=INLINEFT
 ¢
=TEX
& Right k-slot  symbol \\\hline
=INLINEFT
 Ñ
=TEX
& Specification statement symbol \\\hline
=INLINEFT
 ò
=TEX
& Function specification statement symbol \\\hline
\end{tabular}}

\end{center}
\caption{Special Symbols}\label{SS}
\end{table}

The Compliance Notation start and end symbols are used like the analogous symbols for {\ProductZ} to delimit the Compliance Notation parts of a document (see \DESCRIPTION).
The other symbols are used within the Compliance Notation proper.
Several of these symbols are also used in Z; the grammar of the Compliance Notation is such that the extent of a Z expression or Z predicate within a valid Compliance Notation construct can always be unambiguously determined.

\subsection{Identifiers}\label{2.3}
The rules for identifiers are as in ALRM.

While Ada is not case-sensitive, Z is: when an Ada name is translated into a Z name it is translated into upper case.

\subsection{Numeric Literals}\label{2.4}
Integer literals are as in ALRM.

Real literals are not handled formally.

\subsection{Character Literals}\label{2.5}

Character literals are not handled formally.

\subsection{String Literals}\label{2.6}

String literals are not handled formally.


\subsection{Comments}\label{2.7}
Ada comments are normally not passed on to the Ada program generated from a Compliance Notation script.
For compatibility with the SPARK examiner, comments beginning with
=INLINEFT
--#
=TEX
\ are passed on to the SPARK program in those syntactic positions where the SPARK examiner allows or requires annotations, as described in \cite{pvl92}.

Comments may also be passed in to the SPARK program using the arbitrary Ada replacement facility.

Wherever a SPARK annotation is permitted, a k-slot (see section \ref{3.9}) may be used to defer provision of the actual text of the annotation.
In the case of the assert annotation, which appears as part of a sequence of statements, use of a k-slot produces a construct which cannot be handled formally (see section \ref{5.1}).
To handle a deferred annotation formally, a specification statement with an empty frame and $true$ for the pre- and post-condition can be used; this specification statement can then be refined (see section \ref{14}) by the assert annotation, which is equivalent to a null statement for the purposes of VC generation.

\subsection{Pragmas}\label{2.8}

Pragmas in the Compliance Notation are supported in the following places:

\begin{enumerate}
\item at any place where a declaration or a statement would be allowed;
\item in a declarative part;
\item immediately after a context clause;
\item where a compilation unit would be allowed.
\end{enumerate}

Pragmas are just treated as data to be passed in to the SPARK program generated from a Compliance Notation script and have no effect on the Z document.

\subsection{Reserved Words}\label{2.9}
In addition to the reserved words of ALRM, the following identifiers (which are not case-sensitive) have special significance in the Compliance Notation:

=GFT
	auxiliary
	by
	con
	implement
	references
	using
=TEX

\subsection{Allowable Replacements of Characters}

The replacement characters are not supported.

\section{Declarations and Types}\label{3}
\subsection{Declarations}\label{3.1}

Only the following forms of basic declaration are supported:

=GFT
€basic_declaration› ::=
		object_declaration
	|	type_declaration
	|	subtype_declaration
	|	subprogram_declaration
	|	package_declaration
	|	renaming_declaration
	|	deferred_constant_declaration
=TEX

A package declaration standing as a basic declaration inside a subprogram or another package declaration cannot be handled formally;
package declarations can only be handled formally when they are used as library units (i.e., at the top level).

\subsection{Objects and Named Numbers}\label{3.2}
=GFT
€object_declaration› ::=	constant_declaration
			|	variable_declaration

constant_declaration	=	identifier_list ":" "constant" type_mark ":=" expression ";"

variable_declaration	=	identifier_list ":" type_mark [ ":=" expression  ] ";"
=TEX

Named number declarations and declarations involving anonymous types are not supported.

\subsection{Types and Subtypes}\label{3.3}
\subsubsection{Type Declarations}\label{3.3.1}
=GFT
€type_declaration› ::=	full_type_declaration
			|	private_type_declaration

€full_type_declaration› ::=	"type" identifier "is" type_definition ";"

€type_definition› ::=	enumeration_type_definition
			|	integer_type_definition
			|	real_type_definition
			|	array_type_definition
			|	record_type_definition
=TEX
\subsubsection{Subtype Declarations}\label{3.3.2}
=GFT
€subtype_declaration› ::=	"subtype" identifier "is" subtype_indication ";"

€subtype_indication› ::=	type_mark [constraint]

€constraint› ::=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint
		|	index_constraint
=TEX

Note that a subtype indication need not include a constraint
(which is a new feature of the SPARK Ada Kernel v3.2).
Discriminant constraints are not supported.
\subsubsection{Classification of Operations}
Use of the base type attribute $T'BASE$ cannot be handled formally.
\subsection{Derived Types}\label{3.4}
Derived types are not supported.
\subsection{Scalar Types}\label{3.5}
=GFT
€range_constraint› ::= "range" range

€range› ::=	range_attribute
	|	simple_expression .. simple_expression
=TEX

A range given as a range attribute cannot be handled formally.

A range constraint must not denote a null range when used within a type definition.
A VC may be generated asserting that the range is not null if it cannot be determined whether or not the range is null (e.g., if the range constraint appeals to compiler-dependent constants such as $INTEGER'LAST$).

\subsubsection{Enumeration Types}\label{3.5.1}

=GFT
€enumeration_type_definition› ::=  "(" identifier {"," identifier} ")"
=TEX

Character literals are not supported as enumeration literals.
\subsubsection{Character Types}\label{3.5.2}
The predefined type $CHARACTER$ may be used;
however, character literals are not handled formally and user-defined character types are not supported (see the restriction in section \ref{3.5.1} above).

\subsubsection{Boolean Types}\label{3.5.3}
No restrictions apply to this section of ALRM.
\subsubsection{Integer Types}\label{3.5.4}

=GFT
€integer_type_definition› ::= range_constraint
=TEX

No restrictions apply to this section of ALRM.
\subsubsection{Operations of Discrete Types}\label{3.5.5}
Only the following attributes of a discrete type or subtype $T$ are supported:
=GFT
	T'FIRST
	T'LAST
	T'POS
	T'VAL
	T'SUCC
	T'PRED
=TEX
\subsubsection{Real Types}\label{3.5.6}
=GFT
€real_type_definition› ::=
	floating_point_constraint | fixed_point_constraint
=TEX


\subsubsection{Floating Point Types}\label{3.5.7}
=GFT
€floating_point_constraint› ::=
	floating_accuracy_definition [range_constraint]

€floating_accuracy_definition› ::=
	"digits" simple_expression
=TEX

The predefined arithmetic operators on floating point types cannot be handled formally.

\subsubsection{Operations of Floating Point Types}\label{3.5.8}
The attributes of floating point types are not supported.

\subsubsection{Fixed Point Types}\label{3.5.9}
=GFT
€fixed_point_constraint› ::=
	fixed_accuracy_definition [range_constraint]

€fixed_accuracy_definition› ::=
	"delta" simple_expression
=TEX

The predefined arithmetic operators on fixed point types cannot be handled formally.

\subsubsection{Operations of Fixed Point Types}\label{3.5.10}
The attributes of fixed point types are not supported.

\subsection{Array Types}\label{3.6}

=GFT
€array_type_definition› ::=
	unconstrained_array_definition | constrained_array_definition

€unconstrained_array_definition› ::=
	"array" "(" index_subtype_definition {"," index_subtype_definition} ")" "of"
		type_mark

€constrained_array_definition› ::=
	"array" index_constraint "of" type_mark

€index_subtype_definition› ::= type_mark "range" "<>"

€index_constraint› ::= "(" type_mark {"," type_mark} ")"
=TEX



The component subtype indication in an unconstrained or constrained array definition must be given as a type mark.

Each discrete range in an index constraint must be given as a type mark.

\subsubsection{Index Constraints and Discrete Ranges}\label{3.6.1}

The discrete ranges in an index constraint must be given as type marks, 
This implies that the bounds of any array object are static expressions.

\subsubsection{Operations of Array Types}\label{3.6.2}

The attributes of array types are only supported for one-dimensional arrays.
The attributes in question are:

=GFT
	A'FIRST
	A'LAST
	A'RANGE
	A'LENGTH
=TEX

The forms of attribute with an argument are not supported.

The catenation and ordering operators for array types are not handled formally.

\subsubsection{The Type String}\label{3.6.3}
The type $STRING$ is treated precisely as if defined by the following unconstrained array type definition (see section \ref{UAT}):
=GFT
	type STRING is array (POSITIVE range <>) of CHARACTER
=TEX

String literals cannot be handled formally and the catenation and ordering operators for string types are not available.

\subsection{Record Types}\label{3.7}

=GFT
€record_type_definition› ::=
	"record"
		component_list
	"end" "record"

€component_list› ::=
	component_declaration {component_declaration}

€component_declaration› ::=
	identifier_list ":" type_mark ";"
=TEX
\subsubsection{Discriminants}\label{3.7.1}
Discriminants are not supported.

\subsubsection{Discriminant Constraints}\label{3.7.2}
Discriminant constraints are not supported.

\subsubsection{Variant Parts}\label{3.7.3}
Variant parts are not supported.
The syntax for $choice$ is given in section \ref{4.3}.

\subsubsection{Operations of Record Types}\label{3.7.4}

All the basic operations other than attributes for record types are supported.

\subsection{Access Types}\label{3.8}
Access types are not supported.

\subsection{Declarative Parts}\label{3.9}

=GFT
€declarative_part› ::=
	{basic_declarative_item} {later_declarative_item}

€basic_declarative_item› ::=
	basic_declaration | representation_clause | k_slot

€later_declarative_item› ::= body
	| subprogram_declaration | package_declaration | k_slot

€body› ::= proper_body | body_stub

€proper_body› = subprogram_body | package_body
=TEX

A k-slot (short for Knuth-slot) serves in several places in the syntax and denotes a placeholder for an Ada construct. The Ada constructs which can be deferred in this way are a compilation, a basic declarative item, a statement, a visible part or a private part.

=GFT
€k_slot› ::= "ß" commentary "¢" [tag]

€tag› ::= "(" digit{digit} ")"
=TEX

Here
=INLINEFT
€commentary›
=TEX
\ stands for an arbitrary sequence of characters not including 
=INLINEFT
"¢"
=TEX
.
The optional numeric tag is used to identify the k-slot when the Ada construct whose place it is holding is provided in a refinement or replacement step.
If the numeric tag is omitted, then an anonymous tag is implicitly introduced to identify the k-slot.
The next refinement or replacement step in the script that also omits the tag will be treated as if it referred to this anonymous tag.



\section{Names and Expressions}\label{4}
\subsection{Names}\label{4.1}
=GFT
€name› ::=
		simple_name
	|	indexed_component
	|	selected_component

€prefix› ::= name | function_call
=TEX

Use of an operator symbol as a name is not supported.

Slices are not supported.

Character literals and attributes are taken as primaries rather than names.

\subsubsection{Indexed Components}\label{4.1.1}

=GFT
€indexed_component› ::= prefix "(" expression {"," expression} ")"
=TEX

\subsubsection{Slices}\label{4.1.2}
Slices are not supported.

\subsubsection{Selected Components}\label{4.1.3}

=GFT
€selected_component› ::= prefix "." selector
=TEX

Other rules imply that the only supported forms of selected components denote a record component or an entity declared in the visible part of a package.

\subsubsection{Attributes}\label{4.1.4}
=GFT
€attribute› ::= prefix "'" attribute_designator
	|	character_literal "'" attribute_designator
=TEX

Only the first form of attribute can be handled formally.

\subsection{Literals}\label{4.2}
The literal $null$ is not supported.

Only integer literals and enumeration literals are handled formally.

\subsection{Aggregates}\label{4.3}

=GFT
€aggregate› ::=
		"(" component_associations ["," "others" "=>" expression] ")" 
	|	"(" "others" "=>" expression ")" 

€component_associations› ::=
		named_association {"," named_association}
	|	positional_association {"," positional_association}

€named_association› ::=
	choice {"|" choice} "=>" expression

€positional_association› ::= expression

€choice› ::=
	simple_expression
	|	discrete_range
	|	"others"
	|	simple_name
=TEX

A mixture of named and positional component associations is not supported in an aggregate (although an $others$ choice is permitted when positional component associations are used).

To be handled formally, an aggregate must appear as the operand of a qualified expression (so that the Ada type of the aggregate is available to guide its translation into Z).

\subsubsection{Record Aggregates}\label{4.3.1}

A record aggregate with an $others$ choice cannot be handled formally.

\subsubsection{Array Aggregates}\label{4.3.2}

Multi-dimensional array aggregates are not handled formally.

\subsection{Expressions}\label{4.4}

=GFT
€expression› ::=
	relation {"and" relation}	| relation {"and" "then" relation}
    |	relation {"or" relation}	| relation {"or" "else" relation}
    |	relation {"xor" relation}

€relation› ::=
	simple_expression [relational_operator simple_expression]
    |	simple_expression ["not"] "in" range
    |	simple_expression ["not"] "in" type_mark

€simple_expression› ::=
	[unary_adding_operator] term {binary_adding_operator term}


€term› ::=
	factor {multiplying_operator factor}


€factor› ::= primary ["**" primary] | "abs" primary | "not" primary

€primary› ::= 
	numeric_literal	|	aggregate		|	string_literal
    |	name			|	function_call		|	type_conversion
    |	qualified_expression	|	"(" expression ")"	| attribute
    |	auxiliary_expression

€auxiliary_expression› ::= "˚" z_expression "˝"
=TEX

The $null$ expression and allocators are not supported.

See section \ref{4.2} for restrictions on literals.

=INLINEFT
€z_expression›
=TEX
\ stands for the construct called $Expr$ in {\DESCRIPTION}.

\subsection{Operators and Expression Evaluation}\label{4.5}
The syntax for the six classes of operator is exactly as in ALRM except that the catenation operator \& is not supported.

\subsubsection{Logical Operators and Short-circuit Control Forms}\label{4.5.1}
The short-circuit control forms $and\,then$ and $or\,else$ are treated formally as synonymous with $and$ and $or$ respectively.



\subsubsection{Relational Operators and Membership Test}\label{4.5.2}

Predefined ordering operators for discrete array types are not handled formally.

Membership tests with a type mark are not handled formally.

\subsubsection{Binary Adding Operators}\label{4.5.3}

Addition and subtraction are only handled formally for integer types.

Catenation is not supported.

\subsubsection{Unary Adding Operators}\label{4.5.4}

The unary adding operators are only handled formally for integer types.

\subsubsection{Multiplying Operators}\label{4.5.5}

The multiplying operators are only handled formally for integer types.

\subsubsection{Highest Precedence Operators}\label{4.5.6}

The absolute value operation is only handled formally for integer types.

\subsubsection{Accuracy of Operations with Real Operands}\label{4.5.7}

The only operators for real types which are handled formally are non-computational operators such as assignment and parameter passing.

\subsection{Type Conversions}\label{4.6}

=GFT
€type_conversion› ::= type_mark "(" expression ")"
=TEX

A type conversion appearing as an actual parameter whose corresponding formal parameter has mode $out$ or $in\,out$ cannot be handled formally.

A type conversion can only be handled formally if both the operand and target types are integer types.


\subsection{Qualified Expressions}\label{4.7}

=GFT
€qualified_expression› ::=
	type_mark "'" "(" expression ")"
    |	type_mark "'" aggregate
=TEX

\subsection{Allocators}\label{4.8}
Allocators are not supported.

\subsection{Static Expressions and Static Subtypes}\label{4.9}

Not all static expressions can be completely evaluated when a Compliance Notation script is checked.
For example, the value of an attribute such as $INTEGER'FIRST$ depends on the compiler being used.
This sometimes results in a VC being generated (see sections~\ref{3.5} and~\ref{RangeInTypeDefinition}).

\subsection{Universal Expressions}\label{4.10}
Universal expressions are only handled formally for the universal integer type.


\section{Statements}\label{5}
\subsection{Simple and Compound Statements --- Sequences of Statements}\label{5.1}

=GFT
€sequence_of_statements› ::= statement {statement}

€statement› ::=
		simple_statement
	|	compound_statement
	|	[logical_constant_declaration] specification_statement [tag]
	|	k_slot

€simple_statement› ::=
		null_statement
	|	assignment_statement
	|	procedure_call_statement
	|	exit_statement
	|	return_statement

€compound_statement› ::=
		if_statement
	|	case_statement
	|	loop_statement

€logical_constant_declaration› ::= "con" z_declaration "∑"

€specification_statement› ::=
		"Ñ" frame "[" [pre_condition ","] post_condition "]"
	|	"Ñ" frame "{" pre_condition "}"

€frame› ::= [ z_identifier {"," z_identifier} ]

€pre_condition› ::= z_predicate

€post_condition› ::= z_predicate

€null_statement› ::= "null" ";"
=TEX

Here
=INLINEFT
€z_declaration›
=TEX
,
=INLINEFT
€z_identifier›
=TEX
\ and 
=INLINEFT 
€z_predicate›
=TEX
\ stand for the constructs called $Decl$, $Id$ and $Pred$ respectively in {\DESCRIPTION}.

The Z declaration in a logical constant declaration must declare a single variable.
The specification statement following a logical constant declaration must have a pre-condition, and that pre-condition must have the form:
=INLINEFT
X = E ± A
=TEX
\ or
=INLINEFT
X = E
=TEX
, where $X$ stands for the variable declared by the Z declaration.

The forms of specification statement with only one predicate are abbreviations of special cases of the form with two predicates.
The form with square brackets and only one predicate is taken as having a pre-condition of $true$.
In the form of specification statement with braces, the post-condition is taken to be $true$.

Anonymous tags are introduced for specification statements appearing as statements without a tag in the same way as for k-slots (see section \ref{3.9}).

A k-slot as a statement cannot be handled formally.

\subsection{Assignment Statement}\label{5.2}
=GFT
€assignment_statement› ::= name ":=" expression ";"
=TEX

\subsection{If Statements}\label{5.3}

=GFT
€if_statement› ::=
	"if" condition "then"
		sequence_of_statements
    {	"elsif" condition "then"
		sequence_of_statements }
    [	"else"
		sequence_of_statements ]

€condition› ::= expression
=TEX

\subsection{Case Statements}\label{5.4}

=GFT
€case_statement› ::=
	"case" expression is
		case_statement_alternative
	{	case_statement_alternative }
	"end" "case" ";"

€case_statement_alternative› ::=
	"when" choice { "|" choice } =>
		sequence_of_statements
=TEX

See section \ref{4.3} for the syntax of $choice$.

A case statement with an $others$ choice cannot be handled formally.

\subsection{Loop Statements}\label{5.5}

=GFT
€loop_statement› ::=
[simple_name:]
	[iteration_scheme]
	[till_predicate] "loop"
		sequence_of_statements
	"end" "loop" [simple_name] ";"

€iteration_scheme› ::=
		"while" condition
	|	"for" loop_parameter_specification

€loop_parameter_specification› ::=
	identifier "in" ["reverse"] discrete_range

€till_predicate› ::=
		"till" auxiliary_expression
=TEX

See section \ref{4.4} for the syntax of auxiliary expression.

To be handled formally, the sequence of statements comprising the body of a loop statement must comprise a single specification statement possibly with a tag (see section \ref{5.1}).

A for loop with a $reverse$ parameter specification cannot be handled formally.

The loop name is for documentary purposes only (see section \ref{5.7}).

\subsection{Block Statements}\label{5.6}

Block statements are not supported.

\subsection{Exit Statements}\label{5.7}

=GFT
€exit_statement› ::=
	"exit" ["when" condition] ";"
=TEX

An exit statement applies to the innermost loop containing it: exit statements including a loop name are not supported.

To be handled formally, an exit statement must meet the following conditions:

\begin{enumerate}
\item the loop containing an exit statement must have a $till$ predicate;
\item if the $exit$ $when$ form is used this loop statement must be the innermost compound statement containing the exit statement;
\item if the form without $when$ is used, the $exit$ statement must be the last statement inside an if statement and the loop statement must be the innermost compound statement containing this if statement.
\end{enumerate}

\subsection{Return Statements}\label{5.8}
=GFT
€return_statement› ::=
	"return" expression ";"
=TEX
Use of return statements in the body of a procedure subprogram is not supported.
The last statement in a function subprogram must be either a return statement or a case statement all of whose alternatives end with a return statement.

\subsection{Goto Statements}\label{5.9}

Goto statements are not supported.

\section{Subprograms}\label{6}

\subsection{Subprogram Declarations}\label{6.1}
=GFT
€subprogram_declaration› ::= subprogram_specification ";"

€subprogram_specification› ::=
		informal_subprogram_specification
	|	formal_subprogram_specification

€informal_subprogram_specification› ::=
		"procedure" identifier [formal_part]
	|	"function" designator [formal_part] "return" type_mark

€formal_subprogram_specification› ::=
		"procedure" identifier [formal_part]
		specification_statement
	|	"function" designator [formal_part] "return" type_mark
		function_specification_statement

€designator› ::= identifier

€formal_part› ::=
	"(" parameter_specification { ";" parameter_specification } ")"

€parameter_specification› ::=
	identifier_list : mode type_mark

€mode› ::= ["in"] | "in" "out" | "out"

€function_specification_statement› ::=
		"ò" global_dependencies "[" [pre_condition ","] post_condition "]"
	|	"ò" global_dependencies "{" pre_condition "}"

€global_dependencies› ::= [ z_identifier {"," z_identifier} ]
=TEX

For the syntax of specification statements see section \ref{5.1};


Use of an operator symbol as a function designator is not supported for user-defined functions.

A subprogram, procedure or function is said to be a {\em formal} subprogram, procedure or function if it has a specification statement and is said to be informal otherwise.
Subprogram calls can only be handled formally for formal subprograms.

A formal function may not have side effects --- the frame of its specification
statement is implicitly empty. A formal function may read the values
of variables declared outside the function.
Such variables must be identified in the global dependencies list of the function specification statement and must be in scope at the point that the function is declared.
These can either be program variables or auxiliary variables.
If auxiliary variables are used, they must be declared in a package other than the package (if any) containing the function specification (data refinement is not supported for function subprograms).
The variables need not actually be global: they might be local to a subprogram containing the function specification.

\subsection{Formal Parameter Modes}\label{6.2}
The following rules are applied when a formal procedure call is processed to ensure that parameter aliasing does not compromise the soundness of the VCs generated for the call.
These also make the soundness of the VCs independent of the parameter passing mechanism used by the Ada compiler.

\begin{enumerate}
\item
Every actual parameter whose corresponding formal parameter has mode $out$ or $in$ $out$, shall be an entire variable (i.e., not an array or record component);
\item
No variable used anywhere in the specification statement for the procedure may occur as an actual parameter whose corresponding formal parameter has mode $out$ or $in$ $out$;
\item
No variable named in the frame of the specification statement for the procedure may occur in any actual parameter;
\item
No variable occurring as an actual parameter whose corresponding formal parameter has mode $out$ or $in$ $out$ may be used anywhere else in the procedure call statement.
\end{enumerate}

\subsection{Subprogram Bodies}\label{6.3}

=GFT
€subprogram_body› ::=
	subprogram_specification "is"
		[ declarative_part ]
	"begin"
		sequence_of_statements
	"end" designator ";"
=TEX

Exception handlers are not supported.

\subsection{Subprogram Calls}\label{6.4}
=GFT
€procedure_call_statement› ::=
	name [actual_parameter_part]";"

€function_call› ::=
	name [actual_parameter_part]

€actual_parameter_part› ::=
	"(" named_parameter {"," named_parameter} ")"
    |	"(" positional_parameter {"," positional_parameter}} ")"


€name_parameter› ::= formal_parameter "=>" expression

€formal_parameter› ::= simple_name

€positional_parameter› ::= expression
=TEX
Positional and named parameter association may not be mixed within one subprogram call.

\subsection{Function Subprograms}\label{6.5}
See section \ref{5.8} for restrictions on function subprograms which ensure that  the function body is always left by a return statement.

\subsection{Parameter and Result Type Profile --- Overloading of Subprograms}\label{6.6}

Overloading of subprogram names cannot be handled formally.

\subsection{Overloading of Operators}\label{6.7}

No overloading of operator symbols is supported except for the limited form of overloading of operator symbols using renaming declarations (see section \ref{8.5}).


\section{Packages}\label{7}
\subsection{Package Structure}\label{7.1}
=GFT
€package_declaration› ::= package_specification ";"

€package_specification› ::=
	"package" identifier "is"
		visible_part
    [	"private"
		private_part basic_declarative_item, { basic_declarative_item } ]
	"end" simple_name

€visible_part› ::= visible_part_declaration { visible_part_declaration }

€visible_part_declaration› ::=
   {	basic_declarative_item
    |	subprogram_declaration
    |	auxiliary_declaration 
    |  renaming_declaration }

€private_part› ::= private_part_declaration { private_part_declaration }

€private_part_declaration› ::=
   {	basic_declarative_item
    |  renaming_declaration }

€auxiliary_declaration› ::= "auxiliary" z_declaration ";"
=TEX

Here 
=INLINEFT
z_declaration
=TEX
\ stands for the construct called $Decl$ in {\DESCRIPTION}.

A variable introduced by an auxiliary declaration ia a Z variable referred to
as an
=INLINEFT
€auxiliary variable›
=TEX
.
Auxiliary variables are used in specification statements in a package specification as abstractions of all or part of the state of the package body.
Together with using clauses, auxiliary variables support data refinement.

Empty visible or private parts are not supported.

The use of k-slots within the visible or private part of a package specification is not supported.

=GFT
€package_body› ::=
	"package" "body" simple_name "is"
		declarative_part
    [	[using_declaration { using_declaration }]
   	"begin"
		sequence_of_statements ]
	"end" simple_name ";"

€using_declaration› ::=
	"using" simple_declaration { simple_declaration }
	"implement" z_identifier "by" invariant ";"

€simple_declaration› ::=
		object_declaration
	|	type_declaration
	|	subtype_declaration

€invariant› ::= z_predicate
=TEX
Here 
=INLINEFT
€z_identifier›
=TEX
\ and 
=INLINEFT
z_predicate
=TEX
\ stand for the constructs called $Id$ and $Pred$ respectively in {\DESCRIPTION}.

Auxiliary declarations and using declarations together support data refinement.
A using declaration relates the values taken by one or more variables in the package body with the value of a Z variable introduced in an auxiliary declaration in the package specification.
If using declarations are given the package body must have a sequence of statements.

\subsection{Package Specifications and Declarations}\label{7.2}

If a procedure in a package specification has a specification statement, then it is this specification statements which is used in the generation of VCs for calls of the procedure outside the package body.

When a package is named in a with clause, Z global variables are introduced representing the types, constants and functions in the package.
The Z variable names are derived from the Ada name by converting it to upper case and prefixing the result with the package name (also converted to upper case) and an `o'.
For example a function $fnc$ define in package $pck$ would give rise to the Z global variable $FNCoPCK$ defined in an axiomatic description capturing the signature and the formal specification of the function (if any).

\subsection{Package Bodies}\label{7.3}

If a subprogram has a specification statement both in the package specification and in the package body, then VCs are generated to ensure that the specification statement in the package body refines that in the package specification.

If a subprogram has a specification statement in the package body, then it is this specification statement which is used in the generation of VCs for calls of the subprogram inside the package body.
The subprogram will be treated as an informal procedure if it is used before its implementation within the package body.

When a package body is introduced, Z global variables are automatically bought into scope representing the types and constants, {\em but not the functions} in the package (as stated in the package specification).
The names of these global variables are {\em not} prefixed with the package name.
Global variables for any functions in the package are introduced as the function implementations are processed.
 
A Z global variable representing a function in the package is introduced at the point where the implementation of the function is provided.
Thus calls of the function will not be handled formally within the package body, if they appear before the implementation of the function.

\subsection{Private Type and Deferred Constant Declarations}\label{7.4}

=GFT
€private_type_declaration› ::=
	"type" identifier "is [ "limited" ] "private" ";"

€deferred_constant_declaration› ::=
	identifier_list : "constant" type_mark ";"
=TEX

The Z global variables corresponding to private type declarations and deferred constant declarations are introduced using the information in the actual declarations in the private part of the package specification.


\section{Visibility Rules}\label{8}
The visibility rules for the Compliance Notation may be described in terms of the Ada visibility rules given the method for extracting the SPARK program from a literate script.
The SPARK program is extracted from a literate script as follows:

\begin{enumerate}
\item Any auxiliary declarations are commented out;
\item Any using declarations are replaced by their constituent simple declarations;
\item Any till predicates are commented out;
\item Any references clauses are commented out;
\item Any specification statements not occurring as statements are commented out;
\item The constituent web clauses of the script are scanned in order and k-slots and specification statements in each web clause are expanded in turn;
\begin{enumerate}
\item A k-slot is expanded by replacing its text by the text on the right hand side of the corresponding replacement step or arbitrary replacement step and then, in the case of an ordinary replacement step, recursively expanding any k-slots or specifications in the resulting text;
\item A specification statement occurring as a statement is  expanded by replacing its text by the text on the right hand side of the corresponding refinement step, replacement step or arbitrary replacement step and then recursively expanding any k-slots or specifications in the resulting text;
\end{enumerate}
\item Any k-slots or specification statements which cannot be expanded are replaced by null statements or commented out according as they do or do not occur as statements.
\end{enumerate}

The phrase ``current SPARK program'' or ``current SPARK program for $C$'' is used below to refer to the result of carrying out the above steps on an initial fragment of the literate script, up to the point at which some construct, $C$, appears.

\subsection{Declarative Region}\label{8.1}
The declarative region in which a Compliance Notation construct occurs is determined by the declarative region it occupies in the current SPARK program.

\subsection{Scope of Declarations}\label{8.2}
Within one compilation unit, the scope of a declaration includes any Compliance Notation construct, $C$, which would be in the scope of the declaration in the current SPARK program for $C$.

A compilation unit $U_1$ may only refer to entities defined in another compilation unit, $U_2$, under the following circumstances:
{\em(a)}, $U_1$ is the package body implementing the package specification in $U_2$ and the entity is a type, constant or variable,
or, {\em(b)}, $U_2$ gives the package specification of a package identified in the context clause of $U_2$.
In case {\em(a)}, the entity must be referred to by its simple name, without a package name prefix.
In case {\em(b)}, since use clauses are not supported, the entity must be referred to with the package name prefix.

\subsection{Visibility}\label{8.3}

No overloading of names or operator symbols is allowed except for the limited form of overloading of operator symbols using renaming declarations (see section \ref{8.5}).

Declaring a name in an inner scope which is already declared in an outer scope is not handled formally.

Other than within the package specification or the package body for a package, $P$, names defined within $P$ must be referenced by selection (i.e., by prefixing the name with $P$ and a dot).

\subsection{Use Clauses}\label{8.4}
Use clauses are not supported.

\subsection{Renaming Declarations}\label{8.5}
=GFT
€renaming_declaration› ::=
		"function" operator_symbol formal_part "return" type_mark
			"renames" simple_name "." operator_symbol ";"
	|	informal_subprogram_specification "renames" simple_name ";"

=TEX

In the first form of renaming declaration the two operator symbols must be the same.
This form of renaming declaration is intended for operators such as
=INLINEFT
pck."+"
=TEX
\ introduced implicitly when a numeric type is declared in package $pck$.


If the subprogram being renamed is a formal procedure, then the formal specification for the new procedure name is taken from that for the old one.

If the subprogram being renamed is a function other than a predefined operator, a Z global variable for the new function name is introduced and defined to be equal to the renamed function.

\subsection{The Package Standard}\label{8.6}

Compliance Notation scripts are processed in an environment which includes the declarations in the package $STANDARD$ with the following restrictions:

\begin{enumerate}
\item
The predefined types $FLOAT$, $SHORT\_FLOAT$ and $LONG\_FLOAT$ are not provided.
\item
The enumeration literals, attributes and predefined operators of the type $CHARACTER$ are not provided.
\item
The package $ASCII$ is not provided.
\item
The only predefined operators for the type $STRING$ are $=$ and 
=INLINEFT
/=
=TEX
.
\item
No attributes of the type $STRING$ are provided.
\item
The type $DURATION$ is not provided.
\end{enumerate}
\subsection{The Context of Overload Resolution}\label{8.7}

No overloading of names is supported except for the limited form of overloading of predefined operators using renaming declarations (see section \ref{8.5}).
The question of overload resolution does not arise for predefined operators, since the underlying semantics of these operators is built into the notation.

\section{Tasks}\label{9}
Tasks are not supported.

\section{Program Structure and Compilation Issues}\label{10}

\subsection{Compilation Units --- Library Units}\label{10.1}

=GFT
€compilation› ::= k_slot | compilation_unit {compilation_unit}

€compilation_unit› ::= context_clause library_unit | context_clause secondary_unit

€library_unit› ::= package_declaration | subprogram_body

€secondary_unit› ::= library_unit_body | subunit

€library_unit_body› ::= package_body
=TEX

The only declarations allowed as compilation units are package declarations.
Consequently, any subprogram body appearing as a compilation unit is a library unit and only packages and subunits are considered to be secondary units.

Generic packages are not supported.

\subsubsection{Context Clauses --- With Clauses}\label{10.1.1}

=GFT
€context_clause› ::= [ with_clause ] [ references_clause ]

€with_clause› ::= "with" simple_name {"," simple_name} ";"

€references_clause› ::= "references" simple_name {"," simple_name} ";"
=TEX

A context clause contains at most one with clause.
Use clauses are not supported.

To allow use of packages for purely informal purposes, the names in a with clause need not all identify packages whose specifications have been provided.
The use of entities declared in such packages is not handled formally.

A context clause may also include a references clause.
A references clause is used to identify packages that are needed to specify the semantics of a compilation unit.
This allows such packages to be identified without including them in a with clause.

\subsection{Subunits of Compilation Units}

=GFT
€body_stub› ::=
	subprogram_specification "is" "separate" ";"
    |	"package" "body" simple_name "is" "separate"

€subunit› ::=
	"separate" "(" name ")" proper_body
=TEX

Tasks are not supported.

\section{Exceptions}\label{11}
Exceptions are not supported.

\section{Generic Units}\label{12}
Generic units are not supported.

\section{Representation Clauses and Implementation-Dependent Features}\label{13}

\subsection{Representation Clauses}

=GFT
€representation_clause› ::= type_representation_clause | address_clause

€type_representation_clause› ::= length_clause
	| enumeration_representation_clause | record_representation_clause
=TEX
\subsection{Length Clauses}\label{13.2}

=GFT
€length_clause› ::= "for" attribute "use" simple_expression ";"
=TEX

\subsection{Enumeration Representation Clauses}\label{13.3}

=GFT
€enumeration_representation_clause› ::= "for" simple_name "use" aggregate ";"
=TEX

\subsection{Record Representation Clauses}\label{13.4}

=GFT
€record_representation_clause› ::=
	"for" simple_name "use" 
	"record" [ alignment_clause ]
	   	{ component_clause }
	"end" "record" ";"

€alignment_clause› ::= "at" "mod" simple_expression ";"

€component_clause› ::= name "at" simple_expression "range" range ";"
=TEX
\subsection{Address Clauses}\label{13.5}

=GFT
€address_clause› ::= "for" simple_name "use" "at" simple_expression ";"
=TEX

\subsection{Change of Representation}\label{13.6}

Note that because derived types are not supported the approach taken in the example in section 13.6 of ALRM would not be supported by the Compliance notation.

\subsection{The Package System}\label{13.7}

The Compliance Notation does not provide the package $SYSTEM$.

\subsection{Machine Code Insertion}\label{13.8}

Machine code insertions are not supported.

\subsection{Interface to Other Languages}\label{13.9}
The interface pragma is supported (as are any other pragmas meeting the restrictions of section \ref{2.8}).

\subsection{Unchecked Programming}\label{13.10}

The generic library subprograms for unchecked storage  deallocation and unchecked type conversions are not supported.


\section{Input-Output}\label{14}
The predefined packages for input-output are not provided.

\section{Web Clauses and Compliance Notation Scripts}\label{15}
=GFT
€web_clause› ::=
	z_paragraph
    |	πCN
		compilation
	∞
    |	πCN
		refinement_step
	∞
    |	πCN
		replacement_step
	∞
    |	πCN
		arbitrary_replacement_step
	∞

€refinement_step› ::= 
	[ tag ] "√" sequence_of_statements

€replacement_step› ::=
	[ tag ] "È" compilation
    |	[ tag ] "È" private_part
    |	[ tag ] "È" visible_part
    |	[ tag ] "È" declarative_part

€arbitrary_replacement_step› ::=
	[ tag ] "!È" lexical_elements
=TEX

If the tag is omitted in any of the above constructs, the refinement, replacement or arbitrary replacement applies to the immediately preceding k-slot or specification statement without an explicit tag.

The kind of refinement or replacement must be appropriate to the corresponding k-slot or specification statement.
For example, it is not allowed to refine a declaration k-slot or to replace a specification statement with a declaration.
This restriction does not apply to an arbitrary replacement step.

A replacement step which introduces a declaration into a declarative part has the implicit effect of widening the frames of any specification statements in the scope of that declarative part to include the variables declared on the right-hand side of the replacement step.
Thus, local variables introduced in this way after a specification statement become available for use in the refinement of that specification statement.

Here,
=INLINEFT
€lexical_elements›
=TEX
\ stands for an arbitrary sequence of the lexical elements of Ada.
This means that string and character quotation characters must be properly balanced in an arbitrary replacement step.
No other restrictions apply to the right-hand side of an arbitrary replacement step, which is copied verbatim, with all format effectors preserved, into the SPARK program when the replacement is expanded.

=GFT
€compliance_notation_application› ::=	compliance_notation_script
						{compliance_notation_script}

€compliance_notation_script› ::=	web_clause
					{web_clause}
=TEX

A compliance notation application is made of one or more scripts each of which is a sequence of web clauses.
In practice, the scripts are interleaved with {\Product} metalanguage commands to identify the scripts (see section \ref{PS} and \CNUSERGUIDE).

A script may contain at most one Ada compilation unit.

The compliance notation requires any formal dependencies between scripts to be expressed in a linear sequence.

\chapter{COMPLIANCE NOTATION SEMANTICS}\label{SEMANTICS}
The semantics of the Compliance Notation may be understood in terms of the translation of one or more Compliance Notation script into {\em(a)} SPARK source code, and {\em(b)} one or more Z documents.
The translation into SPARK source code is described in section \ref{8} above.
The translation of a script into a Z document is described in this chapter.

The main purpose of the Z document is to provide a set of Z conjectures, the verification conditions, or VCs, whose truth entails that the formally specified parts of the SPARK program satisfy their specifications.
The Z document also contains any Z paragraphs which appear in the script together with Z paragraphs that are automatically generated from some of the Ada declarations in the script.
These Z paragraphs together with the extensions to the Z library described in chapter \ref{cn} provide the vocabulary in terms of which the VCs are couched.

In sections \ref{ToE} to \ref{PS} below, the generation of the Z document is described under the following headings:

\begin{description}
\item[Expressions] Ada expressions are translated into Z expressions appearing in VCs or in generated Z paragraphs according to the context of use.
\item[Declarations] Type, constant and function declarations are translated into  Z paragraphs.
\item[VC Generation] VCs are generated for refinement steps and for certain other constructs.
\item[Program Structure] The top level structure of the literate scripts gives rise to the creation of one or more {\Product} theories.
\end{description}

\section{Translation of Expressions}\label{ToE}

In this section the translation of SPARK expressions into Z is described.
The examples used depend on the following definitions:
=GFT
   type €DAY› is (€MON›, €TUE›, €WED›, €THU›, €FRI›, €SAT›, €SUN›);
   subtype €INDEX› is INTEGER range 2 .. 5;
   type €ARR› is array (INDEX) of DAY;
   type €REC› is record  START : DAY; FINISH : DAY; end record; 	 
   function €MAX› (x, y: DAY) return DAY ò [true];
   function €CONST› return INTEGER ò [CONST = 1001];
   function €SUMXY› return INTEGER ò X, Y [SUMXY(X, Y) = X + Y];
   function €XPLUSY› (Y : INTEGER) return INTEGER ò X [XPLUSY(X)(Y) = X + Y];
   ArrVar : €ARR›;
   RecVar : €REC›;
=TEX

Sections \ref{Literals} to \ref{Type} below discuss the translation of the various forms of SPARK expression.
Many of these translations depend on the some extensions to the Z library which support predefined types and their operators and attributes.
These extensions are described in chapter \ref{cn}.

\subsection{Literals}\label{Literals}
Character, null, real and string literals cannot be handled formally and do not have a translation.

Integer literals both based and decimal are translated into Z decimal literals.
For example, both $35$ and
=INLINEFT
2#0010_0011#
=TEX
\ are translated as $35$.

An enumeration literal is translated in the same way as an identifier (see below).

\subsection{Identifiers}
A simple name is translated into Z as a variable (global or local) by converting all letters into upper case.
For example, both $Var$ and $var$ are translated as $VAR$.

An identifier prefixed by a package name (which is strictly speaking a selected component in Ada terminology) is translated into a Z variable by converting all letters into upper case and replacing each `.' by `$o$'.
For example, $Pack.object$ is translated as $PACKoOBJECT$.

Attribute names are translated into Z global variables whose names are formed by converting letters to upper case and replacing the prime with a `$v$'. 
For example, $ARR'LENGTH$ is translated as $ARRvLENGTH$.

\subsection{Record Aggregates}\label{Records}
A record aggregate using either named or positional association is translated into a Z binding display.

For example both
=INLINEFT
REC'(WED, SUN)
=TEX
\ and
=INLINEFT
REC'(START=>WED, FINISH=>SUN)
=TEX
\ are translated as
=INLINEFT
(FINISH ¶ SUN, START ¶ WED)
=TEX
.

\subsection{Array Aggregates}\label{Array}
A positional array aggregate with no $others$ part is translated as a Z sequence display composed with a numerical shift operator.
For example,
=GFT
		ARR'(SAT, SUN, MON, TUE)
=TEX
is translated as
=GFT
		succ Á 1 - ARRvFIRST Í ª ßSAT, SUN, MON, TUE¢.
=TEX
A named array aggregate with no $others$ part is translated as the union of functions with a singleton range, and with a domain formed by representing the aggregate choice as a union of singleton sets or integer intervals:
For example,
=GFT
		ARR'(MON .. THU | FRI => WED, SAT | SUN => TUE);
=TEX
is translated as
=GFT
		((MON .. THU) ¿ {FRI} ∏ {WED}) ¿ ({SAT, SUN} ∏ {TUE}).
=TEX

An $others$ part is represented by a total function on the index set of the array with a singleton range.
This is overridden with the translation of the rest of the aggregate (if any)
For example,
=GFT
		ARR'(others=>MON)
=TEX
is translated as
=GFT
		(ARRvRANGE ∏ {MON}),
=TEX
and
=GFT
		ARR'(SAT, SUN, others=>MON)
=TEX
is translated as
=GFT
		(ARRvRANGE ∏ {MON}) ´ (succ Á 1 - ARRvFIRST Í ª ßSAT, SUN¢).
=TEX

\subsection{Unary Expressions}\label{Unary}

Unary plus is simply discarded in the translation.
I.e., $+Exp$ is translated in the same way as $Exp$.

Other unary expressions are translated into an application of a Z function representing the operator to the translation of the operand.
The Z functions representing the operators are either taken from the Z library or are defined in the theory $cn$ described in chapter \ref{cn}.

\subsection{Binary Expressions}\label{Binary}

Binary expressions are translated into an application of an infix Z function representing the operator to the translated operands.
The Z functions representing the operators are either taken from the Z library or are defined in the theory $cn$ described in chapter \ref{cn}.
For example,
=INLINEFT
not(abs (-2) = (1 + y))
=TEX
\ is translated as
=INLINEFT
not (abs (~ 2) eq (1 + Y))
=TEX
.

\subsection{Membership}\label{Membership}

Membership of a range is treated in the same way as the binary expressions
and is supported by the operators $mem$ and $notmem$ in the theory $cn$ described in chapter \ref{cn}.

\subsection{Indexed Components}\label{Indexed}
An indexed component with a one-dimensional index is translated into a Z function application of the function representing the array to the translation of the index expression.
For example,
=INLINEFT
ArrVar(3)
=TEX
\ is translated as
=INLINEFT
ARRVAR 3
=TEX
.
Indexed components with multi-dimensional indices are not handled formally and have no translation.

(Note: the above description does not apply to a one-dimensional indexed component appearing as the left-hand side of an assignment statement.
Such an assignment is effectively treated as an assignment of an aggregate value to the whole array, see section \ref{Assignment}.)
\subsection{Selected Components}\label{Selected}
Selection of a component from a record is translated into Z component selection.
For example,
=INLINEFT
RecVar.START
=TEX
\ is translated as
=INLINEFT
RECVAR.START
=TEX
.

(Note: the above description does not apply to a selected component appearing as the left-hand side of an assignment statement.
Such an assignment is effectively treated as an assignment of an aggregate value to the whole record, see section \ref{Assignment}.)

\subsection{Function Calls}\label{Function}
A function call using either positional or named argument association translates into a Z function application.
For example,
both 
=INLINEFT
MAX(y=>THU, x=>FRI)
=TEX
\ and
=INLINEFT
MAX(FRI, THU)
=TEX
\ are translated as
=INLINEFT
MAX(FRI, THU)
=TEX
.
A call of a function with neither global dependencies or arguments is translated as a Z global variable, for example
=INLINEFT
CONST
=TEX
\ is translated as
=INLINEFT
CONST
=TEX
.
If a function has global dependencies, then these are formed into
a tuple (if there is more than one), and become an extra argument to
the Z function call.
For example, the function calls
=INLINEFT
SUMXY
=TEX
\ and
=INLINEFT
XPLUSY(42)
=TEX
\ are translated as
=INLINEFT
SUMXY(X, Y)
=TEX
\ and
=INLINEFT
PLUSX X 42
=TEX
\ respectively.
\subsection{Qualified Expressions}\label{Qualified}
A qualified expression is translated in the same way as its operand.
For example,
=INLINEFT
NATURAL'(4)
=TEX
\ is translated as
=INLINEFT
4
=TEX
.
\subsection{Type Conversions}\label{Type}
A type conversion is translated in the same way as its operand provided both the operand and the result have integer types.
For example,
=INLINEFT
NATURAL(4)
=TEX
\ is translated as
=INLINEFT
4
=TEX
.
Type conversions other than between integer types cannot be handled formally and are not translated.

\section{Translation of Declarations}\label{ToD}


\subsection{Enumeration Types}\label{ET}

An enumeration type is represented in Z as a range of integers starting at $0$.
Global variables are introduced corresponding to the type name, the enumeration literals and the supported attributes of the type.

For example, the enumeration type declaration:

=GFT
	type ENUM_TYPE is (LIT1, LIT2, LIT3);
=TEX

is translated into a sequence of abbreviation definitions as follows:

=GFT
‹	LIT1 ¶ 0
‹	LIT2 ¶ 1
‹	LIT3 ¶ 2
‹	ENUM_TYPE ¶ LIT1 .. LIT3
‹	ENUM_TYPEvFIRST ¶ LIT1
‹	ENUM_TYPEvLAST ¶ LIT3
‹	ENUM_TYPEvSUCC ¶ (ENUM_TYPE \ {ENUM_TYPEvLAST}) Ú succ
‹	ENUM_TYPEvPRED ¶ ENUM_TYPEvSUCC Á~Í
‹	ENUM_TYPEvPOS ¶ id ENUM_TYPE
‹	ENUM_TYPEvVAL ¶ ENUM_TYPEvPOS Á~Í
=TEX 

\subsection{Array Types}\label{AT}

\subsubsection{Constrained Array Types}

A constrained array type is represented as a set of total functions.
Z global variables are introduced corresponding to the type name and the supported attributes of the type.
The attributes are only supported for one-dimensional arrays.

For example, the one-dimensional array type:
=GFT
	type ARRAY_TYPE is array (INDEX_TYPE) of ELEMENT_TYPE;
=TEX
is translated into a sequence of abbreviation definitions as follows:
=GFT
‹	ARRAY_TYPE ¶ INDEX_TYPE ≠ ELEMENT_TYPE
‹	ARRAY_TYPEvFIRST ¶ INDEX_TYPEvFIRST
‹	ARRAY_TYPEvLAST ¶ INDEX_TYPEvLAST
‹	ARRAY_TYPEvLENGTH ¶ # INDEX_TYPE
‹	ARRAY_TYPEvRANGE ¶ INDEX_TYPE
=TEX
A 2-dimensional array type:
=GFT
	type ARRAY_TYPE2 is
		array (INDEX_TYPE1, INDEX_TYPE2) of ELEMENT_TYPE;
=TEX
is translated into the single abbreviation definition:
=GFT
‹	ARRAY_TYPE2 ¶ INDEX_TYPE1 ∏ INDEX_TYPE2 ≠ ELEMENT_TYPE
=TEX

\subsubsection{Unconstrained Array Types}\label{UAT}
An unconstrained array type is represented as a set of total functions.
For example, the unconstrained array type:
=GFT
	type ARRAY_TYPE3 is array (INDEX_TYPE range <>) of ELEMENT_TYPE;
=TEX
is translated as:
=GFT
‹	ARRAY_TYPE3 :  (INDEX_TYPE ﬂ ELEMENT_TYPE)
=TEX
\subsection{Integer Types}\label{IT}
An integer type declaration is represented as a range of integers.
Z global variables are introduced corresponding to the type name and the supported attributes of the type.
The attributes that are functions have Z signatures but no defining properties (since the defining properties are compiler-dependent as regards arithmetic overflow).


For example, the integer type declaration:

=GFT
	type INTEGER_TYPE is range -1000 .. 1000;
=TEX

is translated as the sequence of abbreviation definitions:
Z global variables are introduced corresponding to the type name and the supported attributes of the type.

=GFT
‹	INTEGER_TYPE ¶ ~ 1000 .. 1000
‹	INTEGER_TYPEvFIRST ¶ ~ 1000
‹	INTEGER_TYPEvLAST ¶ 1000
=TEX

followed by the sequence of axiomatic descriptions:

=GFT
‹	INTEGER_TYPEvSUCC : ˙ ﬂ ˙
‹	INTEGER_TYPEvPRED : ˙ ﬂ ˙
‹	INTEGER_TYPEvPOS : ˙ ﬂ ˙
‹	INTEGER_TYPEvVAL : ˙ ﬂ ˙
=TEX

\subsection{Real Types}\label{RT}

A real type (floating point or fixed point) is represented as a given set.

For example, the real type declaration:

=GFT
	type REAL_TYPE is delta 0.1 range 1.0 .. 10.0;
=TEX

is translated as

=GFT
‹	[REAL_TYPE]
=TEX

\subsection{Subtypes}\label{ST}
\subsubsection{Integer Subtypes}\label{IST}
An integer subtype is represented as a range of integers.
Z global variables are introduced corresponding to the type name and the supported attributes of the type.
The attributes are defined to be equal to the corresponding attributes of the base type.

For example, the subtype declaration:

=GFT
	subtype INTEGER_SUBTYPE is INTEGER_TYPE range -10 .. 10;
=TEX
is translated as the sequence of abbreviation definitions:

=GFT
‹	INTEGER_SUBTYPE ¶ ~ 10 .. 10
‹	INTEGER_SUBTYPEvFIRST ¶ ~ 10
‹	INTEGER_SUBTYPEvLAST ¶ 10
‹	INTEGER_SUBTYPEvSUCC ¶ INTEGER_TYPEvSUCC
‹	INTEGER_SUBTYPEvPRED ¶ INTEGER_TYPEvPRED
‹	INTEGER_SUBTYPEvPOS ¶ INTEGER_TYPEvPOS
‹	INTEGER_SUBTYPEvVAL ¶ INTEGER_TYPEvVAL
=TEX
\subsubsection{Array Subtypes}\label{AST}
A array subtype, i.e. an subtype with an index constraint, is represented as an appropriate subset of the set of functions which represents the base type.
Z global variables are introduced corresponding to the type name and the supported attributes of the type.
The attributes are only supported for one-dimensional arrays.

For example, the subtype declaration:

=GFT
	   subtype ARRAY_SUBTYPE is ARRAY_TYPE3(INDEX_TYPE);
=TEX

is translated as:

=GFT
‹	ARRAY_SUBTYPE ¶ {array : ARRAY_TYPE3 | dom array = INDEX_TYPE}
‹	ARRAY_SUBTYPEvFIRST ¶ INDEX_TYPEvFIRST
‹	ARRAY_SUBTYPEvLAST ¶ INDEX_TYPEvLAST
‹	ARRAY_SUBTYPEvLENGTH ¶ # INDEX_TYPE
‹	ARRAY_SUBTYPEvRANGE ¶ INDEX_TYPE
=TEX

For a multi-dimensional array, the domain in the first abbreviation definition is given by an appropriate cartesian product and the attributes are not introduced.

\subsubsection{Other Subtypes}
Unconstrained subtypes have type attributes introduced for each
of the type attributes of the base type of the subtype.
Otherwise, subtypes of forms other than those discussed in section \ref{IST} and \ref{AST} above are represented as given sets in a similar way to real types as described in section \ref{RT}.

\subsection{Constant Declarations}\label{TCD}

An Ada constant is represented in Z as a global variable.
The form of definition for this global variable depends on whether the 
defining expression for the constant can be handled formally.
 
Provided $EXPRESSION$ can be handled formally, the constant declaration:

=GFT
	CONST_NAME : constant TYPE_NAME := EXPRESSION
=TEX

is translated as the abbreviation definition:

=GFT
	CONST_NAME ¶ EXPRESSION
=TEX

If $EXPRESSION$ cannot be handled formally, the constant declaration above would be translated as the axiomatic description:

=GFT
‹	CONST_NAME : TYPE_NAME
=TEX

A constant declaration defining more than one constant is treated as the equivalent sequence of single-constant declarations.

\subsection{Function Specifications}\label{TFS}
An Ada function is represented in Z as a global variable defined via an axiomatic description.
The form of the axiomatic description depends on whether or not the function is a formal function (i.e., whether or not the function specification includes a function specification statement).

An informal function (i.e., a function without a function specification statement) is translated into a member of the given set
=INLINEFT
INFORMAL_FUNCTION
=TEX
.
Informal functions have no defining property and are only translated into Z to prevent their use in expressions in the formal parts of a Compliance Notation script.
For example, a function specified as:

=GFT
function INF_FUN (A : in INTEGER) return INTEGER;
∞

is translated into Z as:

=GFT
‹ INF_FUN : INFORMAL_FUNCTION
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ true
=TEX
A formal function is translated into a global variable whose type is derived from the global dependencies, formal parameters and return type of the function and whose defining property is derived from the pre- and post-conditions in the function specification statement.
For example, the functions specified as follows:

=GFT
function FORM_FUN_00 return RTYPE
ò [ FORM_FUN_00 = 100 ]
function FORM_FUN_01 (A : PTYPE) return RTYPE
ò [ FORM_FUN_01 A = A * A ]
function FORM_FUN_10 return RTYPE
ò G [ G > 0, FORM_FUN_10 G = G ]
function FORM_FUN_23 (A, B, C : PTYPE) return RTYPE
ò G, H [ H > 0, FORM_FUN_23 (G, H) (A, B, C) = G + H + A + B + C ]
=TEX
are translated into the following axiomatic descriptions.
=GFT
‹ FORM_FUN_00 : RTYPE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ true ¥ FORM_FUN_00 = 100
=TEX
=GFT
‹ FORM_FUN_01 : PTYPE ≠ RTYPE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ A : PTYPE ∑ true ¥ FORM_FUN_01 A = A * A
=TEX
=GFT
‹ FORM_FUN_10 : GTYPE ≠ RTYPE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ G : GTYPE ∑ G > 0 ¥ FORM_FUN_10 G = G
=TEX
=GFT
‹ FORM_FUN_23 : GTYPE ∏ HTYPE ≠ PTYPE ∏ PTYPE ∏ PTYPE ≠ RTYPE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ G : GTYPE; H : HTYPE
‹   ∑ µ A, B, C : PTYPE
‹     ∑ H > 0 ¥ FORM_FUN_23 (G, H) (A, B, C) = G + H + A + B + C
=TEX
\section{VC Generation}\label{VCG}
\HOLindexOff % - stays off throughout most of this section 

A number of language constructs give rise to VCs.
These constructs are as follows.

\begin{enumerate}
%vcs_speclabel:
\item \label{VCRefStep}
A refinement step gives rise to VCs demanding that the sequence of statements on the right-hand side of the refinement symbol correctly implements the specification statement being refined.
\item \label{VCSubProgBody}
A subprogram body with a formal subprogram specification gives rise to VCs demanding that the sequence of statements in the body correctly implements the specification statement in the subprogram specification.
\item \label{VCSubProgPackBody}
If a subprogram specification in a package body and the corresponding subprogram specification in the package declaration are both formal, then VCs are generated demanding that the specification statement in the package body correctly implements the one in the package declaration.
\item \label{VCSubunit}
If a subprogram specification in a subunit and the corresponding subprogram specification in the corresponding body stub are both formal, then VCs are generated demanding that the specification statement in the subunit correctly implements the one in the body stub.
\item \label{VCPackInit}
A package body which implements a package containing using declarations gives rise to VCs demanding that the package initialisation statements establishes the invariants given in the using declarations.
\item \label{VCType}
If it cannot be determined whether a range in a type definition is non-empty, a VC is generated asserting that the type is non-empty, this VC always has the form
=INLINEFT
Ù TYPENAME Ω ö
=TEX
. 
\end{enumerate}

The first four forms of VC generation in the above list are concerned with one or more specification statements.
A specification statement is a general means for making assertions about program state changes.
The specification statement with frame variables
=INLINEFT
A, B, C ...
=TEX
:

=GFT
	Ñ A, B, C ... [PRE_CONDITION, POST_CONDITION]
=TEX
\ effectively denotes the set of all pairs $(S\sb{1}, S\sb{2})$ where: each $S\sb{i}$ is a program state; the pre-condition holds in $S\sb{1}$; the post-condition holds in $S\sb{2}$; and $S\sb{1}$ and $S\sb{2}$ only differ with respect to the values of the frame variables
=INLINEFT
A, B, C ...
=TEX
\ (but see also the remarks about replacement steps which declare new local variables in section \ref{15}).
In the post-condition the initial values of the frame variables may be referred to by adding a subscript $0$ to the name.
For example, the specification statement:

=GFT
	Ñ A [true, A = Aâ0 + 1]
=TEX
\ asserts that the integer variable $A$ should be increased by $1$.

The Compliance Notation VC generation algorithm is based on the notion of {\em partial correctness}.
If all VCs of a refinement step can be proved, then at run-time, the refining code either meets its specification or fails to terminate.
The soundness of the algorithm requires that the script conform to the rules in chapter \ref{SYNTAX} above and that the SPARK program generated from the script conforms to the rules of the ALRM.


The form of VCs generated for refinement steps involving the various forms of statement are described, by means of symbolic examples, in sections~\ref{Null} to \ref{LogicalConstant} below.
Sections~\ref{SubprogramBody} to \ref{RangeInTypeDefinition} below give symbolic examples for the other kinds of VC generation.

\Hide{%
=SML
map (fn thy => ( force_delete_theory thy handle Fail _ => () ))
	(get_descendants "cn" less "cn" diff get_cache_theories());
open_theory"cn";
new_theory"usr504aux";
=TEX
We will need a supply of symbolic pre- and post-conditions.
We use generic sets for these purposes.
It is pleasant to use prefix syntax for membership of the generic sets:
πZ
‹ rel	PRE _ ,		POST _,		PRE1 _ ,	POST1 _,
‹	PRE2 _,		POST2 _,		PRE3 _ ,	POST3 _,
‹	TILL _,		COND _,		APRE _ ,	APOST _,
‹	CPRE _,		CPOST _,	INV _,	SPRE _,
‹	SPOST _, IPRE _, IPOST _
∞
∞
ù[ X ]úúúúúúúúúúú
‹	PRE _,		POST _,		PRE1 _, 	POST1 _,
‹	PRE2 _,		POST2 _,		PRE3 _, 	POST3 _,
‹	TILL _,		COND _,		APRE _ ,	APOST _,
‹	CPRE _,		CPOST _,	INV _,	SPRE _,
‹	SPOST _, IPRE _, IPOST _			:  X
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=TEX
The following package introduces functions which we will need.
It reduces clutter to define these functions here rather than inside the subprograms which use them.
Here and throughout this document, red-tape commands to {\Product} have been suppressed from the printed document in the interests of clarity.
=SML
new_script1 {name="usr504pack", state=initial_cn_state, 	
	library_theories=["usr504aux"]};
=TEX
πCN
 package FUNS
 is
    function TEST (A : INTEGER) return BOOLEAN
     ò [COND (A, TEST(A))] ;
    function COMPUTE (A : INTEGER) return INTEGER
     ò [COND (A, COMPUTE(A))] ;
 end FUNS;
∞
The following Standard ML command is used to set up the tool to process each of the many other little Compliance Notation scripts given in this document.
Note that it ensures that ``usr504aux'' is a parent of any theories created.
=SML
val usr504_state = get_cn_state();
val wanted_thys = get_descendants"cn";
fun ns (script : string) : unit = (
	map (fn thy => ( force_delete_theory thy handle Fail _ => () ))
	(get_descendants "cn" diff (get_cache_theories() cup wanted_thys));
	new_script1 {name=script, state=usr504_state,
		 library_theories=["usr504aux"]}
);
=TEX
}
\newpage
\subsection{Null Statement}\label{Null}
\subsubsection*{Compliance Notation Script: Null Statement}
\Hide{%
=SML
ns"usr504x01";
=TEX
}
πCN
 procedure vc_null
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(111)
 end vc_null;
∞
πCN
 (111) √ NULL;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x01.th.doc", theory="usr504x01"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x01.th}
\subsubsection*{Notes}
A null statement can only achieve its specification if the pre-condition
already implies the post-condition so that no action needs to be taken.
\newpage
\subsection{Assignment Statement}\label{Assignment}
\subsubsection*{Compliance Notation Script: Assignment: Case 1}
\Hide{%
=SML
ns"usr504x02";
=TEX
}
πCN
 procedure vc_assignment1
 is
    LHS, RHS : INTEGER;
 begin
  Ñ LHS [ PRE (LHS, RHS), POST (LHS, RHS, LHSâ0) ]		(211)
 end vc_assignment1;
∞
πCN
 (211) √ LHS := RHS;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x02.th.doc", theory="usr504x02"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x02.th}
%\subsubsection*{Notes}
%\cite[vol. 2]{DRA/CIS/CSE3/TR/94/27/2.1}.
\newpage
\subsubsection*{Compliance Notation Script: Assignment: Case 2}
\Hide{%
=SML
ns"usr504x03";
=TEX
}
πCN
 procedure vc_assignment2
 is
    type REC_AB is record A: INTEGER; B : INTEGER; end record;
    LHS : REC_AB;
    RHS : INTEGER;
 begin
  Ñ LHS [ PRE (LHS, RHS), POST (LHS, RHS, LHSâ0) ]		(221)
 end vc_assignment2;
∞
πCN
 (221) √ LHS.A := RHS;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x03.th.doc", theory="usr504x03"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x03.th}
\subsubsection*{Notes}
Assignment to a record component results in a Z binding display in the VC.
\newpage
\subsubsection*{Compliance Notation Script: Assignment: Case 3}
\Hide{%
=SML
ns"usr504x04";
=TEX
}
πCN
 procedure vc_assignment3
 is
    type TRIAD is (ONE, TWO, THREE);
    type ARRAY3 is array (TRIAD) of INTEGER;
    LHS : ARRAY3;
    RHS : INTEGER;
    INDEX : TRIAD;
 begin
  Ñ LHS [ PRE (LHS, RHS), POST (LHS, RHS, LHSâ0) ]		(231)
 end vc_assignment3;
∞
πCN
 (231) √ LHS(INDEX) := RHS;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x04.th.doc", theory="usr504x04"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x04.th}
\subsubsection*{Notes}
Assignment to an array element results in a singleton override on the Z function representing the array in the VC.
\newpage
\subsubsection*{Compliance Notation Script: Assignment: Case 4}
\Hide{%
=SML
ns"usr504x05";
=TEX
}
πCN
 procedure vc_assignment4
 is
    type REC_XY is record X : INTEGER; Y : INTEGER; end record;
    type DYAD is (EINS, ZWEI);
    type ARRAY2_REC is array (DYAD) of REC_XY;
    LHS : ARRAY2_REC;
    RHS : INTEGER;
    INDEX : DYAD;
 begin
  Ñ LHS [ PRE (LHS, RHS), POST (LHS, RHS, LHSâ0) ]		(241)
 end vc_assignment4;
∞
πCN
 (241) √ LHS(INDEX).X := RHS;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x05.th.doc", theory="usr504x05"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x05.th}
\subsubsection*{Notes}
Assignments with more complex right hand-sides produce a mixture of binding displays and singleton overrides in the VC.
\newpage
\subsubsection*{Compliance Notation Script: Assignment: Case 5}
\Hide{%
=SML
ns"usr504x20";
=TEX
}
πCN
 procedure vc_assignment5
 is
    type DYAD is (EINS, ZWEI);
    type ARRAY2_INT is array (DYAD) of INTEGER;
    type REC_AB is record A : ARRAY2_INT; B : ARRAY2_INT; end record;
    LHS : REC_AB;
    RHS : INTEGER;
    INDEX : DYAD;
 begin
  Ñ LHS [ PRE (LHS, RHS), POST (LHS, RHS, LHSâ0) ]		(251)
 end vc_assignment5;
∞
πCN
 (251) √ LHS.A(INDEX) := RHS;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x20.th.doc", theory="usr504x20"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x20.th}
\subsubsection*{Notes}
Assignments with more complex right hand-sides produce a mixture of binding displays and singleton overrides in the VC.
\newpage
\subsection{Specification Statement}\label{Specification}
\subsubsection*{Compliance Notation Script: Specification Statement}
\Hide{%
=SML
ns"usr504x06";
=TEX
}
πCN
 procedure vc_specification
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST (X, Xâ0) ]		(311)
 end vc_specification;
∞
πCN
 (311) √  Ñ X [ PRE1 X, POST1 (X, Xâ0) ] (312)
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x06.th.doc", theory="usr504x06"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x06.th}
\subsubsection*{Notes}
Note that $PRE$ rather than $PRE1$ appears in the second VC.
Since the first VC requires $PRE$ to be at least as strong $PRE1$ this is no loss, and could be a gain.

\newpage
\subsection{Semicolon}\label{Sequence of Statements}
\subsubsection*{Compliance Notation Script: Sequence of Statements}
\Hide{%
=SML
ns"usr504x07";
=TEX
}
πCN
 procedure vc_sequence_of_statements
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST (X, Xâ0) ]		(411)
 end vc_sequence_of_statements;
∞
πCN
 (411) √	Ñ X [ PRE1 X, POST1 (X, Xâ0) ] (412)
		Ñ X [ PRE2 X, POST2 X ] (413)
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x07.th.doc", theory="usr504x07"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x07.th}
\subsubsection*{Notes}

It is not permitted to refer to initial values of variables in the second statement.

The intermediate post-condition $POST1$ only as appears as part of the assumptions under which the second VC requires us to prove $PRE2$.
If $POST1$ or some part of $POST1$ is needed in $POST$, then it must be included in $POST2$ and $PRE2$.

\Hide{%
This construct is referred to as ``semicolon'' in \cite[vol. 2]{DRA/CIS/CSE3/TR/94/27/2.1}; we have reverted to the official Ada terminology, because no semicolon actually appears when both statements are specification statements.
}

\newpage
\subsection{If Statement}\label{If}
\subsubsection*{Compliance Notation Script: If Statement}
\Hide{%
=SML
ns"usr504x08";
=TEX
}
πCN
with FUNS;
 procedure vc_if
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(511)
 end vc_if;
∞
πCN
 (511) √	if FUNS.TEST(X)
		then	Ñ X [ PRE1 X, POST1 X ] (512)
		else	Ñ X [ PRE2 X, POST2 X ] (513)
		end if;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x08.th.doc", theory="usr504x08"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x08.th}
\subsubsection*{Notes}
Initial variables are not allowed in the arms of the if statement.

If the $else$ part is omitted then $POST$ appears in the second VC in place of $PRE2$ and the fourth VC does not appear.
\newpage
\subsection{Case Statement}\label{Case}
\subsubsection*{Compliance Notation Script: Case Statement}
\Hide{%
=SML
ns"usr504x09";
=TEX
}
πCN
with FUNS;
 procedure vc_case
 is
    type T_CASE is range 1 .. 9;
    X : T_CASE;
 begin
  Ñ X [ PRE X, POST X ]		(611)
 end vc_case;
∞
πCN
 (611) √	case T_CASE(FUNS.COMPUTE(X)) is
		when 1 =>			Ñ X [ PRE1 X, POST1 X ] (612)
		when 5 .. 7 =>		Ñ X [ PRE2 X, POST2 X ] (613)
		when 2 .. 4 | 8 | 9  =>	Ñ X [ PRE3 X, POST3 X ] (614)
		end case;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x09.th.doc", theory="usr504x09"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x09.th}
\subsubsection*{Notes}
Initial variables are not allowed in the specification statements in the arms of the case statement.

If the fact that the case expression is in one of the ranges is needed in the corresponding arm, then that needs to be stated in the pre-condition for that arm.
(E.g. if we need to know that the expression is $1$ in the first arm here, we need to say that in $PRE1$).

\newpage
\subsection{Undecorated Loop Statement}\label{Undecorated}
\subsubsection*{Compliance Notation Script: Undecorated Loop Statement}
\Hide{%
=SML
ns"usr504x10";
=TEX
}
πCN
 procedure vc_undecorated_loop
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(711)
 end vc_undecorated_loop;
∞
πCN
 (711) √	till ˚ TILL X ˝ 
		loop
		   Ñ X [ PRE1 X, POST1 X ] (712)
		end loop;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x10.th.doc", theory="usr504x10"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x10.th}
\subsubsection*{Notes}
If the till predicate is omitted, then the last VC is not produced (and there is no formally handled way of leaving the loop, since an $exit$ statement is not allowed in a loop with no till predicate).

\newpage
\subsection{While Loop Statement}\label{While}
\subsubsection*{Compliance Notation Script: While Loop Statement}
\Hide{%
=SML
ns"usr504x11";
=TEX
}
πCN
with FUNS;
 procedure vc_while_loop
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(811)
 end vc_while_loop;
∞
πCN
 (811) √	while FUNS.TEST(X) till ˚ TILL X ˝
		loop
		   Ñ X [ PRE1 X, POST1 X ] (812)
		end loop;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x11.th.doc", theory="usr504x11"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x11.th}
\subsubsection*{Notes}
If the till predicate is omitted, then the last VC is not produced.
\newpage
\subsection{For Loop Statement}\label{For}
\subsubsection*{Compliance Notation Script: For Loop Statement: Case 1}
\Hide{%
=SML
ns"usr504x12";
=TEX
}
πCN
 procedure vc_for_loop1
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(911)
 end vc_for_loop1;
∞
πCN
 (911) √	for I in INTEGER range 1 .. 10 till ˚ TILL (X, I) ˝
		loop
		   Ñ X [ PRE1 (X, I) , POST1 (X, I) ] (912)
		end loop;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x12.th.doc", theory="usr504x12"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x12.th}
\subsubsection*{Notes}
If the till predicate is omitted, then the last VC is not produced.
\newpage
\subsubsection*{Compliance Notation Script: For Loop Statement: Case 2}
\Hide{%
=SML
ns"usr504x13";
=TEX
}
πCN
 procedure vc_for_loop2
 is
    type T_FOR_LOOP2 is range 1 .. 10;
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(921)
 end vc_for_loop2;
∞
πCN
 (921) √	for I in T_FOR_LOOP2 till ˚ TILL (X, I) ˝
		loop
		  Ñ X [ PRE1 (X, I), POST1 (X, I) ] (922)
		end loop;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x13.th.doc", theory="usr504x13"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x13.th}
\subsubsection*{Notes}
If the till predicate is omitted, then the last VC is not produced.
=TEX
\newpage
\subsection{Exit Statement}\label{Exit}
\subsubsection*{Compliance Notation Script: Exit Statement: Case 1}
\Hide{%
=SML
ns"usr504x14";
=TEX
}
πCN
with FUNS;
 procedure vc_exit1
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(1011)
 end vc_exit1;
∞
πCN
 (1011) √	for I in INTEGER range 1 .. 10 till ˚TILL X˝
		loop
		   Ñ X [ PRE1 (X, I), POST1 (X, I) ]		(1012)
		end loop;
∞
\Hide{%
=SML
(map delete_conjecture (flat (map fst  (get_conjectures"-"))); ());
=TEX
}
πCN
 (1012) √	Ñ X[PRE2 X, POST2 X]
		exit when FUNS.TEST(X);
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x14.th.doc", theory="usr504x14"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x14.th}
\subsubsection*{Notes}
For clarity, the VCs from the first refinement step are not shown above.

The till predicate must not be omitted 

If the statement before the exit is omitted the first VC does not appear.
\newpage
\subsubsection*{Compliance Notation Script: Exit Statement: Case 2}
\Hide{%
=SML
ns"usr504x15";
=TEX
}
πCN
with FUNS;
 procedure vc_exit2
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(1021)
 end vc_exit2;
∞
πCN
 (1021) √	for I in INTEGER range 1 .. 10 till ˚TILL X˝
		loop
		   Ñ X [ PRE1 (X, I), POST1 (X, I) ]		(1022)
		end loop;
∞
\Hide{%
=SML
(map delete_conjecture (flat (map fst  (get_conjectures"-"))); ());
=TEX
}
πCN
 (1022) √	if FUNS.TEST(X)
		then	Ñ X[PRE2 X, POST2 X]
			exit;
		end if;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x15.th.doc", theory="usr504x15"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x15.th}
\subsubsection*{Notes}
For clarity, the VCs from the first refinement step have been omitted.

The till predicate must not be omitted.

If the statement before the exit is omitted the first VC does not appear.
\newpage
\subsection{Return Statement}\label{Return}
\subsubsection*{Compliance Notation Script: Return Statement: Case 1}
\Hide{%
=SML
ns"usr504x16";
=TEX
}
πCN
with FUNS;
 function vc_return1 (A : INTEGER) return INTEGER
 ò [PRE A, POST (A, VC_RETURN1(A))]
 is
 begin
  return FUNS.COMPUTE(A);
 end vc_return1;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x16.th.doc", theory="usr504x16"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x16.th}
\newpage
\subsubsection*{Compliance Notation Script: Return Statement: Case 2}
\Hide{%
=SML
ns"usr504x17";
=TEX
}
πCN
with FUNS;
 function vc_return2 (A : INTEGER) return INTEGER
 ò [PRE A, POST (A, VC_RETURN2(A))]
 is
 begin
     Ñ  [ PRE1 A , false ]   (1121)
 end vc_return2;
∞
πCN
 (1121) √ return FUNS.COMPUTE(A);
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x17.th.doc", theory="usr504x17"};
=TEX
}
\subsubsection*{Generated VCs}
\input{usr504x17.th}
\subsubsection*{Notes}
The post-condition for the body of a function can be $false$ since control never returns from the body (instead, control returns to the caller of the function when the return statement is executed).
By using $false$ we ensure that the second VC is a tautology.
=TEX
\newpage
\subsection{Procedure Call Statement}\label{Procedure}
\subsubsection*{Compliance Notation Script: Procedure Call Statement}
\Hide{%
=SML
ns"usr504x18";
=TEX
}
πCN
 procedure vc_procedure_call
 is
    procedure PROC (A : in out INTEGER)
     Ñ [PRE1 A, PRE1 (Aâ0, A)]
    is separate;
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(1211)
 end vc_procedure_call;
∞
πCN
 (1211) √  PROC(X);
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x18.th.doc", theory="usr504x18"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x18.th}
\newpage
\subsection{Logical Constant Statement}\label{LogicalConstant}
\subsubsection*{Compliance Notation Script: Logical Constant Statement}
\Hide{%
=SML
ns"usr504x19";
=TEX
}
πCN
 procedure vc_logical_constant
 is
    X : INTEGER;
 begin
  Ñ X [ PRE X, POST X ]		(1311)
 end vc_logical_constant;
∞
πCN
 (1311) √	CON X_INIT : ˙∑
			Ñ X [X_INIT = X ± PRE1 X, POST1(X, X_INIT)] (1312)
∞
πCN
 (1312) √	Ñ X [ PRE2 X, POST2(X, X_INIT)] (1313)
		Ñ X [ PRE3(X, X_INIT), POST3(X, X_INIT)] (1314)
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x19.th.doc", theory="usr504x19"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x19.th}
\subsubsection*{Notes}
A refinement of the logical constant statement into a sequence of statements i
s shown to illustrate how the statement may be used to capture an initial value.
\newpage
\subsection{Subprogram Body}\label{SubprogramBody}
\subsubsection*{Compliance Notation Script: Subprogram Body: Case 1 (Procedure)}
\Hide{%
=SML
ns"usr504x21";
=TEX
}
πCN
 procedure vc_procedure_body(X : in out INTEGER)
 Ñ X[ PRE X, POST X ]
 is
    Y : INTEGER := 0;
 begin
  Ñ X [ PRE1 (X, Y), POST1 (X, Y) ]
 end vc_procedure_body;
∞

\Hide{%
=SML
z_output_theory{out_file="usr504x21.th.doc", theory="usr504x21"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x21.th}
\subsubsection*{Notes}
This shows the VCs generated for a formal procedure body.
The VCs assert that the sequence of statements in the body
(given in the example as a single specification statement)
refines the specification statement in the procedure specification.
Equations derived from any initial values in variable declarations in the subprogram are conjoined with the pre-condition, $PRE\,X$. 

If the body contains one or more program statements then the VCs generated are similar to those generated if the statements were used to implement the specification statement in a refinement step as described in sections~\ref{Null} to~\ref{LogicalConstant} above.
\newpage
\subsubsection*{Compliance Notation Script: Subprogram Body: Case 2 (Function)}
\Hide{%
=SML
ns"usr504x22";
=TEX
}
πCN
 function vc_function_body(X : in INTEGER) return INTEGER
 ò X[ PRE X, POST (X, VC_FUNCTION_BODY X) ]
 is
    Y : INTEGER;
 begin
  Ñ Y [ PRE1 (X, Y), POST1 (X, Y) ]
 end vc_function_body;
∞

\Hide{%
=SML
z_output_theory{out_file="usr504x22.th.doc", theory="usr504x22"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x22.th}
\subsubsection*{Notes}
This shows the VCs generated for a formal function body.
The VCs assert that the sequence of statements in the body
(given in the example as a single specification statement)
refines the specification statement in the function specification.

Here, and in further refinements of the sequence of statements, the function itself appears under a universal quantifier, so that the translation of the function as a Z global variable is not available inside the formal development of the function itself.
=TEX
\newpage
\subsection{Subprogram in Package Body}\label{SubprogramPackBody}
\subsubsection*{Compliance Notation Script: Subprogram in Package Body: Case 1}
\Hide{%
=SML
ns"usr504x23";
=TEX
}
πCN
 package vc_subprogram_pack_body1
 is
   X : INTEGER;
   procedure P
   Ñ X[ PRE X, POST X ] ;
 end vc_subprogram_pack_body1;
∞
\Hide{%
=SML
new_script1{name="usr504x24", state=get_cn_state(),
	library_theories=["usr504aux"]};
=TEX
}
πCN
 package body vc_subprogram_pack_body1
 is
   procedure P
   Ñ X[ PRE1 X, POST1 X ]
   is
   begin
   Ñ X[ PRE2 X, POST2 X]
   end P;
 end vc_subprogram_pack_body1;
∞

\Hide{%
=SML
val _ = map delete_conjecture
["vcVC_SUBPROGRAM_PACK_BODY1body_3",
 "vcVC_SUBPROGRAM_PACK_BODY1body_4"];
z_output_theory{out_file="usr504x24.th.doc", theory="usr504x24"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x24.th}
\subsubsection*{Notes}
The subprogram body in this example cause 2 additional VCs to be generated that are not shown here.
See sections~\ref{SubprogramBody} for these VCs.
\newpage
\subsubsection*{Compliance Notation Script: Subprogram in Package Body: Case 2}
\Hide{%
=SML
ns"usr504x25";
=TEX
}
πCN
package vc_subprogram_pack_body2
is
  auxiliary A : Ó;
  procedure P
  Ñ A [ APRE A, APOST A ] ;
end vc_subprogram_pack_body2;
∞
\Hide{%
=SML
new_script1{name="usr504x26", state=get_cn_state(),
	library_theories=["usr504aux"]};
=TEX
}
πCN
package body vc_subprogram_pack_body2
is
  using C : INTEGER; implement A by INV(A, C);
  procedure P
  Ñ C [ CPRE  C, CPOST C ]
  is begin
   Ñ C [ SPRE C, SPOST C] (1)
  end P;
begin
  Ñ C[IPRE C, IPOST C] (2)
end vc_subprogram_pack_body2;
∞

\Hide{%
=SML
val _ = map delete_conjecture
["vcVC_SUBPROGRAM_PACK_BODY2body_3",
 "vcVC_SUBPROGRAM_PACK_BODY2body_4",
 "vcVC_SUBPROGRAM_PACK_BODY2body_5",
 "vcVC_SUBPROGRAM_PACK_BODY2body_6"];
z_output_theory{out_file="usr504x26.th.doc", theory="usr504x26"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x26.th}
\subsubsection*{Notes}
This example shows a
\HOLindexOn
=INLINEFT
€data refinement›
=TEX
\HOLindexOff
: the situation in which one or more auxiliary variables are used in the package specification to model the state of the package.
If the using clause is omitted, then the invariant $INV(A, C)$ does not appear in the VCs (which will typically not then be provable).

The subprogram body and the package initialisation in this example cause 4 additional VCs to be generated that are not shown here.
See sections~\ref{SubprogramBody} and~\ref{PackageInitialisation} for these VCs.
\newpage
\subsubsection*{Compliance Notation Script: Subprogram in Package Body: Case 3}
\Hide{%
=SML
ns"usr504x27";
=TEX
}
πCN
package vc_subprogram_pack_body3
is
  auxiliary A : Ó;
  procedure Q(X : in out INTEGER)
  Ñ X [APRE (A, X), APOST(A, X, Xâ0)] ;
end vc_subprogram_pack_body3;
∞
\Hide{%
=SML
new_script1{name="usr504x28", state=get_cn_state(),
	library_theories=["usr504aux"]};
=TEX
}
πCN
package body vc_subprogram_pack_body3
is
  using C : INTEGER; implement A by INV(A, C);
  procedure Q(X : in out INTEGER)
  Ñ X [CPRE C, CPOST(C, X, Xâ0)]
  is begin
   Ñ X [SPRE C, SPOST(C, X, Xâ0)] (1)
  end Q;
begin
  Ñ C[IPRE C, IPOST C] (2)
end vc_subprogram_pack_body3;
∞

\Hide{%
=SML
val _ = map delete_conjecture
["vcVC_SUBPROGRAM_PACK_BODY3body_3",
 "vcVC_SUBPROGRAM_PACK_BODY3body_4",
 "vcVC_SUBPROGRAM_PACK_BODY3body_5",
 "vcVC_SUBPROGRAM_PACK_BODY3body_6"];
z_output_theory{out_file="usr504x28.th.doc", theory="usr504x28"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x28.th}
\subsubsection*{Notes}
This case shows a data refinement in which a procedure specification does not refer to the auxiliary variables in its frame.
In this case, equations requiring that the procedure does not change the auxiliary variable are introduced.

The subprogram body and the package initialisation in this example cause 4 additional VCs to be generated that are not shown here.
See sections~\ref{SubprogramBody} and~\ref{PackageInitialisation} for these VCs.
\newpage
\subsection{Subunit}\label{Subunit}
\subsubsection*{Compliance Notation Script: Subunit}
\Hide{%
=SML
ns"usr504x29";
=TEX
}
πCN
procedure vc_subunit
is
  X : INTEGER;
  procedure P
  Ñ X[ PRE X, POST X ]
  is separate;
begin
  null;
end vc_subunit;
∞
\Hide{%
=SML
new_script1{name="usr504x30", state=get_cn_state(),
	library_theories=["usr504aux"]};
=TEX
}
πCN
 separate (vc_subunit)
 procedure P
   Ñ X[ PRE1 X, POST1 X ]
   is
   begin
   Ñ X[ PRE2 X, POST2 X]
   end P;
∞

\Hide{%
=SML
z_output_theory{out_file="usr504x30.th.doc", theory="usr504x30"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x30.th}
\subsubsection*{Notes}
The {\ProductML} command required to introduce the new script to contain the subunit has been suppressed for clarity.
The first two VCs assert that the subunit specification statement refines the specification statement in the stub.
The second two VCs arise from the subprogram body as in section~\ref{SubprogramBody}.

\newpage
\subsection{Package Initialisation}\label{PackageInitialisation}
\subsubsection*{Compliance Notation Script: Package Initialisation}
\Hide{%
=SML
ns"usr504x31";
=TEX
}
πCN
package package_initialisation
is
  auxiliary A : Ó;
  procedure Q(X : in out INTEGER)
  Ñ X [APRE (A, X), APOST(A, X, Xâ0)] ;
end package_initialisation;
∞
\Hide{%
=SML
new_script1{name="usr504x32", state=get_cn_state(),
	library_theories=["usr504aux"]};
=TEX
}
πCN
package body package_initialisation
is
  using C : INTEGER; implement A by INV(A, C);
  procedure Q(X : in out INTEGER)
  Ñ X [CPRE C, CPOST(C, X, Xâ0)]
  is begin
   Ñ X [SPRE C, SPOST(C, X, Xâ0)] (1)
  end Q;
begin
  Ñ C[IPRE C, IPOST C] (2)
end package_initialisation;
∞

\Hide{%
=SML
val _ = map delete_conjecture
["vcPACKAGE_INITIALISATIONbody_1",
"vcPACKAGE_INITIALISATIONbody_2",
"vcPACKAGE_INITIALISATIONbody_3",
"vcPACKAGE_INITIALISATIONbody_4"];
z_output_theory{out_file="usr504x32.th.doc", theory="usr504x32"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x32.th}
\subsubsection*{Notes}
The {\ProductML} command required to introduce the new script to contain the subunit has been suppressed for clarity.
The first 4 VCs generated by this example do not relate to the package initialisation and may be seen in cases 2 and 3 in section~\ref{SubprogramPackBody} above.
\newpage
\subsection{Range in Type Definition}\label{RangeInTypeDefinition}
\subsubsection*{Compliance Notation Script: Range in Type Definition}
\Hide{%
=SML
ns"usr504x33";
=TEX
}
πCN
procedure range_type
is
 type T3 is (ONE, TWO, THREE);
 subtype SUB is T3 range ONE .. T3'SUCC(ONE);
begin
 null;
end range_type;
∞
\Hide{%
=SML
z_output_theory{out_file="usr504x33.th.doc", theory="usr504x33"};
=TEX
}
=TEX
\subsubsection*{Generated VCs}
\input{usr504x33.th}
\subsubsection*{Notes}
Here, the heuristics used in the attempt to prove that the type $SUB$ is non-empty did not succeed (because of the use of the successor attribute) and a VC has been generated.
In normal use, the heuristics typically succeed in evaluating the bounds of the range and such a VC is not generated.
\newpage

\HOLindexOn
\section{Program Structure}\label{PS}
The Z paragraphs in a Z document produced by processing a Compliance Notation script are put in {\Product} theories so as to manage the namespace in a way which represents the Ada program structure.
For this to work correctly, the following rules are imposed:
{\em(a)} a script may contain at most one compilation unit,
and, {\em(b)}, a script delimits the scope of all the k-slots tags and specification statement tags it contains, i.e., the refinement,
replacement, or arbitrary replacement step that expands a tag must be given in
the same script as the k-slot or specification statement that introduced the
tag.


A theory, referred to as the {\em script theory} is created before the script is processed to hold any Z paragraphs in the script and the Z paragraphs that are generated directly by the type, constant and function definitions in the script together with the VCs generated for the script.

Processing of the various forms of library unit or secondary unit may cause other theories to be created indirectly as shown in table \ref{UoT}.
In this table, {\em PACKAGE} (resp. {\em UNIT}, {\em SUBUNIT}) stand for the name of the package (resp. {\em UNIT}, {\em SUBUNIT}) in question; {\em SCRIPT} stands for the name  of the script theory (determined by the function $new\_script$ or $new\_script1$ called by convention at the beginning of each script, see \CNUSERGUIDE). 

With one exception, all VCs generated during processing of a script are placed in the script theory.
The exception is the VC generated when it cannot be determined whether or not a range in a type declaration in a package declaration is non-empty.
The VC produced to assert the non-emptiness of such a range will appear in two places: {\em(i)} in the script theory for the script containing the package specification (i.e. the Internal Package Declaration, below),
and {\em(ii)} in the package specification theory ({\em PACKAGE}{\tt spec}) produced when the package is referenced in a context clause.

\def\Stack#1{\begin{tabular}[t]{@{}l@{}}#1\end{tabular}} 

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|p{3.75in}|}\hline
Construct & Theory Name & Discussion \\\hline\hline

\Stack{Package\\declaration} & \Stack{{\em PACKAGE}{\tt spec}} &
This holds the Z theory for the package and contains the types, constants and functions introduced by the package (each prefixed by the package name). This theory becomes a parent theory of any theory corresponding to a script containing a context clause referring to the package and is created when the first such with clause is encountered.
\\\hline

\Stack{Internal\\package\\declaration} & \Stack{{\em SCRIPT}} &
This holds the internal form of the Z theory for the package and contains the types, constants and functions introduced by the package (unprefixed). 
This theory is used to type check the package specification at
its declaration.
It also becomes a parent theory of the theory used to hold the 
Z material for the associated package body.
\\\hline

\Stack{Subprogram\\body/\\Package \\body} & \Stack{\em SCRIPT} &
The Z for the subprogram or package body is placed in the script theory.
For each context clause in the compilation unit, the corresponding package specification theories becomes parents of the script theory.
The internal package declaration script theory will be made a parent 
of the matching package body script theory.
\\\hline

\Stack{Body\\stub} & \Stack{{\em UNIT}{\tt o}{\em SUBUNIT}{\tt stub}} &
This holds the Z representing the point in the Z document where the stub was encountered. This is done by duplicating the current script theory to create the stub theory.
When the corresponding subunit is processed (which must be in a different literate script from the stub), the stub theory becomes a parent of the script theory.
\\\hline
%
\end{tabular}
\end{center}
\caption{Use of Theories}\label{UoT}
\end{table}
\chapter{COMPLIANCE NOTATION TOOLKIT}\label{cn}
The Z paragraphs below support the translation of expressions and declaration into Z as described in chapter \ref{SEMANTICS}.

Essentially these paragraphs define the representations of the supported predefined types and their supported attributes.
They also give representations for those predefined operators of SPARK which are not directly supported by the Z library.
 
\input{usr504a}

\chapter*{REFERENCES}
\addcontentsline{toc}{chapter}{REFERENCES}
\label{BIBLIOG}

\bibliographystyle{fmu}
\bibliography{fmu,daz}
 
\pagebreak
\twocolumn
\chapter*{INDEX}
\addcontentsline{toc}{chapter}{INDEX}
\small
\printindex

\end{document}


