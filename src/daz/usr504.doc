% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
% sed -n "/^=DOC/,/^=ENDDOC/p" <dtd516.doc | sieve tex > usr501E.tex
\documentstyle[11pt,hol1,fleqn,USR,epsf]{book}
% temporary measure while waiting for LaTeXe to come along
\def\LaTeXe{\LaTeX$2_{\varepsilon}$}
\def\Hide#1{}
% Set the following macros as necessary as release
% numbers change.
\def\texrelease{\TeX\ version 3.1415}
\def\latexrelease{\LaTeXe}
\def\arch{sun4}
\def\solarisrelease{Solaris 2.3}
\def\motifrelease{Motif 1.2}
\def\polyrelease{Poly/ML 2.07MX}
\def\quicktexloc{{\tt /QLaTeX}} % NB one location needs this hard wired in
\def\daztool{Compliance Tool}
% just useful macros
\def\ltm{$^{\rm TM}$}
\def\Note#1{{\small\bf[ #1 ]}}
=IGN
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Tool --- Description}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/USR504}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{D.J.~King & Project Manager}
\TPPabstract{
This document is the Description Manual for the Compliance Tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
\begin{tabular}[t]{lr}
C.O"Halloran & DRA\\
DAZ Project Library & WIN01\\
\end{tabular}}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadcentre{}
%\def\TPPheadcentreproject{}
%\def\TPPheadrhs{}
\let\TPPfootlhs=\TPPfootrhs
\def\TPPfootcentre{$\vcenter{\halign{\hfil\strut##\hfil\cr
COPYRIGHT  \copyright\ ICL 1994\cr}}$}
=TEX
\ftlmargin 0.0in
\ftrmargin 0.0in

\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$%
}}

\USRmanual{Compliance Tool --- Description}
\USRref{USR504}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}
\makeUSRfrontpage

\underscoreoff

\chapter*{CONTENTS}

\tableofcontents
%\listoffigures

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document describes Compliance Notation and how it is supported by the Compliance Tool supplied with {\Product}.

\section{Readership}
This document provides reference material intended to be read by users of the Compliance Tool.

\section{Related Publications}

A bibliography is given towards the end of this document.

\begin{itemize}

\item
An overview of the of the Compliance notation can be found in the DRA document:

{\em A commentary on the Specification of the Compliance Notation for SPARK and Z} \cite{DRA/CIS.SE2/PROJ/SWI/TR/1/1.0}.

\item
The formal specification of the Compliance notation may be found in the DRA document:

{\em Specification of the Compliance Notation for SPARK and Z (3 volumes)} \cite{DRA/CIS/CSE3/TR/94/27/2.1}.

\item
A description of \Product{} may be found in:

{\em \ {\SOFTSERV}},

which also contains a full list of other \Product{} documentation.

\end{itemize}


\section{Prerequisites}

TBA

\section{Acknowledgements}
TBA
=TEX
\chapter{INTRODUCTION}\label{INTRODUCTION}

The Compliance Notation allows Ada programs to be presented in a literate programming style in which the order of presentation of program fragments is chosen by the writer rather than fixed by the Ada syntax rules.
A program presented in the Compliance Notation may be interspersed with formal specifications of the program"s behaviour written in the specification language Z.
If the program conforms to the SPARK subset of Ada, a Z document can be produced automatically from its presentation using the Compliance Notation.
This Z document contains Z paragraphs representing the Ada types, functions and constants defined in the Ada program, together with conjectures, known as verification conditions (VCs), whose proof constitutes a correctness proof for the program against its specification.

The level of mathematical rigour in a Compliance Notation script is under the user's control.
At one extreme, no formal material at all need be included; at the other extreme, every subprogram can be formally specified and verified.
Most practical uses of the Compliance Notation will lie between these extremes.

The notation includes a feature allowing the syntactic rules of SPARK to be bypassed completely so that Ada features, such as generic packages, which are outside the scope of SPARK can be used.

\chapter{COMPLIANCE NOTATION SYNTAX}\label{SYNTAX}
\section{Introduction}
In this chapter, the syntax of the Compliance Notation is described.
The Compliance Notation as described here uses the {\ProductZ} dialect of Z.
The syntax of {\ProductZ} is described in \DESCRIPTION.
The description is organised following the structure the Ada Language Reference Manual, \cite{AJPO83}, which will be referred to as $ALRM$ in this document.

\section{Lexical Elements}
\subsection{Character Set}\label{2.1}
The character set for the Compliance Notation is the ISO seven-bit coded character set augmented with the symbols required by the Z notation and certain special symbols described in section \ref{2.2} below.

\subsection{Lexical Elements, Separators, and Delimiters}\label{2.2}
The lexical elements of the Compliance Notation are the union of those for Ada as described in \cite{AJPO83} and those for {\ProductZ} as described in {\DESCRIPTION} augmented with a small list of symbols with special significance.

The special symbols are as follows:

{\ShowAllImages
\begin{tabular}{|l|p{5.0in}|}\hline
Symbol & Name \\\hline\hline
=INLINEFT
 ¹CN
=TEX
& Compliance Notation start symbol \\\hline
=INLINEFT
 °
=TEX
& Compliance Notation end symbol\\\hline
=INLINEFT
 Ã
=TEX
& Refinement symbol \\\hline
=INLINEFT
 é
=TEX
& Replacement symbol \\\hline
=INLINEFT
 !é
=TEX
& Arbitrary Ada symbol \\\hline
=INLINEFT
 §
=TEX
& Left k-slot  symbol \\\hline
=INLINEFT
 ¢
=TEX
& Right k-slot  symbol \\\hline
=INLINEFT
 „
=TEX
& Specification statement symbol \\\hline
\end{tabular}}

The Compliance Notation start and end symbols are used like the analogous symbols for {\ProductZ} to delimit the Compliance Notation parts of a document.
The other symbols are used within the Compliance Notation proper.
Several of these symbols are also used in Z; the grammar of the Compliance Notation is such that the extent of a Z expression or Z predicate within a valid Compliance Notation construct can always be unambiguously determined.

\subsection{Identifiers}\label{2.3}
The rules for identifiers are as in ALRM.

While Ada is not case-sensitive, Z is: when an Ada name is translated into a Z name it is translated into upper case.

\subsection{Numeric Literals}\label{2.4}
Real literals are not handled formally.

\subsection{Character Literals}\label{2.5}

Character literals are not handled formally.

\subsection{String Literals}\label{2.6}

String literals are not handled formally.


\subsection{Comments}\label{2.7}
Ada comments will normally not be passed in to the Ada program generated from a Compliance Notation script.
For compatibility with the SPARK examiner, comments beginning with
=INLINEFT
--#
=TEX
\ are passed in to the Ada program in those syntactic positions where the SPARK examiner allows or requires annotations, as described in \cite{pvl92}.

Comments may also be passed in to the Ada program using the arbitrary Ada replacement facility.


\subsection{Pragmas}\label{2.8}

Pragmas in the Compliance Notation are allowed in the following places:

\begin{enumerate}
\item at any place where a declaration or a statement would be allowed;
\item in a declarative part;
\item immediately after a context clause;
\item where a compilation unit would be allowed.
\end{enumerate}

Pragmas are just treated as data to be passed in to the Ada program generated from a Compliance Notation script and have no effect on the Z document.

\subsection{Reserved Words}\label{2.9}
In addition to the reserved words of ALRM, the following identifiers (which are not case-sensitive) have special significance in the Compliance Notation:

=GFT
	auxiliary
	by
	con
	implement
	using
=TEX

\subsection{Allowable Replacements of Characters}

The replacement characters are not supported.

\section{Declarations and Types}\label{3}
\subsection{Declarations}\label{3.1}

Only the following forms of basic declaration are permitted:

=GFT
basic_declaration ::=
		object_declaration
	|	type_declaration
	|	subtype_declaration
	|	subprogram_declaration
	|	package_declaration
	|	renaming_declaration
	|	deferred_constant_declaration
=TEX

A package declaration standing as a basic declaration inside a subprogram or another package declaration cannot be handled formally;
package declarations can only be handled formally when they are used as library units (i.e., at the top level).

\subsection{Objects and Named Numbers}\label{3.2}
An object declaration
=TEX
\ must conform to the following syntax:
=GFT
object_declaration	::=	constant_declaration
			|	variable_declaration

constant_declaration	=	identifier_list ":" "constant" type_mark ":=" expression;

variable_declaration	=	identifier_list ":" "type_mark;
=TEX

Named number declarations and declarations involving anonymous types are not permitted.

\subsection{Types and Subtypes}\label{3.3}
\subsubsection{Type Declarations}\label{3.3.1}
A type declaration
=TEX
\ must conform to the following syntax:
=GFT
type_declaration	::=	full_type_declaration
			|	private_type_declaration

full_type_declaration	::=	"type" identifier "is" type_definition;

type_definition	::=	enumeration_type_definition
			|	integer_type_definition
			|	real_type_definition
			|	array_type_definition
			|	record_type_definition
=TEX
\subsubsection{Subype Declarations}\label{3.3.2}
A subtype declaration
=TEX
\ must conform to the following syntax:
=GFT
subtype_declaration	::=	"subtype" identifier "is" subtype_indication;

subtype_indication	::=	type_mark constraint

constraint		::=	range_constraint
			|	floating_point_constraint
			|	fixed_point_constraint
			|	index_constraint
=TEX

A subtype indication must include a constraint.
Discriminant constraints are not permitted.
\subsubsection{Classification of Operations}
Use of the base type attribute $T'BASE$ cannot be handled formally.
\subsection{Derived Types}\label{3.4}
Derived types are not permitted.
\subsection{Scalar Types}\label{3.5}
=GFT
range_constraint ::= "range" range

range ::=
		range_attribute
	|	simple_expression .. simple_expression
=TEX

A range given as a range attribute cannot be handled formally.

A range constraint must not denote a null range when used within a type definition.
A VC may be generated asserting that the range is not null in such circumstances if it cannot be determined whether the range is null (e.g., if the range constraint appeals to compiler-dependent constants such as $INTEGER"LAST$).

\subsubsection{Enumeration Types}\label{3.5.1}

=GFT
enumeration_type_definition ::= 
	"(" identifier {"," identifier} ")"
=TEX

Character literals are not permitted as enumeration literals.
\subsubsection{Character Types}\label{3.5.2}
The predefined type $CHARACTER$ may be used;
however, character literals are not handled formally and user-defined character types are not permitted (see the restriction in section \ref{3.5.1} above).

\subsubsection{Boolean Types}\label{3.5.3}
No restrictions apply to this section of ALRM.
\subsubsection{Integer Types}\label{3.5.4}

=GFT
integer_type_definition ::= range_constrain
=TEX

No restrictions apply to this section of ALRM.
\subsubsection{Operations of Discrete Types}\label{3.5.5}
Only the following attribute of a discrete type or subtype $T$ are permitted:
=GFT
	T'POS
	T'VAL
	T'SUCC
	T'PRED
=TEX
\subsubsection{Real Types}\label{3.5.6}
=GFT
real_type_definition ::=
	floating_point_constraint | fixed_point_constraint
=TEX


\subsubsection{Floating Point Types}\label{3.5.7}
=GFT
floating_point_constraint ::=
	floating_accuracy_definition [range_constraint]

floating_accuracy_definition ::=
	"digits" simple_expression
=TEX

The predefined arithmetic operators on floating point types cannot be handled formally.

\subsubsection{Operations of Floating Point Types}\label{3.5.8}
The attributes of floating point types are not permitted.

\subsubsection{Fixed Point Types}\label{3.5.9}
=GFT
fixed_point_constraint ::=
	fixed_accuracy_definition [range_constraint]

fixed_accuracy_definition ::=
	"delta" simple_expression
=TEX

The predefined arithmetic operators on fixed point types cannot be handled formally.

\subsubsection{Operations of Fixed Point Types}\label{3.5.10}
The attributes of floating point types are not permitted.

\subsection{Array Types}\label{3.6}

=GFT
array_type_definition ::=
	unconstrained_array_definition | constrained_array_definition

unconstrained_array_definition ::=
	"array" "(" index_subtype_definition {"," index_subtype_definition} ")" "of"
		type_mark

constrained_array_definition ::=
	"array" index_constraint "of" type_mark

index_subtype_definition ::= type_mark "range" "<>"

index_constraint ::= "(" type_mark {"," type_mark} ")"
=TEX



The component subtype indication in an unconstrained or constrained array definition must be given as a type mark.

Each discrete range in an index constraint must be given as a type mark.

\subsubsection{Index Constraints and Discrete Ranges}\label{3.6.1}

The discrete ranges in an index constraint must be given as type marks, 
This implies that the bounds of any array object are static expressions.

\subsubsection{Operations of Array Types}\label{3.6.2}

The attributes of array types are only supported for one-dimensional arrays.
The form of attribute with an argument are not supported.

The catenation and ordering operators for array types are not handled formally.

\subsubsection{The Type String}\label{3.6.3}
The type $STRING$ is treated precisely as if defined by the following unconstrained array type definition:
=GFT
	type STRING is array (POSITIVE range <>) of CHARACTER
=TEX

String literals cannot be handled formally and the catenation and ordering operators for string types are no available.

\subsection{Record Types}\label{3.7}
A record type definition must conform to the following syntax:

=GFT
record_type_definition ::=
	"record"
		component_list
	"end" "record"

component_list ::=
	component_declaration {component_declaration}

component_declaration ::=
	identifier_list ":" type_mark
=TEX
\subsubsection{Discriminants}\label{3.7.1}
Discriminants are not permitted.

\subsubsection{Discriminant Constraints}\label{3.7.2}
Discriminant coinstraints are not permitted.

\subsubsection{Variant Parts}\label{3.7.3}
Variant parts are not permitted.
The syntax for $choice$ is given in section \ref{4.3}.

\subsubsection{Operations of Record Types}\label{3.7.4}

All the basic operations other than attributes for record types are supported.

\subsection{Access Types}\label{3.8}
Access types are not supported.

\subsection{Declarative Parts}\label{3.9}
Declarative parts must conform to the following syntax:

=GFT
declarative_part ::=
	{basic_declarative_item} {later_declarative_item}

basic_declarative_item ::=
	basic_declaration | representation_clause | k_slot

later_declarative_item ::= body
	| subprogram_declaration | package_declaration | k_slot

body ::= proper_body | body_stub

proper_body = subprogram_body | package_body
=TEX

A k-slot (short for Knuth-slot) serves in several places in the syntax and denotes a placeholder for an Ada construct. The Ada constructs which can be deferred in this way are a compilation, a basic declarative item, a statement, a visible part or a private part.
A k-slot must conform to the following syntax:

=GFT
k_slot ::= "§" commentary "¢" [tag]

tag ::= "(" digit{digit} ")"
=TEX

Here $commentary$ stands for an arbitrary sequence of characters not including =INLINEFT
"¢"
=TEX
.
The optional numeric tag is used to identify the k-slot when the Ada construct whose place it is holding is provided in a refinement or replacement step.
If the numeric tag is omitted, then the next refinement
or replacement step in the script that does not specify a tag is taken to 



\section{Names and Expressions}\label{4}
\subsection{Names}\label{4.1}
=GFT
name ::=
		simple_name
	|	indexed_component
	|	selected_component
=TEX

Operator symbols are not allowed as names.

Slices are not supported.

Character literals and attributes are taken as primaries rather than names.

\subsubsection{Indexed Components}\label{4.1.1}

=GFT
indexed_component ::= prefix "(" expression {"," expression} ")"
=TEX

\subsubsection{Slices}\label{4.1.2}
Slices are not supported.

\subsubsection{Selected Components}\label{4.1.3}

=GFT
selected_component ::= prefix "." selector
=TEX

Other rules imply that the only permitted forms of selected components denote a record component or an entity declared in the visible part of a package.

\subsubsection{Attributes}\label{4.1.4}
=GFT
attribute ::= prefix "'" attribute_designator
	|	character_literal "'" attribute_designator
=TEX

Only the first form of attribute can be handled formally.

\subsection{Literals}\label{4.2}
The literal $null$ is not supported.

Only integer literals and enumeration literals are handled formally.

\subsection{Aggregates}\label{4.3}

=GFT
aggregate ::=
		"(" component_associations ["," "others" "=>" expression] ")" 
	|	"(" "others" "=>" expression ")" 

component_associations ::=
		named_association {"," named_association}
	|	positional_association {"," positional_association}

named_association ::=
	choice {"|" choice} "=>" expression

positional_association ::= expression

choice ::=
	simple_expression
	|	discrete_range
	|	"others"
	|	simple_name
=TEX

A mixture of named and positional component associations is not permitted in an aggregate (although an $others$ choice is permitted when positional component associations are used).

To be handled formally, an aggregate must appear as the operand of a qualified expression (so that the Ada type of the aggregate is available to guide its translation into Z).

\subsubsection{Record Aggregates}\label{4.3.1}

A record aggregate with an $others$ choice cannot be handled formally.

\subsubsection{Array Aggregates}\label{4.3.2}

Multi-dimensional array aggregates are not handled formally.

\subsection{Expressions}\label{4.4}

=GFT
expression ::=
		relation {"and" relation}	| relation {"and" "then" relation}
	|	relation {"or" relation}	| relation {"or" "else" relation}
	|	relation {"xor" relation}

relation ::=
		simple_expression [relational_operator simple_expression]
	|	simple_expression ["not"] "in" range
	|	simple_expression ["not"] "in" type_mark

simple_expression ::=
	[unary_adding_operator] term {binary_adding_operator term}


term ::=
	factor {multiplying_operator factor}


factor ::= primary ["**" primary] | "abs" primary | "not" primary

primary ::= 
		numeric_literal	|	aggregate	|	string_literal
	|	name			|	function_call	|	type_conversion
	|	qualified_expression	|	"(" expression ")"	| attribute
	|	auxiliary_expression

auxiliary_expression ::=
	"û" z_expression "ý"
=TEX

The $null$ expression and allocators are not supported.

See section \ref{4.2} for restrictions on literals.

$z\_expression$ stands for the construct called $Expr$ in {\DESCRIPTION}.

\subsection{Operators and Expression Evaluation}\label{4.5}
The syntax for the six classes of operator is exactly as in ALRM except that the catenation operator \& is not supported.

\subsubsection{Logical Operators and Short-circuit Control Forms}\label{4.5.1}
The short-circuit control forms $and\,then$ and $or\,else$ are treated formally as synonymous with $and$ and $or$ respectively.
In the current version of the notation, it is the user's responsibility to ensure that functions are free of side effects so that this treatment is sound.

\subsubsection{Relational Operators and Membership Test}\label{4.5.2}

Predefined ordering operators for discrete array types cannot be handled formally.

Membership tests with a type mark are not handled formally.

\subsubsection{Binary Adding Operators}\label{4.5.3}

Addition and subtraction are only handled formally for integer types.

Catenation is not supported.

\subsubsection{Unary Adding Operators}\label{4.5.4}

The unary adding operators are only handled formally for integer types.

\subsubsection{Multiplying Operators}\label{4.5.5}

The multiplying operators are only handled formally for integer types.

\subsubsection{Highest Precedence Operators}\label{4.5.6}

The absolute value operation is only handled formally for integer types.

\subsubsection{Accuracy of Operations with Real Operands}\label{4.5.7}

The only operators for real types which are handled formally are non-computational operators such as assignment and parameter passing.

\subsection{Type Conversions}\label{4.6}

=GFT
type_conversion ::= type_mark "(" expression ")"
=TEX

A type conversion is not allowed as an actual parameter whose corresponding formal parameter has mode $out$ or $in\,out$.

A type conversion can only be handled formally if both the operand and target types are integer types.

It is the user's responsibility to ensure that the exception which can be raised by evaluation of a type conversion does not occur (e.g., by including an appropriate pre-condition in the specification of the statement containing the expression).

\subsection{Qualified Expressions}\label{4.7}

=GFT
aqualified_expression ::=
	type_mark "'" "(" expression ")"
	type_mark "'" aggregate
=TEX

\subsection{Allocators}\label{4.8}
Allocators are not supported.

\subsection{Static Expressions and Static Subtypes}

Not all static expressions can be completely evaluated when a Compliance Notation script is checked.
For example, the value of an attribute such as $INTEGER"FIRST$ depends on the compiler being used.
This sometimes results in a VC being generated (see section \ref{3.5}).

\subsection{Universal Expressions}
Universal expressions are only handled formally for the universal integer type.


\section{Statements}
\section{Simple and Compount Statements --- Sequences of Statements}\label{5.1}

=GFT
sequence_of_statements ::= statement {statement}

statement ::=
		simple_statement
	|	compound_statement
	|	[logical_constant_declaration] specification_statement [tag]
	|	k-slot

simple_statement ::=
		null_statement
	|	assignment_statement
	|	procedure_call_statement
	|	exit_statement
	|	return_statement

compount_statement ::=
		if_statement
	|	case_statement
	|	loop_statement

logical_constant_declaration ::= "con" z_declaration "·"

specification_statement ::=
		"„" frame "[" [pre_condition ","] post_condition "]"
	|	"„" frame "{" pre_condition "}"

frame ::= z_identifier {"," z_identifier}

pre_condition ::= z_predicate

post_condition ::= z_predicate

null_statement ::= "null" ";"
=TEX

Here $z\_declaration$, $z\_identifier$ and $z\_predicate$ stand for the constructs called $Decl$, $Id$ and $Pred$ respectively in {\DESCRIPTION}.

\subsection{Assignment Statement}
=GFT
assignment_statement ::= name ":=" expression ";"
=TEX

\section{Subprograms}
\section{Packages}
\section{Visibility Rules}
\section{Tasks}
\section{Program Structure and Compilation Issues}

\chapter*{REFERENCES}
\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
\bibliography{fmu,daz}
 
%\pagebreak
%\twocolumn
%\chapter*{INDEX}
%\addcontentsline{toc}{chapter}{INDEX}
%\small
%\printindex

\end{document}


