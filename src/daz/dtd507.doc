=IGN
********************************************************************************
dtd507.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  %Z% $Revision: 1.170 $ $RCSfile: dtd507.doc,v $ $Date: 2006/06/13 16:01:43 $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD507}  %% Mandatory field
\def\SCCSversion{$Revision: 1.170 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/06/13 16:01:43 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{R.D.~Arthan&WIN01}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the detailed design for the
Compliance Notation Z Generation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,hatdocs,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.21] Initial drafts.
\item[Issue 1.22 (21th September 1994) ] Rework done according to deck-check report reference 0010 and checked by KB.
\item[Issues 1.22-1.34] Phase 3 rework.
\item[Issues 1.35-1.43] Fixed to the Z during type-checking.
\item[Issue 1.44] Final version for issue.
\item[Issue 1.45-1.47] Bug fixes.
\item[Issue 1.48] Enhancements 1, 5, 6, 7 and 20; bug fix 17 (batch 2).
\item[Issue 1.49] Enhancement 10.
\item[Issue 1.50] Issue for review.
\item[Issue 1.51] Exposed $add\_type\_info$.
\item[Issue 1.52 (14th December 1995)] Changes according to desk check report 024.
\item[Issue 1.53] Fixed bug 6 (V0.6).
\item[Issue 1.54] New error message for resolution of issue 1 (V0.6).
\item[Issue 1.55] Updated reference to DRA spec.
\item[Issue 1.56] Added $new\_script1$ for IUCT project WP 1.
\item[Issue 1.57 - 1.58] Changes for IUCT WP 7.
\item[Issue 1.59-1.60] Changes for IUCT WP 2.
\item[Issue 1.61] Further changes for IUCT WP 7.
\item[Issue 1.62-1.65] Additional error messages.
\item[Issue 1.66] IUCT WP 5.
\item[Issue 1.68] IUCT WP 9.
\item[Issue 1.69] Removed $pack\_spec\_with\_modules$ as per new spec.
\item[Issue 1.70] Corrected Z syntax and type errors.
\item[Issue 1.71] First round of syntax/type error correction for IUCT.
\item[Issue 1.72] Typos.
\item[Issue 1.73] Updated Z for HLD504 Appendix Material.
\item[Issue 1.74] Updated references.
\item[Issue 1.75] Tidying.
\item[Issue 1.76] Update for SML97.
\item[Issue 1.77] Enhancement R5 (initial variables in conditionals).
\item{Issue 1.78,1.79} Brought {\it vcs\_body\_fun} and {\it add\_log\_con\_env}
into line with latest specifications.
\item[Issue 1.80] CTLE II R1/3: reverse loops.
\item[Issue 1.81] CTLE II R1/9: SPARK 83 attributes.
\item[Issue 1.82] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.83,1.84] CTLE II R1/11: nested packages.
\item[Issue 1.85] CTLE II R1/1: real types.
\item[Issue 1.86] Fixes to Z spec of {\it update\_envs\_pack\_spec}.
\item[Issue 1.87] Perfomance enhancement for type-checking of specification statements.
\item[Issue 1.88] Fixed {\LaTeX} error.
\item[Issue 1.89] Corrected out-of-date narrative about type-checking.
\item[Issue 1.90] Removed local declarations for Poly/ML port.
\item[Issue 1.91] Index brackets added.
\item[Issues 1.92, 1.93] R0006: spec updates.
\item[Issue 1.94] R0044: checks on array ranges.
\item[Issue 1.95] Support for new SPARK output functions.
\item[Issue 1.96] Applying specification changes from HLD508.
\item[Issue 1.97] Fixing {\LaTeX} and other minor problems for SPC501.
\item[Issue 1.99] R0065: duplicates in context clauses now allowed.
\item[Issue 1.100] Spring 2002 enhancements: syntax changes for interim release.
\item[Issue 1.101] Spring 2002 enhancements: Forward declarations for subprograms.
\item[Issue 1.101--1.107] Spring 2002 enhancements: renaming
\item[Issue 1.108, 1.109] Spring 2002 enhancements: more on named loops.
\item[Issue 1.110] Duplicate renamings and use clauses are now errors.
\item[Issue 1.111] Fixed mismatched type.
\item[Issue 1.112] Full syntax-check-only now implemented.
\item[Issue 1.113] Changed signature of {\it renames\_proc\_common}.
\item[Issue 1.114] More on renaming.
\item[Issue 1.115] Exposed {\it current\_cn\_env} in the signature for diagnostic purposes.
\item[Issue 1.116] New error message for revised treatment of renaming.
\item[Issue 1.117] Error message for misplaced assertions.
\item[Issue 1.118, 1.119] R0051: default parameters (new and modified error messages).
\item[Issue 1.120] Merged in changes for R0062. Error messages for VC browser info get and set.
\item[Issue 1.121] Copyright and banner updates for open source release.
\item[Issue 1.122, 1.123] DAZ-specific updates to banner for open source release
\item[Issue 1.124] Uniform treatment of block statements.
\item[Issue 1.125--1.126] Script deletion.
\item[Issue 1.127] Schemas-as-declarations now catered for in output Z syntax.
\item[Issues 1.128, 1.129] R0067: specification changes for schema references in $\Xi$-lists.
\item[Issues 1.130--1.133] R0066: specification changes for auxiliary variables in $\Xi$-lists.
\item[Issue 1.134] Added exception logging.
\item[Issue 1.135] New error messages for the rationalised error system.
\item[Issues 1.136, 1.137] Updates to the Z specifications after GMP's preliminary review.
\item[Issue 1.138] R0091: the implementation entailed a new internal error message.
\item[Issue 1.139] Improved error messages for type-checking of specification statements.
\item[Issue 1.140] The SPARK program is now referred to as the Ada program.
\item[Issues 1.141-1.145] Reform of the Environments.
\item[Issues 1.146]  New error messages for using clauses
\item[Issue 1.147] Renaming informal procedures no longer causes an error.
\item[Issue 1.148] Adjustments for fix to informal procedure unsoundness problem.
\item[Issue 1.149] New error message for case when an informal function clashes with \item[Issue 1.150] Now exports {\em ti\_context\_of\_in\_scope} and {\em cn\_env\_of\_in\_scope}.
\item[Issue 1.151] Added {\em create\_package\_spec\_theory}.
\item[Issue 1.152] Enhanced error reports for free variables in specification statements.
\item[Issue 1.153] Adjusted error reports after comments from QinetiQ.
\item[Issue 1.154] VC soundness warnings for informal development steps.
\item[Issue 1.155] Fixed problem with object renamings in package specifications.
\item[Issue 1.156] Enhancement 115: support for implicitly declared subprograms.
\item[Issue 1.157] Minor adjustments to error messages.
\item[Issue 1.158] First clean compile for enhancement 117.
\item[Issue 1.159] Debugging enhancement 117.
\item[Issue 1.160] Beginnings of enhancement 118.
\item[Issue 1.161] Automated state management.
\item[Issue 1.162] Added message needed for testing enhancement 117.
\item[Issue 1.165] Under enhancement 117, checks on use of names in Z are now given a uniform treatment.
\item[Issue 1.166] Support for general expanded names.
\item[Issue 1.167] Clarified error message 507137.
\item[Issue 1.168] Signature changes to allow for rationalised data type for subunits.
\item[Issue 1.169] Issue 139: ``1 theory per subprogram''.
\item[Issue 1.170] Exposed string constants for use in the Z output function.
\item[Issue 1.171] Added {\em get\_script\_theories}.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the functions whose Z specification is given in in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}; it is called for in \cite{ISS/HAT/DAZ/HLD503}.
Sections \ref{BASICDECLARATIONS}-\ref{WEBCLAUSES} contain the design and correspond directly with sections 4-16 of the DRA specification.

\subsection{Introduction}
This document gives the structure (i.e., module) containing the functions defined \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.
This covers the main semantic processing involved in the extraction of a Z document from a Compliance Notation script.
As usual it also includes a transcription into {\ProductZ} of the relevant parts of the DRA specification.

The overall effect of the processing defined here is to update the {\Product} theory database as if the Z document had been loaded into it and to update internal state representing the environments of  \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} as implemented in \cite{ISS/HAT/DAZ/DTD513}.
The internal state also includes additional information defined in \cite{ISS/HAT/DAZ/DTD513} and used to record the association of k-slot labels with SPARK program fragments.
This gives all the information required to reduce extraction of the Z document and of the SPARK program to straightforward pretty-printing tasks.



\subsubsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/HLD503}.


\subsubsection{Dependencies}
See \cite{ISS/HAT/DAZ/HLD503}.
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.


\subsection{Compliance}
For the description of the Z in this document see \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}. Where the Z differs from that in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}, justification has been provided.

In \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} where names contain double underscores, the implementation has chosen to use only single underscores (no ambiguity results from this).

In {\ProductZ}, subscripts are not decoration. In order to achieve the effect required by \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}, multiple priming has been used and generally, the number of primes in a decoration corresponds to the numeric value of the subscript in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.

In a number of places, the Z in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} (and hence in this document) is recognised to be deficient. In specific cases, agreed with DRA, the implementation has been discussed and agreed, but the Z has not been brought into line with the implementation. Where this is the case, there is a note to draw attention to this fact.







\section{PREAMBLE}
\subsection{Preamble for Z Type-Checking}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd505";
push_pc "z_library";
force_delete_theory"dtd507" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory "dtd507";
new_parent "dtd513";
=TEX

\subsection{The Signature}
=DOC
signature €CNZGenerator› = sig
=DESCRIBE
=ENDDOC
As with other signatures, the following would be local declarations
rather than includes if that were allowed.
=SML
include	(* CNTypes CNTypes2 CNBasicDeclsAndExprs *) CNTypes1;
(*	ZParagraphs ZUserInterfaceSupport; *)
=TEX
\section{TYPE-CHECKING}
Type-checking the Z that occurs in specification statements is a somewhat
thorny problem, since some care has to be taken to ensure that
the current theory and the type inference context are appropriate.

At DERA's request, the implementation endeavours to type-check every
Z fragment as soon as it is processed by the Z Generator. Unfortunately,
a simple implementation of this following the structure of the formal
specification of the tool causes each Z fragment to be type-checked
several times. This inefficiency has proved to be very significant
in actual examples.

The checking is most safely done by simulating a call
to the VC generator. To improve performance, the function {\it vcs}
that is the entry point to the VC generator returns a type-checked
specification statement in addition to the VCs. The Z Generator
is then able to store the type-checked specification statement in
its data structures and so avoid repeated type-checking.

In the current implementation, the performance enhancement has
been implemented for specification statements and logical
constant statements as statements but not for other uses of
specification statements. To facilitate future improvements,
the type-checked specification statement is propagated up
the calling tree until it can either be stored for future
reference or until the logic of the formal specification
makes it difficult to pass the value up.

The following SID functions now return a type-checked specification
statement for the caller's benefit:

\begin{tabular}{l}
{\it form\_proc\_pack\_body}\\
{\it form\_proc\_pack\_body\_aux}\\
{\it k\_slot\_stmt}\\
{\it vcs\_aux\_initial}\\
{\it vcs\_body\_proc}\\
{\it vcs\_body\_fun}\\
{\it vcs\_speclabel}
\end{tabular}

The following functions are the ones that are forced to discard a type-checked
specification statement passed up by a supporting function. (I.e., these
are the candidates for future performance enhancements).

\begin{tabular}{l}
{\it form\_proc\_subunit}\\
{\it check\_stub\_spec\_proc}\\
{\it form\_proc}\\
{\it form\_fun\_pack\_body}\\
{\it form\_fun\_subunit}\\
{\it vcs\_body}\\
{\it do\_proper\_body}
\end{tabular}

=TEX
\section{BASIC DECLARATIONS}\label{BASICDECLARATIONS}
\subsection{The SID Function basic\_declaration}
ˇ€BASIC_DEC›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	basic_decl : SI_BASIC_DECL
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €basic_decl_pack_spec› : BASIC_DECL -> unit;
=DESCRIBE
ˇ€basic_decl_pack_spec›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	ÑZ_DOC;
‹	BASIC_DEC;
‹	ENV;
‹	Package;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag' = True;
‹	 Block' = blocks 1;
‹	pack_env block_name' =  Package;
‹	∂adjusted_decls : seq BASIC_DECL ∑
‹		pack_env' =
‹		pack_env ´
‹		{ block_name' Ì
‹			Package_consts_types( Package, consts_types Î adjusted_decls)} ±
‹		z' = z Î ã(trans_basic_decl o adjusted_decls)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €basic_decl_otherwise› : BASIC_DECL -> unit;
=DESCRIBE
ˇ€basic_decl_otherwise›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	BASIC_DEC;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag' = False;
‹	 Block' = blocks 1;
‹	z' = z Î ã(trans_basic_decl o adjust_basic_decl(basic_decl))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507041	Unsupported language feature encountered in a basic declaration
=ENDDOC
=DOC
val €basic_declaration› : BASIC_DECL -> unit;
=DESCRIBE
πZ
‹	€basic_declaration› ¶ basic_decl_pack_spec ≤ basic_decl_otherwise
∞
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name (?0)
=ENDDOC
\subsection{The SID Function var\_pack\_spec}
=DOC
val €var_pack_spec› : VAR_DECL -> unit;
=DESCRIBE
In the implementation, variable declarations contain lists of identifiers, rather than single identifiers (i.e., they are as in the concrete syntax rather than the Z abstract syntax).
We therefore only deal with a single $VAR\_DECL$ here.
ˇ€var_pack_spec›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	VAR_DECL;
‹	ENV;
‹	Package;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag' = True;
‹	 Block' = blocks 1;
‹	pack_env block_name' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{ block_name' Ì
‹		Package_vc_vars( Package, vc_vars ¿ vars) }
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
\subsection{The SID Function update\_envs\_var}
=DOC
val €update_subunit_env_var› : PREFIX_INFO -> VAR_DECL -> unit;
=DESCRIBE
ˇ€update_subunit_env_var›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#subunit_env = #subunit_env';
‹	µidâ1, idâ2 : ID; s, s' : Subunit |
‹		subunit_env(idâ1, idâ2) = s ± subunit_env'(idâ1, idâ2) = s' ∑
‹		dec_lab' ç s.dec_labels ±
‹		s' = Subunit_vc_vars(s, s.vc_vars ¿ vars) ≤
‹		dec_lab' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
=DOC
val €update_dec_env_var› : PREFIX_INFO -> VAR_DECL -> unit;
=DESCRIBE
ˇ€update_dec_env_var›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#dec_env = #dec_env';
‹	µdec_label : LABEL; d, d' : Declab |
‹		dec_env dec_label = d ± dec_env' dec_label = d'∑
‹		dec_lab' ç d.dec_labels ±
‹		d' = Declab_vc_vars(d, d.vc_vars ¿ vars) ≤
‹		dec_lab' é d.dec_labels ± d' = d
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
=DOC
val €update_spec_env_var› : PREFIX_INFO -> VAR_DECL -> unit;
=DESCRIBE
ˇ€update_spec_env_var›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#spec_env = #spec_env';
‹	µspec_label : LABEL; s, s' : Speclab |
‹		spec_env spec_label = s ± spec_env' spec_label = s'∑
‹		dec_lab' ç s.dec_labels ±
‹		s' = Speclab_w
‹		(Speclab_vc_vars(s, s.vc_vars ¿ vars),
‹		s.w ¿ {v : vars∑ trans_id v.var}) ≤
‹		dec_lab' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
=DOC
val €update_envs_var› : VAR_DECL -> unit;
=DESCRIBE
πZ
‹		€update_envs_var›
‹	¶	update_subunit_env_var
‹	±	update_dec_env_var
‹	±	update_spec_env_var
∞
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
\subsection{The SID Function add\_var\_env}
=DOC
val €add_var_env› : VAR_DECL -> unit;
=DESCRIBE
ˇ€add_var_env›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	blocks' = blocks ´ {1 Ì Block_vc_vars(blocks 1, vc_vars' ¿ vars)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID Function add\_var\_init\_env}
=DOC
val €add_var_init_env› : (VAR_DECL * EXP) -> unit;
=DESCRIBE
ˇ€add_var_init_env›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ ÑENV;
‹ VAR_DECL;
‹ Block'
˜¸¸¸¸¸¸
‹  Block' = blocks 1;
‹ init = no_init ±
‹ blocks' = blocks ≤
‹ (∂e: EXP∑ init=init_val e ±
‹   blocks' = blocks ´ {1 Ì 
‹              Block_var_inits
‹		(blocks 1, var_inits' ¿ {v: vars∑v.var Ì (e, v.tmark)})})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507043	Attempting to give variable initialisation for ?0 when it is already initialised
=ENDDOC
\subsection{The SID Function adj\_var\_decl}
This SID function is implemented implicitly via direct use
of {\it adjust\_var\_decl}.
ˇ€adj_var_decl›¸¸
‹ ÑPACK_ENV;
‹ ÑZ_DOC;
‹ ENV;
‹ Package;
‹ Block';
‹ SI_VAR_DECL; 
‹ VAR_DECL;
‹ od : OPT[SI_BASIC_DECL]
˜
‹ adjust_var_decl(  SI_VAR_DECL) = (od, VAR_DECL) ±
‹ ( (od = Nil ± òPACK_ENV ± òZ_DOC) 
‹   ≤
‹   ( ∂ BASIC_DEC ∑ od = Value basic_decl ± basic_declaration )
‹ )
à¸¸
\section{DECLARATIONS}\label{DECLARATIONS}
\subsection{The SID function k\_slot\_dec}
ˇ€LAB›¸¸¸¸¸¸¸¸¸¸¸¸
‹	label : LABEL
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZAX
‹	€no_label› : LABEL
∞
πZ
fun 6 _€dot›_
∞
πZAX
‹	_€dot›_: (ID ∏ ID) ≠ ID
∞
=DOC
val €k_slot_dec› : LABEL -> unit;
=DESCRIBE
ˇ€k_slot_dec›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ÑENV;
‹	LAB;
‹	ENV;
‹	Declab;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	dec_env' = dec_env ¿ {label Ì  Declab};
‹	subunit_flag'' = True ± block_name = block_name'' dot block_name' ≤
‹	subunit_flag'' = False ± block_name = block_name';
‹	 Flags =  Flags';
‹	 In_Scope = flatten_env( ENV);
‹	blocks' =
‹	blocks ´ {1 Ì Block_dec_labels (blocks 1, dec_labels' ¿ {label})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, $ENV$ should be $ÑENV$ and the $blocks'$ component is also updated. (See Implementation.) 
=FAILURE
507006	Internal error: running environment stack unexpectedly empty
507010	?0 is already in use as a declaration label
=ENDDOC
\subsection{The SID function update\_envs\_k\_slot}
=DOC
(* local function €update_subunit_env_k_slot› *)
=DESCRIBE
ˇ €update_subunit_env_k_slot›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	LAB;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#subunit_env = #subunit_env';
‹	µidâ1, idâ2 : ID; s, s' : Subunit |
‹		subunit_env(idâ1, idâ2) = s ± subunit_env'(idâ1, idâ2) = s' ∑
‹		dec_lab' ç s.dec_labels ±
‹		s' = Subunit_dec_labels(s, s.dec_labels ¿ {label}) ≤
‹		dec_lab' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
(* local function €update_dec_env_k_slot› *)
=DESCRIBE
ˇ €update_dec_env_k_slot›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	LAB;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#dec_env = #dec_env';
‹	µdec_label : LABEL; d, d' : Declab |
‹		dec_env dec_label = d ± dec_env' dec_label = d'∑
‹		dec_lab' ç d.dec_labels ±
‹		d' = Declab_dec_labels(d, d.dec_labels ¿ {label}) ≤
‹		dec_lab' é d.dec_labels ± d' = d
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
(* local function €update_spec_env_k_slot› *)
=DESCRIBE
ˇ €update_spec_env_k_slot›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	LAB;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#spec_env = #spec_env';
‹	µspec_label : LABEL; s, s' : Speclab |
‹		spec_env spec_label = s ± spec_env' spec_label = s'∑
‹		dec_lab' ç s.dec_labels ±
‹		s' = Speclab_dec_labels(s, s.dec_labels ¿ {label}) ≤
‹		dec_lab' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €update_envs_k_slot› : LABEL -> unit;
=DESCRIBE
πZ
‹		€update_envs_k_slot›
‹	¶	update_subunit_env_k_slot
‹	±	update_dec_env_k_slot
‹	±	update_spec_env_k_slot
∞
=ENDDOC
\section{STATEMENTS}\label{STATEMENTS}
\subsection{The SID function spec\_stmt}
ˇ€SPEC_STMT›¸¸¸¸¸¸¸¸¸¸¸¸
‹	specification : Spec
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ€spec_stmt_common›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	SPEC_STMT;
‹	LAB;
‹	ENV;
‹	Speclab;
‹	Block';
‹	named_tills' : ID ≠ Z_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	spec_env' = spec_env ¿ {label Ì  Speclab};
‹	 Spec = specification;
‹	formal_body_flag = formal_body_flag';
‹	till_flag = till_flag';
‹	(∂n:ID∑ current_loop_name' = Value n ± till_flag' = True ± named_tills' = {n Ì till'}) ≤
‹	(till_flag' = False ≤ current_loop_name' = Nil) ± named_tills' = ö;
‹	till = till'
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €spec_stmt_speclabel› : {spec :SPEC, label : LABEL} -> unit;
=DESCRIBE
ˇ€spec_stmt_speclabel›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	spec_stmt_common;
‹	Speclab''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	speclabel_flag' = True;
‹	 Speclab'' = spec_env spec_lab';
‹	formal_body_flag = formal_body_flag'';
‹	fun_flag = fun_flag'';
‹	fun_header = fun_header'';
‹	named_tills = named_tills' ¿ named_tills'';
‹	return = return'';
‹	vc_vars = vc_vars'';
‹	vc_pars = vc_pars'' ¿ (flatten_env( ENV)).vc_pars;
‹	vc_log_cons = vc_log_cons'' ¿ vc_log_cons';
‹	vc_aux_vars = vc_aux_vars'';
‹	formal_procs = formal_procs'';
‹	dec_labels = dec_labels''
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507014	specification label ?0 has not been introduced
507015	label ?0 has already been introduced
507033	badly formed logical constant encountered
=ENDDOC
=DOC
val €spec_stmt_otherwise› : {spec : SPEC, label : LABEL} -> unit;
=DESCRIBE
ˇ€spec_stmt_otherwise›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	spec_stmt_common;
‹	Formal_Fun'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	speclabel_flag' = False;
‹	formal_body_flag = formal_body_flag';
‹	fun_flag = fun_flag';
‹	current_formal_fun' =  Formal_Fun';
‹	fun_header =  Informal_Fun';
‹	named_tills = named_tills';
‹	return =post';
‹	 In_Scope = flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹	€spec_stmt› ¶ spec_stmt_speclabel ≤ spec_stmt_otherwise
∞
=FAILURE
507015	label ?0 has already been introduced
=ENDDOC
\subsection{The SID function k\_slot\_stmt}
=DOC
val €k_slot_stmt› : LABEL -> SPEC;
=DESCRIBE
πZ
‹	€k_slot_stmt› ¶ spec_stmt
∞
=FAILURE
507015	label ?0 has already been introduced
=ENDDOC
\subsection{The SID function add\_log\_con\_env}
ˇ€LOGICAL_CON›¸¸¸¸¸¸¸¸¸
‹	logical_con : Z_Decl
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €add_log_con_env› : LOG_CON_DEF list -> unit;
=DESCRIBE
ˇ€add_log_con_env›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	LOGICAL_CON
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_log_cons(blocks 1, logical_con)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, this specification is insufficient. See implementation.
=FAILURE
507032	Declaration of ?0 has already been introduced 
=ENDDOC
\subsection{The SID function remove\_log\_con\_env}
=DOC
val €remove_log_con_env› : unit -> unit;
=DESCRIBE
ˇ€remove_log_con_env›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_log_cons(blocks 1, {})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function new\_block}
=TEX
=DOC
	val €new_block› : ID OPT -> unit;
=DESCRIBE
ˇ€new_block›¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑBlock
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block = blocks 1;
‹	 Block' = Block_body_flag ( Block, True);
‹	blocks' = blocks ´ ß Block'¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function update\_spec\_env\_block}
=TEX
=DOC
	val €update_spec_env_block› : unit -> unit;
=DESCRIBE
ˇ€update_spec_env_block›¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	Block'; Block'';
‹	ÑSpeclab'''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Speclab''' = spec_env spec_lab';
‹	w'''' = w''' ¿ {v : vc_vars' ∑ trans_id v.var};
‹	Pre'''' = z_many_and({Pre'''} ¿
‹	ﬁ {v : dom var_inits'; ze : Z_EXP; tm : TMARK
‹	 | ze = trans_exp(first(var_inits' v)) ± tm = second(var_inits' v)∑
‹		{z_eq(zid(trans_id v), slide_to_tmark(ze, tm))} ¿ domain_conds ze});
‹	 In_Scope'''' = merge_in_scopes ( In_Scope''',  In_Scope');
‹	 Speclab'''' = Speclab_in_scope(
‹			Speclab_w(Speclab_pre ( Speclab''', Pre''''), w''''),
‹			 In_Scope'''');
‹	spec_env' = spec_env ´ {spec_lab' Ì  Speclab''''}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{LOOPS}\label{LOOPS}
\subsection{The SID function new\_scope\_loop}
=DOC
	val €new_scope_loop› : ID OPT -> unit;
=DESCRIBE
ˇ €LOOP_NAME› ¸¸¸¸¸¸¸¸¸¸¸
‹ loop_name : OPT[ID]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ€new_scope_loop›¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	Empty_Block;
‹	LOOP_NAME;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	 Block' = blocks 1;
‹	pack_spec_flag = stub_flag = subunit_flag =
‹		declabel_flag = till_flag = body_flag = False;
‹	formal_body_flag = formal_body_flag';
‹	fun_flag = fun_flag';
‹	speclabel_flag = speclabel_flag';
‹	current_formal_proc = current_formal_proc';
‹	current_formal_fun = current_formal_fun';
‹	current_loop_name = loop_name;
‹	spec_lab = spec_lab'
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsection{The SID function end\_scope}

=DOC
val €end_scope› : unit -> unit;
=DESCRIBE
ˇ€end_scope›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = tail blocks
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507006	Internal error: running environment stack unexpectedly empty
=ENDDOC
\subsection{The SID function for\_param}
ˇ€FOR_PARAM›¸¸¸¸¸¸¸¸¸¸¸
‹	Param_Spec
˜¸¸¸¸¸¸¸
‹	mode = inn
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €for_param› : ID * TMARK -> unit;
=DESCRIBE
ˇ€for_param›¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FOR_PARAM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_pars(blocks 1, { Param_Spec})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, this specification is insufficient. See implementation.
=ENDDOC
\subsection{The SID function till\_pred}
ˇ€TILL_PRED›¸¸¸¸¸¸¸¸¸¸¸
‹	till : Z_PRED
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €till_pred› : ZUserInterfaceSupport.Z_TM -> unit;
=DESCRIBE
ˇ€till_pred›¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	TILL_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_till(Block_till_flag(blocks 1, True), till)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\section{SUBPROGRAM DECLARATIONS}\label{SUBPROGRAMDECLARATIONS}
The SID function $end\_scope$ used in processing these has already been defined in section \ref{LOOPS}.
\section{PROCEDURES}\label{PROCEDURES}
\subsection{The SID function subunit\_form}
ˇ€IDENT›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ident : ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €subunit_form› : ID -> unit;
=DESCRIBE
ˇ€subunit_form›¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑENV;
‹	Z_PARENTS;
‹	SUBUNIT_ENV;
‹	IDENT;
‹	ÑBlock;
‹	Subunit''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_flag = True;
‹	 Block = head blocks;
‹	blocks' = blocks ´ {1 Ì  Block'};
‹	parents = {zmod''.mod_name};
‹	z' = z Î ßz_parents( Z_PARENTS)¢;
‹	 Subunit'' = subunit_env(block_name, ident);
‹	block_name' = block_name;
‹	 Flags' =  Flags;
‹	 In_Scope' =  In_Scope''
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A unit ?0 containing subunit ?1 has not been introduced 
=ENDDOC
\subsection{The SID function subunit\_inf}
=DOC
	val €subunit_inf› : ID -> unit;
=DESCRIBE
ˇ€subunit_inf›¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	subunit_form
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_env' = {(block_name, ident)} · subunit_env
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A subunit ?0 containing ?1 has not been introduced 
=ENDDOC
\subsection{The SID function new\_scope\_proc\_inf}
=DOC
	val €new_scope_proc_inf› : ID -> unit;
=DESCRIBE
ˇ€new_scope_proc_inf›¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	formal_body_flag = fun_flag = declabel_flag = speclabel_flag =
‹	till_flag = body_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function new\_scope\_proc\_form}
=DOC
	val €new_scope_proc_form› : ID -> unit;
=DESCRIBE
ˇ€new_scope_proc_form›¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	formal_body_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = body_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function stub}
πZAX
‹	€make_module› : Z_ID ∏ seq Z_PARA ≠ seq Z_PARA
∞
πZAX
‹	€trans_subunit_name› : ID ∏ ID ≠ Z_ID
∞
=DOC
val €make_module› : int -> string -> Z_ID -> unit;
val €trans_subunit_name› : Z_ID -> Z_ID;
val €stub› : unit -> unit;
val €cn_subprog_ud_key› : string;
val €cn_new_parent_ud_key› : string;
val €get_script_theories› : string -> string list;
=DESCRIBE
ˇ€stub›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ÑZ_DOC;
‹	ENV;
‹	Subunit;
‹	id1, id2 : ID;
‹	Block';
‹	Block'';
‹	Block'''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stub_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Block''' = blocks 3;
‹ 	∂mod_name : Z_ID∑
‹		mod_name = trans_subunit_name(id1, id2) ±
‹		z' = make_module(mod_name, z) Î z ±
‹ 		zmod =  Z_MODULE;
‹	subunit_env' = subunit_env  ¿ {(id1, id2) Ì  Subunit};
‹		subunit_flag''' = True ± id1 = block_name''' dot block_name''
‹	≤	subunit_flag''' = False ± id1 = block_name'';
‹	id2 = block_name';
‹	specif_flag = False;
‹	 In_Scope = flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The extra parameters to {\em make\_module} are for error reporting.
=FAILURE
507013	A stub called ?0 has already been introduced
507140	The Compliance Notation theory information is corrupt
	(there is an infinite cycle through theory ?0)
507141	The theory ?0 is not a Compliance Notation script theory
=ENDDOC
\subsection{The SID function stub\_spec\_proc}
ˇ€FORM_PROC›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Formal_Proc
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €stub_spec_proc› : FORMAL_PROC -> unit;
=DESCRIBE
ˇ€stub_spec_proc›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	FORM_PROC;
‹	ÑSubunit;
‹	idâ1, idâ2 : ID;
‹	Block';
‹	Block'';
‹	Block'''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stub_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Block''' = blocks 3;
‹	subunit_env(idâ1, idâ2) =  Subunit;
‹	subunit_env' = subunit_env ´ {(idâ1, idâ2) Ì  Subunit'};
‹		subunit_flag''' = True ± idâ1 = block_name''' dot block_name''
‹	≤	subunit_flag''' = False ± idâ1 = block_name'';
‹	idâ2 = block_name';
‹	specif_flag' = True;
‹	specif' =  Spec;
‹	zmod' = zmod;
‹	globs' = globals;
‹	 In_Scope' = subprog_flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A subunit ?0 containing ?1 has not been introduced 
=ENDDOC
\subsection{The SID function form\_proc}
=DOC
val €form_proc_pack_spec› : FORMAL_PROC -> unit;
=DESCRIBE
ˇ€form_proc_pack_spec›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	FORM_PROC;
‹	ENV;
‹	Package;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = True;
‹	 Block'' = blocks 2;
‹	pack_env block_name'' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{block_name'' Ì
‹		Package_formal_procs( Package, formal_procs ¿ { Formal_Proc})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
507076	Internal error: data structure for formal procedure is invalid
=ENDDOC
=DOC
val €form_proc_pack_body_common› : bool -> FORMAL_PROC ->
			(BLOCK * FORMAL_PROC * PACKAGE * SPECLAB * ID list) OPT
=DESCRIBE
ˇ €form_proc_pack_body_common›¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC; PACK_ENV; FORM_PROC; ENV;
‹	Package'''';
‹	Speclab''''';
‹	Formal_Proc''';
‹	Block';
‹	Block'';
‹	st : Statement;
‹	pack_body_vars :  Var_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_body_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Package'''' = pack_env block_name'';
‹	block_name' ç {p : formal_procs'''' ∑ p.name};
‹	z' = z Î ßz_vcs(vcs( Speclab''''', st))¢;
‹	 Formal_Proc''' ç formal_procs''''; name''' = block_name';
‹	fun_flag''''' = False;
‹	vc_pars''''' = vc_pars'; vc_log_cons''''' = {};
‹	vc_aux_vars''''' = (subprog_flatten_env( ENV)).vc_aux_vars \ aux_vars'''';
‹	expand_schema_sigs (ran globals) \ w Ä expand_schema_sigs (ran globals''');
‹	pack_body_vars = vc_vars'' \ vc_vars'''';
‹	(		(st = spec_no_ivars( Spec))
‹		≤	(st = spec_ivars( Spec))
‹	)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
507058	When a procedure is implemented, each variable in the list of global dependencies
	must be in the frame or global dependencies in the specification.
	?0 is not contained in ?1 in the specification of ?2
=ENDDOC
=DOC
val €form_proc_pack_body› :
	(BLOCK * FORMAL_PROC * PACKAGE * SPECLAB * ID list) ->FORMAL_PROC -> 
		SPEC;
=DESCRIBE
ˇ €form_proc_pack_body›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	form_proc_pack_body_common
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(w'''  ¿ expand_schema_sigs(ran globals''')) ° {a : aux_vars'''' ∑ (ValueÁ~Í) a.zvar} = ö;
‹	w''''' = w''' ¿ {v : pack_body_vars ∑ trans_id v.var};
‹	Pre''''' = Pre''';
‹	post''''' = post''';
‹	vc_vars''''' = (flatten_env( ENV)).vc_vars
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_proc_pack_body_aux› :
	(BLOCK * FORMAL_PROC * PACKAGE * SPECLAB * ID list) ->
	TERM list -> FORMAL_PROC -> SPEC;
=DESCRIBE
ˇ  €form_proc_pack_body_aux›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	form_proc_pack_body_common;
‹	ENV;
‹	aux_vars, aux_vars0 :  Z_Decl;
‹	conc_vars :  Var_Decl;
‹	invs :  Z_PRED;
‹	Spec'''''';
‹	frame_aux_conc, frame_aux_conc0, add_aux, add_aux0 :  Z_ID;
‹	seq_aux : seq Z_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(w'''  ¿ expand_schema_sigs(ran globals''')) ° {a : aux_vars'''' ∑ (ValueÁ~Í) a.zvar} Ω ö;
‹	add_aux = {a : aux_vars'''' ∑ (ValueÁ~Í) a.zvar} \ w''';
‹	w'''''' = w''' ¿ add_aux;
‹	Pre'''''' = Pre''';
‹	post'''''' =
‹	z_many_and ({post'''} ¿
‹	  {a : add_aux ∑ z_eq(zid a, subs_exp(zid a, add_aux, add_aux0))});
‹	aux_vars = {a : aux_vars'''' | (ValueÁ~Í) a.zvar ç w''''''};
‹	conc_vars = ﬁ {x : using_decs'' ® w''''''© ∑ first x};
‹	invs = {x : using_decs'' ® w''''''© ∑ second x};
‹	frame_aux_conc = w'''''' ¿ {c : conc_vars ∑ trans_id c.var};
‹	# seq_aux = # aux_vars;
‹	ran seq_aux = aux_vars0;
‹	w''''' = frame_aux_conc ¿ {v : pack_body_vars ∑ trans_id v.var} \
‹	  {a : aux_vars ∑ (ValueÁ~Í) a.zvar};
‹	Pre''''' = z_exists (aux_vars, z_many_and ({Pre''''''} ¿ invs));
‹	post''''' =
‹	 z_forall (seq_aux, z_imp (subs_pred (z_many_and
‹	  ({Pre''''''} ¿ invs), frame_aux_conc, frame_aux_conc0),
‹	  z_exists (aux_vars, z_many_and ({post''''''} ¿ invs))));
‹	vc_vars''''' = (subprog_flatten_env( ENV)).vc_vars ¿ conc_vars
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_proc_subunit› : FORMAL_PROC -> unit;
=DESCRIBE
ˇ  €form_proc_subunit›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑSUBUNIT_ENV;
‹	FORM_PROC;
‹	ENV;
‹	Subunit''';
‹	Speclab'''';
‹	Block';
‹	Block'';
‹	st : Statement
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Subunit''' = subunit_env (block_name'', block_name');
‹	subunit_env' = {(block_name'', block_name')} · subunit_env;
‹	specif_flag''' = True;
‹	z' = z Î ßz_vcs(vcs( Speclab'''', st))¢;
‹	 Spec'''' = specif''';
‹	fun_flag'''' = False;
‹	vc_vars'''' = vc_vars''';
‹	vc_pars'''' = vc_pars' ¿ vc_pars''';
‹	vc_log_cons'''' = {}
‹	vc_aux_vars'''' = vc_aux_vars''';
‹	expand_schema_sigs(ran globals) \ w Ä expand_schema_sigs (ran globs''');
‹	(	(st = spec_no_ivars( Spec))
‹	  ≤ 	(st = spec_ivars( Spec))
‹	)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_proc› : bool -> FORMAL_PROC -> unit;
=DESCRIBE
πZ
‹	€form_proc› ¶ 	form_proc_pack_spec ≤ form_proc_pack_body ≤
‹			form_proc_pack_body_aux ≤ form_proc_subunit 
∞
=ENDDOC
\subsection{The SID function curr\_form\_proc}
=DOC
	val €curr_form_proc› : FORMAL_PROC -> unit;
=DESCRIBE
ˇ€curr_form_proc›¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FORM_PROC
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' =
‹	blocks ´ {1 Ì Block_current_formal_proc(blocks 1,  Formal_Proc)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{FUNCTIONS}\label{FUNCTIONS}
\subsection{The SID function new\_scope\_fun\_inf}
=DOC
	val €new_scope_fun_inf› : ID -> unit;
=DESCRIBE
ˇ€new_scope_fun_inf›¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	fun_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	formal_body_flag = declabel_flag = speclabel_flag =
‹	till_flag = body_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function new\_scope\_fun\_form}
=DOC
	val €new_scope_fun_form› : ID -> unit;
=DESCRIBE
ˇ€new_scope_fun_form›¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	formal_body_flag = fun_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = body_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function stub\_spec\_fun}
ˇ€FORM_FUN›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Formal_Fun
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €stub_spec_fun› : FORMAL_FUN -> unit;
=DESCRIBE
ˇ  €stub_spec_fun›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	FORM_FUN;
‹	ÑSubunit;
‹	idâ1, idâ2 : ID;
‹	Block';
‹	Block'';
‹	Block'''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stub_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Block''' = blocks 3;
‹	subunit_env(idâ1, idâ2) =  Subunit;
‹	subunit_env' = subunit_env ´ {(idâ1, idâ2) Ì  Subunit'};
‹		subunit_flag''' = True ± idâ1 = block_name''' dot block_name''
‹	≤	subunit_flag''' = False ± idâ1 = block_name'';
‹	idâ2 = block_name';
‹	specif_flag' = True;
‹	specif' =  Spec;
‹	zmod' = zmod;
‹	 In_Scope' =  In_Scope;
‹	globs' = globals
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A subunit ?0 containing ?1 has not been introduced 
=ENDDOC
\subsection{The SID function inf\_fun}
ˇ€INF_FUN›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Informal_Fun
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
=DESCRIBE
πZAX
‹ €informal_function› : Z_ID
∞
πZAX
‹	€inf_fun_decl› : Informal_Fun ≠ Z_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ Informal_Fun; Z_Decl∑
‹	inf_fun_decl (  Informal_Fun) =  Z_Decl §
‹		zvar = Value(trans_id name) ±
‹		zexp = zid(informal_function)
∞
Since it is needed in $trans\_informal\_fun$, the ML coding of the
function returns the Z name as well as just the declaration.
=FAILURE
507096	?0 has already been declared;
	it cannot be used as the name of an informal function here
=ENDDOC
=DOC
val €inf_fun_pack_spec› : INFORMAL_FUN -> unit;
=DESCRIBE
ˇ€inf_fun_pack_spec›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	INF_FUN;
‹	ENV;
‹	Package;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = True;
‹	 Block'' = blocks 2;
‹	pack_env block_name'' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{block_name'' Ì
‹		Package_informal_funs( Package, informal_funs Î ß Informal_Fun¢)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €trans_informal_fun› : PREFIX_INFO -> INFORMAL_FUN -> ZParagraphs.PARAINFO;
=DESCRIBE
πZAX
‹	€trans_informal_fun› : Informal_Fun ≠ Z_Ax
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µf: Informal_Fun; Z_Ax∑
‹	trans_informal_fun f =  Z_Ax § decls = {inf_fun_decl f} ± preds = {}
∞
=ENDDOC
πZAX
‹ €add_fun_ax› : (seq Z_PARA) ∏ Z_PARA ≠ seq Z_PARA
˜¸¸¸¸¸¸
‹ µz : seq Z_PARA; para : Z_PARA∑
‹	para ç  ran z ± add_fun_ax(z, para) = z
‹ ≤	para é ran z ± add_fun_ax(z, para) = z Î ßpara¢
∞

=DOC
val €inf_fun_otherwise› : PREFIX_INFO -> INFORMAL_FUN -> unit;
=DESCRIBE
ˇ€inf_fun_otherwise›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	INF_FUN;
‹	ENV;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = False;
‹	 Block'' = blocks 2;
‹	z' = add_fun_ax(z, z_ax(trans_informal_fun( Informal_Fun)))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €inf_fun› : INFORMAL_FUN -> unit;
=DESCRIBE
πZ
‹	€inf_fun› ¶ inf_fun_pack_spec ≤ inf_fun_otherwise
∞
=ENDDOC
\subsection{The SID function form\_fun}
=DOC
val €form_fun_pack_spec› : FORMAL_FUN -> unit;
=DESCRIBE
ˇ€form_fun_pack_spec›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	FORM_FUN;
‹	ENV;
‹	Package;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = True;
‹	 Block'' = blocks 2;
‹	pack_env block_name'' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{block_name'' Ì
‹		Package_formal_funs( Package, formal_funs Î ß Formal_Fun¢)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €z_forall_opt› : (Z_DECL list * Z_PRED) -> Z_PRED;
=DESCRIBE
πZAX
‹	€z_forall_opt› : (seq Z_Decl) ∏ Z_PRED ≠ Z_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ zdecs: seq Z_Decl; zpred : Z_PRED; zres : Z_PRED∑
‹	z_forall_opt (zdecs, zpred) = zres §
‹		zdecs = ß¢ ± zres = zpred ≤
‹		zdecs Ω ß¢ ± zres = z_forall(zdecs, zpred)
∞
=ENDDOC
=DOC
val €fun_sig› : (Z_EXP list * Z_EXP) -> Z_EXP;
val €par_tmark› : CN_ENV -> PARAM_SPEC -> Z_ID list;
val €var_sig› : CN_ENV -> Z_ID -> Z_EXP;
val €fun_decl› : CN_ENV -> FORMAL_FUN -> Z_DECL;
=DESCRIBE
πZAX
‹	€fun_sig› : (seq Z_EXP) ∏ Z_EXP ≠ Z_EXP
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ zpars : seq Z_EXP; zret : Z_EXP; zsig : Z_EXP∑
‹	fun_sig (zpars, zret) = zsig §
‹		zpars = ß¢ ± zsig = zret ≤
‹		zpars Ω ß¢ ± zsig = z_tfun(z_many_cross zpars, zret)
∞
πZAX
‹	€par_tmark› : Param_Spec ≠ Z_ID
∞
πZAX
‹	€var_sig› : ENV ≠ Z_ID ≠ Z_EXP
∞
πZAX
‹	€fun_decl› : ENV ≠ Formal_Fun ≠ Z_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ env : ENV;  Formal_Fun; Z_Decl∑
‹	fun_decl env (  Formal_Fun) =  Z_Decl §
‹		zvar = Value(trans_id name) ±
‹		zexp = fun_sig(map (var_sig env) globals,
‹				fun_sig(map (zid o par_tmark) formal_pars,
‹					zid(trans_id return_type)))
∞
The implementation of these functions are included as part of the VC generator as a) they are required there and b) this module depends on the VC generator. The names are included in this signature for traceability purposes.

$par\_tmark$ returns a list of type marks one for each parameter declared
in the $PARAM\_SPEC$ argument.
=ENDDOC
=DOC
val €z_par_decl› : PARAM_SPEC -> Z_DECL;
=DESCRIBE
πZAX
‹	€z_par_decl› : Param_Spec ≠ Z_Decl
∞
=ENDDOC
=DOC
val €z_vars_of_env› : CN_ENV -> Z_ID -> bool;
val €z_var_decl› : CN_ENV -> Z_ID -> Z_DECL;
=DESCRIBE
πZAX
‹	€z_vars_of_env› : ENV ≠ Z_ID
˜
‹ µENV; zi : Z_ID∑ zi ç z_vars_of_env ( ENV) §
‹	(∂i: dom blocks; Var_Decl∑
‹	 Var_Decl ç (blocks i).vc_vars ± trans_id var = zi)
‹ ≤	(∂i: dom blocks; Param_Spec∑
‹	 Param_Spec ç (blocks i).vc_pars ± trans_id var = zi)
‹ ≤	(∂i: dom blocks; Z_Decl[Z_EXP]∑
‹	 Z_Decl ç (blocks i).vc_aux_vars ± zvar = Value zi)
∞
πZAX
‹	€z_var_decl› : ENV ≠ Z_ID ≠ Z_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µenv: ENV; zname : Z_ID; Z_Decl∑
‹	z_var_decl env zname =  Z_Decl §
‹	(zname ç z_vars_of_env env ±
‹	zvar = Value zname ±  zexp = var_sig env zname)
‹	≤
‹	(zname é z_vars_of_env env ±
‹	zvar = Nil ±  zexp = zid zname)
∞
=ENDDOC
=DOC
val €trans_formal_fun› : PREFIX_INFO -> CN_ENV -> FORMAL_FUN -> ZParagraphs.PARAINFO * Z_PRED * Z_PRED * Z_ID;
=DESCRIBE
πZAX
‹	€trans_formal_fun› : ENV ≠ Formal_Fun ﬂ Z_Ax
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µenv : ENV; Formal_Fun; Z_Ax∑
‹	trans_formal_fun env ( Formal_Fun) =  Z_Ax §
‹		decls = {fun_decl env ( Formal_Fun)} ±
‹		preds = {z_forall_opt(map (z_var_decl env) globals,
‹				z_forall_opt(map z_par_decl formal_pars,
‹					z_imp(Pre, post)))}
∞
The ML function also returns the type-checked pre- and post-conditions.
=FAILURE
507067	Internal error: unexpected return value from trans_formal_fun
507068	The Z global variable ?0 has already been introduced and the
	declaration of function ?1 clashes with it
=ENDDOC
=DOC
val €trans_formal_fun_name› : PREFIX_INFO -> CN_ENV ->  PACKAGE OPT -> FORMAL_FUN -> Z_EXP;
=DESCRIBE
πZAX
‹	€trans_formal_fun_name› : Formal_Fun ﬂ Z_EXP
∞
πZAX
‹	€subs_exp_for_exp_in_pred› : Z_PRED ∏ Z_EXP ∏ Z_EXP ≠ Z_PRED
∞
=ENDDOC
=DOC
val €form_fun_pack_body_common› : bool -> FORMAL_FUN -> 
			(BLOCK * FORMAL_FUN * PACKAGE * SPECLAB) OPT
=DESCRIBE
ˇ€form_fun_pack_body_common›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	PACK_ENV;
‹	FORM_FUN;
‹	ENV;
‹	Package'''';
‹	Speclab''''';
‹	ref : seq Z_PARA;
‹	Formal_Fun''';
‹	Block';
‹	Block'';
‹	st : Statement
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_body_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	z' =add_fun_ax(z, z_ax(trans_formal_fun( ENV)( Formal_Fun))) Î ref;
‹	 Package'''' = pack_env block_name'';
‹	(
‹		block_name' ç {f : ran formal_funs'''' ∑ f.name}
‹	±	ref = ßz_vcs(vcs( Speclab''''', st))¢
‹	±	(st = spec_no_ivars( Spec) ≤ st = spec_ivars( Spec))
‹	±	 Formal_Fun''' ç ran formal_funs'''' ± name''' = block_name'
‹	±	formal_body_flag''''' = True
‹	±	fun_flag''''' = True
‹	±	fun_header''''' =  Informal_Fun
‹	±	vc_pars''''' = vc_pars' ± vc_log_cons''''' = {}
‹	±	vc_vars''''' = (subprog_flatten_env( ENV)).vc_vars
‹	±	vc_aux_vars''''' = (subprog_flatten_env( ENV)).vc_aux_vars \ aux_vars''''
‹	)
‹	≤
‹		(block_name' é {f : ran formal_funs'''' ∑ f.name} ± ref = ß¢)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_fun_pack_body› : 
	(BLOCK * FORMAL_FUN * PACKAGE * SPECLAB) -> FORMAL_FUN ->  unit;
=DESCRIBE
ˇ€form_fun_pack_body›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	form_fun_pack_body_common
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	expand_schema_sigs(ran globals''') ° Value Á~Í ®{ a : aux_vars''''∑a.zvar}© = ö;
‹	globals = globals''';
‹	Pre''''' = Pre''';
‹	post''''' = post'''
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507050	When a function is implemented in a package body,
	unless the formal function in the package specification ontains auxiliary variables, 
	the list of global dependencies in the package body
	must be the same as in the package specification. ?0 does not agree with
	?1 in the specification of ?2
=ENDDOC
=DOC
val €form_fun_pack_body_aux› : 
	(BLOCK * FORMAL_FUN * PACKAGE * SPECLAB) -> 
	TERM list -> FORMAL_FUN ->  unit;
=DESCRIBE
ˇ€form_fun_pack_body_aux›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	form_fun_pack_body_common;
‹	aux_vars : Z_Decl;
‹	invs : Z_PRED;
‹	seq_aux : seq Z_Decl;
‹	afunc, cfunc : Z_EXP;
‹	conc_ids : ID
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	expand_schema_sigs(ran globals''') ° Value Á~Í ®{ a : aux_vars''''∑a.zvar}© = ö;
‹	aux_vars = {a : aux_vars'''' | (ValueÁ~Í) a.zvar ç expand_schema_sigs(ran globals''')};
‹	invs = {x : using_decs'' ®  expand_schema_sigs(ran globals''') © ∑ second x};
‹	conc_ids =  {d : ﬁ {x : using_decs'' ®  expand_schema_sigs(ran globals''') © ∑ first x} ∑ d.var} ¿
‹		trans_id  Á~Í ®expand_schema_sigs(ran globals''') \ Value Á~Í ® {a : aux_vars∑ a.zvar}© ©;
‹	#seq_aux = #aux_vars;
‹	ran seq_aux = aux_vars;
‹	afunc = trans_formal_fun_name( Formal_Fun''');
‹	cfunc = trans_formal_fun_name( Formal_Fun);
‹	Pre''''' = z_exists (aux_vars, z_many_and ({Pre'''} ¿ invs));
‹	post''''' =
‹	 z_forall (seq_aux, z_imp (z_many_and ({Pre'''} ¿ invs),
‹	  z_exists (aux_vars,
‹	    z_many_and ({subs_exp_for_exp_in_pred(post''', afunc, cfunc)} ¿ invs))))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
507095	When a function is implemented in a package body, if the 
	formal function in the package specification contains auxiliary variables,
	then each variable in the list of global dependencies in the package body
	must either appear in the global dependency list in the package specification or must be a using
	variable implementing one of the auxiliary variables in the specification.
	?0 in the specification of ?1 violates this rule.
=ENDDOC
=DOC
val €form_fun_subunit› : FORMAL_FUN -> unit;
=DESCRIBE
ˇ €form_fun_subunit›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑSUBUNIT_ENV;
‹	FORM_FUN;
‹	ENV;
‹	Subunit''';
‹	Speclab'''';
‹	ref : seq Z_PARA;
‹	Block';
‹	Block'';
‹	st : Statement
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	z' = add_fun_ax(z, z_ax(trans_formal_fun( ENV)( Formal_Fun))) Î ref;
‹	 Subunit''' = subunit_env (block_name'', block_name');
‹	subunit_env' = {(block_name'', block_name')} · subunit_env;
‹		specif_flag''' = True
‹	±	ref = ßz_vcs(vcs( Speclab'''', st))¢
‹	±	(st = spec_no_ivars( Spec) ≤ st = spec_ivars( Spec))
‹	±	 Spec'''' = specif''' ± formal_body_flag'''' = True
‹	±	fun_flag'''' = True
‹	±	fun_header'''' =  Informal_Fun ± vc_vars'''' = {}
‹	±	vc_pars'''' = vc_pars' ¿ vc_pars''' ± vc_log_cons'''' = {}
‹	±	vc_aux_vars''' = {} ± globals = globs'''
‹	≤
‹		specif_flag''' = False ± ref = ß¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_fun_otherwise› : FORMAL_FUN -> unit;
=DESCRIBE
ˇ€form_fun_otherwise›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	FORM_FUN;
‹	ENV;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = pack_body_flag'' = subunit_flag'' = False;
‹	 Block'' = blocks 2;
‹	z' = add_fun_ax(z, z_ax(trans_formal_fun( ENV)( Formal_Fun)))
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €form_fun› : bool -> FORMAL_FUN -> unit;
=DESCRIBE
πZ
‹	€form_fun› ¶ 	form_fun_pack_spec ≤ form_fun_pack_body ≤
‹			form_fun_pack_body_aux ≤ form_fun_subunit ≤ form_fun_otherwise
∞
=ENDDOC
\subsection{The SID function curr\_form\_fun}
=DOC
	val €curr_form_fun› : FORMAL_FUN -> unit;
=DESCRIBE
ˇ€curr_form_fun›¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FORM_FUN
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_current_formal_fun(blocks 1,  Formal_Fun)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{FORMAL PARAMETERS}\label{FORMALPARAMETERS}
ˇ€FORMALS›¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	formals :  Param_Spec
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\subsection{The SID function formal\_part}
=DOC
	val €fformal_part› : PARAMETER_SPECIFICATION list -> unit;
=DESCRIBE
ˇ€formal_part›¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FORMALS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_pars(blocks 1, formals)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{SUBPROGRAM BODIES}\label{SUBPROGRAMBODIES}
\subsection{The SID function update\_envs\_proc}
=DOC
	val €update_subunit_env_proc› : PREFIX_INFO -> unit;
=DESCRIBE
ˇ€update_subunit_env_proc›¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	declabel_flag'' = formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	#subunit_env = #subunit_env';
‹	µidâ1, idâ2 : ID; s, s' : Subunit |
‹		subunit_env(idâ1, idâ2) = s ± subunit_env'(idâ1, idâ2) = s'
‹	∑	dec_lab'' ç s.dec_labels ±
‹		s' =
‹		Subunit_formal_procs(s, s.formal_procs ¿ {current_formal_proc'})
‹	≤	dec_lab'' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_dec_env_proc› : PREFIX_INFO -> unit;
=DESCRIBE
ˇ€update_dec_env_proc›¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	declabel_flag'' = formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	#dec_env = #dec_env';
‹	µdec_label : LABEL; d, d' : Declab |
‹		dec_env dec_label = d ± dec_env' dec_label = d'
‹	∑	dec_lab'' ç d.dec_labels ±
‹		d' =
‹		Declab_formal_procs(d, d.formal_procs ¿ {current_formal_proc'})
‹	≤	dec_lab'' é d.dec_labels ± d' = d
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_spec_env_proc› : PREFIX_INFO ->  unit;
=DESCRIBE
ˇ€update_spec_env_proc›¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	declabel_flag'' = formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	#spec_env = #spec_env';
‹	µspec_label : LABEL; s, s' : Speclab |
‹		spec_env spec_label = s ± spec_env' spec_label = s'
‹	∑	dec_lab'' ç s.dec_labels ±
‹		s' =
‹		Speclab_formal_procs(s, s.formal_procs ¿ {current_formal_proc'})
‹	≤	dec_lab'' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_envs_proc› : PROCEDURE_SPECIFICATION -> unit;
=DESCRIBE
πZ
‹ €update_envs_proc› ¶ update_subunit_env_proc ± update_dec_env_proc
‹			± update_spec_env_proc
∞
=ENDDOC
\subsection{The SID function add\_proc\_env}
=DOC
	val €add_proc_env› : ID -> unit;
=DESCRIBE
ˇ€add_proc_env›¸¸¸¸¸¸¸
‹	ÑENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	blocks' =
‹	blocks ´ {2 Ì Block_formal_procs( Block'',
‹			formal_procs'' ¿ {current_formal_proc'})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507066	A declaration for formal procedure ?0 has already been processed;
	the specification statements in the two declarations do not agree
507051	A declaration for procedure ?0 has already been processed;
=ENDDOC
\subsection{The SID function subprogram\_implementation}
=DOC
	val €subprogram_implementation› : {is_proc: bool} -> string;
=DESCRIBE
ˇ€subprogram_implementation›¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FORMALS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_body_flag(blocks 1, True)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The ML function creates the new theory for the subprogram and makes it current and returns the name of the theory that was current previously, so that caller can revert to it when the subprogram body has been processed.

=ENDDOC

\subsection{The SID function vcs\_body}
ˇ€SEQ_STMTS›¸¸¸¸
‹	st : Statement
à¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €vcs_body_proc› : STATEMENT -> SPEC;
=DESCRIBE
ˇ €vcs_body_proc›¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ENV;
‹	SEQ_STMTS;
‹	Speclab;
‹	Formal_Proc';
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	formal_body_flag' = True;
‹	fun_flag' = False;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	z' = z Î ßz_vcs(vcs( Speclab, st))¢;
‹	current_formal_proc' =  Formal_Proc';
‹	Pre = z_many_and({Pre'} ¿
‹	ﬁ{v : dom var_inits'; ze : Z_EXP; tm : TMARK
‹	 | ze = trans_exp(first(var_inits' v)) ± tm = second(var_inits' v)∑
‹		{z_eq(zid(trans_id v), slide_to_tmark(ze, tm))} ¿ domain_conds ze});
‹	post = post';
‹	fun_flag = False;
‹	return = post';
‹	 In_Scope = subprog_flatten_env( ENV);
‹	w = w' ¿ {v : vc_vars' ∑ trans_id v.var}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €vcs_body_fun› : STATEMENT -> SPEC;
=DESCRIBE
ˇ€vcs_body_fun›¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ENV;
‹	SEQ_STMTS;
‹	Speclab;
‹	Formal_Fun';
‹	Block'
˜¸¸¸¸¸¸¸¸
‹	formal_body_flag' = True;
‹	fun_flag' = True;
‹	 Block' = blocks 1;
‹	z' = z Î ßz_vcs(vcs( Speclab, st))¢;
‹	current_formal_fun' =  Formal_Fun';
‹	w = {v : vc_vars' ∑ trans_id (v.var)};
‹	Pre = z_many_and({Pre'} ¿
‹	ﬁ{v : dom var_inits'; ze : Z_EXP; tm : TMARK
‹	 | ze = trans_exp(first(var_inits' v)) ± tm = second(var_inits' v)∑
‹		{z_eq(zid(trans_id v), slide_to_tmark(ze, tm))} ¿ domain_conds ze});
‹	post = post';
‹	formal_body_flag = fun_flag = True;
‹	fun_header=  Informal_Fun';
‹	return = post';
‹	 In_Scope = subprog_flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, this specification is insufficient. See implementation.
=ENDDOC
=DOC
	val €vcs_body› : STATEMENT -> unit;
=DESCRIBE
πZ
‹	€vcs_body› ¶ vcs_body_proc ≤ vcs_body_fun
∞
=ENDDOC
\section{PACKAGES}\label{PACKAGES}
\subsection{The SID function new\_scope\_pack\_spec}
=DOC
	val €empty_package› : DECLARATION PACKAGE_DECLARATION -> PACKAGE;
=DESCRIBE
ˇ€Empty_Package›¸¸¸¸¸¸¸
‹	Package
˜¸¸¸¸¸¸¸¸
‹	vc_vars = {};
‹	consts_types = ß¢;
‹	formal_procs = {};
‹	informal_funs = ß¢;
‹	formal_funs = ß¢;
‹	aux_vars = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €new_scope_pack_spec› : ID -> DECLARATION PACKAGE_DECLARATION -> unit;
=DESCRIBE
ˇ€new_scope_pack_spec›¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑPACK_ENV;
‹	IDENT;
‹	Empty_Block;
‹	Empty_Package
˜¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	pack_spec_flag = True;
‹	pack_body_flag = stub_flag = subunit_flag = formal_body_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = body_flag = False;
‹	pack_env' = pack_env ¿ {ident Ì  Package}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507007	The name ?0 has already been used for a package
=ENDDOC
\subsection{The SID function new\_scope\_pack\_body}
=DOC
	val €new_scope_pack_body› : ID -> unit;
=DESCRIBE
ˇ€new_scope_pack_body›¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑENV;
‹	Z_PARENTS;
‹	IDENT;
‹	PACK_ENV;
‹	Block;
‹	Block';
‹	Package'
˜¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	(subunit_flag' = False ±
‹		parents = {zmod'.mod_name} ± z' = z Î ßz_parents( Z_PARENTS)¢ ≤
‹	 subunit_flag' = True ± z' = z);
‹	blocks' = ß  Block¢ Î blocks;
‹	 Package' = pack_env ident;
‹	block_name = ident;
‹	pack_body_flag = body_flag = True;
‹	pack_spec_flag = stub_flag = subunit_flag = formal_body_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = False;
‹	vc_vars = vc_vars';
‹	vc_pars = {};
‹	vc_log_cons = {};
‹	vc_aux_vars = {};
‹	formal_procs = {};
‹	dec_labels = {};
‹	using_decs = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
=ENDDOC
\pagebreak
\subsection{The SID function new\_scope\_with}
πZAX
‹	€new_ids› : Package ≠  ID
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µPackage∑
‹	new_ids( Package) = 
‹	{v : vc_vars ∑ v.var} ¿
‹	{c : Const_Decl | const_decl c ç ran consts_types ∑ c.const} ¿
‹	{t : Type_Decl | type_decl t ç ran consts_types ∑ t.name} ¿
‹	{ident : ID; Type_Decl; Enum_Type_Def |
‹		type_decl( Type_Decl) ç ran consts_types ±
‹		type_def = enum_type_def( Enum_Type_Def) ±
‹		ident ç ran vals ∑ ident} ¿
‹	{s : Subtype_Decl | subtype_decl s ç ran consts_types ∑ s.name} ¿
‹	{p : formal_procs ∑ p.name} ¿
‹	{f : ran informal_funs ∑ f.name} ¿
‹	{f : ran formal_funs∑ f.name}
∞
πZAX
‹	€prefix› : (ID ∏ ID ∏ Package) ≠ Package
∞
πZAX
‹	€z_prefix› : (ID ∏ ID ∏ Z_MODULE) ≠ seq Z_PARA
∞
=DOC
	val €new_scope_with› : ID -> unit;
=DESCRIBE
ˇ €new_scope_with›¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑENV;
‹	Z_MODULE;
‹	Z_PARENTS;
‹	IDENT;
‹	PACK_ENV;
‹	Block;
‹	Package';
‹	Z_DOC''
˜¸¸¸¸¸¸¸¸
‹	ident ç dom pack_env;
‹	z_module(  Z_MODULE) é ran z;
‹	z' = z'' Î z Î ßz_parents(  Z_PARENTS)¢;
‹	z'' = z_prefix(ident, new_ids(pack_env ident), (pack_env ident).zmod) Î
‹		map (trans_informal_fun ª z_ax) informal_funs'Î
‹		map (trans_formal_fun ( ENV)ª z_ax) formal_funs';
‹	head z'' = z_module(  Z_MODULE);
‹	parents = {mod_name};
‹	blocks' = ß  Block¢ Î blocks;
‹	 Package' = prefix(ident, new_ids(pack_env ident), pack_env ident);
‹	pack_body_flag = pack_spec_flag = stub_flag = subunit_flag =
‹	formal_body_flag = fun_flag = declabel_flag =
‹	speclabel_flag = till_flag = body_flag = False;
‹	vc_vars = vc_vars';
‹	vc_pars = {};
‹	vc_log_cons = {};
‹	vc_aux_vars = aux_vars';
‹	formal_procs = formal_procs';
‹	dec_labels = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €package_ids› : ID -> ID list;
=DESCRIBE
This is the composite of a look-up in the package environment and {\it new\_ids}
for the convenience of checking use clauses in the SPARK output function.
If there is no package environment entry, an empty list is returned (and checks
made in the Z Generator will have raised an exception unless the package was
introduced via an arbitrary replacement).
=ENDDOC
\subsection{The SID function update\_envs\_pack\_spec}
=DOC
=DESCRIBE
ˇ €update_envs_pack_spec› ¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑENV;
‹	Block';
‹	In_Scope;
‹	IDENT;
‹	PACK_ENV;
‹	Package''
˜¸¸¸¸¸¸¸¸
‹	body_flag' = True;
‹	 Block' = blocks 1;
‹	blocks' = blocks ´ {1 Ì Block_in_scope( Block',  In_Scope)};
‹	z' = z Î z_prefix(ident, new_ids(pack_env ident), (pack_env ident).zmod) ;
‹	 Package'' = prefix(ident, new_ids(pack_env ident), pack_env ident);
‹	vc_vars = vc_vars' ¿ vc_vars'';
‹	vc_pars = vc_pars';
‹	vc_log_cons = vc_log_cons';
‹	vc_aux_vars = vc_aux_vars' ¿ aux_vars'';
‹	formal_procs = formal_procs' ¿ formal_procs'';
‹	dec_labels = dec_labels'
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507060	Internal error: the package environment entry for ?0 has gone missing
=ENDDOC
\subsection{The SID function end\_scope\_comp\_unit}
=DOC
val €end_scope_comp_unit› : unit -> unit;
=DESCRIBE
ˇ€end_scope_comp_unit›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = ßblocks 1¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function aux\_var}
$AUX\_VAR$ is declared in \cite{ISS/HAT/DAZ/DTD502}.
=DOC
val €aux_var› : AUX_VAR -> unit;
=DESCRIBE
ˇ €aux_var› ¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	AUX_VAR;
‹	ÑENV;
‹	Package;
‹	Block'
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	pack_env block_name' =  Package;
‹	pack_env' =
‹	 pack_env ´
‹	 {block_name' Ì Package_aux_vars( Package, aux_vars ¿ {aux})};
‹	blocks' =
‹	blocks ´ {1 Ì Block_vc_aux_vars( Block', vc_aux_vars' ¿ {aux})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507032	Declaration of ?0 has already been introduced 
=ENDDOC
\subsection{The SID function using\_dec}
$USING\_DEC$ is declared in \cite{ISS/HAT/DAZ/DTD502}.
=DOC
val €using_dec› : USING_DEC -> unit;
=DESCRIBE
ˇ€using_dec›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	USING_DEC;
‹	Block'
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	blocks' =
‹	 blocks ´
‹	 {1 Ì
‹	  Block_using_decs
‹	   (blocks 1, using_decs' ¿ {aux Ì (concrete_vars, invariant)})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507031	A usng declaration for the auxiliary variable ?0 has already been processed
507037	Usng declarations are only allowed  in package bodies
=ENDDOC
\subsection{The SID function vcs\_aux\_initial}
=DOC
val €vcs_aux_initial› : STATEMENT -> SPEC;
=DESCRIBE
ˇ€vcs_aux_initial›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ENV;
‹	SEQ_STMTS;
‹	PACK_ENV;
‹	Block';
‹	Speclab
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	z' = z Î ß z_vcs (vcs ( Speclab, st))¢;
‹	vc_vars = vc_vars';
‹	vc_pars = {};
‹	vc_log_cons = {};
‹	vc_aux_vars = {};
‹	formal_procs = formal_procs';
‹	fun_flag = False;
‹	w = {v : vc_vars' ∑ trans_id v.var};
‹ 	Pre = z_many_and(
‹        {v : dom var_inits'; ze : Z_EXP; tm : TMARK
‹	 | ze = trans_exp(first(var_inits' v)) ± tm = second(var_inits' v)
‹	 ∑ z_eq(zid(trans_id v), slide_to_tmark(ze, tm))});
‹	post =
‹	 z_exists
‹	 ((pack_env block_name').aux_vars,
‹	 z_many_and {x : ran using_decs' ∑ second x})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{RENAMING DECLARATIONS AND USE CLAUSES}\label{RENAMINGDECLARATIONS}
\subsection{The SID function renames\_proc}
ˇ€RENAMES_NEW›¸¸¸¸¸¸¸¸¸¸¸
‹	new:ID;
‹	formal_pars : seq Param_Spec
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ€RENAMES_OLD›¸¸¸¸¸¸¸¸¸¸¸
‹	pack : OPT[ID];
‹	old:ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=DOC
val €renames_proc_common› : FORMAL_PROC list -> SUBPROGRAM_RENAMING -> FORMAL_PROC OPT;
=DESCRIBE
ˇ€renames_proc_common›¸¸¸¸¸¸¸¸¸¸¸
‹	ENV;
‹	PACK_ENV;
‹	RENAMES_NEW;
‹	RENAMES_OLD;
‹	Package;
‹	Block';
‹	Formal_Proc'';
‹	Formal_Proc'''
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	(∂n: ID∑ pack = Value n ±
‹		name'' = n dot old ±
‹		 Package = prefix(n, new_ids(pack_env n), pack_env n))
‹ ≤	(pack = Nil ±
‹		name'' = old ± formal_procs = (flatten_env( ENV)).formal_procs);
‹	 Formal_Proc'' ç formal_procs;
‹	name''' = new;
‹	formal_ids''' = formal_ids'';
‹	globals''' = globals'';
‹	 Spec''' =  Spec''
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €renames_proc_pack_spec› : SUBPROGRAM_RENAMING -> unit;
val €renames_proc_otherwise› : SUBPROGRAM_RENAMING -> unit;
val €renames_proc› : SUBPROGRAM_RENAMING -> unit;
=DESCRIBE
ˇ €renames_proc_pack_spec› ¸¸¸¸¸¸¸¸¸¸¸
‹ ÑPACK_ENV;
‹ renames_proc_common;
‹ Package''
˜¸¸¸¸¸¸
‹ pack_spec_flag' = True;
‹ pack_env block_name' =  Package'';
‹ pack_env' =
‹ pack_env ´  { block_name' Ì
‹   Package_formal_procs( Package'', formal_procs'' ¿ { Formal_Proc'''})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ €renames_proc_otherwise› ¸¸¸¸¸¸¸¸¸¸¸
‹ ÑENV;
‹ renames_proc_common
˜¸¸¸¸¸¸
‹ pack_spec_flag' = False;
‹ blocks' = blocks ´ { 1 Ì
‹    Block_formal_procs( Block', formal_procs' ¿ { Formal_Proc'''})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ €renames_proc› ¶ renames_proc_pack_spec ≤ renames_proc_otherwise
∞

=FAILURE
507059	The renaming declaration for ?0 as ?1  cannot be handled formally
	(the renaming declaration is not consistent with the declaration of ?0)
507052	The renaming declaration for ?0 as ?1  cannot be handled formally
	(?0 is already defined as a formal procedure)
507061	The renaming declaration for ?0 as ?1  cannot be handled formally
	(package ?1 has already been processed)
507062	The renaming declaration for ?0 as ?1  cannot be handled formally
	(package ?0 has not been processed)
507063	The use clause for package ?0 cannot be handled formally
	(package ?0 has not been processed)
507064	The renaming declaration for ?0 as ?1  cannot be handled formally
	(either ?0 has not been processed formally or ?1 is already in scope in the Ada program
	or the declaration for ?1 is not compatible with that of ?0)
507073	The use clause for package ?0 cannot be handled formally (?1)
507074	The renaming declaration for package ?0 as ?1 cannot be handled formally (?2)
507075	The required abbreviation definition ?0 = ?1 is incompatible with the existing definition
=ENDDOC
\subsection{The SID function renames\_fun}

=DOC
val €renames_fun› : SUBPROGRAM_RENAMING -> unit;
=DESCRIBE
ˇ€renames_fun›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	RENAMES_NEW;
‹	RENAMES_OLD
˜¸¸¸¸¸¸¸
‹	(∂n: ID∑ pack = Value n ±
‹		z' = z Î ßz_eq_eq(trans_id new, zid(trans_id(n dot old)))¢)
‹ ≤	(pack = Nil ±
‹		z' = z Î ßz_eq_eq(trans_id new, zid(trans_id old))¢)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function renames\_opsym}
=DOC
val €renames_opsym› : OPSYM_RENAMING -> unit;
=DESCRIBE
πZAX
‹ €resolve_opsym› : ID ∏ seq Param_Spec ≠ Z_EXP
∞

ˇ€renames_opsym›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	RENAMES_NEW;
‹	RENAMES_OLD
˜¸¸¸¸¸¸¸
‹	z' = z Î ßz_eq_eq(trans_id new, resolve_opsym (new, formal_pars))¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function renames\_object}
ˇ€renames_var_common›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	PACK_ENV;
‹	RENAMES_NEW;
‹	RENAMES_OLD;
‹	zname' : Z_ID;
‹	Block'
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹ ∂In_Scope; n : ID; zname : Z_ID ∑  In_Scope = flatten_env( ENV)
‹ ±	(	pack = Nil ± zname = trans_id old
‹	≤	pack = Value n ± zname  = trans_id (n dot old) )
‹ ±	(	zname' ç {v : vc_vars∑ trans_id (v.var)} ¿ {a : vc_aux_vars∑ (ValueÁ~Í) a.zvar}
‹	±	zname = zname'
‹	≤	zname Ì zname' ç obj_renamings )
‹ ±	blocks' =
‹	blocks ´ {1 Ì  Block_obj_renamings(blocks 1, obj_renamings ¿ {trans_id new Ì zname'})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ €renames_var_pack_spec› ¸¸¸¸¸¸¸¸¸¸¸
‹ ÑPACK_ENV;
‹ renames_var_common;
‹ Package''
˜¸¸¸¸¸¸
‹ pack_spec_flag' = True;
‹ pack_env block_name' =  Package'';
‹ pack_env' =
‹ pack_env ´  { block_name' Ì
‹   Package_obj_renamings( Package'', obj_renamings'' ¿ {trans_id new Ì zname'})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ €renames_var_otherwise› ¸¸¸¸¸¸¸¸¸¸¸
‹ renames_var_common
˜¸¸¸¸¸¸
‹ pack_spec_flag' = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ €renames_var› ¶  renames_var_pack_spec ≤ renames_var_otherwise
∞

ˇ€renames_const›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ENV;
‹	PACK_ENV;
‹	RENAMES_NEW;
‹	RENAMES_OLD
˜¸¸¸¸¸¸¸
‹ ∂In_Scope; n : ID; zname : Z_ID ∑  In_Scope = flatten_env( ENV)
‹ ±	(	pack = Nil ± zname = trans_id old
‹	≤	pack = Value n ± zname  = trans_id (n dot old) )
‹ ±	(	zname é {v : vc_vars∑ trans_id (v.var)} ¿ {a : vc_aux_vars∑ (ValueÁ~Í) a.zvar}
‹	±	zname é dom obj_renamings )
‹ ±	z' = z Î ßz_eq_eq(trans_id new, zid zname)¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ €renames_object› ¶ renames_var_pack_spec ≤ renames_var
∞
\subsection{The SID function renames\_pack}
πZAX
‹ €rename_basic_decl› : ID ≠ BASIC_DECL ≠ Z_PARA
˜¸¸¸¸¸¸
‹ µpack : ID; Const_Decl∑
‹	rename_basic_decl pack (const_decl( Const_Decl)) = 
‹	z_eq_eq(trans_id const, zid(trans_id(pack dot const)));
‹ µpack : ID; Type_Decl∑
‹	rename_basic_decl pack (type_decl( Type_Decl)) =
‹	z_eq_eq(trans_id name, zid(trans_id(pack dot name)));
‹ µpack : ID; Subtype_Decl∑
‹	rename_basic_decl pack (subtype_decl( Subtype_Decl)) =
‹	z_eq_eq(trans_id name, zid(trans_id(pack dot name)))
∞
πZAX
‹ €rename_formal_fun› : ID ≠ Formal_Fun ≠ Z_PARA
˜¸¸¸¸¸¸
‹ µpack : ID; Formal_Fun∑
‹	rename_formal_fun pack ( Formal_Fun) =
‹	z_eq_eq(trans_id name, zid(trans_id(pack dot name)))
∞

ˇ€renames_pack_consts_types_funs›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	IDENT;
‹	Package
˜¸¸¸¸¸¸¸
‹	z' =
‹	z Î rename_basic_decl ident o consts_types Î rename_formal_fun ident o formal_funs
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ€renames_pack_procs›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑPACK_ENV;
‹	IDENT;
‹	Package;
‹	envs : seq ENV;
‹	pack_envs : seq PACK_ENV;
‹	fps : seq Formal_Proc
˜¸¸¸¸¸¸¸
‹	envs 1 = { ENV};
‹	 ENV' ç envs(#envs) ;
‹	pack_envs 1 = { PACK_ENV};
‹	 PACK_ENV' ç pack_envs(#pack_envs);
‹	#envs = #pack_envs = #fps + 1 = #formal_procs + 1;
‹	ran fps = formal_procs;
‹µ i : dom fps∑∂ envs i; (envs(i+1))'; pack_envs i; (pack_envs(i+1))'; renames_proc∑
‹	pack = Value ident ± old = (fps i).name ± new = (fps i).name
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ€renames_pack_vars›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑPACK_ENV;
‹	IDENT;
‹	Package;
‹	envs : seq ENV;
‹	pack_envs : seq PACK_ENV;
‹	vds : seq Var_Decl
˜¸¸¸¸¸¸¸
‹	envs 1 = { ENV};
‹	 ENV' ç envs(#envs) ;
‹	pack_envs 1 = { PACK_ENV};
‹	 PACK_ENV' ç pack_envs(#pack_envs);
‹	#envs = #pack_envs = #vds + 1 = #formal_procs + 1;
‹	ran vds = vc_vars;
‹µ i : dom vds∑∂ envs i; (envs(i+1))'; pack_envs i; (pack_envs(i+1))'; renames_var[opack/pack]∑
‹	opack = Value ident ± old = (vds i).var ± new = (vds i).var
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZAX
‹ €untrans_id› : Z_ID ≠ ID
˜¸¸¸¸¸¸
‹  µzi : Z_ID∑ trans_id(untrans_id zi) = zi
∞
ˇ€renames_pack_aux_vars›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑPACK_ENV;
‹	IDENT;
‹	Package;
‹	envs : seq ENV;
‹	pack_envs : seq PACK_ENV;
‹	avs : seq Z_Decl
˜¸¸¸¸¸¸¸
‹	envs 1 = { ENV};
‹	 ENV' ç envs(#envs) ;
‹	pack_envs 1 = { PACK_ENV};
‹	 PACK_ENV' ç pack_envs(#pack_envs);
‹	#envs = #pack_envs = #avs + 1 = #formal_procs + 1;
‹	ran avs = aux_vars;
‹µ i : dom avs∑∂ envs i; (envs(i+1))'; pack_envs i; (pack_envs(i+1))'; renames_var[opack/pack]∑
‹	opack = Value ident ±
‹	old =untrans_id((ValueÁ~Í)(avs i).zvar) ±
‹	new = untrans_id((ValueÁ~Í)(avs i).zvar)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ€renames_pack›¸¸¸¸¸¸¸¸¸¸¸
‹	renames_pack_consts_types_funsªâs
‹	renames_pack_procsªâs
‹	renames_pack_varsªâs
‹	renames_pack_aux_vars
˜¸¸¸¸¸¸¸
‹	 Package = pack_env ident
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ €use_pack› ¶ renames_pack
∞

\section{STUBS AND SUBUNITS}\label{STUBSANDSUBUNITS}

\subsection{The SID function begin\_stub}
=DOC
val €begin_stub› : unit -> unit;
=DESCRIBE
ˇ€begin_stub›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_stub_flag(blocks 1, True)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function end\_stub}
=DOC
val €end_stub› : unit -> unit;
=DESCRIBE
ˇ€end_stub›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_stub_flag(blocks 1, False)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function new\_scope\_subunit}
=DOC
val €new_scope_subunit› : ID list -> unit;
=DESCRIBE
ˇ€new_scope_subunit›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	subunit_flag = body_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = formal_body_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function pack\_stub}
=DOC
val €pack_stub› : ID -> unit;
=DESCRIBE
ˇ €pack_stub› ¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ÑZ_DOC;
‹	ENV;
‹	Subunit;
‹	id1 : ID;
‹	Block';
‹	Block'';
‹	IDENT
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹ 	∂mod_name : Z_ID∑
‹		mod_name = trans_subunit_name(id1, ident) ±
‹		z' = make_module(mod_name, z) Î z ±
‹ 		zmod =  Z_MODULE;
‹	subunit_env' = subunit_env  ¿ {(id1, ident) Ì  Subunit};
‹		subunit_flag'' = True ± id1 = block_name'' dot block_name'
‹	≤	subunit_flag'' = False ± id1 = block_name';
‹	subunit_env' = subunit_env  ¿ {(id1, ident) Ì  Subunit};
‹	specif_flag = False;
‹	 In_Scope = flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=ENDDOC

\section{WEB CLAUSES}\label{WEBCLAUSES}
\subsection{The SID function z\_copy}
ˇ€ZPARA›¸¸¸¸¸¸¸¸¸¸¸
‹	zpara : Z_PARA
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ€z_copy›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ZPARA
˜¸¸¸¸¸¸¸
‹	z' = z Î ßzpara¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\subsection{The SID function new\_scope\_dec\_replace}
=DOC
val €new_scope_dec_replace› : REPLACED_BY_DECL -> unit;
=DESCRIBE
ˇ€new_scope_dec_replace›¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑDEC_ENV;
‹	LAB;
‹	Block
˜¸¸¸¸¸¸¸
‹	blocks' = ß Block¢ Î blocks;
‹	 Declab = Declab_declabel_flag(dec_env label, True);
‹	dec_lab = label;
‹	dec_env' = {label} · dec_env
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507002	?0 has not been introduced as a declaration label
=ENDDOC

\subsection{The SID function update\_envs\_remove\_declabel}
=DOC
	val €update_subunit_env_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
ˇ€update_subunit_env_remove_declabel›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	#subunit_env = #subunit_env';
‹	µidâ1, idâ2 : ID; s, s' : Subunit |
‹		subunit_env(idâ1, idâ2) = s ± subunit_env'(idâ1, idâ2) = s' ∑
‹		s' = Subunit_dec_labels (s, s.dec_labels \ {dec_lab'})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_dec_env_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
ˇ€update_dec_env_remove_declabel›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	#dec_env = #dec_env';
‹	µdec_label : LABEL; d, d' : Declab |
‹		dec_env dec_label = d ± dec_env' dec_label = d'∑
‹		d' = Declab_dec_labels(d, d.dec_labels \ {dec_lab'})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_spec_env_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
ˇ€update_spec_env_remove_declabel›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	#spec_env = #spec_env';
‹	µspec_label : LABEL; s, s' : Speclab |
‹		spec_env spec_label = s ± spec_env' spec_label = s'∑
‹		s' = Speclab_dec_labels(s, s.dec_labels \ {dec_lab'})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_envs_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
πZ
‹		€update_envs_remove_declabel›
‹	¶	update_subunit_env_remove_declabel
‹	±	update_dec_env_remove_declabel
‹	±	update_spec_env_remove_declabel
∞
=ENDDOC
\subsection{The SID function new\_scope\_speclabel}
=DOC
	val €new_scope_speclabel›: LABEL -> unit
=DESCRIBE
ˇ€new_scope_speclabel›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	LAB;
‹	SPEC_ENV;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß Block¢ Î blocks;
‹	speclabel_flag = True;
‹	till_flag = (spec_env label).till_flag;
‹	pack_spec_flag = pack_body_flag = stub_flag =
‹	subunit_flag = formal_body_flag = fun_flag =
‹	declabel_flag = body_flag = False;
‹	spec_lab = label;
‹	till = (spec_env label).till
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507003	label ?0 has not been introduced
=ENDDOC
\subsection{The SID function vcs\_speclabel}
=DOC
	val €vcs_speclabel›: REFINED_BY -> SPEC
=DESCRIBE
ˇ€vcs_speclabel›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	SEQ_STMTS;
‹	SPEC_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	z' = z Î ßz_vcs(vcs(spec_env spec_lab', st))¢	
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=ENDDOC
\subsection{The SID function end\_scope\_speclabel}
=DOC
	val €end_scope_speclabel›: unit -> unit
=DESCRIBE
ˇ€end_scope_speclabel›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	end_scope;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	spec_env' = {spec_lab'} · spec_env
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID functions new\_scope\_stmtlabel and end\_scope\_stmt\_label}
=DOC
	val €new_scope_stmt_label›: LABEL -> unit
	val €end_scope_stmt_label›: unit -> unit
=DESCRIBE
πZ
‹	€new_scope_stmt_label› ¶ new_scope_speclabel
∞
πZ
‹	€end_scope_stmt_label› ¶ end_scope_speclabel
∞
=ENDDOC

\newpage
\section{SPARK PROGRAM ENVIRONMENT}
The SPARK program environment enables the SPARK program to be recovered.
The relevant data structures are described in \cite{ISS/HAT/DAZ/DTD513}.
 
To describe the manipulation of this environment, we use some additional SID functions.

\subsection{The SID Function update\_replacement\_env}

This is called at the following points in the syntax.

=GFT
web_clause =
	z,
	compilation <update_spark_prog>,
	comp_label replacedby compilation <update_replacement_env>,
	ppart_label replacedby private_part <update_replacement_env>,
	vpart_label replacedby visible_part <update_replacement_env>,
	dec_label replacedby dec dp1 <update_replacement_env>,
	stmt_label replacedby sequence_of_statements <update_replacement_env>,
	spec_label refinedby sequence_of_statements <update_replacement_env>,
	refinedby sequence_of_statements <update_replacement_env>,
	spec_label replacedby sequence_of_statements <update_replacement_env>,
	replacedby sequence_of_statements <update_replacement_env>;
=TEX
(The manipulation of the replacement environment does not interact with the other SID functions, and so the interleaving of calls to $update\_replacement\_env$ and the other SID functions is immaterial).

The global variable $REPL$ holds the right-hand side of the current replacement or refinement web clause:

ˇREPL¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	repl : Replacement
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The global variable $COMP$ holds the current k-slot or compilation unit web clause:

ˇCOMP¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	comp : K_Slot_Compilation_Unit
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

$update\_replacement\_env$ adds the maplet mapping the current label (in the global variable $LAB$) to $REPL$ to the replacement environment.
=DOC
val €update_replacement_env› : LABEL * REPLACEMENT -> unit
=DESCRIBE
ˇupdate_replacement_env¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑREPL_ENV;
‹	LAB;
‹	REPL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	repl_env' = repl_env ´ {label Ì repl}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €update_spark_prog› : KSLOT_COMPILATION_UNIT list -> unit
=DESCRIBE
$update\_spark\_prog$ appends the current compilation to the sequence of same held in the SPARK program environment.

ˇupdate_spark_prog¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPARK_Prog;
‹	COMP
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	spark' = spark Î ßcomp¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507003	label ?0 has not been introduced
507004	label ?0 has already been refined or replaced
507005	label ?0 has already been used
=ENDDOC
\newpage
\section{INTERFACE}
=DOC
val €get_z_generator_state› : unit -> Z_GENERATOR_STATE
val €set_z_generator_state› : Z_GENERATOR_STATE -> unit
val €diag_z_generator_state› : Z_GENERATOR_STATE ref
val €diag_web_clause› : WEB_CLAUSE ref;
val €diag_basic_decl_list› : BASIC_DECL list ref;
val €diag_vc_args› : (SPECLAB * STATEMENT) list ref;
val €kslot_compilation_unit_name› : KSLOT_COMPILATION_UNIT -> string;
type €CN_EXCEPTION_LOG› = string list S_DICT;
val €get_exception_logs› : unit ->  CN_EXCEPTION_LOG;
val €delete_exception_log› : string -> unit; 
val €log_message› : string -> unit;
val €log_exception› : exn -> string;
val €current_cn_env› : CN_ENV;
val €ti_context_of_in_scope› : IN_SCOPE -> TYPE E_DICT;
val €cn_env_of_in_scope› : IN_SCOPE -> CN_ENV;
=DESCRIBE
=ENDDOC
=DOC
val €classify_label› : string -> REPL_SORT OPT
val €get_replacement› : string -> REPLACEMENT OPT
val €do_web_clause› : CNTypes.WEB_CLAUSE -> unit
=DESCRIBE
=ENDDOC

=DOC
type €CN_STATE›
val €get_cn_state› : unit -> CN_STATE
val €set_cn_state› : CN_STATE -> unit
val €new_script› : {name : string} -> unit
val €new_script1› :
	{name : string, library_theories : string list} -> unit
val €new_continuation_script› : {name : string} -> unit
val €new_continuation_script1› :
	{name : string, library_theories : string list} -> unit
val €cn_z_generator› : CNTypes.WEB_CLAUSE -> unit
val €sco_z_generator› : CNTypes.WEB_CLAUSE -> unit
val €restart_cn_z_generator› : unit -> unit
val €get_saved_cn_state› : string -> CN_STATE;
val €delete_script› : string -> unit;
=DESCRIBE
$new\_script1$ acts the same as $new\_script$ except that its list
of library theories will be made the parents of the script theory,
and any theory produced during processing the script.	
=ENDDOC

\section{VC Browser Information Interface} 
=DOC
val €get_vc_context_route› : string * (string -> string) -> vc_context_route;
val €dest_route› : ROUTE -> (TERM * vc_route_arg);
=DESCRIBE
Information about VCs is stored as a \textit{\slshape USER\_DATUM} and extracted with 
\textit{\slshape get\_vc\_context\_route}.
=FAILURE
507085	Unexpected term in VC route.
507086	Case branch count out of int range.
507087	Unexpected term when elsf indicator expected.
507088	Unexpected structure of contexts and routes. 
=ENDDOC
\section{Additional Error Messages} 
=DOC
(* additional error messages *)
=DESCRIBE
This long list of error messages is split over several pages:
=FAILURE
507017	Representation clauses are not handled formally and may affect the meaning of the program
507018	Pragmas are not handled formally and may affect the meaning of the program
507019	Internal error: unexpected abstract syntax category encountered
507021	Deferred constant declarations are not handled formally
507023	Cannot introduce theory ?0; a declaration for package
	?1 has probably already been processed
507024	Cannot introduce theory ?0; a body for package
	?1 has probably already been processed
507025	Cannot introduce theory ?0; a main program called
	?1 may already have been processed
507026	Cannot introduce theory ?0; a stub for the subunit
	?1 may already have been processed
507027	Cannot open theory ?0; a stub for the subunit
	?1 has not been processed
507028	Cannot open theory ?0; a declaration for the package
	?1 has not been processed
507029	Design error: information required for package ?0 has vanished
507030	Cannot introduce package body: a specification for package ?0 has not been processed
507034	Cannot make theory ?0 a parent of theory ?1: ?2
507035	Cannot make theory ?0 a parent of theory ?1: theory ?0 does not exist
507036	This renaming declaration cannot be handled formally 
	(?0 is not a formal procedure)
507038	A specification for package ?0 has not been processed
507039	An arbitrary Ada replacement is an informal development step.
507070	There is no script called ?0 in the current state database
507071	When a package is referred to in a USE clause or a RENAMING clause
	its declaration must be complete; 
	package ?0 is not complete; it contains the following unexpanded label?1
507072	Unable to check package ?0 (missing or corrupt table entry for script ?1)
507079	Internal error: corrupt table entry for script ?1
507089	The declarations in a block statement can only be handled formally
	if the block statement appears on its own on the right-hand side of
	a refinement or replacement step.
=ENDDOC
=DOC
(* additional error messages *)
=DESCRIBE
Continuation of the long list of error messages split over several pages:
=FAILURE
507040	A specification for package ?0 is not allowed here because the
	theory ?1 already exists (perhaps because a specification for
	the package has already been processed)
507042	Library theory ?0 cannot be made a parent of the script theory: ?1
507044	This renaming declaration cannot be handled formally
	(?0 not successfully processed because ?1)
507045	A script may not contain more than one compilation unit:
	cannot add compilation unit ?0 to script ?1 as it already contains
	compilation unit ?2.
507046	DESIGN ERROR: Corrupt compilation unit data for theory ?0
507047	DESIGN ERROR: Should be called in theory ?0 but currently in ?1
507048	?0 appear to be one or more SPARK functions from the same package
	specification that specifies function ?1, which may not be used
	in the specification of that function
507053	Free variable ?0 found in checking predicate ?1 of formal procedure
507054	Free variables ?0 found in checking predicate ?1 of formal procedure
507055	Formal parameter ?0 in package ?1 clashes with a name declared in
	package that must be prefixed.
507056	Compilation units may only be added to theories created for that purpose:
	compilation unit ?0 cannot be added to theory ?1 
507057	Unable to provide prefixed specifications for ?0
507065	?0 is not a valid label here
507069	Internal error: unexpected environment renaming entry (old name: ?0, new name: ?1)
507077	An assertion may only appear in a refinement step or in the body of a formal subprogram
507078	Internal error: corrupt default parameter information
507081	To be handled formally, default expressions in parameter specifications must be constant expressions.
	The Z expression ?0 contains the free variable ?1
507082	To be handled formally, default expressions in parameter specifications must be constant expressions.
	The Z expression ?0 contains the free variables ?1
507090	The theory ?0 is locked and so cannot be deleted
507091	Deleting script ?0 has caused the following to be deleted:
507092	Script theories:?0Other theories:?1Subunits?2Packages:?3
507093	The theory ?0 is an ancestor of the current theory and so cannot be deleted
507094	The theory ?0 is in an ancestor database and so cannot be deleted
507100	*** SOUNDNESS WARNING : ?2 [?1.?0]
507101	*** Z GENERATION FAILURE: ?0
=ENDDOC
=DOC
(* additional error messages *)
=DESCRIBE
Continuation of the long list of error messages split over several pages:
=FAILURE
507121	Ada variables in pre- and post-conditions must appear in
	an enclosing frame or ò-list.
	The following variable?0 ?1 not in an enclosing frame or ò-list:
507122	Invalid pre-condition
507123	Invalid post-condition
507124	VCs must not contain free variables.
	The following variable?0 ?1 would appear free:
507125	Invalid VC
507127	?0 is not a valid type mark
507128	Internal error: invalid Z type associated with type mark ?0
507129	The identifier ?0 is not in scope in the Ada program
507130	Internal error: attempt to look up ?0 in an empty environment
507131	Internal error: inconsistent use of environment dictionary entry for ?0
507132	Procedure ?0 has not been declared
507133	Package ?0 has not been processed formally
507134	A statement replacement is an informal development step
507135	?0 is not formally specified here but is
	formally specified in the specification of package ?1.
	This is an informal development step
507136	?0 is not formally specified here but is
	formally specified in its stub in unit ?1.
	This is an informal development step
507137	$IMPLICIT may only be used in a package body to
	introduce a formal subprogram that has been declared in
	the package specification.
507138	The theory name ?0 does not follow conventions;
	the expected name is ?1
507139	Cannot introduce theory ?0; a subprogram
	?1 may already have been processed
=ENDDOC
=ENDDOC
\section{EPILOGUE}
=SML
end; (* signature CNZGenerator *)
=TEX
\section{TEST POLICY}
The functions in this document do not lend themselves to module testing (as discussed in \cite{ISS/HAT/DAZ/HLD503}). Testing of the design and implementation of the Z document generator will be done using suitable integration tests.

Testing will be in accordance with the criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



