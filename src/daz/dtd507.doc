%  dtd507.doc @(#) 95/10/11 1.49 dtd507.doc
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD507}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{R.D.~Arthan&WIN01}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the detailed design for the
Compliance Notation Z Generation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,hatdocs,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.21] Initial drafts.
\item[Issue 1.22 (21th September 1994) ] Rework done according to deck-check report reference 0010 and checked by KB.
\item[Issues 1.22-1.34] Phase 3 rework.
\item[Issues 1.35-1.43] Fixed to the Z during type-checking.
\item[Issue 1.44] Final version for issue.
\item[Issue 1.45-1.47] Bug fixes.
\item[Issue 1.48] Enhancements 1, 5, 6, 7 and 20; bug fix 17 (batch 2).
\item[Issue 1.49] Enhancement 10.
\item[Issue 1.50] Issue for review.
\item[Issue 1.51] Exposed $add\_type\_info$.
\item[Issue 1.52 (14th December 1995)] Changes according to desk check report 024.
\item[Issue 1.53] Fixed bug 6 (V0.6).
\item[Issue 1.54] New error message for resolution of issue 1 (V0.6).
\item[Issue 1.55] Updated reference to DRA spec.
\item[Issue 1.56] Added $new\_script1$ for IUCT project WP 1.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the functions whose Z specification is given in in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1}; it is called for in \cite{ISS/HAT/DAZ/HLD503}.
Sections \ref{BASICDECLARATIONS}-\ref{WEBCLAUSES} contain the design and correspond directly with sections 4-16 of the DRA specification.

\subsection{Introduction}
This document gives the structure (i.e., module) containing the functions defined \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1}.
This covers the main semantic processing involved in the extraction of a Z document from a Compliance Notation script.
As usual it also includes a transcription into {\ProductZ} of the relevant parts of the DRA specification.

The overall effect of the processing defined here is to update the {\Product} theory database as if the Z document had been loaded into it and to update internal state representing the environments of  \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1} as implemented in \cite{ISS/HAT/DAZ/DTD513}.
The internal state also includes additional information defined in \cite{ISS/HAT/DAZ/DTD513} and used to record the association of k-slot labels with SPARK program fragments.
This gives all the information required to reduce extraction of the Z document and of the SPARK program to straightforward pretty-printing tasks.



\subsubsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/HLD503}.


\subsubsection{Dependencies}
See \cite{ISS/HAT/DAZ/HLD503}.
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
The Z in this document has been type-checked with the exception of a small number of paragraphs which define the following: $form\_fun\_subunit$, $form\_fun$ and $stub\_spec\_fun$. These Z objects have been syntax-checked but a full type-checking of them with the current version of {\ProductZ} takes an enormous amount of processing due to the width of the schemas involved.


\subsection{Compliance}
For the description of the Z in this document see \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1}. Where the Z differs from that in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1}, justification has been provided.

In \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1} where names contain double underscores, the implementation has chosen to use only single underscores (no ambiguity results from this).

In {\ProductZ}, subscripts are not decoration. In order to achieve the effect required by \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1}, multiple priming has been used and generally, the number of primes in a decoration corresponds to the numeric value of the subcript in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1}.

In a number of places, the Z in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/2.1} (and hence in this document) is recognised to be deficient. In specific cases, agreed with DRA, the implementation has been dicussed and agreed, but the Z has not been brought into line with the implementation. Where this is the case, there is a note to draw attention to this fact.







\section{PREAMBLE}
\subsection{Preamble for Z Type-Checking}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd505";
push_pc "z_library";
force_delete_theory"dtd507" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
new_theory "dtd507";
=TEX

\subsection{The Signature}
=DOC
signature €CNZGenerator› = sig
=DESCRIBE
=ENDDOC

=SML
local
open	CNTypes CNTypes1 CNTypes2 ZParagraphs ZUserInterfaceSupport;
in
=TEX
\section{BASIC DECLARATIONS}\label{BASICDECLARATIONS}
\subsection{The SID Function basic\_declaration}
ˇBASIC_DEC¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	basic_decl : BASIC_DECL
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €basic_decl_pack_spec› : BASIC_DECL -> unit;
=DESCRIBE
ˇbasic_decl_pack_spec¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	BASIC_DEC;
‹	ENV;
‹	Package;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag' = True;
‹	 Block' = blocks 1;
‹	pack_env block_name' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{ block_name' Ì
‹		Package_consts_types( Package, consts_types Î ßbasic_decl¢)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €basic_decl_otherwise› : BASIC_DECL -> unit;
=DESCRIBE
ˇbasic_decl_otherwise¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	BASIC_DEC;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag' = False;
‹	 Block' = blocks 1;
‹	z' =
‹	z Î trans_basic_decl basic_decl
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507041	Unsupported language feature encountered in a basic declaration
=ENDDOC
=DOC
val €basic_declaration› : BASIC_DECL -> unit;
=DESCRIBE
πZ
‹	basic_declaration ¶ basic_decl_pack_spec ≤ basic_decl_otherwise
∞
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
\subsection{The SID Function var\_pack\_spec}
ˇVAR_DECL¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	vars :  Var_Decl
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €var_pack_spec› : VAR_DECL -> unit;
=DESCRIBE
In the implementation, variable declarations contain lists of identifiers, rather than single identifiers (i.e., they are as in the concrete syntax rather than the Z abstract syntax).
We therefore only deal with a single $VAR\_DECL$ here.
ˇvar_pack_spec¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	VAR_DECL;
‹	ENV;
‹	Package;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag' = True;
‹	 Block' = blocks 1;
‹	pack_env block_name' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{ block_name' Ì
‹		Package_vc_vars( Package, vc_vars ¿ vars) }
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
\subsection{The SID Function update\_envs\_var}
=DOC
val €update_subunit_env_var› : VAR_DECL -> unit;
=DESCRIBE
ˇupdate_subunit_env_var¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#subunit_env = #subunit_env';
‹	µidâ1, idâ2 : ID; s, s' : Subunit |
‹		subunit_env(idâ1, idâ2) = s ± subunit_env'(idâ1, idâ2) = s' ∑
‹		dec_lab' ç s.dec_labels ±
‹		s' = Subunit_vc_vars(s, s.vc_vars ¿ vars) ≤
‹		dec_lab' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
=DOC
val €update_dec_env_var› : VAR_DECL -> unit;
=DESCRIBE
ˇupdate_dec_env_var¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#dec_env = #dec_env';
‹	µdec_label : LABEL; d, d' : Declab |
‹		dec_env dec_label = d ± dec_env' dec_label = d'∑
‹		dec_lab' ç d.dec_labels ±
‹		d' = Declab_vc_vars(d, d.vc_vars ¿ vars) ≤
‹		dec_lab' é d.dec_labels ± d' = d
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
=DOC
val €update_spec_env_var› : VAR_DECL -> unit;
=DESCRIBE
ˇupdate_spec_env_var¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	declabel_flag' = True;
‹	 Block' = blocks 1;
‹	#spec_env = #spec_env';
‹	µspec_label : LABEL; s, s' : Speclab |
‹		spec_env spec_label = s ± spec_env' spec_label = s'∑
‹		dec_lab' ç s.dec_labels ±
‹		s' = Speclab_w
‹		(Speclab_vc_vars(s, s.vc_vars ¿ vars),
‹		s.w ¿ {v : vars∑ trans_id v.var}) ≤
‹		dec_lab' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
=DOC
val €update_envs_var› : VAR_DECL -> unit;
=DESCRIBE
πZ
‹		update_envs_var
‹	¶	update_subunit_env_var
‹	±	update_dec_env_var
‹	±	update_spec_env_var
∞
=FAILURE
507001	Internal error: running environment contains a non-existent
	package name
=ENDDOC
\subsection{The SID Function add\_var\_env}
=DOC
val €add_var_env› : VAR_DECL -> unit;
=DESCRIBE
ˇadd_var_env¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	VAR_DECL;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	blocks' = blocks ´ {1 Ì Block_vc_vars(blocks 1, vc_vars' ¿ vars)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{DECLARATIONS}\label{DECLARATIONS}
\subsection{The SID function k\_slot\_dec}
ˇLAB¸¸¸¸¸¸¸¸¸¸¸¸
‹	label : LABEL
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZAX
‹	no_label : LABEL
∞
πZ
fun 6 _dot_
∞
πZAX
‹	_dot_: (ID ∏ ID) ≠ ID
∞
=DOC
val €k_slot_dec› : LABEL -> unit;
=DESCRIBE
ˇk_slot_dec¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ÑENV;
‹	LAB;
‹	ENV;
‹	Declab;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	dec_env' = dec_env ¿ {label Ì  Declab};
‹	subunit_flag'' = True ± block_name = block_name'' dot block_name' ≤
‹	subunit_flag'' = False ± block_name = block_name';
‹	 Flags =  Flags';
‹	 In_Scope = flatten_env( ENV);
‹	blocks' =
‹	blocks ´ {1 Ì Block_dec_labels (blocks 1, dec_labels' ¿ {label})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, $ENV$ should be $ÑENV$ and the $blocks'$ component is also updated. (See Implementation.) 
=FAILURE
507006	Internal error: running environment stack unexpectedly empty
507010	?0 is already in use as a declaration label
=ENDDOC

\section{STATEMENTS}\label{STATEMENTS}
\subsection{The SID function spec\_stmt}
ˇSPEC_STMT¸¸¸¸¸¸¸¸¸¸¸¸
‹	specification : Spec
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €spec_stmt_speclabel› : {spec :SPEC, label : LABEL} -> unit;
=DESCRIBE
ˇspec_stmt_speclabel¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	SPEC_STMT;
‹	LAB;
‹	ENV;
‹	Speclab;
‹	Speclab'';
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	speclabel_flag' = True;
‹	 Block' = blocks 1;
‹	spec_env' = spec_env ¿ {label Ì  Speclab};
‹	 Speclab'' = spec_env spec_lab';
‹	 Spec = specification;
‹	formal_body_flag = formal_body_flag'';
‹	fun_flag = fun_flag'';
‹	till_flag = till_flag';
‹	fun_header = fun_header'';
‹	return = return'';
‹	till = till';
‹	vc_vars = vc_vars'';
‹	vc_pars = vc_pars'' ¿ (flatten_env( ENV)).vc_pars;
‹	vc_log_cons = vc_log_cons'' ¿ vc_log_cons';
‹	vc_aux_vars = vc_aux_vars'';
‹	formal_procs = formal_procs'';
‹	dec_labels = dec_labels''
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507014	specification label ?0 has not been introduced
507015	label ?0 has already been introduced
507033	badly formed logical constant encountered
=ENDDOC
=DOC
val €spec_stmt_otherwise› : {spec : SPEC, label : LABEL} -> unit;
=DESCRIBE
ˇspec_stmt_otherwise¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	SPEC_STMT;
‹	LAB;
‹	ENV;
‹	Speclab;
‹	Formal_Fun';
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	speclabel_flag' = False;
‹	 Block' = blocks 1;
‹	spec_env' = spec_env ¿ {label Ì  Speclab};
‹	 Spec = specification;
‹	formal_body_flag = formal_body_flag';
‹	fun_flag = fun_flag';
‹	till_flag = till_flag';
‹	current_formal_fun' =  Formal_Fun';
‹	fun_header =  Informal_Fun';
‹	return =post';
‹	till = till';
‹	 In_Scope = flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹	spec_stmt ¶ spec_stmt_speclabel ≤ spec_stmt_otherwise
∞
=FAILURE
507015	label ?0 has already been introduced
=ENDDOC
\subsection{The SID function k\_slot\_stmt}
=DOC
val €k_slot_stmt› : LABEL -> unit;
=DESCRIBE
πZ
‹	k_slot_stmt ¶ spec_stmt
∞
=FAILURE
507015	label ?0 has already been introduced
=ENDDOC
\subsection{The SID function add\_log\_con\_env}
ˇLOGICAL_CON¸¸¸¸¸¸¸¸¸
‹	logical_con : Z_Decl
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €add_log_con_env› : LOG_CON -> unit;
=DESCRIBE
ˇadd_log_con_env¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	LOGICAL_CON
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_log_cons(blocks 1, {logical_con})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, this specification is insufficient. See implementation.
=FAILURE
507032	Declaration of ?0 has already been introduced 
=ENDDOC
=DOC
val €remove_log_con_env› : unit -> unit;
=DESCRIBE
ˇremove_log_con_env¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_log_cons(blocks 1, {})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{LOOPS}\label{LOOPS}
\subsection{The SID function new\_scope\_loop}
=DOC
	val €new_scope_loop› : unit -> unit;
=DESCRIBE
ˇnew_scope_loop¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	Empty_Block;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	 Block' = blocks 1;
‹	pack_spec_flag = stub_flag = subunit_flag =
‹		declabel_flag = till_flag = False;
‹	formal_body_flag = formal_body_flag';
‹	fun_flag = fun_flag';
‹	speclabel_flag = speclabel_flag';
‹	current_formal_proc = current_formal_proc';
‹	current_formal_fun = current_formal_fun';
‹	spec_lab = spec_lab'
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsection{The SID function end\_scope}

=DOC
val €end_scope› : unit -> unit;
=DESCRIBE
ˇend_scope¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = tail blocks
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507006	Internal error: running environment stack unexpectedly empty
=ENDDOC
\subsection{The SID function for\_param}
ˇFOR_PARAM¸¸¸¸¸¸¸¸¸¸¸
‹	Param_Spec
˜¸¸¸¸¸¸¸
‹	mode = inn
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €for_param› : ID * TMARK -> unit;
=DESCRIBE
ˇfor_param¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FOR_PARAM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_pars(blocks 1, { Param_Spec})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, this specification is insufficient. See implementation.
=ENDDOC
\subsection{The SID function till\_pred}
ˇTILL_PRED¸¸¸¸¸¸¸¸¸¸¸
‹	till : Z_PRED
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €till_pred› : Z_TM -> unit;
=DESCRIBE
ˇtill_pred¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	TILL_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_till(Block_till_flag(blocks 1, True), till)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\section{SUBPROGRAM DECLARATIONS}\label{SUBPROGRAMDECLARATIONS}
The SID function $end\_scope$ used in processing these has already been defined in section \ref{LOOPS}.
\section{PROCEDURES}\label{PROCEDURES}
\subsection{The SID function subunit\_form}
ˇIDENT¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ident : ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €subunit_form› : ID -> unit;
=DESCRIBE
ˇsubunit_form¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑENV;
‹	SUBUNIT_ENV;
‹	IDENT;
‹	ÑBlock;
‹	Subunit''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_flag = True;
‹	 Block = head blocks;
‹	blocks' = blocks ´ {1 Ì  Block'};
‹	z' = z Î ßz_module zmod''¢;
‹	 Subunit'' = subunit_env(block_name, ident);
‹	block_name' = block_name;
‹	 Flags' =  Flags;
‹	 In_Scope' =  In_Scope''
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A subunit ?0 containing ?1 has not been introduced 
=ENDDOC
\subsection{The SID function subunit\_inf}
=DOC
	val €subunit_inf› : ID -> unit;
=DESCRIBE
ˇsubunit_inf¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	subunit_form
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_env' = {(block_name, ident)} · subunit_env
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A subunit ?0 containing ?1 has not been introduced 
=ENDDOC
\subsection{The SID function new\_scope\_proc\_inf}
=DOC
	val €new_scope_proc_inf› : ID -> unit;
=DESCRIBE
ˇnew_scope_proc_inf¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	formal_body_flag = fun_flag = declabel_flag = speclabel_flag =
‹	till_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function new\_scope\_proc\_form}
=DOC
	val €new_scope_proc_form› : ID -> unit;
=DESCRIBE
ˇnew_scope_proc_form¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	formal_body_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function stub}
πZAX
‹	make_module : Z_DOC ≠ Z_MODULE
∞
=DOC
val €stub› : unit -> unit;
=DESCRIBE
ˇstub¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	Z_DOC;
‹	ENV;
‹	Subunit;
‹	idâ1, idâ2 : ID;
‹	Block';
‹	Block'';
‹	Block'''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stub_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Block''' = blocks 3;
‹	subunit_env' = subunit_env  ¿ {(idâ1, idâ2) Ì  Subunit};
‹		subunit_flag''' = True ± idâ1 = block_name''' dot block_name''
‹	≤	subunit_flag''' = False ± idâ1 = block_name'';
‹	idâ2 = block_name';
‹	zmod = make_module (  Z_DOC);
‹	specif_flag = False;
‹	 In_Scope = flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507013	A stub called ?0 has already been introduced
=ENDDOC
\subsection{The SID function stub\_spec\_proc}
ˇFORM_PROC¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Formal_Proc
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €stub_spec_proc› : FORMAL_PROC -> unit;
=DESCRIBE
ˇstub_spec_proc¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	FORM_PROC;
‹	ÑSubunit;
‹	idâ1, idâ2 : ID;
‹	Block';
‹	Block'';
‹	Block'''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stub_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Block''' = blocks 3;
‹	subunit_env(idâ1, idâ2) =  Subunit;
‹	subunit_env' = subunit_env ´ {(idâ1, idâ2) Ì  Subunit'};
‹		subunit_flag''' = True ± idâ1 = block_name''' dot block_name''
‹	≤	subunit_flag''' = False ± idâ1 = block_name'';
‹	idâ2 = block_name';
‹	specif_flag' = True;
‹	specif' =  Spec;
‹	zmod' = zmod;
‹	 In_Scope' =  In_Scope
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A subunit ?0 containing ?1 has not been introduced 
=ENDDOC
\subsection{The SID function form\_proc}
=DOC
val €form_proc_pack_spec› : FORMAL_PROC -> unit;
=DESCRIBE
ˇform_proc_pack_spec¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	FORM_PROC;
‹	ENV;
‹	Package;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = True;
‹	 Block'' = blocks 2;
‹	pack_env block_name'' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{block_name'' Ì
‹		Package_formal_procs( Package, formal_procs ¿ { Formal_Proc})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_proc_pack_body_common› : FORMAL_PROC ->
			(BLOCK * FORMAL_PROC * PACKAGE * SPECLAB) OPT
=DESCRIBE
ˇ form_proc_pack_body_common¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	PACK_ENV;
‹	FORM_PROC;
‹	ENV;
‹	Package'''';
‹	Speclab''''';
‹	Formal_Proc''';
‹	Block';
‹	Block'';
‹	st : Statement;
‹	free :  Z_ID;
‹	pack_body_vars :  Var_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_body_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Package'''' = pack_env block_name'';
‹	block_name' ç {p : formal_procs'''' ∑ p.name};
‹	z' = z Î ßz_vcs(vcs( Speclab''''', st))¢;
‹	 Formal_Proc''' ç formal_procs''''; name''' = block_name';
‹	fun_flag''''' = False;
‹	vc_pars''''' = vc_pars'; vc_log_cons''''' = {};
‹	vc_aux_vars''''' = {};
‹	free = free_vars_zpred Pre''' ¿ free_vars_zpred post''';
‹	pack_body_vars = vc_vars'' \ vc_vars'''';
‹	(		(st = stmt(spec_no_ivars( Spec)))
‹		≤	(st = spec_ivars( Spec, null))
‹	)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
507051	Free variables are not allowed in VCs.
	The VC ?0 contains the free variable ?1.
=ENDDOC
=DOC
val €form_proc_pack_body› :
	(BLOCK * FORMAL_PROC * PACKAGE * SPECLAB) ->FORMAL_PROC -> 
		unit;
=DESCRIBE
ˇ form_proc_pack_body¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	form_proc_pack_body_common
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(w''' ¿ free) ° {a : aux_vars'''' ∑ a.zvar} = ö;
‹	w''''' = w''' ¿ {v : pack_body_vars ∑ trans_id v.var};
‹	Pre''''' = Pre''';
‹	post''''' = post''';
‹	vc_vars''''' = vc_vars''
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_proc_pack_body_aux› :
	(BLOCK * FORMAL_PROC * PACKAGE * SPECLAB) ->
	TERM list -> FORMAL_PROC -> unit;
=DESCRIBE
ˇ  form_proc_pack_body_aux¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	form_proc_pack_body_common;
‹	ÑENV;
‹	aux_vars, aux_vars0 :  Z_Decl;
‹	conc_vars :  Var_Decl;
‹	invs :  Z_PRED;
‹	Spec'''''';
‹	frame_aux_conc, frame_aux_conc0, add_aux, add_aux0 :  Z_ID;
‹	seq_aux : seq Z_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(w''' ¿ free) ° {a : aux_vars'''' ∑ a.zvar} = ö;
‹	add_aux = free ° {a : aux_vars'''' ∑ a.zvar} \ w''';
‹	w'''''' = w''' ¿ add_aux;
‹	Pre'''''' = Pre''';
‹	post'''''' =
‹	z_many_and ({post'''} ¿
‹	  {a : add_aux ∑ z_eq(zid a, subs_exp(zid a, add_aux, add_aux0))});
‹	aux_vars = {a : aux_vars'''' | a.zvar ç w''''''};
‹	conc_vars = ﬁ {x : using_decs'' ® w''''''© ∑ first x};
‹	invs = {x : using_decs'' ® w''''''© ∑ second x};
‹	frame_aux_conc = w'''''' ¿ {c : conc_vars ∑ trans_id c.var};
‹	# seq_aux = # aux_vars;
‹	ran seq_aux = aux_vars0;
‹	w''''' = frame_aux_conc ¿ {v : pack_body_vars ∑ trans_id v.var} \
‹	  {a : aux_vars ∑ a.zvar};
‹	Pre''''' = z_exists (aux_vars, z_many_and ({Pre''''''} ¿ invs));
‹	post''''' =
‹	 z_forall (seq_aux, z_imp (subs_pred (z_many_and
‹	  ({Pre''''''} ¿ invs), frame_aux_conc, frame_aux_conc0),
‹	  z_exists (aux_vars, z_many_and ({post''''''} ¿ invs))));
‹	vc_vars''''' = vc_vars'' ¿ conc_vars;
‹	blocks' = blocks ´ {1 Ì Block_vc_vars(blocks 1, vc_vars' ¿ conc_vars)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_proc_subunit› : FORMAL_PROC -> unit;
=DESCRIBE
ˇ  form_proc_subunit¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑSUBUNIT_ENV;
‹	FORM_PROC;
‹	ENV;
‹	Subunit''';
‹	Speclab'''';
‹	Block';
‹	Block'';
‹	st : Statement
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Subunit''' = subunit_env (block_name'', block_name');
‹	subunit_env' = {(block_name'', block_name')} · subunit_env;
‹	specif_flag''' = True;
‹	z' = z Î ßz_vcs(vcs( Speclab'''', st))¢;
‹	 Spec'''' = specif''';
‹	fun_flag'''' = False;
‹	vc_vars'''' = vc_vars''';
‹	vc_pars'''' = vc_pars';
‹	vc_log_cons'''' = {}
‹	vc_aux_vars'''' = vc_aux_vars''';
‹	(	(st = stmt(spec_no_ivars( Spec)))
‹	  ≤ 	(st = spec_ivars( Spec, null))
‹	)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_proc› : FORMAL_PROC -> unit;
=DESCRIBE
πZ
‹	form_proc ¶ 	form_proc_pack_spec ≤ form_proc_pack_body ≤
‹			form_proc_pack_body_aux ≤ form_proc_subunit 
∞
=ENDDOC
\subsection{The SID function curr\_form\_proc}
=DOC
	val €curr_form_proc› : FORMAL_PROC -> unit;
=DESCRIBE
ˇcurr_form_proc¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FORM_PROC
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' =
‹	blocks ´ {1 Ì Block_current_formal_proc(blocks 1,  Formal_Proc)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{FUNCTIONS}\label{FUNCTIONS}
\subsection{The SID function new\_scope\_fun\_inf}
=DOC
	val €new_scope_fun_inf› : ID -> unit;
=DESCRIBE
ˇnew_scope_fun_inf¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	fun_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	formal_body_flag = declabel_flag = speclabel_flag =
‹	till_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function new\_scope\_fun\_form}
=DOC
	val €new_scope_fun_form› : ID -> unit;
=DESCRIBE
ˇnew_scope_fun_form¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	formal_body_flag = fun_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = subunit_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function stub\_spec\_fun}
ˇFORM_FUN¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Formal_Fun
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
val €stub_spec_fun› : FORMAL_FUN -> unit;
=DESCRIBE
ˇ  stub_spec_fun¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	FORM_FUN;
‹	ÑSubunit;
‹	idâ1, idâ2 : ID;
‹	Block';
‹	Block'';
‹	Block'''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stub_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	 Block''' = blocks 3;
‹	subunit_env(idâ1, idâ2) =  Subunit;
‹	subunit_env' = subunit_env ´ {(idâ1, idâ2) Ì  Subunit'};
‹		subunit_flag''' = True ± idâ1 = block_name''' dot block_name''
‹	≤	subunit_flag''' = False ± idâ1 = block_name'';
‹	idâ2 = block_name';
‹	specif_flag' = True;
‹	specif' =  Spec;
‹	zmod' = zmod;
‹	 In_Scope' =  In_Scope
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507011	A subunit ?0 containing ?1 has not been introduced 
=ENDDOC
\subsection{The SID function inf\_fun}
ˇINF_FUN¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Informal_Fun
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €cart_prod1› : PARAM_SPEC list -> Z_EXP;
=DESCRIBE
πZAX
‹	cart_prod : seqâ1 Param_Spec ﬂ Z_EXP
∞
The implementation of this function will be included as part of the VC generator as a) it is required there and b) this module depends on the VC generator. The name is included in this signature for traceability purposes.
=ENDDOC
=DOC
	val €fun_decl1› : INFORMAL_FUN -> Z_DECL;
=DESCRIBE
πZAX
‹	fun_decl : Informal_Fun ≠ Z_Decl
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ Informal_Fun; Z_Decl∑
‹	fun_decl (  Informal_Fun) =  Z_Decl §
‹		formal_pars = ß¢ ± zvar = trans_id name ±
‹		zexp = zid(trans_id return_type) ≤
‹		formal_pars Ω ß¢ ± zvar = trans_id name ±
‹		zexp = z_tfun(cart_prod formal_pars, zid(trans_id return_type))
∞
The implementation of this function will be included as part of the VC generator as a) it is required there and b) this module depends on the VC generator. The name is included in this signature for traceability purposes.
=ENDDOC
=DOC
val €inf_fun_pack_spec› : INFORMAL_FUN -> unit;
=DESCRIBE
ˇinf_fun_pack_spec¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	INF_FUN;
‹	ENV;
‹	Package;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = True;
‹	 Block'' = blocks 2;
‹	pack_env block_name'' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{block_name'' Ì
‹		Package_informal_funs( Package, informal_funs Î ß Informal_Fun¢)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €trans_informal_fun› : INFORMAL_FUN -> PARAINFO;
=DESCRIBE
πZAX
‹	trans_informal_fun : Informal_Fun ≠ Z_Ax
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µf: Informal_Fun; Z_Ax∑
‹	trans_informal_fun f =  Z_Ax § decls = {fun_decl f} ± preds = {}
∞
=ENDDOC
=DOC
val €inf_fun_otherwise› : INFORMAL_FUN -> unit;
=DESCRIBE
ˇinf_fun_otherwise¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	INF_FUN;
‹	ENV;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = False;
‹	 Block'' = blocks 2;
‹	z' = z Î ßz_ax(trans_informal_fun( Informal_Fun))¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €inf_fun› : INFORMAL_FUN -> unit;
=DESCRIBE
πZ
‹	inf_fun ¶ inf_fun_pack_spec ≤ inf_fun_otherwise
∞
=ENDDOC
\subsection{The SID function form\_fun}
=DOC
val €form_fun_pack_spec› : FORMAL_FUN -> unit;
=DESCRIBE
ˇform_fun_pack_spec¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	FORM_FUN;
‹	ENV;
‹	Package;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = True;
‹	 Block'' = blocks 2;
‹	pack_env block_name'' =  Package;
‹	pack_env' =
‹	pack_env ´
‹	{block_name'' Ì
‹		Package_formal_funs( Package, formal_funs Î ß Formal_Fun¢)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €z_decls› : PARAM_SPEC list -> Z_DECL list;
=DESCRIBE
πZAX
‹	z_decls : seqâ1 Param_Spec ﬂ seqâ1 Z_Decl[Z_EXP]
∞
=ENDDOC
=DOC
val €trans_formal_fun› : FORMAL_FUN -> PARAINFO;
=DESCRIBE
πZAX
‹	trans_formal_fun : Formal_Fun ﬂ Z_Ax
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µFormal_Fun; Z_Ax∑
‹	trans_formal_fun ( Formal_Fun) =  Z_Ax §
‹		decls = {fun_decl ( Informal_Fun)} ±
‹			(formal_pars = ß¢ ± preds = {z_imp(Pre, post)} ≤
‹			formal_pars Ω ß¢ ±
‹			preds = {z_forall(z_decls formal_pars, z_imp(Pre, post))})
∞
=ENDDOC
=DOC
val €form_fun_pack_body› : FORMAL_FUN -> unit;
=DESCRIBE
ˇform_fun_pack_body¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	PACK_ENV;
‹	FORM_FUN;
‹	ENV;
‹	Package'''';
‹	Speclab''''';
‹	ref : seq Z_PARA;
‹	Formal_Fun''';
‹	Block';
‹	Block'';
‹	st : Statement
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_body_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	z' = z Î ßz_ax(trans_formal_fun( Formal_Fun))¢ Î ref;
‹	 Package'''' = pack_env block_name'';
‹	(
‹		block_name' ç {f : ran formal_funs'''' ∑ f.name}
‹	±	ref = ßz_vcs(vcs( Speclab''''', st))¢
‹	±	(st = stmt(spec_no_ivars( Spec)) ≤ st = spec_ivars( Spec, null))
‹	±	 Formal_Fun''' ç ran formal_funs'''' ± name''' = block_name'
‹	±	 Spec''''' =  Spec''' ± formal_body_flag''''' = True
‹	±	fun_flag''''' = True
‹	±	fun_header''''' =  Informal_Fun ± vc_vars''''' = {}
‹	±	vc_pars''''' = vc_pars' ± vc_log_cons''''' = {}
‹	±	vc_aux_vars''''' = {}
‹	)
‹	≤
‹		(block_name' é {f : ran formal_funs'''' ∑ f.name} ± ref = ß¢)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_fun_subunit› : FORMAL_FUN -> unit;
=DESCRIBE
ˇ form_fun_subunit¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑSUBUNIT_ENV;
‹	FORM_FUN;
‹	ENV;
‹	Subunit''';
‹	Speclab'''';
‹	ref : seq Z_PARA;
‹	Block';
‹	Block'';
‹	st : Statement
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	subunit_flag'' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	z' = z Î ßz_ax(trans_formal_fun( Formal_Fun))¢ Î ref;
‹	 Subunit''' = subunit_env (block_name'', block_name');
‹	subunit_env' = {(block_name'', block_name')} · subunit_env;
‹		specif_flag''' = True
‹	±	ref = ßz_vcs(vcs( Speclab'''', st))¢
‹	±	(st = stmt(spec_no_ivars( Spec)) ≤ st = spec_ivars( Spec, null))
‹	±	 Spec'''' = specif''' ± formal_body_flag'''' = True
‹	±	fun_flag'''' = True
‹	±	fun_header'''' =  Informal_Fun ± vc_vars'''' = {}
‹	±	vc_pars'''' = vc_pars' ± vc_log_cons'''' = {}
‹	≤
‹		specif_flag''' = False ± ref = ß¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507012	Internal error: entry for ?0 missing from package environment
=ENDDOC
=DOC
val €form_fun_otherwise› : FORMAL_FUN -> unit;
=DESCRIBE
ˇform_fun_otherwise¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	FORM_FUN;
‹	ENV;
‹	Block''
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	pack_spec_flag'' = pack_body_flag'' = subunit_flag'' = False;
‹	 Block'' = blocks 2;
‹	z' = z Î ßz_ax(trans_formal_fun( Formal_Fun))¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €form_fun› : FORMAL_FUN -> unit;
=DESCRIBE
πZ
‹	form_fun ¶ 	form_fun_pack_spec ≤ form_fun_pack_body ≤
‹			form_fun_subunit ≤ form_fun_otherwise
∞
=ENDDOC
\subsection{The SID function curr\_form\_fun}
=DOC
	val €curr_form_fun› : FORMAL_FUN -> unit;
=DESCRIBE
ˇcurr_form_fun¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FORM_FUN
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_current_formal_fun(blocks 1,  Formal_Fun)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{FORMAL PARAMETERS}\label{FORMALPARAMETERS}
ˇFORMALS¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	formals :  Param_Spec
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\subsection{The SID function formal\_part}
=DOC
	val €fformal_part› : PARAMETER_SPECIFICATION list -> unit;
=DESCRIBE
ˇformal_part¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	FORMALS
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_vc_pars(blocks 1, formals)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{SUBPROGRAM BODIES}\label{SUBPROGRAMBODIES}
\subsection{The SID function update\_envs\_proc}
=DOC
	val €update_subunit_env_proc› : unit -> unit;
=DESCRIBE
ˇupdate_subunit_env_proc¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	declabel_flag'' = formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	#subunit_env = #subunit_env';
‹	µidâ1, idâ2 : ID; s, s' : Subunit |
‹		subunit_env(idâ1, idâ2) = s ± subunit_env'(idâ1, idâ2) = s'
‹	∑	dec_lab'' ç s.dec_labels ±
‹		s' =
‹		Subunit_formal_procs(s, s.formal_procs ¿ {current_formal_proc'})
‹	≤	dec_lab'' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_dec_env_proc› : unit -> unit;
=DESCRIBE
ˇupdate_dec_env_proc¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	declabel_flag'' = formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	#dec_env = #dec_env';
‹	µdec_label : LABEL; d, d' : Declab |
‹		dec_env dec_label = d ± dec_env' dec_label = d'
‹	∑	dec_lab'' ç d.dec_labels ±
‹		d' =
‹		Declab_formal_procs(d, d.formal_procs ¿ {current_formal_proc'})
‹	≤	dec_lab'' é d.dec_labels ± d' = d
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_spec_env_proc› : unit -> unit;
=DESCRIBE
ˇupdate_spec_env_proc¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	declabel_flag'' = formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	#spec_env = #spec_env';
‹	µspec_label : LABEL; s, s' : Speclab |
‹		spec_env spec_label = s ± spec_env' spec_label = s'
‹	∑	dec_lab'' ç s.dec_labels ±
‹		s' =
‹		Speclab_formal_procs(s, s.formal_procs ¿ {current_formal_proc'})
‹	≤	dec_lab'' é s.dec_labels ± s' = s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_envs_proc› : unit -> unit;
=DESCRIBE
πZ
‹ update_envs_proc ¶ update_subunit_env_proc ± update_dec_env_proc
‹			± update_spec_env_proc
∞
=ENDDOC
\subsection{The SID function add\_proc\_env}
=DOC
	val €add_proc_env› : unit -> unit;
=DESCRIBE
ˇadd_proc_env¸¸¸¸¸¸¸
‹	ÑENV;
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	formal_body_flag' = True;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	blocks' =
‹	blocks ´ {2 Ì Block_formal_procs( Block'',
‹			formal_procs'' ¿ {current_formal_proc'})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function vcs\_body}
ˇSEQ_STMTS¸¸¸¸
‹	st : Statement
à¸¸¸¸¸¸¸¸¸¸¸
=DOC
	val €vcs_body_proc› : STATEMENT -> unit;
=DESCRIBE
ˇ vcs_body_proc¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ENV;
‹	SEQ_STMTS;
‹	Speclab;
‹	Formal_Proc';
‹	Block';
‹	Block''
˜¸¸¸¸¸¸¸¸
‹	formal_body_flag' = True;
‹	fun_flag' = False;
‹	 Block' = blocks 1;
‹	 Block'' = blocks 2;
‹	z' = z Î ßz_vcs(vcs( Speclab, st))¢;
‹	current_formal_proc' =  Formal_Proc';
‹	Pre = Pre';
‹	post = post';
‹	fun_flag = False;
‹	 In_Scope = flatten_env( ENV);
‹	(	pack_body_flag'' = True
‹	±	w = w' ¿
‹		  ({v : vc_vars' ∑ trans_id v.var} \
‹		 ﬁ {x : ran using_decs'' ∑ {y : first x ∑ trans_id y.var}})
‹	)
‹		≤
‹	(	pack_body_flag'' = False
‹	±	w = w' ¿ {v : vc_vars' ∑ trans_id (v.var)}
‹	)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, this specification is insufficient. See implementation.
=ENDDOC
=DOC
	val €vcs_body_fun› : STATEMENT -> unit;
=DESCRIBE
ˇvcs_body_fun¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ENV;
‹	SEQ_STMTS;
‹	Speclab;
‹	Formal_Fun';
‹	Block'
˜¸¸¸¸¸¸¸¸
‹	formal_body_flag' = True;
‹	fun_flag' = True;
‹	 Block' = blocks 1;
‹	z' = z Î ßz_vcs(vcs( Speclab, st))¢;
‹	current_formal_fun' =  Formal_Fun';
‹	w = {v : vc_vars' ∑ trans_id (v.var)};
‹	Pre = Pre';
‹	post = post';
‹	formal_body_flag = fun_flag = True;
‹	fun_header=  Informal_Fun';
‹	return = post';
‹	 In_Scope = flatten_env( ENV)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: As agreed with DRA, this specification is insufficient. See implementation.
=ENDDOC
=DOC
	val €vcs_body› : STATEMENT -> unit;
=DESCRIBE
πZ
‹	vc_body ¶ vcs_body_proc ≤ vcs_body_fun
∞
=ENDDOC
\section{PACKAGES}\label{PACKAGES}
\subsection{The SID function new\_scope\_pack\_spec}
=DOC
	val €empty_package› : PACKAGE;
=DESCRIBE
ˇEmpty_Package¸¸¸¸¸¸¸
‹	Package
˜¸¸¸¸¸¸¸¸
‹	vc_vars = {};
‹	consts_types = ß¢;
‹	formal_procs = {};
‹	informal_funs = ß¢;
‹	formal_funs = ß¢;
‹	aux_vars = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €new_scope_pack_spec› : ID -> unit;
=DESCRIBE
ˇnew_scope_pack_spec¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑPACK_ENV;
‹	IDENT;
‹	Empty_Block;
‹	Empty_Package
˜¸¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	pack_spec_flag = True;
‹	pack_body_flag = stub_flag = subunit_flag = formal_body_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = False;
‹	pack_env' = pack_env ¿ {ident Ì  Package}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507007	The name ?0 has already been used for a package
=ENDDOC
\subsection{The SID function new\_scope\_pack\_body}
ˇPACK_SPEC_WITH_MODULES¸¸¸¸¸¸¸
‹	pack_spec_name : ID;
‹	pack_spec_with_modules : seq Z_MODULE
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The information contained in the above global variable is extracted in the implementation from an additional field in the package type, see \cite{ISS/HAT/DAZ/DTD513}.
=DOC
	val €new_scope_pack_body› : ID -> unit;
=DESCRIBE
ˇnew_scope_pack_body¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑENV;
‹	IDENT;
‹	PACK_ENV;
‹	PACK_SPEC_WITH_MODULES;
‹	Block;
‹	Package'
˜¸¸¸¸¸¸¸¸
‹	z' = z Î map z_module pack_spec_with_modules 
‹		ã (map trans_basic_decl consts_types');
‹	blocks' = ß  Block¢ Î blocks;
‹	 Package' = pack_env ident;
‹	pack_spec_name = ident;
‹	block_name = ident;
‹	pack_body_flag = True;
‹	pack_spec_flag = stub_flag = subunit_flag = formal_body_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = False;
‹	vc_vars = vc_vars';
‹	vc_pars = {};
‹	vc_log_cons = {};
‹	vc_aux_vars = {};
‹	formal_procs = {};
‹	dec_labels = {};
‹	using_decs = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Note: it is also necessary to update the bring into scope the auxiliary variables and formal procedures from the packages named in $pack\_spec\_with\_modules$.
This can conveniently be achieved in the implementation by calling $new\_scope\_with$, q.v.
=FAILURE
=ENDDOC
\pagebreak
\subsection{The SID function new\_scope\_with}
πZAX
‹	new_ids : Package ≠  ID
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹µPackage∑
‹	new_ids( Package) = 
‹	{v : vc_vars ∑ v.var} ¿
‹	{c : Const_Decl | const_decl c ç ran consts_types ∑ c.const} ¿
‹	{t : Type_Decl | type_decl t ç ran consts_types ∑ t.name} ¿
‹	{ident : ID; Type_Decl; Enum_Type_Def |
‹		type_decl( Type_Decl) ç ran consts_types ±
‹		type_def = enum_type_def( Enum_Type_Def) ±
‹		ident ç ran vals ∑ ident} ¿
‹	{s : Subtype_Decl | subtype_decl s ç ran consts_types ∑ s.name} ¿
‹	{p : formal_procs ∑ p.name} ¿
‹	{f : ran informal_funs ∑ f.name} ¿
‹	{f : ran formal_funs∑ f.name}
∞
πZAX
‹	prefix : (ID ∏ ID ∏ Package) ≠ Package
∞
=DOC
	val new_scope_with : ID -> unit;
=DESCRIBE
ˇ new_scope_with¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ÑENV;
‹	IDENT;
‹	PACK_ENV;
‹	PACK_SPEC_WITH_MODULES;
‹	Block;
‹	Package';
‹	Z_DOC''
˜¸¸¸¸¸¸¸¸
‹	z' = z Î ßz_module (make_module ( Z_DOC''))¢;
‹	z'' = ßz_module toolkit, z_module extend¢ Î
‹		map z_module pack_spec_with_modules 
‹		ã (map trans_basic_decl consts_types') Î
‹		map (trans_informal_fun ª z_ax) informal_funs'Î
‹		map (trans_formal_fun ª z_ax) formal_funs';
‹	blocks' = ß  Block¢ Î blocks;
‹	 Package' = prefix(ident, new_ids(pack_env ident), pack_env ident);
‹	pack_spec_name = ident;
‹	pack_body_flag = pack_spec_flag = stub_flag = subunit_flag =
‹	formal_body_flag = fun_flag = declabel_flag =
‹	speclabel_flag = till_flag = False;
‹	vc_vars = vc_vars';
‹	vc_pars = {};
‹	vc_log_cons = {};
‹	vc_aux_vars = aux_vars';
‹	formal_procs = formal_procs';
‹	dec_labels = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function end\_scope\_comp\_unit}
=DOC
val €end_scope_comp_unit› : unit -> unit;
=DESCRIBE
ˇend_scope_comp_unit¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = ßblocks 1¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function aux\_var}
$AUX\_VAR$ is declared in \cite{ISS/HAT/DAZ/DTD502}.
=DOC
val €aux_var› : AUX_VAR -> unit;
=DESCRIBE
ˇaux_var¸¸¸¸¸¸¸¸¸¸¸
‹	ÑPACK_ENV;
‹	AUX_VAR;
‹	ENV;
‹	Package;
‹	Block'
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	pack_env block_name' =  Package;
‹	pack_env' =
‹	 pack_env ´
‹	 {block_name' Ì Package_aux_vars( Package, aux_vars ¿ {aux})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507032	Declaration of ?0 has already been introduced 
=ENDDOC
\subsection{The SID function using\_dec}
$USING\_DEC$ is declared in \cite{ISS/HAT/DAZ/DTD502}.
=DOC
val €using_dec› : USING_DEC -> unit;
=DESCRIBE
ˇusing_dec¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	USING_DEC;
‹	Block'
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	blocks' =
‹	 blocks ´
‹	 {1 Ì
‹	  Block_using_decs
‹	   (blocks 1, using_decs' ¿ {aux Ì (concrete_vars, invariant)})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €add_conc_vars_env› : unit -> unit;
=DESCRIBE
ˇadd_conc_vars_env¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	Block'
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	blocks' =
‹	 blocks ´
‹	 {1 Ì
‹	  Block_vc_vars
‹	   (blocks 1, vc_vars' ¿ ﬁ{x : ran using_decs' ∑ first x})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function vcs\_aux\_initial}
=DOC
val €vcs_aux_initial› : STATEMENT -> unit;
=DESCRIBE
ˇvcs_aux_initial¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ENV;
‹	SEQ_STMTS;
‹	PACK_ENV;
‹	Block';
‹	Speclab
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	z' = z Î ß z_vcs (vcs ( Speclab, st))¢;
‹	vc_vars = vc_vars';
‹	vc_pars = {};
‹	vc_log_cons = {};
‹	vc_aux_vars = {};
‹	formal_procs = formal_procs';
‹	fun_flag = False;
‹	w = {v : vc_vars' ∑ trans_id v.var};
‹	Pre = z_true;
‹	post =
‹	 z_exists
‹	 ((pack_env block_name').aux_vars,
‹	 z_many_and {x : ran using_decs' ∑ second x})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{RENAMING DECLARATIONS}\label{RENAMINGDECLARATIONS}
\subsection{The SID function renames\_proc}
ˇRENAMES_NEW¸¸¸¸¸¸¸¸¸¸¸
‹	new:ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇRENAMES_OLD¸¸¸¸¸¸¸¸¸¸¸
‹	pack,old:ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=DOC
val €renames_proc› : SUBPROGRAM_RENAMING -> unit;
=DESCRIBE
ˇrenames_proc¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	PACK_ENV;
‹	RENAMES_NEW;
‹	RENAMES_OLD;
‹	Package;
‹	Block';
‹	Formal_Proc'';
‹	Formal_Proc'''
˜¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	 Package = pack_env pack;
‹	 Formal_Proc'' ç formal_procs;
‹	name'' = old;
‹	name''' = new;
‹	formal_ids''' = formal_ids'';
‹	 Spec''' =  Spec'';
‹	blocks' = blocks ´
‹	{1 Ì Block_formal_procs( Block', formal_procs' ¿ { Formal_Proc'''})}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function renames\_fun}

=DOC
val €renames_fun› : SUBPROGRAM_RENAMING -> unit;
=DESCRIBE
ˇrenames_proc¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	RENAMES_NEW;
‹	RENAMES_OLD
˜¸¸¸¸¸¸¸
‹	z' = z Î ßz_eq_eq(trans_id new, zid(trans_id(pack dot old)))¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\section{STUBS AND SUBUNITS}\label{STUBSANDSUBUNITS}

\subsection{The SID function begin\_stub}
=DOC
val €begin_stub› : unit -> unit;
=DESCRIBE
ˇbegin_stub¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_stub_flag(blocks 1, True)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function end\_stub}
=DOC
val €end_stub› : unit -> unit;
=DESCRIBE
ˇend_stub¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV
˜¸¸¸¸¸¸¸
‹	blocks' = blocks ´ {1 Ì Block_stub_flag(blocks 1, False)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID function new\_scope\_subunit}
=DOC
val €new_scope_subunit› : ID -> unit;
=DESCRIBE
ˇnew_scope_subunit¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	IDENT;
‹	Empty_Block
˜¸¸¸¸¸¸¸
‹	blocks' = ß  Block¢ Î blocks;
‹	block_name = ident;
‹	subunit_flag = True;
‹	pack_spec_flag = pack_body_flag = stub_flag = formal_body_flag =
‹	fun_flag = declabel_flag = speclabel_flag = till_flag = False
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\section{WEB CLAUSES}\label{WEBCLAUSES}
\subsection{The SID function z\_copy}
ˇZPARA¸¸¸¸¸¸¸¸¸¸¸
‹	zpara : Z_PARA
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇz_copy¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	ZPARA
˜¸¸¸¸¸¸¸
‹	z' = z Î ßzpara¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\subsection{The SID function new\_scope\_dec\_replace}
=DOC
val €new_scope_dec_replace› : REPLACED_BY_DECL -> unit;
=DESCRIBE
ˇnew_scope_dec_replace¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	ÑDEC_ENV;
‹	LAB;
‹	Block
˜¸¸¸¸¸¸¸
‹	blocks' = ß Block¢ Î blocks;
‹	 Declab = Declab_declabel_flag(dec_env label, True);
‹	dec_lab = label;
‹	dec_env' = {label} · dec_env
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507002	?0 has not been introduced as a declaration label
=ENDDOC

\subsection{The SID function update\_envs\_remove\_declabel}
=DOC
	val €update_subunit_env_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
ˇupdate_subunit_env_remove_declabel¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSUBUNIT_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	#subunit_env = #subunit_env';
‹	µidâ1, idâ2 : ID; s, s' : Subunit |
‹		subunit_env(idâ1, idâ2) = s ± subunit_env'(idâ1, idâ2) = s' ∑
‹		s' = Subunit_dec_labels (s, s.dec_labels \ {dec_lab'})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_dec_env_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
ˇupdate_dec_env_remove_declabel¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑDEC_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	#dec_env = #dec_env';
‹	µdec_label : LABEL; d, d' : Declab |
‹		dec_env dec_label = d ± dec_env' dec_label = d'∑
‹		d' = Declab_dec_labels(d, d.dec_labels \ {dec_lab'})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_spec_env_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
ˇupdate_spec_env_remove_declabel¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	#spec_env = #spec_env';
‹	µspec_label : LABEL; s, s' : Speclab |
‹		spec_env spec_label = s ± spec_env' spec_label = s'∑
‹		s' = Speclab_dec_labels(s, s.dec_labels \ {dec_lab'})
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
	val €update_envs_remove_declabel›: REPLACED_BY_DECL -> unit
=DESCRIBE
πZ
‹		update_envs_remove_declabel
‹	¶	update_subunit_env_remove_declabel
‹	±	update_dec_env_remove_declabel
‹	±	update_spec_env_remove_declabel
∞
=ENDDOC
\subsection{The SID function new\_scope\_speclabel}
=DOC
	val €new_scope_speclabel›: LABEL -> unit
=DESCRIBE
ˇnew_scope_speclabel¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑENV;
‹	LAB;
‹	SPEC_ENV;
‹	Empty_Block
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	blocks' = ß Block¢ Î blocks;
‹	speclabel_flag = True;
‹	till_flag = (spec_env label).till_flag;
‹	pack_spec_flag = pack_body_flag = stub_flag =
‹	subunit_flag = formal_body_flag = fun_flag = declabel_flag = False;
‹	spec_lab = label;
‹	till = (spec_env label).till
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507003	label ?0 has not been introduced
=ENDDOC
\subsection{The SID function vcs\_speclabel}
=DOC
	val €vcs_speclabel›: REFINED_BY -> unit
=DESCRIBE
ˇvcs_speclabel¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑZ_DOC;
‹	SEQ_STMTS;
‹	SPEC_ENV;
‹	ENV;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	z' = z Î ßz_vcs(vcs(spec_env spec_lab', st))¢	
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=ENDDOC
\subsection{The SID function end\_scope\_speclabel}
=DOC
	val €end_scope_speclabel›: unit -> unit
=DESCRIBE
ˇend_scope_speclabel¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPEC_ENV;
‹	end_scope;
‹	Block'
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	 Block' = blocks 1;
‹	spec_env' = {spec_lab'} · spec_env
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsection{The SID functions new\_scope\_stmtlabel and end\_scope\_stmt\_label}
=DOC
	val €new_scope_stmt_label›: LABEL -> unit
	val €end_scope_stmt_label›: unit -> unit
=DESCRIBE
πZ
‹	new_scope_stmt_label ¶ new_scope_speclabel
∞
πZ
‹	end_scope_stmt_label ¶ end_scope_speclabel
∞
=ENDDOC
\section{SPARK PROGRAM ENVIRONMENT}
The SPARK program environment enables the SPARK program to be recovered.
The relevant data structures are described in \cite{ISS/HAT/DAZ/DTD513}.
 
To describe the manipulation of this environment, we use some additional SID functions.

\subsection{The SID Function update\_replacement\_env}

This is called at the following points in the syntax.

=GFT
web_clause =
	z,
	compilation <update_spark_prog>,
	comp_label replacedby compilation <update_replacement_env>,
	ppart_label replacedby private_part <update_replacement_env>,
	vpart_label replacedby visible_part <update_replacement_env>,
	dec_label replacedby dec dp1 <update_replacement_env>,
	stmt_label replacedby sequence_of_statements <update_replacement_env>,
	spec_label refinedby sequence_of_statements <update_replacement_env>,
	refinedby sequence_of_statements <update_replacement_env>,
	spec_label replacedby sequence_of_statements <update_replacement_env>,
	replacedby sequence_of_statements <update_replacement_env>;
=TEX
(The manipulation of the replacement environment does not interact with the other SID functions, and so the interleaving of calls to $update\_replacement\_env$ and the other SID functions is immaterial).

The global variable $REPL$ holds the right-hand side of the current replacement or refinement web clause:

ˇREPL¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	repl : Replacement
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The global variable $COMP$ holds the current k-slot or compilation unit web clause:

ˇCOMP¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	comp : K_Slot_Compilation_Unit
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

$update\_replacement\_env$ adds the maplet mapping the current label (in the global variable $LAB$) to $REPL$ to the replacement environment.
=DOC
val €update_replacement_env› : LABEL * REPLACEMENT -> unit
=DESCRIBE
ˇupdate_replacement_env¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑREPL_ENV;
‹	LAB;
‹	REPL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	repl_env' = repl_env ´ {label Ì repl}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
val €update_spark_prog› : KSLOT_COMPILATION_UNIT list -> unit
=DESCRIBE
$update\_spark\_prog$ appends the current compilation to the sequence of same held in the SPARK program environment.

ˇupdate_spark_prog¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSPARK_Prog;
‹	COMP
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	spark' = spark Î ßcomp¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=FAILURE
507003	label ?0 has not been introduced
507004	label ?0 has already been refined or replaced
507005	label ?0 has already been used
=ENDDOC
\section{INTERFACE}
=DOC
val €get_z_generator_state› : unit -> Z_GENERATOR_STATE
val €set_z_generator_state› : Z_GENERATOR_STATE -> unit
val €diag_z_generator_state› : Z_GENERATOR_STATE ref
val €diag_web_clause› : WEB_CLAUSE ref;
val €diag_vc_args› : (SPECLAB * STATEMENT) list ref;
val €kslot_compilation_unit_name› : KSLOT_COMPILATION_UNIT -> string;
val €add_type_info› : ID * ID list -> unit;
=DESCRIBE
=ENDDOC
=DOC
val €classify_label› : string -> REPL_SORT OPT
val €get_replacement› : string -> REPLACEMENT OPT
val €do_web_clause› : CNTypes.WEB_CLAUSE -> unit
=DESCRIBE
=ENDDOC

=DOC
type €CN_STATE›
val €get_cn_state› : unit -> CN_STATE
val €set_cn_state› : CN_STATE -> unit
val €initial_cn_state› : CN_STATE
val €new_script› : {name : string, state : CN_STATE} -> unit
val €new_script1› : {name : string, state : CN_STATE, library_theories : string list} -> unit
val €cn_z_generator› : CNTypes.WEB_CLAUSE -> unit
val €restart_cn_z_generator› : unit -> unit
val €get_script_theories› : string -> string list
=DESCRIBE
$new\_script1$ acts the same as $new\_script$ except that its list
of library theories will be made the parents of the script theory,
and any theory produced during processing the script.	
=FAILURE
507017	Representation clauses are not handled formally
507018	Nested packages are not handled formally
507019	Internal error: unexpected abstract syntax category encountered
507020	Reverse loops are not handled formally
507021	Deferred constant declarations are not handled formally
507023	Cannot introduce theory ?0; a declaration for package
	?1 has probably already been processed
507024	Cannot introduce theory ?0; a body for package
	?1 has probably already been processed
507025	Cannot introduce theory ?0; a main program called
	?1 may already have been processed
507026	Cannot introduce theory ?0; a stub for the subunit
	?1 may already have been processed
507027	Cannot open theory ?0; a stub for the subunit
	?1 has not been processed
507028	Cannot open theory ?0; a declaration for the package
	?1 has not been processed
507029	Design error: information required for package ?0 has vanished
507030	Cannot introduce package body: a specification for package ?0 has not been processed
507031	Package name ?0 appears more than once in the with clause
507034 Cannot make theory ?0 a parent of theory ?1: ?2
507035 Cannot make theory ?0 a parent of theory ?1: theory ?0 does not exist
507036	This renaming declaration cannot be handled formally (?0 is not a formal procedure)
507037	This renaming declaration cannot be handled formally: ?0
507038	A specification for package ?0 has not been processed
507039	Arbitrary Ada replacements may violate VC soundness
507040	A specification for package ?0 is not allowed here because the
	theory ?1 already exists (perhaps because a specification for
	the package has already been processed)
507042	Library theory ?0 cannot be made a parent of the script theory: ?1
=ENDDOC
\section{EPILOGUE}
=SML
end; (* local...in *)
end; (* signature CNZGenerator *)
=TEX
\section{TEST POLICY}
The functions in this document do not lend themselves to module testing (as discussed in \cite{ISS/HAT/DAZ/HLD503}). Testing of the design and implementation of the Z document generator will be done using suitable integration tests.

Testing will be in accordance with the criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



