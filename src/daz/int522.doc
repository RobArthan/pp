=IGN
********************************************************************************
int522.doc: this file is part of the Ada Compliance Tool system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Spring 2002 Enhancement Tests }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document provides integration tests to support the enhancements developed 
under the enhancements programme carried out inspring 2002.}
\end{center}}

\def\Reference{LEMMA1/DAZ/INT522}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.20 $%
}
\def\Date{\FormatDate{$Date: 2002/10/17 15:10:58 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\underscoreoff
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
h{\raggedright
\bibliography{fmu,daz}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1-1.2] First drafts
\item[Issue 1.3] 2.5.4 bug 7 has been withdrawn.
\item[Issue 1.4] interim release tests.
\item[Issue 1.5] improved recursion examples.
\item[Issue 1.6] more tests for renaming.
\item[Issue 1.7] more tests for subprogram renaming; fix to test of use clauses.
\item[Issue 1.8] Tested relaxation of restriction on aggregates.
\item[Issue 1.9, 1.10] Tests for more liberal treatment of use clauses.
\item[Issue 1.11] Test for pp259-bug3 fix.
\item[Issue 1.12] Test for R0076 bug fix.
\item[Issue 1.13] R0054: reworked treatment of use clauses.
\item[Issue 1.14] More bug fix tests.
\item[Issue 1.15] Further tests for interactions between renaming and use clauses.
\item[Issue 1.16] Tests for assertions.
\item[Issue 1.17] Test for bug fix (pp2510-bug0).
\item[Issue 1.18] Tests for block statements.
\item[Issue 1.19] Tests for default parameters; accommodated fix to VC generation for procedure calls;
more tests for renaming (distributed through the document).
\item[Issue 1.20] Copyright and banner updates for open source release.
\item[Issue 1.21] DAZ-specific updates to banner for open source release
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Rob Arthan & Lemma 1
\end{tabular}
\end{center}


\section{INTRODUCTION}\label{INTRODUCTION}
This document is intended to provide integration tests to cover
the enhancements undertaken under the programme
of enhancements carried out in Spring 2002. See \cite{LEMMA1/DAZ/HLD509}
for the detailed specification of the enhancements.

The interim releases of the Compliance Tool have been
fully regression-tested and the new features have been module-
and integration-tested to a certain extent by the existing tests.
This document provides specific integration tests to
complete the coverage. 
\section{PREAMBLE}
Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.

=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn"
                                        diff get_cache_theories())
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ())
        in      map del_thy thys;
	open_theory"cn";
	set_pc "cn1"
        end;    ()
);
=TEX
For batch use turn off subgoal package output:
=SML
set_flag("subgoal_package_quiet", not(ExtendedIO.is_term_in std_in));
=TEX
\section{THE TESTS}
\subsection{R0002: Spring 2002 Efficiency Issues} \label{ROne}
\subsection{R0031/R0069: {\tt Xpp} enhancements} \label{RTwo}
\subsection{R0047/R0054: Renaming declarations and use clauses} \label{RThree}
=SML
clean_up();
new_script{name = "r3.1", state = initial_cn_state};

πCN
procedure p
is
  a, b : integer;
  y : integer renames a;
  z : integer renames b;
begin
  Ñ A, B [A = Y ± B = Z, Z = 42 ± Y = A]
end p;
∞
πCN
  √  a := 42; z := y;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convÒ42Æ));
store_mt_results
mt_run
 [("r3.1.1", fun_true o pop_thm , (), true)];

=SML
clean_up();
new_script{name = "r3.2", state = initial_cn_state};

πCN
package p
is
  a, b : integer;
  y : integer renames a;
  z : integer renames b;
end p;
∞

=SML
new_script{name = "r3.2.a", state =get_cn_state()};

πCN
with p;
procedure q
is
begin
  Ñ PoA, PoB[PoA = PoY ± PoB = PoZ, PoZ = 42 ± PoY = PoA]
end q;
∞

πCN
  √  p.a := 42; p.z := p.y;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convÒ42Æ));
store_mt_results
mt_run
 [("r3.2.1", fun_true o pop_thm , (), true)];

=SML
new_script{name = "r3.2.b", state =get_cn_state()};

πCN
with p;
use p;
procedure r
is
begin
  Ñ A, Z[A = PoY ± PoB = PoZ, B = 42 ± PoY = PoA]
end r;
∞

πCN
  √  p.a := 42; p.z := p.y;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convÒ42Æ));
store_mt_results
mt_run
 [("r3.2.2", fun_true o pop_thm , (), true)];

=SML
new_script{name = "r3.2.c", state =get_cn_state()};

πCN
with p;
procedure s
is
package REN renames p;
begin
  Ñ PoA, RENoZ[RENoA = RENoY ± RENoB = RENoZ, PoB = 42 ± RENoY = RENoA]
end s;
∞

πCN
  √  REN.a := 42; p.z := REN.y;
∞

=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convÒ42Æ));
store_mt_results
mt_run
 [("r3.2.3", fun_true o pop_thm , (), true)];
=SML
clean_up();
new_script{name = "r3.3", state = initial_cn_state};

πCN
package p1
is
  a, b : integer;
   ßmore decs ¢			( decs )
end p1;
∞

=SML
val p1_state = get_cn_state();
new_script{name = "r3.3.a", state = get_cn_state()};
fun do_it() =
πCN
with p1;
use p1;
procedure s
Ñ A [ A  = 0]
is
begin
 a := 0;
end s;
∞
=SML
store_mt_results
mt_run_fail
[
	("r3.3.1", do_it, (),  gen_fail_msg "check_pack_complete" 507071 ["P1", ": DECS"])
];

=SML
new_script{name = "r3.3.b", state = initial_cn_state};
=SML
store_mt_results
mt_run_fail
[
	("r3.3.2", do_it, (), gen_fail_msg "use_pack"  507063 ["P1"])
];

=SML
set_cn_state p1_state;

πCN
 (decs) È   y : integer renames a;
∞
=SML
new_script{name = "r3.3.c", state =get_cn_state()};

=SML
store_mt_results
mt_run
[
	("r3.3.3", do_it, (), ())
];
=TEX
=SML
fun dupl1 () = (
clean_up();
new_script{name = "r3.4", state = initial_cn_state};
πCN
package p
is
  a, b : integer;
  y : integer renames a;
  y : integer renames a;
end p;
∞
=SML
());
=TEX
=SML
fun dupl2 () = (
clean_up();
new_script{name = "r3.4", state = initial_cn_state};
πCN
package p
is
  a, b : integer;
  b : integer renames a;
end p;
∞
=SML
());
=TEX
=SML
store_mt_results
mt_run_fail
[
	("r3.4.1", dupl2, (), gen_fail_msg "renames_object_common"  507064 ["A", "B"])
];
=TEX
=SML
clean_up();
new_script{name = "r3.5.1", state=initial_cn_state};
πCN
procedure p
is
  x : integer;
  procedure p1
  Ñ X [ X = 1 ]
  is begin x := 1; end p1;
  procedure r1 renames p1;
begin
 Ñ X [X = 1]
end p;
∞
πCN
  √ r1;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_2");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r3.5.1", fun_true o pop_thm , (), true)];
=TEX
=SML
clean_up();
new_script{name = "r3.5.2", state=initial_cn_state};
fun do_it() = 
πCN
procedure p
is
  x : integer;
  function p1 return integer
  ò X [ P1 X = X ]
  is begin return x; end p1;
  function r1(x : integer) return integer renames p1;
begin
 Ñ X [X = 1]
end p;
∞
store_mt_results
mt_run_fail
[
	("r3.5.2", do_it, (), gen_fail_msg "use_pack"  507064["P", "R"])
];
=SML
clean_up();
new_script{name = "r3.6", state = initial_cn_state};

πCN
package p
is
  a : integer;
  function read_a return integer ò A [ READ_A  A = A ];
  procedure set_a (x : integer) Ñ A [ A = X ];
  c : constant integer := 1;
  type enum is (l1, l2, l3, l4);
  type interval is range 1 .. 10;
  type real_interval is delta 0.001 range 0.1 .. 1.0;
end p;
∞

=SML
new_script{name = "r3.6.a", state =get_cn_state()};

πCN
with p;
use p;
procedure q
is
  x, y, z : interval;
begin
  Ñ A, X, Y, Z [X = PoC ± Y = C + PoC ± PoA = C]
end q;
∞
πCN
  √ a:= p.c; x := read_a; y := 2*read_a;
   Ñ A [X = PoC ± Y = 2*X, X = PoC ± Y = C + PoC ± A = PoC]
∞
πCN
  √ set_a(c);
∞

=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(strip_asm_tac(z_get_specÒPoCÆ) THEN ALL_FC_T rewrite_tac[z_get_specÒPoREAD_AÆ]);
store_mt_results
mt_run
 [("r3.6.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vc_1_2");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("r3.6.2", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vc_2_2");
a(PC_T1 "z_lin_arith" prove_tac[]);
store_mt_results
mt_run
 [("r3.6.3", fun_true o pop_thm , (), true)];
=TEX
=SML
new_script{name = "r3.6.b", state =get_cn_state()};

πCN
with p;
package r
is
use p;
  z : constant integer := 2*c;
  procedure p1
  Ñ A [ A = Aâ0 + Z];
end r;
∞
=TEX
=SML
new_script{name = "r3.6.c", state =get_cn_state()};

πCN
with p;
with r;
package s
is
use p;
use r;
  c1 : constant integer := 2*c + z;
  c2 : constant enum := l1;
  procedure p2
  Ñ A [ A = Aâ0 + Z];
end s;
∞
=SML
set_pc"cn1";
set_goal([], ÒC1 = 4 ± C2 = 0Æ);
a(rewrite_tac(map z_get_spec[ÒC1Æ, ÒC2Æ, ÒPoCÆ, ÒRoZÆ, ÒPoL1Æ]));
store_mt_results
mt_run
 [("r3.6.d.2", fun_true o pop_thm , (), true)];
=SML
new_script{name = "r3.6.d", state =get_cn_state()};

πCN
with p;
with r;
package body s
is
use p;
use r;
  procedure p2
  Ñ A [ 2*A = 2*Aâ0 + Z]
  is
     x : integer;
  begin
   x := read_a; p.a := x + 1;
  end p2;
end s;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcSbody_3");
a(rewrite_tac(map z_get_spec[ÒPoREAD_AÆ, ÒPoCÆ, ÒRoZÆ]) THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_get_specÒPoREAD_AÆ]);
a(PC_T1"z_lin_arith" prove_tac[]);
store_mt_results
mt_run
 [("r3.6.d.3", fun_true o pop_thm , (), true)];

=SML
store_mt_results
mt_run
 [
	("r3.6.4", print_spark_program1 , "r3.6", ()),
	("r3.6.5", print_spark_program1 , "r3.6.a", ()),
	("r3.6.6", print_spark_program1 , "r3.6.b", ()),
	("r3.6.7", print_spark_program1 , "r3.6.c", ()),
	("r3.6.8", print_spark_program1 , "r3.6.d", ())
];
=SML
clean_up();
new_script { name = "S", state = initial_cn_state };
πCN
package S is
  type T is digits 6 range -1.0 .. +1.0;
end S;
∞
=SML
new_script { name = "P", state = get_cn_state() };
πCN
with S;
use S;
package P is
  function FUNCT56 (LEFT : in T; RIGHT : in T) return T
    ò [ FUNCT56 (LEFT, RIGHT) = RIGHT -âR LEFT ];
  function F56 (LEFT : in T; RIGHT : in T) return T renames FUNCT56;
  procedure P56 (X : out T)
  Ñ X [ X = real 0 ];
end P;
∞
=SML
new_script { name = "Q", state = get_cn_state() };
πCN
with p;
with s;
use p;
use s;
package q
is
	x : T;
	function f(L : in T) return T
	ò X [F X L =  F56(X, L)];
	procedure q56 (Y : out T) renames p56;
end q;
∞
=SML
new_script { name = "R", state = get_cn_state() };
πCN
with s;
use s;
with q;
use q;
procedure r
is
  y : T;
begin
 Ñ X, Y [ Y ºâR real 1 ] (1)
 Ñ Y [ Y ºâR real 1 ] (2)
end r;
∞
πCN
(1)  √ q.x := T(0); y := 0.0; y := q.f(y);
∞
πCN
(2)  √ q56(y);
∞
=SML
all_cn_make_script_support "spqr";
set_merge_pcs["'z_reals", "'cn_reals", "spqr"];
set_goal([], ÒPoF56 = PoFUNCT56Æ);
a(contr_tac THEN ante_tac (±_right_elim(z_get_specÒPoF56Æ)) THEN
	asm_rewrite_tac[]);
a(conv_tac z_≥_µ_conv);
a(z_∂_tacÒ(RIGHT¶real 0, LEFT¶real 0)Æ THEN rewrite_tac[]);
a(rewrite_tac[z_get_specÒ(_ ..âR _)Æ]);
val PoF56THM = pop_thm();
=TEX
=SML
set_goal([], get_conjecture "-" "vc1_1");
a(cn_vc_simp_tac[]);
a(lemma_tac Òreal 0 ç SoTÆ THEN1 
	(rewrite_tac[z_get_specÒ(_ ..âR _)Æ] THEN PC_T1 "z_Ø_lin_arith" prove_tac[]));
a(ALL_FC_T rewrite_tac [cn_QoF_thm]);
a(rewrite_tac [PoF56THM]);
a(ALL_FC_T rewrite_tac [z_get_specÒPoFUNCT56Æ]);
store_mt_results
(mt_runf (op =$))
 [("r.3.7.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vc1_1")];
=TEX
=SML
set_goal([], get_conjecture "-" "vc2_2");
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r.3.7.2", snd o dest_thm o pop_thm , (), get_conjecture"-""vc2_2")];
=TEX
\subsection{R0048: {\tt Use type} clauses} \label{RFour}
=SML
clean_up();
new_script{name = "r4.1", state = initial_cn_state};
πCN
package p1
is
  type byte is range 0 .. 255;
end p1;
∞
=SML
new_script{name = "r4.1.a", state = get_cn_state()};
πCN
with p1;
use type p1;
procedure s
is
 a : p1.byte;
begin
  null;
end s;
∞
=SML
store_mt_results
mt_run [("r4.1.1", fun_true , "just have to get here", true)];
=SML
new_script{name = "r4.1.b", state = get_cn_state()};
πCN
with p1, undefined1;
with undefined2;
use type p1, undefined1, undefined2;
procedure s
is
 a : p1.byte;
begin
  null;
end s;
∞
=SML
store_mt_results
mt_run [("r4.1.2", fun_true , "just have to get here", true)];
=TEX
\subsection{R0049: Generic Packages and Subprograms} \label{RFive}
\subsection{R0050: Discriminants} \label{RSix}
=SML
clean_up();
new_script{name = "r6.1", state = initial_cn_state};

πCN
 procedure main
 is
  type disc_rec1 (size : integer) is
   record
    pos : integer;
    buf : string( 1 .. size );
   end record; 
  procedure p Ñ[true] is begin null; end p;
  c2 : disc_rec1(42);
  c3 : disc_rec1 := disc_rec1'(2,  1, "ab");
  type disc_rec2 (size1 : integer; size2 : integer) is
   record
    pos2 : integer;
    buf1 : disc_rec1( size1 );
    buf2 :  string( 1 .. size2 );
   end record;
  type uncon2 is array(integer range <>, integer range <>) of character;
  subtype sub_ty1 is integer range 1 .. 10;
  subtype sub_ty2 is integer range 1 .. 15;
  type disc_rec3 (lo1, hi1, lo2, hi2 : integer) is
   record
    buf1 : uncon2(lo1 .. hi1, lo2 .. hi2);
    buf2 : uncon2(sub_ty1, lo2 .. hi2);
    buf3 : uncon2(lo1 .. hi1, sub_ty2 range lo2 .. hi2);
    buf4 : uncon2(sub_ty1, sub_ty2);
   end record;
 begin
 Ñ C3 [ C2.SIZE = 42 ± C3 = (SIZE ¶  1, POS ¶ 1, BUF ¶ string_lit "X")]
 end main;
∞

πCN
  √  c3 := disc_rec1'(1,  1, "X");
∞
=SML
val _ = cn_make_script_support "-" "r6.1";
set_pc"r6.1";
set_goal([], get_conjecture"-""vc_1_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
store_mt_results
mt_run
 [("r6.1.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{R0051: Default parameters} \label{RSeven}
=SML
clean_up();
new_script{name="r7.1", state=initial_cn_state};

πCN
 procedure p
 is
   x, y : integer;
   c : constant integer := 99;
   procedure q (a : in integer := c)
  Ñ X [X = A]
  is begin x := a; end q;
 begin
 Ñ X, Y [ X = 99 ]
 end p;
∞
πCN
  √ q;
∞

=SML
store_mt_results
(mt_runf (op =$))
 [("r7.1.1", get_conjecture "-" , "vc_1_2", Òµ X : INTEGER | true ± X = C ∑ X = 99Æ)];
=SML
clean_up();
new_script{name="r7.2", state=initial_cn_state};

πCN
 procedure p
 is
   x, y : integer;
   c : constant integer := 99;
   procedure q (a : in integer := c)
  Ñ X [X = A]
  is begin x := a; end q;
  procedure r (y : in integer := 2*c) renames q;
 begin
 Ñ X [ X = 198 ]
 end p;
∞
πCN
  √ r;
∞
=SML
store_mt_results
(mt_runf (op =$))
 [("r7.2.1", get_conjecture "-" , "vc_1_2", Òµ X : INTEGER | true ± X = 2*C ∑ X = 198Æ)];
=TEX
=SML
clean_up();
new_script{name="r7.3", state=initial_cn_state};

πCN
 procedure p
 is
   type interval is range 1 .. 1000;
   x, y : interval;
   c : constant interval := 99;
   function q (a : in interval := c) return interval
  ò X [Q X A = X + A]
  is begin return x + a; end q;
  function r (y : in interval := 2*c)  return interval renames q;
 begin
 Ñ X, Y [ Y = 5 * 99 ]
 end p;
∞
πCN
  √  x := c; y := q + r;
∞
=TEX
=SML
all_cn_make_script_support "r7.3";
set_pc "r7.3";
set_goal([], get_conjecture"-""vc_1_1");
a(cn_vc_simp_tac[]);
a(PC_T1 "cn1" lemma_tacÒ99 ç INTERVAL ± 198 ç INTERVALÆ THEN1 REPEAT strip_tac);
a(PC_T1 "cn1" (ALL_FC_T rewrite_tac)[z_get_specÒQÆ]);
store_mt_results
mt_run
 [("r7.3.1", fun_true o pop_thm , (), true)];
=SML
clean_up();
new_script{name="r7.4", state=initial_cn_state};

πCN
 procedure p
 is
   type interval is range 1 .. 1000;
   x, y : interval;
   c : constant interval := 99;
   procedure q (a, b : in interval := c; m : interval; y, z : interval := 2*c) 
  Ñ X [X = A + B + M + Y + Z]
  is begin x := a + b + m + y + z; end q;
 begin
 Ñ X [ X = 7 * 99 - 1 ]
 end p;
∞
πCN
  √  q(m => c - 1);
∞

=SML
all_cn_make_script_support "r7.4";
set_pc "r7.4";
set_goal([], get_conjecture"-""vc_1_2");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
store_mt_results
mt_run
 [("r7.4.1", fun_true o pop_thm , (), true)];
=TEX
=SML
clean_up();
new_script{name="r7.5", state=initial_cn_state};

πCN
 procedure p
 is
   type interval is range 1 .. 1000;
   m : interval;
  function add (x : interval := 1; y : in interval := 2)  return interval renames "+";
 begin
 Ñ M [ M = 13 ]
 end p;
∞
πCN
  √  m := add(add(add(3), add(y => 4)), add); --   ((3+2) + (1+4)) + (1+2)
∞
=SML
set_pc "cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(cn_vc_simp_tac[z_get_specÒADDÆ]);
store_mt_results
mt_run
 [("r7.5.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{R0052: Block statements} \label{REight}
=SML
clean_up();
new_script{name="r8.1", state=initial_cn_state};

πCN
 procedure p
 is
   x : integer;
 begin
 Ñ X [ X = 0 ]
 end p;
∞

πCN
  √ begin x := 0; end;
∞
=SML
store_mt_results
(mt_runf (op =$))
 [("r8.1.1", get_conjecture "-" , "vc_1_1", Òtrue ¥ 0 = 0Æ)];
=SML
clean_up();
new_script{name="r8.2", state=initial_cn_state};

πCN
 procedure p
 is
   x : integer;
 begin
 Ñ X [ X = 0 ]
 end p;
∞

πCN
  √ declare begin x := 0; end;
∞
=SML
store_mt_results
(mt_runf (op =$))
 [("r8.2.1", get_conjecture "-" , "vc_1_1", Òtrue ¥ 0 = 0Æ)];
=SML
clean_up();
new_script{name="r8.3", state=initial_cn_state};

πCN
 procedure p
 is
   x : integer;
 begin
 Ñ X [ X = 0 ]
 end p;
∞

πCN
  √ x := 4;
    Ñ X [ X = 4, X = 0]
∞
πCN
  √ declare y : integer := x; begin x := x - y; end;
∞
The VC from the last step will be unprovable unless the initialisation of y has been looked after
properly.
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_2_1");
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
store_mt_results
mt_run
 [("r8.3.1", fun_true o pop_thm , (), true)];
=TEX
Now check that more complicated things in a block declarative part are OK.
=SML
clean_up();
new_script{name="r8.4", state=initial_cn_state};

πCN
 procedure p
 is
   x : integer;
 begin
 Ñ X [ X = 0 ]
 end p;
∞

πCN
  √
  declare
   type t is range 1 .. 10;
    y : t := t(x);
    c : constant integer := 5;
   function f (x : in t) return integer
  ò [ F X = X + C ]
   is begin  return integer(x) + c; end f;
  begin
    x := f(y) - x - 5;
  end;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_2");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_get_specÒFÆ]);
a(asm_rewrite_tac[z_get_specÒCÆ]);
a(PC_T1"z_lin_arith" prove_tac[]);
store_mt_results
mt_run
 [("r8.4.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{R0053/R0073: Loop names, exits from named loops, return statements} \label{RNine}

=SML
clean_up();
new_script{name="r9.1", state=initial_cn_state};

πCN
 procedure set(a : in boolean; x : in out boolean)
 ÑX [A = X, X = TRUE]
 is
 begin
  if a then return; end if;
  x := true;
 end set;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcSET_1");
a(prove_tac[]);
store_mt_results
mt_run
 [("r9.1.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcSET_2");
a(prove_tac[]);
store_mt_results
mt_run
 [("r9.1.2", fun_true o pop_thm , (), true)];
=SML
clean_up();
new_script{name="r9.2", state=initial_cn_state};

πCN
 procedure main
 is
  type table is array(1..10) of boolean;
  procedure find_true(flags : table; i : in out integer; not_found : out boolean)
  Ñ I, NOT_FOUND [FLAGS I = TRUE ≤ NOT_FOUND = TRUE]
  is
  begin
   i := 1;
-- Optimist's approach: guess it's there, return from proc when found, exit loop when none found.
   not_found := false;
  L1:
  till ˚I = 11˝
  loop
   Ñ I [NOT_FOUND = FALSE, NOT_FOUND = FALSE]
  end loop L1;
  not_found := true;
  end find_true;
 begin
   null;
 end main;
∞
πCN
  √
   if flags(i) then return; end if;
     i := i + 1;
    exit L1 when i = 11;
∞
=SML
set_pc"cn1";
val r9_2_vcs = map (snd o snd) (get_conjectures"-");

fun r9_2_tp conj = tac_proof(([], conj), cn_vc_simp_tac[] THEN prove_tac[]);

store_mt_results
mt_run
 [("r9.2.1", length o map (dest_thm o r9_2_tp o switch nth r9_2_vcs) , interval 0 5, length r9_2_vcs)];


=SML
clean_up();
new_script{name="r9.3", state=initial_cn_state};

πCN
 procedure main
 is
  type table is array(1..10) of boolean;
  procedure find_true(flags : table; i : in out integer; not_found : out boolean)
  Ñ I, NOT_FOUND [FLAGS I = TRUE ≤ NOT_FOUND = TRUE]
  is
  begin
   i := 1;
-- Pessimist's approach: guess it's not there, return from proc when not found, exit loop when found.
   not_found := true;
  L1:
  till ˚FLAGS I = TRUE˝
  loop
   Ñ I [NOT_FOUND = TRUE, NOT_FOUND = TRUE]
  end loop L1;
  not_found := false;
  end find_true;
 begin
   null;
 end main;
∞
πCN
  √
    exit L1 when flags(i);
     i := i + 1;
    if  i = 11 then return; end if;
∞

=SML
set_pc"cn1";
val r9_3_vcs = map (snd o snd) (get_conjectures"-");

fun r9_3_tp conj = tac_proof(([], conj), cn_vc_simp_tac[] THEN prove_tac[]);

store_mt_results
mt_run
 [("r9.3.1", length o map (dest_thm o r9_3_tp o switch nth r9_3_vcs) , interval 0 5, length r9_3_vcs)];

=SML
clean_up();
new_script{name="r9.4", state=initial_cn_state};

πCN
 procedure main
 is
  type table is array(1..10, 1..10) of boolean;
  procedure find_true(flags : table; i, j : in out integer; not_found : out boolean)
  Ñ I, J, NOT_FOUND [FLAGS(I, J) = TRUE ≤ NOT_FOUND = TRUE]
  is
  begin
   i := 1;
   not_found := true;
  L1:
  till ˚FLAGS(I, J) = TRUE˝
  loop
   Ñ I, J [NOT_FOUND = TRUE, NOT_FOUND = TRUE]
  end loop L1;
 not_found := false;
  end find_true;
 begin
   null;
 end main;
∞
πCN
  √
      j := 1;
     till ˚FLAGS(I, J) = TRUE ≤ J = 11˝
      loop
     Ñ J [NOT_FOUND = TRUE, NOT_FOUND = TRUE]
     end loop;
     i := i + 1;
     if i = 11
    then
      return;
    end if;
∞

πCN
  √
       exit L1 when flags(i, j);
       j := j + 1;
      exit when j = 11;
∞


=SML
set_pc"cn1";
val r9_4_vcs = map (snd o snd) (get_conjectures"-");

fun r9_4_tp conj = tac_proof(([], conj), cn_vc_simp_tac[] THEN prove_tac[]);

store_mt_results
mt_run
 [("r9.4.1", length o map (dest_thm o r9_4_tp o switch nth r9_4_vcs) , interval 0 9, length r9_4_vcs)];

=TEX
\subsection{R0055: Warnings for non-SPARK constructs} \label{RTen}
\subsection{R0056: Default parameter modes} \label{REleven}
\subsection{R0057: Script management facilities} \label{RTwelve}
\subsection{R0058: Forward declarations of subprograms} \label{RThirteen}
=SML
clean_up();
new_script{name="r13.1", state=initial_cn_state};
πCN
 procedure main
 is
  x : integer := 0;
  procedure increment(a : in out integer)
  Ñ A [ A = Aâ0 + 1];
 function add1(a : in integer) return integer
 ò [ADD1 A = A + 1];
 function add1(a : in integer) return integer
 ò [ADD1 A = A + 1] 
 is
  t : integer;
 begin
  t := a;
  Ñ T [T = A,  T = A + 1 ]  (add1)
  return t;
 end add1;
  procedure increment(a : in out integer)
  Ñ A [ A = Aâ0 + 1]
  is
  begin
   a := a + 1;
  end increment;
 begin
   Ñ X [ X = 0,  X = 2 ] (main)
 end main;
∞
πCN
(add1) √
  increment(t);
∞
πCN
(main) √
  increment(x); x := add1(x);
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcMAIN_1");
a(prove_tac[]);
store_mt_results
mt_run
 [("r13.1.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_2");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
store_mt_results
mt_run
 [("r13.1.2", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_3");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.1.3", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_4");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.1.4", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_5");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[z_get_specÒADD1Æ]);
store_mt_results
mt_run
 [("r13.1.5", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcADD1_1");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.1.6", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcADD1_2");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN strip_tac);
store_mt_results
mt_run
 [("r13.1.7", fun_true o pop_thm , (), true)];


=TEX
=SML
clean_up();
new_script{name="r13.2", state=initial_cn_state};
πCN
  procedure mk_pos(a : in out integer)
  Ñ A [ A > 0]
 is
 begin
   if a <= 0 then a := a + 1; mk_pos(a); end if;
 end mk_pos;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcMK_POS_1");
a(prove_tac[]);
store_mt_results
mt_run
 [("r13.2.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMK_POS_2");
a(prove_tac[]);
store_mt_results
mt_run
 [("r13.2.2", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMK_POS_3");
a(cn_vc_simp_tac [] );
store_mt_results
mt_run
 [("r13.2.3", fun_true o pop_thm , (), true)];
=TEX


=SML
clean_up();
new_script{name="r13.3", state=initial_cn_state};
πZAX
‹	fact : ˙ ≠ ˙
˜¸¸¸¸¸¸
‹	fact 0 = 1 ;
‹ 	µm:Ó∑ fact(m+1) = (m + 1) * fact m
∞
πCN
procedure p
is
  type num is range 0 .. 1000000;
  function fact(a :  num) return num
  ò [µx: NUM∑ x <  A ¥ FACT x = fact  x, FACT A = fact A]
 is
 begin
   if a = 0 then return 1; else return a * fact(a-1); end if;
 end fact;
begin
 null;
end p;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[z_get_specÒfactÆ]);
store_mt_results
mt_run
 [("r13.3.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcP_2");
a(cn_vc_simp_tac[z_get_specÒNUMÆ] THEN REPEAT strip_tac);
a(lemma_tacÒ∂B:Ó∑A = B + 1Æ  THEN1
	(z_∂_tacÒA- 1Æ THEN rewrite_tac[] THEN PC_T1"z_lin_arith" asm_prove_tac[]));
a(all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 4 ÒBÆ THEN1 PC_T1"z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T asm_rewrite_tac[z_get_specÒfactÆ]);
a(asm_rewrite_tac[z_plus_assoc_thm]);
store_mt_results
mt_run
 [("r13.3.2", fun_true o pop_thm , (), true)];

set_goal([], ÒµA: NUM∑ FACT A = fact AÆ);
a(ante_tac(z_get_specÒFACTÆ));
a(rewrite_tac[z_get_specÒNUMÆ] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN z_cov_induction_tac ÒAÆ);
a(z_spec_nth_asm_tac 3 ÒAÆ THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 6 ÒxÆ THEN REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.3.3", fun_true o pop_thm , (), true)];










=TEX
\subsection{R0059: Enhanced syntax-check-only mode} \label{RFourteen}
\subsection{R0060/R0064: Rationalised error reporting} \label{RFifteen}
\subsection{R0061: Change symbol for statement replacement} \label{RSixteen}
\subsection{R0062: Origin of VCs} \label{RSeventeen}
\subsection{R0063: Unexpanded specification statements} \label{REighteen}
\subsection{R0065: Duplicated names in context clauses} \label{RNineteen}

=SML
clean_up();
new_script{name = "r19.1", state = initial_cn_state};

πCN
package p
is
  a, b : integer;
  y : integer renames a;
  z : integer renames b;
end p;
∞

=SML
new_script{name = "r19.2.a", state =get_cn_state()};

πCN
with p, p;
use p;
procedure r
is
begin
  Ñ A, Z[A = PoY ± PoB = PoZ, B = 42 ± PoY = PoA]
end r;
∞

πCN
  √  p.a := 42; p.z := p.y;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convÒ42Æ));
store_mt_results
mt_run
 [("r19.2.1", fun_true o pop_thm , (), true)];



=TEX
\subsection{R0066: Auxiliary variables in function $\Xi $-lists} \label{RTwenty}
\subsection{R0067: Schema references in function $\Xi $-lists} \label{RTwentyOne}
\subsection{R0071: Multiple underscores in Z identifiers} \label{RTwentyTwo}
\subsection{R0068: Poly/ML problems and other bug-fixing} \label{RTwentyThree}
\subsection{R0077: Relax restrictions on aggregates used as initial values} \label{RTwentyFour}
=SML
clean_up();
new_script{name = "r24.1", state = initial_cn_state};

πCN
procedure p(x, y : out integer)
Ñ X, Y [ X = 1 ± Y = 2]
is
  type pair is record a, b : integer; end record;
  cp : constant pair := (a => 1, b => 2);
  vp : pair := (3, 2);
begin
Ñ X, Y, VP [VP = (A ¶ 3, B ¶ 2), X = 1 ± Y = 2]
end p;
∞
πCN
  √ 
  y := vp.b;
  x := cp.a;
∞


=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcP_1");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r24.1.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcP_2");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r24.1.2", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT strip_tac THEN asm_rewrite_tac[z_get_specÒCPÆ]);
store_mt_results
mt_run
 [("r24.1.3", fun_true o pop_thm , (), true)];
=TEX
\subsection{R0079: Assertions{RTwentySix}
=SML
clean_up();
new_script{name = "r26.1", state = initial_cn_state};
πCN
procedure p
Ñ [ true ]
is
 x : integer;
begin
 x := 2;
 á{X Ω 0}
end p;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcP_1");
a(REPEAT strip_tac);
store_mt_results
(mt_runf (op =$))
 [("r26.1.1", concl o pop_thm , (), Òtrue ¥ 2 Ω 0Æ)];
=TEX
=SML
clean_up();
new_script{name = "r26.2", state = initial_cn_state};
πCN
procedure p( y : integer)
is
 x : integer;
begin
Ñ X [ Y æ 0, true ]
end p;
∞
πCN
√ x := y + 1;
  á{X > 0}
∞

=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(cn_vc_simp_tac[] THEN PC_T1 "z_lin_arith" prove_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r26.2.1", concl o pop_thm , (), Òµ Y : INTEGER | Y æ 0 ∑ Y + 1 > 0Æ)];
=TEX
=SML
clean_up();
new_script{name = "r26.3.1", state = initial_cn_state};
πCN
package p
is
 x : integer;
end p;
∞
=SML
new_script{name = "r26.3.2", state = get_cn_state()};
fun do_it () =
πCN
package body p
is
begin
 x := 1;
 á {X > 0}
end p;
∞
=TEX
=SML
store_mt_results
mt_run_fail
[
	("r26.3.1", do_it, (), gen_fail_msg "do_statement"  507077 [])
];
=TEX
=SML
clean_up();
new_script{name = "r26.4.1", state = initial_cn_state};
πCN
package p
is
 x : integer;
end p;
∞
=SML
new_script{name = "r26.4.2", state = get_cn_state()};
πCN
package body p
is
begin
Ñ X[ true ]
end p;
∞
πCN
√ 
 x := 1;
 á {X > 0}
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT strip_tac);
store_mt_results
(mt_runf (op =$))
 [("r26.4.1", concl o pop_thm , (), Òtrue ¥ 1 > 0Æ)];
=TEX
=SML

=TEX
\subsubsection{pp2.5.4-bug1/R0042}
There are specific tests for the detailed changes to the treatment of aliases in {\ProductHOL}
in the relevant HOL module tests.
We give an explicit test here for the problem as reported by QinetiQ.
=SML
clean_up();
new_theory"t";
val b1_thm = (hd o rev o strip_±_rule o z_get_spec)Ò(absâR_)Æ;
=SML
store_mt_results
mt_run
 [("bugs.1.1", (PrettyPrinter.format_term true o concl), b1_thm, 
	["Òµ x : Ø ∑ absâR x = ¨Abs xÆÆ"])];
=TEX
\subsubsection{pp2.5.4-bug2}
Explicitly tested here:
=SML
clean_up();
new_script{name = "pack.ads", state = initial_cn_state};
πCN
package Pack is
  type Rec is record A, B : Integer; end record;
  procedure P (X : in out Integer);
  procedure Q (X : in out Rec);
end Pack;  
∞
=SML
val state = get_cn_state();
new_script{name = "pack.adb", state = state};
πCN
package body Pack is
  procedure P (X : in out Integer)
  Ñ X [ X = 22 ]
  is separate;
  procedure Q (X : in out Rec)
  is separate;
end Pack;  
∞
=SML
val state = get_cn_state();
new_script{name = "pack-p.adb", state = state};
πCN 
separate (Pack)
procedure P (X : in out Integer)
Ñ X [ X = 22 ]
is
begin
  X := 22;
end P;
∞
=SML
val state = get_cn_state();
new_script{name = "pack-q.adb", state = state};
πCN 
separate (Pack)
procedure Q (X : in out Rec)
Ñ X [ X.A = 22 ]
is
  V : Integer;
begin
  P(V);
  X.A := V;
end Q;
∞
With the bug the last web clause made the tool raise an exception.
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcPACKoQ_2");
a(rewrite_tac[z_gen_pred_elim[ÒUÆ](z_get_specÒRECuAÆ)]);
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("bug.254.2.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcPACKoQ_2")];
=TEX
\subsubsection{pp2.5.4-bug4}
Tested in INT511.
\subsubsection{pp2.5.4-bug5}
Tested in INT511.
\subsubsection{pp2.5.4-bug6}
=SML
clean_up();
new_script{name = "test.adb", state = initial_cn_state};
πCN
procedure Test is
  C1 : constant Float := Float(55);
  C2 : constant Float := Float(55.7);
begin
  null;
end Test;
∞
=SML
set_pc"cn1";
set_goal([], ÒC1 = real 55 ± C2 = 557 e (~1)Æ);
a(rewrite_tac(map z_get_spec[ÒC1Æ,ÒC2Æ, Òinteger_to_realÆ]));
store_mt_results
(mt_runf (op =$))
 [("bug.254.6.1", snd o dest_thm o pop_thm , (), ÒC1 = real 55 ± C2 = 557 e (~1)Æ)];
=TEX
\subsubsection{pp2.5.4-bug7}
At release 2.5.7 and later this bug becomes irrelevant --- the syntactic restrictions
on return statements have been dropped.
=TEX
\subsubsection{R0076}
Explicitly tested here using a test based on an example From Alf Smith.
=SML
clean_up();
new_script{name = "stack.ads", state = initial_cn_state};
πCN
package Stack is
  auxiliary v : ˙;
  procedure Pop (X : out Integer)  
  Ñ X ò v [ X = v ];
end Stack;
∞
=SML
val state = get_cn_state();
new_script{name = "stack.adb", state = state};
fun do_it() =
πCN
package body Stack is
  using V : Integer; implement v by V = v;
  procedure Pop (X : out Integer)  
  Ñ X [ X = V ± V = Vâ0 ]
  is
  begin
    X := V;
  end Pop;
begin
  null;
end Stack;
∞
store_mt_results
mt_run_fail
[
	("r0076.1", do_it, (), gen_fail_msg "zid"  508021 ["V"])
];

=TEX
\subsubsection{pp2.5.9-bug0}
Explicitly tested here.
=SML
clean_up();
new_script { name = "test.ads", state = initial_cn_state };

πCN
package P is
  type T is range 1 .. 10;
  function FUNCT56 (LEFT : in T; RIGHT : in T) return T
    ò [ FUNCT56(LEFT, RIGHT) = LEFT * RIGHT ];
  function F56 (LEFT : in T; RIGHT : in T) return T renames FUNCT56;
end P;
∞
=SML
new_script { name = "test2.ads", state = get_cn_state() };
πCN
with p;
procedure q
is
 x : p.T;
begin
 Ñ X[ X = 4 ]
end q;
∞
πCN
  √ x := p.f56(2, 2);
∞
=SML
set_pc"cn1";
set_goal([], ÒPoF56 = PoFUNCT56Æ);
a(contr_tac THEN ante_tac (±_right_elim(z_get_specÒPoF56Æ)) THEN asm_rewrite_tac[]);
a(conv_tac z_≥_µ_conv);
a(z_∂_tacÒ(RIGHT¶1, LEFT¶1)Æ THEN rewrite_tac[z_get_specÒPoTÆ]);
store_mt_results
mt_run
 [("bug.259.0.1", fun_true o pop_thm , (), true)];
=TEX
\subsubsection{pp2.5.9-bug1}
Explicitly tested here.
=SML
clean_up();
new_script { name = "test.ads", state = initial_cn_state };

πCN
package P is
  type T is range 1 .. 10;
  x : T;
  procedure PROC121 (LEFT : in T; RIGHT : in out T)
   Ñ X [ X  = 1] ;
  procedure P121 (LEFT : in T; RIGHT : in out T) renames PROC121;
end P;
∞
=SML
new_script { name = "test2.ads", state = get_cn_state() };
πCN
with p;
use p;
procedure q
is
 y : p.T;
begin
 Ñ X, Y[ Y = 1 ]
end q;
∞
πCN
  √ p.p121(1, y); y := x;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_2");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("bug.259.1.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vc_1_2")];
=TEX
\subsubsection{pp2.5.9-bug2}
Explicitly tested here.
=SML
clean_up();
new_script { name = "P.ads", state = initial_cn_state };
πCN
package P is
  type T is (A, B, C);
end P;
∞
=SML
new_script { name = "R.ads", state = get_cn_state() };
πCN
with P;
use P;
package R is
 x : T;
end R;
∞
=SML
new_script { name = "S.ads", state = get_cn_state() };
πCN
with P;
use P;
package S is
 y : T;
end S;
∞
=SML
new_script { name = "V.ads", state = get_cn_state() };
πCN
with R;
with S;
package V is
  use R;
  use S;
  procedure mk_a
  Ñ X, Y[X = Y = PoA];
end V;
∞
=SML
new_script { name = "V.adb", state = get_cn_state() };
πCN
with R;
with S;
package body V is
  use R;
  use S;
  procedure mk_a
  Ñ X, Y[X = Y = PoA]
  is begin x := p.a; y := p.a; end mk_a;
end V;
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-" "vcVbody_2");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("bug.259.2.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcVbody_2")];
=TEX
=SML
clean_up();
new_script { name = "P.ads", state = initial_cn_state };
πCN
package P is
  type T is (A, B, C);
end P;
∞
=SML
new_script { name = "R.ads", state = get_cn_state() };
πCN
with P;
package R is
  use P;
end R;
∞
=SML
new_script { name = "S.ads", state = get_cn_state() };
πCN
with P;
package S is
  use P;
end S;
∞
=SML
new_script { name = "V.ads", state = get_cn_state() };
fun doit() =
πCN
with R;
with S;
package V is
  use R;
  use S;
end V;
∞
=SML
store_mt_results
mt_run
 [("bug.259.2.2", doit , (), ())];
=TEX
\subsubsection{pp2.5.9-bug3}
Explicitly tested here.
=SML
clean_up();
new_script { name = "A.ads", state = initial_cn_state };
πCN
package A is
  type T is record
    I : INTEGER;
  end record;
  V : T;
end A;
∞
=SML
new_script { name = "B.ada", state = get_cn_state() };
πCN
with A;
procedure B
is
  W : INTEGER;
  procedure P (X : in INTEGER)
    Ñ W [ W = X ]
  is begin
   W := X;
  end P;
begin
 Ñ W [ W = AoV.I]
end B;
∞
=SML
fun b259_3() =
πCN
  √   P (X => A.V.I);      -- fails at 2.5.9 and earlier if procedure B has formal spec
∞
=SML
store_mt_results
mt_run
 [("bug.259.3.1", fun_true o b259_3 , (), true)];
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_2" handle Fail _ => mk_t);
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("bug.259.3.2", fun_true o pop_thm , (), true)];
=TEX
\subsubsection{pp2.5.10-bug0}
Explicitly tested here.
=SML
clean_up();
new_script { name = "A.ads", state = initial_cn_state };

πCN
package A is

  type T is record
    I : INTEGER;
  end record;

end A;
∞
=SML
new_script { name = "B.ads", state = get_cn_state() };

πCN
with A;
package B is

  use A;

  Y0 : constant A.T := T'(I => 543);	-- used to fail
  Y1 : constant T := T'(I => 543);	-- used to fail
  Y2 : constant T := (I => 543);	-- used to fail

end B;
∞
=SML
set_pc"cn1";
set_goal([], ÒY0.I = Y1.I = Y2.I = 543Æ);
a(cn_vc_simp_tac(map z_get_spec[ÒY0Æ, ÒY1Æ, ÒY2Æ]));
store_mt_results
mt_run
 [("bug.2510.0.1", fun_true o pop_thm , (), true)];
=TEX
\subsubsection{R0046}
\subsubsection{R0075}
=TEX
\section{EPILOGUE}
=SML
diag_line(summarize_mt_results());
=TEX
\end{document}
