=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Spring 2002 Enhancement Tests }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document provides integration tests to support the enhancements developed 
under the enhancements programme carried out inspring 2002.}
\end{center}}

\def\Reference{LEMMA1/DAZ/INT522}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.2 $%
}
\def\Date{\FormatDate{$Date: 2002/05/11 14:08:34 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\underscoreoff
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
h{\raggedright
\bibliography{fmu,daz}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1-1.2] First drafts
\item[Issue 1.3] 2.5.4 bug 7 has been withdrawn.
\item[Issue 1.4] interim release tests.
\item[Issue \Version] improved recursion examples.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Rob Arthan & Lemma 1
\end{tabular}
\end{center}


\section{INTRODUCTION}\label{INTRODUCTION}
This document is intended to provide integration tests to cover
the enhancements undertaken under the programme
of enhancements carried out in Spring 2002. See \cite{LEMMA1/DAZ/HLD509}
for the detailed specification of the enhancements.

The interim releases of the Compliance Tool have been
fully regression-tested and the new features have been module-
and integration-tested to a certain extent by the existing tests.
This document provides specific integration tests to
complete the coverage. 
\section{PREAMBLE}
Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.

=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn"
                                        diff get_cache_theories())
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ())
        in      map del_thy thys;
	open_theory"cn";
	set_pc "cn1"
        end;    ()
);
=TEX
=TEX
For batch use turn off subgoal package output:
=SML
set_flag("subgoal_package_quiet", not(ExtendedIO.is_term_in std_in));
=TEX
\section{THE TESTS}
\subsection{R0002: Spring 2002 Efficiency Issues} \label{ROne}
\subsection{R0031/R0069: {\tt Xpp} enhancements} \label{RTwo}
\subsection{R0047/R0054: Renaming declarations and use clauses} \label{RThree}
=SML
clean_up();
new_script{name = "r3.1", state = initial_cn_state};

¹CN
procedure p
is
  a, b : integer;
  y : integer renames a;
  z : integer renames b;
begin
  „ A, B [A = Y ± B = Z, Z = 42 ± Y = A]
end p;
°
¹CN
  Ã  a := 42; z := y;
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convñ42®));
store_mt_results
mt_run
 [("r3.1.1", fun_true o pop_thm , (), true)];

=SML
clean_up();
new_script{name = "r3.2", state = initial_cn_state};

¹CN
package p
is
  a, b : integer;
  y : integer renames a;
  z : integer renames b;
end p;
°

=SML
new_script{name = "r3.2.a", state =get_cn_state()};

¹CN
with p;
procedure q
is
begin
  „ PoA, PoB[PoA = PoY ± PoB = PoZ, PoZ = 42 ± PoY = PoA]
end q;
°

¹CN
  Ã  p.a := 42; p.z := p.y;
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convñ42®));
store_mt_results
mt_run
 [("r3.2.1", fun_true o pop_thm , (), true)];

=SML
new_script{name = "r3.2.b", state =get_cn_state()};

¹CN
with p;
use p;
procedure r
is
begin
  „ A, Z[A = PoY ± PoB = PoZ, B = 42 ± PoY = PoA]
end r;
°

¹CN
  Ã  p.a := 42; p.z := p.y;
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convñ42®));
store_mt_results
mt_run
 [("r3.2.2", fun_true o pop_thm , (), true)];

=SML
new_script{name = "r3.2.c", state =get_cn_state()};

¹CN
with p;
procedure s
is
package REN renames p;
begin
  „ PoA, RENoZ[RENoA = RENoY ± RENoB = RENoZ, PoB = 42 ± RENoY = RENoA]
end s;
°

¹CN
  Ã  REN.a := 42; p.z := REN.y;
°

=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convñ42®));
store_mt_results
mt_run
 [("r3.2.3", fun_true o pop_thm , (), true)];
=SML
clean_up();
new_script{name = "r3.3", state = initial_cn_state};

¹CN
package p1
is
  a, b : integer;
   §more decs ¢			( decs )
end p1;
°

=SML
val p1_state = get_cn_state();
new_script{name = "r3.3.a", state = get_cn_state()};
fun do_it() =
¹CN
with p1;
use p1;
procedure s
„ A [ Y = 0]
is
begin
  p1.y := a - y;
end s;
°
=SML
store_mt_results
mt_run_fail
[
	("r3.3.1", do_it, (), gen_fail_msg "check_pack_complete"  507071 ["P1", ": DECS"])
];

=SML
new_script{name = "r3.3.b", state = initial_cn_state};
=SML
store_mt_results
mt_run_fail
[
	("r3.3.2", do_it, (), gen_fail_msg "do_declaration"  507063 ["P1"])
];

=SML
set_cn_state p1_state;

¹CN
 (decs) é   y : integer renames a;
°
=SML
new_script{name = "r3.3.c", state =get_cn_state()};

=SML
store_mt_results
mt_run
[
	("r3.3.3", do_it, (), ())
];

=TEX
\subsection{R0048: {\tt Use type} clauses} \label{RFour}
=SML
clean_up();
new_script{name = "r4.1", state = initial_cn_state};
¹CN
package p1
is
  type byte is range 0 .. 255;
end p1;
°
=SML
new_script{name = "r4.1.a", state = get_cn_state()};
¹CN
with p1;
use type p1;
procedure s
is
 a : p1.byte;
begin
  null;
end s;
°
=SML
store_mt_results
mt_run [("r4.1.1", fun_true , "just have to get here", true)];
=SML
new_script{name = "r4.1.b", state = get_cn_state()};
¹CN
with p1, undefined1;
with undefined2;
use type p1, undefined1, undefined2;
procedure s
is
 a : p1.byte;
begin
  null;
end s;
°
=SML
store_mt_results
mt_run [("r4.1.2", fun_true , "just have to get here", true)];
=TEX
\subsection{R0049: Generic Packages and Subprograms} \label{RFive}
\subsection{R0050: Discriminants} \label{RSix}
=SML
clean_up();
new_script{name = "r6.1", state = initial_cn_state};

¹CN
 procedure main
 is
  type disc_rec1 (size : integer) is
   record
    pos : integer;
    buf : string( 1 .. size );
   end record; 
  procedure p „[true] is begin null; end p;
  c2 : disc_rec1(42);
  c3 : disc_rec1 := disc_rec1'(2,  1, "ab");
  type disc_rec2 (size1 : integer; size2 : integer) is
   record
    pos2 : integer;
    buf1 : disc_rec1( size1 );
    buf2 :  string( 1 .. size2 );
   end record;
  type uncon2 is array(integer range <>, integer range <>) of character;
  subtype sub_ty1 is integer range 1 .. 10;
  subtype sub_ty2 is integer range 1 .. 15;
  type disc_rec3 (lo1, hi1, lo2, hi2 : integer) is
   record
    buf1 : uncon2(lo1 .. hi1, lo2 .. hi2);
    buf2 : uncon2(sub_ty1, lo2 .. hi2);
    buf3 : uncon2(lo1 .. hi1, sub_ty2 range lo2 .. hi2);
    buf4 : uncon2(sub_ty1, sub_ty2);
   end record;
 begin
 „ C3 [ C2.SIZE = 42 ± C3 = (SIZE ¦  1, POS ¦ 1, BUF ¦ string_lit "X")]
 end main;
°

¹CN
  Ã  c3 := disc_rec1'(1,  1, "X");
°
=SML
val _ = cn_make_script_support "-" "r6.1";
set_pc"r6.1";
set_goal([], get_conjecture"-""vc_1_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
store_mt_results
mt_run
 [("r6.1.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{R0051: Default parameters} \label{RSeven}
\subsection{R0052: Block statements} \label{REight}
\subsection{R0053/R0073: Loop names, exits from named loops, return statements} \label{RNine}

=SML
clean_up();
new_script{name="r9.1", state=initial_cn_state};

¹CN
 procedure set(a : in boolean; x : in out boolean)
 „X [A = X, X = TRUE]
 is
 begin
  if a then return; end if;
  x := true;
 end set;
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcSET_1");
a(prove_tac[]);
store_mt_results
mt_run
 [("r9.1.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcSET_2");
a(prove_tac[]);
store_mt_results
mt_run
 [("r9.1.2", fun_true o pop_thm , (), true)];
=SML
clean_up();
new_script{name="r9.2", state=initial_cn_state};

¹CN
 procedure main
 is
  type table is array(1..10) of boolean;
  procedure find_true(flags : table; i : in out integer; not_found : out boolean)
  „ I, NOT_FOUND [FLAGS I = TRUE ² NOT_FOUND = TRUE]
  is
  begin
   i := 1;
-- Optimist's approach: guess it's there, return from proc when found, exit loop when none found.
   not_found := false;
  L1:
  till ûI = 11ý
  loop
   „ I [NOT_FOUND = FALSE, NOT_FOUND = FALSE]
  end loop L1;
  not_found := true;
  end find_true;
 begin
   null;
 end main;
°
¹CN
  Ã
   if flags(i) then return; end if;
     i := i + 1;
    exit L1 when i = 11;
°
=SML
set_pc"cn1";
val r9_2_vcs = map (snd o snd) (get_conjectures"-");

fun r9_2_tp conj = tac_proof(([], conj), cn_vc_simp_tac[] THEN prove_tac[]);

store_mt_results
mt_run
 [("r9.2.1", length o map (dest_thm o r9_2_tp o switch nth r9_2_vcs) , interval 0 5, length r9_2_vcs)];


=SML
clean_up();
new_script{name="r9.3", state=initial_cn_state};

¹CN
 procedure main
 is
  type table is array(1..10) of boolean;
  procedure find_true(flags : table; i : in out integer; not_found : out boolean)
  „ I, NOT_FOUND [FLAGS I = TRUE ² NOT_FOUND = TRUE]
  is
  begin
   i := 1;
-- Pessimist's approach: guess it's not there, return from proc when not found, exit loop when found.
   not_found := true;
  L1:
  till ûFLAGS I = TRUEý
  loop
   „ I [NOT_FOUND = TRUE, NOT_FOUND = TRUE]
  end loop L1;
  not_found := false;
  end find_true;
 begin
   null;
 end main;
°
¹CN
  Ã
    exit L1 when flags(i);
     i := i + 1;
    if  i = 11 then return; end if;
°

=SML
set_pc"cn1";
val r9_3_vcs = map (snd o snd) (get_conjectures"-");

fun r9_3_tp conj = tac_proof(([], conj), cn_vc_simp_tac[] THEN prove_tac[]);

store_mt_results
mt_run
 [("r9.3.1", length o map (dest_thm o r9_3_tp o switch nth r9_3_vcs) , interval 0 5, length r9_3_vcs)];

=SML
clean_up();
new_script{name="r9.4", state=initial_cn_state};

¹CN
 procedure main
 is
  type table is array(1..10, 1..10) of boolean;
  procedure find_true(flags : table; i, j : in out integer; not_found : out boolean)
  „ I, J, NOT_FOUND [FLAGS(I, J) = TRUE ² NOT_FOUND = TRUE]
  is
  begin
   i := 1;
   not_found := true;
  L1:
  till ûFLAGS(I, J) = TRUEý
  loop
   „ I, J [NOT_FOUND = TRUE, NOT_FOUND = TRUE]
  end loop L1;
 not_found := false;
  end find_true;
 begin
   null;
 end main;
°
¹CN
  Ã
      j := 1;
     till ûFLAGS(I, J) = TRUE ² J = 11ý
      loop
     „ J [NOT_FOUND = TRUE, NOT_FOUND = TRUE]
     end loop;
     i := i + 1;
     if i = 11
    then
      return;
    end if;
°

¹CN
  Ã
       exit L1 when flags(i, j);
       j := j + 1;
      exit when j = 11;
°


=SML
set_pc"cn1";
val r9_4_vcs = map (snd o snd) (get_conjectures"-");

fun r9_4_tp conj = tac_proof(([], conj), cn_vc_simp_tac[] THEN prove_tac[]);

store_mt_results
mt_run
 [("r9.4.1", length o map (dest_thm o r9_4_tp o switch nth r9_4_vcs) , interval 0 9, length r9_4_vcs)];

=TEX
\subsection{R0055: Warnings for non-SPARK constructs} \label{RTen}
\subsection{R0056: Default parameter modes} \label{REleven}
\subsection{R0057: Script management facilities} \label{RTwelve}
\subsection{R0058: Forward declarations of subprograms} \label{RThirteen}
=SML
clean_up();
new_script{name="r13.1", state=initial_cn_state};
¹CN
 procedure main
 is
  x : integer := 0;
  procedure increment(a : in out integer)
  „ A [ A = A‰0 + 1];
 function add1(a : in integer) return integer
 ˜ [ADD1 A = A + 1];
 function add1(a : in integer) return integer
 ˜ [ADD1 A = A + 1] 
 is
  t : integer;
 begin
  t := a;
  „ T [T = A,  T = A + 1 ]  (add1)
  return t;
 end add1;
  procedure increment(a : in out integer)
  „ A [ A = A‰0 + 1]
  is
  begin
   a := a + 1;
  end increment;
 begin
   „ X [ X = 0,  X = 2 ] (main)
 end main;
°
¹CN
(add1) Ã
  increment(t);
°
¹CN
(main) Ã
  increment(x); x := add1(x);
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcMAIN_1");
a(prove_tac[]);
store_mt_results
mt_run
 [("r13.1.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_2");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
store_mt_results
mt_run
 [("r13.1.2", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_3");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.1.3", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_4");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.1.4", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMAIN_5");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(ALL_FC_T rewrite_tac[z_get_specñADD1®]);
store_mt_results
mt_run
 [("r13.1.5", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcADD1_1");
a(REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.1.6", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcADD1_2");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN strip_tac);
store_mt_results
mt_run
 [("r13.1.7", fun_true o pop_thm , (), true)];


=TEX
=SML
clean_up();
new_script{name="r13.2", state=initial_cn_state};
¹CN
  procedure mk_pos(a : in out integer)
  „ A [ A > 0]
 is
 begin
   if a <= 0 then a := a + 1; mk_pos(a); end if;
 end mk_pos;
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcMK_POS_1");
a(prove_tac[]);
store_mt_results
mt_run
 [("r13.2.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMK_POS_2");
a(prove_tac[]);
store_mt_results
mt_run
 [("r13.2.2", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcMK_POS_3");
a(cn_vc_simp_tac [] );
store_mt_results
mt_run
 [("r13.2.3", fun_true o pop_thm , (), true)];
=TEX


=SML
clean_up();
new_script{name="r13.3", state=initial_cn_state};
¹ZAX
Ü	fact : ú ­ ú
÷üüüüüü
Ü	fact 0 = 1 ;
Ü 	µm:î· fact(m+1) = (m + 1) * fact m
°
¹CN
procedure p
is
  type num is range 0 .. 1000000;
  function fact(a :  num) return num
  ˜ [µx: NUM· x <  A ´ FACT x = fact  x, FACT A = fact A]
 is
 begin
   if a = 0 then return 1; else return a * fact(a-1); end if;
 end fact;
begin
 null;
end p;
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[z_get_specñfact®]);
store_mt_results
mt_run
 [("r13.3.1", fun_true o pop_thm , (), true)];

set_goal([], get_conjecture"-""vcP_2");
a(cn_vc_simp_tac[z_get_specñNUM®] THEN REPEAT strip_tac);
a(lemma_tacñ¶B:î·A = B + 1®  THEN1
	(z_¶_tacñA- 1® THEN rewrite_tac[] THEN PC_T1"z_lin_arith" asm_prove_tac[]));
a(all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 4 ñB® THEN1 PC_T1"z_lin_arith" asm_prove_tac[]);
a(ALL_FC_T asm_rewrite_tac[z_get_specñfact®]);
a(asm_rewrite_tac[z_plus_assoc_thm]);
store_mt_results
mt_run
 [("r13.3.2", fun_true o pop_thm , (), true)];

set_goal([], ñµA: NUM· FACT A = fact A®);
a(ante_tac(z_get_specñFACT®));
a(rewrite_tac[z_get_specñNUM®] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN z_cov_induction_tac ñA®);
a(z_spec_nth_asm_tac 3 ñA® THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 6 ñx® THEN REPEAT strip_tac);
store_mt_results
mt_run
 [("r13.3.3", fun_true o pop_thm , (), true)];










=TEX
\subsection{R0059: Enhanced syntax-check-only mode} \label{RFourteen}
\subsection{R0060/R0064: Rationalised error reporting} \label{RFifteen}
\subsection{R0061: Change symbol for statement replacement} \label{RSixteen}
\subsection{R0062: Origin of VCs} \label{RSeventeen}
\subsection{R0063: Unexpanded specification statements} \label{REighteen}
\subsection{R0065: Duplicated names in context clauses} \label{RNineteen}
=SML
clean_up();
new_script{name = "r19.1", state = initial_cn_state};

¹CN
package p
is
  a, b : integer;
  y : integer renames a;
  z : integer renames b;
end p;
°

=SML
new_script{name = "r19.2.a", state =get_cn_state()};

¹CN
with p, p;
use p;
procedure r
is
begin
  „ A, Z[A = PoY ± PoB = PoZ, B = 42 ± PoY = PoA]
end r;
°

¹CN
  Ã  p.a := 42; p.z := p.y;
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(REPEAT_UNTIL is_± strip_tac);
a(strip_tac THEN accept_tac(refl_convñ42®));
store_mt_results
mt_run
 [("r19.2.1", fun_true o pop_thm , (), true)];



=TEX
\subsection{R0066: Auxiliary variables in function $\Xi $-lists} \label{RTwenty}
\subsection{R0067: Schema references in function $\Xi $-lists} \label{RTwentyOne}
\subsection{R0071: Multiple underscores in Z identifiers} \label{RTwentyTwo}
\subsection{R0068: Poly/ML problems and other bug-fixing} \label{RTwentyThree}
\subsubsection{pp2.5.4-bug1/R0042}
There are specific tests for the detailed changes to the treatment of aliases in {\ProductHOL}
in the relevant HOL module tests.
We give an explicit test here for the problem as reported by QinetiQ.
=SML
clean_up();
val b1_thm = (hd o rev o strip_±_rule o z_get_spec)ñ(abs‰R_)®;
=SML
store_mt_results
mt_run
 [("bugs.1.1", (PrettyPrinter.format_term true o concl), b1_thm, 
	["ñµ x : ¯ · abs‰R x = ¬Abs x®®"])];
=TEX
\subsubsection{pp2.5.4-bug2}
Explicitly tested here:
=SML
clean_up();
new_script{name = "pack.ads", state = initial_cn_state};
¹CN
package Pack is
  type Rec is record A, B : Integer; end record;
  procedure P (X : in out Integer);
  procedure Q (X : in out Rec);
end Pack;  
°
=SML
val state = get_cn_state();
new_script{name = "pack.adb", state = state};
¹CN
package body Pack is
  procedure P (X : in out Integer)
  „ X [ X = 22 ]
  is separate;
  procedure Q (X : in out Rec)
  is separate;
end Pack;  
°
=SML
val state = get_cn_state();
new_script{name = "pack-p.adb", state = state};
¹CN 
separate (Pack)
procedure P (X : in out Integer)
„ X [ X = 22 ]
is
begin
  X := 22;
end P;
°
=SML
val state = get_cn_state();
new_script{name = "pack-q.adb", state = state};
¹CN 
separate (Pack)
procedure Q (X : in out Rec)
„ X [ X.A = 22 ]
is
  V : Integer;
begin
  P(V);
  X.A := V;
end Q;
°
With the bug the last web clause made the tool raise an exception.
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcPACKoQ_2");
a(rewrite_tac[z_gen_pred_elim[ñU®](z_get_specñRECuA®)]);
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("bug.2.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcPACKoQ_2")];
=TEX
\subsubsection{pp2.5.4-bug4}
Tested in INT511.
\subsubsection{pp2.5.4-bug5}
Tested in INT511.
\subsubsection{pp2.5.4-bug6}
=SML
clean_up();
new_script{name = "test.adb", state = initial_cn_state};
¹CN
procedure Test is
  C1 : constant Float := Float(55);
  C2 : constant Float := Float(55.7);
begin
  null;
end Test;
°
=SML
set_pc"cn1";
set_goal([], ñC1 = real 55 ± C2 = 557 e (~1)®);
a(rewrite_tac(map z_get_spec[ñC1®,ñC2®, ñinteger_to_real®]));
store_mt_results
(mt_runf (op =$))
 [("bug.6.1", snd o dest_thm o pop_thm , (), ñC1 = real 55 ± C2 = 557 e (~1)®)];
=TEX
\subsubsection{pp2.5.4-bug7}
At release 2.5.7 and later this bug becomes irrelevant --- the syntactic restrictions
on return statements have been dropped.
=TEX
\subsubsection{R0046}
\subsubsection{R0075}
=TEX
\section{EPILOGUE}
=SML
diag_line(summarize_mt_results());
=TEX
\end{document}
