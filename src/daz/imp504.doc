% %Z% $Date: 2002/05/02 16:29:28 $ $Revision: 1.28 $ $RCSfile: imp504.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Web Clause Processor}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP504}  %% Mandatory field
\def\SCCSversion{$Revision: 1.28 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/05/02 16:29:28 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the implementation for the compliance notation web clause processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.10] Initial Drafts.
\item[Issue 1.11 (27th May 1994)] First draft for comment.
\item[Issue 1.14 (8th November 1994)] Made it handle errors in Reader/Writer set-up.
\item[Issue 1.17] Updated to reset the lexer state on error.
\item[Issue 1.18-1.19] Added support for generating hypertext links.
\item[Issue 1.20-22] Fixed bugs and improved error handling in hypertext processing.
\item[Issue 1.23-1.24] k-slots now allowed as annotations.
\item[Issue 1.25] Prototyping enhancement R5 --- Initial Variables in Conditionals.
\item[Issue 1.26] CTLE II R1/11 --- nested packages.
\item[Issue 1.27] Added syntax check only flag.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance notation web clause processor. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD504}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD504}.

%\subsection{Algorithms}
%\subsection{Dependencies}
%\subsection{Known Deficencies}
\subsection{Possible Enhancements}
None.
=TEX

\section{THE STRUCTURE $WebClauses$}

=SML
structure €WebClauses› : WebClauses = struct
local
	open CNTypes CNTypes1 CNLex CNParser CNZGenerator;
in
=TEX
=SML
val €has_no_label› = "__empty";
=TEX
=SML
val €corrupt_hypertext_info› = "__corrupt";
=TEX
=SML
fun €extract_labels_from_statement› (STNull) = ([]
) | extract_labels_from_statement (STImplicitNull) = ([]
) | extract_labels_from_statement (STAssign _) = ([]
) | extract_labels_from_statement (STSpecNoIvars {label,...}) = (
	[label]
) | extract_labels_from_statement (STSemicolon (s1,s2)) = (
	extract_labels_from_statement s1 @ extract_labels_from_statement s2
) | extract_labels_from_statement (STIfThenElse {p,q,...}) = (
	extract_labels_from_statement p @ extract_labels_from_statement p
) | extract_labels_from_statement (STCase {s,others,...}) = (
	flat (map (extract_labels_from_statement o (fn {p,...}=> p)) s) @
	extract_labels_from_statement others
) | extract_labels_from_statement (STLoop {stmt,...}) = (
	extract_labels_from_statement stmt
) | extract_labels_from_statement (STNamedLoop {stmt,...}) = (
	extract_labels_from_statement stmt
) | extract_labels_from_statement (STWhile {loop={stmt,...},...}) = (
	extract_labels_from_statement stmt
) | extract_labels_from_statement (STForStatic {loop={stmt,...},...}) = (
	extract_labels_from_statement stmt
) | extract_labels_from_statement (STForTmark {loop={stmt,...},...}) = (
	extract_labels_from_statement stmt
) | extract_labels_from_statement (STExitWhen _ ) = ([]
) | extract_labels_from_statement (STExit _) = ([]
) | extract_labels_from_statement (STRet _) = ([]
) | extract_labels_from_statement (STProcNoIvars _) = ([]
) | extract_labels_from_statement (STKSlot {label,...}) = (
	[label]
) | extract_labels_from_statement (STPragma _) = ([]
) | extract_labels_from_statement (STAnnotation _) = ([]
) | extract_labels_from_statement (SSpecIvars {label,...}) = (
	[label]
) | extract_labels_from_statement (SForNonStatic {loop={stmt,...},...}) = (
	extract_labels_from_statement stmt
) | extract_labels_from_statement (SLogCon {label,...}) = (
	[label]
) | extract_labels_from_statement (SProcIvars _) = (
	[]
);
=TEX

=SML
fun €mark_place_for_procedure_specification›
	({spec=Value _,...} : PROCEDURE_SPECIFICATION) : LABEL list = (
		[has_no_label]
) | mark_place_for_procedure_specification _ = (
		[]
);
=TEX
=SML
fun €mark_place_for_function_specification›
	({spec=Value _,...} : FUNCTION_SPECIFICATION) : LABEL list = (
		[has_no_label]
) | mark_place_for_function_specification _ = (
		[]
);
=TEX
=SML
fun €extract_labels_from_subprog_spec› (SSProcedure proc_spec) = (
	mark_place_for_procedure_specification proc_spec
) | extract_labels_from_subprog_spec (SSFunction fun_spec) = (
	mark_place_for_function_specification fun_spec
);
=TEX
=SML
fun €extract_labels_from_renaming_decl› (RDSubprogram
		{subprogram_specification,...}) = (
	extract_labels_from_subprog_spec subprogram_specification
) | extract_labels_from_renaming_decl _  = [];
=TEX
=SML
fun €extract_labels_from_declaration› (DDeclarationKSlot ({label,...}, _)) = (
	[label]
) | extract_labels_from_declaration (DRenamingDeclaration rd) = (
	extract_labels_from_renaming_decl rd
) | extract_labels_from_declaration (DBasicDecl _) = ([]
) | extract_labels_from_declaration (DRepresentationClause _) = ([]
) | extract_labels_from_declaration (DUseClause _) = ([]
) | extract_labels_from_declaration (DProperBody pb) = (
	extract_labels_from_proper_body pb
) | extract_labels_from_declaration (DProcedureDeclaration pd) = (
	mark_place_for_procedure_specification pd
) | extract_labels_from_declaration (DFunctionDeclaration fd) = (
	mark_place_for_function_specification fd
) | extract_labels_from_declaration (DPackageDeclaration
	{visible_decs,private_decs,...}) = (
	flat (map extract_labels_from_declaration visible_decs) @
	flat (map extract_labels_from_declaration private_decs)
) | extract_labels_from_declaration (DProcedureStub ps) = (
	mark_place_for_procedure_specification ps
) | extract_labels_from_declaration (DFunctionStub fs) = (
	mark_place_for_function_specification fs
) | extract_labels_from_declaration (DPackageStub _) = ([]
) | extract_labels_from_declaration (DExternalProcedureStub eps) = (
	mark_place_for_procedure_specification eps
) | extract_labels_from_declaration (DExternalFunctionStub efs) = (
	mark_place_for_function_specification efs
) | extract_labels_from_declaration (DAuxiliary _) = ([]
) | extract_labels_from_declaration (DUsing {basic_decls,...}) = ([]
)
=TEX
=SML
and €extract_labels_from_proper_body› (PBProcedure
		{procedure_spec,declarative_part,statement}) = (
	mark_place_for_procedure_specification procedure_spec @
	flat (map extract_labels_from_declaration declarative_part) @
	extract_labels_from_statement statement
) | extract_labels_from_proper_body (PBFunction
		{function_spec,declarative_part,statement}) = (
	mark_place_for_function_specification function_spec @
	flat (map extract_labels_from_declaration declarative_part) @
	extract_labels_from_statement statement
) | extract_labels_from_proper_body (PBPackage {decls,statement,...}) = (
	flat (map extract_labels_from_declaration decls) @
	extract_labels_from_statement statement
);
=TEX
=SML
fun €extract_labels_from_comp_unit› (CUPackageDeclaration {visible_decs,private_decs,...}) = (
	flat (map extract_labels_from_declaration visible_decs) @
	flat (map extract_labels_from_declaration private_decs)
) | extract_labels_from_comp_unit (CUProperBody pb) = (
	extract_labels_from_proper_body pb
) | extract_labels_from_comp_unit (CUSubUnit {proper_body,...}) = (
	extract_labels_from_proper_body proper_body
);
=TEX
=SML
fun €extract_labels_from_kslot_comp_unit› (KCUKSlot {label,...}) = (
	[label]
) | extract_labels_from_kslot_comp_unit (KCUUnit {comp_unit,...}) = (
	extract_labels_from_comp_unit comp_unit
) | extract_labels_from_kslot_comp_unit (KCUPragma _) = ([]
);
=TEX
=SML
fun €extract_labels_from_annotation› (ANKSlot {label,...}::more) = (
	label :: extract_labels_from_annotation more
) | extract_labels_from_annotation (_ :: more) = (
	extract_labels_from_annotation more
) | extract_labels_from_annotation [] = (
	[]
);
=TEX
=SML
fun €extract_labels_from_web_clause› (WCCompilation comp_units) = (
	(Nil, flat (map extract_labels_from_kslot_comp_unit comp_units))
) | extract_labels_from_web_clause (WCReplacedByCompilation {label,comp}) = (
	(Value label, flat (map extract_labels_from_kslot_comp_unit comp))
) | extract_labels_from_web_clause (WCReplacedByPrivatePart {label,private}) = (
	(Value label, flat (map extract_labels_from_declaration private))
) | extract_labels_from_web_clause (WCReplacedByVisiblePart {label,visible}) = (
	(Value label, flat (map extract_labels_from_declaration visible))
) | extract_labels_from_web_clause (WCReplacedByDecl {label,decls}) = (
	(Value label, flat (map extract_labels_from_declaration decls))
) | extract_labels_from_web_clause (WCReplacedByArbitraryAda {label,...}) = (
	(Value label,[])
) | extract_labels_from_web_clause (WCRefinedBy {label,statement}) = (
	(Value label, extract_labels_from_statement statement)
) | extract_labels_from_web_clause (WCReplacedBy {label,statement}) = (
	(Value label, extract_labels_from_statement statement)
) | extract_labels_from_web_clause (WCReplacedByAnnotation {label,replacement}) = (
	(Value label, extract_labels_from_annotation replacement)
);
=TEX
=SML
val €hypertext_info› : (int * LABEL) list list ref = ref [];
=TEX
=SML
fun €reset_hypertext_info› () = (
	hypertext_info := []
);
=TEX
=SML
fun €get_hypertext_info› () = (
	!hypertext_info
);
=TEX
=SML
fun €set_hypertext_info› (h : (int * LABEL) list list) : unit = (
	hypertext_info := h
);
=TEX
=SML
val €goto_next_web_clause› = (
	["/\\\\begin{GFT}{Compliance Notation}\n"]
);
val €goto_previous_web_clause› = (
	["?\\\\begin{GFT}{Compliance Notation}\n"]
);
=TEX
=SML
fun €skip_fwd› (n : int) = (
	[".+"^string_of_int n^"\n"]
);
=TEX
=SML
fun €generate_ed_line› (offset : int, label : string) = (
	if offset < 0 (* § is a plug *)
	then
		[
		"s/^\\\\+/\\\\+\\\\FTHyperRefPlug{"^label^"} /\n"
		]
	else
		skip_fwd offset@
		[
		"s/\\\\\\\\$/ \\\\FTHyperRefSocket{"^label^"}\\\\\\\\/\n"
		]
);
=TEX
=SML
fun €update_hypertext_info› (lhsopt, labels : LABEL list)
				 (offsets : int list) : unit = (
let	val newinfo = combine offsets labels
				handle ex => (
					[(0,corrupt_hypertext_info)]
				);
	fun aux (carry : int) ((i,lab)::rest) = (
		if lab = has_no_label
		then
			aux (i+carry) rest
		else
			(i+carry,lab)::aux 0 rest
	) | aux _ _ = [];
	val newinfo1 = aux 0 newinfo;
	val newinfo2 = case lhsopt of
				Value label	=> (~1,label)::newinfo1
				|Nil		=> newinfo1;
in
	set_hypertext_info(get_hypertext_info()@[newinfo2])
end
);
=TEX
=SML
fun €output_hypertext_edit_script› {
	out_file : string
	} : unit = (
let	val info = get_hypertext_info();
	val side =
		if any (flat info) (fn (_, lab) => lab = corrupt_hypertext_info)
		then	fail "output_hypertext_edit_script" 504110 []
		else	();
	val out_stream = open_out out_file;
	val output_string = curry output out_stream;
	val ed_directives = flat (map
					(fn hi => (
						goto_next_web_clause @
						skip_fwd 1 @
						flat (map generate_ed_line hi)
						)
				        ) info
				     );
	
in
	map output_string ed_directives;
	close_out out_stream
end);
=TEX

\subsection{Interface}
The following function looks at the initial label in a web clause (if there is one). The label determines the kind of web clause entered. This classification function is called from within the lexical analyser, and it is necessary for it to be called prior to the parser since the parser recognises a language in which the distinction between the kinds of web clause is made in the parser's input.

=SML
fun €classify_initial_label› (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list = (
	case itemlist of
	(LCOrd, _)::(lex_class, CNText labn)::(LCCrd, _)::rest => (
		if	lex_class = LCNumericLiteral
		orelse	lex_class = LCIdentifier
		then	((case classify_label labn of
					Value RSCompilation => LCCompLabel
				|	Value RSPrivatePart => LCPPartLabel
				|	Value RSVisiblePart => LCVPartLabel
				|	Value RSDeclaration => LCDecLabel
				|	Value RSStatement => LCStmtLabel
				|	Value RSSpecStatement => LCSpecLabel
				|	Value RSAnnotation => LCAnnotationLabel
				|	Nil => LCCompLabel
			), CNText labn)::rest
		else	itemlist
	)|_ => itemlist
);
=TEX
=SML
val €cn_syntax_check_only› : bool ref = ref false;
val _ = new_flag{
	name="cn_syntax_check_only",
	check=fun_true,
	control=cn_syntax_check_only,
	default=fun_false} handle Fail _ => ();
=TEX
=SML
fun €cn_recogniser› (start:string, lang:string, value:Lex.INPUT list, finish:string) = (
	if	ReaderWriterSupport.PrettyNames.is_same_symbol(start, "π")
	andalso	ReaderWriterSupport.PrettyNames.is_same_symbol(finish, "∞")
	andalso	(lang = "CN")
	then
		let	val save_cn_parser_state = get_cn_parser_state();
		in
		   let	val (lexed, offsets) = CNLex.cn_lex classify_initial_label value;
			val parsed = CNParser.cn_parser lexed;
		   in	if	!cn_syntax_check_only
			then	()
			else	let	val hi = extract_labels_from_web_clause parsed;
				in	update_hypertext_info hi offsets;
					CNZGenerator.cn_z_generator parsed
				end
		   end
			handle ex => (
				set_cn_parser_state save_cn_parser_state;
				raise ex
			)
		end
	else
		fail "cn_recogniser" 504010
			[fn () => start, fn () => lang, fn () => finish]
);
=TEX
=SML
val _ = ReaderWriterSupport.add_named_reader(
			"π",
			"CN",
			"Lex.Term",
			CNReaderWriter.cn_reader "cn_recogniser"
	) handle Fail _ => ();
val _ = ReaderWriterSupport.PrettyNames.add_new_symbols [
	([	"refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple),
	([	"replacedby"], Value "È", ReaderWriterSupport.PrettyNames.Simple)
]
	handle Fail _ => ();
=TEX

\subsection{Epilogue}
=SML
end (* local ... in *);
end (* of structure WebClauses *);
open WebClauses;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
=IGN


get_hypertext_info();
 πCN
procedure P is
    A : INTEGER;
    subtype S is INTEGER range 3 .. 10;
    procedure Q
        Ñ A [ A = S_APOST_FIRST ]
    is
        S_APOST_FIRST : INTEGER;
    begin
        S_APOST_FIRST := A;
    end Q;
begin
    Ñ A[A = 5]
end P;
 ∞


 πCN
procedure P is
	ß kslot ¢			(1)
	procedure proc_with_spec Ñ [true] is separate;
begin
    null;
end P;
 ∞
output_hypertext_edit_script{out_file="x"};
