% %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Web Clause Processor}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP504}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{CN}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the implementation for the compliance notation web clause processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.10] Initial Drafts.
\item[Issue 1.11 (27th May 1994)] First draft for comment.
\item[Issue 1.14 (8th November 1994)] Made it handle errors in Reader/Writer set-up.
\item[Issue 1.17] Updated to reset the lexer state on error.
\item[Issue 1.18-1.19] Added support for generating hypertext links.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance notation web clause processor. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD504}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD504}.

%\subsection{Algorithms}
%\subsection{Dependencies}
%\subsection{Known Deficencies}
\subsection{Possible Enhancements}
None.
=TEX

\section{THE STRUCTURE $WebClauses$}

=SML
structure €WebClauses› : WebClauses  = struct
	open CNTypes CNTypes1 CNLex CNParser CNZGenerator;
=TEX

=SML
fun €extract_labels_from_declaration› (DDeclarationKSlot ({label,...}, _)) = (
	[label]
) | extract_labels_from_declaration (DRenamingDeclaration _) = []
  | extract_labels_from_declaration (DBasicDecl _) = []
  | extract_labels_from_declaration (DRepresentationClause _) = []
  | extract_labels_from_declaration (DProperBody _) = []
  | extract_labels_from_declaration (DProcedureDeclaration _) = []
  | extract_labels_from_declaration (DFunctionDeclaration _) = []
  | extract_labels_from_declaration (DPackageDeclaration _) = []
  | extract_labels_from_declaration (DProcedureStub _) = []
  | extract_labels_from_declaration (DFunctionStub _) = []
  | extract_labels_from_declaration (DPackageStub _) = []
  | extract_labels_from_declaration (DExternalProcedureStub _) = []
  | extract_labels_from_declaration (DExternalFunctionStub _) = []
  | extract_labels_from_declaration (DAuxiliary _) = []
  | extract_labels_from_declaration (DUsing {basic_decls,...}) = ([]
);
=TEX
=SML
fun €extract_labels_from_stmt› (STNull) = ([]
) | extract_labels_from_stmt (STImplicitNull) = ([]
) | extract_labels_from_stmt (STAssign _) = ([]
) | extract_labels_from_stmt (STSpecNoIvars {label,...}) = (
	[label]
) | extract_labels_from_stmt (STSemicolon (s1,s2)) = (
	extract_labels_from_stmt s1 @ extract_labels_from_stmt s2
) | extract_labels_from_stmt (STIfThenElse {p,q,...}) = (
	extract_labels_from_stmt p @ extract_labels_from_stmt p
) | extract_labels_from_stmt (STCase {s,others,...}) = (
	flat (map (extract_labels_from_stmt o (fn {p,...}=> p)) s) @
	extract_labels_from_stmt others
) | extract_labels_from_stmt (STLoop {stmt,...}) = (
	extract_labels_from_stmt stmt
) | extract_labels_from_stmt (STNamedLoop {stmt,...}) = (
	extract_labels_from_stmt stmt
) | extract_labels_from_stmt (STWhile {loop={stmt,...},...}) = (
	extract_labels_from_stmt stmt
) | extract_labels_from_stmt (STForStatic {loop={stmt,...},...}) = (
	extract_labels_from_stmt stmt
) | extract_labels_from_stmt (STForTmark {loop={stmt,...},...}) = (
	extract_labels_from_stmt stmt
) | extract_labels_from_stmt (STExitWhen _ ) = ([]
) | extract_labels_from_stmt (STExit) = ([]
) | extract_labels_from_stmt (STRet _) = ([]
) | extract_labels_from_stmt (STProcNoIvars _) = ([]
) | extract_labels_from_stmt (STKSlot {label,...}) = (
	[label]
) | extract_labels_from_stmt (STPragma _) = ([]
) | extract_labels_from_stmt (STAnnotation _) = ([]
);
=TEX
=SML
fun €extract_labels_from_statement› (SStmt stmt) = (
	extract_labels_from_stmt stmt
) | extract_labels_from_statement (SSpecIvars ({label,...},stmt)) = (
	label::extract_labels_from_stmt stmt
) | extract_labels_from_statement (SForNonStatic ({loop={stmt,...},...},stmt1)) = (
	extract_labels_from_stmt stmt1@extract_labels_from_stmt stmt1
) | extract_labels_from_statement (SLogCon ({label,...},stmt)) = (
	label::extract_labels_from_stmt stmt
) | extract_labels_from_statement (SProcIvars (_,stmt)) = (
	extract_labels_from_stmt stmt
);
=TEX
=SML
fun €extract_labels_from_proper_body› (PBProcedure {declarative_part,statement,...}) = (
	flat (map extract_labels_from_declaration declarative_part) @
	extract_labels_from_statement statement
) | extract_labels_from_proper_body (PBFunction {declarative_part,statement,...}) = (
	flat (map extract_labels_from_declaration declarative_part) @
	extract_labels_from_statement statement
) | extract_labels_from_proper_body (PBPackage {decls,statement,...}) = (
	flat (map extract_labels_from_declaration decls) @
	extract_labels_from_statement statement
);
=TEX
=SML
fun €extract_labels_from_comp_unit› (CUPackageDeclaration {visible_decs,private_decs,...}) = (
	flat (map extract_labels_from_declaration visible_decs) @
	flat (map extract_labels_from_declaration private_decs)
) | extract_labels_from_comp_unit (CUProperBody pb) = (
	extract_labels_from_proper_body pb
) | extract_labels_from_comp_unit (CUSubUnit {proper_body,...}) = (
	extract_labels_from_proper_body proper_body
);
=TEX
=SML
fun €extract_labels_from_kslot_comp_unit› (KCUKSlot {label,...}) = (
	[label]
) | extract_labels_from_kslot_comp_unit (KCUUnit {comp_unit,...}) = (
	extract_labels_from_comp_unit comp_unit
) | extract_labels_from_kslot_comp_unit (KCUPragma _) = ([]
);
=TEX
=SML
fun €extract_labels_from_web_clause› (WCCompilation comp_units) = (
	(Nil, flat (map extract_labels_from_kslot_comp_unit comp_units))
) | extract_labels_from_web_clause (WCReplacedByCompilation comp_units) = (Nil,[]
) | extract_labels_from_web_clause (WCReplacedByPrivatePart {label,private}) = (
	(Value label, flat (map extract_labels_from_declaration private))
) | extract_labels_from_web_clause (WCReplacedByVisiblePart {label,visible}) = (
	(Value label, flat (map extract_labels_from_declaration visible))
) | extract_labels_from_web_clause (WCReplacedByDecl {label,decls}) = (
	(Value label, flat (map extract_labels_from_declaration decls))
) | extract_labels_from_web_clause (WCReplacedByArbitraryAda {label,...}) = (
	(Value label,[])
) | extract_labels_from_web_clause (WCRefinedBy {label,statement}) = (
	(Value label, extract_labels_from_statement statement)
) | extract_labels_from_web_clause (WCReplacedBy {label,statement}) = (
	(Value label, extract_labels_from_statement statement)
);
=TEX
=SML
val €hypertext_info› : (int * LABEL) list list ref = ref [];
=TEX
=SML
fun €reset_hypertext_info› () = (
	hypertext_info := []
);
=TEX
=SML
fun €get_hypertext_info› () = (
	!hypertext_info
);
=TEX
=SML
fun €set_hypertext_info› (h : (int * LABEL) list list) : unit = (
	hypertext_info := h
);
=TEX
=SML
val €goto_next_web_clause› = (
	["/\\\\begin{GFT}{Compliance Notation}\n"]
);
val €goto_previous_web_clause› = (
	["?\\\\begin{GFT}{Compliance Notation}\n"]
);
=TEX
=SML
fun €skip_fwd› (n : int) = (
	[".+"^string_of_int n^"\n"]
);
=TEX
=SML
fun €generate_ed_line› (offset : int, label : string) = (
	if offset < 0 (* § is a plug *)
	then
		[
		"s/^\\\\+/\\\\+\\\\FTHyperRefPlug{"^label^"} /\n"
		]
	else
		skip_fwd offset@
		[
		"s/\\\\\\\\$/ \\\\FTHyperRefSocket{"^label^"}\\\\\\\\/\n"
		]
);
=TEX
=SML
fun €update_hypertext_info› (lhsopt, labels : LABEL list)
				 (offsets : int list) : unit = (
let	val newinfo = combine offsets labels
				handle ex => (
					[];
					reraise ex "update_hypertext_info"
				);
	val newinfo1 = case lhsopt of
				Value label	=> (~1,label)::newinfo
				|Nil		=> newinfo;
in
	case newinfo1 of
	_::_ =>		set_hypertext_info(get_hypertext_info()@[newinfo1])
	|_ =>		()
end
);
=TEX
=SML
fun €output_hypertext_edit_script› {
	out_file : string
	} : unit = (
let	val out_stream = open_out out_file;
	val output_string = curry output out_stream;
	val ed_directives = flat (map
					(fn hi => (
						goto_next_web_clause @
						skip_fwd 1 @
						flat (map generate_ed_line hi)
					)
				    ) (get_hypertext_info ()))
	
in
	map output_string ed_directives;
	close_out out_stream
end);
=TEX

\subsection{Interface}
The following function looks at the initial label in a web clause (if there is one). The label determines the kind of web clause entered. This classification function is called from within the lexical analyser, and it is necessary for it to be called prior to the parser since the parser recognises a language in which the distinction between the kinds of web clause is made in the parser's input.

=SML
fun €classify_initial_label› (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list = (
	case itemlist of
	(LCOrd, _)::(LCNumericLiteral, CNText labn)::(LCCrd, _)::rest => (
			((case classify_label labn of
					Value RSCompilation => LCCompLabel
				|	Value RSPrivatePart => LCPPartLabel
				|	Value RSVisiblePart => LCVPartLabel
				|	Value RSDeclaration => LCDecLabel
				|	Value RSStatement => LCStmtLabel
				|	Value RSSpecStatement => LCSpecLabel
				|	_ => LCCompLabel
			), CNText labn)::rest
	)|_ => itemlist
);
=TEX

=SML
fun €cn_recogniser› (start:string, lang:string, value:Lex.INPUT list, finish:string) = (
	if	ReaderWriterSupport.PrettyNames.is_same_symbol(start, "π")
	andalso	ReaderWriterSupport.PrettyNames.is_same_symbol(finish, "∞")
	andalso	(lang = "CN")
	then
		let	val save_cn_parser_state = get_cn_parser_state();
		in
		   let	val (lexed,offsets) = CNLex.cn_lex classify_initial_label value;
			val parsed = CNParser.cn_parser lexed;
			val hi = extract_labels_from_web_clause parsed;
			val side = update_hypertext_info hi offsets;
			val web_clause = CNZGenerator.cn_z_generator parsed;
		   in
			web_clause
		   end
			handle ex => (
				set_cn_parser_state save_cn_parser_state;
				raise ex
			)
		end
	else
		fail "cn_recogniser" 504010
			[fn () => start, fn () => lang, fn () => finish]
);
=TEX
=SML
val _ = ReaderWriterSupport.add_named_reader(
			"π",
			"CN",
			"Lex.Term",
			CNReaderWriter.cn_reader "cn_recogniser"
	) handle Fail _ => ();
val _ = ReaderWriterSupport.PrettyNames.add_new_symbols [
	([	"refinedby"], Value "√", ReaderWriterSupport.PrettyNames.Simple),
	([	"replacedby"], Value "È", ReaderWriterSupport.PrettyNames.Simple)
]
	handle Fail _ => ();
=TEX

\subsection{Epilogue}
=SML
end (* of structure WebClauses *);
open WebClauses;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
