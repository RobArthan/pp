=IGN
********************************************************************************
imp517.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% ‚Ñ§
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Implementation: Script Proof Support}

\def\AbstractText{This is the implementation of methods of making the paragraphs generated by the compliance notation available to the user in a normalised form.}

\def\Reference{ISS/HAT/DAZ/IMP517}

\def\Author{K. Blackburn}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{DAZ PROJECT}  %% Mandatory field
%% LaTeX2e port: %\TPPvolume{}
%% LaTeX2e port: %\TPPpart{}
%% LaTeX2e port: \TPPtitle{Implementation: Script Proof Support}  %% Mandatory field
%% LaTeX2e port: \TPPref{ISS/HAT/DAZ/IMP517}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{$Revision: 1.17 $%
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{\FormatDate{$Date: 2005/12/16 13:46:01 $%
%% LaTeX2e port: }}
%% LaTeX2e port: \TPPstatus{Draft}			%% Mandatory field
%% LaTeX2e port: \TPPtype{Implementation}
%% LaTeX2e port: \TPPkeywords{HOL}
%% LaTeX2e port: \TPPauthor{K.~Blackburn&WIN01}
%% LaTeX2e port: \TPPauthorisation{R.D.~Arthan & DAZ Team Leader}
%% LaTeX2e port: \TPPabstract{
%% LaTeX2e port: This is the implementation of methods of making the paragraphs generated by the compliance notation available to the user in a
%% LaTeX2e port: normalised form.}
%% LaTeX2e port: %\TPPabstractB{}
%% LaTeX2e port: %\TPPabstractC{}
%% LaTeX2e port: %\TPPabstractD{}
%% LaTeX2e port: %\TPPabstractE{}
%% LaTeX2e port: %\TPPabstractF{}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port: 	Library}}
%% LaTeX2e port: 
%% LaTeX2e port: %\TPPclass{CLASSIFICATION}
%% LaTeX2e port: %\def\TPPheadlhs{}
%% LaTeX2e port: %\def\TPPheadcentre{}
%% LaTeX2e port: %def\TPPheadrhs{}
%% LaTeX2e port: %\def\TPPfootlhs{}
%% LaTeX2e port: %\def\TPPfootcentre{}
%% LaTeX2e port: %\def\TPPfootrhs{}
%% LaTeX2e port: 
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \TPPsetsizes
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: 
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: 
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: 
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1 (1996/01/24) - 1.2 (1996/01/30)] Initial Versions.
\item[Issues 1.3 (1996/02/29) - 1.4 (1996/03/08)] Specifically working towards fulfilling item 6 of \cite{ISS/HAT/DAZ/MIN09} v1.2.
\item[Issue 1.5 (1996/03/11)]
To match issue 1.5 of dtd517.
\item[Issue 1.6 (1996/03/12) - 1.10 (1996/03/20)]
Fixing treatment of Q's.
\item [Issue 1.11 (1996/03/26)]
Removed a local theorem in favour of a global one, prevented
some current proof context effects.
\item[Issue 1.12 (1999/05/05)]
Fixed problem with spaces in object language names.
\item[Issue 1.13 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.14 (2002/10/17)] DAZ-specific updates to banner for open source release
\item[Issue 1.15 (2002/10/17)] DAZ-specific updates to banner for open source release
\item[Issue 1.16 (2004/01/19)] The Z universal set is now called ùïå
\item[Issue 1.17 (2005/12/16)] Private names are now prefixed with $pp'$.
\item[Issue 1.18 (2009/03/24)] Eliminated non-exhaustive matches.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

\item[2015/04/17]
Ported daz source documents onto the Lemma 1 document template
%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the Theory Proof Support tools.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD517}.

\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}

\subsection{Dependencies}

\subsection{Known Deficencies}

\subsection{Possible Enhancements}
\section{PROLOGUE}
=SML
open_theory "cn";
force_delete_theory "imp517" handle (Fail _) => ();
if get_current_theory_status() <> TSNormal
then new_theory "imp517"
else ();
val imp517_thy = get_current_theory_name ();
push_pc "cn1";
=TEX
=SML
structure ‚¶èCNTheoryProofSupport‚¶é : CNTheoryProofSupport = struct
=TEX
\subsection{Common Tools}
Protect uses of the systems $use\_string$ against mishaps with Q's.
=SML
fun use_string1 (s : string) = use_string (translate_for_output s);
=TEX
=SML
fun ‚¶èoverride_save_thm‚¶é (nm : string, thm : THM) : THM = (
	save_thm (nm, thm)
	handle (Fail _) => (
		let
			val old_thm = get_thm "-" nm;
			val thy_nm = get_current_theory_name();
		in
			(warn "override_save_thm" 517001 [(fn _ => nm), (fn _ => thy_nm)];
			delete_thm nm;
			save_thm (nm, thm)
			)
		end
		handle (Fail _) => fail "override_save_thm" 517002 [(fn _ => nm),
				 	get_current_theory_name]
	)
);
=TEX
Make ``-'' into the correct theory name, and otherwise just return the argument.
=SML
fun ‚¶èmake_actual_theory_name‚¶é (nm : string) = (
	case nm of
	"-" => get_current_theory_name()
	| _ => nm
);
=TEX
Make an arbitrary name into a valid alphanumeric ML variable name:
=SML
local
	fun aux_sane (c : string) : string = (
	case c of
	"!" => "_splat_"
	| "&" => "_and_"
	| "$" => "_dollar_"
	| "#" => "_hash_"
	| "+" => "_plus_"
	| "-" => "_dash_"
	| "/" => "_slash_"
	| ":" => "_colon_"
	| "<" => "_less_"
	| ">" => "_gtr_"
	| "=" => "_eq_"
	| "?" => "_qu_"
	| "@" => "_at_"
	| "\\" => "_bs_"
	| "~" => "_tw_"
	| "`" => "_bq_"
	| "^" => "_ca_"
	| "|" => "_bar_"
	| "*" => "_star_"
	| "\"" => "_dq_"
	| " " => "_sp_"
	| _ => (if ord(c) = 37
		then "_pc_"
		else c)
	);
in
fun ‚¶èmake_valid_var_name‚¶é (nm: string) : string = (
	case nm of
	"" => "empty"
	| _ => implode (map aux_sane (explode nm))
);
end;
=TEX
=SML
fun ‚¶èmatch1‚¶é (tm1 : TERM) (tm2 : TERM) : TERM = (
	case term_match tm1 tm2 of
		(_, [(x, _)]) => x
	|	_ => fail "match1" 517010 []
);
=TEX
=SML
fun ‚¶èmatch2‚¶é (tm1 : TERM) (tm2 : TERM) : TERM * TERM = (
	case term_match tm1 tm2 of
		(_, [(x, _), (y, _)]) => (x, y)
	|	_ => fail "match1" 517010 []
);
=TEX
=SML
fun ‚¶èmatch3‚¶é (tm1 : TERM) (tm2 : TERM) : TERM * TERM * TERM = (
	case term_match tm1 tm2 of
		(_, [(x, _), (y, _), (z, _)]) => (x, y, z)
	|	_ => fail "match1" 517010 []
);
=TEX
\subsection{Auxiliary Functions}
=SML
fun ‚¶èaux_list_cn_spec_rule‚¶é (f : THM -> (string * THM)list ) (fname : string) =(fn
	(thms : THM list) => (
let 	val thms1 = (flat (mapfilter f thms));
(*	val dummy0 = map ((fn cnm => use_string1 ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle (Fail _) => fail fname 517003 [fn _ => cnm])
		o fst)
		thms1; *)
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string1
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
in
	union (op ~=|-) (map snd thms1) []
end)
);
=TEX
=SML
fun ‚¶èaux_cn_script_support_thms‚¶é (f : THM -> (string * THM)list) (fname : string) =(fn  (in_nm : string) => (
let	val thms = map snd (get_defns in_nm @ get_axioms in_nm)
		handle exn => reraise exn fname;
	val thms1 = flat (mapfilter f thms);
(*	val dummy0 = map ((fn cnm => use_string1 ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle (Fail _) => fail fname 517003 [fn _ => cnm])
		o fst)
		thms1; *)
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string1
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
in
	union (op ~=|-) (map snd thms1) []
end));
=TEX
=SML
fun ‚¶èaux_list_cn_script_support_thms‚¶é  (f : THM -> (string * THM) list) (fname : string) =(fn (in_nms : string list) => (
let	val thmsl = map (fn nm =>
		map snd (get_defns nm @ get_axioms nm)
		handle exn => reraise exn fname) in_nms;
	val thms1l = map (fn thms => flat(mapfilter f thms)) thmsl;
(*	val dummy0 = map ((fn cnm => use_string1 ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle (Fail _) => fail fname 517003 [fn _ => cnm])
		o fst)
		(flat thms1l); *)
	val dummy1 = map (fn thms1 => map override_save_thm thms1) thms1l;
	val dummy2 = map (fn thms1 => map
		(fn (nm1,_) => use_string1
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1) thms1l;
in
	union (op ~=|-) (map snd (flat thms1l)) []
end));
=TEX
\subsection{Alternative Tools}
First some theorems:
=SML
val local_id_thm = tac_proof(
	([],  ‚åú‚àÄ X f ‚¶Å
		‚ì©(f = id X ‚áí (‚àÄ i : X ‚¶Å f i = i))‚åù‚åù),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  asm_rewrite_tac[z_id_thm] THEN
	  z_app_eq_tac THEN
	  REPEAT strip_tac THEN
	  all_var_elim_asm_tac THEN
	  strip_tac));
=TEX
=SML
val local_id_sig_thm = tac_proof(
	([],  ‚åú‚àÄ X f ‚¶Å
		‚ì©(f = id X ‚áí (f ‚àà X ‚Üí X))‚åù‚åù),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  all_var_elim_asm_tac1 THEN
	  PC_T "z_fun_ext" (REPEAT z_strip_tac) THEN_LIST
	  [ all_var_elim_asm_tac,
	    all_var_elim_asm_tac THEN strip_tac,
	    z_‚àÉ_tac ‚ì©x1‚åù THEN PC_T "z_rel_ext" (REPEAT z_strip_tac)
	  ])
	);
=TEX
=SML
val local_dot_dot_diff_thm = tac_proof(
	([],  ‚ì©‚àÄi, j : ‚Ñ§‚¶Å (i .. j) \ {j} = i .. (j + ~ 1)‚åù),
	MERGE_PCS_T1 ["'z_numbers1", "z_sets_ext"] REPEAT strip_tac
	THEN PC_T1 "z_lin_arith1" asm_prove_tac []);
=TEX
=SML
val local_id_rel_inv_thm = tac_proof(
	([],  ‚åú‚àÄ X ‚¶Å ‚ì© (id X) ‚Üó~‚Üï = id X‚åù‚åù),
	  PC_T "z_library1_ext"
	  (prove_tac[]));
=TEX
=SML
val local_‚óÅ_succ_thm = tac_proof(
	([],  ‚åú‚àÄ f j k ‚¶Å ‚ì© 0 ‚â§ j ‚áí
			(f = (j .. k) ‚óÅ succ) ‚áí
			(‚àÄ i : j .. k ‚¶Å f i = i + 1)‚åù‚åù),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 3 rewrite_thm_tac THEN
	  z_app_eq_tac THEN
	  rewrite_tac[z_‚óÅ_thm, z_‚àà_succ_thm] THEN
	  REPEAT strip_tac THEN
	  PC_T1 "z_lin_arith1" asm_prove_tac[]
	  ));
=TEX
=SML
val local_‚óÅ_succ_sig_thm = tac_proof(
	([],  ‚åú‚àÄ f j k ‚¶Å ‚ì© 0 ‚â§ j ‚áí
			(f = (j .. k) ‚óÅ succ) ‚áí
			(f ‚àà (j .. k) ‚Üí (j + 1 .. k + 1))‚åù‚åù),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  all_var_elim_asm_tac1 THEN
	  PC_T "z_fun_ext" (REPEAT strip_tac) THEN_LIST
	  [(DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[z_‚àà_succ_thm]) THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[])
		),
	   (DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[z_‚àà_succ_thm]) THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[z_‚àà_succ_thm])),
	   (z_‚àÉ_tac ‚ì©x1 + 1‚åù THEN PC_T "z_rel_ext" (REPEAT z_strip_tac) THEN
		rewrite_tac[z_‚àà_succ_thm] THEN
		DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[]) THEN
		all_asm_fc_tac[z_‚â§_trans_thm])	
	  ]
	  ));
=TEX
=SML
val local_‚óÅ_succ_rel_inv_thm = tac_proof(
	([],  ‚åú‚àÄ f j k ‚¶Å ‚ì© 0 ‚â§ j ‚áí
			(f = ((j .. k) ‚óÅ succ) ‚Üó~‚Üï) ‚áí
			(‚àÄ i : j + 1 .. k + 1‚¶Å f i = i + ~ 1)‚åù‚åù),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 3 rewrite_thm_tac THEN
	  z_app_eq_tac THEN
	  rewrite_tac[z_rel_inv_thm, z_‚óÅ_thm, z_‚àà_succ_thm] THEN
	  rewrite_tac[z_plus_assoc_thm] THEN
	  PC_T1 "z_lin_arith1" asm_prove_tac[]
	  ));
=SML
=TEX
=SML
val local_‚óÅ_succ_rel_inv_sig_thm = (
	push_pc "z_library1";
	set_goal([],  ‚åú‚àÄ f j k ‚¶Å ‚ì© 0 ‚â§ j ‚áí
			(f = ((j .. k) ‚óÅ succ) ‚Üó~‚Üï) ‚áí
			(f ‚àà j + 1  .. k + 1 ‚Üí (j .. k))‚åù‚åù);
	a(REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 1 rewrite_thm_tac THEN
	  PC_T "z_fun_ext" (REPEAT z_strip_tac));
	(* *** Goal "1" *** *)
	a(DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[z_‚àà_succ_thm]) THEN
		all_var_elim_asm_tac1 THEN
		rewrite_tac[] THEN
		DROP_NTH_ASM_T 2 (rewrite_thm_tac o rewrite_rule[]));
	(* *** Goal "2" *** *)
	a(DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[z_‚àà_succ_thm]) THEN
		DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[z_‚àà_succ_thm]) THEN
		all_var_elim_asm_tac1 THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[]));
	(* *** Goal "4" *** *)
	a(z_‚àÉ_tac ‚ì©x1 + (~ 1)‚åù THEN rewrite_tac[z_rel_inv_thm, z_‚óÅ_thm, z_‚àà_succ_thm]	THEN
		DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[]) THEN
		PC_T1 "z_lin_arith1" asm_prove_tac []);
	pop_pc();
	pop_thm ()
);

=SML
val local_set_abs_thm = (
	  set_goal([],  ‚åú‚àÄ f master index X Y ‚¶Å ‚ì©
			(f = {u : master | dom u = index}) ‚áí
			(master ‚àà ‚Ñô (X ‚á∏ Y)) ‚áí
			f = (index ‚Üí Y) ‚à© master
			‚åù‚åù);
		push_pc "z_library1";
		a(strip_tac THEN strip_tac THEN strip_tac THEN strip_tac THEN strip_tac);
		a(‚áí_T rewrite_thm_tac);
		a(PC_T1 "z_fun_ext" rewrite_tac[]);
		a(strip_tac THEN z_‚àÄ_tac THEN strip_tac);
		a(POP_ASM_T (strip_asm_tac o z_‚àÄ_elim ‚ì©x1‚åù));
(* *** Goal "1" *** *)
		a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
		a(cases_tac ‚ì©x1 ‚àà master‚åù THEN asm_rewrite_tac[]);
		a(DROP_NTH_ASM_T 1 discard_tac);
		a(CASES_T (fst(dest_z_‚áî(snd(top_goal()))))
			(fn t => rewrite_tac[t] THEN asm_tac t));
		a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
		a(asm_fc_tac[]);
(* *** Goal "2.2" *** *)
		a(asm_fc_tac[]);
(* *** Goal "2.3" *** *)
		a(z_spec_nth_asm_tac 7 ‚ì©(x ‚âú x, y1 ‚âú y1, y2 ‚âú y2)‚åù);
		a(z_spec_nth_asm_tac 9 ‚ì©(x2 ‚âú x, x3 ‚âú y1)‚åù);
		pop_pc();
		pop_thm()
	  );
=TEX
Now the normalisation of Z horizontal schemas signatures:
=SML
val ‚¶èz_norm_sig_h_schema_conv‚¶é : CONV = (fn tm =>
let	val (d,p) = dest_z_h_schema tm
		handle exn => reraise exn "z_norm_sig_h_schema_conv";
	val decs = dest_z_decl d;
	val ddecs = mapfilter dest_z_dec decs;
	val otherdecs = filter (not o is_z_dec) decs;
	val flat_ddecs = flat (map
		(fn (vs,ty) => map (fn x => (fst(dest_var x), ([x], ty))) vs)
		ddecs);
	val sorted_flat_ddecs = map snd (Sort.sort
		(fn (s1,(_,ty1)) => fn (s2,(_,ty2)) =>
		 if s1 = s2
		 then Sort.string_order (string_of_term ty1) (string_of_term ty2)
		 else ZTypesAndTermsSupport.z_sig_order s1 s2)
		flat_ddecs);
	val rhs = mk_z_h_schema(mk_z_decl (map mk_z_dec sorted_flat_ddecs
			@ otherdecs), p);
in
	if (tm ~=$ rhs)
	then refl_conv tm
	else
	tac_proof(([], mk_z_eq (tm, rhs)),
		PC_T "z_library1" (
			conv_tac z_sets_ext_conv THEN z_‚àÄ_tac THEN z_strip_tac THEN
			conv_tac (ONCE_MAP_C z_‚àà_h_schema_conv) THEN
			TRY_T(conv_tac (MAP_C z_setd_‚äÜ_conv)) THEN
			taut_tac
		)
	)
end
);

=TEX
The following could be made local to $cn\_simplify\_thm$, but for
development purposes they are pervasive in the module.

We rely on the fact that users shouldn't introduce \Product\ variables with
names prefixed by $pp'$, expecially as these are not valid Z names.
If they do, then patterns won't match.
=IGN
local
=SML
	val nat = ‚ì©‚Ñï‚åù;
	val nat0 = ‚ì©0‚åù;
	val pat1 = ‚ì©id ‚åúpp'name‚åù‚åù;
	val pat2 = ‚ì©‚åúpp'name‚åù ‚Üó~‚Üï‚åù;
	val pat3 = ‚ì© ( ‚åúpp'name‚åù \ { ‚åúpp'lst‚åù } ) ‚óÅ succ‚åù;
	val pat4= ‚ì© {u : ‚åúpp'master‚åù | dom u = ‚åúpp'index‚åù } ‚åù;
	val pat5 = ‚ì©‚åúpp'lhs‚åù = ( ‚åúpp'first‚åù .. ‚åúpp'lstm1‚åù  ) ‚óÅ succ‚åù;
	val pat6 = ‚ì©‚åúpp'lhs‚åù = (( ‚åúpp'first‚åù .. ‚åúpp'lstm1‚åù  ) ‚óÅ succ) ‚Üó~‚Üï‚åù;
	val pat7 = ‚ì©‚åúpp'master‚åù ‚àà ‚Ñô ( ‚åúpp'X‚åù ‚á∏ ‚åúpp'Y‚åù)‚åù;

	val local_rw_rule = pure_rewrite_rule[z_plus_assoc_thm,
		‚àß_right_elim(z_get_spec ‚ì©(_ - _)‚åù), z_minus_clauses,
		z_plus0_thm];
	val local_rw_rule1 = pure_once_rewrite_rule[local_dot_dot_diff_thm];
=TEX
Match:
=GFT
‚ä¢ f = id name
=TEX
=SML	
	fun pat1_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val name = match1 rhs pat1;
		val thm1 = list_‚àÄ_elim [name, lhs] local_id_thm;
		val thm2 = ‚áí_elim thm1 thm;
		val thm3 = list_‚àÄ_elim [name, lhs] local_id_sig_thm;
		val thm4 = ‚áí_elim thm3 thm;
	in
		[thm2, thm4]
	end);
=TEX
Match:
=GFT
‚ä¢ f = (name \ {last} ) ‚óÅ succ
=TEX
=IGN
pat3_canon (z_get_spec ‚ì©DAYvSUCC‚åù);
=SML
	fun pat3_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val (last, name) = match2 rhs pat3;
		val nm1_spec = z_get_spec name;
		val (nm1_lhs, nm1_rhs) = dest_z_eq (concl nm1_spec);
		val (nm2, ty2, []) = dest_z_gvar nm1_lhs;
		val thm1 = conv_rule (ONCE_MAP_C (eq_match_conv nm1_spec)) thm;
		val last_spec = z_get_spec last;
		val (last_lhs, last_rhs) = dest_z_eq (concl last_spec);
		val (nm3, ty3, _) = dest_z_gvar last_lhs;
		val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv last_spec)) thm1;
		val thm3 = local_rw_rule1 thm2;
		val (_, first, _) = match3 (concl thm3) pat5;
		val first_spec = z_get_spec first;
		val first2 = snd(dest_eq (concl first_spec));
 		val thm4 = ‚áî_t_elim (z_‚â§_conv (mk_z_‚â§ (nat0, first2)));
		val thm5 = conv_rule (LEFT_C (RIGHT_C
			(eq_match_conv (eq_sym_rule first_spec)))) thm4;
		val last2 = mk_z_plus(last_rhs, ‚ì©~ 1‚åù);
		val thm6 = list_‚àÄ_elim [lhs, first, last2]
			local_‚óÅ_succ_thm;
		val thm7 = ‚áí_elim (‚áí_elim thm6 thm5) thm3;
		val thm8 = list_‚àÄ_elim [lhs, first, last2] local_‚óÅ_succ_sig_thm;
		val thm9 = local_rw_rule (‚áí_elim (‚áí_elim thm8 thm5) thm3);
	in
		[thm7, thm9]
	end);
=TEX
Match:
=GFT
‚ä¢ f = g ‚Üó~‚Üï
=TEX
Two cases - matching $g$ being the two cases above.
=IGN
pat2_canon (z_get_spec ‚ì©DAYvPRED‚åù);
=SML
	fun pat2_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val name = match1 rhs pat2;
		val (nm1, ty1, _) = dest_z_gvar name;
		val nm1_spec = z_get_spec name;
		val (nm1_lhs, nm1_rhs) = dest_z_eq (concl nm1_spec);
		val (nm2, ty2, _) = dest_z_gvar nm1_lhs;
		val thm1 = conv_rule (ONCE_MAP_C (eq_match_conv nm1_spec)) thm;
	in
		(let	val name2 = match1 nm1_rhs pat1;
			val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv local_id_rel_inv_thm)) thm1;
			val thm3 = list_‚àÄ_elim [name2, lhs] local_id_thm;
			val thm4 = ‚áí_elim thm3 thm2;
			val thm5 = list_‚àÄ_elim [name2, lhs] local_id_sig_thm;
			val thm6 = ‚áí_elim thm5 thm2;
		in
			[thm4, thm6]
		end)
		handle (Fail _) =>
		(let	val (last, nm2) = match2 nm1_rhs pat3;
			val nm2_spec = z_get_spec nm2;
			val (nm2_lhs, nm2_rhs) = dest_z_eq (concl nm2_spec);
			val (nm3, ty3, _) = dest_z_gvar nm2_lhs;
			val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv nm2_spec)) thm1;
			val last_spec = z_get_spec last;
			val (last_lhs, last_rhs) = dest_z_eq (concl last_spec);
			val (nm4, ty4, _) = dest_z_gvar last_lhs;
			val thm3 = conv_rule (ONCE_MAP_C (eq_match_conv last_spec)) thm2;
			val thm4 = local_rw_rule1 thm3;
			val (_, first, _)= match3 (concl thm4) pat6;
			val first_spec = z_get_spec first;
			val first2 = snd(dest_eq (concl first_spec));
 			val thm5 = ‚áî_t_elim (z_‚â§_conv (mk_z_‚â§ (nat0, first2)));
			val thm6 = conv_rule (LEFT_C (RIGHT_C
				(eq_match_conv (eq_sym_rule first_spec)))) thm5;
			val last2 = mk_z_plus(last_rhs, ‚ì©~ 1‚åù);
			val thm7 = list_‚àÄ_elim [lhs, first, last2]
				local_‚óÅ_succ_rel_inv_thm;
			val thm8 = ‚áí_elim (‚áí_elim thm7 thm6) thm4;
			val thm9 = local_rw_rule thm8;
			val thm10 = list_‚àÄ_elim [lhs, first, last2]
				local_‚óÅ_succ_rel_inv_sig_thm;
			val thm11 = ‚áí_elim (‚áí_elim thm10 thm6) thm4;
			val thm12 = local_rw_rule  thm11;
		in
			[thm9, thm12]
		end)
	end);
=TEX
Match:
=GFT
‚ä¢ f = {u : master | dom u = index}
=TEX
=SML
	fun pat4_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val (index, master) = match2 rhs pat4;
		val master_spec = ‚àß_left_elim (z_get_spec master);
		val (Y, X, _) =
			match3 (concl master_spec) pat7;
		val thm1 = list_‚àÄ_elim[lhs, master, index, X, Y]
			 local_set_abs_thm;
		val thm2 = ‚áí_elim (‚áí_elim thm1 thm) master_spec;
	in
		[thm2]
	end);
=IGN
in (* local patterns and canons *)
=TEX
=SML
fun ‚¶ècn_simplify_canon‚¶é (thm: THM) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_simplify_canon" 517006 []
	else ();
let 	val cnc = concl thm;
	val (lhs, rhs) = dest_z_eq cnc;
	val dummy = dest_z_gvar lhs;
in
=TEX
Match:
=GFT
‚ä¢ f = id name
=TEX
=SML
	(let 	val name = match1 rhs pat1;
	in
		pat1_canon thm
	end)
	handle (Fail _) =>
=TEX
Match:
=GFT
‚ä¢ f = (name \ {last} ) ‚óÅ succ
=TEX
=SML
	(let 	val (last, name) = match2 rhs pat3;
	in
		pat3_canon thm
	end)
 	handle (Fail _) =>
=TEX
Match:
=GFT
‚ä¢ f = g ‚Üó~‚Üï
=TEX
Two cases - matching $g$ being the two cases above.
=SML
	(let 	val name = match1 rhs pat2;
	in
		pat2_canon thm
	end)
	handle (Fail _) =>
=TEX
Match:
=GFT
‚ä¢ f = {u : master | dom u = index}
=TEX
=SML
	(let 	val (index, master) = match2 rhs pat4;
	in
		pat4_canon thm
 	end)
	handle (Fail _) =>
=TEX
deal with horizontal schemas:
=SML
	[conv_rule (RIGHT_C z_norm_sig_h_schema_conv) thm]
end)
handle (Fail _) => []
=IGN
end (* of local patterns and canons *)
=SML
;
=TEX
The following doesn't defend its self against bad input.
=SML
fun ‚¶èstrip_decls_canon‚¶é (thm : THM) : THM list = (
	if is_‚àß (concl thm)
	then (
		strip_decls_canon (‚àß_left_elim thm) @
		strip_decls_canon (‚àß_right_elim thm))
	else ((let val thm1 = (conv_rule z_setd_‚äÜ_conv thm)
		in
			strip_decls_canon thm1
		end)
		handle (Fail _) =>
		(if is_z_‚àà (concl thm)
		then (let val (a, _) =  dest_z_‚àà (concl thm)
			in
			if (is_z_gvar a orelse is_z_binding a)
			then [thm]
			else []
			end)
		else []))
);
=IGN
strip_decls_canon (‚àß_left_elim (z_get_spec ‚ì©(not_)‚åù));
=TEX
=SML
fun remove_underscores (nm: string): string = (
let val enm = explode nm;
	val enm1 = case (rev enm) of
		("_" :: " " :: rest) => rev rest
		| _ => enm;
	val enm2 = case enm1 of
		("_" :: " " :: rest) =>  rest
		| _ => enm1;
in
	implode enm2
end);
=TEX
The following is the same as the pure equivalent, except for the call to
$cn\_simplify\_rule$.
=IGN
map (fn x => (x, (cn_spec_rule x handle (Fail _) => [])))
(map snd
(flat(map (fn y => get_defns y @ get_axioms y) (get_ancestors "-" diff
		get_ancestors "cn"))));
map (fn x => (x, (cn_spec_rule x handle (Fail _) => [])))
(map snd
(flat(map (fn y => get_defns y @ get_axioms y) ["Alarm_body"])));
val it = ["SHOLSELECTIONspec", "SENSORspec", "BASICTYPESspec", "Alarm_body"] : string
cn_spec_rule (get_spec ‚ì©(not_)‚åù);
cn_spec_rule(get_spec ‚ì©(bag_)‚åù);
=SML
local val tru = ‚ì©true‚åù
in
fun ‚¶ècn_spec_rule‚¶é (thm : THM) : (string * THM) list = (
let	val cthm = concl thm;
in
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_spec_rule" 517006 []
	else ();
	if is_eq cthm andalso is_u(snd(dest_eq cthm))
	then (let val (full_nm, _, _) = dest_z_gvar(fst(dest_eq cthm)) ;
		    val nm = remove_underscores full_nm;
		in
		[("cn_" ^ nm ^ "_thm", thm)]
		end)
	else if is_app cthm andalso
		(fst (dest_app cthm) =$ ‚åú$"Z'Constraint"‚åù)
	then thm_fail "cn_spec_rule" 517004 [thm]
		 (* can't get names from constraints *)
	else
(let	val thm0 = conv_rule z_para_pred_conv thm
		handle (Fail _) => thm_fail "cn_spec_rule" 517004 [thm];
		(* fail if not a Z para *)
	val thm1 = all_‚àÄ_elim thm0;
in
	map (fn (n, t) => (n, all_‚àÄ_intro t)) (* reintroduce variables *)
	(case (dest_z_term (concl thm1)) of
	ZEq(lhs, rhs) => (     (* Given sets, abreviation defns, schema boxes *)
		if is_z_gvar(lhs)
		then (
		let val (full_nm, _, _) = dest_z_gvar lhs;
		    val nm = remove_underscores full_nm;
		    val r = cn_simplify_canon thm1;
		in
			case r of
			[thm2, thm3] => [("cn_" ^ nm ^ "_thm", thm2),
				("cn_" ^ nm ^ "_sig_thm", thm3)]
			| [thm2] => [("cn_" ^ nm ^ "_thm", thm2)]
			| _ => [("cn_" ^ nm ^ "_thm", conv_rule
			(TRY_C (PC_C1 "z_library1" rewrite_conv [] )) thm1)]
		end)
		else (warn "cn_spec_rule" 517007 [fn () => string_of_term lhs];
			[])
	) | Z‚àß (a, b) => ( (* axiomatic box with decl, free type defns *)
	let	val a_thms = strip_decls_canon (‚àß_left_elim thm1);
		val (names, a_outs) = split (flat
			(map (fn x =>
			let val (m, t) = dest_z_‚àà (concl x);
			in
				if is_z_gvar m
				then (let
					val (full_nm, _, _) = dest_z_gvar m;
		    			val nm = remove_underscores full_nm;
				in
					[(nm, ("cn_"  ^ nm ^ "_sig_thm", x))]
				end)
				else (let val nms = fst(split(dest_z_binding m));
				in
				map (fn nm => (remove_underscores nm, ("cn_"  ^
					remove_underscores nm ^ "_sig_thm", x))) nms
				end)
			end)
			a_thms));
		val b_proper_thm = conv_rule
			(TRY_C (PC_C1 "z_library1" rewrite_conv [] ))
			(‚àß_right_elim thm1);
		val b_outs = (if (b ~=$ tru)
			then []
			else map
				(fn nm => ("cn_"  ^ nm ^ "_thm", b_proper_thm))
				 names
		);
	in
		a_outs @ b_outs
	end
	) | _ => thm_fail "cn_spec_rule" 517004 [thm]
		(* axiomatic box w/o decl *)
	)
	handle (exn as Fail _) =>
		reraise exn "cn_spec_rule"

end)
end); (* cthm let *)
end; (* local *)
=TEX
The following are just the same as the pure tools but with a name change.
=SML
fun ‚¶èlist_cn_spec_rule‚¶é (thms : THM list) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_script_support_thms" 517006 []
	else ();
	aux_list_cn_spec_rule cn_spec_rule "list_cn_spec_rule" thms
);
=TEX
=SML
fun ‚¶ècn_script_support_thms‚¶é (nm : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_script_support_thms" 517006 []
	else ();
	aux_cn_script_support_thms cn_spec_rule "cn_script_support_thms" nm
);
=TEX
We choose the following presentation to catch any unknown or out of scope theory
names before we do any saving.
We use $cup$ to delete duplicates.
=SML
fun ‚¶èlist_cn_script_support_thms‚¶é (in_nms : string list) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "list_cn_script_support_thms" 517006 []
	else ();
	aux_list_cn_script_support_thms cn_spec_rule
		"list_cn_script_support_thms" in_nms
);
=TEX

\subsection{Proof Contexts}
If the index to the equaltion context entry isn't of type BOOL then it can't be
used in stripping.
=SML
fun ‚¶èmaybe_strip‚¶é (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else fail "" 0 []
);
=TEX
If the index in an equation context is a set type,m then we can promote the
entry to be an equation of memberships.
=SML
local
	val setty = type_of ‚ì©{}‚åù;
in
fun ‚¶èadd_‚àà‚¶é ((index,cnv)::rest) = (
	(let val tyms = type_match (type_of index) setty @ [(‚ì£'a‚åù,‚ì£'a‚åù)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		((mk_z_‚àà(x,index), ‚àà_C cnv) :: (index,cnv) :: add_‚àà rest)
	end)
	handle (Fail _) =>
	((index,cnv) :: add_‚àà rest)
) | add_‚àà [] = [];
end;
=TEX
=SML
local
	val pat = ‚ì©x = ùïå‚åù;
in
fun ‚¶èis_U_eqn‚¶é (thm : THM) : bool = (
	(term_match (concl thm) pat; true) handle (Fail _) => false
);
end;

=TEX
Given a list of theorems create an equation context:
=SML
fun ‚¶èthms_to_eqn_cxt‚¶é (thms:THM list) : EQN_CXT = (
let	val dummy1 = push_pc "cn1";
	val res = flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms);
	val dummy2 = pop_pc();
in
	res
end);
=TEX
Create a proof context from a list of theorems, as called for in
detailed design.
In theory the following can't fail.
=SML
fun ‚¶èlocal_make_pc‚¶é (fname : string) (in_thms : THM list) (pcname : string) : unit = (
let 	val dummy_pc1 = push_pc "cn1";
	val sort_thms = union (op ~=|-) in_thms []; (* probably already done *)
	val thms = filter (fn x =>
		((z_‚àà_u_conv (concl x); false) handle (Fail _) => true))
		sort_thms;
	val u_thms = filter is_U_eqn thms;
	val not_u_thms = filter (fn x => not(is_U_eqn x)) thms;
	val source_ec = add_‚àà(thms_to_eqn_cxt not_u_thms);
	val ec_for_strip = mapfilter maybe_strip source_ec;
	val dummy1 = delete_pc pcname handle Fail _ => ();
	val dummy2 = new_pc pcname;
	val dummy3 = merge_pcs ["cn1"] pcname;
	val dummy4 = add_rw_thms not_u_thms pcname;
	val pos = ec_for_strip;
	val neg = map (mk_¬¨ ** RAND_C) pos;
	val dummy5 = set_st_eqn_cxt (pos @ neg) pcname;
	val dummy6 = set_sc_eqn_cxt (pos @ neg) pcname;
	val dummy7 = set_u_simp_eqn_cxt (u_simp_eqn_cxt u_thms) pcname;
	val dummy8 = set_pc_z_‚àà_rules
		(pc_z_‚àà_rules_of_thms [pcname] not_u_thms)
		pcname;
	val dummy9 = commit_pc pcname;
 	val dummy_pc2 = pop_pc ();
in
	()
end);
=IGN
val thms = cn_make_script_support "cn" "cn_pc";
val nets = get_pc_z_‚àà_rules "cn_pc";
val enets = map (fn (net, nm) => (nm,
	map (fn (x,y) => (x, y x)) net)) nets;
=TEX
Now to use it:
=SML
fun ‚¶ècn_make_script_support‚¶é (nm : string) (pcname : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_make_script_support" 517006 []
	else ();
let val thms = aux_cn_script_support_thms cn_spec_rule "cn_script_support_thms" nm;
	val dummy = local_make_pc "cn_make_script_support" thms pcname;
in
	thms
end);
=TEX
We choose the following presentation to catch any unknown or out of scope theory
names before we do any saving.
We use $cup$ to delete duplicates.
=SML
fun ‚¶èlist_cn_make_script_support‚¶é (in_nms : string list) (pcname : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "list_cn_make_script_support" 517006 []
	else ();
let 	val thms = aux_list_cn_script_support_thms cn_spec_rule
		"list_cn_script_support_thms" in_nms;
	val dummy = local_make_pc "list_cn_script_support_thms" thms pcname;
in
	thms
end);
=TEX
=SML
fun ‚¶èall_cn_make_script_support‚¶é (pcname : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "all_cn_make_script_support" 517006 []
	else ();
	list_cn_make_script_support
		(((get_ancestors "-") diff (get_ancestors "cn")))
		pcname
);
=TEX

\section{EPILOGUE}
=SML
end (* of structure CNTheoryProofSupport *);
open CNTheoryProofSupport;
pop_pc();
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

