=IGN
********************************************************************************
wrk507.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Date: 2004/02/07 17:28:56 $ $Revision: 1.20 $ $RCSfile: wrk507.doc,v $
=TEX
% TQtemplate.tex
% use_file "daz_init";
% use_file "wrk507";
% z_print_theory"-";
% open CNZGenerator;
\documentstyle[hol1,11pt,TQ,hyperbasics]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Calculator Example}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/WRK507}  %% Mandatory field
\def\SCCSversion{$Revision: 1.20 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2004/02/07 17:28:56 $%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{%
This document gives an example of the Compliance Notation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\pagebreak
\section{INTRODUCTION}
This document contains an example of the Compliance Notation.
The example is concerned with the computational aspects of a simple calculator.

Part of the purpose of this example is to demonstrate the insertion of hypertext links in the script by the compliance tool
(see \cite{ISS/HAT/DAZ/USR501}).
For this reason, the example adopts the rather unusual policy of giving proofs of VCs immediately after the Compliance Notation clause which generates them (so that the interleaving of refinement steps and proofs is fairly complicated).

This example has also been used in the {\em Compliance Tool --- Proving VCs}
tutorial, \cite{ISS/HAT/DAZ/USR503}. For reference purposes, a proof script
for all the VCs has been supplied in \cite{ISS/HAT/DAZ/WRK513}. These
proofs illustrate the techniques advocated in the tutorial, and differ slightly from those presented here.

\section{PREAMBLE}

The following Standard ML command sets up the Compliance Tool to process the rest of the script.
=FULLVERSION
force_delete_theory"wrk507" handle Fail _ => ();
=SML
new_script {name="wrk507", state=initial_cn_state};
=TEX
\newpage
\section{BASIC DEFINITIONS}
In this section, we define types and constants which will be of use throughout the rest of the script.

The SPARK package $BASICS$ below helps record the following facts:

\begin{quotation}
The calculator deals with signed integers expressed using up to six decimal digits.
It has a numeric keypad and 6 operation buttons labelled $+$, $-$, $\times$, $+/-$, $!$, $\sqrt{ }$, and $=$.
\end{quotation}

πCN
package BASICS is

    BASE : constant INTEGER := 10;
    PRECISION : constant INTEGER := 6;
    MAX_NUMBER : constant INTEGER := BASE ** PRECISION - 1;
    MIN_NUMBER : constant INTEGER := -MAX_NUMBER;

    subtype DIGIT is INTEGER range 0 .. BASE - 1;

    subtype NUMBER is INTEGER range MIN_NUMBER .. MAX_NUMBER;

    type OPERATION is
      (PLUS, MINUS, TIMES, CHANGE_SIGN, SQUARE_ROOT, FACTORIAL, EQUALS);

end BASICS;
∞
\newpage
\section{THE STATE}
In this section, we define a package which contains all the state variables of the calculator.

The package $STATE$ below defines the variables we will use to implement the following informal description of part of the calculator's behaviour:

\begin{quotation}
The calculator has two numeric state variables: the display, which contains the number currently being entered, and the accumulator, which contains the last result calculated.

The user is considered to be in the process of entering a number whenever a digit button is pressed, and entry of a number is terminated by pressing one of the operation keys.

When a binary operation key is pressed, the operation is remembered so that it can be calculated when the second operand has been entered.
\end{quotation}

=SML
val state1 = get_cn_state();
new_script {name="wrk507a", state=state1};
=TEX

πCN
with BASICS;
package STATE is

    DISPLAY, ACCUMULATOR : BASICS.NUMBER;

    LAST_OP : BASICS.OPERATION;

    IN_NUMBER : BOOLEAN;

end STATE;
∞

\newpage
\section{THE OPERATIONS}

In this section, we define a package which contains procedures corresponding to pressing the calculator buttons.

\subsection{Package Specification}

We now want to introduce a package $OPERATIONS$ which implements the following informal description ofhow the calculator responds to button presses:

\begin{quotation}
The behaviour when a digit button is pressed depends on whether a number is currently being entered into the display. If a number is being entered, then the digit is taken as part of the number. If a number is not being entered (e.g., if an operation button has just been pressed), then the digit is taken as the most significant digit of a new number in the display.

When a binary operation button is pressed, any outstanding calculation is carried out and the answer (which will be the first operand of the operation) is  displayed; the calculator is then ready for the user to enter the other operand of the operation.

When a unary operation button is pressed, the result of performing that operation to the displayed number is computed and displayed; the accumulator is unchanged, but entry of the displayed number is considered to be complete.

When the button marked $=$ is pressed, any outstanding calculation is carried out and the answer is displayed.
\end{quotation}

The package implementing this is defined in section \ref{PackageOPERATIONS} below after we have dealt with some preliminaries.

\subsubsection{Z Preliminaries}
=SML
val state2 = get_cn_state();
new_script1 {name="wrk507b", state=state2, library_theories=["BASICSspec"]};
=TEX
To abbreviate the description of the package, we do some work in Z first, corresponding to the various sorts of button press.

Note that the use of
=INLINEFT
˙
=TEX
\ rather than
=INLINEFT
BASICSoNUMBER
=TEX
\ reflects the fact that we are ignoring questions of arithmetic overflow here.
If we used the Z set which accurately represents the SPARK type, then we would have to add in pre-conditions saying that the operations do not overflow.
The following schema defines what happens when a digit button is pressed.

ˇ DO_DIGIT ¸¸¸¸¸¸¸¸¸¸¸
‹ DISPLAYâ0, DISPLAY : ˙;
‹ IN_NUMBERâ0, IN_NUMBER : BOOLEAN;
‹ D : BASICSoDIGIT
˜¸¸¸¸¸¸
‹	IN_NUMBERâ0 = TRUE ¥ DISPLAY = DISPLAYâ0*BASICSoBASE + D;
‹	IN_NUMBERâ0 = FALSE ¥  DISPLAY = D;
‹	IN_NUMBER = TRUE
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We now define sets $UNARY$ and $BINARY$ which partition the two sorts of operation key.
Note that $=$ can be considered as a sort of binary operation (which given operands $x$ and $y$ returns $x$).
πZ
‹ UNARY ¶ {BASICSoCHANGE_SIGN, BASICSoFACTORIAL, BASICSoSQUARE_ROOT}
∞

πZ
‹ BINARY ¶ BASICSoOPERATION \ UNARY
∞
We need to define a function for computing factorials in order to define the response to the factorial operation button.

πZAX
‹	fact : Ó ≠ Ó
˜¸¸¸¸¸¸
‹	fact 0 = 1 ;
‹ 	µm:Ó∑ fact(m+1) = (m + 1) * fact m
∞
Unary operations behave as specified by the following schema.
In which we do specify explicitly  that the accumulator and last operation values are unchanged for clarity and for simplicity later on (when we group the unary and binary operations together).

ˇ DO_UNARY_OPERATION ¸¸¸¸¸¸¸¸¸¸¸
‹ ACCUMULATORâ0, ACCUMULATOR : ˙;
‹ DISPLAYâ0, DISPLAY : ˙;
‹ LAST_OPâ0, LAST_OP : ˙;
‹ IN_NUMBER : BOOLEAN;
‹ O : UNARY
˜¸¸¸¸¸¸
‹	IN_NUMBER = FALSE;
‹	ACCUMULATOR = ACCUMULATORâ0;
‹	LAST_OP = LAST_OPâ0;
‹	O = BASICSoCHANGE_SIGN ¥ DISPLAY = ~DISPLAYâ0;
‹	O = BASICSoFACTORIAL ± DISPLAYâ0 æ 0 ¥ DISPLAY = fact DISPLAYâ0;
‹	O = BASICSoSQUARE_ROOT  ± DISPLAYâ0 æ 0 ¥
‹			DISPLAY ** 2 º DISPLAYâ0 < (DISPLAY + 1) ** 2
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The binary operations are specified by the following schema.
ˇ DO_BINARY_OPERATION ¸¸¸¸¸¸¸¸¸¸¸
‹ ACCUMULATORâ0, ACCUMULATOR : ˙;
‹ DISPLAYâ0, DISPLAY : ˙;
‹ LAST_OPâ0, LAST_OP : ˙;
‹ IN_NUMBER : BOOLEAN;
‹ O : BINARY
˜¸¸¸¸¸¸
‹	IN_NUMBER = FALSE;
‹	DISPLAY = ACCUMULATOR;
‹	LAST_OP = O;
‹	LAST_OPâ0 = BASICSoEQUALS ¥
‹			ACCUMULATOR = DISPLAYâ0;
‹	LAST_OPâ0 = BASICSoPLUS ¥
‹			ACCUMULATOR = ACCUMULATORâ0 + DISPLAYâ0;
‹	LAST_OPâ0 = BASICSoMINUS ¥
‹			ACCUMULATOR = ACCUMULATORâ0 - DISPLAYâ0;
‹	LAST_OPâ0 = BASICSoTIMES ¥
‹			ACCUMULATOR = ACCUMULATORâ0 * DISPLAYâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The disjunction of the schemas for the unary and binary operations is then what is needed to define the response to pressing an arbitrary button press.
πZ
‹ DO_OPERATION ¶ DO_UNARY_OPERATION ≤ DO_BINARY_OPERATION
∞
\newpage
\subsection{The SPARK Package}\label{PackageOPERATIONS}
We now use the schemas of the previous section to define the package $OPERATIONS$.
Since we used the short forms of the SPARK names in the previous section, we need to rename the schema signature variables to prefix them with the appropriate package names.
πCN
with BASICS, STATE;
package OPERATIONS is
procedure DIGIT_BUTTON (D : in BASICS.DIGIT)
        Ñ STATEoDISPLAY, STATEoIN_NUMBER [
         DO_DIGIT [
           STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
           STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
           D/D] ] ;
procedure OPERATION_BUTTON (O : in BASICS.OPERATION)
        Ñ STATEoACCUMULATOR, STATEoDISPLAY,
                STATEoIN_NUMBER, STATEoLAST_OP [
         DO_OPERATION[
          STATEoACCUMULATORâ0/ACCUMULATORâ0,
          STATEoACCUMULATOR/ACCUMULATOR,
          STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
          STATEoLAST_OPâ0/LAST_OPâ0,  STATEoLAST_OP/LAST_OP,
          STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
          D/D] ] ;
end OPERATIONS;
∞
\newpage
\subsection{Package Implementation}
\subsubsection{Package Body}
The following specification of the package body is derived from the package specification in the obvious way. We leave a k-slot for any extra declarations we may need.
=SML
val state3 = get_cn_state();
new_script {name="wrk507c", state=state3};
=TEX

πCN
references BASICS, STATE;
package body OPERATIONS is
     ß Extra Declarations ¢			( 500 )
procedure DIGIT_BUTTON (D : in BASICS.DIGIT)
        Ñ STATEoDISPLAY, STATEoIN_NUMBER [
         DO_DIGIT [
           STATEoDISPLAYâ0/DISPLAYâ0, STATEoDISPLAY/DISPLAY,
           STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
           D/D] ]
    is begin
        Ñ STATEoDISPLAY, STATEoIN_NUMBER [
         DO_DIGIT [ STATEoDISPLAYâ0/DISPLAYâ0, STATEoDISPLAY/DISPLAY,
           STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
           D/D] ]				(3001)
    end DIGIT_BUTTON;
procedure OPERATION_BUTTON (O : in BASICS.OPERATION)
        Ñ STATEoACCUMULATOR, STATEoDISPLAY,
                 STATEoIN_NUMBER, STATEoLAST_OP [
         DO_OPERATION[
          STATEoACCUMULATORâ0/ACCUMULATORâ0,
          STATEoACCUMULATOR/ACCUMULATOR,
          STATEoDISPLAYâ0/DISPLAYâ0, STATEoDISPLAY/DISPLAY,
          STATEoLAST_OPâ0/LAST_OPâ0, STATEoLAST_OP/LAST_OP,
          STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
          D/D] ]
    is begin
        Ñ STATEoACCUMULATOR, STATEoDISPLAY,
                STATEoIN_NUMBER, STATEoLAST_OP [
         DO_OPERATION[ STATEoACCUMULATORâ0/ACCUMULATORâ0,
          STATEoACCUMULATOR/ACCUMULATOR,
          STATEoDISPLAYâ0/DISPLAYâ0, STATEoDISPLAY/DISPLAY,
          STATEoLAST_OPâ0/LAST_OPâ0, STATEoLAST_OP/LAST_OP,
          STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
          D/D] ]			(3002)
    end OPERATION_BUTTON;
end OPERATIONS;
∞
=TEX
Introducing the package body gives us 8 very trivial VCs to prove:
=FULLVERSION
set_pc"cn";
set_goal([], get_conjecture"-""vcOPERATIONSbody_1");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vcOPERATIONSbody_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_2";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vcOPERATIONSbody_3");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_3";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vcOPERATIONSbody_4");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_4";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vcOPERATIONSbody_5");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_5";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vcOPERATIONSbody_6");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_6";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vcOPERATIONSbody_7");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_7";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vcOPERATIONSbody_8");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_8";
=TEX
\subsubsection{Supporting Functions}
We choose to separate out the computation of factorials and square roots into separate functions which replace the k-slot labelled 500.
In both cases, we prepare for the necessary algorithms.
Our approach for both functions is to introduce and initialise appropriately a variable called $RESULT$, demand that this be set to the desired function return value and return that value.


πCN
 (500) È 
    function FACT (M : NATURAL) return NATURAL
        ò [ FACT(M) = fact(M) ]
    is
        RESULT : NATURAL;
    begin
        RESULT := 1;
        Ñ RESULT [M æ 0 ± RESULT = 1, RESULT = fact M ]	(1001)
        return RESULT;
    end FACT;

    function SQRT (M : NATURAL) return NATURAL
        ò [SQRT(M) ** 2 º M < (SQRT(M) + 1) ** 2]
    is
        RESULT : NATURAL;
       ß other local vars ¢		(2)
    begin
       RESULT := 0;
       Ñ RESULT [RESULT = 0, RESULT ** 2 º M < (RESULT + 1) ** 2]	(2001)
      return RESULT;
    end SQRT;
∞
The above results in a number of VCs to show that the function bodies achieve what is demanded in the function specification.
We now prove these VCs, some of which require the following lemma about SPARK natural numbers.
=FULLVERSION
set_goal([], Òµm : NATURAL∑ m æ 0Æ);
a(rewrite_tac[z_get_specÒNATURALÆ] THEN REPEAT strip_tac);
val natural_thm = save_pop_thm"natural_thm";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc500_1");
a(REPEAT strip_tac THEN all_fc_tac[natural_thm]);
val _ = save_pop_thm "vc500_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc500_2");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
val _ = save_pop_thm "vc500_2";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc500_3");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc500_3";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc500_4");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
val _ = save_pop_thm "vc500_4";
=TEX
\subsubsection{Algorithm for Factorial}
Factorial is implemented by a for-loop with loop-counter $J$ and an invariant requiring that as $J$ steps from $2$ up to $M$, $RESULT$ is kept equal to the factorial of $J$:
πCN
  (1001) √
    for J in INTEGER range 2 .. M
    loop
        Ñ RESULT [J æ 1 ± RESULT = fact (J-1), RESULT = fact J] (1002)
    end loop;
∞
This produces 4 VCs, which we proceed to prove, beginning with a lemma about the first two values of factorial (needed because our algorithm avoids the unnecessary pass through the loop with $J = 1$).

=TEX
=FULLVERSION
set_goal([], Òfact 0 = 1 ± fact 1 = 1Æ);
a(rewrite_tac[z_get_specÒfactÆ,
	(rewrite_rule[z_get_specÒfactÆ] o z_µ_elimÒ0Æ o
			±_right_elim o ±_right_elim o z_get_spec)ÒfactÆ
]);
val fact_thm  = save_pop_thm"fact_thm";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc1001_1");
a(REPEAT strip_tac THEN asm_rewrite_tac[fact_thm]);
val _ = save_pop_thm "vc1001_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc1001_2");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒM = 0 ≤ M = 1Æ);
(* *** Goal "1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[fact_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[fact_thm]);
val _ = save_pop_thm "vc1001_2";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc1001_3");
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_ante_tacÒ2 º JÆ THEN PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_plus_assoc_thm]);
val _ = save_pop_thm "vc1001_3";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc1001_4");
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val _ = save_pop_thm "vc1001_4";
=TEX
Now we can complete the implementation of the factorial function by providing the loop body:

πCN
  (1002) √
       RESULT := J * RESULT;
∞
Again this gives rise to a VC which we prove immediately, completing the implementation and verification of the factorial function:
=FULLVERSION
set_goal([], get_conjecture"-""vc1002_1");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒ∂K:É∑ K + 1 = JÆ);
(* *** Goal "1" *** *)
a(z_∂_tacÒJ - 1Æ THEN PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(rewrite_tac[z_plus_assoc_thm]);
a(ALL_FC_T rewrite_tac[z_get_specÒfactÆ]);
val _ = save_pop_thm "vc1002_1";
=TEX

\subsubsection{Algorithm for Square Root}
For square root, we need two extra variables to implement a binary search for the square root.

πCN
(2) È
    MID, HI : INTEGER;
∞
The following just says that we propose to achieve the desired effect on $RESULT$ using $MID$ and $HI$ as well.
πCN
(2001) √
        Ñ RESULT, MID, HI
            [RESULT = 0, RESULT ** 2 º M < (RESULT + 1) ** 2] (2002)
∞
=TEX
This produces two very trivial VCs:
=FULLVERSION
set_goal([], get_conjecture "-" "vc2001_1");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2001_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2001_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2001_2";
=TEX
Now we give the initialisation for $HI$ and describe the loop which will find the square root:

πCN
(2002) √
       HI := M + 1;
       till ˚RESULT ** 2 º M < (RESULT + 1) ** 2˝
       loop
           Ñ RESULT, MID, HI
               [RESULT ** 2 º M < HI ** 2, RESULT ** 2 º M < HI ** 2] (2003)
       end loop;
∞
=TEX
This gives us 3 more VCs to prove, which depend on a few mathematical facts about the exponentiation operator:

=TEX
=FULLVERSION
set_goal([], Òµx: ˙∑  x ** 1 = xÆ);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[](
    z_µ_elimÒ(x ¶ x, y ¶ 0)Æ (±_right_elim(z_get_specÒ(_**_)Æ)))]);
val star_star_1_thm = pop_thm();
=TEX
=FULLVERSION
set_goal([], Òµx: ˙∑  x ** 2 = x * xÆ);
a(REPEAT strip_tac);
a(rewrite_tac[star_star_1_thm, rewrite_rule[](
    z_µ_elimÒ(x ¶ x, y ¶ 1)Æ (±_right_elim(z_get_specÒ(_**_)Æ)))]);
val star_star_2_thm = pop_thm();
=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2002_1");
a(REPEAT strip_tac THEN all_fc_tac[natural_thm]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[star_star_1_thm, star_star_2_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN DROP_ASMS_T discard_tac THEN strip_tac);
a(z_º_induction_tacÒMÆ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[star_star_1_thm, star_star_2_thm]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[star_star_2_thm]);
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
val _ = save_pop_thm "vc2002_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2002_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2002_2";
=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2002_3");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2002_3";
=TEX
Now we implement the exit for the loop and specify the next step:
πCN
(2003) √
       exit when RESULT + 1 = HI;
       Ñ RESULT, MID, HI
            [RESULT ** 2 º M < HI ** 2, RESULT ** 2 º M < HI ** 2] (2004)
∞
Again we get VCs which we now prove:

=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2003_1");
a(rewrite_tac[]);
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
val _ = save_pop_thm "vc2003_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2003_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2003_2";
=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2003_3");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2003_3";
=TEX
Now we can fill in the last part of the loop:
πCN
(2004)    √ 
    MID := (RESULT + HI + 1) / 2;
    if      MID ** 2 > M
    then    HI := MID;
    else    RESULT := MID;
    end if;
∞
=TEX
We now prove the 2 VCs produced, which completes the implementation and verification of the square root function.
 
=FULLVERSION
set_goal([], get_conjecture "-" "vc2004_1");
a(rewrite_tac[star_star_2_thm]);
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2004_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture "-" "vc2004_2");
a(rewrite_tac[star_star_2_thm]);
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2004_2";
=TEX
\subsubsection{Digit Button Algorithm}
We now continue with the body of the digit button procedure.
An if-statement handling the two cases for updating the display, followed by an assignment to the flag should meet the bill here.
πCN
 (3001) √
    if    STATE.IN_NUMBER
    then  STATE.DISPLAY := STATE.DISPLAY * BASICS.BASE + D;
    else  STATE.DISPLAY := D;
    end if;
    STATE.IN_NUMBER := true; 
∞
=TEX
This produces 2 VCs corresponding to the two branches of the if-statement.
Both are easy to prove:
=FULLVERSION
set_goal([], get_conjecture"-""vc3001_1");
a(REPEAT strip_tac);
a(asm_rewrite_tac[z_get_specÒDO_DIGITÆ]);
a(REPEAT strip_tac);
val _ = save_pop_thm "vc3001_1";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc3001_2");
a(REPEAT strip_tac);
a(asm_rewrite_tac[z_get_specÒDO_DIGITÆ]);
val _ = save_pop_thm "vc3001_2";
=TEX
\subsubsection{Operation Button Algorithm}
We now complete the implementation and verification of the package $OPERATIONS$ by giving the body of the procedure for handling the operation buttons.
πCN
 (3002) √
    if      O = BASICS.CHANGE_SIGN
    then    STATE.DISPLAY := -STATE.DISPLAY;
    elsif   O = BASICS.FACTORIAL
    then    STATE.DISPLAY := FACT(STATE.DISPLAY);
    elsif   O = BASICS.SQUARE_ROOT
    then    STATE.DISPLAY := SQRT(STATE.DISPLAY);
    else    if      STATE.LAST_OP = BASICS.EQUALS
            then    STATE.ACCUMULATOR := STATE.DISPLAY;
            elsif   STATE.LAST_OP = BASICS.PLUS
            then   STATE.ACCUMULATOR := STATE.ACCUMULATOR + STATE.DISPLAY;
            elsif   STATE.LAST_OP = BASICS.MINUS
            then   STATE.ACCUMULATOR := STATE.ACCUMULATOR - STATE.DISPLAY;
            elsif   STATE.LAST_OP = BASICS.TIMES
            then   STATE.ACCUMULATOR := STATE.ACCUMULATOR * STATE.DISPLAY;
            end if;
            STATE.DISPLAY := STATE.ACCUMULATOR;
            STATE.LAST_OP := O;
    end if;
    STATE.IN_NUMBER := false;
∞
=TEX
=FULLVERSION
val basics_defs = map z_get_spec(get_consts"BASICSspec");
val op_defs = map z_get_spec(flat( 
	map get_consts ["wrk507c", "wrk507b"]));
=TEX
The first three VCs are concerned with the unary operations.
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_1");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
val _ = save_pop_thm "vc3002_1";
=TEX
For the next two VCs, it is necessary to make the (reasonable) assumption that a non-negative number of the precision handled by the calculator will fit in a SPARK $NATURAL$.
This amounts to the following axiom:
πZ
‹ BASICSoMAX_NUMBER º INTEGERvLAST
∞
=FULLVERSION
val number_ax = snd(hd(get_axioms"-"));
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_2");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
a(all_var_elim_asm_tac1 THEN strip_tac);
a(lemma_tac ÒSTATEoDISPLAY ç NATURALÆ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 5 ante_tac);
a(ante_tac number_ax);
a(asm_rewrite_tac(z_get_specÒNATURALÆ :: basics_defs));
a(PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_get_specÒFACTÆ]);
val _ = save_pop_thm "vc3002_2";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_3");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
a(all_var_elim_asm_tac1 THEN strip_tac);
a(lemma_tac ÒSTATEoDISPLAY ç NATURALÆ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 6 ante_tac);
a(ante_tac number_ax);
a(asm_rewrite_tac(z_get_specÒNATURALÆ :: basics_defs));
a(PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[z_get_specÒSQRTÆ]);
a(REPEAT strip_tac);
val _ = save_pop_thm "vc3002_3";
=TEX
Because the binary operations only involve built-in arithmetic operators, they are a little easier to verify than the unary ones.
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_4");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
val _ = save_pop_thm "vc3002_4";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_5");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
val _ = save_pop_thm "vc3002_5";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_6");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
val _ = save_pop_thm "vc3002_6";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_7");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
val _ = save_pop_thm "vc3002_7";
=TEX
=FULLVERSION
set_goal([], get_conjecture"-""vc3002_8");
a(rewrite_tac op_defs);
a(z_µ_tac THEN ¥_tac THEN asm_rewrite_tac basics_defs);
val _ = save_pop_thm "vc3002_8";
=TEX
That completes the formal verification of the calculator packages.
\section{EPILOGUE}
The following {\ProductML} commands produce the Z document, the SPARK program and the hypertext edit script for this script and save the Compliance Tool state in a variable for re-use in other scripts depending on this one.

The final command prints out a message for use when this script is used as part of the Compliance Tool test suite.
=FULLVERSION
val €wrk507_state› = get_cn_state();
output_z_document{script="wrk507", out_file="wrk507.zdoc"};
output_z_document{script="wrk507a", out_file="wrk507a.zdoc"};
output_z_document{script="wrk507b", out_file="wrk507b.zdoc"};
output_z_document{script="wrk507c", out_file="wrk507c.zdoc"};
=TEX
=SML
output_ada_program{script="-", out_file="wrk507.ada"};
output_hypertext_edit_script{out_file="wrk507.ex"};
set_cn_state state1;
output_ada_program{script="-", out_file="wrk507a.ada"};
output_hypertext_edit_script{out_file="wrk507a.ex"};
set_cn_state state2;
output_ada_program{script="-", out_file="wrk507b.ada"};
output_hypertext_edit_script{out_file="wrk507b.ex"};
set_cn_state state3;
output_ada_program{script="-", out_file="wrk507c.ada"};
output_hypertext_edit_script{out_file="wrk507c.ex"};
diag_line "All module tests passed";
=TEX
%\pagebreak
%\HOLindexOff
%\input{wrk507.th.tex}
%\HOLindexOn
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}
=IGN

