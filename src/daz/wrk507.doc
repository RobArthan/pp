% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
% use_file "daz_init";
% use_file "wrk507";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ,hyperbasics]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Calculator Example}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/WRK507}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{%
This document gives an example of the Compliance Notation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\pagebreak
\section{INTRODUCTION}
This document contains an example of the Compliance Notation.
The example is concerned with the computational aspects of a simple calculator.

Part of the purpose of this example is to demonstrate the insertion of hypertext links in the script by the compliance tool.

\section{PREAMBLE}

The following Standard ML command sets up the Compliance Tool to process the rest of the script.
=SML
force_delete_theory"wrk507" handle Fail _ => ();
new_script {name="wrk507", state=initial_cn_state};
=TEX

\section{BASIC DEFINITIONS}
In this section, we define types and constants which will be of use throughout the rest of the script.

The SPARK package $BASICS$ below helps record the following facts:

\begin{quotation}
The calculator deals with signed integers expressed using up to six decimal digits.
It has a numeric keypad and 6 operation buttons labelled $+$, $-$, $\times$, $+/-$, $!$, $\sqrt{ }$, and $=$.
\end{quotation}

πCN
package BASICS is

    BASE : constant INTEGER := 10;
    PRECISION : constant INTEGER := 6;
    MAX_NUMBER : constant INTEGER := BASE ** PRECISION - 1;
    MIN_NUMBER : constant INTEGER := -MAX_NUMBER;

    type DIGIT is range 0 .. BASE - 1;

    type NUMBER is range MIN_NUMBER .. MAX_NUMBER;

    type OPERATION is
        (PLUS, MINUS, TIMES, CHANGE_SIGN, SQUARE_ROOT, FACTORIAL, EQUALS);

end BASICS;
∞
\newpage
\section{THE STATE}
In this section, we define a package which will contains all the state variables of the calculator.

The package $STATE$ below defines the variables we will use to implement the following informal description of part of the calculator's behaviour:

\begin{quotation}
The calculator has two numeric state variables: the display, which contains the number currently being entered, and the accumulator, which contains the last result calculated.

The user is considered to be in the process of entering a number whenever a digit button is pressed, and entry of a number is terminated by pressing one of the operation keys.
\end{quotation}

πCN
with BASICS;
package STATE is

    DISPLAY, ACCUMULATOR : BASICS.NUMBER;

    IN_NUMBER : BOOLEAN;

end STATE;
∞

\newpage
\section{CALCULATOR FUNCTIONS}\label{MATHFUNCTIONS}
Our calculator will have two functions which are not built-in to Ada and Z, namely factorial and integer square root.
In this section, we implement a package provding these two functions.

\subsection{Package Specification}

We define factorial in Z as follows.
πZAX
‹	fact : Ó ≠ Ó
˜¸¸¸¸¸¸
‹	fact 0 = 1 ;
‹ 	µm:Ó∑ fact(m+1) = (m + 1) * fact m
∞
We can then formally specify the required package as follows:

πCN
package MATHS_FUNCTIONS
is
function FACT (M : NATURAL) return NATURAL
    Ñ [ FACT(M) = fact(M) ];

function SQRT (M : NATURAL) return NATURAL
    Ñ [SQRT(M) ** 2 º M < (SQRT(M) + 1) ** 2];

end MATHS_FUNCTIONS;
∞

\subsection{Package Implementation}
We now begin to provide the formal implementation of the package.
\subsubsection{Package Body}
First of all we introduce the package body and prepare for the necessary algorithms.
Our approach for both functions is to introduce and initialise appropriately a variable called $RESULT$, demand that this be set to the desired function return value and return that value.
πCN
package body MATHS_FUNCTIONS
is

function FACT (M : NATURAL) return NATURAL
    Ñ [ FACT(M) = fact(M) ]
is
    RESULT : NATURAL;
begin
    RESULT := 1;
    Ñ RESULT [M æ 0 ± RESULT = 1, RESULT = fact M ]	(1001)
    return RESULT;
end FACT;

function SQRT (M : NATURAL) return NATURAL
    Ñ [SQRT(M) ** 2 º M < (SQRT(M) + 1) ** 2]
is
    RESULT : INTEGER;
   ß other local vars ¢		(2)
begin
   RESULT := 0;
   Ñ RESULT [RESULT = 0, RESULT ** 2 º M < (RESULT + 1) ** 2]	(2001)
  return RESULT;
end SQRT;

end MATHS_FUNCTIONS;
∞

The above results in a number of VCs both to show that the functions achieve what is demanded in the package specification and to show that the function bodies achieve what the functions are to achieve.
We now prove these VCs:


=TEX
=SML
set_pc"cn";
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_1");
a(prove_tac[]);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_1";
=TEX
=SML
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_2");
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_2";
=TEX
We need the following general fact about the data type $NATURAL$:
=SML
set_goal([], Òµm : NATURAL∑ m æ 0Æ);
a(rewrite_tac[z_get_specÒNATURALÆ] THEN REPEAT strip_tac);
val natural_thm = save_pop_thm"natural_thm";
=TEX
=SML
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_3");
a(REPEAT strip_tac THEN all_fc_tac[natural_thm]);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_3";
=TEX
=SML
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_4");
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_4";
=TEX
=SML
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_5");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_5";
=TEX
=SML
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_6");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_6";
=TEX
=SML
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_7");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_7";
=TEX
=SML
set_goal([], get_conjecture"-""vcMATHS_FUNCTIONSbody_8");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
val _ = save_pop_thm "vcMATHS_FUNCTIONSbody_8";
=TEX
\subsubsection{Algorithm for Factorial}
Factorial is implemented by a for-loop with loop-counter $J$ and an invariant requiring that as $J$ steps from $2$ up to $M$, $RESULT$ is kept equal to the factorial of $J$:

πCN
  (1001) √
    for J in INTEGER range 2 .. M
    loop
        Ñ RESULT [J æ 1 ± RESULT = fact (J-1), RESULT = fact J] (1002)
    end loop;
∞
This produces 4 VCs, which we proceed to prove, beginning with a lemma about the first two values of factorial (needed because our algorithm avoids the unnecessary pass through the loop with $J = 1$).

=TEX
=SML
set_goal([], Òfact 0 = 1 ± fact 1 = 1Æ);
a(rewrite_tac[z_get_specÒfactÆ,
	(rewrite_rule[z_get_specÒfactÆ] o z_µ_elimÒ0Æ o
			±_right_elim o ±_right_elim o z_get_spec)ÒfactÆ
]);
val fact_thm  = save_pop_thm"fact_thm";
=TEX
=SML
set_goal([], get_conjecture"-""vc1001_1");
a(REPEAT strip_tac THEN asm_rewrite_tac[fact_thm]);
val _ = save_pop_thm "vc1001_1";
=TEX
=SML
set_goal([], get_conjecture"-""vc1001_2");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒM = 0 ≤ M = 1Æ);
(* *** Goal "1" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[fact_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[fact_thm]);
val _ = save_pop_thm "vc1001_2";
=TEX
=SML
set_goal([], get_conjecture"-""vc1001_3");
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_ante_tacÒ2 º JÆ THEN PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_plus_assoc_thm]);
val _ = save_pop_thm "vc1001_3";
=TEX
=SML
set_goal([], get_conjecture"-""vc1001_4");
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val _ = save_pop_thm "vc1001_4";
=TEX
Now we can complete the implementation of the factorial function by providing the loop body:

πCN
  (1002) √
       RESULT := J * RESULT;
∞
Again this gives rise to a VC which we now prove:
=SML
set_goal([], get_conjecture"-""vc1002_1");
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(lemma_tacÒ∂K:U∑ K + 1 = JÆ);
(* *** Goal "1" *** *)
a(z_∂_tacÒJ - 1Æ THEN PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(rewrite_tac[z_plus_assoc_thm]);
a(ALL_FC_T rewrite_tac[z_get_specÒfactÆ]);
val _ = save_pop_thm "vc1002_1";
=TEX
That completes the implementation and verification of the factorial function.
\subsubsection{Algorithm for Square Root}
For square root, we need two extra variables to implement a binary search for the square root.

=SML
πCN
(2) È
    MID, HI : INTEGER;
∞
The following just says that we propose to achieve the desired effect on $RESULT$ using $MID$ and $HI$ as well.
πCN
(2001) √
        Ñ RESULT, MID, HI
            [RESULT = 0, RESULT ** 2 º M < (RESULT + 1) ** 2] (2002)
∞
=TEX
This produces two very trivial VCs:
=SML
set_goal([], get_conjecture "-" "vc2001_1");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2001_1";
=TEX
=SML
set_goal([], get_conjecture "-" "vc2001_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2001_2";
=TEX
Now we give the initialisation for $HI$ and describe the loop which will find the square root:

πCN
(2002) √
       HI := M + 1;
       till ˚RESULT ** 2 º M < (RESULT + 1) ** 2˝
       loop
           Ñ RESULT, MID, HI
               [RESULT ** 2 º M < HI ** 2, RESULT ** 2 º M < HI ** 2] (2003)
       end loop;
∞
=TEX
This gives us 3 more VCs to prove, which depend on a few mathematical facts about the exponentiation operator:

=TEX
=SML
set_goal([], Òµx: ˙∑  x ** 1 = xÆ);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[](
    z_µ_elimÒ(x ¶ x, y ¶ 0)Æ (±_right_elim(z_get_specÒ(_**_)Æ)))]);
val star_star_1_thm = pop_thm();
=TEX
=SML
set_goal([], Òµx: ˙∑  x ** 2 = x * xÆ);
a(REPEAT strip_tac);
a(rewrite_tac[star_star_1_thm, rewrite_rule[](
    z_µ_elimÒ(x ¶ x, y ¶ 1)Æ (±_right_elim(z_get_specÒ(_**_)Æ)))]);
val star_star_2_thm = pop_thm();
=TEX
=SML
set_goal([], get_conjecture "-" "vc2002_1");
a(REPEAT strip_tac THEN all_fc_tac[natural_thm]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[star_star_1_thm, star_star_2_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN DROP_ASMS_T discard_tac THEN strip_tac);
a(z_º_induction_tacÒMÆ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[star_star_1_thm, star_star_2_thm]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac);
a(rewrite_tac[star_star_2_thm]);
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
val _ = save_pop_thm "vc2002_1";
=TEX
=SML
set_goal([], get_conjecture "-" "vc2002_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2002_2";
=TEX
=SML
set_goal([], get_conjecture "-" "vc2002_3");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2002_3";
=TEX
Now we implement the exit condition for the loop and specify the next step:
πCN
(2003) √
       exit when RESULT + 1 = HI;
       Ñ RESULT, MID, HI
            [RESULT ** 2 º M < HI ** 2, RESULT ** 2 º M < HI ** 2] (2004)
∞
Again we get VCs which we now prove:

=TEX
=SML
set_goal([], get_conjecture "-" "vc2003_1");
a(rewrite_tac[]);
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
val _ = save_pop_thm "vc2003_1";
=TEX
=SML
set_goal([], get_conjecture "-" "vc2003_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2003_2";
=TEX
=SML
set_goal([], get_conjecture "-" "vc2003_3");
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2003_3";
=TEX
Now we can fill in the last part of the loop:
πCN
(2004)    √ 
    MID := (RESULT + HI + 1) / 2;
    if      MID ** 2 > M
    then    HI := MID;
    else    RESULT := MID;
    end if;
∞
=TEX
We now prove the 2 VCs produced, which completes the implementation and verification of the square root function and of the package $MATHS\_FUNCTIONS$.
 
=SML
set_goal([], get_conjecture "-" "vc2004_1");
a(rewrite_tac[star_star_2_thm]);
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2004_1";
=TEX
=SML
set_goal([], get_conjecture "-" "vc2004_2");
a(rewrite_tac[star_star_2_thm]);
a(REPEAT strip_tac);
val _ = save_pop_thm "vc2004_2";
=TEX
\newpage
\section{THE OPERATIONS}

In this section, we define a package which contains procedures corresponding to pressing the calculator buttons.

\subsection{Package Specification}

The package $OPERATIONS$ below defines procedures which implement the following informal description ofhow the calculator responds to button presses:

\begin{quotation}
The behaviour when a digit button is pressed depends on whether a number is currently being entered into the display. If a number is being entered, then the digit is taken as part of the number. If a number is not being entered (e.g., if an operation button has just been pressed), then the digit is taken as the most significant digit of a new number in the display.

When a binary operation button is pressed, any outstanding calculation is carried out and the answer (which will be the first operand of the operation) is  displayed; the calculator is then ready for the user to enter the other operand of the operation.

When a unary operation button is pressed, the result of performing that operation to the displayed number is computed and displayed; the accumulator is unchanged, but entry of the displayed number is considered to be complete.

When the button marked $=$ is pressed, any outstanding calculation is carried out and the answer is displayed.
\end{quotation}

To abbreviate the description of the package, we do some work in Z first, corresponding to the various sorts of button press.
Note that the use of
=INLINEFT
˙
=TEX
\ rather than
=INLINEFT
BASICSoNUMBER
=TEX
\ reflects the fact that we are ignoring questions of arithmetic overflow here.
If we used the Z set which accurately represents the SPARK type, then we would have to add in pre-conditions saying that the operations do not overflow.


ˇ DO_DIGIT ¸¸¸¸¸¸¸¸¸¸¸
‹ IN_NUMBERâ0, IN_NUMBER : BOOLEAN;
‹ DISPLAYâ0, DISPLAY : ˙;
‹ D : BASICSoDIGIT
˜¸¸¸¸¸¸
‹	IN_NUMBERâ0 = TRUE ¥ DISPLAY = DISPLAYâ0*BASICSoBASE + D;
‹	IN_NUMBERâ0 = FALSE ¥  DISPLAY = D;
‹	IN_NUMBER = TRUE
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ UNARY ¶ {BASICSoCHANGE_SIGN, BASICSoFACTORIAL, BASICSoSQUARE_ROOT}
∞
In the following, note that $=$ can be considered as a sort of binary operation (which given $x$ and $y$ returns $x$).

πZ
‹ BINARY ¶ BASICSoOPERATION \ UNARY
∞

ˇ DO_UNARY_OPERATION ¸¸¸¸¸¸¸¸¸¸¸
‹ IN_NUMBER : BOOLEAN;
‹ ACCUMULATORâ0, ACCUMULATOR : ˙;
‹ DISPLAYâ0, DISPLAY : ˙;
‹ O : UNARY
˜¸¸¸¸¸¸
‹	IN_NUMBER = FALSE;
‹	ACCUMULATOR = ACCUMULATORâ0;
‹	O = BASICSoCHANGE_SIGN ¥ DISPLAY = ~DISPLAYâ0;
‹	O = BASICSoFACTORIAL ± DISPLAYâ0 æ 0 ¥ DISPLAY = fact DISPLAYâ0;
‹	O = BASICSoSQUARE_ROOT  ± DISPLAYâ0 æ 0 ¥
‹			DISPLAY ** 2 º DISPLAYâ0 < (DISPLAY + 1) ** 2
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ DO_BINARY_OPERATION ¸¸¸¸¸¸¸¸¸¸¸
‹ IN_NUMBER : BOOLEAN;
‹ ACCUMULATORâ0, ACCUMULATOR : ˙;
‹ DISPLAYâ0, DISPLAY : ˙;
‹ O : BINARY
˜¸¸¸¸¸¸
‹	IN_NUMBER = FALSE;
‹	DISPLAY = ACCUMULATOR;
‹	O = BASICSoEQUALS ¥ ACCUMULATOR = DISPLAYâ0;
‹	O = BASICSoPLUS ¥ ACCUMULATOR = ACCUMULATORâ0 + DISPLAYâ0;
‹	O = BASICSoMINUS ¥ ACCUMULATOR = ACCUMULATORâ0 - DISPLAYâ0;
‹	O = BASICSoTIMES ¥ ACCUMULATOR = ACCUMULATORâ0 * DISPLAYâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ DO_OPERATION ¶ DO_UNARY_OPERATION ≤ DO_BINARY_OPERATION
∞

πCN
with BASICS, STATE;
package OPERATIONS is

    procedure DIGIT_BUTTON (D : in BASICS.DIGIT)
        Ñ STATEoDISPLAY, STATEoIN_NUMBER [
         DO_DIGIT [
           STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
           STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
           D/D ]] ;

    procedure OPERATION_BUTTON (O : in BASICS.OPERATION)
        Ñ STATEoACCUMULATOR, STATEoDISPLAY, STATEoIN_NUMBER [
         DO_OPERATION[
          STATEoACCUMULATORâ0/ACCUMULATORâ0,  STATEoACCUMULATOR/ACCUMULATOR,
          STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
          STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
          D/D ]] ;

end OPERATIONS;
∞

\subsection{Package Implementation}
\subsubsection{Package Body}
In the package body, we will need to use the SPARK factorial and square root functions defined in section \ref{MATHSFUNCTIONS} above (in the specification of the package only the Z factorial function was needed, and this was already available).

πCN
with MATHS_FUNCTIONS;
package body OPERATIONS is

    procedure DIGIT_BUTTON (D : in BASICS.DIGIT)
        Ñ STATEoDISPLAY, STATEoIN_NUMBER [
         DO_DIGIT [
           STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
           STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
           D/D ]]
    is
    begin
        Ñ STATEoDISPLAY, STATEoIN_NUMBER [
         DO_DIGIT [
           STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
           STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
           D/D ]]				(3001)
    end DIGIT_BUTTON;

    procedure OPERATION_BUTTON (O : in BASICS.OPERATION)
        Ñ STATEoACCUMULATOR, STATEoDISPLAY, STATEoIN_NUMBER [
         DO_OPERATION[
          STATEoACCUMULATORâ0/ACCUMULATORâ0,  STATEoACCUMULATOR/ACCUMULATOR,
          STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
          STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
          D/D ]]
    is
    begin
        Ñ STATEoACCUMULATOR, STATEoDISPLAY, STATEoIN_NUMBER [
         DO_OPERATION[
          STATEoACCUMULATORâ0/ACCUMULATORâ0,  STATEoACCUMULATOR/ACCUMULATOR,
          STATEoDISPLAYâ0/DISPLAYâ0,  STATEoDISPLAY/DISPLAY,
          STATEoIN_NUMBERâ0/IN_NUMBERâ0, STATEoIN_NUMBER/IN_NUMBER,
          D/D ]]			(3002)
    end OPERATION_BUTTON;

end OPERATIONS;
∞
=TEX
Introducing the package body gives us 8 very trivial VCs to prove:
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_1");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_1";
=TEX
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_2");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_2";
=TEX
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_3");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_3";
=TEX
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_4");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_4";
=TEX
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_5");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_5";
=TEX
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_6");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_6";
=TEX
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_7");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_7";
=TEX
=SML
set_goal([], get_conjecture"-""vcOPERATIONSbody_8");
a(REPEAT strip_tac);
val _ = save_pop_thm "vcOPERATIONSbody_8";
=TEX
\subsubsection{Digit Button Algorithm}
An if-statement handling the two cases for updating the display, followed by an assignment to the flag should meet the bill here.
πCN
 (3001) √
        if    STATE.IN_NUMBER
        then  STATE.DISPLAY := STATE.DISPLAY * BASICS.BASE + BASICS.NUMBER'(D);
        else  STATE.DISPLAY := BASICS.NUMBER'(D);
        end if;
        STATE.IN_NUMBER := true; 
∞
=TEX
=SML
set_goal([], get_conjecture"-""vc3001_1");
a(REPEAT strip_tac);
a(asm_rewrite_tac[z_get_specÒDO_DIGITÆ]);
a(REPEAT strip_tac);
val _ = save_pop_thm "vc3001_1";
=TEX
=SML
set_goal([], get_conjecture"-""vc3001_2");
a(REPEAT strip_tac);
a(asm_rewrite_tac[z_get_specÒDO_DIGITÆ]);
val _ = save_pop_thm "vc3001_2";
=TEX
\subsubsection{Operation Button Algorithm}
A case statement to handle the different possibilities followed by an assignment to the flag is used here:
πCN
 (3002) √
        case O is
        when BASICS.CHANGE_SIGN .. BASICS.CHANGE_SIGN =>
            STATE.DISPLAY := -STATE.DISPLAY;
        when BASICS.FACTORIAL .. BASICS.FACTORIAL =>
            STATE.DISPLAY := MATHS_FUNCTIONS.FACT(STATE.DISPLAY);
        when BASICS.SQUARE_ROOT .. BASICS.SQUARE_ROOT =>
            STATE.DISPLAY := MATHS_FUNCTIONS.SQRT(STATE.DISPLAY);
        when BASICS.EQUALS .. BASICS.EQUALS =>
            STATE.ACCUMULATOR := STATE.DISPLAY;
            STATE.DISPLAY := STATE.ACCUMULATOR;
        when BASICS.PLUS .. BASICS.PLUS =>
            STATE.ACCUMULATOR := STATE.DISPLAY + STATE.ACCUMULATOR;
            STATE.DISPLAY := STATE.ACCUMULATOR;
        when BASICS.MINUS .. BASICS.MINUS =>
            STATE.ACCUMULATOR := STATE.DISPLAY - STATE.ACCUMULATOR;
            STATE.DISPLAY := STATE.ACCUMULATOR;
        when BASICS.TIMES .. BASICS.TIMES=>
            STATE.ACCUMULATOR := STATE.DISPLAY * STATE.ACCUMULATOR;
            STATE.DISPLAY := STATE.ACCUMULATOR;
        end case;
        STATE.IN_NUMBER := false; 
∞
=TEX
=SML
val basics_defs = map z_get_spec(get_consts"BASICSspec");
val op_defs = map z_get_spec(get_consts"-");
val many_defs = op_defs @ basics_defs;
=TEX
=SML
set_goal([], get_conjecture"-""vc3002_1");
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac many_defs);
val _ = save_pop_thm "vc3002_1";
=TEX
For the next two VCs, it is necessary to make the (reasonable) assumption that non-negative numbers of the precision handled by calculator will fit in a SPARK $NATURAL$.
This amounts to the following axiom:
πZ
‹ BASICSoMAX_NUMBER º INTEGERvLAST
∞
=SML
val number_ax = snd(hd(get_axioms"-"));
=SML
set_goal([], get_conjecture"-""vc3002_2");
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac many_defs);
a(REPEAT strip_tac);
a(lemma_tac ÒSTATEoDISPLAY ç NATURALÆ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 4 ante_tac);
a(ante_tac number_ax);
a(asm_rewrite_tac(z_get_specÒNATURALÆ :: basics_defs));
a(PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_get_specÒMATHS_FUNCTIONSoFACTÆ]);
z_get_specÒMATHS_FUNCTIONSoFACTÆ;


val _ = save_pop_thm "vc3002_2";
=TEX
=SML


=SML
output_z_document{script="wrk507", out_file="wrk507.zdoc"};
output_spark_program{out_file="wrk507.ada"};

val €wrk507_state› = get_cn_state();

=TEX

\pagebreak
%\HOLindexOff
%\input{wrk507.th.tex}
%\HOLindexOn
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}
=IGN

trace_envs();
#w0(#spec(fst (hd(!CNZGenerator.diag_vc_args))));
print_theory"-";


