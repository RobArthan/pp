%  mdt505.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Verification Condition Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT505}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team Member}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Verification Condition Generator as described in the document ISS/HAT/DAZ/DTD505.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library }}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1]
This is the first draft.

\end{description}

\subsection{Changes Forecast}
This document may change when it is reviewed.
\pagebreak

\section{GENERAL}
\subsection{Scope}\label{Scope}

This document comprises test cases and test code/data for
testing the Verification Condition Generator specified in \cite{ISS/HAT/DAZ/DTD508}. Module test cases exist for most of the functionality of the Verification Condition Generator.
A small minority of tests have been deferred to integration testing due to the complex nature of the input test data required.
The functionality not tested comprises testing of VC generation for:

\begin{enumerate}
\item{Procedure call with no initial variables in specification}
\item{Specification statement with initial variables}
\item{For loop with non-static bounds}
\item{Logical constants}
\item{Procedure call with initial variables in specification}
\end{enumerate}

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Verification Condition Generator as defined in \cite{ISS/HAT/DAZ/DTD505} and implemented in \cite{ISS/HAT/DAZ/IMP505}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in \cite{DS/FMU/IED/IMP013}, and its corresponding detailed design document, \cite{DS/FMU/IED/DTD013}. Additionally, the tests make use of utilities defined in \cite{ISS/HAT/DAZ/DTD515} and implemented in \cite{ISS/HAT/DAZ/IMP515}.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies in the defined scope of this document (see section \ref{Scope}).

\section{INITIALISATION}
First we need to load the test harnes and initialise it.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX
\section{PREAMBLE}

Set up the theory database as necessary.

=SML
use_file "dtd515";
use_file "imp515";
open_theory "cn";
force_delete_theory "mdt505" handle (_) => ();
new_theory "mdt505";
=TEX

=SML
local
	open CNParser CNTypes CNTypes2 CNVCGenerator ZUserInterfaceSupport;
in
=TEX

\section{SUPPORTING FUNCTIONS}

The following values are used in the construction of a suitable environment for the tests to take place.

=SML
val €informal_fun› : INFORMAL_FUN = {
		name = "FUNC",
		formal_pars = [{
			mode = MSparkIn,
			var_decl = {vars=["X"],tmark="INTEGER"}
		}],
		return_type = "INTEGER"
	};
=TEX
=SML
val €formal_proc› : FORMAL_PROC = {
		name = "PROC",
		formal_ids = [{
			mode = MSparkIn,
			var_decl = {vars=["X"],tmark="INTEGER"}
		}],
		spec = {w=[], w0=[], pre=z_tm_true, post=z_tm_true}
	};
=TEX
=SML
fun €simple_speclab› (w : Z_ID list, pre : Z_TM, post : Z_TM) : SPECLAB = (
let	val dummy_wp_env : WP_ENV = {
		fun_header = informal_fun,
		return = ÒFUNC (X∫˙) ç 0..10Æ,
		till = ÒtrueÆ,
		formal_procs = [],
		env = env
		};
	fun is_ivar_name n = (
		implode (rev(rev (explode n) to 1)) = "â0"
	);
	fun name_stem n = (
		if	is_ivar_name n
		then	implode (rev(rev (explode n) from 2))
		else	n
	);
	val w0 = map (fn s => s ^"â0") w;
in	{spec = {pre = pre, post = post, w = w, w0 = w0},
		formal_body_flag = true,
		fun_flag = false,
		till_flag = true,
		wp_env = dummy_wp_env,
		in_scope = {
			vc_vars = [{vars=["x"],tmark="INTEGER"}], vc_pars = [],
			vc_log_cons = [], vc_aux_vars = [],
			formal_procs = [formal_proc], dec_labels = []
		}
	}
end
);

=TEX

=SML
fun €vc› (spec : string) (st : string) : VC list = (
let	val speclab = (simple_speclab o cn_specinfo_of_string) spec;
	val statement = cn_statement_of_string st;
in
	vcs(speclab, statement)
end);
=TEX

=SML
fun €vc_eq› ((d1, seq1) : VC, (d2, seq2) : VC) : bool = (
	(all (combine d1 d2) (op =$)) andalso seq1 ~=# seq2
	handle _ => false
); 
=TEX

=SML
fun €vc_list_eq› (vcl1 : VC list, vcl2 : VC list) : bool = (
	all (map vc_eq (combine vcl1 vcl2)) (fn x => x)
);
=TEX


\section{THE TESTS}

Each of the following sections corresponds each kind of statement.
The statements not covered by the following tests are listed in section \ref{Scope}. 
\subsection{Null}

=SML
val vct1 = vc "Ñ [true]";
val arg1 = "NULL;";
val res1 = [([],([ÒtrueÆ],ÒtrueÆ))] : VC list;

val vct2 = vc "Ñ A [A=0, true]";
val arg2 = "NULL;";
val res2 = [([],([ÒA=0Æ],ÒtrueÆ))] : VC list;

val vct3 = vc "Ñ A [A=0, A=0]";
val arg3 = "NULL;";
val res3 = [([],([ÒA=0Æ],ÒA=0Æ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcnull1", vct1, arg1, res1),
("vcnull2", vct2, arg2, res2),
("vcnull3", vct3, arg3, res3)
];

=TEX

\subsection{Assignment}

=SML
val _ = cn_declare "a, b, c : integer;";

val vct1 = vc "Ñ A [A=0]";
val arg1 = "a := 0 ;";
val res1 = [([],([ÒtrueÆ],Ò0=0Æ))] : VC list;

val vct2 = vc "Ñ A [A=0, A=1]";
val arg2 = "a := 1 ;";
val res2 = [([],([ÒA=0Æ],Ò1=1Æ))] : VC list;

val vct3 = vc "Ñ A {A=0}";
val arg3 = "a := 0 ;";
val res3 = [([],([ÒA=0Æ],ÒtrueÆ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcassign1", vct1, arg1, res1),
("vcassign2", vct2, arg2, res2),
("vcassign3", vct3, arg3, res3)

];

=TEX

=SML
val _ = cn_declare "TYPE day IS (mon,tue,wed,thu,fri,sat,sun);";
val _ = cn_declare "TYPE arr IS ARRAY (day) OF integer;";
val _ = cn_declare "hours : arr;";
val _ = cn_declare "d : day;";

val vct1 = vc "Ñ HOURS, MON [HOURS(MON) = 7]";
val arg1 = "hours(mon) := 7 ;";
val res1 = [([],([ÒtrueÆ],Ò(HOURS ´ {MON Ì 7}) MON = 7Æ))] : VC list;

val vct2 = vc "Ñ HOURS, SUN, MON [HOURS(MON) > HOURS(SUN)]";
val arg2 = "hours(mon) := hours(sun) + 1 ;";
val res2 = [([],([ÒtrueÆ],
	Ò(HOURS ´ {MON Ì HOURS(SUN) + 1}) MON
             > (HOURS ´ {MON Ì HOURS(SUN) + 1}) SUNÆ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcarrassign1", vct1, arg1, res1),
("vcarrassign2", vct2, arg2, res2)
];

=TEX
=SML
val _ = cn_declare "TYPE complex IS RECORD r, i : integer; END RECORD;";
val _ = cn_declare "comp : complex;";
val _ = change_env "COMPLEX" CNBasicDeclsAndExprs.EIEnvRecordType;
val vct1 = vc "Ñ COMP [(COMP∫COMPLEX).R = 1]";
val arg1 = "comp.r := 1 ;";
val res1 = [([],([ÒtrueÆ],
	Ò(Õ COMPLEX | I = (COMP∫COMPLEX).I ± R = 1 ∑  COMPLEX).R = 1Æ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcrecassign1", vct1, arg1, res1)
];

=TEX

\subsection{Specification Statement (No Initial Variables)}

=SML

val vct1 = vc "Ñ A [A æ 0]";
val arg1 = "Ñ A [A ç 128..255] (100)";
val res1 = [
	([],([ÒtrueÆ], ÒtrueÆ)),
	([],([ÒtrueÆ, ÒA ç 128 .. 255Æ], ÒA æ 0Æ))
] : VC list;

val vct2 = vc "Ñ A [A = 0, A = Aâ0 + 1]";
val arg2 = "Ñ A [A = 1] (100)";
val res2 = [
	([],([ÒA = 0Æ], ÒtrueÆ)),
	([],([ÒAâ0 = 0Æ, ÒA = 1Æ], ÒA = Aâ0 + 1Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcspec1", vct1, arg1, res1),
("vcspec2", vct2, arg2, res2)
];

=TEX
\subsection{Semicolon}

=SML

val vct1 = vc "Ñ A, B [A = 1, B = 0]";
val arg1 = "a := 0; b := a;";
val res1 = [([],([ÒA = 1Æ], Ò0 = 0Æ))] : VC list;

val vct2 = vc "Ñ A, B [A = 0, A = Aâ0 + 1]";
val arg2 = "b := a; a := b + 1 - a;";
val res2 = [([],([ÒA = 0Æ], ÒA + 1 - A = A + 1Æ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcsemicolon1", vct1, arg1, res1),
("vcsemicolon2", vct2, arg2, res2)
];

=TEX
\subsection{If Statement}

=SML

val vct1 = vc "Ñ A [A=0]";
val arg1 = "IF true THEN a := 0; END IF;";
val res1 = [
	([], ([ÒtrueÆ, ÒTRUE = TRUEÆ], Ò0 = 0Æ)),
	([], ([ÒtrueÆ, ÒTRUE = FALSEÆ], ÒA = 0Æ))
] : VC list;

val vct2 = vc "Ñ A, B [A=0, B=0]";
val arg2 = "IF a > 0 THEN b := 1; ELSE b := 0; END IF;";
val res2 = [
	([], ([ÒA = 0Æ, ÒA greater 0 = TRUEÆ], Ò1 = 0Æ)),
	([], ([ÒA = 0Æ, ÒA greater 0 = FALSEÆ], Ò0 = 0Æ))
] : VC list;

val vct3 = vc "Ñ A, B [A=0, B=0]";
val arg3 = "\
\	IF a < 0 THEN \
\		b := -1; \
\	ELSIF a = 0 THEN \
\		b := 0; \
\	ELSE b := 1; \
\	END IF; \
\";

val res3 = [
	([], ([ÒA = 0Æ, ÒA less 0 = TRUEÆ], Ò~ 1 = 0Æ)),
	([], ([ÒA = 0Æ, ÒA less 0 = FALSEÆ, ÒA eq 0 = TRUEÆ], Ò0 = 0Æ)),
	([], ([ÒA = 0Æ, ÒA less 0 = FALSEÆ, ÒA eq 0 = FALSEÆ], Ò1 = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcif1", vct1, arg1, res1),
("vcif2", vct2, arg2, res2),
("vcif3", vct3, arg3, res3)
];

=TEX
\subsection{Case Statement}

=SML

val vct1 = vc "Ñ A, B, C, D, SUN [A = 0 ± B = 0 ± C = 1, D = SUN]";
val arg1 = "\
\	CASE a IS \
\		WHEN b =>	d := sun; \
\		WHEN c =>	d := mon; \
\	END CASE; \
\";
val res1 = [
	([], ([ÒA = 0 ± B = 0 ± C = 1Æ, ÒA ç {B∫˙}Æ], ÒSUN = SUNÆ)),
	([], ([ÒA = 0 ± B = 0 ± C = 1Æ, ÒA ç {C∫˙}Æ], ÒMON = SUNÆ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vccase1", vct1, arg1, res1)
];

=TEX

\subsection{Undecorated Loop}

The following result is interesting because the refinement can establis the result false!
=SML

val vct1 = vc "Ñ [false]";
val arg1 = "\
\	LOOP \
\		Ñ [A = 0] (100) \
\	END LOOP; \
\";
val res1 = [
	([], ([ÒtrueÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA = 0Æ], ÒtrueÆ))
	] : VC list;

val vct2 = vc "Ñ A [A > 0]";
val arg2 = "\
\	TILL ˚A = 10˝ \
\	LOOP \
\		Ñ A [A=0] (100) \
\	END LOOP; \
\";
val res2 = [
	([], ([ÒtrueÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA = 0Æ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA = 10Æ], ÒA > 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcloop1", vct1, arg1, res1),
("vcloop2", vct2, arg2, res2)
];

=TEX

\subsection{While Loop}
=SML

val vct1 = vc "Ñ A [A = 0]";
val arg1 = "\
\	WHILE a /= 0 \
\	LOOP \
\		Ñ A [A = 0] (100) \
\	END LOOP; \
\";
val res1 = [
	([], ([ÒtrueÆ, ÒA noteq 0 = TRUEÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA noteq 0 = FALSEÆ], ÒA = 0Æ)),
	([], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 0 = TRUEÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 0 = FALSEÆ], ÒA = 0Æ))
] : VC list;

val vct2 = vc "Ñ A, B [A = 10 ± B = 0]";
val arg2 = "\
\	WHILE a /= 10 \
\	TILL ˚B = 0˝ \
\	LOOP \
\		Ñ A [A=0] (100) \
\	END LOOP; \
\";
val res2 = [
	([], ([ÒtrueÆ, ÒA noteq 10 = TRUEÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA noteq 10 = FALSEÆ], ÒA = 10 ± B = 0Æ)),
	([], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 10 = TRUEÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 10 = FALSEÆ], ÒA = 10 ± B = 0Æ)),
	([], ([ÒtrueÆ, ÒB = 0Æ], ÒA = 10 ± B = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcwhile1", vct1, arg1, res1),
("vcwhile2", vct2, arg2, res2)
];

=TEX

\subsection{For Loop (Static Bounds)}

=SML

val vct1 = vc "Ñ A [A = 0]";
val arg1 = "\
\	FOR c IN integer RANGE 1..10 \
\	LOOP \
\		Ñ A [A = 0] (100) \
\	END LOOP; \
\";
val res1 = [
	([], ([ÒtrueÆ, Ò1 º 10Æ], ÒtrueÆ)),
	([], ([ÒtrueÆ, Ò1 > 10Æ], ÒA = 0Æ)),
	([], ([ÒtrueÆ, ÒC ç 1 .. 10Æ, ÒC Ω 10Æ, ÒA = 0Æ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA = 0Æ], ÒA = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcforstatic1", vct1, arg1, res1)
];
=TEX

\subsection{For Loop (Type Mark as Range)}

=SML
val vct1 = vc "Ñ A [A = 0]";
val arg1 = "\
\	FOR c IN day \
\	LOOP \
\		Ñ A [A = 0] (100) \
\	END LOOP; \
\";
val res1 = [
	([], ([ÒtrueÆ, ÒDAYvFIRST º DAYvLASTÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒDAYvFIRST > DAYvLASTÆ], ÒA = 0Æ)),
	([], ([ÒtrueÆ, ÒC Ω DAYvLASTÆ, ÒA = 0Æ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA = 0Æ], ÒA = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcfortmark1", vct1, arg1, res1)
];

=TEX

\subsection{Exit Statement (with Condition)}

=SML
val vct1 = vc "Ñ [true]";
val arg1 = "EXIT WHEN ˚A eq 0˝;";
val res1 = [
	([], ([ÒtrueÆ, ÒA eq 0 = TRUEÆ], ÒtrueÆ)),
	([], ([ÒtrueÆ, ÒA eq 0 = FALSEÆ], ÒtrueÆ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcexitwhen1", vct1, arg1, res1)
];

=TEX

\subsection{Exit Statement}

=SML
val vct1 = vc "Ñ [true]";
val arg1 = "EXIT;";
val res1 = [
	([], ([ÒtrueÆ], ÒtrueÆ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcexit1", vct1, arg1, res1)
];

=TEX

\subsection{Return Statement}

=SML
val _ = cn_declare "FUNCTION func (x : integer) RETURN integer;";
val _ = cn_declare "x : integer;";
val vct1 = vc "Ñ [true]";
val arg1 = "RETURN 0;";
val res1 = [
	([], ([ÒtrueÆ, ÒFUNC X = 0Æ], ÒFUNC X ç 0 .. 10Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcreturn1", vct1, arg1, res1)
];

=TEX

\section{SUMMARY OF RESULTS}

=SML
end (* local...in *);

diag_line(summarize_mt_results());

=TEX

\end{document}
=IGN
vc "Ñ [B=A]" "CON x : ˙ ∑ Ñ [x=A ± true, true]"; (* wrong *)
=TEX


(simple_speclab o cn_specinfo_of_string) "Ñ A[A = Aâ0]";
val vct2 = vc "Ñ A [A = Aâ0]";
val arg2 = "nuLL;";

vct2 arg2;





