=IGN
********************************************************************************
mdt505.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% $Header: /home/rda/daz/RCS/mdt505.doc,v 1.35 2006/09/18 16:09:35 rda Exp rda $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Verification Condition Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT505}  %% Mandatory field
\def\SCCSversion{$Revision: 1.35 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/09/18 16:09:35 $
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team Member}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Verification Condition Generator as described in the document ISS/HAT/DAZ/DTD505.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library }}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1-1.8]
Under development for V0.5 tool.
\item[Issue 1.9]
Revision for V0.5.X enhancements.
\item[Issue 1.10]
Update for SML'97.
\item[Issue 1.11]
Update for June 2000 enhancements.
\item[Issue 1.12]
Update for CTLE II enhancement (``others'' in case statements).
\item[Issue 1.13]
Update for CTLE II enhancement (reverse loops).
\item[Issue 1.14] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.15] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.16] R0056: default parameter modes supported properly.
\item[Issue 1.17] vcs now returns type-checked pre- and post-conditions.
\item[Issue 1.18] Spring 2002 enhancements: return and exit statements.
\item[Issue 1.19] Corrected invalid renaming example that is now detected properly.
\item[Issue 1.20] {\it renamings} now called {\it var\_renamings}.
\item[Issue 1.21] Allowed for change to signature of the function {vcs}.
\item[Issue 1.22] R0054: reworked treatment of use clauses.
\item[Issue 1.23] R0051: default parameters (accommodated changed ML types).
\item[Issue 1.24] Copyright and banner updates for open source release.
\item[Issue 1.25] DAZ-specific updates to banner for open source release
\item[Issue 1.26] DAZ-specific updates to banner for open source release
\item[Issue 1.27] Allowed for changes to DTD515 and the environment reforms (which cause most of these test cases to get the proper declarations, which they did not with the previous test harness set up).
\item[Issue 1.28] Using clauses now allowed anywhere in package body.
\item[Issue 1.27] Allowed for new representation of procedures in the environment.
\item[Issue 1.28] Compliance Notation reserved words are now prefixed by a dollar sign.
\item[Issue 1.29] Allowed for changes to {\em cn\_declare}.
\item[Issue 1.32] Allowed for automated state management.
\item[Issue 1.33] Allowed for new uniform checks on Z names
\item[Issue 1.34] Allowed for enhanced {\em check\_1\_b}.
\item[Issue 1.35] Allowed for changed to type of block names.
\end{description}

\subsection{Changes Forecast}
This document may change when it is reviewed.
\pagebreak

\section{GENERAL}
\subsection{Scope}\label{Scope}

This document comprises test cases and test code/data for
testing the Verification Condition Generator specified in \cite{ISS/HAT/DAZ/DTD508}. Module test cases exist for most of the functionality of the Verification Condition Generator.
Some test cases have been deferred to integration testing due to the complex nature of the input test data required.
The functionality not tested comprises testing of VC generation for:

\begin{enumerate}
\item{Procedure call with no initial variables in specification}
\item{Specification statement with initial variables}
\item{For loop with non-static bounds}
\item{Logical constants}
\item{Procedure call with initial variables in specification}
\end{enumerate}

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Verification Condition Generator as defined in \cite{ISS/HAT/DAZ/DTD505} and implemented in \cite{ISS/HAT/DAZ/IMP505}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in \cite{DS/FMU/IED/IMP013}, and its corresponding detailed design document, \cite{DS/FMU/IED/DTD013}. Additionally, the tests make use of utilities defined in \cite{ISS/HAT/DAZ/DTD515} and implemented in \cite{ISS/HAT/DAZ/IMP515}.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies in the defined scope of this document (see section \ref{Scope}).

\section{INITIALISATION}
First we need to load the test harnes and initialise it.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX
\section{PREAMBLE}

Set up the theory database as necessary.

=SML
use_file "dtd515";
use_file "imp515";
open_theory "cn";
force_delete_theory "mdt505" handle (_) => ();
new_theory "mdt505";
=TEX

=SML
	open CNParser CNTypes CNTypes2 CNVCGenerator ZUserInterfaceSupport;
=TEX

\section{SUPPORTING FUNCTIONS}

The following values are used in the construction of a suitable environment for the tests to take place.

=SML
val €informal_fun› : INFORMAL_FUN = {
		name = "FUNC",
		formal_pars = [{
			mode = MSparkIn true,
			var_decl = {vars=["X"],tmark="INTEGER"}
		}],
		par_names_defs = [("X", Nil)],
		return_type = "INTEGER"
	};
=TEX
=SML
val €formal_proc› : FORMAL_PROC = {
		name = "PROC",
		formal_ids = [{
			mode = MSparkIn true,
			var_decl = {vars=["X"],tmark="INTEGER"}
		}],
		globals = [],
		par_names_defs = [("X", Nil)],
		spec = {w=[], w0=[], pre=z_tm_true, post=z_tm_true}
	};
=TEX
=SML
fun €simple_speclab› (fun_flag : bool) (w : Z_ID list, pre : Z_TM, post : Z_TM) : SPECLAB = (
let	val dummy_wp_env : WP_ENV = {
		fun_header = informal_fun,
		return = ÒFUNC (X∫˙) ç 0..10Æ,
		till = ÒtrueÆ,
		named_tills = [],
		env = env
		};
	fun is_ivar_name n = (
		implode (rev(rev (explode n) to 1)) = "â0"
	);
	fun name_stem n = (
		if	is_ivar_name n
		then	implode (rev(rev (explode n) from 2))
		else	n
	);
	val w0 = map (fn s => s ^"â0") w;
in	{spec = {pre = pre, post = post, w = w, w0 = w0},
		formal_body_flag = true,
		fun_flag = fun_flag,
		till_flag = true,
		wp_env = dummy_wp_env,
		block_name = [Value "Boo!"],
		in_scope = {
			dict =
			add_to_env_dict initial_env_dict
	[ ( "X", {
		tipe = Value î˙Æ,
		canon_name = "X",
		info =EIEnvVar { kind = VKVar, tmark = "INTEGER" } } ),
	( "PROC", {
		tipe = Nil,
		canon_name = "PROC",
		info =EIEnvProcedure { formal_proc = Value formal_proc } } )	] ,
			dec_labels = []
		}
	}
end
);
=TEX
=SML
fun €vc› (spec : string) (st : string) : VC list = (
let	val speclab = (simple_speclab false o cn_specinfo_of_string) spec;
	val statement = cn_statement_of_string st;
in
	map (fn(a,_)=>a) (fst(vcs(speclab, statement)))
end);
=TEX
=SML
fun €vcf› (spec : string) (st : string) : VC list = (
let	val speclab = (simple_speclab true o cn_specinfo_of_string) spec;
	val statement = cn_statement_of_string st;
in
	map (fn(a,_)=>a) (fst(vcs(speclab, statement)))
end);
=TEX

=SML
fun €vc_eq› ((d1, seq1) : VC, (d2, seq2) : VC) : bool = (
	(all (combine d1 d2) (op =$)) andalso seq1 ~=# seq2
	handle _ => false
); 
=TEX

=SML
fun €vc_list_eq› (vcl1 : VC list, vcl2 : VC list) : bool = (
	all (map vc_eq (combine vcl1 vcl2)) (fn x => x)
);
=TEX


\section{THE TESTS}

Each of the following sections corresponds each kind of statement.
The statements not covered by the following tests are listed in section \ref{Scope}. 
\subsection{Null}

=SML
val _ = cn_declare [] "a, b, c : integer;";
val vct1 = vc "Ñ [true]";
val arg1 = "NULL;";
val res1 = [([],([ÒtrueÆ],ÒtrueÆ))] : VC list;

val vct2 = vc "Ñ A [A=0, true]";
val arg2 = "NULL;";
val res2 = [([Òëdec_ofÒ[A : INTEGER]ÆÆÆ],([ÒA=0Æ],ÒtrueÆ))] : VC list;

val vct3 = vc "Ñ A [A=0, A=0]";
val arg3 = "NULL;";
val res3 = [([Òëdec_ofÒ[A : INTEGER]ÆÆÆ],([ÒA=0Æ],ÒA=0Æ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcnull1", vct1, arg1, res1),
("vcnull2", vct2, arg2, res2),
("vcnull3", vct3, arg3, res3)
];

=TEX

\subsection{Assignment}

=SML

val vct1 = vc "Ñ A [A=0]";
val arg1 = "a := 0 ;";
val res1 = [([],([ÒtrueÆ],Ò0=0Æ))] : VC list;

val vct2 = vc "Ñ A [A=0, A=1]";
val arg2 = "a := 1 ;";
val res2 = [([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒA=0Æ],Ò1=1Æ))] : VC list;

val vct3 = vc "Ñ A {A=0}";
val arg3 = "a := 0 ;";
val res3 = [([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒA=0Æ],ÒtrueÆ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcassign1", vct1, arg1, res1),
("vcassign2", vct2, arg2, res2),
("vcassign3", vct3, arg3, res3)

];

=TEX

=SML
val _ = cn_declare [] "TYPE day IS (mon,tue,wed,thu,fri,sat,sun);";
val _ = cn_declare [] "TYPE arr IS ARRAY (day) OF integer;";
val _ = cn_declare [] "hours : arr;";
val _ = cn_declare [] "d : day;";

val vct1 = vc "Ñ HOURS, MON [HOURS(MON) = 7]";
val arg1 = "hours(mon) := 7 ;";
val res1 = [([ëdec_ofÒ[HOURS : ARR]ÆÆ],([ÒtrueÆ],Ò(HOURS ´ {MON Ì 7}) MON = 7Æ))] : VC list;

val vct2 = vc "Ñ HOURS, SUN, MON [HOURS(MON) > HOURS(SUN)]";
val arg2 = "hours(mon) := hours(sun) + 1 ;";
val res2 = [([ëdec_ofÒ[HOURS : ARR]ÆÆ],([ÒtrueÆ],
	Ò(HOURS ´ {MON Ì HOURS(SUN) + 1}) MON
             > (HOURS ´ {MON Ì HOURS(SUN) + 1}) SUNÆ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcarrassign1", vct1, arg1, res1),
("vcarrassign2", vct2, arg2, res2)
];

=TEX
=SML
val _ = cn_declare [] "TYPE complex IS RECORD r, i : integer; END RECORD;";
val _ = cn_declare [] "comp : complex;";
val _ = change_env "COMPLEX"
		{
			tipe = Value(type_ofÒCOMPLEXÆ),
			canon_name = "COMPLEX",
			info = EIEnvRecordType  {
				comp_names = ["R", "I"],
				num_discs = 0 } } ;
val vct1 = vc "Ñ COMP [(COMP∫COMPLEX).R = 1]";
val arg1 = "comp.r := 1 ;";
val res1 = [([ëdec_ofÒ[COMP : COMPLEX]ÆÆ],([ÒtrueÆ],
	Ò(COMPLEXuR(COMP∫COMPLEX, 1)).R = 1Æ))] : VC list;
val _ = store_mt_results (mt_runf vc_list_eq) [
("vcrecassign1", vct1, arg1, res1)
];
=TEX

\subsection{Specification Statement (No Initial Variables)}

=SML

val vct1 = vc "Ñ A [A æ 0]";
val arg1 = "Ñ A [A ç 128..255] (100)";
val res1 = [
	([],([ÒtrueÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒtrueÆ, ÒA ç 128 .. 255Æ], ÒA æ 0Æ))
] : VC list;

val vct2 = vc "Ñ A [A = 0, A = Aâ0 + 1]";
val arg2 = "Ñ A [A = 1] (100)";
val res2 = [
	([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒA = 0Æ], ÒtrueÆ)),
	([ëdec_ofÒ[A, Aâ0 : INTEGER]ÆÆ],([ÒAâ0 = 0Æ, ÒA = 1Æ], ÒA = Aâ0 + 1Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcspec1", vct1, arg1, res1),
("vcspec2", vct2, arg2, res2)
];

=TEX
\subsection{Semicolon}

=SML

val vct1 = vc "Ñ A, B [A = 1, B = 0]";
val arg1 = "a := 0; b := a;";
val res1 = [([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒA = 1Æ], Ò0 = 0Æ))] : VC list;

val vct2 = vc "Ñ A, B [A = 0, A = Aâ0 + 1]";
val arg2 = "b := a; a := b + 1 - a;";
val res2 = [([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒA = 0Æ], Ò(A + 1) - A = A + 1Æ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcsemicolon1", vct1, arg1, res1),
("vcsemicolon2", vct2, arg2, res2)
];

=TEX
\subsection{If Statement}

=SML

val vct1 = vc "Ñ A [A=0]";
val arg1 = "IF true THEN a := 0; END IF;";
val res1 = [
	([], ([ÒtrueÆ, ÒTRUE = TRUEÆ], Ò0 = 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒTRUE = FALSEÆ], ÒA = 0Æ))
] : VC list;

val vct2 = vc "Ñ A, B [A=0, B=0]";
val arg2 = "IF a > 0 THEN b := 1; ELSE b := 0; END IF;";
val res2 = [
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒA = 0Æ, ÒA greater 0 = TRUEÆ], Ò1 = 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒA = 0Æ, ÒA greater 0 = FALSEÆ], Ò0 = 0Æ))
] : VC list;

val vct3 = vc "Ñ A, B [A=0, B=0]";
val arg3 = "\
\       IF a < 0 THEN \
\               b := -1; \
\       ELSIF a = 0 THEN \
\               b := 0; \
\       ELSE b := 1; \
\       END IF; \
\";

val res3 = [
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒA = 0Æ, ÒA less 0 = TRUEÆ], Ò~ 1 = 0Æ)),
	([ëdec_ofÒ[A: INTEGER]ÆÆ], ([ÒA = 0Æ, ÒA less 0 = FALSEÆ, ÒA eq 0 = TRUEÆ], Ò0 = 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒA = 0Æ, ÒA less 0 = FALSEÆ, ÒA eq 0 = FALSEÆ], Ò1 = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcif1", vct1, arg1, res1),
("vcif2", vct2, arg2, res2),
("vcif3", vct3, arg3, res3)
];

=TEX
\subsection{Case Statement}

=SML

val vct1 = vc "Ñ A, B, C, D, SUN [A = 0 ± B = 0 ± C = 1, D = SUN]";
val arg1 = "\
\       CASE a IS \
\               WHEN b =>       d := sun; \
\               WHEN c =>       d := mon; \
\       END CASE; \
\";
val res1 = [
	([ëdec_ofÒ[A, B, C : INTEGER]ÆÆ], ([ÒA = 0 ± B = 0 ± C = 1Æ, ÒA ç {B∫˙}Æ], ÒSUN = SUNÆ)),
	([ëdec_ofÒ[A, B, C : INTEGER]ÆÆ], ([ÒA = 0 ± B = 0 ± C = 1Æ, ÒA ç {C∫˙}Æ], ÒMON = SUNÆ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vccase1", vct1, arg1, res1)
];

=TEX
=SML

val vct2 = vc "Ñ A, B, C, D, SUN [A = 0 ± B = 0 ± C = 1, D = SUN]";
val arg2 = "\
\       CASE a IS \
\               WHEN b =>       d := sun; \
\               WHEN c =>       d := mon; \
\               WHEN others =>  d := tue; \
\       END CASE; \
\";
val res2 = [
	([ëdec_ofÒ[A, B, C : INTEGER]ÆÆ], ([ÒA = 0 ± B = 0 ± C = 1Æ, ÒA ç {B∫˙}Æ], ÒSUN = SUNÆ)),
	([ëdec_ofÒ[A, B, C : INTEGER]ÆÆ], ([ÒA = 0 ± B = 0 ± C = 1Æ, ÒA ç {C∫˙}Æ], ÒMON = SUNÆ)),
	([ëdec_ofÒ[A, B, C : INTEGER]ÆÆ], ([ÒA = 0 ± B = 0 ± C = 1Æ, ÒA é {B∫˙} ¿ {C}Æ], ÒTUE = SUNÆ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vccase2", vct2, arg2, res2)
];

=TEX

\subsection{Undecorated Loop}

The following result is interesting because the refinement can establis the result false!
=SML

val vct1 = vc "Ñ [false]";
val arg1 = "\
\       LOOP \
\               Ñ [A = 0] (100) \
\       END LOOP; \
\";
val res1 = [
	([], ([ÒtrueÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ], ÒtrueÆ))
	] : VC list;

val vct2 = vc "Ñ A [A > 0]";
val arg2 = "\
\       $TILL ˚A = 10˝ \
\       LOOP \
\               Ñ A [A=0] (100) \
\       END LOOP; \
\";
val res2 = [
	([], ([ÒtrueÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ], ÒtrueÆ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 10Æ], ÒA > 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcloop1", vct1, arg1, res1),
("vcloop2", vct2, arg2, res2)
];

=TEX

\subsection{While Loop}
=SML

val vct1 = vc "Ñ A [A = 0]";
val arg1 = "\
\       WHILE a /= 0 \
\       LOOP \
\               Ñ A [A = 0] (100) \
\       END LOOP; \
\";
val res1 = [
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA noteq 0 = TRUEÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA noteq 0 = FALSEÆ], ÒA = 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 0 = TRUEÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 0 = FALSEÆ], ÒA = 0Æ))
] : VC list;

val vct2 = vc "Ñ A, B [A = 10 ± B = 0]";
val arg2 = "\
\       WHILE a /= 10 \
\       $TILL ˚B = 0˝ \
\       LOOP \
\               Ñ A [A=0] (100) \
\       END LOOP; \
\";
val res2 = [
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA noteq 10 = TRUEÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A, B : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA noteq 10 = FALSEÆ], ÒA = 10 ± B = 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 10 = TRUEÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A, B : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ, ÒA noteq 10 = FALSEÆ], ÒA = 10 ± B = 0Æ)),
	([ëdec_ofÒ[A, B : INTEGER]ÆÆ], ([ÒtrueÆ, ÒB = 0Æ], ÒA = 10 ± B = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcwhile1", vct1, arg1, res1),
("vcwhile2", vct2, arg2, res2)
];

=TEX

\subsection{For Loop (Static Bounds)}

=SML

val vct1 = vc "Ñ A [A = 0]";
val arg1 = "\
\       FOR c IN integer RANGE 1..10 \
\       LOOP \
\               Ñ A [C > 0, A = 0] (100) \
\       END LOOP; \
\";

val res1 = [
	([],([ÒtrueÆ,Ò1 º 10Æ],Ò1 > 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒtrueÆ,Ò1 > 10Æ],ÒA = 0Æ)),
	([ëdec_ofÒ[A, C : INTEGER]ÆÆ],([ÒtrueÆ,ÒC ç 1 .. 10Æ,ÒC Ω 10Æ,ÒA = 0Æ],ÒC + 1 > 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒtrueÆ,ÒA = 0Æ],ÒA = 0Æ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcforstatic1", vct1, arg1, res1)
];
=TEX

=SML

val vct2 = vc "Ñ A [A = 1]";
val arg2 = "\
\       FOR c IN reverse integer RANGE 1..10 \
\       LOOP \
\               Ñ A [C > 0, A = C] (100) \
\       END LOOP; \
\";
val res2 = 
  [([],([ÒtrueÆ,Ò1 º 10Æ],Ò10 > 0Æ)),
   ([ëdec_ofÒ[A : INTEGER]ÆÆ],([ÒtrueÆ,Ò1 > 10Æ],ÒA = 1Æ)),
   ([ëdec_ofÒ[A, C : INTEGER]ÆÆ],([ÒtrueÆ,ÒC ç 1 .. 10Æ,ÒC Ω 1Æ,ÒA = CÆ],ÒC - 1 > 0Æ)),
   ([ëdec_ofÒ[A, C : INTEGER]ÆÆ],([ÒtrueÆ,ÒA = CÆ],ÒA = 1Æ))] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcforstatic2", vct2, arg2, res2)
];
=TEX

\subsection{For Loop (Type Mark as Range)}

=SML
val vct1 = vc "Ñ A [A = 0]";
val arg1 = "\
\       FOR c IN day \
\       LOOP \
\               Ñ A [C æ 0, A = 0] (100) \
\       END LOOP; \
\";
val res1 = [
	([], ([ÒtrueÆ, ÒDAYvFIRST º DAYvLASTÆ], ÒDAYvFIRST æ 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒDAYvFIRST > DAYvLASTÆ], ÒA = 0Æ)),
	([ëdec_ofÒ[A, C : INTEGER]ÆÆ], ([ÒtrueÆ, ÒC Ω DAYvLASTÆ, ÒA = 0Æ], ÒC + 1 æ 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ], ÒA = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcfortmark1", vct1, arg1, res1)
];

=TEX

=SML
val vct2 = vc "Ñ A [A = 0]";
val arg2 = "\
\       FOR c IN reverse day \
\       LOOP \
\               Ñ A [C æ 0, A = 0] (100) \
\       END LOOP; \
\";
val res2 = [
	([], ([ÒtrueÆ, ÒDAYvFIRST º DAYvLASTÆ], ÒDAYvLAST æ 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒDAYvFIRST > DAYvLASTÆ], ÒA = 0Æ)),
	([ëdec_ofÒ[A, C : INTEGER]ÆÆ], ([ÒtrueÆ, ÒC Ω DAYvFIRSTÆ, ÒA = 0Æ], ÒC - 1 æ 0Æ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA = 0Æ], ÒA = 0Æ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcfortmark2", vct2, arg2, res2)
];

=TEX

\subsection{Exit Statement (with Condition)}

=SML
val vct1 = vc "Ñ [true]";
val arg1 = "EXIT WHEN ˚A eq 0˝;";
val res1 = [
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA eq 0 = TRUEÆ], ÒtrueÆ)),
	([ëdec_ofÒ[A : INTEGER]ÆÆ], ([ÒtrueÆ, ÒA eq 0 = FALSEÆ], ÒtrueÆ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcexitwhen1", vct1, arg1, res1)
];

=TEX

\subsection{Exit Statement}

=SML
val vct1 = vc "Ñ [true]";
val arg1 = "EXIT;";
val res1 = [
	([], ([ÒtrueÆ], ÒtrueÆ))
] : VC list;

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcexit1", vct1, arg1, res1)
];

=TEX

\subsection{Return Statement}
In a real example, things would be set up so that $FUNC$ would be a variable in this VC.
=SML
val res1 = [
	([ëdec_ofÒ[X : INTEGER]ÆÆ, Òëdec_ofÒ[FUNC : INTEGER ≠ INTEGER]ÆÆÆ], ([ÒtrueÆ, ÒFUNC (X ∫ INTEGER) = 0Æ], ÒFUNC (X ∫ INTEGER)  ç 0 .. 10Æ))
] : VC list;
val _ = cn_declare [] "FUNCTION func (x : integer) RETURN integer;";
val _ = cn_declare [] "x : integer;";
val vct1 = vcf "Ñ [true]";
val arg1 = "RETURN 0;";

val _ = store_mt_results (mt_runf vc_list_eq) [
("vcreturn1", vct1, arg1, res1)
];

=TEX

\section{SUMMARY OF RESULTS}

=SML

diag_line(summarize_mt_results());

=TEX

\end{document}
=IGN
vc "Ñ [B=A]" "$CON x : ˙ ∑ Ñ [x=A ± true, true]"; (* wrong *)
=TEX





