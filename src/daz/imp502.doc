% imp502.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Compliance Notation Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD502}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE}
=SML
structure €CNTypes› : CNTypes = struct
=TEX

\section{LEXIS}
The following data type represents the lexical classes which are the
terminals of the grammar:
$SpecificationStatement$ is not a terminal and the syntax of a specification statement is part of the grammar. The Z predicates for pre- and post-condition are terminals and are captured by the $Z$ type constructor. Other terminals required are:
=SML
datatype €CN_LEX_CLASS›
			=	€LCAbstractExpression›
			|	€LCAbs›
			|	€LCAmpersand›
			|	€LCAnd›
			|	€LCArray›
			|	€LCAt›
			|	€LCBar›
			|	€LCBBody›
			|	€LCBecomes›
			|	€LCBegin›
			|	€LCCase›
			|	€LCCharacterLiteral›
			|	€LCColon›
			|	€LCComma›
			|	€LCCompLabel›
			|	€LCConstant›
			|	€LCCon›
			|	€LCCrd›
			|	€LCDecLabel›
			|	€LCDelta›
			|	€LCDigits›
			|	€LCDiv›
			|	€LCDotDot›
			|	€LCDot›
			|	€LCElse›
			|	€LCElsIf›
			|	€LCEnd›
			|	€LCEquals›
			|	€LCExit›
			|	€LCFatDot›
			|	€LCFor›
			|	€LCFunctionName›
			|	€LCFunction›
			|	€LCGoesTo›
			|	€LCGreaterEquals›
			|	€LCGreaterThan›
			|	€LCIdentifier›
			|	€LCIf›
			|	€LCIn›
			|	€LCIs›
			|	€LCKSlot›
			|	€LCLessEquals›
			|	€LCLessGreat›
			|	€LCLessThan›
			|	€LCLimited›
			|	€LCLoop›
			|	€LCMinus›
			|	€LCMod›
			|	€LCNotEquals›
			|	€LCNot›
			|	€LCNull›
			|	€LCNumericLiteral›
			|	€LCOf›
			|	€LCOrd›
			|	€LCOr›
			|	€LCOthers›
			|	€LCOut›
			|	€LCPackage›
			|	€LCPlus›
			|	€LCPPartLabel›
			|	€LCPrime›
			|	€LCPrimedIdentifier›
			|	€LCPrivate›
			|	€LCProcedureName›
			|	€LCProcedure›
			|	€LCRecord›
			|	€LCRefinedBy›
			|	€LCRem›
			|	€LCRenames›
			|	€LCReplacedBy›
			|	€LCReturn›
			|	€LCReverse›
			|	€LCRRange›
			|	€LCSemi›
			|	€LCSeparate›
			|	€LCSpecLabel›
			|	€LCStarStar›
			|	€LCStar›
			|	€LCStmtLabel›
			|	€LCStringLiteral›
			|	€LCSubType›
			|	€LCThen›
			|	€LCTypeMark›
			|	€LCType›
			|	€LCTill›
			|	€LCUse›
			|	€LCVPartLabel›
			|	€LCWhenOthers›
			|	€LCWhen›
			|	€LCWhile›
			|	€LCWith›
			|	€LCXor›
			|	€LCEos›
			|	€LCZ›
			|	€LCGrkDelta›
			|	€LCLSqBrack›
			|	€LCRSqBrack›
			|	€LCLBrace›
			|	€LCRBrace›
			|	€LCLStrachey›
			|	€LCRStrachey›
			|	€LCLChevron›
			|	€LCRChevron›;
=TEX
=SML
datatype €CN_TOKEN›	=	€CNZ› of ZLex.Z_TOKEN list
			|	€CNText› of string
			|	€CNString› of string
			|	€CNKSlot› of Lex.INPUT list
			|	€CNEos›;
=TEX
=SML
type €CN_LEX_ITEM› = CN_LEX_CLASS * CN_TOKEN;
=TEX

\section{ABSTRACT SYNTAX}

\subsection{Basic Declarations}

=SML
type €ID› = string;
=TEX
=SML
type €ENUM_TYPE_DEF› = {vals : ID list};
=TEX
=SML
type €TMARK› = ID;
=TEX
=SML
type €ARRAY_DEF› = {index : TMARK, comp : TMARK};
=TEX
=SML
type €VAR_DECL› = {vars : ID list, tmark : TMARK};
=TEX
=SML
type 'COMP €RECORD_TYPE_DEF› = {comps : 'COMP list};
=TEX
=SML
type 'EXP €RANGE› = {lo : 'EXP, hi : 'EXP};
=TEX
\subsubsection{Private Types}
=SML
type €PRIVATE_TYPE_DEF› = {
	id : ID,
	limited : bool};
	
=TEX
\subsubsection{Variants}
=SML
type 'COMP €VARIANT› = {
	ids : ID list,
	comp : 'COMP list
	};

type 'COMP €VARIANT_PART› = {
	id : ID,
	variants : 'COMP VARIANT list
	};

type 'COMP €DECLARATION_VARIANT› = {
	decls : VAR_DECL list,
	variant : 'COMP VARIANT_PART
	};

datatype €COMPONENT› =
				€CDeclaration› of VAR_DECL list
			|	€CVariantPart› of COMPONENT VARIANT_PART
			|	€CDeclarationVariant› of COMPONENT DECLARATION_VARIANT
			|	€CNone›;
=TEX




=SML
type ('TYPE_DEF) €TYPE_DECL› = {name : ID, type_def : 'TYPE_DEF};
=TEX

=SML
type ('CONSTRAINT) €SUB_IND› = {tmark : TMARK, con : 'CONSTRAINT};
=TEX
=SML
type ('CONSTRAINT) €SUBTYPE_DECL› = {name : ID, sub_ind : ('CONSTRAINT) SUB_IND};
=TEX
=SML
type ('EXP) €CONST_DECL› = {consts : ID list, tm : TMARK, expr : 'EXP};
=TEX
=SML
type €DEFERRED_CONST_DECL› = {consts : ID list, tmark : TMARK};
=TEX
=SML
type ('EXP) €AGG_POS› = {tmark : TMARK, comps : 'EXP list};
=TEX
=SML
type ('EXP) €OTHERS› = {others : 'EXP};
=TEX
=SML
type ('EXP) €AGG_POS_OTHERS›
		= {agg_pos : ('EXP) AGG_POS, others : ('EXP) OTHERS};
=TEX
=SML
type ('EXP) €AGG_OTHERS› = {tmark : TMARK, others : ('EXP) OTHERS};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €NAMED_ASSOC› = {choice : 'AGG_CHOICE list, comp : 'EXP};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €AGG_NAMED› = {named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €AGG_NAMED_OTHERS›
		= {tmark : TMARK, agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
			others : ('EXP) OTHERS};
=TEX
=SML
type ('EXP) €REC_AGG_NAMED›
		= {tmark : TMARK, named_assocs : (ID * 'EXP) list};
=TEX
=SML
datatype €UNARY_OP› =
			€UOSparkUnaryAdd›
		|	€UOSparkUnaryMinus›
		|	€UOSparkNot›
		|	€UOSparkAbs›;
=TEX
=SML
type ('EXP) €UNARY_EXP› = {uop : UNARY_OP, right : 'EXP};
=TEX
=SML
datatype €BIN_OP› =
			€BOSparkAnd›
		|	€BOSparkOr›
		|	€BOSparkXor›
		|	€BOSparkEq›
		|	€BOSparkNotEq›
		|	€BOSparkLess›
		|	€BOSparkLessEq›
		|	€BOSparkGreater›
		|	€BOSparkGreaterEq›
		|	€BOSparkAdd›
		|	€BOSparkMinus›
		|	€BOSparkTimes›
		|	€BOSparkIntdiv›
		|	€BOSparkMod›
		|	€BOSparkRem›
		|	€BOSparkExpon›
		|	€BOSparkMem›
		|	€BOSparkNotmem›
=TEX
=SML
		|	€BOSparkAndThen›
		|	€BOSparkOrElse›;
=TEX
=SML
type ('EXP) €BIN_EXP› = {bop : BIN_OP, left : 'EXP, right : 'EXP};
=TEX
=SML
type €MEM_OP› = BIN_OP;
=TEX
=SML
type ('EXP) €MEM_RANGE› = {left : 'EXP, mop : MEM_OP, range : ('EXP) RANGE};
=TEX
=SML
type €ATTRIB› = ID;
=TEX
=SML
type ('ATTRIB_DESIG) €ATTRIBUTE›
	= {prefix : ID, attribute_desig : 'ATTRIB_DESIG};
=TEX
=SML
type ('EXP) €INDEXED_COMP›
	= {prefix : 'EXP, index : 'EXP};
=TEX
=SML
type ('EXP) €SELECTED_COMP›
	= {prefix : 'EXP, selector : ID};
=TEX
=SML
type ('EXP) €FUN_CALL›
	= {fun_name : ID, args : 'EXP list};
=TEX
=SML
type €INT_LIT› = string;
=TEX
=SML
type Z_EXP = TERM;
=TEX
=SML
datatype €TYPE_DEF› =
			€TDEnumTypeDef› of ENUM_TYPE_DEF
		|	€TDIntTypeDef› of (EXP) RANGE
		|	€TDUnconArrayDef› of ARRAY_DEF
		|	€TDConArrayDef› of ARRAY_DEF
		|	€TDRecordTypeDef› of COMPONENT RECORD_TYPE_DEF
		|	€TDPrivateTypeDef› of PRIVATE_TYPE_DEF
=TEX
=SML
and €CONSTRAINT› =
			€CRangeCon› of (EXP) RANGE
		|	€CIndexCon› of TMARK
=TEX
=SML
and €BASIC_DECL› =
			€BDConstDecl› of (EXP) CONST_DECL
		|	€BDDeferredConstDecl› of DEFERRED_CONST_DECL
		|	€BDTypeDecl› of (TYPE_DEF) TYPE_DECL
		|	€BDVarDecl› of VAR_DECL
		|	€BDSubtypeDecl› of (CONSTRAINT) SUBTYPE_DECL
=TEX
=SML
and €AGG_CHOICE› =
			€ACAggChoiceRange› of (EXP) RANGE
		|	€ACAggChoiceSingle› of EXP
=TEX
=SML
and €ATTRIB_DESIG› =
			€ADAttrib› of ATTRIB
		|	€ADAttribArg› of (ATTRIB * EXP)
=TEX
=SML
and €EXP› =
		€EId› of ID | €EInt› of INT_LIT | €EArrayAggPos› of (EXP) AGG_POS |
		€EArrayAggPosOthers› of (EXP) AGG_POS_OTHERS |
		€EArrayAggOthers› of (EXP) AGG_OTHERS |
		€EArrayAggNamed› of (AGG_CHOICE, EXP) AGG_NAMED |
		€EArrayAggNamedOthers› of (AGG_CHOICE, EXP) AGG_NAMED_OTHERS |
		€ERecAggPos› of (EXP) AGG_POS | €ERecAggNamed› of (EXP) REC_AGG_NAMED |
		€EUnaryExp› of (EXP) UNARY_EXP | €EBinExp› of (EXP) BIN_EXP |
		€EMemRange› of (EXP) MEM_RANGE | €EAttribute› of (ATTRIB_DESIG) ATTRIBUTE |
		€EIndexedComp› of (EXP) INDEXED_COMP |
		€ESelectedComp› of (EXP) SELECTED_COMP |
		€EFunCall› of (EXP) FUN_CALL |
		€EAuxiliaryExp› of Z_EXP |
		€EBracketed› of EXP;
=TEX

\subsection{Statements}

=SML
type ASSIGN = {name : EXP, e : EXP};
=TEX
=SML
type Z_PRED = TERM;
=TEX
=SML
type Z_PREDâ0 = Z_PRED;
=TEX
=SML
type Z_ID = ID;
=TEX
=SML
datatype €LABEL› =
			€LExplicit› of string
		|	€LImplicit›;
=TEX
=SML
type SPEC = {w : ID list, w0 : ID list, pre : Z_PRED, post : Z_PRED, label : LABEL};
=TEX
=SML
type SPEC_NO_IVARS = SPEC;
=TEX
=SML
type COND = EXP;
=TEX
=SML
type ('STMT) IF_THEN_ELSE = {g : COND, p : 'STMT, q : 'STMT};
=TEX
=SML
datatype €CASE_CHOICE› =
				€CCCaseExp› of EXP
			|	€CCCaseRange› of (EXP) RANGE;
=TEX
=SML
type ('STMT) CASE_ALTERNATIVE = {choices : CASE_CHOICE list, p : 'STMT};
=TEX
=SML
type ('STMT) CASE = {e : EXP, s : ('STMT) CASE_ALTERNATIVE list};
=TEX
=SML
type LOOP = {t : Z_PRED OPT, spec : SPEC_NO_IVARS};
=TEX
=SML
type NAMED_LOOP = {name : ID, t : Z_PRED OPT, spec : SPEC_NO_IVARS};
=TEX
=SML
type WHILE = {name : ID OPT, g : COND, loop : LOOP};
=TEX
=SML
type STATIC_EXP = EXP;
=TEX
=SML
datatype €LOOP_DIRECTION› =
				LDForwards
			|	LDReverse;
=TEX
=SML
type FOR_STATIC = {name : ID OPT, tmark : ID, i : ID, dir : LOOP_DIRECTION, lo : STATIC_EXP, hi : STATIC_EXP, loop : LOOP};
=TEX
=SML
type FOR_TMARK = {name : ID OPT, i : ID, tmark : TMARK, dir : LOOP_DIRECTION, loop : LOOP};
=TEX
=SML
type EXIT_WHEN = {g : COND};
=TEX
=SML
type RETURN = {e : EXP};
=TEX
=SML
type PROC_CALL = {name : ID, actuals : EXP list};
=TEX
=SML
type PROC_CALL_NO_IVARS = PROC_CALL;
=TEX
=SML
type €K_SLOT› = {content : string, label : LABEL};
=TEX
=SML
datatype €STMT›	= 	€STNull›
		|	€STAssign› of (ASSIGN)
		|	€STSpecNoIvars› of (SPEC_NO_IVARS)
		|	€STSemicolon› of (STMT * STMT)
		|	€STIfThenElse› of ((STMT)IF_THEN_ELSE)
		|	€STCase› of ((STMT)CASE)
		|	€STLoop› of (LOOP)
		|	€STNamedLoop› of (NAMED_LOOP)
		|	€STWhile› of (WHILE)
		|	€STForStatic› of (FOR_STATIC)
		|	€STForTmark› of (FOR_TMARK)
		|	€STExitWhen› of (EXIT_WHEN)
		|	€STExit›
		|	€STRet› of (RETURN)
		|	€STProcNoIvars› of (PROC_CALL_NO_IVARS)
		|	€STKSlot› of K_SLOT;
=TEX
=SML
type €SPEC_IVARS› = SPEC;
=TEX
=SML
type €FOR_NON_STATIC› = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : LOOP};
=TEX
=SML
fun €free_ids› (ze : Z_EXP) : ID list = (map (fst o dest_var) (frees ze));
=TEX
=SML
type €LOG_CON› = {x : Z_ID, e : Z_EXP, spec : SPEC, pre1 : Z_PRED};
=TEX
=SML
type €PROC_CALL_IVARS› = PROC_CALL;
=TEX
=SML
datatype €STATEMENT› =
		 	€SStmt› of (STMT)
		|	€SSpecIvars› of (SPEC_IVARS * STMT)
		|	€SForNonStatic› of (FOR_NON_STATIC * STMT)
		|	€SLogCon› of (LOG_CON * STMT)
		|	€SProcIvars› of (PROC_CALL_IVARS * STMT);
=TEX
\subsection{Subprogram Declarations}
=SML
datatype €MODE› = MSparkIn | MSparkOut | MSparkInOut;

type €PARAMETER_SPECIFICATION› = {
	idlist : ID list,
	mode : MODE,
	name : TMARK};

type €PROCEDURE_SPECIFICATION› = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT};

type €FUNCTION_SPECIFICATION› = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT};

datatype €SUBPROGRAM_SPECIFICATION› =
			SSProcedure of PROCEDURE_SPECIFICATION
		|	SSFunction of FUNCTION_SPECIFICATION;

type €PROCEDURE_DECLARATION› = PROCEDURE_SPECIFICATION;
type €FUNCTION_DECLARATION› =FUNCTION_SPECIFICATION;
type €SUBPROGRAM_DECLARATION› = SUBPROGRAM_SPECIFICATION;
=TEX
\subsection{Subprogram Bodies}
\subsection{Procedure and Function Calls}
=SML
type €NAMED_PARAM› = {
	formal : ID,
	actual : EXP};

type €NAMED_PARAMETER_ASSOC› = {
	params: NAMED_PARAM list};

type €POS_PARAMETER_ASSOC› = {
	params : EXP list};

datatype €ACTUAL_PARAMETER_PART› = 
			APPNamed of NAMED_PARAMETER_ASSOC
		|	APPPositional of POS_PARAMETER_ASSOC;

type €PROCEDURE_CALL_STATEMENT› = {
	name : ID,
	params : ACTUAL_PARAMETER_PART OPT};

type €FUNCTION_CALL› = {
	name : ID,
	params : ACTUAL_PARAMETER_PART OPT};

=TEX
\subsection{Package Declaration}
=SML
type €OPERATOR_SYMBOL› = string;

type €FUNCTION_RENAMING› = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL};

type €SUBPROGRAM_RENAMING› = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID};

datatype €RENAMING_DECLARATION› =
			RDFunction of FUNCTION_RENAMING
		|	RDSubprogram of SUBPROGRAM_RENAMING;

type €LENGTH_CLAUSE› = {
	attribute : EXP,
	exp : EXP};

type €ENUMERATION_REPRESENTATION_CLAUSE› = {
	name : ID,
	exp : EXP};

type €COMPONENT_CLAUSE› = {
	exp : EXP,
	range : AGG_CHOICE};

type €RECORD_REPRESENTATION_CLAUSE› = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list};

type €ADDRESS_CLAUSE› = {
	name : ID,
	exp : EXP};

datatype €REPRESENTATION_CLAUSE› =
			RCLength of LENGTH_CLAUSE
		|	RCEnumeration of ENUMERATION_REPRESENTATION_CLAUSE
		|	RCRecord of RECORD_REPRESENTATION_CLAUSE
		|	RCAddress of ADDRESS_CLAUSE;
=TEX
=SML
datatype €DECLARATION› =
			DDeclarationKSlot of K_SLOT
		|	DRenamingDeclaration of RENAMING_DECLARATION
		|	DBasicDecl of BASIC_DECL
		|	DRepresentationClause of REPRESENTATION_CLAUSE
		|	DProperBody of PROPER_BODY
		|	DProcedureDeclaration of PROCEDURE_DECLARATION
		|	DFunctionDeclaration of FUNCTION_DECLARATION
		|	DPackageDeclaration of PACKAGE_DECLARATION
		|	DProcedureStub of PROCEDURE_DECLARATION
		|	DFunctionStub of FUNCTION_DECLARATION
		|	DPackageStub of ID

and €PROPER_BODY› =	PBProcedure of PROCEDURE_BODY
		|	PBFunction of FUNCTION_BODY
		|	PBPackage of PACKAGE_BODY
=TEX
=SML
withtype €PROCEDURE_BODY› = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT}

and €FUNCTION_BODY› = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT}

and €PACKAGE_BODY› = {
	name : ID,
	decls : DECLARATION list,
	statement : STATEMENT}

and €PACKAGE_DECLARATION› = {
	name : ID,
	visible_decs : DECLARATION list,
	private_decs : DECLARATION list};

=TEX

=TEX
=SML
type €SUBUNIT› = {
	id : ID,
	proper_body : PROPER_BODY};

datatype €COMPILATION_UNIT› =
			CUPackageDeclaration of PACKAGE_DECLARATION
		|	CUProperBody of PROPER_BODY
		|	CUSubUnit of SUBUNIT;


type €REFINED_BY› = {label : LABEL,  statement : STATEMENT};
type €REPLACED_BY› = {label : LABEL,  statement : STATEMENT};

type €REPLACED_BY_DECL› = {label : LABEL,  decls : DECLARATION list};
type €REPLACED_BY_VISIBLE_PART› = {label : LABEL, visible : DECLARATION list};
type €REPLACED_BY_PRIVATE_PART› = {label : LABEL, private : DECLARATION list};

type CONTEXT_COMPILATION_UNIT = {
	context : ID list,
	comp_unit : COMPILATION_UNIT};

datatype €KSLOT_COMPILATION_UNIT› =
			KCUKSlot of K_SLOT
		|	KCUUnit of CONTEXT_COMPILATION_UNIT;

type €REPLACED_BY_COMP› = {label : LABEL,  comp : KSLOT_COMPILATION_UNIT list};

datatype €WEB_CLAUSE› = 
			WCCompilation of KSLOT_COMPILATION_UNIT list
		|	WCReplacedByCompilation of REPLACED_BY_COMP
		|	WCReplacedByPrivatePart of REPLACED_BY_PRIVATE_PART
		|	WCReplacedByVisiblePart of REPLACED_BY_VISIBLE_PART
		|	WCReplacedByDecl of REPLACED_BY_DECL
		|	WCRefinedBy of REFINED_BY
		|	WCReplacedBy of REPLACED_BY;
=TEX

\section{EPILOGUE}
=SML
end (* of structure CNTypes *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
