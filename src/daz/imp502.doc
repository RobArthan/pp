% imp502.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Compliance Notation Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD502}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE}
=SML
structure €CNAbstractSyntax› = struct
=TEX
\section{PRELIMINARIES}
Before we do anything else, we set up a {\Product} theory, $vc\_gen$ to hold the Z specification which is contained in the document.

We need either dummy versions of or {\em ad hoc} substitutes for such of material of \cite{DRA/CIS/CSE3/SWI/WP/2} as is used in \cite{DRA/CIS/CSE3/SWI/WP/1}.
These are given in the remaining subsections of this section.

\subsection{Expressions and Predicates}
We take the SPARK expressions, $EXP$ in the Z specification as a given type since for present purposes we do not wish to discuss the internal details.

For simplicity, we use Z expressions represented as HOL terms to represent SPARK expressions.
Thus we can pretend that the expression translation of \cite{DRA/CIS/CSE3/SWI/WP/2} is just the identify function.
Note that the use of HOL terms to represent Z expressions is realistic --- and lies at the heart of the technique of ``semantic embedding'' used to implement support for reasoning in Z with \Product.

=SML
	type €ID› = string;
	type €EXP› = TERM;
	type €Z_ID› = string;
	type €Z_EXP› = TERM;
	type €Z_PRED› = TERM;
=TEX
\subsection{Sequents, Declarations and VCs}
A type of sequents adequate to represent sequents in the above sense is supplied as part of \Product.
It is simplifies matters later on to use this type here.
=SML
	type €Sequent› = SEQ;
=TEX
The semantics of a $VC$ are presumably similar to those of the sequents used in Appendix F of the draft Z Standard, \cite{zip/prg/92/121} (which incorporate declarations in their antecedents).
I.e. the declarations act, in effect, as additional assumptions, which also serve to constrain the types of variables in the rest of the sequent.
In \Product, the semantics of this is probably best carried by representing a $VC$ as a sequent, with the declarations included in the assumptions.
Nonetheless we give Standard ML declarations reflecting the above Z.

=SML
	type €Z_Decl› = {zvar : Z_ID, zexp : Z_EXP};
	type €VC› = Z_Decl list * Sequent;
=TEX
\pagebreak
\section{SYNTAX OF SPARK STATEMENTS}

\subsection{Assignment}\label{assignment}
=SML
	type €Assign› = {x : ID, E : EXP};
=TEX
\subsection{Array Assignment}\label{array-assignment}
=SML
	type €Array_Assign› = {a : ID, E1 : EXP, E2 : EXP};
=TEX
\subsection{Specification (No initial variables)}\label{specification-no-ivars}
=TEX
In the translation into Standard ML of a schema which includes another,
we have various choices.
In this simple case where the new schema has the same signature as the included one, we just say that the new type is an abbreviation for the old one.
=SML
	type €Z_PRED0› = Z_PRED;
	type €Spec› = {w : ID list, w0 : ID list, pre : Z_PRED, post : Z_PRED};
	type €Spec_No_Ivars› = Spec;
=TEX
\subsection{If-then-else}\label{if-then-else}
=SML
	type €COND› = EXP;
	type ('STMT) €If_Then_Else› = {G : COND, P : 'STMT, Q : 'STMT};
=TEX
\subsection{Case}\label{case}
=SML
	type ('STMT) €Case_Seg› = {when : EXP list, P : 'STMT};
	type ('STMT) €Case› = {E : EXP, s : ('STMT) Case_Seg list};
=TEX
The fact that the list of arms may not be empty is not captured by the above.
The following exception is available for later code to raise if this constraint is violated.
=SML
exception Empty_Case_Statement of string;
=TEX
\subsection{Loop}\label{loop}
As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.
=SML
	type €Loop› = {u : Z_PRED, spec : Spec_No_Ivars};
=TEX
\subsection{While Loop}\label{while-loop}
=SML
	type €While› = {G : COND, loop : Loop};
=TEX
\subsection{For Loop (Values as Bounds)}\label{for-value}
=SML
	type €VALUE› = EXP;
	type €For_Value› = {i : ID, lo : VALUE, hi : VALUE, loop : Loop};
=TEX
\subsection{Exit}\label{exit}
=SML
	type €Exit› = {G : COND};
=TEX
\subsection{Return}\label{return}

=SML
	type €Return› = {E : EXP};
=TEX
\subsection{Procedure Call}\label{procedure-call}
=SML
	type €Proc_Call› = {name : ID, actuals : EXP list};
=TEX
\subsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.
=TEX
The constructors $case$ and $while$ must be misspelt in the Standard ML datatype twhich implements the above because they are reserved identifiers.
=SML
datatype 
	€Stmt›	= 	€null›
		|	€assign› of (Assign)
		|	€arr_assign› of (Array_Assign)
		|	€spec_no_ivars› of (Spec_No_Ivars)
		|	€semicolon› of (Stmt * Stmt)
		|	€if_then_else› of ((Stmt)If_Then_Else)
		|	€kase› of ((Stmt)Case)
		|	€loop› of (Loop)
		|	€whyle› of (While)
		|	€for_value› of (For_Value)
		|	€exit› of (Exit)
		|	€ret› of (Return)
		|	€proc_no_ivars› of (Proc_Call);
=TEX
\pagebreak
\subsection{For Loop (Bounds with Variables)}\label{for-var}
=SML
	type €For_Var› = {i : ID, lo : VALUE, hi : VALUE, loop : Loop};
=TEX
\subsection{Specification (with initial variables)}\label{specification-ivars}
=TEX
=SML
	type €Spec_Ivars› = Spec;
=TEX
\subsection{Logical Constants}\label{logical-constants}
=TEX
The functions $free\_id$ may readily and reallistically be implemented using existing \Product\
syntax functions.
=SML
	type €Log_Con› = {X : Z_ID, E : Z_EXP, spec : Spec, pre1 : Z_PRED};
=TEX
\subsection{Statement}\label{statement}
=TEX
=SML
datatype 
	€Statement›
		= 	€stmt› of (Stmt)
		|	€for_exp› of (For_Var * Stmt)
		|	€spec_ivars› of (Spec_Ivars * Stmt)
		|	€log_con› of (Log_Con * Stmt)
		|	€proc_ivars› of (Proc_Call * Stmt);
=TEX

=TEX 
\section{EPILOGUE}
=SML
end (* of structure CNAbstractSyntax *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
