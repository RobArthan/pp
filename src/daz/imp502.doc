% imp502.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Compliance Notation Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD502}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE}
=SML
structure €CNTypes› : CNTypes = struct
=TEX

\section{LEXIS}
The following data type represents the lexical classes which are the
terminals of the grammar:
$SpecificationStatement$ is not a terminal and the syntax of a specification statement is part of the grammar. The Z predicates for pre- and post-condition are terminals and are captured by the $Z$ type constructor. Other terminals required are:
=SML
datatype €CN_LEX_CLASS›
			=	€LCAbstractExpression›
			|	€LCAbs›
			|	€LCAmpersand›
			|	€LCAnd›
			|	€LCArray›
			|	€LCAt›
			|	€LCBar›
			|	€LCBBody›
			|	€LCBecomes›
			|	€LCBegin›
			|	€LCCase›
			|	€LCCharacterLiteral›
			|	€LCColon›
			|	€LCComma›
			|	€LCCompLabel›
			|	€LCConstant›
			|	€LCCon›
			|	€LCCrd›
			|	€LCDecLabel›
			|	€LCDelta›
			|	€LCDigits›
			|	€LCDiv›
			|	€LCDotDot›
			|	€LCDot›
			|	€LCElse›
			|	€LCElsIf›
			|	€LCEnd›
			|	€LCEquals›
			|	€LCExit›
			|	€LCFatDot›
			|	€LCFor›
			|	€LCFunctionName›
			|	€LCFunction›
			|	€LCGoesTo›
			|	€LCGreaterEquals›
			|	€LCGreaterThan›
			|	€LCIdentifier›
			|	€LCIf›
			|	€LCIn›
			|	€LCIs›
			|	€LCKSlot›
			|	€LCLessEquals›
			|	€LCLessGreat›
			|	€LCLessThan›
			|	€LCLimited›
			|	€LCLoop›
			|	€LCMinus›
			|	€LCMod›
			|	€LCNotEquals›
			|	€LCNot›
			|	€LCNull›
			|	€LCNumericLiteral›
			|	€LCOf›
			|	€LCOrd›
			|	€LCOr›
			|	€LCOthers›
			|	€LCOut›
			|	€LCPackage›
			|	€LCPlus›
			|	€LCPPartLabel›
			|	€LCPrime›
			|	€LCPrimedIdentifier›
			|	€LCPrivate›
			|	€LCProcedureName›
			|	€LCProcedure›
			|	€LCRecord›
			|	€LCRefinedBy›
			|	€LCRem›
			|	€LCRenames›
			|	€LCReplacedBy›
			|	€LCReturn›
			|	€LCReverse›
			|	€LCRRange›
			|	€LCSemi›
			|	€LCSeparate›
			|	€LCSpecLabel›
			|	€LCStarStar›
			|	€LCStar›
			|	€LCStmtLabel›
			|	€LCStringLiteral›
			|	€LCSubType›
			|	€LCThen›
			|	€LCTypeMark›
			|	€LCType›
			|	€LCTill›
			|	€LCUse›
			|	€LCVPartLabel›
			|	€LCWhenOthers›
			|	€LCWhen›
			|	€LCWhile›
			|	€LCWith›
			|	€LCXor›
			|	€LCEos›
			|	€LCZ›
			|	€LCGrkDelta›
			|	€LCLSqBrack›
			|	€LCRSqBrack›
			|	€LCLBrace›
			|	€LCRBrace›
			|	€LCLStrachey›
			|	€LCRStrachey›
			|	€LCLChevron›
			|	€LCRChevron›;
=TEX
=SML
datatype €CN_TOKEN›	=	€CNZ› of ZLex.Z_TOKEN list
			|	€CNText› of string
			|	€CNString› of string
			|	€CNKSlot› of Lex.INPUT list
			|	€CNEos›;
=TEX
=SML
type €CN_LEX_ITEM› = CN_LEX_CLASS * CN_TOKEN;
=TEX

\section{ABSTRACT SYNTAX}

\subsection{Basic Declarations}

=SML
type €ID› = string;
=TEX
=SML
type €ENUM_TYPE_DEF› = {vals : ID list};
=TEX
=SML
type €TMARK› = ID list;
=TEX
=SML
type €ARRAY_DEF› = {index : TMARK, comp : TMARK};
=TEX
=SML
type €VAR_DECL› = {var : ID, tmark : TMARK};
=TEX
=SML
type €RECORD_TYPE_DEF› = {decl : VAR_DECL list};
=TEX
=SML
type ('EXP) €RANGE› = {lo : 'EXP, hi : 'EXP};
=TEX
=SML
type ('TYPE_DEF) €TYPE_DECL› = {name : ID, type_def : 'TYPE_DEF};
=TEX

=SML
type ('CONSTRAINT) €SUB_IND› = {tmark : TMARK, con : 'CONSTRAINT};
=TEX
=SML
type ('CONSTRAINT) €SUBTYPE_DECL› = {name : ID, sub_ind : ('CONSTRAINT) SUB_IND};
=TEX
=SML
type ('EXP) €CONST_DECL› = {const : ID, tm : TMARK, expr : 'EXP};
=TEX
=SML
type ('EXP) €AGG_POS› = {tmark : TMARK, comps : 'EXP list};
=TEX
=SML
type ('EXP) €OTHERS› = {others : 'EXP};
=TEX
=SML
type ('EXP) €AGG_POS_OTHERS›
		= {agg_pos : ('EXP) AGG_POS, others : ('EXP) OTHERS};
=TEX
=SML
type ('EXP) €AGG_OTHERS› = {tmark : TMARK, others : ('EXP) OTHERS};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €NAMED_ASSOC› = {choice : 'AGG_CHOICE list, comp : 'EXP};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €AGG_NAMED› = {named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €AGG_NAMED_OTHERS›
		= {tmark : TMARK, agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
			others : ('EXP) OTHERS};
=TEX
=SML
type ('EXP) €REC_AGG_NAMED›
		= {tmark : TMARK, named_assocs : (ID * 'EXP) list};
=TEX
=SML
datatype €UNARY_OP› =
			€SparkUnaryAdd›
		|	€SparkUnaryMinus›
		|	€SparkNot›
		|	€SparkAbs›;
=TEX
=SML
type ('EXP) €UNARY_EXP› = {Op : UNARY_OP, right : 'EXP};
=TEX
=SML
datatype €BIN_OP› =
			€SparkAnd›
		|	€SparkAndThen›
		|	€SparkOr›
		|	€SparkOrElse›
		|	€SparkXor›
		|	€SparkEq›
		|	€SparkNotEq›
		|	€SparkLess›
		|	€SparkLessEq›
		|	€SparkGreater›
		|	€SparkGreaterEq›
		|	€SparkAdd›
		|	€SparkMinus›
		|	€SparkTimes›
		|	€SparkIntdiv›
		|	€SparkMod›
		|	€SparkRem›
		|	€SparkExpon›
		|	€SparkMem›
		|	€SparkNotmem›;
=TEX
=SML
type ('EXP) €BIN_EXP› = {Op : BIN_OP, left : 'EXP, right : 'EXP};
=TEX
=SML
type €MEM_OP› = BIN_OP;
=TEX
=SML
type ('EXP) €MEM_RANGE› = {left : 'EXP, Op : MEM_OP, range : ('EXP) RANGE};
=TEX
=SML
type €ATTRIB› = ID list;
=TEX
=SML
type ('ATTRIB_DESIG) €ATTRIBUTE›
	= {prefix : ID, attribute_desig : 'ATTRIB_DESIG};
=TEX
=SML
type ('EXP) €INDEXED_COMP›
	= {prefix : 'EXP, index : 'EXP};
=TEX
=SML
type ('EXP) €SELECTED_COMP›
	= {prefix : 'EXP, selector : ID};
=TEX
=SML
type ('EXP) €FUN_CALL›
	= {fun_name : ID, args : 'EXP list};
=TEX
=SML
type €INT_LIT› = string;
=TEX
=SML
type Z_EXP = TERM;
=TEX
=SML
datatype €TYPE_DEF› =
			€EnumTypeDef› of ENUM_TYPE_DEF
		|	€IntTypeDef› of (EXP) RANGE
		|	€UnconArrayDef› of ARRAY_DEF
		|	€ConArrayDef› of ARRAY_DEF
		|	€RecordTypeDef› of RECORD_TYPE_DEF
=TEX
=SML
and €CONSTRAINT› =
			€RangeCon› of (EXP) RANGE
		|	€IndexCon› of TMARK
=TEX
=SML
and €BASIC_DECL› =
			€ConstDecl› of (EXP) CONST_DECL
		|	€TypeDecl› of (TYPE_DEF) TYPE_DECL
		|	€SubtypeDecl› of (CONSTRAINT) SUBTYPE_DECL
=TEX
=SML
and €AGG_CHOICE› =
			€AggChoiceRange› of (EXP) RANGE
		|	€AggChoiceSingle› of EXP
=TEX
=SML
and €ATTRIB_DESIG› =
			€Attrib› of ATTRIB
		|	€AttribArg› of (ATTRIB * EXP)
=TEX
=SML
and €EXP› =
		€Id› of ID | €Int› of INT_LIT | €ArrayAggPos› of (EXP) AGG_POS |
		€ArrayAggPos_others› of (EXP) AGG_POS_OTHERS |
		€ArrayAggOthers› of (EXP) AGG_OTHERS |
		€ArrayAggNamed› of (AGG_CHOICE, EXP) AGG_NAMED |
		€ArrayAggNamedOthers› of (AGG_CHOICE, EXP) AGG_NAMED_OTHERS |
		€RecAggPos› of (EXP) AGG_POS | €RecAggNamed› of (EXP) REC_AGG_NAMED |
		€UnaryExp› of (EXP) UNARY_EXP | €BinExp› of (EXP) BIN_EXP |
		€MemRange› of (EXP) MEM_RANGE | €Attribute› of (ATTRIB_DESIG) ATTRIBUTE |
		€IndexedComp› of (EXP) INDEXED_COMP |
		€SelectedComp› of (EXP) SELECTED_COMP |
		€FunCall› of (EXP) FUN_CALL |
		€AuxiliaryExp› of Z_EXP;
=TEX

\subsection{Statements}

=SML
type ASSIGN = {name : EXP, E : EXP};
=TEX
=SML
type Z_PRED = TERM;
=TEX
=SML
type Z_PREDâ0 = Z_PRED;
=TEX
=SML
type Z_ID = ID;
=TEX
=SML
type SPEC = {w : ID list, w0 : ID list, pre : Z_PRED, post : Z_PRED};
=TEX
=SML
type SPEC_NO_IVARS = SPEC;
=TEX
=SML
type COND = EXP;
=TEX
=SML
type ('STMT) IF_THEN_ELSE = {G : COND, P : 'STMT, Q : 'STMT};
=TEX
=SML
datatype €CASE_CHOICE› =
				€CaseExp› of EXP
			|	€CaseRange› of (EXP) RANGE;
=TEX
=SML
type ('STMT) CASE_ALTERNATIVE = {choices : CASE_CHOICE, P : 'STMT};
=TEX
=SML
type ('STMT) CASE = {E : EXP, s : ('STMT) CASE_ALTERNATIVE list};
=TEX
=SML
type LOOP = {T : Z_PRED, spec : SPEC_NO_IVARS};
=TEX
=SML
type WHILE = {G : COND, loop : LOOP};
=TEX
=SML
type STATIC_EXP = EXP;
=TEX
=SML
type FOR_STATIC = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : LOOP};
=TEX
=SML
type FOR_TMARK = {i : ID, tmark : TMARK, loop : LOOP};
=TEX
=SML
type EXIT_WHEN = {G : COND};
=TEX
=SML
type RETURN = {E : EXP};
=TEX
=SML
type PROC_CALL = {name : ID, actuals : EXP list};
=TEX
=SML
type PROC_CALL_NO_IVARS = PROC_CALL;
=TEX
=SML
datatype €STMT›	= 	€Null›
		|	€Assign› of (ASSIGN)
		|	€SpecNoIvars› of (SPEC_NO_IVARS)
		|	€Semicolon› of (STMT * STMT)
		|	€IfThenElse› of ((STMT)IF_THEN_ELSE)
		|	€Case› of ((STMT)CASE)
		|	€Loop› of (LOOP)
		|	€While› of (WHILE)
		|	€ForStatic› of (FOR_STATIC)
		|	€ForTmark› of (FOR_TMARK)
		|	€ExitWhen› of (EXIT_WHEN)
		|	€Exit›
		|	€Ret› of (RETURN)
		|	€ProcNoIvars› of (PROC_CALL_NO_IVARS);
=TEX
=SML
type SPEC_IVARS = SPEC;
=TEX
=SML
type FOR_NON_STATIC = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : LOOP};
=TEX
=SML
fun €free_ids› (ze : Z_EXP) : ID list = (map (fst o dest_var) (frees ze));
=TEX
=SML
type LOG_CON = {X : Z_ID, E : Z_EXP, spec : SPEC, pre1 : Z_PRED};
=TEX
=SML
type PROC_CALL_IVARS = PROC_CALL;
=TEX
=SML
datatype €STATEMENT› =
		 	€Stmt› of (STMT)
		|	€SpecIvars› of (SPEC_IVARS * STMT)
		|	€ForNonStatic› of (FOR_NON_STATIC * STMT)
		|	€LogCon› of (LOG_CON * STMT)
		|	€ProcIvars› of (PROC_CALL_IVARS * STMT);
=TEX
\subsection{Subprogram Declarations}
=SML
datatype €MODE› = spark_in | spark_out | spark_in_out;

type €PARAMETER_SPECIFICATION› = {
	idlist : ID list,
	mode : MODE,
	name : TMARK};

type €PROCEDURE_SPECIFICATION› = {
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT};

type €FUNCTION_SPECIFICATION› = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT};

datatype €SUBPROGRAM_DECLARATION› =
			procedure_specification of PROCEDURE_SPECIFICATION
		|	function_specification of FUNCTION_SPECIFICATION;

type €SUBPROGRAM_SPECIFICATION› = SUBPROGRAM_DECLARATION;
=TEX
\subsection{Subprogram Bodies}
=SML
type €SUBPROGRAM_IMPLEMENTATION› = {
	declarative_part : BASIC_DECL list,
	statements : STATEMENT list,
	designator : ID};

type €SUBPROGRAM_BODY_PROC› = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	subprogram_impl : SUBPROGRAM_IMPLEMENTATION};

type €SUBPROGRAM_BODY_FUN› = {
	function_spec : FUNCTION_SPECIFICATION,
	subprogram_impl : SUBPROGRAM_IMPLEMENTATION};

datatype €SUBPROGRAM_BODY› =	SubprogramBodyProc of SUBPROGRAM_BODY_PROC
			|	SubprogramBodyFun of SUBPROGRAM_BODY_FUN;
=TEX
\subsection{Procedure and Function Calls}
=SML
type €NAMED_PARAM› = {
	formal : ID,
	actual : EXP};

type €NAMED_PARAMETER_ASSOC› = {
	params: NAMED_PARAM list};

type €POS_PARAMETER_ASSOC› = {
	params : EXP list};

datatype €ACTUAL_PARAMETER_PART› = 
			NamedParameterAssociation of NAMED_PARAMETER_ASSOC
		|	PositionalParameterAssociation of POS_PARAMETER_ASSOC;

type €PROCEDURE_CALL_STATEMENT› = {
	name : ID,
	params : ACTUAL_PARAMETER_PART OPT};

type €FUNCTION_CALL› = {name : ID,
	params : ACTUAL_PARAMETER_PART OPT};

=TEX
\subsection{Package Declaration}
=SML
type €K_SLOT› = {label : ID};

type €OPERATOR_SYMBOL› = string;

type €FUNCTION_RENAMING› = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL};

type €SUBPROGRAM_RENAMING› = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID};

datatype €RENAMING_DECLARATION› =
			FunctionRenaming of FUNCTION_RENAMING
		|	SubprogramRenaming of SUBPROGRAM_RENAMING;
	
		

datatype €BODY_STUB› =	SeparateProcedure of PROCEDURE_SPECIFICATION
		|	SeparateFunction of FUNCTION_SPECIFICATION
		|	SeparatePackage of ID;

datatype €BODY› =	ProperBody of PROPER_BODY
		|	BodyStub of BODY_STUB;

datatype €DECLARATION› =
			DeclarationKSlot of K_SLOT
		|	RenamingDeclaration of RENAMING_DECLARATION
		|	BasicDeclarativeItem of BASIC_DECLARATIVE_ITEM
		|	Package_Declaration of PACKAGE_DECLARATION
		|	Body of BODY;

=TEX
=SML
type €LENGTH_CLAUSE› = {
	attribute : (ATTRIB_DESIG) ATTRIBUTE,
	expr : EXP};

type €ENUMERATION_REPRESENTATION_CLAUSE› = {
	name : ID,
	expr : EXP};

type €COMPONENT_CLAUSE› = {
	expr : EXP,
	range : (EXP)RANGE};

type €RECORD_REPRESENTATION_CLAUSE› = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list};

datatype €TYPE_REPRESENTATION_CLAUSE› =
			LengthClause of LENGTH_CLAUSE
		|	EnumerationRepresentationClause of ENUMERATION_REPRESENTATION_CLAUSE
		|	RecordRepresentationClause of RECORD_REPRESENTATION_CLAUSE;

type €ADDRESS_CLAUSE› = {
	name : ID,
	expr : EXP};

datatype €REPRESENTATION_CLAUSE› =
			TypeRepresentationClause of TYPE_REPRESENTATION_CLAUSE
		|	AddressClause of ADDRESS_CLAUSE;

datatype €BASIC_DECLARATIVE_ITEM› =
			BasicDecl of BASIC_DECL
		|	RepresentationClause of REPRESENTATION_CLAUSE;

datatype €PVDEC› =	Declaration of DECLARATION
		|	SubprogramDeclaration of SUBPROGRAM_DECLARATION;

type €VISIBLE_PART› = PVDEC list;

type €PRIVATE_PART› = PVDEC list;

type €PACKAGE_SPECIFICATION› = {
	name : ID,
	visible_part : VISIBLE_PART};

type €PACKAGE_SPECIFICATION› = {
	name : ID,
	visible_part : VISIBLE_PART,
	private_part : PRIVATE_PART OPT};

type €PACKAGE_DECLARATION› = PACKAGE_SPECIFICATION;
=TEX
\subsection{Package Body}
=SML
type €PACKAGE_IMPLEMENTATION› = {
	decls : BASIC_DECL list,
	stmts : STATEMENT list};

type €PACKAGE_BODY› = {
	name : ID,
	package_imp : PACKAGE_IMPLEMENTATION};

=TEX
=SML
datatype €PROPER_BODY› =	SubprogramBody of SUBPROGRAM_BODY
			|	PackageBody of PACKAGE_BODY;

type €SUBUNIT› = {
	name : ID,
	proper_body : PROPER_BODY};


type €SECONDARY_UNIT› = {
	library_unit_body : PACKAGE_BODY,
	subunit : SUBUNIT};


type €CU_SECONDARY› = {
	context_clause : CONTEXT_CLAUSE,
	secondary_unit : SECONDARY_UNIT};


type €REFINED_BY› = {label : ID,  stmts : STATEMENT list};
type €REPLACED_BY› = {label : ID,  stmts : STATEMENT list};

type €REPLACED_BY_DECL› = {label : ID,  decls : DECLARATION list};
type €REPLACED_BY_VISIBLE_PART› = {label : ID, visible : VISIBLE_PART};
type €REPLACED_BY_PRIVATE_PART› = {label : ID, private : PRIVATE_PART};
=TEX
=SML
type €CONTEXT_CLAUSE› = ID list;

type €LIBRARY_UNIT› = {
	package_declaration : PACKAGE_DECLARATION,
	main_program : SUBPROGRAM_BODY};

type €CU_LIBRARY› = {
	context_clause : CONTEXT_CLAUSE,
	library_unit : LIBRARY_UNIT};

datatype €COMPILATION_UNIT› =
			CULibrary of CU_LIBRARY
		|	CUSecondary of CU_SECONDARY;

datatype €COMPILATION› =	CompilationKSlot of K_SLOT
		|	CompilationUnits of COMPILATION_UNIT list;
=TEX
=SML
type €REPLACED_BY_COMP› = {label : ID,  comp : COMPILATION};

datatype €WEB_CLAUSE› = 
			Compilation of COMPILATION
		|	ReplacedByCompilation of REPLACED_BY_COMP
		|	ReplacedByPrivatePart of REPLACED_BY_PRIVATE_PART
		|	ReplacedByVisiblePart of REPLACED_BY_VISIBLE_PART
		|	ReplacedByDecl of REPLACED_BY_DECL
		|	RefinedBy of REFINED_BY
		|	ReplacedBy of REPLACED_BY;
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNTypes *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
