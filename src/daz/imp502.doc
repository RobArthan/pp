% imp502.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Compliance Notation Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD502}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE}
=SML
structure €CNTypes› : CNTypes = struct
=TEX

\section{LEXIS}
The following data type represents the lexical classes which are the
terminals of the grammar:
$SpecificationStatement$ is not a terminal and the syntax of a specification statement is part of the grammar. The Z predicates for pre- and post-condition are terminals and are captured by the $Z$ type constructor. Other terminals required are:
=SML
datatype €CN_LEX_CLASS›
			=	€AbstractExpression›
			|	€Abs›
			|	€Ampersand›
			|	€And›
			|	€Array›
			|	€At›
			|	€Bar›
			|	€BBody›
			|	€Becomes›
			|	€Begin›
			|	€Case›
			|	€CharacterLiteral›
			|	€Colon›
			|	€Comma›
			|	€CompLabel›
			|	€Constant›
			|	€Con›
			|	€Crd›
			|	€DecLabel›
			|	€Delta›
			|	€Digits›
			|	€Div›
			|	€DotDot›
			|	€Dot›
			|	€Else›
			|	€ElsIf›
			|	€End›
			|	€Equals›
			|	€Exit›
			|	€FatDot›
			|	€For›
			|	€FunctionName›
			|	€Function›
			|	€GoesTo›
			|	€GreaterEquals›
			|	€GreaterThan›
			|	€Identifier›
			|	€If›
			|	€In›
			|	€Is›
			|	€KSlot›
			|	€LessEquals›
			|	€LessGreat›
			|	€LessThan›
			|	€Limited›
			|	€Loop›
			|	€Minus›
			|	€Mod›
			|	€NotEquals›
			|	€Not›
			|	€Null›
			|	€NumericLiteral›
			|	€Of›
			|	€Ord›
			|	€Or›
			|	€Others›
			|	€Out›
			|	€Package›
			|	€Plus›
			|	€PPartLabel›
			|	€Prime›
			|	€PrimedIdentifier›
			|	€Private›
			|	€ProcedureName›
			|	€Procedure›
			|	€Record›
			|	€RefinedBy›
			|	€Rem›
			|	€Renames›
			|	€ReplacedBy›
			|	€Return›
			|	€Reverse›
			|	€RRange›
			|	€Semi›
			|	€Separate›
			|	€SpecLabel›
			|	€StarStar›
			|	€Star›
			|	€StmtLabel›
			|	€StringLiteral›
			|	€SubType›
			|	€Then›
			|	€TypeMark›
			|	€Type›
			|	€Till›
			|	€Use›
			|	€VPartLabel›
			|	€WhenOthers›
			|	€When›
			|	€While›
			|	€With›
			|	€Xor›
			|	€Eos›
			|	€Z›
			|	€GrkDelta›
			|	€LSqBrack›
			|	€RSqBrack›
			|	€LBrace›
			|	€RBrace›
			|	€LStrachey›
			|	€RStrachey›
			|	€LChevron›
			|	€RChevron›;
=TEX
=SML
datatype €CN_TOKEN›	=	€CNZ› of ZLex.Z_TOKEN list
			|	€CNText› of string
			|	€CNString› of string
			|	€CNKSlot› of Lex.INPUT list
			|	€CNEos›;
=TEX
=SML
type €CN_LEX_ITEM› = CN_LEX_CLASS * CN_TOKEN;
=TEX

\section{ABSTRACT SYNTAX}

\subsection{Basic Declarations}

=SML
type €ID› = string;
=TEX
=SML
type €Enum_Type_Def› = {vals : ID list};
=TEX
=SML
type €TMARK› = ID list;
=TEX
=SML
type €Array_Def› = {index : TMARK, comp : TMARK};
=TEX
=SML
type €Var_Decl› = {var : ID, tmark : TMARK};
=TEX
=SML
type €Record_Type_Def› = {decl : Var_Decl list};
=TEX
=SML
type ('EXP) €Range› = {lo : 'EXP, hi : 'EXP};
=TEX
=SML
type ('TYPE_DEF) €Type_Decl› = {name : ID, type_def : 'TYPE_DEF};
=TEX

=SML
type ('CONSTRAINT) €Sub_Ind› = {tmark : TMARK, con : 'CONSTRAINT};
=TEX
=SML
type ('CONSTRAINT) €Subtype_Decl› = {name : ID, sub_ind : ('CONSTRAINT) Sub_Ind};
=TEX
=SML
type ('EXP) €Const_Decl› = {const : ID, tm : TMARK, expr : 'EXP};
=TEX
=SML
type ('EXP) €Agg_Pos› = {tmark : TMARK, comps : 'EXP list};
=TEX
=SML
type ('EXP) €Others› = {others : 'EXP};
=TEX
=SML
type ('EXP) €Agg_Pos_Others›
		= {agg_pos : ('EXP) Agg_Pos, others : ('EXP) Others};
=TEX
=SML
type ('EXP) €Agg_Others› = {tmark : TMARK, others : ('EXP) Others};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €Named_Assoc› = {choice : 'AGG_CHOICE list, comp : 'EXP};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €Agg_Named› = {named_assocs : ('AGG_CHOICE, 'EXP) Named_Assoc list};
=TEX
=SML
type ('AGG_CHOICE, 'EXP) €Agg_Named_Others›
		= {tmark : TMARK, agg_named : ('AGG_CHOICE, 'EXP) Agg_Named, 
			others : ('EXP) Others};
=TEX
=SML
type ('EXP) €Rec_Agg_Named›
		= {tmark : TMARK, named_assocs : (ID * 'EXP) list};
=TEX
=SML
datatype €UNARY_OP› =
			€spark_unary_add›
		|	€spark_unary_minus›
		|	€spark_not›
		|	€spark_abs›;
=TEX
=SML
type ('EXP) €Unary_Exp› = {Op : UNARY_OP, right : 'EXP};
=TEX
=SML
datatype €BIN_OP› =
			€spark_and›
		|	€spark_or›
		|	€spark_xor›
		|	€spark_eq›
		|	€spark_noteq›
		|	€spark_less›
		|	€spark_less_eq›
		|	€spark_greater›
		|	€spark_greater_eq›
		|	€spark_add›
		|	€spark_minus›
		|	€spark_times›
		|	€spark_intdiv›
		|	€spark_mod›
		|	€spark_rem›
		|	€spark_expon›
		|	€spark_mem›
		|	€spark_notmem›;
=TEX
=SML
type ('EXP) €Bin_Exp› = {Op : BIN_OP, left : 'EXP, right : 'EXP};
=TEX
=SML
type €MEM_OP› = BIN_OP;
=TEX
=SML
type ('EXP) €Mem_Range› = {left : 'EXP, Op : MEM_OP, range : ('EXP) Range};
=TEX
=SML
type €ATTRIB› = ID list;
=TEX
=SML
type ('ATTRIB_DESIG) €Attribute›
	= {prefix : ID, attribute_desig : 'ATTRIB_DESIG};
=TEX
=SML
type ('EXP) €Indexed_Comp›
	= {prefix : 'EXP, index : 'EXP};
=TEX
=SML
type ('EXP) €Selected_Comp›
	= {prefix : 'EXP, selector : ID};
=TEX
=SML
type ('EXP) €Fun_Call›
	= {fun_name : ID, args : 'EXP list};
=TEX
=SML
type €INT_LIT› = string;
=TEX
=SML
type Z_EXP = TERM;
=TEX
=SML
datatype €TYPE_DEF› =
			€enum_type_def› of Enum_Type_Def
		|	€int_type_def› of (EXP) Range
		|	€uncon_array_def› of Array_Def
		|	€con_array_def› of Array_Def
		|	€record_type_def› of Record_Type_Def
=TEX
=SML
and €CONSTRAINT› =
			€range_con› of (EXP) Range
		|	€index_con› of TMARK
=TEX
=SML
and €BASIC_DECL› =
			€const_decl› of (EXP) Const_Decl
		|	€type_decl› of (TYPE_DEF) Type_Decl
		|	€subtype_decl› of (CONSTRAINT) Subtype_Decl
=TEX
=SML
and €AGG_CHOICE› =
			€agg_choice_range› of (EXP) Range
		|	€agg_choice_single› of EXP
=TEX
=SML
and €ATTRIB_DESIG› =
			€attrib› of ATTRIB
		|	€attrib_arg› of (ATTRIB * EXP)
=TEX
=SML
and €EXP› =
		€Id› of ID | €int› of INT_LIT | €array_agg_pos› of (EXP) Agg_Pos |
		€array_agg_pos_others› of (EXP) Agg_Pos_Others |
		€array_agg_others› of (EXP) Agg_Others |
		€array_agg_named› of (AGG_CHOICE, EXP) Agg_Named |
		€array_agg_named_others› of (AGG_CHOICE, EXP) Agg_Named_Others |
		€rec_agg_pos› of (EXP) Agg_Pos | €rec_agg_named› of (EXP) Rec_Agg_Named |
		€unary_exp› of (EXP) Unary_Exp | €bin_exp› of (EXP) Bin_Exp |
		€mem_range› of (EXP) Mem_Range | €attribute› of (ATTRIB_DESIG) Attribute |
		€indexed_comp› of (EXP) Indexed_Comp |
		€selected_comp› of (EXP) Selected_Comp |
		€fun_call› of (EXP) Fun_Call |
		€auxiliary_exp› of Z_EXP;
=TEX

\subsection{Statements}

=SML
type Assign = {name : EXP, E : EXP};
=TEX
=SML
type Z_PRED = TERM;
=TEX
=SML
type Z_PREDâ0 = Z_PRED;
=TEX
=SML
type Z_ID = ID;
=TEX
=SML
type Spec = {w : ID list, w0 : ID list, pre : Z_PRED, post : Z_PRED};
=TEX
=SML
type Spec_No_Ivars = Spec;
=TEX
=SML
type COND = EXP;
=TEX
=SML
type ('STMT) If_Then_Else = {G : COND, P : 'STMT, Q : 'STMT};
=TEX
=SML
datatype CASE_CHOICE =
				case_exp of EXP
			|	case_range of (EXP) Range
=TEX
=SML
type ('STMT) Case_Alternative = {choices : CASE_CHOICE, P : 'STMT};
=TEX
=SML
type ('STMT) Case = {E : EXP, s : ('STMT) Case_Alternative list};
=TEX
=SML
type Loop = {T : Z_PRED, spec : Spec_No_Ivars};
=TEX
=SML
type While = {G : COND, loop : Loop};
=TEX
=SML
type STATIC_EXP = EXP;
=TEX
=SML
type For_Static = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : Loop};
=TEX
=SML
type For_Tmark = {i : ID, tmark : TMARK, loop : Loop};
=TEX
=SML
type Exit_When = {G : COND};
=TEX
=SML
type Return = {E : EXP};
=TEX
=SML
type Proc_Call = {name : ID, actuals : EXP list};
=TEX
=SML
type Proc_Call_No_Ivars = Proc_Call;
=TEX
=SML
datatype Stmt	= 	null
		|	assign of (Assign)
		|	spec_no_ivars of (Spec_No_Ivars)
		|	semicolon of (Stmt * Stmt)
		|	if_then_else of ((Stmt)If_Then_Else)
		|	kase of ((Stmt)Case)
		|	loop of (Loop)
		|	whyle of (While)
		|	for_static of (For_Static)
		|	for_tmark of (For_Tmark)
		|	exit_when of (Exit_When)
		|	exit
		|	ret of (Return)
		|	proc_no_ivars of (Proc_Call_No_Ivars);
=TEX
=SML
type Spec_Ivars = Spec;
=TEX
=SML
type For_Non_Static = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : Loop};
=TEX
=SML
fun €free_ids› (ze : Z_EXP) : ID list = (map (fst o dest_var) (frees ze));
=TEX
=SML
type Log_Con = {X : Z_ID, E : Z_EXP, spec : Spec, pre1 : Z_PRED};
=TEX
=SML
type Proc_Call_Ivars = Proc_Call;
=TEX
=SML
datatype Statement =
		 	stmt of (Stmt)
		|	spec_ivars of (Spec_Ivars * Stmt)
		|	for_non_static of (For_Non_Static * Stmt)
		|	log_con of (Log_Con * Stmt)
		|	proc_ivars of (Proc_Call_Ivars * Stmt);

=TEX
\section{EPILOGUE}
=SML
end (* of structure CNTypes *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
