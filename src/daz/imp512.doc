=IGN
********************************************************************************
imp512.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp512.doc   %Z% $Date: 2002/10/17 15:46:52 $ $Revision: 1.19 $ $RCSfile: imp512.doc,v $
% use_file "dtd512";PolyML.use "imp512";
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Compiler{C{\tiny OMPILER}}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Compliance Notation Reader/Writer}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP512}  %% Mandatory field
\def\SCCSversion{$Revision: 1.19 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/10/17 15:46:52 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & DAZ Team}
\TPPabstract{
This document contains the implementation for the Compliance Notation Reader/Writer.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1 - 1.4] Initial Drafts.

\item[Issue 1.5] First draft for comment.

\item[Issues 1.6, 1.7] Minor typographical corrections.

\item[Issue 1.8] Bug fixing.

\item[Issues 1.9-1.11 ] Recognition of annotations added (CTE 1).
\item [Issue 1.13]
Used the new $SymEndOfInput$ where apropriate.
\item[Issue 1.14] Updates for Poly/ML port.
\item[Issue 1.15] R0020: percent signs in comments (fixed by suppressing these errors).
\item[Issue 1.16] Treatment of `Q' in strings fixed.
\item[Issue 1.17] $Lex.Text$ items now split up into line-sized chunks.
\item[Issue 1.18] Copyright and banner updates for open source release.
\item[Issue 1.19] DAZ-specific updates to banner for open source release
\item[Issue 1.20] DAZ-specific updates to banner for open source release
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance notation reader/writer. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD512}.

\subsection{Introduction}
\subsection{Purpose and Background}

See \cite{ISS/HAT/DAZ/DTD512}.
%\subsection{Algorithms}
%\subsection{Dependencies}
%\subsection{Known Deficencies}
\subsection{Possible Enhancements}
None.
=TEX

\section{THE STRUCTURE $CNReaderWriter$}

=SMLPLAIN SML
structure €CNReaderWriter› : CNReaderWriter = struct

open ReaderWriterSupport;
=TEX

\section{WARNING MESSAGES}

Faults detected in the embedded text are reported via $local\_error$ as
they occur, they are also noted in the generated output using these
two functions.

=SMLPLAIN SML
fun €lex_error_code› (id : int, prev:string list) : string list = (
	", Lex.Text\"" :: (*="=*)
	"Lex.Error " ^ (string_of_int id) ::
	"\", " :: (*="=*)
	prev
);
=TEX
=SMLPLAIN SML
fun	€lex_error_codes› (nil : int list, prev:string list) : string list =
		prev
|	lex_error_codes (errnos, prev) =
		fold lex_error_code errnos prev;
=TEX

This is a function to print out the previous context upon an error.
=SMLPLAIN SML
fun €prev_context› (num:int) (prev:string list) : string = (
let
	val part1 = rev(prev to num);
	val part2 =	if length prev > num
			then	" ... " :: part1
			else	part1
in
	implode part2
end
);
=TEX

\section{STRINGS IN SPARK}

The following function is a re-implementation of $read\_symbol$ in \cite{DS/FMU/IED/IMP005}, adjusted to ignore keywords and treat percent signs as regular symbols. This is in accordance with the requirement to support SPARK strings, where no keyword recognition is required.
=SMLPLAIN SML
fun €cn_read_symbol› (R:READER_ENV) : SYMBOL = (
let
	fun formatters next =
	let
		fun aux prev next =
			if is_white next
			then	aux (next::prev) (#skip_and_look_at_next R ())
			else	prev;
	in
		SymWhite(aux nil next)
	end;

	val next = #look_at_next R ()
in
		if is_white next
		then	formatters next
		else
			let
				val ch = #advance R ();
				val ord_ch = ord ch
			in
				if ord_ch > 127
				then	case PrettyNames.find_char ch
					of Value info => SymKnown(ch, false, info)
					|  Nil	=> SymUnknownChar ch
				else
					SymCharacter ch
			end
end);
=TEX
=SMLPLAIN SML
fun €cn_string_body› (R:READER_ENV) (prev:string list, preverrs:int list)
			: (string list * int list) = (
	case cn_read_symbol R
	of SymCharacter ch => (
		case ch
		of "\"" =>	(*="=*)
				if #look_at_next R () = "\""
				then	(
					#advance R ();
					cn_string_body R ("\\\"" (*="=*) :: prev, preverrs))
				else	(
					("\"" (*="=*) :: prev, preverrs))
		|  "\^D" =>	fail "cn_string_body" 5002 nil
		|  "Q" =>	cn_string_body R ("Q"::prev, preverrs)
		|  "%" =>	cn_string_body R ("%"::prev, preverrs)
		|  "\\" =>	cn_string_body R ("\\\\"::prev, preverrs)
		|  _ =>		cn_string_body R (ch::prev, preverrs)
		)
	| SymEndOfInput => fail "cn_string_body" 5002 nil
	| SymDoublePercent => cn_string_body R ("%" :: prev, preverrs)
	| SymWhite wh => (	if contains wh "\n"
				then
					(	local_error "cn_string_body" 5014 [fn () =>
							prev_context 20 prev];
						(("5014\"" (*="=*)
						) :: prev, 5014 :: preverrs)
					)
				else
					cn_string_body R (wh@prev, preverrs))
	| sy as SymKnown _ =>
				cn_string_body R ((expand_symbol sy) :: prev, preverrs)
	| SymUnknownKw(sym, _) => (
				(* local_error "cn_string_body" 5003 [fn () => sym, fn () =>
					prev_context 20 prev]; *)
				cn_string_body R  ("* ERROR  5003 " :: prev, 5003 :: preverrs))
	| SymUnknownChar ch =>
				cn_string_body R
					(("\\" ^ string_of_int3(ord ch))::prev, preverrs)
);
=TEX

The result from $cn_string_body$ is a sequence of mainly one-character
strings, it seems appropriate to convert it to one long string at this
stage rather than retaining the space overhead until the whole input
text is formed.

=SMLPLAIN SML
fun €get_cn_string› (R:READER_ENV) (prev:string list) : string list * int list = (
let
	val (str, errs) = cn_string_body R (["\"" (*="=*)], nil)
in
	([implode(rev str)] @ prev, errs)
end);
=TEX

\section{SPARK COMMENTS}

These are handled in the lexical analyser. Unlike other {\Product} object
languages, we do not want misspelt keywords to give rise to an error here,
because something like \verb"-- % %" is a perfectly valid Ada comment.
This is achieved simply by suppressing the printing of the error message.

=TEX
\section{WHITE SPACE}
White space needs more complicated handling than with most other object languages.
This is because of the requirement to respect the line layout for hidden text (SPARK hide directive) and for arbitrary Ada replacements.
The following function turns a white space character into appropriate ML.
See the ML standard section 2.2 for the justification of the numbers in the last case.

=SMLPLAIN SML
fun €protect_space› (ch : string) : string = (
	case ch of
		" " => " "
	|	"\n" => "\\n"
	|	"\t" => "\\t"
	|	_ =>
		let	val ord_ch = ord ch;
		in	if	ord_ch < 32
			then	"\\^" ^ chr(ord_ch + 64)
			else	" "
		end	handle Fail _ => " "
);
=TEX
\section{COMPLIANCE NOTATION TEXT INPUT}\label{CNTI}

The following function eats compliance notation input, calling the special handlers for strings as required.
It reads and assembles the quoted text (i.e., the body of the quotation) and the closing text.
{\ftlinepenalty=9999
=SMLPLAIN SML
fun €get_cn_any› (R:READER_ENV) (prevA:string list) : string list= (
let
	open PrettyNames;

	fun	do_keyword _ (_,Value ch,Simple) p =
			get_cn_any R ((to_ML_string ch) :: p)
	|	do_keyword _ (names,Nil,Simple) p =
			get_cn_any R ("%" ^ (hd names) ^ "%" :: p)
	|	do_keyword k (info as (_,_, (Starting(proc, str)))) p =
			get_cn_any R (proc R k str false p)
	|	do_keyword _ (_,_,Middle str) p =
			get_cn_any R (str :: p)
	|	do_keyword (k, _) (_,ch_opt,Ending str) p =
			((*=[(("=*)	"\"))" :: to_ML_string k :: "\"], \"" ::
			to_ML_string str :: p)
	|	do_keyword _ (_,_,Ignore) p =
			get_cn_any R p
	|	do_keyword (k, is_keyword) (names,_,Invalid) p = (
			(* local_error "get_cn_any" 5007
				[fn () => if is_keyword then "%" ^ k ^ "%" else k]; *)
			get_cn_any R (lex_error_code(5007, p)));

	fun do_string () = (
		let	val (read_string, ol_name) = (get_cn_string,
					"Lex.String")
			val (str, errnos) = read_string R (ol_name :: "\", " :: prevA); (*="=*)
			val text_so_far = ", Lex.Text\"" (*="=*) :: str;
		in
			get_cn_any R (lex_error_codes(errnos, text_so_far))
		end
	);

in
	case read_symbol R
	of	SymCharacter ch => (
			case ch
			of "\""	=>	do_string () (*="=*)
			|  "\^D" =>	prevA
			|  "Q"	=>	get_cn_any R ("QQQQ" :: prevA)
			|  "\\"	=>	get_cn_any R ("\\\\" :: prevA)
			|  _ => 	get_cn_any R (ch :: prevA)
		)
	|	SymEndOfInput => prevA
	|	SymWhite chs =>  (
			if	contains chs "\n"
			then	get_cn_any R
				("\", Lex.Text\""  :: (implode (rev(map protect_space chs)) :: prevA))
			else	get_cn_any R
				(implode (rev(map protect_space chs)) :: prevA))
	|	SymKnown(sym, is_keyword, info) => do_keyword (sym, is_keyword) info prevA
	|	SymDoublePercent => get_cn_any R ("%%" :: prevA)
	|	SymUnknownKw(sym, is_closed) => (
(*
			local_error "get_cn_any" 5003 [fn () => sym, fn () =>
							implode(rev(" ... " :: (prevA to 20)))]; *)
			get_cn_any R (lex_error_code(5003, prevA))
		)
	|	SymUnknownChar ch => (
			local_error "get_cn_any" 5005
						[fn () => ch,
						fn () => string_of_int(ord ch),
						fn () => implode(" ... " :: (rev(prevA to 20)))];
				get_cn_any R (lex_error_code(5005, prevA))
		)
end);
=TEX
}

\section{COMPLIANCE NOTATION READER FUNCTION}

Function $cn\_reader$ is responsible for building the opening part of the Standard~ML text; the function $get\_cn\_any$ (see above) reads and assembles the quoted text (i.e., the body of the quotation) and the closing text.

=SMLPLAIN SML
fun €cn_reader› (recogniser:string) (R:READER_ENV)
		(start:string, is_keyword:bool)
		(lang:string) (opening:string) (prevA:string list) : string list = (
let
	val prevB =
		opening ::
		"\", [Lex.Text\"" ::
		to_ML_string lang ::
		"\", \"" ::
		to_ML_string start ::
		"(\"" (*=")=*) ::
		recogniser ::
		"(" ::
		prevA;

	val read_text = get_cn_any R prevB;
in
		";" :: read_text
end
);
=TEX

\section{EPILOGUE}
=SMLPLAIN
end (* of structure CNReaderWriter *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

