% imp501.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Toolkit Extensions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP501}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthanlocation 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN 
parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1] Initial Versions.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the theory `cn'.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD509}.

\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}

\subsection{Dependencies}

\subsection{Known Deficencies}

\subsection{Possible Enhancements}
\section{PROLOGUE}
=SML
structure €CNToolkitExtensions› (* : CNToolkitExtensions *) = struct
=TEX
\section{THEOREMS}



=SML
val _ = set_pc"z_library";
=TEX
=SML
val €cn_boolean_thm› = (
set_goal([], ÒBOOLEAN = {FALSE, TRUE}Æ);
a(rewrite_tac[z_get_specÒBOOLEANÆ,z_get_specÒTRUEÆ,z_get_specÒFALSEÆ]);
a(rewrite_tac [z_dots_def]);
a(PC_T "z_sets_ext" (REPEAT strip_tac) THEN_TRY asm_rewrite_tac[]);
a(strip_asm_tac (z_µ_elimÒx1Æz_Ó_cases_thm));
(* *** Goal "1" *** *)
a(all_fc_tac[z_º_less_trans_thm]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[z_º_antisym_thm]);
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
save_pop_thm"cn_boolean_thm"
);
=TEX
=SML
val cn_succ_thm = (
set_goal([],Òµ i, j : U ∑ (i,j) ç succ ¥ j = i + 1Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_get_specÒsuccÆ));
a(all_fc_tac [z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
a(lemma_tacÒi ç ÓÆ);
(* *** Goal "1" *** *)
a(PC_T1 "z_fun_ext" asm_prove_tac []);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(fn _ => pop_thm()) "cn_succ_thm"
);
=TEX
=SML
val cn_succ_0_thm = (
set_goal([],Òsucc 0 = 1Æ);
a(asm_tac z_0_Ó_thm);
a(strip_asm_tac (z_get_specÒsuccÆ));
a(z_spec_asm_tac Òµ n : Ó ∑ succ n = n + 1Æ Ò0Æ);
a(asm_rewrite_tac[]);
(fn _ => pop_thm())"cn_succ_0_thm"
);
=TEX
=SML
val cn_boolean_succ_thm = (
set_goal([], ÒBOOLEANvSUCC = {FALSE Ì TRUE}Æ);
a(rewrite_tac[z_get_specÒBOOLEANvSUCCÆ]);
a(rewrite_tac[cn_boolean_thm, z_get_specÒBOOLEANvLASTÆ]);
a(rewrite_tac[z_get_specÒTRUEÆ,z_get_specÒFALSEÆ]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(strip_asm_tac cn_succ_thm);
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1);
a(strip_asm_tac cn_succ_0_thm);
a(strip_asm_tac (z_get_specÒsuccÆ));
a(asm_tac z_0_Ó_thm);
a(all_asm_fc_tac[z_≠_app_eq_§_ç_rel_thm]);
save_pop_thm"cn_boolean_succ_thm"
);
=TEX
=SML
val cn_boolean_pred_thm = (
set_goal([], ÒBOOLEANvPRED = {TRUE Ì FALSE}Æ);
a(rewrite_tac[z_get_specÒBOOLEANvPREDÆ]);
a(rewrite_tac[z_get_specÒBOOLEANvSUCCÆ]);
a(rewrite_tac[cn_boolean_thm, z_get_specÒBOOLEANvLASTÆ]);
a(rewrite_tac[z_get_specÒTRUEÆ,z_get_specÒFALSEÆ]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(strip_asm_tac cn_succ_thm);
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1);
a(strip_asm_tac cn_succ_0_thm);
a(strip_asm_tac (z_get_specÒsuccÆ));
a(asm_tac z_0_Ó_thm);
a(all_asm_fc_tac[z_≠_app_eq_§_ç_rel_thm]);
save_pop_thm"cn_boolean_pred_thm"
);
=TEX
=SML
val cn_boolean_pos_thm = (
set_goal([],ÒBOOLEANvPOS = id BOOLEANÆ);
a(rewrite_tac[z_get_specÒBOOLEANvPOSÆ]);
save_pop_thm"cn_boolean_pos_thm"
);
=TEX
=SML
val cn_boolean_val_thm = (
set_goal([], ÒBOOLEANvVAL = id BOOLEANÆ);
a(rewrite_tac[z_get_specÒBOOLEANvVALÆ]);
a(rewrite_tac[cn_boolean_pos_thm]);
a(rewrite_tac[cn_boolean_thm,z_get_specÒTRUEÆ,z_get_specÒFALSEÆ]);
a(PC_T1 "z_library_ext" prove_tac[]);
save_pop_thm"cn_boolean_val_thm"
);
=TEX
=SML
val €cn_≥_true_eq_false_thm› = (
set_goal([], Ò≥TRUE = FALSEÆ);
a(rewrite_tac[z_get_specÒTRUEÆ, z_get_specÒFALSEÆ]);
save_pop_thm"cn_≥_true_eq_false_thm"
);
=TEX
=SML
val €cn_boolean_cases_thm› = (
set_goal([], Òµx:BOOLEAN∑ x = TRUE ≤ x = FALSEÆ);
a(rewrite_tac[z_get_specÒTRUEÆ, z_get_specÒFALSEÆ, z_get_specÒBOOLEANÆ]);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒxÆz_Ó_cases_thm));
(* *** Goal "1" *** *)
a(all_fc_tac[z_º_less_trans_thm]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[z_º_antisym_thm]);
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
save_pop_thm"cn_boolean_cases_thm"
);
=TEX
=SML
val €cn_false_true_boolean_thm› = (
set_goal([], ÒFALSE ç BOOLEAN ± TRUE ç BOOLEANÆ);
a(rewrite_tac[z_get_specÒTRUEÆ, z_get_specÒFALSEÆ, z_get_specÒBOOLEANÆ]);
pop_thm()
);
=TEX
=SML
val €cn_boolean_not_thm› = (
set_goal([], Òµ p : U ∑ not Boolean p = Boolean (ê(≥p))Æ);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ÒpÆ THEN asm_rewrite_tac[z_get_specÒBooleanÆ]);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_get_specÒ(not_)Æ]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_get_specÒ(not_)Æ]);
(fn _ => pop_thm())"cn_boolean_not_thm"
);
=TEX
=SML
val cn_boolean_and_thm = (
set_goal([],Òµ p, q : U ∑ Boolean p and Boolean q = Boolean (ê(p ± q))Æ);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ÒpÆ
    THEN cases_tac ÒqÆ
    THEN asm_rewrite_tac[z_get_specÒBooleanÆ]
    THEN strip_asm_tac (z_get_specÒ(_ and _)Æ)
    THEN all_asm_fc_tac[]);
(fn _ => pop_thm())"cn_boolean_and_thm"
);
=TEX
=SML
val cn_boolean_or_thm = (
set_goal([],Òµ p, q : U ∑ Boolean p or Boolean q = Boolean (ê(p ≤ q))Æ);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ÒpÆ
    THEN cases_tac ÒqÆ
    THEN asm_rewrite_tac[z_get_specÒBooleanÆ]
    THEN strip_asm_tac (z_get_specÒ(_ or _)Æ)
    THEN all_asm_fc_tac[]);
(fn _ => pop_thm())"cn_boolean_or_thm"
);
=TEX
=SML
val cn_boolean_xor_thm = (
set_goal([],Òµ p, q : U ∑ Boolean p xor Boolean q = Boolean (ê(≥(p § q)))Æ);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ÒpÆ
    THEN cases_tac ÒqÆ
    THEN asm_rewrite_tac[z_get_specÒBooleanÆ]
    THEN strip_asm_tac (z_get_specÒ(_ xor _)Æ)
    THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(fn _ => pop_thm())"cn_boolean_xor_thm"
);
=TEX
=SML
val cn_boolean_eq_thm = (
set_goal([],Òµ p, q : U ∑ Boolean p = Boolean q § (p § q)Æ);
a(REPEAT_N 4 strip_tac);
a(cases_tac ÒpÆ THEN cases_tac ÒqÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ,cn_≥_true_eq_false_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ,z_get_specÒTRUEÆ,z_get_specÒFALSEÆ]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
(fn _ => pop_thm())"cn_boolean_eq_thm"
);
=TEX
=SML
val cn_boolean_clauses = (
set_goal([], ÒTRUE = Boolean true
    ± FALSE = Boolean false
    ± (µ p : U ∑ not Boolean p = Boolean (ê(≥p)))
    ± (µ p, q : U ∑ Boolean p and Boolean q = Boolean (ê(p ± q)))
    ± (µ p, q : U ∑ Boolean p or Boolean q = Boolean (ê(p ≤ q)))
    ± (µ p, q : U ∑ Boolean p xor Boolean q = Boolean (ê(≥(p § q))))
    ± (µ p, q : U ∑ Boolean p = Boolean q § (p § q))Æ);
a(rewrite_tac[cn_boolean_not_thm,cn_boolean_and_thm]);
a(rewrite_tac[cn_boolean_or_thm,cn_boolean_xor_thm]);
a(rewrite_tac[z_get_specÒBooleanÆ,cn_boolean_eq_thm]);
save_pop_thm "cn_boolean_clauses"
);
=TEX
=SML
val cn_boolean_ran_type_thm = (
set_goal([],Òµ x : U ∑ Boolean x ç BOOLEANÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(rewrite_rule[z_get_specÒBOOLÆ](z_get_specÒBooleanÆ)));
a(LEMMA_T Òx ç UÆ asm_tac);
(* *** Goal "1" *** *)
a(prove_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[z_fun_dom_clauses]);
a(all_asm_fc_tac[z_fun_ç_clauses]);
(fn _ => pop_thm()) "cn_boolean_ran_type_thm"
);
=TEX
=SML
val cn_mem_def_thm = (
set_goal([],Òµ x : U; S :  U ∑ x mem S = TRUE § x ç SÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[cn_false_true_boolean_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_mem_)Æ)));
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacÒx mem S = TRUEÆ);
a(z_spec_nth_asm_tac 5 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ);
(* *** Goal "2.2" *** *)
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x mem S = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(z_spec_nth_asm_tac 4 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ);
(fn _ => pop_thm()) "cn_mem_def_thm"
);
=TEX
=SML
val cn_mem_boolean_thm = (
set_goal([],Òµ x : U; S : U ∑ x mem S = Boolean (x ç S)Æ);
a(REPEAT strip_tac);
a(cases_tac Òx ç SÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_mem_def_thm);
a(z_spec_nth_asm_tac 1 Ò(x¶x,S¶S)Æ);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_mem_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 Ò(x¶x,S¶S)Æ);
a(lemma_tacÒx mem S ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_mem_)Æ)));
a(LIST_DROP_NTH_ASM_T [1,2,3,4] discard_tac);
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(x,S) ç U ∏  UÆ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒx mem SÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_mem_boolean_thm"
);
=TEX
=SML
val cn_notmem_def_thm = (
set_goal([],Òµ x : U; S :  U ∑ x notmem S = TRUE § x é SÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[cn_false_true_boolean_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_notmem_)Æ)));
a(REPEAT_N 7 strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacÒx notmem S = TRUEÆ);
a(z_spec_nth_asm_tac 5 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ
    THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x notmem S = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(z_spec_nth_asm_tac 4 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ);
(fn _ => pop_thm()) "cn_notmem_def_thm"
);
=TEX
=SML
val cn_notmem_boolean_thm = (
set_goal([],Òµ x : U; S : U ∑ x notmem S = Boolean (ê(≥x ç S))Æ);
a(REPEAT strip_tac);
a(cases_tac Ò≥x ç SÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_notmem_def_thm);
a(z_spec_nth_asm_tac 1 Ò(x¶x,S¶S)Æ);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_notmem_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 Ò(x¶x,S¶S)Æ);
a(lemma_tacÒx notmem S ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_mem_)Æ)));
a(LIST_DROP_NTH_ASM_T [1,2,3,5] discard_tac);
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(x,S) ç U ∏  UÆ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒx notmem SÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_notmem_boolean_thm"
);
=TEX
=SML
val cn_eq_def_thm = (
set_goal([],Òµ x : U; y : U ∑ x eq y = TRUE § x = yÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ
    THEN1 asm_rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_eq_)Æ)));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacÒx eq y = TRUEÆ);
a(z_spec_nth_asm_tac 5 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x eq y = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(z_spec_nth_asm_tac 5 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ);
(fn _ => pop_thm()) "cn_eq_def_thm"
);
=TEX
=SML
val cn_eq_boolean_thm = (
set_goal([],Òµ x, y : U ∑ x eq y = Boolean (x = y)Æ);
a(REPEAT strip_tac);
a(cases_tac Òx = yÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_eq_def_thm);
a(z_spec_nth_asm_tac 1 Ò(x¶x,y¶y)Æ);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_eq_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 Ò(x¶x,y¶y)Æ);
a(lemma_tacÒx eq y ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_eq_)Æ)));
a(LIST_DROP_NTH_ASM_T [1,2,4,5] discard_tac);
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(x,y) ç U ∏ UÆ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒx eq yÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_eq_boolean_thm"
);
=TEX
=SML
val cn_noteq_def_thm = (
set_goal([],Òµ x : U; y : U ∑ x noteq y = TRUE § x Ω yÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ
    THEN rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_noteq_)Æ)));
a(REPEAT_N 7 strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacÒx noteq y = TRUEÆ);
a(z_spec_nth_asm_tac 5 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ
    THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x noteq y = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(LEMMA_T Òx ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ÒS ç  UÆ asm_tac THEN1 prove_tac[]);
a(z_spec_nth_asm_tac 5 Ò(x¶x,y¶y,S¶S,b¶TRUE)Æ);
(fn _ => pop_thm()) "cn_noteq_def_thm"
);
=TEX
=SML
val cn_noteq_boolean_thm = (
set_goal([],Òµ x, y : U ∑ x noteq y = Boolean (ê(≥x = y))Æ);
a(REPEAT strip_tac);
a(cases_tac Ò≥x = yÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_noteq_def_thm);
a(z_spec_nth_asm_tac 1 Ò(x¶x,y¶y)Æ);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_noteq_def_thm);
a(z_spec_nth_asm_tac 1 Ò(x¶y,y¶y)Æ);
a(contr_tac);
a(lemma_tacÒy noteq y ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ÒUÆ](z_get_specÒ(_noteq_)Æ)));
a(LIST_DROP_NTH_ASM_T [1,3,4,5] discard_tac);
a(LEMMA_T Òy ç UÆ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(y,y) ç U ∏ UÆ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒy noteq yÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_noteq_boolean_thm"
);
=TEX
=SML
val cn_less_def_thm = (
set_goal([],Òµ x : ˙; y : ˙ ∑ x less y = TRUE § x < yÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specÒ(_less_)Æ));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacÒx less y = TRUEÆ);
a(z_spec_nth_asm_tac 2 Ò(x¶x,y¶y,b¶TRUE)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x less y = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim Ò(x¶x,y¶y,b¶TRUE)Æ));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_less_def_thm"
);
=TEX
=SML
val cn_less_eq_def_thm = (
set_goal([],Òµ x : ˙; y : ˙ ∑ x less_eq y = TRUE § x º yÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specÒ(_less_eq_)Æ));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacÒx less_eq y = TRUEÆ);
a(z_spec_nth_asm_tac 2 Ò(x¶x,y¶y,b¶TRUE)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x less_eq y = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim Ò(x¶x,y¶y,b¶TRUE)Æ));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_less_eq_def_thm"
);
=TEX
=SML
val cn_greater_def_thm = (
set_goal([],Òµ x : ˙; y : ˙ ∑ x greater y = TRUE § x > yÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specÒ(_greater_)Æ));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacÒx greater y = TRUEÆ);
a(z_spec_nth_asm_tac 2 Ò(x¶x,y¶y,b¶TRUE)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x greater y = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim Ò(x¶x,y¶y,b¶TRUE)Æ));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_greater_def_thm"
);
=TEX
=SML
val cn_greater_eq_def_thm = (
set_goal([],Òµ x : ˙; y : ˙ ∑ x greater_eq y = TRUE § x æ yÆ);
a(lemma_tacÒTRUE ç BOOLEANÆ
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specÒ(_greater_eq_)Æ));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacÒx greater_eq y = TRUEÆ);
a(z_spec_nth_asm_tac 2 Ò(x¶x,y¶y,b¶TRUE)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacÒ≥ x greater_eq y = TRUEÆ);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim Ò(x¶x,y¶y,b¶TRUE)Æ));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_greater_eq_def_thm"
);
=TEX
=SML
val cn_less_boolean_thm = (
set_goal([],Òµ x, y : U ∑ x less y = Boolean (x < y)Æ);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac Òx < yÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_less_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim Ò(x¶x,y¶y)Æ));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_less_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 Ò(x¶x,y¶y)Æ);
a(lemma_tacÒx less y ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specÒ(_less_)Æ));
a(LIST_DROP_NTH_ASM_T [1,2,3,4] discard_tac);
a(LEMMA_T Òx ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(x,y)ç ˙ ∏ ˙Æ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒx less yÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_less_boolean_thm"
);
=TEX
=SML
val cn_less_eq_boolean_thm = (
set_goal([],Òµ x, y : U ∑ x less_eq y = Boolean (x º y)Æ);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac Òx º yÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_less_eq_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim Ò(x¶x,y¶y)Æ));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_less_eq_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 Ò(x¶x,y¶y)Æ);
a(lemma_tacÒx less_eq y ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specÒ(_less_eq_)Æ));
a(LIST_DROP_NTH_ASM_T [1,2,3,5] discard_tac);
a(LEMMA_T Òx ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(x,y)ç ˙ ∏ ˙Æ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒx less_eq yÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_less_eq_boolean_thm"
);
=TEX
=SML
val cn_greater_boolean_thm = (
set_goal([],Òµ x, y : U ∑ x greater y = Boolean (x > y)Æ);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac Òx > yÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_greater_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim Ò(x¶x,y¶y)Æ));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_greater_def_thm);
a(swap_nth_asm_concl_tac 2);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim Ò(x¶x,y¶y)Æ));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tacÒx greater y ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specÒ(_greater_)Æ));
a(LIST_DROP_NTH_ASM_T [1,2,4,5] discard_tac);
a(LEMMA_T Òx ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(x,y)ç ˙ ∏ ˙Æ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒx greater yÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_greater_boolean_thm"
);
=TEX
=SML
val cn_greater_eq_boolean_thm = (
set_goal([],Òµ x, y : U ∑ x greater_eq y = Boolean (x æ y)Æ);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac Òx æ yÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_greater_eq_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim Ò(x¶x,y¶y)Æ));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specÒBooleanÆ]);
a(strip_asm_tac cn_greater_eq_def_thm);
a(swap_nth_asm_concl_tac 2);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim Ò(x¶x,y¶y)Æ));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tacÒx greater_eq y ç BOOLEANÆ);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specÒ(_greater_eq_)Æ));
a(LIST_DROP_NTH_ASM_T [1,3,4,5] discard_tac);
a(LEMMA_T Òx ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Òy ç ˙Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T Ò(x,y)ç ˙ ∏ ˙Æ asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_≠_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimÒx greater_eq yÆcn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_greater_eq_boolean_thm"
);
=TEX
=SML
val cn_relational_clauses = (
set_goal([], Ò(µ x : U; S : U ∑ x mem S = Boolean (x ç S))
    ± (µ x : U; S : U ∑ x notmem S = Boolean (ê(≥x ç S)))
    ± (µ x, y : U ∑ x eq y = Boolean (x = y))
    ± (µ x, y : U ∑ x noteq y = Boolean (ê(≥x = y)))
    ± (µ x, y : U ∑ x less y = Boolean (x < y))
    ± (µ x, y : U ∑ x less_eq y = Boolean (x º y))
    ± (µ x, y : U ∑ x greater y = Boolean (x > y))
    ± (µ x, y : U ∑ x greater_eq y = Boolean (x æ y))Æ);
a(REPEAT strip_tac);
a(rewrite_tac[cn_mem_boolean_thm]);
a(rewrite_tac[cn_notmem_boolean_thm]);
a(rewrite_tac[cn_eq_boolean_thm]);
a(rewrite_tac[cn_noteq_boolean_thm]);
a(rewrite_tac[cn_less_boolean_thm]);
a(rewrite_tac[cn_less_eq_boolean_thm]);
a(rewrite_tac[cn_greater_boolean_thm]);
a(rewrite_tac[cn_greater_eq_boolean_thm]);
save_pop_thm"cn_relational_clauses"
);
=TEX
\section{PROOF PROCEDURES}
=TEX
\subbsection{Syntax Manipulation}
=SML
fun €dest_z_bin_op› (area : string) (msg : int)
	(n : string) : TERM -> TERM * TERM = (fn tm =>
	let	val (f, args) = (dest_z_app tm);
		val (cn, _) = dest_const f;
		val ops = dest_z_tuple args;
	in	if n = cn
		then (hd ops, hd(tl ops))
		else term_fail area msg [tm]
	end	handle Fail _ => term_fail area msg [tm]
);
=TEX
=SML
fun is_z_bin_op (n : string) : TERM -> bool = (
	let	val dest = dest_z_bin_op "is_z_bin_op" 0 n
	in	(fn tm =>
			(dest tm; true) handle Fail _ => false
		)
	end
);
=TEX
=SML
fun mk_z_simple_bin_op (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_z_app(tm, mk_z_tuple [a1, a2])
);
=TEX
=SML
val €˙› = î˙Æ;
fun €mk_˙_bin_op› (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let	val f = mk_z_simple_bin_op tm;
	in	(fn tt as (t1, t2) => (
			if	type_of t1 =: ˙
			then	if	type_of t2 =: ˙
				then	f tt
				else	term_fail area 509001 [t2]
			else	term_fail area 509001 [t1]
		))
	end
);
=TEX
=SML
val €dest_cn_intdiv› = dest_z_bin_op "dest_cn_intdiv" 509002 (fst(dest_constÒ(_intdiv_)Æ));
val €dest_cn_intmod› = dest_z_bin_op "dest_cn_intmod" 509004 (fst(dest_constÒ(_intmod_)Æ));
val €dest_cn_rem› = dest_z_bin_op "dest_cn_rem" 509003 (fst(dest_constÒ(_rem_)Æ));
val €dest_cn_star_star› = dest_z_bin_op "dest_cn_star_star" 509004 (fst(dest_constÒ(_**_)Æ));

val €is_cn_intdiv› = is_z_bin_op (fst(dest_constÒ(_intdiv_)Æ));
val €is_cn_intmod› = is_z_bin_op (fst(dest_constÒ(_intmod_)Æ));
val €is_cn_rem› = is_z_bin_op (fst(dest_constÒ(_rem_)Æ));
val €is_cn_star_star› = is_z_bin_op (fst(dest_constÒ(_**_)Æ));

val €mk_cn_intdiv› = mk_˙_bin_op "mk_cn_intdiv" Ò(_intdiv_)Æ;
val €mk_cn_intmod› = mk_˙_bin_op "mk_cn_intmod" Ò(_intmod_)Æ;
val €mk_cn_rem› = mk_˙_bin_op "mk_cn_rem" Ò(_rem_)Æ;
val €mk_cn_star_star› = mk_˙_bin_op "mk_cn_star_star" Ò(_**_)Æ;
=TEX
\subsection{Constant Expression Evaluation}
=SML
val €cn_intdiv_thm› = (
set_goal ([], ¨µx y∑ Ò≥y = 0 ¥
	(0 º x * y ¥ x intdiv y = abs x div abs y)
        ± (x * y < 0 ¥ x intdiv y = ~ (abs x div abs y))ÆÆ);
a(REPEAT µ_tac THEN strip_tac);
a(ante_tac (z_µ_elimÒ(x¶x, y¶y)Æ
		(±_right_elim (z_get_specÒ(_intdiv_)Æ))));
a(asm_rewrite_tac[]);
a taut_tac;
pop_thm()
);
=TEX
=SML
val €cn_rem_thm› = (
set_goal ([], ¨µx y∑ Ò≥y = 0 ¥
	(x rem y = x - (x intdiv y) * y)ÆÆ);
a(REPEAT µ_tac THEN strip_tac);
a(ante_tac (z_µ_elimÒ(x¶x, y¶y)Æ
		(±_right_elim (z_get_specÒ(_intdiv_)Æ))));
a(asm_rewrite_tac[]);
a(taut_tac);
pop_thm()
);
=TEX
=SML
val €cn_intmod_thm› = (
set_goal ([], ¨µx y∑ Ò≥y = 0 ¥
	((0 º x * y ≤ x rem y = 0 ¥ x intmod y = x rem y)
        ± (x * y < 0 ± ≥x rem y = 0 ¥ x intmod y = x rem y + y))ÆÆ);
a(REPEAT µ_tac THEN strip_tac);
a(ante_tac (z_µ_elimÒ(x¶x, y¶y)Æ
		(±_right_elim (z_get_specÒ(_intdiv_)Æ))));
a(asm_rewrite_tac[]);
a(taut_tac);
pop_thm()
);
=TEX
=SML
val €cn_star_star_0_thm› = (
set_goal ([], ¨µx∑ Òx ** 0 = 1ÆÆ);
a(REPEAT strip_tac);
a(ante_tac (z_µ_elimÒ(x¶x, y¶0)Æ(±_right_elim (z_get_specÒ(_**_)Æ))));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €cn_star_star_plus1_thm› = (
set_goal ([], ¨µx y∑ Ò0 º y ¥ x ** (y + 1) = x * (x ** y)ÆÆ);
a(REPEAT strip_tac);
a(ante_tac (z_µ_elimÒ(x¶x, y¶y)Æ(±_right_elim (z_get_specÒ(_**_)Æ))));
a(asm_rewrite_tac[] THEN taut_tac);
pop_thm()
);
=TEX
=SML
val z_zero = Ò0Æ;
val misc_thm1 = taut_rule¨µp∑(≥F ¥ p) ¥ pÆ;
val misc_thm2 = taut_rule¨µp∑(T ¥ p) ¥ pÆ;
val misc_thm3 = pc_rule1"z_library" prove_rule[]¨µi j∑Òi - j = i + ~jÆÆ;
val misc_thm4 = pc_rule1"z_library" prove_rule[]¨µi j∑Òi - ~j = i + jÆÆ;
val misc_thm5 = taut_rule¨µp∑(T ≤ p) § TÆ;
val misc_thm6 = taut_rule¨µp∑(p ≤ T) § TÆ;
val misc_thm7 = taut_rule¨µp∑(T ± ≥F) § TÆ;
fun €Z_LEFT_C› (c : CONV) : CONV = RAND_C (LEFT_C c);
fun €Z_RIGHT_C› (c : CONV) : CONV = RAND_C (RIGHT_C c);
fun €Z_RANDS_C› (c : CONV) : CONV = Z_LEFT_C c THEN_C Z_RIGHT_C c;
fun €Z_REL_LEFT_C› (c : CONV) : CONV = LEFT_C (LEFT_C c);
fun €Z_REL_RIGHT_C› (c : CONV) : CONV = LEFT_C (RIGHT_C c);
=TEX
=SML
val €cn_intdiv_conv› = (fn tm =>
	let	val (x, y) = dest_cn_intdiv tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
		val thm1 = list_µ_elim [x, y] cn_intdiv_thm;
		val thm2 = conv_rule (LEFT_C (RAND_C z_˙_eq_conv)) thm1;
		val thm3 = simple_¥_match_mp_rule misc_thm1 thm2;
		val left = ix * iy >= 0;
		val thm4 = (if left then ±_left_elim else ±_right_elim) thm3;
		val conv1 = 
			if left
			then (Z_REL_RIGHT_C z_times_conv THEN_C z_º_conv)
			else (Z_REL_LEFT_C z_times_conv THEN_C z_less_conv);
		val thm5 = conv_rule (LEFT_C conv1) thm4;
		val thm6 = simple_¥_match_mp_rule misc_thm2 thm5;
		val conv2 = Z_RANDS_C z_abs_conv  THEN_C z_div_conv;
		val conv3 = if left then conv2 else RIGHT_C conv2;
	in	conv_rule (RIGHT_C conv3) thm6	
	end	handle Fail _ => term_fail "cn_intdiv_conv" 509011 [tm]
);
=TEX
=SML
val €cn_rem_conv› = (fn tm =>
	let	val (x, y) = dest_cn_rem tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
		val thm1 = list_µ_elim [x, y] cn_rem_thm;
		val thm2 = conv_rule (LEFT_C (RAND_C z_˙_eq_conv)) thm1;
		val thm3 = simple_¥_match_mp_rule misc_thm1 thm2;
		val subtract_conv = simple_eq_match_conv misc_thm4
				ORELSE_C simple_eq_match_conv misc_thm3;
		val conv = Z_RIGHT_C(Z_LEFT_C cn_intdiv_conv THEN_C z_times_conv)
				THEN_C subtract_conv
				THEN_C z_plus_conv;
	in	conv_rule (RIGHT_C conv) thm3
	end	handle Fail _ => term_fail "cn_rem_conv" 509012 [tm]
);
=TEX
=SML
val €cn_intmod_conv› = (fn tm =>
	let	val (x, y) = dest_cn_intmod tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
		val thm1 = list_µ_elim [x, y] cn_intmod_thm;
		val thm2 = conv_rule (LEFT_C (RAND_C z_˙_eq_conv)) thm1;
		val thm3 = simple_¥_match_mp_rule misc_thm1 thm2;
		val left = ix * iy >= 0;
		val right = ix mod iy = 0;
	in	if	left orelse right
		then
	let	val thm4 = ±_left_elim thm3;
		val conv1 = 
			if left
			then LEFT_C (Z_REL_RIGHT_C z_times_conv THEN_C z_º_conv)
				THEN_C simple_eq_match_conv misc_thm5
			else RIGHT_C(LEFT_C cn_rem_conv THEN_C z_˙_eq_conv)
				THEN_C simple_eq_match_conv misc_thm6;
		val thm5 = conv_rule (LEFT_C conv1) thm4;
		val thm6 = simple_¥_match_mp_rule misc_thm2 thm5;
		val conv2 = RIGHT_C cn_rem_conv;
	in	conv_rule conv2 thm6
	end	else
	let	val thm4 = ±_right_elim thm3;
		val conv1 =  
			LEFT_C (Z_REL_LEFT_C z_times_conv THEN_C z_less_conv)
		THEN_C	RIGHT_C (RAND_C(LEFT_C cn_rem_conv THEN_C z_˙_eq_conv))
		THEN_C simple_eq_match_conv misc_thm7;
		val thm5 = conv_rule (LEFT_C conv1) thm4;
		val thm6 = simple_¥_match_mp_rule misc_thm2 thm5;
		val conv2 = RIGHT_C (Z_LEFT_C cn_rem_conv THEN_C z_plus_conv);
	in	conv_rule conv2 thm6
	end
	end	handle Fail _ => term_fail "cn_intmod_conv" 509013 [tm]
);
=TEX
=SML
val rec €cn_star_star_conv› = (fn tm =>
	let	val (x, y) = dest_cn_star_star tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
	in	if	iy = 0
		then	µ_elim x cn_star_star_0_thm
		else
	let	val thm1 = list_µ_elim
			[x, mk_z_signed_int (iy-1)] cn_star_star_plus1_thm;
		val thm2 = conv_rule (LEFT_C z_º_conv) thm1;
		val thm3 = simple_¥_match_mp_rule misc_thm2 thm2;
		val conv1 = LEFT_C (Z_RIGHT_C z_plus_conv);
		val thm4 = conv_rule conv1 thm3;
		val conv2 = Z_RIGHT_C cn_star_star_conv THEN_C z_times_conv;
	in	conv_rule (RIGHT_C conv2) thm4	
	end
	end	handle Fail _ => term_fail "cn_star_star_conv" 509014 [tm]
);
=TEX
\subsection{Proof Contexts}
 SML
val €cn_cxt1› = (flat o map (cthm_eqn_cxt (current_ad_rw_canon()))) [
	cn_boolean_thm,
	cn_boolean_succ_thm,
	cn_boolean_pred_thm,
	cn_boolean_pos_thm,
	cn_boolean_val_thm,
 	cn_boolean_clauses,
	cn_relational_clauses,
	z_get_specÒBOOLEANvFIRSTÆ,
	z_get_specÒBOOLEANvLASTÆ
];
val €cn_cxt2› = [

	(Òi intdiv jÆ, cn_intdiv_conv),
	(Òi rem jÆ, cn_rem_conv),
	(Òi intmod jÆ, cn_intmod_conv),
	(Òi ** jÆ, cn_star_star_conv)
];
val €cn_cxt› = cn_cxt1 @ cn_cxt2;

=IGN
map (fn (t, c) => TRY_C c t) cn_cxt;
=TEX
 SML
val _ = delete_pc "'cn" handle Fail _ => ();
val _ = new_pc €"'cn"›;
val _ = set_rw_eqn_cxt cn_cxt "'cn";
val _ = set_st_eqn_cxt cn_cxt "'cn";
val _ = set_sc_eqn_cxt cn_cxt "'cn";
val _ = commit_pc "'cn";
=TEX
 SML
val _ = delete_pc "cn" handle Fail _ => ();
val _ = new_pc €"cn"›;
val _ = merge_pcs ["'cn","z_library"] "cn";
val _ = commit_pc "cn";
=TEX
 SML
val _ = delete_pc "cn_ext" handle Fail _ => ();
val _ = new_pc €"cn_ext"›;
val _ = merge_pcs ["'cn","z_library_ext"] "cn_ext";
val _ = commit_pc "cn_ext";
=TEX
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNToolkitExtensions *);
open CNToolkitExtensions;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
