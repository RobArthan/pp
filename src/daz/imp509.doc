% imp501.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Toolkit Extensions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP501}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthanlocation 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN 
parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1] Initial Versions.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the theory `cn'.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD509}.

\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}

\subsection{Dependencies}

\subsection{Known Deficencies}

\subsection{Possible Enhancements}
\section{PROLOGUE}
=SML
structure ÛCNToolkitExtensionsİ (* : CNToolkitExtensions *) = struct
=TEX
\section{THEOREMS}



=SML
val _ = set_pc"z_library";
=TEX
=SML
val Ûcn_boolean_thmİ = (
set_goal([], ñBOOLEAN = {FALSE, TRUE}®);
a(rewrite_tac[z_get_specñBOOLEAN®,z_get_specñTRUE®,z_get_specñFALSE®]);
a(rewrite_tac [z_dots_def]);
a(PC_T "z_sets_ext" (REPEAT strip_tac) THEN_TRY asm_rewrite_tac[]);
a(strip_asm_tac (z_µ_elimñx1®z_î_cases_thm));
(* *** Goal "1" *** *)
a(all_fc_tac[z_¼_less_trans_thm]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[z_¼_antisym_thm]);
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
save_pop_thm"cn_boolean_thm"
);
=TEX
=SML
val cn_succ_thm = (
set_goal([],ñµ i, j : U · (i,j)  succ ´ j = i + 1®);
a(REPEAT strip_tac);
a(strip_asm_tac (z_get_specñsucc®));
a(all_fc_tac [z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
a(lemma_tacñi  î®);
(* *** Goal "1" *** *)
a(PC_T1 "z_fun_ext" asm_prove_tac []);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(fn _ => pop_thm()) "cn_succ_thm"
);
=TEX
=SML
val cn_succ_0_thm = (
set_goal([],ñsucc 0 = 1®);
a(asm_tac z_0_î_thm);
a(strip_asm_tac (z_get_specñsucc®));
a(z_spec_asm_tac ñµ n : î · succ n = n + 1® ñ0®);
a(asm_rewrite_tac[]);
(fn _ => pop_thm())"cn_succ_0_thm"
);
=TEX
=SML
val cn_boolean_succ_thm = (
set_goal([], ñBOOLEANvSUCC = {FALSE í TRUE}®);
a(rewrite_tac[z_get_specñBOOLEANvSUCC®]);
a(rewrite_tac[cn_boolean_thm, z_get_specñBOOLEANvLAST®]);
a(rewrite_tac[z_get_specñTRUE®,z_get_specñFALSE®]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(strip_asm_tac cn_succ_thm);
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1);
a(strip_asm_tac cn_succ_0_thm);
a(strip_asm_tac (z_get_specñsucc®));
a(asm_tac z_0_î_thm);
a(all_asm_fc_tac[z_­_app_eq_¤__rel_thm]);
save_pop_thm"cn_boolean_succ_thm"
);
=TEX
=SML
val cn_boolean_pred_thm = (
set_goal([], ñBOOLEANvPRED = {TRUE í FALSE}®);
a(rewrite_tac[z_get_specñBOOLEANvPRED®]);
a(rewrite_tac[z_get_specñBOOLEANvSUCC®]);
a(rewrite_tac[cn_boolean_thm, z_get_specñBOOLEANvLAST®]);
a(rewrite_tac[z_get_specñTRUE®,z_get_specñFALSE®]);
a(PC_T1 "z_library_ext" prove_tac[]);
(* *** Goal "1" *** *)
a(strip_asm_tac cn_succ_thm);
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1);
a(strip_asm_tac cn_succ_0_thm);
a(strip_asm_tac (z_get_specñsucc®));
a(asm_tac z_0_î_thm);
a(all_asm_fc_tac[z_­_app_eq_¤__rel_thm]);
save_pop_thm"cn_boolean_pred_thm"
);
=TEX
=SML
val cn_boolean_pos_thm = (
set_goal([],ñBOOLEANvPOS = id BOOLEAN®);
a(rewrite_tac[z_get_specñBOOLEANvPOS®]);
save_pop_thm"cn_boolean_pos_thm"
);
=TEX
=SML
val cn_boolean_val_thm = (
set_goal([], ñBOOLEANvVAL = id BOOLEAN®);
a(rewrite_tac[z_get_specñBOOLEANvVAL®]);
a(rewrite_tac[cn_boolean_pos_thm]);
a(rewrite_tac[cn_boolean_thm,z_get_specñTRUE®,z_get_specñFALSE®]);
a(PC_T1 "z_library_ext" prove_tac[]);
save_pop_thm"cn_boolean_val_thm"
);
=TEX
=SML
val Ûcn_³_true_eq_false_thmİ = (
set_goal([], ñ³TRUE = FALSE®);
a(rewrite_tac[z_get_specñTRUE®, z_get_specñFALSE®]);
save_pop_thm"cn_³_true_eq_false_thm"
);
=TEX
=SML
val Ûcn_boolean_cases_thmİ = (
set_goal([], ñµx:BOOLEAN· x = TRUE ² x = FALSE®);
a(rewrite_tac[z_get_specñTRUE®, z_get_specñFALSE®, z_get_specñBOOLEAN®]);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimñx®z_î_cases_thm));
(* *** Goal "1" *** *)
a(all_fc_tac[z_¼_less_trans_thm]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(all_fc_tac[z_¼_antisym_thm]);
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
save_pop_thm"cn_boolean_cases_thm"
);
=TEX
=SML
val Ûcn_false_true_boolean_thmİ = (
set_goal([], ñFALSE  BOOLEAN ± TRUE  BOOLEAN®);
a(rewrite_tac[z_get_specñTRUE®, z_get_specñFALSE®, z_get_specñBOOLEAN®]);
pop_thm()
);
=TEX
=SML
val Ûcn_boolean_not_thmİ = (
set_goal([], ñµ p : U · not Boolean p = Boolean ((³p))®);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ñp® THEN asm_rewrite_tac[z_get_specñBoolean®]);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_get_specñ(not_)®]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_get_specñ(not_)®]);
(fn _ => pop_thm())"cn_boolean_not_thm"
);
=TEX
=SML
val cn_boolean_and_thm = (
set_goal([],ñµ p, q : U · Boolean p and Boolean q = Boolean ((p ± q))®);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ñp®
    THEN cases_tac ñq®
    THEN asm_rewrite_tac[z_get_specñBoolean®]
    THEN strip_asm_tac (z_get_specñ(_ and _)®)
    THEN all_asm_fc_tac[]);
(fn _ => pop_thm())"cn_boolean_and_thm"
);
=TEX
=SML
val cn_boolean_or_thm = (
set_goal([],ñµ p, q : U · Boolean p or Boolean q = Boolean ((p ² q))®);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ñp®
    THEN cases_tac ñq®
    THEN asm_rewrite_tac[z_get_specñBoolean®]
    THEN strip_asm_tac (z_get_specñ(_ or _)®)
    THEN all_asm_fc_tac[]);
(fn _ => pop_thm())"cn_boolean_or_thm"
);
=TEX
=SML
val cn_boolean_xor_thm = (
set_goal([],ñµ p, q : U · Boolean p xor Boolean q = Boolean ((³(p ¤ q)))®);
a(REPEAT strip_tac THEN strip_asm_tac cn_false_true_boolean_thm);
a(cases_tac ñp®
    THEN cases_tac ñq®
    THEN asm_rewrite_tac[z_get_specñBoolean®]
    THEN strip_asm_tac (z_get_specñ(_ xor _)®)
    THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(fn _ => pop_thm())"cn_boolean_xor_thm"
);
=TEX
=SML
val cn_boolean_eq_thm = (
set_goal([],ñµ p, q : U · Boolean p = Boolean q ¤ (p ¤ q)®);
a(REPEAT_N 4 strip_tac);
a(cases_tac ñp® THEN cases_tac ñq®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®,cn_³_true_eq_false_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®,z_get_specñTRUE®,z_get_specñFALSE®]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
(fn _ => pop_thm())"cn_boolean_eq_thm"
);
=TEX
=SML
val cn_boolean_clauses = (
set_goal([], ñTRUE = Boolean true
    ± FALSE = Boolean false
    ± (µ p : U · not Boolean p = Boolean ((³p)))
    ± (µ p, q : U · Boolean p and Boolean q = Boolean ((p ± q)))
    ± (µ p, q : U · Boolean p or Boolean q = Boolean ((p ² q)))
    ± (µ p, q : U · Boolean p xor Boolean q = Boolean ((³(p ¤ q))))
    ± (µ p, q : U · Boolean p = Boolean q ¤ (p ¤ q))®);
a(rewrite_tac[cn_boolean_not_thm,cn_boolean_and_thm]);
a(rewrite_tac[cn_boolean_or_thm,cn_boolean_xor_thm]);
a(rewrite_tac[z_get_specñBoolean®,cn_boolean_eq_thm]);
save_pop_thm "cn_boolean_clauses"
);
=TEX
=SML
val cn_boolean_ran_type_thm = (
set_goal([],ñµ x : U · Boolean x  BOOLEAN®);
a(REPEAT strip_tac);
a(strip_asm_tac(rewrite_rule[z_get_specñBOOL®](z_get_specñBoolean®)));
a(LEMMA_T ñx  U® asm_tac);
(* *** Goal "1" *** *)
a(prove_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[z_fun_dom_clauses]);
a(all_asm_fc_tac[z_fun__clauses]);
(fn _ => pop_thm()) "cn_boolean_ran_type_thm"
);
=TEX
=SML
val cn_mem_def_thm = (
set_goal([],ñµ x : U; S : ğ U · x mem S = TRUE ¤ x  S®);
a(lemma_tacñTRUE  BOOLEAN®);
(* *** Goal "1" *** *)
a(rewrite_tac[cn_false_true_boolean_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_mem_)®)));
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacñx mem S = TRUE®);
a(z_spec_nth_asm_tac 5 ñ(x¦x,y¦y,S¦S,b¦TRUE)®);
(* *** Goal "2.2" *** *)
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x mem S = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(z_spec_nth_asm_tac 4 ñ(x¦x,y¦y,S¦S,b¦TRUE)®);
(fn _ => pop_thm()) "cn_mem_def_thm"
);
=TEX
=SML
val cn_mem_boolean_thm = (
set_goal([],ñµ x : U; S : U · x mem S = Boolean (x  S)®);
a(REPEAT strip_tac);
a(cases_tac ñx  S®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_mem_def_thm);
a(z_spec_nth_asm_tac 1 ñ(x¦x,S¦S)®);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_mem_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 ñ(x¦x,S¦S)®);
a(lemma_tacñx mem S  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_mem_)®)));
a(LIST_DROP_NTH_ASM_T [1,2,3,4] discard_tac);
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(x,S)  U ¸ ğ U® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñx mem S®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_mem_boolean_thm"
);
=TEX
=SML
val cn_notmem_def_thm = (
set_goal([],ñµ x : U; S : ğ U · x notmem S = TRUE ¤ x  S®);
a(lemma_tacñTRUE  BOOLEAN®);
(* *** Goal "1" *** *)
a(rewrite_tac[cn_false_true_boolean_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_notmem_)®)));
a(REPEAT_N 7 strip_tac);
(* *** Goal "2.1" *** *)
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacñx notmem S = TRUE®);
a(z_spec_nth_asm_tac 5 ñ(x¦x,y¦y,S¦S,b¦TRUE)®
    THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x notmem S = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(z_spec_nth_asm_tac 4 ñ(x¦x,y¦y,S¦S,b¦TRUE)®);
(fn _ => pop_thm()) "cn_notmem_def_thm"
);
=TEX
=SML
val cn_notmem_boolean_thm = (
set_goal([],ñµ x : U; S : U · x notmem S = Boolean ((³x  S))®);
a(REPEAT strip_tac);
a(cases_tac ñ³x  S®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_notmem_def_thm);
a(z_spec_nth_asm_tac 1 ñ(x¦x,S¦S)®);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_notmem_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 ñ(x¦x,S¦S)®);
a(lemma_tacñx notmem S  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_mem_)®)));
a(LIST_DROP_NTH_ASM_T [1,2,3,5] discard_tac);
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(x,S)  U ¸ ğ U® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñx notmem S®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_notmem_boolean_thm"
);
=TEX
=SML
val cn_eq_def_thm = (
set_goal([],ñµ x : U; y : U · x eq y = TRUE ¤ x = y®);
a(lemma_tacñTRUE  BOOLEAN®
    THEN1 asm_rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_eq_)®)));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacñx eq y = TRUE®);
a(z_spec_nth_asm_tac 5 ñ(x¦x,y¦y,S¦S,b¦TRUE)®);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x eq y = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(z_spec_nth_asm_tac 5 ñ(x¦x,y¦y,S¦S,b¦TRUE)®);
(fn _ => pop_thm()) "cn_eq_def_thm"
);
=TEX
=SML
val cn_eq_boolean_thm = (
set_goal([],ñµ x, y : U · x eq y = Boolean (x = y)®);
a(REPEAT strip_tac);
a(cases_tac ñx = y®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_eq_def_thm);
a(z_spec_nth_asm_tac 1 ñ(x¦x,y¦y)®);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_eq_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 ñ(x¦x,y¦y)®);
a(lemma_tacñx eq y  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_eq_)®)));
a(LIST_DROP_NTH_ASM_T [1,2,4,5] discard_tac);
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(x,y)  U ¸ U® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñx eq y®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_eq_boolean_thm"
);
=TEX
=SML
val cn_noteq_def_thm = (
set_goal([],ñµ x : U; y : U · x noteq y = TRUE ¤ x ½ y®);
a(lemma_tacñTRUE  BOOLEAN®
    THEN rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_noteq_)®)));
a(REPEAT_N 7 strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(eq_sym_asm_tacñx noteq y = TRUE®);
a(z_spec_nth_asm_tac 5 ñ(x¦x,y¦y,S¦S,b¦TRUE)®
    THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x noteq y = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(LEMMA_T ñx  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñS  ğ U® asm_tac THEN1 prove_tac[]);
a(z_spec_nth_asm_tac 5 ñ(x¦x,y¦y,S¦S,b¦TRUE)®);
(fn _ => pop_thm()) "cn_noteq_def_thm"
);
=TEX
=SML
val cn_noteq_boolean_thm = (
set_goal([],ñµ x, y : U · x noteq y = Boolean ((³x = y))®);
a(REPEAT strip_tac);
a(cases_tac ñ³x = y®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_noteq_def_thm);
a(z_spec_nth_asm_tac 1 ñ(x¦x,y¦y)®);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_noteq_def_thm);
a(z_spec_nth_asm_tac 1 ñ(x¦y,y¦y)®);
a(contr_tac);
a(lemma_tacñy noteq y  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_gen_pred_elim[ñU®](z_get_specñ(_noteq_)®)));
a(LIST_DROP_NTH_ASM_T [1,3,4,5] discard_tac);
a(LEMMA_T ñy  U® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(y,y)  U ¸ U® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñy noteq y®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_noteq_boolean_thm"
);
=TEX
=SML
val cn_less_def_thm = (
set_goal([],ñµ x : ú; y : ú · x less y = TRUE ¤ x < y®);
a(lemma_tacñTRUE  BOOLEAN®
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specñ(_less_)®));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacñx less y = TRUE®);
a(z_spec_nth_asm_tac 2 ñ(x¦x,y¦y,b¦TRUE)®);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x less y = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim ñ(x¦x,y¦y,b¦TRUE)®));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_less_def_thm"
);
=TEX
=SML
val cn_less_eq_def_thm = (
set_goal([],ñµ x : ú; y : ú · x less_eq y = TRUE ¤ x ¼ y®);
a(lemma_tacñTRUE  BOOLEAN®
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specñ(_less_eq_)®));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacñx less_eq y = TRUE®);
a(z_spec_nth_asm_tac 2 ñ(x¦x,y¦y,b¦TRUE)®);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x less_eq y = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim ñ(x¦x,y¦y,b¦TRUE)®));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_less_eq_def_thm"
);
=TEX
=SML
val cn_greater_def_thm = (
set_goal([],ñµ x : ú; y : ú · x greater y = TRUE ¤ x > y®);
a(lemma_tacñTRUE  BOOLEAN®
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specñ(_greater_)®));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacñx greater y = TRUE®);
a(z_spec_nth_asm_tac 2 ñ(x¦x,y¦y,b¦TRUE)®);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x greater y = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim ñ(x¦x,y¦y,b¦TRUE)®));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_greater_def_thm"
);
=TEX
=SML
val cn_greater_eq_def_thm = (
set_goal([],ñµ x : ú; y : ú · x greater_eq y = TRUE ¤ x ¾ y®);
a(lemma_tacñTRUE  BOOLEAN®
    THEN1 rewrite_tac[cn_false_true_boolean_thm]);
a(strip_asm_tac(z_get_specñ(_greater_eq_)®));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(eq_sym_asm_tacñx greater_eq y = TRUE®);
a(z_spec_nth_asm_tac 2 ñ(x¦x,y¦y,b¦TRUE)®);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(eq_sym_asm_tacñ³ x greater_eq y = TRUE®);
a(swap_nth_asm_concl_tac 1);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim ñ(x¦x,y¦y,b¦TRUE)®));
a(asm_rewrite_tac[]);
a(taut_tac);
(fn _ => pop_thm()) "cn_greater_eq_def_thm"
);
=TEX
=SML
val cn_less_boolean_thm = (
set_goal([],ñµ x, y : U · x less y = Boolean (x < y)®);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac ñx < y®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_less_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim ñ(x¦x,y¦y)®));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_less_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 ñ(x¦x,y¦y)®);
a(lemma_tacñx less y  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specñ(_less_)®));
a(LIST_DROP_NTH_ASM_T [1,2,3,4] discard_tac);
a(LEMMA_T ñx  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(x,y) ú ¸ ú® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñx less y®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_less_boolean_thm"
);
=TEX
=SML
val cn_less_eq_boolean_thm = (
set_goal([],ñµ x, y : U · x less_eq y = Boolean (x ¼ y)®);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac ñx ¼ y®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_less_eq_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim ñ(x¦x,y¦y)®));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_less_eq_def_thm);
a(swap_nth_asm_concl_tac 2);
a(z_spec_nth_asm_tac 2 ñ(x¦x,y¦y)®);
a(lemma_tacñx less_eq y  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specñ(_less_eq_)®));
a(LIST_DROP_NTH_ASM_T [1,2,3,5] discard_tac);
a(LEMMA_T ñx  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(x,y) ú ¸ ú® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñx less_eq y®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_less_eq_boolean_thm"
);
=TEX
=SML
val cn_greater_boolean_thm = (
set_goal([],ñµ x, y : U · x greater y = Boolean (x > y)®);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac ñx > y®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_greater_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim ñ(x¦x,y¦y)®));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_greater_def_thm);
a(swap_nth_asm_concl_tac 2);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim ñ(x¦x,y¦y)®));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tacñx greater y  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specñ(_greater_)®));
a(LIST_DROP_NTH_ASM_T [1,2,4,5] discard_tac);
a(LEMMA_T ñx  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(x,y) ú ¸ ú® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñx greater y®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_greater_boolean_thm"
);
=TEX
=SML
val cn_greater_eq_boolean_thm = (
set_goal([],ñµ x, y : U · x greater_eq y = Boolean (x ¾ y)®);
a(REPEAT strip_tac);
a(PC_T1 "z_predicates" cases_tac ñx ¾ y®);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_greater_eq_def_thm);
a(DROP_NTH_ASM_T 1 (ante_tac o z_µ_elim ñ(x¦x,y¦y)®));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_get_specñBoolean®]);
a(strip_asm_tac cn_greater_eq_def_thm);
a(swap_nth_asm_concl_tac 2);
a(DROP_NTH_ASM_T 2 (ante_tac o z_µ_elim ñ(x¦x,y¦y)®));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(lemma_tacñx greater_eq y  BOOLEAN®);
(* *** Goal "2.1" *** *)
a(DROP_ASMS_T discard_tac);
a(strip_asm_tac (z_get_specñ(_greater_eq_)®));
a(LIST_DROP_NTH_ASM_T [1,3,4,5] discard_tac);
a(LEMMA_T ñx  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñy  ú® asm_tac THEN1 prove_tac[]);
a(LEMMA_T ñ(x,y) ú ¸ ú® asm_tac THEN1 prove_tac[]);
a(all_asm_fc_tac[z_­_app_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(z_µ_elimñx greater_eq y®cn_boolean_cases_thm));
(fn _ => pop_thm()) "cn_greater_eq_boolean_thm"
);
=TEX
=SML
val cn_relational_clauses = (
set_goal([], ñ(µ x : U; S : U · x mem S = Boolean (x  S))
    ± (µ x : U; S : U · x notmem S = Boolean ((³x  S)))
    ± (µ x, y : U · x eq y = Boolean (x = y))
    ± (µ x, y : U · x noteq y = Boolean ((³x = y)))
    ± (µ x, y : U · x less y = Boolean (x < y))
    ± (µ x, y : U · x less_eq y = Boolean (x ¼ y))
    ± (µ x, y : U · x greater y = Boolean (x > y))
    ± (µ x, y : U · x greater_eq y = Boolean (x ¾ y))®);
a(REPEAT strip_tac);
a(rewrite_tac[cn_mem_boolean_thm]);
a(rewrite_tac[cn_notmem_boolean_thm]);
a(rewrite_tac[cn_eq_boolean_thm]);
a(rewrite_tac[cn_noteq_boolean_thm]);
a(rewrite_tac[cn_less_boolean_thm]);
a(rewrite_tac[cn_less_eq_boolean_thm]);
a(rewrite_tac[cn_greater_boolean_thm]);
a(rewrite_tac[cn_greater_eq_boolean_thm]);
save_pop_thm"cn_relational_clauses"
);
=TEX
\section{PROOF PROCEDURES}
=TEX
\subbsection{Syntax Manipulation}
=SML
fun Ûdest_z_bin_opİ (area : string) (msg : int)
	(n : string) : TERM -> TERM * TERM = (fn tm =>
	let	val (f, args) = (dest_z_app tm);
		val (cn, _) = dest_const f;
		val ops = dest_z_tuple args;
	in	if n = cn
		then (hd ops, hd(tl ops))
		else term_fail area msg [tm]
	end	handle Fail _ => term_fail area msg [tm]
);
=TEX
=SML
fun is_z_bin_op (n : string) : TERM -> bool = (
	let	val dest = dest_z_bin_op "is_z_bin_op" 0 n
	in	(fn tm =>
			(dest tm; true) handle Fail _ => false
		)
	end
);
=TEX
=SML
fun mk_z_simple_bin_op (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_z_app(tm, mk_z_tuple [a1, a2])
);
=TEX
=SML
val Ûúİ = ”ú®;
fun Ûmk_ú_bin_opİ (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let	val f = mk_z_simple_bin_op tm;
	in	(fn tt as (t1, t2) => (
			if	type_of t1 =: ú
			then	if	type_of t2 =: ú
				then	f tt
				else	term_fail area 509001 [t2]
			else	term_fail area 509001 [t1]
		))
	end
);
=TEX
=SML
val Ûdest_cn_intdivİ = dest_z_bin_op "dest_cn_intdiv" 509002 (fst(dest_constñ(_intdiv_)®));
val Ûdest_cn_intmodİ = dest_z_bin_op "dest_cn_intmod" 509004 (fst(dest_constñ(_intmod_)®));
val Ûdest_cn_remİ = dest_z_bin_op "dest_cn_rem" 509003 (fst(dest_constñ(_rem_)®));
val Ûdest_cn_star_starİ = dest_z_bin_op "dest_cn_star_star" 509004 (fst(dest_constñ(_**_)®));

val Ûis_cn_intdivİ = is_z_bin_op (fst(dest_constñ(_intdiv_)®));
val Ûis_cn_intmodİ = is_z_bin_op (fst(dest_constñ(_intmod_)®));
val Ûis_cn_remİ = is_z_bin_op (fst(dest_constñ(_rem_)®));
val Ûis_cn_star_starİ = is_z_bin_op (fst(dest_constñ(_**_)®));

val Ûmk_cn_intdivİ = mk_ú_bin_op "mk_cn_intdiv" ñ(_intdiv_)®;
val Ûmk_cn_intmodİ = mk_ú_bin_op "mk_cn_intmod" ñ(_intmod_)®;
val Ûmk_cn_remİ = mk_ú_bin_op "mk_cn_rem" ñ(_rem_)®;
val Ûmk_cn_star_starİ = mk_ú_bin_op "mk_cn_star_star" ñ(_**_)®;
=TEX
\subsection{Constant Expression Evaluation}
=SML
val Ûcn_intdiv_thmİ = (
set_goal ([], ¬µx y· ñ³y = 0 ´
	(0 ¼ x * y ´ x intdiv y = abs x div abs y)
        ± (x * y < 0 ´ x intdiv y = ~ (abs x div abs y))®®);
a(REPEAT µ_tac THEN strip_tac);
a(ante_tac (z_µ_elimñ(x¦x, y¦y)®
		(±_right_elim (z_get_specñ(_intdiv_)®))));
a(asm_rewrite_tac[]);
a taut_tac;
pop_thm()
);
=TEX
=SML
val Ûcn_rem_thmİ = (
set_goal ([], ¬µx y· ñ³y = 0 ´
	(x rem y = x - (x intdiv y) * y)®®);
a(REPEAT µ_tac THEN strip_tac);
a(ante_tac (z_µ_elimñ(x¦x, y¦y)®
		(±_right_elim (z_get_specñ(_intdiv_)®))));
a(asm_rewrite_tac[]);
a(taut_tac);
pop_thm()
);
=TEX
=SML
val Ûcn_intmod_thmİ = (
set_goal ([], ¬µx y· ñ³y = 0 ´
	((0 ¼ x * y ² x rem y = 0 ´ x intmod y = x rem y)
        ± (x * y < 0 ± ³x rem y = 0 ´ x intmod y = x rem y + y))®®);
a(REPEAT µ_tac THEN strip_tac);
a(ante_tac (z_µ_elimñ(x¦x, y¦y)®
		(±_right_elim (z_get_specñ(_intdiv_)®))));
a(asm_rewrite_tac[]);
a(taut_tac);
pop_thm()
);
=TEX
=SML
val Ûcn_star_star_0_thmİ = (
set_goal ([], ¬µx· ñx ** 0 = 1®®);
a(REPEAT strip_tac);
a(ante_tac (z_µ_elimñ(x¦x, y¦0)®(±_right_elim (z_get_specñ(_**_)®))));
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val Ûcn_star_star_plus1_thmİ = (
set_goal ([], ¬µx y· ñ0 ¼ y ´ x ** (y + 1) = x * (x ** y)®®);
a(REPEAT strip_tac);
a(ante_tac (z_µ_elimñ(x¦x, y¦y)®(±_right_elim (z_get_specñ(_**_)®))));
a(asm_rewrite_tac[] THEN taut_tac);
pop_thm()
);
=TEX
=SML
val z_zero = ñ0®;
val misc_thm1 = taut_rule¬µp·(³F ´ p) ´ p®;
val misc_thm2 = taut_rule¬µp·(T ´ p) ´ p®;
val misc_thm3 = pc_rule1"z_library" prove_rule[]¬µi j·ñi - j = i + ~j®®;
val misc_thm4 = pc_rule1"z_library" prove_rule[]¬µi j·ñi - ~j = i + j®®;
val misc_thm5 = taut_rule¬µp·(T ² p) ¤ T®;
val misc_thm6 = taut_rule¬µp·(p ² T) ¤ T®;
val misc_thm7 = taut_rule¬µp·(T ± ³F) ¤ T®;
fun ÛZ_LEFT_Cİ (c : CONV) : CONV = RAND_C (LEFT_C c);
fun ÛZ_RIGHT_Cİ (c : CONV) : CONV = RAND_C (RIGHT_C c);
fun ÛZ_RANDS_Cİ (c : CONV) : CONV = Z_LEFT_C c THEN_C Z_RIGHT_C c;
fun ÛZ_REL_LEFT_Cİ (c : CONV) : CONV = LEFT_C (LEFT_C c);
fun ÛZ_REL_RIGHT_Cİ (c : CONV) : CONV = LEFT_C (RIGHT_C c);
=TEX
=SML
val Ûcn_intdiv_convİ = (fn tm =>
	let	val (x, y) = dest_cn_intdiv tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
		val thm1 = list_µ_elim [x, y] cn_intdiv_thm;
		val thm2 = conv_rule (LEFT_C (RAND_C z_ú_eq_conv)) thm1;
		val thm3 = simple_´_match_mp_rule misc_thm1 thm2;
		val left = ix * iy >= 0;
		val thm4 = (if left then ±_left_elim else ±_right_elim) thm3;
		val conv1 = 
			if left
			then (Z_REL_RIGHT_C z_times_conv THEN_C z_¼_conv)
			else (Z_REL_LEFT_C z_times_conv THEN_C z_less_conv);
		val thm5 = conv_rule (LEFT_C conv1) thm4;
		val thm6 = simple_´_match_mp_rule misc_thm2 thm5;
		val conv2 = Z_RANDS_C z_abs_conv  THEN_C z_div_conv;
		val conv3 = if left then conv2 else RIGHT_C conv2;
	in	conv_rule (RIGHT_C conv3) thm6	
	end	handle Fail _ => term_fail "cn_intdiv_conv" 509011 [tm]
);
=TEX
=SML
val Ûcn_rem_convİ = (fn tm =>
	let	val (x, y) = dest_cn_rem tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
		val thm1 = list_µ_elim [x, y] cn_rem_thm;
		val thm2 = conv_rule (LEFT_C (RAND_C z_ú_eq_conv)) thm1;
		val thm3 = simple_´_match_mp_rule misc_thm1 thm2;
		val subtract_conv = simple_eq_match_conv misc_thm4
				ORELSE_C simple_eq_match_conv misc_thm3;
		val conv = Z_RIGHT_C(Z_LEFT_C cn_intdiv_conv THEN_C z_times_conv)
				THEN_C subtract_conv
				THEN_C z_plus_conv;
	in	conv_rule (RIGHT_C conv) thm3
	end	handle Fail _ => term_fail "cn_rem_conv" 509012 [tm]
);
=TEX
=SML
val Ûcn_intmod_convİ = (fn tm =>
	let	val (x, y) = dest_cn_intmod tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
		val thm1 = list_µ_elim [x, y] cn_intmod_thm;
		val thm2 = conv_rule (LEFT_C (RAND_C z_ú_eq_conv)) thm1;
		val thm3 = simple_´_match_mp_rule misc_thm1 thm2;
		val left = ix * iy >= 0;
		val right = ix mod iy = 0;
	in	if	left orelse right
		then
	let	val thm4 = ±_left_elim thm3;
		val conv1 = 
			if left
			then LEFT_C (Z_REL_RIGHT_C z_times_conv THEN_C z_¼_conv)
				THEN_C simple_eq_match_conv misc_thm5
			else RIGHT_C(LEFT_C cn_rem_conv THEN_C z_ú_eq_conv)
				THEN_C simple_eq_match_conv misc_thm6;
		val thm5 = conv_rule (LEFT_C conv1) thm4;
		val thm6 = simple_´_match_mp_rule misc_thm2 thm5;
		val conv2 = RIGHT_C cn_rem_conv;
	in	conv_rule conv2 thm6
	end	else
	let	val thm4 = ±_right_elim thm3;
		val conv1 =  
			LEFT_C (Z_REL_LEFT_C z_times_conv THEN_C z_less_conv)
		THEN_C	RIGHT_C (RAND_C(LEFT_C cn_rem_conv THEN_C z_ú_eq_conv))
		THEN_C simple_eq_match_conv misc_thm7;
		val thm5 = conv_rule (LEFT_C conv1) thm4;
		val thm6 = simple_´_match_mp_rule misc_thm2 thm5;
		val conv2 = RIGHT_C (Z_LEFT_C cn_rem_conv THEN_C z_plus_conv);
	in	conv_rule conv2 thm6
	end
	end	handle Fail _ => term_fail "cn_intmod_conv" 509013 [tm]
);
=TEX
=SML
val rec Ûcn_star_star_convİ = (fn tm =>
	let	val (x, y) = dest_cn_star_star tm;
		val ix = dest_z_signed_int x;
		val iy = dest_z_signed_int y;
	in	if	iy = 0
		then	µ_elim x cn_star_star_0_thm
		else
	let	val thm1 = list_µ_elim
			[x, mk_z_signed_int (iy-1)] cn_star_star_plus1_thm;
		val thm2 = conv_rule (LEFT_C z_¼_conv) thm1;
		val thm3 = simple_´_match_mp_rule misc_thm2 thm2;
		val conv1 = LEFT_C (Z_RIGHT_C z_plus_conv);
		val thm4 = conv_rule conv1 thm3;
		val conv2 = Z_RIGHT_C cn_star_star_conv THEN_C z_times_conv;
	in	conv_rule (RIGHT_C conv2) thm4	
	end
	end	handle Fail _ => term_fail "cn_star_star_conv" 509014 [tm]
);
=TEX
\subsection{Proof Contexts}
 SML
val Ûcn_cxt1İ = (flat o map (cthm_eqn_cxt (current_ad_rw_canon()))) [
	cn_boolean_thm,
	cn_boolean_succ_thm,
	cn_boolean_pred_thm,
	cn_boolean_pos_thm,
	cn_boolean_val_thm,
 	cn_boolean_clauses,
	cn_relational_clauses,
	z_get_specñBOOLEANvFIRST®,
	z_get_specñBOOLEANvLAST®
];
val Ûcn_cxt2İ = [

	(ñi intdiv j®, cn_intdiv_conv),
	(ñi rem j®, cn_rem_conv),
	(ñi intmod j®, cn_intmod_conv),
	(ñi ** j®, cn_star_star_conv)
];
val Ûcn_cxtİ = cn_cxt1 @ cn_cxt2;

=IGN
map (fn (t, c) => TRY_C c t) cn_cxt;
=TEX
 SML
val _ = delete_pc "'cn" handle Fail _ => ();
val _ = new_pc Û"'cn"İ;
val _ = set_rw_eqn_cxt cn_cxt "'cn";
val _ = set_st_eqn_cxt cn_cxt "'cn";
val _ = set_sc_eqn_cxt cn_cxt "'cn";
val _ = commit_pc "'cn";
=TEX
 SML
val _ = delete_pc "cn" handle Fail _ => ();
val _ = new_pc Û"cn"İ;
val _ = merge_pcs ["'cn","z_library"] "cn";
val _ = commit_pc "cn";
=TEX
 SML
val _ = delete_pc "cn_ext" handle Fail _ => ();
val _ = new_pc Û"cn_ext"İ;
val _ = merge_pcs ["'cn","z_library_ext"] "cn_ext";
val _ = commit_pc "cn_ext";
=TEX
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNToolkitExtensions *);
open CNToolkitExtensions;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
