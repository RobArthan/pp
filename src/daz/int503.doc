% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% The ML code in this document produces a number of theory listings in /tmp
% The following shell commands combine these into 1 file for inclusion
% in the printed document
% cat /tmp/INT503*.th.doc >int503.th.doc
% doctex int503.th
% rm /tmp/INT503*.th.doc

% TQtemplate.tex
% use_file "daz_init";
% use_file "int503";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Soundness Checks Test Material}  %% Mandatory field
\def\TPPheadtitle{Soundness Checks Test Material}
\TPPref{ISS/HAT/DAZ/INT503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives a Compliance Notation script with examples of each kind of check which needs to be applied.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-?] Initial Drafts.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501}.
\subsection{Introduction}
To test the correct application of checks it is useful to have a set of examples which exercise the checks, i.e., exercising each check in volume I of \cite{DRA/CIS/CSE3/TR/94/27/1.2}

=SML
use_file "dtd013";
use_file "imp013";
=TEX
=SML
open_theory"cn";
force_delete_theory"int503" handle Fail _ => ();
new_script "int503";
=TEX
=SML
init_mt_results();
=TEX

\section{THE LITERATE SCRIPTS}

\subsection{Check 1 (a)}

The variables that may change in $st$ must be a subset of the frame in the $Spec$ of $Speclab$.

¹CN
procedure proc1a (x, y : in out integer) is
   z : integer;
begin
   „ X,Y [X=0 ± Y=1]		(1)
end proc1a;
°
=SML
fun Ûcheck1aÝ () = ¹CN
(1) Ã
	„ Z [X=0 ± Y=1]
 °
=TEX

\subsection{Check 1 (b)}

If $st$ contains a $return$ statement then $formal\_body\_flag$ must be $True$.

¹CN
function func1b (x : integer) return integer
is
   z : integer;
begin
   „ [FUNC1B X = 0]	(2)
end func1b;
°

=SML
fun Ûcheck1bÝ () = ¹CN
(2) Ã return 0;
 °
=TEX

\subsection{Check 1 (c)}

If $st$ contains an $exit$ statement then $till\_flag$ must be $True$.

¹CN
function func1c (x : integer) return integer is
   z : integer;
begin
   „ [T1 X = 0]	(3)
end func1c;
°

=SML
fun Ûcheck1cÝ () = ¹CN
(3) Ã exit;
 °
=TEX

\subsection{Check 1 (d)}

Any procedure call in $st$ must have a corresponding $Formal\_Proc$ in the $Speclab$.

¹CN
procedure proc1d (x : in out integer) is
begin
	x := 0;
end proc1d;
°

=SML
fun Ûcheck1dÝ () = ¹CN
procedure main (v : out integer)
„ V [V = 0]
is
begin
	proc1d (v);
end main;
 °
=TEX
=SML
store_mt_results mt_run_fail [
("check1a", check1a, (), gen_fail_msg "check_1_a" 505064 ["x, y", "z"]),
("check1b", check1b, (), gen_fail_msg "check_1_b" 505061 []),
("check1c", check1c, (), gen_fail_msg "check_1_c" 505062 []),
("check1d", check1d, (), gen_fail_msg "check_1_d" 505063 [])
];
=TEX
\subsection{Check 2}
This check is performed in the tests for checking the generated SPARK output and the generated Z document.

\subsection{Check 3}
See section \ref{CheckSO}

\subsection{Check 12}

¹CN
package pack12 is
	zero : constant integer := 0;
end pack12;
°

=SML
fun Ûcheck12Ý () = ¹CN
with pack12, pack12;
procedure main is
begin
   null;
end main;
 °
=TEX
store_mt_results mt_run_fail [
("check12", check12, (), gen_fail_msg "with_clause_check" 505031 [])
];

\subsection{Anti-Aliasing Check 1}

¹CN
procedure aa1 is
   a, b : integer;
   procedure p (x : in integer; y : out integer)
   „ Y [Y = B + 7]
   is
   begin
      y := b + 7;
   end p;
begin
   „ A, B [B = 29]	(11)
end aa1;
°

The following should report the anti aliasing check 1.

=SML
fun Ûcheck_a1Ý () = ¹CN
(11) Ã	a := 1;
	b := 2;
	p(a, a+b);
 °
=TEX
\subsection{Anti-Aliasing Check 2}

¹CN
procedure aa2 is
   a : integer;
   procedure p (y : out integer)
   „ Y [Y = A + 9]
   is
   begin
      y := a + 9;
   end p;
begin
   „ A [A = 25]	(12)
end aa2;
°

=SML
fun Ûcheck_a2Ý () = ¹CN
(12) Ã	a := 1;
	p(a);
 °
=TEX
\subsection{Anti-Aliasing Check 3}

¹CN
procedure aa3 is
   a : integer;
   procedure p (x : in integer)
   „ A [A = X + 9]
   is
   begin
      a := x + 8;
   end p;
begin
   „ A [A = 40]	(13)
end aa3;
°

=SML
fun Ûcheck_a3Ý () = ¹CN
(13) Ã	a := 1;
	p(a);
 °
=TEX

\subsection{Anti-Aliasing Check 4}

¹CN
procedure aa4 is
   a : integer;
   procedure p (x : in integer; y : out integer)
   „ Y [Y = X + 16]
   is
   begin
      y := x + 16;
   end p;
begin
   „ A [A = 100]	(14)
end aa4;
°

=SML
fun Ûcheck_a4Ý () = ¹CN
(14) Ã	a := 1;
	p(a, a);
 °
=TEX

=SML
store_mt_results_show mt_run_fail [
("check_a1", check_a1, (), gen_fail_msg "anti_aliasing_check_1"
				505069 ["p"]),
("check_a2", check_a2, (), gen_fail_msg "anti_aliasing_check_2"
				505071 ["","p","a"]),
("check_a3", check_a3, (), gen_fail_msg "anti_aliasing_check_3"
				505072 ["", "p", "a"]),
("check_a4", check_a4, (), gen_fail_msg "anti_aliasing_check_4"
				505073 ["", "p", "a"])
];
=TEX

\subsection{Variable Capture Checks - SPARK Identifiers}

=SML
fun Ûcheck_vcc1Ý () = ¹CN
procedure vcc1 is
   i, i : integer;
begin
	null;
end vcc1;
 °
=TEX

=SML
fun Ûcheck_vcc2Ý () = ¹CN
procedure vcc2 is
   i : integer;
   i : integer;
begin
	null;
end vcc2;
 °
=TEX

=SML
fun Ûcheck_vcc3Ý () = ¹CN
procedure vcc3 is
   X : integer;
begin
	CON X : ú · „ [I = X]
	null;
end vcc3;
 °
=TEX

=SML
fun Ûcheck_vcc4Ý () = ¹CN
package pack_vcc4 is
   x : integer;
   auxiliary X:ú;
end pack_vcc4;
 °
=TEX

\section{EXECUTING THE TESTS}

=SML
store_mt_results mt_run_fail [
("check_vcc1", check_vcc1, (), gen_fail_msg "check_new_spark_ids"
					505075 []),
("check_vcc2", check_vcc2, (), gen_fail_msg "check_new_spark_ids"
					505074 ["I"]),
("check_vcc3", check_vcc3, (), gen_fail_msg "check_new_z_id"
					505074 ["X"]),
("check_vcc4", check_vcc4, (), gen_fail_msg "check_new_z_id"
					505074 ["X"])
];
=TEX

\subsection{Checks during Spark Output}\label{CheckSO}

Check that the closest-containing compound statement of an EXIT WHEN G statement is be a loop statement.

=SML
CNZGenerator.restart_cn_z_generator();
=TEX

¹CN
procedure check3a1
is
	x : integer;
begin
   loop
	„ X [true]	(5)
   end loop;
end check3a1;
°

¹CN
(5) Ã	exit when ûX eq 25ý;
°

=SML
store_mt_results_show mt_run [
("check_3a1", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX

¹CN
procedure check3a2
is
	x : integer;
begin
	exit when ûX eq 30ý;
end check3a2;
°

Check that it fails 
=SML
store_mt_results_show mt_run_fail [
("check_3a", print_spark_program, (), gen_fail_msg "check_3a"
					505065 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

¹CN
procedure check3b1
is
	x : integer;
begin
   loop
   if x = 0
   then
	exit;
   end if;
   end loop;
end check3b1;
°
=SML
store_mt_results_show mt_run [
("check_3b1", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX

¹CN
procedure check3b2
is
	x : integer;
begin
   if x = 0
   then
	exit;
   end if;
end check3b2;
°
=SML
store_mt_results_show mt_run_fail [
("check_3b2", print_spark_program, (), gen_fail_msg "check_3b"
					505066 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

¹CN
procedure check3b3
is
	x : integer;
begin
   if x = 0
   then
	exit;
   else
	null;
   end if;
end check3b3;
°
=SML
store_mt_results_show mt_run_fail [
("check_3b3", print_spark_program, (), gen_fail_msg "check_3b"
					505066 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

\subsection{Check 4}

¹CN
function check4a1 (x : in integer) return integer
is
begin
   return 0;
end check4a1;
°
=SML
store_mt_results_show mt_run [
("check_4a1", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX

¹CN
procedure check4a2 (x : in integer)
is
begin
   return 0;
end check4a2;
°
=SML
store_mt_results_show mt_run_fail [
("check_4a2", print_spark_program, (), gen_fail_msg "check_4a"
					505078 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

¹CN
function check4b1 (x : in integer) return integer
is
   y : integer;
begin
   return 0;
   y := 10;
end check4b1;
°
=SML
store_mt_results_show mt_run_fail [
("check_4b1", print_spark_program, (), gen_fail_msg "check_4b"
					505079 [])];
CNZGenerator.restart_cn_z_generator();
=TEX
¹CN
function check4b2 (x : in integer) return integer
is
   y : integer;
begin
   case x is
      when 0 =>	return 0;
      when 1 =>	return 10;
      when others =>
		return 99;
   end case;
end check4b2;
°

=SML
store_mt_results_show mt_run [
("check_4b2", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX
¹CN
function check4b3 (x : in integer) return integer
is
   y : integer;
begin
   case x is
      when 0 =>	return 0;
      when 1 =>	return 10;
      when others =>
		y := 99;
   end case;
end check4b3;
°

=SML
store_mt_results_show mt_run_fail [
("check_4b3", print_spark_program, (), gen_fail_msg "check_4b"
					505079 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

\subsection{Check 5}

=GFT
package check5_1
is
   type coord is
   record
      x : integer;
      y : integer;
      z : integer;
   end record;
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0];
end check5_1;
=TEX

=GFT
package body check5_1 is
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0] is
   begin
       c := coord'(x|y|z => 0);
   end home;
end check5_1;
=TEX



=GFT
package check5_2
is
   type coord is
   record
      x : integer;
      y : integer;
      z : integer;
   end record;
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0];
end check5_2;
=TEX

=GFT
package body check5_2 is
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0] is
   begin
       c := coord'(x => 0, others => 0);
   end home;
end check5_2;
=TEX

\subsection{Checks 6 - 8}

Checks not implemented in the tool.

\subsection{Check 9}

TBS

\subsection{Check 10}

Checks not implemented in the tool.

\subsection{Check 11}
\subsection{Check 12}

See above.
\subsection{Check 13}

Checks not implemented in the tool.

\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX



\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
=IGN
