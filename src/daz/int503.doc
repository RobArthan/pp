% %Z% $Date$ $Revision$ $RCSfile$
=TEX

\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Soundness Checks Test Material}  %% Mandatory field
\def\TPPheadtitle{Soundness Checks Test Material}
\TPPref{ISS/HAT/DAZ/INT503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives a Compliance Notation script with examples of each kind of check which needs to be applied.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}
%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\TPPsetsizes
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\newpage

\section{DOCUMENT CONTROL}

\subsection{Contents List}
\tableofcontents
\pagebreak

\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1-1.9] Initial Drafts.
\item[Issue 1.10] Correction for enhanced error message.
\item[Issue 1.11] Minor clarification of diagnostic output.
\item[Issue 1.12] added till-clause to accommodate fixed checking (bug 12 V0.6).
\item[Issue 1.13] Changed to one compilation unit per script.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak

\section{GENERAL}

\subsection{Scope}
This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501}.

\subsection{Introduction}
To test the correct application of checks it is useful to have a set of examples which exercise the checks, i.e., exercising each check in volume I of \cite{DRA/CIS/CSE3/TR/94/27/1.2}

=SML
diag_line "These tests will generate loading, warning and error messages that can be ignored.";
diag_line "Only messages from the test harness should be considered.";
use_file "dtd013";
use_file "imp013";
=TEX
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX

=SML
open_theory"cn";
clean_up();
=TEX

=SML
init_mt_results();
=TEX

\section{THE LITERATE SCRIPTS}
\subsection{Check 1 (a)}

The variables that may change in $st$ must be a subset of the frame in the $Spec$ of $Speclab$.
=SML
new_script {name="int503_1a", state=initial_cn_state};
¹CN
procedure proc1a (x, y : in out integer) is
   z : integer;
begin
   „ X,Y [X=0 ± Y=1]		(1)
end proc1a;
°

=SML
fun Ûcheck1aÝ () = 
¹CN
(1) Ã
	„ Z [X=0 ± Y=1]
°

=TEX
=SML
store_mt_results mt_run_fail [
("check1a", check1a, (), gen_fail_msg "check_1_a" 505064 ["x, y", "z"])
];
=TEX

\subsection{Check 1 (b)}
If $st$ contains a $return$ statement then $formal\_body\_flag$ must be $True$.

=SML
new_script {name="int503_1b", state=initial_cn_state};
¹CN
function func1b (x : integer) return integer
is
   z : integer;
begin
   „ [FUNC1B X = 0]	(2)
end func1b;
°

=SML
fun Ûcheck1bÝ () = 
¹CN
(2) Ã return 0;
°

=TEX
=SML
store_mt_results mt_run_fail [
("check1b", check1b, (), gen_fail_msg "check_1_b" 505061 [])
];
=TEX

\subsection{Check 1 (c)}
If $st$ contains an $exit$ statement then $till\_flag$ must be $True$.

=SML
new_script {name="int503_1c", state=initial_cn_state};
¹CN
function func1c (x : integer) return integer is
   z : integer;
begin
   „ [T1 X = 0]	(3)
end func1c;
°

=SML
fun Ûcheck1cÝ () = 
¹CN
(3) Ã exit;
°

=TEX
=SML
store_mt_results mt_run_fail [
("check1c", check1c, (), gen_fail_msg "check_1_c" 505062 [])
];
=TEX

\subsection{Check 1 (d)}
Any procedure call in $st$ must have a corresponding $Formal\_Proc$ in the $Speclab$.

=SML
new_script {name="int503_1d", state=initial_cn_state};
fun Ûcheck1dÝ () = 
¹CN
procedure main (v : out integer)
„ V [V = 0]
is
	procedure proc1d (x : in out integer) is
	begin
		x := 0;
	end proc1d;
begin
	proc1d (v);
end main;
°

=TEX

=SML
store_mt_results mt_run_fail [
("check1d", check1d, (), gen_fail_msg "check_1_d" 505063 [])
];
=TEX

\subsection{Check 2}
This check is performed in the tests for checking the generated SPARK output and the generated Z document.

\subsection{Check 3}
See section \ref{CheckSO}

\subsection{Check 12}

=SML
new_script {name="int503_12", state=initial_cn_state};
¹CN
package pack12 is
	zero : constant integer := 0;
end pack12;
°

=SML
val state1 = get_cn_state();
new_script {name="int503_12a", state=state1};

fun Ûcheck12Ý () = 
¹CN
with pack12, pack12;
procedure main is
begin
   null;
end main;
°

=TEX
=SML
store_mt_results mt_run_fail [
("check12", check12, (), gen_fail_msg "with_clause_check" 507031 ["PACK12"])
];
=TEX
\subsection{Anti-Aliasing Check 1}
=SML
new_script {name="int503_aa1", state=initial_cn_state};

¹CN
procedure aa1 is
   a, b : integer;
   procedure p (x : in integer; y : out integer)
   „ Y [Y = B + 7]
   is
   begin
      y := b + 7;
   end p;
begin
   „ A, B [B = 29]	(11)
end aa1;
°

The following should report the anti aliasing check 1.

=SML
fun Ûcheck_a1Ý () = 
¹CN
(11) Ã	a := 1;
	b := 2;
	p(a, a+b);
°

=TEX
=SML
store_mt_results_show mt_run_fail [
("check_a1", check_a1, (), gen_fail_msg "anti_aliasing_check_1"
				505069 ["p"])
];
=TEX

\subsection{Anti-Aliasing Check 2}
=SML
new_script {name="int503_aa2", state=initial_cn_state};

¹CN
procedure aa2 is
   a : integer;
   procedure p (y : out integer)
   „ Y [Y = A + 9]
   is
   begin
      y := a + 9;
   end p;
begin
   „ A [A = 25]	(12)
end aa2;
°

=SML
fun Ûcheck_a2Ý () = 
¹CN
(12) Ã	a := 1;
	p(a);
°

=TEX
=SML
store_mt_results_show mt_run_fail [
("check_a2", check_a2, (), gen_fail_msg "anti_aliasing_check_2"
				505071 ["","p","a"])
];
=TEX

\subsection{Anti-Aliasing Check 3}

=SML
new_script {name="int503_aa3", state=initial_cn_state};

¹CN
procedure aa3 is
   a : integer;
   procedure p (x : in integer)
   „ A [A = X + 9]
   is
   begin
      a := x + 8;
   end p;
begin
   „ A [A = 40]	(13)
end aa3;
°

=SML
fun Ûcheck_a3Ý () = 
¹CN
(13) Ã	a := 1;
	p(a);
°

=TEX
=SML
store_mt_results_show mt_run_fail [
("check_a3", check_a3, (), gen_fail_msg "anti_aliasing_check_3"
				505072 ["", "p", "a"])
];
=TEX

\subsection{Anti-Aliasing Check 4}

=SML
new_script {name="int503_aa4", state=initial_cn_state};

¹CN
procedure aa4 is
   a : integer;
   procedure p (x : in integer; y : out integer)
   „ Y [Y = X + 16]
   is
   begin
      y := x + 16;
   end p;
begin
   „ A [A = 100]	(14)
end aa4;
°

=SML
fun Ûcheck_a4Ý () = 
¹CN
(14) Ã	a := 1;
	p(a, a);
°

=TEX

=SML
store_mt_results_show mt_run_fail [
("check_a4", check_a4, (), gen_fail_msg "anti_aliasing_check_4"
				505073 ["", "p", "a"])
];
=TEX

\subsection{Variable Capture Checks - SPARK Identifiers}
=SML
new_script {name="int503_vcc1", state=initial_cn_state};

=SML
fun Ûcheck_vcc1Ý () = 
¹CN
procedure vcc1 is
   i, i : integer;
begin
	null;
end vcc1;
°
=SML
store_mt_results mt_run_fail [
("check_vcc1", check_vcc1, (), gen_fail_msg "check_new_spark_ids"
					505075 [])
];
=TEX

=TEX

=SML
new_script {name="int503_vcc2", state=initial_cn_state};
fun Ûcheck_vcc2Ý () = 
¹CN
procedure vcc2 is
   i : integer;
   i : integer;
begin
	null;
end vcc2;
°
=SML
store_mt_results mt_run_fail [
("check_vcc2", check_vcc2, (), gen_fail_msg "check_new_z_id"
					505074 ["I"])
];
=TEX

=TEX

=SML
new_script {name="int503_vcc3", state=initial_cn_state};
fun Ûcheck_vcc3Ý () = 
¹CN
procedure vcc3 is
   X : integer;
begin
	CON X : ú · „ [I = X]
	null;
end vcc3;
°
=SML
store_mt_results mt_run_fail [
("check_vcc3", check_vcc3, (), gen_fail_msg "check_new_z_id"
					505074 ["X"])
];
=TEX

=SML
new_script {name="int503_vcc4", state=initial_cn_state};
fun Ûcheck_vcc4Ý () = 
¹CN
package pack_vcc4 is
   x : integer;
   auxiliary X:ú;
end pack_vcc4;
°

=TEX

=SML
store_mt_results mt_run_fail [
("check_vcc4", check_vcc4, (), gen_fail_msg "check_new_z_id"
					505074 ["X"])
];
=TEX

\subsection{Checks during Spark Output}\label{CheckSO}
Check that the closest-containing compound statement of an EXIT WHEN G statement is be a loop statement.

=SML
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c3a", state=initial_cn_state};
¹CN
procedure check3a1
is
	X : integer;
begin
   till  ûX = 25ý
   loop
	„ X [true]	(5)
   end loop;
end check3a1;
°

¹CN
(5) Ã	exit when ûX eq 25ý;
°

=SML
store_mt_results_show mt_run [
("check_3a1", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX
=SML
new_script {name="int503_c3b", state=initial_cn_state};

¹CN
procedure check3a2
is
	x : integer;
begin
	exit when ûX eq 30ý;
end check3a2;
°

Check that it fails 

=SML
store_mt_results_show mt_run_fail [
("check_3a", print_spark_program, (), gen_fail_msg "check_3a"
					505065 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c3c", state=initial_cn_state};
¹CN
procedure check3b1
is
	x : integer;
begin
   loop
   if x = 0
   then
	exit;
   end if;
   end loop;
end check3b1;
°

=SML
store_mt_results_show mt_run [
("check_3b1", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c3d", state=initial_cn_state};
¹CN
procedure check3b2
is
	x : integer;
begin
   if x = 0
   then
	exit;
   end if;
end check3b2;
°

=SML
store_mt_results_show mt_run_fail [
("check_3b2", print_spark_program, (), gen_fail_msg "check_3b"
					505066 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c3e", state=initial_cn_state};
¹CN
procedure check3b3
is
	x : integer;
begin
   if x = 0
   then
	exit;
   else
	null;
   end if;
end check3b3;
°

=SML
store_mt_results_show mt_run_fail [
("check_3b3", print_spark_program, (), gen_fail_msg "check_3b"
					505066 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

\subsection{Check 4}

=SML
new_script {name="int503_c4a", state=initial_cn_state};
¹CN
function check4a1 (x : in integer) return integer
is
begin
   return 0;
end check4a1;
°

=SML
store_mt_results_show mt_run [
("check_4a1", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c4b", state=initial_cn_state};
¹CN
procedure check4a2 (x : in integer)
is
begin
   return 0;
end check4a2;
°

=SML
store_mt_results_show mt_run_fail [
("check_4a2", print_spark_program, (), gen_fail_msg "check_4a"
					505078 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c4c", state=initial_cn_state};
¹CN
function check4b1 (x : in integer) return integer
is
   y : integer;
begin
   return 0;
   y := 10;
end check4b1;
°

=SML
store_mt_results_show mt_run_fail [
("check_4b1", print_spark_program, (), gen_fail_msg "check_4b"
					505079 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c4d", state=initial_cn_state};
¹CN
function check4b2 (x : in integer) return integer
is
   y : integer;
begin
   case x is
      when 0 =>	return 0;
      when 1 =>	return 10;
      when others =>
		return 99;
   end case;
end check4b2;
°

=SML
store_mt_results_show mt_run [
("check_4b2", print_spark_program, (), ())];
CNZGenerator.restart_cn_z_generator();
=TEX

=SML
new_script {name="int503_c4e", state=initial_cn_state};
¹CN
function check4b3 (x : in integer) return integer
is
   y : integer;
begin
   case x is
      when 0 =>	return 0;
      when 1 =>	return 10;
      when others =>
		y := 99;
   end case;
end check4b3;
°

=SML
store_mt_results_show mt_run_fail [
("check_4b3", print_spark_program, (), gen_fail_msg "check_4b"
					505079 [])];
CNZGenerator.restart_cn_z_generator();
=TEX

\subsection{Check 5}
=GFT
package check5_1
is
   type coord is
   record
      x : integer;
      y : integer;
      z : integer;
   end record;
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0];
end check5_1;
=TEX

=GFT
package body check5_1 is
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0] is
   begin
       c := coord'(x|y|z => 0);
   end home;
end check5_1;
=TEX

=GFT
package check5_2
is
   type coord is
   record
      x : integer;
      y : integer;
      z : integer;
   end record;
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0];
end check5_2;
=TEX

=GFT
package body check5_2 is
   procedure home (c : out coord)
   „ C [C.X = 0 ± C.Y = 0 ± C.Z = 0] is
   begin
       c := coord'(x => 0, others => 0);
   end home;
end check5_2;
=TEX


\subsection{Checks 6 - 8}
Checks not implemented in the tool.

\subsection{Check 9}
TBS

\subsection{Check 10}
Checks not implemented in the tool.

\subsection{Check 11}

\subsection{Check 12}
See above.

\subsection{Check 13}
Checks not implemented in the tool.
\subsection{Abstract Syntax Rules}
These are the rules from section 3 of volume 2 of the specification.

1) The body of a loop must be a specification statement, without initial variables:
=SML
new_script {name="int503_as1", state=initial_cn_state};
fun Ûcheck_as1Ý () = 
¹CN
procedure as1(x : in out INTEGER)
   „ X [ true ]
is
begin
	for i in INTEGER range 1 .. 20
	loop
		„ X [X = X‰0 + 1] (1000)
	end loop;
end as1;
°
=SML
store_mt_results mt_run_fail [
("check_as1", check_as1, (), gen_fail_msg "adjust_statement"
					505091 [])
];
=TEX
2) A specification statement with initial variables must be the first statement in the sequence:
=SML
new_script {name="int503_as2", state=initial_cn_state};
fun Ûcheck_as2Ý () = 
¹CN
procedure as2(x : in out INTEGER)
   „ X [ true ]
is
begin
	x := 1;
	„ X [X = X‰0 + 1] (1001)
end as2;
°
=SML
store_mt_results mt_run_fail [
("check_as2", check_as2, (), gen_fail_msg "adjust_statement"
					505091 [])
];
=TEX
3) A for loop with non-static bounds must be the first statement in the sequence:
=SML
new_script {name="int503_as3", state=initial_cn_state};
fun Ûcheck_as3Ý () = 
¹CN
procedure as3(x : in out INTEGER)
   „ X [ true ]
is
begin
	x := 1;
	for i in INTEGER range X .. 20
	loop
		„ X [true] (1005)
	end loop;
end as3;
°
=SML
store_mt_results mt_run_fail [
("check_as3", check_as3, (), gen_fail_msg "adjust_statement"
					505092 [])
];
=TEX
4) A logical constant must be the first in its sequence:
=SML
new_script {name="int503_as4", state=initial_cn_state};
fun Ûcheck_as4Ý () = 
¹CN
procedure as4(x : in out INTEGER)
   „ X [ true ]
is
begin
	x := 1;
	con A : ú · „ X [true]
end as4;
°
=SML
store_mt_results mt_run_fail [
("check_as4", check_as4, (), gen_fail_msg "cn_parser"
					503204 [])
];
=TEX
5) A call to a procedure with initial variables in its specification
statement must be the first in its sequence:
=SML
new_script {name="int503_as5", state=initial_cn_state};
fun Ûcheck_as5Ý () = 
¹CN
procedure as5(x : in out INTEGER)
    „ X [ true ]
is
  procedure as5a (y : in out INTEGER)
	„ Y [ Y = Y‰0 + 1]
   is
   begin
       y := y + 1;
   end as5a;
begin
	x := 1;
	as5a(x);
end as5;
°


=SML
store_mt_results mt_run_fail [
("check_as5", check_as5, (), gen_fail_msg "adjust_statement"
					505093 [])
];
=TEX

\section{EPILOGUE}

=SML
diag_line (summarize_mt_results());
=TEX

\twocolumn[
\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
=IGN
