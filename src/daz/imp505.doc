=TEX
% pp -i zed505 -d zplay
% pp_list -d zplay vc_gen >zed505.th.doc
% doctex zed505 zed505.th
% texdvi zed505
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Verification Condition Generator}  %% Mandatory field
\def\TPPheadtitle{VC Generation}
\TPPref{ISS/HAT/DAZ/IMP505}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\R.D.~Arthan & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{%
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion] First issue for distribution.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
\subsection{Introduction}
=TEX
\pagebreak
=SML
structure €CNVCGenerator› = struct
local
	open CaseIndependence CNTypes CNBasicDeclsAndExprs;
in
=TEX
SML
	fun €free_ids› (ze : Z_EXP) : ID list = (map (fst o dest_var) (frees ze));
=TEX
=SML
type SEQUENT=SEQ;
type VC = Z_DECL list * SEQUENT;
=TEX

\pagebreak
\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}
\subsection{Sequents}
=SML
infix 3 Ù;
fun (H : Z_PRED list) Ù (c : Z_PRED) : SEQUENT = (H, c);

infix 4 %Longrightarrow%;
fun (h : Z_PRED) %Longrightarrow% (S : SEQUENT list) : SEQUENT list = (
	map (fn (H, c) => (h :: H, c)) S
);
=TEX
\pagebreak
\section{Substitutions}
=SML
fun €sub› ((p, x, e) :Z_PRED * Z_ID * Z_EXP) : Z_PRED = (
	let	val p' = subst[(e, mk_var(x, type_of e))] p;
	in	(snd o dest_eq o concl o TRY_C (TOP_MAP_C z_schema_pred_conv1)) p'
	end
);
=TEX
=SML
fun €list_sub› ((p, xes) :Z_PRED * ((Z_ID * Z_EXP) list)) : Z_PRED = (
	let	fun mk_subs (x : Z_ID, e : Z_EXP) = (e, mk_var(x, type_of e));
		val p' = subst (map mk_subs xes) p;
	in	(snd o dest_eq o concl o TRY_C (TOP_MAP_C z_schema_pred_conv1)) p'
	end
);
=TEX
=SML
fun €subs_exp› ((e, xs, ys) :Z_EXP * (Z_ID list) * (Z_ID list)) : Z_EXP = (
	let	val xys = combine xs ys;
		val ntys = map dest_var(frees e);
		fun s ((n, ty) :: more) (x, y) = (
			if	n = x
			then	(x, mk_var(y, ty)) :: s more (x, y)
			else	s more (x, y)
		) | s [] _ = [];
	in	list_sub(e, flat(map (s ntys) xys))
	end		
);
=TEX
=SML
fun €subs_pred› ((p, xs, ys) :Z_PRED * (Z_ID list) * (Z_ID list)) : Z_PRED = (
	subs_exp(p, xs, ys)
);
fun €subseq› ((seql, x, e) :SEQUENT list * Z_ID * Z_EXP) : SEQUENT list = (
	map (fn (H, c) => map (fn p => sub(p, x, e)) H Ù sub(c, x, e)) seql
);
=TEX
\pagebreak

\section{ABSTRACT SYNTAX OF SPARK STATEMENTS}\label{ASSPARK}

See \cite{ISS/HAT/DAZ/DTD502}.

\section{WEAKEST PRECONDITIONS}\label{WPS}
\subsection{Environments}\label{environments}
=SML
type €PARAM_SPEC› = {var_decl : VAR_DECL, mode : MODE};
type €FORMAL_PROC› = {name : ID, formal_ids : PARAM_SPEC list,
				spec : SPEC};
type €INFORMAL_FUN› = {name : ID, formal_pars : PARAM_SPEC list,
				return_type : TMARK};
type €WP_ENV› = {fun_header : INFORMAL_FUN, return : Z_PRED,
			till : Z_PRED, formal_procs : FORMAL_PROC list,
			env : CN_ENV};
=IGN
val spec_EG : SPEC =
	{w = ["w"], w0 = ["w0"], pre = ÒtrueÆ, post = ÒtrueÆ, label=LImplicit};
val var_decl_EG : VAR_DECL =
	{vars = ["variable_name"], tmark = "integer"};
val param_spec_EG : PARAM_SPEC =
	{var_decl = var_decl_EG, mode = MSparkIn};
val formal_proc_EG : FORMAL_PROC =
	{name = "formal_proc", formal_ids = [param_spec_EG], spec = spec_EG};
val informal_fun_EG : INFORMAL_FUN =
	{name = "informal_fun", formal_pars = [param_spec_EG],
		return_type = "result_type"};
val wp_env = {fun_header = informal_fun_EG,
		return = ÒtrueÆ, till = ÒtrueÆ,
		formal_procs = [formal_proc_EG], env=env} : WP_ENV;
=TEX
\subsection{Other Preliminaries}\label{Preliminaries}
=SML
type €RESULT› = {wp : SEQUENT list, side : SEQUENT list};
type €WP_TYPE› = (STATEMENT * SEQUENT list * WP_ENV) -> RESULT;
type €WP_PARS› = {wp : WP_TYPE, a: SEQUENT list, wp_env : WP_ENV};

=TEX
=IGN
val wp_pars :WP_PARS = {wp=wp, a=[], wp_env = wp_env};



\subsection{Null Statement}\label{wp-null}
=SML
fun €null› ({a, ...} : WP_PARS) : RESULT = (
	{wp = a, side = []}
);
=TEX
\subsection{Assignment Statement}\label{wp-assignment}
=SML
fun €simple_assign› ({wp_env={env,...}, a, ...} : WP_PARS)
		(x : ID) (e : EXP) : RESULT = (
	{wp = subseq(a, trans_id x, trans_exp env e), side = []}
);
=TEX
=SML
fun €array_assign›	({wp, a, wp_env as {env,...}} : WP_PARS)
			({prefix, index} : EXP INDEXED_COMP) (e : EXP) : RESULT = (
let	val name' = prefix;
	val e' = EAuxiliaryExp (z_override
			(trans_exp env prefix, z_set
			   [z_maplet (trans_exp env index, trans_exp env e)]));
in
	wp (SStmt (STAssign{name=name',e=e'}), a, wp_env)
end
);
=TEX
=SML
fun €retrieve_type_mark› (env : CN_ENV) (exp : EXP) : TMARK = (
let	val tmark = (to_upper o name_to_tmark) exp;
in
	case env tmark of
	Value (_, EIEnvVar tmark') => tmark'
	|_ => fail "retrieve_type_mark" 505001 [fn()=>tmark^" is not a variable"] 
end
);
=TEX
=SML
fun €record_assign›	({wp, a, wp_env as {env, ...}} : WP_PARS)
			({prefix, selector} : EXP SELECTED_COMP) (e : EXP) : RESULT = (
let	val name' = prefix;
	val tmark = retrieve_type_mark env prefix;
	val record_components = retrieve_record_components env tmark
		handle _ => fail "record_assign" 505001 [];
	fun do_comps sel = case lassoc5 record_components sel of 
			Value _ => (e
			)|Nil => ESelectedComp{prefix=prefix,selector=sel};
	val comps = map (fn (a,_) => do_comps a) record_components;
	val e' = ERecAggPos {tmark=tmark,comps=comps};
in
	wp (SStmt (STAssign{name=name',e=e'}), a, wp_env)
end
);
=TEX
=SML
fun €assign› (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ({name, e} : ASSIGN)
			: RESULT = (
let	val e' = adjust_exp env e;
in
	case adjust_exp env name of
	EId id => simple_assign wp_pars id e'
	|EIndexedComp ic => array_assign wp_pars ic e'
	|ESelectedComp sc => record_assign wp_pars sc e'
	|_ => fail "assign" 505001 [fn()=>"weird lhs of an assignment"]
end
);
=TEX
\subsection{Specification Statement (No initial variables)}\label{wp-specification-no-ivars}
=SML
fun €spec_no_ivars› ({a, ...} : WP_PARS) ({pre, post,...} : SPEC_NO_IVARS)
			: RESULT = (
	{wp = [[] Ù pre], side = post %Longrightarrow% a}
);
=TEX
=SML
fun €spec_no_ivars_empty› ({a, ...} : WP_PARS) ({pre, post,...} : SPEC_NO_IVARS)
			: RESULT = (
	{wp = ([] Ù pre) :: (post %Longrightarrow% a), side = []}
);
=TEX
=SML
fun €spec_no_ivars_either› (wp : WP_PARS) (sp as {w, ...} : SPEC_NO_IVARS) 
		: RESULT = (
	if	w = []
	then	spec_no_ivars_empty wp sp
	else	spec_no_ivars wp sp
);
=TEX
\subsection{Semicolon}\label{wp-semicolon}
=SML
fun €semicolon› ({wp, a, wp_env} : WP_PARS) ((p, q) : STMT * STMT)
			: RESULT = (
let	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val {wp = wp1, side = side1} = wp (SStmt p, wp2, wp_env);
in
	{wp = wp1, side = side1 @ side2}
end
);
=TEX
\subsection{If Statement}\label{wp-if-then-else}
=SML
fun €if_then_else›	({wp, a, wp_env as {env,...}} : WP_PARS)
			({g, p, q,...} : STMT IF_THEN_ELSE) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val wp = (z_eq(trans_exp env g, zid env "TRUE") %Longrightarrow% wp1) @
		(z_eq(trans_exp env g, zid env "FALSE") %Longrightarrow% wp2);
	val side = side1 @ side2;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Case Statement}\label{wp-case}
=SML
fun €trans_case_choices› (env : CN_ENV) (choices : CASE_CHOICE list) : Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		CCCaseRange (DRRange(RRange{lo,hi})) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|CCCaseRange (DRRange _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|CCCaseRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|CCCaseRange (DRConstrained _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		CCCaseExp exp =>
			trans_exp env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choices;
	val zsingles = z_set (aux_singles choices);
in
	z_many_union(zranges @ [zsingles])
end
);
=TEX
SML
fun €case_base› (env : CN_ENV) (e : EXP)
			({when, p} : (STMT) CASE_SEG)
			({wp, a, wp_env} : WP_PARS) : RESULT = (
let	val {wp = WP1, side = side1} = wp env (stmt P, a, wp_env);
	val elm = Òëtrans_exp EÆ ç Òzset (map trans_exp when)ÆÆ;
in	{wp = elm %Longrightarrow% WP1, side = side1}
end
);
=TEX
SML
fun €CASE_STEP› ({E, s} : (Stmt) Case,
			pars as {wp, a, wp_env} : WP_PARS) : RESULT = (
	case s of
		[] =>
		raise Empty_Case_STATEMENT "detected in VC generation"
	|	[seg] =>
		case_base(E, seg, pars)
	|	({when, P} :: s') => (
		let	val {wp = WP1, side = side1} = wp(stmt P, a, wp_env);
			val {wp = WP2, side = side2} = CASE_STEP({E=E, s=s'}, pars);
			val elm = Òëtrans_exp EÆ ç Òzset (map trans_exp when)ÆÆ;
		in	{wp = (elm %Longrightarrow% WP1) @ WP2 , side = side1 @ side2}
		end)
);
=TEX
Note that $CASE\_STEP$ is recursive and does the full job. 
But by analogy with the naming convention we chose to adopt for the
two case of specification statement in section \ref{wp-specification-no-ivars},
we define the following.
SML
val €case_either› : Stmt Case * WP_PARS -> RESULT = CASE_STEP;
=TEX
\subsection{Undecorated Loop}\label{wp-loop}
=SML
fun €loop› ({a, ...} : WP_PARS) ({t, stmt} : STMT LOOP)
			: RESULT = (
let	val {pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => fail "loop" 505001 [fn()=>
			"Cannot proceed formally when loop body size > 1"];
	val wp = [[] Ù pre];
	val side = case t of
			Value till => [[post] Ù pre] @ (till %Longrightarrow% a)
			|Nil => [[post] Ù pre];
in
	{wp = wp, side = side}
end
);
=TEX
=SML
fun €named_loop› (wp_pars : WP_PARS) ({t, stmt, ...} : STMT NAMED_LOOP)
			: RESULT = (
	loop wp_pars {t=t, stmt=stmt}
);
=TEX
\subsection{While Loop}\label{wp-while-loop}
=SML
fun €cn_while›	({a, wp_env={env, ...}, ...} : WP_PARS)
		({g, loop={t,stmt}, ...} : STMT WHILE) : RESULT = (
let	val {w, w0, pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => fail "loop" 505001 [fn()=>
			"Cannot proceed formally when loop body size > 1"];
	val wp = ([z_eq(trans_exp env g, zid env "TRUE")] Ù pre) ::
			(z_eq(trans_exp env g, zid env "FALSE")
				%Longrightarrow% a);
	val side = case t of
			Value till => (post %Longrightarrow% wp) @
					(till %Longrightarrow% a)
			|Nil => (post %Longrightarrow% wp);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-static}
SML
fun €for_value› ({i = i, lo = lo, hi = hi,
				loop = {u = u,
					spec = spec as
						{w, w0, pre, post}}} : For_Value,
			pars as {wp, a, wp_env} : WP_PARS) : RESULT = (
	let	val zi = trans_id i;
		val zlo = trans_exp lo;
		val zhi = trans_exp hi;
		val zran = Òëzid ziÆ ç ëzloÆ .. ëzhiÆÆ;
		val z_bin_exp_theta = Òëzid ziÆ + 1Æ;
		val WP = [[] Ù sub(pre, zi, zlo)];
		val side = [[zran, Òëzid ziÆ Ω ëzhiÆÆ, post] Ù 
				sub(pre, zi, z_bin_exp_theta)] @
			(sub(post, zi, zhi) %Longrightarrow% A) @
			(zran %Longrightarrow% (u %Longrightarrow% A));
	in	{wp = WP, side = side}
	end
);
=TEX
\subsection{Exit}\label{wp-exit}
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=SML
fun €exit_when› ({a, wp_env={till, env, ...}, ...} : WP_PARS)
		({g} : EXIT_WHEN)
			 : RESULT = (
let	val zg = trans_exp env g;
	val wp = ([z_eq(zg, zid env "TRUE")] Ù till) ::
		(z_eq(zg, zid env "FALSE") %Longrightarrow% a);
in	{wp = wp, side = []}
end
);
=TEX
=SML
fun €cn_exit› ({wp_env={till, ...},...} : WP_PARS) : RESULT = (
	{wp = [[] Ù till], side = []}
);
=TEX
\subsection{Return}\label{wp-return}
=TEX
The following is a simplistic approximation/guess.
SML
fun €make_fun_call› ({name, formal_pars, return_type} : INFORMAL_FUN) : Z_EXP = (
let	fun mk_par ({var_decl = {var, tmark}, ...} : PARAM_SPEC) : Z_EXP = (
		mk_var(var, mk_ctype(tmark, []))
	);
	val par_tuple = mk_z_tuple(map mk_par formal_pars);
	val res_ty = mk_ctype(return_type, []);
	val func_ty = mk_z_power_type(mk_z_tuple_type
			[type_of par_tuple, res_ty]);
	val func = mk_z_gvar(name, func_ty, []);
in	mk_z_app(func, par_tuple)
end
);
=TEX
SML
fun €cn_return› (env : CN_ENV) ({e} : RETURN)
			({wp, a, wp_env= {fun_header, return, ...}} : WP_PARS)
					: RESULT = (
let	val zfun = zid env (trans_id name);
	val zargs = fn i => zid env (trans_id (formal_pars i).var);
	val wp = [[z_eq(z_fun_call
	{wp = [[Òëmake_fun_call fun_headerÆ = ëtrans_exp EÆÆ] Ù return],
	side = []}
);
=TEX
\subsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}
Like the implementation of $make\_fun\_call$ above the following is another simplistic approximation/guess.
It is assumed that the caller will have supplied the correct $Formal\_Proc$ from the environment.
The formals and actuals must agree in number, and the library function $combine$, which turns a pair of equal length lists into a list of pairs, will raise the exception $Fail$ if they do not.
=SML
fun €proc_call_spec› ({actuals, ...} : (AGG_CHOICE,EXP) PROC_CALL,
		{formal_ids, spec as {w, w0, pre, post, label}, ...}
			: FORMAL_PROC) : SPEC = (
spec);
(*
let	fun subs (actual : EXP,
		{var_decl = {vars, ...}, ...} : PARAM_SPEC)
			: (Z_ID * Z_EXP) = (var, trans_exp actual);
	val subs_list = map subs (combine actuals formal_ids)
		handle Fail _ =>
		fail "proc_call_spec" 505001 [fn()=>"parameter list mismatch"];
in	{w = w, w0 = w0,
	pre = list_sub(pre, subs_list),
	post = list_sub(post, subs_list),
	label=label}
end
);
*)
=TEX
The relevant formal procedure may not be in the environment here.
The library function $find$ will raise the exception $Fail$ if this is the case.
=SML
fun €proc_call_no_ivars› ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
		(pc as {name, actuals} : (AGG_CHOICE,EXP) PROC_CALL)
	
		: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_no_ivars" 505001 [fn()=>"formal procedure not found"];
in
	wp (SStmt(STSpecNoIvars(proc_call_spec(pc, fp))), a, wp_env)
end
);
=TEX
\subsection{For Loop (Bounds with Variables)}\label{wp-for-var}
SML
fun €for_var› (({i = i, lo = lo, hi = hi,
				loop = {u = u,
					spec = spec as
						{w, w0, pre, post}}},
			q) : For_Var * Stmt,
			pars as {wp, a, wp_env} : WP_PARS) : RESULT = (
	let	val zi = trans_id i;
		val zlo = trans_exp lo;
		val zhi = trans_exp hi;
		val zlo0 = subs_exp(zlo, w, w0);
		val zhi0 = subs_exp(zhi, w, w0);
		val zran = Òëzid ziÆ ç ëzlo0Æ .. ëzhi0ÆÆ;
		val z_bin_exp_theta = Òëzid ziÆ + 1Æ;
		val {wp = WP1, side = side1} = wp(stmt q, a, wp_env);
		val WP = [[ÒëzloÆ º ëzhiÆÆ] Ù sub(pre, zi, zlo)] @
			(ÒëzloÆ > ëzhiÆÆ %Longrightarrow% WP1);
		val side = [[zran, Òëzid ziÆ Ω ëzhi0ÆÆ, post] Ù 
				sub(pre, zi, z_bin_exp_theta)] @
			(sub(post, zi, zhi0) %Longrightarrow% WP1) @
			(zran %Longrightarrow% (u %Longrightarrow% WP1));
	in	{wp = WP, side = side}
	end
);
=TEX
\subsection{Specification (With Initial Variables)}\label{wp-spec-ivars}
=SML
fun €spec_ivars› ({wp, a, wp_env as {env, ...}} : WP_PARS) (({pre, post, ...},q) : SPEC_IVARS * STMT)
			 : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] Ù pre];
	val side = (post %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Logical Constant}\label{wp-log-con}
=SML
fun €log_con› ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(({x, e, spec as {w, w0, pre, post,...}, pre1}, q) : LOG_CON * STMT)
		: RESULT = (

let	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] Ù sub(pre1, x, e)];
	val zvar_ty = dest_z_power_type(type_of e);
	val env' = fn id => if id = x then Value (zvar_ty, EIEnvVar "")					else env id;
	val side = (* TBS -  z_eq
		    * should this be z_mem 
		    *)
		z_eq(zid env' x, subs_exp (e,w,w0)) %Longrightarrow%
		(post %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
=SML
fun €proc_call_ivars› ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
	((pc as {name, actuals}, q) : (AGG_CHOICE, EXP) PROC_CALL * STMT)
					: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_ivars" 505001 [fn()=>"formal procedure not found"];
in
	wp (SSpecIvars(proc_call_spec(pc, fp), q), a, wp_env)
end
);
=TEX
\subsection{$wp$}\label{wp}
=SML
fun €wp› ((st, a, wp_env) : STATEMENT * SEQUENT list * WP_ENV) : RESULT = (
let	val pars : WP_PARS = {wp = wp, a = a, wp_env = wp_env};
in	case st of
		SStmt STNull => null pars
	|	SStmt STImplicitNull => null pars
	|	SStmt (STAssign x) => assign pars x 
	|	SStmt (STSpecNoIvars x) => spec_no_ivars_either pars x
	|	SStmt (STSemicolon x) => semicolon pars x
	|	SStmt (STIfThenElse x) => if_then_else pars x
	|	SStmt (STCase x) => {wp=[],side=[]}
	|	SStmt (STLoop x) => loop pars x
	|	SStmt (STNamedLoop x) => named_loop pars x
	|	SStmt (STWhile x) => cn_while pars x
	|	SStmt (STForStatic x) => {wp=[],side=[]}
	|	SStmt (STForTmark x) => {wp=[],side=[]}
	|	SStmt (STExitWhen x) => exit_when pars x
	|	SStmt (STExit) => cn_exit pars
	|	SStmt (STRet x) => {wp=[],side=[]}
	|	SStmt (STProcNoIvars x) => proc_call_no_ivars pars x
	|	SStmt (STKSlot x) => {wp=[],side=[]}
	|	SSpecIvars x => spec_ivars pars x
	|	SForNonStatic _ => {wp=[],side=[]}
	|	SLogCon x => log_con pars x
	|	SProcIvars x => proc_call_ivars pars x
end
);
=IGN
val assign_EG1 : Stmt = assign {x="a", E = Òa - bÆ}		(* a0 - b0 *);
val assign_EG2 : Stmt = assign {x="b", E = Òa + bÆ}		(* a0 *);
val assign_EG3 : Stmt = assign {x="a", E = Òb - aÆ}		(* b0 *);
val semi_EG1 : Stmt = semicolon(assign_EG2, assign_EG3);
val semi_EG2 : Stmt = semicolon(assign_EG1, semi_EG1);

val A_EG = [([] Ù ÒP (a ∫ ˙) ± Q (b ∫ ˙)Æ)];
val A_EG2 = [([] Ù Ò(a ∫ ˙)= bâ0 ± (b ∫ ˙)= aâ0Æ)];
wp(stmt null, A_EG, wp_env_EG);
wp(stmt (arr_assign array_assign_EG), A_EG, wp_env_EG);
wp(stmt (assign assign_EG), A_EG2, wp_env_EG);
wp(stmt semi_EG2, A_EG2, wp_env_EG);

val my_conv : CONV = (fn tm =>
	let	val vs = frees tm drop (fn t => not(type_of t =: type_ofÒ0Æ));
		val vs' = Sort.sort term_order vs;
		val convs = map (fn t => TRY_C(rewrite_conv[z_minus_thm, z_µ_elim t z_plus_order_thm])) vs';
	in	EVERY_C convs
	end	tm
);
my_conv Ò((a - b) + b) - a - b = bâ0 ± (a - b) + b = aâ0Æ;
=TEX
\pagebreak
\section{VERIFICATION CONDITIONS}
=SML
type €FLAG› = bool;
type €DEC_LABEL› = string;
=TEX
=SML
type €IN_SCOPE› = {
		vc_vars : VAR_DECL list,
		vc_pars : PARAM_SPEC list,
		vc_log_cons : Z_DECL list,
		formal_procs : FORMAL_PROC list,
		dec_labels : DEC_LABEL list};
type €SPECLAB› = {
		spec : SPEC,
		formal_body_flag : FLAG,
		fun_flag : FLAG,
		till_flag : FLAG,
		wp_env : WP_ENV,
		in_scope : IN_SCOPE};
=TEX
=SML
fun €vc_local_decls› (seqs : SEQUENT list,
	{fun_flag, in_scope as {vc_vars, vc_pars, ...},
		wp_env={env, ...}, ...} : SPECLAB)
		: VC list = (
let	fun conv_var_decl ({vars=vs, tmark=t} : VAR_DECL)
		: {var : ID, tmark : TMARK} list = (
	 map (fn id => {var=id, tmark=t}) vs
	);
	fun var_decl_decls {var, tmark} =
		[{zvar = trans_id var, zexp = zid env (trans_id tmark)},
		{zvar = (trans_id var ^ "â0"), zexp = zid env (trans_id tmark)}];
	val vdd = flat o (map var_decl_decls) o conv_var_decl;
	fun param_spec_decls {var_decl, mode} = (
		if	mode = MSparkIn
		then	[hd(vdd var_decl)]
		else	vdd var_decl
	);
	val decls = flat(map vdd vc_vars @
			map param_spec_decls vc_pars);
	fun add_decls decs (seq as (H, c)) = (
		let	val vns = map (fst o dest_var)
				(flat(frees c :: map frees H));
		in	(decs drop (fn {zvar, zexp} => zvar mem vns),
			seq)
		end
	);
in
	map (add_decls decls) seqs
end
);
=TEX
=SML
fun €vcs› ((sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st): SPECLAB * STATEMENT)
			: VC list = (
let	val {wp, side} = wp (st, [[] Ù post], wp_env);
	fun subs_c (h, c) = (
		h Ù subs_pred(c, w0, w)
	);
	val wp1 = map subs_c wp;
	val s = (pre %Longrightarrow% wp1) @
		(subs_pred(pre, w, w0) %Longrightarrow% side);
in
	vc_local_decls(s, sl)
end
);
=TEX
\section{EPILOGUE}
=SML
end (* local ... in *);
end (* structure CNVCGenerator *);
=TEX
%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed505.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}


