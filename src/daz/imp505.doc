=IGN
********************************************************************************
imp505.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Date: 2003/07/18 11:46:18 $ $Revision: 1.121 $ $RCSfile: imp505.doc,v $
=TEX
% pp -i zed505 -d zplay
% pp_list -d zplay vc_gen >zed505.th.doc
% doctex zed505 zed505.th
% texdvi zed505
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Verification Condition Generator}  %% Mandatory field
\def\TPPheadtitle{Verification Condition Generator}
\TPPref{ISS/HAT/DAZ/IMP505}  %% Mandatory field
\def\SCCSversion{$Revision: 1.121 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{97/07/18%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Informal}
\TPPtype{Specification}
%\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\R.D.~Arthan & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This is the implementation of the verification condition generator for the compliance tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.28] Initial Drafts.
\item[Issue 1.29] Changed signature of $check\_new\_z\_id$.
\item[Issues 1.30-1.34] Fixes/palliatives for DRA bugs (batch 1) 8, 9, 10, 11, 19.
\item[Issue 1.35] Palliative for bug 10 (batch 1)
\item[Issue 1.36] Fixes for DRA bugs (batch 2) 1, 2.
\item[Issue 1.37] Enhancements 1, 6 and 20 (annotations, pragmas and arbitrary replacements catered for).
\item[Issue 1.38] New treatment of records.
\item[Issue 1.39] Bug fixing (batch 2 bug 13).
\item[Issue 1.40] Rationalised error reporting.
\item[Issue 1.41] Fixed problem adjusting case selectors.
\item[Issue 1.42] Update references.
\item[Issue 1.43] Fixed DRA bug 12 (V0.6).
\item[Issue 1.44] Fixed DRA bug 4 (V0.6).
\item[Issue 1.45] Fixed DRA bug 2 (V0.6).
\item[Issue 1.46] Fixed DRA bug 15 (V0.6).
\item[Issue 1.47] Fixed \LaTeX{} error.
\item[Issue 1.48] k-slots as annotations.
\item[Issue 1.49] Fixing $analyse\_log\_con$.
\item[Issue 1.50] Improved message 505063.
\item[Issue 1.51] Improved use of substitutions and common  subterms.
\item[Issue 1.51-1.54] IUCT WP 4.
\item[Issue 1.55] Check 1(a) now applies to procedure calls too.
\item[Issue 1.56] Added new check 16.
\item[Issue 1.57] Updated references.
\item[Issue 1.58] Update for new INTEGER type.
\item[Issue 1.59] Prototyping enhancement R5 --- Initial Variables in Conditionals.
\item[Issue 1.60] Prototyping enhancement R3 --- Assignment to Record Components.
\item[Issue 1.61-1.64] Prototyping enhancement R2: Multiple Logical Constant Definitions.
\item[Issue 1.65] Check on initial variables in pre-conditions added.
\item[Issue 1.66] CTLE II enhancement R1/2 --- ``others'' in case statements.
\item[Issues 1.67, 1.68] CTLE II enhancement R1/3 --- reverse loops.
\item[Issues 1.69] CTLE II R1/5 --- range attributes as ranges.
\item[Issues 1.70] CTLE II R1/9 --- SPARK 83 attributes.
\item[Issue 1.71] CTLE II R1/9 --- SPARK 83 attributes.
\item[Issue 1.72] CTLE II R1/11 --- nested packages.
\item[Issue 1.73] Fixes to CTLE II R1/5 and R1/6.
\item[Issue 1.74] Investigating performance problem.
\item[Issue 1.75] Perfomance enhancement for type-checking of specification statements.
\item[Issue 1.76] Added option to compactify pre- and post-conditions.
\item[Issues 1.77,1.78] Enhancement R0003 --- record and array components as exported parameters.
\item[Issues 1.79-1.82] Fixed {\it var\_sig} and the use of {\it adjust\_exp} etc. in the anti-aliasing checks.
\item[Issue 1.83] R0021: domain condition generation.
\item[Issue 1.84] R0040: bug in treatment of type inference context in procedure calls.
\item[Issues 1.85,1.86] Accommodated use of signature inclusion.
\item[Issue 1.87] Fixed bug in treatment of expressions in for loops.
\item[Issue 1.88--1.90] Further fixes and R0044: checks on array ranges.
\item[Issue 1.91] Fixed {\LaTeX} errors.
\item[Issues 1.92, 1.93] Fixed bug in {\it proc\_call\_param}.
\item[Issue 1.94] R0056: default parameter modes supported properly.
\item[Issue 1.95] Fixing bug in type-checking during preprocessing of
procedure calls.
\item[Issue 1.96] Fixing bug in check on case statement with omitted others part.
\item[Issue 1.97] Spring 2002 enhancements: adjustments for syntax for interim release.
\item[Issue 1.98] Spring 2002 enhancements: return and exit statements.
\item[Issue 1.99,1.100] Spring 2002 enhancements: subprogram and object renaming.
\item[Issue 1.101,1.102] Spring 2002 enhancements: package renaming.
\item[Issue 1.103] Spring 2002 enhancements: VC derivations enquiries - adding information to sequents.
\item[Issue 1.104] Fixed some slips in VC derivation code.
\item[Issue 1.105] Fixed bug in check on statements that must come first in their sequence of statements.
\item[Issue 1.106] Fixed bug in the anti-aliasing checks (which were applying {\it adjust\_exp} twice to
some expressions which is not appropriate in general).
\item[Issue 1.107] R0054: reworked treatment of use clauses.
\item[Issue 1.108] Moved {\it init\_var} to DTD508.
\item[Issue 1.109, 1.110] R0079: assertions (allowed for new syntax).
\item[Issue 1.111] Checks 1(a) and 19 now made for logical constant statements as well as
ordinary specification statements.
\item[Issue 1.112] R0051: default parameters. Fixed bug in {\it proc\_call\_spec}.
\item[Issue 1.113] Merged in changes for R0062.
More corrections to VC derivation code. Change names {\it Sequent\_Route} to 
			{\it VC\_Route}, constructors PP-compatible e.g. {\it VRExitTillIntro}. 
\item[Issue 1.114] Copyright and banner updates for open source release.
\item[Issue 1.115, 1.116] DAZ-specific updates to banner for open source release
\item[Issue 1.117] Uniform treatment of block statements.
\item[Issues 1.118, 1.119] Schema references in function $\Xi$-lists.
\item[Issue 1.120] R0096: improved formatting of nothing statement form in web clauses
\item[Issue 1.121] Fixed bug in error handling.
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance tool verification condition generator. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Possible Enhancements}
None.

\pagebreak

\section{THE STRUCTURE $CNVCGenerator$}
=SML
infix 3 ô;
infix 4 %Longrightarrow%;
infix 5 cap;
=TEX
=SML
structure ÛCNVCGeneratorÝ : CNVCGenerator = struct
	open CaseIndependence CNTypes1 CNTypes2 CNTypes CNBasicDeclsAndExprs
		ZUserInterfaceSupport ZGeneratedConstants TypeInference;
=TEX
\section{SUPPORTING FUNCTIONS}
In version 0.6 and onwards we follow the new policy of not attempting to recover when a construct cannot be handled formally.
The special exception $VCInformal$ and associated functions are therefore no longer required.
=TEX
The following functions are used to construct a type inference context for use when the specification statement of a procedure is type checked.
=SML
fun v_v0 (in_mode : bool) (ty : TYPE) (v : ID) : TERM list = (
		if	in_mode
		then	[mk_var(v, ty)]
		else	[mk_var(init_var v, ty), mk_var(v, ty)]
);
=TEX
=SML
fun Ûti_context_of_formal_idsÝ (env : CN_ENV) ([] : PARAM_SPEC list)
		: TERM list = []
|  ti_context_of_formal_ids env ({var_decl as {vars, tmark}, mode} :: more) = (
	let	val ty = dest_z_power_type (type_of (zid env (trans_id tmark)))
			handle Fail _ => fail "vcs" 508051 [fn()=>tmark];
		val inmode = case mode of MSparkIn _ => true | _ => false;
	in	flat (map (v_v0 inmode ty) vars)
		@ ti_context_of_formal_ids env more
	end
);
=TEX
The following is exported as a convenience for use in the Z Generator.
=SML
fun Ûti_context_of_formal_procÝ (env : CN_ENV) ({formal_ids, ...} : FORMAL_PROC)
	: TERM list =  (
	ti_context_of_formal_ids env formal_ids
);
=TEX
\section{STORAGE OF Z TERMS}
=TEX
First we introduce the new flag.
=SML
val Ûcn_compactify_termsÝ : bool ref = ref true;
val side_effect = new_flag
	{name = "cn_compactify_terms",
	control = cn_compactify_terms,
	check = fun_true,
	default = fun_true} handle Fail _ => ();
=TEX
Now we can define {\it z\_quote}:
=SML
val Ûz_quoteÝ : TERM * Unification.EXTYPE OPT -> Z_TM = (fn (tm, ty_opt) =>
	ZTmQuotation(if !cn_compactify_terms then compact_term tm else tm, ty_opt)
);
=TEX
\pagebreak
\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}
\subsection{Sequents}
=SML
fun (h : Z_PRED list) ô (c : Z_PRED) : SEQUENT = (h, c);

fun (h : Z_PRED) %Longrightarrow% (s : SEQUENT list) : SEQUENT list = (
	map (fn (h', c) => (h' term_grab h, c)) s
);

=TEX
=SML
fun Ûadd_hypsÝ ([] : Z_PRED list, s : SEQUENT list) : SEQUENT list = s
|    add_hyps (h::more, s) = h %Longrightarrow% add_hyps (more, s);
=TEX
=SML
fun Ûadd_domain_condsÝ (env : CN_ENV)
	(zes : Z_EXP list, s : SEQUENT list) : SEQUENT list = (
	let	val zps = list_term_union (map (domain_conds env) zes);
	in	add_hyps (zps, s)
	end
);
=TEX
\subsubsection{Information on Sequent Provenance}
We have functions \textit{\slshape init\_sr}, \textit{\slshape cons\_sr},
  \textit{\slshape cons\_dec\_sr}, 
 \textit{\slshape cons\_srs}, \textit{\slshape cons\_dec\_srs}, \textit{\slshape extract\_routes}.

The constructors are nullary e.g. 
=INLINEFT
vr_while_pre_intro
=TEX
\ or unary e.g.
=INLINEFT
vr_while_via
=TEX
\ in the \textit{\slshape VC\_Route} argument. 

Supporting functions are: \textit{\slshape is\_route}, \textit{\slshape dest\_route}, 
  \textit{\slshape mk\_route}, \textit{\slshape extend\_path}, \textit{\slshape extend\_dec\_path}.

We use the type \textit{\slshape ROUTE} for the route information and form a \textit{\slshape Z\_PRED}
in order to include it in a sequent.

=SML
type ROUTE = TERM

val vc_route_set = ñVC_Route®

fun Ûmk_routeÝ ( path : ROUTE ) : Z_PRED = mk_z_(path,vc_route_set)

fun Ûis_routeÝ  ( rpred : Z_PRED ) : bool = 
	 case dest_term rpred of 
            DApp(_, sr) =>  sr =$ vc_route_set
          | _ => false

fun Ûdest_routeÝ ( rpred : Z_PRED ) : ROUTE = (
	let	val sr1  = fst(dest_app rpred);
	    	val sr2 = snd(dest_app sr1)   (* get first argument of curried eps *);
	in
		sr2
	end
);

fun Ûextend_pathÝ ( constr : TERM ) ( p : ROUTE) : ROUTE = z_fun_call( constr, [p] )

fun Ûextend_dec_pathÝ ( constr : TERM,  d : TERM list ) ( p : ROUTE ) : ROUTE = 
	z_fun_call( constr,  rev(p::(rev d)) )
=SML


fun Ûinit_srÝ ( constr : ROUTE ) ( (h,c) : SEQUENT) : SEQUENT = 
		(mk_route(constr)::h, c)

fun Ûinit_dec_srÝ ( constr : ROUTE, d : TERM list ) ( (h,c) : SEQUENT) : SEQUENT = 
		(mk_route(z_fun_call(constr,d))::h, c)
=TEX
example: 
=INLINEFT
init_sr vr_while_pre_intro s
=SML

fun Ûcons_srÝ  (constr : TERM ) ( (h,c) : SEQUENT ) : SEQUENT = 
		( map (fn zp => 
			if is_route zp then mk_route(extend_path constr (dest_route zp))
			else zp
		      )  h,  
		  c
		)

fun Ûcons_dec_srÝ  (constr : TERM, d : TERM list ) ( (h,c) : SEQUENT ) : SEQUENT = 
		( map (fn zp => 
			if is_route zp then mk_route(extend_dec_path (constr,d) (dest_route zp))
			else zp
		      )  h,  
		  c
		)

fun Ûcons_srsÝ (constr : TERM) ( hcs : SEQUENT list ) : SEQUENT list = 
	map (cons_sr constr) hcs 

fun Ûcons_dec_srsÝ (constr : TERM, d : TERM list ) ( hcs : SEQUENT list ) : SEQUENT list = 
	map (cons_dec_sr (constr, d)) hcs ;


fun extract_routes  ( [] : SEQUENT list ) : (SEQUENT list * ROUTE OPT list) = ([],[])
|   extract_routes  ( hc :: hcs ) = 
	let 	fun drop_get_routes ([],c) =  ( ([],c), Nil )
             	|   drop_get_routes (zp::zps,c) = 
			let val ( (h,c), r ) = drop_get_routes(zps,c)
			in   	if is_route zp  then  
					let val app_eps1 = fst(dest_app zp);
				    	    val rte = snd(dest_app app_eps1);
					in (  (h,c), Value rte )
					end
				else  ( (zp::h,c), r)
			end
	 	val ( seqs, routes ) = extract_routes hcs
		val (sequ, optrte) = drop_get_routes hc
	in	( sequ :: seqs, optrte :: routes )
	end


val vr_elsf_true =		ñVRElsfTrue®
val vr_elsf_false =		ñVRElsfFalse®

val vr_any =			ñ(VRAny _)®
val vr_null =			ñ(VRNull _)®
val vr_assign =			ñ(VRAssign _)® 
val vr_spec_via =			ñ(VRSpecVia _)® 
val vr_spec_to_side =		ñ(VRSpecToSide _)® 
val vr_spec_pre_intro =		ñVRSpecPreIntro® 
val vr_semi =			ñ(VRSemi _)® 
val vr_end_semi =			ñ(VREndSemi _)® 
val vr_if_then =			ñ(VRIfThen _)® 
val vr_if_else =			ñ(VRIfElse _)®
val vr_end_if =			ñ(VREndIf _)® 
val vr_case_branch =		ñ(VRCaseBranch _)® 
val vr_case_others =		ñ(VRCaseOthers _)®
val vr_end_case =			ñ(VREndCase _)®
val vr_loop_undec_via =		ñ(VRLoopUndecVia _)®
val vr_loop_undec_pre_intro =	ñVRLoopUndecPreIntro®
val vr_loop_undec_pre_to_side =	ñVRLoopUndecPreToSide®
val vr_loop_undec_to_side =	ñ(VRLoopUndecToSide _)®
val vr_while_via =		ñ(VRWhileVia _)®
val vr_while_pre_intro =		ñVRWhilePreIntro®
val vr_while_wp_to_side =		ñ(VRWhileWPToSide _)®
val vr_while_to_side =		ñ(VRWhileToSide _)®
val vr_for_via =			ñ(VRForVia _)®
val vr_for_pre_intro =		ñVRForPreIntro®
val vr_for_pre_to_side =		ñVRForPreToSide®
val vr_for_to_side =		ñ(VRForToSide _)®
val vr_for_exit_to_side =		ñ(VRForExitToSide _)®
val vr_exit_till_intro =		ñVRExitTillIntro®
val vr_exit_via =			ñ(VRExitVia _)®
val vr_return_intro =		ñVRReturnIntro®
val vr_proc_call =		ñ(VRProcCall _)®
val vr_proc_call_end =		ñ(VRProcCallEnd _)®
val vr_proc_call_rng_intro =	ñVRProcCallRngIntro®
val vr_log_con_to_side =		ñ(VRLogConToSide _)®
val vr_log_con_pre_intro =		ñVRLogConPreIntro®
val vr_log_con_type_mem_intro =	ñVRLogConTypeMemIntro®
val vr_refinement_begin =		ñ(VRRefinementBegin _)®
val vr_refinement_intro =		ñVRRefinementIntro®
=TEX
\pagebreak
\section{Substitutions}
=TEX
First we introduce the new flag.
=SML
val Ûcn_use_let_in_vcsÝ : bool ref = ref false;
val side_effect = new_flag
	{name = "cn_use_let_in_vcs",
	control = cn_use_let_in_vcs,
	check = fun_true,
	default = fun_false} handle Fail _ => ();
=TEX
For convenience in coding, we introduce $list\_sub$, a general parallel substitution operator and use it to support the particular variants on substitution which are required.
=SML
fun Ûlist_subÝ ((p, xes) :Z_PRED * ((Z_ID * Z_EXP) list)) : Z_PRED = (
	if	!cn_use_let_in_vcs
	then	let	fun mk_def (x : Z_ID, e : Z_EXP) = (
					(mk_var(x, type_of e), e)
			);
			fun not_wanted (x, e) = (
					not (is_free_in x p)
				orelse	x =$ e
			);
			val defs = map mk_def xes drop not_wanted;
		in	mk_let (defs, p)
		end
	else	let	fun mk_subs (x : Z_ID, e : Z_EXP) = (
				(e, mk_var(x, type_of e))
			);
			val isubs1 = (map mk_subs xes);
		val isubs2 = isubs1 drop (fn (a, b) => (a =$ b));
			val p' = var_subst isubs2 p;
			val back_to_z_conv = TRY_C(TOP_MAP_C (
				z_schema_pred_conv1 ORELSE_C
				z_Ê_conv1 ORELSE_C
				z_dec_rename‰s_conv));
		in	(snd o dest_eq o concl o back_to_z_conv) p'
		end
);
=TEX
=SML
fun ÛsubÝ ((p, x, e) :Z_PRED * Z_ID * Z_EXP) : Z_PRED = (
	list_sub(p, [(x, e)])
);
=TEX
=SML
fun Ûsubs_expÝ ((e, xs, ys) :Z_EXP * (Z_ID list) * (Z_ID list)) : Z_EXP = (
	let	val xys = combine xs ys;
		val ntys = map dest_var(frees e);
		fun s ((n, ty) :: more) (x, y) = (
			if	n = x
			then	(x, mk_var(y, ty)) :: s more (x, y)
			else	s more (x, y)
		) | s [] _ = [];
	in	list_sub(e, flat(map (s ntys) xys))
	end		
);
=TEX
=SML
fun Ûsubs_predÝ ((p, xs, ys) :Z_PRED * (Z_ID list) * (Z_ID list)) : Z_PRED = (
	subs_exp(p, xs, ys)
);
fun ÛsubseqÝ ((seql, x, e) :SEQUENT list * Z_ID * Z_EXP) : SEQUENT list = (
	map (fn (H, c) => map (fn p => sub(p, x, e)) H ô sub(c, x, e)) seql
);
=TEX
\pagebreak

\section{ABSTRACT SYNTAX OF SPARK STATEMENTS}\label{ASSPARK}

See \cite{ISS/HAT/DAZ/DTD502}.

\section{WEAKEST PRECONDITIONS}\label{WPS}
\subsection{Environments}\label{environments}
=TEX
\subsection{Other Preliminaries}\label{Preliminaries}
=TEX

\subsection{Null Statement}\label{wp-null}
=SML
fun ÛnullÝ ({a, ...} : WP_PARS) : RESULT = (
	{wp = cons_srs vr_null a, side = []}
);
=TEX
\subsection{Assignment Statement}\label{wp-assignment}
=TEX
{\it z\_record\_update} has some tricky type instantiation
to do (the problem is that the order (and number) of the generic parameters
does not correspond one-to-one with the binding components, because
binding components that shared a type mark in the type declaration have just
one generic parameter).
=SML
fun Ûz_record_updateÝ (ztmark : Z_ID, sel : ID, zpfx : Z_EXP, e : Z_EXP) : Z_EXP = (
	let	val fun_name = ztmark ^ "u" ^ sel;
		val ty = case get_const_type(ZTypesAndTermsSupport.bind_gvar_name fun_name) of
				Value t => t
			|	_ => fail "z_record_update" 505028 [];
		val (gty, rty) = dest_­_type ty;
		val us = map mk_u (dest_z_tuple_type gty);
		val fun_exp = mk_z_gvar(fun_name, rty, us);
		val arg_exp = mk_z_tuple[zpfx, e];
		val (arg_ty, res_ty) = case dest_z_tuple_type
					(dest_z_power_type (type_of fun_exp)) of
					[ty1, ty2] => (ty1, ty2)
				|	_ => fail "z_record_update" 505028 [];
		val ty_map = type_match (type_of arg_exp) arg_ty
				handle Fail _ => fail "z_record_update" 505028 [];
	in	mk_z_app(inst [] ty_map fun_exp, arg_exp)
	end
);
=TEX
The implementation of $simple\_assign$ works on an assignment where the expression on the rhs has already been converted to Z.
=SML
fun Ûsimple_assignÝ ({wp_env={env,...}, a, ...} : WP_PARS)
		(x : ID) (ze : Z_EXP) : RESULT = (
	let	val zx = trans_id x;
		val orig = case env zx of
			Value(_, EIEnvVar(_, Value orig)) => orig
		|	Value(_, EIEnvRetry ex) => ex
		|	_ => zx;
	in	{wp = add_domain_conds env ([ze], subseq(a, orig, ze)), side = []}
	end
)
(*
=TEX
=SML
*)
and Ûarray_assignÝ ({wp, a, wp_env as {env,...}} : WP_PARS)
			({prefix, index as EArrayAggPos{comps, tmark as Nil}} : EXP INDEXED_COMP) (ze : Z_EXP) : RESULT = (
let	val name' = prefix;
	val e' = (z_override
			(trans_exp env prefix, z_set
			   [z_maplet (z_tuple(map (trans_exp env) comps), ze)]));
in
	assign_rec {wp = wp, a = a, wp_env = wp_env} (name', e')
end
) | array_assign _ _ _ = (
	fail "array_assign" 508056 []
)
(*
=TEX
=SML
*)
and  Ûrecord_assignÝ	({wp, a, wp_env as {env, ...}} : WP_PARS)
	({prefix, selector} : EXP SELECTED_COMP) (ze : Z_EXP) : RESULT = (
let	val zprefix = trans_exp env prefix;
	val side = dest_z_schema_type(type_of zprefix)
			handle Fail _ => fail "record_assign" 505027 [];
	val name' = prefix;
	val tmark = tmark_of_prefix env zprefix
			handle Fail _ => fail "record_assign" 505028 [];
	val ze' = z_record_update(tmark, selector, zprefix, ze); 
in
	assign_rec {wp = wp, a = a, wp_env = wp_env} (name', ze')
end
)
(*
=TEX
=SML
*)
and Ûassign_recÝ (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ((name, ze) : EXP * Z_EXP)
			: RESULT = (
	case name of
	EId id => simple_assign wp_pars id ze
	|EIndexedComp ic => array_assign wp_pars ic ze
	|ESelectedComp sc => record_assign wp_pars sc ze
	|_ => fail "assign" 505029 []
);
=TEX
=SML
fun ÛassignÝ (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ((name, ze) : EXP * Z_EXP)
			: RESULT = (
let	val tmark = tmark_of_prefix env(trans_exp env name);
	val ze' = slide_to_tmark env (ze, tmark);
	val {wp = wp1, side = side1} = assign_rec wp_pars (name, ze');
in	{wp = cons_srs vr_assign wp1, side = cons_srs vr_any side1}
end
);
=TEX
\subsection{Specification Statement (No initial variables)}\label{wp-specification-no-ivars}
=SML
fun Ûspec_no_ivarsÝ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	let 	val wphd = [] ô pre
		val side = post %Longrightarrow% a
	in
		{wp = [ init_sr vr_spec_pre_intro wphd ], 
		 side = cons_srs vr_spec_to_side side 
		}
	end
);
=TEX
=SML
fun Ûspec_no_ivars_emptyÝ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = init_sr vr_spec_pre_intro  ([] ô pre):: 
		(cons_srs vr_spec_via  (post %Longrightarrow% a)), 
	 side = []
	}
);
=TEX
=SML
fun Ûspec_no_ivars_eitherÝ (wp : WP_PARS) (w : Z_ID list) ((pre, post) : Z_EXP * Z_EXP) 
		: RESULT = (
	if	w = []
	then	spec_no_ivars_empty wp (pre, post)
	else	spec_no_ivars wp (pre, post)
);
=TEX
\subsection{Semicolon}\label{wp-semicolon}
=SML
fun ÛsemicolonÝ ({wp, a, wp_env} : WP_PARS) ((p, q) : STATEMENT * STATEMENT)
			: RESULT = (
let	val {wp = wp2, side = side2} = wp (q, cons_srs vr_end_semi a, wp_env);
	val {wp = wp1, side = side1} = wp (p, wp2, wp_env);
in
	{wp = cons_srs vr_semi  wp1, 
	 side = cons_srs vr_semi (side1 @ (cons_srs vr_any side2)) 
	}
end
);
=TEX
=IGN
val (STSemicolon (p,q)) = exp;
val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
val save_exp1 = exp;
val exp= q;
=TEX
\subsection{If Statement}\label{wp-if-then-else}
=SML
fun Ûif_then_elseÝ	({wp, a, wp_env as {env,...}} : WP_PARS)
			({g, p, q, elsif} : STATEMENT IF_THEN_ELSE) : RESULT = (
let	val sr_a = cons_srs vr_end_if a
	val {wp = wp1, side = side1} = wp (p, sr_a, wp_env);
	val {wp = wp2, side = side2} = wp (q, sr_a, wp_env);
         val sr_elsf = if elsif then vr_elsf_true else vr_elsf_false
	val sr_wp1 = cons_dec_srs (vr_if_then, [sr_elsf]) wp1
	val sr_wp2 = cons_dec_srs (vr_if_else, [sr_elsf]) wp2
	val ze = trans_exp env g;
	val wp = add_domain_conds env ([ze],
		(z_eq(ze, zid env "TRUE") %Longrightarrow% sr_wp1) @
		(z_eq(ze, zid env "FALSE") %Longrightarrow% sr_wp2));
	val sr_side1 = cons_dec_srs (vr_if_then,[sr_elsf]) side1
	val sr_side2 = cons_dec_srs (vr_if_else,[sr_elsf]) side2
	val side = sr_side1 @ sr_side2;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Case Statement}\label{wp-case}
=SML
fun Ûadjust_choicesÝ (env : CN_ENV) (choices : CASE_CHOICE list) : CASE_CHOICE list = (
	case choices of
		[] => []
	|	(ch as CCCaseRange _)::rest => ch :: adjust_choices env rest
	|	(ch as CCCaseExp exp):: rest => (
			let	val n = name_to_tmark exp;
			in
				case env n of
					Value (_, EIEnvOtherType) => (
			CCCaseRange(DRConstrained{range=RRange {
				lo=EAttribute {attribute_desig=ADAttrib "FIRST",prefix=exp},
				hi=EAttribute {attribute_desig=ADAttrib "LAST", prefix=exp}},
				tmark=n})
				) |	_ => CCCaseExp exp
			end :: adjust_choices env rest
	)
);
=TEX
=SML
fun Ûtrans_case_choicesÝ (env : CN_ENV) (in_choices : CASE_CHOICE list) : Z_EXP = (
let	val choices = adjust_choices env in_choices;
	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	fun aux_range (ch::rest) = (
		case ch of
		CCCaseRange (DRRange range) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
			end		
		|CCCaseRange (DRConstrained{range,...}) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
			end		
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		CCCaseExp exp =>
			adjust_and_trans exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choices;
	val zsingles = z_set (aux_singles choices);
in
	z_many_union(zranges @ [zsingles])
end
);
=TEX
=SML
fun Ûcase_baseÝ ({wp, a, wp_env as {env,...}} : WP_PARS) (e : EXP) (n : int)
			({choices, p} : STATEMENT CASE_ALTERNATIVE)
			 : RESULT * Z_EXP = (
let	val {wp = wp1, side = side1} = wp (p, a, wp_env);
	val ze = trans_exp env e;
	val zcs = trans_case_choices env choices;
         val sr_op = cons_dec_srs (vr_case_branch, [mk_z_int (string_of_int n)] ) 
	val sr_wp1 = sr_op wp1
         val sr_side1 =  sr_op side1
	val wp' = z_elem (ze, zcs) %Longrightarrow% sr_wp1;
in	({wp = add_domain_conds env ([ze, zcs], wp'), side = sr_side1}, zcs)
end
);
=TEX
{\it case\_step} expects to be called by {\it case\_others} and ignores
the ``others'' part.
=SML
fun Ûcase_stepÝ (pars as {wp, a, wp_env as {env,...}} : WP_PARS) (n : int) 
		({e, s, others} : STATEMENT CASE) : RESULT * Z_EXP list = (
	case s of
	[] =>
		fail "case_step" 505030 []
	| [alt] =>
		let	val (res, ze) = case_base pars e n alt;
		in	(res, [ze])
		end
	| ({choices, p} :: s') =>
		let	val {wp = wp1, side = side1} =
				wp (p, a, wp_env);
         		val sr_op = cons_dec_srs 
					(vr_case_branch, [mk_z_int (string_of_int n)] ) 
			val (sr_wp1, sr_side1) = (sr_op wp1, sr_op side1)
			val ({wp = wp2, side = side2}, rest) =
				case_step pars (n+1) {e=e, s=s', others=others};
			val ze = trans_exp env e;
			val zcs = trans_case_choices env choices;
			val wp3 = add_domain_conds env([ze, zcs],
				(z_elem (ze, zcs) %Longrightarrow% sr_wp1) @ wp2);
		in	({wp = wp3 , side = sr_side1 @ side2},
			 zcs :: rest)
		end
);
=TEX
Note that {\it case\_step} is recursive and does the full job for a case statement
without an others part. 
{\it case\_others} then acts as the main entry point for case statements,
calling {\it case\_step} to do do the non-others alternatives and then
handling the others part if present.

As agreed with QinetiQ, in the (unlikely) case where the others part is an explicit nothing statement,
we do not generate any VCs for the others part, since the program will not have an others part
and so, if it passes the compiler's checks on the exhaustive coverage of the case statement, the
VCs are guaranteed to be true. We do not attempt to suppress VC generation if the others
part comprises something like the sequential composition of two nothings (in general, it could
comprise a sequential compositioin of nothings and specifications statements that will later
be refined to nothings, but we cannot detect that case here).
=SML
fun Ûcase_othersÝ (pars as {wp, a, wp_env as {env,...}} : WP_PARS)
		(st as {e, others, ...} : STATEMENT CASE) : RESULT = (
	let	val a_in = cons_srs vr_end_case a
		val pars_in = {wp = wp, a = a_in, wp_env = wp_env}
		val (res as {wp = wp1, side = side1}, exps) = case_step pars_in 1 st;
		val ze = trans_exp env e
	in	case others of 
		(STNull SNImplicit) => res
	|	(STNull SNNothing) => res
	|	stmt =>
		let	val {wp = wp2, side = side2} = wp(others, a_in, wp_env);
			val wp2_g = (z_notelem(ze, z_many_union exps) %Longrightarrow% wp2);
			val sr_wp2_g = cons_srs vr_case_others wp2_g;
			val wp = wp1 @ sr_wp2_g;
                           val sr_side2 = cons_srs vr_case_others side2;
			val side = side1 @ sr_side2;
		in	{wp = add_domain_conds env (ze::exps, wp), side = side}
		end
	end
);
=TEX

\subsection{Undecorated Loop}\label{wp-loop}
=SML
fun ÛloopÝ ({a, wp_env={env, ...}, ...} : WP_PARS) ({t, stmt} : STATEMENT LOOP)
			: RESULT = (
let	val (pre1, post1) = case stmt of
		STSpecNoIvars {spec={pre, post, ...}, ...} => (
			(z_predexp_of_z_tm1 env pre,z_predexp_of_z_tm1 env post)
		) |_ => fail "loop" 505022 [];
	val wp = [init_sr vr_loop_undec_pre_intro ([] ô pre1)];
	val side = case t of
			Value till => 
			   [init_sr vr_loop_undec_pre_to_side ([post1] ô pre1)] @
				(cons_srs vr_loop_undec_to_side
					((z_predexp_of_z_tm1 env till) %Longrightarrow% a))
			|Nil => [init_sr vr_loop_undec_pre_to_side ([post1] ô pre1)];
in
	{wp = wp, side = side}
end
);
=TEX
=SML
fun Ûnamed_loopÝ (wp_pars : WP_PARS) ({t, stmt, ...} : STATEMENT NAMED_LOOP)
			: RESULT = (
	loop wp_pars {t=t, stmt=stmt}
);
=TEX
\subsection{While Loop}\label{wp-while-loop}
=SML
fun Ûcn_whileÝ	({a, wp_env={env, ...}, ...} : WP_PARS)
		({g, loop={t,stmt}, ...} : STATEMENT WHILE) : RESULT = (
let	val {w, w0, pre, post} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "loop" 505022 [];
	val pre1 = z_predexp_of_z_tm1 env pre;
	val post1 = z_predexp_of_z_tm1 env post;
	val ze = trans_exp env g;
         val pre_intro_seq = init_sr vr_while_pre_intro ([z_eq(ze, zid env "TRUE")] ô pre1);
         val via_seqs = (z_eq(ze, zid env "FALSE") %Longrightarrow% a);
         val sr_via_seqs = cons_srs vr_while_via via_seqs
	val wp = add_domain_conds env([ze], pre_intro_seq :: sr_via_seqs );
         val wp_to_side = (post1 %Longrightarrow% wp);
	val sr_wp_to_side = cons_srs vr_while_wp_to_side wp_to_side;
	val till_part = case t of
			Value till => (z_predexp_of_z_tm1 env till) %Longrightarrow% a
					
			|Nil => [];
	val sr_till_part = cons_srs vr_while_to_side till_part;
	val side = sr_wp_to_side @ sr_till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-static}
=SML
fun Ûfor_staticÝ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, range, dir, loop = {t, stmt}, ...} : STATEMENT FOR_STATIC) : RESULT = (
let	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	val {lo, hi} = dest_range range;
	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_static" 505022 [];
	val pre1 = z_predexp_of_z_tm1 env pre;
	val post1 = z_predexp_of_z_tm1 env post;
	val zi = trans_id i;
	val zlo = adjust_and_trans lo;
	val zhi = adjust_and_trans hi;
	val (zinitial, zfinal, zop) =
		if dir = LDForwards then (zlo, zhi, z_add) else (zhi, zlo, z_minus);
	val zleft = zid env zi;
	val zright = z_num one;
	val zid_zi = zid env zi;
	val zran = z_elem (zid_zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val pre_intro = [z_less_eq (zlo, zhi)] ô sub(pre1, zi, zinitial);
	val sr_pre_intro = [init_sr vr_for_pre_intro pre_intro];
	val via = z_greater (zlo, zhi) %Longrightarrow% a;
	val sr_via = cons_srs vr_for_via via;
	val wp = add_domain_conds env ([zlo, zhi], sr_pre_intro @ sr_via );
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm1 env till) %Longrightarrow% a)
			) | Nil => [];
         val sr_till_part = cons_srs vr_for_exit_to_side till_part;
	val go_round = [zran, z_noteq(zid_zi, zfinal), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright));
	val sr_go_round = [init_sr vr_for_pre_to_side  go_round];
	val dont_go = sub(post1, zi, zfinal) %Longrightarrow% a;
	val sr_dont_go = cons_srs vr_for_to_side dont_go;
	val side = add_domain_conds env ([zfinal], 
			sr_go_round @ sr_dont_go @ sr_till_part);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}
=SML
fun Ûfor_tmarkÝ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, dir, loop = {t, stmt}, ...} : STATEMENT FOR_TMARK) : RESULT = (
let	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_tmark" 505022 [];
	val pre1 = z_predexp_of_z_tm1 env pre;
	val post1 = z_predexp_of_z_tm1 env post;
	val zi = trans_id i;
	val zlo = zid env (trans_id tmark ^^ zfst);
	val zhi = zid env (trans_id tmark ^^ zlst);
	val (zinitial, zfinal, zop) =
		if dir = LDForwards then (zlo, zhi, z_add) else (zhi, zlo, z_minus);
	val zleft = zid env zi;
	val zright = z_num one;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val pre_intro = [z_less_eq (zlo, zhi)] ô sub(pre1, zi, zinitial);
	val sr_pre_intro = [init_sr vr_for_pre_intro pre_intro];
	val via = z_greater (zlo, zhi) %Longrightarrow% a;
	val sr_via = cons_srs vr_for_via via;
 	val wp = sr_pre_intro @ sr_via;
	val till_part = case t of
			Value till => (
				(z_predexp_of_z_tm1 env till) %Longrightarrow% a
			) | Nil => [];
         val sr_till_part = cons_srs vr_for_to_side till_part;
	val go_round = [z_noteq(zid env zi, zfinal), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright));
	val sr_go_round = [init_sr vr_for_pre_to_side go_round];
	val dont_go = sub(post1, zi, zfinal) %Longrightarrow% a;
	val sr_dont_go = cons_srs vr_for_to_side dont_go;
	val side = sr_go_round @ sr_dont_go @ sr_till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=SML
fun Ûexit_whenÝ ({a, wp_env={till, env, ...}, ...} : WP_PARS)
		({g, n = Nil} : EXIT_WHEN)
			 : RESULT = (
let	val ze = trans_exp env g;
	val do_exit = ([z_eq(ze, zid env "TRUE")] ô till);
	val sr_do_exit = [init_dec_sr (vr_exit_till_intro, [mk_z_string ""]) do_exit];
	val dont_exit = (z_eq(ze, zid env "FALSE") %Longrightarrow% a);
	val sr_dont_exit = cons_srs vr_exit_via dont_exit;
	val wp = add_domain_conds env ([ze], sr_do_exit @ sr_dont_exit);
in	{wp = wp, side = []}
end
) | exit_when ({a, wp_env={named_tills, env, ...}, ...})
	({g, n = Value name} : EXIT_WHEN) = (
let	val ze = trans_exp env g;
	val till = case s_lookup name named_tills of
		Value p => p
	|	Nil => fail "exit_when" 505069 [fn _ => name];
	val do_exit = ([z_eq(ze, zid env "TRUE")] ô till);
	val sr_do_exit = [init_dec_sr (vr_exit_till_intro,  [mk_z_string name]) (do_exit)];
	val dont_exit = z_eq(ze, zid env "FALSE") %Longrightarrow% a;
	val sr_dont_exit = cons_srs vr_exit_via dont_exit;
	val wp = add_domain_conds env ([ze], sr_do_exit @ sr_dont_exit );
in	{wp = wp, side = []}
end
);
=TEX
\subsection{Exit}\label{wp-exit}
=SML
fun Ûcn_exitÝ ({wp_env={till, ...},...} : WP_PARS) ({n = Nil} : EXIT): RESULT = (
	{wp = [init_dec_sr (vr_exit_till_intro , [mk_z_string ""]) ([] ô till)], side = []}
) | cn_exit ({wp_env={named_tills, ...},...} : WP_PARS) ({n = Value name} : EXIT) = (
let	val till = case s_lookup name named_tills of
		Value p => p
	|	Nil => fail "exit_when" 505069 [fn _ => name]
in	{wp = [init_dec_sr(vr_exit_till_intro,[mk_z_string name]) ([] ô till)], 
	 side = []
	}
end
);
=TEX
\subsection{Return}\label{wp-return}
=TEX
$conv\_var\_decl$ is implemented in \cite{ISS/HAT/DAZ/IMP508}.
=SML
fun Ûcn_returnÝ ({wp, a, wp_env= {env,
		fun_header={name, formal_pars, return_type, par_names_defs},
			return, ...}} : WP_PARS)
		({e = Value exp} : RETURN) : RESULT = (
let	val zfun = trans_fun_name env name;
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_pars;
	val ids = flat (map (fn {vars, ...} => vars) var_decls);
	val zargs = map (fn id => zid env (trans_id id)) ids;
	val ze = slide_to_tmark env (trans_exp env exp, return_type);
	val do_return = [z_eq(z_fun_call(zfun, zargs), ze)] ô return;
	val sr_do_return = [init_sr vr_return_intro do_return];
	val wp = add_domain_conds env ([ze], sr_do_return );
	val side = [];
in
	{wp = wp, side = side}
end
) | cn_return ({wp, a, wp_env= {env, return, ...}})
		({e = Nil} : RETURN) : RESULT = (
	{wp = [ init_sr vr_return_intro ([] ô return) ], side = []}
);
=TEX
\subsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}
We need a mechanism for generating the names for the new Z variables
that stand for record or array components as exported actual parameters.
The function {\it param\_tmp\_name} does this.
The function constructs a list of names to be avoided from the type inference context.
This relies on the function {\it call\_vcs} in \cite{ISS/HAT/DAZ/IMP507} which
always puts all variables (including auxiliary variables and logical constants)
that are in scope in the VCs being calculated into the type inference
context.
The new variables are themselves added to the type inference context to handle
the situation where several new variables are needed in one sequence of statements
(to enable the new variables to be added to the type inference context, the
appropriate type must be passed in).

To confirm this approach, note that: {\it store\_vcs} in \cite{ISS/HAT/DAZ/IMP507}
fails if any VC contains free variables; moreover {\it call\_vcs} sets up the
type inference context using the same {\it SPECLAB} that it passes to the
function {\it vcs} below, which in turn uses that {\it SPECLAB} to derive
the local declarations to be added when the universal closure of each VC
is formed; so every variable that can appear
in a VC and so might clash with a new variable name generated here
must be in the type inference context; also 
\cite{ISS/HAT/DAZ/IMP507} arranges to type-check every post-condition
and this will ensuer that the new variable name cannot appear free in the
original sequent whose weakest pre-condition we are calculating.

=SML
val Ûparam_tmp_name_stemÝ : Z_ID = "tmp_";
fun Ûmaybe_param_tmp_nameÝ (n : Z_ID) : bool = (
	let	val tmp_size = size param_tmp_name_stem;
	in	substring(n, 0, tmp_size) = param_tmp_name_stem handle _ => false
	end
);
fun Ûparam_tmp_nameÝ (ty : TYPE) : Z_ID = (
	let	fun filter av = (
			not (maybe_param_tmp_name av)
		);
		val ti_cxt_names = map ((fn (n, _, _) => n) o dest_z_lvar) (get_ti_context());
		val avoid = ti_cxt_names drop filter;
		fun find_next i = (
			let	val n = param_tmp_name_stem ^ string_of_int i;
			in	if	n mem avoid
				then	find_next (i+1)
				else	n
			end
		);
		val res = find_next 1;
	in	set_ti_context(mk_var(res, ty)::get_ti_context());
		res
	end
);
=IGN
param_tmp_name ”ú®;
param_tmp_name ”ú®;
set_ti_context (map (switch(curry mk_var) ”ú®) ["abc", "def", param_tmp_name”ú®]);
param_tmp_name ”ú®;
param_tmp_name ”ú®;
param_tmp_name ”ú®;
param_tmp_name ”ú®;
set_ti_context (map (switch(curry mk_var) ”ú®) ["abc", "def", "tmp_3", "tmp_4"]);
param_tmp_name ”ú®;
get_ti_context();
set_ti_context[];
=TEX
The work done for an individual parameter is sufficiently complicated to
merit a separate function.
This is passed the actual parameter expression together with the
all the information from the formal parameter specification for this parameter.
It returns two substitution lists: one to be applied to the pre-condition
and one to be applied to the post-condition.
It also returns, if necessary, a list of predicates giving
the domain conditions for the actual parameter and,
if this is a record or array component actual parameter being
exported, the membership constraint giving the declaration for
the new Z variable that represents the parameter.

The optional predicate is the VC that may be needed if an exported parameter
is being passed to a formal whose type is a constrained array subtype
and which therefore may be subject to sliding.
The control logic relies on the fact that a slid expression is not a variable
and so we will always end up in the exception handler in the case where a VC may be necessary.
In this case, if the parameter is an {\tt in} we can just use the (possibly) slid expression.
We therefore only have to test whether sliding has occurred in the handler in the
case of an exported parameter.

The final part of the return value is the optional
assignment statement that gives the update to the actual parameter
to be considered as executed after the call.
=SML
fun Ûproc_call_paramÝ (env : CN_ENV)
	(actual : EXP, formal : ID, tmark : TMARK, mode : MODE)

	: (Z_ID * Z_EXP) list * (Z_ID * Z_EXP) list * Z_PRED list * Z_PRED OPT * STATEMENT OPT = (
let	val	ntm as (n, tm) = (trans_id formal, trans_exp env actual);
	val	sl_tm = slide_to_tmark env (tm, tmark);
	val	dcs = domain_conds env tm;
in	let	val (v, ty) = dest_var sl_tm;
	in	([ntm], [ntm, (init_var n, mk_var(init_var v, ty))], dcs, Nil, Nil)
	end	handle Fail _ => (
			case mode of
				MSparkIn _ => ([(n, sl_tm)], [(n, sl_tm)], dcs, Nil, Nil)
			|	_ => (
				let	val (v, ty) = dest_var tm;
					val cnstrnt = zid env (trans_id tmark);
					val vc_opt = (
						case con_array_range_from_tmark cnstrnt of
							Nil => Nil
						|	Value r => Value (z_eq(z_dom tm, r))
					);
				in	([ntm],
					 [ntm, (init_var n, mk_var(init_var v, ty))],
					 dcs,
					 vc_opt,
					 Nil)
				end handle Fail _ =>
				let	val ty = type_of tm;
					val nv = param_tmp_name (type_of tm);
					val cnstrnt = zid env (trans_id tmark);
					val nvtm = mk_z_lvar(nv, ty, []);
					val pred = z_mem(nvtm, cnstrnt);
					val vc_opt = (
							case con_array_range_from_tmark cnstrnt of
							Nil => Nil
						|	Value r => Value (z_eq(z_dom tm, r))
					);
					val stmt = Value (STAssign {
						name = actual,
						e = EAuxiliaryExp(z_quote(nvtm, Nil))});
				in	([ntm],
					 [(init_var n, tm), (n, nvtm)],
					 pred::dcs,
					 vc_opt,
					 stmt)
				end
			)
		)
	end
);
=TEX
The following function type-checks the pre- and post-condition of a procedure
call in the appropriate context, restoring the original context afterwards.
=SML
fun Ûz_preds_in_callee_cxtÝ
	(env : CN_ENV)
	({name, formal_ids, ...} : FORMAL_PROC)
	(ztms : Z_TM list)
			: Z_PRED list = (
	let	val old_cxt = get_ti_context();
		val extra_cxt = ti_context_of_formal_ids env formal_ids;
		val extra_ns = map (fst o dest_var) extra_cxt;
		val filt_old_cxt = old_cxt drop (fn t => fst(dest_var t) mem extra_ns);
		val new_cxt =  extra_cxt @ filt_old_cxt;
		val side1 = set_ti_context new_cxt;
		val zps = map (z_predexp_of_z_tm1 env) ztms;
		val side2  = set_ti_context old_cxt;
	in	zps
	end
);
=TEX
In the following, computing the precise frame of the {\it SPEC}  returned would be a little tricky.
However, all that matters in the weakest pre-condition calcualation is whether or not the
frame is empty, so we just copy the original frame from the {\it FORMAL\_PROC}.

=SML
fun Ûproc_call_specÝ (env : CN_ENV)
		({actuals, ...} : (AGG_CHOICE,EXP) PROC_CALL)
		(fp as {name, formal_ids, par_names_defs, spec={pre, post, w, w0}, ...} : FORMAL_PROC)
			: SPEC * STATEMENT * Z_PRED list * Z_PRED list = (
let	val names = map fst par_names_defs;
	val pre1_post1 = z_preds_in_callee_cxt env fp [pre, post];
	val pre1 = hd pre1_post1;
	val post1 = hd(tl pre1_post1);
	val var_decls = map #var_decl formal_ids;
	val adj_actuals = case actuals of
			APositional exps => map (adjust_exp env)
					(positional_assocs_to_exps par_names_defs exps)
			|ANamed nas => map (adjust_exp env)
					(named_assocs_to_exps par_names_defs nas);
	fun do_params (acc as (presub, postsub, dc_preds, vc_preds, st))
		(acts as (act::more_acts) : EXP list)
		({var_decl = {vars = frm::more_frms, tmark}, mode}::more_pss : PARAM_SPEC list)
	: (Z_ID * Z_EXP) list * (Z_ID * Z_EXP) list * Z_PRED list * Z_PRED list * STATEMENT = (
		let	val (prs, psts, prds, prd_opt, st_opt) =
			proc_call_param env (act, frm, tmark, mode);
		in	do_params
			(prs@presub, psts@postsub, prds term_union dc_preds,
			(case prd_opt of Nil => vc_preds
			| Value prd => vc_preds @ [prd]),
			(case st_opt of Nil => st
			 | Value asgn => STSemicolon(asgn, st)))
			more_acts
			({var_decl = {vars = more_frms, tmark = tmark},
			  mode = mode}::more_pss)
		end
	) | do_params acc acts ({var_decl = {vars = [], ...}, ...}::more_pss) = (
		do_params acc acts more_pss
	) | do_params acc [] [] = (
		acc
	) | do_params _ _ _ = (
		fail "proc_call_spec" 505026 [fn () => name]
	);
	val (presubs, postsubs, dc_preds, vc_preds, asgns) =
		do_params ([], [], [], [], STNull SNImplicit) adj_actuals formal_ids;
	val pre2 = list_sub(pre1, presubs);
	val post2 = list_sub(post1, postsubs);
	val spec = {w = w, w0=w0,
				pre=z_quote(pre2, Nil),
				post=z_quote(post2, Nil)};

in
	(spec, asgns, dc_preds, vc_preds)
end
);
=TEX
The following function, common to either kind of procedure call, looks for the formal specification
of a procedure taking into account the possibility that its name may be the unexpanded form
of a procedure in a used package.
=SML
fun Ûget_proc_specÝ (caller : string)  (env : CN_ENV)
	(fps : FORMAL_PROC list) (name : ID)  : FORMAL_PROC= (
let	val	zname = 
		case env name of
			Value (_, EIEnvRetry n') =>  n'
		|	_ => trans_id name;
	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (zname = trans_id n);
in	find fps is_it
	handle Fail _ =>
	fail caller 505031 [fn()=>name]
end
);
=TEX
=SML
fun Ûproc_call_no_ivarsÝ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
		(pc as {name, actuals} : (AGG_CHOICE,EXP) PROC_CALL)
			: RESULT = (
let	val fp as {spec = {w, ...}, ...} = get_proc_spec "proc_call_no_ivars" env formal_procs name;
	val (spec, asgns, dc_preds, vc_preds) = proc_call_spec env pc fp;
	val xform = STSemicolon(
			STSpecNoIvars{spec = spec,
				label = "", is_assertion = false}, asgns);
	val a_in = cons_srs vr_proc_call_end a;
	val {wp = wp1, side = side1} = wp (xform, a_in, wp_env);
	val side2 = map (fn p => init_sr vr_proc_call_rng_intro ([] ô p)) vc_preds;
         val sr_wp1 = cons_srs vr_proc_call wp1;
	val sr_side1 = cons_srs vr_proc_call side1;
in	{wp = add_hyps(dc_preds, sr_wp1), side = add_hyps(dc_preds, sr_side1@side2)}
end
);
=TEX
\subsection{Specification Statement (with Initial Variables)}\label{wp-spec-ivars}
=SML
fun Ûspec_ivarsÝ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(((pre, post)) : (Z_EXP * Z_EXP)) : RESULT = (
let	val sr_wp = [init_sr vr_spec_pre_intro ([] ô pre)];
	val side = post %Longrightarrow% a;
	val sr_side = cons_srs vr_spec_to_side side;
in
	{wp = sr_wp, side = sr_side}
end
);
=TEX
\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}
=SML
fun Ûfor_non_staticÝ (pars as {wp, a, wp_env as {env, ...}} : WP_PARS)
			({i, range, loop = {t, stmt}, dir, ...} : STATEMENT FOR_NON_STATIC)
			 : RESULT = (
let	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	val {lo, hi} = dest_range range;
	val {pre, post, w, w0, ...} = case stmt of
		STSpecNoIvars {spec,  ...} => spec
		|_ => fail "for_non_static" 505022 [];
	val pre1 = z_predexp_of_z_tm1 env pre;
	val post1 = z_predexp_of_z_tm1 env post;
	val zi = trans_id i;
	val zlo = adjust_and_trans lo;
	val zhi = adjust_and_trans hi;
	val zleft = zid env zi;
	val zright = z_num one;
	val zlo0 = subs_exp (zlo, w, w0);
	val zhi0 = subs_exp(zhi, w, w0);
	val (zinitial0, zfinal0, zop) =
		if dir = LDForwards then (zlo0, zhi0, z_add) else (zhi0, zlo0, z_minus);
	val zran = z_elem(zid env zi, z_rng (zlo0, zhi0));
	val pre_intro = [z_less_eq (zlo, zhi)] ô sub(pre1, zi, zinitial0);
	val sr_pre_intro = [init_sr vr_for_pre_intro pre_intro];
	val via = z_greater(zlo, zhi) %Longrightarrow% a;
	val sr_via = cons_srs vr_for_via via;
	val wp = add_domain_conds env ([zlo, zhi], sr_pre_intro @ sr_via);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm1 env till )%Longrightarrow% a)
			) | Nil => [];
	val sr_till_part = cons_srs vr_for_exit_to_side till_part;
	val go_round = [zran, z_noteq(zid env zi, zfinal0), post1] ô 
			sub(pre1, zi, z_bin_exp(zleft, zop, zright));
	val sr_go_round = [init_sr vr_for_pre_to_side go_round];
	val dont_go = sub(post1, zi, zfinal0) %Longrightarrow% a;
	val sr_dont_go = cons_srs vr_for_to_side dont_go;
	val side = add_domain_conds env ([zfinal0],
			sr_go_round @ sr_dont_go @ sr_till_part);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Logical Constant}\label{wp-log-con}
{\it analyse\_log\_con} picks apart the precondition to set up the actual
list of {\it log\_con\_def}s required for the weakest precondition calculation.
It is essentially the implementation of the predicate of the schema {\it Log\_Con}
in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

=SML
fun Ûanalyse_log_conÝ (defs : LOG_CON_DEF list) (pre : Z_PRED) : (LOG_CON_DEF list * Z_PRED) = (
let	fun moan () = term_fail "analyse_log_con" 505024 [pre];
	fun get_def eq_x eq_e acc ((def as {x, t, e=_})::more) = (
		if	x = eq_x
		then	(acc@more, {x = x, t = t, e = eq_e})
		else	get_def eq_x eq_e (def::acc) more
	) | get_def _ _ _ [] = moan();
	fun check xv {x=_, t=_, e=e} = (
		if	xv term_mem frees e
		then	term_fail "analyse_log_con" 505025 [xv, e]
		else	()
	);
	fun do_defs acc p [] = (rev acc, p)
	|   do_defs acc p defs = (
		let	val (eqtm, p') = (dest_z_± p) handle Fail _ => (p, mk_z_true);
			val (eq_xv, eq_e) = (dest_z_eq eqtm) handle Fail _ => moan();
			val (defs', new_def) = get_def (fst(dest_var eq_xv)) eq_e [] defs;
			val acc' = (new_def::acc);
			val _ = map (check eq_xv) acc';
		in	do_defs acc' p' defs'
		end
	);
in
	do_defs [] pre defs
end);
=TEX
=SML
fun Ûz_log_con_defÝ ((u, v): Z_ID list * Z_ID list) ({x, t=_, e} : LOG_CON_DEF) : Z_PRED = (
	let	val env' = fn id =>	if id = x
					then Value (type_of e, EIEnvVar ("__none", Nil))
					else Nil;
	in	z_eq(zid env' x, subs_exp(e, u, v))
	end
);
=TEX
=SML
fun Ûlog_conÝ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	({defs, spec as {w, w0, pre, post}, ...} : LOG_CON)
		: RESULT = (

let	val (defs, pre1) = analyse_log_con defs (z_predexp_of_z_tm1 env pre);
	val hyps = map (z_log_con_def ([], [])) defs;
	fun aux acc ((hyp, {x, t, e})::more) = (
		(init_sr vr_log_con_type_mem_intro 
		(acc ô z_mem(e, z_predexp_of_z_tm1 env t))) :: aux (hyp::acc) more
	) | aux _ [] = [];
	val wp = [init_sr vr_log_con_pre_intro (hyps ô pre1)] @ aux [] (combine hyps defs);
	val side = add_hyps (map (z_log_con_def(w, w0)) defs,
			cons_srs vr_log_con_to_side 
			  (z_predexp_of_z_tm1 env post %Longrightarrow% a));
in
	{wp = wp, side = side}
end);
=TEX
\subsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
=SML
fun Ûproc_call_ivarsÝ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
	(pc as {name, actuals} : (AGG_CHOICE, EXP) PROC_CALL)
					: RESULT = (
let	val fp as {spec = {w, ...}, ...} = get_proc_spec "proc_call_ivars" env formal_procs name;
	val (spec, asgns, dc_preds, vc_preds) = proc_call_spec env pc fp;
	val xform = STSemicolon(
			SSpecIvars{spec = spec,
				label = ""}, asgns);
	val a_in = cons_srs vr_proc_call_end a;
	val {wp = wp1, side = side1} = wp (xform, a_in, wp_env);
	val side2 = map (fn p => init_sr vr_proc_call_rng_intro ([] ô p)) vc_preds;
         val sr_wp1 = cons_srs vr_proc_call wp1;
         val sr_side = cons_srs vr_proc_call (side1@side2)
in	{wp = add_hyps(dc_preds, sr_wp1), side = add_hyps(dc_preds, sr_side)}
end
);
=TEX
\subsection{Adjusting Statements}
=SMLPLAIN
fun Ûany_initial_variables_z_predÝ (pred : Z_PRED) : bool = (
let	val names = map (fst o dest_var) (frees pred);
	fun is_init_var s =
		case (rev o explode) s of
			"0" :: "‰" :: _ =>	true
		|	_ => 			false;
	
in
	any names (fn s => is_init_var s)
end
);
=TEX
In the following, the renaming substitution is not relevant to the test being made.
=SMLPLAIN
fun Ûany_initial_variables_z_tmÝ (z_tm : Z_TM) : bool = (
	any_initial_variables_z_pred (z_predexp_of_z_tm (Combinators.I) z_tm)
);
=TEX
=SML
fun Ûis_static_for_loopÝ (wp as {env, ...}: WP_ENV) (fs : STATEMENT FOR_STATIC) : bool = (
let	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	fun no_vars_in_exp exp = (
		case (term_vars o adjust_and_trans) exp of
			[] =>	true
		|	_ =>	false
	);
	val {lo, hi} = dest_range(#range fs);
in	no_vars_in_exp lo andalso no_vars_in_exp hi
end
);
=TEX
In the following, most of the work is done in $adj\_stmt\_aux$.
Note that, $adj\_stmt\_aux$ always returns a statement which is just $SStmt\,s$ unless $is\_first$ is true.
$adj\_stmt\_aux$ calls itself recursively (via $check\_inner$) just to check the form of constituents of the various compound statement forms.

Initial variables may not appear in the pre-conditions of specifications
statements (see schema {\it Spec} in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}).
The check for this on a specification statement that refines some other
specification statement is made here.
The check on pre-conditions on specification statements being refined is made
in the function {\it vcs}.
The Z Generator (\cite{ISS/HAT/DAZ/IMP507}) makes dummy calls
to {\it vcs} as necessary to ensure that the check is then made on all specification
statements in the script. 

In the following, an assertion will have a pre-condition and a default, vacuous post-condition.
=SML
fun Ûadj_stmt_auxÝ (wp as {env, ...} : WP_ENV)
			(is_first : bool)
				(s : STATEMENT)
					: STATEMENT = (
let	val check_inner = adj_stmt_aux wp false;
	val adj_first = adj_stmt_aux wp is_first;
in
	case s of
		STSpecNoIvars {spec, label, is_assertion}  =>
			if	any_initial_variables_z_tm (#pre spec)
			then	fail "adjust_statement" 505095 []
			else if	any_initial_variables_z_tm (#post spec)
			then	if	is_first
				then	SSpecIvars {spec = spec, label = label}
				else	fail "adjust_statement" 505091 []
			else	s
	|	SLogCon lc =>
			if	any_initial_variables_z_tm (#pre (#spec lc))
			then	fail "adjust_statement" 505095 []
			else if	not is_first
			then	fail "adjust_statement" 505094 []
			else	s
	|	STForStatic (fs as {name,i,range,loop as {stmt, ...}, dir, tmark}) => (
			check_inner stmt;
			if	is_static_for_loop wp fs
			then	s
			else	if	is_first
				then	SForNonStatic {	name=name,
							i=i,
							range=range,
							loop=loop,
							dir = dir,
							tmark = tmark
						}
				else	fail "adjust_statement" 505092 []
	) |	STProcNoIvars piv =>
		let	fun find_formal_proc id fps= (
				Value(get_proc_spec "adj_stmt_aux" env fps id)
				handle Fail _ => Nil
			);
		in
			case find_formal_proc (#name piv) (#formal_procs wp) of
			Value fp => (
				if	any_initial_variables_z_pred
					(hd(z_preds_in_callee_cxt env fp [#post(#spec fp)]))
				then	if	is_first
					then	SProcIvars piv
					else	fail "adjust_statement" 505093 []
				else	s
			) |	Nil => s
		end
	|	STSemicolon (st1, st2) =>
			STSemicolon (adj_first st1, check_inner st2)
	|	STIfThenElse {g, p, q, elsif} => (
			STIfThenElse {
				g = g,
				p = adj_first p,
				q = adj_first q,
				elsif = elsif}
	) |	STCase {s, others, e = e} => (
			STCase{
				s = map
				(fn {choices, p} => {choices = choices, p = adj_first p}) s,
				others = adj_first others,
				e = e}
	) |	STLoop {stmt, ...} => (
			check_inner stmt;
			s
	) |	STNamedLoop {stmt, ...} => (
			check_inner stmt;
			s
	) |	STWhile {loop as {stmt, ...}, ...} => (	
			check_inner stmt;
			s
	) |	STForTmark {loop as {stmt, ...}, ...} => (
			check_inner stmt;
			s
	) |	_ => s
end
);
fun Ûadjust_statementÝ (wp : WP_ENV) (st : STATEMENT) : STATEMENT = (
			adj_stmt_aux wp true st
);
=TEX
=IGN
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));
=TEX
\subsection{$wp$}\label{wp}
The following does most of the expression adjustment for the expressions in
the top level structure of the statement.
However, there are one or two exceptions, notably, the ranges that appear for-loops
are adjusted by the support functions and the expressions in case choices.
=SML
fun ÛwpÝ ((st, a, wp_env) : STATEMENT * SEQUENT list * WP_ENV) : RESULT = (
let	val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	val adjust = adjust_exp env;
in	case adjust_statement wp_env st of
		STNull _ => null pars
	|	STAssign {name, e} =>
			assign pars (adjust name, adjust_and_trans e)
	|	STSpecNoIvars {spec={pre, post, w, ...}, ...} => 
			spec_no_ivars_either pars w
				(z_predexp_of_z_tm1 env pre, z_predexp_of_z_tm1 env post)
	|	STSemicolon x => semicolon pars x
	|	STIfThenElse {g, p, q, elsif} =>
			if_then_else pars {g=adjust g, p=p, q=q, elsif=elsif}
	|	STCase {e, s, others} =>
			case_others pars {e=adjust e, s=s, others=others}
	|	STLoop x => loop pars x
	|	STNamedLoop x => named_loop pars x
	|	STWhile {g, loop, name} =>
			cn_while pars {g=adjust g, loop=loop, name=name}
	|	STForStatic x => for_static pars x
	|	STForTmark x => for_tmark pars x
	|	STExitWhen {g, n} => exit_when pars {g=adjust g, n = n}
	|	STExit x => cn_exit pars x
	|	STRet {e = Value exp} => cn_return pars {e=Value (adjust exp)}
	|	STRet x => cn_return pars x
	|	STProcNoIvars x => proc_call_no_ivars pars x
	|	STKSlot x => fail "wp" 505040 []
	|	STPragma _ => null pars
	|	STAnnotation _ => null pars
	|	SSpecIvars {spec={pre, post, ...}, ...} =>
			spec_ivars pars (z_predexp_of_z_tm1 env pre, z_predexp_of_z_tm1 env  post)
	|	SForNonStatic x => for_non_static pars x
	|	SLogCon x => log_con pars x
	|	SProcIvars x => proc_call_ivars pars x
	|	SBlockStatement _ => fail "wp" 505096 []
end
);
=TEX
\pagebreak
\section{APPLICATION OF CHECKS}


\subsection{Useful Printing Functions in Lieu of CNSparkOutput}
=SML
fun Ûfmt_idÝ (n : ID) : string = CaseIndependence.get_external_name n;
fun Ûfmt_id_listÝ ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
=TEX
\subsection{The Error Printing Function}
=SML
fun Ûchecking_errorÝ (msg : string) (n : int) (ins) = (
	diag_line (get_error_message 505050 []);
	fail msg n ins
);
=TEX
\subsection{The Checks}
=SML
fun Ûcheck_1_aÝ (id : Z_ID list, speclab : SPECLAB) = (
	let	val w = (#w o #spec) speclab;
	in
		if id diff w = []
		then ()
		else if w = []
		then	checking_error "check_1_a" 505060
			[	fn () => fmt_id_list id]
		else	checking_error "check_1_a" 505064
			[	fn () => fmt_id_list w,
				fn () => fmt_id_list id]
	end
);
=TEX
=SML
fun Ûcheck_1_bÝ (speclab : SPECLAB) = (
	if #formal_body_flag speclab
	then ()
	else checking_error "check_1_b" 505061 []
);
=TEX
=SML
fun Ûcheck_1_cÝ (speclab : SPECLAB) = (
	if #till_flag speclab
	then ()
	else checking_error "check_1_c" 505062 []
);
=TEX
=SML
fun Ûcheck_1_dÝ (p : ID, speclab as {wp_env = {env, ...}, in_scope ={formal_procs, ...}, ...}: SPECLAB) = (
	(get_proc_spec "check_1_d" env formal_procs p; ())
	handle Fail _ => checking_error "check_1_d" 505063 [fn () => p]
);
=TEX
The following check, we also check 
=SML
fun Ûcheck_19Ý (env : CN_ENV) (globs_opt : Z_ID list OPT) ({w, ...} : SPEC) : unit = (
let	fun aux number (v::more) = (
		case env v of
			Value (_, EIEnvVar _) => aux number more
		|	Value (_, EIEnvAuxVar _) =>  aux number more
		|	Value (_, EIEnvRetry v') => aux number (v'::more)
		|	Value _ => fail "check_19" (number+1) [fn()=> v]
		|	Nil => fail "check_19" number [fn()=> v]
	) | aux _ [] = ();
in	aux 505082 w;
	(case globs_opt of
		Value globs => aux 505084 globs
	|	_ => ());
	()
end
);
=TEX
\subsection{Anti-Aliasing Checks}

=SML
fun op ÛcapÝ (a, b) = (a cup b) diff (a diff b) diff (b diff a);
=TEX
=SML
fun Ûentire_var_expÝ (cn_env : CN_ENV) (e : EXP) : ID = (
	let	fun aux (EId id) = id
		|   aux (ESelectedComp {prefix, selector}) = aux prefix
		|   aux (EIndexedComp{prefix, index}) = aux prefix
		|   aux _ = fail "entire_var_exp" 505080 [];
	in	aux (adjust_exp cn_env e)
	end
);
=TEX
=SML
fun Ûname_to_entire_variable_nameÝ (cn_env : CN_ENV) (e : EXP) : Z_ID = (
	let	val zx = trans_id (entire_var_exp cn_env e);
		val orig = case cn_env zx of
			Value(_, EIEnvVar(_, Value orig)) => orig
		|	Value(_, EIEnvRetry ex) => ex
		|	_ => zx;
	in	orig
	end	handle exn => reraise exn "name_to_entire_variable_name"

);
=TEX
=SML
fun Ûfree_var_namesÝ (fv::rest : TERM list) : ID list = (
		if is_z_lvar fv
		then
			((fn (n,_, _) => n) o dest_z_lvar) fv::free_var_names rest
		else
			free_var_names rest
) | free_var_names _ = [];
=TEX
The following is slightly different from the specification.
We exploit the fact that {\it other\_vars\_exp} is only used
in anti-aliasing check 3 and there it is only applied to an expression
that must be formed from a variable by some combination of
indexed component and selected component constructs.
We can therefore happily let {\it other\_vars\_exp} fail on
expressions that are not of this form.
Note that as in \cite{ISS/HAT/DAZ/IMP508}, the index or indices in
an indexed component expression are always wrapped up as if they
were a positional array aggregate.
=SML
fun other_vars_exp (cn_env : CN_ENV) (e : EXP) : ID list = (
	let	fun get_index_exps acc (EId id) = acc
		|   get_index_exps acc (ESelectedComp {prefix, selector}) =
			get_index_exps acc prefix
		|   get_index_exps acc (EIndexedComp{prefix,
			index as EArrayAggPos{comps, ...}}) =
			get_index_exps (comps@acc) prefix
		|   get_index_exps acc _ = fail "other_vars_exp" 505080 [];
		val tm = mk_z_tuple(map (trans_exp cn_env)
				(get_index_exps [] (adjust_exp cn_env e)));
	in	(free_var_names o frees) tm
	end
);
=TEX
The above trickery with {\it other\_vars\_exp} means that we have to code
{\it vars\_exp} directly rather than the way the
specification describes it, but that's easier and faster in any case.
=SML
fun Ûvars_expÝ (cn_env : CN_ENV) (exp : EXP) : ID list = (
	(free_var_names o frees o trans_exp cn_env o adjust_exp cn_env) exp
);
=TEX	
In the following, we rely on the fact that {\it zid} does not
change the name of the variable (any changes to the name, e.g., replacing
`.'s by `o's are done by {\it trans\_id}).
Thus we can get away with treating the {\it Z\_ID}s in the global
dependency list as {\it ID}s.
=SML
fun Ûanti_aliasing_parsÝ (fp : FORMAL_PROC) (pc : (AGG_CHOICE,EXP)PROC_CALL)
				: ID list * ID list = (
	let	val formal_ids = #formal_ids fp;
		val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
		val formals = flat (map (fn {vars, ...} => vars) var_decls);
		val trans_formals = map trans_id formals;
	in
		(formals, #globals fp)
	end
);
=TEX
The following function makes a pair-wise list of actual parameters (EXPs) with their modes (which are extracted from the corresponding $formal\_proc$).
The actuals are in the order given in the procedure specification.
The actual parameter expressions are not adjusted.
=SML
fun Ûanti_aliasing_actuals_modesÝ (env : CN_ENV) (formal_proc as {par_names_defs, ...}: FORMAL_PROC)
				(proc : (AGG_CHOICE, EXP) PROC_CALL) :
			(EXP * MODE) list = (
	let	val name = #name proc;
		val formal_ids = #formal_ids formal_proc;
		val var_decls_modes = map (fn {var_decl, mode,...}
					=> (var_decl,mode)) formal_ids;
		val vars_modes = map
				(fn ({vars, ...},mode) => (vars,mode))
				 var_decls_modes;
		fun do_formals_modes (id::rest, m) = (
			(id, m)::do_formals_modes (rest, m)
		) | do_formals_modes _ = [];
		val (formals,modes) = (split o flat o map do_formals_modes)
						vars_modes;
		val actuals = (case #actuals proc of
				APositional exps => positional_assocs_to_exps par_names_defs exps
			|	ANamed nas => named_assocs_to_exps par_names_defs nas)
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
		val actuals_modes = combine actuals modes
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
	in	combine actuals modes
	end
);
=TEX
=SML

=TEX
=SML
fun Ûanti_aliasing_check_1Ý  (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val cn_env = (#env o #wp_env) speclab;
		val (formals, trans_globals) = anti_aliasing_pars formal_proc proc;
		val set = map fst (actuals_modes drop
				(fn am => not (	snd am = MSparkInOut orelse
							snd am = MSparkOut)));
		val trans_set = map (fn
				e => entire_var_exp cn_env e
				handle Fail _ =>
				fail "anti_aliasing_check_1" 505070
				[fn()=>name]) set;
		val inter_set = trans_set cap (trans_globals diff formals);
		fun plural () = if length inter_set > 1 then "s" else "";
	in
		if inter_set = []
		then (* OK *) ()
		else	checking_error "anti_aliasing_check_1" 505071
				[	plural,
					fn()=> fmt_id_list inter_set,
					fn()=> fmt_id name]
	end
);
=TEX
=SML
fun Ûanti_aliasing_check_2Ý (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val (formals, _) = anti_aliasing_pars formal_proc proc;
		val w = (#w o #spec) formal_proc;
		val actuals = map fst actuals_modes;
		val ids = list_cup (map (vars_exp ((#env o #wp_env) speclab))
					actuals);
		val trans_ids = map trans_id ids;
		val inter_set = (w diff formals) cap trans_ids;
		val plural = if length inter_set > 1 then "s" else "";
	in	if inter_set = []
		then (* OK *) ()
		else checking_error "anti_aliasing_check_2" 505072
				[	fn()=> plural,
					fn()=> fmt_id_list inter_set,
					fn()=> fmt_id name]
	end
);
=TEX
=SML
fun Ûanti_aliasing_check_3Ý (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val cn_env = (#env o #wp_env) speclab;
		val var_sets = map (vars_exp cn_env o fst) actuals_modes;
		val acts_modes_vars = combine actuals_modes var_sets;
		fun do_check bef (((act, MSparkIn _), vars)::aft) = (
			do_check (vars::bef) aft
		) | do_check bef (((act, _), vars)::aft) = (
				let	val ent_var = entire_var_exp cn_env act;
				val other_vars = other_vars_exp cn_env act;
			in	if	not (ent_var mem other_vars)
				andalso	not (any bef (fn vs => ent_var mem vs))
				andalso	not (any aft (fn (_, vs) => ent_var mem vs))
				then	do_check (vars::bef) aft
				else	checking_error "anti_aliasing_check_3"
					505073 [	fn()=> fmt_id ent_var,
						fn()=> fmt_id name]
			end
		) | do_check _ [] = ();
	in	 do_check [] acts_modes_vars
	end
);
=TEX
The following function computes the effective frame of a procedure call --- the frame that is obtained by substituting the entire variables of the actual parameters
for the formals in the original frame.  
=SML
fun Ûproc_frameÝ (env : CN_ENV)
			({formal_ids, spec={w, ...}, ...} : FORMAL_PROC )
			(actuals_modes : (EXP * MODE) list)
				: Z_ID list = (
	let	val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
		val formals = flat (map (fn {vars, ...} => vars) var_decls);
		val table = combine formals (map fst actuals_modes);
		fun aux (v :: vs) = (
			(case lassoc5 table v of
				Nil => v
			|	Value e =>
				name_to_entire_variable_name env e)
			:: aux vs
		) | aux [] = [];
	in	aux w
	end
);
=TEX
=SML
fun Ûanti_aliasing_checkÝ (speclab as {wp_env as {formal_procs, env, ...}, ...}: SPECLAB,
				proc as {name, ...}: (AGG_CHOICE,EXP)PROC_CALL) = (
	let	val formal_proc = get_proc_spec "anti_aliasing_check" env formal_procs name;
		val actuals_modes =
			anti_aliasing_actuals_modes env formal_proc proc
			handle Fail _ =>
			fail "anti_aliasing_check" 505068 [fn()=> #name proc];
	in
		anti_aliasing_check_1 speclab formal_proc proc actuals_modes;
		anti_aliasing_check_2 speclab formal_proc proc actuals_modes;
		anti_aliasing_check_3 speclab formal_proc proc actuals_modes;
		check_1_a(proc_frame env formal_proc actuals_modes, speclab)
	end
);
=TEX
\subsection{Invoking the Checks}
=SML
fun Ûdo_soundness_checksÝ (
	(speclab as {wp_env as {env, ...}, ...},
		statement): SPECLAB * STATEMENT) : unit = (

let	fun pass_over_statement (st : STATEMENT) = (

	case st of
			STNull _ => (
		)|	STAssign {name,e} => (
				check_1_a
				([name_to_entire_variable_name env name],
					speclab)
		)|	STSpecNoIvars {spec as {w,w0,pre,post},label, is_assertion} => (
				check_1_a (w, speclab);
				check_19 env Nil spec
		)|	STSemicolon (s1,s2) => (
					(pass_over_statement s1;
					pass_over_statement s2)
		)|	STIfThenElse  {g,p,q,elsif} => (
					(pass_over_statement p;
					pass_over_statement q)
		)|	STCase {e,s,others} => (
				map (fn st1 => pass_over_statement (#p st1)) s;
				pass_over_statement others
		)|	STLoop {t,stmt} => (
				pass_over_statement stmt
		)|	STNamedLoop {name,t,stmt} => (
				pass_over_statement stmt
		)|	STWhile {name,g,loop} => (
				pass_over_statement (#stmt loop)
		)|	STForStatic {name,i,tmark,range,dir,loop} => (
				pass_over_statement (#stmt loop)
		)|	STForTmark {name,i,tmark,dir,loop} => (
				pass_over_statement (#stmt loop)
		)|	STExitWhen {n = Nil, ...} => (
				check_1_c speclab
		)|	STExitWhen _ => (
		)|	STExit {n = Nil} => (
				check_1_c speclab
		)|	STExit _ => (
		)|	STRet _ => (
				check_1_b speclab
		)|	STProcNoIvars (proc as {name,actuals}) => (
				check_1_d (name, speclab);
				anti_aliasing_check (speclab, proc)
		)|	STKSlot {content,label} => (
		)|	STPragma _ => (
		)|	STAnnotation _ => (
		)|	SSpecIvars _ => (
		)|	SLogCon {spec as {w, ...}, ...} => (
				check_1_a (w, speclab);
				check_19 env Nil spec
		)|	SForNonStatic {loop, ...} => (
				pass_over_statement (#stmt loop)
		)|	SProcIvars (proc as {name,actuals}) => (
				check_1_d (name, speclab);
				anti_aliasing_check (speclab, proc)
		) |	SBlockStatement _ => fail "do_soundness_checks" 505096 []
	);
	in	pass_over_statement statement
	end
);
=TEX
\subsection{Variable Capture Checks}

The following function is called from $add\_var\_env$ in \cite{ISS/HAT/DAZ/IMP507}.

=SML
fun Ûcheck_new_spark_idsÝ (cn_env : CN_ENV) (ids : ID list) = (
	let	fun aux recur (id::rest) = (
			case cn_env id of
				Value (_, EIEnvRetry id2) => 
					if	recur
					then	aux false (id2::ids)
					else	fail "check_new_spark_ids" 505074 [fn()=>id]
			|	Value _ => fail "check_new_spark_ids" 505074 [fn()=>id]
			|	Nil => aux true rest
		) | aux _ [] = ();
	in
		if all_different ids
		then
			aux true ids
		else
			fail "check_new_spark_ids" 505075 []
	end
);
=TEX
=SML
fun Ûcheck_new_z_idÝ (z_ids : Z_ID list) (z_id : Z_ID) : unit = (
	if z_id mem z_ids
	then
		fail "check_new_z_id" 505074 [fn()=>z_id]
	else	case (get_const_type o fst o dest_const o mk_z_gvar)
			(z_id, BOOL, []) of
				Value _ =>
					fail "check_new_z_id" 505074 [fn()=>z_id]
			|	Nil => ()
);
=TEX
\section{VERIFICATION CONDITIONS}
$cart\_prod$ and $fun\_decl$ are specified in
\cite[volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.
=SML
fun Ûfun_sigÝ (zpars : Z_EXP list, zret : Z_EXP) : Z_EXP= (
	case zpars of
		[] => zret
	|	[zpar] => z_tfun(zpar, zret)
	|	_ => z_tfun(z_many_cross zpars, zret)
);
=TEX
=SML
fun Ûpar_tmarkÝ (env : CN_ENV)
	({var_decl = {vars, tmark, ...}, ...} : PARAM_SPEC) : Z_ID list = (
	let	val zi = trans_id tmark;
	in	map (Combinators.K zi) vars
	end
);
=TEX
=SML
fun Ûvar_sigÝ (env : CN_ENV) (zn : Z_ID) : Z_EXP = (
	case env zn of
		Value (_, EIEnvVar (tmark, _)) => zid env(trans_id tmark)
	|	Value (_, EIEnvAuxVar (ztm, _)) => ztm
	|	Value (_, EIEnvRetry zn') => var_sig env zn'
	|	Value _ => zid env zn
	|	_ => fail "var_sig" 505041 [fn()=>zn]
);
=TEX
=SML
fun Ûfun_decl_auxÝ
	((env, {name, formal_pars, return_type, par_names_defs}, globals)
	: CN_ENV * INFORMAL_FUN * Z_EXP list) : Z_DECL * TERM * TERM = (
	let	val zn = trans_id name;
		val z_ret_ty = zid env (trans_id return_type);
		fun dec_of v = (
			if	is_var v
			then	var_sig env (fst(dest_var v))
			else	v
		);
		val gdecs = map dec_of globals;
		val tmarks = flat (map (par_tmark env) formal_pars);
		val pdecs = map (zid env) tmarks;
		val zexp = fun_sig(gdecs, fun_sig(pdecs, z_ret_ty));
		val t_zexp = (dest_z_power_type o type_of) zexp;
		val lvar = mk_z_lvar(zn, t_zexp, []);
		val gvar = mk_z_gvar(zn, t_zexp, []);
	in	(mk_z_dec([lvar], zexp), lvar, gvar)
	end
);
=TEX
We can defined $fun\_decl$ in terms of $fun\_decl\_aux$ by throwing away the second and third parts of the result value and currying the function.
=SML
fun Ûfun_declÝ
	(env : CN_ENV)	({informal_fun, globals, ...} : FORMAL_FUN) : Z_DECL = (
	let	val (d, _, _) = fun_decl_aux(env, informal_fun, map (zid env) globals);
	in	d
	end
);
=TEX
=SML
fun Ûvc_local_declsÝ (seqs : SEQUENT list,
	{formal_body_flag, fun_flag,
		in_scope as {vc_vars, vc_pars, vc_log_cons, vc_aux_vars, ...},
		wp_env = {fun_header, env, ...}, ...} : SPECLAB)
		: VC list = (
let
(*
=TEX
Every variable in $vc\_vars$ and its corresponding initial variable is introduced.
=SML
*)
	fun do_vars var = (
	let	val t_v = trans_id var;
	in
		[t_v, init_var t_v]
	end);
	fun var_decl_decls {vars, tmark} =
		trans_decl env {vars = (flat o (map do_vars)) vars, tmark=tmark};
(*
=TEX
The following function implements the special case for input parameters specified in \cite[Volume 2, section 5.1.5]{DRA/CIS/CSE3/TR/94/27/3.0}.
=SML
*)
	fun param_spec_decls {var_decl, mode} = (
		case mode of
		MSparkIn _ => trans_decl env var_decl
		|	_ => var_decl_decls var_decl
	);
(*
=TEX
=SML
*)
	val decls = map var_decl_decls vc_vars @ map param_spec_decls vc_pars;

(*
=TEX
Add the logical constants (no initial versions).
=SML
*)
	val decls = vc_log_cons @ decls;
(*
=TEX
Add the auxiliary variables (with initial versions).
=SML
*)
	val vc_aux_vars_0 = (
			  map mk_z_dec
			o map (fn (ds, t) =>
					(map (	  mk_z_lvar
						o (fn (n,t,a) => (init_var n,t,a))
						o dest_z_lvar
					    ) ds, t))
			o map dest_z_dec)
		vc_aux_vars;
	val decls = vc_aux_vars @ vc_aux_vars_0 @ decls;
(*
=TEX
\raggedright{If $formal\_body\_flag$ and $fun\_flag$ are $true$, add a declaration of the function (obtained from $fun\_header$).}
=SML
*)
	fun opt_dest_Ê t = fst (dest_z_Ê t) handle Fail _ => t;
	val (decls, subs_fn) =
		if	formal_body_flag andalso fun_flag
			then	let 	val (d, l, g) = fun_decl_aux
		(env,fun_header, map opt_dest_Ê (fun_globals env (#name fun_header)));
				in	(d :: decls, subst [(l, g)])
				end
			else	(decls, Combinators.I);

	val seqs1 = map (fn (h, c) => (map subs_fn h, subs_fn c)) seqs;
(*
=TEX

Remove any declarations which are not needed by the sequent.
=SML
*)
	fun drop_vars vns vardecl = (
	let	val (vars, ty) = dest_z_dec vardecl;
		val vartys = map dest_var vars;
		val dvartys = vartys drop (fn (v,ty) => not (v mem vns));
	in
		case dvartys of
			[] =>	[]
		|	_ =>	[mk_z_dec (map mk_var dvartys, ty)]
	end);
	fun frees_in_seq (seq as (h, c)) = (
		map (fst o dest_var) (flat(frees c :: map frees h))
	);
	fun add_decls decs seq = (
	let	val ddecs = map ((drop_vars o frees_in_seq) seq) decs;
	in
		(flat ddecs, seq)
	end
	);

	val vcs1  = map (add_decls decls) seqs1;
(*
=TEX
Add declarations for any new Z variables introduced in processing
procedure calls with record or array components as exported parameter
and remove the corresponding hypotheses from the sequent.
=SML
*)
	fun add_tmp_decls (decs, seq as (h, c)) = (
	let	fun strip_tmp_decs acc [] = acc
		|   strip_tmp_decs (acc as (new_ds, h)) (hyp::hyps) = (
			let	val (v, tm) = dest_z_ hyp;
				val (n, _, _) = dest_z_lvar v;
			in	if	maybe_param_tmp_name n
				andalso	not (any decs (is_free_in v))
				then	strip_tmp_decs 
						(mk_z_dec([v], tm)::new_ds, h) hyps
				else	term_fail "" 0 []
			end	handle Fail _ => strip_tmp_decs (new_ds, hyp::h) hyps
		);
		val (new_ds, new_h) = (rev ** rev)(strip_tmp_decs ([], []) h);
	in	(decs @ new_ds, (new_h, c))
	end);
	val vcs2 = map add_tmp_decls vcs1;
in	vcs2
end
);
=TEX
Initial variables may not appear in the pre-conditions of specifications
statements (see schema {\it Spec} in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}).

=SML
fun ÛvcsÝ ((sl, st): SPECLAB * STATEMENT)

			: (VC * ROUTE OPT) list * SPEC = (

let	val {spec as {w, w0, pre, post},
			wp_env as {env, ...}, ...} = sl;

	val side_effect = do_soundness_checks (sl, st);

	val pre1 = z_predexp_of_z_tm1 env pre;
	val post1 = z_predexp_of_z_tm1 env post;
	val {wp, side} = wp (st, [init_sr vr_refinement_intro ([] ô post1)], wp_env);
	fun subs_c (h, c) = (
		h ô subs_pred(c, w0, w)
	);
	val wp1 = map subs_c (cons_srs vr_refinement_begin wp);
	val sr_side = cons_srs vr_refinement_begin side;
	val s = (pre1 %Longrightarrow% wp1) @
		(subs_pred(pre1, w, w0) %Longrightarrow% sr_side);
         val (no_sr_s, routes) = extract_routes s 
in
	if	any_initial_variables_z_pred pre1
	then	fail "vcs" 505095 []
	else	(combine (vc_local_decls(no_sr_s, sl)) routes,
		 {	w = w,
			w0 = w0,
			pre = z_quote (pre1, Nil),
			post = z_quote (post1, Nil)})
end
);
=TEX
=TEX
\section{EPILOGUE}
=SML
end (* structure CNVCGenerator *);
=TEX
%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed505.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

=IGN

CNZGenerator.diag_vc_args;
CNVCGenerator.vcs (hd(!CNZGenerator.diag_vc_args));
use_file"wrk001";
val (sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st)= hd(! CNZGenerator.diag_vc_args);

