% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% pp -i zed505 -d zplay
% pp_list -d zplay vc_gen >zed505.th.doc
% doctex zed505 zed505.th
% texdvi zed505
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Verification Condition Generator}  %% Mandatory field
\def\TPPheadtitle{Verification Condition Generator}
\TPPref{ISS/HAT/DAZ/IMP505}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Informal}
\TPPtype{Specification}
%\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\R.D.~Arthan & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This is the implementation of the verification condition generator for the compliance tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.9] Initial Drafts.
\item[Issue 1.10]

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance tool verification condition generator. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Possible Enhancements}
None.

\pagebreak

\section{THE STRUCTURE $CNVCGenerator$}

=SML
infix 3 ô;
infix 4 %Longrightarrow%;
=TEX
=SML
structure ÛCNVCGeneratorÝ : CNVCGenerator = struct
local
	open CaseIndependence;
	open CNTypes2 CNParser CNTypes CNBasicDeclsAndExprs;
	open ZUserInterfaceSupport;
in
=TEX
\section{SUPPORTING FUNCTIONS}
When a construct is found for which is not supported formally, we choose to continue processing informally rather that halt the processing of the literate script. The local exception $VCInformal$ is raised if this condition is detected. This is caught by $vcs$ which returns an dummy VC is the exception has been raised. 
=SML
exception ÛVCInformalÝ;

fun Ûvc_go_informalÝ
		(s : string)
		(i : int)
		(fns : (unit -> string) list) : 'a = (
	comment s i fns;
	raise VCInformal
);
=TEX
$trans\_exp2$ catches the case where an attempt to translate an expression has failed due to a language feature being unsupported.
=SML
fun Ûtrans_exp2Ý (env : CN_ENV) (exp : EXP) : Z_EXP = (
	case trans_exp1 env exp of
		Value ze	=> ze
	|	Nil		=> raise VCInformal
);
=TEX
=SML
fun Ûadjust_exp2Ý (env : CN_ENV) (exp : EXP) : EXP = (
	case adjust_exp1 env exp of
		Value e		=> e
	|	Nil		=> raise VCInformal
);
=TEX
=SML
val Ûvc_dummy_seqÝ = ([],
	ñDummyVC "VC Generator encountered an unsupported language feature"®);
=TEX
\pagebreak
\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}
\subsection{Sequents}
=SML
fun (h : Z_PRED list) ô (c : Z_PRED) : SEQUENT = (h, c);

fun (h : Z_PRED) %Longrightarrow% (s : SEQUENT list) : SEQUENT list = (
	map (fn (h', c) => (h :: h', c)) s
);
=TEX
\pagebreak
\section{Substitutions}
=SML
fun ÛsubÝ ((p, x, e) :Z_PRED * Z_ID * Z_EXP) : Z_PRED = (
	let	val p' = subst[(e, mk_var(x, type_of e))] p;
	in	(snd o dest_eq o concl o TRY_C (TOP_MAP_C z_schema_pred_conv1)) p'
	end
);
=TEX
=SML
fun Ûlist_subÝ ((p, xes) :Z_PRED * ((Z_ID * Z_EXP) list)) : Z_PRED = (
	let	fun mk_subs (x : Z_ID, e : Z_EXP) = (e, mk_var(x, type_of e));
		val p' = subst (map mk_subs xes) p;
	in	(snd o dest_eq o concl o TRY_C (TOP_MAP_C z_schema_pred_conv1)) p'
	end
);
=TEX
=SML
fun Ûsubs_expÝ ((e, xs, ys) :Z_EXP * (Z_ID list) * (Z_ID list)) : Z_EXP = (
	let	val xys = combine xs ys;
		val ntys = map dest_var(frees e);
		fun s ((n, ty) :: more) (x, y) = (
			if	n = x
			then	(x, mk_var(y, ty)) :: s more (x, y)
			else	s more (x, y)
		) | s [] _ = [];
	in	list_sub(e, flat(map (s ntys) xys))
	end		
);
=TEX
=SML
fun Ûsubs_predÝ ((p, xs, ys) :Z_PRED * (Z_ID list) * (Z_ID list)) : Z_PRED = (
	subs_exp(p, xs, ys)
);
fun ÛsubseqÝ ((seql, x, e) :SEQUENT list * Z_ID * Z_EXP) : SEQUENT list = (
	map (fn (H, c) => map (fn p => sub(p, x, e)) H ô sub(c, x, e)) seql
);
=TEX
\pagebreak

\section{ABSTRACT SYNTAX OF SPARK STATEMENTS}\label{ASSPARK}

See \cite{ISS/HAT/DAZ/DTD502}.

\section{WEAKEST PRECONDITIONS}\label{WPS}
\subsection{Environments}\label{environments}
=TEX
\subsection{Other Preliminaries}\label{Preliminaries}
=TEX

\subsection{Null Statement}\label{wp-null}
=SML
fun ÛnullÝ ({a, ...} : WP_PARS) : RESULT = (
	{wp = a, side = []}
);
=TEX
\subsection{Assignment Statement}\label{wp-assignment}

The implementation of $simple\_assign$ works on an assignment where the expression on the rhs has already been converted to Z.
=SML
fun Ûsimple_assignÝ ({wp_env={env,...}, a, ...} : WP_PARS)
		(x : ID) (ze : Z_EXP) : RESULT = (
	{wp = subseq(a, trans_id x, ze), side = []}
)
=TEX
=SML
and Ûarray_assignÝ ({wp, a, wp_env as {env,...}} : WP_PARS)
			({prefix, index} : EXP INDEXED_COMP) (ze : Z_EXP) : RESULT = (
let	val name' = prefix;
	val e' = (z_override
			(trans_exp2 env prefix, z_set
			   [z_maplet (trans_exp2 env index, ze)]));
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', e')
end
)
=TEX
=SML
and Ûretrieve_type_markÝ (env : CN_ENV) (exp : EXP) : TMARK = (
let	val tmark = name_to_tmark exp;
in
	case env tmark of
	Value (_, EIEnvVar tmark') => tmark'
	|_ => fail "retrieve_type_mark" 505028 [fn()=>tmark] 
end
)
=TEX
=SML
and Ûrecord_assignÝ	({wp, a, wp_env as {env, ...}} : WP_PARS)
	({prefix, selector} : EXP SELECTED_COMP) (ze : Z_EXP) : RESULT = (
let	val name' = prefix;
	val tmark = retrieve_type_mark env prefix;
	val record_components = retrieve_record_components env tmark
		handle _ => fail "record_assign" 505027 [fn()=>tmark];
	fun do_comps sel = if sel = selector 
				then ze
				else trans_exp2 env 
					(ESelectedComp{prefix=prefix,selector=sel});
	val comps = map (fn (a,_) => do_comps a) record_components;
	val ze' = exp_rec_agg_pos_z env (tmark, comps);
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', ze')
end
)
=TEX
=SML
and ÛassignÝ (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ((name, ze) : EXP * Z_EXP)
			: RESULT = (
	case adjust_exp2 env name of
	EId id => simple_assign wp_pars id ze
	|EIndexedComp ic => array_assign wp_pars ic ze
	|ESelectedComp sc => record_assign wp_pars sc ze
	|_ => fail "assign" 505029 []
);
=TEX
\subsection{Specification Statement (No initial variables)}\label{wp-specification-no-ivars}
=SML
fun Ûspec_no_ivarsÝ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = [[] ô pre], side = post %Longrightarrow% a}
);
=TEX
=SML
fun Ûspec_no_ivars_emptyÝ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = ([] ô pre) :: (post %Longrightarrow% a), side = []}
);
=TEX
=SML
fun Ûspec_no_ivars_eitherÝ (wp : WP_PARS) (w : Z_ID list) ((pre, post) : Z_EXP * Z_EXP) 
		: RESULT = (
	if	w = []
	then	spec_no_ivars_empty wp (pre, post)
	else	spec_no_ivars wp (pre, post)
);
=TEX
\subsection{Semicolon}\label{wp-semicolon}
=SML
fun ÛsemicolonÝ ({wp, a, wp_env} : WP_PARS) ((p, q) : STMT * STMT)
			: RESULT = (
let	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val {wp = wp1, side = side1} = wp (SStmt p, wp2, wp_env);
in
	{wp = wp1, side = side1 @ side2}
end
);
=TEX
=IGN
val SStmt(STSemicolon (p,q)) = exp;
val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
val save_exp1 = exp;
val exp= SStmt q;
=TEX
\subsection{If Statement}\label{wp-if-then-else}
=SML
fun Ûif_then_elseÝ	({wp, a, wp_env as {env,...}} : WP_PARS)
			({g, p, q,...} : STMT IF_THEN_ELSE) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val wp = (z_eq(trans_exp2 env g, zid env "TRUE") %Longrightarrow% wp1) @
		(z_eq(trans_exp2 env g, zid env "FALSE") %Longrightarrow% wp2);
	val side = side1 @ side2;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Case Statement}\label{wp-case}
=SML
fun Ûtrans_case_choicesÝ (env : CN_ENV) (choices : CASE_CHOICE list) : Z_EXP = (
let	val adjust_and_trans = (trans_exp2 env) o (adjust_exp2 env);
	fun aux_range (ch::rest) = (
		case ch of
		CCCaseRange (DRRange(RRange{lo,hi})) =>
			z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
		|CCCaseRange (DRRange _) =>
			vc_go_informal "trans_case_choices" 508020 [] 
		|CCCaseRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
		|CCCaseRange (DRConstrained _) =>
			vc_go_informal "trans_case_choices" 508020 []
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		CCCaseExp exp =>
			trans_exp2 env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choices;
	val zsingles = z_set (aux_singles choices);
in
	z_many_union(zranges @ [zsingles])
end
);
=TEX
=SML
fun Ûcase_baseÝ ({wp, a, wp_env as {env,...}} : WP_PARS) (e : EXP)
			({choices, p} : STMT CASE_ALTERNATIVE)
			 : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val wp' = z_elem (trans_exp2 env e, trans_case_choices env choices)
			%Longrightarrow% wp1;
in	{wp = wp', side = side1}
end
);
=TEX
=SML
fun Ûcase_stepÝ (pars as {wp, a, wp_env as {env,...}} : WP_PARS)
		({e, s, others as STImplicitNull} : STMT CASE) : RESULT = (
	case s of
	[] =>
		fail "case_step" 505030 []
	| [alt] =>
		case_base pars e alt
	| ({choices, p} :: s') => (
		let	val {wp = wp1, side = side1} =
				wp (SStmt p, a, wp_env);
			val {wp = wp2, side = side2} =
				case_step pars {e=e, s=s', others=others};
			val elm =
				z_elem (trans_exp2 env e, trans_case_choices env choices)
		in	{wp = (elm %Longrightarrow% wp1) @ wp2 , side = side1 @ side2}
		end)
) | case_step _ _ = (
	vc_go_informal "case_step" 505021 []
);
=TEX
Note that $case\_step$ is recursive and does the full job. 
But by analogy with the naming convention we chose to adopt for the
two case of specification statement in section \ref{wp-specification-no-ivars},
we define the following.
=SML
val Ûcase_eitherÝ : WP_PARS -> STMT CASE -> RESULT = case_step;
=TEX

\subsection{Undecorated Loop}\label{wp-loop}
=SML
fun ÛloopÝ ({a, ...} : WP_PARS) ({t, stmt} : STMT LOOP)
			: RESULT = (
let	val (pre1, post1) = case stmt of
		STSpecNoIvars {pre, post, ...} => (
			(z_predexp_of_z_tm pre,z_predexp_of_z_tm post)
		) |_ => vc_go_informal "loop" 505022 [];
	val wp = [[] ô pre1];
	val side = case t of
			Value till => [[post1] ô pre1] @
				((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => [[post1] ô pre1];
in
	{wp = wp, side = side}
end
);
=TEX
=SML
fun Ûnamed_loopÝ (wp_pars : WP_PARS) ({t, stmt, ...} : STMT NAMED_LOOP)
			: RESULT = (
	loop wp_pars {t=t, stmt=stmt}
);
=TEX
\subsection{While Loop}\label{wp-while-loop}
=SML
fun Ûcn_whileÝ	({a, wp_env={env, ...}, ...} : WP_PARS)
		({g, loop={t,stmt}, ...} : STMT WHILE) : RESULT = (
let	val {w, w0, pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => vc_go_informal "loop" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val wp = ([z_eq(trans_exp2 env g, zid env "TRUE")] ô pre1) ::
			(z_eq(trans_exp2 env g, zid env "FALSE")
				%Longrightarrow% a);
	val side = case t of
			Value till => (post1 %Longrightarrow% wp) @
					((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => (post1 %Longrightarrow% wp);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-static}
=SML
fun Ûfor_staticÝ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, range, dir, loop = {t, stmt}, ...} : STMT FOR_STATIC) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else vc_go_informal "for_static" 505023 [];
	val {lo, hi} = case range of
			RRange {lo, hi} => {lo=adjust_exp2 env lo, hi=adjust_exp2 env hi}
			|RRangeAttr _ =>
				vc_go_informal "for_static" 505020 [];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => vc_go_informal "for_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp2 env lo;
	val zhi = trans_exp2 env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till) %Longrightarrow% a)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zhi), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}
=SML
fun Ûfor_tmarkÝ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, dir, loop = {t, stmt}, ...} : STMT FOR_TMARK) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else vc_go_informal "for_tmark" 505023 [];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => vc_go_informal "for_tmark" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = zid env (trans_id tmark ^^ zfst);
	val zhi = zid env (trans_id tmark ^^ zlst);
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				(z_predexp_of_z_tm till) %Longrightarrow% a
			) | Nil => [];
	val side = [[z_noteq(zid env zi, zhi), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=SML
fun Ûexit_whenÝ ({a, wp_env={till, env, ...}, ...} : WP_PARS)
		({g} : EXIT_WHEN)
			 : RESULT = (
let	val zg = trans_exp2 env g;
	val wp = ([z_eq(zg, zid env "TRUE")] ô till) ::
		(z_eq(zg, zid env "FALSE") %Longrightarrow% a);
in	{wp = wp, side = []}
end
);
=TEX
\subsection{Exit}\label{wp-exit}
=SML
fun Ûcn_exitÝ ({wp_env={till, ...},...} : WP_PARS) : RESULT = (
	{wp = [[] ô till], side = []}
);
=TEX
\subsection{Return}\label{wp-return}
=TEX
$conv\_var\_decl$ is implemented in \cite{ISS/HAT/DAZ/IMP508}.
=SML
fun Ûcn_returnÝ ({wp, a, wp_env= {env, fun_header={name, formal_pars, ...},
			return, ...}} : WP_PARS)
		({e} : RETURN) : RESULT = (
let	val zfun = zid env (trans_id name);
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_pars;
	val ids = flat (map (fn {vars, ...} => vars) var_decls);
	val zargs = map (fn id => zid env (trans_id id)) ids;
	val wp = [[z_eq(z_fun_call(zfun, zargs), trans_exp2 env e)] ô return];
	val side = [];
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}
=SML
fun Ûproc_call_specÝ (env : CN_ENV)
		({actuals, ...} : (AGG_CHOICE,EXP) PROC_CALL)
		({name, formal_ids, spec as {w, w0, pre, post, label}, ...} : FORMAL_PROC)
			: (Z_EXP * Z_EXP) = (
let	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
	val names = ((map trans_id) o flat
				o (map (fn {vars, ...} => vars))) var_decls;
	val exps = case actuals of
			APositional exps => map (adjust_exp2 env) exps
			|ANamed nas => map (adjust_exp2 env)
					(named_assocs_to_exps names nas);
	fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) = (name, trans_exp2 env actual);
	val exp_names = combine exps names
		handle _ => fail "proc_call_spec" 505026 [fn()=>name];
	val subs_list = map subs exp_names;
in
	(list_sub(pre1, subs_list),list_sub(post1, subs_list))
end
);
=TEX
=IGN

val {formal_ids, spec as {w, w0, pre, post, label}, ...}=fp;
val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
val names = flat (map (fn {vars, ...} => vars) var_decls);
val exps = case actuals of
			APositional exps => map (adjust_exp2 env) exps
			|ANamed nas => map (adjust_exp2 env) (named_assocs_to_exps names nas);
fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) = (name, trans_exp2 env actual);
val exp_names = combine exps names
		handle _ => fail "proc_call_spec" 505026 [fn()=>name];
val subs_list = map subs exp_names;

=TEX
In the following, we call $spec\_no\_ivars\_either$ directly rather than call $wp$ because the pre- and post-conditions have already been converted to $Z\_PRED$s. 
=SML
fun Ûproc_call_no_ivarsÝ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
		(pc as {name, actuals} : (AGG_CHOICE,EXP) PROC_CALL)
	
		: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp as {spec = {w, ...}, ...} = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_no_ivars" 505031 [fn()=>name];
in
	spec_no_ivars_either {wp = wp, a = a, wp_env = wp_env}
		w (proc_call_spec env pc fp)
end
);
=TEX
=IGN
val {formal_procs, env, ...} = wp_env;
val SStmt (STProcNoIvars (pc as {name, actuals})) = exp;
fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);


=TEX
\subsection{Specification Statement (with Initial Variables)}\label{wp-spec-ivars}
=SML
fun Ûspec_ivarsÝ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(((pre, post), q) : (Z_EXP * Z_EXP) * STMT) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] ô pre];
	val side = (post %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}
=SML
fun Ûfor_non_staticÝ (pars as {wp, a, wp_env as {env, ...}} : WP_PARS)
			(({i, range, loop = {t, stmt}, ...}, q) : FOR_NON_STATIC * STMT)
			 : RESULT = (
let	val {lo, hi} = case range of
			RRange {lo, hi} => {lo=adjust_exp2 env lo, hi=adjust_exp2 env hi}
			|RRangeAttr _ =>
				vc_go_informal "for_non_static" 505020 []
	val {pre, post, w, w0, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => vc_go_informal "for_non_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp2 env lo;
	val zhi = trans_exp2 env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zlo0 = subs_exp (zlo, w, w0);
	val zhi0 = subs_exp(zhi, w, w0);
	val zran = z_elem(zid env zi, z_rng (zlo0, zhi0));
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zlo)] @
		(z_greater(zlo, zhi) %Longrightarrow% wp1);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till )%Longrightarrow% wp1)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zhi0), post1] ô 
			sub(pre1, zi, z_bin_exp(zleft, zop, zright))] @
				(sub(post1, zi, zhi0) %Longrightarrow% wp1) @
				till_part;
in
	{wp = wp, side = side}
end
);
=TEX

\subsection{Logical Constant}\label{wp-log-con}
=SML
fun Ûanalyse_log_conÝ (pre : Z_PRED) : (Z_EXP * Z_PRED) = (
let	val (eqtm, pre1) = dest_z_± pre handle Fail _ => (pre, mk_z_true);
	val (_, e) = dest_z_eq eqtm;
in
	(e, pre1)
end
handle _ => fail "analyse_log_con" 505024 []
);
=TEX
=SML
fun Ûlog_conÝ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(({x, t, spec as {w, w0, pre, post,...}, ...}, q) : LOG_CON * STMT)
		: RESULT = (

let	val (e, pre1) = analyse_log_con (z_predexp_of_z_tm pre);
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] ô sub(pre1, x, e)];
	val zvar_ty = (dest_z_power_type o type_of o z_predexp_of_z_tm) t;
	val env' = fn id =>	if id = x
				then Value (zvar_ty, EIEnvVar "__none")
				else env id;
	val side = z_eq(zid env' x, subs_exp (e,w,w0)) %Longrightarrow%
		((z_predexp_of_z_tm post) %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
=SML
fun Ûproc_call_ivarsÝ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
	((pc as {name, actuals}, q) : (AGG_CHOICE, EXP) PROC_CALL * STMT)
					: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_ivars" 505031 [fn()=>name];
in
	spec_ivars {wp = wp, a = a, wp_env = wp_env}
			(proc_call_spec env pc fp, q)
end
);
=TEX
\subsection{Adjusting Statements}

=SMLPLAIN
fun Ûany_initial_variablesÝ (z_tm : Z_TM) : bool = (
let	val pred = z_predexp_of_z_tm z_tm;
	val names = map (fst o dest_var) (frees pred);
	fun is_init_var s =
		case (rev o explode) s of
			"0" :: "‰" :: _ =>	true
		|	_ => 			false;
	
in
	any names (fn s => is_init_var s)
end
);
=TEX
=SML
fun Ûis_static_for_loopÝ (wp : WP_ENV) (fs : STMT FOR_STATIC) : bool = (
let	fun no_vars_in_exp exp = (
		case (term_vars o (trans_exp2 (#env wp))) exp of
			[] =>	true
		|	_ =>	false
	);
in
	case (#range fs) of
	RRange {lo, hi} =>
		no_vars_in_exp lo andalso no_vars_in_exp hi
	|RRangeAttr _ => true
end
);
=TEX
=SML
fun Ûadjust_statementÝ (wp : WP_ENV) (st as SStmt s : STATEMENT)
		: STATEMENT = (

	case s of
		STSpecNoIvars sni =>
			if	any_initial_variables (#post sni)
			then	SSpecIvars (sni, STImplicitNull)
			else	st
	|	STForStatic (fs as {name,i,range,loop, ...}) =>
			if	is_static_for_loop wp fs
			then	st
			else	SForNonStatic ({	name=name,
							i=i,
							range=range,
							loop=loop
						}, STImplicitNull)
	|	STProcNoIvars piv => (
		let	fun find_spec id ((fproc::rest) : FORMAL_PROC list) = (
				if (#name fproc) = id
				then	#spec fproc
				else	find_spec id rest
			) | find_spec id _ = vc_go_informal
					"adjust_statement" 505025 [fn()=>id];
		in
			if	any_initial_variables (#post (find_spec
								(#name piv)
								(#formal_procs wp)))
			then	SProcIvars (piv, STImplicitNull)
			else	st
		end
	) |	STSemicolon (st1, st2) => (
			case adjust_statement wp (SStmt st1) of
				SStmt st1' => SStmt s
			|	SSpecIvars (si, _) => SSpecIvars (si, st2)
			|	SForNonStatic (fns, _) => SForNonStatic (fns, st2)
			|	SProcIvars (piv, _) => SProcIvars (piv, st2)
			|	SLogCon lc => SLogCon lc
			)
	|	_ => st

) | adjust_statement _ other = other;
=TEX
=IGN
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));
=TEX
\subsection{$wp$}\label{wp}

=SML
fun ÛwpÝ ((st, a, wp_env) : STATEMENT * SEQUENT list * WP_ENV) : RESULT = (
let	val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
	val adjust_and_trans = (trans_exp2 env) o (adjust_exp2 env);
	val adjust = adjust_exp2 env;
in	case adjust_statement wp_env st of
		SStmt STNull => null pars
	|	SStmt STImplicitNull => null pars
	|	SStmt (STAssign {name, e}) =>
			assign pars (name, adjust_and_trans e)
	|	SStmt (STSpecNoIvars {pre, post, w, ...}) => 
			spec_no_ivars_either pars w
				(z_predexp_of_z_tm pre, z_predexp_of_z_tm post)
	|	SStmt (STSemicolon x) => semicolon pars x
	|	SStmt (STIfThenElse {g, p, q, elsif}) =>
			if_then_else pars {g=adjust g, p=p, q=q, elsif=elsif}
	|	SStmt (STCase {e, s, others}) =>
			case_either pars {e=adjust e, s=s, others=others}
	|	SStmt (STLoop x) => loop pars x
	|	SStmt (STNamedLoop x) => named_loop pars x
	|	SStmt (STWhile {g, loop, name}) =>
			cn_while pars {g=adjust g, loop=loop, name=name}
	|	SStmt (STForStatic x) => for_static pars x
	|	SStmt (STForTmark x) => for_tmark pars x
	|	SStmt (STExitWhen {g}) => exit_when pars {g=adjust g}
	|	SStmt (STExit) => cn_exit pars
	|	SStmt (STRet {e}) => cn_return pars {e=adjust e}
	|	SStmt (STProcNoIvars x) => proc_call_no_ivars pars x
	|	SStmt (STKSlot x) => {wp=[],side=[]}
	|	SSpecIvars ({pre, post, ...}, q) =>
			spec_ivars pars ((z_predexp_of_z_tm pre, z_predexp_of_z_tm  post), q)
	|	SForNonStatic x => for_non_static pars x
	|	SLogCon x => log_con pars x
	|	SProcIvars x => proc_call_ivars pars x
end
);
=TEX
\pagebreak
\section{VERIFICATION CONDITIONS}
$cart\_prod$ and $fun\_decl$ are specified in
\cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.0}.
=SML
fun Ûcart_prodÝ (env : CN_ENV) (par_specs : PARAM_SPEC list) : Z_EXP = (
	let	fun aux (par_spec : PARAM_SPEC) = (
			(zid env o trans_id o #tmark o #var_decl)
			par_spec
		);
	in	case par_specs of
			[]	=>	error "cart_prod" 505009 []
		|	[ps]	=>	aux ps
		|	several =>	mk_z_¸ (map aux par_specs)
	end
);
=TEX
=SML
fun Ûfun_declÝ
	(env : CN_ENV)
	({name, formal_pars, return_type} : INFORMAL_FUN) : Z_DECL = (
	let	val zn = trans_id name;
		val z_ret_ty = zid env (trans_id return_type);
		val zexp = (
			case formal_pars of
				[] => z_ret_ty
			|	non_empty => z_tfun(cart_prod env formal_pars,
						 z_ret_ty));
		val zvar = mk_z_lvar(zn, (dest_z_power_type o type_of) zexp, []);
	in	mk_z_dec([zvar], zexp)
	end
);
=TEX
=SML
fun Ûvc_local_declsÝ (seqs : SEQUENT list,
	{formal_body_flag, fun_flag,
		in_scope as {vc_vars, vc_pars, vc_log_cons, ...},
		wp_env = {fun_header, env, ...}, ...} : SPECLAB)
		: VC list = (
let
=TEX
Every variable in $vc\_vars$ and its corresponding initial variable is introduced.
=SML
	fun do_vars var = (
		[trans_id var, trans_id var ^ "‰0"]
	);
	fun var_decl_decls {vars, tmark} =
		trans_decl env {vars = (flat o (map do_vars)) vars, tmark=tmark};
=TEX
The following function implements the check for input parameters specified in \cite[section 5.5]{DRA/CIS/CSE3/TR/94/27/1.0}.
=SML
	fun param_spec_decls {var_decl, mode} = (
		case mode of
		MSparkIn => trans_decl env var_decl
		|	_ => var_decl_decls var_decl
	);
=TEX
=SML
	val decls = map var_decl_decls vc_vars @ map param_spec_decls vc_pars;

=TEX
Add the logical constants (no initial versions).
=SML
	val decls = vc_log_cons @ decls;
=TEX
\raggedright{If $formal\_body\_flag$ and $fun\_flag$ are $true$, add a declaration of the function (obtained from $fun\_header$).}
=SML
	val decls =	if	formal_body_flag andalso fun_flag
			then	(fun_decl env fun_header) :: decls
			else	decls;
=TEX

Remove any declarations which are not needed by the sequent.
=SML
	fun drop_vars vns vardecl = (
	let	val (vars, ty) = dest_z_dec vardecl;
		val vartys = map dest_var vars;
		val dvartys = vartys drop (fn (v,ty) => not (v mem vns));
	in
		case dvartys of
			[] =>	[]
		|	_ =>	[mk_z_dec (map mk_var dvartys, ty)]
	end);
	fun frees_in_seq (seq as (h, c)) = (
		map (fst o dest_var) (flat(frees c :: map frees h))
	);
	fun add_decls decs seq = (
	let	val ddecs = map ((drop_vars o frees_in_seq) seq) decs;
	in
		(flat ddecs, seq)
	end
	);
	val res = map (add_decls decls) seqs;
in
	res
end
);
=TEX
=SML
fun ÛvcsÝ ((sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st): SPECLAB * STATEMENT)
			: VC list = (
let	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val {wp, side} = wp (st, [[] ô post1], wp_env);
	fun subs_c (h, c) = (
		h ô subs_pred(c, w0, w)
	);
	val wp1 = map subs_c wp;
	val s = (pre1 %Longrightarrow% wp1) @
		(subs_pred(pre1, w, w0) %Longrightarrow% side);
in
	vc_local_decls(s, sl)
end
	handle VCInformal =>
		[([], vc_dummy_seq)]
);
=TEX
=IGN
val (sl as 	{	spec as {w, w0, pre, post, ...},
			wp_env,
			in_scope,...},
		st)= hd(! CNZGenerator.diag_vc_args);

val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val a = [[] ô post1];
wp (st, a, wp_env);
(* assignments in wp *)
val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
val adjust_and_trans = (trans_exp2 env) o (adjust_exp2 env);
val adjust = adjust_exp2 env;
val exp = adjust_statement wp_env st;
(* now goto the appropriate function *)
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));

=TEX
\section{EPILOGUE}
=SML
end (* local ... in *);
end (* structure CNVCGenerator *);
=TEX
%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed505.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

=IGN

CNZGenerator.diag_vc_args;
CNVCGenerator.vcs (hd(!CNZGenerator.diag_vc_args));
use_file"wrk001";
val (sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st)= hd(! CNZGenerator.diag_vc_args);

