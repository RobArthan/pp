=TEX
% pp -i zed505 -d zplay
% pp_list -d zplay vc_gen >zed505.th.doc
% doctex zed505 zed505.th
% texdvi zed505
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Verification Condition Generator}  %% Mandatory field
\def\TPPheadtitle{VC Generation}
\TPPref{ISS/HAT/DAZ/IMP505}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\R.D.~Arthan & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{%
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion] First issue for distribution.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
\subsection{Introduction}
=TEX
\pagebreak
=SML
infix 3 Ù;
infix 4 %Longrightarrow%;
=TEX
=SML
structure €CNVCGenerator› : CNVCGenerator = struct
local
	open CaseIndependence;
	open CNTypes2 CNParser CNTypes CNBasicDeclsAndExprs;
in
=TEX
\pagebreak
\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}
\subsection{Sequents}
=SML
fun (H : Z_PRED list) Ù (c : Z_PRED) : SEQUENT = (H, c);

fun (h : Z_PRED) %Longrightarrow% (S : SEQUENT list) : SEQUENT list = (
	map (fn (H, c) => (h :: H, c)) S
);
=TEX
\pagebreak
\section{Substitutions}
=SML
fun €sub› ((p, x, e) :Z_PRED * Z_ID * Z_EXP) : Z_PRED = (
	let	val p' = subst[(e, mk_var(x, type_of e))] p;
	in	(snd o dest_eq o concl o TRY_C (TOP_MAP_C z_schema_pred_conv1)) p'
	end
);
=TEX
=SML
fun €list_sub› ((p, xes) :Z_PRED * ((Z_ID * Z_EXP) list)) : Z_PRED = (
	let	fun mk_subs (x : Z_ID, e : Z_EXP) = (e, mk_var(x, type_of e));
		val p' = subst (map mk_subs xes) p;
	in	(snd o dest_eq o concl o TRY_C (TOP_MAP_C z_schema_pred_conv1)) p'
	end
);
=TEX
=SML
fun €subs_exp› ((e, xs, ys) :Z_EXP * (Z_ID list) * (Z_ID list)) : Z_EXP = (
	let	val xys = combine xs ys;
		val ntys = map dest_var(frees e);
		fun s ((n, ty) :: more) (x, y) = (
			if	n = x
			then	(x, mk_var(y, ty)) :: s more (x, y)
			else	s more (x, y)
		) | s [] _ = [];
	in	list_sub(e, flat(map (s ntys) xys))
	end		
);
=TEX
=SML
fun €subs_pred› ((p, xs, ys) :Z_PRED * (Z_ID list) * (Z_ID list)) : Z_PRED = (
	subs_exp(p, xs, ys)
);
fun €subseq› ((seql, x, e) :SEQUENT list * Z_ID * Z_EXP) : SEQUENT list = (
	map (fn (H, c) => map (fn p => sub(p, x, e)) H Ù sub(c, x, e)) seql
);
=TEX
\pagebreak

\section{ABSTRACT SYNTAX OF SPARK STATEMENTS}\label{ASSPARK}

See \cite{ISS/HAT/DAZ/DTD502}.

\section{WEAKEST PRECONDITIONS}\label{WPS}
\subsection{Environments}\label{environments}
=TEX
\subsection{Other Preliminaries}\label{Preliminaries}
=TEX

\subsection{Null Statement}\label{wp-null}
=SML
fun €null› ({a, ...} : WP_PARS) : RESULT = (
	{wp = a, side = []}
);
=TEX
\subsection{Assignment Statement}\label{wp-assignment}
=SML
fun €simple_assign› ({wp_env={env,...}, a, ...} : WP_PARS)
		(x : ID) (e : EXP) : RESULT = (
	{wp = subseq(a, trans_id x, trans_exp env e), side = []}
);
=TEX
=SML
fun €array_assign›	({wp, a, wp_env as {env,...}} : WP_PARS)
			({prefix, index} : EXP INDEXED_COMP) (e : EXP) : RESULT = (
let	val name' = prefix;
	val e' = EAuxiliaryExp (z_override
			(trans_exp env prefix, z_set
			   [z_maplet (trans_exp env index, trans_exp env e)]));
in
	wp (SStmt (STAssign{name=name',e=e'}), a, wp_env)
end
);
=TEX
=SML
fun €retrieve_type_mark› (env : CN_ENV) (exp : EXP) : TMARK = (
let	val tmark = name_to_tmark exp;
in
	case env tmark of
	Value (_, EIEnvVar tmark') => tmark'
	|_ => fail "retrieve_type_mark" 505001 [fn()=>tmark^" is not a variable"] 
end
);
=TEX
=SML
fun €record_assign›	({wp, a, wp_env as {env, ...}} : WP_PARS)
			({prefix, selector} : EXP SELECTED_COMP) (e : EXP) : RESULT = (
let	val name' = prefix;
	val tmark = retrieve_type_mark env prefix;
	val record_components = retrieve_record_components env tmark
		handle _ => fail "record_assign" 505001 [];
	fun do_comps sel = case lassoc5 record_components sel of 
			Value _ => (e
			)|Nil => ESelectedComp{prefix=prefix,selector=sel};
	fun do_comps sel = if sel = selector 
				then e
				else ESelectedComp{prefix=prefix,selector=sel};
	val comps = map (fn (a,_) => do_comps a) record_components;
	val e' = ERecAggPos {tmark=tmark,comps=comps};
in
	wp (SStmt (STAssign{name=name',e=e'}), a, wp_env)
end
);
=TEX
=SML
fun €assign› (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ({name, e} : ASSIGN)
			: RESULT = (
let	val e' = adjust_exp env e;
in
	case adjust_exp env name of
	EId id => simple_assign wp_pars id e'
	|EIndexedComp ic => array_assign wp_pars ic e'
	|ESelectedComp sc => record_assign wp_pars sc e'
	|_ => fail "assign" 505001 [fn()=>"weird lhs of an assignment"]
end
);
=TEX
\subsection{Specification Statement (No initial variables)}\label{wp-specification-no-ivars}
=SML
fun €spec_no_ivars› ({a, ...} : WP_PARS) ({pre, post,...} : SPEC_NO_IVARS)
			: RESULT = (
	{wp = [[] Ù pre], side = post %Longrightarrow% a}
);
=TEX
=SML
fun €spec_no_ivars_empty› ({a, ...} : WP_PARS) ({pre, post,...} : SPEC_NO_IVARS)
			: RESULT = (
	{wp = ([] Ù pre) :: (post %Longrightarrow% a), side = []}
);
=TEX
=SML
fun €spec_no_ivars_either› (wp : WP_PARS) (sp as {w, ...} : SPEC_NO_IVARS) 
		: RESULT = (
	if	w = []
	then	spec_no_ivars_empty wp sp
	else	spec_no_ivars wp sp
);
=TEX
\subsection{Semicolon}\label{wp-semicolon}
=SML
fun €semicolon› ({wp, a, wp_env} : WP_PARS) ((p, q) : STMT * STMT)
			: RESULT = (
let	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val {wp = wp1, side = side1} = wp (SStmt p, wp2, wp_env);
in
	{wp = wp1, side = side1 @ side2}
end
);
=TEX
\subsection{If Statement}\label{wp-if-then-else}
=SML
fun €if_then_else›	({wp, a, wp_env as {env,...}} : WP_PARS)
			({g, p, q,...} : STMT IF_THEN_ELSE) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val wp = (z_eq(trans_exp env g, zid env "TRUE") %Longrightarrow% wp1) @
		(z_eq(trans_exp env g, zid env "FALSE") %Longrightarrow% wp2);
	val side = side1 @ side2;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Case Statement}\label{wp-case}
=SML
fun €trans_case_choices› (env : CN_ENV) (choices : CASE_CHOICE list) : Z_EXP = (
let	fun aux_range (ch::rest) = (
		case ch of
		CCCaseRange (DRRange(RRange{lo,hi})) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|CCCaseRange (DRRange _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|CCCaseRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(trans_exp env lo, trans_exp env hi)::aux_range rest
		|CCCaseRange (DRConstrained _) =>
			fail "trans_named_assoc" 508001
				[fn()=>"range attributes not supported"] 
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		CCCaseExp exp =>
			trans_exp env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choices;
	val zsingles = z_set (aux_singles choices);
in
	z_many_union(zranges @ [zsingles])
end
);
=TEX
=SML
fun €case_base› ({wp, a, wp_env as {env,...}} : WP_PARS) (e : EXP)
			({choices, p} : STMT CASE_ALTERNATIVE)
			 : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val wp' = z_elem (trans_exp env e, trans_case_choices env choices)
			%Longrightarrow% wp1;
in	{wp = wp', side = side1}
end
);
=TEX
=SML
fun €case_step› (pars as {wp, a, wp_env as {env,...}} : WP_PARS)
		({e, s, others=STImplicitNull} : STMT CASE) : RESULT = (
	case s of
	[] =>
		fail "case_step" 505001 [fn()=>"detected in VC generation"]
	| [alt] =>
		case_base pars e alt
	| ({choices, p} :: s') => (
		let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
			val {wp = wp2, side = side2} = case_step pars {e=e, s=s', others=others};
			val elm = z_elem (trans_exp env e, trans_case_choices env choices)
		in	{wp = (elm %Longrightarrow% wp1) @ wp2 , side = side1 @ side2}
		end)
) | case_step _ _ = (
	fail "case_step" 505001 [fn()=>"cannot proceed formally: OTHERS part present in Case statement not supported"];
=TEX
Note that $case\_step$ is recursive and does the full job. 
But by analogy with the naming convention we chose to adopt for the
two case of specification statement in section \ref{wp-specification-no-ivars},
we define the following.
=SML
val €case_either› : WP_PARS -> STMT CASE -> RESULT = case_step;
=TEX

\subsection{Undecorated Loop}\label{wp-loop}
=SML
fun €loop› ({a, ...} : WP_PARS) ({t, stmt} : STMT LOOP)
			: RESULT = (
let	val {pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => fail "loop" 505001 [fn()=>
			"cannot proceed formally: LOOP body must be a specification statement"];
	val wp = [[] Ù pre];
	val side = case t of
			Value till => [[post] Ù pre] @ (till %Longrightarrow% a)
			|Nil => [[post] Ù pre];
in
	{wp = wp, side = side}
end
);
=TEX
=SML
fun €named_loop› (wp_pars : WP_PARS) ({t, stmt, ...} : STMT NAMED_LOOP)
			: RESULT = (
	loop wp_pars {t=t, stmt=stmt}
);
=TEX
\subsection{While Loop}\label{wp-while-loop}
=SML
fun €cn_while›	({a, wp_env={env, ...}, ...} : WP_PARS)
		({g, loop={t,stmt}, ...} : STMT WHILE) : RESULT = (
let	val {w, w0, pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => fail "loop" 505001 [fn()=>
			"cannot proceed formally: LOOP body must be a specification statement"];
	val wp = ([z_eq(trans_exp env g, zid env "TRUE")] Ù pre) ::
			(z_eq(trans_exp env g, zid env "FALSE")
				%Longrightarrow% a);
	val side = case t of
			Value till => (post %Longrightarrow% wp) @
					(till %Longrightarrow% a)
			|Nil => (post %Longrightarrow% wp);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-static}
=SML
fun €for_static› ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, range, dir, loop = {t, stmt}, ...} : STMT FOR_STATIC) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else fail "for_static" 505001 [fn()=>"cannot proeed formally: REVERSE not supported"];
	val {lo, hi} = case range of
			RRange r => r
			|RRangeAttr _ =>
				fail "for_static" 505001 [fn()=>"range attributes not supported"];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => fail "for_static" 505001 [fn()=>
			"Cannot proceed formally when loop body size > 1"];
	val zi = trans_id i;
	val zlo = trans_exp env lo;
	val zhi = trans_exp env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] Ù sub(pre, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% (till %Longrightarrow% a)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zhi), post] Ù 
			sub(pre, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}
=SML
fun €for_tmark› ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, dir, loop = {t, stmt}, ...} : STMT FOR_TMARK) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else fail "for_static" 505001 [fn()=>"reverse not supported"];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => fail "for_static" 505001 [fn()=>
			"Cannot proceed formally when loop body size > 1"];
	val zi = trans_id i;
	val zlo = zid env (trans_id tmark ^^ zfst);
	val zhi = zid env (trans_id tmark ^^ zlst);
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] Ù sub(pre, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				till %Longrightarrow% a
			) | Nil => [];
	val side = [[z_noteq(zid env zi, zhi), post] Ù 
			sub(pre, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=SML
fun €exit_when› ({a, wp_env={till, env, ...}, ...} : WP_PARS)
		({g} : EXIT_WHEN)
			 : RESULT = (
let	val zg = trans_exp env g;
	val wp = ([z_eq(zg, zid env "TRUE")] Ù till) ::
		(z_eq(zg, zid env "FALSE") %Longrightarrow% a);
in	{wp = wp, side = []}
end
);
=TEX
\subsection{Exit}\label{wp-exit}
=SML
fun €cn_exit› ({wp_env={till, ...},...} : WP_PARS) : RESULT = (
	{wp = [[] Ù till], side = []}
);
=TEX
\subsection{Return}\label{wp-return}
=TEX
$conv\_var\_decl$ is implemented in \cite{ISS/HAT/DAZ/IMP508}.
=SML
fun €cn_return› ({wp, a, wp_env= {env, fun_header={name, formal_pars, ...},
			return, ...}} : WP_PARS)
		({e} : RETURN) : RESULT = (
let	val zfun = zid env (trans_id name);
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_pars;
	val ids = flat (map (fn {vars, ...} => vars) var_decls);
	val zargs = map (fn id => zid env (trans_id id)) ids;
	val wp = [[z_eq(z_fun_call(zfun, zargs), trans_exp env e)] Ù return];
	val side = [];
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}
=SML
fun €proc_call_spec› (env : CN_ENV)
		({actuals, ...} : (AGG_CHOICE,EXP) PROC_CALL)
		({formal_ids, spec as {w, w0, pre, post, label}, ...} : FORMAL_PROC)
			: SPEC = (
let	val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
	val names = flat (map (fn {vars, ...} => vars) var_decls);
	val exps = case actuals of
			APositional exps => exps
			|ANamed nas => named_assocs_to_exps names nas;
	fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) = (name, trans_exp env actual);
	val subs_list = map subs (combine exps names)
		handle Fail _ =>
		fail "proc_call_spec" 505001 [fn()=>"parameter list mismatch"];
in	{w = w, w0 = w0,
	pre = list_sub(pre, subs_list),
	post = list_sub(post, subs_list),
	label=label}
end
);
=TEX
=SML
fun €proc_call_no_ivars› ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
		(pc as {name, actuals} : (AGG_CHOICE,EXP) PROC_CALL)
	
		: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_no_ivars" 505001 [fn()=>"formal procedure not found"];
in
	wp (SStmt(STSpecNoIvars(proc_call_spec env pc fp)), a, wp_env)
end
);
=TEX
\subsection{Specification Statement (with Initial Variables)}\label{wp-spec-ivars}
=SML
fun €spec_ivars› ({wp, a, wp_env as {env, ...}} : WP_PARS) (({pre, post, ...},q) : SPEC_IVARS * STMT)
			 : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] Ù pre];
	val side = (post %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}
=SML
fun €for_non_static› (pars as {wp, a, wp_env as {env, ...}} : WP_PARS)
			(({i, range, loop = {t, stmt}, ...}, q) : FOR_NON_STATIC * STMT)
			 : RESULT = (
let	val {lo, hi} = case range of
			RRange r => r
			|RRangeAttr _ =>
				fail "for_static" 505001
					[fn()=>"range attributes not supported"];
	val {pre, post, w, w0, ...} = case stmt of
		STSpecNoIvars spec => spec
		|_ => fail "for_static" 505001 [fn()=>
			"Cannot proceed formally when loop body size > 1"];
	val zi = trans_id i;
	val zlo = trans_exp env lo;
	val zhi = trans_exp env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zlo0 = subs_exp (zlo, w, w0);
	val zhi0 = subs_exp(zhi, w, w0);
	val zran = z_elem(zid env zi, z_rng (zlo0, zhi0));
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[z_less_eq (zlo, zhi)] Ù sub(pre, zi, zlo)] @
		(z_greater(zlo, zhi) %Longrightarrow% wp1);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% (till %Longrightarrow% wp1)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zhi0), post] Ù 
			sub(pre, zi, z_bin_exp(zleft, zop, zright))] @
				(sub(post, zi, zhi0) %Longrightarrow% wp1) @
				till_part;
in
	{wp = wp, side = side}
end
);
=TEX

\subsection{Logical Constant}\label{wp-log-con}
=SML
fun €analyse_log_con› (pre : Z_PRED) : (Z_EXP * Z_PRED) = (
let	val (eqtm, pre1) = dest_z_± pre;
	val (_, e) = dest_z_eq eqtm;
in
	(e, pre1)
end
handle _ => fail "analyse_log_con" 505001 [fn()=>"logical constant not of form CON X : T ∑ Ñ w [X=E ± pre1, post]"]
);
=TEX
=SML
fun €log_con› ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(({x, t, spec as {w, w0, pre, post,...}, ...}, q) : LOG_CON * STMT)
		: RESULT = (

let	val (e, pre1) = analyse_log_con pre;
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] Ù sub(pre1, x, e)];
	val zvar_ty = dest_z_power_type(type_of t);
	val env' = fn id => if id = x then Value (zvar_ty, EIEnvVar "__none")					else env id;
	val side = z_eq(zid env' x, subs_exp (e,w,w0)) %Longrightarrow%
		(post %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
=SML
fun €proc_call_ivars› ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
	((pc as {name, actuals}, q) : (AGG_CHOICE, EXP) PROC_CALL * STMT)
					: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_ivars" 505001 [fn()=>"formal procedure not found"];
in
	wp (SSpecIvars(proc_call_spec env pc fp, q), a, wp_env)
end
);
=TEX
\subsection{$wp$}\label{wp}
=SML
fun €wp› ((st, a, wp_env) : STATEMENT * SEQUENT list * WP_ENV) : RESULT = (
let	val pars : WP_PARS = {wp = wp, a = a, wp_env = wp_env};
in	case st of
		SStmt STNull => null pars
	|	SStmt STImplicitNull => null pars
	|	SStmt (STAssign x) => assign pars x
	|	SStmt (STSpecNoIvars x) => spec_no_ivars_either pars x
	|	SStmt (STSemicolon x) => semicolon pars x
	|	SStmt (STIfThenElse x) => if_then_else pars x
	|	SStmt (STCase x) => case_either pars x
	|	SStmt (STLoop x) => loop pars x
	|	SStmt (STNamedLoop x) => named_loop pars x
	|	SStmt (STWhile x) => cn_while pars x
	|	SStmt (STForStatic x) => for_static pars x
	|	SStmt (STForTmark x) => for_tmark pars x
	|	SStmt (STExitWhen x) => exit_when pars x
	|	SStmt (STExit) => cn_exit pars
	|	SStmt (STRet x) => cn_return pars x
	|	SStmt (STProcNoIvars x) => proc_call_no_ivars pars x
	|	SStmt (STKSlot x) => {wp=[],side=[]}
	|	SSpecIvars x => spec_ivars pars x
	|	SForNonStatic x => for_non_static pars x
	|	SLogCon x => log_con pars x
	|	SProcIvars x => proc_call_ivars pars x
end
);
=TEX
\pagebreak
\section{VERIFICATION CONDITIONS}
=SML
fun €vc_local_decls› (seqs : SEQUENT list,
	{fun_flag, in_scope as {vc_vars, vc_pars, ...},
		wp_env={env, ...}, ...} : SPECLAB)
		: VC list = (
let	fun conv_var_decl ({vars=vs, tmark=t} : VAR_DECL)
		: {var : ID, tmark : TMARK} list = (
	 map (fn id => {var=id, tmark=t}) vs
	);
	fun var_decl_decls {var, tmark} =
		[{var = trans_id var, tmark=tmark},
		{var = (trans_id var ^ "â0"), tmark=tmark}];
	val vdd = flat o (map var_decl_decls) o conv_var_decl;
	fun param_spec_decls {var_decl, mode} = (
		if	mode = MSparkIn
		then	[hd(vdd var_decl)]
		else	vdd var_decl
	);
	val decls = flat(map vdd vc_vars @
			map param_spec_decls vc_pars);
	fun add_decls decs (seq as (H, c)) = (
		let	val vns = map (fst o dest_var)
				(flat(frees c :: map frees H));
		in	(decs drop (fn {var, tmark} => var mem vns),
			seq)
		end
	);
	fun mk_z_decl_part  (vartml, seq) =
		(map (trans_decl env) vartml, seq);
	val res = map (add_decls decls) seqs;

in
	map mk_z_decl_part res
end
);
=TEX
=SML
fun €vcs› ((sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st): SPECLAB * STATEMENT)
			(*: VC list*) = (
let	val {wp, side} = wp (st, [[] Ù post], wp_env);
	fun subs_c (h, c) = (
		h Ù subs_pred(c, w0, w)
	);
	val wp1 = map subs_c wp;
	val s = (pre %Longrightarrow% wp1) @
		(subs_pred(pre, w, w0) %Longrightarrow% side);
in
	vc_local_decls(s, sl)
end
);
=TEX
\section{EPILOGUE}
=SML
end (* local ... in *);
end (* structure CNVCGenerator *);
=TEX
%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed505.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}


