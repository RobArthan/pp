% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% pp -i zed505 -d zplay
% pp_list -d zplay vc_gen >zed505.th.doc
% doctex zed505 zed505.th
% texdvi zed505
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Verification Condition Generator}  %% Mandatory field
\def\TPPheadtitle{Verification Condition Generator}
\TPPref{ISS/HAT/DAZ/IMP505}  %% Mandatory field
\def\SCCSversion{1.52%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{97/07/18%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Informal}
\TPPtype{Specification}
%\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\R.D.~Arthan & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This is the implementation of the verification condition generator for the compliance tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.28] Initial Drafts.
\item[Issue 1.29] Changed signature of $check\_new\_z\_id$.
\item[Issues 1.30-1.34] Fixes/palliatives for DRA bugs (batch 1) 8, 9, 10, 11, 19.
\item[Issue 1.35] Palliative for bug 10 (batch 1)
\item[Issue 1.36] Fixes for DRA bugs (batch 2) 1, 2.
\item[Issue 1.37] Enhancements 1, 6 and 20 (annotations, pragmas and arbitrary replacements catered for).
\item[Issue 1.38] New treatment of records.
\item[Issue 1.39] Bug fixing (batch 2 bug 13).
\item[Issue 1.40] Rationalised error reporting.
\item[Issue 1.41] Fixed problem adjusting case selectors.
\item[Issue 1.42] Update references.
\item[Issue 1.43] Fixed DRA bug 12 (V0.6).
\item[Issue 1.44] Fixed DRA bug 4 (V0.6).
\item[Issue 1.45] Fixed DRA bug 2 (V0.6).
\item[Issue 1.46] Fixed DRA bug 15 (V0.6).
\item[Issue 1.47] Fixed \LaTeX{} error.
\item[Issue 1.48] k-slots as annotations.
\item[Issue 1.49] Fixing $analyse\_log\_con$.
\item[Issue 1.50] Improved message 505063.
\item[Issue 1.51] Improved use of substitutions and common  subterms.
\item[Issue 1.51-1.54] IUCT WP 4.
\item[Issue 1.55] Check 1(a) now applies to procedure calls too.
\item[Issue 1.56] Added new check 16.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance tool verification condition generator. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Possible Enhancements}
None.

\pagebreak

\section{THE STRUCTURE $CNVCGenerator$}
=SML
infix 3 Ù;
infix 4 %Longrightarrow%;
infix 5 cap;
=TEX
=SML
structure €CNVCGenerator› : CNVCGenerator = struct
local
	open CaseIndependence;
	open CNTypes1 CNTypes2 CNParser CNTypes CNBasicDeclsAndExprs;
	open ZUserInterfaceSupport ZGeneratedConstants TypeInference;
in
=TEX
\section{SUPPORTING FUNCTIONS}
In version 0.6 and onwards we follow the new policy of not attempting to recover when a construct cannot be handled formally.
The special exception $VCInformal$ and associated functions are therefore no longer required.
=TEX
The following function decorates a string with a subscript ``0'' and is used to give the initial version of a variable name.
=SML
fun €init_var› (name : string) : string = name ^ "â0";
=TEX
The following functions are used to construct a type inference context for use when the specification statement of a procedure is type checked.
=SML
fun v_v0 (in_mode : bool) (ty : TYPE) (v : ID) : TERM list = (
		if	in_mode
		then	[mk_var(v, ty)]
		else	[mk_var(init_var v, ty), mk_var(v, ty)]
);
fun ti_context_of_formal_ids (env : CN_ENV) ([] : PARAM_SPEC list)
		: TERM list = []
|  ti_context_of_formal_ids env ({var_decl as {vars, tmark}, mode} :: more) = (
	let	val ty = dest_z_power_type (type_of (zid env (trans_id tmark)));
		val inmode = case mode of MSparkIn => true | _ => false;
	in	flat (map (v_v0 inmode ty) vars)
		@ ti_context_of_formal_ids env more
	end	handle Fail _ => fail "vcs" 508051 [fn()=>tmark]
);
=TEX
\pagebreak
\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}
\subsection{Sequents}
=SML
fun (h : Z_PRED list) Ù (c : Z_PRED) : SEQUENT = (h, c);

fun (h : Z_PRED) %Longrightarrow% (s : SEQUENT list) : SEQUENT list = (
	map (fn (h', c) => (h :: h', c)) s
);
=TEX
\pagebreak
\section{Substitutions}
=TEX
First we introduce the new flag.
=SML
val €cn_use_let_in_vcs› : bool ref = ref false;
val side_effect = new_flag
	{name = "cn_use_let_in_vcs",
	control = cn_use_let_in_vcs,
	check = fun_true,
	default = fun_false} handle Fail _ => ();
=TEX
For convenience in coding, we introduce $list\_sub$, a general parallel substitution operator and use it to support the particular variants on substitution which are required.
=SML
fun €list_sub› ((p, xes) :Z_PRED * ((Z_ID * Z_EXP) list)) : Z_PRED = (
	if	!cn_use_let_in_vcs
	then	let	fun mk_def (x : Z_ID, e : Z_EXP) = (
					(mk_var(x, type_of e), e)
			);
			fun not_wanted (x, e) = (
					not (is_free_in x p)
				orelse	x =$ e
			);
			val defs = map mk_def xes drop not_wanted;
		in	mk_let (defs, p)
		end
	else	let	fun mk_subs (x : Z_ID, e : Z_EXP) = (
				(e, mk_var(x, type_of e))
			);
			val isubs1 = (map mk_subs xes);
			val isubs2 = isubs1 drop (fn (a, b) => (a =$ b));
			val p' = var_subst isubs2 p;
			val back_to_z_conv = TRY_C(TOP_MAP_C (
				z_schema_pred_conv1 ORELSE_C
				z_ _conv1 ORELSE_C
				z_dec_renameâs_conv));
		in	(snd o dest_eq o concl o back_to_z_conv) p'
		end
);
=TEX
=SML
fun €sub› ((p, x, e) :Z_PRED * Z_ID * Z_EXP) : Z_PRED = (
	list_sub(p, [(x, e)])
);
=TEX
=SML
fun €subs_exp› ((e, xs, ys) :Z_EXP * (Z_ID list) * (Z_ID list)) : Z_EXP = (
	let	val xys = combine xs ys;
		val ntys = map dest_var(frees e);
		fun s ((n, ty) :: more) (x, y) = (
			if	n = x
			then	(x, mk_var(y, ty)) :: s more (x, y)
			else	s more (x, y)
		) | s [] _ = [];
	in	list_sub(e, flat(map (s ntys) xys))
	end		
);
=TEX
=SML
fun €subs_pred› ((p, xs, ys) :Z_PRED * (Z_ID list) * (Z_ID list)) : Z_PRED = (
	subs_exp(p, xs, ys)
);
fun €subseq› ((seql, x, e) :SEQUENT list * Z_ID * Z_EXP) : SEQUENT list = (
	map (fn (H, c) => map (fn p => sub(p, x, e)) H Ù sub(c, x, e)) seql
);
=TEX
\pagebreak

\section{ABSTRACT SYNTAX OF SPARK STATEMENTS}\label{ASSPARK}

See \cite{ISS/HAT/DAZ/DTD502}.

\section{WEAKEST PRECONDITIONS}\label{WPS}
\subsection{Environments}\label{environments}
=TEX
\subsection{Other Preliminaries}\label{Preliminaries}
=TEX

\subsection{Null Statement}\label{wp-null}
=SML
fun €null› ({a, ...} : WP_PARS) : RESULT = (
	{wp = a, side = []}
);
=TEX
\subsection{Assignment Statement}\label{wp-assignment}

The implementation of $simple\_assign$ works on an assignment where the expression on the rhs has already been converted to Z.
=SML
fun €simple_assign› ({wp_env={env,...}, a, ...} : WP_PARS)
		(x : ID) (ze : Z_EXP) : RESULT = (
	{wp = subseq(a, trans_id x, ze), side = []}
)
=TEX
=SML
and €array_assign› ({wp, a, wp_env as {env,...}} : WP_PARS)
			({prefix, index} : EXP INDEXED_COMP) (ze : Z_EXP) : RESULT = (
let	val name' = prefix;
	val e' = (z_override
			(trans_exp env prefix, z_set
			   [z_maplet (trans_exp env index, ze)]));
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', e')
end
)
=TEX
=SML
and  €record_assign›	({wp, a, wp_env as {env, ...}} : WP_PARS)
	({prefix, selector} : EXP SELECTED_COMP) (ze : Z_EXP) : RESULT = (
let	val z_prefix = trans_exp env prefix;
	val z_sig = dest_z_schema_type(type_of z_prefix)
			handle Fail _ => fail "record_assign" 505027 [];
	val zvars = map fst z_sig;
	fun do_comp zvar = (
		if	zvar = selector 
		then	(zvar, ze)
		else	(	zvar,
				trans_exp env 
				(ESelectedComp{prefix=prefix,selector=zvar})
			)
	);
	val name' = prefix;
	val zbinds = map do_comp zvars;
	val ze' = z_binding zbinds; 
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', ze')
end
)
=TEX
=SML
and €assign› (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ((name, ze) : EXP * Z_EXP)
			: RESULT = (
	case name of
	EId id => simple_assign wp_pars id ze
	|EIndexedComp ic => array_assign wp_pars ic ze
	|ESelectedComp sc => record_assign wp_pars sc ze
	|_ => fail "assign" 505029 []
);
=TEX
\subsection{Specification Statement (No initial variables)}\label{wp-specification-no-ivars}
=SML
fun €spec_no_ivars› ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = [[] Ù pre], side = post %Longrightarrow% a}
);
=TEX
=SML
fun €spec_no_ivars_empty› ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = ([] Ù pre) :: (post %Longrightarrow% a), side = []}
);
=TEX
=SML
fun €spec_no_ivars_either› (wp : WP_PARS) (w : Z_ID list) ((pre, post) : Z_EXP * Z_EXP) 
		: RESULT = (
	if	w = []
	then	spec_no_ivars_empty wp (pre, post)
	else	spec_no_ivars wp (pre, post)
);
=TEX
\subsection{Semicolon}\label{wp-semicolon}
=SML
fun €semicolon› ({wp, a, wp_env} : WP_PARS) ((p, q) : STMT * STMT)
			: RESULT = (
let	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val {wp = wp1, side = side1} = wp (SStmt p, wp2, wp_env);
in
	{wp = wp1, side = side1 @ side2}
end
);
=TEX
=IGN
val SStmt(STSemicolon (p,q)) = exp;
val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
val save_exp1 = exp;
val exp= SStmt q;
=TEX
\subsection{If Statement}\label{wp-if-then-else}
=SML
fun €if_then_else›	({wp, a, wp_env as {env,...}} : WP_PARS)
			({g, p, q,...} : STMT IF_THEN_ELSE) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val g' = trans_exp env g;
	val wp = (z_eq(g', zid env "TRUE") %Longrightarrow% wp1) @
		(z_eq(g', zid env "FALSE") %Longrightarrow% wp2);
	val side = side1 @ side2;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Case Statement}\label{wp-case}
=SML
fun €trans_case_choices› (env : CN_ENV) (choices : CASE_CHOICE list) : Z_EXP = (
let	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	fun aux_range (ch::rest) = (
		case ch of
		CCCaseRange (DRRange(RRange{lo,hi})) =>
			z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
		|CCCaseRange (DRRange _) =>
			fail "trans_case_choices" 508020 [] 
		|CCCaseRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
		|CCCaseRange (DRConstrained _) =>
			fail "trans_case_choices" 508020 []
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		CCCaseExp exp =>
			adjust_and_trans exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choices;
	val zsingles = z_set (aux_singles choices);
in
	z_many_union(zranges @ [zsingles])
end
);
=TEX
=SML
fun €case_base› ({wp, a, wp_env as {env,...}} : WP_PARS) (e : EXP)
			({choices, p} : STMT CASE_ALTERNATIVE)
			 : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val wp' = z_elem (trans_exp env e, trans_case_choices env choices)
			%Longrightarrow% wp1;
in	{wp = wp', side = side1}
end
);
=TEX
=SML
fun €case_step› (pars as {wp, a, wp_env as {env,...}} : WP_PARS)
		({e, s, others as STImplicitNull} : STMT CASE) : RESULT = (
	case s of
	[] =>
		fail "case_step" 505030 []
	| [alt] =>
		case_base pars e alt
	| ({choices, p} :: s') => (
		let	val {wp = wp1, side = side1} =
				wp (SStmt p, a, wp_env);
			val {wp = wp2, side = side2} =
				case_step pars {e=e, s=s', others=others};
			val elm =
				z_elem (trans_exp env e, trans_case_choices env choices)
		in	{wp = (elm %Longrightarrow% wp1) @ wp2 , side = side1 @ side2}
		end)
) | case_step _ _ = (
	fail "case_step" 505021 []
);
=TEX
Note that $case\_step$ is recursive and does the full job. 
But by analogy with the naming convention we chose to adopt for the
two case of specification statement in section \ref{wp-specification-no-ivars},
we define the following.
=SML
val €case_either› : WP_PARS -> STMT CASE -> RESULT = case_step;
=TEX

\subsection{Undecorated Loop}\label{wp-loop}
=SML
fun €loop› ({a, ...} : WP_PARS) ({t, stmt} : STMT LOOP)
			: RESULT = (
let	val (pre1, post1) = case stmt of
		STSpecNoIvars {spec={pre, post, ...}, ...} => (
			(z_predexp_of_z_tm pre,z_predexp_of_z_tm post)
		) |_ => fail "loop" 505022 [];
	val wp = [[] Ù pre1];
	val side = case t of
			Value till => [[post1] Ù pre1] @
				((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => [[post1] Ù pre1];
in
	{wp = wp, side = side}
end
);
=TEX
=SML
fun €named_loop› (wp_pars : WP_PARS) ({t, stmt, ...} : STMT NAMED_LOOP)
			: RESULT = (
	loop wp_pars {t=t, stmt=stmt}
);
=TEX
\subsection{While Loop}\label{wp-while-loop}
=SML
fun €cn_while›	({a, wp_env={env, ...}, ...} : WP_PARS)
		({g, loop={t,stmt}, ...} : STMT WHILE) : RESULT = (
let	val {w, w0, pre, post} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "loop" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val g' = trans_exp env g;
	val wp = ([z_eq(g', zid env "TRUE")] Ù pre1) ::
			(z_eq(g', zid env "FALSE")
				%Longrightarrow% a);
	val side = case t of
			Value till => (post1 %Longrightarrow% wp) @
					((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => (post1 %Longrightarrow% wp);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-static}
=SML
fun €for_static› ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, range, dir, loop = {t, stmt}, ...} : STMT FOR_STATIC) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else fail "for_static" 505023 [];
	val {lo, hi} = case range of
			RRange {lo, hi} => {lo=adjust_exp env lo, hi=adjust_exp env hi}
			|RRangeAttr _ =>
				fail "for_static" 505020 [];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp env lo;
	val zhi = trans_exp env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zid_zi = zid env zi;
	val zran = z_elem (zid_zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] Ù sub(pre1, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till) %Longrightarrow% a)
			) | Nil => [];
	val side = [[zran, z_noteq(zid_zi, zhi), post1] Ù 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}
=SML
fun €for_tmark› ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, dir, loop = {t, stmt}, ...} : STMT FOR_TMARK) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else fail "for_tmark" 505023 [];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_tmark" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = zid env (trans_id tmark ^^ zfst);
	val zhi = zid env (trans_id tmark ^^ zlst);
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] Ù sub(pre1, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				(z_predexp_of_z_tm till) %Longrightarrow% a
			) | Nil => [];
	val side = [[z_noteq(zid env zi, zhi), post1] Ù 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=SML
fun €exit_when› ({a, wp_env={till, env, ...}, ...} : WP_PARS)
		({g} : EXIT_WHEN)
			 : RESULT = (
let	val zg = trans_exp env g;
	val wp = ([z_eq(zg, zid env "TRUE")] Ù till) ::
		(z_eq(zg, zid env "FALSE") %Longrightarrow% a);
in	{wp = wp, side = []}
end
);
=TEX
\subsection{Exit}\label{wp-exit}
=SML
fun €cn_exit› ({wp_env={till, ...},...} : WP_PARS) : RESULT = (
	{wp = [[] Ù till], side = []}
);
=TEX
\subsection{Return}\label{wp-return}
=TEX
$conv\_var\_decl$ is implemented in \cite{ISS/HAT/DAZ/IMP508}.
=SML
fun €cn_return› ({wp, a, wp_env= {env, fun_header={name, formal_pars, ...},
			return, ...}} : WP_PARS)
		({e} : RETURN) : RESULT = (
let	val zfun = trans_fun_name env name;
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_pars;
	val ids = flat (map (fn {vars, ...} => vars) var_decls);
	val zargs = map (fn id => zid env (trans_id id)) ids;
	val wp = [[z_eq(z_fun_call(zfun, zargs), trans_exp env e)] Ù return];
	val side = [];
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}
=SML
fun €proc_call_spec› (env : CN_ENV)
		({actuals, ...} : (AGG_CHOICE,EXP) PROC_CALL)
		({name, formal_ids, spec={w, w0, pre, post}, ...} : FORMAL_PROC)
			: (Z_EXP * Z_EXP) = (
let	val old_cxt = get_ti_context();
	val new_cxt = ti_context_of_formal_ids env formal_ids @ old_cxt;
	val side1 = set_ti_context new_cxt;
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val side2  = set_ti_context old_cxt;
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
	val names = ((map trans_id) o flat
				o (map (fn {vars, ...} => vars))) var_decls;
	val exps = case actuals of
			APositional exps => map (adjust_exp env) exps
			|ANamed nas => map (adjust_exp env)
					(named_assocs_to_exps names nas);
	fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) list = (
		let 	val ntm as (n, tm) = (name, trans_exp env actual);
		in let	val (v, ty) = dest_var tm;
		in	[ntm, (init_var n, mk_var(init_var v, ty))]
		end	handle Fail _ => [ntm]
		end
	);
	val exp_names = combine exps names
		handle _ => fail "proc_call_spec" 505026 [fn()=>name];
	val subs_list = flat(map subs exp_names);
in
	(list_sub(pre1, subs_list),list_sub(post1, subs_list))
end
);
=TEX
=IGN

val {formal_ids, spec as {w, w0, pre, post, label}, ...}=fp;
val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
val names = flat (map (fn {vars, ...} => vars) var_decls);
val exps = case actuals of
			APositional exps => map (adjust_exp env) exps
			|ANamed nas => map (adjust_exp env) (named_assocs_to_exps names nas);
fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) = (name, trans_exp env actual);
val exp_names = combine exps names
		handle _ => fail "proc_call_spec" 505026 [fn()=>name];
val subs_list = map subs exp_names;

=TEX
In the following, we call $spec\_no\_ivars\_either$ directly rather than call $wp$ because the pre- and post-conditions have already been converted to $Z\_PRED$s. 
=SML
fun €proc_call_no_ivars› ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
		(pc as {name, actuals} : (AGG_CHOICE,EXP) PROC_CALL)
	
		: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp as {spec = {w, ...}, ...} = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_no_ivars" 505031 [fn()=>name];
in
	spec_no_ivars_either {wp = wp, a = a, wp_env = wp_env}
		w (proc_call_spec env pc fp)
end
);
=TEX
=IGN
val {formal_procs, env, ...} = wp_env;
val SStmt (STProcNoIvars (pc as {name, actuals})) = exp;
fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);


=TEX
\subsection{Specification Statement (with Initial Variables)}\label{wp-spec-ivars}
=SML
fun €spec_ivars› ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(((pre, post), q) : (Z_EXP * Z_EXP) * STMT) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] Ù pre];
	val side = (post %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}
=SML
fun €for_non_static› (pars as {wp, a, wp_env as {env, ...}} : WP_PARS)
			(({i, range, loop = {t, stmt}, ...}, q) : FOR_NON_STATIC * STMT)
			 : RESULT = (
let	val {lo, hi} = case range of
			RRange {lo, hi} => {lo=adjust_exp env lo, hi=adjust_exp env hi}
			|RRangeAttr _ =>
				fail "for_non_static" 505020 []
	val {pre, post, w, w0, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_non_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp env lo;
	val zhi = trans_exp env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zlo0 = subs_exp (zlo, w, w0);
	val zhi0 = subs_exp(zhi, w, w0);
	val zran = z_elem(zid env zi, z_rng (zlo0, zhi0));
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[z_less_eq (zlo, zhi)] Ù sub(pre1, zi, zlo)] @
		(z_greater(zlo, zhi) %Longrightarrow% wp1);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till )%Longrightarrow% wp1)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zhi0), post1] Ù 
			sub(pre1, zi, z_bin_exp(zleft, zop, zright))] @
				(sub(post1, zi, zhi0) %Longrightarrow% wp1) @
				till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Logical Constant}\label{wp-log-con}
=SML
fun €analyse_log_con› (x : ID) (pre : Z_PRED) : (Z_EXP * Z_PRED) = (
let	val (eqtm, pre1) = dest_z_± pre handle Fail _ => (pre, mk_z_true);
	val (c, e) = dest_z_eq eqtm;
	val dummy = if (not (fst(dest_var c)  = x))
		then fail "analyse_log_con" 505024 [fn _ => x, 
			fn _ => string_of_term pre]
		else ();
	val dummy1 = if (c term_mem (frees e))
		then fail "analyse_log_con" 505024 [fn _ => x, 
			fn _ => string_of_term pre]
		else ();
in
	(e, pre1)
end
handle (Fail _) => 
  fail "analyse_log_con" 505024 [fn _ => x, fn _ => string_of_term pre]
);
=TEX
=SML
fun €log_con› ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(({x, t, spec as {w, w0, pre, post}, ...}, q)
			: LOG_CON * STMT)
		: RESULT = (

let	val (e, pre1) = analyse_log_con x (z_predexp_of_z_tm pre);
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] Ù sub(pre1, x, e)];
	val zvar_ty = (dest_z_power_type o type_of o z_predexp_of_z_tm) t;
	val env' = fn id =>	if id = x
				then Value (zvar_ty, EIEnvVar "__none")
				else env id;
	val side = (z_eq(zid env' x, subs_exp (e,w,w0)) %Longrightarrow%
		((z_predexp_of_z_tm post) %Longrightarrow% wp1)) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
=SML
fun €proc_call_ivars› ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
	((pc as {name, actuals}, q) : (AGG_CHOICE, EXP) PROC_CALL * STMT)
					: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_ivars" 505031 [fn()=>name];
in
	spec_ivars {wp = wp, a = a, wp_env = wp_env}
			(proc_call_spec env pc fp, q)
end
);
=TEX
\subsection{Adjusting Statements}

=SMLPLAIN
fun €any_initial_variables› (z_tm : Z_TM) : bool = (
let	val pred = z_predexp_of_z_tm z_tm;
	val names = map (fst o dest_var) (frees pred);
	fun is_init_var s =
		case (rev o explode) s of
			"0" :: "â" :: _ =>	true
		|	_ => 			false;
	
in
	any names (fn s => is_init_var s)
end
);
=TEX
=SML
fun €is_static_for_loop› (wp : WP_ENV) (fs : STMT FOR_STATIC) : bool = (
let	fun no_vars_in_exp exp = (
		case (term_vars o (trans_exp (#env wp))) exp of
			[] =>	true
		|	_ =>	false
	);
in
	case (#range fs) of
	RRange {lo, hi} =>
		no_vars_in_exp lo andalso no_vars_in_exp hi
	|RRangeAttr _ => true
end
);
=TEX
In the following, most of the work is done in $adj\_stmt\_aux$.
Note that, $adj\_stmt\_aux$ always returns a statement which is just $SStmt\,s$ unless $is\_first$ is true.
$adj\_stmt\_aux$ calls itself recursively (via $check\_inner$) just to check the form of constituents of the various compound statement forms.
=SML
local
fun €adj_stmt_aux› (wp : WP_ENV)
			(is_first : bool)
				(s : STMT)
					: STATEMENT = (
let	val check_inner = adj_stmt_aux wp false;
in
	case s of
		STSpecNoIvars sni =>
			if	any_initial_variables (#post (#spec sni))
			then	if	is_first
				then	SSpecIvars (sni, STImplicitNull)
				else	fail "adjust_statement" 505091 []
			else	SStmt s
	|	STForStatic (fs as {name,i,range,loop as {stmt, ...}, ...}) => (
			check_inner stmt;
			if	is_static_for_loop wp fs
			then	SStmt s
			else	if	is_first
				then	SForNonStatic ({	name=name,
							i=i,
							range=range,
							loop=loop
						}, STImplicitNull)
				else	fail "adjust_statement" 505092 []
	) |	STProcNoIvars piv =>
		let	fun find_spec id ((fproc::rest) : FORMAL_PROC list) = (
				if (#name fproc) = id
				then	Value (#spec fproc)
				else	find_spec id rest
			) | find_spec id [] = Nil;
		in
			case find_spec (#name piv) (#formal_procs wp) of
			Value sp => (
				if	any_initial_variables (#post sp)
				then	if	is_first
					then	SProcIvars (piv, STImplicitNull)
					else	fail "adjust_statement" 505093 []
				else	SStmt s
			) |	Nil => SStmt s
		end
	|	STSemicolon (st1, st2) =>
		let	val side = check_inner st2;
		in	case adj_stmt_aux wp true st1 of
				SStmt st1' => SStmt(STSemicolon (st1', st2))
			|	SSpecIvars (si, STImplicitNull) =>
					SSpecIvars (si, st2)
			|	SSpecIvars (si, st) =>
					SSpecIvars (si, STSemicolon(st, st2))
			|	SForNonStatic (fns, STImplicitNull) =>
					SForNonStatic (fns, st2)
			|	SForNonStatic (fns, st) =>
					SForNonStatic (fns, STSemicolon(st, st2))
			|	SProcIvars (piv, STImplicitNull) =>
					SProcIvars (piv, st2)
			|	SProcIvars (piv, st) =>
					SProcIvars (piv, STSemicolon(st, st2))
			|	_ => fail "adjust_statement" 505094 []
		end
	|	STIfThenElse {p, q, ...} => (
			check_inner p;
			check_inner q;
			SStmt s
	) |	STCase {s = alts, others = others, ...} => (
			map (fn {choices, p} => check_inner p) alts;
			check_inner others;
			SStmt s
	) |	STLoop {stmt, ...} => (
			check_inner stmt;
			SStmt s
	) |	STNamedLoop {stmt, ...} => (
			check_inner stmt;
			SStmt s
	) |	STWhile {loop as {stmt, ...}, ...} => (	
			check_inner stmt;
			SStmt s
	) |	STForTmark {loop as {stmt, ...}, ...} => (
			check_inner stmt;
			SStmt s
	) |	_ => SStmt s
end
);
in
fun €adjust_statement› (wp : WP_ENV) (st : STATEMENT)
		: STATEMENT = (
	case st of
		SStmt s =>
			adj_stmt_aux wp true s
	|	SLogCon (lc, st) => (
			case adj_stmt_aux wp false st of
				SStmt s => SLogCon (lc, s)
			|	_ => fail "adjust_statement" 505094 []
	) | 	_ => fail "adjust_statement" 505094 []
);
end
=TEX
=IGN
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));
=TEX
\subsection{$wp$}\label{wp}

=SML
fun €wp› ((st, a, wp_env) : STATEMENT * SEQUENT list * WP_ENV) : RESULT = (
let	val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	val adjust = adjust_exp env;
in	case adjust_statement wp_env st of
		SStmt STNull => null pars
	|	SStmt STImplicitNull => null pars
	|	SStmt (STAssign {name, e}) =>
			assign pars (adjust name, adjust_and_trans e)
	|	SStmt (STSpecNoIvars {spec={pre, post, w, ...}, ...}) => 
			spec_no_ivars_either pars w
				(z_predexp_of_z_tm pre, z_predexp_of_z_tm post)
	|	SStmt (STSemicolon x) => semicolon pars x
	|	SStmt (STIfThenElse {g, p, q, elsif}) =>
			if_then_else pars {g=adjust g, p=p, q=q, elsif=elsif}
	|	SStmt (STCase {e, s, others}) =>
			case_either pars {e=adjust e, s=s, others=others}
	|	SStmt (STLoop x) => loop pars x
	|	SStmt (STNamedLoop x) => named_loop pars x
	|	SStmt (STWhile {g, loop, name}) =>
			cn_while pars {g=adjust g, loop=loop, name=name}
	|	SStmt (STForStatic x) => for_static pars x
	|	SStmt (STForTmark x) => for_tmark pars x
	|	SStmt (STExitWhen {g}) => exit_when pars {g=adjust g}
	|	SStmt (STExit) => cn_exit pars
	|	SStmt (STRet {e}) => cn_return pars {e=adjust e}
	|	SStmt (STProcNoIvars x) => proc_call_no_ivars pars x
	|	SStmt (STKSlot x) => fail "wp" 505040 []
	|	SStmt (STPragma _) => null pars
	|	SStmt (STAnnotation _) => null pars
	|	SSpecIvars ({spec={pre, post, ...}, ...}, q) =>
			spec_ivars pars ((z_predexp_of_z_tm pre, z_predexp_of_z_tm  post), q)
	|	SForNonStatic x => for_non_static pars x
	|	SLogCon x => log_con pars x
	|	SProcIvars x => proc_call_ivars pars x
end
);
=TEX
\pagebreak
\section{APPLICATION OF CHECKS}


\subsection{Useful Printing Functions in Lieu of CNSparkOutput}
=SML
fun €fmt_id› (n : ID) : string = CaseIndependence.get_external_name n;
fun €fmt_id_list› ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
=TEX
\subsection{The Error Printing Function}
=SML
fun €checking_error› (msg : string) (n : int) (ins) = (
	diag_line (get_error_message 505050 []);
	fail msg n ins
);
=TEX
\subsection{The Checks}
=SML
fun €check_1_a› (id : Z_ID list, speclab : SPECLAB) = (
	let	val w = (#w o #spec) speclab;
	in
		if id diff w = []
		then ()
		else if w = []
		then	checking_error "check_1_a" 505060
			[	fn () => fmt_id_list id]
		else	checking_error "check_1_a" 505064
			[	fn () => fmt_id_list w,
				fn () => fmt_id_list id]
	end
);
=TEX
=SML
fun €check_1_b› (speclab : SPECLAB) = (
	if #formal_body_flag speclab
	then ()
	else checking_error "check_1_b" 505061 []
);
=TEX
=SML
fun €check_1_c› (speclab : SPECLAB) = (
	if #till_flag speclab
	then ()
	else checking_error "check_1_c" 505062 []
);
=TEX
=SML
fun €check_1_d› (p : ID, speclab : SPECLAB) = (
	if any ((#formal_procs o #in_scope) speclab)
			(fn fp => p = #name fp) 
	then ()
	else checking_error "check_1_d" 505063 [fn () => p]
);
=TEX
The following check, we also check 
=SML
fun €check_16› (env : CN_ENV) ({w, ...} : SPEC) = (
let	fun aux v = (
		case env v of
			Value (_, EIEnvVar _) => ()
		|	Value (_, EIEnvAuxVar _) => ()
		|	Value _ => fail "check_16" 505083 [fn()=> v]
		|	Nil => fail "check_16" 505082 [fn()=> v]
	);
in	map aux w; ()
end
);
=TEX
\subsection{Anti-Aliasing Checks}

=SML
fun op €cap› (a, b) = (a cup b) diff (a diff b) diff (b diff a);
=TEX

=SML
fun €free_vars_zpred› (zp : Z_PRED) : Z_ID list = (
	 (map ((fn (n,_,_) => n) o dest_z_lvar) o frees) zp
);
=TEX
=SML
fun €name_to_entire_variable_name› (e : EXP) : Z_ID = (
	case e of
		EId id => (
			trans_id id
	) |	ESelectedComp {prefix, selector} => (
			name_to_entire_variable_name prefix
	) |	EIndexedComp{prefix, index} => (
			name_to_entire_variable_name prefix
	) |	_ => error "name_to_entire_variable_name" 505080 []
);
=TEX
=SML
fun €find_formal_proc› (speclab : SPECLAB) (name : ID) : FORMAL_PROC = (
	find 
	((#formal_procs o #in_scope) speclab)
		(fn p => #name p = name)
		handle Fail _ => checking_error "find_formal_proc" 505067
						[fn () => name]
);
=TEX	
=SML
fun €anti_aliasing_pars› (fp : FORMAL_PROC) (pc : (AGG_CHOICE,EXP)PROC_CALL)
				: ID list * ID list = (
	let	val formal_ids = #formal_ids fp;
		val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
		val formals = flat (map (fn {vars, ...} => vars) var_decls);
		val pre = (z_predexp_of_z_tm o #pre o #spec) fp;
		val post = (z_predexp_of_z_tm o #post o #spec) fp;
		val trans_formals = map trans_id formals;
		val trans_globals = (free_vars_zpred pre cup
				free_vars_zpred post) diff trans_formals;
	in
		(formals, trans_globals)
	end
);
=TEX
The following function makes a pair-wise list of actual parameters (EXPs) with their modes (which are extracted from the corresponding $formal\_proc$).
The actuals are in the order given in the procedure specification.
=SML
fun €anti_aliasing_actuals_modes› (env : CN_ENV) (formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE, EXP) PROC_CALL) :
			(EXP * MODE) list = (
	let	val name = #name proc;
		val formal_ids = #formal_ids formal_proc;
		val var_decls_modes = map (fn {var_decl, mode,...}
					=> (var_decl,mode)) formal_ids;
		val vars_modes = map
				(fn ({vars, ...},mode) => (vars,mode))
				 var_decls_modes;
		fun do_formals_modes (id::rest, m) = (
			(id, m)::do_formals_modes (rest, m)
		) | do_formals_modes _ = [];
		val (formals,modes) = (split o flat o map do_formals_modes)
						vars_modes;
		val actuals = map (adjust_exp env) (case #actuals proc of
				APositional exps => exps
			|	ANamed nas => named_assocs_to_exps formals nas)
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
		val actuals_modes = combine actuals modes
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
	in	combine actuals modes
	end
);
=TEX
=SML
fun €anti_aliasing_check_1› (proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val set = map fst (actuals_modes drop
				(fn am => not (snd am = MSparkInOut orelse
						 snd am = MSparkOut)));
	in
		if any set (fn EId x => false | _ => true)
		then
		let	val exprs = set drop (fn EId x => true | _ => false);
			val plural = if length exprs > 1 then "s" else "";
		in
			checking_error "anti_aliasing_check_1" 505069
				[fn() => fmt_id (#name proc)]
		end
		else (* OK *) ()
	end
);
=TEX
=SML

=TEX
=SML
fun €anti_aliasing_check_2› (formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val (_, trans_globals) = anti_aliasing_pars formal_proc proc;
		val set = map fst (actuals_modes drop
				(fn am => not (	snd am = MSparkInOut orelse
							snd am = MSparkOut)));
		val trans_set = map (fn
				EId id => trans_id id
				|_	=> fail "anti_aliasing_check_2" 505070
						[fn()=>name]) set;
		val inter_set = trans_set cap trans_globals;
		val plural = if length inter_set > 1 then "s" else "";
	in
		if inter_set = []
		then (* OK *) ()
		else	checking_error "anti_aliasing_check_2" 505071
				[	fn()=> plural,
					fn()=> fmt_id name,
					fn()=> fmt_id_list inter_set]
	end
);
=TEX
=SML
local
	fun aux (fv::rest) = (
		if is_z_lvar fv
		then
			((fn (n,_, _) => n) o dest_z_lvar) fv::aux rest
		else
			aux rest
	) | aux _ = [];
in
fun €vars_exp› (cn_env : CN_ENV) (exp : EXP) : ID list = (
	(aux o frees o trans_exp cn_env) exp
);
end (* local ... in *);
=TEX
=SML
fun €anti_aliasing_check_3› (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val (_, trans_globals) = anti_aliasing_pars formal_proc proc;
		val w = (#w o #spec) formal_proc;
		val actuals = map fst actuals_modes;
		val ids = list_cup (map (vars_exp ((#env o #wp_env) speclab))
					actuals);
		val trans_ids = map trans_id ids;
		val inter_set = trans_globals cap w cap trans_ids;
		val plural = if length inter_set > 1 then "s" else "";
	in	if inter_set = []
		then (* OK *) ()
		else checking_error "anti_aliasing_check_3" 505072
				[	fn()=> plural,
					fn()=> fmt_id name,
					fn()=> fmt_id_list inter_set]
	end
);
=TEX
=SML
fun €anti_aliasing_check_4› (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val (_, trans_globals) = anti_aliasing_pars formal_proc proc;
		val cn_env = (#env o #wp_env) speclab;
		fun pair_wise (a_m_1::a_m_2::rest) = (
		let	val (actual1, mode1) = a_m_1;
			val (actual2, mode2) = a_m_2;
			val ve1 = vars_exp cn_env actual1;
			val ve2 = vars_exp cn_env actual2;
			val inter_set = ve1 cap ve2;
		in
			if not (inter_set = [])
			then	if mode1 = MSparkIn andalso mode2 = MSparkIn
				then (* OK *) ()
				else let val plural = if length inter_set > 1
							then "s" else "";
				     in
					checking_error "anti_aliasing_check_4"
					505073 [	fn()=> plural,
							fn()=> fmt_id name,
							fn()=> fmt_id_list inter_set]
				     end
			else	(* OK *) ()
		end
		) | pair_wise _ = ();
	in	 pair_wise actuals_modes
	end
);
=TEX
The following function computes the effective frame of a procedure call --- the frame that obtained by substituting actual parameters for formals in the original frame.
=SML
fun €proc_frame› (env : CN_ENV)
			({formal_ids, spec={w, ...}, ...} : FORMAL_PROC )
			(actuals_modes : (EXP * MODE) list)
				: Z_ID list = (
	let	val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
		val formals = flat (map (fn {vars, ...} => vars) var_decls);
		val table = combine formals (map fst actuals_modes);
		fun aux (v :: vs) = (
			(case lassoc5 table v of
				Nil => v
			|	Value e =>
				name_to_entire_variable_name	(adjust_exp env e))
			:: aux vs
		) | aux [] = [];
	in	aux w
	end
);
=TEX
=SML
fun €anti_aliasing_check› (env : CN_ENV) (speclab : SPECLAB,
				proc : (AGG_CHOICE,EXP)PROC_CALL) = (
	let	val formal_proc = find_formal_proc speclab (#name proc);
		val actuals_modes =
			anti_aliasing_actuals_modes env formal_proc proc
			handle Fail _ =>
			fail "anti_aliasing_check" 505068 [fn()=> #name proc];
	in
		anti_aliasing_check_1 proc actuals_modes;
		anti_aliasing_check_2 formal_proc proc actuals_modes;
		anti_aliasing_check_3 speclab formal_proc proc actuals_modes;
		anti_aliasing_check_4 speclab formal_proc proc actuals_modes;
		check_1_a(proc_frame env formal_proc actuals_modes, speclab)
	end
);
=TEX
\subsection{Invoking the Checks}
=SML
fun €do_soundness_checks1› (
	(speclab as {wp_env as {env, ...}, ...},
		statement): SPECLAB * STATEMENT) : unit = (

let	fun pass_over_stmt (st : STMT) = (

	case st of
			STNull => (
		)| 	STImplicitNull => (
		)|	STAssign {name,e} => (
				check_1_a
				([name_to_entire_variable_name
						(adjust_exp env name)],
					speclab)
		)|	STSpecNoIvars {spec as {w,w0,pre,post},label} => (
				check_1_a (w, speclab);
				check_16 env spec
		)|	STSemicolon (s1,s2) => (
					(pass_over_stmt s1;
					pass_over_stmt s2)
		)|	STIfThenElse  {g,p,q,elsif} => (
					(pass_over_stmt p;
					pass_over_stmt q)
		)|	STCase {e,s,others} => (
				map (fn st1 => pass_over_stmt (#p st1)) s;
				pass_over_stmt others
		)|	STLoop {t,stmt} => (
				pass_over_stmt stmt
		)|	STNamedLoop {name,t,stmt} => (
				pass_over_stmt stmt
		)|	STWhile {name,g,loop} => (
				pass_over_stmt (#stmt loop)
		)|	STForStatic {name,i,tmark,range,dir,loop} => (
				pass_over_stmt (#stmt loop)
		)|	STForTmark {name,i,tmark,dir,loop} => (
				pass_over_stmt (#stmt loop)
		)|	STExitWhen {g} => (
				check_1_c speclab
		)|	STExit => (
				check_1_c speclab
		)|	STRet {e} => (
				check_1_b speclab
		)|	STProcNoIvars (proc as {name,actuals}) => (
				check_1_d (name, speclab);
				anti_aliasing_check  env (speclab, proc)
		)|	STKSlot {content,label} => (
		)|	STPragma _ => (
		)|	STAnnotation _ => (
		)
	);
	fun pass_over_statement (statement : STATEMENT) = (
		case statement of
			SStmt s => (
				pass_over_stmt s
		) |	SSpecIvars (si, st2) => (
				pass_over_stmt st2
		) |	SLogCon (lc, st2) => (
				pass_over_stmt st2
		) |	SForNonStatic ({name,i,range,loop}, st2) => (
				pass_over_stmt (#stmt loop);
				pass_over_stmt st2
		) |	SProcIvars (proc as {name,actuals}, st2) => (
				check_1_d (name, speclab);
				anti_aliasing_check env (speclab, proc);
				pass_over_stmt st2
		)
	);
	in	pass_over_statement statement
	end
);
=TEX
=SML
fun €resolver› (repl_function : LABEL -> REPLACEMENT OPT) (label : LABEL)
			: STATEMENT = (
	let	val repl = case repl_function label of
					Nil => (
						UnReplaced (RSStatement, "")
				) |	Value repl => repl;
	in
		case repl of
			ReplaceComp _ => (	SStmt STImplicitNull
		) |    ReplacePPart _ => (	SStmt STImplicitNull
		) |    ReplaceVPart _ => (	SStmt STImplicitNull
		) |    ReplaceDecl _ => (	SStmt STImplicitNull
		) |    RefineStat {statement, ...} => (	statement
		) |    ReplaceStat {statement, ...}  => (	statement
		) |    ReplaceArbitrary _ => (	SStmt STImplicitNull
		) |    ReplaceAnnotation _ => (	SStmt STImplicitNull
		) |    UnReplaced _ => (	SStmt STImplicitNull
		)	
	end
);
=TEX
=SML
datatype €CHECK_STATE› = €CSTop› | €CSInLoop› | €CSInCase›
		| €CSOKToExit› | €CSInIfThenElse›;

=TEX
=SML
fun €check_3a›	 (state : CHECK_STATE, st : STMT) = (

	case  st of
		STExitWhen _ => (
			if state = CSInLoop
			then ()
			else checking_error "check_3a" 505065 []
	) |	_ =>	error "check_3a" 505076 []
);
=TEX
=SML
fun €check_3b›	 (state : CHECK_STATE, st : STMT) = (

	case  st of
		STExit => (
			if state = CSOKToExit
			then ()
			else checking_error "check_3b" 505066 []
	) |	_ =>	error "check_3b" 505077 []
);
=TEX
=SML
datatype €ENDING› = €EndsInReturn› | €EndsInOther›;
=TEX
=SML
fun €check_4a›	 (is_function_subprogram : bool) : unit = (

	if is_function_subprogram
	then
		()
	else
		checking_error "check_4a" 505078 []
);

fun €check_4b›	 (is_function_subprogram : bool,
		 	ends_in_return : ENDING) : unit = (

	if is_function_subprogram
	then
		case ends_in_return of
			EndsInReturn => (
		) |	EndsInOther =>
				checking_error "check_4b" 505079 []
	else	()
);
=TEX

=SML
fun €do_soundness_checks2›	(repl_function : LABEL -> REPLACEMENT OPT)
				(is_function_subprogram : bool)
				(statement : STATEMENT) : unit = (

let	val local_resolver = resolver repl_function;
	fun check_over_stmt (state : CHECK_STATE) (st : STMT) : ENDING = (

	case st of
			STNull => (	EndsInOther
		)| 	STImplicitNull => ( EndsInOther
		)|	STAssign {name,e} => ( EndsInOther
		)|	STSpecNoIvars {spec,label} => (
				check_over_statement state (local_resolver label)
		)|	STSemicolon (s1,s2) => (
				if state = CSOKToExit
				then
					(check_over_stmt CSInIfThenElse s1;
					check_over_stmt state s2)
				else
					(check_over_stmt state s1;
					check_over_stmt state s2)
		)|	STIfThenElse  {g,p,q,elsif} => (
				if not elsif andalso state = CSInLoop
				then	(check_over_stmt CSOKToExit p;
					check_over_stmt CSOKToExit q;
					EndsInOther)
				else	(check_over_stmt CSInIfThenElse p;
					check_over_stmt CSInIfThenElse q;
					EndsInOther)
		)|	STCase {e,s,others} => (
			let	val res =  map
				   (fn st1 => check_over_stmt CSInCase (#p st1)) s;
				val res1 = check_over_stmt CSInCase others;
			in
				if all (res1::res) (fn r => r = EndsInReturn)
				then	EndsInReturn
				else	EndsInOther
			end
		)|	STLoop {t,stmt} => (
				check_over_stmt CSInLoop stmt;
				EndsInOther
		)|	STNamedLoop {name,t,stmt} => (
				check_over_stmt CSInLoop stmt;
				EndsInOther
		)|	STWhile {name,g,loop} => (
				check_over_stmt CSInLoop (#stmt loop);
				EndsInOther
		)|	STForStatic {name,i,tmark,range,dir,loop} => (
				check_over_stmt CSInLoop (#stmt loop);
				EndsInOther
		)|	STForTmark {name,i,tmark,dir,loop} => (
				check_over_stmt CSInLoop (#stmt loop);
				EndsInOther
		)|	STExitWhen {g} => (
				check_3a (state, st);
				EndsInOther
		)|	STExit => (
				check_3b (state, st);
				EndsInOther
		)|	STRet {e} => (
				check_4a is_function_subprogram;
				EndsInReturn
		)|	STProcNoIvars (proc as {name,actuals}) => (
				EndsInOther
		)|	STKSlot {content,label} => (
				check_over_statement state (local_resolver label);
				EndsInOther
		)| 	STAnnotation _ => ( EndsInOther
		)| 	STPragma _ => ( EndsInOther
		)
	)
	and check_over_statement (state : CHECK_STATE)
					(statement : STATEMENT) = (
		case statement of
			SStmt s => (
				check_over_stmt state s
		) |	SSpecIvars ({spec,label}, st2) => (
				check_over_statement state (local_resolver label);
				check_over_stmt state st2
		) |	SLogCon (lc, st2) => (
				check_over_stmt state st2
		) |	SForNonStatic ({name,i,range,loop}, st2) => (
				check_over_stmt state (#stmt loop);
				check_over_stmt state st2
		) |	SProcIvars (proc as {name,actuals}, st2) => (
				check_over_stmt state st2
		)
	);
		val ends_in_return = check_over_statement CSTop statement;
	in
		check_4b (is_function_subprogram, ends_in_return);
		()
	end
);
=TEX
\subsection{Variable Capture Checks}

The following function is called from $add\_var\_env$ in \cite{ISS/HAT/DAZ/IMP507}.

=SML
fun €check_new_spark_ids› (cn_env : CN_ENV) (ids : ID list) = (
	let	fun aux (id::rest) = (
			case cn_env id of
				Value _ =>
					fail "check_new_spark_ids" 505074 [fn()=>id]
			|	Nil => aux rest
		) | aux [] = ();
	in
		if all_different ids
		then
			aux ids
		else
			fail "check_new_spark_ids" 505075 []
	end
);
=TEX
=SML
fun €check_new_z_id› (z_ids : Z_ID list) (z_id : Z_ID) : unit = (
	if z_id mem z_ids
	then
		fail "check_new_z_id" 505074 [fn()=>z_id]
	else	case (get_const_type o fst o dest_const o mk_z_gvar)
			(z_id, BOOL, []) of
				Value _ =>
					fail "check_new_z_id" 505074 [fn()=>z_id]
			|	Nil => ()
);
=TEX


\section{VERIFICATION CONDITIONS}
$cart\_prod$ and $fun\_decl$ are specified in
\cite[volume 1]{DRA/CIS/CSE3/TR/94/27/2.1}.
=SML
fun €fun_sig› (zpars : Z_EXP list, zret : Z_EXP) : Z_EXP= (
	case zpars of
		[] => zret
	|	[zpar] => z_tfun(zpar, zret)
	|	_ => z_tfun(z_many_cross zpars, zret)
);
=TEX
=SML
fun €par_tmark› (env : CN_ENV)
	({var_decl = {vars, tmark, ...}, ...} : PARAM_SPEC) : Z_ID list = (
	let	val zi = trans_id tmark;
	in	map (Combinators.K zi) vars
	end
);
=TEX
=SML
fun €var_sig› (env : CN_ENV) (zn : Z_ID) : Z_EXP = (
	case env zn of
		Value (_, EIEnvVar tmark) => zid env(trans_id tmark)
	|	Value (_, EIEnvAuxVar zdec) => snd(dest_z_dec zdec)
	|	_ => fail "var_sig" 505041 [fn()=>zn]
);
=TEX
=SML
fun €fun_decl_aux›
	((env, {name, formal_pars, return_type}, globals)
	: CN_ENV * INFORMAL_FUN * Z_ID list) : Z_DECL * TERM * TERM = (
	let	val zn = trans_id name;
		val z_ret_ty = zid env (trans_id return_type);
		val gdecs = map (var_sig env) globals;
		val tmarks = flat (map (par_tmark env) formal_pars);
		val pdecs = map (zid env) tmarks;
		val zexp = fun_sig(gdecs, fun_sig(pdecs, z_ret_ty));
		val t_zexp = (dest_z_power_type o type_of) zexp;
		val lvar = mk_z_lvar(zn, t_zexp, []);
		val gvar = mk_z_gvar(zn, t_zexp, []);
	in	(mk_z_dec([lvar], zexp), lvar, gvar)
	end
);
=TEX
We can defined $fun\_decl$ in terms of $fun\_decl\_aux$ by throwing away the second and third parts of the result value and currying the function.
=SML
fun €fun_decl›
	(env : CN_ENV)	({informal_fun, globals, ...} : FORMAL_FUN) : Z_DECL = (
	let	val (d, _, _) = fun_decl_aux(env, informal_fun, globals);
	in	d
	end
);
=TEX
=SML
fun €vc_local_decls› (seqs : SEQUENT list,
	{formal_body_flag, fun_flag,
		in_scope as {vc_vars, vc_pars, vc_log_cons, vc_aux_vars, ...},
		wp_env = {fun_header, env, ...}, ...} : SPECLAB)
		: VC list = (
let
(*
=TEX
Every variable in $vc\_vars$ and its corresponding initial variable is introduced.
=SML
*)
	fun do_vars var = (
	let	val t_v = trans_id var;
	in
		[t_v, init_var t_v]
	end);
	fun var_decl_decls {vars, tmark} =
		trans_decl env {vars = (flat o (map do_vars)) vars, tmark=tmark};
(*
=TEX
The following function implements the check for input parameters specified in \cite[section 5.5]{DRA/CIS/CSE3/TR/94/27/2.1}.
=SML
*)
	fun param_spec_decls {var_decl, mode} = (
		case mode of
		MSparkIn => trans_decl env var_decl
		|	_ => var_decl_decls var_decl
	);
(*
=TEX
=SML
*)
	val decls = map var_decl_decls vc_vars @ map param_spec_decls vc_pars;

(*
=TEX
Add the logical constants (no initial versions).
=SML
*)
	val decls = vc_log_cons @ decls;
(*
=TEX
Add the auxiliary variables (with initial versions).
=SML
*)
	val vc_aux_vars_0 = (
			  map mk_z_dec
			o map (fn (ds, t) =>
					(map (	  mk_z_lvar
						o (fn (n,t,a) => (init_var n,t,a))
						o dest_z_lvar
					    ) ds, t))
			o map dest_z_dec)
		vc_aux_vars;
	val decls = vc_aux_vars @ vc_aux_vars_0 @ decls;
(*
=TEX
\raggedright{If $formal\_body\_flag$ and $fun\_flag$ are $true$, add a declaration of the function (obtained from $fun\_header$).}
=SML
*)
	val (decls, subs_fn) =
		if	formal_body_flag andalso fun_flag
			then	let 	val (d, l, g) = fun_decl_aux
		(env,fun_header, fun_globals env (#name fun_header));
				in	(d :: decls, subst [(l, g)])
				end
			else	(decls, Combinators.I);

	val seqs1 = map (fn (d,c) => (d, subs_fn c)) seqs;
(*
=TEX

Remove any declarations which are not needed by the sequent.
=SML
*)
	fun drop_vars vns vardecl = (
	let	val (vars, ty) = dest_z_dec vardecl;
		val vartys = map dest_var vars;
		val dvartys = vartys drop (fn (v,ty) => not (v mem vns));
	in
		case dvartys of
			[] =>	[]
		|	_ =>	[mk_z_dec (map mk_var dvartys, ty)]
	end);
	fun frees_in_seq (seq as (h, c)) = (
		map (fst o dest_var) (flat(frees c :: map frees h))
	);
	fun add_decls decs seq = (
	let	val ddecs = map ((drop_vars o frees_in_seq) seq) decs;
	in
		(flat ddecs, seq)
	end
	);
	val res = map (add_decls decls) seqs1;
in
	res
end
);
=TEX
=SML
fun €vcs› ((sl as {spec as {w, w0, pre, post},
			wp_env, ...}, st): SPECLAB * STATEMENT)
			: VC list = (

let	val side_effect = do_soundness_checks1 (sl, st);

	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val {wp, side} = wp (st, [[] Ù post1], wp_env);
	fun subs_c (h, c) = (
		h Ù subs_pred(c, w0, w)
	);
	val wp1 = map subs_c wp;
	val s = (pre1 %Longrightarrow% wp1) @
		(subs_pred(pre1, w, w0) %Longrightarrow% side);
in
	vc_local_decls(s, sl)
end
);
=TEX
=IGN
val (sl as 	{	spec ,
			wp_env,
			in_scope,...} : SPECLAB,
		st)= hd(! CNZGenerator.diag_vc_args);
val  {w, w0, pre, post} = spec;

val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val a = [[] Ù post1];
wp (st, a, wp_env);
(* assignments in wp *)
val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
val adjust_and_trans = (trans_exp env) o (adjust_exp env);
val adjust = adjust_exp env;
val exp = adjust_statement wp_env st;
(* now goto the appropriate function *)
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));

=TEX
\section{EPILOGUE}
=SML
end (* local ... in *);
end (* structure CNVCGenerator *);
=TEX
%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed505.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

=IGN

CNZGenerator.diag_vc_args;
CNVCGenerator.vcs (hd(!CNZGenerator.diag_vc_args));
use_file"wrk001";
val (sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st)= hd(! CNZGenerator.diag_vc_args);

