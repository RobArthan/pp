% @(#) 94/12/05 1.24 imp505.doc
=TEX
% pp -i zed505 -d zplay
% pp_list -d zplay vc_gen >zed505.th.doc
% doctex zed505 zed505.th
% texdvi zed505
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Verification Condition Generator}  %% Mandatory field
\def\TPPheadtitle{Verification Condition Generator}
\TPPref{ISS/HAT/DAZ/IMP505}  %% Mandatory field
\def\SCCSversion{1.24%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{94/12/05%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Informal}
\TPPtype{Specification}
%\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\R.D.~Arthan & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This is the implementation of the verification condition generator for the compliance tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.28] Initial Drafts.
\item[Issue 1.29] Changed signature of $check\_new\_z\_id$.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance tool verification condition generator. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Possible Enhancements}
None.

\pagebreak

\section{THE STRUCTURE $CNVCGenerator$}

=SML
infix 3 ô;
infix 4 %Longrightarrow%;
infix 5 cap;
=TEX
=SML
structure ÛCNVCGeneratorÝ : CNVCGenerator = struct
local
	open CaseIndependence;
	open CNTypes1 CNTypes2 CNParser CNTypes CNBasicDeclsAndExprs;
	open ZUserInterfaceSupport;
in
=TEX
\section{SUPPORTING FUNCTIONS}
When a construct is found for which is not supported formally, we choose to continue processing informally rather that halt the processing of the literate script. The local exception $VCInformal$ is raised if this condition is detected. This is caught by $vcs$ which returns an dummy VC is the exception has been raised. 
=SML
exception ÛVCInformalÝ;

fun Ûvc_go_informalÝ
		(s : string)
		(i : int)
		(fns : (unit -> string) list) : 'a = (
	comment s i fns;
	raise VCInformal
);
=TEX
$trans\_exp2$ catches the case where an attempt to translate an expression has failed due to a language feature being unsupported.
=SML
fun Ûtrans_exp2Ý (env : CN_ENV) (exp : EXP) : Z_EXP = (
	case trans_exp1 env exp of
		Value ze	=> ze
	|	Nil		=> raise VCInformal
);
=TEX
=SML
fun Ûadjust_exp2Ý (env : CN_ENV) (exp : EXP) : EXP = (
	case adjust_exp1 env exp of
		Value e		=> e
	|	Nil		=> raise VCInformal
);
=TEX
=SML
val Ûvc_dummy_seqÝ = ([],
	ñDummyVC "VC Generator encountered an unsupported language feature"®);
=TEX
\pagebreak
\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}
\subsection{Sequents}
=SML
fun (h : Z_PRED list) ô (c : Z_PRED) : SEQUENT = (h, c);

fun (h : Z_PRED) %Longrightarrow% (s : SEQUENT list) : SEQUENT list = (
	map (fn (h', c) => (h :: h', c)) s
);
=TEX
\pagebreak
\section{Substitutions}
=TEX
First we introduce the new flag.
=SML
val Ûcn_use_let_in_vcsÝ : bool ref = ref false;
val side_effect = new_flag
	{name = "cn_use_let_in_vcs",
	control = cn_use_let_in_vcs,
	check = fun_true,
	default = fun_false} handle Fail _ => ();
=TEX
For convenience in coding, we introduce a $list\_sub$ a general parallel substitution operator and use it to support the particular variants on substitution which are required.
=SML
fun Ûlist_subÝ ((p, xes) :Z_PRED * ((Z_ID * Z_EXP) list)) : Z_PRED = (
	if	!cn_use_let_in_vcs
	then	let	fun mk_def (x : Z_ID, e : Z_EXP) = (								(mk_var(x, type_of e), e)
			);
			fun not_wanted (x, e) = (
					not (is_free_in x p)
				orelse	x =$ e
			);
			val defs = map mk_def xes drop not_wanted;
		in	mk_let (defs, p)
		end
	else	let	fun mk_subs (x : Z_ID, e : Z_EXP) = (
				(e, mk_var(x, type_of e))
			);
			val p' = subst (map mk_subs xes) p;
			val back_to_z_conv = TRY_C(TOP_MAP_C (
				z_schema_pred_conv1 ORELSE_C
				z_Ê_conv1 ORELSE_C
				z_dec_rename‰s_conv));
		in	(snd o dest_eq o concl o back_to_z_conv) p'
		end
);
=TEX
=SML
fun ÛsubÝ ((p, x, e) :Z_PRED * Z_ID * Z_EXP) : Z_PRED = (
	list_sub(p, [(x, e)])
);
=TEX
=SML
fun Ûsubs_expÝ ((e, xs, ys) :Z_EXP * (Z_ID list) * (Z_ID list)) : Z_EXP = (
	let	val xys = combine xs ys;
		val ntys = map dest_var(frees e);
		fun s ((n, ty) :: more) (x, y) = (
			if	n = x
			then	(x, mk_var(y, ty)) :: s more (x, y)
			else	s more (x, y)
		) | s [] _ = [];
	in	list_sub(e, flat(map (s ntys) xys))
	end		
);
=TEX
=SML
fun Ûsubs_predÝ ((p, xs, ys) :Z_PRED * (Z_ID list) * (Z_ID list)) : Z_PRED = (
	subs_exp(p, xs, ys)
);
fun ÛsubseqÝ ((seql, x, e) :SEQUENT list * Z_ID * Z_EXP) : SEQUENT list = (
	map (fn (H, c) => map (fn p => sub(p, x, e)) H ô sub(c, x, e)) seql
);
=TEX
\pagebreak

\section{ABSTRACT SYNTAX OF SPARK STATEMENTS}\label{ASSPARK}

See \cite{ISS/HAT/DAZ/DTD502}.

\section{WEAKEST PRECONDITIONS}\label{WPS}
\subsection{Environments}\label{environments}
=TEX
\subsection{Other Preliminaries}\label{Preliminaries}
=TEX

\subsection{Null Statement}\label{wp-null}
=SML
fun ÛnullÝ ({a, ...} : WP_PARS) : RESULT = (
	{wp = a, side = []}
);
=TEX
\subsection{Assignment Statement}\label{wp-assignment}

The implementation of $simple\_assign$ works on an assignment where the expression on the rhs has already been converted to Z.
=SML
fun Ûsimple_assignÝ ({wp_env={env,...}, a, ...} : WP_PARS)
		(x : ID) (ze : Z_EXP) : RESULT = (
	{wp = subseq(a, trans_id x, ze), side = []}
)
=TEX
=SML
and Ûarray_assignÝ ({wp, a, wp_env as {env,...}} : WP_PARS)
			({prefix, index} : EXP INDEXED_COMP) (ze : Z_EXP) : RESULT = (
let	val name' = prefix;
	val e' = (z_override
			(trans_exp2 env prefix, z_set
			   [z_maplet (trans_exp2 env index, ze)]));
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', e')
end
)
=TEX
=SML
and Ûretrieve_type_markÝ (env : CN_ENV) (exp : EXP) : TMARK = (
let	val tmark = name_to_tmark exp;
in
	case env tmark of
	Value (_, EIEnvVar tmark') => tmark'
	|_ => fail "retrieve_type_mark" 505028 [fn()=>tmark] 
end
)
=TEX
=SML
and Ûrecord_assignÝ	({wp, a, wp_env as {env, ...}} : WP_PARS)
	({prefix, selector} : EXP SELECTED_COMP) (ze : Z_EXP) : RESULT = (
let	val name' = prefix;
	val tmark = retrieve_type_mark env prefix;
	val record_components = retrieve_record_components env tmark
		handle _ => fail "record_assign" 505027 [fn()=>tmark];
	fun do_comps sel = if sel = selector 
				then ze
				else trans_exp2 env 
					(ESelectedComp{prefix=prefix,selector=sel});
	val comps = map (fn (a,_) => do_comps a) record_components;
	val ze' = exp_rec_agg_pos_z env (tmark, comps);
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', ze')
end
)
=TEX
=SML
and ÛassignÝ (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ((name, ze) : EXP * Z_EXP)
			: RESULT = (
	case adjust_exp2 env name of
	EId id => simple_assign wp_pars id ze
	|EIndexedComp ic => array_assign wp_pars ic ze
	|ESelectedComp sc => record_assign wp_pars sc ze
	|_ => fail "assign" 505029 []
);
=TEX
\subsection{Specification Statement (No initial variables)}\label{wp-specification-no-ivars}
=SML
fun Ûspec_no_ivarsÝ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = [[] ô pre], side = post %Longrightarrow% a}
);
=TEX
=SML
fun Ûspec_no_ivars_emptyÝ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = ([] ô pre) :: (post %Longrightarrow% a), side = []}
);
=TEX
=SML
fun Ûspec_no_ivars_eitherÝ (wp : WP_PARS) (w : Z_ID list) ((pre, post) : Z_EXP * Z_EXP) 
		: RESULT = (
	if	w = []
	then	spec_no_ivars_empty wp (pre, post)
	else	spec_no_ivars wp (pre, post)
);
=TEX
\subsection{Semicolon}\label{wp-semicolon}
=SML
fun ÛsemicolonÝ ({wp, a, wp_env} : WP_PARS) ((p, q) : STMT * STMT)
			: RESULT = (
let	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val {wp = wp1, side = side1} = wp (SStmt p, wp2, wp_env);
in
	{wp = wp1, side = side1 @ side2}
end
);
=TEX
=IGN
val SStmt(STSemicolon (p,q)) = exp;
val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
val save_exp1 = exp;
val exp= SStmt q;
=TEX
\subsection{If Statement}\label{wp-if-then-else}
=SML
fun Ûif_then_elseÝ	({wp, a, wp_env as {env,...}} : WP_PARS)
			({g, p, q,...} : STMT IF_THEN_ELSE) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
	val wp = (z_eq(trans_exp2 env g, zid env "TRUE") %Longrightarrow% wp1) @
		(z_eq(trans_exp2 env g, zid env "FALSE") %Longrightarrow% wp2);
	val side = side1 @ side2;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Case Statement}\label{wp-case}
=SML
fun Ûtrans_case_choicesÝ (env : CN_ENV) (choices : CASE_CHOICE list) : Z_EXP = (
let	val adjust_and_trans = (trans_exp2 env) o (adjust_exp2 env);
	fun aux_range (ch::rest) = (
		case ch of
		CCCaseRange (DRRange(RRange{lo,hi})) =>
			z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
		|CCCaseRange (DRRange _) =>
			vc_go_informal "trans_case_choices" 508020 [] 
		|CCCaseRange (DRConstrained{range=RRange{lo,hi},...}) =>
			z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
		|CCCaseRange (DRConstrained _) =>
			vc_go_informal "trans_case_choices" 508020 []
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		CCCaseExp exp =>
			trans_exp2 env exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choices;
	val zsingles = z_set (aux_singles choices);
in
	z_many_union(zranges @ [zsingles])
end
);
=TEX
=SML
fun Ûcase_baseÝ ({wp, a, wp_env as {env,...}} : WP_PARS) (e : EXP)
			({choices, p} : STMT CASE_ALTERNATIVE)
			 : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt p, a, wp_env);
	val wp' = z_elem (trans_exp2 env e, trans_case_choices env choices)
			%Longrightarrow% wp1;
in	{wp = wp', side = side1}
end
);
=TEX
=SML
fun Ûcase_stepÝ (pars as {wp, a, wp_env as {env,...}} : WP_PARS)
		({e, s, others as STImplicitNull} : STMT CASE) : RESULT = (
	case s of
	[] =>
		fail "case_step" 505030 []
	| [alt] =>
		case_base pars e alt
	| ({choices, p} :: s') => (
		let	val {wp = wp1, side = side1} =
				wp (SStmt p, a, wp_env);
			val {wp = wp2, side = side2} =
				case_step pars {e=e, s=s', others=others};
			val elm =
				z_elem (trans_exp2 env e, trans_case_choices env choices)
		in	{wp = (elm %Longrightarrow% wp1) @ wp2 , side = side1 @ side2}
		end)
) | case_step _ _ = (
	vc_go_informal "case_step" 505021 []
);
=TEX
Note that $case\_step$ is recursive and does the full job. 
But by analogy with the naming convention we chose to adopt for the
two case of specification statement in section \ref{wp-specification-no-ivars},
we define the following.
=SML
val Ûcase_eitherÝ : WP_PARS -> STMT CASE -> RESULT = case_step;
=TEX

\subsection{Undecorated Loop}\label{wp-loop}
=SML
fun ÛloopÝ ({a, ...} : WP_PARS) ({t, stmt} : STMT LOOP)
			: RESULT = (
let	val (pre1, post1) = case stmt of
		STSpecNoIvars {spec={pre, post, ...}, ...} => (
			(z_predexp_of_z_tm pre,z_predexp_of_z_tm post)
		) |_ => vc_go_informal "loop" 505022 [];
	val wp = [[] ô pre1];
	val side = case t of
			Value till => [[post1] ô pre1] @
				((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => [[post1] ô pre1];
in
	{wp = wp, side = side}
end
);
=TEX
=SML
fun Ûnamed_loopÝ (wp_pars : WP_PARS) ({t, stmt, ...} : STMT NAMED_LOOP)
			: RESULT = (
	loop wp_pars {t=t, stmt=stmt}
);
=TEX
\subsection{While Loop}\label{wp-while-loop}
=SML
fun Ûcn_whileÝ	({a, wp_env={env, ...}, ...} : WP_PARS)
		({g, loop={t,stmt}, ...} : STMT WHILE) : RESULT = (
let	val {w, w0, pre, post} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => vc_go_informal "loop" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val wp = ([z_eq(trans_exp2 env g, zid env "TRUE")] ô pre1) ::
			(z_eq(trans_exp2 env g, zid env "FALSE")
				%Longrightarrow% a);
	val side = case t of
			Value till => (post1 %Longrightarrow% wp) @
					((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => (post1 %Longrightarrow% wp);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-static}
=SML
fun Ûfor_staticÝ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, range, dir, loop = {t, stmt}, ...} : STMT FOR_STATIC) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else vc_go_informal "for_static" 505023 [];
	val {lo, hi} = case range of
			RRange {lo, hi} => {lo=adjust_exp2 env lo, hi=adjust_exp2 env hi}
			|RRangeAttr _ =>
				vc_go_informal "for_static" 505020 [];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => vc_go_informal "for_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp2 env lo;
	val zhi = trans_exp2 env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till) %Longrightarrow% a)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zhi), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}
=SML
fun Ûfor_tmarkÝ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, dir, loop = {t, stmt}, ...} : STMT FOR_TMARK) : RESULT = (
let	val side = if dir = LDForwards
			then ()
			else vc_go_informal "for_tmark" 505023 [];
	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => vc_go_informal "for_tmark" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = zid env (trans_id tmark ^^ zfst);
	val zhi = zid env (trans_id tmark ^^ zlst);
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zlo)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				(z_predexp_of_z_tm till) %Longrightarrow% a
			) | Nil => [];
	val side = [[z_noteq(zid env zi, zhi), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zhi) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=SML
fun Ûexit_whenÝ ({a, wp_env={till, env, ...}, ...} : WP_PARS)
		({g} : EXIT_WHEN)
			 : RESULT = (
let	val zg = trans_exp2 env g;
	val wp = ([z_eq(zg, zid env "TRUE")] ô till) ::
		(z_eq(zg, zid env "FALSE") %Longrightarrow% a);
in	{wp = wp, side = []}
end
);
=TEX
\subsection{Exit}\label{wp-exit}
=SML
fun Ûcn_exitÝ ({wp_env={till, ...},...} : WP_PARS) : RESULT = (
	{wp = [[] ô till], side = []}
);
=TEX
\subsection{Return}\label{wp-return}
=TEX
$conv\_var\_decl$ is implemented in \cite{ISS/HAT/DAZ/IMP508}.
=SML
fun Ûcn_returnÝ ({wp, a, wp_env= {env, fun_header={name, formal_pars, ...},
			return, ...}} : WP_PARS)
		({e} : RETURN) : RESULT = (
let	val zfun = zid env (trans_id name);
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_pars;
	val ids = flat (map (fn {vars, ...} => vars) var_decls);
	val zargs = map (fn id => zid env (trans_id id)) ids;
	val wp = [[z_eq(z_fun_call(zfun, zargs), trans_exp2 env e)] ô return];
	val side = [];
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}
=SML
fun Ûproc_call_specÝ (env : CN_ENV)
		({actuals, ...} : (AGG_CHOICE,EXP) PROC_CALL)
		({name, formal_ids, spec={w, w0, pre, post}, ...} : FORMAL_PROC)
			: (Z_EXP * Z_EXP) = (
let	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
	val names = ((map trans_id) o flat
				o (map (fn {vars, ...} => vars))) var_decls;
	val exps = case actuals of
			APositional exps => map (adjust_exp2 env) exps
			|ANamed nas => map (adjust_exp2 env)
					(named_assocs_to_exps names nas);
	fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) = (name, trans_exp2 env actual);
	val exp_names = combine exps names
		handle _ => fail "proc_call_spec" 505026 [fn()=>name];
	val subs_list = map subs exp_names;
in
	(list_sub(pre1, subs_list),list_sub(post1, subs_list))
end
);
=TEX
=IGN

val {formal_ids, spec as {w, w0, pre, post, label}, ...}=fp;
val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
val names = flat (map (fn {vars, ...} => vars) var_decls);
val exps = case actuals of
			APositional exps => map (adjust_exp2 env) exps
			|ANamed nas => map (adjust_exp2 env) (named_assocs_to_exps names nas);
fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) = (name, trans_exp2 env actual);
val exp_names = combine exps names
		handle _ => fail "proc_call_spec" 505026 [fn()=>name];
val subs_list = map subs exp_names;

=TEX
In the following, we call $spec\_no\_ivars\_either$ directly rather than call $wp$ because the pre- and post-conditions have already been converted to $Z\_PRED$s. 
=SML
fun Ûproc_call_no_ivarsÝ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
		(pc as {name, actuals} : (AGG_CHOICE,EXP) PROC_CALL)
	
		: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp as {spec = {w, ...}, ...} = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_no_ivars" 505031 [fn()=>name];
in
	spec_no_ivars_either {wp = wp, a = a, wp_env = wp_env}
		w (proc_call_spec env pc fp)
end
);
=TEX
=IGN
val {formal_procs, env, ...} = wp_env;
val SStmt (STProcNoIvars (pc as {name, actuals})) = exp;
fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);


=TEX
\subsection{Specification Statement (with Initial Variables)}\label{wp-spec-ivars}
=SML
fun Ûspec_ivarsÝ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(((pre, post), q) : (Z_EXP * Z_EXP) * STMT) : RESULT = (
let	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] ô pre];
	val side = (post %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}
=SML
fun Ûfor_non_staticÝ (pars as {wp, a, wp_env as {env, ...}} : WP_PARS)
			(({i, range, loop = {t, stmt}, ...}, q) : FOR_NON_STATIC * STMT)
			 : RESULT = (
let	val {lo, hi} = case range of
			RRange {lo, hi} => {lo=adjust_exp2 env lo, hi=adjust_exp2 env hi}
			|RRangeAttr _ =>
				vc_go_informal "for_non_static" 505020 []
	val {pre, post, w, w0, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => vc_go_informal "for_non_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp2 env lo;
	val zhi = trans_exp2 env hi;
	val zop = z_add;
	val zleft = zid env zi;
	val zright = z_num 1;
	val zlo0 = subs_exp (zlo, w, w0);
	val zhi0 = subs_exp(zhi, w, w0);
	val zran = z_elem(zid env zi, z_rng (zlo0, zhi0));
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zlo)] @
		(z_greater(zlo, zhi) %Longrightarrow% wp1);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till )%Longrightarrow% wp1)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zhi0), post1] ô 
			sub(pre1, zi, z_bin_exp(zleft, zop, zright))] @
				(sub(post1, zi, zhi0) %Longrightarrow% wp1) @
				till_part;
in
	{wp = wp, side = side}
end
);
=TEX

\subsection{Logical Constant}\label{wp-log-con}
=SML
fun Ûanalyse_log_conÝ (pre : Z_PRED) : (Z_EXP * Z_PRED) = (
let	val (eqtm, pre1) = dest_z_± pre handle Fail _ => (pre, mk_z_true);
	val (_, e) = dest_z_eq eqtm;
in
	(e, pre1)
end
handle _ => fail "analyse_log_con" 505024 []
);
=TEX
=SML
fun Ûlog_conÝ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(({x, t, spec as {w, w0, pre, post}, ...}, q)
			: LOG_CON * STMT)
		: RESULT = (

let	val (e, pre1) = analyse_log_con (z_predexp_of_z_tm pre);
	val {wp = wp1, side = side1} = wp (SStmt q, a, wp_env);
	val wp = [[] ô sub(pre1, x, e)];
	val zvar_ty = (dest_z_power_type o type_of o z_predexp_of_z_tm) t;
	val env' = fn id =>	if id = x
				then Value (zvar_ty, EIEnvVar "__none")
				else env id;
	val side = z_eq(zid env' x, subs_exp (e,w,w0)) %Longrightarrow%
		((z_predexp_of_z_tm post) %Longrightarrow% wp1) @ side1;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
=SML
fun Ûproc_call_ivarsÝ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
	((pc as {name, actuals}, q) : (AGG_CHOICE, EXP) PROC_CALL * STMT)
					: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_ivars" 505031 [fn()=>name];
in
	spec_ivars {wp = wp, a = a, wp_env = wp_env}
			(proc_call_spec env pc fp, q)
end
);
=TEX
\subsection{Adjusting Statements}

=SMLPLAIN
fun Ûany_initial_variablesÝ (z_tm : Z_TM) : bool = (
let	val pred = z_predexp_of_z_tm z_tm;
	val names = map (fst o dest_var) (frees pred);
	fun is_init_var s =
		case (rev o explode) s of
			"0" :: "‰" :: _ =>	true
		|	_ => 			false;
	
in
	any names (fn s => is_init_var s)
end
);
=TEX
=SML
fun Ûis_static_for_loopÝ (wp : WP_ENV) (fs : STMT FOR_STATIC) : bool = (
let	fun no_vars_in_exp exp = (
		case (term_vars o (trans_exp2 (#env wp))) exp of
			[] =>	true
		|	_ =>	false
	);
in
	case (#range fs) of
	RRange {lo, hi} =>
		no_vars_in_exp lo andalso no_vars_in_exp hi
	|RRangeAttr _ => true
end
);
=TEX
=SML
fun Ûadjust_statementÝ (wp : WP_ENV) (st as SStmt s : STATEMENT)
		: STATEMENT = (

	case s of
		STSpecNoIvars sni =>
			if	any_initial_variables (#post (#spec sni))
			then	SSpecIvars (sni, STImplicitNull)
			else	st
	|	STForStatic (fs as {name,i,range,loop, ...}) =>
			if	is_static_for_loop wp fs
			then	st
			else	SForNonStatic ({	name=name,
							i=i,
							range=range,
							loop=loop
						}, STImplicitNull)
	|	STProcNoIvars piv => (
		let	fun find_spec id ((fproc::rest) : FORMAL_PROC list) = (
				if (#name fproc) = id
				then	Value (#spec fproc)
				else	find_spec id rest
			) | find_spec id [] = Nil;
		in
			case find_spec (#name piv) (#formal_procs wp) of
			Value sp => (
				if	any_initial_variables (#post sp)
				then	SProcIvars (piv, STImplicitNull)
				else	st
			) |	Nil => st
		end
	) |	STSemicolon (st1, st2) => (
			case adjust_statement wp (SStmt st1) of
				SStmt st1' => SStmt s
			|	SSpecIvars (si, _) => SSpecIvars (si, st2)
			|	SForNonStatic (fns, _) => SForNonStatic (fns, st2)
			|	SProcIvars (piv, _) => SProcIvars (piv, st2)
			|	SLogCon lc => SLogCon lc
			)
	|	_ => st

) | adjust_statement _ other = other;
=TEX
=IGN
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));
=TEX
\subsection{$wp$}\label{wp}

=SML
fun ÛwpÝ ((st, a, wp_env) : STATEMENT * SEQUENT list * WP_ENV) : RESULT = (
let	val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
	val adjust_and_trans = (trans_exp2 env) o (adjust_exp2 env);
	val adjust = adjust_exp2 env;
in	case adjust_statement wp_env st of
		SStmt STNull => null pars
	|	SStmt STImplicitNull => null pars
	|	SStmt (STAssign {name, e}) =>
			assign pars (name, adjust_and_trans e)
	|	SStmt (STSpecNoIvars {spec={pre, post, w, ...}, ...}) => 
			spec_no_ivars_either pars w
				(z_predexp_of_z_tm pre, z_predexp_of_z_tm post)
	|	SStmt (STSemicolon x) => semicolon pars x
	|	SStmt (STIfThenElse {g, p, q, elsif}) =>
			if_then_else pars {g=adjust g, p=p, q=q, elsif=elsif}
	|	SStmt (STCase {e, s, others}) =>
			case_either pars {e=adjust e, s=s, others=others}
	|	SStmt (STLoop x) => loop pars x
	|	SStmt (STNamedLoop x) => named_loop pars x
	|	SStmt (STWhile {g, loop, name}) =>
			cn_while pars {g=adjust g, loop=loop, name=name}
	|	SStmt (STForStatic x) => for_static pars x
	|	SStmt (STForTmark x) => for_tmark pars x
	|	SStmt (STExitWhen {g}) => exit_when pars {g=adjust g}
	|	SStmt (STExit) => cn_exit pars
	|	SStmt (STRet {e}) => cn_return pars {e=adjust e}
	|	SStmt (STProcNoIvars x) => proc_call_no_ivars pars x
	|	SStmt (STKSlot x) => {wp=[],side=[]}
	|	SSpecIvars ({spec={pre, post, ...}, ...}, q) =>
			spec_ivars pars ((z_predexp_of_z_tm pre, z_predexp_of_z_tm  post), q)
	|	SForNonStatic x => for_non_static pars x
	|	SLogCon x => log_con pars x
	|	SProcIvars x => proc_call_ivars pars x
end
);
=TEX
\pagebreak
\section{APPLICATION OF CHECKS}


\subsection{Useful Printing Functions in Lieu of CNSparkOutput}
=SML
fun Ûfmt_idÝ (n : ID) : string = CaseIndependence.get_external_name n;
fun Ûfmt_id_listÝ ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
=TEX
\subsection{The Error Printing Function}
=SML
fun Ûchecking_errorÝ (msg : string) (n : int) (ins) = (
	diag_line (get_error_message 505050 []);
	fail msg n ins
);
=TEX
\subsection{The Checks}
=SML
fun Ûcheck_1_aÝ (id : ID list, speclab : SPECLAB) = (
	let	val w = (#w o #spec) speclab;
	in
		if id diff w = []
		then ()
		else if w = []
		then	checking_error "check_1_a" 505060
			[	fn () => fmt_id_list id]
		else	checking_error "check_1_a" 505064
			[	fn () => fmt_id_list w,
				fn () => fmt_id_list id]
	end
);
=TEX
=SML
fun Ûcheck_1_bÝ (speclab : SPECLAB) = (
	if #formal_body_flag speclab
	then ()
	else checking_error "check_1_b" 505061 []
);
=TEX
=SML
fun Ûcheck_1_cÝ (speclab : SPECLAB) = (
	if #till_flag speclab
	then ()
	else checking_error "check_1_c" 505062 []
);
=TEX
=SML
fun Ûcheck_1_dÝ (p : ID, speclab : SPECLAB) = (
	if any ((#formal_procs o #in_scope) speclab)
			(fn fp => p = #name fp) 
	then ()
	else checking_error "check_1_d" 505063 []
);
=TEX



\subsection{Anti-Aliasing Checks}

=SML
fun ÛcapÝ (a, b) = (a cup b) diff (a diff b) diff (b diff a);
=TEX

=SML
fun Ûfree_vars_zpredÝ (zp : Z_PRED) : Z_ID list = (
	 (map ((fn (n,_,_) => n) o dest_z_lvar) o frees) zp
);
=TEX
=SML
fun Ûname_to_entire_variable_nameÝ (e : EXP) : TMARK = (
	case e of
		EId id => (
			id
	) |	ESelectedComp {prefix, selector} => (
			name_to_entire_variable_name prefix
	) |	EIndexedComp{prefix, index} => (
			name_to_entire_variable_name prefix
	) |	_ => error "name_to_entire_variable_name" 505080 []
);
=TEX
=SML
fun Ûfind_formal_procÝ (speclab : SPECLAB) (name : ID) : FORMAL_PROC = (
	find 
	((#formal_procs o #in_scope) speclab)
		(fn p => #name p = name)
		handle Fail _ => checking_error "find_formal_proc" 505067
						[fn () => name]
);
=TEX	
=SML
fun Ûanti_aliasing_parsÝ (fp : FORMAL_PROC) (pc : (AGG_CHOICE,EXP)PROC_CALL)
				: ID list * ID list = (
	let	val formal_ids = #formal_ids fp;
		val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
		val formals = flat (map (fn {vars, ...} => vars) var_decls);
		val pre = (z_predexp_of_z_tm o #pre o #spec) fp;
		val post = (z_predexp_of_z_tm o #post o #spec) fp;
		val trans_formals = map trans_id formals;
		val trans_globals = (free_vars_zpred pre cup
				free_vars_zpred post) diff trans_formals;
	in
		(formals, trans_globals)
	end
);
=TEX
The following function makes a pair-wise list of actual parameters (EXPs) with their modes (which are extracted from the corresponding $formal\_proc$).
=SML
fun Ûanti_aliasing_actuals_modesÝ (speclab : SPECLAB)
				(proc : (AGG_CHOICE, EXP) PROC_CALL) :
			(EXP * MODE) list = (
	let	val name = #name proc;
		val formal_proc = find_formal_proc speclab (#name proc);
		val formal_ids = #formal_ids formal_proc;
		val var_decls_modes = map (fn {var_decl, mode,...}
					=> (var_decl,mode)) formal_ids;
		val vars_modes = map
				(fn ({vars, ...},mode) => (vars,mode))
				 var_decls_modes;
		fun do_formals_modes (id::rest, m) = (
			(id, m)::do_formals_modes (rest, m)
		) | do_formals_modes _ = [];
		val (formals,modes) = (split o flat o map do_formals_modes)
						vars_modes;
		val actuals = (case #actuals proc of
				APositional exps => exps
			|	ANamed nas => named_assocs_to_exps formals nas)
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
		val actuals_modes = combine actuals modes
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
	in	combine actuals modes
	end
);
=TEX
=SML
fun Ûanti_aliasing_check_1Ý (proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val set = map fst (actuals_modes drop
				(fn am => not (snd am = MSparkInOut orelse
						 snd am = MSparkOut)));
	in
		if any set (fn EId x => false | _ => true)
		then
		let	val exprs = set drop (fn EId x => true | _ => false);
			val plural = if length exprs > 1 then "s" else "";
		in
			checking_error "anti_aliasing_check_1" 505069
				[fn() => fmt_id (#name proc)]
		end
		else (* OK *) ()
	end
);
=TEX
=SML

=TEX
=SML
fun Ûanti_aliasing_check_2Ý (speclab : SPECLAB)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val formal_proc = find_formal_proc speclab name;
		val (_, trans_globals) = anti_aliasing_pars formal_proc proc;
		val set = map fst (actuals_modes drop
				(fn am => not (	snd am = MSparkInOut orelse
							snd am = MSparkOut)));
		val trans_set = map (fn
				EId id => trans_id id
				|_	=> fail "anti_aliasing_check_2" 505070
						[fn()=>name]) set;
		val inter_set = trans_set cap trans_globals;
		val plural = if length inter_set > 1 then "s" else "";
	in
		if inter_set = []
		then (* OK *) ()
		else	checking_error "anti_aliasing_check_2" 505071
				[	fn()=> plural,
					fn()=> fmt_id name,
					fn()=> fmt_id_list inter_set]
	end
);
=TEX
=SML
local
	fun aux (fv::rest) = (
		if is_z_lvar fv
		then
			((fn (n,_, _) => n) o dest_z_lvar) fv::aux rest
		else
			aux rest
	) | aux _ = [];
in
fun Ûvars_expÝ (cn_env : CN_ENV) (exp : EXP) : ID list = (
	(aux o frees o trans_exp cn_env) exp
);
end (* local ... in *);
=TEX
=SML
fun Ûanti_aliasing_check_3Ý (speclab : SPECLAB)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val formal_proc = find_formal_proc speclab name;
		val (_, trans_globals) = anti_aliasing_pars formal_proc proc;
		val w = (#w o #spec) formal_proc;
		val actuals = map fst actuals_modes;
		val ids = list_cup (map (vars_exp ((#env o #wp_env) speclab))
					actuals);
		val trans_ids = map trans_id ids;
		val inter_set = trans_globals cap w cap trans_ids;
		val plural = if length inter_set > 1 then "s" else "";
	in	if inter_set = []
		then (* OK *) ()
		else checking_error "anti_aliasing_check_3" 505072
				[	fn()=> plural,
					fn()=> fmt_id name,
					fn()=> fmt_id_list inter_set]
	end
);
=TEX
=SML
fun Ûanti_aliasing_check_4Ý (speclab : SPECLAB)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val formal_proc = find_formal_proc speclab (#name proc);
		val (_, trans_globals) = anti_aliasing_pars formal_proc proc;
		val cn_env = (#env o #wp_env) speclab;
		fun pair_wise (a_m_1::a_m_2::rest) = (
		let	val (actual1, mode1) = a_m_1;
			val (actual2, mode2) = a_m_2;
			val ve1 = vars_exp cn_env actual1;
			val ve2 = vars_exp cn_env actual2;
			val inter_set = ve1 cap ve2;
		in
			if not (inter_set = [])
			then	if mode1 = MSparkIn andalso mode2 = MSparkIn
				then (* OK *) ()
				else let val plural = if length inter_set > 1
							then "s" else "";
				     in
					checking_error "anti_aliasing_check_4"
					505073 [	fn()=> plural,
							fn()=> fmt_id name,
							fn()=> fmt_id_list inter_set]
				     end
			else	(* OK *) ()
		end
		) | pair_wise _ = ();
	in	 pair_wise actuals_modes
	end
);

=TEX
=SML
fun Ûanti_aliasing_checkÝ (speclab : SPECLAB,
				proc : (AGG_CHOICE,EXP)PROC_CALL) = (
	let	val actuals_modes = anti_aliasing_actuals_modes speclab proc
			handle Fail _ =>
			fail "anti_aliasing_check" 505068 [fn()=> #name proc];
	in
		anti_aliasing_check_1 proc actuals_modes;
		anti_aliasing_check_2 speclab proc actuals_modes;
		anti_aliasing_check_3 speclab proc actuals_modes;
		anti_aliasing_check_4 speclab proc actuals_modes
	end
);
=TEX
\subsection{Invoking the Checks}
=SML
fun Ûdo_soundness_checks1Ý ((speclab, statement): SPECLAB * STATEMENT) : unit = (

let	fun pass_over_stmt (st : STMT) = (

	case st of
			STNull => (
		)| 	STImplicitNull => (
		)|	STAssign {name,e} => (
				check_1_a
				([name_to_entire_variable_name name], speclab)
		)|	STSpecNoIvars {spec={w,w0,pre,post},label} => (
				check_1_a (w, speclab)
		)|	STSemicolon (s1,s2) => (
					(pass_over_stmt s1;
					pass_over_stmt s2)
		)|	STIfThenElse  {g,p,q,elsif} => (
					(pass_over_stmt p;
					pass_over_stmt q)
		)|	STCase {e,s,others} => (
				map (fn st1 => pass_over_stmt (#p st1)) s;
				pass_over_stmt others
		)|	STLoop {t,stmt} => (
				pass_over_stmt stmt
		)|	STNamedLoop {name,t,stmt} => (
				pass_over_stmt stmt
		)|	STWhile {name,g,loop} => (
				pass_over_stmt (#stmt loop)
		)|	STForStatic {name,i,tmark,range,dir,loop} => (
				pass_over_stmt (#stmt loop)
		)|	STForTmark {name,i,tmark,dir,loop} => (
				pass_over_stmt (#stmt loop)
		)|	STExitWhen {g} => (
		)|	STExit => (
				check_1_c speclab
		)|	STRet {e} => (
				check_1_b speclab
		)|	STProcNoIvars (proc as {name,actuals}) => (
				check_1_d (name, speclab);
				anti_aliasing_check (speclab, proc)
		)|	STKSlot {content,label} => (
		)
	);
	fun pass_over_statement (statement : STATEMENT) = (
		case statement of
			SStmt s => (
				pass_over_stmt s
		) |	SSpecIvars (si, st2) => (
				pass_over_stmt st2
		) |	SLogCon (lc, st2) => (
				pass_over_stmt st2
		) |	SForNonStatic ({name,i,range,loop}, st2) => (
				pass_over_stmt (#stmt loop);
				pass_over_stmt st2
		) |	SProcIvars (proc as {name,actuals}, st2) => (
				check_1_d (name, speclab);
				anti_aliasing_check (speclab, proc);
				pass_over_stmt st2
		)
	);
	in	pass_over_statement statement
	end
);
=TEX
=SML
fun ÛresolverÝ (repl_function : LABEL -> REPLACEMENT OPT) (label : LABEL)
			: STATEMENT = (
	let	val repl = case repl_function label of
					Nil => (
						UnReplaced (RSStatement, "")
				) |	Value repl => repl;
	in
		case repl of
			ReplaceComp _ => (	SStmt STImplicitNull
		) |    ReplacePPart _ => (	SStmt STImplicitNull
		) |    ReplaceVPart _ => (	SStmt STImplicitNull
		) |    ReplaceDecl _ => (	SStmt STImplicitNull
		) |    RefineStat {statement, ...} => (	statement
		) |    ReplaceStat {statement, ...}  => (	statement
		) |    UnReplaced _ => (	SStmt STImplicitNull
		)	
	end
);
=TEX
=SML
datatype ÛCHECK_STATEÝ = ÛCSTopÝ | ÛCSInLoopÝ | ÛCSInCaseÝ
		| ÛCSOKToExitÝ | ÛCSInIfThenElseÝ;

=TEX
=SML
fun Ûcheck_3aÝ	 (state : CHECK_STATE, st : STMT) = (

	case  st of
		STExitWhen _ => (
			if state = CSInLoop
			then ()
			else checking_error "check_3a" 505065 []
	) |	_ =>	error "check_3a" 505076 []
);
=TEX
=SML
fun Ûcheck_3bÝ	 (state : CHECK_STATE, st : STMT) = (

	case  st of
		STExit => (
			if state = CSOKToExit
			then ()
			else checking_error "check_3b" 505066 []
	) |	_ =>	error "check_3b" 505077 []
);
=TEX
=SML
datatype ÛENDINGÝ = ÛEndsInReturnÝ | ÛEndsInOtherÝ;
=TEX
=SML
fun Ûcheck_4aÝ	 (is_function_subprogram : bool) : unit = (

	if is_function_subprogram
	then
		()
	else
		checking_error "check_4a" 505078 []
);

fun Ûcheck_4bÝ	 (is_function_subprogram : bool,
		 	ends_in_return : ENDING) : unit = (

	if is_function_subprogram
	then
		case ends_in_return of
			EndsInReturn => (
		) |	EndsInOther =>
				checking_error "check_4b" 505079 []
	else	()
);
=TEX

=SML
fun Ûdo_soundness_checks2Ý	(repl_function : LABEL -> REPLACEMENT OPT)
				(is_function_subprogram : bool)
				(statement : STATEMENT) : unit = (

let	val local_resolver = resolver repl_function;
	fun check_over_stmt (state : CHECK_STATE) (st : STMT) : ENDING = (

	case st of
			STNull => (	EndsInOther
		)| 	STImplicitNull => ( EndsInOther
		)|	STAssign {name,e} => ( EndsInOther
		)|	STSpecNoIvars {spec,label} => (
				check_over_statement state (local_resolver label)
		)|	STSemicolon (s1,s2) => (
				if state = CSOKToExit
				then
					(check_over_stmt CSInIfThenElse s1;
					check_over_stmt state s2)
				else
					(check_over_stmt state s1;
					check_over_stmt state s2)
		)|	STIfThenElse  {g,p,q,elsif} => (
				if not elsif andalso state = CSInLoop
				then	(check_over_stmt CSOKToExit p;
					check_over_stmt CSOKToExit q;
					EndsInOther)
				else	(check_over_stmt CSInIfThenElse p;
					check_over_stmt CSInIfThenElse q;
					EndsInOther)
		)|	STCase {e,s,others} => (
			let	val res =  map
				   (fn st1 => check_over_stmt CSInCase (#p st1)) s;
				val res1 = check_over_stmt CSInCase others;
			in
				if all (res1::res) (fn r => r = EndsInReturn)
				then	EndsInReturn
				else	EndsInOther
			end
		)|	STLoop {t,stmt} => (
				check_over_stmt CSInLoop stmt;
				EndsInOther
		)|	STNamedLoop {name,t,stmt} => (
				check_over_stmt CSInLoop stmt;
				EndsInOther
		)|	STWhile {name,g,loop} => (
				check_over_stmt CSInLoop (#stmt loop);
				EndsInOther
		)|	STForStatic {name,i,tmark,range,dir,loop} => (
				check_over_stmt CSInLoop (#stmt loop);
				EndsInOther
		)|	STForTmark {name,i,tmark,dir,loop} => (
				check_over_stmt CSInLoop (#stmt loop);
				EndsInOther
		)|	STExitWhen {g} => (
				check_3a (state, st);
				EndsInOther
		)|	STExit => (
				check_3b (state, st);
				EndsInOther
		)|	STRet {e} => (
				check_4a is_function_subprogram;
				EndsInReturn
		)|	STProcNoIvars (proc as {name,actuals}) => (
				EndsInOther
		)|	STKSlot {content,label} => (
				check_over_statement state (local_resolver label);
				EndsInOther

		)
	)
	and check_over_statement (state : CHECK_STATE)
					(statement : STATEMENT) = (
		case statement of
			SStmt s => (
				check_over_stmt state s
		) |	SSpecIvars ({spec,label}, st2) => (
				check_over_statement state (local_resolver label);
				check_over_stmt state st2
		) |	SLogCon (lc, st2) => (
				check_over_stmt state st2
		) |	SForNonStatic ({name,i,range,loop}, st2) => (
				check_over_stmt state (#stmt loop);
				check_over_stmt state st2
		) |	SProcIvars (proc as {name,actuals}, st2) => (
				check_over_stmt state st2
		)
	);
		val ends_in_return = check_over_statement CSTop statement;
	in
		check_4b (is_function_subprogram, ends_in_return);
		()
	end
);
=TEX
\subsection{Variable Capture Checks}

The following function is called from $add\_var\_env$ in \cite{ISS/HAT/DAZ/IMP507}.

=SML
fun Ûcheck_new_spark_idsÝ (cn_env : CN_ENV) (ids : ID list) = (
	let	fun aux (id::rest) = (
			case cn_env id of
				Value _ =>
					fail "check_new_spark_ids" 505074 [fn()=>id]
			|	Nil => aux rest
		) | aux [] = ();
	in
		if all_different ids
		then
			aux ids
		else
			fail "check_new_spark_ids" 505075 []
	end
);
=TEX
=SML
fun Ûcheck_new_z_idÝ (z_ids : Z_ID list) (z_id : Z_ID) : unit = (
	if z_id mem z_ids
	then
		fail "check_new_z_id" 505074 [fn()=>z_id]
	else	case (get_const_type o fst o dest_const o mk_z_gvar)
			(z_id, BOOL, []) of
				Value _ =>
					fail "check_new_z_id" 505074 [fn()=>z_id]
			|	Nil => ()
);
=TEX


\section{VERIFICATION CONDITIONS}
$cart\_prod$ and $fun\_decl$ are specified in
\cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}.
=SML
fun Ûcart_prodÝ (env : CN_ENV) (par_specs : PARAM_SPEC list) : Z_EXP = (
	let	fun aux (par_spec : PARAM_SPEC) = (
			(zid env o trans_id o #tmark o #var_decl)
			par_spec
		);
	in	case par_specs of
			[]	=>	error "cart_prod" 505009 []
		|	[ps]	=>	aux ps
		|	several =>	mk_z_¸ (map aux par_specs)
	end
);
=TEX
=SML
fun Ûfun_decl_auxÝ
	((env, {name, formal_pars, return_type})
	: CN_ENV * INFORMAL_FUN) : Z_DECL * TERM * TERM = (
	let	val zn = trans_id name;
		val z_ret_ty = zid env (trans_id return_type);
		val zexp = (
			case formal_pars of
				[] => z_ret_ty
			|	non_empty => z_tfun(cart_prod env formal_pars,
						 z_ret_ty));
		val lvar = mk_z_lvar(zn, (dest_z_power_type o type_of) zexp, []);
		val gvar = mk_z_gvar(zn, (dest_z_power_type o type_of) zexp, []);
	in	(mk_z_dec([lvar], zexp), lvar, gvar)
	end
);
=TEX
We can defined $fun\_decl$ in terms of $fun\_decl\_aux$ by throwing away the second and third parts of the result value and currying the function.
=SML
val Ûfun_declÝ = curry ((fn (d, _, _) => d) o fun_decl_aux);
=TEX
=SML
fun Ûvc_local_declsÝ (seqs : SEQUENT list,
	{formal_body_flag, fun_flag,
		in_scope as {vc_vars, vc_pars, vc_log_cons, vc_aux_vars, ...},
		wp_env = {fun_header, env, ...}, ...} : SPECLAB)
		: VC list = (
let
(*
=TEX
Every variable in $vc\_vars$ and its corresponding initial variable is introduced.
=SML
*)
	fun do_vars var = (
		[trans_id var, trans_id var ^ "‰0"]
	);
	fun var_decl_decls {vars, tmark} =
		trans_decl env {vars = (flat o (map do_vars)) vars, tmark=tmark};
(*
=TEX
The following function implements the check for input parameters specified in \cite[section 5.5]{DRA/CIS/CSE3/TR/94/27/1.2}.
=SML
*)
	fun param_spec_decls {var_decl, mode} = (
		case mode of
		MSparkIn => trans_decl env var_decl
		|	_ => var_decl_decls var_decl
	);
(*
=TEX
=SML
*)
	val decls = map var_decl_decls vc_vars @ map param_spec_decls vc_pars;

(*
=TEX
Add the logical constants (no initial versions).
=SML
*)
	val decls = vc_log_cons @ decls;
(*
=TEX
Add the auxiliary variables (with initial versions).
=SML
*)
	val vc_aux_vars_0 = (
			  map mk_z_dec
			o map (fn (ds, t) =>
					(map (	  mk_z_lvar
						o (fn (n,t,a) => (n^"‰0",t,a))
						o dest_z_lvar
					    ) ds, t))
			o map dest_z_dec)
		vc_aux_vars;
	val decls = vc_aux_vars @ vc_aux_vars_0 @ decls;
(*
=TEX
\raggedright{If $formal\_body\_flag$ and $fun\_flag$ are $true$, add a declaration of the function (obtained from $fun\_header$).}
=SML
*)
	val (decls, subs_fn) =
		if	formal_body_flag andalso fun_flag
			then	let 	val (d, l, g) = fun_decl_aux
								(env,fun_header);
				in	(d :: decls, subst [(l, g)])
				end
			else	(decls, Combinators.I);

	val seqs1 = map (fn (d,c) => (d, subs_fn c)) seqs;
(*
=TEX

Remove any declarations which are not needed by the sequent.
=SML
*)
	fun drop_vars vns vardecl = (
	let	val (vars, ty) = dest_z_dec vardecl;
		val vartys = map dest_var vars;
		val dvartys = vartys drop (fn (v,ty) => not (v mem vns));
	in
		case dvartys of
			[] =>	[]
		|	_ =>	[mk_z_dec (map mk_var dvartys, ty)]
	end);
	fun frees_in_seq (seq as (h, c)) = (
		map (fst o dest_var) (flat(frees c :: map frees h))
	);
	fun add_decls decs seq = (
	let	val ddecs = map ((drop_vars o frees_in_seq) seq) decs;
	in
		(flat ddecs, seq)
	end
	);
	val res = map (add_decls decls) seqs1;
in
	res
end
);
=TEX
=SML
fun ÛvcsÝ ((sl as {spec as {w, w0, pre, post},
			wp_env, ...}, st): SPECLAB * STATEMENT)
			: VC list = (

let	val side_effect = do_soundness_checks1 (sl, st);

	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val {wp, side} = wp (st, [[] ô post1], wp_env);
	fun subs_c (h, c) = (
		h ô subs_pred(c, w0, w)
	);
	val wp1 = map subs_c wp;
	val s = (pre1 %Longrightarrow% wp1) @
		(subs_pred(pre1, w, w0) %Longrightarrow% side);
in
	vc_local_decls(s, sl)
end
	handle VCInformal =>
		[([], vc_dummy_seq)]
);
=TEX
=IGN
val (sl as 	{	spec as {spec={w, w0, pre, post}, ...},
			wp_env,
			in_scope,...},
		st)= hd(! CNZGenerator.diag_vc_args);

val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val a = [[] ô post1];
wp (st, a, wp_env);
(* assignments in wp *)
val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
val adjust_and_trans = (trans_exp2 env) o (adjust_exp2 env);
val adjust = adjust_exp2 env;
val exp = adjust_statement wp_env st;
(* now goto the appropriate function *)
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));

=TEX
\section{EPILOGUE}
=SML
end (* local ... in *);
end (* structure CNVCGenerator *);
=TEX
%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed505.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

=IGN

CNZGenerator.diag_vc_args;
CNVCGenerator.vcs (hd(!CNZGenerator.diag_vc_args));
use_file"wrk001";
val (sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st)= hd(! CNZGenerator.diag_vc_args);

