% %Z% $Date: 2001/11/07 13:43:12 $ $Revision: 1.80 $ $RCSfile: imp505.doc,v $
=TEX
% pp -i zed505 -d zplay
% pp_list -d zplay vc_gen >zed505.th.doc
% doctex zed505 zed505.th
% texdvi zed505
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Verification Condition Generator}  %% Mandatory field
\def\TPPheadtitle{Verification Condition Generator}
\TPPref{ISS/HAT/DAZ/IMP505}  %% Mandatory field
\def\SCCSversion{1.52%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{97/07/18%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Informal}
\TPPtype{Specification}
%\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\R.D.~Arthan & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This is the implementation of the verification condition generator for the compliance tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.28] Initial Drafts.
\item[Issue 1.29] Changed signature of $check\_new\_z\_id$.
\item[Issues 1.30-1.34] Fixes/palliatives for DRA bugs (batch 1) 8, 9, 10, 11, 19.
\item[Issue 1.35] Palliative for bug 10 (batch 1)
\item[Issue 1.36] Fixes for DRA bugs (batch 2) 1, 2.
\item[Issue 1.37] Enhancements 1, 6 and 20 (annotations, pragmas and arbitrary replacements catered for).
\item[Issue 1.38] New treatment of records.
\item[Issue 1.39] Bug fixing (batch 2 bug 13).
\item[Issue 1.40] Rationalised error reporting.
\item[Issue 1.41] Fixed problem adjusting case selectors.
\item[Issue 1.42] Update references.
\item[Issue 1.43] Fixed DRA bug 12 (V0.6).
\item[Issue 1.44] Fixed DRA bug 4 (V0.6).
\item[Issue 1.45] Fixed DRA bug 2 (V0.6).
\item[Issue 1.46] Fixed DRA bug 15 (V0.6).
\item[Issue 1.47] Fixed \LaTeX{} error.
\item[Issue 1.48] k-slots as annotations.
\item[Issue 1.49] Fixing $analyse\_log\_con$.
\item[Issue 1.50] Improved message 505063.
\item[Issue 1.51] Improved use of substitutions and common  subterms.
\item[Issue 1.51-1.54] IUCT WP 4.
\item[Issue 1.55] Check 1(a) now applies to procedure calls too.
\item[Issue 1.56] Added new check 16.
\item[Issue 1.57] Updated references.
\item[Issue 1.58] Update for new INTEGER type.
\item[Issue 1.59] Prototyping enhancement R5 --- Initial Variables in Conditionals.
\item[Issue 1.60] Prototyping enhancement R3 --- Assignment to Record Components.
\item[Issue 1.61-1.64] Prototyping enhancement R2: Multiple Logical Constant Definitions.
\item[Issue 1.65] Check on initial variables in pre-conditions added.
\item[Issue 1.66] CTLE II enhancement R1/2 --- ``others'' in case statements.
\item[Issues 1.67, 1.68] CTLE II enhancement R1/3 --- reverse loops.
\item[Issues 1.69] CTLE II R1/5 --- range attributes as ranges.
\item[Issues 1.70] CTLE II R1/9 --- SPARK 83 attributes.
\item[Issue 1.71] CTLE II R1/9 --- SPARK 83 attributes.
\item[Issue 1.72] CTLE II R1/11 --- nested packages.
\item[Issue 1.73] Fixes to CTLE II R1/5 and R1/6.
\item[Issue 1.74] Investigating performance problem.
\item[Issue 1.75] Perfomance enhancement for type-checking of specification statements.
\item[Issue 1.76] Added option to compactify pre- and post-conditions.
\item[Issues 1.77,1.78] Enhancement R0003 --- record and array components as exported parameters.
\item[Issues 1.79-1.81] Fixed {\it var\_sig} and the use of {\it adjust\_exp} etc. in the anti-aliasing checks.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the compliance tool verification condition generator. It is written in response to the detailed design to be found in \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD505}.
\subsection{Possible Enhancements}
None.

\pagebreak

\section{THE STRUCTURE $CNVCGenerator$}
=SML
infix 3 ô;
infix 4 %Longrightarrow%;
infix 5 cap;
=TEX
=SML
structure ÛCNVCGeneratorİ : CNVCGenerator = struct
local
	open CaseIndependence;
	open CNTypes1 CNTypes2 CNParser CNTypes CNBasicDeclsAndExprs;
	open ZUserInterfaceSupport ZGeneratedConstants TypeInference;
in
=TEX
\section{SUPPORTING FUNCTIONS}
In version 0.6 and onwards we follow the new policy of not attempting to recover when a construct cannot be handled formally.
The special exception $VCInformal$ and associated functions are therefore no longer required.
=TEX
The following function decorates a string with a subscript ``0'' and is used to give the initial version of a variable name.
=SML
fun Ûinit_varİ (name : string) : string = name ^ "‰0";
=TEX
The following functions are used to construct a type inference context for use when the specification statement of a procedure is type checked.
=SML
fun v_v0 (in_mode : bool) (ty : TYPE) (v : ID) : TERM list = (
		if	in_mode
		then	[mk_var(v, ty)]
		else	[mk_var(init_var v, ty), mk_var(v, ty)]
);
fun ti_context_of_formal_ids (env : CN_ENV) ([] : PARAM_SPEC list)
		: TERM list = []
|  ti_context_of_formal_ids env ({var_decl as {vars, tmark}, mode} :: more) = (
	let	val ty = dest_z_power_type (type_of (zid env (trans_id tmark)));
		val inmode = case mode of MSparkIn => true | _ => false;
	in	flat (map (v_v0 inmode ty) vars)
		@ ti_context_of_formal_ids env more
	end	handle Fail _ => fail "vcs" 508051 [fn()=>tmark]
);
=TEX
\section{STORAGE OF Z TERMS}
=TEX
First we introduce the new flag.
=SML
val Ûcn_compactify_termsİ : bool ref = ref true;
val side_effect = new_flag
	{name = "cn_compactify_terms",
	control = cn_compactify_terms,
	check = fun_true,
	default = fun_true} handle Fail _ => ();
=TEX
Now we can define {\it z\_quote}:
=SML
val Ûz_quoteİ : TERM * Unification.EXTYPE OPT -> Z_TM = (fn (tm, ty_opt) =>
	ZTmQuotation(if !cn_compactify_terms then compact_term tm else tm, ty_opt)
);
=TEX
\pagebreak
\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}
\subsection{Sequents}
=SML
fun (h : Z_PRED list) ô (c : Z_PRED) : SEQUENT = (h, c);

fun (h : Z_PRED) %Longrightarrow% (s : SEQUENT list) : SEQUENT list = (
	map (fn (h', c) => (h' term_grab h, c)) s
);

=TEX
=SML
fun Ûadd_hypsİ ([] : Z_PRED list, s : SEQUENT list) : SEQUENT list = s
|    add_hyps (h::more, s) = h %Longrightarrow% add_hyps (more, s);
=TEX
\pagebreak
\section{Substitutions}
=TEX
First we introduce the new flag.
=SML
val Ûcn_use_let_in_vcsİ : bool ref = ref false;
val side_effect = new_flag
	{name = "cn_use_let_in_vcs",
	control = cn_use_let_in_vcs,
	check = fun_true,
	default = fun_false} handle Fail _ => ();
=TEX
For convenience in coding, we introduce $list\_sub$, a general parallel substitution operator and use it to support the particular variants on substitution which are required.
=SML
fun Ûlist_subİ ((p, xes) :Z_PRED * ((Z_ID * Z_EXP) list)) : Z_PRED = (
	if	!cn_use_let_in_vcs
	then	let	fun mk_def (x : Z_ID, e : Z_EXP) = (
					(mk_var(x, type_of e), e)
			);
			fun not_wanted (x, e) = (
					not (is_free_in x p)
				orelse	x =$ e
			);
			val defs = map mk_def xes drop not_wanted;
		in	mk_let (defs, p)
		end
	else	let	fun mk_subs (x : Z_ID, e : Z_EXP) = (
				(e, mk_var(x, type_of e))
			);
			val isubs1 = (map mk_subs xes);
			val isubs2 = isubs1 drop (fn (a, b) => (a =$ b));
			val p' = var_subst isubs2 p;
			val back_to_z_conv = TRY_C(TOP_MAP_C (
				z_schema_pred_conv1 ORELSE_C
				z_Ê_conv1 ORELSE_C
				z_dec_rename‰s_conv));
		in	(snd o dest_eq o concl o back_to_z_conv) p'
		end
);
=TEX
=SML
fun Ûsubİ ((p, x, e) :Z_PRED * Z_ID * Z_EXP) : Z_PRED = (
	list_sub(p, [(x, e)])
);
=TEX
=SML
fun Ûsubs_expİ ((e, xs, ys) :Z_EXP * (Z_ID list) * (Z_ID list)) : Z_EXP = (
	let	val xys = combine xs ys;
		val ntys = map dest_var(frees e);
		fun s ((n, ty) :: more) (x, y) = (
			if	n = x
			then	(x, mk_var(y, ty)) :: s more (x, y)
			else	s more (x, y)
		) | s [] _ = [];
	in	list_sub(e, flat(map (s ntys) xys))
	end		
);
=TEX
=SML
fun Ûsubs_predİ ((p, xs, ys) :Z_PRED * (Z_ID list) * (Z_ID list)) : Z_PRED = (
	subs_exp(p, xs, ys)
);
fun Ûsubseqİ ((seql, x, e) :SEQUENT list * Z_ID * Z_EXP) : SEQUENT list = (
	map (fn (H, c) => map (fn p => sub(p, x, e)) H ô sub(c, x, e)) seql
);
=TEX
\pagebreak

\section{ABSTRACT SYNTAX OF SPARK STATEMENTS}\label{ASSPARK}

See \cite{ISS/HAT/DAZ/DTD502}.

\section{WEAKEST PRECONDITIONS}\label{WPS}
\subsection{Environments}\label{environments}
=TEX
\subsection{Other Preliminaries}\label{Preliminaries}
=TEX

\subsection{Null Statement}\label{wp-null}
=SML
fun Ûnullİ ({a, ...} : WP_PARS) : RESULT = (
	{wp = a, side = []}
);
=TEX
\subsection{Assignment Statement}\label{wp-assignment}
=TEX
{\it z\_record\_update} has some tricky type instantiation
to do (the problem is that the order (and number) of the generic parameters
does not correspond one-to-one with the binding components, because
binding components that shared a type mark in the type declaration have just
one generic parameter).
=SML
fun Ûz_record_updateİ (ztmark : Z_ID, sel : ID, zpfx : Z_EXP, e : Z_EXP) : Z_EXP = (
	let	val fun_name = ztmark ^ "u" ^ sel;
		val ty = case get_const_type(ZTypesAndTermsSupport.bind_gvar_name fun_name) of
				Value t => t
			|	_ => fail "z_record_update" 505028 [];
		val (gty, rty) = dest_­_type ty;
		val us = map mk_u (dest_z_tuple_type gty);
		val fun_exp = mk_z_gvar(fun_name, rty, us);
		val arg_exp = mk_z_tuple[zpfx, e];
		val (arg_ty, res_ty) = case dest_z_tuple_type
					(dest_z_power_type (type_of fun_exp)) of
					[ty1, ty2] => (ty1, ty2)
				|	_ => fail "z_record_update" 505028 [];
		val ty_map = type_match (type_of arg_exp) arg_ty
				handle Fail _ => fail "z_record_update" 505028 [];
	in	mk_z_app(inst [] ty_map fun_exp, arg_exp)
	end
);
=TEX
The implementation of $simple\_assign$ works on an assignment where the expression on the rhs has already been converted to Z.
=SML
fun Ûsimple_assignİ ({wp_env={env,...}, a, ...} : WP_PARS)
		(x : ID) (ze : Z_EXP) : RESULT = (
	{wp = subseq(a, trans_id x, ze), side = []}
)
(*
=TEX
=SML
*)
and Ûarray_assignİ ({wp, a, wp_env as {env,...}} : WP_PARS)
			({prefix, index as EArrayAggPos{comps, tmark as Nil}} : EXP INDEXED_COMP) (ze : Z_EXP) : RESULT = (
let	val name' = prefix;
	val e' = (z_override
			(trans_exp env prefix, z_set
			   [z_maplet (z_tuple(map (trans_exp env) comps), ze)]));
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', e')
end
) | array_assign _ _ _ = (
	fail "array_assign" 508056 []
)
(*
=TEX
=SML
*)
and  Ûrecord_assignİ	({wp, a, wp_env as {env, ...}} : WP_PARS)
	({prefix, selector} : EXP SELECTED_COMP) (ze : Z_EXP) : RESULT = (
let	val zprefix = trans_exp env prefix;
	val side = dest_z_schema_type(type_of zprefix)
			handle Fail _ => fail "record_assign" 505027 [];
	val name' = prefix;
	val tmark = tmark_of_prefix env zprefix
			handle Fail _ => fail "record_assign" 505028 [];
	val ze' = z_record_update(tmark, selector, zprefix, ze); 
in
	assign {wp = wp, a = a, wp_env = wp_env} (name', ze')
end
)
(*
=TEX
=SML
*)
and Ûassignİ (wp_pars as {wp_env as {env, ...}, ...} : WP_PARS) ((name, ze) : EXP * Z_EXP)
			: RESULT = (
	case name of
	EId id => simple_assign wp_pars id ze
	|EIndexedComp ic => array_assign wp_pars ic ze
	|ESelectedComp sc => record_assign wp_pars sc ze
	|_ => fail "assign" 505029 []
);
=TEX
\subsection{Specification Statement (No initial variables)}\label{wp-specification-no-ivars}
=SML
fun Ûspec_no_ivarsİ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = [[] ô pre], side = post %Longrightarrow% a}
);
=TEX
=SML
fun Ûspec_no_ivars_emptyİ ({a, ...} : WP_PARS) ((pre, post) : Z_EXP * Z_EXP)
			: RESULT = (
	{wp = ([] ô pre) :: (post %Longrightarrow% a), side = []}
);
=TEX
=SML
fun Ûspec_no_ivars_eitherİ (wp : WP_PARS) (w : Z_ID list) ((pre, post) : Z_EXP * Z_EXP) 
		: RESULT = (
	if	w = []
	then	spec_no_ivars_empty wp (pre, post)
	else	spec_no_ivars wp (pre, post)
);
=TEX
\subsection{Semicolon}\label{wp-semicolon}
=SML
fun Ûsemicolonİ ({wp, a, wp_env} : WP_PARS) ((p, q) : STATEMENT * STATEMENT)
			: RESULT = (
let	val {wp = wp2, side = side2} = wp (q, a, wp_env);
	val {wp = wp1, side = side1} = wp (p, wp2, wp_env);
in
	{wp = wp1, side = side1 @ side2}
end
);
=TEX
=IGN
val (STSemicolon (p,q)) = exp;
val {wp = wp2, side = side2} = wp (SStmt q, a, wp_env);
val save_exp1 = exp;
val exp= q;
=TEX
\subsection{If Statement}\label{wp-if-then-else}
=SML
fun Ûif_then_elseİ	({wp, a, wp_env as {env,...}} : WP_PARS)
			({g, p, q,...} : STATEMENT IF_THEN_ELSE) : RESULT = (
let	val {wp = wp1, side = side1} = wp (p, a, wp_env);
	val {wp = wp2, side = side2} = wp (q, a, wp_env);
	val g' = trans_exp env g;
	val wp = (z_eq(g', zid env "TRUE") %Longrightarrow% wp1) @
		(z_eq(g', zid env "FALSE") %Longrightarrow% wp2);
	val side = side1 @ side2;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Case Statement}\label{wp-case}
=SML
fun Ûadjust_choicesİ (env : CN_ENV) (choices : CASE_CHOICE list) : CASE_CHOICE list = (
	case choices of
		[] => []
	|	(ch as CCCaseRange _)::rest => ch :: adjust_choices env rest
	|	(ch as CCCaseExp exp):: rest => (
			let	val n = name_to_tmark exp;
			in
				case env n of
					Value (_, EIEnvOtherType) => (
			CCCaseRange(DRConstrained{range=RRange {
				lo=EAttribute {attribute_desig=ADAttrib "FIRST",prefix=exp},
				hi=EAttribute {attribute_desig=ADAttrib "LAST", prefix=exp}},
				tmark=n})
				) |	_ => CCCaseExp exp
			end :: adjust_choices env rest
	)
);
=TEX
=SML
fun Ûtrans_case_choicesİ (env : CN_ENV) (in_choices : CASE_CHOICE list) : Z_EXP = (
let	val choices = adjust_choices env in_choices;
	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	fun aux_range (ch::rest) = (
		case ch of
		CCCaseRange (DRRange range) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
			end		
		|CCCaseRange (DRConstrained{range,...}) =>
			let	val {lo, hi} = dest_range range;
			in	z_rng(adjust_and_trans lo, adjust_and_trans hi)::aux_range rest
			end		
		|_ => aux_range rest
	) | aux_range _ = [];
	fun aux_singles (ch::rest) = (
		case ch of
		CCCaseExp exp =>
			adjust_and_trans exp::aux_singles rest
		|_ => aux_singles rest
	) | aux_singles _ = [];
	val zranges = aux_range choices;
	val zsingles = z_set (aux_singles choices);
in
	z_many_union(zranges @ [zsingles])
end
);
=TEX
=SML
fun Ûcase_baseİ ({wp, a, wp_env as {env,...}} : WP_PARS) (e : EXP)
			({choices, p} : STATEMENT CASE_ALTERNATIVE)
			 : RESULT * Z_EXP = (
let	val {wp = wp1, side = side1} = wp (p, a, wp_env);
	val zchoices = trans_case_choices env choices;
	val wp' = z_elem (trans_exp env e, zchoices)
			%Longrightarrow% wp1;
in	({wp = wp', side = side1}, zchoices)
end
);
=TEX
{\it case\_step} expects to be called by {\it case\_others} and ignores
the ``others'' part.
=SML
fun Ûcase_stepİ (pars as {wp, a, wp_env as {env,...}} : WP_PARS)
		({e, s, others} : STATEMENT CASE) : RESULT * Z_EXP list = (
	case s of
	[] =>
		fail "case_step" 505030 []
	| [alt] =>
		let	val (res, ze) = case_base pars e alt;
		in	(res, [ze])
		end
	| ({choices, p} :: s') =>
		let	val {wp = wp1, side = side1} =
				wp (p, a, wp_env);
			val ({wp = wp2, side = side2}, rest) =
				case_step pars {e=e, s=s', others=others};
			val zchoices = trans_case_choices env choices;
			val elm =
				z_elem (trans_exp env e, zchoices)
		in	({wp = (elm %Longrightarrow% wp1) @ wp2 , side = side1 @ side2},
			 zchoices :: rest)
		end
);
=TEX
Note that {\it case\_step} is recursive and does the full job for a case statement
without an others part. 
{\it case\_others} then acts as the main entry point for case statements,
calling {\it case\_step} to do do the non-others alternatives and then
handling the others part if present.
=SML
fun Ûcase_othersİ (pars as {wp, a, wp_env as {env,...}} : WP_PARS)
		(st as {e, others, ...} : STATEMENT CASE) : RESULT = (
	let	val (res as {wp = wp1, side = side1}, zchoices) = case_step pars st;
	in	case others of 
		STImplicitNull => res
	|	stmt =>
		let	val {wp = wp2, side = side2} = wp(others, a, wp_env);
			val wp = wp1 @ (z_notelem(trans_exp env e, z_many_union zchoices)
					%Longrightarrow% wp2);
			val side = side1 @ side2;
		in	{wp = wp, side = side}
		end
	end
);
=TEX

\subsection{Undecorated Loop}\label{wp-loop}
=SML
fun Ûloopİ ({a, ...} : WP_PARS) ({t, stmt} : STATEMENT LOOP)
			: RESULT = (
let	val (pre1, post1) = case stmt of
		STSpecNoIvars {spec={pre, post, ...}, ...} => (
			(z_predexp_of_z_tm pre,z_predexp_of_z_tm post)
		) |_ => fail "loop" 505022 [];
	val wp = [[] ô pre1];
	val side = case t of
			Value till => [[post1] ô pre1] @
				((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => [[post1] ô pre1];
in
	{wp = wp, side = side}
end
);
=TEX
=SML
fun Ûnamed_loopİ (wp_pars : WP_PARS) ({t, stmt, ...} : STATEMENT NAMED_LOOP)
			: RESULT = (
	loop wp_pars {t=t, stmt=stmt}
);
=TEX
\subsection{While Loop}\label{wp-while-loop}
=SML
fun Ûcn_whileİ	({a, wp_env={env, ...}, ...} : WP_PARS)
		({g, loop={t,stmt}, ...} : STATEMENT WHILE) : RESULT = (
let	val {w, w0, pre, post} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "loop" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val g' = trans_exp env g;
	val wp = ([z_eq(g', zid env "TRUE")] ô pre1) ::
			(z_eq(g', zid env "FALSE")
				%Longrightarrow% a);
	val side = case t of
			Value till => (post1 %Longrightarrow% wp) @
					((z_predexp_of_z_tm till) %Longrightarrow% a)
			|Nil => (post1 %Longrightarrow% wp);
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-static}
=SML
fun Ûfor_staticİ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, range, dir, loop = {t, stmt}, ...} : STATEMENT FOR_STATIC) : RESULT = (
let	val {lo, hi} = dest_range range;
	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp env lo;
	val zhi = trans_exp env hi;
	val (zinitial, zfinal, zop) =
		if dir = LDForwards then (zlo, zhi, z_add) else (zhi, zlo, z_minus);
	val zleft = zid env zi;
	val zright = z_num one;
	val zid_zi = zid env zi;
	val zran = z_elem (zid_zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zinitial)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till) %Longrightarrow% a)
			) | Nil => [];
	val side = [[zran, z_noteq(zid_zi, zfinal), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zfinal) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}
=SML
fun Ûfor_tmarkİ ({a, wp_env={env, ...}, ...} : WP_PARS)
	({i, tmark, dir, loop = {t, stmt}, ...} : STATEMENT FOR_TMARK) : RESULT = (
let	val {pre, post, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_tmark" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = zid env (trans_id tmark ^^ zfst);
	val zhi = zid env (trans_id tmark ^^ zlst);
	val (zinitial, zfinal, zop) =
		if dir = LDForwards then (zlo, zhi, z_add) else (zhi, zlo, z_minus);
	val zleft = zid env zi;
	val zright = z_num one;
	val zran = z_elem (zid env zi, z_rng (zlo, zhi));
	val z_bin_exp_theta = z_bin_exp (zleft, zop, zright);
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zinitial)] @
		(z_greater (zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				(z_predexp_of_z_tm till) %Longrightarrow% a
			) | Nil => [];
	val side = [[z_noteq(zid env zi, zfinal), post1] ô 
			sub(pre1, zi, z_bin_exp (zleft, zop, zright))] @
			(sub(post1, zi, zfinal) %Longrightarrow% a) @
			till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=SML
fun Ûexit_whenİ ({a, wp_env={till, env, ...}, ...} : WP_PARS)
		({g} : EXIT_WHEN)
			 : RESULT = (
let	val zg = trans_exp env g;
	val wp = ([z_eq(zg, zid env "TRUE")] ô till) ::
		(z_eq(zg, zid env "FALSE") %Longrightarrow% a);
in	{wp = wp, side = []}
end
);
=TEX
\subsection{Exit}\label{wp-exit}
=SML
fun Ûcn_exitİ ({wp_env={till, ...},...} : WP_PARS) : RESULT = (
	{wp = [[] ô till], side = []}
);
=TEX
\subsection{Return}\label{wp-return}
=TEX
$conv\_var\_decl$ is implemented in \cite{ISS/HAT/DAZ/IMP508}.
=SML
fun Ûcn_returnİ ({wp, a, wp_env= {env, fun_header={name, formal_pars, ...},
			return, ...}} : WP_PARS)
		({e} : RETURN) : RESULT = (
let	val zfun = trans_fun_name env name;
	val var_decls = map (fn {var_decl, ...} => var_decl) formal_pars;
	val ids = flat (map (fn {vars, ...} => vars) var_decls);
	val zargs = map (fn id => zid env (trans_id id)) ids;
	val wp = [[z_eq(z_fun_call(zfun, zargs), trans_exp env e)] ô return];
	val side = [];
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}
We need a mechanism for generating the names for the new Z variables
that stand for record or array components as exported actual parameters.
The function {\it param\_tmp\_name} does this.
The function constructs a list of names to be avoided from the type inference context.
This relies on the function {\it call\_vcs} in \cite{ISS/HAT/DAZ/IMP507} which
always puts all variables (including auxiliary variables and logical constants)
that are in scope in the VCs being calculated into the type inference
context.
The new variables are themselves added to the type inference context to handle
the situation where several new variables are needed in one sequence of statements
(to enable the new variables to be added to the type inference context, the
appropriate type must be passed in).

To confirm this approach, note that: {\it store\_vcs} in \cite{ISS/HAT/DAZ/IMP507}
fails if any VC contains free variables; moreover {\it call\_vcs} sets up the
type inference context using the same {\it SPECLAB} that it passes to the
function {\it vcs} below, which in turn uses that {\it SPECLAB} to derive
the local declarations to be added when the universal closure of each VC
is formed; so every variable that can appear
in a VC and so might clash with a new variable name generated here
must be in the type inference context; also 
\cite{ISS/HAT/DAZ/IMP507} arranges to type-check every post-condition
and this will ensuer that the new variable name cannot appear free in the
original sequent whose weakest pre-condition we are calculating.

=SML
val Ûparam_tmp_name_stemİ : Z_ID = "tmp_";
fun Ûmaybe_param_tmp_nameİ (n : Z_ID) : bool = (
	let	val tmp_size = size param_tmp_name_stem;
	in	substring(n, 0, tmp_size) = param_tmp_name_stem handle _ => false
	end
);
fun Ûparam_tmp_nameİ (ty : TYPE) : Z_ID = (
	let	fun filter av = (
			not (maybe_param_tmp_name av)
		);
		val ti_cxt_names = map ((fn (n, _, _) => n) o dest_z_lvar) (get_ti_context());
		val avoid = ti_cxt_names drop filter;
		fun find_next i = (
			let	val n = param_tmp_name_stem ^ string_of_int i;
			in	if	n mem avoid
				then	find_next (i+1)
				else	n
			end
		);
		val res = find_next 1;
	in	set_ti_context(mk_var(res, ty)::get_ti_context());
		res
	end
);
=IGN
param_tmp_name ”ú®;
param_tmp_name ”ú®;
set_ti_context (map (switch(curry mk_var) ”ú®) ["abc", "def", param_tmp_name”ú®]);
param_tmp_name ”ú®;
param_tmp_name ”ú®;
param_tmp_name ”ú®;
param_tmp_name ”ú®;
set_ti_context (map (switch(curry mk_var) ”ú®) ["abc", "def", "tmp_3", "tmp_4"]);
param_tmp_name ”ú®;
get_ti_context();
set_ti_context[];
=TEX
The work done for an individual parameter is sufficiently complicated to
merit a separate function.
This is passed the actual parameter expression together with the
all the information from the formal parameter specification for this parameter.
It returns two substitution lists: one to be applied to the pre-condition
and one to be applied to the post-condition.
It also returns, if necessary, a list of predicates giving
the domain conditions for the actual parameter (TBD) and,
if this is a record or array component actual parameter being
exported, the membership constraint giving the declaration for
the new Z variable that represents the parameter and the
assignment statement that gives the update to the actual parameter
to be considered as executed after the call.
=SML
fun Ûproc_call_paramİ (env : CN_ENV)
	(actual : EXP, formal : ID, tmark : TMARK, mode : MODE)

	: (Z_ID * Z_EXP) list * (Z_ID * Z_EXP) list * Z_PRED list * STATEMENT OPT = (
let	val	ntm as (n, tm) = (trans_id formal, trans_exp env actual);
	val	dcs = [] (* domain_conds tm *);
in	let	val (v, ty) = dest_var tm;
	in	([ntm], [ntm, (init_var n, mk_var(init_var v, ty))], dcs, Nil)
	end	handle Fail _ => (
			case mode of
				MSparkIn => ([ntm], [ntm], dcs, Nil)
			|	_ =>
				let	val ty = type_of tm;
					val nv = param_tmp_name (type_of tm);
					val cnstrnt = zid env (trans_id tmark);
					val nvtm = mk_z_lvar(nv, ty, []);
					val pred = z_mem(nvtm, cnstrnt);
					val stmt = Value (STAssign {
						name = actual,
						e = EAuxiliaryExp(z_quote(nvtm, Nil))});
				in	([ntm],
					 [(init_var n, tm), (n, nvtm)],
					 pred::dcs,
					 stmt)
				end
		)
	end
);
=TEX
In the following, the {\it Spec} of the specification is just given by the
pre- and post-condition as Z predicates. The frames are irrelevant to
the weakest pre-condition calculation.

=SML
fun Ûproc_call_specİ (env : CN_ENV)
		({actuals, ...} : (AGG_CHOICE,EXP) PROC_CALL)
		({name, formal_ids, spec={w, w0, pre, post}, ...} : FORMAL_PROC)
			: Z_PRED * Z_PRED * STATEMENT * Z_PRED list = (
let	val old_cxt = get_ti_context();
	val new_cxt = ti_context_of_formal_ids env formal_ids @ old_cxt;
	val side1 = set_ti_context new_cxt;
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val side2  = set_ti_context old_cxt;
	val var_decls = map #var_decl formal_ids;
	val names = ((map trans_id) o flat
				o (map #vars)) var_decls;
	val adj_actuals = case actuals of
			APositional exps => map (adjust_exp env) exps
			|ANamed nas => map (adjust_exp env)
					(named_assocs_to_exps names nas);
	fun do_params (acc as (presub, postsub, preds, st))
		(acts as (act::more_acts) : EXP list)
		({var_decl = {vars = frm::more_frms, tmark}, mode}::more_pss : PARAM_SPEC list)
	: (Z_ID * Z_EXP) list * (Z_ID * Z_EXP) list * Z_PRED list * STATEMENT = (
		let	val (prs, psts, prds, st_opt) =
			proc_call_param env (act, frm, tmark, mode);
		in	do_params
			(prs@presub, psts@postsub, prds term_union preds,
			(case st_opt of Nil => st
			 | Value asgn => STSemicolon(asgn, st)))
			more_acts
			({var_decl = {vars = more_frms, tmark = tmark},
			  mode = mode}::more_pss)
		end
	) | do_params acc acts ({var_decl = {vars = [], ...}, ...}::more_pss) = (
		do_params acc acts more_pss
	) | do_params acc [] [] = (
		acc
	) | do_params _ _ _ = (
		fail "proc_call_spec" 505026 [fn () => name]
	);
	val (presubs, postsubs, preds, st) =
		do_params ([], [], [], STNull) adj_actuals formal_ids;
in
	(list_sub(pre1, presubs), list_sub(post1, postsubs), st, preds)
end
);
=TEX
=IGN

val {formal_ids, spec as {w, w0, pre, post, label}, ...}=fp;
val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
val names = flat (map (fn {vars, ...} => vars) var_decls);
val exps = case actuals of
			APositional exps => map (adjust_exp env) exps
			|ANamed nas => map (adjust_exp env) (named_assocs_to_exps names nas);
fun subs (actual : EXP,	name : ID)
			: (Z_ID * Z_EXP) = (name, trans_exp env actual);
val exp_names = combine exps names
		handle _ => fail "proc_call_spec" 505026 [fn()=>name];
val subs_list = map subs exp_names;

=TEX
In the following, we call $spec\_no\_ivars\_either$ directly rather than call $wp$ because the pre- and post-conditions have already been converted to $Z\_PRED$s. 
=SML
fun Ûproc_call_no_ivarsİ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
		(pc as {name, actuals} : (AGG_CHOICE,EXP) PROC_CALL)
	
		: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp as {spec = {w, ...}, ...} = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_no_ivars" 505031 [fn()=>name];
	val (pre, post, asgns, preds) = proc_call_spec env pc fp;
	val xform = STSemicolon(
			STSpecNoIvars{spec = {w = [], w0=[],
					pre=z_quote(pre, Nil),
					post=z_quote(post, Nil)},
				label = ""}, asgns);
	val {wp = wp1, side = side1} = wp (xform, a, wp_env);
in	{wp = add_hyps(preds, wp1), side = add_hyps(preds, side1)}
end
);
=TEX
=IGN
val {formal_procs, env, ...} = wp_env;
val SStmt (STProcNoIvars (pc as {name, actuals})) = exp;
fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);


=TEX
\subsection{Specification Statement (with Initial Variables)}\label{wp-spec-ivars}
=SML
fun Ûspec_ivarsİ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	(((pre, post)) : (Z_EXP * Z_EXP)) : RESULT = (
let		val wp = [[] ô pre];
	val side = post %Longrightarrow% a;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}
=SML
fun Ûfor_non_staticİ (pars as {wp, a, wp_env as {env, ...}} : WP_PARS)
			({i, range, loop = {t, stmt}, dir, ...} : STATEMENT FOR_NON_STATIC)
			 : RESULT = (
let	val {lo, hi} = dest_range range;
	val {pre, post, w, w0, ...} = case stmt of
		STSpecNoIvars {spec, ...} => spec
		|_ => fail "for_non_static" 505022 [];
	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val zi = trans_id i;
	val zlo = trans_exp env lo;
	val zhi = trans_exp env hi;
	val zleft = zid env zi;
	val zright = z_num one;
	val zlo0 = subs_exp (zlo, w, w0);
	val zhi0 = subs_exp(zhi, w, w0);
	val (zinitial0, zfinal0, zop) =
		if dir = LDForwards then (zlo0, zhi0, z_add) else (zhi0, zlo0, z_minus);
	val zran = z_elem(zid env zi, z_rng (zlo0, zhi0));
	val wp = [[z_less_eq (zlo, zhi)] ô sub(pre1, zi, zinitial0)] @
		(z_greater(zlo, zhi) %Longrightarrow% a);
	val till_part = case t of
			Value till => (
				zran %Longrightarrow% ((z_predexp_of_z_tm till )%Longrightarrow% a)
			) | Nil => [];
	val side = [[zran, z_noteq(zid env zi, zfinal0), post1] ô 
			sub(pre1, zi, z_bin_exp(zleft, zop, zright))] @
				(sub(post1, zi, zfinal0) %Longrightarrow% a) @
				till_part;
in
	{wp = wp, side = side}
end
);
=TEX
\subsection{Logical Constant}\label{wp-log-con}
{\it analyse\_log\_con} picks apart the precondition to set up the actual
list of {\it log\_con\_def}s required for the weakest precondition calculation.
It is essentially the implementation of the predicate of the schema {\it Log\_Con}
in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

=SML
fun Ûanalyse_log_conİ (defs : LOG_CON_DEF list) (pre : Z_PRED) : (LOG_CON_DEF list * Z_PRED) = (
let	fun moan () = term_fail "analyse_log_con" 505024 [pre];
	fun get_def eq_x eq_e acc ((def as {x, t, e=_})::more) = (
		if	x = eq_x
		then	(acc@more, {x = x, t = t, e = eq_e})
		else	get_def eq_x eq_e (def::acc) more
	) | get_def _ _ _ [] = moan();
	fun check xv {x=_, t=_, e=e} = (
		if	xv term_mem frees e
		then	term_fail "analyse_log_con" 505025 [xv, e]
		else	()
	);
	fun do_defs acc p [] = (rev acc, p)
	|   do_defs acc p defs = (
		let	val (eqtm, p') = (dest_z_± p) handle Fail _ => (p, mk_z_true);
			val (eq_xv, eq_e) = (dest_z_eq eqtm) handle Fail _ => moan();
			val (defs', new_def) = get_def (fst(dest_var eq_xv)) eq_e [] defs;
			val acc' = (new_def::acc);
			val _ = map (check eq_xv) acc';
		in	do_defs acc' p' defs'
		end
	);
in
	do_defs [] pre defs
end);
=TEX
=SML
fun Ûz_log_con_defİ ((u, v): Z_ID list * Z_ID list) ({x, t=_, e} : LOG_CON_DEF) : Z_PRED = (
	let	val env' = fn id =>	if id = x
					then Value (type_of e, EIEnvVar "__none")
					else Nil;
	in	z_eq(zid env' x, subs_exp(e, u, v))
	end
);
=TEX
=SML
fun Ûlog_conİ ({wp, a, wp_env as {env, ...}} : WP_PARS)
	({defs, spec as {w, w0, pre, post}, ...} : LOG_CON)
		: RESULT = (

let	val (defs, pre1) = analyse_log_con defs (z_predexp_of_z_tm pre);
	val hyps = map (z_log_con_def ([], [])) defs;
	fun aux acc ((hyp, {x, t, e})::more) = (
		(acc ô z_mem(e, z_predexp_of_z_tm t)) :: aux (hyp::acc) more
	) | aux _ [] = [];
	val wp = [hyps ô pre1] @ aux [] (combine hyps defs);
	val side = add_hyps (map (z_log_con_def(w, w0)) defs,
		z_predexp_of_z_tm post %Longrightarrow% a);
in
	{wp = wp, side = side}
end);
=TEX
\subsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
=SML
fun Ûproc_call_ivarsİ ({wp, a, wp_env as {formal_procs, env, ...}} : WP_PARS)
	(pc as {name, actuals} : (AGG_CHOICE, EXP) PROC_CALL)
					: RESULT = (
let	fun is_it ({name = n, ...} : FORMAL_PROC) : bool = (name = n);
	val fp = find formal_procs is_it
		handle Fail _ =>
		fail "proc_call_ivars" 505031 [fn()=>name];
	val (pre, post, asgns, preds) = proc_call_spec env pc fp;
	val xform = STSemicolon(
			SSpecIvars{spec = {w = [], w0=[],
					pre=z_quote(pre, Nil),
					post=z_quote(post, Nil)},
				label = ""}, asgns);
	val {wp = wp1, side = side1} = wp (xform, a, wp_env);
in	{wp = add_hyps(preds, wp1), side = add_hyps(preds, side1)}
end
);
=TEX
\subsection{Adjusting Statements}
=SMLPLAIN
fun Ûany_initial_variables_z_predİ (pred : Z_PRED) : bool = (
let	val names = map (fst o dest_var) (frees pred);
	fun is_init_var s =
		case (rev o explode) s of
			"0" :: "‰" :: _ =>	true
		|	_ => 			false;
	
in
	any names (fn s => is_init_var s)
end
);
=SMLPLAIN
fun Ûany_initial_variables_z_tmİ (z_tm : Z_TM) : bool = (
	any_initial_variables_z_pred (z_predexp_of_z_tm z_tm)
);
=TEX
=SML
fun Ûis_static_for_loopİ (wp : WP_ENV) (fs : STATEMENT FOR_STATIC) : bool = (
let	fun no_vars_in_exp exp = (
		case (term_vars o (trans_exp (#env wp))) exp of
			[] =>	true
		|	_ =>	false
	);
	val {lo, hi} = dest_range(#range fs);
in	no_vars_in_exp lo andalso no_vars_in_exp hi
end
);
=TEX
In the following, most of the work is done in $adj\_stmt\_aux$.
Note that, $adj\_stmt\_aux$ always returns a statement which is just $SStmt\,s$ unless $is\_first$ is true.
$adj\_stmt\_aux$ calls itself recursively (via $check\_inner$) just to check the form of constituents of the various compound statement forms.

Initial variables may not appear in the pre-conditions of specifications
statements (see schema {\it Spec} in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}).
The check for this on a specification statement that refines some other
specification statement is made here.
The check on pre-conditions on specification statements being refined is made
in the function {\it vcs}.
The Z Generator (\cite{ISS/HAT/DAZ/IMP507}) makes dummy calls
to {\it vcs} as necessary to ensure that the check is then made on all specification
statements in the script. 
=SML
local
fun Ûadj_stmt_auxİ (wp : WP_ENV)
			(is_first : bool)
				(s : STATEMENT)
					: STATEMENT = (
let	val check_inner = adj_stmt_aux wp false;
	val adj_first = adj_stmt_aux wp true;
in
	case s of
		STSpecNoIvars sni =>
			if	any_initial_variables_z_tm (#pre (#spec sni))
			then	fail "adjust_statement" 505095 []
			else if	any_initial_variables_z_tm (#post (#spec sni))
			then	if	is_first
				then	SSpecIvars sni
				else	fail "adjust_statement" 505091 []
			else	s
	|	SLogCon lc =>
			if	any_initial_variables_z_tm (#pre (#spec lc))
			then	fail "adjust_statement" 505095 []
			else if	not is_first
			then	fail "adjust_statement" 505094 []
			else	s
	|	STForStatic (fs as {name,i,range,loop as {stmt, ...}, dir, tmark}) => (
			check_inner stmt;
			if	is_static_for_loop wp fs
			then	s
			else	if	is_first
				then	SForNonStatic {	name=name,
							i=i,
							range=range,
							loop=loop,
							dir = dir,
							tmark = tmark
						}
				else	fail "adjust_statement" 505092 []
	) |	STProcNoIvars piv =>
		let	fun find_spec id ((fproc::rest) : FORMAL_PROC list) = (
				if (#name fproc) = id
				then	Value (#spec fproc)
				else	find_spec id rest
			) | find_spec id [] = Nil;
		in
			case find_spec (#name piv) (#formal_procs wp) of
			Value sp => (
				if	any_initial_variables_z_tm (#post sp)
				then	if	is_first
					then	SProcIvars piv
					else	fail "adjust_statement" 505093 []
				else	s
			) |	Nil => s
		end
	|	STSemicolon (st1, st2) =>
			STSemicolon (adj_first st1, check_inner st2)
	|	STIfThenElse {g, p, q, elsif} => (
			STIfThenElse {
				g = g,
				p = adj_first p,
				q = adj_first q,
				elsif = elsif}
	) |	STCase {s, others, e = e} => (
			STCase{
				s = map
				(fn {choices, p} => {choices = choices, p = adj_first p}) s,
				others = adj_first others,
				e = e}
	) |	STLoop {stmt, ...} => (
			check_inner stmt;
			s
	) |	STNamedLoop {stmt, ...} => (
			check_inner stmt;
			s
	) |	STWhile {loop as {stmt, ...}, ...} => (	
			check_inner stmt;
			s
	) |	STForTmark {loop as {stmt, ...}, ...} => (
			check_inner stmt;
			s
	) |	_ => s
end
);
in
fun Ûadjust_statementİ (wp : WP_ENV) (st : STATEMENT) : STATEMENT = (
			adj_stmt_aux wp true st
);
end
=TEX
=IGN
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));
=TEX
\subsection{$wp$}\label{wp}

=SML
fun Ûwpİ ((st, a, wp_env) : STATEMENT * SEQUENT list * WP_ENV) : RESULT = (
let	val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
	val adjust_and_trans = (trans_exp env) o (adjust_exp env);
	val adjust = adjust_exp env;
in	case adjust_statement wp_env st of
		STNull => null pars
	|	STImplicitNull => null pars
	|	STAssign {name, e} =>
			assign pars (adjust name, adjust_and_trans e)
	|	STSpecNoIvars {spec={pre, post, w, ...}, ...} => 
			spec_no_ivars_either pars w
				(z_predexp_of_z_tm pre, z_predexp_of_z_tm post)
	|	STSemicolon x => semicolon pars x
	|	STIfThenElse {g, p, q, elsif} =>
			if_then_else pars {g=adjust g, p=p, q=q, elsif=elsif}
	|	STCase {e, s, others} =>
			case_others pars {e=adjust e, s=s, others=others}
	|	STLoop x => loop pars x
	|	STNamedLoop x => named_loop pars x
	|	STWhile {g, loop, name} =>
			cn_while pars {g=adjust g, loop=loop, name=name}
	|	STForStatic x => for_static pars x
	|	STForTmark x => for_tmark pars x
	|	STExitWhen {g} => exit_when pars {g=adjust g}
	|	STExit => cn_exit pars
	|	STRet {e} => cn_return pars {e=adjust e}
	|	STProcNoIvars x => proc_call_no_ivars pars x
	|	STKSlot x => fail "wp" 505040 []
	|	STPragma _ => null pars
	|	STAnnotation _ => null pars
	|	SSpecIvars {spec={pre, post, ...}, ...} =>
			spec_ivars pars (z_predexp_of_z_tm pre, z_predexp_of_z_tm  post)
	|	SForNonStatic x => for_non_static pars x
	|	SLogCon x => log_con pars x
	|	SProcIvars x => proc_call_ivars pars x
end
);
=TEX
\pagebreak
\section{APPLICATION OF CHECKS}


\subsection{Useful Printing Functions in Lieu of CNSparkOutput}
=SML
fun Ûfmt_idİ (n : ID) : string = CaseIndependence.get_external_name n;
fun Ûfmt_id_listİ ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
=TEX
\subsection{The Error Printing Function}
=SML
fun Ûchecking_errorİ (msg : string) (n : int) (ins) = (
	diag_line (get_error_message 505050 []);
	fail msg n ins
);
=TEX
\subsection{The Checks}
=SML
fun Ûcheck_1_aİ (id : Z_ID list, speclab : SPECLAB) = (
	let	val w = (#w o #spec) speclab;
	in
		if id diff w = []
		then ()
		else if w = []
		then	checking_error "check_1_a" 505060
			[	fn () => fmt_id_list id]
		else	checking_error "check_1_a" 505064
			[	fn () => fmt_id_list w,
				fn () => fmt_id_list id]
	end
);
=TEX
=SML
fun Ûcheck_1_bİ (speclab : SPECLAB) = (
	if #formal_body_flag speclab
	then ()
	else checking_error "check_1_b" 505061 []
);
=TEX
=SML
fun Ûcheck_1_cİ (speclab : SPECLAB) = (
	if #till_flag speclab
	then ()
	else checking_error "check_1_c" 505062 []
);
=TEX
=SML
fun Ûcheck_1_dİ (p : ID, speclab : SPECLAB) = (
	if any ((#formal_procs o #in_scope) speclab)
			(fn fp => p = #name fp) 
	then ()
	else checking_error "check_1_d" 505063 [fn () => p]
);
=TEX
The following check, we also check 
=SML
fun Ûcheck_19İ (env : CN_ENV) ({w, ...} : SPEC) = (
let	fun aux v = (
		case env v of
			Value (_, EIEnvVar _) => ()
		|	Value (_, EIEnvAuxVar _) => ()
		|	Value _ => fail "check_19" 505083 [fn()=> v]
		|	Nil => fail "check_19" 505082 [fn()=> v]
	);
in	map aux w; ()
end
);
=TEX
\subsection{Anti-Aliasing Checks}

=SML
fun op Ûcapİ (a, b) = (a cup b) diff (a diff b) diff (b diff a);
=TEX

=SML
fun Ûfree_vars_zpredİ (zp : Z_PRED) : Z_ID list = (
	 (map ((fn (n,_,_) => n) o dest_z_lvar) o frees) zp
);
=TEX
=SML
fun Ûentire_var_expİ (cn_env : CN_ENV) (e : EXP) : ID = (
	let	fun aux (EId id) = id
		|   aux (ESelectedComp {prefix, selector}) = aux prefix
		|   aux (EIndexedComp{prefix, index}) = aux prefix
		|   aux _ = fail "entire_var_exp" 505080 [];
	in	aux (adjust_exp cn_env e)
	end
);
=TEX
=SML
fun Ûname_to_entire_variable_nameİ (cn_env : CN_ENV) (e : EXP) : Z_ID = (
	trans_id (entire_var_exp cn_env e)
	handle exn => reraise exn "name_to_entire_variable_name"
);
=TEX
=SML
fun Ûfind_formal_procİ (speclab : SPECLAB) (name : ID) : FORMAL_PROC = (
	find 
	((#formal_procs o #in_scope) speclab)
		(fn p => #name p = name)
		handle Fail _ => checking_error "find_formal_proc" 505067
						[fn () => name]
);
=TEX
=SML
fun Ûfree_var_namesİ (fv::rest : TERM list) : ID list = (
		if is_z_lvar fv
		then
			((fn (n,_, _) => n) o dest_z_lvar) fv::free_var_names rest
		else
			free_var_names rest
) | free_var_names _ = [];
=TEX
The following is slightly different from the specification.
We exploit the fact that {\it other\_vars\_exp} is only used
in anti-aliasing check 3 and there it is only applied to an expression
that must be formed from a variable by some combination of
indexed component and selected component constructs.
We can therefore happily let {\it other\_vars\_exp} fail on
expressions that are not of this form.
Note that as in \cite{ISS/HAT/DAZ/IMP508}, the index or indices in
an indexed component expression are always wrapped up as if they
were a positional array aggregate.
=SML
fun other_vars_exp (cn_env : CN_ENV) (e : EXP) : ID list = (
	let	fun get_index_exps acc (EId id) = acc
		|   get_index_exps acc (ESelectedComp {prefix, selector}) =
			get_index_exps acc prefix
		|   get_index_exps acc (EIndexedComp{prefix,
			index as EArrayAggPos{comps, ...}}) =
			get_index_exps (comps@acc) prefix
		|   get_index_exps acc _ = fail "other_vars_exp" 505080 [];
		val tm = mk_z_tuple(map (trans_exp cn_env)
				(get_index_exps [] (adjust_exp cn_env e)));
	in	(free_var_names o frees) tm
	end
);
=TEX
The above trickery with {\it other\_vars\_exp} means that we have to code
{\it vars\_exp} directly rather than the way the
specification describes it, but that's easier and faster in any case.
=SML
fun Ûvars_expİ (cn_env : CN_ENV) (exp : EXP) : ID list = (
	(free_var_names o frees o trans_exp cn_env o adjust_exp cn_env) exp
);
=TEX	
In the following, we rely on the fact that {\it zid} does not
change the name of the variable (any changes to the name, e.g., replacing
`.'s by `o's are done by {\it trans\_id}).
Thus we can get away with treating the {\it Z\_ID}s in the global
dependency list as {\it ID}s.
=SML
fun Ûanti_aliasing_parsİ (fp : FORMAL_PROC) (pc : (AGG_CHOICE,EXP)PROC_CALL)
				: ID list * ID list = (
	let	val formal_ids = #formal_ids fp;
		val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
		val formals = flat (map (fn {vars, ...} => vars) var_decls);
		val pre = (z_predexp_of_z_tm o #pre o #spec) fp;
		val post = (z_predexp_of_z_tm o #post o #spec) fp;
		val trans_formals = map trans_id formals;
	in
		(formals, #globals fp)
	end
);
=TEX
The following function makes a pair-wise list of actual parameters (EXPs) with their modes (which are extracted from the corresponding $formal\_proc$).
The actuals are in the order given in the procedure specification.
=SML
fun Ûanti_aliasing_actuals_modesİ (env : CN_ENV) (formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE, EXP) PROC_CALL) :
			(EXP * MODE) list = (
	let	val name = #name proc;
		val formal_ids = #formal_ids formal_proc;
		val var_decls_modes = map (fn {var_decl, mode,...}
					=> (var_decl,mode)) formal_ids;
		val vars_modes = map
				(fn ({vars, ...},mode) => (vars,mode))
				 var_decls_modes;
		fun do_formals_modes (id::rest, m) = (
			(id, m)::do_formals_modes (rest, m)
		) | do_formals_modes _ = [];
		val (formals,modes) = (split o flat o map do_formals_modes)
						vars_modes;
		val actuals = map (adjust_exp env) (case #actuals proc of
				APositional exps => exps
			|	ANamed nas => named_assocs_to_exps formals nas)
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
		val actuals_modes = combine actuals modes
			handle Fail _ => fail "anti_aliasing_check_1" 505068
						[fn() => fmt_id name];
	in	combine actuals modes
	end
);
=TEX
=SML

=TEX
=SML
fun Ûanti_aliasing_check_1İ  (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val cn_env = (#env o #wp_env) speclab;
		val (formals, trans_globals) = anti_aliasing_pars formal_proc proc;
		val set = map fst (actuals_modes drop
				(fn am => not (	snd am = MSparkInOut orelse
							snd am = MSparkOut)));
		val trans_set = map (fn
				e => entire_var_exp cn_env e
				handle Fail _ =>
				fail "anti_aliasing_check_1" 505070
				[fn()=>name]) set;
		val inter_set = trans_set cap (trans_globals diff formals);
		fun plural () = if length inter_set > 1 then "s" else "";
	in
		if inter_set = []
		then (* OK *) ()
		else	checking_error "anti_aliasing_check_1" 505071
				[	plural,
					fn()=> fmt_id_list inter_set,
					fn()=> fmt_id name]
	end
);
=TEX
=SML
fun Ûanti_aliasing_check_2İ (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val (formals, trans_globals) = anti_aliasing_pars formal_proc proc;
		val w = (#w o #spec) formal_proc;
		val actuals = map fst actuals_modes;
		val ids = list_cup (map (vars_exp ((#env o #wp_env) speclab))
					actuals);
		val trans_ids = map trans_id ids;
		val inter_set = (trans_globals diff formals) cap trans_ids;
		val plural = if length inter_set > 1 then "s" else "";
	in	if inter_set = []
		then (* OK *) ()
		else checking_error "anti_aliasing_check_2" 505072
				[	fn()=> plural,
					fn()=> fmt_id_list inter_set,
					fn()=> fmt_id name]
	end
);
=TEX
=SML
fun Ûanti_aliasing_check_3İ (speclab : SPECLAB)
				(formal_proc : FORMAL_PROC)
				(proc : (AGG_CHOICE,EXP)PROC_CALL)
				(actuals_modes : (EXP * MODE) list) : unit = (
	let	val name = #name proc;
		val cn_env = (#env o #wp_env) speclab;
		val var_sets = map (vars_exp cn_env o fst) actuals_modes;
		val acts_modes_vars = combine actuals_modes var_sets;
		fun do_check bef (((act, MSparkIn), vars)::aft) = (
			do_check (vars::bef) aft
		) | do_check bef (((act, _), vars)::aft) = (
				let	val ent_var = entire_var_exp cn_env act;
				val other_vars = other_vars_exp cn_env act;
			in	if	not (ent_var mem other_vars)
				andalso	not (any bef (fn vs => ent_var mem vs))
				andalso	not (any aft (fn (_, vs) => ent_var mem vs))
				then	do_check (vars::bef) aft
				else	checking_error "anti_aliasing_check_3"
					505073 [	fn()=> fmt_id ent_var,
						fn()=> fmt_id name]
			end
		) | do_check _ [] = ();
	in	 do_check [] acts_modes_vars
	end
);
=TEX
The following function computes the effective frame of a procedure call --- the frame that is obtained by substituting the entire variables of the actual parameters
for the formals in the original frame.  
=SML
fun Ûproc_frameİ (env : CN_ENV)
			({formal_ids, spec={w, ...}, ...} : FORMAL_PROC )
			(actuals_modes : (EXP * MODE) list)
				: Z_ID list = (
	let	val var_decls = map (fn {var_decl, ...} => var_decl) formal_ids;
		val formals = flat (map (fn {vars, ...} => vars) var_decls);
		val table = combine formals (map fst actuals_modes);
		fun aux (v :: vs) = (
			(case lassoc5 table v of
				Nil => v
			|	Value e =>
				name_to_entire_variable_name env e)
			:: aux vs
		) | aux [] = [];
	in	aux w
	end
);
=TEX
=SML
fun Ûanti_aliasing_checkİ (env : CN_ENV) (speclab : SPECLAB,
				proc : (AGG_CHOICE,EXP)PROC_CALL) = (
	let	val formal_proc = find_formal_proc speclab (#name proc);
		val actuals_modes =
			anti_aliasing_actuals_modes env formal_proc proc
			handle Fail _ =>
			fail "anti_aliasing_check" 505068 [fn()=> #name proc];
	in
		anti_aliasing_check_1 speclab formal_proc proc actuals_modes;
		anti_aliasing_check_2 speclab formal_proc proc actuals_modes;
		anti_aliasing_check_3 speclab formal_proc proc actuals_modes;
		check_1_a(proc_frame env formal_proc actuals_modes, speclab)
	end
);
=TEX
\subsection{Invoking the Checks}
=SML
fun Ûdo_soundness_checks1İ (
	(speclab as {wp_env as {env, ...}, ...},
		statement): SPECLAB * STATEMENT) : unit = (

let	fun pass_over_statement (st : STATEMENT) = (

	case st of
			STNull => (
		)| 	STImplicitNull => (
		)|	STAssign {name,e} => (
				check_1_a
				([name_to_entire_variable_name env name],
					speclab)
		)|	STSpecNoIvars {spec as {w,w0,pre,post},label} => (
				check_1_a (w, speclab);
				check_19 env spec
		)|	STSemicolon (s1,s2) => (
					(pass_over_statement s1;
					pass_over_statement s2)
		)|	STIfThenElse  {g,p,q,elsif} => (
					(pass_over_statement p;
					pass_over_statement q)
		)|	STCase {e,s,others} => (
				map (fn st1 => pass_over_statement (#p st1)) s;
				pass_over_statement others
		)|	STLoop {t,stmt} => (
				pass_over_statement stmt
		)|	STNamedLoop {name,t,stmt} => (
				pass_over_statement stmt
		)|	STWhile {name,g,loop} => (
				pass_over_statement (#stmt loop)
		)|	STForStatic {name,i,tmark,range,dir,loop} => (
				pass_over_statement (#stmt loop)
		)|	STForTmark {name,i,tmark,dir,loop} => (
				pass_over_statement (#stmt loop)
		)|	STExitWhen {g} => (
				check_1_c speclab
		)|	STExit => (
				check_1_c speclab
		)|	STRet {e} => (
				check_1_b speclab
		)|	STProcNoIvars (proc as {name,actuals}) => (
				check_1_d (name, speclab);
				anti_aliasing_check  env (speclab, proc)
		)|	STKSlot {content,label} => (
		)|	STPragma _ => (
		)|	STAnnotation _ => (
		)|	SSpecIvars _ => (
		)|	SLogCon _ => (
		)|	SForNonStatic {loop, ...} => (
				pass_over_statement (#stmt loop)
		)|	SProcIvars (proc as {name,actuals}) => (
				check_1_d (name, speclab);
				anti_aliasing_check env (speclab, proc)
		)
	);
	in	pass_over_statement statement
	end
);
=TEX
=SML
fun Ûresolverİ (repl_function : LABEL -> REPLACEMENT OPT) (label : LABEL)
			: STATEMENT = (
	let	val repl = case repl_function label of
					Nil => (
						UnReplaced (RSStatement, "")
				) |	Value repl => repl;
	in
		case repl of
			ReplaceComp _ => ( STImplicitNull
		) |    ReplacePPart _ => (	STImplicitNull
		) |    ReplaceVPart _ => (	STImplicitNull
		) |    ReplaceDecl _ => (	STImplicitNull
		) |    RefineStat {statement, ...} => ( statement
		) |    ReplaceStat {statement, ...}  => ( statement
		) |    ReplaceArbitrary _ => ( STImplicitNull
		) |    ReplaceAnnotation _ => ( STImplicitNull
		) |    UnReplaced _ => ( STImplicitNull
		)	
	end
);
=TEX
=SML
datatype ÛCHECK_STATEİ = ÛCSTopİ | ÛCSInLoopİ | ÛCSInCaseİ
		| ÛCSOKToExitİ | ÛCSInIfThenElseİ;

=TEX
=SML
fun Ûcheck_3aİ	 (state : CHECK_STATE, st : STATEMENT) = (

	case  st of
		STExitWhen _ => (
			if state = CSInLoop
			then ()
			else checking_error "check_3a" 505065 []
	) |	_ =>	error "check_3a" 505076 []
);
=TEX
=SML
fun Ûcheck_3bİ	 (state : CHECK_STATE, st : STATEMENT) = (

	case  st of
		STExit => (
			if state = CSOKToExit
			then ()
			else checking_error "check_3b" 505066 []
	) |	_ =>	error "check_3b" 505077 []
);
=TEX
=SML
datatype ÛENDINGİ = ÛEndsInReturnİ | ÛEndsInOtherİ;
=TEX
=SML
fun Ûcheck_4aİ	 (is_function_subprogram : bool) : unit = (

	if is_function_subprogram
	then
		()
	else
		checking_error "check_4a" 505078 []
);

fun Ûcheck_4bİ	 (is_function_subprogram : bool,
		 	ends_in_return : ENDING) : unit = (

	if is_function_subprogram
	then
		case ends_in_return of
			EndsInReturn => (
		) |	EndsInOther =>
				checking_error "check_4b" 505079 []
	else	()
);
=TEX

=SML
fun Ûdo_soundness_checks2İ	(repl_function : LABEL -> REPLACEMENT OPT)
				(is_function_subprogram : bool)
				(statement : STATEMENT) : unit = (

let	val local_resolver = resolver repl_function;
	fun check_over_statement (state : CHECK_STATE) (st : STATEMENT) : ENDING = (

	case st of
			STNull => (	EndsInOther
		)| 	STImplicitNull => ( EndsInOther
		)|	STAssign {name,e} => ( EndsInOther
		)|	STSpecNoIvars {spec,label} => (
				check_over_statement state (local_resolver label)
		)|	STSemicolon (s1,s2) => (
				if state = CSOKToExit
				then
					(check_over_statement CSInIfThenElse s1;
					check_over_statement state s2)
				else
					(check_over_statement state s1;
					check_over_statement state s2)
		)|	STIfThenElse  {g,p,q,elsif} => (
				if not elsif andalso state = CSInLoop
				then	(check_over_statement CSOKToExit p;
					check_over_statement CSOKToExit q;
					EndsInOther)
				else	(check_over_statement CSInIfThenElse p;
					check_over_statement CSInIfThenElse q;
					EndsInOther)
		)|	STCase {e,s,others} => (
			let	val res =  map
				   (fn st1 => check_over_statement CSInCase (#p st1)) s;
				val res1 = check_over_statement CSInCase others;
			in
				if all (res1::res) (fn r => r = EndsInReturn)
				then	EndsInReturn
				else	EndsInOther
			end
		)|	STLoop {t,stmt} => (
				check_over_statement CSInLoop stmt;
				EndsInOther
		)|	STNamedLoop {name,t,stmt} => (
				check_over_statement CSInLoop stmt;
				EndsInOther
		)|	STWhile {name,g,loop} => (
				check_over_statement CSInLoop (#stmt loop);
				EndsInOther
		)|	STForStatic {name,i,tmark,range,dir,loop} => (
				check_over_statement CSInLoop (#stmt loop);
				EndsInOther
		)|	STForTmark {name,i,tmark,dir,loop} => (
				check_over_statement CSInLoop (#stmt loop);
				EndsInOther
		)|	STExitWhen {g} => (
				check_3a (state, st);
				EndsInOther
		)|	STExit => (
				check_3b (state, st);
				EndsInOther
		)|	STRet {e} => (
				check_4a is_function_subprogram;
				EndsInReturn
		)|	STProcNoIvars (proc as {name,actuals}) => (
				EndsInOther
		)|	STKSlot {content,label} => (
				check_over_statement state (local_resolver label);
				EndsInOther
		)| 	STAnnotation _ => ( EndsInOther
		)| 	STPragma _ => ( EndsInOther
		)|	SSpecIvars {label, ...} => (
				check_over_statement state (local_resolver label)
		)|	SLogCon {label, ...} => (
				check_over_statement state (local_resolver label)
		)|	SForNonStatic {loop, ...} => (
				check_over_statement state (#stmt loop)
		)|	SProcIvars _ => (
				EndsInOther
		)
	);
		val ends_in_return = check_over_statement CSTop statement;
	in
		check_4b (is_function_subprogram, ends_in_return);
		()
	end
);
=TEX
\subsection{Variable Capture Checks}

The following function is called from $add\_var\_env$ in \cite{ISS/HAT/DAZ/IMP507}.

=SML
fun Ûcheck_new_spark_idsİ (cn_env : CN_ENV) (ids : ID list) = (
	let	fun aux recur (id::rest) = (
			case cn_env id of
				Value (_, EIEnvRetry id2) => 
					if	recur
					then	aux false (id2::ids)
					else	fail "check_new_spark_ids" 505074 [fn()=>id]
			|	Value _ => fail "check_new_spark_ids" 505074 [fn()=>id]
			|	Nil => aux true rest
		) | aux _ [] = ();
	in
		if all_different ids
		then
			aux true ids
		else
			fail "check_new_spark_ids" 505075 []
	end
);
=TEX
=SML
fun Ûcheck_new_z_idİ (z_ids : Z_ID list) (z_id : Z_ID) : unit = (
	if z_id mem z_ids
	then
		fail "check_new_z_id" 505074 [fn()=>z_id]
	else	case (get_const_type o fst o dest_const o mk_z_gvar)
			(z_id, BOOL, []) of
				Value _ =>
					fail "check_new_z_id" 505074 [fn()=>z_id]
			|	Nil => ()
);
=TEX
\section{VERIFICATION CONDITIONS}
$cart\_prod$ and $fun\_decl$ are specified in
\cite[volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.
=SML
fun Ûfun_sigİ (zpars : Z_EXP list, zret : Z_EXP) : Z_EXP= (
	case zpars of
		[] => zret
	|	[zpar] => z_tfun(zpar, zret)
	|	_ => z_tfun(z_many_cross zpars, zret)
);
=TEX
=SML
fun Ûpar_tmarkİ (env : CN_ENV)
	({var_decl = {vars, tmark, ...}, ...} : PARAM_SPEC) : Z_ID list = (
	let	val zi = trans_id tmark;
	in	map (Combinators.K zi) vars
	end
);
=TEX
=SML
fun Ûvar_sigİ (env : CN_ENV) (zn : Z_ID) : Z_EXP = (
	case env zn of
		Value (_, EIEnvVar tmark) => zid env(trans_id tmark)
	|	Value (_, EIEnvAuxVar ztm) => ztm
	|	_ => fail "var_sig" 505041 [fn()=>zn]
);
=TEX
=SML
fun Ûfun_decl_auxİ
	((env, {name, formal_pars, return_type}, globals)
	: CN_ENV * INFORMAL_FUN * Z_ID list) : Z_DECL * TERM * TERM = (
	let	val zn = trans_id name;
		val z_ret_ty = zid env (trans_id return_type);
		val gdecs = map (var_sig env) globals;
		val tmarks = flat (map (par_tmark env) formal_pars);
		val pdecs = map (zid env) tmarks;
		val zexp = fun_sig(gdecs, fun_sig(pdecs, z_ret_ty));
		val t_zexp = (dest_z_power_type o type_of) zexp;
		val lvar = mk_z_lvar(zn, t_zexp, []);
		val gvar = mk_z_gvar(zn, t_zexp, []);
	in	(mk_z_dec([lvar], zexp), lvar, gvar)
	end
);
=TEX
We can defined $fun\_decl$ in terms of $fun\_decl\_aux$ by throwing away the second and third parts of the result value and currying the function.
=SML
fun Ûfun_declİ
	(env : CN_ENV)	({informal_fun, globals, ...} : FORMAL_FUN) : Z_DECL = (
	let	val (d, _, _) = fun_decl_aux(env, informal_fun, globals);
	in	d
	end
);
=TEX
=SML
fun Ûvc_local_declsİ (seqs : SEQUENT list,
	{formal_body_flag, fun_flag,
		in_scope as {vc_vars, vc_pars, vc_log_cons, vc_aux_vars, ...},
		wp_env = {fun_header, env, ...}, ...} : SPECLAB)
		: VC list = (
let
(*
=TEX
Every variable in $vc\_vars$ and its corresponding initial variable is introduced.
=SML
*)
	fun do_vars var = (
	let	val t_v = trans_id var;
	in
		[t_v, init_var t_v]
	end);
	fun var_decl_decls {vars, tmark} =
		trans_decl env {vars = (flat o (map do_vars)) vars, tmark=tmark};
(*
=TEX
The following function implements the special case for input parameters specified in \cite[Volume 2, section 5.1.5]{DRA/CIS/CSE3/TR/94/27/3.0}.
=SML
*)
	fun param_spec_decls {var_decl, mode} = (
		case mode of
		MSparkIn => trans_decl env var_decl
		|	_ => var_decl_decls var_decl
	);
(*
=TEX
=SML
*)
	val decls = map var_decl_decls vc_vars @ map param_spec_decls vc_pars;

(*
=TEX
Add the logical constants (no initial versions).
=SML
*)
	val decls = vc_log_cons @ decls;
(*
=TEX
Add the auxiliary variables (with initial versions).
=SML
*)
	val vc_aux_vars_0 = (
			  map mk_z_dec
			o map (fn (ds, t) =>
					(map (	  mk_z_lvar
						o (fn (n,t,a) => (init_var n,t,a))
						o dest_z_lvar
					    ) ds, t))
			o map dest_z_dec)
		vc_aux_vars;
	val decls = vc_aux_vars @ vc_aux_vars_0 @ decls;
(*
=TEX
\raggedright{If $formal\_body\_flag$ and $fun\_flag$ are $true$, add a declaration of the function (obtained from $fun\_header$).}
=SML
*)
	val (decls, subs_fn) =
		if	formal_body_flag andalso fun_flag
			then	let 	val (d, l, g) = fun_decl_aux
		(env,fun_header, fun_globals env (#name fun_header));
				in	(d :: decls, subst [(l, g)])
				end
			else	(decls, Combinators.I);

	val seqs1 = map (fn (h, c) => (map subs_fn h, subs_fn c)) seqs;
(*
=TEX

Remove any declarations which are not needed by the sequent.
=SML
*)
	fun drop_vars vns vardecl = (
	let	val (vars, ty) = dest_z_dec vardecl;
		val vartys = map dest_var vars;
		val dvartys = vartys drop (fn (v,ty) => not (v mem vns));
	in
		case dvartys of
			[] =>	[]
		|	_ =>	[mk_z_dec (map mk_var dvartys, ty)]
	end);
	fun frees_in_seq (seq as (h, c)) = (
		map (fst o dest_var) (flat(frees c :: map frees h))
	);
	fun add_decls decs seq = (
	let	val ddecs = map ((drop_vars o frees_in_seq) seq) decs;
	in
		(flat ddecs, seq)
	end
	);

	val vcs1  = map (add_decls decls) seqs1;
(*
=TEX
Add declarations for any new Z variables introduced in processing
procedure calls with record or array components as exported parameter
and remove the corresponding hypotheses from the sequent.
=SML
*)
	fun add_tmp_decls (decs, seq as (h, c)) = (
	let	fun strip_tmp_decs acc [] = acc
		|   strip_tmp_decs (acc as (new_ds, h)) (hyp::hyps) = (
			let	val (v, tm) = dest_z_ hyp;
				val (n, _, _) = dest_z_lvar v;
			in	if	maybe_param_tmp_name n
				andalso	not (any decs (is_free_in v))
				then	strip_tmp_decs 
						(mk_z_dec([v], tm)::new_ds, h) hyps
				else	term_fail "" 0 []
			end	handle Fail _ => strip_tmp_decs (new_ds, hyp::h) hyps
		);
		val (new_ds, new_h) = (rev ** rev)(strip_tmp_decs ([], []) h);
	in	(decs @ new_ds, (new_h, c))
	end);
	val vcs2 = map add_tmp_decls vcs1;
in	vcs2
end
);
=TEX
Initial variables may not appear in the pre-conditions of specifications
statements (see schema {\it Spec} in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}).

=SML
fun Ûvcsİ ((sl as {spec as {w, w0, pre, post},
			wp_env, ...}, st): SPECLAB * STATEMENT)
			: VC list * SPEC = (

let	val side_effect = do_soundness_checks1 (sl, st);

	val pre1 = z_predexp_of_z_tm pre;
	val post1 = z_predexp_of_z_tm post;
	val {wp, side} = wp (st, [[] ô post1], wp_env);
	fun subs_c (h, c) = (
		h ô subs_pred(c, w0, w)
	);
	val wp1 = map subs_c wp;
	val s = (pre1 %Longrightarrow% wp1) @
		(subs_pred(pre1, w, w0) %Longrightarrow% side);
in
	if	any_initial_variables_z_pred pre1
	then	fail "vcs" 505095 []
	else	(vc_local_decls(s, sl),
		 {	w = w,
			w0 = w0,
			pre = z_quote (pre1, Nil),
			post = z_quote (post1, Nil)})
end
);
=TEX
=IGN
val (sl as 	{	spec ,
			wp_env,
			in_scope,...} : SPECLAB,
		st)= hd(! CNZGenerator.diag_vc_args);
val  {w, w0, pre, post} = spec;

val pre1 = z_predexp_of_z_tm pre;
val post1 = z_predexp_of_z_tm post;
val a = [[] ô post1];
wp (st, a, wp_env);
(* assignments in wp *)
val pars as {wp_env as {env, ...}, ...} : WP_PARS =
			{wp = wp, a = a, wp_env = wp_env};
val adjust_and_trans = (trans_exp env) o (adjust_exp env);
val adjust = adjust_exp env;
val exp = adjust_statement wp_env st;
(* now goto the appropriate function *)
val fp= #formal_procs(#in_scope((fst (hd(!CNZGenerator.diag_vc_args)))));

=TEX
\section{EPILOGUE}
=SML
end (* local ... in *);
end (* structure CNVCGenerator *);
=TEX
%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed505.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

=IGN

CNZGenerator.diag_vc_args;
CNVCGenerator.vcs (hd(!CNZGenerator.diag_vc_args));
use_file"wrk001";
val (sl as {spec as {w, w0, pre, post, ...},
			wp_env, ...}, st)= hd(! CNZGenerator.diag_vc_args);

