% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
% rash -W 6in -e usr501A.rs >usr501A.ps
% rash -W 6in -e usr501B.rs >usr501B.ps
% rash -W 6in -e usr501C.rs >usr501C.ps
% rash -W 6in -e usr501D.rs >usr501D.ps
% sed -n '/^=DOC/,/^=ENDDOC/p' <dtd516.doc | sieve tex > usr501E.tex
\documentstyle[11pt,hol1,fleqn,USR,epsf]{book}
% temporary measure while waiting for LaTeXe to come along
\def\LaTeXe{\LaTeX$2_{\varepsilon}$}
\def\Hide#1{}
% Set the following macros as necessary as release
% numbers change.
\def\texrelease{\TeX\ version 3.1415}
\def\latexrelease{\LaTeXe}
\def\arch{sun4}
\def\solarisrelease{Solaris 2.3}
\def\motifrelease{Motif 1.2}
\def\polyrelease{Poly/ML 3.01}
\def\quicktexloc{{\tt /QLaTeX}} % NB one location needs this hard wired in
\def\daztool{Compliance Tool}
% just useful macros
\def\ltm{$^{\rm TM}$}
\def\Note#1{{\small\bf[ #1 ]}}
=IGN
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Tool --- User Guide}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/USR501}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Manager}
\TPPabstract{
This document is the User Guide for the Compliance Tool
being produced for DRA under the DAZ project.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
\begin{tabular}[t]{lr}
C.O'Halloran & DRA\\
DAZ Project Library & WIN01\\
\end{tabular}}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadcentre{}
%\def\TPPheadcentreproject{}
%\def\TPPheadrhs{}
\let\TPPfootlhs=\TPPfootrhs
\def\TPPfootcentre{$\vcenter{\halign{\hfil\strut##\hfil\cr
COPYRIGHT  \copyright\ ICL 1997\cr}}$}
=TEX
\ftlmargin 0.0in
\ftrmargin 0.0in

\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$%
}}

\USRmanual{Compliance Tool --- User Guide}
\USRref{USR501}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}
\makeUSRfrontpage

\underscoreoff

\chapter*{CONTENTS}

\tableofcontents
\listoffigures

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document describes the use of the Compliance Tool supplied with {\Product}.

\section{Readership}
This document is intended to be read by users of the Compliance Tool.
It contains both introductory material for the new user and reference material for more experienced users.

\section{Related Publications}

A bibliography is given towards the end of this document.

\begin{itemize}

\item
Installation of the Compliance Tool is described in:

{\CNINSTALLATION}
 

\item
Advice on proving verification conditions generated by the tool is given in:

{\CNPROVINGVCS}


\item
The syntax and semantics of the Compliance Notation as supported by the Compliance Tool is described in:

{\CNNOTATION}
 
\item
An overview of the of the Compliance notation can be found in the DRA document:

{\em A commentary on the Specification of the Compliance Notation for SPARK and Z} \cite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.1}.

\item
A description of \Product{} may be found in:

{\SOFTSERV},

which also contains a full list of other \Product{} documentation.

\end{itemize}

\section{Area Covered}

Once the Compliance Tool is installed on the user's workstation, by following the procedure described in {\em Compliance Tool Installation and Operation \cite{ISS/HAT/DAZ/USR502}}, this User Guide should enable the user to undertake the following tasks:

\begin{enumerate}
\item
Loading a Compliance Notation script into the tool;
\item
Generation of the SPARK program from a script;
\item
Generation of the Z document from a script and reloading the Z document into {\Product};
\item
Using the VC Browser to examine the VCs and the Compliance Notation constructs which gave rise to them.
\item
Preparation and checking of new scripts;
\item
Using {\Product} facilities to work with VCs, e.g., to begin an attempt to prove a VC.
\end{enumerate}

\section{Prerequisites}

This User Guide is {\em not} intended to be an introduction to the Z language, or to the Compliance Notation, or to the use of {\Product} to prepare the Z parts of a script.

Familiarity with Compliance Notation as specified in \cite{DRA/CIS/CSE3/TR/94/27/1.2} and some familiarity with {\Product} is very desirable, although not essential for simple use of the tool to process existing scripts.
Some familiarity with the use of {\Product} for developing Z specifications is required to use the tool to develop new scripts.


A tool-independent description of the Compliance Notation is given in \cite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.1}.
The {\ProductZ} tutorial, \cite{DS/FMU/IED/USR010}, gives an introduction to the use of {\Product} for specification and proof in Z.

The {\Product} user documentation is supplied as part of the {\Product} release  included with the Compliance Tool and is available for on-line reference.

The user interface to the tool described in this document is a Motif application  running under the X Windows System.
Users who are unfamiliar with X or Motif should consult local or supplier's documentation or expertise for further guidance (e.g. see \cite{sun92a}).



\section{Acknowledgements}
=IGN
The below are taken from Motif 1.2 Users Guide, July 1993
=TEX
Sun Microsystems is a registered trademark of Sun Microsystems Inc.  Sun-3, OpenWindows, Sun-4, SPARCstation, SunOS and Solaris are trademarks of Sun Microsystems Inc.

Motif is a registered trademark of the Open Software Foundation, Inc.

UNIX is a registered trademark of UNIX System Laboratories, Inc.

Poly/ML is an implementation of Standard ML with a few non-standard extensions.  Poly/ML, and its documentation, is copyright Abstract Hardware Limited.  

\TeX{} is copyright the American Mathematical Society and by Donald E. Knuth.
The \LaTeXe\ distribution tape is copyright the \LaTeX\ 3 project and its individual authors.

The X Windows System is a trademark of the Massachusetts Institute of Technology.

=TEX
\chapter{INTRODUCTION TO THE COMPLIANCE TOOL}\label{INTROTOOL}
\section{The Compliance Notation}
The Compliance Tool supports a notation for demonstrating the compliance of Ada programs with Z specifications.
The Ada parts of the notation belong to the SPARK subset of Ada and will be referred to as SPARK in the rest of this document.
The Compliance Notation was designed by the Defence Research Agency, Malvern and is described in the DRA document \cite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.1}.

Compliance Notation is prepared and presented in literate scripts containing a mixture of narrative text, Z and SPARK.
Special constructs are provided for two main purposes:

\begin{enumerate}
\item
to allow the SPARK program to be presented and documented in an order independent of that prescribed by the SPARK syntax (in a similar fashion to Knuth's Web system \cite{Knuth84a});
\item
to allow the behaviour of the SPARK code to be formally specified in Z (using a style based on Morgan's refinement calculus \cite{Morgan90}).
\end{enumerate}

These constructs allow the user to assert formal connections between the Z parts and the SPARK parts in a Compliance Notation script and permit the compliance of the SPARK program against its Z specifications to be reduced to a set of conjectures known as verification conditions, whose truth guarantees compliance.
The VC generation algorithm is formally specified in the DRA technical report \cite{DRA/CIS/CSE3/TR/94/27/1.2}.
The algorithm maps a Compliance Notation script to a Z document containing the VCs formulated with Z conjectures together with supporting Z definitions.

\section{The Compliance Tool}
The Compliance Tool described in this document supports the use of the Compliance Notation.
It performs the following principal functions:

\begin{enumerate}
\item
Checking the syntax of a Compliance Notation script;
\item
Generating the Z document including VCs from a script;
\item
Extracting the SPARK program from a script.
\end{enumerate}

The Compliance Tool is implemented as an application of the {\Product} specification and proof tool.
The tool provides all the facilities offered by {\Product} for developing specifications and proofs in HOL and Z and for preparing high quality printed output via the {\LaTeX} system.
The tool includes some custom facilities for working with Compliance Notation including a VC browser and some customised proof procedures.

The use of the tool in the development of a compliance argument will involve several stages, typically including the following:

\begin{enumerate}
\item
Initial preparation of the literate scripts using the editing and interactive checking facilities of the tool.
During this stage, the Z documents and SPARK program are produced and inspected as required to assist in the development.
\item
Batch processing of the complete literate scripts.
If the conventions suggested in this User Guide are followed, the Z documents and SPARK program are produced automatically.
The tool can be used interactively if required, e.g., to help diagnose errors.
\item
Further analysis of the Z documents.
Depending on circumstances and on the level of formality required, this might involve some or all of:
{\em(a)}, inspection of the documents, on paper or using a viewer;
{\em(b)}, use of the VC browser supplied with the tool;
and, {\em(c)}, machine-checked proof of some or all of the VCs.
\end{enumerate} 

The Compliance Tool offers a range of facilities to help in all of these activities.


\chapter{GETTING STARTED}

The task of using of the Compliance Tool to process a script is very similar to that of using {\Product} to process a Z specification.
Indeed, the Z paragraphs in a Compliance Notation script are handled using the usual {\Product} mechanisms and the constructs peculiar to the Compliance Notation are treated in a very similar way.

Simple use of the tool to process existing scripts does not require any great familiarity with {\Product}.
Using the tool to create new scripts or edit existing ones requires some familiarity with the preparation of Z specifications using {\Product} (as described in \cite{DS/FMU/IED/USR011}).
The rest of this chapter explains how to make a start with the tool for either of these levels of use.
Section \ref{Databases} describes set-up procedures which are common to batch and interactive working;
section \ref{BatchWorking} describes how to use the tool to process existing scripts using UNIX commands;
section \ref {InteractiveWorking} explains how to start an interactive session with the tool and gives an overview of its main graphical features.


\section{{\Product} Databases}\label{Databases}
As always with a {\Product} application, to use the Compliance Tool you must first pick the {\Product} database with which you wish to work.
A {\Product} database is a file which holds code and data recording the results of work with {\Product}.
These databases are organised in a hierarchy.
To run the Compliance Tool, you use a database which is a descendant in this hierarchy of the database {\tt pp\_daz}.
This database, held in a file called
{\tt sun4bin/sun4pp\_daz.db} in the {\Product} installation directory, contains the code and data required to process Compliance Notation.
If you are starting from scratch, you would create a suitable database, say called {\tt mydatabase}, using a UNIX command line such as:

\begin{verbatim}
        pp_make_database -p pp_daz mydatabase
\end{verbatim}

This creates an empty database, which you will generally refer to as `{\tt mydatabase}' when using the system.
The database is held in a file called `{\tt sun4mydatabase.db}' and this is the name you would use to carry out UNIX file operations on the database, e.g., to delete it with the UNIX command `{\tt rm}'.

\section{Batch Working}\label{BatchWorking}
Providing the conventions of chapter~\ref{LITERATESCRIPTCONVENTIONS} have been followed in the development of the scripts,
one or more literate scripts may be processed using the programs, {\tt docsml} and {\tt pp} to produce the Z documents and SPARK program.
For example, assuming a database {\tt mydatabase} has been set up as described above, the following UNIX commands will process the script in file {\tt wrk501.doc}.

\begin{verbatim}
        docsml wrk501
        pp -f wrk501 -d mydatabase >wrk501.run.log
\end{verbatim}

Here the first command produces a file called {\tt wrk501.sml}, containing the formal material from {\tt wrk501.doc} without the narrative text.
The second command causes the Compliance Tool proper to process {\tt wrk501.sml}, updating the database {\tt mydatabase} and producing the Z document and SPARK program for the script.
If the conventions of chapter~\ref{LITERATESCRIPTCONVENTIONS} have been followed in the development of the script, the Z document will be in a file called {\tt wrk501.zdoc} and the SPARK program will be in {\tt wrk501.ada}.
The log produced as the standard output from {\tt pp} has been directed to a file {\tt wrk501.run.log}, since it is likely to contain non-ASCII characters.

In a compliance argument involving more than one script, the {\tt docsml}-{\tt pp} command sequence above is entered in turn for each script.
Note that the order of the scripts is important, and providers of compliance arguments must indicate the required order (e.g., by supplying a make file or a shell script containing the necessary sequence of commands).

The SPARK program is an Ada source file which may be examined with any text editor.
The Z document contains non-ASCII characters and is best examined either using the {\tt xpp} editor or using the program {\tt docpr} to print it.
The log file  is best examined in the same way.
The following UNIX command will print the Z document in our example:

\begin{verbatim}
        docpr wrk501.zdoc
\end{verbatim}

Basic use of the {\tt xpp} editor is described in section \ref{StartingXpp}.
To use it to examine the Z document in this example, one would use the UNIX command:

\begin{verbatim}
        xpp -file wrk501.zdoc
\end{verbatim}

\section{Interactive Working}\label{InteractiveWorking}
\subsection{Starting {\tt xpp}}\label{StartingXpp}
To start an interactive session with the Compliance Tool, you use the UNIX command {\tt xpp}.
{\tt xpp} comprises a custom editor for working on your scripts together with a command interface for executing {\Product} commands and for loading Z and Compliance Notation constructs into the database.

The {\tt xpp} command has options to identify the file containing the script you want edit and to give the {\Product} command options (including the database to use).
To begin work on the script `{\tt wrk501.doc}' with the database `{\tt mydatabase}', you might use the UNIX command line:

\begin{verbatim}
        xpp -file wrk501.doc -command pp -d mydatabase
\end{verbatim}
 

This will create a Motif window similar to the one shown in figure \ref{fig1}.
This is referred to as the {\tt xpp} Main Window.
If you omit the {\tt -command} option, then you will get a so-called edit-only session, in which the lower part of the window will be missing.

\subsection{Window Layout}\label{WindowLayout}
This section describes briefly the main elements of the {\tt xpp} Main Window.
Further information may be obtained either from the tool's help system or from the {\Product} documentation.

In overview, the top part of the window acts as an editor for literate scripts.
Material from the editor can be transferred into the {\ProductML} system for processing (e.g. to type check a specification paragraph or initiate a proof step).
The journal of the transactions with {\Product} occupies the bottom part of the window.
Figure \ref{fig1} also shows a popup window (in this case a palette of special symbols).
The size and position of all the windows can be adjusted using standard Motif techniques.

Sections \ref{MenuBar} to \ref{JournalWindow} below describe the principal features of the {\tt xpp} Main Window.

\subsubsection{Menu Bar}\label{MenuBar}
The menu bar is at the top of the window shown in figure \ref{fig1}.
The menus are all pulldown menus operated in the usual Motif fashion.
The functions they perform are briefly described below.

\paragraph{File Menu}
This menu is for common file operations including: loading and saving the literate script; creating a new literate script; deleting a file.

\paragraph{Tools Menu}
This menu is used to create popup windows to perform various tasks.
An example is the palette window shown in figure \ref{fig1}.

\paragraph{Edit Menu}
This menu provides script editing operations: `Cut', `Copy', `Paste' and `Undo'.
\paragraph{Command Menu}\label{CommandMenu}

This menu is primarily used to cause text from the script window to be executed by the {\ProductML} system.
It also provides various control functions for the {\ProductML} system.

\paragraph{Help Menu}\label{HelpMenu}
This menu provides help on various topics.
Its `Tutorial' item may be consulted for more information on basic operation of {\tt xpp}.

\subsubsection{File Name Bar}\label{FileNameBar}
This displays the name of the file containing the script which is being edited in the Script Window.

\subsubsection{Script Window}\label{ScriptWindow}
The Script Window is the upper large Motif text window in the {\tt xpp} Main Window.
It provides a general purpose editor for viewing and modifying scripts.
In  figure \ref{fig1} on page \pageref{fig1}, a Compliance Notation script containing definitions of a Z global variable, `$primed$', and a SPARK procedure, `$primes$', is being displayed in the Script Window.

Part of the Script Window in figure \ref{fig1} is hidden behind a window containing a `palette' of symbols.
This palette has been selected from the Tools Menu and can be used to enter the symbols into the literate script.
Pushing one of the buttons on the palette causes the symbol to appear in the document as if it had been typed at  the keyboard.

Note that the Z and SPARK constructs in the Script Window are delimited using special mark-up sequences:
{\ShowAllImages `$¹Z$'', `$¹CN$' and `°'}.
A tool called the Templates Tool is available from the Tools Menu allowing easy entry of these mark-up sequences.

\subsubsection{Journal Window}\label{JournalWindow}
The Journal Window is the lower large Motif text window in the {\tt xpp} Main Window.
When {\Product} commands are executed the resulting responses from the {\Product} system are displayed in the Journal Window.
The Journal Window is a read-only text window --- you cannot alter its contents by typing into it.

In \ref{fig1}, the user has just issued a command to process the procedure $primes$.
This is done by selecting the procedure and its delimiting mark-up sequences in the Script Window and then using the `Execute' item in the Command Menu.
The absence of error messages in the Journal Window and the prompt (`$:>$') indicate that the procedure has been processed and accepted.

\begin{figure}[p]
\begin{center}
\leavevmode
% rash -W 6in -e usr501A.rs >usr501A.ps
\epsffile{usr501A.ps}
\end{center}
\caption{An Example Compliance Tool Session}\label{fig1}
\end{figure}


\chapter{LITERATE SCRIPT CONVENTIONS}\label{LITERATESCRIPTCONVENTIONS}

Literate scripts are held in UNIX files, typically with one script per file.
Processing a script has three main goals: production of a Z document; production of the SPARK program; and modifications to the state of a database maintained by the tool and used in processing subsequent scripts.
The literate scripts making up a complete compliance argument must be presented to the tool in some order, compatible with any dependencies between the scripts.

In addition to narrative text, Z paragraphs and Compliance Notation clauses, each script contains commands which direct the tool, e.g., to tell it to output the SPARK program to a particular file.
In this chapter, we recommend some conventions for these commands which are intended to make the script easy to process both interactively and in batch.
A complete example of a script following these conventions is given in chapter~\ref{EXAMPLESCRIPT}.

The conventions described below are not enforced by the tool, and some users may wish to adapt them to their own needs.
However, other sections of this user guide are written on the assumption that these conventions have been followed (e.g., section \ref{BatchWorking}).

\section{Initialisation}\label{Initialisation}
The formal material in each literate script should be preceded by an initialisation section giving a name to the script and identifying the state in which it is to be processed.
This is done with a {\ProductML} command, $new\_script$.
Execution of $new\_script$ introduces a new {\Product} theory, whose name is the same as the script name.

For the first script in a compliance argument, the initialisation should be as in the following example:
=GFT
	new_script{name = "script1", state = initial_cn_state};
=TEX
Here the name $script1$ has been chosen for the script.
This name should be the same as the base name of the file containing the script (so in this case the file would be called {\tt script1.doc}).

For the second and subsequent scripts in a compliance argument the call to $new\_script$ should be as in the following:
=GFT
	new_script{name = "script2", state = script1_state};
=TEX
Here, the state in which $script2$ is to be processed is taken to be the one produced at the end of the previous script, following the conventions of section \ref{StatePreservation} below.

\section{Output Commands}\label{OutputCommands}
The formal material in a literate script should be followed by directions for the production of the Z document and of the SPARK program.
This should be as in the following example:

=GFT
	output_z_document{script="SCRIPT", out_file="SCRIPT.zdoc"};
	output_spark_program{out_file="SCRIPT.ada"};
=TEX
Here
=INLINEFT
SCRIPT
=TEX
\ is the script name, and conventional file name suffixes have been added to it for the Z document and the SPARK program.
 

\section{State Preservation}\label{StatePreservation}
Finally, the literate script should include after the output commands a command to bind the state of the tool in a {\ProductML} variable for use in the initialisation section of the subsequent script.
This should be as in the following example:

=GFT
	val SCRIPT_state = get_cn_state();
=TEX
Here, the script name
=INLINEFT
SCRIPT
=TEX
\ is used, by convention, as part of the name of the variable to be used in the next script.

\chapter{COMPLIANCE TOOL FUNCTIONS}
Sections \ref{Loading} to \ref{PrintingAndPreviewing} below describe basic use of the main functions of the Compliance Tool.

You invoke many of these functions by executing {\ProductML} commands.
This may conveniently be done interactively using the Command Line Tool which can be started using the Tools Menu.
An instance of the Command Line Tool may be seen in figure \ref{fig2} on page \pageref{fig2}.
This tool allows single line {\ProductML} commands to be entered and executed without changing the script which is being edited.
The tool also has a scrollable list which you can use as a memory for common commands.

Some functions are provided as UNIX commands or as a combination of UNIX and {\ProductML} commands.

\section{Loading a Script}\label{Loading}
To load a script, the UNIX command {\tt docsml} must first be used to extract the formal material.
For example, the UNIX command:
\begin{verbatim}
        docsml wrk501
\end{verbatim}

copies the formal material from the file {\tt wrk501.doc} into a file called {\tt wrk501.sml}.

The {\tt .sml} file produced by {\tt docsml} may then be loaded using the {\ProductML} command:

=GFT
	use_file "wrk501";
=TEX

\section{Generating the SPARK Program}\label{SPARKProgram}
The SPARK program is output to a file using the {\ProductML} command $output\_spark\_program$.
This command is normally included at the end of each literate script as described in section \ref{OutputCommands} and may also be called at any time during the development of the script.

A function $print\_spark\_program$ is also provided for displaying the SPARK program on the standard output.
For example, in an interactive session with {\tt xpp}, the {\ProductML} command:

=GFT
	print_spark_program();
=TEX
will cause the SPARK program to be displayed in the journal window.


\section{Generating and Reloading the Z document}\label{ZDocument}
The Z document is output to a file using the {\ProductML} command $output\_z\_document$.
This command is normally called at the end of each literate script as described in section \ref{OutputCommands} and may also be called at any time during the development of the script.

A function $print\_z\_document$ is also provided for displaying the Z document on the standard output.
For example, in an interactive session with {\tt xpp}, the {\ProductML} command:

=GFT
	print_z_document "SCRIPT";
=TEX
will cause the Z document for the script called
=INLINEFT
SCRIPT
=TEX
\ to be displayed in the journal window.

In many situations, there is no actual need to reload the Z document, since it is automatically loaded as a a side-effect of processing the literate script.
Thus work on proof of VCs, for example, can begin immediately after the script is processed.
The Z document can be reloaded into the tool, if required, simply by treating it in the same way as a {\tt .sml} file produced by running {\tt docsml} on an ordinary Z specification.
Thus one can use either a {\ProductML} command such as:

=GFT
	use_file"SCRIPT.zdoc";
=TEX
or a UNIX command such as:

\begin{verbatim}
        pp -f SCRIPT.zdoc -d database
\end{verbatim}

to load in the Z document.
The following points should be noted in connection with reloading Z documents produced by the Compliance Tool:

\begin{enumerate}
\item the Z document requires the presence of the theory $cn$, which is not provided as standard in {\ProductZ} databases (so that {\tt database} in the example above must refer to a Compliance Tool database);
\item loading the Z document attempts to create {\Product} theories which will already exist in a database in which the literate script giving rise to the Z document has already been processed (so that these theories must be deleted, or a fresh Compliance Tool database created, if the loading is to succeed);
\item loading the Z document does not recreate the information about the SPARK program which is computed and stored when the literate script is processed
(so that facilities such as the VC browser which require this information will no longer be useful).
\end{enumerate}

\section{Using the VC Browser}\label{VCBrowser}
Figure \ref{fig2} on page \pageref{fig2} gives another example of an {\tt xpp} Main Window.
In this example, the user has used the Command Line Tool to issue commands to load an entire script into the tool and then display the Z document in the Journal Window.
The Search-and-Replace Tool has been used to carry out a textual search in the Script Window for the refinement step which introduced the VC at the end of the Z document.

Using an editor to correlate the script with the VCs can be a useful technique but is often time consuming.
The VC Browser gives an easy way of examining the VCs and relating them to the Compliance Notation clauses which produced them.
The VC Browser is started by running the {\ProductML} command `$browse\_vcs()$'.
This produces a window like the one shown in figure \ref{fig3} on page \pageref{fig3}.


The main controls in the VC Browser are two scrolling lists of names and some push-buttons.
Above each list is a text area.

The list on the left contains the names of the clauses in the script;
the list on the right the names of the VCs.
Double-click on an item in either list to display the clause or VC in the text area above the list.

The buttons marked `Filter' are used to find the clause corresponding to a selected VC and the VCs corresponding to a selected clause.
After you have used one of the `Filter' buttons, you can use the corresponding `Reset' button to restore the contents of the list.

In figure \ref{fig3}, the user has double clicked on the label `$5$' in order to see the corresponding refinement step.
Pressing the right-hand filter button has then resulted in the corresponding VC  being listed and displayed on the right (in this case there is only one VC).

If you have processed several literate scripts in one Compliance Tool database,  the conventions for preservation of state described in section \ref{StatePreservation} may be used to advantage with the VC browser.
The function $set\_cn\_state$ allows you to view VCs from any of the literate scripts.
For example, if you have processed scripts called $A$, $B$ and $C$, and then invoked the VC browser in the same session, you will initially be working with the VCs from script $C$.
To look at the VCs from script $A$, enter the {\ProductML} command

=GFT
	set_cn_state A_state;
=TEX
and then press the two `Reset' buttons in the VC browser.

A $set\_cn\_state$ command similar to the one shown above is necessary in order to use the VC browser in an interactive session after loading one or more scripts in batch (otherwise the VC browser will display the VCs for the last script loaded but will not be able to relate them to the corresponding Compliance Notation clauses).
 

\begin{figure}[p]
\begin{center}
\leavevmode
\epsffile{usr501B.ps}
\end{center}
\caption{Inspecting VCs with {\tt xpp}}\label{fig2}
\end{figure}

\begin{figure}[p]
\begin{center}
\leavevmode
\epsffile{usr501C.ps}
\end{center}
\caption{Inspecting VCs with the VC Browser}\label{fig3}
\end{figure}

\pagebreak
\section{Editing and Checking a Script}\label{Editing}

The {\tt xpp} Script Window provides a general purpose editor for use in preparing scripts.
The {\Product} document \cite{DS/FMU/IED/USR004} or the {\tt xpp} help system may be consulted for an introduction to its use.
The easiest way to begin constructing a new script is to adapt an existing one, and a number of examples are supplied with the Compliance Tool for this purpose.

Just as with a {\ProductZ} specification, a Compliance Notation script may be entered a clause at a time so that errors can be detected and corrected interactively. 
Note however, that the initialisation section of the script as described in section \ref{Initialisation} has to be entered first of all, and that clauses will generally need to be entered in the correct order.

In the case of syntax errors, and many errors encountered during VC generation, a clause can simply be re-entered after the error has been corrected.
In some cases, however, processing of a clause containing errors can prevent subsequent re-entry of the correct clause.
In these cases, the script has to be re-entered from the beginning.
This can be done without restarting the tool by using the {\ProductML} command:

=GFT
	force_delete_theory"SCRIPT";
=TEX
\ where
=INLINEFT
SCRIPT
=TEX
\ is the name of the script as given in the initialisation section and then carrying on with the $new\_script$ command for the script as normal.


To make entry of Compliance Notation constructs easier, the Templates Tool in {\tt xpp} has been customised so that you can enter a template for any of the following constructs with one button-press:

\begin{enumerate}
\item
Replacement Step;
\item
Refinement Step;
\item
Compilation Unit;
\item
Specification Statement;
\item
Each of the 8 Z Paragraph forms.
\end{enumerate}

The customised Templates Tool may be seen in figure \ref{fig4} on page \pageref{fig4}.
The four buttons at the bottom are for the four Compliance Notation constructs listed above.
In the figure the user has just pressed the refinement step button and has started to fill in the template at the bottom of the Script Window --- the label has been filled in and the ellipsis, `\ldots', has been selected ready to be replaced by the statement part of the refinement.

\begin{figure}[p]
\begin{center}
\leavevmode
\epsffile{usr501D.ps}
\end{center}
\caption{Compliance Notation Templates Tool}\label{fig4}
\end{figure}

\section{Accessing and Proving VCs}\label{AccessingVCs}

VCs are represented in the tool using Z's conjecture paragraph form.
A conjecture paragraph associates a name with a Z predicate, and is used in specifications to record properties which the specifier believes to be true of the objects specified.
In {\Product}  the function $get\_conjecture$ retrieves a conjecture from a specification by name.
The conjecture is retrieved as a Z term which can be used, e.g., to form a goal for proof with the {\Product} Subgoal Package.

The tool assigns a name to each Compliance Notation clause in the script being processed and this name is used as the basis for the names of any VCs generated by the clause.
In the case of clauses containing a package or similar named SPARK object, the name is taken from the object name;
for other clauses the name is derived from the implicit or explicit numeric label associated with the clause.

Examples of clause names and VC names can be seen in  \ref{fig3} on page \pageref{fig3}.
Here the clause name $5$ on the left refers to the refinement step refining label $5$.
The VCs corresponding to the clause named $5$ are named $vc5\_1$, $vc5\_2$, etc. (in this case there is only one).
A clause name like $4\_11$ is used for the $11$-th unlabelled refinement step in the script, with the $4$ indicating that this refinement step comes after the one labelled $4$.

To access the VC in the example, one would use the {\ProductML} function call:

=GFT
	get_conjecture "wrk501" "vc5_1";
=TEX

Here the first parameter gives the name of the literate script which gave rise to the VC.
Proof of a VC will normally need to be carried out within the theory corresponding to the literate script in question.
Thus, to begin work on a proof of the VC with the Subgoal Package, the following commands would be used:

=GFT
	open_theory "wrk501";
	set_goal([], get_conjecture "wrk501" "vc5_1");
=TEX

As ordinary Z goals, VCs may be proved using all of the normal facilities provided by {\Product} for proof in Z.
Some extensions to the Z toolkit are used in many VCs.
These extensions are contained in the theory $cn$.
Some custom support is provided in the Compliance Tool to assist with reasoning in this theory, most notably the proof contexts $cn$ and $cn\_ext$.
These proof contexts and the other custom proof tools are described in section \ref{CustomProofFacilities} of this document.
The user interface to the conversions etc. described there is via the proof contexts, so that most users will only need to be familiar with the proof contexts.
An example of a complete proof script for a literate script is included in chapter~\ref{EXAMPLESCRIPT}

\section{Printing and Previewing Scripts}\label{PrintingAndPreviewing}
You can produce a {\LaTeX} document from a Compliance Notation script using {\Product}'s document preparation facilities, which are described in detail in \TUTORIAL.
The UNIX command {\tt doctex} is used to produce the {\LaTeX} file which you can then run through {\LaTeX} using the UNIX command {\tt texdvi}.
You can then print or preview the resulting DVI file using the programs provided with your {\LaTeX} installation.

So for example, to print the script in file {\tt wrk507.doc} on a PostScript printer, you might use the following UNIX commands:

\begin{verbatim}
        doctex wrk507
        texdvi wrk507
        dvips wrk507
\end{verbatim}

You can also generate a DVI file with embedded hypertext links, which help you relate k-slots and specification statements with the corresponding replacement steps and refinement steps.
To do this, you use a Compliance Tool function which generates an edit script which can be used by {\tt doctex} to make the links.
For example, the example script {\tt wrk507.doc}, contains the following {\ProductML} command at the end:

=GFT
output_hypertext_edit_script{out_file="wrk507.ex"};
=TEX

When the script has been loaded, the DVI file with hypertext links can be produced using the UNIX commands:

=GFT
        doctex -e wrk507.ex wrk507
        texdvi wrk507
=TEX

The resulting DVI file, {\tt wrk507.dvi}, can then be viewed with a hypertext viewer such as {\tt xhdvi}.
You can navigate around the script by clicking on the underlined arrows which appear in the margins near k-slots, specification statements, refinement steps and replacement steps.

\chapter{EXAMPLE SCRIPT}\label{EXAMPLESCRIPT}
In this chapter, we give an example literate script, following the conventions recommended in chapter~\ref{LITERATESCRIPTCONVENTIONS}.
The script shows the initial part of the compliance argument for a SPARK procedure for computing integer square roots.

Section \ref{TheLiterateScript} contains the script and associated {\Product} commands.
Sections \ref{TheZDocument} and  \ref{TheSPARKProgram} shows the corresponding Z document and SPARK Program.
Section \ref{TheProofs} contains proofs of the VCs produced by the script and section \ref{TheTheoryListing} shows the listing of the resulting {\Product} theory.

\section{The Literate Script}\label{TheLiterateScript}
\subsection{Initialisation Commands}
This script does not depend on any other script, it is therefore processed starting from the initial state.
We give it the name $usr501$ (since this document is {\tt usr501.doc}):

\Hide{%
=SML
force_delete_theory"usr501" handle Fail _ => ();
=TEX
}
=SML
new_script{name = "usr501", state = initial_cn_state};
=TEX
\subsection{The Compliance Argument}
For simplicity, we present the square root function as a top-level procedure.
The procedure has a specification statement requiring that for non-negative input values of $X$, the output value of $Y$ is the integer part of the square root of $X$.

¹CN
procedure SQRT (X : INTEGER; Y : out INTEGER)

„ Y [X ¾ 0, Y ** 2 ¼ X < (Y + 1) ** 2]

is
   LO : INTEGER;

   § local vars ¢		(2)

begin
   LO := 0;

    „ LO [X ¾ 0 ± LO = 0, LO ** 2 ¼ X < (LO + 1) ** 2]

   Y := LO;
end SQRT;
°

¹CN
(2) é

HI : INTEGER;
°

¹CN
Ã
„ LO, HI [X ¾ 0 ± LO = 0, LO ** 2 ¼ X < (LO + 1) ** 2]
°

¹CN
Ã

HI := X + 1;

till ûLO ** 2 ¼ X < (LO + 1) ** 2ý

loop

    „ LO, HI [LO ** 2 ¼ X < HI ** 2, LO ** 2 ¼ X < HI ** 2]

end loop;
°

¹CN
Ã

exit when LO + 1 = HI;

„ LO, HI [LO ** 2 ¼ X < HI ** 2, LO ** 2 ¼ X < HI ** 2]
°
Note the development is not complete at this point.
However, we can still output the Z document and the SPARK program as if it were, and begin to do proofs.
The fact that the development is not complete is made manifest in the SPARK program which will contain null statements corresponding to the omissions, see section \ref{TheSPARKProgram}.
\subsection{Output Commands}
=SML
output_z_document{script="usr501", out_file="usr501.zdoc"};
output_spark_program{out_file="usr501.ada"};
=TEX
\subsection{State Preservation}
=SML
val usr501_state = get_cn_state();
=TEX
\pagebreak
\section{The Z Document}\label{TheZDocument}
The following shows the Z document produced by the example script.

\Hide{%
=SML
force_delete_theory"usr501" handle Fail _ => ();
=TEX
}
=SML
new_theory "usr501";

¹Z
Ü vcSQRT_1 ?ô
Ü     µ X : INTEGER | X ¾ 0 · X ¾ 0 ± 0 = 0
°

¹Z
Ü vcSQRT_2 ?ô
Ü     µ LO : INTEGER; X : INTEGER
Ü       | X ¾ 0 ± LO ** 2 ¼ X ± X < (LO + 1) ** 2
Ü       · LO ** 2 ¼ X ± X < (LO + 1) ** 2
°

¹Z
Ü vc2_1_1 ?ô
Ü     µ LO : INTEGER; X : INTEGER | X ¾ 0 ± LO = 0 · X ¾ 0 ± LO = 0
°

¹Z
Ü vc2_1_2 ?ô
Ü     µ LO, LO‰0 : INTEGER; X : INTEGER
Ü       | (X ¾ 0 ± LO‰0 = 0) ± LO ** 2 ¼ X ± X < (LO + 1) ** 2
Ü       · LO ** 2 ¼ X ± X < (LO + 1) ** 2
°

¹Z
Ü vc2_2_1 ?ô
Ü     µ LO : INTEGER; X : INTEGER
Ü       | X ¾ 0 ± LO = 0
Ü       · LO ** 2 ¼ X ± X < (X + 1) ** 2
°

¹Z
Ü vc2_2_2 ?ô
Ü     µ HI : INTEGER; LO, LO‰0 : INTEGER; X : INTEGER
Ü       | (X ¾ 0 ± LO‰0 = 0) ± LO ** 2 ¼ X ± X < HI ** 2
Ü       · LO ** 2 ¼ X ± X < HI ** 2
°

¹Z
Ü vc2_2_3 ?ô
Ü     µ LO, LO‰0 : INTEGER; X : INTEGER
Ü       | (X ¾ 0 ± LO‰0 = 0) ± LO ** 2 ¼ X ± X < (LO + 1) ** 2
Ü       · LO ** 2 ¼ X ± X < (LO + 1) ** 2
°

¹Z
Ü vc2_3_1 ?ô
Ü     µ HI : INTEGER; LO : INTEGER; X : INTEGER
Ü       | (LO ** 2 ¼ X ± X < HI ** 2) ± LO + 1 eq HI = TRUE
Ü       · LO ** 2 ¼ X ± X < (LO + 1) ** 2
°

¹Z
Ü vc2_3_2 ?ô
Ü     µ HI : INTEGER; LO : INTEGER; X : INTEGER
Ü       | (LO ** 2 ¼ X ± X < HI ** 2) ± LO + 1 eq HI = FALSE
Ü       · LO ** 2 ¼ X ± X < HI ** 2
°

¹Z
Ü vc2_3_3 ?ô
Ü     µ HI, HI‰0 : INTEGER; LO, LO‰0 : INTEGER; X : INTEGER
Ü       | (LO‰0 ** 2 ¼ X ± X < HI‰0 ** 2) ± LO ** 2 ¼ X ± X < HI ** 2
Ü       · LO ** 2 ¼ X ± X < HI ** 2
°
=SML
(* Number of VCs in theory "usr501" : 10 *)
=TEX
\pagebreak
\section{The SPARK Program}\label{TheSPARKProgram}
The following shows the SPARK program produced by the example script.
Note the $NULL$ statement the tool has introduced because the development was not complete.
The comment on the $NULL$ statements means that the unlabelled specification statement to which the tool has assigned label $2\_4$ has not been refined.

\begin{verbatim}
  PROCEDURE SQRT (X : IN INTEGER; Y : OUT INTEGER)
    -- Spec ...
  IS
    LO : INTEGER;
    HI : INTEGER;
  BEGIN
    LO := 0;
    HI := X + 1;
    -- TILL ...
    LOOP
      EXIT WHEN LO + 1 = HI;
      NULL; -- 2_4
    END LOOP;
    Y := LO;
  END SQRT;
\end{verbatim}
  

\pagebreak
\section{The Proofs}\label{TheProofs}
To embark on the proofs of the VCs, we first open the theory for the literate script:
=SML
open_theory"usr501";
=TEX
We will work in the proof context $cn$ most of the time:
=SML
set_pc"cn";
=TEX
The statements of the VCs may be seen in the Z document in section \ref{TheZDocument} or in the theory listing in section \ref{TheTheoryListing}.

All but one of the VCs are little more than tautologies, and will be proved by repeating $strip\_tac$.
=SML
set_goal([], get_conjecture "usr501" "vcSQRT_1");
a(REPEAT strip_tac);
val vcSQRT_1_thm = save_pop_thm"vcSQRT_1_thm";
=TEX
=SML
set_goal([], get_conjecture "usr501" "vcSQRT_2");
a(REPEAT strip_tac);
val vcSQRT_2_thm = save_pop_thm"vcSQRT_2_thm";
=TEX
=SML
set_goal([], get_conjecture "usr501" "vc2_1_1");
a(REPEAT strip_tac);
val vc2_1_1_thm = save_pop_thm"vc2_1_1_thm";
=TEX
=SML
set_goal([], get_conjecture "usr501" "vc2_1_2");
a(REPEAT strip_tac);
val vc2_1_2_thm = save_pop_thm"vc2_1_2_thm";
=TEX
Before proving the next VC, we need to prove some simple facts about exponientation, namely:
=INLINEFT
x ** 1 = x
=TEX
\ and  
=INLINEFT
x ** 2 = x * x
=TEX
. The proofs require little more than specialising the definition of
=INLINEFT
(_**_)
=TEX
\ appropriately.
=SML
set_goal([], ñµx: ú·  x ** 1 = x®);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[](
    z_µ_elimñ(x ¦ x, y ¦ 0)® (±_right_elim(z_get_specñ(_**_)®)))]);
val star_star_1_thm = pop_thm();
=TEX
=SML  
set_goal([], ñµx: ú·  x ** 2 = x * x®);
a(REPEAT strip_tac);
a(rewrite_tac[star_star_1_thm, rewrite_rule[](
    z_µ_elimñ(x ¦ x, y ¦ 1)® (±_right_elim(z_get_specñ(_**_)®)))]);
val star_star_2_thm = pop_thm();
=TEX
The meat of the next VC is that for non-negative $X$,
=INLINEFT
X ¼ (X + 1) ** 2
=TEX
.
Induction is used to prove this, together with the above lemmas and the automatic prover for linear arithmetic.
=SML
set_goal([], get_conjecture "usr501" "vc2_2_1");
a(REPEAT strip_tac THEN asm_rewrite_tac[star_star_2_thm]);
a(DROP_NTH_ASM_T 2 ante_tac THEN DROP_ASMS_T discard_tac THEN strip_tac);
a(z_¼_induction_tacñX® THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val vc2_2_1_thm = save_pop_thm"vc2_2_1_thm";
=TEX
The remaining VCs are straightforward:
=SML
set_goal([], get_conjecture "usr501" "vc2_2_2");
a(REPEAT strip_tac);
val vc2_2_2_thm = save_pop_thm"vc2_2_2_thm";
=TEX
=SML
set_goal([], get_conjecture "usr501" "vc2_2_3");
a(REPEAT strip_tac);
val vc2_2_3_thm = save_pop_thm"vc2_2_3_thm";
=TEX
=SML
set_goal([], get_conjecture "usr501" "vc2_3_1");
a(rewrite_tac[]);
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
val vc2_3_1_thm = save_pop_thm"vc2_3_1_thm";
=TEX
=SML
set_goal([], get_conjecture "usr501" "vc2_3_2");
a(REPEAT strip_tac);
val vc2_3_2_thm = save_pop_thm"vc2_3_2_thm";
=TEX
=SML
set_goal([], get_conjecture "usr501" "vc2_3_3");
a(REPEAT strip_tac);
val vc2_3_3_thm = save_pop_thm"vc2_3_3_thm";
=TEX


\pagebreak
\section{The Theory Listing}\label{TheTheoryListing}
The following is the listing of the theory $usr501$ produced by the example script and the proofs in the previous section.
=THEORYLISTINGSECTION
Parents
=TEX
=THEORYLISTINGTABLE
	cache'daz	cn
=TEX
=THEORYLISTINGSECTION
Conjectures
=TEX
=THEORYLISTINGOTHER
vcSQRT_1
	µ X : INTEGER | X ¾ 0 · X ¾ 0 ± 0 = 0
vcSQRT_2
	µ LO : INTEGER; X : INTEGER
	  | X ¾ 0 ± LO ** 2 ¼ X ± X < (LO + 1) ** 2
	  · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_1_1	µ LO : INTEGER; X : INTEGER
	  | X ¾ 0 ± LO = 0
	  · X ¾ 0 ± LO = 0
vc2_1_2	µ LO, LO‰0 : INTEGER; X : INTEGER
	  | (X ¾ 0
	    ± LO‰0 = 0)
	    ± LO ** 2 ¼ X
	    ± X < (LO + 1) ** 2
	  · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_2_1	µ LO : INTEGER; X : INTEGER
	  | X ¾ 0 ± LO = 0
	  · LO ** 2 ¼ X ± X < (X + 1) ** 2
vc2_2_2	µ HI : INTEGER; LO, LO‰0 : INTEGER; X : INTEGER
	  | (X ¾ 0 ± LO‰0 = 0) ± LO ** 2 ¼ X ± X < HI ** 2
	  · LO ** 2 ¼ X ± X < HI ** 2
vc2_2_3	µ LO, LO‰0 : INTEGER; X : INTEGER
	  | (X ¾ 0
	    ± LO‰0 = 0)
	    ± LO ** 2 ¼ X
	    ± X < (LO + 1) ** 2
	  · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_3_1	µ HI : INTEGER; LO : INTEGER; X : INTEGER
	  | (LO ** 2 ¼ X ± X < HI ** 2) ± LO + 1 eq HI = TRUE
	  · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_3_2	µ HI : INTEGER; LO : INTEGER; X : INTEGER
	  | (LO ** 2 ¼ X ± X < HI ** 2) ± LO + 1 eq HI = FALSE
	  · LO ** 2 ¼ X ± X < HI ** 2
vc2_3_3	µ HI, HI‰0 : INTEGER; LO, LO‰0 : INTEGER; X : INTEGER
	  | (LO‰0 ** 2 ¼ X
	    ± X < HI‰0 ** 2)
	    ± LO ** 2 ¼ X
	    ± X < HI ** 2
	  · LO ** 2 ¼ X ± X < HI ** 2
=TEX
=THEORYLISTINGSECTION
Theorems
=TEX
=THEORYLISTINGOTHER
vcSQRT_1_thm
	ô µ X : INTEGER | X ¾ 0 · X ¾ 0 ± 0 = 0
vcSQRT_2_thm
	ô µ LO : INTEGER; X : INTEGER
	    | X ¾ 0 ± LO ** 2 ¼ X ± X < (LO + 1) ** 2
	    · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_1_1_thm
	ô µ LO : INTEGER; X : INTEGER
	    | X ¾ 0 ± LO = 0
	    · X ¾ 0 ± LO = 0
vc2_1_2_thm
	ô µ LO, LO‰0 : INTEGER; X : INTEGER
	    | (X ¾ 0
	      ± LO‰0 = 0)
	      ± LO ** 2 ¼ X
	      ± X < (LO + 1) ** 2
	    · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_2_1_thm
	ô µ LO : INTEGER; X : INTEGER
	    | X ¾ 0 ± LO = 0
	    · LO ** 2 ¼ X ± X < (X + 1) ** 2
vc2_2_2_thm
	ô µ HI : INTEGER; LO, LO‰0 : INTEGER; X : INTEGER
	    | (X ¾ 0 ± LO‰0 = 0) ± LO ** 2 ¼ X ± X < HI ** 2
	    · LO ** 2 ¼ X ± X < HI ** 2
vc2_2_3_thm
	ô µ LO, LO‰0 : INTEGER; X : INTEGER
	    | (X ¾ 0
	      ± LO‰0 = 0)
	      ± LO ** 2 ¼ X
	      ± X < (LO + 1) ** 2
	    · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_3_1_thm
	ô µ HI : INTEGER; LO : INTEGER; X : INTEGER
	    | (LO ** 2 ¼ X ± X < HI ** 2) ± LO + 1 eq HI = TRUE
	    · LO ** 2 ¼ X ± X < (LO + 1) ** 2
vc2_3_2_thm
	ô µ HI : INTEGER; LO : INTEGER; X : INTEGER
	    | (LO ** 2 ¼ X
	      ± X < HI ** 2)
	      ± LO + 1 eq HI = FALSE
	    · LO ** 2 ¼ X ± X < HI ** 2
vc2_3_3_thm
	ô µ HI, HI‰0 : INTEGER; LO, LO‰0 : INTEGER; X : INTEGER
	    | (LO‰0 ** 2 ¼ X
	      ± X < HI‰0 ** 2)
	      ± LO ** 2 ¼ X
	      ± X < HI ** 2
	    · LO ** 2 ¼ X ± X < HI ** 2
=TEX
=THEORYLISTINGTRAILER
End of listing of theory usr501
=TEX


\chapter{{\ProductML} COMPLIANCE TOOL REFERENCE}\label{COMMANDREF}
The following sections give reference documentation for the principal {\ProductML} commands which are specific to the Compliance Tool,
followed by the theory listing of ``cn''.
Consult the {\Product} reference manual for further information on {\ProductML} commands mentioned in this document which are not mentioned here.

\section{Controlling the Tool}
\input{usr501E.tex}
\pagebreak
\section{Custom Proof Facilities}\label{CustomProofFacilities}
=IGN
dtd509
=TEX
\input{usr501F.tex}

=IGN
dtd518
=TEX
\input{usr501G.tex}

=IGN
dtd517
=TEX
\input{usr501H.tex}

\input{cn.thl.tex}

\chapter*{REFERENCES}
\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
\bibliography{fmu,daz}
 
\pagebreak
\twocolumn
\chapter*{INDEX}
\addcontentsline{toc}{chapter}{INDEX}
\small
 
\printindex

\end{document}


