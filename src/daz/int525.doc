=IGN
********************************************************************************
int525.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Compliance Tool --- 2.7.4 Enhancement Tests}

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document provides integration tests to support the enhancements developed 
for version 2.7.4 of the Compliance Tool during  Autumn 2004.}
\end{center}}

\def\Reference{LEMMA1/DAZ/INT525}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.5 $%
}
\def\Date{\FormatDate{$Date: 2004/10/27 17:05:46 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\underscoreoff
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
h{\raggedright
\bibliography{fmu,daz}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1]  Test for PC61
\item[Issues 1.2]  Test for PC63
\item[Issues 1.3]  Test for MA37
\item[Issue 1.4] Test for liberalised renaming and for fix to informal procedure unsoundness problem.
\item[Issue 1.5] Test for option to ignore SPARK annotations (QQ52).
\item[Issue 1.6] Improved coverage of tests for renaming.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Rob Arthan & Lemma 1
\end{tabular}
\end{center}


\section{INTRODUCTION}\label{INTRODUCTION}
This document is intended to provide integration tests to cover
the enhancements undertaken under the programme
of enhancements carried out in Autumn 2004 resutling in version 2.7.4 of the Compliance Tool.

Note the vast majority of the tests for 2.7.4 are actually distributed where they belong in other test docuemnts (and a few are misplaced in LEMMA1/DAZ/INT524 for historical reasons).

\section{PREAMBLE}
Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.

=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn"
                                        diff get_cache_theories())
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	val err_scrs =map fst (CNZGenerator.get_exception_logs());
        in      map del_thy thys;
	map delete_exception_log err_scrs;
	open_theory"cn";
	set_pc "cn1"
        end;    ()
);
=TEX
For batch use turn off subgoal package output:
=SML
set_flag("subgoal_package_quiet", not(ExtendedIO.is_term_in std_in));
=TEX
\section{THE TESTS}
\subsection{PC61: Data refinement in global dependencies of procedures}
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

¹CN
package A is
  auxiliary A : ú;
  procedure P (Y : out Integer)
    „ Y ˜ A [ Y = A + 1 ]
  ;
end A;
°
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
¹CN
package body A is
  using C : Integer; implement A by C = ~A;
  procedure P (Y : out Integer)
    „ Y ˜ C [ Y = ~C + 1 ]             -- should work now
  --„ Y, C ˜ [ Y = ~C + 1 ± C = C‰0 ]  -- ok
  is begin
    Y := 1 - C;
  end P;
end A;
°
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcAbody_3");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC61.1.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{PC63: Data refinement in global dependencies of procedures}
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};
¹CN
package A is
  procedure P;
end A;
°
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
¹CN
package body A is

  X : Boolean;
  Y : Integer;

  § F ¢		(1)

  § P ¢		(2)

end A;
°
¹CN
 (1) é
  function F return Boolean ˜ X [ F X = X ] is begin return X; end F;
°
¹CN
 (2) é
  procedure P
    „ Y ˜ X [ X = TRUE ± Y = 5 ² X = FALSE ± Y = 7 ]
  is begin
    if F
    then
      Y := 5;
    else
      Y := 7;
    end if;
  end P;
°
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc1_1");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC63.1.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{MA37: More liberal treatment of using clauses}
Various cases to test.

1) General ability to introduce using clause in k-slot.
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

¹CN
package A is
  auxiliary A : ú;
  procedure P (Y : out Integer)
    „ Y ˜ A [ Y = A + 1 ]
  ;
end A;
°
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
¹CN
package body A is
 § using clause and procedure p ¢			( 1 )
end A;
°

¹CN
 (1) é 
  using C : Integer; implement A by C = ~A;
  procedure P (Y : out Integer)
    „ Y ˜ C [ Y = ~C + 1 ]             -- should work now
  --„ Y, C ˜ [ Y = ~C + 1 ± C = C‰0 ]  -- ok
  is begin
    Y := 1 - C;
  end P;
°
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc1_3");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC37.1.1", fun_true o pop_thm , (), true)];
=TEX
2) Propagation of using clause into other k-slot.
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

¹CN
package A is
  auxiliary A : ú;
  procedure P (Y : out Integer)
    „ Y ˜ A [ Y = A + 1 ]
  ;
end A;
°
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
¹CN
package body A is
 § using clause ¢			( 1 )
 § procedure p ¢			( 2 )
end A;
°

¹CN
 (1) é  using C : Integer; implement A by C = ~A;
°
¹CN
 (2) é
  procedure P (Y : out Integer)
    „ Y ˜ C [ Y = ~C + 1 ]             -- should work now
  --„ Y, C ˜ [ Y = ~C + 1 ± C = C‰0 ]  -- ok
  is begin
    Y := 1 - C;
  end P;
°
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc2_3");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC37.2.1", fun_true o pop_thm , (), true)];
=TEX
3) Error cases: using clause are only allowed in package body:
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

=SML
fun check37_3() = (
¹CN
 procedure P (Y : out Integer)
    „ Y [ Y = 42 ] 
  is
  using C : Integer; implement A by C = ~A;
 begin
    Y := 1 - C;
  end P;
°
=SML
false) handle Fail _ => true;
store_mt_results
mt_run
 [("PC37.3.1", check37_3 , (), true)];
=TEX
\subsection{QQ50: Liberalise renaming of informal procedures and functions}
Renaming declation of informal procedure should not give rise to error:
=SML
clean_up();
new_script {name = "renames.1", state = initial_cn_state};
¹CN
 procedure p1
 „ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure rq  (x : in out integer) renames q;
begin
 null; -- should not fail
end p1;
°
=TEX
Just need to get here to pass the first test:
=SML
store_mt_results
mt_run
 [("Renames.1.1", fun_true , (), true)];
=TEX
Attempt to use the procedure via the new name should fail:
=SML
clean_up();
new_script {name = "renames.2", state = initial_cn_state};
=SML
fun renames2() = 
¹CN
 procedure p1
 „ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure rq  (x : in out integer) renames q;
begin
 rq; -- should fail
end p1;
°
=TEX
Check that it raises an exception
=SML
store_mt_results
mt_run
 [("Renames.2.1", (fn _ => (renames2 (); false) handle Fail _ => true) , (), true)];
=TEX
Check out renaming of functions in package specifications.
=SML
clean_up();
new_script {name = "renames.3.1", state = initial_cn_state};
=SML
fun renames3_1() = 
¹CN
package A is

  function F return Integer;

  function G return Integer renames F;

  function F1 return Integer
   ˜ [F1 = 100] ;

end A;
°
=SML
store_mt_results
mt_run
 [("Renames.3.1", (fn _ => (renames3_1(); true) handle Fail _ => false) , (), true)];
=TEX
=SML
new_script {name = "renames.3.2", state = get_cn_state()};
=SML
fun renames3_2() = 
¹CN
with A;
package B is

  function H return Integer renames A.F;
  function I return Integer renames A.G;
  function H1 return Integer renames A.F1;
end B;
°
=SML
store_mt_results
mt_run
 [("Renames.3.2", (fn _ => (renames3_2 (); true) handle Fail _ => false) , (), true)];
=TEX
=SML
new_script {name = "renames.3.3", state = get_cn_state()};
=SML
¹CN
with B;
use B;
procedure P(X : out Integer)
is
  function PF return Integer renames B.I;
begin
  „ X [X > 0]
end P;
°
¹CN
  Ã X := H1;
°
=TEX
=SML
set_pc"cn1";

set_goal([], get_conjecture"-""vc_1_1");
a(rewrite_tac (map z_get_spec[ñH1®, ñAoF1®]));
store_mt_results
mt_run
 [("Renames.3.3", fun_true o pop_thm , (), true)];
=SML
=TEX
=TEX
\subsection{QQ51: Fix unsoundness caused by ignoring informal procedures}
Multiple informal procedures should not give rise to error:
=SML
clean_up();
new_script {name = "InfProc.1", state = initial_cn_state};
¹CN
 procedure p1
 „ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure q (y : in out integer)
  is begin x := 1; end q;
begin
 null; -- should not fail
end p1;
°
=TEX
Just need to get here to pass the first test:
=SML
store_mt_results
mt_run
 [("InfProc.1.1", fun_true , (), true)];
=TEX
Attempt to declare formal after informal  should fail:
=SML
clean_up();
new_script {name = "InfProc.2", state = initial_cn_state};
=SML
fun inf_proc2() = 
¹CN
 procedure p1
 „ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure q (x : in out integer)
 „ X [ X = 1 ]
  is begin x := 1; end q;
begin
 null;
end p1;
°
=TEX
Check that it raises an exception
=SML
store_mt_results
mt_run
 [("InfProc.2.1", (fn _ => (inf_proc2 (); false) handle Fail _ => true) , (), true)];
=TEX
Attempt to declare informal after formal  should fail:
=SML
clean_up();
new_script {name = "InfProc.3", state = initial_cn_state};
=SML
fun inf_proc3() = 
¹CN
 procedure p1
 „ [ true ]
 is
  procedure q (x : in out integer)
 „ X [ X = 1 ]
  is begin x := 1; end q;
  procedure q (x : in out integer)
  is begin x := 1; end q;
begin
 null;
end p1;
°
=TEX
Check that it raises an exception
=SML
store_mt_results
mt_run
 [("InfProc.3.1", (fn _ => (inf_proc3 (); false) handle Fail _ => true) , (), true)];
=TEX
\subsection{QQ52: Option to ignore SPARK annotations}
Renaming declation of informal procedure should not give rise to error:
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};
¹CN
package A is

end A;
°

=SML
new_script {name = "b.ads", state = get_cn_state ()};
¹CN
package B is

end B;
°

=SML

new_script {name = "c.ads", state = get_cn_state ()};

=SML
fun qq52_fail () =
¹CN

with A;

--# inherits A

references B;

-- works here ok

package C is

end C;
°
=TEX
Check that the above raises an exception
=SML
store_mt_results
mt_run
 [("qq52.1.1", (fn _ => (qq52_fail (); false) handle Fail _ => true) , (), true)];
=TEX
Now change the flag and check that it works:
=SML
val was_i_s_a = set_flag("cn_ignore_spark_annotations", true);
store_mt_results
mt_run
 [("qq52.1.2", (fn _ => (qq52_fail (); false) handle Fail _ => true) , (), false)];
val _ = set_flag("cn_ignore_spark_annotations", was_i_s_a);
=TEX
\section{EPILOGUE}
=SML
diag_line(summarize_mt_results());
=TEX
\end{document}
