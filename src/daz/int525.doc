=IGN
********************************************************************************
int525.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Compliance Tool --- 2.7.4--2.7.6 Enhancement Tests}

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document provides integration tests to support the enhancements developed 
for versions 2.7.4 to 2.7.6 of the Compliance Tool during 2004/2005.}
\end{center}}

\def\Reference{LEMMA1/DAZ/INT525}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 948 4409}

\def\Fax{+44 118 946 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.19 $%
}
\def\Date{\FormatDate{$Date: 2005/09/14 11:32:14 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\underscoreoff
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
h{\raggedright
\bibliography{fmu,daz}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1]  Test for PC61
\item[Issues 1.2]  Test for PC63
\item[Issues 1.3]  Test for MA37
\item[Issue 1.4] Test for liberalised renaming and for fix to informal procedure unsoundness problem.
\item[Issue 1.5] Test for option to ignore SPARK annotations (QQ52).
\item[Issue 1.6] Improved coverage of tests for renaming.
\item[Issue 1.7] Test treatment of forward declarations of informal functions.
\item[Issue 1.8] Test that initial variables corresponding to out mode parameters give an error.
\item[Issue 1.9] Test that labelled statements and goto statements are handled correctly.
\item[Issue 1.10] Added tests for QQ73.
\item[Issues 1.11,1.12] Added tests for QQ85.
\item[Issue 1.13] Added tests for QQ74.
\item[Issue 1.14] Compliance Notation reserved words are now prefixed by a dollar sign.
\item[Issue 1.15] Added test to show that results of {\em fmt\_web\_clause} can be processed back into the tool.
\item[Issues 1.16, 1.17] Added tests for QQ94 and QQ95.
\item[Issue 1.18] Tests for QQ98.
\item[Issue 1.19, 1.20] Tests adjusted added for enhanced error messages when formal material invalidly contains free variables.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Rob Arthan & Lemma 1
\end{tabular}
\end{center}


\section{INTRODUCTION}\label{INTRODUCTION}
This document is intended to provide integration tests to cover
the enhancements undertaken under the programme
of enhancements carried out in Autumn 2004 resutling in version 2.7.4 of the Compliance Tool.

Note the vast majority of the tests for 2.7.4 are actually distributed where they belong in other test docuemnts (and a few are misplaced in LEMMA1/DAZ/INT524 for historical reasons).

\section{PREAMBLE}
Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.

=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn"
                                        diff get_cache_theories())
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	val err_scrs =map fst (CNZGenerator.get_exception_logs());
        in      map del_thy thys;
	map delete_exception_log err_scrs;
	open_theory"cn";
	set_pc "cn1"
        end;    ()
);
=TEX
For batch use turn off subgoal package output:
=SML
set_flag("subgoal_package_quiet", not(ExtendedIO.is_term_in std_in));
=TEX
Work in proof context cn1 by default:
=SML
set_pc "cn1";
=TEX
\section{THE TESTS}
\subsection{PC61: Data refinement in global dependencies of procedures}
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

πCN
package A is
  $auxiliary A : ˙;
  procedure P (Y : out Integer)
    Ñ Y ò A [ Y = A + 1 ]
  ;
end A;
∞
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
πCN
package body A is
  $using C : Integer; $implement A $by C = ~A;
  procedure P (Y : out Integer)
    Ñ Y ò C [ Y = ~C + 1 ]             -- should work now
  --Ñ Y, C ò [ Y = ~C + 1 ± C = Câ0 ]  -- ok
  is begin
    Y := 1 - C;
  end P;
end A;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcAbody_3");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC61.1.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{PC63: Data refinement in global dependencies of procedures}
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};
πCN
package A is
  procedure P;
end A;
∞
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
πCN
package body A is

  X : Boolean;
  Y : Integer;

  ß F ¢		(1)

  ß P ¢		(2)

end A;
∞
πCN
 (1) È
  function F return Boolean ò X [ F X = X ] is begin return X; end F;
∞
πCN
 (2) È
  procedure P
    Ñ Y ò X [ X = TRUE ± Y = 5 ≤ X = FALSE ± Y = 7 ]
  is begin
    if F
    then
      Y := 5;
    else
      Y := 7;
    end if;
  end P;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc1_1");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC63.1.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{MA37: More liberal treatment of using clauses}
Various cases to test.

1) General ability to introduce using clause in k-slot.
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

πCN
package A is
  $auxiliary A : ˙;
  procedure P (Y : out Integer)
    Ñ Y ò A [ Y = A + 1 ]
  ;
end A;
∞
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
πCN
package body A is
 ß using clause and procedure p ¢			( 1 )
end A;
∞

πCN
 (1) È 
  $using C : Integer; $implement A $by C = ~A;
  procedure P (Y : out Integer)
    Ñ Y ò C [ Y = ~C + 1 ]             -- should work now
  --Ñ Y, C ò [ Y = ~C + 1 ± C = Câ0 ]  -- ok
  is begin
    Y := 1 - C;
  end P;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc1_3");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC37.1.1", fun_true o pop_thm , (), true)];
=TEX
2) Propagation of using clause into other k-slot.
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

πCN
package A is
  $auxiliary A : ˙;
  procedure P (Y : out Integer)
    Ñ Y ò A [ Y = A + 1 ]
  ;
end A;
∞
=TEX
=SML
new_script {name = "a.adb", state = get_cn_state ()};
πCN
package body A is
 ß using clause ¢			( 1 )
 ß procedure p ¢			( 2 )
end A;
∞

πCN
 (1) È  $using C : Integer; $implement A $by C = ~A;
∞
πCN
 (2) È
  procedure P (Y : out Integer)
    Ñ Y ò C [ Y = ~C + 1 ]             -- should work now
  --Ñ Y, C ò [ Y = ~C + 1 ± C = Câ0 ]  -- ok
  is begin
    Y := 1 - C;
  end P;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc2_3");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("PC37.2.1", fun_true o pop_thm , (), true)];
=TEX
3) Error cases: using clause are only allowed in package body:
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};

=SML
fun check37_3() = (
πCN
 procedure P (Y : out Integer)
    Ñ Y [ Y = 42 ] 
  is
  $using C : Integer; $implement A $by C = ~A;
 begin
    Y := 1 - C;
  end P;
∞
=SML
false) handle Fail _ => true;
store_mt_results
mt_run
 [("PC37.3.1", check37_3 , (), true)];
=TEX
\subsection{QQ50: Liberalise renaming of informal procedures and functions}
Renaming declation of informal procedure should not give rise to error:
=SML
clean_up();
new_script {name = "renames.1", state = initial_cn_state};
πCN
 procedure p1
 Ñ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure rq  (x : in out integer) renames q;
begin
 null; -- should not fail
end p1;
∞
=TEX
Just need to get here to pass the first test:
=SML
store_mt_results
mt_run
 [("Renames.1.1", fun_true , (), true)];
=TEX
Attempt to use the procedure via the new name should fail:
=SML
clean_up();
new_script {name = "renames.2", state = initial_cn_state};
=SML
fun renames2() = 
πCN
 procedure p1
 Ñ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure rq  (x : in out integer) renames q;
begin
 rq; -- should fail
end p1;
∞
=TEX
Check that it raises an exception
=SML
store_mt_results
mt_run
 [("Renames.2.1", (fn _ => (renames2 (); false) handle Fail _ => true) , (), true)];
=TEX
Check out renaming of functions in package specifications.
=SML
clean_up();
new_script {name = "renames.3.1", state = initial_cn_state};
=SML
fun renames3_1() = 
πCN
package A is

  function F return Integer;

  function G return Integer renames F;

  function F1 return Integer
   ò [F1 = 100] ;

end A;
∞
=SML
store_mt_results
mt_run
 [("Renames.3.1", (fn _ => (renames3_1(); true) handle Fail _ => false) , (), true)];
=TEX
=SML
new_script {name = "renames.3.2", state = get_cn_state()};
=SML
fun renames3_2() = 
πCN
with A;
package B is

  function H return Integer renames A.F;
  function I return Integer renames A.G;
  function H1 return Integer renames A.F1;
end B;
∞
=SML
store_mt_results
mt_run
 [("Renames.3.2", (fn _ => (renames3_2 (); true) handle Fail _ => false) , (), true)];
=TEX
=SML
new_script {name = "renames.3.3", state = get_cn_state()};
=SML
πCN
with B;
use B;
procedure P(X : out Integer)
is
  function PF return Integer renames B.I;
begin
  Ñ X [X > 0]
end P;
∞
πCN
  √ X := H1;
∞
=TEX
=SML
set_pc"cn1";

set_goal([], get_conjecture"-""vc_1_1");
a(rewrite_tac (map z_get_spec[ÒH1Æ, ÒAoF1Æ]));
store_mt_results
mt_run
 [("Renames.3.3", fun_true o pop_thm , (), true)];
=SML
=TEX
=TEX
\subsection{QQ51: Fix unsoundness caused by ignoring informal procedures}
Multiple informal procedures should not give rise to error:
=SML
clean_up();
new_script {name = "InfProc.1", state = initial_cn_state};
πCN
 procedure p1
 Ñ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure q (y : in out integer)
  is begin x := 1; end q;
begin
 null; -- should not fail
end p1;
∞
=TEX
Just need to get here to pass the first test:
=SML
store_mt_results
mt_run
 [("InfProc.1.1", fun_true , (), true)];
=TEX
Attempt to declare formal after informal  should fail:
=SML
clean_up();
new_script {name = "InfProc.2", state = initial_cn_state};
=SML
fun inf_proc2() = 
πCN
 procedure p1
 Ñ [ true ]
 is
  procedure q (x : in out integer)
  is begin x := 1; end q;
  procedure q (x : in out integer)
 Ñ X [ X = 1 ]
  is begin x := 1; end q;
begin
 null;
end p1;
∞
=TEX
Check that it raises an exception
=SML
store_mt_results
mt_run
 [("InfProc.2.1", (fn _ => (inf_proc2 (); false) handle Fail _ => true) , (), true)];
=TEX
Attempt to declare informal after formal  should fail:
=SML
clean_up();
new_script {name = "InfProc.3", state = initial_cn_state};
=SML
fun inf_proc3() = 
πCN
 procedure p1
 Ñ [ true ]
 is
  procedure q (x : in out integer)
 Ñ X [ X = 1 ]
  is begin x := 1; end q;
  procedure q (x : in out integer)
  is begin x := 1; end q;
begin
 null;
end p1;
∞
=TEX
Check that it raises an exception
=SML
store_mt_results
mt_run
 [("InfProc.3.1", (fn _ => (inf_proc3 (); false) handle Fail _ => true) , (), true)];
=TEX
\subsection{QQ52: Option to ignore SPARK annotations}
Renaming declation of informal procedure should not give rise to error:
=SML
clean_up();
new_script {name = "a.ads", state = initial_cn_state};
πCN
package A is

end A;
∞

=SML
new_script {name = "b.ads", state = get_cn_state ()};
πCN
package B is

end B;
∞

=SML

new_script {name = "c.ads", state = get_cn_state ()};

=SML
fun qq52_fail () =
πCN

with A;

--# inherits A

$references B;

-- works here ok

package C is

end C;
∞
=TEX
Check that the above raises an exception
=SML
store_mt_results
mt_run
 [("qq52.1.1", (fn _ => (qq52_fail (); false) handle Fail _ => true) , (), true)];
=TEX
Now change the flag and check that it works:
=SML
val was_i_s_a = set_flag("cn_ignore_spark_annotations", true);
store_mt_results
mt_run
 [("qq52.1.2", (fn _ => (qq52_fail (); false) handle Fail _ => true) , (), false)];
val _ = set_flag("cn_ignore_spark_annotations", was_i_s_a);
=TEX
=TEX
\subsection{QQ55: Support forward declaration of informal functions}
Multiple informal functions should not give rise to error:
=SML
clean_up();
new_script {name = "InfFun.1", state = initial_cn_state};
πCN
 procedure p1
 Ñ [ true ]
 is
  function q (x : in out integer) return integer
  is begin x := 1; return x; end q;
  function q (y : in out integer) return integer
  is begin x := 1; return x; end q;
begin
 null; -- should not fail
end p1;
∞
=TEX
Just need to get here to pass the first test:
=SML
store_mt_results
mt_run
 [("InfFun.1.1", fun_true , (), true)];
=TEX
Now try it with a forward declaration:
=SML
clean_up();
new_script {name = "InfFun.2", state = initial_cn_state};
πCN
 procedure p1
 Ñ [ true ]
 is
  function q (x : in out integer) return integer;
  function q (x : in out integer) return integer
  is begin x := 1; return x; end q;
begin
 null; -- should not fail
end p1;
∞
=TEX
Just need to get here to pass the second test:
=SML
store_mt_results
mt_run
 [("InfFun.1.2", fun_true , (), true)];
=TEX
Now try an error case:
=SML
clean_up();
new_script {name = "InfFun.3", state = initial_cn_state};
fun inf_fun3() =
πCN
 procedure p1
 Ñ [ true ]
 is
  q : integer;
  function q (x : in out integer) return integer
  is begin x := 1; return x; end q;
begin
 null; -- should not fail
end p1;
∞
=TEX
=SML
store_mt_results
mt_run
 [("InfFun.1.3", (fn () => (inf_fun3(); false) handle Fail _ => true) , (), true)];
=TEX
\subsection{QQxx: Disallow initial variables corresponding to out mode parameters}
=SML
clean_up();
new_script{name = "test1.adb", state = initial_cn_state};
fun init_var_err() =
πCN
procedure TEST1
is
  procedure P (X : in INTEGER; Y : out INTEGER)
  Ñ Y [X Ω 2 ¥ Y = Yâ0]
  is
  begin
    if X = 2 then Y := 2; end if;
  end P;
  A : INTEGER;
  B : INTEGER;
begin
  Ñ A, B [B = 99]				( 1 )
end TEST1;
∞
=TEX
=SML
store_mt_results
mt_run
 [("Initvar.1.1", (fn () => (init_var_err(); false) handle Fail _ => true) , (), true)];
=TEX
\subsection{QQ68: Labelled statements and goto statements}
=SML
clean_up();
new_script{name = "qq68.1", state = initial_cn_state};
πCN
procedure TEST1
is
 b : integer;
begin
  Ñ B [B = 99]				( 1 )
end TEST1;
∞
=SML
fun fail68_1() =
πCN
 (1) √ goto pack1.label;
∞
=TEX
=SML
store_mt_results
mt_run
 [("LabelsAndGotos.1.1", (fn () => (fail68_1(); false) handle Fail _ => true) , (), true)];
πCN
 (1) √  <<label>> ÑB [B = 99] (2)
∞
πCN
 (2) √  b := 99;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc1_2");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("LabelsAndGotos.1.2", fun_true o pop_thm , (), true)];
set_goal([], get_conjecture"-""vc2_1");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("LabelsAndGotos.1.3", fun_true o pop_thm , (), true)];
=TEX
\subsection{QQ73: Improved handling of initial variables in side conditions}
First check Phil Clayton's original example.
=SML
clean_up();
new_script {name = "qq73.1", state = initial_cn_state};
πCN
package A is
  procedure Eg1;
  procedure Eg2;
end A;
∞
=TEX
=SML
new_script {name = "qq73.2", state = get_cn_state ()};
πCN
package body A is
  A, X, Y : Integer;
  procedure Eg1
  is
  begin
    Ñ A, Y [ A = Aâ0 + 1 ]		(1)
  end Eg1;
  procedure Eg2
  is
  begin
    Ñ A, Y [ A = X, A = X + 1 ]		(2)
  end Eg2;
end A;
∞


πCN
 (1) √
  Ñ Y [ true ]		(3)
  A := A + 1;
∞
πCN
 (2) √
  Ñ Y [ true ]		(4)
  A := A + 1;
∞
=SML
val vc_conjs1 = map (snd o snd) (get_conjectures "-");
fun vc_thms1 () = (map (pc_rule1 "cn1" prove_rule[]) vc_conjs1; ());
store_mt_results
mt_run
 [("qq73.1.1", vc_thms1 , (), ())];
=TEX
Now try the important example where a procedure updates just a part of an entire variable.
=SML
clean_up();
new_script {name = "qq73.3", state = initial_cn_state};
πCN
procedure p
is
  procedure q(x : in out integer; y : in integer)
  Ñ X [ X = Y ]
  is begin x := y; end;
  type t is record a, b : integer; end record;
  rec : t;
begin
  Ñ REC [ REC.A = RECâ0.A ± REC.B = 1] (1)
end;
∞
πCN
 (1) √
 q(rec.b, 1);
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc1_2");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN
	asm_rewrite_tac[z_gen_pred_elim[ÒÉÆ] (z_get_specÒTuBÆ)]);
store_mt_results
mt_run
 [("qq73.1.2", fun_true o pop_thm , (), true)];
=TEX
\subsection{QQ85: Derived Types}
=SML
clean_up();
new_script{name = "85.1", state = initial_cn_state};

πCN
 procedure main
 is
  type ty1 is new integer range 1 .. 15;
  x1 : ty1;
 begin
 Ñ X1 [ X1 = 14 ]
 end main;
∞


πCN
  √  x1 := ty1'last - x1'first;
∞
=SML
val _ = cn_make_script_support "-" "85.1";
set_pc"85.1";
set_goal([], get_conjecture"-""vc_1_1");
a(cn_vc_simp_tac[]);
store_mt_results
mt_run
 [("85.1.1", fun_true o pop_thm , (), true)];
=TEX
=TEX
\subsection{QQ74: Early Creation of Package Spec Theory}
=SML
clean_up();
new_script{name = "74.1", state = initial_cn_state};

πCN
package pack74
is
 type enum is (a, b, c);
 a_a : constant enum := a;
 a_b : constant enum := b;
 a_c : constant enum := c;
end;
∞


=SML
fun cn_thys () = (
	Sort.sort Sort.string_order
	(get_descendants"cn" less "cn" diff get_cache_theories())
);
store_mt_results
mt_run
 [("qq74.1.1", cn_thys , (), ["74.1"])];
=TEX
=SML
create_package_spec_theory "pack74";
=SML
store_mt_results
mt_run
 [("qq74.1.2", cn_thys , (), ["PACK74spec", "74.1"])];
=SML
open_theory "PACK74spec";
val a_a_def = z_get_specÒPACK74oA_AÆ;
new_script{name = "74.2", state = get_cn_state()};

πCN
with pack74;
procedure proc74
is
  x : pack74.enum;
begin
 Ñ X[X = PACK74oA]
end;
∞
πCN
  √ x := pack74.a_a;
∞
=TEX
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vc_1_1");
a(rewrite_tac[a_a_def]);
store_mt_results
mt_run
 [("qq74.2.1", fun_true o pop_thm , (), true)];
=TEX
\subsection{QQ83: Prefix CN Keywords with a Dollar}
That the new syntax works is checked by test scripts passim.
We add some specific tests to show that the web clauses output by the tool can be read back in again (as happens in Phil Clayton's refinement calculator).

=SML
clean_up();
new_script{name = "83.1", state = initial_cn_state};
=TEX
=SML
val results : string list list ref = ref [];
fun record_last () = (
	let	open CNAdaOutput CNZGenerator;
		val wc = !diag_web_clause;
		val strs =
			strings_from_fmt1 fmt_web_clause wc;
	in	results := strs :: !results
	end
);
fun cn_recogniser x = (
	WebClauses.cn_recogniser x;
	record_last()
);
fun output_results (strm : outstream) = (
	let	fun  outln s = (
			output(strm, s);
			output(strm, "\n")
		);
		fun do1 strs = (
			outln "πCN";
			app outln strs;
			outln "∞"
		);
	in	map do1 (rev (!results))
	end
);
πCN
procedure FOURTH_ROOT is
 N,F : INTEGER;
 ß square root function ¢			(1)
begin
 Ñ F [N æ 0, F ** 4 º (F + 1) ** 4]	(2)
end FOURTH_ROOT;
∞
πCN
(1) È
function SQRT (X : INTEGER) return INTEGER
 ò [X æ 0, (SQRT(X)) ** 2 º X < (SQRT(X) + 1) ** 2]
is
 LO : INTEGER := 0;
 MID, HI : INTEGER;
begin
 LO := 0;
 HI := X + 1;
 while LO +1 /= HI
 loop
 Ñ MID, LO, HI [LO ** 2 º X < HI ** 2, LO ** 2 º X < HI ** 2]	(4)
 end loop;
 return LO;
end SQRT;
∞
πCN
(2) √
 F := SQRT(N);
 F := SQRT(F);
∞
πCN
(4) √
 MID := (LO + HI)/2;
 if X >= MID ** 2
 then LO := MID;
 else HI := MID;
 end if;
∞
=SML
val cn_recogniser = WebClauses.cn_recogniser;
val strm = open_out "int525.A.ML";
output_results strm;
close_out strm;
clean_up();
new_script{name = "83.2", state = initial_cn_state};
store_mt_results
mt_run
 [("qq83.1.1", use_file , "int525.A.ML", ())];
=TEX
\subsection{QQ94: Generate Domain Conditions from Subtype Constraints in Procedure Call, Assignment and Return Statements}
=SML
val old_cdc = set_int_control("cn_domain_conds", cn_standard_domain_conds);
=TEX
The first example deals with procedure calls.
In the following, the call to {\tt q} from {\tt p} results in a domain condition asserting that  the array index {\tt i} is in range.
Without this, the correctness of {\tt p} would not be provable.
=SML
clean_up();
new_script {name = "94.1", state = initial_cn_state};
πCN
 procedure main
 is
  type ind10 is range 1 .. 10;
  type int10 is array (ind10) of integer;
  procedure q (a : int10; i : ind10; r : out integer)
  Ñ R [R = A I]
  is
  begin
   r := a(i);
  end;
  procedure p (a : int10; i : integer; r : out integer)
  Ñ R [ ran A Ä Ó, R ç Ó]
  is
  begin
   q(a, i, r);
  end;
  x : integer;
 begin
  Ñ [true]
 end;
∞
=SML
set_pc "cn1";
set_goal([], get_conjecture "-" "vcMAIN_1");
a(cn_vc_simp_tac[]);
val vcMAIN_1 = save_pop_thm "vcMAIN_1";
=TEX
=SML
set_goal([], get_conjecture "-" "vcMAIN_2");
a(cn_vc_simp_tac[]);
val vcMAIN_2 = save_pop_thm "vcMAIN_2";
=TEX
=SML
set_goal([], get_conjecture "-" "vcMAIN_3");
a(cn_vc_simp_tac[z_get_specÒINT10Æ] THEN REPEAT strip_tac
	THEN all_var_elim_asm_tac1);
a(all_fc_tac[z_fun_dom_clauses]);
a(all_fc_tac[z_≠_dom_thm]);
a(all_fc_tac[z_≠_app_ç_rel_thm]);
a(PC_T1 "z_library_ext" asm_prove_tac[]);
val vcMAIN_3 = save_pop_thm "vcMAIN_3";
=TEX
=SML
fun check_conjecture name = (
	let	val tm = get_conjecture "-" name;
		val thm = get_thm "-" name;
	in	is_nil (asms thm) andalso tm =$ concl thm
	end
);
store_mt_results
mt_run
 [("qq94.1.1", all (map (hd o fst) (get_conjectures "-")), check_conjecture, true)];
=TEX
The second example deals with assignment statements.
The procedure {\tt p} only achieves its post-condition given the domain condition that asserts that the right-hand side of the assignment statement in the body of {\tt p} lies in the subtype of the left-hand side.
=SML
clean_up();
new_script {name = "94.2.ads", state = initial_cn_state};
πCN
package A is
   type T is range -100 .. 100;
   subtype ST is T range -10 .. 10;
   procedure P (U : in ST; V : out ST);
end A;
∞
=TEX
=SML
new_script {name = "94.2.adb", state = get_cn_state ()};
πCN
package body A is
   X, Y : T;
   ß procedure P ¢	(2)
begin
   Ñ Y [ Y ç ST ]	(3)
end A;
∞
πCN
 (2) È
   procedure P (U : in ST; V : out ST)
      Ñ V [ V ç ST ]
   is
   begin
      V := U + 1;
   end P;
∞
πCN
 (3) √
   P (U => X, V => Y);
∞
=TEX
=SML
val thms_94_2 = map (fn name =>
	(set_goal ([], get_conjecture "-"  name);
	a (cn_vc_simp_tac []);
	save_pop_thm name))
	((rev o map (hd o fst) o get_conjectures) "-");
store_mt_results
mt_run
 [("qq94.2.1", all (map (hd o fst) (get_conjectures "-")), check_conjecture, true)];
=TEX
The third example deals with return statements.
It is essentially the same as the second example but using a function in place of a procedure with an {\tt out} mode parameter.
=SML
clean_up();
new_script {name = "94.3.ads", state = initial_cn_state};
πCN
package A is
   type T is range -100 .. 100;
   subtype ST is T range -10 .. 10;
   procedure P (U : in ST; V : out ST);
end A;
∞
=TEX
=SML
new_script {name = "94.3.adb", state = get_cn_state ()};
πCN
package body A is
   X, Y : T;
   ß function F ¢	(2)
begin
   Ñ Y [ Y ç ST ]	(3)
end A;
∞
πCN
 (2) È
   function F (U : in ST) return ST
      ò [ F U ç ST ]
   is
   begin
      return U + 1;
   end F;
∞
πCN
 (3) √
   Y := F(X);
∞
=TEX
=SML
set_goal([], get_conjecture "-" "vc2_1");
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
val _ = save_pop_thm "vc2_1";
=TEX
=SML
set_goal([], get_conjecture "-" "vc3_1");
a(REPEAT strip_tac);
a(strip_asm_tac (rewrite_rule[](z_get_specÒFÆ)));
a(all_fc_tac[z_fun_dom_clauses]);
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val _ = save_pop_thm "vc3_1";
=TEX
=SML
store_mt_results
mt_run
 [("qq94.3.1", all (map (hd o fst) (get_conjectures "-")), check_conjecture, true)];
=SML
val _ = set_int_control("cn_domain_conds", old_cdc);
=TEX
=TEX
\subsection{QQ95: Fix Inappropriate error 508081}
=SML
clean_up();
new_script {name = "95.1.ads", state = initial_cn_state};
πCN
package B is
  procedure P;
end B;
∞
=SML
new_script {name = "95.1.adb", state = get_cn_state ()};
fun chk95_1() =
πCN
package body B is
   X, Y : Integer;
   function F (X : Integer) return Integer ò [ true ] is begin return X; end F;
   procedure P Ñ X [ true ] is begin X := F(Y); end P;
end B;
∞
=SML
store_mt_results
mt_run_fail
[
	("95.1.1", chk95_1, (),  gen_fail_msg "zid" 508077 ["Y"])
];
=TEX
=TEX
\subsection{QQ98: improve error messages for procedure specification statements}
=SML
clean_up();
new_script {name = "t98.1.1", state = initial_cn_state};
πCN
package TEST is
  X : INTEGER;
  Y : FLOAT;
end TEST;
∞
=TEX
=SML
new_script {name = "t98.1.2", state = get_cn_state()};
πCN
package body TEST is
  procedure P
    Ñ X, Y [ true ]
  is separate;
end TEST;
∞
=TEX
=SML
new_script {name = "t98.1.3", state = get_cn_state()};
=TEX
=SML
fun check_98_1() =
πCN
separate (TEST)
procedure P
  Ñ X, Y [ true, Some_Predicate ± true]
is
begin
  Ñ X, Y [ true ]
end P;
∞
=TEX
=SML
store_mt_results
mt_run_fail
[
	("98.1.1", check_98_1, (),
	gen_fail_msg "call_vcs" 507121 [
		"ÒSome_Predicate ± trueÆ",
		"ÒSome_PredicateÆ", "", "is", "in scope."])
];
=SML
clean_up();
new_script {name = "t98.2.1", state = initial_cn_state};
πCN
package TEST is
  X : INTEGER;
  Y : FLOAT;
  procedure P
  Ñ X, Y [ true ];
end TEST;
∞
=TEX
=SML
new_script {name = "t98.2.2", state = get_cn_state()};
fun check_98_2() =
πCN
package body TEST is
  procedure P
    Ñ X, Y [ true, Some_Predicate ± true ]
  is begin null; end;
end TEST;
∞
=SML
store_mt_results
mt_run_fail
[
	("98.2.1", check_98_2, (),
		gen_fail_msg "call_vcs" 507121 [
		"ÒSome_Predicate ± trueÆ",
		"ÒSome_PredicateÆ", "", "is", "in scope."])
];
=SML
clean_up();
new_script {name = "t98.3.1", state = initial_cn_state};
πCN
package TEST is
  $auxiliary X : ˙;
  Y : FLOAT;
  procedure P
  Ñ X, Y [ true ];
end TEST;
∞
=TEX
=SML
new_script {name = "t98.3.2", state = get_cn_state()};
fun check_98_3() =
πCN
package body TEST is
  $using c : integer; $implement X $by C = X;
  procedure P
    Ñ C, Y [ true, Some_Predicate ± true ]
  is begin null; end;
end TEST;
∞
=SML
store_mt_results
mt_run_fail
[
	("98.3.1", check_98_3, (),
		gen_fail_msg "call_vcs" 507121 [
		"ÒSome_Predicate ± trueÆ",
		"ÒSome_PredicateÆ", "", "is", "in scope."])
];
=SML
clean_up();
new_script {name = "t98.4.1", state = initial_cn_state};
fun check_98_4() =
πCN
procedure test
is
  X : integer;
  C : constant integer := X;
begin
  null;
end;
∞
=SML
store_mt_results
mt_run_fail
[
	("98.4.1", check_98_4, (),
		gen_fail_msg "z_ax" 508106 [
		"constant", "ÒXÆ", ""])
];
=TEX
=SML
clean_up();
new_script {name = "t98.5.1", state = initial_cn_state};
fun check_98_5() =
πCN
procedure test
is
  X : integer;
  C : constant := X;
begin
  null;
end;
∞
=SML
store_mt_results
mt_run_fail
[
	("98.5.1", check_98_5, (),
		gen_fail_msg "z_eq_eq" 508106 [
		"constant", "ÒXÆ", ""])
];
=TEX
\section{EPILOGUE}
=SML
diag_line(summarize_mt_results());
=TEX
\end{document}
