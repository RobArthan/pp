=IGN
********************************************************************************
imp514.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp514.doc   %Z% $Date: 2006/03/24 16:40:29 $ $Revision: 1.22 $ $RCSfile: imp514.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Compliance Notation (Volume II) Types}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP514}  %% Mandatory field
\def\SCCSversion{$Revision: 1.22 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/03/24 16:40:29 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This document contains the implementation for the automatic generation of a structure containing the Compliance Notation Types defined in Volume II of DRA/CIS/CSE3/TR/94/27/3.0.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1] Initial Draft.
\item[Issue 1.2 (27th May 1994)] First draft for comment.
\item[Issue 1.4] Updated references.
\item[Issue 1.5] Accommodated use of signature inclusion for Poly/ML port.
\item[Issue 1.6] Copyright and banner updates for open source release.
\item[Issue 1.7] DAZ-specific updates to banner for open source release
\item[Issue 1.8] DAZ-specific updates to banner for open source release
\item[Issues 1.9-1.17] Reform of the Environments.
\item[Issue 1.18] Support for multiple use clauses for the same package.
\item[Issue 1.19] Fix for type inference of aliases.
\item[Issue 1.20] Fixed bug in getting types from the theory hierarchy.
\item[Issue 1.21] Aliasing in pre- and post-conditions is now only supported for Ada variables (not constants etc.).
\item[Issue 1.22] Added variant of {\em env\_of\_env\_dict}.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for automatically generating the structure for Volume II types.

The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD514}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD514}.
\subsection{Possible Enhancements}
None.
=TEX
\section{PREAMBLE}
=TEX
=SH
sieve -f daz.svf imp <dtd514.doc | \
	sed \
	-e '/^signature/d' \
	-e '/^include/d' \
	-e '/^type.*ENV_DICT/d' \
	-e '/^val/d' \
	-e '/^end.*signature/s/signature/structure/' \
		>imp514.inc
=TEX
=SML
structure CNTypes2 : CNTypes2 = struct
open    CNBasicDeclsAndExprs;
=TEX
=SML
datatype €ENV_DICT› = EnvDict of {
	infos : ENV_INFO E_DICT,
	ti_cxt : TYPE E_DICT,
	local_vars : {
		vc_vars : Z_ID list,
		vc_pars : Z_ID list,
		vc_aux_vars : Z_ID list,
		vc_log_cons : Z_ID list},
	cn_scope : unit E_DICT OPT,
	used_packages : ID list};
(*
=TEX
=SML
*)
val €initial_infos› : ENV_INFO E_DICT = list_e_enter initial_e_dict (
	open_theory "cn";
	let	fun not_a_basic_type t = not
			(type_of t =: type_of Ò˙Æ orelse type_of t =: type_of ÒØÆ);
		fun name_of t =  let val (n,_,_) = dest_z_gvar t in n end;
		val extras = [ÒSTRINGÆ];
		val tms_to_do = extras term_union (get_consts"cn" drop not_a_basic_type);
		fun do_1_tm t = (
			let	val n = name_of t;
			in	(n,
					{tipe = Value (type_of t),
					canon_name = n,
					info = EIEnvOtherType})
			end
		)
	in	map do_1_tm tms_to_do
	end
);
(*
=TEX
=SML
*)
val €initial_env_dict› : ENV_DICT = EnvDict {
	infos =initial_infos,
	ti_cxt = initial_e_dict,
	local_vars = {
		vc_vars = [],
		vc_pars = [],
		vc_aux_vars = [],
		vc_log_cons = []},
	cn_scope = Nil,
	used_packages = []
};
(*
=TEX
=SML
*)
fun €add_to_env_dict›
	(EnvDict{infos, ti_cxt, local_vars, cn_scope, used_packages} : ENV_DICT)
	(new :ENV_INFO S_DICT) :  ENV_DICT = (
	let	val infos' = list_e_enter infos new;
		open ZTypesAndTermsSupport;
		fun mk_ti_cxt acc [] = acc
		|    mk_ti_cxt acc ((n, {tipe, info as EIEnvVar _, canon_name}):: more) = (
			if	n = canon_name
			then	let	val ty = force_value tipe;
					val entries = [(n, ty), (n ^ "â0", ty)];
				in	mk_ti_cxt (list_e_enter acc entries) more
				end	handle Fail _ => fail "add_to_env_dict" 514001 [fn _ => n]
			else	mk_ti_cxt acc more
		) |  mk_ti_cxt acc ((n, {tipe, info as EIEnvAuxVar _, canon_name}):: more) = (
			let	val ty = force_value tipe;
				val entries = [(n, ty), (n ^ "â0", ty)];
			in	mk_ti_cxt (list_e_enter acc entries) more
			end	handle Fail _ => fail "add_to_env_dict" 514001 [fn _ => n]
		) |  mk_ti_cxt acc ((n, {tipe, info as EIEnvLogCon _, canon_name}):: more) = (
			mk_ti_cxt (e_enter n (force_value tipe) acc) more
			handle Fail _ => fail "add_to_env_dict" 514001 [fn _ => n]
		) |  mk_ti_cxt acc ((n, {tipe, info, canon_name}):: more) = (
			mk_ti_cxt acc more
		);
		fun grow_scope _ Nil = Nil
		|     grow_scope n (Value dict) = Value (e_enter n () dict);
		fun add_local_vars scope acc ([] : ENV_INFO S_DICT) = (scope, acc)
		|     add_local_vars scope {vc_vars, vc_pars, vc_aux_vars, vc_log_cons}
				((n, {info as EIEnvVar {kind = VKPar _, ...}, canon_name, ...}):: more) = (
			add_local_vars (grow_scope n scope) {
				vc_vars = vc_vars,
				vc_pars =
				if	n = canon_name
				then	n :: vc_pars
				else	vc_pars,
				vc_aux_vars = vc_aux_vars,
				vc_log_cons = vc_log_cons} more
		) |  add_local_vars scope {vc_vars, vc_pars, vc_aux_vars, vc_log_cons}
				((n, {info as EIEnvVar _, canon_name, ...}):: more) = (
			add_local_vars (grow_scope n scope) {
				vc_vars = 
				if	n = canon_name
				then	n :: vc_vars
				else	vc_vars,
				vc_pars = vc_pars,
				vc_aux_vars = vc_aux_vars,
				vc_log_cons = vc_log_cons} more
		) |   add_local_vars scope {vc_vars, vc_pars, vc_aux_vars, vc_log_cons}
				((n, {info as EIEnvAuxVar _, ...}):: more) = (
			add_local_vars (grow_scope n scope) {
				vc_vars = vc_vars,
				vc_pars =vc_pars,
				vc_aux_vars = n :: vc_aux_vars,
				vc_log_cons = vc_log_cons} more
		) |  add_local_vars scope {vc_vars, vc_pars, vc_aux_vars, vc_log_cons}
				((n, {info as EIEnvLogCon _, ...}):: more) = (
			add_local_vars (grow_scope n scope) {
				vc_vars = vc_vars,
				vc_pars =vc_pars,
				vc_aux_vars = vc_aux_vars,
				vc_log_cons = n :: vc_log_cons} more
		) | add_local_vars scope acc ((n, _)::more) = (
			add_local_vars (grow_scope n scope) acc more
		);
		val ti_cxt' = mk_ti_cxt ti_cxt new;
		val (cn_scope', local_vars') = add_local_vars cn_scope local_vars new;
	in	EnvDict {
			infos = infos',
			ti_cxt = ti_cxt', 
			local_vars = local_vars',
			cn_scope = cn_scope',
			used_packages = used_packages}
	end
);
(*
=TEX
=SML
*)
fun €delete_from_env_dict›
	(EnvDict ed: ENV_DICT)
	(zns : Z_ID list) :  ENV_DICT = (
	let	fun aux (zn, {
			infos,
			ti_cxt,
			local_vars = {vc_vars, vc_pars, vc_aux_vars, vc_log_cons},
			cn_scope,
			used_packages}) = (
			{infos = e_delete zn infos,
			ti_cxt = e_delete zn ti_cxt,
			local_vars = {
				vc_vars = vc_vars less zn,
				vc_pars = vc_pars less zn,
				vc_aux_vars = vc_aux_vars less zn,
				vc_log_cons = vc_log_cons less zn},
			cn_scope = (case cn_scope of
					Value d => Value(e_delete zn d)
				|	Nil => Nil),
			used_packages = used_packages}
		);
	in	EnvDict (fold aux zns ed)
	end
);
(*
=TEX
The following could be made a little more efficient by handcrafting the elevation of the names in
the supplied scope into the local variable information, but the benefit is not felt to be worth the extra code.
=SML
*)
fun €set_cn_scope›
	(dict as (EnvDict ed): ENV_DICT)
	(zns : Z_ID list) : ENV_DICT = (
	let	val cn_scope' = Value(list_e_enter initial_e_dict (map (fn zn => (zn, ())) zns));
		fun aux zn = (
			(zn, force_value (e_lookup zn (#infos ed)))
			handle Fail _ =>  fail "set_cn_scope" 514002 [fn () => zn]
		);
		val new_local_infos = map aux zns;
		val EnvDict{infos, ti_cxt, local_vars, cn_scope = _, used_packages} = 
			add_to_env_dict dict new_local_infos;
	in	EnvDict {
			infos = infos,
			ti_cxt = ti_cxt, 
			local_vars = local_vars,
			cn_scope = cn_scope',
			used_packages = used_packages}
	end
);
(*
=TEX
=SML
*)
fun €get_cn_scope›
	(EnvDict{infos = _, ti_cxt = _, local_vars = _,
		cn_scope = Value g, used_packages = _} : ENV_DICT)
	: Z_ID list OPT = (
	Value(map fst (e_flatten g))
) | get_cn_scope _ = Nil;
(*
=TEX
In the following {\em aux} maps the {\em kind} into ``out of scope'' if the {|em cn\_scope} is not nil and doesn't contain the name we're looking for. This supports the {\em subprog\_flatten\_env} operation of the volume I of the specification.
If the name we're looking for isn't in the {\em infos} dictionary,
=SML
*)
fun €env_of_env_dict_aux› (use_gct : bool)
	(EnvDict{infos = infos, ti_cxt = _, local_vars = _,
		cn_scope = cn_scope, used_packages = _} : ENV_DICT)
	 : CN_ENV = (
let	fun aux (Value g) zn = (
		case e_lookup zn infos of
			res as (Value {canon_name, info as EIEnvVar {tmark, ...}, tipe}) => (
				case e_lookup canon_name g of
					Value _ => res
				|	Nil =>  Value {
						canon_name = canon_name,
						info = EIEnvVar{
							tmark = tmark,
							kind = VKOutOfScope
						},
						tipe = tipe}
		) |	res as (Value {canon_name, info as EIEnvAuxVar {decl, ...}, tipe}) => (
				case e_lookup canon_name g of
					Value _ => res
				|	Nil =>  Value {
						canon_name = canon_name,
						info = EIEnvAuxVar{
							decl = decl,
							in_scope = false
						},
						tipe = tipe}
		) |	other => other
	) | aux Nil zn = e_lookup zn infos;
	open ZTypesAndTermsSupport;
in	fn zn =>
	case aux cn_scope zn of
		res as (Value {tipe = Value _, ...}) => res
	|	res as (Value {tipe = Nil, canon_name, info}) => (
		let	val hol_name =  bind_gvar_name canon_name;
		in	Value{
				tipe = get_const_type hol_name,
				canon_name = canon_name,
				info = info}
		end		
	) |	Nil => (
		if	use_gct
		then	let	val hol_name =   bind_gvar_name zn;
			in	case get_const_type hol_name of
					Value ty => Value {
							tipe = Value ty,
							canon_name = zn,
							info = EIEnvOther}
				|	Nil => Nil
			end
		else	Nil
	)
end);
=TEX
=SML
val €env_of_env_dict› : ENV_DICT -> CN_ENV = env_of_env_dict_aux true;
val €env_of_env_dict1› : ENV_DICT -> CN_ENV = env_of_env_dict_aux false;
(*
=TEX
=SML
*)
fun €flatten_env_dict›
	(EnvDict{infos = infos, ti_cxt = _, local_vars = _,
		cn_scope = _, used_packages = _} : ENV_DICT)
	: ENV_INFO S_DICT = (
	e_flatten infos
);
(*
=TEX
=SML
*)
fun €ti_context_of_env_dict›
	(EnvDict{infos = _, ti_cxt = ti_cxt, local_vars = _,
		cn_scope = _, used_packages =_} : ENV_DICT)
	: TYPE E_DICT = (
	ti_cxt
);
(*
=TEX
=SML
*)
fun €new_scope_env_dict› 
	(EnvDict{infos, ti_cxt, local_vars = _, cn_scope, used_packages} : ENV_DICT)
	: ENV_DICT = (
	EnvDict{
		infos = infos,
		ti_cxt = ti_cxt,
		local_vars = {
			vc_vars = [],
			vc_pars = [],
			vc_aux_vars = [],
			vc_log_cons = []},
		cn_scope = cn_scope,
		used_packages = used_packages}
);
(*
=TEX
=SML
*)
fun €get_local_vars› 
	(EnvDict{infos = _, ti_cxt = _, local_vars = local_vars,
		cn_scope = _, used_packages = _} : ENV_DICT)
	:	{vc_vars : Z_ID list,
		vc_pars : Z_ID list,
		vc_aux_vars : Z_ID list,
		vc_log_cons : Z_ID list} = (
	local_vars
);
(*
=TEX
=SML
*)
fun €get_used_packages› 
	(EnvDict{infos = _, ti_cxt = _, local_vars =_,
		cn_scope = _, used_packages = used_packages} : ENV_DICT)
	:	ID list = (
	used_packages
);
(*
=TEX
=SML
*)
fun €add_used_package› 
	(EnvDict{infos, ti_cxt, local_vars, cn_scope, used_packages} : ENV_DICT)
	(pack_id : ID)
	:	ENV_DICT = (
	EnvDict {
		infos = infos,
		ti_cxt = ti_cxt,
		local_vars = local_vars,
		cn_scope = cn_scope,
		used_packages = used_packages grab pack_id}
);
=TEX
=INCLUDE
imp514.inc
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

