% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
% use_file "wrk509";
% doctex wrk509x[0-9][0-9].th
% docdvi wrk509
\documentstyle[hol1,11pt,TQ,hyperbasics]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Analysis of Declarations}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/WRK509}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{%
As part of the requirements analysis for proof tools for the Compliance Notation, the generation of Z paragraphs has been analysed for basic declarations.
This paper reports on that analysis.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
%\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}
\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.2] Initial Drafts.
\end{description}
\subsection{Changes Forecast}
As called for by peer review.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document reports on a study called for in \cite{ISS/HAT/DAZ/PLN010,ISS/HAT/DAZ/PLN012}.
\subsection{Introduction}
As part of the requirements analysis for proof tools for the Compliance Notation, the generation of Z paragraphs has been analysed for basic declarations.
This paper reports on that analysis.

Note that the specification of SPARK uses ``type mark" for ``type name or subtype name'',
and this wording is used in this document.

Various expression slots in declarations must be given static expressions in SPARK. 
It should be noted that this does not necessarily mean that they can be evaluated 
within \ProductZ.
This is for a variety of reasons, such as an inability to reason about
real numbers to the same extent as SPARK.
However, any expression that is meant to be statically evaluated to a $˙$ value
is assumed to be a good candidate for a ``once and for all'' attempt at
evaluation in \ProductZ, rather than being left for repeated attempts during
individual proofs.

Variable declarations do not directly cause the introduction of Z
paragraphs, and are therefore not further considered in this document.
Likewise for private type declarations(?).

=IGN
\section{PREAMBLE}

As a theory to provide a home for our Z:
 =SML
map (fn thy => ( force_delete_theory thy handle Fail _ => () ))
	(get_descendants "cn" less "cn" diff get_cache_theories());
open_theory"cn";
new_theory"wrk509aux";
 =TEX
The following Standard ML command is used to set up the tool to process each of the many little scripts comprised in this document.
 =SML
fun ns (script : string) : unit = (
	new_script {name=script, state=initial_cn_state};
	new_parent"wrk509aux"
);
 =TEX
=TEX
\section{CATEGORIES OF BASIC DECLARATIONS}
\subsection{A Hierarchy of Usefulness}
A conversion (or implicitly, and most commonly the theorem used to generate the conversion) can be
categorised as to its likely usefulness.
\begin{description}
\item[Class 1]
Appropriate to be a conversion for the default rewrite rules, etc., in a straightforward proof context in the appropriate theory.

Such a conversion should simplify the term it is applied to, and not lengthen it (by count of tokens). 
Appropriate conversions for this class would for example be ones that replace constants by literals.

It is still possible that a user will not want the conversion applied in all cases, but only with the sort of frequency that, for instance pure rewriting is chosen over rewriting with the current proof context rewrite rules.

\item[Class 2]
Appropriate to be a conversion used within a straightforward automatic proof procedure (e.g. the one for $prove\_tac$ in a straightforward proof context), but not one that should ``always'' be applied.
A user would probably want easy access to such a conversion.

Such a conversion should simplify the term it is applied to, but may lengthen it to some extent.
Appropriate conversions would be ones that move the proof into a ``lower'' theory, 
such as rewriting a Compliance Notation expression into a term only using operators from the theory of relations, when reasoning about the Compliance Notation form of the term is unlikely to progress any other way.

\item[Class 3]
Appropriate only to automatic proof tools that take a ``brutal'' approach to
a proof, for instance,  conversion that simplifies, but greatly lengthens, a term, whose output is not intended to be human readable.
Such a conversion will not often be of use in a manual proof.

Some of the extensionality conversions would fit in this class.

\item[Class 4]
A conversion that is has no appropriate use except for careful manual use.

This includes many recursive definitions and conversions that reverse the effect of 
conversions from other classes.
\end{description}

\subsection{Constants}
πCN
name : constant name_type := exp;
∞
The SPARK specification allows multiple constant identifiers to be 
introduced in one statement, but this is not covered in the Compliance Notation
work.
$exp$ must be a static expression in SPARK.

A declaration of a constant will either introduce a global definition or an axiom, depending on whether the constant's expression can be translated into Z.

These Z paragraphs are either of the form:
πZ
name == exp
∞
or:
πZ
name : name_type
∞

A theorem providing the rewrite of the name to the best available evaluation of the expression in the first case 
would of use (for it must be a static expression, so evaluation within \ProductZ\ is at least possible).
Such a theorem would be in Class 1 if the expression can be evaluated to a literal or other previously defined constant, and otherwise would probably fall in class 2 (and the worst cases in Class 3), and would make the original
global definition of no further use.

There is no obvious processing for the second case, but the axiom (used as a membership statement, perhaps normalised with other Class 1  conversions) is in Class 1.

\subsection{Enumeration Types}
πCN
type name is (nameâ0, ..., nameân)
∞
There must be at least 2 enumeration literals.

The introduction of an enumeration type introduces generic definitions of the enumeration literals, the type itself, and the type's attributes.
In more detail:

There will be one global definition per enumeration literal, of the form:
πZ
name == integer_literal
∞
Such theorems are in class 1.

The global definition of the type is of the form:
πZ
name == nameâ0 .. nameân
∞
This can be rewritten to:
πZ
Ù name = 0 .. integer_literal
∞
or various other obvious forms, e.g. involving inequalities, or simplifications
if there are few enumerated elements.
This rewritten theorem belongs in Class 2 (perhaps Class 1 in special cases), and would make the original
global definition of no further use.

The attributes are as follows:

πZ
name__FIRST == nameâ0
name__LAST == nameân
∞
which can be rewritten to:
πZ
Ù name__FIRST = 0
Ù name__LAST = integer_literal
∞
These rewritten theorems belong in Class 1, and would make the original
global definitions of no further use.

πZ
name__SUCC == (name \ {name__LAST}) Ú succ
∞
This has a variety of possible rewrites. The two extremes might be:
πZ
Ù name__SUCC == (0 .. integer_literal) Ú succ
Ù name__SUCC == {(0,1), ..., (integer_literalân, integer_literalËn+1Í)}
∞
In general, the first belongs in Class 2, the second in Class 3. 
However, if the enumerated type is small (2, maybe 3, elements), then 
then simplifications can be made to the first rewritten theorem, and the results moved up the classes.
Any of these would make the original
global definition of no further use.
Some rewriting use may be made of the fact that the domain of $succ$ is already domain restricted to $Ó$.

πZ
name__PRED == ((name \ {name__LAST}) Ú succ)~
∞
This has a variety of possible rewrites. The two extremes might be:
πZ
Ù name__PRED == (1 .. integer_literal) Ú (succ ~)
Ù name__PRED == {(1,0), ..., (integer_literalân, integer_literalËn-1Í)}
∞
In general, the first belongs in Class 2, the second in Class 3. 
However, if the enumerated type is small (2, maybe 3, elements), then 
then simplifications can be made to the first rewritten theorem, and both the rewritten theorem and the second global definition moved up the classes.
Any of these would make the original
global definition of no further use.
Some rewriting use may be made of the fact that the domain of $succ$ is already domain restricted to $Ó$.

πZ
name__POS == id name
name__VAL == name__POS~
∞
The second can be rewritten to:
πZ
Ù name__VAL = name__POS
∞
The rewritten theorem should probably be in Class 1, the first global definition should be in Class 2 (it is too expansive, given the follow-on rewrite of $name$, to be in Class 1), and would make the original
global definition of no further use.
A rewrite theorem of the following form might be put in Class 3 if the type is small (if very small, perhaps even in Class 2):
πZ
Ù name__POS = {(0,0),...(integer_literalân, integer_literalân)}
∞

\subsection{Array Types}
Constrained array type declarations are of the form:
πCN
type name is array (indexâ1, ..., indexân) of comp;
∞
The indexes must be type marks for discrete, and thus static, ranges. 

The introduction of an constrained array type with component type mark $comp$ will introduce global definitions for the type itself and, if only 1-dimensional, its attributes.

πZ
name == indexâ1 ∏ ... ∏ indexân ≠ comp
∞
This definition is in Class 2 or maybe even 3, depending on the number and character of the index types.

For 1-dimensional arrays the attribute definitions are:
πZ
name__FIRST == indexâ1__FIRST
name__LAST == indexâ1__LAST
name__LENGTH == # indexâ1
name__RANGE == indexâ1
∞
All but the 3rd of these are in Class 1, the 3rd one being in Class 2.
It is possible that $\# indexâ1$ can be rewritten to a simpler value, maybe even an
integer literal (for instance $\# (n .. m)$, assuming a likely form of the underlying index type, could be rewritten to $m + 1 - n$). 
This may move the rewritten theorem to Class 1, and would make the original
global definition of no further use.

Unconstrained array type declarations are of the form:
πCN
type name is array (indexâ1 range <>, ..., indexân range <>) of comp;
∞
The indexes are arbitrary type marks, apparently, and in particular do not
appear to need to be static in SPARK.

The introduction of an unconstrained array type only introduces an axiom of the form:
πZ
name :  (indexâ1 ∏ ... ∏ indexân ﬂ comp)
∞
This axiom, used as a membership statement, perhaps normalised by applying other applicable Class 1 conversions, is probably in Class 1, and could also be used in 
resolution proof attempts.

\subsection{Record Types}
πCN
type name is 
record
	labâ1 : ltypeâ1;
	...
	labân : ltypeân;
end record;
∞
The Compliance Notation does not seem to address the issue of multiple
identifiers in a single component declaration.
The $ltype$s are all type marks.

The introduction of a record type will introduce the following style of schema:
ˇ name ¸¸¸¸¸¸¸¸¸¸¸
‹ labâ1 : ltypeâ1
‹ ...
‹ labân : ltypeân
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
This can be used to generate various type membership theorems, that might be
useful (and thus perhaps even in Class 1 due to their simple nature).

\subsection{Integer Types}
πCN
type name is expâ1 .. expâ2
∞
(what happens to range attributes as valid SPARC range constraints???)

Integer type declarations are types with the range constraint being statically determinable. 
Their introduction causes the introduction of a global definition of themselves and either global definitions or axioms for their attributes.

πZ
name == expâ1 .. expâ2
∞
This is a Class 2 theorem, and there may be possible rewrites of it, as
the two expressions should be static.

πZ
name__FIRST == expâ1
name__LAST == expâ2
∞
Rewritten theorems based on the evaluation of the expressions should be in Class 1 if the results are integer literals or other constants, and Class 2 otherwise, and would make the original
global definitions of no further use.

πZ
name__SUCC : ˙ ﬂ ˙
name__PRED : ˙ ﬂ ˙
name__POS : ˙ ﬂ ˙
name__VAL : ˙ ﬂ ˙
∞
These, taken as membership statements are in Class 1.

\subsection{Real Types}
πCN
type name is delta ...
type name is digits ...
∞

The introduction of a real type introduces the type as a given set:
πZ
[ name ]
∞
This has no associated rewrite rules, etc.

\subsection{Subtypes}
πCN
subtype name is master constraint
∞
The constraint can be range, floating point, fixed point or index, and, from SPARK, must
be statically determinable.

There are various possibilities for subtypes, being whether or not they are subtypes of types that are translated into $˙$, and on the nature of their constraint (e.g. can it be translated into a range constraint).

\subsubsection{Case 1}
If the master type, $master$, can be translated to $˙$ and the constraint can be translated to a $˙$ range constraint $expâ1 .. expâ2$ global definitions are introduced for the type and its attributes:
πZ
name == expâ1 .. expâ2
∞
The expressions must be static, and thus we can hope to be able to 
rewrite this to something of the form:
πZ
Ù name = integer_literalâ1 .. integer_literalâ2
∞
Such a theorem is in Class 2, but if the expressions cannot be rewritten to 
integer literals it may be more appropriate to place the result in Class 3, and would make the original
global definition of no further use.

The attributes for this are as follows:
πZ
name__FIRST == expâ1
name__LAST == expâ2
∞
The expressions in these may be rewritable to integer literals, giving the
theorems:
πZ
Ù name__FIRST == integer_literalâ1
Ù name__LAST == integer_literalâ2
∞
or similar theorems.
These theorems should be in the same class, being 1 if both expressions evaluate
to integer literals, and class 2 or 3 otherwise, and would make the original
global definitions of no further use.

The other attributes are just copies of the master type (which will be a type mark, as anonymous types are not allowed in SPARK), so the global definitions are:
πZ
name__SUCC == master__SUCC
name_PRED == master__PRED
name__POS == master__POS
name__VAL == master__VAL
∞
All of these should be in Class 1, perhaps first rewriting them with Class 1 rules for type $master$.
Notice that the domains of these attributes are those of the master types attributes.

\subsubsection{Case 2}
For 1-dimensional index constraints, noting that the constraint must be a type mark in SPARK ($index$ below), the declaration introduces global definitions for the type and some attributes:
πZ
name == {u : master | dom u = index}
∞
$u$ is an introduced bound variable, $master$ the original array type mark. This is in Class 2.

The attributes are:
πZ
name__FIRST == index__FIRST
name__LAST == index__LAST
name__RANGE == index
∞
These are in Class 1, perhaps after having been rewritten by Class 1 theorems for $index$.

πZ
name__LENGTH == # index
∞
This is a Class 2 theorem, and it is possible that $\# index$ can be rewritten
to a simpler form introducing a 
more appropriate Class 2 theorem  (for instance $\# (n .. m)$, assuming a likely form of the underlying index type, could be rewritten to $m + 1 - n$) or even Class 1 if $\# index$ can be rewritten to an integer literal, and would make the original
global definition of no further use.

\subsubsection{Case 3}
For 2+-dimensional index constraints only a global definition of the type
is given:
πZ
name == {u : master | dom u = indexâ1 ∏ ... ∏ indexân }
∞
$u$ is an introduced bound variable, $master$ the original array type. This is in Class 2 (bordering on Class 3).

\subsubsection{Case 4}
When either the constraint is not a range constraint that can be translated into $˙$, or the master type is not $˙$, or any other case not covered in the above, then
the following axiom is introduced:
πZ
name :  master
∞
This, as a membership statement, is in Class 1, perhaps normalised by other applicable Class 1 conversions and could also be used in 
resolution proof attempts.

\section{CONCLUSIONS}
Almost all of the potentially useful theorems that are introduced by
a declaration are global definition paragraphs of the form:
πZ
name == expression
∞
The only potentially useful things that can be done with these at the point of declaration is to:
\begin{itemize}
\item
attempt to evaluate the expressions within \ProductZ\ and keep the resulting theorems;
\item
categorise the original or derived theorems and create a proof context, or
values contributing towards creating a proof context,
based upon the categorisation;
\item
also based on the categorisation, perhaps make the derived theorems available to the user (e.g. save them in the theory).
\end{itemize}
The evaluation attempts could be guided by knowledge specific to the Compliance
Notation, such as the possible forms of the sub-expressions (e.g. must be 
result in ranges), or the starting
structure of the expression (e.g. one case starts as $\# typemark$).

The only other useful theorems introduced by global definitions
come from membership axioms that can be used in the
form:
πZ
Ù name ç expression § true
∞
which may again be used in forming new proof contexts, or possibly as 
theorems to resolve or chain against.
The derived form can be automatically produced from the original axiom by, e.g. the rewriting tools, and
does not need to be separately stored. 
\end{document}
