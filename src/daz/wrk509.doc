% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
% use_file "wrk509";
% doctex wrk509x[0-9][0-9].th
% docdvi wrk509
\documentstyle[hol1,11pt,TQ,hyperbasics]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{VC Generation By Declarations}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/WRK509}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{%
As part of the requirements analysis for proof tools for the Compliance Notation, the VC generation has been analysed for basic declrations.
This paper reports on that analysis.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
%\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document reports on a study called for in \cite{ISS/HAT/DAZ/PLN010,ISS/HAT/DAZ/PLN012}.
\subsection{Introduction}
As part of the requirements analysis for proof tools for the Compliance Notation, the VC generation has been analysed for basic declarations.
This paper reports on that analysis.

\section{PREAMBLE}

As a theory to provide a home for our Z:
=SML
map (fn thy => ( force_delete_theory thy handle Fail _ => () ))
	(get_descendants "cn" less "cn" diff get_cache_theories());
open_theory"cn";
new_theory"wrk509aux";
=TEX
The following Standard ML command is used to set up the tool to process each of the many little scripts comprised in this document.
=SML
fun ns (script : string) : unit = (
	new_script {name=script, state=initial_cn_state};
	new_parent"wrk509aux"
);
=TEX
\section{CATEGORIES OF BASIC DECLARATIONS}
\subsection{A Hierarchy of Usefulness}
A conversion (or implicitly, and most commonly) the theorem used to generate the conversion) can be
categorised as to its likely usefulness.
\begin{description}
\item[Class 1]
Appropriate to be a conversion for a straightforward proof context in the appropriate theory.

Such a conversion should simplify the term it is applied to, and not lengthen it. 
Appropriate conversions for this class would for example be ones that replace constants by literals.

It is still possible that a user will not want the conversion applied in all cases, but only with the sort of frequency that, for instance pure rewriting is chosen over rewriting with the current proof context rewrite rules.

\item[Class 2]
Appropriate to be a conversion used within a straightforward automatic proof procedure, but not one that should "always" be applied.
A user would probably want easy access to such a conversion.

Such a conversion should simplify the term it is applied to, but may lengthen it to some extent.
Appropiate conversions would be ones that move the proof into a "lower" theory, 
such as rewriting a Compliance Notation expression into a term only using operators from the theory of relations, when reasoning about the Compliance Notation form of the term is unlikely to progress any other way.

\item[Class 3]
Appropriate only to automatic proof tools that take a "brutal" approach to
a proof, for instance,  conversion that simplifies, but greatly lengthens, a term, whose output is not intended to be human readable.
Such a conversion will not often be of use in a manual proof.

Some of the extensionality conversions would fit in this class.

\item[Class 4]
A conversion that is has no appropriate use except for careful manual use.

This includes many recursive definitions and conversions that reverse the effect of 
conversions from other classes.
\end{description}

\subsection{Constants}
A declaration of a constant will either introduce a global definition or an axiom, depending on whether the constant's expression can be translated into Z.

These Z paragraphs are either of the form:
¹Z
name == expression
°
or:
¹Z
name : type
°

A theorem providing the rewrite of the name to the best available evaluation of the expression in the first case 
would of use.
Such a theorem would be in Class 1 if the expression can be evaluated to a literal or other more primitive constant, and otherwise would probably fall in class 2 (and the worst cases in Class 3).

There is no obvious processing for the second case, but the axiom (used as a membership statement) is in Class 1.

\subsection{Enumeration Types}
The introduction of an enumeration type introduces generic definitions of the enumerated elements, the type itself, and the types attributes.
In more detail:

There will be one global definition per enumerated item, of the form:
¹Z
name == integer_literal
°
Such theorems are in class 1.

The global definition of the type is of the form:
¹Z
name == name‰0 .. name‰n
°
This can be rewritten to:
¹Z
ô name = 0 .. integer_literal
°
or various other obvious forms, e.g. involving inequalities, or simplifications
if there are few enumerated elements.
This rewritten theorem belongs in Class 2 (perhaps Class 1 in special cases).

The attributes are as follows:

¹Z
name__FIRST == name‰0
name__LAST == name‰n
°
which can be rewritten to:
¹Z
ô name__FIRST = 0
ô name__LAST = integer_literal
°
These rewritten theorems belong in Class 1.

¹Z
name__SUCC == (name \ {name__LAST}) ò succ
°
This has a variety of possible rewrites. The two extremes might be:
¹Z
ô name__SUCC == (0 .. integer_literal) ò succ
ô name__SUCC == {(0,1), ..., (integer_literal‰n, integer_literalè n + 1ê)}
°
In general, the first belongs in Class 2, the second in Class 3. 
However, if the enumerated type is small (1, 2, maybe 3, elements), then 
then simplifications can be made to the first rewritten theorem, and the results moved up the classes.
Some rewriting use may be made of the fact that the domain of $succ$ is already domain restricted to $\nat$.

¹Z
name__PRED == ((name \ {name__LAST}) ò succ)~
°
This has a variety of possible rewrites. The two extremes might be:
¹Z
ô name__PRED == (1 .. integer_literal) ò (succ ~)
ô name__PRED == {(1,0), ..., (integer_literal‰n, integer_literalè n - 1ê)}
°
In general, the first belongs in Class 2, the second in Class 3. 
However, if the enumerated type is small (1, 2, maybe 3, elements), then 
then simplifications can be made to the first rewritten theorem, and the results moved up the classes.
Some rewriting use may be made of the fact that the domain of $succ$ is already domain restricted to $\nat$.

¹Z
name__POS == id name
name__VAL == name__POS~
°
The second can be rewritten to:
¹Z
ô name__VAL = name__POS
°
The rewritten theorem should probably be in Class 1, the first global definition should be in Class 2 (it is too expansive, given the follow-on rewrite of the type name, to be in Class 1).
A rewrite theorem of the following form might be put in Class 3 if the type is small (if very small, perhaps even in Class 2):
¹Z
ô name__POS = {(0,0),...(integer_literal‰n, integer_literal‰n)}
°

\subsection{Array Types}
The introduction of an constrained array type will introduce global definitions for the type itself and, if only 1-dimensional, its attributes.

¹Z
name == index_name‰1 ¸ index_name‰2 ¸ ... ­ comp_name
°
The index$\_$names are the type names of discrete ranges.
This definition is in Class 2 or maybe even 3, depending on the number and character of the index types.

For 1-dimensional arrays the attribute definitions are:
¹Z
name__FIRST == index_name‰1__FIRST
name__LAST == index_name‰1__LAST
name__LENGTH == # index_name‰1
name__RANGE == index_name‰1
°
All but the 3rd of these are in Class 1, the 3rd one being in Class 2.

The introduction of an unconstrained array type only introduces an axiom of the form:
¹Z
name : ð (index_name‰1 ¸ index_name‰2 ¸ ... ­ comp_name)
°
This axiom, used as a membership statement is probably in Class 1.

\subsection{Record Types}
The introduction of a record type will introduce the following style of schema:
ÿ name üüüüüüüüüüü
Ü lab‰1 : type_name‰1
Ü ...
Ü lab‰n : type_name‰n
ˆüüüüüüüüüüüüüü
This can be used to generate various type membership theorems, that might be
useful (and thus perhaps even in Class 1 due to their simple nature).

\subsection{Integer Types}
We know that integer type declarations are essentially types with statically evaluable range constraints. 
Their introduction causes the introduction of a global definition of themselves and either global definitions or axioms for their attributes.

¹Z
name == exp‰1 .. exp‰2
°
(what happens to range attributes as valid SPARC range constraints???)
This is a Class 2 theorem, and there may be possible rewrites of it.

¹Z
name__FIRST == exp‰1
name__LAST == exp‰2
°
Rewrite theorems based on the static evaluation of the expressions should be in Class 1 if the results are integer literals or other constants, and Class 2 otherwise.

¹Z
name__SUCC : ú ß ú
name__PRED : ú ß ú
name__POS : ú ß ú
name__VAL : ú ß ú
°
These, taken as membership statements are in Class 1.



\section{NIGGLES}
type marks versus type names.

statically evaluable effects.
\end{document}
=IGN

