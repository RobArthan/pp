%  dtd508.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD508}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Web Clause Processor.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{TRANSLATING SPARK BASIC DECLARATIONS}
\subsection{Preamble}
=DUMP dtd508.imp.sml
=TEX
=DOC
signature €CNBasicDeclarations› = sig
local
	open CNTypes CNEnvironmentTypes ZProofMode;
in
=DESCRIBE
=ENDDOC

πZAX
‹	trans_basic_decl : BASIC_DECL -> seq Z_PARA
∞

=SML
=IGN
val €trans_basic_decl› : BASIC_DECL -> Z_PARA list
=TEX

ˇBasic_Decl_Pars¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	basic_decl : BASIC_DECL;
‹	z : seq Z_PARA
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\subsection{Translating Constants}

πZAX
‹	trans_id : ID ≠ Z_ID
∞

=SML
val €trans_id› : ID -> Z_ID
=DUMPMORE dtd508.imp.sml
fun trans_id id = (

let	fun aux (c::rest) = (
		case c of
		"." => "âƒ"::aux rest
		|_ => (to_upper c)::aux rest	
	) | aux _ = []
in
	(implode o aux o explode) id
end
);
=TEX

πZAX
‹	trans_exp : EXP -> Z_EXP
∞

=SML
val €trans_exp› : EXP -> Z_EXP
=DUMPMORE dtd508.imp.sml
fun trans_exp exp = (
	Ò˙Æ
);
=TEX

=SML
val €trans_exp› : EXP -> Z_EXP
=TEX


ˇBasic_Decl_Const¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Basic_Decl_Pars
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	∂ Const_Decl ∑
‹		basic_decl = const_decl (  Const_Decl) ±
‹		z = ßz_eq_eq(trans_id const, trans_exp expr)¢
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
val €basic_decl_const› : EXP CONST_DECL -> PARAINFO list
=DUMPMORE dtd508.imp.sml
fun basic_decl_const {consts=consts, tm=tm, expr=expr} = (
	map (fn c => z_eq_eq(trans_id c, trans_exp expr)) consts
);
=TEX

\subsection{Translating Types}

πZ
‹	zfst ¶ trans_id fst
∞
πZ
‹	zlst ¶ trans_id lst
∞
πZ
‹	zsuc ¶ trans_id suc
∞
πZ
‹	zpred ¶ trans_id pred
∞
πZ
‹	zpos ¶ trans_id pos
∞
πZ
‹	zval ¶ trans_id val
∞
πZ
‹	zlength ¶ trans_id length
∞
πZ
‹	zrange ¶ trans_id range
∞
=DUMPMORE dtd508.imp.sml
val	zfst = trans_id "first"
and	zlst = trans_id "last"
and	zsuc = trans_id "succ"
and	zpred = trans_id "pred"
and	zpos = trans_id "pos"
and	zval = trans_id "val"
and	zlength = trans_id "length"
and	zrange = trans_id "range";
=TEX

πZ
‹	fun 3	_ ^ _
∞

πZAX
‹	_ ^ _ : (Z_ID ∏ Z_ID) ≠ Z_ID
∞

=SML
val ^^ : (Z_ID * Z_ID) -> Z_ID
=DUMPMORE dtd508.imp.sml
infix 3 ^^;
fun zid1^^ zid2 = (
	zid1^"â¡"^zid2
);
=TEX

πZAX
‹	enum_attrib : (Z_ID ∏ Z_ID ∏ Z_ID) ≠ seq Z_PARA
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ zidâ1, zidâ2, zidâ3 : Z_ID ∑
‹	∂ zexp : Z_EXP ∑
‹	zexp = z_set_minus(zid zidâ1, z_set {zid (zidâ1 ^ zlst)}) ±
‹	enum_attrib (zidâ1, zidâ2, zidâ3) =
‹		ßz_eq_eq(zidâ1 ^ zfst, zid zidâ2),
‹		z_eq_eq(zidâ1 ^ zlst, zid zidâ3),
‹		z_eq_eq(zidâ1 ^ zsuc, z_dom_res(zexp, zsucc)),
‹		z_eq_eq(zidâ1 ^ zpred, z_inv(zid (zidâ1 ^ zsuc))),
‹		z_eq_eq(zidâ1 ^ zpos, z_id_rel (zid zidâ1)),
‹		z_eq_eq(zidâ1 ^ zval, z_inv(zid(zidâ1 ^ zpos)))
∞

=SML
val €enum_attrib› : (Z_ID * Z_ID * Z_ID) -> PARAINFO list
=DUMPMORE dtd508.imp.sml
fun enum_attrib (zidâ1, zidâ2, zidâ3) = (
let	val zexp = z_set_minus (zid zidâ1, z_set[zid (zidâ1^^zlst)]);
in
	[z_eq_eq (zidâ1 ^^ zfst, zid zidâ2),
	z_eq_eq (zidâ1 ^^ zlst, zid zidâ3),
	z_eq_eq (zidâ1 ^^ zsuc, z_dom_res (zexp, zsucc)),
	z_eq_eq(zidâ1 ^^ zpred, z_inv(zid (zidâ1 ^^ zsuc))),
	z_eq_eq(zidâ1 ^^ zpos, z_id_rel (zid zidâ1)),
	z_eq_eq(zidâ1 ^^ zval, z_inv(zid(zidâ1 ^^ zpos)))]
end);
=TEX

ù[X,Y]úúúúúúúúúúúúúú
‹	map : (X ≠ Y) ≠ seq X ≠ seq Y
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ f : X ≠ Y; s : seq X ∑
‹	map f s = {i : ˙; x : X | (i, x) ç s ∑ (i, f x)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

This function already exists in {\Product} and is called $map$.

ˇBasic_Decl_Enum¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Basic_Decl_Pars
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	∂ Type_Decl; Enum_Type_Def; zname : Z_ID;
‹	zvals : seq Z_ID ∑
‹	basic_decl = type_decl (  Type_Decl) ±
‹	type_def = enum_type_def (  Enum_Type_Def) ±
‹	zname = trans_id name ± zvals = map trans_id vals ±
‹	z =
‹	{ i : dom vals ∑ i Ì z_eq_eq(zvals i, z_num(i-1))} ^
‹		ßz_eq_eq(zname, z_rng(zid(head zvals), zid(last zvals)))¢ ^
‹		enum_attrib(zname, head zvals, last zvals)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
val €basic_decl_enum› : TYPE_DEF TYPE_DECL -> PARAINFO list
=DUMPMORE dtd508.imp.sml
fun basic_decl_enum ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val {vals=vals} =
		case type_def of
		TDEnumTypeDef td => td
		|_ => basic_decl_error "basic_decl_enum";
	val zname = trans_id name;
	val zvals = map trans_id vals;
	val znums = map z_num (interval 0 ((length vals)-1));
in
	map (fn j => z_eq_eq j) (combine zvals znums) @
	[z_eq_eq(zname, z_rng(zid(head zvals), zid(last zvals)))] @
	enum_attrib(zname, head zvals, last zvals)
end);
=TEX

πZAX
‹	int_type_attrib : (Z_ID ∏ Range) ≠ seq Z_PARA
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ zidâ1 : Z_ID; Range ∑
‹	int_type_attrib (zidâ1,   Range) =
‹		ßz_eq_eq(zidâ1 ^ zfst, trans_exp lo),
‹		z_eq_eq(zidâ1 ^ zlst, trans_exp hi)¢
∞

=SML
val €int_type_attrib› : (Z_ID * EXP RANGE) -> PARAINFO list
=DUMPMORE dtd508.imp.sml
fun int_type_attrib (zidâ1, {lo=lo, hi=Value hi}) = (
	[z_eq_eq(zidâ1 ^^ zfst, trans_exp lo),
	z_eq_eq(zidâ1 ^^ zlst, trans_exp hi)]
) | int_type_attrib _ = basic_decl_error "int_type_attrib";
=TEX

ˇBasic_Decl_Int_Type¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Basic_Decl_Pars
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	∂ Type_Decl; Range; zname : Z_ID ∑
‹	basic_decl = type_decl (  Type_Decl) ±
‹	type_def = int_type_def (  Range) ±
‹	zname = trans_id name
‹	z =
‹	ßz_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi))¢ ^
‹		int_type_attrib(zname,   Range)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
val €basic_decl_int_type› : TYPE_DEF TYPE_DECL -> PARAINFO list
=DUMPMORE dtd508.imp.sml
fun basic_decl_int_type ({name=name, type_def=type_def,...} : TYPE_DEF TYPE_DECL) = (
let	val (lo, hi) =
		case type_def of
		TDIntTypeDef {lo=lo,hi=Value h} => (lo, h)
		|_ => basic_decl_error "basic_decl_enum";
	val zname = trans_id name;
in
	[z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi))] @
		int_type_attrib(zname, {lo=lo,hi=Value hi})
end);
=TEX


\subsection{Translating Subtypes}

\section{Epilogue}

=SML
end (* local...in *);
end (* signature CNBasicDeclarations *);
=TEX

\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{Preamble}

=DOC
signature €CNExpressions› = sig
=DESCRIBE
=ENDDOC

\subsection{Translating Identifiers}

\subsection{Translating Integer Literals}

\subsection{Translating Aggregates}

\subsection{Translating Unary Expressions}

\subsection{Translating Binary Expressions}

\subsection{Translating Attributes}

\subsection{Translating Indexed Components}

\subsection{Translating Selected Components}

\subsection{Translating Functions Calls}

\subsection{Translating Auxiliary Expressions}

\subsection{Epilogue}
=SML
end; (* signature CNExpressions *)
=TEX




=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



