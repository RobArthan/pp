% dtd508.doc %Z% $Date: 2000/10/19 16:05:54 $ $Revision: 1.58 $ $RCSfile: dtd508.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}	%% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Declaration and Expression Generator} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD508}	%% Mandatory field
\def\SCCSversion{$Revision: 1.58 $%
}
\TPPissue{\SCCSversion}	%% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/10/19 16:05:54 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This is the detailed design for the Declaration and Expression Generator as specified in volume 3 of DRA/CIS/CSE3/TR/94/27/3.0.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}		% to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.12] Initial Drafts.
\item[Issue 1.13 (9th June 1994)] First draft for review.
\item[Issue 1.14-1.16] Bug fixing.
\item[Issues 1.17,1.18 (14th July 1994)] Minor typographical corrections.
\item[Issue 1.19 (22nd Sept 1994)] Changed according to desk check report 008.
\item[Issue 1.23 (31 October 1994)] Added $z\_true$ and $z\_exists$ as per version 1.1 of Volume 3 of DRA's specification.
\item[Issue 1.24 (9th November 1994)]
Adjusted $ENV\_INFO$ and allowed for type conversions.
\item[Issues 1.25-1.26] Bug fixing.
\item[Issue 1.27] Updated document references.
\item[Issue 1.28] Updated the Z for DRA enhancements 13 and 14.
\item[Issue 1.29] Enhancment 11.
\item[Issue 1.30] Enhancements 13 and 14.
\item[Issue 1.31] Enhancement 15.
\item[Issues 1.32-1.35] Enhancements to translation of basic declarations
(enhancements number, 2, 3, 8).
\item[Issues 1.36-1.37] Enhancements 3 and 18.
\item[Issue 1.38 (14th December 1995)] Changes according to desk check report 024.
\item [Issue 1.39] Improved error reporting.
\item[Issue 1.40] IUCT WP 7 changes.
\item[Issue 1.41] IUCT WP 4 changes.
\item[Issue 1.42] Corrected Z syntax and type errors.
\item[Issue 1.43] Improved some error messages.
\item[Issue 1.44] Updated references.
\item[Issue 1.45,1.46] Update for SML97. Fixed broken error message.
\item[Issue 1.47] Update for new INTEGER type.
\item[Issue 1.48] Trial of enhancements from \cite{LEMMA1/DAZ/HLD506}.
\item[Issue 1.49,1.50] Typechecking new approach to enhancement R3 --- Assignment to Record Components.
\item[Issue 1.51] Enhancement R2 --- Multiple Logical Constants.
\item[Issues 1.52-1.54] Enhancement R1 --- Multidimensional Arrays.
\item[Issue 1.55] CTLE II R1/2 --- ``Others'' in case statements.
\item[Issue 1.55] CTLE II R1/2 --- ``Others'' in case statements.
\item[Issue 1.56] CTLE II R1/4 --- logical operators on arrays
of booleans, including overloading, and some parts of R1/1 (reals) and R1/8 (characters and strings).
\item[Issue 1.57,1.58] CTLE II R1/8 --- characters and strings.
\item[Issue 1.59] CTLE II R1/5 --- range attributes as ranges.
\end{description}

\subsection{Changes Forecast}

None.

\section{GENERAL}

\subsection{Scope}
This document contains the detailed design for the Basic Declaration and Expression Generator. The design is in response to the high level design for compliance notation processing \cite{ISS/HAT/DAZ/HLD503}.

The document provides a design which implements DRA's specification for Basic Declaration and Expression Generation described in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.
Specifically, the implementation corresponds to the specification in sections 5 and 6 of \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

Free type definitions in the specification of the Abstract Syntax for Z in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0} are implemented as functions corresponding to the type constructors of the type definitions. The design of these is covered by this document. 

\subsection{Introduction}

\subsubsection{Purpose and Background}
The declaration and expression generator is called by the VC generator \cite{ISS/HAT/DAZ/IMP505} and the Z document generator \cite{ISS/HAT/DAZ/IMP507} to translate SPARK basic declarations and expressions into Z according to the algorithms specified in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

The Z of \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0} is reproduced in this document (suitable for type-checking with {\Product}) adjacent to the signature declarations of the functions which implement the Z. The corresponding implementatation is in \cite{ISS/HAT/DAZ/IMP508}.

\subsection{Compliance}

This detailed design contains signatures for Standard ML functions with the Z specification of these functions, transcribed from \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}. The names of these functions corresponds to the names used in the Z, and where they differ, justification has been provided.

The implementation of this design can be found in \cite{ISS/HAT/DAZ/IMP508} where the style of coding is intended to make the compliance with the Z specification evident by a visual comparison.

%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}

\section{PREAMBLE}
The following literate script is used for type checking the Z in this document with {\Product}. It is not processed when building the Compliance Tool.

=SMLZ
open_theory"dtd502";
push_pc "z_library";
force_delete_theory"dtd508" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory "dtd508";
=TEX

\section{THE SIGNATURE $CNBasicDeclsAndExprs$}
=DOC
local
	open CNTypes ZParagraphs;
in
signature ÛCNBasicDeclsAndExprsÝ = sig
=DESCRIBE
This is the signature for the Basic Declaration and Expression Generator.
=ENDDOC

\section{CUSTOMIZED ENVIRONMENT HANDLING}

=DOC
datatype ÛENV_INFOÝ =
			ÛEIEnvFunctionÝ of Z_ID list * ID list (* globals / pars *)
		|	ÛEIEnvVarÝ of TMARK
		|	ÛEIEnvAuxVarÝ of Z_DECL
		|	ÛEIEnvRecordTypeÝ of ID list
		|	ÛEIEnvOtherTypeÝ
		|	ÛEIEnvOtherÝ;

type ÛCN_ENVÝ (* = Z_ID -> (TYPE * ENV_INFO) OPT *);
=DESCRIBE
$CN\_ENV$ is the type of a function which maps an identifier onto its type and yields contextual information about the identifier.
Such functions returns $Nil$ if the identifier is not in scope at the point at which the function is called.
=USES
A function of type $CN\_ENV$ is passed recursively into the generator for basic declarations and expressions so that the contextual information about an identifier is available at the point it is needed.
=ENDDOC

\section{SUPPORT FOR Z ABSTRACT SYNTAX}

\subsection{Z Unary Expressions}

=DOC
val Ûz_unary_minusÝ : Z_EXP
val Ûz_bool_notÝ : Z_EXP
val Ûz_absÝ : Z_EXP
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for unary expressions in ISS/HAT/DAZ/DTD502.}
=ENDDOC

\subsection{Z Binary Expressions}

=DOC
val Ûz_bool_andÝ : Z_EXP
val Ûz_bool_orÝ : Z_EXP
val Ûz_bool_xorÝ : Z_EXP
val Ûz_bool_eqÝ : Z_EXP
val Ûz_bool_noteqÝ : Z_EXP
val Ûz_bool_lessÝ : Z_EXP
val Ûz_bool_less_eqÝ : Z_EXP
val Ûz_bool_greaterÝ : Z_EXP
val Ûz_bool_greater_eqÝ : Z_EXP
val Ûz_addÝ : Z_EXP
val Ûz_minusÝ : Z_EXP
val Ûz_timesÝ : Z_EXP
val Ûz_intdivÝ : Z_EXP
val Ûz_modÝ : Z_EXP
val Ûz_remÝ : Z_EXP
val Ûz_exponÝ : Z_EXP
val Ûz_bool_memÝ : Z_EXP
val Ûz_bool_notmemÝ : Z_EXP
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for binary expressions in ISS/HAT/DAZ/DTD502.}
=ENDDOC

\subsection{Z Expressions}
=DOC
val ÛzsuccÝ : Z_EXP
val ÛzidÝ : CN_ENV -> Z_ID -> Z_EXP
val Ûz_numÝ : INTEGER -> Z_EXP
val Ûz_stringÝ : string -> Z_EXP
val Ûz_tfunÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_pfunÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_rngÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_domÝ : Z_EXP -> Z_EXP
val Ûz_dom_resÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_invÝ : Z_EXP -> Z_EXP
val Ûz_id_relÝ : Z_EXP -> Z_EXP
val Ûz_sizeÝ : Z_EXP -> Z_EXP
val Ûz_setÝ : Z_EXP list -> Z_EXP
val Ûz_set_minusÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_set_compÝ : (Z_DECL * Z_EXP) -> Z_EXP
val Ûz_powerÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_rel_compÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_seqÝ : Z_EXP list -> Z_EXP
val Ûz_crossÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_many_crossÝ : (Z_EXP list) -> Z_EXP
val Ûz_overrideÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_many_unionÝ : Z_EXP list -> Z_EXP
val Ûz_unary_expÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_bin_expÝ : (Z_EXP * Z_EXP * Z_EXP) -> Z_EXP
val Ûz_fun_callÝ : (Z_EXP * Z_EXP list) -> Z_EXP
val Ûz_selectionÝ : (Z_EXP * Z_ID) -> Z_EXP
val Ûz_mapletÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_powersetÝ : Z_EXP -> Z_EXP
val Ûz_bindingÝ : (string * Z_EXP) list -> Z_EXP
val Ûz_tupleÝ : Z_EXP list -> Z_EXP
val Ûother_z_expÝ : Z_EXP -> Z_EXP
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for expressions in ISS/HAT/DAZ/DTD502.}
=ENDDOC

\subsection{Z Predicates}

=DOC
val Ûz_trueÝ : Z_PRED
val Ûz_eqÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_andÝ : (Z_PRED * Z_PRED) -> Z_PRED
val Ûz_many_andÝ : Z_PRED list -> Z_PRED
val Ûz_elemÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_notelemÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_noteqÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_less_eqÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_greaterÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_forallÝ : (Z_DECL list * Z_PRED) -> Z_PRED
val Ûz_existsÝ : (Z_DECL list * Z_PRED) -> Z_PRED
val Ûz_impÝ : (Z_PRED * Z_PRED) -> Z_PRED
val Ûz_memÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûother_z_predÝ : Z_PRED -> Z_PRED
=DESCRIBE
\raggedright{This corresponds to  the abstract syntax of Z for predicates in ISS/HAT/DAZ/DTD502.}
=ENDDOC

\subsection{Z Paragraphs}

=DOC
val Ûz_eq_eqÝ : (Z_ID * Z_EXP) -> PARAINFO
val Ûz_axÝ : (Z_ID * Z_EXP * Z_PRED list) -> PARAINFO
val Ûz_schemaÝ : (Z_ID * Z_DECL list) -> PARAINFO
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for some of the Z paragraphs in ISS/HAT/DAZ/DTD502.}
=ENDDOC

\subsection{Failure Messages}
The following error messages can be reported by the functions which support the Z abstract syntax.

=FAILURE
508021	The variable ñ?0® is not in scope
508023	Internal error: ?0 is a badly formed Z declaration
508024	Internal error: The expression list argument must not be empty 
=TEX

\section{TRANSLATING SPARK EXPRESSIONS}

The following corresponds to the specification in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

The signature for $trans\_exp$ is in section \ref{transexp}.

¹ZAX
Ü	trans_exp : EXP ß Z_EXP
°

ÿExp_Parsüüüüüüüüüüüüüüüüüü
Ü	expr : EXP;
Ü	zexpr : Z_EXP
ˆüüüüüüüüüüüüüüüüüü

\subsection{Translating Identifiers}
=DOC
val Ûtrans_idÝ : ID -> Z_ID
=DESCRIBE
¹ZAX
Ü	trans_id : ID ­ Z_ID
°
=ENDDOC

Note $Id: dtd508.doc,v 1.58 2000/10/19 16:05:54 rda Exp $ in the following paragraph rather than $id$ because $id$ is a reserved word in the Z library of {\ProductZ}.

ÿExp_Idüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ ident : ID · expr = Id ident ± zexpr = zid(trans_id ident)
ˆüüüüüüüüüüüüüüüüüü

\subsection{Translating Aggregates (Positional Array)}
=DOC
val ÛzfstÝ : Z_ID
val ÛzlstÝ : Z_ID
val ÛzsucÝ : Z_ID
val ÛzpredÝ : Z_ID
val ÛzposÝ : Z_ID
val ÛzvalÝ : Z_ID
val ÛzlengthÝ : Z_ID
val ÛzrangeÝ : Z_ID
=DESCRIBE
¹Z
Ü	zfst ¦ trans_id fst
°
¹Z
Ü	zlst ¦ trans_id lst
°
¹Z
Ü	zsuc ¦ trans_id suc
°
¹Z
Ü	zpred ¦ trans_id pred
°
¹Z
Ü	zpos ¦ trans_id pos
°
¹Z
Ü	zval ¦ trans_id val
°
¹Z
Ü	zlength ¦ trans_id length
°
¹Z
Ü	zrange ¦ trans_id range
°
=ENDDOC

=DOC
(* infix 3 ^^; *)

val Û^^Ý : Z_ID * Z_ID -> Z_ID
=DESCRIBE
¹Z
Ü	fun 3	_ ^ _
°
¹ZAX
Ü	_ ^ _ : (Z_ID ¸ Z_ID) ­ Z_ID
°
=ENDDOC

=DOC
val Ûdest_range : EXP RANGE -> EXP RANGELOHI
=DESCRIBE
Given a range of either of the forms {\it x .. y}
or {\it t'range}, this function gives upper and lower
bounds for the range (either {\it x} and {\it y}
or {\it t'first} and {\it t'last}. It also handles
the case {\it t.range(n)} by mapping to {\it t'first(n)} and {\it t'last(n)}.
It is exposed here so that it can be used in the verification condition generation
for case and loop statements.
=ENDDOC
The function $map$ already exists in {\Product} and already corresponds to this specification.

[X, Y]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	map : (X ­ Y) ­ seq X ­ seq Y
÷üüüüüüüüüüüüüüüüüüüüü
Ü	µ f : X ­ Y; s : seq X ·
Ü	map f s = { i : ú; x : X | (i, x)  s · (i, f x)}
ˆüüüüüüüüüüüüüüüüüüüüüü
=DOC
val ÛdimenÝ : Z_ID * int -> Z_ID
=DESCRIBE
¹ZAX
Ü dimen : (Z_ID ¸ î) ­ Z_ID
°
=ENDDOC
=DOC
type ÛARRAY_AGG_ENVÝ (* = {tname : TMARK, this : int, max : int} *);
=DESCRIBE
ÿ Array_Agg_Env üüüüüüüüüüü
Ü	tname : TMARK;
Ü	this, max  : î
÷üüüüüü
Ü	 1 ¼ this ¼ max + 1
ˆüüüüüüüüüüüüüü
=ENDDOC
=DOC
val Ûtrans_array_agg_expÝ : CN_ENV -> ARRAY_AGG_ENV -> EXP -> Z_EXP
=DESCRIBE
¹ZAX
Ü	trans_array_agg_exp : Array_Agg_Env ­ EXP ß Z_EXP
÷üüüüüü
Ü	µ Array_Agg_Env
Ü	|	this = max + 1
Ü	·	trans_array_agg_exp (ÊArray_Agg_Env) = trans_exp
°
=ENDDOC
ÿ Array_Agg_Pars üüüüüüüüüüü
Ü 	Array_Agg_Env;
Ü 	expr : EXP;
Ü	zexpr : Z_EXP
ˆüüüüüüüüüüüüüü
=DOC
val Ûarray_firstÝ : CN_ENV -> ARRAY_AGG_ENV -> Z_EXP;
=DESCRIBE
¹ZAX
Ü	array_first : Array_Agg_Env  ­ Z_EXP
÷üüüüüü
Ü	µ Array_Agg_Env
Ü	· max = 1 ±
Ü		array_first(ÊArray_Agg_Env) = zid(trans_id tname ^ zfst)
Ü	² max ½ 1 ±
Ü		array_first(ÊArray_Agg_Env) = zid(dimen(trans_id tname ^ zfst, this))
°
=ENDDOC
=DOC
val Ûexp_array_agg_posÝ : CN_ENV -> ARRAY_AGG_ENV -> EXP AGG_POS -> Z_EXP
=DESCRIBE
ÿExp_Array_Agg_Posüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Pos; Z_Bin_Exp; zseq : seq Z_EXP; Array_Agg_Env' ·
Ü	expr = array_agg_pos (ÊAgg_Pos) ±
Ü	ran comps € dom (trans_array_agg_exp (ÊArray_Agg_Env')) ±
Ü	zop = z_minus ± zleft = z_num 1 ± 
Ü	zright = array_first(ÊArray_Agg_Env) ±
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	zseq = map (trans_array_agg_exp (ÊArray_Agg_Env')) comps ±
Ü	zexpr =
Ü	z_rel_comp(z_power(zsucc, z_bin_exp(ÊZ_Bin_Exp)), z_seq zseq)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Positional Array with Others)}
=DOC
val Ûexp_array_agg_pos_othersÝ : CN_ENV -> ARRAY_AGG_ENV -> EXP AGG_POS_OTHERS -> Z_EXP
=DESCRIBE
ÿExp_Array_Agg_Pos_Othersüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Pos_Others; oth, posit : EXP; Array_Agg_Env' ·
Ü	expr = array_agg_pos_others (Ê Agg_Pos_Others) ±
Ü	oth = array_agg_others (Ê Agg_Others) ±
Ü	posit = array_agg_pos (Ê Agg_Pos) ±
Ü	oth  dom (trans_array_agg_exp (ÊArray_Agg_Env)) ±
Ü	posit  dom (trans_array_agg_exp (ÊArray_Agg_Env')) ±
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	zexpr =
Ü	z_override
Ü	(trans_array_agg_exp (ÊArray_Agg_Env) oth, trans_array_agg_exp (ÊArray_Agg_Env') posit)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Positional Array with Just Others)}
=DOC
val Ûarray_rangeÝ : CN_ENV -> ARRAY_AGG_ENV -> Z_EXP;
=DESCRIBE
¹ZAX
Ü	array_range : Array_Agg_Env  ­ Z_EXP
÷üüüüüü
Ü	µ Array_Agg_Env
Ü	· max = 1 ±
Ü		array_range(ÊArray_Agg_Env) = zid(trans_id tname ^ zrange)
Ü	² max ½ 1 ±
Ü		array_range(ÊArray_Agg_Env) = zid(dimen(trans_id tname ^ zrange, this))
°
=ENDDOC
=DOC
val Ûexp_array_agg_othersÝ : CN_ENV -> ARRAY_AGG_ENV -> EXP AGG_OTHERS -> Z_EXP
=DESCRIBE
ÿExp_Array_Agg_Othersüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Others; Array_Agg_Env' ·
Ü	expr = array_agg_others (Ê Agg_Others) ±
Ü	others  dom (trans_array_agg_exp (ÊArray_Agg_Env')) ±
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	zexpr =
Ü	z_cross(array_range(ÊArray_Agg_Env), z_set {trans_array_agg_exp (ÊArray_Agg_Env') others} )
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Named Array)}
=DOC
val Ûtrans_named_assocÝ : CN_ENV -> ARRAY_AGG_ENV ->
	(AGG_CHOICE,EXP) NAMED_ASSOC -> Z_EXP
=DESCRIBE
¹ZAX
Ü	trans_named_assoc : Array_Agg_Env ­ Named_Assoc ß Z_EXP
÷üüüüüüüü
Üµ Array_Agg_Env; Array_Agg_Env'·
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	dom (trans_named_assoc (ÊArray_Agg_Env)) = 
Ü	{ Named_Assoc |
Ü	(µ Range | agg_choice_range (Ê Range)  choices ·
Ü		{lo, hi} € dom trans_exp) ±
Ü	(µ ex : EXP | agg_choice_single ex  choices · ex  dom trans_exp) ±
Ü	comp  dom (trans_array_agg_exp(ÊArray_Agg_Env'))} ±
Ü	(µ Named_Assoc | ÊNamed_Assoc  dom (trans_named_assoc (ÊArray_Agg_Env))·
Ü	¶ zranges : ð Z_EXP; zsingles : Z_EXP ·
Ü	zranges =
Ü	{ Range | agg_choice_range (Ê Range)  choices ·
Ü		z_rng(trans_exp lo, trans_exp hi)} ±
Ü	zsingles =
Ü	z_set
Ü	{ ex : EXP | agg_choice_single ex  choices · trans_exp ex} ±
Ü	trans_named_assoc (ÊArray_Agg_Env) (Ê Named_Assoc) =
Ü	z_cross
Ü	(z_many_union(zranges À {zsingles}), z_set {trans_array_agg_exp (ÊArray_Agg_Env') comp} )) 
°
=ENDDOC

=DOC
val Ûexp_array_agg_namedÝ : CN_ENV ->
	ARRAY_AGG_ENV -> (AGG_CHOICE, EXP) AGG_NAMED -> Z_EXP
=DESCRIBE
ÿExp_Array_Agg_Namedüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Named ·
Ü	expr = array_agg_named (Ê Agg_Named) ±
Ü	named_assocs € dom (trans_named_assoc (ÊArray_Agg_Env)) ±
Ü	zexpr =
Ü	z_many_union
Ü	(trans_named_assoc (ÊArray_Agg_Env) ¨ named_assocs © )
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Named Array with Others)}
=DOC
val Ûexp_array_agg_named_othersÝ : CN_ENV
		-> ARRAY_AGG_ENV -> (AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> Z_EXP
=DESCRIBE
ÿExp_Array_Agg_Named_Othersüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Named_Others; oth, nam : EXP ·
Ü	expr = array_agg_named_others (Ê Agg_Named_Others) ±
Ü	oth = array_agg_others (Ê Agg_Others) ±
Ü	nam = array_agg_named (Ê Agg_Named) ±
Ü	{ oth, nam } € dom (trans_array_agg_exp(ÊArray_Agg_Env)) ±
Ü	zexpr =
Ü	z_override
Ü	(trans_array_agg_exp(ÊArray_Agg_Env) oth, trans_array_agg_exp(ÊArray_Agg_Env) nam)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

¹Z
Ü µArray_Agg_Pars | this ¼ max ·
Ü	expr í zexpr  trans_array_agg_exp (ÊArray_Agg_Env) ¤
Ü		 Exp_Array_Agg_Pos ² Exp_Array_Agg_Pos_Others ²
Ü		 Exp_Array_Agg_Others ² Exp_Array_Agg_Named ² Exp_Array_Agg_Named_Others
°
=DOC
val Ûarray_dimÝ : CN_ENV -> TMARK -> int;
=DESCRIBE
¹ZAX
Ü array_dim : TMARK ß î‰1
°
=ENDDOC
=DOC
val z_array_agg : int -> Z_ID;
val Ûmk_array_aggÝ : int * Z_EXP -> Z_EXP;
=DESCRIBE
¹ZAX
Ü z_array_agg : î ­ Z_ID
°

¹ZAX
Ü mk_array_agg : î ¸ Z_EXP ­ Z_EXP
÷üüüüüü
Üµ max_dim : î; zex : Z_EXP; Z_Fun_Call ·
Ü	max_dim = 1 ± mk_array_agg(max_dim, zex) = zex
Ü²	zfun = zid(z_array_agg max_dim) ± zargs = §zex¢ ±
Ü	mk_array_agg(max_dim, zex) = z_fun_call(ÊZ_Fun_Call)
°
=FAILURE
508058	type error detected while attempting to make a multidimensional aggregate from ?0
=ENDDOC
=DOC
val Ûexp_array_aggÝ : CN_ENV -> EXP -> Z_EXP
=DESCRIBE
ÿExp_Array_Agg üüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü¶ Array_Agg_Env ·
Ü((¶ Agg_Pos · expr = array_agg_pos (Ê Agg_Pos) ± opt_tmark_tmark tname = tmark) ²
Ü  (¶ Agg_Pos_Others · expr = array_agg_pos_others (Ê Agg_Pos_Others) ± opt_tmark_tmark tname = tmark) ²
Ü  (¶ Agg_Named · expr = array_agg_named (Ê Agg_Named) ± opt_tmark_tmark tname = tmark) ²
Ü  (¶ Agg_Named_Others · expr = array_agg_named_others (Ê Agg_Named_Others) ± opt_tmark_tmark tname = tmark))
Ü± tname í max  array_dim
Ü± this = 1
Ü± expr  dom (trans_array_agg_exp(ÊArray_Agg_Env))
Ü± zexpr = mk_array_agg (max, trans_array_agg_exp(ÊArray_Agg_Env) expr)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC
=TEX

\subsection{Translating Aggregates (Positional Record)}

=DOC
val Ûexp_rec_agg_pos_zÝ : CN_ENV -> TMARK OPT * Z_EXP list -> Z_EXP
=DESCRIBE
ÿExp_Rec_Agg_Posüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Rec_Agg_Pos; Z_Schema_Type; Z_Binding; tm : TMARK ·
Ü	expr = rec_agg_pos (Ê Rec_Agg_Pos) ± ran comps € dom trans_exp ±
Ü	z_type_of (zid (trans_id tmark)) =
Ü		z_power_type (z_sch_type (Ê Z_Schema_Type)) ±
Ü	zexpr = z_binding (Ê Z_Binding) ±
Ü	zbinds =
Ü	{ i : dom z_sig; Z_Decl |
Ü		zvar = first (z_sig i) ± zexp = trans_exp (comps i) · Ê Z_Decl}
ˆüüüüüüüüüüüüüüüüüü
=FAILURE
508026	The type ?0 is not a record type
508027	The number of components in the record aggregate
	does not match the declaration of ?0
=ENDDOC

\subsection{Translating Aggregates (Named Record)}
=DOC
val Ûexp_rec_agg_namedÝ : CN_ENV
	-> (AGG_CHOICE, EXP) REC_AGG_NAMED -> Z_EXP
=DESCRIBE
ÿExp_Rec_Agg_Namedüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Rec_Agg_Named; Z_Binding ·
Ü	expr = rec_agg_named (Ê Rec_Agg_Named) ±
Ü	{ ident : ID; ex : EXP | (ident, ex)  named_assocs · ex } €
Ü		dom trans_exp ± zexpr = z_binding (Ê Z_Binding) ±
Ü	zbinds =
Ü	{ ident : ID; ex : EXP; Z_Decl |
Ü		(ident, ex)  named_assocs ± zvar = trans_id ident ±
Ü		zexp = trans_exp ex · Ê Z_Decl }
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Unary Expressions}
=DOC
val Ûunary_opsÝ : UNARY_OP -> Z_EXP list;
val Ûtrans_unary_opÝ : UNARY_OP * Z_EXP -> Z_EXP
=DESCRIBE
¹ZAX
Ü	unary_ops : UNARY_OP ß ðZ_UNARY_OP
÷üüüüüüüüüüüüüüüüüüü
Ü	unary_ops =
Ü	{spark_unary_minus í {z_unary_minus, z_real_unary_minus},
Ü	 spark_not í {z_bool_not, z_array_not},
Ü	 spark_abs í {z_abs, z_real_abs} }
°
¹ZAX
Ü	trans_unary_op : UNARY_OP ¸ Z_EXP ß Z_UNARY_OP
÷üüüüüüüüüüüüüüüüüüü
Üµ op: UNARY_OP; zright : Z_EXP·
Ü	trans_unary_op(op, zright)  unary_ops op
°
=ENDDOC

=DOC
val Ûexp_unary_expÝ : CN_ENV -> EXP UNARY_EXP -> Z_EXP
=DESCRIBE
ÿExp_Unary_Expüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Unary_Exp; Z_Unary_Exp ·
Ü	expr = unary_exp (Ê Unary_Exp) ± right  dom trans_exp ±
Ü	(op = spark_unary_add ± zexpr = trans_exp right ²
Ü	op ½ spark_unary_add ± zop = trans_unary_op (op, zright) ±
Ü	zright = trans_exp right ± zexpr = z_unary_exp (Ê Z_Unary_Exp))
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Binary Expressions}
=DOC
val Ûbin_opsÝ : BIN_OP -> Z_EXP list
val Ûtrans_bin_opÝ : BIN_OP * Z_EXP * Z_EXP -> Z_EXP
=DESCRIBE

=FAILURE
508031	Internal error: unsupported SPARK operator
=ENDDOC
¹ZAX
Ü	bin_ops : BIN_OP ß ðZ_BIN_OP
÷üüüüüüüüüüüüüüüüüüü
Ü	bin_ops =
Ü	{spark_and í { z_bool_and, z_array_and },
Ü	 spark_or í { z_bool_or, z_array_or }, 
Ü	 spark_and_then í { z_bool_and, z_array_and },
Ü	 spark_or_else í { z_bool_or },
Ü	 spark_xor í { z_bool_xor },
Ü	 spark_eq í { z_bool_eq },
Ü	 spark_noteq í { z_bool_noteq },
Ü	 spark_less í { z_bool_less, z_array_less, z_bool_real_less },
Ü	 spark_less_eq í { z_bool_less_eq, z_array_less_eq, z_bool_real_less_eq },
Ü	 spark_greater í { z_bool_greater, z_array_greater, z_bool_real_greater },
Ü	 spark_greater_eq í { z_bool_greater_eq, z_array_greater_eq,
Ü				z_bool_real_greater_eq },
Ü	 spark_add í { z_add, z_real_add },
Ü	 spark_minus í { z_minus, z_real_minus },
Ü	 spark_times í { z_times, z_real_times },
Ü	 spark_intdiv í { z_intdiv },
Ü	 spark_mod í { z_mod },
Ü	 spark_over í { z_real_over }, 
Ü	 spark_rem í { z_rem },
Ü	 spark_expon í { z_expon, z_real_expon },
Ü	 spark_mem í { z_bool_mem },
Ü	 spark_notmem í { z_bool_notmem },
Ü	 spark_cat í { z_array_array_cat, z_array_elem_cat, z_elem_array_cat } }
°
¹ZAX
Ü	trans_bin_op : BIN_OP ¸ Z_EXP ¸ Z_EXP ß Z_BIN_OP
÷üüüüüüüüüüüüüüüüüüü
Üµ op: BIN_OP; zleft, zright : Z_EXP·
Ü	trans_bin_op(op, zleft, zright)  bin_ops op
°
=DOC
val Ûexp_bin_expÝ : CN_ENV -> EXP BIN_EXP -> Z_EXP
=DESCRIBE
ÿExp_Bin_Expüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Bin_Exp; Z_Bin_Exp ·
Ü	expr = bin_exp (Ê Bin_Exp) ± { left, right } € dom trans_exp ±
Ü	zop = trans_bin_op(op, zleft, zright) ± zleft = trans_exp left ±
Ü	zright = trans_exp right ± zexpr = z_bin_exp (Ê Z_Bin_Exp)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Membership of a Range}
=DOC
val Ûexp_mem_rangeÝ : CN_ENV -> EXP MEM_RANGE -> Z_EXP
=DESCRIBE
ÿExp_Mem_Rangeüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Mem_Range; Z_Bin_Exp ·
Ü	expr = mem_range (Ê Mem_Range) ± 
Ü	{ left, lo, hi } € dom trans_exp ± zop = trans_bin_op(op, zleft, zright) ±
Ü	zleft = trans_exp left ± zright = z_rng (trans_exp lo, trans_exp hi) ±
Ü	zexpr = z_bin_exp (Ê Z_Bin_Exp)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Attributes}
=DOC
val Ûexp_attribÝ : CN_ENV -> (EXP, ATTRIB_DESIG) ATTRIBUTE -> Z_EXP
=DESCRIBE
ÿExp_Attribüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB ·
Ü	expr = attribute (Ê Attribute) ± attrib_desig = attrib[EXP] att ±
Ü	zexpr = zid (trans_id prefix ^ trans_id att)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

The implementations of {\it Exp\_Nonarray\_Attrib\_Arg}
and {\it Exp\_Array\_Attrib\_Arg} are covered by the interface for $exp\_attrib$ and a separate functional interface has therefore not been provided.
¹Z
Ü	ARRAY_ATTRIB ¦ {fst, lst, length, range}
°

ÿExp_Nonarray_Attrib_Argüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB; arg : EXP; Z_Fun_Call ·
Ü	expr = attribute (Ê Attribute) ±
Ü	att Ž ARRAY_ATTRIB ±
Ü	attrib_desig = attrib_arg(att,arg) ± arg  dom trans_exp ±
Ü	zexpr = z_fun_call (Ê Z_Fun_Call) ±
Ü	zfun = zid (trans_id prefix ^ trans_id att) ±
Ü	zargs = § trans_exp arg ¢
ˆüüüüüüüüüüüüüüüüüü
=DOC
val Ûeval_attr_argÝ : Z_EXP -> int
=DESCRIBE
¹ZAX
Ü	eval_attr_arg : EXP ß î‰1
°
The implementation takes a Z expression to simplify the organisation of the
code.
=FAILURE
508029	Invalid attribute argument: ?0 cannot be statically evaluated to give an integer value
508030	Invalid attribute argument: ?0 is less than or equal to zero
=ENDDOC
ÿExp_Array_Attrib_Argüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB; arg : EXP ·
Ü	expr = attribute (Ê Attribute) ±
Ü	att  ARRAY_ATTRIB ±
Ü	attrib_desig = attrib_arg(att,arg) ± arg  dom eval_attr_arg ±
Ü	zexpr = zid (dimen(trans_id prefix ^ trans_id att, eval_attr_arg arg))
ˆüüüüüüüüüüüüüüüüüü

¹Z
Ü Exp_Attrib_Arg ¦ Exp_Nonarray_Attrib_Arg ² Exp_Array_Attrib_Arg
°

\subsection{Translating Indexed Components}
=DOC
val Ûexp_indexed_compÝ : CN_ENV -> EXP INDEXED_COMP -> Z_EXP
=DESCRIBE
ÿExp_Indexed_Compüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Indexed_Comp; Z_Fun_Call ·
Ü	expr = indexed_comp (Ê Indexed_Comp) ± 
Ü	{ prefix } À ran index € dom trans_exp ± zfun = trans_exp prefix ±
Ü	zargs = map trans_exp index ± zexpr = z_fun_call (Ê Z_Fun_Call)
ˆüüüüüüüüüüüüüüüüüü
=FAILURE
508071	type error: cannot apply ?0 to ?1
=ENDDOC

\subsection{Translating Selected Components}
=DOC
val Ûexp_selected_compÝ : CN_ENV -> EXP SELECTED_COMP -> Z_EXP
=DESCRIBE
ÿExp_Selected_Compüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Selected_Comp; Z_Selection ·
Ü	expr = selected_comp (Ê Selected_Comp) ± prefix  dom trans_exp ±
Ü	zbinding = trans_exp prefix ± zselector = trans_id selector ±
Ü	zexpr = z_selection (Ê Z_Selection)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Functions Calls}
=DOC
val Ûinformal_functionÝ : Z_ID;
val Ûfun_globalsÝ : CN_ENV -> ID -> Z_ID list;
val Ûtrans_fun_nameÝ : CN_ENV -> ID -> Z_EXP;
=DESCRIBE
¹ZAX
Ü fun_globals : ID ­ seq Z_ID
°
¹ZAX
Ü trans_fun_name : ID ­ Z_EXP
÷üüüüüüüü
Ü µn : ID·
Ü fun_globals n = §¢ ± trans_fun_name n = zid(trans_id n) ²
Ü (¶gs : seq‰1 Z_ID; Z_Fun_Call · gs = fun_globals n ±
Ü  zfun = zid(trans_id n) ± zargs = map zid gs ±
Ü  trans_fun_name n = z_fun_call(ÊZ_Fun_Call))
°
The formal specification of $informal\_function$ is in ISS/HAT/DAZ/DTD507.
It is needed here to implement informal check 17.
=FAILURE
508081	The environment information for ?0 is corrupt
=ENDDOC
=DOC
val Ûexp_fun_callÝ : CN_ENV -> EXP FUN_CALL -> Z_EXP
=DESCRIBE
ÿExp_Fun_Callüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü ¶ Fun_Call ·
Ü expr = fun_call (Ê Fun_Call) ± ran args € dom trans_exp ±
Ü (args = §¢ ± zexpr = trans_fun_name fun_name ²
Ü args ½ §¢ ±
Ü (¶Z_Fun_Call·
Ü  zfun = trans_fun_name fun_name ± zargs = map trans_exp args ±
Ü  zexpr = z_fun_call(Ê Z_Fun_Call)))
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsection{Translating Qualified Expressions}
=DOC
val Ûexp_qualifiedÝ : CN_ENV -> EXP QUALIFIED_EXPRESSION -> Z_EXP
=DESCRIBE
ÿExp_Qualifiedüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Qualified_Exp ·
Ü	expr = qualified_exp (Ê Qualified_Exp) ± ex  dom trans_exp ±
Ü	zexpr = trans_exp ex
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Type Conversions}
=DOC
val Ûexp_type_convÝ : CN_ENV -> EXP TYPE_CONVERSION -> Z_EXP
=DESCRIBE
ÿExp_Type_Convüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Type_Conv ·
Ü	expr = type_conv (Ê Type_Conv) ± ex  dom trans_exp ±
Ü	z_type_of(zid(trans_id tm)) = z_power_type z_int_type ±
Ü	z_type_of zexpr = z_int_type ± zexpr = trans_exp ex
ˆüüüüüüüüüüüüüüüüüü
=FAILURE
508053	Type conversions for types other than integer types
	cannot be handled formally
=ENDDOC

\subsection{Translating Integer Literals}
=DOC
val Ûtrans_intÝ : INT_LIT -> INTEGER
=DESCRIBE
¹ZAX
Ü	trans_int : INT_LIT ­ ú
°
=FAILURE
508025	Cannot translate ?0; this form of literal is not handled formally
=ENDDOC
=DOC
val Ûexp_int_litÝ : INT_LIT -> Z_EXP
=DESCRIBE
ÿExp_Int_Litüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ n : INT_LIT ·
Ü	expr = int n ± zexpr = z_num (trans_int n)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Real Literals}
=DOC

=DESCRIBE
¹ZAX
Ü	trans_real : REAL_LIT ­ Z_REAL
°
=ENDDOC
=DOC

=DESCRIBE
ÿExp_Real_Litüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ r : REAL_LIT ·
Ü	expr = real r ± zexpr = z_real (trans_real r)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsection{Translating Character Literals}
=DOC
val Ûexp_char_litÝ : CHAR_LIT -> Z_EXP
=DESCRIBE
¹ZAX
Ü	trans_char : CHAR_LIT ­ Z_STRING
°
ÿExp_Char_Litüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ c : CHAR_LIT; Z_Unary_Exp ·
Ü	expr = char c ± zop = z_char_lit ± zright = z_string(trans_char c) ±
Ü	zexpr = z_unary_exp (ÊZ_Unary_Exp)
ˆüüüüüüüüüüüüüüüüüü

{\it trans\_char} is the identity function in this implementation, and so
no ML is needed for it.
=ENDDOC


\subsection{Translating String Literals}
=DOC
val Ûexp_string_litÝ : CHAR_LIT -> Z_EXP

=DESCRIBE
¹ZAX
Ü	trans_string : STRING_LIT ­ Z_STRING
°
ÿExp_String_Litüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ s : STRING_LIT; Z_Unary_Exp ·
Ü	expr = string s ± zop = z_string_lit ± zright = z_string(trans_string s) ±
Ü	zexpr = z_unary_exp (ÊZ_Unary_Exp)
ˆüüüüüüüüüüüüüüüüüü
{\it trans\_string} is the identity function in this implementation, and so
no ML is needed for it.
=ENDDOC

\subsection{Translating Auxiliary Expressions}
=DOC
val Ûexp_auxiliary_expÝ : ZUserInterfaceSupport.Z_TM -> Z_EXP
=DESCRIBE
ÿExp_Auxiliary_Expüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ ze : Z_EXP ·
Ü	expr = auxiliary_exp ze ± zexpr = ze
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{The Function $trans\_exp$}\label{transexp}
=DOC
val Ûtrans_expÝ : CN_ENV -> EXP -> Z_EXP
val Ûtrans_exp1Ý : CN_ENV -> EXP -> Z_EXP OPT
=DESCRIBE
$trans\_exp$ translates a Compliance Notation (SPARK) expression into Z according to the algorithm specification in Volume 3 of DRA/CIS/CSE3/TR/94/27/3.0. following the Z specification below.

$trans\_exp1$ is just like $trans\_exp$ except that it returns an optional Z expression. If the SPARK expression can only be handled informally then a warning message is printed out and $Nil$ is returned.

¹Z
Ü	µ Exp_Pars ·
Ü	trans_exp expr = zexpr ¤
Ü		Exp_Id ² Exp_Int_Lit ² Exp_Array_Agg ²
Ü		Exp_Rec_Agg_Pos ² Exp_Rec_Agg_Named ² Exp_Unary_Exp ²
Ü		Exp_Bin_Exp ² Exp_Mem_Range ² Exp_Attrib ² Exp_Attrib_Arg ²
Ü		Exp_Indexed_Comp ² Exp_Selected_Comp ² Exp_Fun_Call ²
Ü		Exp_Qualified ² Exp_Type_Conv ² Exp_Auxiliary_Exp ²
Ü		Exp_Real_Lit ² Exp_Char_Lit ² Exp_String_Lit
°
=FAILURE
508020	This form of expression cannot be handled formally here
508032	Internal error: unexpected use of a qualified expression constructor
508050	?0
508052	Ranges are not handled formally here
508054	An aggregate that is not the operand of a qualified expression
	and is not a subaggregate cannot be handled formally  
=ENDDOC

\section{TRANSLATING SPARK BASIC DECLARATIONS}

The design in this section corresponds to the specification in section 6 of \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.


¹ZAX
Ü	trans_basic_decl : BASIC_DECL ­ seq Z_PARA
°

The following schema denotes the input and output parameters to basic declaration-handling functions.
ÿBasic_Decl_Parsüüüüüüüüüüüüüüüüü
Ü	basic_decl : BASIC_DECL;
Ü	z : seq Z_PARA
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Translating Constants}
=DOC
val Ûbasic_decl_constÝ : CN_ENV -> EXP CONST_DECL -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Const_1üüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Const_Decl ·
Ü	basic_decl = const_decl (Ê Const_Decl) ± expr  dom trans_exp ±
Ü	z = §z_eq_eq(trans_id const, trans_exp expr)¢
ˆüüüüüüüüüüüüüüüüüüüü
ÿBasic_Decl_Const_2üüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Const_Decl; Z_Ax; Z_Decl ·
Ü	basic_decl = const_decl (Ê Const_Decl) ± expr Ž dom trans_exp ±
Ü	zvar = trans_id const ± zexp = zid(trans_id tm) ±
Ü	decls = {ÊZ_Decl} ± preds = { } ± z = §z_ax(ÊZ_Ax)¢
ˆüüüüüüüüüüüüüüüüüüüü
Note: the implementation of these is via a single function which takes
the appropriate action according as $expr$ is or is not translatable.
I.e. $basic\_decl\_const$ implements the schema disjunction of the above two schemas (which is what is required where they are used in $trans\_basic\_decl$).

=ENDDOC

\subsection{Translating Enumeration Types}
=DOC
val Ûenum_attribÝ : CN_ENV -> (Z_ID * Z_ID * Z_ID)
			-> PARAINFO list
=DESCRIBE
The name $Z\_PARA$ is already used in {\ProductZ} for something else, but $PARAINFO$ of {\ProductZ} actually corresponds in semantics to DRA's use of $Z\_PARA$.

¹ZAX
Ü	enum_attrib : (Z_ID ¸ Z_ID ¸ Z_ID) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2, zid‰3 : Z_ID ·
Ü ¶ zexp : Z_EXP ·
Ü	zexp = z_set_minus(zid zid‰1, z_set {zid (zid‰1 ^ zlst)}) ±
Ü	enum_attrib (zid‰1, zid‰2, zid‰3) =
Ü		§z_eq_eq(zid‰1 ^ zfst, zid zid‰2),
Ü		z_eq_eq(zid‰1 ^ zlst, zid zid‰3),
Ü		z_eq_eq(zid‰1 ^ zsuc, z_dom_res(zexp, zsucc)),
Ü		z_eq_eq(zid‰1 ^ zpred, z_inv(zid (zid‰1 ^ zsuc))),
Ü		z_eq_eq(zid‰1 ^ zpos, z_id_rel (zid zid‰1)),
Ü		z_eq_eq(zid‰1 ^ zval, z_inv(zid(zid‰1 ^ zpos)))¢
°
=ENDDOC

=DOC
val Ûbasic_decl_enumÝ : CN_ENV -> ID -> ENUM_TYPE_DEF -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Enumüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü 	¶ Type_Decl; Enum_Type_Def; zname : Z_ID;
Ü	zvals : seq Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = enum_type_def (Ê Enum_Type_Def) ±
Ü	zname = trans_id name ± zvals = map trans_id vals ±
Ü	z =
Ü	{ i : dom vals · i í z_eq_eq(zvals i, z_num(i-1))} ë
Ü		§z_eq_eq(zname, z_rng(zid(head zvals), zid(last zvals)))¢ ë
Ü		enum_attrib(zname, head zvals, last zvals)
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Array Types}

=DOC
val Ûarray_attrib_auxÝ : CN_ENV -> Z_ID -> (Z_ID * int) -> PARAINFO list
val Ûarray_attribÝ : CN_ENV -> (Z_ID * Z_ID list) -> PARAINFO list
=DESCRIBE
¹ZAX
Ü	array_attrib_aux : (Z_ID ¸ Z_ID ¸ î) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2 : Z_ID; i : î ·
Ü	array_attrib_aux (zid‰1, zid‰2, i) =
Ü		§z_eq_eq(dimen(zid‰1 ^ zfst, i), zid (zid‰2 ^ zfst)),
Ü		z_eq_eq(dimen(zid‰1 ^ zlst, i), zid (zid‰2 ^ zlst)),
Ü		z_eq_eq(dimen(zid‰1 ^ zlength, i), z_size (zid zid‰2)),
Ü		z_eq_eq(dimen(zid‰1 ^ zrange, i), zid zid‰2)¢
°

¹ZAX
Ü	array_attrib : (Z_ID ¸ seq‰1 Z_ID) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid : Z_ID; zids : seq‰1 Z_ID ·
Ü	array_attrib (zid, zids) =
Ü		array_attrib_aux(zid, head zids, 0) ë
Ü		‹(Ìi : dom zids· array_attrib_aux(zid, zids i, i)) 
°
{\it array\_attrib\_aux} is curried in ML to make the coding of
{\it array\_attrib} simpler.
=FAILURE
508035	Internal error: parser has generated a 0-dimensional array ?0
=ENDDOC

\newpage

=DOC
val Ûbasic_decl_con_arrayÝ : CN_ENV -> ID -> ARRAY_DEF -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Con_Arrayüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Array_Def; zname, zcomp : Z_ID; zindex : seq‰1 Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = con_array_def (Ê Array_Def) ±
Ü	zname = trans_id name ± zindex = map trans_id index ±
Ü	zcomp = trans_id comp ±
Ü	z =
Ü	§z_eq_eq (zname, z_tfun(z_many_cross(map zid zindex), zid zcomp))¢ ë
Ü		array_attrib(zname, zindex)
ˆüüüüüüüüüüüüüüüüüüüü

=ENDDOC

=DOC
val Ûbasic_decl_uncon_arrayÝ : CN_ENV -> ID -> ARRAY_DEF -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Uncon_Arrayüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Array_Def; Z_Ax; Z_Decl;
Ü		zname, zcomp : Z_ID; zindex : Z_EXP·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = uncon_array_def (Ê Array_Def) ±
Ü	zname = trans_id name ±
Ü	zindex = z_many_cross(map (zid o trans_id) index) ±
Ü	zcomp = trans_id comp ± zvar = zname ±
Ü	zexp = z_powerset(z_pfun(zindex, zid zcomp)) ±
Ü	decls ={ÊZ_Decl} ± preds = { } ± z= §z_ax(Ê(Z_Ax))¢
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Record Types}
=DOC
val Ûtrans_declÝ : CN_ENV -> VAR_DECL -> Z_DECL
val Ûrecord_update_defsÝ : (Z_ID * Z_ID list list) -> PARAINFO
=DESCRIBE
¹ZAX
Ü	trans_decl : Var_Decl ­ Z_Decl
÷üüüüüüüüüüüüü
Ü µ Var_Decl; Z_Decl ·
Ü	trans_decl (Ê Var_Decl) = Ê Z_Decl ¤
Ü		zvar = trans_id var ± zexp = zid (trans_id tmark)
Ü		
°
¹ZAX
Ü record_update_defs : ID ¸ Record_Type_Def ­ seq Z_PARA
°
The {\Product} implementation uses {\it Z\_ID}s to save multiple calls of {\it trans\_id}
and returns a single paragraph, because that is all that is needed.
=ENDDOC

=DOC
val Ûbasic_decl_recordÝ : CN_ENV -> ID
	-> RECORD_TYPE_DEF -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Recordüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü	¶ Type_Decl; rec : Record_Type_Def; Z_Schema ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = record_type_def rec ± z_sname = trans_id name ±
Ü	z_decls = trans_decl ¨ ran rec.decl © ±
Ü	z = §z_schema (Ê Z_Schema)¢ ë record_update_defs (name, rec)
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Integer Types}

=DOC
val Ûint_type_attribÝ : CN_ENV -> (Z_ID * EXP RANGE) -> PARAINFO list
=DESCRIBE
¹ZAX
Ü	z_ints : Z_ID
°
¹ZAX
Ü	int_type_attrib : (Z_ID ¸ Range) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü	µ zid‰1 : Z_ID; Range ·
Ü	¶ Z_Ax'; Z_Ax''; Z_Ax'''; Z_Ax'''' ·
Ü		decls' = {Z_Decl | zvar = zid‰1 ^ zsuc ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	decls'' = {Z_Decl | zvar = zid‰1 ^ zpred ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	decls''' = {Z_Decl | zvar = zid‰1 ^ zpos ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	decls'''' = {Z_Decl | zvar = zid‰1 ^ zval ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	(preds' = preds'' = preds''' = preds'''')
Ü	±	int_type_attrib (zid‰1, Ê Range) =
Ü			§z_eq_eq(zid‰1 ^ zfst, trans_exp lo),
Ü			z_eq_eq(zid‰1 ^ zlst, trans_exp hi),
Ü			z_ax(ÊZ_Ax'), z_ax(ÊZ_Ax''),
Ü			z_ax(ÊZ_Ax'''), z_ax(ÊZ_Ax'''') ¢
°
=ENDDOC

=DOC
val Ûbasic_decl_int_typeÝ : CN_ENV -> ID -> EXP RANGE -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Int_Typeüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Range; zname : Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = int_type_def (Ê Range) ±
Ü	zname = trans_id name ±
Ü	z =
Ü	§z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi))¢ ë
Ü		int_type_attrib(zname, Ê Range)
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Real Types}
=DOC
val Ûbasic_decl_real_typeÝ : ID -> PARAINFO list
=DESCRIBE
ÿ Basic_Decl_Real_Type üüüüüüüüüüü
Ü Basic_Decl_Pars
÷üüüüüü
Ü ¶ Type_Decl; zname : Z_ID ·
Ü	basic_decl = type_decl(ÊType_Decl) ± type_def = real_type_def ±
Ü	zname = trans_id name ± z = §z_given zname¢
ˆüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Subtypes}

=DOC
val Ûrange_con_attribÝ : CN_ENV -> (Z_ID * Z_ID * EXP RANGELOHI)
				-> PARAINFO list
=DESCRIBE
¹ZAX
Ü	range_con_attrib : (Z_ID ¸ Z_ID ¸ Range) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2 : Z_ID; Range ·
Ü	range_con_attrib (zid‰1, zid‰2, Ê Range) =
Ü		§z_eq_eq(zid‰1 ^ zfst, trans_exp lo),
Ü		z_eq_eq(zid‰1 ^ zlst, trans_exp hi),
Ü		z_eq_eq(zid‰1 ^ zsuc, zid(zid‰2 ^ zsuc)),
Ü		z_eq_eq(zid‰1 ^ zpred, zid(zid‰2 ^ zpred)),
Ü		z_eq_eq(zid‰1 ^ zpos, zid (zid‰2 ^ zpos)),
Ü		z_eq_eq(zid‰1 ^ zval, zid(zid‰2 ^ zval))¢
°
=ENDDOC

=DOC
val Ûbasic_decl_subtype_range_conÝ : CN_ENV -> ID
	-> TMARK -> EXP RANGE -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Subtype_Range_Con_1üüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Range; zname, ztmark : Z_ID ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = range_con (Ê Range) ±
Ü	z_type_of(zid ztmark) = z_power_type z_int_type ±
Ü	lo  dom trans_exp ± hi  dom trans_exp ±
Ü	zname = trans_id name ±
Ü	ztmark = trans_id tmark ±
Ü	z =
Ü	§z_eq_eq (zname, z_rng (trans_exp lo, trans_exp hi)) ¢ ë
Ü		range_con_attrib(zname, ztmark, Ê Range)
ˆüüüüüüüüüüüüüüüüüüüü
ÿBasic_Decl_Subtype_Range_Con_2üüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Range; zname, ztmark : Z_ID; Z_Ax; Z_Decl ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = range_con (Ê Range) ±
Ü	(z_type_of(zid ztmark) ½ z_power_type z_int_type ²
Ü	lo Ž dom trans_exp ² hi Ž dom trans_exp) ±
Ü	zname = trans_id name ± ztmark = trans_id tmark ± zvar = zname ±
Ü	zexp = z_powerset(zid ztmark) ± decls = {ÊZ_Decl} ±
Ü	preds = {} ± z = §z_ax(ÊZ_Ax)¢
ˆüüüüüüüüüüüüüüüüüüüü
Note: the implementation of these is via a single function which takes
the appropriate action according to the number of indices.
I.e. $basic\_decl\_subtype\_range_con$ implements the schema disjunction of the above two schemas (which is what is required where they are used in $trans\_basic\_decl$).
=FAILURE
508051	?0 is not a valid type mark
508060	The range constraint would give an empty type:
	the lower bound ?0 is greater than the upper bound ?1
508061	The range constraint for the type ?0 could not be evaluated;
	a VC has been generated for this type
=ENDDOC
=DOC
val Ûbasic_decl_subtype_floating_fixed_conÝ : CN_ENV -> ID
	-> TMARK -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Subtype_Floating_Fixed_Conüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Range[EXP]; zname, ztmark : Z_ID; Z_Ax; Z_Decl ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	(con = floating_con ² con = fixed_con) ± zname = trans_id name ±
Ü	ztmark = trans_id tmark ± zvar = zname ±
Ü	zexp = z_powerset(zid ztmark) ± decls = {ÊZ_Decl} ±
Ü	preds = {} ± z = §z_ax(ÊZ_Ax)¢
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûbasic_decl_subtype_index_conÝ : CN_ENV -> ID
	-> TMARK -> EXP list -> PARAINFO list
=DESCRIBE
ÿBasic_Decl_Subtype_Index_Conüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü	¶ Subtype_Decl; index : seq TMARK; Z_Decl;
Ü	zname : Z_ID; zindex : seq‰1 Z_ID; zp : Z_PRED ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = index_con index ± zname = trans_id name ±
Ü	zindex = map trans_id index ±
Ü	zexp = zid (trans_id tmark) ±
Ü	zp = z_eq (z_dom (zid zvar), z_many_cross(map zid zindex)) ±
Ü	z =
Ü	§z_eq_eq (zname, z_set_comp (Ê Z_Decl, zp)) ¢ ë
Ü		array_attrib(zname, zindex)
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
508075	A subtype of STRING must have a lower index bound of 1; the lower bound
	for the subtype ?0 is not equal to 1
508076	The lower index bound for the type ?0 could not be evaluated;
	a VC has been generated for this type
=ENDDOC
=DOC
val Ûbase_typeÝ : Z_EXP -> TMARK OPT
=DESCRIBE
Given an Ada type mark, {\it tm}, translated into a Z expression,
{\it base\_type tm} is the Z type for the base type of {\it tm}, if any.
The returned value is {\it Nil} for Ada integer and real types (since
these are subtyped from compiler-dependent pre-defined types) or if
for some reason the base type cannot be determined.
Ada enumeration types and their subtypes are represented in Z as integer types, but
{\it base\_type} can distinguish them from Ada integer types by checking on
the form of the definition of the successor attribute (which will not have
a defining equation for an Ada integer type).


This function is used to to determine whether an Ada type is subtyped from the unconstrained
array type {\it STRING}, in which case any subtype must have an index
range with lower bound equal to 1.
It is also used in the implementation of attributes containing {\it 'BASE}.

=DOC
=DOC
val Ûbasic_decl_subtype_no_conÝ : CN_ENV -> ID
	-> TMARK -> PARAINFO list;
val Ûada_attributes_listÝ : ID list;
val Ûtype_attrsÝ : ID -> ID list;
=DESCRIBE
$ada\_attributes\_list$ is based on material taken from the Ada Reference Manual.
It is based on all Ada attributes, not just those mentioned in the list in
Volume 3, section 3.13 of the specification of the Compliance Notation.
However, it does not list attributes of attributes, such as attributes of the $BASE$ attribute.

$type\_attrs$ $t$ then returns all the members of this list who are used to form
constants that are attributes of type $t$ in the theory in which $t$ is declared.
This may miss attribute names covered by the broader description of $type\_attrs$ in the specification.

¹ZAX
Ü type_attrs : ID ­ seq ID
°

ÿ Basic_Decl_Subtype_No_Con üüüüüüüüüüü
Ü Basic_Decl_Pars
÷üüüüüü
Ü ¶Subtype_Decl; zname, ztmark : Z_ID ·
Ü   con = no_con ± zname = trans_id name ± ztmark = trans_id tmark ±
Ü   z = §z_eq_eq(zname, zid ztmark)¢ ë
Ü   (type_attrs tmark » trans_id » (Ìa: Z_ID·(z_eq_eq(zname ^ a, zid(ztmark ^ a)))))
ˆüüüüüüüüüüüüüü
=ENDDOC

\subsection{The Function $trans\_basic\_decl$}
=DOC
val Ûtrans_basic_declÝ : CN_ENV -> BASIC_DECL -> PARAINFO list
val Ûtrans_basic_decl1Ý : CN_ENV -> BASIC_DECL -> PARAINFO list OPT
=DESCRIBE

$trans\_basic\_decl$ takes a basic declaration in Compliance Notation (SPARK) and translates it into Z according to the algorithm specified in Volume 3 of DRA/CIS/CSE3/TR/94/27/3.0, and follows the Z specification below.
 
$trans\_basic\_decl1$ is similar to $trans\_basic\_decl$ except that it returns an optional Z list of Z paragraphs. If the SPARK basic declaration can only be handled informally then a warning message is printed out and $Nil$ is returned.

¹Z
Ü µ Basic_Decl_Pars ·
Ü	trans_basic_decl basic_decl = z ¤
Ü		Basic_Decl_Const_1 ² Basic_Decl_Const_2 ² Basic_Decl_Enum ²
Ü		Basic_Decl_Int_Type ² Basic_Decl_Con_Array ²
Ü		Basic_Decl_Con_Array ² Basic_Decl_Uncon_Array ² Basic_Decl_Record ²
Ü		Basic_Decl_Real_Type ² Basic_Decl_Subtype_Range_Con_1 ²
Ü		Basic_Decl_Subtype_Range_Con_2 ² Basic_Decl_Subtype_Floating_Fixed_Con ²
Ü		Basic_Decl_Subtype_Index_Con ²
Ü		Basic_Decl_Subtype_No_Con
°
=FAILURE
508039	Deferred constants are not handled formally
508040	Internal error: unexpected variable declaration
508041	Private types are not handled formally
=ENDDOC
\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}

During parsing, there were several cases where it was not possible to determine the actual abstract syntax which should be generated because of the lack of contextual information at the time of parsing. The design of this module is such that all the information needed to adjust the abstract syntax for expressions can be derived from the environment information in $CN\_ENV$. The function $adjust\_exp$ is provided to carry out those adjustments to expressions which the parser produced so that the abstract syntax is correct by the time the algorithms for generating Z from expressions, (and ultimately VCs) are invoked.


The function carries out the following adjustments to expressions:

\begin{description}

\item[Identifiers]
An identifier of the form $x.y$ can either be a package selection or a record selection. Which kind of selection is determined by the kind of object $x$ is. It is necessary to distinguish between the two because the names of the identifiers translated into Z by the expression generator would be different. In the example, where $x$ is in scope as a record, then $x.y$ is treated as a record selection; otherwise is is assumed to be a package selection.

\item[Aggregates]
The parser represents record aggregates as array aggregates (this is the case both for positional and named aggregates). $adjust\_exp$ determines whether to convert an array aggregate into a record aggregate by checking whether a record aggregate with the corresponding name to the array aggregate has been declared and is in scope. If so, the adjustment is made.

\item[Indexed Components]
Function calls and type constraints are represented as indexed components by the parser. An indexed component is converted to a type constraint or a function by $adjust\_exp$ depending the functions and types which are in scope at the time. 

\item[Qualified Expressions]
In SPARK record aggregates have to appear within qualified expressions.
Thus, the representation of aggregates contains a component which is the type mark of the aggregate. A qualified expression representation contains an aggregate part and a type mark part. Since the algorithms for generating Z assume that aggregates have associated with them the correct type mark, it is necessary in the case of a qualified expression to push its type mark into the appropriate type mark component of the aggregate and throw away the qualified expression data constructor. Since the aggregate part of a qualified expression may be either a record or an array, it is itself subject to possible adjustment for aggregates (see above). Thus, a qualified expression can be changed by $adjust\_exp$ into any one of the types of array aggregate or record aggregate.

During the analysis of the various forms of operand of the qualified expression to handle record aggregates, the form where the operand is not an aggregate is handled simply by replacing the qualified expression by the operand.
This implements the formal treatment of qualified expressions as defined by the Z schema $Exp\_Qualified$. 
\end{description}


=DOC
val Ûnamed_assocs_to_expsÝ : ID list ->
	(AGG_CHOICE,EXP) NAMED_ASSOC list -> EXP list
=DESCRIBE
This function converts a named association list into an expression list based upon knowledge of names of the components of a function/record for which the named association list is the parameter.
=USES
It is required by $adjust\_exp$ see below.
=FAILURE
508043	There are missing or duplicate parameters in the function call
508044	?0 is not a valid parameter in the procedure/function call
508045	Syntax error: a range is not allowed to denote parameters of a function call
=ENDDOC

=DOC
val Ûadjust_expÝ : CN_ENV -> EXP -> EXP
val Ûadjust_exp1Ý : CN_ENV -> EXP -> EXP OPT
=DESCRIBE
$adjust\_exp$ transforms an expression into its correct representation, determined by information in the environment. For example, array aggregates are used by the parser to carry both function applications and arrays indexed by positional aggregates. This function determines from the environment whether the object is a function application or an indexed component and applies the appropriate transformation to the abstract expression.

$adjust\_exp1$ is similar to $adjust\_exp$ but it returns $Nil$ if the expression cannot be handled formally; otherwise it returns a value which is the same as that had $adjust\_exp$ been called.
=FAILURE
508048	Internal error: badly formed indexed component found near ?0
508035	Internal error: parser has generated a 0-dimensional array ?0
508055	Internal error: parser has generated a qualified expression as an index for ?0
508056	Internal error: the expression adjuster has generated an ill-formed indexed selection
508042	Internal error: badly formed qualified expression
508046	Syntax error: OTHERS part is not allowed in a record aggregate
508047	Syntax error: cannot index ?0 using a named association
508049	Informal functions cannot be handled formally; ?0 cannot be used here
=ENDDOC
=TEX
\section{Support for Multidimensional Arrays}
=DOC
val Ûarray_agg_defÝ : int -> unit
=DESCRIBE
=FAILURE
508059	the argument to array_agg_def must be at least 2
=ENDDOC

\section{EPILOGUE}

=SML
end (* local...in *);
end (* signature CNBasicDeclsAndExprs *);
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
