=IGN
********************************************************************************
dtd508.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% dtd508.doc %Z% $Date: 2008/07/24 12:12:34 $ $Revision: 1.120 $ $RCSfile: dtd508.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}	%% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Declaration and Expression Generator} %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD508}	%% Mandatory field
\def\SCCSversion{$Revision: 1.120 $%
}
\TPPissue{\SCCSversion}	%% Mandatory field
\TPPdate{\FormatDate{$Date: 2008/07/24 12:12:34 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This is the detailed design for the Declaration and Expression Generator as specified in volume 3 of DRA/CIS/CSE3/TR/94/27/3.0.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}		% to get section number `0.3'
\begin{description}
\item[Issue 1.1 (1994/03/29)-1.12 (1994/06/06)] Initial Drafts.
\item[Issue 1.13 (1994/06/16) (9th June 1994)] First draft for review.
\item[Issue 1.14 (1994/06/20)-1.16 (1994/06/20)] Bug fixing.
\item[Issues 1.17 (1994/07/14),1.18 (1994/08/03) (14th July 1994)] Minor typographical corrections.
\item[Issue 1.19 (1994/09/26) (22nd Sept 1994)] Changed according to desk check report 008.
\item[Issue 1.23 (1994/10/31) (31 October 1994)] Added $z\_true$ and $z\_exists$ as per version 1.1 of Volume 3 of DRA's specification.
\item[Issue 1.24 (1994/11/03) (9th November 1994)]
Adjusted $ENV\_INFO$ and allowed for type conversions.
\item[Issues 1.25 (1994/11/09)-1.26 (1994/11/25)] Bug fixing.
\item[Issue 1.27 (1994/12/01)] Updated document references.
\item[Issue 1.28 (1995/10/13)] Updated the Z for DRA enhancements 13 and 14.
\item[Issue 1.29 (1995/10/17)] Enhancment 11.
\item[Issue 1.30 (1995/10/19)] Enhancements 13 and 14.
\item[Issue 1.31 (1995/10/25)] Enhancement 15.
\item[Issues 1.32 (1995/11/23)-1.35 (1995/11/28)] Enhancements to translation of basic declarations
(enhancements number, 2, 3, 8).
\item[Issues 1.36 (1995/11/29)-1.37 (1995/12/01)] Enhancements 3 and 18.
\item[Issue 1.38 (1995/12/14) (14th December 1995)] Changes according to desk check report 024.
\item [Issue 1.39 (1996/02/12)] Improved error reporting.
\item[Issue 1.40 (1997/05/29)] IUCT WP 7 changes.
\item[Issue 1.41 (1997/07/18)] IUCT WP 4 changes.
\item[Issue 1.42 (1997/07/29)] Corrected Z syntax and type errors.
\item[Issue 1.43 (1997/07/31)] Improved some error messages.
\item[Issue 1.44 (1997/08/18)] Updated references.
\item[Issue 1.45 (1999/02/25),1.46 (1999/02/26)] Update for SML97. Fixed broken error message.
\item[Issue 1.47 (1999/03/07)] Update for new INTEGER type.
\item[Issue 1.48 (2000/05/23)] Trial of enhancements from \cite{LEMMA1/DAZ/HLD506}.
\item[Issue 1.49 (2000/05/31),1.50 (2000/06/01)] Typechecking new approach to enhancement R3 --- Assignment to Record Components.
\item[Issue 1.51 (2000/06/16)] Enhancement R2 --- Multiple Logical Constants.
\item[Issues 1.52 (2000/06/16)-1.54 (2000/06/20)] Enhancement R1 --- Multidimensional Arrays.
\item[Issue 1.55 (2000/10/17)] CTLE II R1/2 --- ``Others'' in case statements.
\item[Issue 1.55 (2000/10/17)] CTLE II R1/2 --- ``Others'' in case statements.
\item[Issue 1.56 (2000/10/18)] CTLE II R1/4 --- logical operators on arrays
of booleans, including overloading, and some parts of R1/1 (reals) and R1/8 (characters and strings).
\item[Issue 1.57 (2000/10/18),1.58 (2000/10/19)] CTLE II R1/8 --- characters and strings.
\item[Issue 1.59 (2000/10/20)] CTLE II R1/5 --- range attributes as ranges.
\item[Issue 1.60 (2000/10/24)] CTLE II R1/9 --- SPARK 83 attributes.
\item[Issue 1.61 (2000/10/26)] CTLE II R1/11 --- nested packages.
\item[Issues 1.62 (2000/10/29),1.63 (2000/10/30)] CTLE II R1/11 --- real types.
\item[Issue 1.64 (2000/12/21)] Fixed omission in spec of {\it Exp\_Type\_Conv}.
\item[Issue 1.65 (2001/09/15)] Fixed {\LaTeX} errors.
\item[Issue 1.66 (2001/11/07)] Fixed incorrect description of {\it CN\_ENV}.
\item[Issue 1.67 (2001/11/08)] Improved error message 508081
\item[Issue 1.68 (2001/11/08)] R0021: new treatment of AND THEN and OR ELSE.
\item[Issue 1.69 (2001/11/09), 1.70 (2001/11/10)] R0021: domain condition generation.
\item[Issue 1.71 (2001/12/12)] Removed local declarations for Poly/ML port.
\item[Issues 1.72 (2001/12/15), 1.73 (2001/12/16)] R0037: support for named numbers.
\item[Issue 1.74 (2002/01/14)] Index brackets added.
\item[Issue 1.75 (2002/01/24)] R0006: spec updates.
\item[Issue 1.76 (2002/01/25),1.77 (2002/01/26)] R0006: code added.
\item[Issue 1.78 (2002/01/29)] R0044: checks on array ranges.
\item[Issue 1.79 (2002/01/30)] Fixed {\LaTeX} errors.
\item[Issue 1.80 (2002/02/14)] Fixed missing index brackets.
\item[Issue 1.80 (2002/02/14)] Fixing {\LaTeX} problems for SPC503.
\item[Issue 1.81 (2002/02/15)] New error message for error in array aggregates.
\item[Issue 1.81 (2002/02/15)] Fixed misleading (but probably impossible) error message.
\item[Issue 1.82 (2002/02/18)-1.84 (2002/05/02)] Spring 2002 enhancements: accommodating new syntax for interim release.
\item[Issue 1.85 (2002/05/03), 1.86 (2002/05/04)]  New functionality for discriminants.
\item[Issue 1.87 (2002/05/07). 1.88 (2002/05/08)] Renaming
\item[Issue 1.89 (2002/05/14), 1.90 (2002/05/17)] Spec updates for interim release.
\item[Issue 1.91 (2002/05/25)] Removed redundant error message.
\item[Issue 1.92 (2002/05/30)] Fixed {\LaTeX} errors.
\item[Issue 1.93 (2002/07/09)] R0078: ada constant declarations now translated into axiomatic descriptions (which
introduces a new error case when the type mark is not compatible with the expression).
\item[Issue 1.94 (2002/07/15)] Moved {\it init\_var} here from DTD505 to give a bit more commonality.
\item[Issue 1.95 (2002/08/08)] R0051: default parameters.
\item[Issue 1.96 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.97 (2002/10/17)] DAZ-specific updates to banner for open source release
\item[Issue 1.98 (2002/10/17)] DAZ-specific updates to banner for open source release
\item[Issue 1.99 (2002/11/25)] Schemas-as-declarations now catered for in output Z syntax.
\item[Issue 1.100 (2002/12/05)] Spec and signature changes for schema references in function $\Xi$-lists.
\item[Issue 1.101 (2003/02/06)] Updates to the Z specs after GMP's preliminary review.
\item[Issue 1.102 (2003/02/18)] Fixed {\LaTeX} error.
\item[Issues 1.103 (2004/06/20)-1.104 (2004/06/21)] Reform of the Environments.
\item[Issue 1.105 (2005/07/26)] New error message for use in translating function calls.
\item[Issue 1.106 (2005/07/29)] Added interface so the VC generator can find out whether we are generating domain conditions.
\item[Issue 1.107 (2005/09/08)] Allowed for new scheme for type names in Z.
\item[Issue 1.108 (2005/09/14),1.109 (2005/09/15)] Added new error message.
\item[Issue 1.110 (2005/12/07)] Aggregates inside aggregates no longer need to be in qualified expressions.
\item[Issue 1.111 (2006/01/16)] Use of term ``in scope'' in error messages is now consistent with other modules.
\item[Issue 1.112 (2006/03/17)] First clean compile for enhancement 117.
\item[Issue 1.113 (2006/03/24)] More adjustments for enhancement 117.
\item[Issue 1.114 (2006/04/11)] Under enhancement 117, checks on use of names in Z are now given a uniform treatment.
\item[Issue 1.115 (2006/04/20)] Ada real literals are now translated into Z floating point literals.
\item[Issue 1.116 (2006/05/04)] Improved error messages for numeric literals.
\item[Issues 1.117 (2006/06/12),1.118 (2008/03/23)] Child packages.
\item[Issue 1.119 (2008/05/05)] Modular types.
\item[Issue 1.120 (2008/07/24)] Support for modular types temporarily withdrawn.
\item[Issue 1.121 (2010/02/11)] Removed obsolete CUTDOWNVERSION option.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

%%%% END OF CHANGES HISTORY %%%%
\end{description}

\subsection{Changes Forecast}

None.

\section{GENERAL}

\subsection{Scope}
This document contains the detailed design for the Basic Declaration and Expression Generator. The design is in response to the high level design for compliance notation processing \cite{ISS/HAT/DAZ/HLD503}.

The document provides a design which implements DRA's specification for Basic Declaration and Expression Generation described in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.
Specifically, the implementation corresponds to the specification in sections 5 and 6 of \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

Free type definitions in the specification of the Abstract Syntax for Z in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0} are implemented as functions corresponding to the type constructors of the type definitions. The design of these is covered by this document.

\subsection{Introduction}

\subsubsection{Purpose and Background}
The declaration and expression generator is called by the VC generator \cite{ISS/HAT/DAZ/IMP505} and the Z document generator \cite{ISS/HAT/DAZ/IMP507} to translate SPARK basic declarations and expressions into Z according to the algorithms specified in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

The Z of \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0} is reproduced in this document (suitable for type-checking with {\Product}) adjacent to the signature declarations of the functions which implement the Z. The corresponding implementatation is in \cite{ISS/HAT/DAZ/IMP508}.

\subsection{Compliance}

This detailed design contains signatures for Standard ML functions with the Z specification of these functions, transcribed from \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}. The names of these functions corresponds to the names used in the Z, and where they differ, justification has been provided.

The implementation of this design can be found in \cite{ISS/HAT/DAZ/IMP508} where the style of coding is intended to make the compliance with the Z specification evident by a visual comparison.

%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}

\section{PREAMBLE}
The following literate script is used for type checking the Z in this document with {\Product}. It is not processed when building the Compliance Tool.

=SMLZ
open_theory"dtd502";
push_pc "z_library";
force_delete_theory"dtd508" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory "dtd508";
=TEX

\section{THE SIGNATURE $CNBasicDeclsAndExprs$}
=DOC
signature ÛCNBasicDeclsAndExprsİ = sig
=DESCRIBE
This is the signature for the Basic Declaration and Expression Generator.
=ENDDOC
It would be much nicer if the following signature inclusion could
be replaced by a local declaration of the corresponding structure
but that is not supported in strict SML '97.
=SML
include CNTypes;
=TEX
\section{SUPPORT FOR Z ABSTRACT SYNTAX}

\subsection{Z Unary Expressions}

=DOC
val Ûz_unary_minusİ : Z_EXP
val Ûz_bool_notİ : Z_EXP
val Ûz_absİ : Z_EXP
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for unary expressions in ISS/HAT/DAZ/DTD502.}
=ENDDOC

\subsection{Z Binary Expressions}

=DOC
val Ûz_bool_andİ : Z_EXP
val Ûz_bool_orİ : Z_EXP
val Ûz_bool_xorİ : Z_EXP
val Ûz_bool_eqİ : Z_EXP
val Ûz_bool_noteqİ : Z_EXP
val Ûz_bool_lessİ : Z_EXP
val Ûz_bool_less_eqİ : Z_EXP
val Ûz_bool_greaterİ : Z_EXP
val Ûz_bool_greater_eqİ : Z_EXP
val Ûz_addİ : Z_EXP
val Ûz_minusİ : Z_EXP
val Ûz_timesİ : Z_EXP
val Ûz_intdivİ : Z_EXP
val Ûz_modİ : Z_EXP
val Ûz_remİ : Z_EXP
val Ûz_exponİ : Z_EXP
val Ûz_bool_memİ : Z_EXP
val Ûz_bool_notmemİ : Z_EXP
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for binary expressions in ISS/HAT/DAZ/DTD502.}
=ENDDOC

\subsection{Z Expressions}
=DOC
val Ûz_succİ : Z_EXP
val Ûzidİ : CN_ENV -> Z_ID -> Z_EXP
val Ûz_numİ : INTEGER -> Z_EXP
val Ûz_stringİ : string -> Z_EXP
val Ûz_tfunİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_pfunİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_rngİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_domİ : Z_EXP -> Z_EXP
val Ûz_dom_resİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_invİ : Z_EXP -> Z_EXP
val Ûz_id_relİ : Z_EXP -> Z_EXP
val Ûz_sizeİ : Z_EXP -> Z_EXP
val Ûz_setİ : Z_EXP list -> Z_EXP
val Ûz_set_minusİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_set_compİ : (Z_DECL * Z_EXP) -> Z_EXP
val Ûz_powerİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_rel_compİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_seqİ : Z_EXP list -> Z_EXP
val Ûz_crossİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_many_crossİ : (Z_EXP list) -> Z_EXP
val Ûz_overrideİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_many_unionİ : Z_EXP list -> Z_EXP
val Ûz_unary_expİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_bin_expİ : (Z_EXP * Z_EXP * Z_EXP) -> Z_EXP
val Ûz_fun_callİ : (Z_EXP * Z_EXP list) -> Z_EXP
val Ûz_selectionİ : (Z_EXP * Z_ID) -> Z_EXP
val Ûz_mapletİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_powersetİ : Z_EXP -> Z_EXP
val Ûz_bindingİ : (string * Z_EXP) list -> Z_EXP
val Ûz_tupleİ : Z_EXP list -> Z_EXP
val Ûother_z_expİ : Z_EXP -> Z_EXP
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for expressions in ISS/HAT/DAZ/DTD502,
with one exception, namely {\it z\_rng}:}
¹ZAX
Ü Ûz_rngİ : Z_EXP ¸ Z_EXP ­ Z_EXP
°

=ENDDOC

\subsection{Z Predicates}

=DOC
val Ûz_trueİ : Z_PRED
val Ûz_eqİ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_andİ : (Z_PRED * Z_PRED) -> Z_PRED
val Ûz_many_andİ : Z_PRED list -> Z_PRED
val Ûz_elemİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_notelemİ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_noteqİ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_less_eqİ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_greaterİ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_forallİ : (Z_DECL list * Z_PRED) -> Z_PRED
val Ûz_existsİ : (Z_DECL list * Z_PRED) -> Z_PRED
val Ûz_impİ : (Z_PRED * Z_PRED) -> Z_PRED
val Ûz_memİ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûother_z_predİ : Z_PRED -> Z_PRED
=DESCRIBE
\raggedright{This corresponds to  the abstract syntax of Z for predicates in ISS/HAT/DAZ/DTD502.}
=ENDDOC
=DOC
val Ûz_predexp_of_z_tmİ :
		CN_ENV ->
		ZUserInterfaceSupport.Z_TM -> Z_PRED;
val Ûinit_varİ : Z_ID -> Z_ID;
val Ûz_free_var_reportİ : int -> TERM OPT -> string list -> unit;
=DESCRIBE
The function $z\_predexp\_of\_z\_tm$ type-checks a parsed Z term and generates the corresponding term. This can be either a $Z\_PRED$ or an $Z\_EXP$ which in fact are aliases for $TERM$.
The first argument gives a compliance notation environment used to construct error messages.

$init\_var$ decorates a string with a subscript 0 as used to indicate an initial variable
in a post-condition.

In the following, 508012 is a fallback error message that should not occur in normal operation.
$z\_free\_var\_report$ produces an error message following the same format as $z\_predexp\_of\_z\_tm$ using the specified error number as the fallback.

=FAILURE
508010	Z variables used in the Compliance Notation must be
	in scope. The following variable?0 ?1 not in scope:
508011	Ada names in Z expressions must be given in canonical
	form. The following name?0 ?1 not in canonical form:
508012	The Z term contained the following name?0 that ?1
	not allowed here:
508018	The Z term ?0 is not valid here because
508019	Illegal Z term
=ENDDOC
=DOC
val Ûz_tm_trueİ : ZUserInterfaceSupport.Z_TM;
=DESCRIBE
The value $z\_tm\_true$ is a value true represented as a $Z\_TM$.
=ENDDOC
=DOC
val Ûname_to_tmarkİ : EXP -> TMARK;
=DESCRIBE
This function converts an expression in compliance notation (identical to a SPARK expression) to a type mark. Only valid identifiers result in a valid type mark.
otherwise the type-mark ``\_\_invalid'' is generated.
=ENDDOC
=DOC
val Ûexp_to_discrete_rangeİ : EXP -> SI_DISCRETE_RANGE;
=DESCRIBE
This function converts an Ada expression (represented in the abstract syntax output by
the parser) to a discrete range.
=FAILURE
508091	Missing TYPE MARK
=ENDDOC
=DOC
 val Ûis_range_attributeİ : EXP -> bool
=DESCRIBE
This function tests whether an expression is a range attribute.
=ENDDOC
\subsection{Z Paragraphs}

=DOC
val Ûz_eq_eqİ : string -> (Z_ID * Z_EXP) -> ZParagraphs.PARAINFO
val Ûz_axİ : string -> (Z_ID * Z_EXP * Z_PRED list) -> ZParagraphs.PARAINFO
val Ûz_schemaİ : (Z_ID * Z_DECL list * Z_PRED) -> ZParagraphs.PARAINFO
val Ûz_constrained_schemaİ : (Z_ID * Z_EXP * Z_PRED) -> ZParagraphs.PARAINFO
=DESCRIBE
\raggedright{This corresponds to the abstract syntax of Z for some of the Z paragraphs in ISS/HAT/DAZ/DTD502.}
The first parameter of each function names the kind (constant, type or subtype)
of declaration being processed and is used to fill in ?0
in the following error message:
=FAILURE
508106	The expressions in ?0 declarations must be static and static
	expressions must not contain variables.
	This declaration contains the variable?2 ?1
=ENDDOC

\subsection{Failure Messages}
The following error messages can be reported by the functions which support the Z abstract syntax.

=FAILURE
508021	The variable ?0 is not in scope in the Ada program
	and is not declared as an auxiliary variable or
	logical constant
508023	Internal error: ?0 is a badly formed Z declaration
508024	Internal error: The expression list argument must not be empty
508077	The variable ?0 is in scope in the Ada program
	but cannot be used here because it has not been
	listed in the frame or global dependency list of the
	containing subprogram
508078	The environment entry for ?0 is corrupt (no type information)
=TEX

\section{TRANSLATING SPARK EXPRESSIONS}

The following corresponds to the specification in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.

The signature for $trans\_exp$ is in section \ref{transexp}.

¹ZAX
Ü	Ûtrans_expİ : EXP ß Z_EXP
°

ÿÛExp_Parsİüüüüüüüüüüüüüüüüüü
Ü	expr : EXP;
Ü	zexpr : Z_EXP
ˆüüüüüüüüüüüüüüüüüü

\subsection{Translating Identifiers}
=DOC
val Ûtrans_idİ : ID -> Z_ID;
val Ûprefix_trans_idİ : Z_ID list -> ID -> Z_ID;
val Ûtrans_expanded_nameİ : EXPANDED_NAME -> Z_ID
=DESCRIBE
¹ZAX
Ü	Ûtrans_idİ : ID ­ Z_ID
°
=ENDDOC

Note {\it Id} in the following paragraph rather than $id$ because $id$ is a reserved word in the Z library of {\ProductZ}.

ÿÛExp_Idİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ ident : ID · expr = Id ident ± zexpr = zid(trans_id ident)
ˆüüüüüüüüüüüüüüüüüü

\subsection{Translating Aggregates (Positional Array)}
=DOC
val Ûzfstİ : Z_ID
val Ûzlstİ : Z_ID
val Ûzsucİ : Z_ID
val Ûzpredİ : Z_ID
val Ûzposİ : Z_ID
val Ûzvalİ : Z_ID
val Ûzlengthİ : Z_ID
val Ûzrangeİ : Z_ID
=DESCRIBE
¹Z
Ü	Ûzfstİ ¦ trans_id fst
°
¹Z
Ü	Ûzlstİ ¦ trans_id lst
°
¹Z
Ü	Ûzsucİ ¦ trans_id suc
°
¹Z
Ü	Ûzpredİ ¦ trans_id pred
°
¹Z
Ü	Ûzposİ ¦ trans_id pos
°
¹Z
Ü	Ûzvalİ ¦ trans_id val
°
¹Z
Ü	Ûzlengthİ ¦ trans_id length
°
¹Z
Ü	Ûzrangeİ ¦ trans_id range
°
¹Z
Ü	Ûzdeltaİ ¦ trans_id delta
°
¹Z
Ü	Ûzdigitsİ ¦ trans_id digits
°
=ENDDOC

=DOC
(* infix 3 ^^; *)

val Û^^İ : Z_ID * Z_ID -> Z_ID
=DESCRIBE
¹Z
Ü	fun 3	_ Û^İ _
°
¹ZAX
Ü	_ Û^İ _ : (Z_ID ¸ Z_ID) ­ Z_ID
°
=ENDDOC

=DOC
val Ûdest_rangeİ : EXP RANGE -> EXP RANGELOHI
=DESCRIBE
Given a range of either of the forms {\it x .. y}
or {\it t'range}, this function gives upper and lower
bounds for the range (either {\it x} and {\it y}
or {\it t'first} and {\it t'last}. It also handles
the case {\it t.range(n)} by mapping to {\it t'first(n)} and {\it t'last(n)}.
It is exposed here so that it can be used in the verification condition generation
for case and loop statements.
=ENDDOC
The function $map$ already exists in {\Product} and already corresponds to this specification.

[X, Y]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	Ûmapİ : (X ­ Y) ­ seq X ­ seq Y
÷üüüüüüüüüüüüüüüüüüüüü
Ü	µ f : X ­ Y; s : seq X ·
Ü	map f s = { i : ú; x : X | (i, x)  s · (i, f x)}
ˆüüüüüüüüüüüüüüüüüüüüüü
=DOC
val Ûdimenİ : Z_ID * int -> Z_ID
=DESCRIBE
¹ZAX
Ü Ûdimenİ : (Z_ID ¸ î) ­ Z_ID
°
=ENDDOC
=DOC
type ÛARRAY_AGG_ENVİ (* = {tname : TMARK, this : int, max : int} *);
=DESCRIBE
ÿ ÛArray_Agg_Envİ üüüüüüüüüüü
Ü	tname : TMARK;
Ü	this, max  : î
÷üüüüüü
Ü	 1 ¼ this ¼ max + 1
ˆüüüüüüüüüüüüüü
=ENDDOC
=DOC
val Ûtrans_array_agg_expİ : CN_ENV -> ARRAY_AGG_ENV -> EXP -> Z_EXP
=DESCRIBE
¹ZAX
Ü	Ûtrans_array_agg_expİ : Array_Agg_Env ­ EXP ß Z_EXP
÷üüüüüü
Ü	µ Array_Agg_Env
Ü	|	this = max + 1
Ü	·	trans_array_agg_exp (ÊArray_Agg_Env) = trans_exp
°
=ENDDOC
ÿ ÛArray_Agg_Parsİ üüüüüüüüüüü
Ü 	Array_Agg_Env;
Ü 	expr : EXP;
Ü	zexpr : Z_EXP
ˆüüüüüüüüüüüüüü
=DOC
val Ûarray_firstİ : CN_ENV -> ARRAY_AGG_ENV -> Z_EXP;
=DESCRIBE
¹ZAX
Ü	Ûarray_firstİ : Array_Agg_Env  ­ Z_EXP
÷üüüüüü
Ü	µ Array_Agg_Env
Ü	· max = 1 ±
Ü		array_first(ÊArray_Agg_Env) = zid(trans_id tname ^ zfst)
Ü	² max ½ 1 ±
Ü		array_first(ÊArray_Agg_Env) = zid(dimen(trans_id tname ^ zfst, this))
°
=ENDDOC
=DOC
val Ûexp_array_agg_posİ : CN_ENV -> ARRAY_AGG_ENV -> EXP AGG_POS -> Z_EXP
=DESCRIBE
ÿÛExp_Array_Agg_Posİüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Pos; Z_Bin_Exp; zseq : seq Z_EXP; Array_Agg_Env' ·
Ü	expr = array_agg_pos (ÊAgg_Pos) ±
Ü	ran comps € dom (trans_array_agg_exp (ÊArray_Agg_Env')) ±
Ü	zop = z_minus ± zleft = z_num 1 ±
Ü	zright = array_first(ÊArray_Agg_Env) ±
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	zseq = map (trans_array_agg_exp (ÊArray_Agg_Env')) comps ±
Ü	zexpr =
Ü	z_rel_comp(z_power(z_succ, z_bin_exp(ÊZ_Bin_Exp)), z_seq zseq)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Positional Array with Others)}
=DOC
val Ûexp_array_agg_pos_othersİ : CN_ENV -> ARRAY_AGG_ENV -> EXP AGG_POS_OTHERS -> Z_EXP
=DESCRIBE
ÿÛExp_Array_Agg_Pos_Othersİüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Pos_Others; oth, posit : EXP; Array_Agg_Env' ·
Ü	expr = array_agg_pos_others (Ê Agg_Pos_Others) ±
Ü	oth = array_agg_others (Ê Agg_Others) ±
Ü	posit = array_agg_pos (Ê Agg_Pos) ±
Ü	oth  dom (trans_array_agg_exp (ÊArray_Agg_Env)) ±
Ü	posit  dom (trans_array_agg_exp (ÊArray_Agg_Env')) ±
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	zexpr =
Ü	z_override
Ü	(trans_array_agg_exp (ÊArray_Agg_Env) oth,
Ü	 trans_array_agg_exp (ÊArray_Agg_Env') posit)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Positional Array with Just Others)}
=DOC
val Ûarray_rangeİ : CN_ENV -> ARRAY_AGG_ENV -> Z_EXP;
=DESCRIBE
¹ZAX
Ü	Ûarray_rangeİ : Array_Agg_Env  ­ Z_EXP
÷üüüüüü
Üµ Array_Agg_Env·
Ü	max = 1 ±
Ü	array_range(ÊArray_Agg_Env) = zid(trans_id tname ^ zrange)
Ü ²	max ½ 1 ±
Ü	array_range(ÊArray_Agg_Env) = zid(dimen(trans_id tname ^ zrange, this))
°
=ENDDOC
=DOC
val Ûexp_array_agg_othersİ : CN_ENV -> ARRAY_AGG_ENV -> EXP AGG_OTHERS -> Z_EXP
=DESCRIBE
ÿÛExp_Array_Agg_Othersİüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Others; Array_Agg_Env' ·
Ü	expr = array_agg_others (Ê Agg_Others) ±
Ü	others  dom (trans_array_agg_exp (ÊArray_Agg_Env')) ±
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	zexpr =
Ü	z_cross(array_range(ÊArray_Agg_Env),
Ü	 z_set {trans_array_agg_exp (ÊArray_Agg_Env') others} )
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Named Array)}
=DOC
val Ûtrans_named_assocİ : CN_ENV -> ARRAY_AGG_ENV ->
	(AGG_CHOICE,EXP) NAMED_ASSOC -> Z_EXP
=DESCRIBE
¹ZAX
Ü	Ûtrans_named_assocİ : Array_Agg_Env ­ Named_Assoc ß Z_EXP
÷üüüüüüüü
Üµ Array_Agg_Env; Array_Agg_Env'·
Ü	tname' = tname ± this' = this+1 ± max' = max ±
Ü	dom (trans_named_assoc (ÊArray_Agg_Env)) =
Ü	{ Named_Assoc |
Ü	(µ Range | agg_choice_range (Ê Range)  choices ·
Ü		{lo, hi} € dom trans_exp) ±
Ü	(µ ex : EXP | agg_choice_single ex  choices · ex  dom trans_exp) ±
Ü	comp  dom (trans_array_agg_exp(ÊArray_Agg_Env'))} ±
Ü	(µ Named_Assoc
Ü	| ÊNamed_Assoc  dom (trans_named_assoc (ÊArray_Agg_Env))·
Ü	¶ zranges : ğ Z_EXP; zsingles : Z_EXP ·
Ü	zranges =
Ü	{ Range | agg_choice_range (Ê Range)  choices ·
Ü		z_rng(trans_exp lo, trans_exp hi)} ±
Ü	zsingles =
Ü	z_set
Ü	{ ex : EXP | agg_choice_single ex  choices · trans_exp ex} ±
Ü	trans_named_assoc (ÊArray_Agg_Env) (Ê Named_Assoc) =
Ü	z_cross
Ü	(z_many_union(zranges À {zsingles}),
Ü	 z_set {trans_array_agg_exp (ÊArray_Agg_Env') comp} ))
°
=ENDDOC

=DOC
val Ûexp_array_agg_namedİ : CN_ENV ->
	ARRAY_AGG_ENV -> (AGG_CHOICE, EXP) AGG_NAMED -> Z_EXP
=DESCRIBE
ÿÛExp_Array_Agg_Namedİüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Named ·
Ü	expr = array_agg_named (Ê Agg_Named) ±
Ü	named_assocs € dom (trans_named_assoc (ÊArray_Agg_Env)) ±
Ü	zexpr =
Ü	z_many_union
Ü	(trans_named_assoc (ÊArray_Agg_Env) ¨ named_assocs © )
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Aggregates (Named Array with Others)}
=DOC
val Ûexp_array_agg_named_othersİ : CN_ENV
		-> ARRAY_AGG_ENV -> (AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> Z_EXP
=DESCRIBE
ÿÛExp_Array_Agg_Named_Othersİüüüüüüüüüüüüüüüüüü
Ü	Array_Agg_Pars
÷üüüüüüüü
Ü	¶ Agg_Named_Others; oth, nam : EXP ·
Ü	expr = array_agg_named_others (Ê Agg_Named_Others) ±
Ü	oth = array_agg_others (Ê Agg_Others) ±
Ü	nam = array_agg_named (Ê Agg_Named) ±
Ü	{ oth, nam } € dom (trans_array_agg_exp(ÊArray_Agg_Env)) ±
Ü	zexpr =
Ü	z_override
Ü	(trans_array_agg_exp(ÊArray_Agg_Env) oth,
Ü	 trans_array_agg_exp(ÊArray_Agg_Env) nam)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

{\def\PrNL#1\PrNN{\relax}
¹Z
Ü µArray_Agg_Pars | this ¼ max ·
Ü	expr í zexpr  trans_array_agg_exp (ÊArray_Agg_Env) ¤
Ü		 Exp_Array_Agg_Pos ² Exp_Array_Agg_Pos_Others ²
Ü		 Exp_Array_Agg_Others ² Exp_Array_Agg_Named ²
Ü	  	 Exp_Array_Agg_Named_Others Û(*İÛtaaeconstraintİÛ*)İ		
°
}
=DOC
val Ûarray_dimİ : CN_ENV -> TMARK -> int;
=DESCRIBE
¹ZAX
Ü Ûarray_dimİ : TMARK ß î‰1
°
=ENDDOC
=DOC
val z_array_agg : int -> Z_ID;
val Ûmk_array_aggİ : int * Z_EXP -> Z_EXP;
=DESCRIBE
¹ZAX
Ü Ûz_array_aggİ : î ­ Z_ID
°

¹ZAX
Ü Ûmk_array_aggİ : î ¸ Z_EXP ­ Z_EXP
÷üüüüüü
Üµ max_dim : î; zex : Z_EXP; Z_Fun_Call ·
Ü	max_dim = 1 ± mk_array_agg(max_dim, zex) = zex
Ü²	zfun = zid(z_array_agg max_dim) ± zargs = §zex¢ ±
Ü	mk_array_agg(max_dim, zex) = z_fun_call(ÊZ_Fun_Call)
°
=FAILURE
508058	type error detected while attempting to make a multidimensional aggregate from ?0
=ENDDOC
=DOC
val Ûexp_array_aggİ : CN_ENV -> EXP -> Z_EXP
=DESCRIBE
ÿÛExp_Array_Aggİ üüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü¶ Array_Agg_Env ·
Ü( (¶ Agg_Pos ·
Ü	expr = array_agg_pos (Ê Agg_Pos)
Ü  ±	opt_tmark_tmark tname = tmark) ²
Ü  (¶ Agg_Pos_Others ·
Ü	expr = array_agg_pos_others (Ê Agg_Pos_Others)
Ü  ±	opt_tmark_tmark tname = tmark) ²
Ü  (¶ Agg_Named ·
Ü	expr = array_agg_named (Ê Agg_Named)
Ü  ±	opt_tmark_tmark tname = tmark) ²
Ü  (¶ Agg_Named_Others ·
Ü	expr = array_agg_named_others (Ê Agg_Named_Others)
Ü  ±	opt_tmark_tmark tname = tmark))
Ü± tname í max  array_dim
Ü± this = 1
Ü± expr  dom (trans_array_agg_exp(ÊArray_Agg_Env))
Ü± zexpr = mk_array_agg (max, trans_array_agg_exp(ÊArray_Agg_Env) expr)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC
=TEX

\subsection{Translating Aggregates (Positional Record)}

=DOC
val Ûexp_rec_agg_posİ : CN_ENV -> TMARK OPT * EXP list -> Z_EXP
=DESCRIBE
ÿÛExp_Rec_Agg_Posİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Rec_Agg_Pos; Z_Schema_Type; Z_Binding; tm : TMARK ·
Ü	expr = rec_agg_pos (Ê Rec_Agg_Pos) ± ran comps € dom trans_exp ±
Ü	z_type_of (zid (trans_id tmark)) =
Ü		z_power_type (z_sch_type (Ê Z_Schema_Type)) ±
Ü	zexpr = z_binding (Ê Z_Binding) ±
Ü	zbinds =
Ü	{ i : dom z_sig; Z_Decl |
Ü		zvar = Value (first (z_sig i)) ± zexp = trans_exp (comps i) · Ê Z_Decl}
ˆüüüüüüüüüüüüüüüüüü
=FAILURE
508026	The type ?0 is not a record type
508027	The number of components in the record aggregate
	does not match the declaration of ?0
=ENDDOC

\subsection{Translating Aggregates (Named Record)}
=DOC
val Ûexp_rec_agg_namedİ : CN_ENV
	-> (AGG_CHOICE, EXP) REC_AGG_NAMED -> Z_EXP
=DESCRIBE
ÿÛExp_Rec_Agg_Namedİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Rec_Agg_Named; Z_Binding ·
Ü	expr = rec_agg_named (Ê Rec_Agg_Named) ±
Ü	{ ident : ID; ex : EXP | (ident, ex)  named_assocs · ex } €
Ü		dom trans_exp ± zexpr = z_binding (Ê Z_Binding) ±
Ü	zbinds =
Ü	{ ident : ID; ex : EXP; Z_Decl |
Ü		(ident, ex)  named_assocs ± zvar = Value(trans_id ident) ±
Ü		zexp = trans_exp ex · Ê Z_Decl }
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Unary Expressions}
=DOC
val Ûunary_opsİ : UNARY_OP -> Z_EXP list;
val Ûtrans_unary_opİ : UNARY_OP * Z_EXP -> Z_EXP
=DESCRIBE
¹ZAX
Ü	Ûunary_opsİ : UNARY_OP ß ğZ_UNARY_OP
÷üüüüüüüüüüüüüüüüüüü
Ü	unary_ops =
Ü	{spark_unary_minus í {z_unary_minus, z_real_unary_minus},
Ü	 spark_not í {z_bool_not, z_array_not},
Ü	 spark_abs í {z_abs, z_real_abs} }
°
¹ZAX
Ü	Ûtrans_unary_opİ : UNARY_OP ¸ Z_EXP ß Z_UNARY_OP
÷üüüüüüüüüüüüüüüüüüü
Üµ op: UNARY_OP; zright : Z_EXP·
Ü	trans_unary_op(op, zright)  unary_ops op
°
=FAILURE
508079	?0 is not a valid operand for this expression
508089	?0 and ?1 are not a valid pair of operands for this expression
=ENDDOC

=DOC
val Ûexp_unary_expİ : CN_ENV -> EXP UNARY_EXP -> Z_EXP
=DESCRIBE
ÿÛExp_Unary_Expİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Unary_Exp; Z_Unary_Exp ·
Ü	expr = unary_exp (Ê Unary_Exp) ± right  dom trans_exp ±
Ü	(op = spark_unary_add ± zexpr = trans_exp right ²
Ü	op ½ spark_unary_add ± zop = trans_unary_op (op, zright) ±
Ü	zright = trans_exp right ± zexpr = z_unary_exp (Ê Z_Unary_Exp))
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Binary Expressions}
=DOC
val Ûbin_opsİ : BIN_OP -> Z_EXP list
val Ûtrans_bin_opİ : BIN_OP * Z_EXP * Z_EXP -> Z_EXP
=DESCRIBE

=FAILURE
508031	Internal error: unsupported SPARK operator
=ENDDOC
¹ZAX
Ü	Ûbin_opsİ : BIN_OP ß ğZ_BIN_OP
÷üüüüüüüüüüüüüüüüüüü
Ü	bin_ops =
Ü	{spark_and í { z_bool_and, z_array_and },
Ü	 spark_or í { z_bool_or, z_array_or },
Ü	 spark_and_then í { z_bool_and_then },
Ü	 spark_or_else í { z_bool_or_else },
Ü	 spark_xor í { z_bool_xor },
Ü	 spark_eq í { z_bool_eq },
Ü	 spark_noteq í { z_bool_noteq },
Ü	 spark_less í { z_bool_less, z_array_less, z_bool_real_less },
Ü	 spark_less_eq í { z_bool_less_eq, z_array_less_eq, z_bool_real_less_eq },
Ü	 spark_greater í { z_bool_greater, z_array_greater, z_bool_real_greater },
Ü	 spark_greater_eq í { z_bool_greater_eq, z_array_greater_eq,
Ü				z_bool_real_greater_eq },
Ü	 spark_add í { z_add, z_real_add },
Ü	 spark_minus í { z_minus, z_real_minus },
Ü	 spark_times í { z_times, z_real_times },
Ü	 spark_intdiv í { z_intdiv },
Ü	 spark_mod í { z_mod },
Ü	 spark_over í { z_real_over },
Ü	 spark_rem í { z_rem },
Ü	 spark_expon í { z_expon, z_real_expon },
Ü	 spark_mem í { z_bool_mem },
Ü	 spark_notmem í { z_bool_notmem },
Ü	 spark_cat í { z_array_array_cat, z_array_elem_cat, z_elem_array_cat } }
°
¹ZAX
Ü	Ûtrans_bin_opİ : BIN_OP ¸ Z_EXP ¸ Z_EXP ß Z_BIN_OP
÷üüüüüüüüüüüüüüüüüüü
Üµ op: BIN_OP; zleft, zright : Z_EXP·
Ü	trans_bin_op(op, zleft, zright)  bin_ops op
°
=DOC
val Ûexp_bin_expİ : CN_ENV -> EXP BIN_EXP -> Z_EXP
=DESCRIBE
ÿÛExp_Bin_Expİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Bin_Exp; Z_Bin_Exp ·
Ü	expr = bin_exp (Ê Bin_Exp) ± { left, right } € dom trans_exp ±
Ü	zop = trans_bin_op(op, zleft, zright) ± zleft = trans_exp left ±
Ü	zleft  {trans_exp left, z_integer_to_real (trans_exp left),
Ü		z_real_to_integer(trans_exp left)} ±
Ü	zright  {trans_exp right, z_integer_to_real (trans_exp right),
Ü		z_real_to_integer(trans_exp right)}
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Membership of a Range}
=DOC
val Ûexp_mem_rangeİ : CN_ENV -> EXP MEM_RANGE -> Z_EXP
=DESCRIBE
ÿÛExp_Mem_Rangeİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Mem_Range; Z_Bin_Exp ·
Ü	expr = mem_range (Ê Mem_Range) ±
Ü	{ left, lo, hi } € dom trans_exp ± zop = trans_bin_op(op, zleft, zright) ±
Ü	zleft = trans_exp left ± zright = z_rng (trans_exp lo, trans_exp hi) ±
Ü	zexpr = z_bin_exp (Ê Z_Bin_Exp)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Attributes}
=DOC
val Ûtmark_of_prefixİ : CN_ENV -> Z_EXP -> TMARK
(* val Ûtrans_attr_prefixİ : (EXP, ATTRIB_DESIG) ATTRIBUTE -> ZID *)
val Ûexp_attribİ : CN_ENV -> (EXP, ATTRIB_DESIG) ATTRIBUTE -> Z_EXP
=DESCRIBE
The Z declaration of
{\it tmark\_of\_prefix} is in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.
The function is used here in the (informally specified aspects of the) translation
of attributes.

¹ZAX
Ü Ûtrans_attr_prefixİ : Attribute ­ Z_ID
°
ÿÛExp_Attribİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB ·
Ü	expr = attribute (Ê Attribute) ± attrib_desig = attrib[EXP] att ±
Ü	zexpr = zid (trans_attr_prefix(ÊAttribute) ^ trans_id att)
ˆüüüüüüüüüüüüüüüüüü
=FAILURE
508028	The attribute cannot be translated into Z
=ENDDOC

The implementations of {\it Exp\_Nonarray\_Attrib\_Arg}
and {\it Exp\_Array\_Attrib\_Arg} are covered by the interface for $exp\_attrib$ and a separate functional interface has therefore not been provided.
¹Z
Ü	ÛARRAY_ATTRIBİ ¦ {fst, lst, length, range}
°

ÿÛExp_Nonarray_Attrib_Argİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB; arg : EXP; Z_Fun_Call ·
Ü	expr = attribute (Ê Attribute) ±
Ü	att  ARRAY_ATTRIB ±
Ü	attrib_desig = attrib_arg(att,arg) ± arg  dom trans_exp ±
Ü	zexpr = z_fun_call (Ê Z_Fun_Call) ±
Ü	zfun = zid (trans_attr_prefix(ÊAttribute) ^ trans_id att) ±
Ü	zargs = § trans_exp arg ¢
ˆüüüüüüüüüüüüüüüüüü
=DOC
val Ûeval_attr_argİ : Z_EXP -> int
=DESCRIBE
¹ZAX
Ü	Ûeval_attr_argİ : EXP ß î‰1
°
The implementation takes a Z expression to simplify the organisation of the
code.
=FAILURE
508029	Invalid attribute argument: ?0 cannot be statically evaluated to give an integer value
508030	Invalid attribute argument: ?0 is less than or equal to zero
=ENDDOC
ÿÛExp_Array_Attrib_Argİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB; arg : EXP ·
Ü	expr = attribute (Ê Attribute) ±
Ü	att  ARRAY_ATTRIB ±
Ü	attrib_desig = attrib_arg(att,arg) ± arg  dom eval_attr_arg ±
Ü	zexpr =
Ü	zid (dimen(trans_attr_prefix(ÊAttribute) ^ trans_id att, eval_attr_arg arg))
ˆüüüüüüüüüüüüüüüüüü

¹Z
Ü ÛExp_Attrib_Argİ ¦ Exp_Nonarray_Attrib_Arg ² Exp_Array_Attrib_Arg
°

\subsection{Translating Indexed Components}
=DOC
val Ûexp_indexed_compİ : CN_ENV -> EXP INDEXED_COMP -> Z_EXP
=DESCRIBE
ÿÛExp_Indexed_Compİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Indexed_Comp; Z_Fun_Call ·
Ü	expr = indexed_comp (Ê Indexed_Comp) ±
Ü	{ prefix } À ran index € dom trans_exp ± zfun = trans_exp prefix ±
Ü	zargs = map trans_exp index ± zexpr = z_fun_call (Ê Z_Fun_Call)
ˆüüüüüüüüüüüüüüüüüü
=FAILURE
508071	type error: cannot apply ?0 to ?1
=ENDDOC

\subsection{Translating Selected Components}
=DOC
val Ûexp_selected_compİ : CN_ENV -> EXP SELECTED_COMP -> Z_EXP
=DESCRIBE
ÿÛExp_Selected_Compİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Selected_Comp; Z_Selection ·
Ü	expr = selected_comp (Ê Selected_Comp) ± prefix  dom trans_exp ±
Ü	zbinding = trans_exp prefix ± zselector = trans_id selector ±
Ü	zexpr = z_selection (Ê Z_Selection)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Functions Calls}
=DOC
val Ûglobal_dep_parİ : CN_ENV -> ID -> Z_EXP;
val Ûfun_globalsİ : CN_ENV -> ID -> Z_EXP list;
val Ûtrans_fun_nameİ : CN_ENV -> ID -> Z_EXP;
=DESCRIBE
¹ZAX
Ü Ûfun_globalsİ : ID ­ seq Z_EXP
°
¹ZAX
Ü Ûfun_param_tmarksİ : ID ­ seq TMARK
°
¹ZAX
Ü Ûtrans_fun_nameİ : ID ­ Z_EXP
÷üüüüüüüü
Ü µn : ID·
Ü fun_globals n = §¢ ± trans_fun_name n = zid(trans_id n) ²
Ü (¶Z_Fun_Call · zargs = fun_globals n ±
Ü  zfun = zid(trans_id n) ±
Ü  trans_fun_name n = z_fun_call(ÊZ_Fun_Call))
°
{\it fun\_param\_tmarks} is implemented via the CN environment mechanism
and does not need an explicit ML function.
=FAILURE
508081	`?0' is not a valid function
508082	Incorrect number of actual parameters to function `?0'
=ENDDOC
The preprocessing of function calls actually means that these errors should never happen now.
=DOC
val Ûslideİ : Z_EXP * Z_EXP -> Z_EXP;
val Ûcon_array_range_from_tmarkİ : Z_EXP -> Z_EXP OPT;
val Ûslide_to_tmarkİ : CN_ENV -> Z_EXP * TMARK -> Z_EXP;
=DESCRIBE
¹ZAX
Ü Ûslide_to_tmarkİ : Z_EXP ¸ TMARK ­ Z_EXP
°
These functions support the treatment of array sliding.
Given the translation into Z of a type mark denoting a constrained
array subtype, {\it con\_array\_range\_from\_tmark} returns
an expression denoting the range of the arrays in the subtype.
When this succeeds with result {\it r} for an expression
{\it a} denoting an element of some other constrained array type with the
same base type, {\it slide(a, r)} denotes the value obtained by sliding
{\it a} so its range becomes {\it r}.

{\it slide\_to\_tmark} fits these pieces together in a way which is
a little more convenient for other modules (and this is the formulation
used in the Z specifications). It is given a translated
expression and a type mark. If the type mark denotes a constrained
array subtype, then it returns the expression denoting the slided value
otherwise it returns the original expression.
The caller may test for whether sliding has occurred by checking whether
the result is equal to the supplied parameter or by observing that
sliding results in a Z function call.
=FAILURE
508090	Cannot construct the sliding expression for ?0
=ENDDOC
=DOC
val Ûexp_fun_callİ : CN_ENV -> EXP FUN_CALL -> Z_EXP
=DESCRIBE
ÿÛExp_Fun_Callİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü ¶ Fun_Call ·
Ü expr = fun_call (Ê Fun_Call) ± ran args € dom trans_exp ±
Ü (args = §¢ ± zexpr = trans_fun_name fun_name ²
Ü args ½ §¢ ±
Ü (¶Z_Fun_Call; es_ts : seq (Z_EXP ¸ TMARK)·
Ü  zfun = trans_fun_name fun_name ±
Ü  map first es_ts = map trans_exp args ±
Ü  map second es_ts = fun_param_tmarks fun_name ±
Ü  zargs = map slide_to_tmark es_ts ±
Ü  zexpr = z_fun_call(Ê Z_Fun_Call)))
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsection{Translating Qualified Expressions}
=DOC
val Ûexp_qualifiedİ : CN_ENV -> EXP QUALIFIED_EXPRESSION -> Z_EXP
=DESCRIBE
ÿÛExp_Qualifiedİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Qualified_Exp ·
Ü	expr = qualified_exp (Ê Qualified_Exp) ± ex  dom trans_exp ±
Ü	zexpr = trans_exp ex
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Type Conversions}
=DOC
val Ûexp_type_convİ : CN_ENV -> EXP TYPE_CONVERSION -> Z_EXP
=DESCRIBE
ÿÛExp_Type_Convİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü ¶ Type_Conv ·
Ü expr = type_conv (Ê Type_Conv) ± ex  dom trans_exp ± ((
Ü	z_type_of(zid(trans_id tm)) = z_power_type z_int_type ±
Ü	z_type_of zexpr = z_int_type ± zexpr = trans_exp ex
Ü ) ² (
Ü	z_type_of(zid(trans_id tm)) = z_power_type z_real_type ±
Ü	z_type_of zexpr = z_real_type ± zexpr = trans_exp ex
Ü ) ² (
Ü	z_type_of(zid(trans_id tm)) = z_power_type z_real_type ±
Ü	z_type_of zexpr = z_int_type ± zexpr = z_integer_to_real (trans_exp ex)
Ü ) ² (
Ü	z_type_of(zid(trans_id tm)) = z_power_type z_int_type ±
Ü	z_type_of zexpr = z_real_type ± zexpr = z_real_to_integer (trans_exp ex)
Ü ))
ˆüüüüüüüüüüüüüüüüüü
=FAILURE
508053	Type conversions for types other than scalar types
	cannot be handled formally
=ENDDOC

\subsection{Translating Integer Literals}
=DOC
val Ûtrans_intİ : INT_REAL_LIT -> INTEGER
=DESCRIBE
¹ZAX
Ü	Ûtrans_intİ : INT_LIT ­ ú
°
=FAILURE
508110	?0 is not a valid exponent
508111	The character ?0 is not allowed here in a numeric literal
508112	An integer literal with no digits is not allowed
508113	?0 is not a valid base ?1 digit
508114	?0 is not a valid decimal number
508115	Negative exponents are not allowed in integer literals
508116	An exponent part with no digits is not allowed
508117	The base in a based literal must be between 2 and 16;
	?0 is not a valid base
508025	Cannot translate ?0; this form of literal is not handled formally
=ENDDOC
=DOC
val Ûexp_int_litİ : INT_REAL_LIT -> Z_EXP
=DESCRIBE
ÿÛExp_Int_Litİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ n : INT_LIT ·
Ü	expr = int n ± zexpr = z_num (trans_int n)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Real Literals}
=DOC
val Ûexp_real_litİ : INT_REAL_LIT -> Z_EXP
=DESCRIBE
¹ZAX
Ü	Ûtrans_realİ : REAL_LIT ­ Z_REAL
°
ÿÛExp_Real_Litİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ r : REAL_LIT ·
Ü	expr = real r ± zexpr = z_real (trans_real r)
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsection{Translating Character Literals}
=DOC
val Ûexp_char_litİ : CHAR_LIT -> Z_EXP
=DESCRIBE
¹ZAX
Ü	Ûtrans_charİ : CHAR_LIT ­ Z_STRING
°
ÿÛExp_Char_Litİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ c : CHAR_LIT; Z_Unary_Exp ·
Ü	expr = char c ± zop = z_char_lit ± zright = z_string(trans_char c) ±
Ü	zexpr = z_unary_exp (ÊZ_Unary_Exp)
ˆüüüüüüüüüüüüüüüüüü

{\it trans\_char} is the identity function in this implementation, and so
no ML is needed for it.
=ENDDOC


\subsection{Translating String Literals}
=DOC
val Ûexp_string_litİ : CHAR_LIT -> Z_EXP

=DESCRIBE
¹ZAX
Ü	Ûtrans_stringİ : STRING_LIT ­ Z_STRING
°
ÿÛExp_String_Litİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ s : STRING_LIT; Z_Unary_Exp ·
Ü	expr = string s ± zop = z_string_lit ± zright = z_string(trans_string s) ±
Ü	zexpr = z_unary_exp (ÊZ_Unary_Exp)
ˆüüüüüüüüüüüüüüüüüü
{\it trans\_string} is the identity function in this implementation, and so
no ML is needed for it.
=ENDDOC

\subsection{Translating Auxiliary Expressions}
=DOC
val Ûexp_auxiliary_expİ : CN_ENV -> ZUserInterfaceSupport.Z_TM -> Z_EXP
=DESCRIBE
ÿÛExp_Auxiliary_Expİüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ ze : Z_EXP ·
Ü	expr = auxiliary_exp ze ± zexpr = ze
ˆüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{The Function $trans\_exp$}\label{transexp}
=DOC
val Ûtrans_expİ : CN_ENV -> EXP -> Z_EXP
val Ûtrans_exp1İ : CN_ENV -> EXP -> Z_EXP OPT
=DESCRIBE
$trans\_exp$ translates a Compliance Notation (SPARK) expression into Z according to the algorithm specification in Volume 3 of DRA/CIS/CSE3/TR/94/27/3.0. following the Z specification below.

$trans\_exp1$ is just like $trans\_exp$ except that it returns an optional Z expression. If the SPARK expression can only be handled informally then a warning message is printed out and $Nil$ is returned.

{\def\PrNL#1\PrNN{\relax}
¹Z
Ü	µ Exp_Pars ·
Ü	trans_exp expr = zexpr ¤
Ü		Exp_Id ² Exp_Int_Lit ² Exp_Array_Agg ²
Ü		Exp_Rec_Agg_Pos ² Exp_Rec_Agg_Named ² Exp_Unary_Exp ²
Ü		Exp_Bin_Exp ² Exp_Mem_Range ² Exp_Attrib ² Exp_Attrib_Arg ²
Ü		Exp_Indexed_Comp ² Exp_Selected_Comp ² Exp_Fun_Call ²
Ü		Exp_Qualified ² Exp_Type_Conv ² Exp_Auxiliary_Exp ²
Ü		Exp_Real_Lit ² Exp_Char_Lit ² Exp_String_Lit Û(*İÛtrans_expconstraintİÛ*)İ
°
}
=FAILURE
508020	This form of expression cannot be handled formally here
508032	Internal error: unexpected use of a qualified expression constructor
508050	?0
508052	Ranges are not handled formally here
508054	An aggregate that is not the operand of a qualified expression
	and is not a subaggregate cannot be handled formally
508062	A subaggregate is required here
=ENDDOC
=TEX
\subsection{External Interface to Overload Resolution}
=DOC
val Ûresolve_opsymİ:
		CN_ENV ->
		OPERATOR_SYMBOL ->
		PARAMETER_SPECIFICATION list ->
		TMARK ->
		 (Z_EXP * TMARK list * TMARK) OPT;
=DESCRIBE
See \cite{ISS/HAT/DAZ/DTD507} for the formal specification.
The implementation also checks the return type and returns the information needed to
check further renamings of the new name.
=ENDDOC

\section{TRANSLATING SPARK BASIC DECLARATIONS}

The design in this section corresponds to the specification in section 6 of \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}.


¹ZAX
Ü	Ûtrans_basic_declİ : BASIC_DECL ­ seq Z_PARA
°

The following schema denotes the input and output parameters to basic declaration-handling functions.
ÿÛBasic_Decl_Parsİüüüüüüüüüüüüüüüüü
Ü	basic_decl : BASIC_DECL;
Ü	z : seq Z_PARA
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Translating Constants}
=DOC
val Ûbasic_decl_constİ : CN_ENV * Z_ID list ->
		EXP CONST_DECL -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Const_1İüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Const_Decl; ze : Z_EXP; tmark : TMARK; Z_Decl; Z_Ax ·
Ü	basic_decl = const_decl (Ê Const_Decl) ± expr í ze  trans_exp ±
Ü	( 	tm = Value tmark ±
Ü		zvar = Value(trans_id const) ± zexp = zid(trans_id tmark) ±
Ü		decls = {ÊZ_Decl} ±
Ü		preds = {z_eq(zid (trans_id const), slide_to_tmark(ze, tmark)) }  ±
Ü		 z = §z_ax(ÊZ_Ax)¢
Ü	²	tm = Nil ±
Ü		z = §z_eq_eq(trans_id const, ze)¢)
ˆüüüüüüüüüüüüüüüüüüüü
ÿÛBasic_Decl_Const_2İüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Const_Decl; Z_Ax; Z_Decl; tmark : TMARK ·
Ü	basic_decl = const_decl (Ê Const_Decl) ± expr  dom trans_exp ±
Ü	zvar = Value(trans_id const) ± zexp = zid(trans_id tmark) ± tm = Value tmark ±
Ü	decls = {ÊZ_Decl} ± preds = { } ± z = §z_ax(ÊZ_Ax)¢
Ü ²	tm = Nil ± z = §¢
ˆüüüüüüüüüüüüüüüüüüüü
Note: the implementation of these is via a single function which takes
the appropriate action according as $expr$ is or is not translatable.
I.e. $basic\_decl\_const$ implements the schema disjunction of the above two schemas (which is what is required where they are used in $trans\_basic\_decl$).
=FAILURE
508067	The expression in the named number declaration for ?0 cannot be translated into Z
508068	The expression in the declaration for ?0 is incompatible with the type mark ?1
=ENDDOC

\subsection{Translating Enumeration Types}
=DOC
val Ûenum_attribİ : CN_ENV -> (Z_ID * Z_ID * Z_ID)
			-> ZParagraphs.PARAINFO list
=DESCRIBE
The name $Z\_PARA$ is already used in {\ProductZ} for something else, but $ZParagraphs.PARAINFO$ of {\ProductZ} actually corresponds in semantics to DRA's use of $Z\_PARA$.

¹ZAX
Ü	Ûenum_attribİ : (Z_ID ¸ Z_ID ¸ Z_ID) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2, zid‰3 : Z_ID ·
Ü ¶ zexp : Z_EXP ·
Ü	zexp = z_set_minus(zid zid‰1, z_set {zid (zid‰1 ^ zlst)}) ±
Ü	enum_attrib (zid‰1, zid‰2, zid‰3) =
Ü		§z_eq_eq(zid‰1 ^ zfst, zid zid‰2),
Ü		z_eq_eq(zid‰1 ^ zlst, zid zid‰3),
Ü		z_eq_eq(zid‰1 ^ zsuc, z_dom_res(zexp, z_succ)),
Ü		z_eq_eq(zid‰1 ^ zpred, z_inv(zid (zid‰1 ^ zsuc))),
Ü		z_eq_eq(zid‰1 ^ zpos, z_id_rel (zid zid‰1)),
Ü		z_eq_eq(zid‰1 ^ zval, z_inv(zid(zid‰1 ^ zpos)))¢
°
=ENDDOC

=DOC
val Ûbasic_decl_enumİ : CN_ENV * Z_ID list ->
		ID -> ENUM_TYPE_DEF -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Enumİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü 	¶ Type_Decl; Enum_Type_Def; zname : Z_ID;
Ü	zvals : seq Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = enum_type_def (Ê Enum_Type_Def) ±
Ü	zname = trans_id name ± zvals = map trans_id vals ±
Ü	z =
Ü	{ i : dom vals · i í z_eq_eq(zvals i, z_num(i-1))} ë
Ü		§z_eq_eq(zname, z_rng(zid(head zvals), zid(last zvals)))¢ ë
Ü		enum_attrib(zname, head zvals, last zvals)
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Array Types}

=DOC
val Ûarray_attrib_auxİ : CN_ENV -> Z_ID -> (Z_ID * int) -> ZParagraphs.PARAINFO list
val Ûarray_attribİ : CN_ENV -> (Z_ID * Z_ID list) -> ZParagraphs.PARAINFO list
=DESCRIBE
¹ZAX
Ü	Ûarray_attrib_auxİ : (Z_ID ¸ Z_ID ¸ î) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2 : Z_ID; i : î ·
Ü	array_attrib_aux (zid‰1, zid‰2, i) =
Ü		§z_eq_eq(dimen(zid‰1 ^ zfst, i), zid (zid‰2 ^ zfst)),
Ü		z_eq_eq(dimen(zid‰1 ^ zlst, i), zid (zid‰2 ^ zlst)),
Ü		z_eq_eq(dimen(zid‰1 ^ zlength, i), z_size (zid zid‰2)),
Ü		z_eq_eq(dimen(zid‰1 ^ zrange, i), zid zid‰2)¢
°

¹ZAX
Ü	Ûarray_attribİ : (Z_ID ¸ seq‰1 Z_ID) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid : Z_ID; zids : seq‰1 Z_ID ·
Ü	array_attrib (zid, zids) =
Ü		array_attrib_aux(zid, head zids, 0) ë
Ü		‹(Ìi : dom zids· array_attrib_aux(zid, zids i, i))
°
{\it array\_attrib\_aux} is curried in ML to make the coding of
{\it array\_attrib} simpler.
=FAILURE
508035	Internal error: parser has generated a 0-dimensional array ?0
=ENDDOC

\newpage

=DOC
val Ûbasic_decl_con_arrayİ : CN_ENV * Z_ID list ->
		ID -> ARRAY_DEF -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Con_Arrayİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Array_Def; zname, zcomp : Z_ID; zindex : seq‰1 Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = con_array_def (Ê Array_Def) ±
Ü	zname = trans_id name ± zindex = map trans_id index ±
Ü	zcomp = trans_id comp ±
Ü	z =
Ü	§z_eq_eq (zname, z_tfun(z_many_cross(map zid zindex), zid zcomp))¢ ë
Ü		array_attrib(zname, zindex)
ˆüüüüüüüüüüüüüüüüüüüü

=ENDDOC

=DOC
val Ûbasic_decl_uncon_arrayİ : CN_ENV * Z_ID list ->
		ID -> ARRAY_DEF -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Uncon_Arrayİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Array_Def; Z_Ax; Z_Decl;
Ü		zname, zcomp : Z_ID; zindex : Z_EXP·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = uncon_array_def (Ê Array_Def) ±
Ü	zname = trans_id name ±
Ü	zindex = z_many_cross(map (zid o trans_id) index) ±
Ü	zcomp = trans_id comp ± zvar = Value zname ±
Ü	zexp = z_powerset(z_pfun(zindex, zid zcomp)) ±
Ü	decls ={ÊZ_Decl} ± preds = { } ± z= §z_ax(Ê(Z_Ax))¢
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Translating Record Types}
=DOC
val Ûtrans_declİ : CN_ENV -> VAR_DECL -> Z_DECL
val Ûrecord_update_defsİ : (Z_ID * Z_ID list list) -> ZParagraphs.PARAINFO
=DESCRIBE
¹ZAX
Ü	Ûtrans_declİ : Var_Decl ­ Z_Decl
÷üüüüüüüüüüüüü
Ü µ Var_Decl; Z_Decl ·
Ü	trans_decl (Ê Var_Decl) = Ê Z_Decl ¤
Ü		zvar = Value(trans_id var) ± zexp = zid (trans_id tmark)
Ü		
°
¹ZAX
Ü Ûrecord_update_defsİ : ID ¸ Record_Type_Def ­ seq Z_PARA
°
The {\Product} implementation uses {\it Z\_ID}s to save multiple calls of {\it trans\_id}
and returns a single paragraph, because that is all that is needed.
=ENDDOC
¹ZAX
Ü Ûtrans_comp_sub_indİ : COMP_SUB_IND ­ Z_EXP
÷üüüüüü
Ü µ t : TMARK; lo, hi : EXP·
Ü	trans_comp_sub_ind (comp_sub_ind_tmark t) = zid (trans_id t)
Ü ±	trans_comp_sub_ind(comp_sub_ind_range (lo, hi)) = z_rng(trans_exp lo, trans_exp hi)
°

¹ZAX
Ü Ûtrans_comp_declİ : Comp_Decl ­ Z_PRED
÷üüüüüü
Ü µ Comp_Decl; ssi : seq COMP_SUB_IND; dc : ID ß EXP; zv : Z_EXP
Ü |	zv = zid(trans_id var)
Ü ·	(constraint = comp_no_con ´ trans_comp_decl (ÊComp_Decl) = z_true)
Ü ±	(constraint = comp_index_con ssi ´
Ü		(¶Z_Decl; zp : Z_PRED·
Ü		zexp = zid(trans_id tmark) ±
Ü		 zp = z_eq(z_dom(zid ((Valueç~ê) zvar)), z_many_cross(trans_comp_sub_ind o ssi)) ±
Ü		trans_comp_decl (ÊComp_Decl) =
Ü		z_mem(zv, z_set_comp(ÊZ_Decl, zp))))
Ü ±	(constraint = comp_disc_con dc ´
Ü		trans_comp_decl (ÊComp_Decl) =
Ü		z_many_and
Ü		{	s : dom dc; Z_Selection
Ü		|	zbinding = zv ± zselector = trans_id s
Ü		·	z_eq(z_selection(ÊZ_Selection), trans_exp (dc s)) })
°

=DOC
val Ûbasic_decl_recordİ : CN_ENV * Z_ID list ->
		ID -> EXP RECORD_TYPE_DEF -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Recordİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü	¶ Type_Decl; rec : Record_Type_Def; Z_Schema ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = record_type_def rec ± z_sname = trans_id name ±
Ü	z_decls = trans_decl ¨ ran (rec.decl » (ÌComp_Decl·ÊVar_Decl)) À ran rec.disc © ±
Ü	z_pred = z_many_and(trans_comp_decl¨ran rec.decl©) ±
Ü	z = §z_schema (Ê Z_Schema)¢ ë record_update_defs (name, rec)
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
508103	A discriminant constraint can only be applied to a record type
	In the declaration for record component ?0, ?1 is not a record type.
508104	In the declaration for record component ?0, the discriminant constraint
	has the wrong number of discriminants (?1 rather than the expected ?2)
=ENDDOC

\subsection{Translating Integer Types}

=DOC
val Ûint_type_attribİ : CN_ENV -> (Z_ID * EXP RANGE) -> ZParagraphs.PARAINFO list
=DESCRIBE
¹ZAX
Ü	Ûz_intsİ : Z_ID
°
¹ZAX
Ü	Ûint_type_attribİ : (Z_ID ¸ Range) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü	µ zid‰1 : Z_ID; Range ·
Ü	¶ Z_Ax'; Z_Ax''; Z_Ax'''; Z_Ax'''' ·
Ü		decls' = {Z_Decl | zvar = Value(zid‰1 ^ zsuc) ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	decls'' = {Z_Decl | zvar = Value(zid‰1 ^ zpred) ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	decls''' = {Z_Decl | zvar = Value(zid‰1 ^ zpos) ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	decls'''' = {Z_Decl | zvar = Value(zid‰1 ^ zval) ±
Ü					zexp = z_pfun(zid z_ints, zid z_ints) }
Ü	±	(preds' = preds'' = preds''' = preds'''')
Ü	±	int_type_attrib (zid‰1, Ê Range) =
Ü			§z_eq_eq(zid‰1 ^ zfst, trans_exp lo),
Ü			z_eq_eq(zid‰1 ^ zlst, trans_exp hi),
Ü			z_ax(ÊZ_Ax'), z_ax(ÊZ_Ax''),
Ü			z_ax(ÊZ_Ax'''), z_ax(ÊZ_Ax'''') ¢
°
=ENDDOC

=DOC
val Ûbasic_decl_int_typeİ : CN_ENV * Z_ID list ->
		ID -> EXP RANGE -> ZParagraphs.PARAINFO list;
val Ûis_modular_typeİ : TMARK -> bool;
=DESCRIBE
ÿÛBasic_Decl_Int_Typeİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Range; zname : Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = int_type_def (Ê Range) ±
Ü	zname = trans_id name ±
Ü	z =
Ü	§z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi))¢ ë
Ü		int_type_attrib(zname, Ê Range)
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
508066	The bounds of an integer type must be integers:
	?0 is not an integer
508074	The modulus of a modular type must be an integer
	?0 is not an integer
=ENDDOC

\subsection{Translating Real Types}
=DOC
val Ûbasic_decl_fixed_typeİ : CN_ENV * Z_ID list ->
		ID -> EXP FIXED_TYPE_DEF -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Fixed_Typeİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Fixed_Type_Def; zname : Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = fixed_type_def (Ê Fixed_Type_Def) ±
Ü	zname = trans_id name ±
Ü	z =
Ü	§z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi)),
Ü		z_eq_eq(zname ^ zdelta, trans_exp delta),
Ü		z_eq_eq(zname ^ zfst, trans_exp lo),
Ü		z_eq_eq(zname ^ zlst, trans_exp hi) ¢
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
508065	A fixed point constraint without a range constraint is not allowed here
=ENDDOC
=DOC
val Ûbasic_decl_floating_typeİ : CN_ENV * Z_ID list ->
		ID -> EXP FLOATING_TYPE_DEF -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Floating_Type_Rangeİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Floating_Type_Def_Range; zname : Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = floating_type_def_range (Ê Floating_Type_Def_Range) ±
Ü	zname = trans_id name ±
Ü	z =
Ü	§z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi)),
Ü		z_eq_eq(zname ^ zdigits, trans_exp digits),
Ü		z_eq_eq(zname ^ zfst, trans_exp lo),
Ü		z_eq_eq(zname ^ zlst, trans_exp hi) ¢
ˆüüüüüüüüüüüüüüüüüüüü
¹ZAX
Ü	Ûz_realsİ : Z_ID
°
ÿÛBasic_Decl_Floating_Type_No_Rangeİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Floating_Type_Def_No_Range; zname : Z_ID; Z_Ax'; Z_Ax'' ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = floating_type_def_no_range (Ê Floating_Type_Def_No_Range) ±
Ü	zname = trans_id name ±
Ü	decls' =
Ü	{ Z_Decl |
Ü	  zvar = Value (zname ^ zfst) ± zexp = zid z_reals } ±
Ü	decls'' =
Ü	{ Z_Decl |
Ü	  zvar = Value (zname ^ zlst) ± zexp = zid z_reals } ±
Ü	z =
Ü	§ z_ax(ÊZ_Ax'),
Ü	  z_ax(ÊZ_Ax''),
Ü	  z_eq_eq(zname, z_rng(zid(zname ^ zfst), zid(zname ^ zlst))),
Ü		z_eq_eq(zname ^ zdigits, trans_exp digits) ¢
ˆüüüüüüüüüüüüüüüüüüüü

=ENDDOC

\subsection{Translating Subtypes}

=DOC
val Ûrange_con_attribİ : CN_ENV ->
	(Z_ID * Z_ID * {lo : Z_EXP, hi : Z_EXP})
				-> ZParagraphs.PARAINFO list
=DESCRIBE
¹ZAX
Ü	Ûrange_con_attribİ : (Z_ID ¸ Z_ID ¸ Range) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2 : Z_ID; Range ·
Ü	range_con_attrib (zid‰1, zid‰2, Ê Range) =
Ü		§z_eq_eq(zid‰1 ^ zfst, trans_exp lo),
Ü		z_eq_eq(zid‰1 ^ zlst, trans_exp hi),
Ü		z_eq_eq(zid‰1 ^ zsuc, zid(zid‰2 ^ zsuc)),
Ü		z_eq_eq(zid‰1 ^ zpred, zid(zid‰2 ^ zpred)),
Ü		z_eq_eq(zid‰1 ^ zpos, zid (zid‰2 ^ zpos)),
Ü		z_eq_eq(zid‰1 ^ zval, zid(zid‰2 ^ zval))¢
°
Caller has already had to translate the bounds of the range into Z,
so the ML function has the translated expressions as its arguments.
=ENDDOC
¹ZAX
Ü Ûtype_attrsİ : ID ­ seq ID
°


=DOC
val Ûbasic_decl_subtype_range_conİ : CN_ENV * Z_ID list ->
		ID -> TMARK -> EXP RANGE -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Subtype_Range_Con_1İüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Range; zname, ztmark : Z_ID ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = range_con (Ê Range) ±
Ü	z_type_of(zid ztmark) = z_power_type z_int_type ±
Ü	lo  dom trans_exp ± hi  dom trans_exp ±
Ü	zname = trans_id name ±
Ü	ztmark = trans_id tmark ±
Ü	z =
Ü	§z_eq_eq (zname, z_rng (trans_exp lo, trans_exp hi)) ¢ ë
Ü		range_con_attrib(zname, ztmark, Ê Range)
ˆüüüüüüüüüüüüüüüüüüüü
ÿÛBasic_Decl_Subtype_Range_Con_2İüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Range; zname, ztmark : Z_ID; Z_Ax; Z_Decl ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = range_con (Ê Range) ±
Ü	(z_type_of(zid ztmark) ½ z_power_type z_int_type ²
Ü	lo  dom trans_exp ² hi  dom trans_exp) ±
Ü	zname = trans_id name ± ztmark = trans_id tmark ± zvar = Value zname ±
Ü	zexp = z_powerset(zid ztmark) ± decls = {ÊZ_Decl} ±
Ü	preds = {} ± z = §z_ax(ÊZ_Ax)¢
ˆüüüüüüüüüüüüüüüüüüüü
ÿÛBasic_Decl_Subtype_Range_Con_3İüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Range; zname, ztmark : Z_ID ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = range_con (Ê Range) ±
Ü	z_type_of(zid ztmark) = z_power_type z_real_type ±
Ü	lo  dom trans_exp ± hi  dom trans_exp ±
Ü	zname = trans_id name ±
Ü	ztmark = trans_id tmark ±
Ü	z =
Ü	§z_eq_eq (zname, z_rng (trans_exp lo, trans_exp hi)) ¢ ë
Ü        ((type_attrs tmark ù (ID \ {fst, lst})) » trans_id »
Ü	 (Ìa: Z_ID·(z_eq_eq(zname ^ a, zid(ztmark ^ a))))) ë
Ü	§z_eq_eq(zname ^ zfst, trans_exp lo),
Ü	 z_eq_eq(zname ^ zlst, trans_exp hi) ¢
ˆüüüüüüüüüüüüüüüüüüüü
Note: the implementation of these is via a single function which takes
the appropriate action according to the number of indices.
I.e. $basic\_decl\_subtype\_range_con$ implements the schema disjunction of the above two schemas (which is what is required where they are used in $trans\_basic\_decl$).
=FAILURE
508051	?0 is not a valid type mark
508060	The range constraint would give an empty type:
	the lower bound ?0 is greater than the upper bound ?1
508061	The range constraint for the type ?0 could not be evaluated;
	a VC has been generated for this type
508072	The modulus of a modular type must be positive:
	?0 is not positive
508073	The modulus for the type ?0 could not be evaluated;
	a VC has been generated for this type
=ENDDOC
=DOC
val Ûbasic_decl_subtype_fixed_conİ : CN_ENV * Z_ID list ->
		ID -> EXP FIXED_POINT_CONSTRAINT -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Subtype_Fixed_Conİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Type_Decl; Fixed_Type_Def ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = fixed_con (Ê Fixed_Type_Def) ±
Ü	type_def = fixed_type_def(Ê Fixed_Type_Def) ±
Ü	Basic_Decl_Fixed_Type
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
val Ûbasic_decl_subtype_floating_conİ : CN_ENV * Z_ID list ->
		ID -> EXP FLOATING_POINT_CONSTRAINT -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Subtype_Floating_Conİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Type_Decl; Floating_Type_Def_Range·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = floating_con (Ê Floating_Type_Def_Range) ±
Ü	type_def = floating_type_def_range(Ê Floating_Type_Def_Range) ±
Ü	Basic_Decl_Floating_Type_Range
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûbasic_decl_subtype_index_conİ : CN_ENV * Z_ID list ->
		ID -> TMARK -> EXP list -> ZParagraphs.PARAINFO list
=DESCRIBE
ÿÛBasic_Decl_Subtype_Index_Conİüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü	¶ Subtype_Decl; index : seq TMARK; Z_Decl;
Ü	zname : Z_ID; zindex : seq‰1 Z_ID; zp : Z_PRED ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = index_con index ± zname = trans_id name ±
Ü	zindex = map trans_id index ±
Ü	zexp = zid (trans_id tmark) ±
Ü	zp = z_eq (z_dom (zid ((Valueç~ê) zvar)), z_many_cross(map zid zindex)) ±
Ü	z =
Ü	§z_eq_eq (zname, z_set_comp (Ê Z_Decl, zp)) ¢ ë
Ü		array_attrib(zname, zindex)
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
508075	A subtype of STRING must have a lower index bound of 1; the lower bound
	for the subtype ?0 is not equal to 1
508076	The lower index bound for the type ?0 could not be evaluated;
	a VC has been generated for this type
=ENDDOC
=DOC
val Ûbase_typeİ : Z_EXP -> TMARK OPT
=DESCRIBE
Given an Ada type mark, {\it tm}, translated into a Z expression,
{\it base\_type tm} is the Z type for the base type of {\it tm}, if any.
The returned value is {\it Nil} for Ada integer and real types (since
these are subtyped from compiler-dependent pre-defined types) or if
for some reason the base type cannot be determined.
Ada enumeration types and their subtypes are represented in Z as integer types, but
{\it base\_type} can distinguish them from Ada integer types by checking on
the form of the definition of the successor attribute (which will not have
a defining equation for an Ada integer type).

It is also used in the implementation of attributes containing {\it 'BASE}.

=ENDDOC
=DOC
val Ûbasic_decl_subtype_disc_conİ : CN_ENV * Z_ID list ->
		ID -> TMARK -> EXP list -> ZParagraphs.PARAINFO list;
=DESCRIBE

ÿ ÛBasic_Decl_Subtype_Disc_Conİ üüüüüüüüüüü
Ü Basic_Decl_Pars
÷üüüüüü
Ü ¶Subtype_Decl; Z_Constrained_Schema; dc : ID ß EXP ·
Ü 	con = discriminant_con dc ± z_sname = trans_id name ± z_decl = trans_id tmark ±
Ü	z_pred = z_many_and { s : dom dc · z_eq(zid(trans_id s), trans_exp(dc s)) } ±
Ü 	z = §z_constrained_schema(ÊZ_Constrained_Schema)¢
ˆüüüüüüüüüüüüüü
=FAILURE
508100	A discriminant constraint can only be applied to a record type
	In the subtype declaration for ?0, ?1 is not a record type.
508101	In the subtype declaration for ?0, the discriminant constraint
	has the wrong number of discriminants (?1 rather than the expected ?2)
508102	Internal error: corrupt environment entry for type ?0
=ENDDOC
=DOC
val Ûbasic_decl_subtype_no_conİ : CN_ENV * Z_ID list ->
		ID -> TMARK -> ZParagraphs.PARAINFO list;
val Ûada_attributes_listİ : ID list;
val Ûtype_attrsİ : ID list -> ID -> ID list;
=DESCRIBE
$ada\_attributes\_list$ is based on material taken from the Ada Reference Manual.
It is based on all Ada attributes, not just those mentioned in the list in
Volume 3, section 3.13 of the specification of the Compliance Notation.
However, it does not list attributes of attributes, such as attributes of the $BASE$ attribute.

$type\_attrs$ $l$ $t$ then returns all the members of this list that are used to form
constants that are attributes of type $t$ in the theory in which $t$ is declared and
whose attribute identifiers are not in the list $l$.

ÿ ÛBasic_Decl_Subtype_No_Conİ üüüüüüüüüüü
Ü Basic_Decl_Pars
÷üüüüüü
Ü ¶Subtype_Decl; zname, ztmark : Z_ID ·
Ü   con = no_con ± zname = trans_id name ± ztmark = trans_id tmark ±
Ü   z = §z_eq_eq(zname, zid ztmark)¢ ë
Ü   (type_attrs tmark » trans_id » (Ìa: Z_ID·(z_eq_eq(zname ^ a, zid(ztmark ^ a)))))
ˆüüüüüüüüüüüüüü
=ENDDOC

\subsection{The Function $trans\_basic\_decl$}
=DOC
val Ûtrans_basic_declİ : CN_ENV * Z_ID list -> BASIC_DECL -> ZParagraphs.PARAINFO list
val Ûtrans_basic_decl1İ : CN_ENV * Z_ID list -> BASIC_DECL -> ZParagraphs.PARAINFO list OPT
=DESCRIBE

$trans\_basic\_decl$ takes a basic declaration in Compliance Notation (SPARK) and translates it into Z according to the algorithm specified in Volume 3 of DRA/CIS/CSE3/TR/94/27/3.0, and follows the Z specification below.

$trans\_basic\_decl1$ is similar to $trans\_basic\_decl$ except that it returns an optional Z list of Z paragraphs. If the SPARK basic declaration can only be handled informally then a warning message is printed out and $Nil$ is returned.

The first parameter is the CN environment for use in translating Ada expressions into Z.
The second parameter is a list of identifiers to be used as a prefix to form an expanded
name when translating the Ada identifiers introduced by the basic declaration into Z.

{\def\PrNL#1\PrNN{\relax}
¹Z
Ü µ Basic_Decl_Pars ·
Ü	trans_basic_decl basic_decl = z ¤
Ü	Basic_Decl_Const_1 ² Basic_Decl_Const_2 ² Basic_Decl_Enum ²
Ü	Basic_Decl_Int_Type ² Basic_Decl_Con_Array ²
Ü	Basic_Decl_Uncon_Array ² Basic_Decl_Record ²
Ü	Basic_Decl_Fixed_Type ² Basic_Decl_Floating_Type_Range ²
Ü	Basic_Decl_Floating_Type_No_Range ²
Ü	Basic_Decl_Subtype_Range_Con_1 ²
Ü	Basic_Decl_Subtype_Range_Con_2 ²
Ü	Basic_Decl_Subtype_Range_Con_3 ²
Ü	Basic_Decl_Subtype_Fixed_Con ² Basic_Decl_Subtype_Floating_Con ²
Ü	Basic_Decl_Subtype_Index_Con ²
Ü	Basic_Decl_Subtype_Disc_Con ²
Ü	Basic_Decl_Subtype_No_Con Û(*İÛtbdconstraintİÛ*)İ
°
}
=FAILURE
508039	Deferred constants are not handled formally
508040	Internal error: unexpected variable declaration
508041	Private types are not handled formally
=ENDDOC
\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}

During parsing, there were several cases where it was not possible to determine the actual abstract syntax which should be generated because of the lack of contextual information at the time of parsing. The design of this module is such that all the information needed to adjust the abstract syntax for expressions can be derived from the environment information in $CN\_ENV$. The function $adjust\_exp$ is provided to carry out those adjustments to expressions which the parser produced so that the abstract syntax is correct by the time the algorithms for generating Z from expressions, (and ultimately VCs) are invoked.


The function carries out the following adjustments to expressions:

\begin{description}

\item[Identifiers]
An identifier of the form $x.y$ can either be a package selection or a record selection. Which kind of selection is determined by the kind of object $x$ is. It is necessary to distinguish between the two because the names of the identifiers translated into Z by the expression generator would be different. In the example, where $x$ is in scope as a record, then $x.y$ is treated as a record selection; otherwise is assumed to be a package selection.

\item[Aggregates]
The parser represents record aggregates as array aggregates (this is the case both for positional and named aggregates). $adjust\_exp$ determines whether to convert an array aggregate into a record aggregate by checking whether a record aggregate with the corresponding name to the array aggregate has been declared and is in scope. If so, the adjustment is made.

\item[Indexed Components]
Function calls and type constraints are represented as indexed components by the parser. An indexed component is converted to a type constraint or a function by $adjust\_exp$ depending the functions and types which are in scope at the time.

\item[Qualified Expressions]
In SPARK record aggregates have to appear within qualified expressions.
Thus, the representation of aggregates contains a component which is the type mark of the aggregate. A qualified expression representation contains an aggregate part and a type mark part. Since the algorithms for generating Z assume that aggregates have associated with them the correct type mark, it is necessary in the case of a qualified expression to push its type mark into the appropriate type mark component of the aggregate and throw away the qualified expression data constructor. Since the aggregate part of a qualified expression may be either a record or an array, it is itself subject to possible adjustment for aggregates (see above). Thus, a qualified expression can be changed by $adjust\_exp$ into any one of the types of array aggregate or record aggregate.

During the analysis of the various forms of operand of the qualified expression to handle record aggregates, the form where the operand is not an aggregate is handled simply by replacing the qualified expression by the operand.
This implements the formal treatment of qualified expressions as defined by the Z schema $Exp\_Qualified$.
\end{description}


=DOC
val Ûnamed_assocs_to_expsİ : (ID * Z_EXP OPT) list ->
	(AGG_CHOICE,EXP) NAMED_ASSOC list -> EXP list
val Ûpositional_assocs_to_expsİ : (ID * Z_EXP OPT) list ->
	EXP list -> EXP list
=DESCRIBE
These function convert a named association parameter list or a positional association parameter list
into an expression list based upon knowledge of names
and default expressions, if any, of the parameters/components of a function/record for
which the named association list is the parameter.
=USES
It is required by $adjust\_exp$ (see below) and also used in the VC generator.
=FAILURE
508043	More than one actual parameter associations have been given for formal parameter ?0
508044	No actual parameter has been supplied for formal parameter ?0 and there is no default expression for it
508045	Syntax error: a parameter name in a subprogram call must be a simple name
508063	The subprogram has no formal parameter named ?0
508064	The subprogram call has too many actual parameters
508069	The subprogram call has too few positional parameters and a default expression is not available for
	one of the missing parameters
=ENDDOC

=DOC
val Ûadjust_expİ : CN_ENV -> EXP -> EXP
val Ûadjust_exp1İ : CN_ENV -> EXP -> EXP OPT
=DESCRIBE
$adjust\_exp$ transforms an expression into its correct representation, determined by information in the environment. For example, array aggregates are used by the parser to carry both function applications and arrays indexed by positional aggregates. This function determines from the environment whether the object is a function application or an indexed component and applies the appropriate transformation to the abstract expression.

$adjust\_exp1$ is similar to $adjust\_exp$ but it returns $Nil$ if the expression cannot be handled formally; otherwise it returns a value which is the same as that had $adjust\_exp$ been called.
=FAILURE
508048	Internal error: badly formed indexed component found near ?0
508035	Internal error: parser has generated a 0-dimensional array ?0
508055	Internal error: parser has generated a qualified expression as an index for ?0
508056	Internal error: the expression adjuster has generated an ill-formed indexed selection
508046	Syntax error: OTHERS part is not allowed in a record aggregate
508047	Syntax error: cannot index ?0 using a named association
508049	Informal functions cannot be handled formally; ?0 cannot be used here
508057	Syntax error: a discrete range is not a valid expression
=ENDDOC
=TEX
\section{SUPPORT FOR MULTIDIMENSIONAL ARRAYS}
=DOC
val Ûarray_agg_defİ : int -> unit
=DESCRIBE
=FAILURE
508059	the argument to array_agg_def must be at least 2
=ENDDOC
\section{GENERATING DOMAIN CONDITIONS}
=DOC
val Ûdomain_condsİ : CN_ENV -> Z_EXP -> Z_PRED list;
(* cn_domain_conds: integer control; 3 values allowed as follows *)
val Ûcn_no_domain_condsİ : int;
val Ûcn_standard_domain_condsİ : int;
val Ûcn_all_domain_condsİ : int;
val Ûget_domain_conds_controlİ : unit -> int;
=DESCRIBE
¹ZAX
Ü	Ûdomain_condsİ : Z_EXP ­ ğZ_PRED
°
This function generates the domain conditions for a Z expression
obtained by translating a SPARK expression.
The function is controlled by the integer control variable called
{\it cn\_domain\_conds}. This should be given one of the three
integer values given by the three ML bindings above. The effect
of the control is shown in the following table:
The current value of the control can be accessed using {\it get\_domain\_conds\_control}.
\begin{center}
\begin{tabular}{|l|p{3in}|}\hline
=INLINEFT
cn_no_domain_conds
=TEX
& No domain conditions are generated.\\\hline
=INLINEFT
cn_standard_domain_conds
=TEX
& Only domain conditions corresponding to exceptions that are guaranteed by ALRM are generated \\\hline
=INLINEFT
cn_all_domain_conds
=TEX
& Domain conditions are generated as for
=INLINEFT
cn_standard_domain_conds
=TEX
\ together with domain conditions corresponding to real arithmetic exceptions.\\\hline
\end{tabular}
\end{center}


The error message below is one which should never be seen unless the
input includes auxiliary expressions that have been maliciously constructed
using ML to fool the algorithm.
=FAILURE
508070	Invalid Z expression (?0) encountered while calculating domain conditions
=ENDDOC
\section{ADJUSTING DECLARATIONS}
\subsection{Basic Declarations}
=DOC
val Ûuniversal_discrete_typeİ : TMARK (* = "universal_discrete" *);
=DESCRIBE
¹ZAX
Ü  Ûuniversal_discrete_typeİ : TMARK
°
=ENDDOC
¹ZAX
Ü Ûgenerate_idİ :  Sub_Ind à TMARK
°
¹ZAX
Ü Ûsi_generate_idİ :  SI_Sub_Ind à TMARK
°
ÿÛadjust_subtypeİüü
Ü Sub_Ind; name : ID; newdecl : seq BASIC_DECL
÷üü
Ü (con = no_con ± name = tmark ± newdecl = §¢)
Ü²
Ü (con ½ no_con ±
Ü  (¶ Subtype_Decl' ·
Ü    name = name' = generate_id (ÊSub_Ind) ±
Ü    ÊSub_Ind = ÊSub_Ind' ±
Ü    newdecl = §subtype_decl(Ê Subtype_Decl')¢))
ˆü
ÿÛadjust_discrete_range_subindİüü
Ü s : SI_Discrete_Range; adjust_subtype
÷
Ü s = si_discrete_range_subind (Ê Sub_Ind)
ˆüü
ÿÛadjust_discrete_range_rangeİüü
Ü  s : SI_Discrete_Range; adjust_subtype
÷
Ü ¶ r : Range[EXP]; d : BASIC_DECL ·
Ü    s = si_discrete_range_range(r) ±
Ü    tmark = universal_discrete_type ± con = range_con(r)
ˆ
¹Z
Ü  Ûadjust_discrete_rangeİ  ¦
Ü      adjust_discrete_range_subind ² adjust_discrete_range_range
°
ÿÛadjust_constraintİüü
Ü  si_con : SI_CONSTRAINT;
Ü  con : CONSTRAINT;
Ü  newdecl : seq BASIC_DECL
÷
Ü  (si_con = si_no_con ± con = no_con ± newdecl = §¢)   ²
Ü  ({con} = range_con¨si_range_conç~ê ¨{si_con}© ©  ± newdecl = §¢)  ²
Ü  ({con} = fixed_con¨si_fixed_conç~ê ¨{si_con}© © ± newdecl = §¢)  ²
Ü  ({con} = floating_con¨si_floating_conç~ê ¨{si_con}© © ± newdecl = §¢)  ²
Ü  ({con} = discriminant_con¨si_discriminant_conç~ê ¨{si_con}© © ± newdecl = §¢)  ²
Ü  (¶ sdr : seq SI_Discrete_Range; si:seq ID · si_con = si_index_con(sdr) ±
Ü     con = index_con(si) ±
Ü     {adjust_discrete_range · s í name} o sdr = si ±
Ü     ‹({adjust_discrete_range · s í newdecl} o sdr) = newdecl
Ü  )
ˆüü
ÿÛadjust_general_subtypeİüü
Ü SI_Sub_Ind;
Ü name : ID;
Ü newdecl : seq BASIC_DECL
÷üü
Ü ¶ adjust_constraint' · si_con' = con ±
Ü (  ( con = si_no_con ± name = tmark ± newdecl = §¢) ²
Ü    ( con ½ si_no_con ± name = generate_id(tmark¦tmark, con¦con') ) ±
Ü    newdecl = newdecl'ë§subtype_decl(name¦name, tmark¦tmark, con¦con')¢
Ü )
ˆ
¹ZAX
Ü Ûadd_tmarkİ : EXP ¸ TMARK ­ EXP
°
ÿÛadjust_const_declİüü
Ü basic_decl : SI_BASIC_DECL;
Ü adjusted_decls: seq BASIC_DECL
÷üü
Ü ¶ adjust_general_subtype'; SI_Const_Decl; Const_Decl'' ·
Ü   basic_decl = si_const_decl(Ê SI_Const_Decl) ± const=const'' ±
Ü   ( ( t = Value(Ê SI_Sub_Ind') ± Value(name') = tm'' ±
Ü       expr'' = add_tmark(expr, name') ±
Ü       adjusted_decls = newdecl' ë§const_decl(Ê Const_Decl'')¢
Ü     ) ²
Ü     ( t = Nil  ± tm'' = Nil ± expr'' = expr ±
Ü       adjusted_decls = §const_decl(Ê Const_Decl'')¢
Ü     )
Ü   )
ˆ
¹ZAX
Ü Ûadjust_elementary_typesİ : SI_TYPE_DEF ß TYPE_DEF
÷üü
Ü adjust_elementary_types =
Ü    enum_type_def o si_enum_type_defç~ê  À
Ü    int_type_def o si_int_type_defç~ê À
Ü    fixed_type_def o si_fixed_type_defç~ê À
Ü    floating_type_def_range o si_floating_type_def_rangeç~ê À
Ü    floating_type_def_no_range o si_floating_type_def_no_rangeç~ê
°
ÿÛadjust_elementary_type_declİüü
Ü basic_decl : SI_BASIC_DECL;
Ü adjusted_decls : seq BASIC_DECL
÷üü
Ü ¶ SI_Type_Decl'; t : TYPE_DEF ·
Ü basic_decl = si_type_decl(Ê SI_Type_Decl') ±
Ü type_def'í t  adjust_elementary_types ±
Ü adjusted_decls = §type_decl(name ¦ name', type_def ¦ t)¢
ˆ
ÿÛadjust_uncon_array_type_declİüü
Ü basic_decl : SI_BASIC_DECL;
Ü adjusted_decls : seq BASIC_DECL
÷üü
Ü ¶ a : SI_Array_Def; Array_Def; adjust_general_subtype'; SI_Type_Decl ·
Ü     basic_decl = si_type_decl(Ê SI_Type_Decl) ±
Ü     type_def = si_uncon_array_def (a)±
Ü     Ê SI_Sub_Ind' = a.comp ± name' = comp ±
Ü     ({i:ID · i í si_discrete_range_subind(tmark¦i,con¦no_con)} o index) =
Ü	a.index ±
Ü       adjusted_decls =
Ü       newdecl' ë§type_decl(name¦name, type_def¦uncon_array_def(Ê Array_Def))¢
ˆ
ÿÛadjust_con_array_type_declİüü
Ü basic_decl : SI_BASIC_DECL;
Ü adjusted_decls : seq BASIC_DECL
÷üü
Ü ¶ a : SI_Array_Def; Array_Def; adjust_general_subtype'; SI_Type_Decl ·
Ü	basic_decl = si_type_decl(ÊSI_Type_Decl) ±
Ü	type_def =  si_con_array_def (a) ±
Ü	ÊSI_Sub_Ind' = a.comp ± name' = comp  ±
Ü	index = { adjust_discrete_range · s í name} o (a.index) ±
Ü	adjusted_decls =
Ü	‹({adjust_discrete_range · s í newdecl} o (a.index)) ë
Ü		§type_decl(name¦name, type_def¦con_array_def(ÊArray_Def))¢
ˆ
ÿ Ûdependent_rangeİ üüüüüüüüüüü
Ü Ûdiscİ : seq Var_Decl;
Ü Ûrİ : SI_Discrete_Range
÷üüüüüü
Ü (¶Range[EXP]; Sub_Ind; vd : ran disc·
Ü	con = range_con(ÊRange) ±
Ü	r = si_discrete_range_subind(ÊSub_Ind) ±
Ü	(lo = Id(vd.var) ² hi = Id(vd.var))) ²
Ü (¶Range[EXP]; vd : ran disc·
Ü	r = si_discrete_range_range(ÊRange) ±
Ü	(lo = Id(vd.var) ² hi = Id(vd.var)))
ˆüüüüüüüüüüüüüü

ÿ Ûdependent_constraintİ üüüüüüüüüüü
Ü Ûdiscİ : seq Var_Decl;
Ü Ûconİ : SI_CONSTRAINT
÷üüüüüü
Ü (¶sr : seq SI_Discrete_Range; r : SI_Discrete_Range·
Ü	con = si_index_con sr ± r  ran sr ± dependent_range) ²
Ü (¶dc : ID ­ EXP; vd : ran disc·
Ü	con = si_discriminant_con dc ± Id(vd.var)  ran dc)
ˆüüüüüüüüüüüüüü

ÿ Ûdependent_var_declİ üüüüüüüüüüü
Ü Ûdiscİ : seq Var_Decl;
Ü  SI_Var_Decl
÷üüüüüü
Ü  ¶SI_Sub_Ind·
Ü	t = ÊSI_Sub_Ind ±  dependent_constraint
ˆüüüüüüüüüüüüüü

¹ZAX
Ü Ûadjust_comp_sub_indİ : SI_Discrete_Range ­ COMP_SUB_IND
÷üüüüüü
Ü µ Sub_Ind; Range[EXP]
Ü |	con = range_con(ÊRange)
Ü ·	 adjust_comp_sub_ind(si_discrete_range_subind(ÊSub_Ind)) = comp_sub_ind_range(lo, hi);
Ü µ Sub_Ind
Ü |	con = no_con
Ü ·	adjust_comp_sub_ind(si_discrete_range_subind(ÊSub_Ind)) = comp_sub_ind_tmark tmark;
Ü µ Range[EXP]
Ü ·	adjust_comp_sub_ind(si_discrete_range_range(ÊRange)) = comp_sub_ind_range(lo, hi)
°
¹ZAX
Ü Ûadjust_comp_constraintİ : SI_CONSTRAINT ­ COMP_CONSTRAINT
÷üüüüüü
Ü 	adjust_comp_constraint si_no_con = comp_no_con;
Ü µsdr : seq SI_Discrete_Range·
Ü	adjust_comp_constraint (si_index_con sdr) = comp_index_con (adjust_comp_sub_ind o sdr);
Ü µ dc : ID ß EXP·
Ü	adjust_comp_constraint(si_discriminant_con dc) = comp_disc_con dc
°

ÿ Ûadjust_comp_declİ üüüüüüüüüüü
Ü  disc : seq Var_Decl;
Ü SI_Var_Decl;
Ü Comp_Decl;
Ü newdecl : seq BASIC_DECL
÷üüüüüü
Ü  (dependent_var_decl ±  tmark = t.tmark ± constraint = adjust_comp_constraint t.con ± newdecl = §¢)
Ü ²
Ü (³dependent_var_decl ± (¶SI_Sub_Ind; name : ID·
Ü	t = ÊSI_Sub_Ind ± constraint = comp_no_con ± tmark = name ± adjust_general_subtype))
Ü
ˆüüüüüüüüüüüüüü


ÿÛadjust_record_type_declİüü
Ü basic_decl : SI_BASIC_DECL;
Ü adjusted_decls : seq BASIC_DECL
÷üü
Ü ¶ r : SI_Record_Type_Def; Record_Type_Def;  d : BASIC_DECL; SI_Type_Decl ·
Ü     basic_decl = si_type_decl(Ê SI_Type_Decl) ±
Ü     type_def = si_record_type_def (r) ±
Ü     decl = {adjust_comp_decl ·
Ü              ÊSI_Var_Decl íÊComp_Decl} o r.decl ±
Ü     adjusted_decls =
Ü      ‹({adjust_comp_decl ·
Ü	  ÊSI_Var_Decl í newdecl} o r.decl) ë
Ü           §type_decl(name¦name, type_def¦record_type_def(ÊRecord_Type_Def))¢
ˆ


ÿÛadjust_subtype_declİüü
Ü basic_decl : SI_BASIC_DECL;
Ü adjusted_decls : seq BASIC_DECL
÷üü
Ü ¶ adjust_constraint'; i:ID; tmark:TMARK ·
Ü     basic_decl = si_subtype_decl(name¦i, tmark¦tmark, con¦si_con'  ) ±
Ü     adjusted_decls = newdecl'ë§subtype_decl(name¦i, tmark¦tmark, con¦con')¢
ˆ
=DOC
val Ûadjust_basic_declsİ : CN_ENV * Z_ID list -> SI_BASIC_DECL list -> BASIC_DECL list;
=DESCRIBE
¹Z
Ü  Ûadjust_basic_declİ ¦
Ü  { ( adjust_const_decl ² adjust_elementary_type_decl ²
Ü      adjust_uncon_array_type_decl ² adjust_con_array_type_decl ²
Ü      adjust_subtype_decl
Ü    )  ·   basic_decl í adjusted_decls
Ü  }
°
The ML interface deals with lists of declarations for convenience in managing
machine-generated type names. The declarations produced by a call should be
translated into Z and and stored in the appropriate theory before making another call,
otherwise duplicated names may be returned.
=FAILURE
508080	Syntax error: type mark expected in unconstrained array definition
508105	Invalid index constraint in declaration of record component ?0
508120	Modular types are not yet supported
=ENDDOC
\subsection{Variable Declarations}

¹Z
Ü ÛOPT_INITİ ::= Ûno_initİ | Ûinit_valİ EXP
°


ÿÛSI_VAR_DECLİüü
Ü si_vars: ğ SI_Var_Decl;
Ü si_init: OPT_INIT
ˆü
ÿÛVAR_DECLİüü
Ü vars: ğ Var_Decl;
Ü init: OPT_INIT
ˆü
ÿÛadjust_var_decl_no_subtypeİüü
Ü SI_VAR_DECL; VAR_DECL
÷
Ü (µ x : si_vars · x.t.con = si_no_con)  ±
Ü   (¶i: EXP; vd : vars·
Ü	init = si_init = no_init ²
Ü	si_init = init_val i ± init = init_val (add_tmark(i, vd.tmark))) ±
Ü  vars = {SI_Var_Decl· ÊSI_Var_Decl í (var¦var, tmark¦t.tmark)}¨si_vars©
ˆüü
ÿÛadjust_var_decl_subtypeİüü
Ü SI_VAR_DECL; VAR_DECL; basic_decl : SI_BASIC_DECL
÷
Ü ¶ SI_Sub_Ind; name:ID; i : EXP ·
Ü   (µ x : si_vars · x.t = Ê SI_Sub_Ind ± x.t.con ½ si_no_con) ±
Ü   name = si_generate_id(Ê SI_Sub_Ind) ±
Ü   basic_decl = si_subtype_decl( ÊSI_Subtype_Decl ) ±
Ü   (init = si_init = no_init ²
Ü     si_init = init_val i ± init = init_val (add_tmark(i, name)))±
Ü   vars = {SI_Var_Decl· ÊSI_Var_Decl í (var¦var, tmark¦name)}¨si_vars©
ˆüü
=DOC
val Ûadjust_var_declsİ : CN_ENV * Z_ID list -> SI_VAR_DECL list -> (BASIC_DECL list * VAR_DECL list);
=DESCRIBE
¹ZAX
Ü Ûadjust_var_declİ : SI_VAR_DECL ­ (OPT[SI_BASIC_DECL] ¸ VAR_DECL)
÷üüüüüü
Ü adjust_var_decl =
Ü {adjust_var_decl_subtype· ÊSI_VAR_DECL í (Value(basic_decl), ÊVAR_DECL)} À
Ü {adjust_var_decl_no_subtype· ÊSI_VAR_DECL í (Nil, ÊVAR_DECL)}
°
The ML interface deals with lists of declarations for convenience in managing
machine-generated type names. It also recursively process any generated {SI\_BASIC\_DECL}s
for the same reason. The declarations produced by a call should be
translated into Z and and stored in the appropriate theory before making another call,
otherwise duplicated names may occur.
=ENDDOC

\section{EPILOGUE}

=SML
end (* signature CNBasicDeclsAndExprs *);
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
