%  dtd508.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Declaration and Expression Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD508}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
The Z for the Z abstract syntax should be moved to dtd502 in the longer term.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Web Clause Processor.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=DOC
signature ÛCNBasicDeclsAndExprsÝ = sig
local
	open CNTypes ZParagraphs;
in
=DESCRIBE
=FAILURE
508001	?0
=ENDDOC

\subsection{Preamble for Z Type-Checking}

=SMLZ
open_theory"dtd513";
push_pc "z_library";
force_delete_theory"dtd508" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory "dtd508";
=TEX

\section{CUSTOMIZED ENVIRONMENT HANDLING}

=SML
datatype ÛENV_INFOÝ =
			ÛEIEnvFunctionÝ of ID list
		|	ÛEIEnvVarÝ of TMARK
		|	ÛEIEnvRecordÝ
		|	ÛEIEnvOtherÝ;
=TEX
=SML
type ÛCN_ENVÝ (* = Z_ID -> (TYPE * ENV_INFO) OPT *);
=TEX


\section{SUPPORT FOR Z ABSTRACT SYNTAX}

\subsection{Z Declarations}

ÿZ_Declüüüüüüüü
Ü	zvar : Z_ID;
Ü	zexp : Z_EXP
ˆüüüüüüüüüüüü

\subsection{Z Unary Expressions}

¹Z
Ü	Z_UNARY_OP ::= z_unary_minus | z_bool_not | z_abs
°

ÿZ_Unary_Expüüüüüüüü
Ü	zop : Z_UNARY_OP;
Ü	zright : Z_EXP
ˆüüüüüüüüüüü

=DOC
val Ûz_unary_minusÝ : Z_EXP
val Ûz_bool_notÝ : Z_EXP
val Ûz_absÝ : Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Z Binary Expressions}

¹Z
Ü	Z_BIN_OP ::= z_bool_and | z_bool_or | z_bool_xor | z_bool_eq | z_bool_noteq |
Ü	z_bool_less | z_bool_less_eq | z_bool_greater | z_bool_greater_eq | z_add |
Ü	z_minus | z_times | z_intdiv | z_mod | z_rem | z_expon | z_bool_mem |
Ü	z_bool_notmem
°

ÿZ_Bin_Expüüüüüüüü
Ü	zop : Z_BIN_OP;
Ü	zleft, zright : Z_EXP
ˆüüüüüüüüüüü



=DOC
val Ûz_bool_andÝ : Z_EXP
val Ûz_bool_orÝ : Z_EXP
val Ûz_bool_xorÝ : Z_EXP
val Ûz_bool_eqÝ : Z_EXP
val Ûz_bool_noteqÝ : Z_EXP
val Ûz_bool_lessÝ : Z_EXP
val Ûz_bool_less_eqÝ : Z_EXP
val Ûz_bool_greaterÝ : Z_EXP
val Ûz_bool_greater_eqÝ : Z_EXP
val Ûz_addÝ : Z_EXP
val Ûz_minusÝ : Z_EXP
val Ûz_timesÝ : Z_EXP
val Ûz_intdivÝ : Z_EXP
val Ûz_modÝ : Z_EXP
val Ûz_remÝ : Z_EXP
val Ûz_exponÝ : Z_EXP
val Ûz_bool_memÝ : Z_EXP
val Ûz_bool_notmemÝ : Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Z Function Calls}
ÿZ_Fun_Callüüüüüüüü
Ü	zfun : Z_EXP;
Ü	zargs : seq Z_EXP
ˆüüüüüüüüüüü

\subsection{Z Binding Selections}
ÿZ_Selectionüüüüüüüü
Ü	zbinding : Z_EXP;
Ü	zselector : Z_ID
ˆüüüüüüüüüüü


\subsection{Z Expressions}


¹Z
Ü	[OTHER_Z_EXP]
°
¹Z
Ü	Z_EXP ::=
Ü	zsucc | zid Z_ID | z_num ú | z_tfun (Z_EXP ¸ Z_EXP) |
Ü	z_pfun (Z_EXP ¸ Z_EXP) | z_rng (Z_EXP ¸ Z_EXP) |
Ü	z_dom Z_EXP | z_dom_res (Z_EXP ¸ Z_EXP) | z_inv Z_EXP |
Ü	z_id_rel Z_EXP | z_size Z_EXP | z_set (ð Z_EXP) |
Ü	z_set_minus (Z_EXP ¸ Z_EXP) |
Ü	z_set_comp (Z_Decl ¸ Z_PRED) | z_power (Z_EXP ¸ Z_EXP) |
Ü	z_rel_comp (Z_EXP ¸ Z_EXP) |  TBS
°

=DOC
val ÛzsuccÝ : Z_EXP
val ÛzidÝ : CN_ENV -> Z_ID -> Z_EXP
val Ûz_numÝ : int -> Z_EXP
val Ûz_tfunÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_pfunÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_rngÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_domÝ : Z_EXP -> Z_EXP
val Ûz_dom_resÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_invÝ : Z_EXP -> Z_EXP
val Ûz_id_relÝ : Z_EXP -> Z_EXP
val Ûz_sizeÝ : Z_EXP -> Z_EXP
val Ûz_setÝ : Z_EXP list -> Z_EXP
val Ûz_set_minusÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_set_compÝ : (Z_DECL * Z_EXP) -> Z_EXP
val Ûz_powerÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_rel_compÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_seqÝ : Z_EXP list -> Z_EXP
val Ûz_crossÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_overrideÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_many_unionÝ : Z_EXP list -> Z_EXP
val Ûz_muÝ : CN_ENV -> Z_ID * Z_PRED -> Z_EXP
val Ûz_unary_expÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_bin_expÝ : (Z_EXP * Z_EXP * Z_EXP) -> Z_EXP
val Ûz_fun_callÝ : (Z_EXP * Z_EXP list) -> Z_EXP
val Ûz_selectionÝ : (Z_EXP * Z_ID) -> Z_EXP
val Ûz_mapletÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûother_z_expÝ : Z_EXP -> Z_EXP
val Ûz_eqÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_andÝ : (Z_PRED * Z_PRED) -> Z_PRED
val Ûz_many_andÝ : Z_PRED list -> Z_PRED
val Ûz_elemÝ : (Z_EXP * Z_EXP) -> Z_EXP
val Ûz_noteqÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_less_eqÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_greaterÝ : (Z_EXP * Z_EXP) -> Z_PRED
val Ûz_forallÝ : (Z_DECL list * Z_PRED) -> Z_PRED
val Ûz_impÝ : (Z_PRED * Z_PRED) -> Z_PRED
val Ûother_z_predÝ : Z_PRED -> Z_PRED
val Ûz_eq_eqÝ : (Z_ID * Z_EXP) -> PARAINFO
val Ûz_schemaÝ : (Z_ID * Z_DECL list) -> PARAINFO
=DESCRIBE
=ENDDOC

\subsection{Z Schemas}

ÿZ_Schemaüüüüüüüü
Ü	z_sname : Z_ID;
Ü	z_decls : ð Z_Decl
ˆüüüüüüüüüüüüü




\section{TRANSLATING SPARK EXPRESSIONS}

\subsection{The Function trans\_exp}
¹ZAX
Ü	trans_exp : EXP ­ Z_EXP
°

ÿExp_Parsüüüüüüüüüüüüüüüüüü
Ü	expr : EXP;
Ü	zexpr : Z_EXP
ˆüüüüüüüüüüüüüüüüüü


\subsection{Translating Identifiers}
¹ZAX
Ü	trans_id : ID ­ Z_ID
°

=DOC
val Ûtrans_idÝ : ID -> Z_ID
=DESCRIBE
=ENDDOC

ÿExp_Idüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ ident : ID · expr = Id ident ± zexpr = zid(trans_id ident)
ˆüüüüüüüüüüüüüüüüüü

\subsection{Translating Aggregates (Positional Array)}

¹Z
Ü	zfst ¦ trans_id fst
°
¹Z
Ü	zlst ¦ trans_id lst
°
¹Z
Ü	zsuc ¦ trans_id suc
°
¹Z
Ü	zpred ¦ trans_id pred
°
¹Z
Ü	zpos ¦ trans_id pos
°
¹Z
Ü	zval ¦ trans_id val
°
¹Z
Ü	zlength ¦ trans_id length
°
¹Z
Ü	zrange ¦ trans_id range
°
=DOC
val ÛzfstÝ : Z_ID
val ÛzlstÝ : Z_ID
val ÛzsucÝ : Z_ID
val ÛzpredÝ : Z_ID
val ÛzposÝ : Z_ID
val ÛzvalÝ : Z_ID
val ÛzlengthÝ : Z_ID
val ÛzrangeÝ : Z_ID
=DESCRIBE
=ENDDOC

¹Z
Ü	fun 3	_ ^ _
°

¹ZAX
Ü	_ ^ _ : (Z_ID ¸ Z_ID) ­ Z_ID
°

=DOC
val Û^^Ý : Z_ID * Z_ID -> Z_ID
=DESCRIBE
=ENDDOC


This function already exists in {\Product} and is called $map$.

[X, Y]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	map : (X ­ Y) ­ seq X ­ seq Y
÷üüüüüüüüüüüüüüüüüüüüü
Ü	µ f : X ­ Y; s : seq X ·
Ü	map f s = { i : ú; x : X | (i, x)  s · (i, f x)}
ˆüüüüüüüüüüüüüüüüüüüüüü

ÿExp_Array_Agg_Posüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Agg_Pos; Z_Bin_Exp; zseq : seq Z_EXP ·
Ü	expr = array_agg_pos (Ê Agg_Pos) ± zop = z_minus ±
Ü	zleft = z_num 1 ± zright = zid (trans_id tmark ^ zfst) ±
Ü	zseq = map trans_exp comps ±
Ü	zexpr =
Ü	z_rel_comp(z_power(zsucc, z_bin_exp(ÊZ_Bin_Exp)), z_seq zseq)
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_array_agg_posÝ : CN_ENV -> EXP AGG_POS -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Aggregates (Positional Array with Others)}

ÿExp_Array_Agg_Pos_Othersüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Agg_Pos_Others  ·
Ü	expr = array_agg_pos_others (Ê Agg_Pos_Others) ±
Ü	zexpr =
Ü	z_override
Ü	(trans_exp (array_agg_others (Ê Agg_Others)),
Ü	trans_exp (array_agg_pos (Ê Agg_Pos)))
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_array_agg_pos_othersÝ : CN_ENV -> EXP AGG_POS_OTHERS -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Aggregates (Positional Array with Just Others)}

ÿExp_Array_Agg_Othersüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Agg_Others  ·
Ü	expr = array_agg_others (Ê Agg_Others) ±
Ü	zexpr =
Ü	z_cross
Ü	(zid(trans_id tmark ^ zrange), z_set {trans_exp others} )
ˆüüüüüüüüüüüüüüüüüü


=DOC
val Ûexp_array_agg_othersÝ : CN_ENV -> EXP AGG_OTHERS -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Aggregates (Named Array)}

¹ZAX
Ü	trans_named_assoc : Named_Assoc ­ Z_EXP
÷üüüüüüüü
Ü   µ Named_Assoc ·
Ü	¶ zranges : ð Z_EXP; zsingles : Z_EXP ·
Ü	zranges =
Ü	{ Range | agg_choice_range (Ê Range)  choices ·
Ü		z_rng(trans_exp lo, trans_exp hi)} ±
Ü	zsingles =
Ü	z_set
Ü	{ ex : EXP | agg_choice_single ex  choices · trans_exp ex} ±
Ü	trans_named_assoc (Ê Named_Assoc) =
Ü	z_cross
Ü	(z_many_union(zranges À {zsingles}), z_set {trans_exp comp} )
°




ÿExp_Array_Agg_Namedüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Agg_Others  ·
Ü	expr = array_agg_named (Ê Agg_Named) ±
Ü	zexpr =
Ü	z_many_union
Ü	(trans_named_assoc ¨ named_assocs © )
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_array_agg_namedÝ : CN_ENV -> (AGG_CHOICE, EXP) AGG_NAMED -> Z_EXP
=DESCRIBE
=ENDDOC
\subsection{Translating Aggregates (Named Array with Others)}

ÿExp_Array_Agg_Named_Othersüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Agg_Named_Others ·
Ü	expr = array_agg_named_others (Ê Agg_Named_Others) ±
Ü	zexpr =
Ü	z_override
Ü	(trans_exp (array_agg_others (Ê Agg_Others)),
Ü	trans_exp (array_agg_named (Ê Agg_Named)))
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_array_agg_named_othersÝ : CN_ENV -> (AGG_CHOICE, EXP) AGG_NAMED_OTHERS -> Z_EXP
=DESCRIBE
=ENDDOC
\subsection{Translating Aggregates (Positional Record)}

¹ZAX
Ü	retrieve_type_def : TMARK ­ TYPE_DEF
°

=DOC
val Ûretrieve_record_componentsÝ : CN_ENV -> TMARK -> (TMARK * TYPE) list
=DESCRIBE
=ENDDOC

ÿExp_Rec_Agg_Posüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Agg_Pos; Record_Type_Def; zp : Z_PRED ·
Ü	expr = rec_agg_pos (Ê Agg_Pos) ±
Ü	retrieve_type_mark tmark = record_type_def (Ê Record_Type_Def) ±
Ü	zp =
Ü	z_many_and
Ü	{ i : dom decl ·
Ü	   z_eq(zid(trans_id (decl i).var), trans_exp (comps i))} ±
Ü	zexpr = z_mu(trans_id tmark, zp)
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_rec_agg_pos_zÝ : CN_ENV -> TMARK * Z_EXP list -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Aggregates (Named Record)}

ÿExp_Rec_Agg_Namedüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Rec_Agg_Named; zp : Z_PRED ·
Ü	expr = rec_agg_named (Ê Rec_Agg_Named) ±
Ü	zp =
Ü	z_many_and
Ü	{ ident : ID; ex : EXP | (ident, ex)  named_assocs ·
Ü	   z_eq(zid(trans_id ident), trans_exp ex)} ±
Ü	zexpr = z_mu(trans_id tmark, zp)
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_rec_agg_namedÝ : CN_ENV -> (AGG_CHOICE, EXP) REC_AGG_NAMED -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Unary Expressions}

¹Z
Ü	trans_unary_op ¦
Ü	{ spark_unary_minus í z_unary_minus, spark_not í z_bool_not,
Ü		spark_abs í z_abs }
°

ÿExp_Unary_Expüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Unary_Exp; Z_Unary_Exp ·
Ü	expr = unary_exp (Ê Unary_Exp) ±
Ü	(op = spark_unary_add ± z_expr = trans_exp right ²
Ü	op ½ spark_unary_add ± zop = trans_unary_op op ±
Ü	zright = trans_exp right ± zexpr = z_unary_exp (Ê Z_Unary_Exp))
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_unary_expÝ : CN_ENV -> EXP UNARY_EXP -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Binary Expressions}

¹Z
Ü	trans_bin_op ¦
Ü	{ spark_and í z_bool_and, spark_or í z_bool_or, spark_xor í z_bool_xor,
Ü	spark_eq í z_bool_eq, spark_noteq í z_bool_noteq,
Ü	spark_less í z_bool_less, spark_less_eq í z_bool_less_eq,
Ü	spark_greater í z_bool_greater, spark_greater_eq í z_bool_greater_eq,
Ü	spark_add í z_add, spark_minus í z_minus, spark_times í z_times,
Ü	spark_intdiv í z_intdiv, spark_mod í z_mod, spark_rem í z_rem,
Ü	spark_expon í z_expon, spark_mem í z_bool_mem,
Ü	spark_notmem í z_bool_notmem }
°

ÿExp_Bin_Expüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Bin_Exp; Z_Bin_Exp ·
Ü	expr = bin_exp (Ê Bin_Exp) ± zop = trans_bin_op op ±
Ü	zleft = trans_exp left ± zright = trans_exp right ±
Ü	zexpr = z_bin_exp (Ê Z_Bin_Exp)
ˆüüüüüüüüüüüüüüüüüü


=DOC
val Ûexp_bin_expÝ : CN_ENV -> EXP BIN_EXP -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Membership of a Range}

ÿExp_Mem_Rangeüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Mem_Range; Z_Bin_Exp ·
Ü	expr = mem_range (Ê Mem_Range) ± zop = trans_bin_op op ±
Ü	zleft = trans_exp left ± zright = z_rng (trans_exp lo, trans_exp hi) ±
Ü	zexpr = z_bin_exp (Ê Z_Bin_Exp)
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_mem_rangeÝ : CN_ENV -> EXP MEM_RANGE -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Attributes}

ÿExp_Attribüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB ·
Ü	expr = attribute (Ê Attribute) ± attrib_desig = attrib att ±
Ü	zexpr = zid (trans_id prefix ^ trans_id att)
ˆüüüüüüüüüüüüüüüüüü

ÿExp_Attrib_Argüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Attribute; att : ATTRIB; arg : EXP; Z_Fun_Call ·
Ü	expr = attribute (Ê Attribute) ± attrib_desig = attrib_arg(att,arg) ±
Ü	zexpr = z_fun_call (Ê Z_Fun_Call) ±
Ü	zfun = zid (trans_id prefix ^ trans_id att) ± zargs = § trans_exp arg ¢
ˆüüüüüüüüüüüüüüüüüü


=DOC
val Ûexp_attribÝ : CN_ENV -> (EXP, ATTRIB_DESIG) ATTRIBUTE -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Indexed Components}

ÿExp_Indexed_Compüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Indexed_Comp; Z_Fun_Call ·
Ü	expr = indexed_comp (Ê Indexed_Comp) ± zfun = trans_exp prefix ±
Ü	zargs = § trans_exp index ¢ ± zexpr = z_fun_call (Ê Z_Fun_Call)
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_indexed_compÝ : CN_ENV -> EXP INDEXED_COMP -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Selected Components}

ÿExp_Selected_Compüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Selected_Comp; Z_Selection ·
Ü	expr = selected_comp (Ê Selected_Comp) ±
Ü	zbinding = trans_exp prefix ± zselector = trans_id selector ±
Ü	zexpr = z_selection (Ê Z_Selection)
ˆüüüüüüüüüüüüüüüüüü


=DOC
val Ûexp_selected_compÝ : CN_ENV -> EXP SELECTED_COMP -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Functions Calls}

ÿExp_Fun_Callüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ Fun_Call; Z_Fun_Call ·
Ü	expr = fun_call (Ê Fun_Call) ± zfun = zid (trans_id fun_name) ±
Ü	zargs = map trans_exp args ± zexpr = z_fun_call (Ê Z_Fun_Call)
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_fun_callÝ : CN_ENV -> EXP FUN_CALL -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{Translating Integer Literals}

¹ZAX
Ü	trans_int : INT_LIST ­ ú
°

ÿExp_Int_Litüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ n : INT_LIT ·
Ü	expr = int n ± zexpr = z_num (trans_int n)
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_int_litÝ : INT_LIT -> Z_EXP
=DESCRIBE
=DESCRIBE
=ENDDOC
\subsection{Translating Auxiliary Expressions}

ÿExp_Auxiliary_Expüüüüüüüüüüüüüüüüüü
Ü	Exp_Pars
÷üüüüüüüü
Ü	¶ ze : Z_EXP ·
Ü	expr = auxiliary_exp ze ± zexpr = ze
ˆüüüüüüüüüüüüüüüüüü

=DOC
val Ûexp_auxiliary_expÝ : ZUserInterfaceSupport.Z_TM -> Z_EXP
=DESCRIBE
=ENDDOC

\subsection{The Function $trans\_exp$}
¹Z
Ü	µ Exp_Pars ·
Ü	trans_exp expr = zexpr ¤
Ü		Exp_Id ² Exp_Int_Lit ² Exp_Array_Agg_Pos ²
Ü		Exp_Array_Agg_Pos_Others ² Exp_Array_Agg_Others ²
Ü		Exp_Array_Agg_Named ² Exp_Array_Agg_Named_Others ²
Ü		Exp_Rec_Agg_Pos ² Exp_Rec_Agg_Named ² Exp_Unary_Exp ²
Ü		Exp_Bin_Exp ² Exp_Mem_Range ² Exp_Attrib ² Exp_Attrib_Arg ²
Ü		Exp_Indexed_Comp ² Exp_Selected_Comp ² Exp_Fun_Call ²
Ü		Exp_Auxiliary_Exp
°

=DOC
val Ûtrans_expÝ : CN_ENV -> EXP -> Z_EXP
=DESCRIBE
=ENDDOC

\section{TRANSLATING SPARK BASIC DECLARATIONS}

ÿBasic_Decl_Parsüüüüüüüüüüüüüüüüü
Ü	basic_decl : BASIC_DECL;
Ü	z : seq Z_PARA
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Translating Constants}

ÿBasic_Decl_Constüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Const_Decl ·
Ü	basic_decl = const_decl (Ê Const_Decl) ±
Ü	z = §z_eq_eq(trans_id const, trans_exp expr)¢
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_constÝ : CN_ENV -> EXP CONST_DECL -> PARAINFO list
=DESCRIBE
=ENDDOC

\subsection{Translating Enumeration Types}

¹ZAX
Ü	enum_attrib : (Z_ID ¸ Z_ID ¸ Z_ID) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2, zid‰3 : Z_ID ·
Ü ¶ zexp : Z_EXP ·
Ü	zexp = z_set_minus(zid zid‰1, z_set {zid (zid‰1 ^ zlst)}) ±
Ü	enum_attrib (zid‰1, zid‰2, zid‰3) =
Ü		§z_eq_eq(zid‰1 ^ zfst, zid zid‰2),
Ü		z_eq_eq(zid‰1 ^ zlst, zid zid‰3),
Ü		z_eq_eq(zid‰1 ^ zsuc, z_dom_res(zexp, zsucc)),
Ü		z_eq_eq(zid‰1 ^ zpred, z_inv(zid (zid‰1 ^ zsuc))),
Ü		z_eq_eq(zid‰1 ^ zpos, z_id_rel (zid zid‰1)),
Ü		z_eq_eq(zid‰1 ^ zval, z_inv(zid(zid‰1 ^ zpos)))¢
°


ÿBasic_Decl_Enumüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Enum_Type_Def; zname : Z_ID;
Ü   zvals : seq Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = enum_type_def (Ê Enum_Type_Def) ±
Ü	zname = trans_id name ± zvals = map trans_id vals ±
Ü	z =
Ü	{ i : dom vals · i í z_eq_eq(zvals i, z_num(i-1))} ^
Ü		§z_eq_eq(zname, z_rng(zid(head zvals), zid(last zvals)))¢ ^
Ü		enum_attrib(zname, head zvals, last zvals)
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_enumÝ : CN_ENV -> ID -> ENUM_TYPE_DEF -> PARAINFO list
=DESCRIBE
=ENDDOC

\subsection{Translating Array Types}

¹ZAX
Ü	array_attrib : (Z_ID ¸ Z_ID) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2 : Z_ID ·
Ü	array_attrib (zid‰1, zid‰2) =
Ü		§z_eq_eq(zid‰1 ^ zfst, zid (zid‰2 ^ zfst)),
Ü		z_eq_eq(zid‰1 ^ zlst, zid (zid‰2 ^ zlst)),
Ü		z_eq_eq(zid‰1 ^ zlength, z_size (zid zid‰2)),
Ü		z_eq_eq(zid‰1 ^ zrange, zid zid‰2)¢
°

ÿBasic_Decl_Array_Parsüüüüüüüüüüüüüüüüü
Ü	Type_Decl;
Ü	Array_Def;
Ü	zname, zindex, zcomp : Z_ID
÷üüüüüüüüüüüüü
Ü	zname = trans_id name;
Ü	zindex = trans_id index;
Ü	zcomp = trans_id comp
ˆüüüüüüüüüüüüüüüüüüüü


ÿBasic_Decl_Con_Arrayüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Basic_Decl_Array_Pars ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = con_array_def (Ê Array_Def) ±
Ü	z =
Ü	§z_eq_eq (zname, z_tfun(zid zindex, zid zcomp))¢ ^
Ü		array_attrib(zname, zindex)
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_con_arrayÝ : CN_ENV -> ID -> ARRAY_DEF -> PARAINFO list
=DESCRIBE
=ENDDOC


ÿBasic_Decl_Uncon_Arrayüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Basic_Decl_Array_Pars ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = uncon_array_def (Ê Array_Def) ±
Ü	z =
Ü	§z_eq_eq (zname, z_pfun(zid zindex, zid zcomp))¢
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_uncon_arrayÝ : CN_ENV -> ID -> ARRAY_DEF -> PARAINFO list
=DESCRIBE
=ENDDOC

\subsection{Translating Record Types}

¹ZAX
Ü	trans_decl : Var_Decl ­ Z_Decl
÷üüüüüüüüüüüüü
Ü µ Var_Decl; Z_Decl ·
Ü	trans_decl (Ê Var_Decl) = Ê Z_Decl ¤
Ü		zvar = trans_id var ± zexp = zid (trans_id tmark)
Ü		
°

=DOC
val Ûtrans_declÝ : CN_ENV -> {var : ID, tmark : TMARK} -> Z_DECL
=DESCRIBE
=ENDDOC

ÿBasic_Decl_Recordüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü	¶ Type_Decl; rec : Record_Type_Def; Z_Schema ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = record_type_def rec ± z_sname = trans_id name ±
Ü	z_decls = trans_decl ¨ ran rec.decl © ±
Ü	z = §z_schema (Ê Z_Schema)¢
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_recordÝ : CN_ENV -> ID -> COMPONENT RECORD_TYPE_DEF -> PARAINFO list
=DESCRIBE
=ENDDOC

\subsection{Translating Integer Types}

¹ZAX
Ü	int_type_attrib : (Z_ID ¸ Range) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1 : Z_ID; Range ·
Ü	int_type_attrib (zid‰1, Ê Range) =
Ü		§z_eq_eq(zid‰1 ^ zfst, trans_exp lo),
Ü		z_eq_eq(zid‰1 ^ zlst, trans_exp hi)¢
°


ÿBasic_Decl_Int_Typeüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Type_Decl; Range; zname : Z_ID ·
Ü	basic_decl = type_decl (Ê Type_Decl) ±
Ü	type_def = int_type_def (Ê Range) ±
Ü	zname = trans_id name
Ü	z =
Ü	§z_eq_eq(zname, z_rng(trans_exp lo, trans_exp hi))¢ ^
Ü		int_type_attrib(zname, Ê Range)
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_int_typeÝ : CN_ENV -> ID -> EXP RANGE -> PARAINFO list
=DESCRIBE
=ENDDOC


\subsection{Translating Subtypes}

¹ZAX
Ü	range_con_attrib : (Z_ID ¸ Z_ID ¸ Range) ­ seq Z_PARA
÷üüüüüüüüüüüüü
Ü µ zid‰1, zid‰2 : Z_ID; Range ·
Ü ¶ zexp : Z_EXP ·
Ü	range_con_attrib (zid‰1, zid‰2, Ê Range) =
Ü		§z_eq_eq(zid‰1 ^ zfst, trans_exp lo),
Ü		z_eq_eq(zid‰1 ^ zlst, trans_exp hi),
Ü		z_eq_eq(zid‰1 ^ zsuc, zid(zid‰2 ^ zsuc)),
Ü		z_eq_eq(zid‰1 ^ zpred, zid(zid‰2 ^ zpred)),
Ü		z_eq_eq(zid‰1 ^ zpos, zid (zid‰2 ^ zpos)),
Ü		z_eq_eq(zid‰1 ^ zval, zid(zid‰2 ^ zval))¢
°

ÿBasic_Decl_Subtype_Range_Conüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; Range; zname, ztmark : Z_ID ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = range_con (Ê Range) ± zname = trans_id name ±
Ü	ztmark = trans_id tmark ±
Ü	z =
Ü	§z_eq_eq (zname, z_rng (trans_exp lo, trans_exp hi)) ¢ ^
Ü		range_con_attrib(zname, ztmark, Ê Range)
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_subtype_range_conÝ : CN_ENV -> ID -> TMARK -> EXP RANGE -> PARAINFO list
=DESCRIBE
=ENDDOC


ÿBasic_Decl_Subtype_Index_Conüüüüüüüüüüüüüüüüü
Ü	Basic_Decl_Pars
÷üüüüüüüüüüüüü
Ü ¶ Subtype_Decl; index : TMARK; Z_Decl;
Ü   zname, zindex : Z_ID; zp : Z_PRED ·
Ü	basic_decl = subtype_decl (Ê Subtype_Decl) ±
Ü	con = range_con (Ê Range) ± zname = trans_id name ±
Ü	ztmark = trans_id tmark ±
Ü	z =
Ü	§z_eq_eq (zname, z_rng (trans_exp lo, trans_exp hi)) ¢ ^
Ü		range_con_attrib(zname, ztmark, Ê Range)
ˆüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûbasic_decl_subtype_index_conÝ : CN_ENV -> ID -> TMARK -> EXP list -> PARAINFO list
=DESCRIBE
=ENDDOC

\subsection{The Function $trans\_basic\_decl$}

¹Z
Ü µ Basic_Decl_Pars ·
Ü	trans_basic_decl basic_decl = z ¤
Ü		Basic_Decl_Const ² Basic_Decl_Enum ²
Ü		Baic_Decl_Int_Type ² Basic_Decl_Con_Array ²
Ü		Basic_Decl_Uncon_Array ² Basic_Decl_Record ²
Ü		Basic_Decl_Subtype_Range_Con ²
Ü		Basic_Decl_Subtype_Index_Con
°

=DOC
val Ûtrans_basic_declÝ : CN_ENV -> BASIC_DECL -> PARAINFO list
=DESCRIBE
=ENDDOC
\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}


=DOC
val Ûnamed_assocs_to_expsÝ : ID list -> (AGG_CHOICE,EXP) NAMED_ASSOC list -> EXP list
=DESCRIBE
=ENDDOC

=DOC
val Ûadjust_expÝ : CN_ENV -> EXP -> EXP
=DESCRIBE
=ENDDOC

\section{EPILOGUE}

=SML
end (* local...in *);
end (* signature CNBasicDeclsAndExprs *);
=TEX


=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



