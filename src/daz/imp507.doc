% imp507.doc %Z% $Revision: 1.181 $ $RCSfile: imp507.doc,v $ $Date: 2002/01/29 19:02:49 $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP507}  %% Mandatory field
\def\SCCSversion{$Revision: 1.181 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/01/29 19:02:49 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\raggedright{\TPPabstract{This document contains the implementation for the Z generation functions of Volume 1 of DRA's specification.}}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz,hatdocs}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1-1.55 ] Initial Drafts.
\item[Issues 1.56] First cut with code for auxiliary variables in the environments.
\item[Issue 1.57] Corrected sequencing for some of the auxiliary variable SID functions.
\item[Issue 1.58] Debugged auxiliary variable code.
\item[Issues 1.59-1.61] Updates for integration with VC browser.
\item[Issues 1.62-1.87] Various bug fixes
\item[Issues 1.87-1.89] Annotations and pragmas (enhancements 1 and 20)
\item[Issue 1.90] Enhancements 5 and 7 plus fix of bug 17 (batch 2).
\item[Issue 1.91] Enhancements 10.
\item[Issue 1.92] Fixed bug 3 (batch 2).
\item[Issue 1.93-1.94] Fixed bug 4 (batch 2) and made $new\_parent\_aux$ less plaintive.
\item[Issue 1.95] Fixed bugs 10 and 11 (batch 2).
\item[Issue 1.96] Fixed bug 18 (batch 2).
\item[Issue 1.97] Enhancement 13.
\item[Issue 1.98-1.103] Bug-fixing of enhancements.
\item[Issues 1.104,1.105] Enhancements 3 and 18 (and a fairly major rework of the funcitons which support $new\_scope\_with$).
\item[Issues 1.106,1.107] Tidy-up
\item[Issues 1.108] fix to $form\_proc\_pack\_body\_common$.
\item[Issue 1.109] made it include auxiliary variables in the type inference context.
\item[Issues 1.110-1.113] fixing context handling in $form\_proc$ $till\_pred$ etc.
\item[Issue 1.114] bug 6 (V0.6).
\item[Issue 1.115] Fixed omitted prefixing of parameter specifications (revealed by fixing bug 4 (V0.6) and running the integration tests (INT508).
Also implemented remedies for issues 1 and 4 (V0.6).
\item[Issue 1.116] Fixed wrong error message in $do\_stmt$..
\item[Issue 1.117] Syntax changes.
\item[Issue 1.118] Fixed bug 2 (V0.7).
\item[Issue 1.119] Correcting IUCT project WP8, bug 1.
\item[Issue 1.120-1.121] Added $new\_script1$ for IUCT project WP 1.
\item[Issue 1.122] Fixing Bug 4.3 of INT502.
\item[Issue 1.123] Fixing bug 6.1 of INT502.
\item[Issue 1.124] Fixing $is\_id\_in\_package$.
\item[Issue 1.125-126] Improved prefixing functions.
\item[Issue 1.127-1.128] IUCT WP7 changes.
\item[Issue 1.129 - 1.130] Changes for IUCT WP 2.
\item[Issue 1.131-1.132] Further IUCT WP7 changes.
\item[Issue 1.133] Fixing prefixing bugs.
\item[Issue 1.134] Type checking procedures and functions at declaration.
\item[Issue 1.135] Prefixing paramater specifications.
\item[Issue 1.136-137] IUCT WP 3 changes and further use of update functions.
\item[Issue 1.138] IUCT WP 5 changes and further use of update functions.
\item[Issue 1.139] Improved handling of prefixing Z paragraphs.
\item[Issue 1.141] References clauses package names must now be present, else a
failure (not comment) is raised).
\item[Issue 1.143] Changed format of warning VC.
\item[Issue 1.144] Corrected bug in prefixing of functions.
\item[Issue 1.145] Typos affecting LaTeX only.
\item[Issue 1.146-1.150] Changes for IUCT WP 4 (and final removal
of $pack\_spec\_with\_modules$ for WP 3).
\item[Issue 1.151] Fixed bug in $vcs\_aux\_initial$.
\item[Issue 1.152] Addressing frame widening issue (issue 4, v0.7.3).
\item[Issue 1.153] Adding calls to do check 16.
\item[Issue 1.154] Included check 16 calls for specification statements as statements (to catch cases where formality has been broken).
\item[Issue 1.155] Typo revealed by LaTeX.
\item[Issue 1.155] Prototyping enhancement R5: Initial Variables in Conditionals.
\item[Issue 1.156-1.160] Prototyping enhancement R4: Frame Abbreviations.
\item[Issue 1.161] Improving error-detection for specification statements: dummy
calls on the VC generator are made whenever a specification statement is processed
in a context where VC generation is not carried out immediately. This makes sure
that the checks on free variables etc. are made.
\item[Issue 1.162,1.163] Fixed {\it is\_id\_in\_package} and many other related fixes
including a major rewrite of {\it store\_prefix\_const\_thms} to remove a flaw
in its treatment of generics. Improved approach to early checking of specification
statements in stubs.
\item[Issue 1.164] Fixed {\it vcs\_speclabel\_aux}.
\item[Issue 1.165] Fixed {\LaTeX} error.
\item[Issue 1.166] CTLE II R1/2: reverse loops.
\item[Issue 1.167] CTLE II R1/10: multiple with clauses (causes a minor change to syntax).
\item[Issue 1.168] CTLE II R1/9: SPARK 83 attributes.
\item[Issues 1.169,1.170] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.171,1.172] CTLE II R1/11: nested packages.
\item[Issue 1.173] Perfomance enhancement for type-checking of specification statements.
\item[Issue 1.174] R0021: domain condition generation.
\item[Issue 1.175] Schema references now accepted in global dependencies of a function.
\item[Issue 1.176] R0037: support for named numbers.
\item[Issue 1.177-1.182] Further work on Autumn 2001 enhancements programme.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
Sections \ref{BASICDECLARATIONS} to \ref{WEBCLAUSES} implement the material defined in the corresponding sections of \cite{ISS/HAT/DAZ/DTD507}. Section \ref{PREAMBLE} contains various material which supports this, e.g. the component update functions and initial environment values of \cite{ISS/HAT/DAZ/DTD513}. Because the implementations of the component update functions are rather long-winded, they are all given together and the other material is not interleaved with them.
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD507}.
=TEX
\section{PREAMBLE AND AUXILIARIES}\label{PREAMBLE}
=SML
structure €CNZGenerator› : CNZGenerator = struct
=SML
open CNTypes CNTypes1 CNTypes2 CNBasicDeclsAndExprs ZParagraphs
	CNVCGenerator CNParser ZUserInterfaceSupport TypeInference ;
=TEX

The following function returns the current level for the specified theory.  This is used as an index to order objects being added to the theory.

=SML
val €current_level› : unit -> int =
	(#current_level o #contents o icl'Kernel.icl'get_theory_info o
		get_current_theory_name);
=TEX

The following functions are used to identify names for web clauses and are used in the naming of VCs.

=SML
fun €k_slot_name› ({content, label} : K_SLOT) : string = "kslot"^label;
fun €package_declaration_name›
	({name, ...} : DECLARATION PACKAGE_DECLARATION)
	: string = (
	name ^ "spec"
);
fun €procedure_specification_name›
	({name, ...} : PROCEDURE_SPECIFICATION) : string = (
	name
);
fun €function_specification_name›
	({designator, ...} : FUNCTION_SPECIFICATION) : string = (
	designator
);

fun €procedure_body_name› ({procedure_spec, ...} : DECLARATION PROCEDURE_BODY)
	: string = (
	procedure_specification_name procedure_spec
);
fun €function_body_name› ({function_spec,...} : DECLARATION FUNCTION_BODY)
	: string = (
	function_specification_name function_spec
);
fun €package_body_name› ({name, ...} : DECLARATION PACKAGE_BODY) : string = (
	name ^ "body"
);
=TEX
=SML
fun €proper_body_name› (pb : PROPER_BODY) : string = (
	case pb of
		PBProcedure prc => procedure_body_name prc
	|	PBFunction fnc =>  function_body_name fnc
	|	PBPackage pck => package_body_name pck
);
fun €subunit_name› ({name, proper_body} : COMP_SUBUNIT) : string = (
	name ^ "o" ^ proper_body_name proper_body
);
fun €compilation_unit_name› (cu : COMPILATION_UNIT) : string = (
	case cu of
		CUPackageDeclaration d => package_declaration_name d
	|	CUProperBody b => proper_body_name b
	|	CUSubUnit s => subunit_name s
);

fun €context_compilation_unit_name›
	({comp_unit, ...} : CONTEXT_COMPILATION_UNIT) = (
	compilation_unit_name comp_unit
);
fun €kslot_compilation_unit_name› (kcu : KSLOT_COMPILATION_UNIT) : string = (
	case kcu of
		KCUKSlot ks => k_slot_name ks
	|	KCUUnit ccu => context_compilation_unit_name ccu
	|	KCUPragma ccu => "<pragma>"
);
=TEX
\subsection{Making Z Predicates}
In some places, we need to form the HOL term corresponding to a Z predicate.
This may require coercion of a schema into a predicate:
=SML
fun €z_pred_of_z_tm› (zt : Z_TM) : Z_PRED = (
	let	val tm = z_predexp_of_z_tm zt;
	in	if	type_of tm =: BOOL
		then	tm
		else	mk_z_schema_pred (tm, "")
	end
);
=TEX
\subsection{Component Update Functions}
=SML
fun €package_vc_vars› (
	{vc_vars, consts_types, formal_procs, informal_funs ,
		formal_funs, aux_vars, zmod}
	: PACKAGE,
	new_vc_vars : VAR_DECL list) : PACKAGE = (
	{	vc_vars				=	new_vc_vars,
		consts_types			=	consts_types,
		formal_procs			=	formal_procs,
		informal_funs			=	informal_funs,
		formal_funs			=	formal_funs,
		aux_vars			=	aux_vars,	
		zmod				=	zmod
	}	
);
=TEX
=SML
fun €package_consts_types› (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars, zmod}
	: PACKAGE,
	new_consts_types : BASIC_DECL list) : PACKAGE = (
	{	vc_vars				=	vc_vars,
		consts_types			=	new_consts_types,
		formal_procs			=	formal_procs,
		informal_funs			=	informal_funs,
		formal_funs			=	formal_funs,	
		aux_vars			=	aux_vars,	
		zmod				=	zmod
	}	
);
=TEX
=SML
fun €package_formal_procs› (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars, zmod}
	: PACKAGE,
	new_formal_procs : FORMAL_PROC list) : PACKAGE = (
	{	vc_vars				=	vc_vars,
		consts_types			=	consts_types,
		formal_procs			=	new_formal_procs,
		informal_funs			=	informal_funs,
		formal_funs			=	formal_funs,	
		aux_vars			=	aux_vars,	
		zmod				=	zmod
	}
);
=TEX
=SML
fun €package_informal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars, zmod}
	: PACKAGE,
	new_informal_funs : INFORMAL_FUN list) : PACKAGE = (
	{	vc_vars				=	vc_vars,
		consts_types			=	consts_types,
		formal_procs			=	formal_procs,
		informal_funs			=	new_informal_funs,
		formal_funs			=	formal_funs,	
		aux_vars			=	aux_vars,	
		zmod				=	zmod
	}
);
=TEX
=SML
fun €package_formal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars, zmod}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars				=	vc_vars,
		consts_types			=	consts_types,
		formal_procs			=	formal_procs,
		informal_funs			=	informal_funs,
		formal_funs			=	new_formal_funs,	
		aux_vars			=	aux_vars,	
		zmod				=	zmod
	}
);
=TEX
=SML
fun €package_aux_vars› (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars, zmod}
	: PACKAGE,
	new_aux_vars : Z_DECL list) : PACKAGE = (
	{	vc_vars				=	vc_vars,
		consts_types			=	consts_types,
		formal_procs			=	formal_procs,
		informal_funs			=	informal_funs,
		formal_funs			=	formal_funs,
		aux_vars			=	new_aux_vars,	
		zmod				=	zmod
	}	
);
=TEX
=SML
fun €in_scope_vc_vars› ({vc_vars = vc_vars,
		vc_pars = vc_pars,
		vc_log_cons = vc_log_cons,
		vc_aux_vars = vc_aux_vars,
		formal_procs = formal_procs,
		dec_labels = dec_labels} : IN_SCOPE, 
	new_vc_vars : VAR_DECL list) : IN_SCOPE = (
		{vc_vars = new_vc_vars,
		vc_pars = vc_pars,
		vc_log_cons = vc_log_cons,
		vc_aux_vars = vc_aux_vars,
		formal_procs = formal_procs,
		dec_labels = dec_labels}
);
=TEX

=SML
fun €subunit_vc_vars›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope,
		globs
	} : SUBUNIT,
	new_vc_vars : VAR_DECL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope	=	in_scope_vc_vars(in_scope, new_vc_vars),
		globs		=	globs
	}
);
=TEX
=SML
fun €subunit_formal_procs›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels},
		globs
	} : SUBUNIT,
	new_formal_procs : FORMAL_PROC list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		},
		globs		=	globs
	}
);
=TEX
=SML
fun €subunit_dec_labels›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels},
		globs
	} : SUBUNIT,
	new_dec_labels : LABEL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		},
		globs		=	globs
	}
);
=TEX
=SML
fun €declab_declabel_flag›  (
	{	block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag, body_flag},
		in_scope
	} : DECLAB,
	new_declabel_flag : FLAG) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	{
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	new_declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag,
			body_flag		=	body_flag
		},
		in_scope	=	in_scope
	}
);
=TEX
=SML
fun €declab_vc_vars›  (
	{	block_name,
		flags,
		in_scope
	} : DECLAB,
	new_vc_vars : VAR_DECL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope	= in_scope_vc_vars(in_scope, new_vc_vars)
	}
);
=TEX
=SML
fun €declab_formal_procs›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : DECLAB,
	new_formal_procs : FORMAL_PROC list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			vc_aux_vars		=	vc_aux_vars,
			formal_procs		=	new_formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun €declab_dec_labels›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : DECLAB,
	new_dec_labels : LABEL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			vc_aux_vars		=	vc_aux_vars,
			formal_procs		=	formal_procs,
			dec_labels		=	new_dec_labels
		}
	}
);
=TEX
=SML
fun €speclab_w›  (
	{spec as {w, w0, pre, post},
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope
	} : SPECLAB,
	new_w : Z_ID list) : SPECLAB = (
	{spec 			=	{w = new_w, w0 = w0, pre = pre,
						post = post},
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	in_scope
	}
);
=TEX
=SML
fun €speclab_vc_vars›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope
	} : SPECLAB,
	new_vc_vars : VAR_DECL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	in_scope_vc_vars(in_scope, new_vc_vars)
	}
);
=TEX
=SML
fun €speclab_formal_procs›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SPECLAB,
	new_formal_procs : FORMAL_PROC list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}

	}
);
=TEX
=SML
fun €speclab_dec_labels›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SPECLAB,
	new_dec_labels : LABEL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}

	}
);
=TEX
=SML
fun €in_scope_vc_aux_vars› ({vc_vars = vc_vars,
		vc_pars = vc_pars,
		vc_log_cons = vc_log_cons,
		vc_aux_vars = vc_aux_vars,
		formal_procs = formal_procs,
		dec_labels = dec_labels} : IN_SCOPE, 
	new_vc_aux_vars : TERM list) : IN_SCOPE = (
		{vc_vars = vc_vars,
		vc_pars = vc_pars,
		vc_log_cons = vc_log_cons,
		vc_aux_vars = new_vc_aux_vars,
		formal_procs = formal_procs,
		dec_labels = dec_labels}
);
=TEX
We give various update functions that are not mentioned in the
specification, as well as the ones called for.
=SML
fun €block_declab›  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits
	} : BLOCK,
	new_declab : DECLAB) : BLOCK = (
	{declab		=	new_declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs,
	var_inits = var_inits
	}
);
=TEX
=SML
fun €block_flags›  (blk as 
	{
	declab as {block_name,
		flags,
		in_scope},
	...
	} : BLOCK,
	new_flags : FLAGS) : BLOCK = (
	block_declab(blk, 
		{block_name = block_name,
		flags = new_flags,
		in_scope = in_scope})
);
=TEX
=SML
fun €block_stub_flag›  (blk as
	{
	declab as {flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag, body_flag},
		...},
	...
	} : BLOCK,
	new_stub_flag : FLAG) : BLOCK = (
	block_flags(blk,
		 {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	new_stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag,
			body_flag		=	body_flag
		})
);
=TEX
=SML
fun €block_body_flag›  (blk as
	{
	declab as {flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag, body_flag},
		...},
	...
	} : BLOCK,
	new_body_flag : FLAG) : BLOCK = (
	block_flags(blk,
		 {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag,
			body_flag		=	new_body_flag
		})
);
=TEX
=SML
fun €block_till_flag›  (blk as 
	{
	declab as {flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag, body_flag},
		...},
	...
	} : BLOCK,
	new_till_flag : FLAG) : BLOCK = (
	block_flags(blk, 
		 {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	new_till_flag,
			body_flag		=	body_flag
		}
	)
);
=TEX
=SML
fun €block_vc_vars›  (blk as 
	{
	declab,
	...
	} : BLOCK,
	new_vc_vars : VAR_DECL list) : BLOCK = (
	block_declab (blk, declab_vc_vars (declab, new_vc_vars))
);
=TEX
=SML
fun €block_vc_pars›  (blk as 
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	...
	} : BLOCK,
	new_vc_pars : PARAM_SPEC list) : BLOCK = (
	block_declab(blk, 
		{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	new_vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}})
);
=TEX
=SML
fun €block_vc_log_cons›  (blk as
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	...
	} : BLOCK,
	new_vc_log_cons : Z_DECL list) : BLOCK = (
	block_declab(blk, 
		{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	new_vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}})
);
=TEX
=SML
fun €block_vc_aux_vars›  (blk as
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	...
	} : BLOCK,
	new_vc_aux_vars : Z_DECL list) : BLOCK = (
	block_declab(blk, 
		{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	new_vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}})
);
=TEX
=SML
fun €block_in_scope›  (blk as
	{
	declab as {block_name,
		flags,
		in_scope = _},
	...
	} : BLOCK,
	new_in_scope : IN_SCOPE) : BLOCK = (
	block_declab(blk, 
		{	block_name = block_name,
			flags = flags,
			in_scope = new_in_scope})
);
=TEX
=SML
fun €block_formal_procs›  (blk as
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	...
	} : BLOCK,
	new_formal_procs : FORMAL_PROC list) : BLOCK = (
	block_declab(blk, {block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
				}})
);
=TEX
=SML
fun €block_current_formal_proc›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits} : BLOCK,
	new_current_formal_proc : FORMAL_PROC) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = new_current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs,
	var_inits = var_inits
	}
);
=TEX
=SML
fun €block_current_formal_fun›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits} : BLOCK,
	new_current_formal_fun : FORMAL_FUN) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = new_current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs,
	var_inits = var_inits
	}
);
=TEX
=SML
fun €block_till›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits} : BLOCK,
	new_till : Z_PRED) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = new_till,
	using_decs = using_decs,
	var_inits = var_inits
	}
);
=TEX
=SML
fun €block_using_decs›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits} : BLOCK,
	new_using_decs : (Z_ID * (VAR_DECL list * Z_PRED)) list) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = new_using_decs,
	var_inits = var_inits
	}
);
=TEX
=SML
fun €block_var_inits›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits} : BLOCK,
	new_var_inits : (EXP * TMARK) S_DICT) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs,
	var_inits = new_var_inits
	}
);
=TEX
=SML
fun €block_spec_lab›  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits
	} : BLOCK,
	new_spec_lab : LABEL) : BLOCK = (
	{declab		=	declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = new_spec_lab,
	till = till,
	using_decs = using_decs,
	var_inits = var_inits
	}
);
=TEX
=SML
fun €block_block_name›  (blk as
	{
	declab as {block_name,
		flags,
		in_scope},
	...
	} : BLOCK,
	new_block_name : ID) : BLOCK = (
	block_declab(blk, 
		{block_name = new_block_name,
				flags = flags,
				in_scope = in_scope})
);
=TEX
=SML
fun €block_in_scope›  (blk as
	{
	declab as {block_name,
		flags,
		in_scope},
	...
	} : BLOCK,
	new_in_scope : IN_SCOPE) : BLOCK = (
	block_declab(blk, 
		{block_name = block_name,
				flags = flags,
				in_scope = new_in_scope})
);
=TEX
=SML
fun €block_dec_labels›  (blk as
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	...
	} : BLOCK,
	new_dec_labels : LABEL list) : BLOCK = (
	block_declab(blk,
		{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
				}})
);
=TEX
=SML
fun €block_current_for_vars›  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits
	} : BLOCK,
	new_current_for_vars : PARAM_SPEC list) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = new_current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs,
	var_inits = var_inits
	}
);
=TEX
=SML
fun €block_current_log_cons›  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs,
	var_inits
	} : BLOCK,
	new_current_log_cons : Z_DECL list) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = new_current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs,
	var_inits = var_inits
	}
);
=TEX

\subsection{Initial Values}

=TEX
=SML
val €pack_env0› : PACK_ENV = initial_s_dict;
val €subunit_env0› : SUBUNIT_ENV = initial_s_dict;
val €dec_env0› : DEC_ENV = initial_s_dict;
val €spec_env0› : SPEC_ENV = initial_s_dict;
=TEX
$empty\_block$ is the initial value for a block, as loosely specified in \cite{ISS/HAT/DAZ/DTD513}.
Fields which are not specified there are given place-holder values.
All the flags are set false, for convenience in defining $env0$.
It is convenient to define some shared dummy values first:
=SML
val €dummy_spec› : SPEC = {
		w 		= 	[],
		w0		=	[],
		pre		=	ZUserInterfaceSupport.ZTmTruth true,
		post		=	ZUserInterfaceSupport.ZTmTruth true};
val €dummy_informal_fun› : INFORMAL_FUN = {
		name		=	"*dummy fun*",
		formal_pars	=	[],
		return_type	=	"*dummy type*"};
val €dummy_formal_fun› : FORMAL_FUN = {
		informal_fun	=	dummy_informal_fun,
		spec		=	dummy_spec,
		globals		=	[]};
val €dummy_formal_proc› : FORMAL_PROC = {
		name		=	"*dummy formal proc*",
		formal_ids	=	[],
		spec		=	dummy_spec,
		globals		=	[]};
val €empty_in_scope› : IN_SCOPE = {
		vc_vars		=	[],
		vc_pars		=	[],
		vc_log_cons	=	[],
		vc_aux_vars	=	[],
		formal_procs	=	[],
		dec_labels	=	[]};
val €false_flags› : FLAGS = {
		pack_spec_flag		=	false,
		pack_body_flag		=	false,
		stub_flag		=	false,
		subunit_flag		=	false,
		formal_body_flag	=	false,
		fun_flag		=	false,
		declabel_flag		=	false,
		speclabel_flag		=	false,
		till_flag		=	false,
		body_flag		=	false};
val €dummy_declab› : DECLAB = {
		block_name	=	"*empty block*",
		flags		=	false_flags,
		in_scope	=	empty_in_scope};
=TEX
=SML
val €empty_block› : BLOCK = 	{
	declab		=	dummy_declab,
	current_formal_proc = dummy_formal_proc,
	current_formal_fun = dummy_formal_fun,
	current_for_vars = [],
	current_log_cons = [],
	dec_lab = "",
	spec_lab = "",
	till = mk_z_true,
	using_decs = [],
	var_inits = []
};
=TEX
Now we can define $env0$, exploiting the fact that all the flags are set to $false$ in $empty\_block$.
=SML
val €env0› : ENV = [empty_block];
=TEX
We also require initial values for the SPARK program and replacement environments discussed in \cite{ISS/HAT/DAZ/DTD513}
=SML
val €repl_env0› : REPL_ENV = initial_s_dict;
val €spark_prog0› : SPARK_PROG = [];
=TEX
For uniformity, we give the initial value for the theory name component of the global state here.
We use the string ``-'' which by convention in {\Product} means the current theory.
=SML
val €script_name0› : string = "-";
=TEX
\subsection{$flatten\_env$}
To implement $flatten\_env$, we first need a function to merge two $IN\_SCOPE$s.
To restrict the scope of frame widening, the block names are also passed in and $dec\_labels$ are only taken from the first $IN\_SCOPE$ when the two block names are different.
=SML
local
fun €merge_in_scopes›
	(block_name1 : ID)
	({	vc_vars = vc_vars1,
		vc_pars = vc_pars1,
		vc_log_cons = vc_log_cons1,
		vc_aux_vars = vc_aux_vars1,
		formal_procs = formal_procs1,
		dec_labels = dec_labels1} : IN_SCOPE)
	(block_name2 : ID)
	({	vc_vars = vc_vars2,
		vc_pars = vc_pars2,
		vc_log_cons = vc_log_cons2,
		vc_aux_vars = vc_aux_vars2,
		formal_procs = formal_procs2,
		dec_labels = dec_labels2} : IN_SCOPE) : IN_SCOPE = (
	{	vc_vars = vc_vars1 cup vc_vars2,
		vc_pars = vc_pars1 cup vc_pars2,
		vc_log_cons = union (op =$) vc_log_cons1 vc_log_cons2,
		vc_aux_vars = union (op =$) vc_aux_vars1 vc_aux_vars2,
		formal_procs = formal_procs1 @ formal_procs2,
		(* an equality test for formal procedure lists is non-trival *)
		dec_labels =
		if block_name1 = block_name2
		then dec_labels1 cup dec_labels2
		else dec_labels1
	}
);
=TEX
We also need a function to extract the name and global dependency list of
the current formal subprogram:
=SML
fun €subprog_info› (block : BLOCK) : ID * Z_ID list= (
	if	#fun_flag (#flags (#declab block))
	then	let	val formal_fun = #current_formal_fun block;
		in	(#name (#informal_fun(formal_fun)), #globals formal_fun)
		end
	else	let	val formal_proc = #current_formal_proc block;
		in	(#name formal_proc, #globals formal_proc)
		end
);
in
=TEX
Now we define $flatten\_env$, which uses $merge\_in\_scopes$ to merge all the $in\_scope$ components of the blocks in a running environment.

=SML
fun €flatten_env› ([] : ENV) : IN_SCOPE = (
	empty_in_scope
) |  flatten_env [blk] = (
	#in_scope(#declab blk)
) |  flatten_env (blk1 :: (blks as (blk2 :: _))) = (
	merge_in_scopes
	(#block_name (#declab blk1))
	(#in_scope (#declab blk1))
	(#block_name  (#declab blk2))
	(flatten_env blks)
);
=TEX
Now we define $subprog\_flatten\_env$: the $filter\_XXX$ functions implement
the set comprehensions in the specification, with $filter_env$ fitting
the results together into an $IN\_SCOPE$.
=SML
fun €subprog_flatten_env› ([] : ENV) : IN_SCOPE = (
	empty_in_scope
) |  subprog_flatten_env (blocks : ENV) = (
	let	val block1 = hd blocks;
		val flags = #flags (#declab block1);
	in	if	not(#formal_body_flag flags)
		then	flatten_env blocks
		else	let	val (name, globals) = subprog_info block1;
				val blocks2 = blocks drop
					(fn b => #block_name (#declab b) <> name);
				fun filter_vars ([] : VAR_DECL list) = []
				|   filter_vars (vardec :: vardecs) = (
					case #vars vardec drop
						(fn n => not(trans_id n mem globals))
					of [] => filter_vars vardecs
					| vars => {vars=vars, tmark= #tmark vardec}
						:: filter_vars vardecs
				);
				fun filter_pars ([] : PARAM_SPEC list) = []
				|   filter_pars ({mode,var_decl ={vars, tmark}}
					 :: parspecs) = (
					case vars drop
						(fn n => not(trans_id n mem globals))
					of [] => filter_pars parspecs
					| vars =>
						{mode= mode,
						 var_decl={ vars=vars, tmark= tmark}}
						:: filter_pars parspecs
				);
				fun filter_aux_vars ([] : Z_DECL list) = []
				|   filter_aux_vars (auxvar :: auxvars) = (
					let	val (vs, t) = dest_z_dec auxvar;
					in	case vs drop
					(fn v => not(fst(dest_var v) mem globals))
					of [] => filter_aux_vars auxvars
					| vars => mk_z_dec (vars, t)
						:: filter_aux_vars auxvars
					end
				);
				fun filter_env ([] : ENV) : IN_SCOPE = (
					empty_in_scope
				) | filter_env (blk :: blks) = (
					let	val in_scope = #in_scope(#declab blk);
					in	merge_in_scopes ""{
		vc_vars = filter_vars(#vc_vars in_scope),
		vc_pars = filter_pars(#vc_pars in_scope),
		vc_log_cons = #vc_log_cons in_scope,
		vc_aux_vars = filter_aux_vars(#vc_aux_vars in_scope),
		formal_procs = #formal_procs in_scope,
		dec_labels = []	} 
						"" (filter_env blks)
					end
				);
			in	merge_in_scopes
				"" (flatten_env blocks2)
				"" (filter_env blocks)
			end
	end
);
end (* of local ... in ... end; *);
=TEX
\subsection{The Global State}
For convenience in the implementation, the eight components of the state are held in eight assignable variables.
=SML
val €pack_env› : PACK_ENV ref = ref pack_env0;
val €subunit_env› : SUBUNIT_ENV ref = ref subunit_env0;
val €dec_env› : DEC_ENV ref = ref dec_env0;
val €spec_env› : SPEC_ENV ref = ref spec_env0;
val €blocks› : ENV ref = ref env0;
val €repl_env› : REPL_ENV ref = ref repl_env0;
val €spark_prog› : SPARK_PROG ref = ref spark_prog0;
val €script_name› : string ref = ref script_name0;
=TEX
The global state may be set from a given value of type $CN\_STATE$ using the following function:
=SML
fun €set_z_generator_state› ({
		pack_env = new_pack_env,
		subunit_env = new_subunit_env,
		dec_env = new_dec_env,
		spec_env = new_spec_env,
		blocks = new_blocks,
		repl_env = new_repl_env,
		spark_prog = new_spark_prog,
		script_name = new_script_name
	} : Z_GENERATOR_STATE) : unit = (
		pack_env := new_pack_env;
		subunit_env := new_subunit_env;
		dec_env := new_dec_env;
		spec_env := new_spec_env;
		blocks := new_blocks;
		repl_env := new_repl_env;
		spark_prog := new_spark_prog;
		script_name := new_script_name
);
=TEX
=SML
fun €get_z_generator_state› (() : unit) : Z_GENERATOR_STATE = (
		{pack_env = !pack_env,
		subunit_env = !subunit_env,
		dec_env = !dec_env,
		spec_env = !spec_env,
		blocks = !blocks,
		repl_env = !repl_env,
		spark_prog = !spark_prog,
		script_name = !script_name}
);
=TEX
\subsection{Accessing the Running Environment}
The function $block$ below implements the 1-based indexing of the running environment which is such a common feature of the Z spec.
=SML
fun €block› (index : int) : BLOCK = (
	(nth (index - 1) (!blocks))
	handle Fail _ => error "block" 507006 []
); 
=TEX
The following function is convenient for accessing the flags in the running environment.
The first parameter is the functions to extract the flag value: it will always be one of the ML built-in selection functions, $\#pack\_spec\_flag$ etc.
The second parameter gives the block to get the flag from: with $1$ identifying the topmost block.
=SML
fun €test_flag› (selector : FLAGS -> bool) (index : int) : bool = (
	(selector o #flags o #declab o block) index
);
=TEX
The specification does not specify the block name to be used in the bottom block in the running environment.
It is convenient to use this to tell the code which stores VCs the name of the current web clause.
The following two functions assist in this.
=SML
fun €set_bottom_block_name› (n : ID) : unit = (
	let	fun aux [] = [block_block_name(empty_block, n)]
		|   aux [blk] = [block_block_name(blk, n)]
		|   aux (blk :: more) = blk :: aux more;
	in	blocks := aux (!blocks)
	end
);
fun €get_bottom_block_name› (() : unit) : ID = (
	let	fun aux [] = ""
		|   aux [blk :BLOCK] = #block_name(#declab blk)
		|   aux (blk :: more) = aux more;
	in	aux (!blocks)
	end
);
=TEX
\subsection{Theory User Data}
The so-called user data part of a ProofPower theory is used to hold various information about the literate scripts which have been or are being processed.
We collect together here those parts of the code concerned with this which do not depend on later material.

The following are the user data key reserved for the Compliance Tool.
=SML
val €cn_pars_ud_key› = "CN'formal_pars";
val €cn_types_ud_key› = "CN'types";
val €cn_constants_ud_key› = "CN'constants";
val €cn_theories_ud_key› = "CN'theories";
val €cn_spec_ud_key› = "CN'createspec";
val €cn_subunit_ud_key› = "CN'createsubunit";
val €cn_new_parent_ud_key› = "CN'newparent";
val €cn_script_library_theories_ud_key› = "CN'script_library_theories";
val €cn_created_ud_key› = "CN'created";
val €cn_compilation_unit_ud_key› = "CN'compilation_unit";
val €cn_body_name_ud_key› = "CN'body_name";
=TEX

The following function is used in several places;
its clients must handle the exception it can raise.

=SML
fun €dest_ud_string› (UD_String (n, uds)) = (n, uds)
|   dest_ud_string _ = fail "" 0 [] (* Caller MUST catch this *);
=TEX

The following function updates the user data for the current theory.  Given a user data key and an item of data it retrieves any data currently stored under that key, adds the new data to it and then stores the result under the key.

=SML
fun €update_user_datum› (key : string) (xs : USER_DATUM) =
let
    val old_datum = (snd o dest_ud_string o get_user_datum "-")
					key handle Fail _ => [];
    val new_datum = xs::old_datum;
in
    set_user_datum(key, UD_String ("",new_datum))
end;
=TEX
The following sets a user data flag to indicate that the theory
was created by the compliance notation tool (e.g. by $new\_script$,
or perhaps as a stub theory).
=SML
fun €set_cn_created› () : unit = (
	set_user_datum (cn_created_ud_key, UD_String("CN created",[]))
);
=TEX
And the following checks for the flag:
=SML
fun €get_cn_created› () : bool = (
	(get_user_datum "-" cn_created_ud_key; true) 
	handle (Fail _) => false
);
=TEX

The following functions are used to maintain the list of theories ``belonging'' to the current literate script.
=SML
fun €get_script_theories› (thy : string) : string list = (
	(map (fst o dest_ud_string) o snd o dest_ud_string o get_user_datum thy)
	cn_theories_ud_key
	handle Fail _ => []
);
=TEX
=SML
fun €add_script_theory› (thy : string) : unit = (
	let	val old = get_current_theory_name();
		val side = open_theory (!script_name);
	in	
		update_user_datum cn_theories_ud_key (UD_String(thy, []));
		open_theory old;
		()
	end
);
=TEX
The following should be used when about to add material for
a compilation unit to a theory. 
It raised a failure if a different compilation unit has already used the theory.
This function implements check 17.
The name is stored for the purposes of this check and to use
in the error message.
=SML
fun €set_cu› (cu_name: string) : unit = (
let	val dummy = if (get_cn_created())
			then ()
			else fail "check17" 507056 [fn () => cu_name,
				fn () => get_current_theory_name()];	
	val (was, _) = dest_ud_string(get_user_datum "-"
				 cn_compilation_unit_ud_key)
			handle Fail _ => ("" ,[]);
in
	if (was = "")
	then set_user_datum(cn_compilation_unit_ud_key, UD_String (cu_name,[]))
	else if (was = cu_name)
	then ()
	else fail "check17" 507045 [fn () => cu_name,
				fn () => get_current_theory_name(),
				fn () => was]
end);
=TEX
The following is necessary when the key has been set incorrectly.
In particular, $duplicate\_theory$ copies keys, which is not helpful
in this case.
=SML
fun €force_set_cu› (cu_name: string) : unit = (
	set_user_datum(cn_compilation_unit_ud_key, UD_String (cu_name,[]))
);
=TEX
The following should be used when a package body is encountered.
=SML
fun €set_body_name› (name: ID) : unit = (
	set_user_datum(cn_body_name_ud_key, UD_String (name,[]))
);
=TEX
=SML
fun €get_parent_body_names› ((): unit) : string list = (
	let	val cur_thy = get_current_theory_name();
		val anc_thys = get_ancestors cur_thy less cur_thy diff get_ancestors"cn";
		fun trawl acc [] = acc
		|   trawl acc (thy::more) = (
			let	val res = fst(dest_ud_string
					(get_user_datum thy cn_body_name_ud_key));
			in	trawl (res::acc) more
			end	handle Fail _ => trawl acc more
		);
	in	trawl [] anc_thys
	end
);
=TEX
=IGN
get_parent_body_names();
open_theory"cn"; new_theory "t"; set_body_name "FRED";
new_theory "u"; set_body_name "BILL"; get_parent_body_names();
new_theory "v"; get_parent_body_names();
=TEX
The following functions are used to maintain the list of library theories ``belonging'' to the current literate script.
=SML
fun €get_library_theories› (thy : string) : string list = (
	(map (fst o dest_ud_string) o snd o dest_ud_string o get_user_datum thy)
	cn_script_library_theories_ud_key
	handle Fail _ => []
);
=TEX
=SML
fun €add_library_theory› (thy : string) : unit = (
	let	val old = get_current_theory_name();
		val side = open_theory (!script_name);
	in	
		update_user_datum cn_script_library_theories_ud_key
			(UD_String(thy, []));
		open_theory old;
		()
	end
);
=TEX

The next function adds a new parent to the current theory, and makes an entry of this fact in the current theory's user data.
If $allow\_fail$ is true, the function will not raise $Fail$: if the attempt to add the parent fails then the exception is caught and the error message is output as part of a comment.
=SML
fun €new_parent_aux› (allow_fail : bool) (thy : string) : unit = (
	if	not (thy mem get_parents "-")
	then	(	new_parent thy;
			update_user_datum cn_new_parent_ud_key
				(UD_String(thy, [UD_Int (current_level(),[])])) )
		handle ex as (Fail msg) =>
		if allow_fail
		then	 (
			if	thy mem get_descendants "min"
			then	comment "new_parent_aux" 507034
					[fn () => thy,
					 get_current_theory_name,
					fn () => get_message msg]
			else	comment "new_parent_aux" 507035
					[fn () => thy, get_current_theory_name]
		) else	reraise ex "new_parent_aux"
	else	()
);
=TEX
The following function creates a new theory (with a given list of theories to be made parents in addition to the current theory) and tries to make sure
it has the current cache theory in its ancestry. This circumvents
a misfeature in versions of ProofPower up to and including 0.5.
=SML
fun €new_theory_aux› (parents : string list) (thy : string) : unit = (
	new_theory thy;
	(case get_cache_theories () of
		cthy :: _ => (
			if	not(cthy mem get_ancestors thy)
			then	new_parent_aux true cthy
			else	()
	) | 	_ => ());
	map (new_parent_aux true) parents;
	()
);
=TEX

\subsection{Function Parameter Lists}
When the global variable representing a SPARK function is stored in a theory, a user data entry giving its formal parameter list is also stored.
This is later accessed via the $CN\_ENV$ when function calls using named parameter associations are translated into Z.

The following function is used here and elsewhere to find the HOL name corresponding to a Z one.
=SML
fun €z_id_of_id› (n : ID) : Z_ID = (
	(fst o dest_const o mk_z_gvar)(n, BOOL, [])
);
=TEX
=SML
local
fun €wanted› (fun_name : ID) (UD_String (i, _)) = (i = fun_name)
|   wanted _ _ = false;
fun €fun_name_par_names› ({name, formal_pars, return_type} : INFORMAL_FUN)
	: ID * (ID * ID) list * TMARK = (
	let 	fun get_names_tmarks {vars, tmark} = (
			map (fn v => (v, tmark)) vars
		);
	in	(name, (flat o map (get_names_tmarks o #var_decl)) formal_pars, return_type)
	end
);
fun €add_globs_pars_return›
	(globals : Z_ID list) (fun_name : ID) (pars_tmarks : (ID * ID) list) (ret_ty : TMARK): unit = (
	let	val old = (snd o dest_ud_string o get_user_datum "-") cn_pars_ud_key
			handle Fail _ => [];
		fun enc_par_tmark (p, t) = UD_String(p, [UD_String(t, [])]);
		val gs = UD_String("", map (fn g => UD_String(g, [])) globals);
		val ps = UD_String("", map enc_par_tmark pars_tmarks);
		val r = UD_String(ret_ty, []);
		val new = 
			UD_String(fun_name, [gs, ps, r])
			:: (old drop wanted fun_name);
	in	set_user_datum(cn_pars_ud_key, UD_String("", new))
	end
);
in
fun €get_spark_function_info› (fun_name : Z_ID) : (Z_ID list * (ID * ID) list * TMARK) OPT = (
	let	val uds = (snd o dest_ud_string o
			switch find (wanted fun_name) o snd o dest_ud_string o
			get_user_datum (get_const_theory (z_id_of_id fun_name)))
				cn_pars_ud_key;
	in	case uds of
			[gl, pl, r] => (Value(
			(map (fst o dest_ud_string) o snd o dest_ud_string) (hd uds),
			(map ((Combinators.I ** (fst o dest_ud_string o hd)) o dest_ud_string) o snd o dest_ud_string) (hd (tl uds)),
			fst(dest_ud_string r)))
		| _ => Nil
	end	handle Fail _ => Nil
);
fun €add_spark_function_info›
	(globals : Z_ID list)
	(inf_fun : INFORMAL_FUN) : unit = (
	let	val (fun_name, pars, ret_ty) = fun_name_par_names inf_fun;
	in	add_globs_pars_return globals fun_name pars ret_ty
	end
);
end;
=IGN
val ps1 : PARAM_SPEC = {var_decl={vars = ["P1"], tmark = "T1"}, mode = MSparkIn};
val if1 : INFORMAL_FUN = {name = "F1", formal_pars = [ps1], return_type="RT1"};
new_const("z'" ^ #name if1, BOOL);
add_spark_function_info [] if1;
get_spark_function_info "F1";
val inf_fun = if1;
val ps2 : PARAM_SPEC = {var_decl={vars = ["P2", "P3"], tmark = "T2"}, mode = MSparkIn};
val if2 : INFORMAL_FUN = {name = "F2", formal_pars = [ps1], return_type="RT2"};
new_const("z'" ^ #name if2, BOOL);
add_spark_function_info ["A", "B"] if2;
get_spark_function_info "F1";
get_spark_function_info "F2";
=TEX
\subsection{Information about SPARK Types and Constants}
When a basic declaration causes a Z global variable to be defined,
we may later need to know whether the Z global variable corresponds to
a SPARK type or a SPARK constant.
For record types, we also need to record the order of the component names.
To do this a list of type names and associated component names from the SPARK type declarations is maintained in the theory.
A global variable will not be a type unless it has an entry in this list.
=TEX
=SML
fun €add_spark_type_info› (tyn : ID, compns : ID list) : unit = (
	let	val	enc_compns = map (fn n => UD_String(n, [])) compns;
	in	update_user_datum cn_types_ud_key (UD_String(tyn, enc_compns))
	end
);
fun €get_spark_type_info› (n : ID) : ID list OPT = (
	let	fun aux (UD_String (tyn, cmps)::more) = (
			if	tyn = n
			then	Value (map (fst o dest_ud_string) cmps)
			else	aux more
		) | aux (_::more) = (aux more
		) | aux [] = Nil;
		val thy = get_const_theory (z_id_of_id n)
		val infos = ((snd o dest_ud_string o get_user_datum thy)
					cn_types_ud_key)
				handle Fail _ => [];
	in	aux infos
	end	handle Fail _ => Nil
);
=TEX
=SML
fun €add_spark_constant_info› (tyn : ID, tmark : ID) : unit = (
	update_user_datum cn_constants_ud_key (UD_String(tyn, [UD_String(tmark, [])]))
);
fun €get_spark_constant_info› (n : ID) : ID OPT = (
	let	fun aux (UD_String (tyn, [tmk])::more) = (
			if	tyn = n
			then	Value (fst(dest_ud_string tmk))
			else	aux more
		) | aux (_::more) = (aux more
		) | aux [] = Nil;
		val thy = get_const_theory (z_id_of_id n)
		val infos = ((snd o dest_ud_string o get_user_datum thy)
					cn_constants_ud_key)
				handle Fail _ => [];
	in	aux infos
	end	handle Fail _ => Nil
);
=TEX
To help with processing record types the following function takes a type definition and returns a list giving the components names (if any, i.e., the list is empty except when a record type definition is processed):
=SML
fun comp_names(TDRecordTypeDef {decl} : TYPE_DEF) = (
	flat (map #vars decl)
) | comp_names _ = [];
=TEX
In the following, named number declarations are just ignored.
This is acceptable because in \cite{ISS/HAT/DAZ/DTD508}
the information recorded for a constant is only used in handling
attributes, which are not relevant for named numbers.
=SML
fun €set_basic_decl_info› (pfx : ID -> ID) (bd : BASIC_DECL) : unit = (
	case bd of
		BDTypeDecl {name, type_def} => (
			add_spark_type_info (pfx (name), comp_names type_def)
	) |	BDSubtypeDecl std => add_spark_type_info (pfx (#name std), [])
	|	BDPrivateTypeDecl ptd => add_spark_type_info (pfx (#id ptd), [])
	|	BDConstDecl {consts = cs, tm = Value tmark, ...} => (map (fn c =>
				add_spark_constant_info (pfx c, tmark)
			) cs; ())
	|	_ => ()
);
=TEX
\subsection{Constructing $CN\_ENV$s}
The code here must pass type information into the functions defined in \cite{ISS/HAT/DAZ/DTD505,ISS/HAT/DAZ/DTD508} using the data type $CN\_ENV$ defined in \cite{ISS/HAT/DAZ/DTD508}.
This happens when declarations are translated for output to the Z document and when VCs are generated;
in the first case, the $CN\_ENV$ value required is taken from the running environment, in the second from the $In\_Scope$ part of the $Speclab$ which is the first part of the arguments to $vcs$.
In either case, Z global variables are sought from the theory data base if there is no local declaration for them.

We will need to be able to convert a type mark into an HOL type.
This is done by looking in the theory database.
The type there for a type $\tau$ will be $\tau$.
We must strip off the .
=SML
fun €type_of_tmark› (tmark : TMARK) : TYPE OPT = (
	(case (get_const_type (z_id_of_id tmark)) of
		Value ty => (Value (dest_z_power_type ty))
	|	Nil => Nil)
	handle Fail _ => Nil
);
=TEX
$get\_tmark\_from\_inscope$ searches an $IN\_SCOPE$ value for the type mark associated with a variable or parameter name, or the type associated with an auxiliary variable:
=SML
fun €get_tmark_from_inscope› (n : Z_ID) (inscope : IN_SCOPE)
	: (TYPE OPT * ENV_INFO) OPT = (
	let	fun do_vars [] = Nil
		|   do_vars ({vars, tmark} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_vars more
		);
		fun do_pars [] = Nil
		|   do_pars ({var_decl as {vars, tmark}, mode} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_pars more
		);
		fun do_aux_vars [] = Nil
		|  do_aux_vars (dec :: more) = (
			case s_lookup n (map dest_var (frees dec)) of
				Nil => do_aux_vars more
			|	Value ty =>
				Value(ty, snd(dest_z_dec dec))
		);
	in	case do_vars (#vc_vars inscope) of
			Value tmk	=> Value(type_of_tmark tmk, EIEnvVar tmk)
		|	Nil		=> (
		case do_pars (#vc_pars inscope) of
			Value tmk	=> Value(type_of_tmark tmk, EIEnvVar tmk)
		|	Nil		=> (
		case do_aux_vars (#vc_aux_vars inscope) of
			Value (ty, tm)	=> Value(Value ty, EIEnvAuxVar tm)
		|	Nil		=> Nil
		))
	end
);
=TEX
Now $get\_tmark\_from\_env$, which searches the running environment using the previous function to look for the required type mark.
=SML
fun €get_tmark_from_env› (_ : Z_ID) ([] : ENV) : (TYPE OPT * ENV_INFO) OPT = (
	Nil
) | €get_tmark_from_env› n (block :: more) = (
	case get_tmark_from_inscope n (#in_scope (#declab block)) of
			Nil		=> get_tmark_from_env n more
		|	v as Value _	=> v
);
=TEX
If we don't find anything in the running environment, then the only remaining possibility is that the name is that of a SPARK function, constant or type stored as a global variable in the theory database.
In this case the stored type is correct as it stands (no  to take away).
=SML
fun €type_of_g_var› (zn : Z_ID) : TYPE OPT = (
	(case get_const_type zn of
		Value ty => (Value ty)
	|	Nil => Nil)
);
=TEX
If we have the a global variable, then we need to classify it as a function, or record type type mark or other sort of SPARK entity.
for a function, we also need the formal parameter list.
To make this classification, we first check to see whether any formal parameters have been associated with the name:
if so, then it's a function and we have the parameter names to hand;
if it's not a function but is a type name, we dismantle the type: if its a set of bindings, then this is a record type mark; otherwise it's an `other type';
if it's neither a function nor a type name, its an `other'.

=SML
fun €env_info_of_g_var› (zn : ID) (ty : TYPE) : (TYPE * ENV_INFO) = (
	case get_spark_function_info zn of
		Value gspstm => (ty, EIEnvFunction gspstm)
	|	Nil => (
			ty,
			case get_spark_type_info zn of
				Value (ns as _::_) => EIEnvRecordType ns
			|	Value _ => EIEnvOtherType
			|	Nil => (
				case get_spark_constant_info zn of
					Value tmk => EIEnvConstant tmk
				|	Nil => EIEnvOther
			)
	)
);
=TEX
If a name is not found in the environment, it may be a prefixed name
of an item in the enclosing package or subprogram body. In that case,
we may strip off the prefix and invite the caller to try again.
(If we do this, the type in the returned value is a dummy).
=SML
fun €env_retry› (n : Z_ID) : (TYPE * ENV_INFO) OPT = (
	let	fun match ("o"::c1s) [] = (
			implode c1s
		) | match (c1::c1s) (c2::c2s) = (
			if c1 = c2 then match c1s c2s else ""
		) | match _ _ = "";
		fun hunt _ [] = Nil
		|   hunt en (body::bodies) = (
			case match en (explode body) of
				"" => hunt en bodies
			|	new_n => Value (BOOL, EIEnvRetry new_n)
		);
	in	hunt (explode n) (get_parent_body_names())
	end			
);
=TEX
The following treats the case where it has not been possible to convert the type mark for a name found in the environment into a type as if the name were not declared. 
=SML
fun €current_cn_env› (n : Z_ID) : (TYPE * ENV_INFO) OPT = (
	case get_tmark_from_env n (!blocks) of
		Value (Value ty, ei) => ( Value (ty, ei)
	) |	Value (Nil, _) => (env_retry n
	) | 	Nil => (
			case type_of_g_var (z_id_of_id n) of
				Value ty => Value(env_info_of_g_var n ty)
			|	Nil => env_retry n
	)
);
=TEX
=SML
fun €cn_env_of_in_scope› (in_scope : IN_SCOPE) (n : Z_ID)
	: (TYPE * ENV_INFO) OPT = (
	case get_tmark_from_inscope n in_scope of
		Value (Value ty, ei) => ( Value (ty, ei)
	) |	Value (Nil, _) => (env_retry n
	) |	Nil => (
			case type_of_g_var (z_id_of_id n) of
				Value ty => Value(env_info_of_g_var n ty)
			|	Nil => env_retry n
	)
);
=TEX
=SML
fun €speclab_wp_env_from_in_scope›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env as {env, till, return, fun_header, formal_procs},
	in_scope
	} : SPECLAB) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			= {
			env = cn_env_of_in_scope in_scope,
			till = till,
			return = return,
			fun_header = fun_header,
			formal_procs = formal_procs
			},
	in_scope		=	in_scope

	}
);
=TEX
\subsection{ProofPower Type Inference Context}
=TEX
=SML
fun €ti_context_of_in_scope› (inscope : IN_SCOPE) : TERM list = (
	let	fun v_v0 (in_mode : bool) (ty : TYPE) (v : ID) : TERM list = (
			if	in_mode
			then	[mk_var(v, ty)]
			else	[mk_var(v ^ "â0", ty), mk_var(v, ty)]
		);
		fun do_vars [] = []
		|   do_vars ({vars, tmark} :: more) = (
			case type_of_tmark tmark of
				Nil => do_vars more
			|	Value ty => (
				flat
				(do_vars more :: map (v_v0 false ty) vars)
			)
		);
		fun do_pars [] = []
		|   do_pars ({var_decl as {vars, tmark}, mode} :: more) = (
			case type_of_tmark tmark of
				Nil => do_pars more
			|	Value ty => (
				flat
				(do_pars more ::
					map (v_v0
					(case mode of MSparkIn => true | _ => false)
						 ty) vars)
			)
		);
		fun do_log_cons (log_cons : Z_DECL list) = (
			(flat o map (fst o dest_z_dec)) log_cons
		);
		fun do_aux_vars (aux_vars : Z_DECL list) = (
			let	val avs = (flat o map (fst o dest_z_dec)) aux_vars;
			    	fun av_av0 tm = (
					let	val (n, ty) = dest_var tm;
					in	mk_var(n^"â0", ty)
					end
				);
			in	avs @ map av_av0 avs
			end
		);
		val {vc_vars, vc_pars, vc_log_cons, vc_aux_vars, ...} = inscope;
	in	do_log_cons vc_log_cons @ do_aux_vars vc_aux_vars
			@ do_pars vc_pars @ do_vars vc_vars
	end
);
=TEX
=SML
fun €ti_context_of_subunit› (subunit : SUBUNIT) : TERM list = (
	ti_context_of_in_scope (#in_scope subunit)
);
=TEX
=SML
fun €ti_context_of_declab› (declab : DECLAB) : TERM list = (
	ti_context_of_in_scope (#in_scope declab)
);
=TEX
=SML
fun €ti_context_of_speclab› (speclab : SPECLAB) : TERM list = (
	if	#formal_body_flag speclab andalso #fun_flag speclab
	then	let 	val cxt = ti_context_of_in_scope (#in_scope speclab);
			val env = cn_env_of_in_scope (#in_scope speclab);
			val inf_fun = #fun_header(#wp_env speclab);
			val form_fun = {
				informal_fun = inf_fun,
				spec = dummy_spec,
				globals	 = fun_globals env (#name inf_fun)};
		in	fun_decl env form_fun :: cxt
		end
	else	ti_context_of_in_scope (#in_scope speclab)
);
=TEX
=SML
fun €ti_context_of_block› (block : BLOCK) : TERM list = (
	ti_context_of_declab (#declab block)
);
=TEX
=SML
fun €current_ti_context› (() : unit) : TERM list = (
	flat (map (ti_context_of_block) (!blocks))
);
=TEX
=SML
fun €set_current_ti_context› (ts : TERM list) : unit = (
	set_ti_context(ts @ current_ti_context())
);
=TEX
=SML
fun €set_in_scope_ti_context› (in_scope : IN_SCOPE) : TERM list = (
	set_ti_context(ti_context_of_in_scope in_scope);
	get_ti_context()
);
=TEX
=SML
fun €set_package_ti_context› (package : PACKAGE) : TERM list = (
	set_in_scope_ti_context {
		vc_pars = [],
		vc_vars = #vc_vars package,
		dec_labels = [],
		vc_aux_vars = #aux_vars package,
		vc_log_cons = [],
		formal_procs = []}
);
=TEX
The following is used to add the typing context for a parameter list into the context temporarily. It returns the context which should be restored when the parameters are no longer needed.
=SML
fun €add_params_ti_context› (pars : PARAM_SPEC list) : TERM list = (
	let	val old = get_ti_context();
		val to_add = ti_context_of_in_scope {
				vc_pars = pars,
				vc_vars = [],
				dec_labels = [],
				vc_aux_vars = [],
				vc_log_cons = [],
				formal_procs = []};
	in	set_ti_context(to_add @ old);
		old
	end
);
=TEX
=SML
fun €z_names_of_in_scope› (in_scope : IN_SCOPE) : Z_ID list  = (
	(map (fst o dest_var) o ti_context_of_in_scope) in_scope
);
=TEX
=SML
fun €z_names_of_z_dec› (zd : Z_DECL) : Z_ID list = (
	(map (fn (x,_,_) => x) o map dest_z_lvar
				o fst o dest_z_dec) zd
			handle _ => fail "z_names_of_z_dec" 507033 []
);
=TEX

\subsection{Updating the Z Theory Database}
=SML
fun €make_label_prefix› (wcn : string) : string = (
	"vc" ^ wcn ^ "_"
);
=TEX
=SML
fun €store_vc_term› (label : LABEL) (tm : TERM) : unit = (
	let	val bbn = get_bottom_block_name ();
		val vc_lab =	make_label_prefix
				(if 	bbn = "" orelse bbn = label
				then	label
				else	bbn);
		fun aux i = (
			let val vc_name = vc_lab ^ string_of_int i;
			in	if (get_conjecture "-" vc_name; false)
						handle Fail _ => true
				then	(new_conjecture ([vc_name], tm); ())
				else	aux (i + 1)
			end
		);
	in	aux 1
	end
);
=TEX
=SML
fun €term_of_vc› (vc as (decs, (asms, conc)) : VC) : TERM = (
	let	val tm = (
		case (decs, asms) of
			([], []) => conc
		|	([], _) => mk_z_¥ (list_mk_± asms, conc)
		|	(_, []) => mk_z_µ(mk_z_decl decs, mk_z_true, conc)
		|	(_, _) => mk_z_µ(mk_z_decl decs, list_mk_± asms, conc));
	in	case frees tm of
			[] => tm
		|	[t] => term_fail "store_vcs" 507051 [tm, t]
		|	fs => fail "store_vcs" 507052 [fn () => string_of_term tm,
				fn () =>  format_list string_of_term fs ", "]
	end
);
=TEX
For various (good) reasons, the underlying {\Product} operations of adding new parent or saving a conjecture (e.g., a VC) do not increment the level counter.
In order for the Z document generator to be able to output the necessary commands in the right place, we make and deletes a dummy type declaration before storing each batch of VCs to force the level counter up.
In order to avoid a potential infinite loop (e.g., if the current theory is not writable), the attempt to do this dummy declaration is abandoned after 10,000 goes (this protects the code against an extremely unlikely event!)
=SML
fun €store_vcs› (label : LABEL, vcs: VC list) : unit = (
	let	fun dummy_decl i = (
			if	i < 10000
			then	let	val tyn = "CN'DUMMY_TYPE" ^ string_of_int i;
				in	((	(icl'Kernel.icl'new_type(tyn, 0); ())
						handle Fail _ => dummy_decl (i+1));
					icl'Kernel.icl'delete_extension();
					()	)
				end	handle Fail _ => ()
			else	()
		);
		val side_effect = dummy_decl 0;
	in	map (store_vc_term label) (map term_of_vc vcs);
		()
	end
);
=TEX
The following function is used to put a warning message in the Z document (as an unprovable VC).
=SML
local
val warning_vc_term = Ò("WARNING" = (x ∫ seq CHAR))∫ BOOLÆ;
val x = Òx ∫ seq CHARÆ;
in
fun store_message_vc (msg : int) (inserts : string list) = (
	set_bottom_block_name "MESSAGE_VC";
	store_vc_term 
	"MESSAGE_VC"
	(subst [(mk_z_string(get_error_message msg inserts), x)] warning_vc_term)
);
end;
=TEX
The processing of declarations can give rise to VCs.
These are delivered as conjecture paragraphs.
In order to handle these vcs uniformly with other VCs, we use
the following interface to the function for storing Z paragraphs.
Currently VCs cannot be generic, and so the interface below does not cater for generic VCs.
=SML
fun €store_para› (para : PARAINFO) : unit = (
	case para of
		ConjectureInfo(Value n, [], pred) => (
			let	val bbn = get_bottom_block_name();
			in	set_bottom_block_name n;
				store_vcs(n, [([], ([], pred))]);
				set_bottom_block_name bbn
			end
	) |	_ => update_theory_db_with_parainfo para
);
=TEX
The following attempts to store a paragraph, and then tides everything
away again.
$delete\_top\_theory\_past\_level$ is taken verbatim from
\cite{DS/FMU/IED/DTD049}.
=SML
local
open	icl'Kernel;
fun delete_top_theory_past_level  (level : int) : unit = (
let	val dummy = case (get_current_theory_status()) of
		TSNormal => ()
		| TSDeleted => error "update_theory_db_with_parainfo" 6008 
			[fn () => get_current_theory_name()]
		| TSLocked => fail "update_theory_db_with_parainfo" 6037
			[fn () => get_current_theory_name()]
		| TSAncestor => fail "update_theory_db_with_parainfo" 6071
			[fn () => get_current_theory_name()];

	val {children = children,...} = icl'get_theory_info "-";

	val {con_env = con_env,ty_env = ty_env,
		axiom_dict = axiom_dict, thm_dict = thm_dict,
		defn_dict = defn_dict,...} = icl'get_theory "-";

	val (del_con,del_lev1) = split (map (fn (name,{ty = ty,level = lev,...}) => 
			((name, ty),lev))
		(con_env drop (fn (_,{level = lev,...}) => lev <= level)));

	val (del_type,del_lev2) = split(map (fn (name,{level = lev,...}) => (name,lev))
		(ty_env drop (fn (_,{level = lev,...}) => lev <= level)));

	val del_type_arities = map (fn ty =>
		case SymbolTable.get_type_info ty of
		Nil => error "update_theory_db_with_parainfo" 49999 []
		|Value (ar, _) => (ty, ar)) del_type;

	val del_thms = map (fn (key,_) => key)
		(thm_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev <= level end));

	val (del_axioms, del_lev3) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(axiom_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev <= level end)));

	val (del_defns, del_lev4) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(defn_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev <= level end)));

	val dl = list_cup[del_lev1, del_lev2, del_lev3, del_lev4];
	val dummy = map icl'delete_thm del_thms;
in
	if (is_nil dl)
	then ()
	else if children <> [] 
	then fail "update_theory_db_with_parainfo"
		 6076 [fn () => get_current_theory_name()]
	else ( map (fn x => icl'delete_extension ()) dl; 
		open_theory"-"; 
		())
end);
in
fun €test_store_para›  (para : PARAINFO) : unit = (
	case para of
		ConjectureInfo(Value n, [], pred) => (
			term_of_vc ([], ([], pred));
			()
	) |	_ => (
	let	val cl = current_level();
		val dummy = update_theory_db_with_parainfo para;
		val undo = delete_top_theory_past_level cl;
	in
		()
	end)
);
end;
=TEX
The following creates a term formed from the variable initialisations and
the domain conditions for the initialising expressions
and combines it with a possible pre-existing pre-condition,
and returns a $Z\_TM$, as that is what a $SPEC$ wants.

(The list reversal in function {\it aux} is for backwards compatibility.
It puts the list in the same order as it was before the introduction of
domain conditions).
=SML
val bool_extype = Unification.type_to_extype îBOOLÆ;
fun €var_inits_pre›
	(opre : Z_TM OPT) ([] : (EXP * TMARK) S_DICT) (cn_env : CN_ENV) : Z_TM  = (
	case opre of 
	Value pre => pre
	| Nil => ZTmTruth true
) 
| var_inits_pre (opre : Z_TM OPT) (vi : (EXP * TMARK) S_DICT) (cn_env : CN_ENV) : Z_TM = (
let	fun aux acc ((id, (exp, tmark))::more) = (
		let	val ze = slide_to_tmark cn_env
				(trans_exp cn_env (adjust_exp cn_env exp), tmark);
			val dc = domain_conds cn_env ze;
			val eqn = z_eq(zid cn_env (trans_id id), ze);
		in	aux (eqn::dc@acc) more
		end
	) | aux acc [] = rev acc;
	val vi_init_dcs = aux [] vi;
in
	case opre of 
	Value pre => z_quote(z_many_and (z_pred_of_z_tm pre :: vi_init_dcs), 
		Value(bool_extype))
	| Nil => z_quote(z_many_and vi_init_dcs, Value(bool_extype))
end
handle exn => pass_on exn "zid" "var_inits_pre"
);
=TEX

\subsection{Creating ProofPower Theories}
The material in this section uses the following function, which is also required for the DRA specs.
=SML
infix dot;
fun (x : ID) €dot› (y : ID) = x ^ "." ^ y;
=TEX
The following forms two identifiers into an index string for $subunit\_env$.
Working on the principle that $(trans\_id$ $o$ $trans\_id)$ equals $trans\_id$,
and that sometimes the arguments will already be translated:
we translate both sides of the pair we are looking up, and combine them with a dot.
=SML
fun €subunit_env_index› (id1 : ID) (id2 : ID) = 
	(trans_id id1) dot (trans_id id2);
=TEX
The following function returns the name of the parent of the script theory.
=SML
fun  €get_parent_name› ((): unit) : string = (
	(hd o rev o get_parents) (!script_name)
);
=TEX
=SML
fun €pack_spec_name› (name : string) : string = (
	(trans_id name) ^ "spec"
);
=TEX
The following are used to describe the compilation unit that is present in the
current theory, based on its name. This is to do with implementing
check 17.
=SML
fun €pack_spec_desc› (name : string) : string = (
	name ^ " (external specification)"
);
=TEX
=SML
fun €spec_script_desc› (name : string) : string = (
	name ^ " (internal specification)"
);
=TEX
=SML
fun €stub_theory_desc› (name : string) : string = (
	name ^ " (stub)"
);
=TEX
=SML
fun €subunit_desc› (name : string) : string = (
	name ^ " (subunit)"
);
=TEX
=SML
fun €pack_body_desc› (name : string) : string = (
	name ^ " (body)"
);
=TEX
=SML
fun €subprogram_desc› (name : string) : string = (
	name ^ " (subprogram)"
);
=TEX

In the following, the spec theories and related theories are made as children of the parent of the script theory.
The new theory becomes the current theory (unless an exception is raised in which case the script theory is made current).
=SML
fun €new_package_spec_theory› (pars : string list) (name : string) : unit = (
	let	val thy = pack_spec_name name;
	in	(	open_theory("cn");
			new_theory_aux pars thy;
			set_cn_created();
			add_script_theory thy;
			open_theory thy )
		handle Fail _ => (
			open_theory (!script_name);
			fail "new_package_spec_theory"
			507023 [fn()=>thy, fn()=>name]
		);
		set_cu (pack_spec_desc name)
	end
);
=TEX
=SML
fun €open_package_spec_theory› (name : string) : unit = (
	open_theory (pack_spec_name name);
	set_cu (pack_spec_desc name)
);
=TEX
The full name of a subunit theory:
=SML
fun €trans_subunit_name›  (unit_name : string, subunit_name : string) : Z_ID =
	trans_id ((unit_name dot subunit_name) ^ "stub") ;
=TEX
In the following the call to the {\Product} function $duplicate\_theory$ creates a new theory which is a copy of the script theory.
The script theory is made the current theory.
=SML
fun €make_module› (thy : Z_ID) : unit = (
	let	fun delete_vc n = ((delete_conjecture n; ())
						handle Fail _ => ());
		val dummy1 = duplicate_theory (!script_name, thy)
			handle Fail _ => (
				open_theory (!script_name);
				fail "make_module" 507026
				[fn()=>thy, fn()=>thy]
			);
		val dummy7 = set_cn_created();
		val dummy3 = add_script_theory thy;
		val dummy4 = open_theory thy;
		val dummy2 = force_set_cu (stub_theory_desc thy);
		val dummy5 = (map delete_vc o flat o map fst o get_conjectures) thy;
		val thy_level = current_level();
		val dummy6 = open_theory (!script_name);
	in	(	
			update_user_datum cn_subunit_ud_key
				(UD_String(thy, [UD_Int (current_level(),
				[UD_Int (thy_level, [])])]));
			()
		)
		handle Fail _ => (
			open_theory (!script_name);
			fail "make_module" 507026
			[fn()=>thy, fn()=>thy]
		)
	end
);
=TEX
=SML
fun €new_parent_subunit_theory› (unit_name : string, x : PROPER_BODY) : unit = (
	let	val subunit_name =(case x of
			PBProcedure {procedure_spec as {name, ...}, ...} => (
				name
		) |	PBFunction {function_spec as {designator, ...}, ...} => (
				designator
		) |	PBPackage {name, ...} => (
				name
		));
		val su_name = unit_name dot subunit_name;
		val thy = trans_id (su_name ^ "stub");
	in	new_parent_aux false thy;
		()
	end
);
=TEX
\subsection{Diagnostic Aids}
=SML
val €diag_z_generator_state› : Z_GENERATOR_STATE ref = (
	ref (get_z_generator_state())
);
val €diag_web_clause› : WEB_CLAUSE ref = ref (WCCompilation []);
val €diag_vc_args› : (SPECLAB * STATEMENT) list ref = ref [];
val €diag_basic_decl_list› : BASIC_DECL list ref = ref [];
=TEX
\subsection{Interface to VC Generator}
=TEX
=SML
fun €add_init_vars_spec› ({w, pre, post, w0} : SPEC) : SPEC = (
	{w = w,
	pre = pre,
	post = post,
	w0 = map (fn s => s ^ "â0") w} 
);
=TEX
=SML
fun €add_init_vars_speclab› ({spec, wp_env, fun_flag, in_scope,
	till_flag, formal_body_flag} : SPECLAB) : SPECLAB = (
	{spec = add_init_vars_spec spec,
	wp_env = wp_env,
	fun_flag = fun_flag,
	in_scope = in_scope,
	till_flag = till_flag,
	formal_body_flag = formal_body_flag}
);
=TEX
=SML
fun €add_formal_procs_wp_env›
	({spec, formal_body_flag, fun_flag, till_flag,
		wp_env as {fun_header, env, return, till, formal_procs},
		in_scope} : SPECLAB) : SPECLAB = (
	{spec = spec,
	formal_body_flag = formal_body_flag,
	fun_flag = fun_flag,
	till_flag = till_flag,
	wp_env = {	fun_header = fun_header,
			env = env,
			return = return,
			till = till,
			formal_procs = #formal_procs in_scope},
	in_scope = in_scope}
);
=TEX
=SML
fun €call_vcs›
	((sl, st) : SPECLAB * STATEMENT) : VC list * SPEC = (
	let	val sl1 = add_init_vars_speclab sl;
		val sl1_st = (add_formal_procs_wp_env sl1, st);
	in	diag_vc_args := sl1_st :: !diag_vc_args;
		set_ti_context (ti_context_of_speclab sl1);
		vcs sl1_st
	end
);
=TEX
\section{BASIC DECLARATIONS}\label{BASICDECLARATIONS}
\subsection{The SID Function basic\_declaration}
The decision about which function to call is made in $basic\_declaration$ itself.
=SML
fun €basic_decl_pack_spec› (basic_decl : BASIC_DECL) : unit = (
	let	val block_name1 = #block_name(#declab (block 1));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "basic_decl_pack_spec" 507001 [];
		val para_info_opt = trans_basic_decl1 current_cn_env basic_decl;
	in	pack_env :=
		s_enter
		block_name1
		(package_consts_types(package,
				#consts_types package @ [basic_decl]))
		(!pack_env);
		case para_info_opt of
			Value para_infos => (
				map store_para para_infos;
				set_basic_decl_info Combinators.I basic_decl
		)|	Nil =>	fail "basic_decl_pack_spec" 507041 []
	end
);
=TEX
=SML
fun €basic_decl_otherwise› (basic_decl : BASIC_DECL) : unit = (
	let	val side = set_current_ti_context [];
		val para_info_opt = trans_basic_decl1 current_cn_env basic_decl;
	in
		case para_info_opt of
			Value para_infos => (
				map store_para para_infos;
				set_basic_decl_info Combinators.I basic_decl
		)|	Nil =>	fail "basic_decl_otherwise" 507041 []
	end
);
=TEX	
=SML
fun €basic_declaration› (basic_decl : BASIC_DECL) : unit = (
	if	test_flag #pack_spec_flag 1
	then	basic_decl_pack_spec basic_decl
	else	basic_decl_otherwise basic_decl
);
=TEX
=SML
fun €var_pack_spec› (var_decl : VAR_DECL) : unit = (
	if	test_flag #pack_spec_flag 1
	then	let	val block_name1 = #block_name(#declab (block 1));
			val package = case (s_lookup block_name1 (!pack_env)) of
				Value p => p
			|	Nil => error "var_pack_spec" 507001 [fn _=>block_name1];
		in	pack_env :=
			s_enter
			block_name1
			(package_vc_vars(package,
					#vc_vars package @ [var_decl]))
			(!pack_env)
		end
	else
		()
);
=TEX
\subsection{The SID Function update\_envs\_var}
The decision making as to whether to call the three support functions is done in $update\_envs\_var$ itself (since it is the same test in each case).

In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab1 mem dec_labels
			then	(id1_id2,
				subunit_vc_vars(s, vc_vars grab var_decl))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_dec_label
			(dec_label_s as
				(dec_label,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(dec_label,
				declab_vc_vars(s, vc_vars grab var_decl))
			else	dec_label_s
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
The identifiers in the variable declaration are translated first.
=SML
fun €update_spec_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		val trans_vars = map trans_id (#vars var_decl);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(spec_label,
				speclab_w(
					speclab_vc_vars(s, vc_vars grab var_decl),
					trans_vars cup w))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun €update_envs_var› (var_decl : VAR_DECL) : unit = (
	if	test_flag #declabel_flag 1
	then	(update_subunit_env_var var_decl;
		update_dec_env_var var_decl;	
		update_spec_env_var var_decl)
	else	()
);
=TEX
\subsection{The SID Function update\_envs\_k\_slot}
The decision making as to whether to call the three support functions is done in $update\_envs\_k\_slot$ itself (since it is the same test in each case).
=SML
fun €update_subunit_env_k_slot› (lab : LABEL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab1 mem dec_labels
			then	(id1_id2,
				subunit_dec_labels(s, dec_labels grab lab))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
=SML
fun €update_dec_env_k_slot› (lab : LABEL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_dec_label
			(dec_label_s as
				(dec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(dec_label,
				declab_dec_labels(s, dec_labels grab lab))
			else	dec_label_s
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
=SML
fun €update_spec_env_k_slot› (lab : LABEL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(spec_label,
					speclab_dec_labels(s, dec_labels grab lab))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun €update_envs_k_slot› (lab : LABEL) : unit = (
	if	test_flag #declabel_flag 1
	then	(update_subunit_env_k_slot lab;
		update_dec_env_k_slot lab;	
		update_spec_env_k_slot lab)
	else	()
);
=TEX
\subsection{The SID Function add\_var\_env}
=SML
fun €add_var_env› (var_decl : VAR_DECL) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "add_var_env" 507006 [];
		val block_name1 = #block_name(#declab block1);
		val avs = #aux_vars (
			force_value(s_lookup block_name1 (!pack_env)))
			handle Fail _ => [];
		val av_names = flat (map z_names_of_z_dec avs);
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val vars = #vars var_decl;
		val zids_in_scope = av_names cup
			(z_names_of_in_scope o #in_scope o #declab) block1;
	in	map (check_new_z_id zids_in_scope) vars;
		check_new_spark_ids current_cn_env vars;
		blocks :=
		block_vc_vars(block1, vc_vars1 grab var_decl):: tl (!blocks)
	end
);
=TEX
\subsection{The SID Function add\_var\_env}
=SML
fun €add_var_init_env› (var_decl as {vars, tmark}: VAR_DECL, init : EXP) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "add_var_init_env" 507006 [];
		val block_name1 = #block_name(#declab block1);
		val var_inits1 = #var_inits(block1);
		fun list_extend ((a :: x) : ID list) (s : (EXP * TMARK) S_DICT) = (
			list_extend x (s_extend a (init, tmark) s)
			handle (Fail _) =>
			fail "add_var_init_env" 507043 [fn _ => a]
		) | list_extend [] s = s;
		val new_var_inits = list_extend vars var_inits1 ;
	in	blocks :=
		block_var_inits(block1, new_var_inits):: tl (!blocks)
	end
);
=TEX
\section{DECLARATIONS}\label{DECLARATIONS}
In the following, $block2$ is bound first to catch possible errors with a corrupt environment.

=SML
fun €k_slot_dec› (label : LABEL) : unit = (
	let	val block2 = block 2
			handle Fail _ => error "k_slot_dec" 507006 [];
		val block1 = block 1;
		val subunit_flag2 = test_flag #subunit_flag 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val declab = {
			block_name 	=	if	subunit_flag2
						then	block_name2 dot block_name1
						else	block_name1,
			flags		=	#flags(#declab block1),
			in_scope	= 	flatten_env (!blocks)			
		};
		val dec_labels1 = #dec_labels (#in_scope (#declab block1));
	in	(dec_env := s_extend label declab (!dec_env)
		handle Fail _ => fail "k_slot_dec" 507010 [fn () => label];
		blocks :=
			block_dec_labels (block1, dec_labels1 grab label)
								:: tl (!blocks)
		)
	end
);
=TEX
\section{STATEMENTS}\label{STATEMENTS}
\subsection{Support for Processing Specification Statement}
The code that follows is essentially the implementation of {\it vc\_speclabel}
with an option not to store the generated VCs. This facility is used to
make checks on a specification statement (as statement) as soon as it is encountered
rather than waiting until someone tries to refine it (which they may never do).

The code does not follow the specification in fishing the label out of the environment
but takes it from the argument (which will have the same value in the call that actually
generates VCs and can be chosen by caller in the call that just makes checks).
The speclab is augmented by any variables brought into scope by a for-loop.

=SML
fun €vcs_speclabel_aux› (just_checking : bool) ({label, statement} : REFINED_BY) : SPEC = (
	let	val block1 = block 1;
		val spec_env_lab = force_value( s_lookup label (!spec_env) )
			handle Fail _ => fail "vcs_speclabel" 507003
				[fn () => label];
		val {wp_env as {env, till, return, fun_header, formal_procs},
			spec, in_scope, formal_body_flag, fun_flag, till_flag}
			= spec_env_lab;
		val current_for_vars1 = #current_for_vars block1;
		val current_log_cons1 = #current_log_cons block1;
		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = (#vc_pars in_scope) cup current_for_vars1,
			vc_log_cons = (#vc_log_cons in_scope) @ current_log_cons1,
			vc_aux_vars = #vc_aux_vars in_scope,
			formal_procs = #formal_procs in_scope,
			dec_labels = #dec_labels in_scope
		};
		val wp_env1 :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = till,
			return = return,
			fun_header = fun_header,
			formal_procs = formal_procs
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1
		};
		val (vcs, spec) = call_vcs (speclab, statement)
	in	if just_checking then () else store_vcs (label, vcs);
		spec
	end
);
=TEX
\subsection{The SID function spec\_stmt}
The decision about which support function to call is made in $spec\_stmt$ itself.
=SML
fun €spec_stmt_speclabel› ({spec : SPEC, label : LABEL}) : unit = (
	let	val block1 = block 1;
		val spec_lab1 = #spec_lab block1;
		val speclab2 = force_value(s_lookup spec_lab1 (!spec_env))
			handle Fail _ =>
			fail "spec_stmt_speclabel" 507014 [fn ()=> spec_lab1];
		val {formal_body_flag, fun_flag,
			wp_env as {fun_header, return, ...}, 
			in_scope as {
				vc_vars = vc_vars2,
				vc_pars = vc_pars2,
				vc_log_cons = vc_log_cons2,
				vc_aux_vars = vc_aux_vars2,
				dec_labels = dec_labels2,
				formal_procs = formal_procs2}, ...} = speclab2;
		val ti_cxt = set_in_scope_ti_context in_scope;
		val till = #till block1;
		val till_flag = #till_flag (#flags (#declab block1));
		val env_pars = #vc_pars (flatten_env(!blocks));
		val vc_pars = vc_pars2 @ env_pars;
		val vc_log_cons1 = #vc_log_cons(#in_scope(#declab block1));
		val vc_log_con_ids = flat (map z_names_of_z_dec vc_log_cons1);
		val zids_in_scope = z_names_of_in_scope in_scope;
		val side = map (check_new_z_id zids_in_scope) vc_log_con_ids;
		val vc_log_cons2_1 = vc_log_cons2 @ vc_log_cons1;
		val in_scope1 : IN_SCOPE = {
			dec_labels = dec_labels2,
			formal_procs = formal_procs2,
			vc_log_cons = vc_log_cons2_1,
			vc_aux_vars = vc_aux_vars2,
			vc_vars = vc_vars2,
			vc_pars = vc_pars			
		};
		val env = cn_env_of_in_scope in_scope1;
		val wp_env1 :WP_ENV = {
			env = env,
			till = till,
			return = return,
			fun_header = fun_header,
			formal_procs = formal_procs2
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1			
		};
		val side = set_in_scope_ti_context in_scope1;
		val chk = check_19 env spec;
	in	spec_env := s_extend label speclab (!spec_env)
		handle Fail _ =>
		fail "spec_stmt_speclabel" 507015 [fn ()=> label]
	end
);
=TEX
=SML
fun €spec_stmt_otherwise› ({spec : SPEC, label : LABEL}) : unit = (
	let	val block1 = block 1;
		val {declab as {flags =
			{formal_body_flag,
			fun_flag,
			till_flag, ...}, ...},
			till,
			current_formal_fun = formal_fun1 as
					{informal_fun = fun_header,
					spec = spec1 as {post = return, ...}, ...},
			...} = block1;
		val in_scope1 : IN_SCOPE = subprog_flatten_env(!blocks);
		val side = set_in_scope_ti_context in_scope1;
		val env = cn_env_of_in_scope in_scope1;
		val wp_env1 :WP_ENV = {
			env = env,
			till = till,
			return = z_pred_of_z_tm return,
			fun_header = fun_header,
			formal_procs = []
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1			
		}; 
		val chk = check_19 env spec;
	in	spec_env := s_extend label speclab (!spec_env)
		handle Fail _ =>
		fail "spec_stmt_otherwise" 507015 [fn ()=> label]
	end
);
=TEX
After doing the work prescribed by the specification, we call {\it vcs\_spec\_label\_aux}
to check the specification statement for free variables or other oddities. 
=SML
fun €spec_stmt› (specstmt as {spec : SPEC, label : LABEL}) : SPEC = (
	(if	test_flag #speclabel_flag 1
	then	spec_stmt_speclabel
	else	spec_stmt_otherwise) specstmt;
	vcs_speclabel_aux true {label = label, statement = STNull}
);
=TEX
\subsection{The SID function k\_slot\_stmt}
=SML
fun €k_slot_stmt› (label : LABEL) : SPEC = (
	spec_stmt {	spec=
			{w = [], w0 = [], pre = z_tm_true, post = z_tm_true},
			label = label}
);
=TEX
\subsection{The SID function add\_log\_con\_env}
We reverse the list below because that makes the declarations in the
VCs come out in the original order.
Note that (fortunately!), this function makes no use of the pre- and post-conditions
in the logical constant statement. Thus it does not interfere with the
strategy for efficient, early, type-checking.
=SML
fun €add_log_con_env› (defs : LOG_CON_DEF list) : unit = (
	let	val xs_ts = map (fn {x, t, e} => (x, t)) defs;
		val block1 = block 1;
		val side = set_current_ti_context[];
		fun make_decl (x, t) = (
			let	val zt = z_predexp_of_z_tm t;
				val zvar = mk_z_lvar(x, (dest_z_power_type o type_of) zt, []);
			in	mk_z_dec([zvar], zt)
			end
		);
		val zdecls = map make_decl xs_ts;
		val current_log_cons1 = #current_log_cons block1;
		val zids_in_scope = (z_names_of_in_scope o #in_scope o #declab)
			 block1;
		val xs = map fst xs_ts;
	in	map (check_new_z_id zids_in_scope) xs;
		check_new_spark_ids current_cn_env xs;
		blocks := block_current_log_cons (
					block_vc_log_cons(block1, zdecls),
					zdecls @ current_log_cons1)
				 :: tl (!blocks)
	end
);
=TEX
\subsection{The SID function remove\_log\_con\_env}
=SML
fun €remove_log_con_env› (() : unit) : unit = (
	let	val block1 = block 1;
	in	blocks := block_vc_log_cons(block1, []) :: tl (!blocks)
	end
);
=TEX
\section{LOOPS}\label{LOOPS}
\subsection{The SID function new\_scope\_loop}
=SML
fun €new_scope_loop› (() : unit) : unit = (
	let	val block1 = block 1;
		val {declab as {flags as 
			{fun_flag, formal_body_flag, speclabel_flag, ...},
			in_scope, block_name, ...},
			... } = block1;
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			declabel_flag = false,
			speclabel_flag = speclabel_flag,
			till_flag = false,
			body_flag = false
		};
		val block = block_declab(block1, {
				block_name = block_name,
				flags = flags,
				in_scope = in_scope});

	in	blocks := block :: !blocks
	end		
);
=TEX

\subsection{The SID function end\_scope}
=SML
fun €end_scope› (():unit) : unit = (
	(blocks := tl (! blocks))
	handle Fail _ => error "end_scope" 507006 []
);
=TEX
\subsection{The SID function for\_param}
=SML
fun €for_param› (i : ID, tmark : TMARK) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val param_spec = {	mode = MSparkIn,
					var_decl = {vars = [i], tmark = tmark}};
		val for_vars = #current_for_vars block2;
	in	blocks := block_vc_pars (block1, [param_spec])
				:: block_current_for_vars
					(block2, for_vars grab param_spec)
				:: (tl o tl) (!blocks)
	end
);
=TEX
\subsection{The SID function till\_pred}
In the following, in order to type-check the till-predicate correctly, we need to make sure that any variable declarations which should be in scope are in scope.
If the till-predicate occurs immediately inside a subprogram body, there is nothing much to do --- the processing of formal parameters and variable declarations will already have planted the necessary information in the running environment.
If the till-predicate is in a refinement step, then we must adjust the type inference context in much the same was as is done in $vcs\_speclabel$.
=SML
fun €till_pred› (t : Z_TM) : unit = (
	let	val block1 = block 1;
		val label = #spec_lab block1;
		fun set_cxt() = (
		if	test_flag #speclabel_flag 1
		then	let	val spec_env_lab =
				force_value( s_lookup label (!spec_env) );
				val {in_scope, ...} = spec_env_lab;
				val in_scope' = {
					vc_vars = #vc_vars in_scope,
					vc_pars = (#vc_pars in_scope)
							cup #current_for_vars block1,
					vc_log_cons = (#vc_log_cons in_scope)
							@ #current_log_cons block1,
					vc_aux_vars = #vc_aux_vars in_scope,
					formal_procs = #formal_procs in_scope,
					dec_labels = #dec_labels in_scope
				};
			in	(set_in_scope_ti_context in_scope'; ())
			end	handle Fail _ => set_current_ti_context[]
		else	set_current_ti_context[]
		);
		val side = set_cxt();
		val till = z_pred_of_z_tm t;
	in	blocks := block_till (block_till_flag(block1, true), till)
		:: tl (!blocks)
	end
);
=TEX
\section{SUBPROGRAM DECLARATIONS}\label{SUBPROGRAMDECLARATIONS}
The SID function $end\_scope$ used in processing these has already been defined in section \ref{LOOPS}.
\section{PROCEDURES}\label{PROCEDURES}
\subsection{The SID function subunit\_form}
This SID function and the next are best handled by a common function with a parameter to determine what to do.
Note that the block name must be in the translated form (i.e. had $trans\_id$
applied to it).
=SML
fun €subunit_form_inf› (ident : ID, is_inf : bool) : unit = (
	if	test_flag #subunit_flag 1
	then	let	val block = hd(!blocks);
			val block_name = #block_name(#declab block);
			val tbn_id = subunit_env_index block_name ident;
			val subunit1 = (force_value(s_lookup tbn_id (!subunit_env)))
				handle Fail _ =>
				fail "subunit_form_inf" 507011
						[fn()=>block_name, fn()=>ident];
			val dummy = new_parent_aux false
				 (trans_subunit_name(block_name, ident));
			val in_scope' = #in_scope subunit1;
			val block' = block_in_scope(block, in_scope');
		in	blocks := block' :: tl (!blocks);
			if	is_inf
			then	subunit_env := s_delete tbn_id (!subunit_env)
			else	()
		end
	else	()
);
=TEX
=SML
fun €subunit_form› (ident : ID) : unit = (
	subunit_form_inf (ident, false)
);
=TEX
\subsection{The SID function subunit\_inf}
=SML
fun €subunit_inf› (ident : ID) : unit = (
	subunit_form_inf (ident, true)
);
=TEX
\subsection{The SID function new\_scope\_proc\_inf}
=SML
fun €new_scope_proc_inf› (ident : ID) : unit = (
	let	val block = block_block_name(
				block_flags(empty_block, false_flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_proc\_inf}
=SML
fun €new_scope_proc_form› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = true,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false,
			body_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function stub}
This corresponds to $make\_module$ as used in the Z spec.
=SML
fun €stub› (() : unit) : unit = (
	if	test_flag #stub_flag 2
	then	let	val block1 = block 1;
			val block2 = block 2;
			val block3 = block 3;
			val block_name1 = #block_name (#declab block1);
			val block_name2 = #block_name (#declab block2);
			val block_name3 = #block_name (#declab block3);
			val id2 = block_name1;
			val id1 =
				if	test_flag #subunit_flag 3
				then	block_name3 dot block_name2
				else	block_name2;
			val id1_id2 = id1 dot id2;
			val tid1_id2 = subunit_env_index id1 id2;
			val subunit = {
				in_scope	=	flatten_env(!blocks),
				specif		=	dummy_spec,
				specif_flag	=	false,			
				zmod		=	id1_id2,
				globs		=	[]
			};
		in	make_module(trans_subunit_name(id1, id2));
			subunit_env := s_enter tid1_id2 subunit (!subunit_env)
		end
	else	()
);
=TEX
The following does all the work for $stub\_spec\_proc$ and $stub\_spec\_fun$.
=SML
fun €stub_spec_proc_fun› 
		(spec : SPEC) (globs : Z_ID list) : unit = (
	if	test_flag #stub_flag 2
	then	let	val block1 = block 1;
			val block2 = block 2;
			val block3 = block 3;
			val block_name1 = #block_name (#declab block1);
			val block_name2 = #block_name (#declab block2);
			val block_name3 = #block_name (#declab block3);
			val id2 = block_name1;
			val id1 =
				if	test_flag #subunit_flag 3
				then	block_name3 dot block_name2
				else	block_name2;
			val tid1_id2 = subunit_env_index id1 id2;
			val subunit = force_value(s_lookup tid1_id2(!subunit_env))
				handle Fail _ =>
				fail "stub_spec_proc_fun" 507011
						[fn()=>id1, fn()=>id2];
			val in_scope' = subprog_flatten_env (!blocks);
			val subunit' = {
				in_scope	= in_scope',
				specif		= spec,
				specif_flag	= true,			
				zmod		= #zmod subunit,
				globs		= globs
			};
		in	subunit_env := s_enter tid1_id2 subunit' (!subunit_env)
		end
	else	()
);
=TEX
=SML
fun €stub_spec_proc› (form_proc : FORMAL_PROC) : unit = (
	stub_spec_proc_fun (#spec form_proc) (#globals form_proc)
);
=TEX
\subsection{The SID function form\_proc}
The following is the meat of $vcs\_body\_proc$, placed here to allow
a check to be made of the VCs of a procedure specification in a package
specification.
=SML
fun €vcs_body_proc_aux› (st : STATEMENT) : (LABEL * (VC list * SPEC)) = (
	let	val block1 = block 1;
		val block2 = block 2;
		val pack_body_flag2 = #pack_body_flag (#flags (#declab block2));
		val current_formal_proc1 = #current_formal_proc block1;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val vc_inits1 = #var_inits(block1);
		val post1 = #post(#spec current_formal_proc1);
		val w1 = #w(#spec current_formal_proc1);
		val w_vcvars = list_cup (map (map trans_id o #vars) vc_vars1);
		val w = if pack_body_flag2
			then let val ran_uds = (map snd o #using_decs) block2;
				  val w_vars_uds = (list_cup o map #vars
						o list_cup o map fst) ran_uds;
			     in	
				w1 cup (w_vcvars diff w_vars_uds)
			     end
			else w1 cup w_vcvars;
		val in_scope = subprog_flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val current_for_vars1 = #current_for_vars block1;
		val current_log_cons1 = #current_log_cons block1;
		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = (#vc_pars in_scope) cup current_for_vars1,
			vc_log_cons = (#vc_log_cons in_scope) @ current_log_cons1,
			vc_aux_vars = #vc_aux_vars in_scope,
			formal_procs = #formal_procs in_scope,
			dec_labels = #dec_labels in_scope
		};
		val wp_env :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = formal_procs
		};
		val pre1 =  var_inits_pre
				(Value (#pre(#spec current_formal_proc1)))
				vc_inits1 
				(#env wp_env)
			handle exn => 
			pass_on exn "var_inits_pre" "vcs_body_proc_aux";
		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "â0") w,
			pre = pre1,
			post = post1
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = true,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope1
		};
	in	(#name current_formal_proc1, call_vcs (speclab, st))
	end	
);
=TEX

=SML
fun €check_formal_proc› (formal_proc : FORMAL_PROC) : SPEC = (
let
	(* mimic curr_form_proc & mimic being in proc body *)
	val block1 = block 1;
	val block2 = block 2;
	val dummy1 = (blocks :=
		block_current_formal_proc (block1, formal_proc) :: tl(!blocks));
	
	(* pretend to be in a package body *)
	val {block_name = block_name2,
		flags = flags2,
		in_scope = in_scope2}  = #declab block2;
	val new_flags2 = {
			pack_spec_flag = false,
			pack_body_flag = true,
			stub_flag = #stub_flag flags2,
			subunit_flag = #subunit_flag flags2,
			formal_body_flag = true,
			fun_flag = #fun_flag flags2,
			declabel_flag = #declabel_flag flags2,
			speclabel_flag = #speclabel_flag flags2,
			till_flag = #till_flag flags2,
			body_flag = true
		};
	val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "check_formal_proc" 507012 [fn()=>block_name2];
	val new_in_scope2 = in_scope_vc_aux_vars (in_scope2, 
		union (op =$) (#vc_aux_vars in_scope2) (#aux_vars package));
	val new_declab2 =  {block_name = block_name2,
		flags = new_flags2,
		in_scope = new_in_scope2};
	val new_block2 = block_declab (block2, new_declab2);
	val dummy2 = (blocks := (block 1 :: (new_block2 :: tl(tl (!blocks)))));
	(* create the vcs for a null statement *)
	val (_, (vcs, spec)) = vcs_body_proc_aux STNull;
	val vcs = map term_of_vc vcs
		handle (exn as Fail _) =>
		(blocks :=
		block1 :: block2 :: tl(tl(!blocks));
		raise exn);
	(* undo mimic of curr_form_proc & flag2 changes *)
	val dummyu1 = (blocks :=
		block1 :: block2 :: tl(tl(!blocks)));
in	spec
end);
=TEX
=SML
fun €form_proc_pack_spec› (form_proc: FORMAL_PROC) : unit = (
	let	val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_proc_pack_spec" 507012 [fn()=>block_name2];
		val dummy = check_formal_proc form_proc;
		val formal_procs = #formal_procs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_formal_procs(package,
				formal_procs @ [form_proc]))
		(!pack_env)
	end
);
=TEX
The following function is common to {\it form\_proc\_pack\_body\_common},
{\it form\_proc\_subunit}.
=SML
fun €check_globals_proc› (block_name1 : string)
	(fp : FORMAL_PROC) (globals3 : Z_ID list) : unit = (
	if	is_nil ((#globals fp diff #w (#spec fp)) diff globals3)
	then	()
	else	let	fun fmt_strs [] () = (
				"empty list of global dependencies"
			) | fmt_strs strs () = (
				format_list Combinators.I strs ", "
			);
		in	fail "check_globals_proc" 507058
			[fmt_strs (#globals fp diff #w (#spec fp)), fmt_strs globals3,
			fn()=>block_name1]
		end
);
=TEX
The VC generator is responsible for distinguishing specification between statements with and without initial variables.
Here, we follow the parser in generating the form without initial variables for it to modify as necessary.
=SML
fun €form_proc_pack_body_common› (form_proc: FORMAL_PROC)
	: (BLOCK * FORMAL_PROC * PACKAGE * SPECLAB) OPT = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val package4 = (force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_proc_pack_body_common" 507012
					[fn()=>block_name2];
		val formal_procs4 = #formal_procs package4;
	in	if	any
			formal_procs4
			(fn p => #name p = block_name1)
		then	
	let
		val formal_proc3 =
			find 
			formal_procs4
			(fn p => #name p = block_name1);
		val _ = check_globals_proc block_name1 form_proc (#globals formal_proc3);
		val vc_vars2 = #vc_vars(#in_scope(#declab block2));
		val vc_vars5 = #vc_vars(flatten_env (tl (!blocks)));
		val vc_vars4 = #vc_vars package4;
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val vc_aux_vars5 = (#vc_aux_vars (flatten_env(!blocks)))
			 term_diff
			 (#aux_vars package4);
		val in_scope5 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_aux_vars = vc_aux_vars5,
			vc_vars = vc_vars5,
			vc_pars = vc_pars1			
		};
		val wp_env5 :WP_ENV = {
			env = cn_env_of_in_scope in_scope5,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = []
		};
		val pack_body_vars = vc_vars2 diff vc_vars4;
		val spec3 = #spec formal_proc3;
		val w5 = (#w spec3) cup
				(flat (map (map trans_id o #vars) pack_body_vars));
		val spec5 : SPEC = {
			w = w5,
			w0 = map (fn s => s^"â0") w5,
			pre = #pre spec3,
			post = #post spec3
		};
		val speclab5 : SPECLAB = {
			spec = spec5,
			formal_body_flag = false,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env5,
			in_scope = in_scope5
		};
	in
		Value (block2, formal_proc3, package4, speclab5)
	end
	else
		Nil
	end
);
=TEX
The default values for the $speclab$ in the following function are set up by the common function above. 
=SML
fun €form_proc_pack_body›
	(block2 : BLOCK, formal_proc3 : FORMAL_PROC,
			package4 : PACKAGE, speclab5 : SPECLAB)
	(form_proc: FORMAL_PROC) : SPEC = (
	let	val vc_vars5a = #vc_vars (flatten_env(!blocks));
		val speclab5a = speclab_wp_env_from_in_scope 
			(speclab_vc_vars(speclab5, vc_vars5a));
		val st = STSpecNoIvars{spec= #spec form_proc,
					label=""};
		val (vcs, spec) = call_vcs (speclab5a, st);
	in	store_vcs (#name formal_proc3, vcs);
		spec
	end
);
=TEX
In the following, the first parameter tuple is the information returned from $form\_proc\_pack\_body\_common$;
the second parameter is the list of auxiliary variables (as HOL terms) returned by $aux\_vars\_in\_fp\_frame$.
N.B. this function relies on the type inference context set up in $aux\_vars\_in\_fp\_frame$.
=SML
fun €form_proc_pack_body_aux›
	(block2 : BLOCK, formal_proc3 : FORMAL_PROC,
			package4 : PACKAGE, speclab5 : SPECLAB)
	(avs : TERM list)
	(form_proc: FORMAL_PROC) : SPEC = (
	let	val block1 = block 1;
		val spec3 = #spec formal_proc3;
		val w3 = #w spec3;
		val add_aux = avs drop (fn v => fst(dest_var v) mem w3);
		val w6 = w3 cup map (fst o dest_var) add_aux;
		val pre6 = #pre spec3;
		val post3 = #post spec3;
		val add_aux0 = map ((fn (n, ty) => mk_var(n^"â0", ty)) o dest_var)
					add_aux;
		val post6 = z_quote (z_many_and
						([z_pred_of_z_tm post3] @
						 map z_eq (combine add_aux add_aux0)),
				Nil);
		val aux_vars4 = #aux_vars package4;
		val aux_vars_decs = map dest_z_dec aux_vars4;
		val aux_vars_newdecs = flat (map (fn (tml,ty) =>
						map (fn t => (t,ty)) tml)
							aux_vars_decs);
		val aux_vars_tab = map (fn (tm, ty) => (dest_z_lvar tm, ty))
								aux_vars_newdecs;
		val aux_vars_tab1 = aux_vars_tab drop
					(fn ((s, _, _), _) => not(s mem w6));
		val aux_vars = map (fn (lv,ty) => mk_z_dec([mk_z_lvar lv], ty))
					aux_vars_tab1;
		val aux_vars_tab0 = map (fn ((s,y,z),t) => ((s^"â0",y,z),t))
							aux_vars_tab1;
		val aux_vars0 = map (fn (lv,ty) => mk_z_dec([mk_z_lvar lv], ty))
					aux_vars_tab0;
		val seq_aux = aux_vars0;
		val using_decs2 = #using_decs block2;
		val ud2_rel_image = (using_decs2 drop
						(fn n => not (fst n mem w6)));
		val conc_vars = (list_cup o map fst o map snd) ud2_rel_image;
		val invs = (map snd o map snd) ud2_rel_image;
		val frame_aux_conc = w6 cup (list_cup (
					map (map trans_id o #vars) conc_vars));
		val frame_aux_conc0 = map (fn s => s^"â0") frame_aux_conc;

		val w5 = frame_aux_conc cup (#w (#spec speclab5));
		
		val pre5 = z_quote (z_exists (aux_vars,
				z_many_and(z_pred_of_z_tm pre6::invs)),
				Nil);
		val post5 = z_quote (z_forall (seq_aux, z_imp (subs_pred (
			  z_many_and (z_pred_of_z_tm pre6::invs),
					frame_aux_conc, frame_aux_conc0),
			    z_exists (aux_vars,
				z_many_and(z_pred_of_z_tm post6::invs)))),
			Nil);

		val in_scope5 = #in_scope speclab5;
		val vc_varsENV = #vc_vars (flatten_env (!blocks));
		val vc_vars1 = #vc_vars (#in_scope (#declab block1));
		val in_scope5a = in_scope_vc_vars(in_scope5, 
					vc_varsENV cup conc_vars);
		val wp_env5a :WP_ENV = {
			env = cn_env_of_in_scope in_scope5a,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = #formal_procs (#wp_env speclab5)
		};
		val spec5 : SPEC = {
			w = w5,
			w0 = map (fn s => s^"â0") w5,
			pre = pre5,
			post = post5
		};
		val speclab5a : SPECLAB = {
			spec = spec5,
			formal_body_flag = false,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env5a,
			in_scope = in_scope5a
		};
		val st = STSpecNoIvars{spec= #spec form_proc, label=""};
		val _ = blocks :=
			block_vc_vars(block1, vc_vars1 cup conc_vars):: tl (!blocks);
		val (vcs, spec) = call_vcs (speclab5a, st);
	in	store_vcs (#name formal_proc3, vcs);
		spec
	end
);
=TEX
=SML
fun €form_proc_subunit› (form_proc: FORMAL_PROC) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val tbn1_bn2 = subunit_env_index block_name2 block_name1
		val subunit3 = (force_value(s_lookup tbn1_bn2 (!subunit_env)))
			handle Fail _ => fail "form_proc_subunit" 507011
					[fn()=>block_name2, fn()=>block_name1];
	in	subunit_env := s_delete tbn1_bn2 (!subunit_env);
		if	#specif_flag subunit3
		then	
	let
		val st = STSpecNoIvars{spec= #spec form_proc,
			label=""};
		val _ = check_globals_proc block_name1 form_proc (#globs subunit3);
		val vc_vars3 = #vc_vars(#in_scope(subunit3));
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val vc_aux_vars3 = #vc_aux_vars (#in_scope (subunit3));
		val in_scope4 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_aux_vars = vc_aux_vars3,
			vc_vars = vc_vars3,
			vc_pars = vc_pars1			
		}
		val wp_env4 :WP_ENV = {
			env = cn_env_of_in_scope in_scope4,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = []
		};
		val speclab4 : SPECLAB = {
			spec = #specif subunit3,
			formal_body_flag = false,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env4,
			in_scope = in_scope4
		};
		val (resulting_vcs, _) = call_vcs (speclab4, st)
	in	store_vcs (block_name1, resulting_vcs)
	end
		else	()
	end
);
=TEX
=SML
fun €check_stub_spec_proc› (form_proc: FORMAL_PROC) : unit = (
	if	test_flag #stub_flag 2
	then	let	val in_scope = flatten_env(!blocks)
			val wp_env :WP_ENV = {
				env = cn_env_of_in_scope in_scope,
				till = mk_z_true,
				return = mk_z_true,
				fun_header = dummy_informal_fun,
				formal_procs = []
			};
			val speclab : SPECLAB = {
				spec = #spec form_proc,
				formal_body_flag = false,
				fun_flag = false,
				till_flag = false,
				wp_env = wp_env,
				in_scope = in_scope
			};
		in	 call_vcs(speclab, STNull); ()
		end
	else	()
);
=TEX
=SML
fun €z_par_decl› (par_spec : PARAM_SPEC) : Z_DECL = (
	let	fun aux1 ({vars, tmark} : VAR_DECL) : Z_DECL = (
			let	val e = (zid current_cn_env o trans_id) tmark;
				val ty = (dest_z_power_type o type_of) e;
				fun v var = mk_z_lvar(var, ty, []);
			in	mk_z_dec(map v vars, e)
			end
		);
	in	(aux1 o #var_decl) par_spec
	end
	handle exn => pass_on exn "zid" "z_par_decl"
);
=TEX
The following function is required to determine whether $form\_proc$ should call $form\_proc\_pack\_body$ or $form\_proc\_pack\_body\_aux$.
It computes a list of HOL terms representing the set of variables which is tested in the first clause in the predicate part of the corresponding Z schemas in the specification.
=SML
fun €aux_vars_in_fp_frame› (formal_proc3 as {formal_ids, ...} : FORMAL_PROC)
			(package4 : PACKAGE) : TERM list = (
	let	val f = map (fst o dest_var) o frees o z_predexp_of_z_tm;
		val spec3 = #spec formal_proc3;
		val side1 = set_package_ti_context package4;
		val side2 = add_params_ti_context formal_ids;
		val free = (f o #pre) spec3 cup (f o #post) spec3;
		val w3 = #w (#spec formal_proc3);
		val w3free = w3 cup free;
		val aux_vars4 = #aux_vars package4;
		val aux_vars4_tms = (flat o map fst o map dest_z_dec) aux_vars4;
	in
		aux_vars4_tms drop (fn v => not (fst (dest_var v) mem w3free))
	end
);
=TEX
=SML
fun €form_proc› (frm_prc: FORMAL_PROC) : unit = (
	if		test_flag #pack_spec_flag 2
	then		form_proc_pack_spec frm_prc
	else if		test_flag #pack_body_flag 2
	then
		case form_proc_pack_body_common frm_prc of
		Value (info as (_, formal_proc3, package4, _)) => (
			case aux_vars_in_fp_frame formal_proc3 package4 of
				[]	 => (form_proc_pack_body info frm_prc; ())
			|	auxvars => (form_proc_pack_body_aux info auxvars frm_prc; ())
		) | Nil =>	()
	else if		test_flag #subunit_flag 2
	then		form_proc_subunit frm_prc
	else		()
);
=TEX
\subsection{The SID function curr\_form\_proc}
=SML
fun €curr_form_proc› (formal_proc : FORMAL_PROC) : unit = (
	let	val block1 = block 1;
	in	blocks :=
		block_current_formal_proc (block1, formal_proc) :: tl(!blocks)
	end
);
=TEX
\section{FUNCTIONS}\label{FUNCTIONS}
\subsection{The SID function new\_scope\_fun\_inf}
=TEX
=SML
fun €new_scope_fun_inf› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = true,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false,
			body_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_fun\_form}
=TEX
=SML
fun €new_scope_fun_form› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = true,
			fun_flag = true,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false,
			body_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function stub\_spec\_fun}
=SML
fun €stub_spec_fun› (form_fun : FORMAL_FUN) : unit = (
	stub_spec_proc_fun (#spec form_fun) (#globals form_fun)
);
=TEX
\subsection{The SID function inf\_fun}
=TEX
The decision of which of the following two functions to call is made in $inf\_fun$
=SML
local
val €informal_function_ty› : TYPE = mk_ctype(informal_function, []);
val €informal_function_gvar› : Z_EXP =
	mk_z_gvar(informal_function, mk_z_power_type informal_function_ty, []);
in
fun €inf_fun_decl› ({name, ...}: INFORMAL_FUN) : (Z_DECL * Z_ID) = (
	let	val n = trans_id name;
		val zexp = informal_function_gvar;
		val zvar = mk_z_lvar(n, informal_function_ty, [])
	in	(mk_z_dec([zvar], zexp), n)
	end
);
fun €trans_informal_fun› (f : INFORMAL_FUN) : PARAINFO = (
	let	val (dec, n) = inf_fun_decl f;
	in	AxDesInfo([], mk_z_decl[dec], Nil, [(n, informal_function_ty)])
	end
);
end;
=TEX
=SML
fun €inf_fun_pack_spec› (inf_fun: INFORMAL_FUN) : unit = (
	let	val test_save = test_store_para(trans_informal_fun inf_fun);
		val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "inf_fun_pack_spec" 507012 [fn()=>block_name2];
		val informal_funs = #informal_funs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_informal_funs(package,
				informal_funs @ [inf_fun]))
		(!pack_env)
	end
);
=TEX
=SML
fun €inf_fun_otherwise› (inf_fun: INFORMAL_FUN) : unit = (
	store_para(trans_informal_fun inf_fun);
	add_spark_function_info [] inf_fun
);
=TEX
=SML
fun €inf_fun› (informal_fun: INFORMAL_FUN) : unit = (
	(if	test_flag #pack_spec_flag 2
	then	inf_fun_pack_spec
	else	inf_fun_otherwise) informal_fun
);
=TEX
\subsection{The SID function form\_fun}
=TEX
=SML
fun €z_forall_opt› (decs : Z_DECL list, zpred : Z_PRED) : Z_PRED = (
	case decs of
		[] =>	zpred
	|	_ => z_forall(decs, zpred)
);
=TEX
=SML
fun €z_var_decl› (cnenv : CN_ENV) (zname : Z_ID) : Z_DECL = (
	let	val zexp = var_sig cnenv zname;
		val ty = (dest_z_power_type o type_of) zexp;
	in	mk_z_dec([mk_z_lvar(zname, ty, [])], zexp)
	end
	handle exn => pass_on exn "var_sig" "z_var_decl"
);
=TEX
The decision of which of the four cases to apply is made in $form\_fun$
=TEX
=SML
fun €trans_formal_fun› (cnenv : CN_ENV)
			(form_fun as {
			spec as {pre, post, ...},
			informal_fun as {formal_pars, ...},
			globals} : FORMAL_FUN)
				: PARAINFO = (
	let	val dec = fun_decl cnenv form_fun;
		val pardecs = map z_par_decl formal_pars
			handle exn => pass_on exn "z_par_decl" "trans_formal_fun";
		val globdecs = map (z_var_decl cnenv) globals
			handle exn => pass_on exn "z_var_decl" "trans_formal_fun";
		val ntys = (map dest_var o fst o dest_z_dec) dec;
		val new_ti_cxt = frees dec term_union flat
				(map frees (pardecs @ globdecs));
		val side = set_current_ti_context new_ti_cxt;
		val imp = z_imp(z_pred_of_z_tm pre, z_pred_of_z_tm post);
		val pred = z_forall_opt(globdecs, z_forall_opt(pardecs, imp));
	in	AxDesInfo([], mk_z_decl[dec], Value pred, ntys)
	end
);
=TEX
=SML
fun €form_fun_pack_spec› (form_fun: FORMAL_FUN) : unit = (
	let	val test_save = test_store_para
			(trans_formal_fun current_cn_env form_fun);
		val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_fun_pack_spec" 507012 [fn()=>block_name2];
		val formal_funs = #formal_funs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_formal_funs(package,
				formal_funs @ [form_fun]))
		(!pack_env)
	end
);
=TEX
The VC generator is responsible for distinguishing specification between statements with and without initial variables.
Here, we follow the parser in generating the form without initial variables for it to modify as necessary.
=SML
fun €form_fun_pack_body› (form_fun: FORMAL_FUN) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val package4 = (force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_fun_pack_body" 507012 [fn()=>block_name2];
		val formal_funs4 = #formal_funs package4;
	in	store_para(trans_formal_fun current_cn_env form_fun);
		add_spark_function_info (#globals form_fun) (#informal_fun form_fun);
		if	any
			formal_funs4
			(fn f => #name(#informal_fun f) = block_name1)
		then	
	let
		val formal_fun3 =
			find 
			formal_funs4
			(fn f => #name(#informal_fun f) = block_name1);
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val in_scope5 = subprog_flatten_env(!blocks);
		val wp_env5 :WP_ENV = {
			env = cn_env_of_in_scope in_scope5,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = #informal_fun form_fun,
			formal_procs = []
		};
		val speclab5 : SPECLAB = {
			spec = #spec formal_fun3,
			formal_body_flag = true,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env5,
			in_scope = in_scope5
		};
		val st = STSpecNoIvars{spec= #spec form_fun, label=""};
		val globals = #globals form_fun;
		val globals3 = #globals formal_fun3;
	in	if	globals = globals3
		then	let	val (vcs, _) = call_vcs (speclab5, st);
			in	store_vcs (block_name2, vcs)
			end
		else	let	fun fmt_strs [] () = (
					"empty list of global dependencies"
				) | fmt_strs strs () = (
					format_list Combinators.I strs ", "
				);
			in	fail "form_fun_pack_body" 507050
				[fmt_strs globals, fmt_strs globals3,
				fn()=>block_name1]
			end
	end
		else	()
	end
);
=TEX
=SML
fun €check_globals_fun› (block_name1 : string)
	(globals : Z_ID list) (globals3 : Z_ID list) : unit = (
	if	globals = globals3
	then	()
	else	let	fun fmt_strs [] () = (
				"no global dependencies"
			) | fmt_strs strs () = (
				format_list Combinators.I strs ", "
			);
		in	fail "check_globals_fun" 507050
			[fmt_strs globals, fmt_strs globals3,
			fn()=>block_name1]
		end
);
=TEX
=SML
fun €form_fun_subunit› (form_fun: FORMAL_FUN) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val tbn1_bn2 = subunit_env_index block_name2 block_name1
		val subunit3 = (force_value(s_lookup tbn1_bn2 (!subunit_env)))
			handle Fail _ =>
			fail "form_fun_subunit" 507011
	 			[fn()=>block_name2, fn()=>block_name1];
	in	store_para(trans_formal_fun current_cn_env form_fun);
		add_spark_function_info (#globals form_fun) (#informal_fun form_fun);
		subunit_env := s_delete tbn1_bn2 (!subunit_env);
		if	#specif_flag subunit3
		then	
	let
		val st = STSpecNoIvars{spec= #spec form_fun,
				label=""};
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val in_scope4 = subprog_flatten_env(!blocks);
		val wp_env4 :WP_ENV = {
			env = cn_env_of_in_scope in_scope4,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = #informal_fun form_fun,
			formal_procs = []
		};
		val speclab4 : SPECLAB = {
			spec = #specif subunit3,
			formal_body_flag = true,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env4,
			in_scope = in_scope4
		};
		val globals = #globals form_fun;
		val globals3 = #globs subunit3;
		val _ = check_globals_fun block_name1 globals globals3;
		val (vcs, _) = call_vcs(speclab4, st);
	in	store_vcs (block_name2, vcs) 
	end
		else	()
	end
);
=TEX
=SML
fun €form_fun_otherwise› (form_fun: FORMAL_FUN) : unit = (
	store_para(trans_formal_fun current_cn_env form_fun);
	add_spark_function_info (#globals form_fun) (#informal_fun form_fun)
);
=TEX
=SML
fun €form_fun› (form_fun: FORMAL_FUN) : unit = (
	(if		test_flag #pack_spec_flag 2
	then		form_fun_pack_spec
	else if		test_flag #pack_body_flag 2
	then		form_fun_pack_body
	else if		test_flag #subunit_flag 2
	then		form_fun_subunit
	else		form_fun_otherwise) form_fun
);
=TEX
\subsection{The SID function curr\_form\_fun}
=SML
fun €curr_form_fun› (formal_fun : FORMAL_FUN) : unit = (
	let	val block1 = block 1;
	in	blocks :=
		block_current_formal_fun (block1, formal_fun) :: tl(!blocks)
	end
);
=TEX
\section{FORMAL PARAMETERS}\label{FORMALPARAMETERS}
\subsection{The SID function formal\_part}
=TEX
=SML
fun €mk_param_spec› ({idlist, mode, name} : PARAMETER_SPECIFICATION)
		: PARAM_SPEC = (
	{mode = mode, var_decl = {vars = idlist, tmark = name}}
);
=TEX
=SML
fun €fformal_part› (par_specs : PARAMETER_SPECIFICATION list) : unit = (
	let	val block1 = block 1;
		val formals = map mk_param_spec par_specs;
	in	blocks := block_vc_pars (block1, formals) :: tl(!blocks)
	end
);
=TEX

\section{SUBPROGRAM BODIES}\label{SUBPROGRAMBODIES}
\subsection{The SID function update\_envs\_proc}
The decision whether to call the three auxiliary functions is made in $update\_envs\_proc$ itself (since the test is the same in each case).

In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_proc› (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab2 mem dec_labels
			then	(id1_id2,
				subunit_formal_procs(s,
					current_formal_proc1 :: formal_procs))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_proc› (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_dec_label
			(dec_label_d as
				(dec_label,
				d as {in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab2 mem dec_labels
			then	(dec_label,
				declab_formal_procs(d, 
					current_formal_proc1 :: formal_procs))
			else	dec_label_d
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
The identifiers in the variable declaration are translated first.
=SML
fun €update_spec_env_proc› (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab2 mem dec_labels
			then	(spec_label,
				speclab_formal_procs(s, 
					current_formal_proc1 :: formal_procs))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun €update_envs_proc› (() : unit) : unit = (
	if	test_flag #declabel_flag 2 andalso test_flag #formal_body_flag 1
	then	(update_subunit_env_proc ();
		update_dec_env_proc ();	
		update_spec_env_proc ())
	else	()
);
=TEX
\subsection{The SID function add\_proc\_env}
=SML
fun €add_proc_env› (() : unit) : unit = (
	if	test_flag #formal_body_flag 1
	then	let	val block1 = block 1;
			val current_formal_proc1 =
					#current_formal_proc(block 1);
			val block2 = block 2;
			val formal_procs2 =
					#formal_procs(#in_scope(#declab block2));
			val block2' = block_formal_procs(block2,
					current_formal_proc1 :: formal_procs2);
		in	blocks := block1 :: block2' :: tl(tl(!blocks))
		end
	else	()
);
=TEX
\subsection{The SID function subprogram\_implementation}
=SML
fun €subprogram_implementation› ((): unit) : unit = (
	let	val block1 = block 1;
	in	blocks := block_body_flag (block1, true) :: tl(!blocks)
	end
);
=TEX
\subsection{The SID function vcs\_body}
The decision about which support function to call (if any) is made in $vcs\_body$ itself.

=SML
fun €vcs_body_proc› (st : STATEMENT) : SPEC = (
	let	val (lab, (vcs, spec)) = vcs_body_proc_aux st;
	in	store_vcs (lab, vcs);
		spec
	end
);
=TEX
=SML
fun €vcs_body_fun› (st : STATEMENT) : SPEC = (
	let	val block1 = block 1;
		val current_formal_fun1 = #current_formal_fun block1;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val vc_inits1 = #var_inits block1;
		val post1 = #post(#spec current_formal_fun1);
		val w = flat (map (map trans_id o #vars) vc_vars1);
		val in_scope = subprog_flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val current_for_vars1 = #current_for_vars block1;
		val current_log_cons1 = #current_log_cons block1;
		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = (#vc_pars in_scope) cup current_for_vars1,
			vc_log_cons = (#vc_log_cons in_scope) @ current_log_cons1,
			vc_aux_vars = #vc_aux_vars in_scope,
			formal_procs = #formal_procs in_scope,
			dec_labels = #dec_labels in_scope
		};
		val fun_dec = fun_decl current_cn_env current_formal_fun1;
		val side1 = set_in_scope_ti_context in_scope1;
		val side2 = set_ti_context
			(frees fun_dec @ get_ti_context());
		val wp_env : WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = mk_z_true,
			return = z_pred_of_z_tm post1,
			fun_header = #informal_fun current_formal_fun1,
			formal_procs = formal_procs
		};
		val pre1 =  var_inits_pre
				(Value (#pre(#spec current_formal_fun1)))
				vc_inits1 
				(#env wp_env)
			handle exn =>
			pass_on exn "var_inits_pre" "vcs_body_fun";
		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "â0") w,
			pre = pre1,
			post = post1
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = true,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope1
		};
		val (vcs, spec) = call_vcs (speclab, st);
	in	store_vcs((#name o #informal_fun) current_formal_fun1, vcs);
		spec
	end	
);
=TEX
=SML
fun €vcs_body› (st : STATEMENT) : unit = (
	if	test_flag #formal_body_flag 1
	then	if	test_flag #fun_flag 1
		then	(vcs_body_fun st; ())
		else	(vcs_body_proc st; ())
	else	()
);
=TEX
\section{PACKAGES}\label{PACKAGES}
\subsection{The SID function new\_scope\_pack\_spec}
=SML
fun €empty_package› () : PACKAGE = 
	{	vc_vars				=	[],
		consts_types			=	[],
		formal_procs			=	[],
		informal_funs			=	[],
		formal_funs			=	[],
		aux_vars			=	[],
		zmod 				=	(!script_name)
	};
=TEX
=SML
fun €new_scope_pack_spec› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = true,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false,
			body_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks;
		pack_env := s_extend ident (empty_package ()) (!pack_env) 
	end	handle Fail _ => fail "new_scope_pack_spec" 507007 [fn () => ident]
);
=TEX

\subsection{The SID function new\_scope\_with}
N.B. $new\_scope\_pack\_body$ has been moved after this section.

The prefixing of names required for $new\_scope\_with$ demands a fair amount of {\Product}-specific code which is not formally specified.
The main issue is that we have to type-check every term in which names are to be prefixed in order to perform a semantically correct substitution using the HOL substitution operation.
The approach is to introduce a temporary theory into which we put Z paragraphs representing the objects in the package with their names unprefixed.
In the context of this temporary theory, we can type-check all the terms which appear as procedure specifications etc.

First of all we define $new\_ids$ according to the specification.

=SML
fun €new_ids› (p : PACKAGE) : ID list = (
	let	val {vc_vars, consts_types, formal_procs,
			informal_funs, formal_funs, aux_vars, ...} = p;
		val v = flat (map #vars vc_vars);
		fun do_enums ({type_def,...} : TYPE_DEF TYPE_DECL) = (
			case type_def of
				TDEnumTypeDef etd =>		#vals etd
			|	_ =>				[]
		);
		val c_t_ident_s = flat (map (fn ct =>
				case ct of
					BDConstDecl cd =>	#consts cd
				|	BDTypeDecl td =>	#name td :: do_enums td
				|	BDSubtypeDecl std =>	[#name std]
				|	_ =>			[]
				) consts_types);
		val p = map #name formal_procs;
		val f1 = map #name informal_funs;
		val f2 = map (#name o #informal_fun) formal_funs;
		val a = flat (map z_names_of_z_dec aux_vars);
	 
	in
		list_cup [v, c_t_ident_s, p, f1, f2, a]
	end
);
=TEX
The following function, {\it is\_id\_in\_package}, returns true if $id$ or any of its attributes are in the set of $newids$, or any of its initial variables.

{\it is\_id\_in\_package names ident} first discards any trailing zero-subscript
from {\it ident}; if the result is a member of the list {\it names},
it returns true, otherwise it splits it up into a sequence of
elements separated by the characters `v' or `u'.
Suppose the resulting sequence is equal to $N_0, N_1, ldots Nk$.
The function will then return true iff. each $N_i$ contains no
lower case letters and also one of the following holds:

\begin{enumerate}
\item
$k = 0$ and $N_0$ is in names --- this is just a name defined in the package.
\item
$k = 1$, $N_0$ is in names and the separator between $N_0$ and $N_1$ was `u' --- this
is taken to be a record update function for the type with type mark $N_0$.
\item
$k \ge 1$, $N_0$ is in names, each $N_i$, for $1 \le i \le k $, is an attribute identifier
and the separators were all `v' --- this is taken to be the translation of an attribute.
\item
$k \ge 2$, $N_0$ is in names, each $N_i$, for $1 \le i < k$, is an attribute identifier,
the separators were all `v' and $N_k$ is a decimal number ---
this is taken to be the translation of an attribute with a numeric argument.
\end{enumerate}

=SMLPLAIN
local
	val ord0 = ord("0");
	val ord9 = ord("9");
	fun is_digit (c:string) : bool = (
		let	val ordc = ord c;
		in	ord0 <= ordc andalso ordc <= ord9
		end
	);
	fun split_up
		(separators : string list)
		((ns, seps) : string list list * string list)
		(name : string list) : string list list * string list = (
			case name of
				[] => (ns, seps)
			|	ch::more => (
					if	ch mem separators
					then	split_up separators
						([]::ns, ch::seps) more
					else	split_up separators
						((ch::hd ns)::tl ns, seps) more
			)							
	);
	fun loseâ0 ("0"::"â"::rest) = rest
	|   loseâ0 other = other;
in		
fun €is_id_in_package› (newids : ID list) (id : ID) : bool = (
		id mem newids orelse
	let	val base = loseâ0 (rev (explode id));
	in	implode (rev base) mem newids orelse
	let	val (ns, seps) = split_up ["v", "u"] ([[]], []) base;
		fun is_an_attr ns = implode ns mem ada_attributes_list;
	in	case (ns, seps) of
			([], _) => false
		|	([n0], []) => implode n0 mem newids
		|	([n0, n1], ["u"]) => implode n0 mem newids
		|	([n0, n1], ["v"]) => implode n0 mem newids andalso is_an_attr n1
		|	(n0::more, uvs) => (
				case rev more of
					[] => false (* can't happen *)
				|	(nk :: attrs) => (
					(is_an_attr nk orelse all nk is_digit) andalso
					implode n0 mem newids andalso
					all attrs is_an_attr andalso
					all uvs (fn uv => uv = "v")
				)
		)
	end end
);
end;
=TEX
The handling of the theory hierarchy was rationalised considerably during
the IUCT project in 1997. Unfortunately, a small amount of legacy code
and nomenclature persisted beyond that project. The ``internal specification
theory'' that used to be set up to hold the Z definitions needed to type-check
a package specification is no longer needed --- the one-compilation-unit-per-script
rule now means that it is the user who defines the script theory in which
those Z definitions are placed. By agreement with DERA a potential soundness problem
is avoided by agreeing that Z definitions are not generated for the functions
in the package. Thus the former ``internal specification theory'' is replaced
by the ``specification script theory''.

In the case of a package nested within a package or subprogram body, the
``specification script theory'' is the script theory for the containing body.


The following function extracts from the specification script theory the types
(corresponding to given sets) and the constants
(corresponding to global variables) together with their definitions if any.
=SML
fun €spec_script_theory_types_and_const_thms› (spec_script_thy : ID)
	: string list * (TERM * THM OPT) list = (
	let	val type_names = rev(map (fst o dest_ctype) (get_types spec_script_thy));
		val consts = get_consts spec_script_thy;
		val const_thms = rev (map (fn x => (x, (Value (get_spec x)
						handle Fail _=> Nil))) consts);
	in	(type_names, const_thms)
	end
);
=TEX
The following functions are used to rename the HOL type names corresponding to given sets in the theory.
Note that neither are visible outside this module, and they work by raising
failures for no change.
=SML
val €just_fail› = fail "just_fail" 3064  [] handle complaint => complaint;

fun €type_subst_type› (subs : (string * string) list) (ty : TYPE) : TYPE = (
let
	(* bool param is interpreted as "anything changed?" *)
	fun aux1 aty = (
	let 	fun aux b [] = (
			if b then [] else raise just_fail
		) | aux b (a :: x) = (
			let val (a', b') = (aux1 a, true) 
				handle _ => (a, b)
			in
				(a' :: aux b' x)
			end
		);
	in
	case dest_simple_type aty of
		Vartype _ => raise just_fail
	|	Ctype(con, pars) => (
		   case rassoc5 subs con of
			(* constructor name changed *)
			Value con' => 
			   mk_ctype(con', 
				map (fn p => aux1 p 
					       handle _ => p) 
					pars)
			(* no constructor name change, so if pars also
			   unchanged then fail *)
		       | Nil => mk_ctype (con, aux false pars)
	)
	end);
in
	aux1 ty
end);

=IGN
let	val b = mk_ctype("b",[]);
	val c = mk_ctype("c",[]);
	val d = mk_ctype("d",[]);
	val av = mk_vartype "a";
	val big = list_mk_≠_type [
		mk_ctype("a",[c, d]),
		b,
		mk_ctype("e", [av]),
		mk_ctype("a", [av, b]),
		mk_ctype("a", [b, av]),
		mk_ctype("a", [mk_ctype("a", [b, av]), b]),
		mk_ctype("f", [c,d]),
		mk_ctype("f", [av, b]),
		mk_ctype("f", [b, av]),
		mk_ctype("f", [mk_ctype("a", [b, av]), b])];
in		
type_subst_type [("x","a"),("y","b")] 
big
end;
=TEX
=SML
fun type_subst_term (subs : (string * string) list) (tm : TERM) : TERM = (
	let	val do_ty = type_subst_type subs;
		fun aux tm = (
			case dest_simple_term tm of
				Const(nm, ty) => mk_const(nm, do_ty ty)
			|	Var(nm, ty) => mk_var(nm, do_ty ty)
			|	App(tm1, tm2) => (
				let val tm1' = aux tm1;
				in
					mk_app(tm1', 
						(aux tm2 handle (Fail _) => tm2))
				end
				handle (Fail _) => mk_app(tm1, aux tm2)
			) |	SimpleÃ(v, tm1) => (
				let val v' = aux v;
				in
					mk_simple_Ã(v', 
						(aux tm1 handle (Fail _) => tm1))
				end
				handle (Fail _) => mk_simple_Ã(v, aux tm1)
			)
		);
	in	case subs of
			[] => tm
		|	_ => (aux tm handle (Fail _) => tm)
	end
);
=IGN
set_flag("pp_show_HOL_types",true);	
let	val b = mk_var("b", mk_ctype("bt",[]));
	val c = mk_const("c", mk_ctype("ct",[]));
	val d = mk_simple_Ã (mk_var("d", mk_ctype("dt",[])), ¨d1Æ);
	val e = mk_simple_Ã (mk_var("a", mk_ctype("at",[])), ¨d1Æ);
	val f = mk_simple_Ã (mk_var("d", mk_ctype("dt",[])), b);
	val g = mk_app(mk_const("a", 
		mk_≠_type(mk_ctype("ct",[]), mk_ctype("at",[]))),
		c);
in	
type_subst_term [("x","at"),("y","bt")] 
	¨(ëbÆ, ëcÆ, ëdÆ, ëeÆ, ëfÆ,  ëgÆ)Æ
end;
set_flag("pp_show_HOL_types",false);
=TEX
Now we define various functions to do the actual prefixing of identifiers, terms etc.
=SML
fun €prefix_id› (ident : ID) (n : string) : ID = (
	trans_id (ident dot "")^n
);
=TEX
=SML
fun €prefix_package_id› (ident : ID) (newids : ID list) (n : string) : ID = (
	if (is_id_in_package newids n)
	then prefix_id ident n
	else n
);
=TEX
The following prefixes the variables and global variables in a Z term (i.e. predicate, declaration or expression); 
it is given as parameters the name of the package, the list of names defined in the package together with the term to be processed.
=SML
fun €prefix_term› (ident : ID)
		(tysubs : (string * string) list)
		(newids : ID list)
		(tm : TERM) : TERM = (
	let	fun var_subs acc [] = (acc
		) | var_subs acc (v::vs) = (
			let	val (n, ty) = dest_var v;
			in	if	is_id_in_package newids n
				then	var_subs
					((mk_var(prefix_id ident n, ty), v)::acc)
					vs
				else	var_subs acc vs
			end
		);
		fun const_subs acc [] = (acc
		) | const_subs acc ((n, ty)::cs) = (
			case explode n of
				"z"::"'"::more => (
				let	val zn = implode more;
				in	if	is_id_in_package newids zn
					then	const_subs
	((mk_const("z'"^prefix_id ident zn, ty), mk_const(n, ty))::acc)
						cs
					else	const_subs acc cs
				end	handle Fail _ => const_subs acc cs
			) | _ => const_subs acc cs
		);
		val subs = var_subs [] (frees tm) @
					const_subs [] (term_consts tm);
	in	type_subst_term tysubs (subst subs tm)
	end
);
=TEX
=SML
fun €prefix_aux_vars› (ident : ID)
		(tysubs : (string * string) list)
		(newids : ID list)
		(av : Z_DECL) : Z_DECL = (
	prefix_term ident tysubs newids av
);
=TEX
=SML
fun €prefix_tmark› (ident : ID) (newids : ID list) (tmark : TMARK) : TMARK = (
	prefix_package_id ident newids tmark
);
=TEX
The following happens only to be used when the $vars$ list
are all members of the package, but just in case we are careful.
=SML
fun €prefix_vardecl› (ident : ID) (newids : ID list)
				({vars, tmark} : VAR_DECL) : VAR_DECL = (
	{	vars = 		map (prefix_package_id ident newids) vars,
		tmark=		prefix_tmark ident newids tmark
	}
);
=TEX
=SML
fun €prefix_param_spec› (ident : ID)
		(newids : ID list)
		({mode, var_decl as {vars, tmark}} : PARAM_SPEC)
			: PARAM_SPEC = (
	map (fn v => if (is_id_in_package newids v)
			then fail "prefix_param_spec" 507055 
				[fn () => v, fn () => ident]
			else ()) vars;
	{mode = mode,
	var_decl = {vars = vars, tmark = prefix_tmark ident newids tmark}}
);
=TEX

When the following is called it is important that the specification script theory for the package be the current theory and that it be populated with all its types and constants.

It is also important that the typing context has been correctly set if the statement
is affected by the typing of other variables, e.g. function or procedure parameters.
=SML
fun €prefix_spec_stmt› (ident : ID)
	(tysubs : (string * string) list)
	(newids : ID list)
	(spec : SPEC) : SPEC = (
	let
(* DESIGN ERROR checking code - could delete *)
		val package = force_value(s_lookup ident (!pack_env))
				handle Fail _ =>
				error "prefix_spec_stmt" 507029 [fn() => ident];
		val spec_script_name = #zmod package;
		val dummy = if (spec_script_name = get_current_theory_name())
			then ()
			else error "prefix_spec_stmt" 507047 [
				fn () => spec_script_name,
				fn () => get_current_theory_name()
			];
(* end DESIGN ERROR checking code *)
		val {w, pre, post, w0} = spec;
		val w'= map (prefix_package_id ident newids) w;
		val w0' = map (prefix_package_id ident newids) w0;
		val pretm = z_predexp_of_z_tm pre;
		val posttm = z_predexp_of_z_tm post;
		val pre' = z_quote
				(prefix_term ident tysubs newids pretm, Nil);
		val post' = z_quote
				(prefix_term ident tysubs newids posttm, Nil);
	in
		{w = w', w0 = w0', pre = pre', post = post'}
	end
);
=TEX
When the following is called it is important that the specification script
theory for the package be the current theory and that it be
populated with all its types and constants.
=SML
fun €prefix_formal_proc› (ident : ID)
		(tysubs : (string * string) list)
		(newids : ID list)
		({name, formal_ids, spec, globals} : FORMAL_PROC)
			: FORMAL_PROC = (
	let	val old_cxt = add_params_ti_context formal_ids;
		val globals1 = map (prefix_package_id ident newids) globals;
		val result = {	
			name = prefix_package_id ident newids name,
			formal_ids =
				map
				(prefix_param_spec ident newids)
				formal_ids,
			globals = globals1,
			spec = prefix_spec_stmt ident tysubs newids spec};
	in	set_ti_context old_cxt;
		result
	end
);
=TEX
=SML
fun €prefix_informal_fun› (ident : ID) (newids : ID list)
		({name, formal_pars, return_type} : INFORMAL_FUN)
			: INFORMAL_FUN = (
	{	name = prefix_package_id ident newids name,
		formal_pars = map (prefix_param_spec ident newids) formal_pars,
		return_type = prefix_tmark ident newids return_type}
);
=TEX
Note how we set up, and later restore, the typing context:
=SML
fun €prefix_formal_fun› (ident : ID) (tysubs : (string * string) list)
	(newids : ID list)
	(form_fun as {
		spec : SPEC, 
		informal_fun  as {formal_pars, ...} : INFORMAL_FUN, 
		globals} : FORMAL_FUN) : 
		FORMAL_FUN = (
let		val dec = fun_decl current_cn_env form_fun;
		val pardecs = map z_par_decl formal_pars handle exn => [];
		val old_ti_cxt = current_ti_context();
		val new_ti_cxt = frees dec term_union (
			flat (map frees pardecs) term_union old_ti_cxt);
		val side = set_current_ti_context new_ti_cxt;
		val spec1 = prefix_spec_stmt ident tysubs newids spec;
		val globals1 = map (prefix_package_id ident newids) globals;
		val side1 = set_current_ti_context old_ti_cxt;
in
	{spec = spec1,
	 informal_fun = prefix_informal_fun ident newids informal_fun,
	 globals = globals1}
end);
=TEX
When the following is called it is important that the specification script
theory for the package be the current theory and that it be populated
with all its types and constants.
=SML
fun €prefix_formal_procs› (ident : ID)
		(tysubs : (string * string) list) (newids : ID list)
		(fps : FORMAL_PROC list) : FORMAL_PROC list  = (
	map (prefix_formal_proc ident tysubs newids) fps
);

=TEX
The following function does the prefixing of the given set paragraphs and returns a list of paragraph infos representing the prefixed paragraphs, together with a substitution list for use in prefixing appearances of type names in terms.
It does not touch defining axioms for these given sets.
=SML
fun €prefix_given_sets›  (ident : ID) (newids : ID list) (names : ID list)
	: (string * string) list * PARAINFO list = (
	let	val pfxd_names = map (prefix_package_id ident newids) names;
		fun do_gset n = GivenSetInfo([n], Nil);
	in	(combine pfxd_names names, map do_gset pfxd_names)
	end
);

=TEX
The following functions is given a list of pairs each comprising a constant and
its defining theorem (if any). It collects together adjacent constants that have
the same defining theorem.
This is used to collect together the constants that must be defined in the same
axiomatic description.
=SML
fun collect_const_defs (consts : TERM list)
		(othm : THM OPT) ([] : (TERM * THM OPT) list) : (TERM list * THM OPT) list = (
	if is_nil consts
	then []
	else [(rev consts, othm)]
	) | collect_const_defs consts Nil ((const, othm) :: more) = (
	if is_nil consts
		then collect_const_defs [const] othm more
		else (rev consts, Nil) :: collect_const_defs [const] othm more
	) | collect_const_defs consts othm ((const, Nil) :: more) = (
		if is_nil consts
		then collect_const_defs [const] Nil more
		else (rev consts, othm) :: collect_const_defs [const] Nil more
	) | collect_const_defs consts (Value thm) ((const, (Value thm1)) :: more) = (
		if (thm =|- thm1)
		then collect_const_defs (const :: consts) (Value thm) more
		else (rev consts, (Value thm)) :: collect_const_defs [const] (Value thm1) more
);
=TEX
The following function does the prefixing and storing of the paragraphs defining global variables other than given sets.
=SML
fun €store_prefix_const_thms› (ident : ID)
		(tysubs : (string * string) list)
		(newids : ID list)
		(const_thms : (TERM * THM OPT) list)
		: unit = (
let	val ty_ty = (fn ty => (type_subst_type tysubs ty 
		handle (Fail _) => ty));
	fun aux (consts, Nil) = (map (fn const =>
		let	val (name, ty, _) = dest_z_gvar const;
		in
			new_const
			((z_id_of_id o prefix_package_id ident newids)
				name,
				ty_ty ty)
		end
		handle (Fail _) => 		
		let	val (name, ty) = dest_const const;
		in
			new_const
			((prefix_package_id ident newids)
				name,
				ty_ty ty)
		end) consts; ()
	) | aux (consts, Value thm) = (
	let	val (constr, tm1) = (dest_app o snd o dest_thm) thm;
	in	case (fst o dest_const) constr handle Fail _ => "" of
		"Z'AxDes" => (
		let 	val (formals, _) = strip_µ tm1;
			val fnames = map ((fn (n,_,_) => n) o dest_z_lvar)
				 formals;
			val mk_subs = case formals of
				[] => (fn gv => (mk_z_lvar(dest_z_gvar gv), gv))
			|	_ => (
				let	val tup = mk_z_tuple formals;
					val tupty = type_of tup;
				in	fn gv =>
					let	val opty = fst (dest_≠_type(type_of gv));
						val ts = type_match tupty opty;
						val gv' = inst[] ts gv;
						val app = mk_app(gv', tup);
						val (n, _, _) = dest_z_gvar gv;
					in	(mk_var(n, type_of app), app)
					end
				end
			);
			val subs = map mk_subs consts;
			val tm = (prefix_term ident tysubs newids o subst subs) tm1;
			val (_, body) = strip_µ tm; 
			val pntys = map (dest_var o prefix_term ident tysubs newids o fst) subs;
			val (decl, vp) =
			((Combinators.I ** Value) o dest_±) body
				handle Fail _ => (body, Nil);
		in	store_para(AxDesInfo (fnames, decl, vp, pntys))
		end
		) | other_constr => (
	let	val lvars = map (mk_z_lvar o dest_z_gvar) consts;
		val plvars = map (prefix_term ident tysubs newids) lvars;
		val tm = (prefix_term ident tysubs newids o 
				subst (combine lvars consts)) tm1;
		val pntys = map (fn l => (let val (pn, pty, _) = dest_z_lvar l; 
					in
						(pn, pty)
					end))
				plvars;
		fun name_strings () = format_list string_of_term consts ", ";
	in	case other_constr of
		"Z'AbbDef" => (
			(let val (formals, body) = strip_µ tm;
				val fnames =  map ((fn (n,_,_) => n) o dest_z_lvar) formals;
			in	
			store_para(AbbDefInfo (fst(hd pntys), fnames, (snd o dest_eq) body))
			end handle (Fail _) =>
			comment "z_prefix" 507057 [name_strings])
		) |"Z'SchBox" => (
			(let val (formals, body) = strip_µ tm;
				val fnames =  map ((fn (n,_,_) => n) o dest_z_lvar) formals;
			in	
			store_para(SchBoxInfo (fst(hd pntys), fnames , (snd o dest_eq) body))
			end handle (Fail _) =>
			comment "z_prefix" 507057 [name_strings])
		) | _ => (if (length consts = 1)
			then ((let val (lhs, rhs) = dest_eq (concl thm);
			 in
				if lhs =$ hd(consts)
				then (simple_new_defn ([fst(hd pntys)],
					z_id_of_id (fst(dest_var (hd plvars))), 
					(prefix_term ident tysubs newids rhs));
					())
				else comment "z_prefix" 507057 
					[name_strings]
			 end)
			 handle (Fail _) => comment "z_prefix" 507057 
				[name_strings])
			else comment "z_prefix" 507057 
				[name_strings]
		)
	end)end);
in	map aux (collect_const_defs [] Nil const_thms); ()
end);
=TEX 
=SML
fun €is_const_in_package› (newids : ID list) (c : TERM) : bool = (
	let	val (n, _, _) = dest_z_gvar c;
	in	is_id_in_package newids n
	end	handle Fail _ => false
);
fun €is_type_in_package› (newids : ID list) (ty : TYPE) : bool = (
	let	val (n, _) = dest_ctype ty;
	in	is_id_in_package newids n
	end	handle Fail _ => false
);
=TEX
In the following, definitions are copied (with modifications, viz.,
package name prefixes) from one theory to another target theory
whose names are given by the last two arguments and which may be
the same (in the case of a package nested inside a package or
subprogram body).
The specification script theory is the source for the copying. 
=SML
fun €store_prefix_types_and_consts›	
		(nested_package : bool)
		(ident : ID)
		(newids : ID list)
		(spec_script_thy : string) 
		(target_thy : string) : (string * string) list = (
let	val old_thy = get_current_theory_name();
	val dummy1 = open_theory spec_script_thy;
	val ifixities = rev(ZUserInterfaceSupport.get_zfixity_infos
		spec_script_thy);
	val itypes =
		if	nested_package
		then	rev(get_types spec_script_thy) drop (not o is_type_in_package newids)
		else	rev(get_types spec_script_thy);
	val iconsts = 
		if	nested_package
		then	rev(get_consts spec_script_thy) drop (not o is_const_in_package newids)
		else	rev(get_consts spec_script_thy);
	val iconst_thms = map (fn x => (x, (Value (get_spec x)
					handle Fail _=> Nil))) 
				iconsts;
	val type_names = map (fst o dest_ctype) itypes;
	val pfxd_names = map (prefix_package_id ident newids) type_names;
	val tysubs = (combine pfxd_names type_names) drop (fn (x,y) => (x = y));
	val dummy2 = open_theory target_thy;
	val dummyfixities = map 
		(fn (c, t) => ZUserInterfaceSupport.set_zfixity_info(c, [t]))
		ifixities;

	fun do_type (ty : TYPE) = (
	let 	val (s,args) = dest_ctype ty;
		val n = length args;
		val prefixed_s = rassoc1 tysubs s;
	in
		new_type(prefixed_s, n)
	end);
	val ptypes = map do_type itypes;
	val dummy3 = store_prefix_const_thms ident tysubs newids
		iconst_thms;
	val dummy4 = open_theory old_thy;
in
	tysubs
end);
=TEX

The following removes the characters ``vc'' from the start of an ID,
if they happen to be present.
=SML
fun €un_vc› (n : ID) : ID = (
	case (explode n) of
	("v" :: "c" :: c :: more) => implode (c :: more)
	| _ => n
);
=TEX
The following function does the prefixing of the conjectures and returns a list representing the prefixed conjectures as paragraphs.
=SML
fun €prefix_conjectures› (ident : ID)
		(tysubs : (string * string) list)
		(newids : ID list)
		(conjectures : (string list * (int * TERM)) list)
		: PARAINFO list = (
	let	fun aux ((sl, (_, tm)) :: more) = (
			let 	val prefixed_tm = prefix_term ident tysubs newids tm;
				val plist = map (fn n => 
					ConjectureInfo(
						Value (prefix_package_id ident newids (un_vc n)),
						 [], prefixed_tm)) sl;
			in
				plist @ aux more
			end
		) | aux [] = [];
	in	aux conjectures
	end
);
=TEX
The following checks to see if any of the function specifications refer
to other functions of the package, which is an error.
=SML
fun €check_ff_xref› (pfx_funs: INFORMAL_FUN list) 
	(formal_fun_paras : PARAINFO list) : unit = (
let 	val names = map (fn f => (#name f)) pfx_funs;
	fun is_pfx_fun_name (v: TERM) = (
		fst(dest_var v) mem names
	);
	fun aux (AxDesInfo(_, decl, Value pred, evars)) = (
	let	val fdecl = frees decl;
		val fpred = frees pred;
		val no_worries = union (op =$) fdecl (map mk_var evars);
		val worries = fpred drop (fn x => x term_mem no_worries);
		val suspects = worries drop (fn w => not(is_pfx_fun_name w));
	in
		if is_nil suspects
		then ()
		else fail "create_prefixed_spec"
			507048
			[fn () => format_list string_of_term suspects ", ",
			 fn () => string_of_term decl]
	end) | aux _ = ();
in
	map aux formal_fun_paras;
	()
end);
=TEX
The following creates and populates the package spec theory when a with-clause
for a top-level package is first encountered.
It returns the list of type substitutions which need to be made.
If this is not a nested package and all goes well,
the package spec theory becomes the current theory.
If this is a nested package or if
an exception is raised in which case the script theory becomes current.
=SML
fun €create_prefixed_spec›
		(nested_package : bool)
		(parents : string list) (ident : ID) (package : PACKAGE)
		: (string * string) list * Z_DECL list = (
	let	val spec_script_name = #zmod package;
		val side = open_theory spec_script_name handle (Fail _) =>
			fail "create_prefixed_spec" 507038
			[fn () => ident];
		val conjectures =
			if	nested_package
			then	[]
			else	get_conjectures spec_script_name;
		val newids = new_ids package;
		val pinformal_funs = map (prefix_informal_fun ident newids)
					(#informal_funs package);
		val pfx_funs = pinformal_funs @ map (prefix_informal_fun ident newids)
			(map #informal_fun (#formal_funs package));
		val side =
			if	nested_package
			then	()
			else	(new_package_spec_theory parents ident
				handle Fail _ => open_package_spec_theory ident);
		val block = block_vc_vars(empty_block, #vc_vars package);
		val block = block_vc_aux_vars(block, #aux_vars package);
		val side = (blocks := block :: !blocks);
		val tysubs =
			store_prefix_types_and_consts nested_package ident newids
			spec_script_name
			(if nested_package
			 then spec_script_name
			 else pack_spec_name ident);
		val paras3 = prefix_conjectures ident tysubs newids conjectures;
		val dummy3 =	map store_para paras3;
		val thychange1 = open_theory spec_script_name;
		val pformal_funs = map (prefix_formal_fun ident tysubs newids)
			(#formal_funs package);
		val side = (blocks := tl (!blocks));
		val vc_vars1 = map (prefix_vardecl ident newids)(#vc_vars package);
		val block = block_vc_vars(block, vc_vars1);
		val aux_vars = map (prefix_aux_vars ident tysubs newids)
					(#aux_vars package);
		val block = block_vc_aux_vars(block, aux_vars);
		val side = (blocks := block :: !blocks);
		val thychange1 = 
			if	nested_package
			then	()
			else	open_package_spec_theory ident;
		val informal_fun_paras = map trans_informal_fun pinformal_funs;
		fun par_aux (ff:FORMAL_FUN) = (
			add_spark_function_info (#globals ff) (#informal_fun ff)
		);
		val dummy = (
			map (add_spark_function_info []) pinformal_funs;
			map par_aux pformal_funs;
			map	(set_basic_decl_info
				   (prefix_package_id ident newids))
				(#consts_types package);
			map store_para informal_fun_paras);
		(* need to do other store_paras first to get right env *)
		val formal_fun_paras =
			map (trans_formal_fun current_cn_env) pformal_funs;
		val dummy1 = check_ff_xref pfx_funs formal_fun_paras;
		val side = (blocks := tl (!blocks));
	in	
		map store_para formal_fun_paras;
		(tysubs, aux_vars)
	end	handle ex => (
			open_theory (!script_name);
			reraise ex "create_prefixed_spec"
		)
);
=TEX
In $new\_scope\_with$, we also need to prefix names occurring in the specification statements in any formal procedures in the withed package.
In order to do the relevant substitutions, we need to type check the Z predicates in the specification statements.
This has already been done at the point of originally entering the specification
theory.
The following function returns information which the caller may need.
It returns a triple comprising: the list of type substitutions which need to be made; the list of formal procedures with the relevant names prefixed in the specs and the prefixed auxiliary variables).

The script theory becomes current after successful or unsuccessful execution.
=SML
fun €z_prefix› (ident : ID) (newids : ID list) (package : PACKAGE)
		: (string * string) list * FORMAL_PROC list * Z_DECL list = (
	let	val package = force_value(s_lookup ident (!pack_env))
				handle Fail _ =>
				error "z_prefix" 507029 [fn() => ident];
		val spec_script_name = #zmod package;
		val dummy = if spec_script_name mem (get_descendants ("cn"))
			then ()
			else fail "z_prefix" 507038 [fn () => spec_script_name];
		val parents = get_parents spec_script_name;
		val prefixed_theory_name = pack_spec_name ident;
		val spec_already_created =
			 prefixed_theory_name mem get_descendants ("cn");
		val (tysubs, aux_vars) = 
			if	spec_already_created
			then	let 	val (tys, _) =
						spec_script_theory_types_and_const_thms
						spec_script_name;
					val (tysubs, _) = prefix_given_sets ident newids tys;
				in	(tysubs,
					map (prefix_aux_vars ident tysubs newids)
						(#aux_vars package))
		end
			else	create_prefixed_spec false parents ident package;
		val fps = (
			open_theory spec_script_name;
			set_package_ti_context package;
			(	prefix_formal_procs ident tysubs newids
					(#formal_procs package))
		);
	in	open_theory (!script_name);
		(if	not spec_already_created
		then	update_user_datum cn_spec_ud_key
				(UD_String(pack_spec_name ident,
					[UD_Int (current_level(),[])]))
		else	());
		(tysubs, fps, aux_vars)
	end	handle ex => (
			open_theory (!script_name);
			reraise ex "z_prefix"
		)
);
=TEX
=SML
fun €new_scope_with› (ident : ID) : unit = (
	case s_lookup ident (!pack_env) of
	Nil => ()
	|Value package => (
		
		let
			val flags = false_flags;
			val newids = new_ids package;
			val (tysubs, formal_procs1, aux_vars1) = 
				z_prefix ident newids package;
			val dummy1 = new_parent_aux false (pack_spec_name ident);
			val vc_vars1 = map (prefix_vardecl ident newids)
							(#vc_vars package);
			val block = block_flags(empty_block, flags);
			val block = block_vc_vars(block, vc_vars1);
			val block = block_vc_aux_vars(block, aux_vars1);
			val block = block_formal_procs(block, formal_procs1);
		in	new_parent_aux true (pack_spec_name ident);
			blocks := block :: !blocks
		end
	)
);
=TEX
\subsection{The SID function update\_envs\_pack\_spec}

In {\it update\_envs\_pack\_spec}, we need to proceed much as in {\it new\_scope\_with},
but adding the prefixed Z material to the script theory to support package
specifications nested inside package or subprogram bodies.
The following analogue of {\it z\_prefix} does this.

=SML
fun €z_prefix_nested› (ident : ID) (newids : ID list) (package : PACKAGE)
		: (string * string) list * FORMAL_PROC list * Z_DECL list = (
	let	val package = force_value(s_lookup ident (!pack_env))
				handle Fail _ =>
				error "z_prefix_nested" 507029 [fn() => ident];
		val (tysubs, aux_vars) = 
			create_prefixed_spec true [] ident package;
		val fps = (
			set_package_ti_context package;
			(	prefix_formal_procs ident tysubs newids
					(#formal_procs package))
		);
	in	(tysubs, fps, aux_vars)
	end
);
=TEX
=SML
fun €update_envs_pack_spec› (ident : ID) : unit = (
if	test_flag #body_flag 1
then	case s_lookup ident (!pack_env) of
		Nil => fail "update_envs_pack_spec" 507060 [fn _ => ident]
	|Value package => (
		let	val newids = new_ids package;
			val (_, formal_procs2, aux_vars2) = 
				z_prefix_nested ident newids package;
			val vc_vars2 = map (prefix_vardecl ident newids)
							(#vc_vars package);
			val block1 = block 1
				handle Fail _ => error "aux_var" 507006 [];
			val vc_vars1 = #vc_vars(#in_scope(#declab block1));
			val vc_aux_vars1 = #vc_aux_vars(#in_scope(#declab block1));
			val formal_procs1 = #formal_procs(#in_scope(#declab block1));
			val block = block_vc_vars(block1, vc_vars1 cup vc_vars2);
			val block = block_vc_aux_vars(block, vc_aux_vars1 @ aux_vars2);
			val block = block_formal_procs(block, formal_procs1 @ formal_procs2);
		in	blocks := block :: tl(!blocks)
		end
	)
else	()
);
=TEX
\subsection{The SID function new\_scope\_pack\_body}
N.B. this section has been moved after $new\_scope\_with$ so that that function can be called from $new\_scope\_pack\_body$
=TEX
=SML
fun €new_scope_pack_body› (ident : ID) : unit = (
	let	val package1 = force_value(s_lookup ident (!pack_env))
			handle Fail _ =>
			fail "new_scope_pack_body" 507030 [fn()=>ident];
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = true,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false,
			body_flag = true
		};
		val vc_vars1 = #vc_vars package1;
		val old_subunit_flag = test_flag #subunit_flag 1;
		val block = block_vc_vars(
			block_flags(empty_block, flags), vc_vars1);
		val block' = block_block_name(block, ident);
	in
		(if old_subunit_flag then () else new_parent_aux false (#zmod package1));
		blocks := block' :: !blocks
	end	
);
=TEX
\subsection{The SID function end\_scope\_comp\_unit}
=SML
fun €end_scope_comp_unit› ((): unit) : unit = (
	blocks := [block 1]
);
=TEX
\subsection{The SID function aux\_var}
=SML
fun €aux_var› (av : AUX_VAR) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "aux_var" 507006 [];
		val block_name1 = #block_name(#declab (block1));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "aux_var" 507001 [];
		val {aux, t} = av;
		val side = set_current_ti_context[];
		val zt = z_predexp_of_z_tm t;
		val zvar = mk_z_lvar(aux, (dest_z_power_type o type_of) zt, []);
		val zdecl = mk_z_dec([zvar], zt);
		val aux_vars1 = #aux_vars package drop (fn x => zdecl =$ x);
		val zids_in_scope = (z_names_of_in_scope o #in_scope o #declab)
				 block1;
		val vc_aux_vars1 = #vc_aux_vars(#in_scope(#declab block1));
	in	check_new_z_id zids_in_scope aux;
		check_new_spark_ids current_cn_env [aux];
		pack_env :=
		s_enter
		block_name1
		(package_aux_vars(package, aux_vars1 @ [zdecl]))
		(!pack_env);
		blocks :=
		block_vc_aux_vars(block1, vc_aux_vars1 @ [zdecl]):: tl (!blocks)

	end
);
=TEX

\subsection{The SID function using\_dec}

=SML
fun €ud_fun_of_using_dec› (ud : USING_DEC)
		: Z_ID * (VAR_DECL list * CNTypes.Z_PRED)= (
	let	val {	aux,
			concrete_vars,
			invariant, ...}		= ud;
		val block1 = block 1
			handle Fail _ => error "ud_fun_of_using_dec" 507006 [];
		val block_name1 = (#block_name o #declab) block1;
		val package = (force_value(s_lookup block_name1 (!pack_env)))
			handle Fail _ =>
			error "ud_fun_of_using_dec" 507012 [fn()=>block_name1];
		val side = set_current_ti_context (#aux_vars package);
		val (id, _, _) = (dest_z_lvar o z_predexp_of_z_tm) aux;
	in	(id, (concrete_vars, z_pred_of_z_tm invariant))
	end
);
=TEX
=SML
fun €using_dec› (ud: USING_DEC) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "using_dec" 507006 [];
		val using_decs1 = #using_decs block1;
		val ud_fn as (id, _) = ud_fun_of_using_dec ud;
		fun ud_fun_match (id1, (bd1, tm1)) (id2, (bd2, tm2)) = (
			id1 = id2 andalso bd1 = bd2
				andalso tm1 =$ tm2
		);
		val using_decs2 = using_decs1 drop
			(fn u => ud_fun_match ud_fn u);			
	in	blocks :=
		block_using_decs(block1, using_decs2 @ [ud_fn]):: tl (!blocks)
	end
);
=TEX
=SML
fun €add_conc_vars_env› ((): unit) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "add_conc_vars_env" 507006 [];
		val block_name1 = #block_name(#declab block1);
		val package = (force_value(s_lookup block_name1 (!pack_env)))
			handle Fail _ =>
			fail "add_conc_vars_env" 507032 [fn()=>block_name1];
		val av_names = flat (map z_names_of_z_dec (#aux_vars package));
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val using_decs = #using_decs block1;
		val var_decls = (list_cup o map fst o map snd) using_decs;
		val vars = (flat o map #vars) var_decls;
		val zids_in_scope = av_names cup
			(z_names_of_in_scope o #in_scope o #declab) block1;
	in	map (check_new_z_id zids_in_scope) vars;
		check_new_spark_ids current_cn_env vars;
		blocks :=
		block_vc_vars(block1, vc_vars1 cup var_decls):: tl (!blocks)
	end
);
=TEX
\subsection{The SID function vcs\_aux\_initial}
=SML
fun €vcs_aux_initial› (st : STATEMENT) : SPEC = (
	let	val block1 = block 1;
		val block_name1 = #block_name(#declab (block1));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "vcs_aux_initial" 507001 [];
		val aux_vars1 = #aux_vars package;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val w = flat (map (map trans_id o #vars) vc_vars1);
		val in_scope = flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val using_decs1 = #using_decs block1;
		val vc_inits1 = #var_inits block1;
		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = [],
			vc_log_cons = [],
			vc_aux_vars = [],
			formal_procs = formal_procs,
			dec_labels = []
		};
		val wp_env :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = formal_procs
		};
		val pre1 = var_inits_pre Nil vc_inits1 (#env wp_env)
			handle exn =>
			pass_on exn "var_inits_pre" "vcs_aux_initial";
		val invariants = (map snd o map snd) using_decs1;
		val post1 = z_exists (aux_vars1, z_many_and invariants);

		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "â0") w,
			pre = pre1,
			post = z_quote (post1, Nil)
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = true,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope1
		};
		val (vcs, res_spec) = call_vcs (speclab, st)
	in	store_vcs(block_name1, vcs);
		res_spec
	end
);
=TEX
\section{RENAMING DECLARATIONS}\label{RENAMINGDECLARATIONS}
\subsection{The SID function renames\_proc}
=SML
fun €renames_proc_common›
	({subprogram_specification = ss, name1 = pack, name2=old}
		: SUBPROGRAM_RENAMING)
	 : FORMAL_PROC OPT = (
	case ss of
		SSProcedure {name = new, ... } => (
		   case s_lookup pack (!pack_env) of
		   Value package => (
			let	val spec_script_name = (#zmod package);
				val formal_proc2  =
					find
						(#formal_procs package)
						(fn p => #name p = old);

				val (tys, _) =
					spec_script_theory_types_and_const_thms spec_script_name;
				val newids = new_ids package;
				val (tysubs, _) = prefix_given_sets pack newids tys;
				val oldthy = get_current_theory_name();
				val changethy = open_theory spec_script_name;
				val {name=pname, formal_ids=pformal_ids, globals=g,
					 spec=pspec} : FORMAL_PROC = (
					prefix_formal_proc
						pack
						tysubs
						(new_ids package)
						formal_proc2)
					handle exn as (Fail _) =>
					(open_theory oldthy;
					 raise exn);
				val changethy2 = open_theory oldthy;
				val formal_proc3 =
						{name = new,
						formal_ids = pformal_ids,
						globals = g,
						spec = pspec};
			in	Value formal_proc3
			end	handle (exn as Fail f) =>
				(if (area_of exn = "find")
				then comment "renames_proc" 507036
					[fn () => pack dot old]
				else comment "renames_proc" 507044
					[fn () => pack dot old,
					fn () => get_message f];
				Nil)
		) |	Nil => (comment "renames_proc" 507038 [fn()=>pack];
				Nil)
	) |	_ => Nil
);
=TEX
=SML
fun €renames_proc_pack_spec›
	(sr as {subprogram_specification = ss, name1 = pack, name2=old}
		: SUBPROGRAM_RENAMING)
	: unit = (
let 	val oformal_proc3 = renames_proc_common sr;
in
	case oformal_proc3 of
	Nil => ()
	| Value formal_proc3 => case ss of
		SSProcedure {name = new, ... } => (
		   case s_lookup pack (!pack_env) of
		   Value package => (
			let	val block1 as
					{declab = declab as
						{in_scope as {formal_procs, ...},
						block_name = block_name1,
						 ...},
					...} =	block 1;
				val dummy = if (block_name1 = pack)
					then fail "renames_proc_pack_spec"
						507049 [fn () => old]
					else ();
				val package2 = force_value(
					s_lookup block_name1 (!pack_env))
					handle _ => fail "renames_proc_pack_spec"
						507012 [fn ()=> block_name1];
			in	pack_env :=
					s_enter
					block_name1
					(package_formal_procs(package2,
						(#formal_procs package2) @
						[formal_proc3]))
					(!pack_env)
			end	handle (exn as Fail f) =>
				() (* done in common *)
		) |	Nil => () (* done in common *)
	) |	_ => ()
end);
=TEX
=SML
fun €renames_proc_otherwise›
	(sr as {subprogram_specification = ss, name1 = pack, name2=old}
		: SUBPROGRAM_RENAMING)
	: unit = (
let	val oformal_proc3 = renames_proc_common sr;
in
	case oformal_proc3 of
	Nil => ()
	| Value formal_proc3 => 
(let	val block1 as	{declab as
			 {in_scope as {formal_procs, ...},
			 ...},
			 ...} =	block 1;
in	blocks :=
		(block_formal_procs (block1, formal_proc3::formal_procs) 
		:: tl (!blocks))
end)
end);
=TEX
=SML
fun €renames_proc› (sr : SUBPROGRAM_RENAMING)
	: unit = (
	if	test_flag #pack_spec_flag 1
	then	renames_proc_pack_spec sr
	else	renames_proc_otherwise sr
);
=TEX
\subsection{The SID function renames\_fun}
=SML
fun €renames_fun›
	({subprogram_specification = ss, name1 = pack, name2=old}
		: SUBPROGRAM_RENAMING)
	: unit = (
	case ss of
		SSFunction {designator = new, ... } => (
			let	val tm = (zid current_cn_env o trans_id)
								(pack dot old);
				val parainfo = AbbDefInfo(new, [], tm);
			in	store_para parainfo
			end	handle Fail msg =>
				comment "renames_proc" 507037
					[fn () => get_message msg]

	) | 	_ => ()
);
=TEX
\section{STUBS AND SUBUNITS}\label{STUBSANDSUBUNITS}
\subsection{The SID function begin\_stub}
=SML
fun €begin_stub› (():unit) : unit = (
	let	val block1 = block 1;
	in	blocks :=  block_stub_flag (block1, true) :: tl (!blocks)
	end	handle Fail _ => error "begin_stub" 507006 []
);
=TEX
\subsection{The SID function end\_stub}
=SML
fun €end_stub› (():unit) : unit = (
	let	val block1 = block 1;
	in	blocks :=  block_stub_flag (block1, false) :: tl (!blocks)
	end	handle Fail _ => error "end_stub" 507006 []
);
=TEX
\subsection{The SID function new\_scope\_subunit}
=SML
fun €new_scope_subunit› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = true,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false,
			body_flag = true
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end
);
=TEX
\subsection{The SID function pack\_stub}
=SML
=TEX
=SML
fun €pack_stub› (ident : ID) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name (#declab block1);
		val block_name2 = #block_name (#declab block2);
		val id1 =
			if	test_flag #subunit_flag 2
			then	block_name2 dot block_name1
			else	block_name1;
		val id1_ident = id1 dot ident;
		val tid1_ident = subunit_env_index id1 ident;
		val subunit = {
			in_scope	=	flatten_env(!blocks),
			specif		=	dummy_spec,
			specif_flag	=	false,			
			zmod		=	id1_ident,
			globs		=	[]
		};
	in	make_module(trans_subunit_name(id1, ident));
		subunit_env := s_enter tid1_ident subunit (!subunit_env)
	end
);
=TEX
\section{WEB CLAUSES}\label{WEBCLAUSES}
=TEX
\subsection{THE SID function new\_scope\_dec\_replace}
In the following, those fields for the new block which are left undefined in the Z specification are borrowed from the empty block value.
=SML
fun €new_scope_dec_replace› ({label, decls} : REPLACED_BY_DECL) : unit = (
	case s_lookup label (!dec_env) of
		Value declab => (
			let	val block = {
		declab = declab_declabel_flag (declab, true),
		current_formal_proc = #current_formal_proc empty_block,
		current_formal_fun = #current_formal_fun empty_block,
		current_for_vars = #current_for_vars empty_block,
		current_log_cons = #current_log_cons empty_block,
		dec_lab = label,
		spec_lab = #spec_lab empty_block,
		till = #till empty_block,
		using_decs = #using_decs empty_block,
		var_inits = #var_inits empty_block};
			in	blocks := block :: !blocks;
				dec_env := s_delete label (!dec_env)
			end
	) |	Nil => fail "new_scope_dec_replace" 507002
			[fn () => label]
);
=TEX
\subsection{THE SID function update\_envs\_remove\_declabel}
In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_remove_declabel›
		({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_subunit
			((id1_id2,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SUBUNIT) = (
			(id1_id2,
			subunit_dec_labels(s, dec_labels less label))
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_remove_declabel› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_dec_label
			((dec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * DECLAB) = (
			(dec_label,
			declab_dec_labels(s, dec_labels less label))
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
=SML
fun €update_spec_env_remove_declabel› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_spec_label
			((spec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SPECLAB) = (
			(spec_label,
			speclab_dec_labels(s, dec_labels less label))
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
=SML
fun €update_envs_remove_declabel› (label_decls : REPLACED_BY_DECL) : unit = (
	update_subunit_env_remove_declabel label_decls;
	update_dec_env_remove_declabel label_decls;	
	update_spec_env_remove_declabel label_decls
);
=TEX
\subsection{THE SID function new\_scope\_speclabel}
=SML
fun €new_scope_speclabel› (label : LABEL) : unit = (
	let	val spec_env_lab = force_value( s_lookup label (!spec_env) )
			handle Fail _ => fail "new_scope_speclabel" 507003
				[fn () => label];
		val till_flag = #till_flag spec_env_lab;
		val till = #till (#wp_env (spec_env_lab));
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = true,
			till_flag = till_flag,
			body_flag = false
		};
		val block =	block_till(
					block_spec_lab(
						block_flags(empty_block, flags),
					label),
				till);
	in	blocks := block :: !blocks
	end
);
=TEX
\subsection{THE SID function vcs\_speclabel}
All the work of this SID function is done in {\it vcs\_speclabel\_aux} (see above).
=SML
val €vcs_speclabel› : REFINED_BY -> SPEC = vcs_speclabel_aux false;
=TEX
\subsection{THE SID function end\_scope\_speclabel}
=SML
fun €end_scope_speclabel› (():unit) : unit = (
	let	val label = #spec_lab(block 1);
	in	end_scope();
		spec_env := s_delete label (!spec_env)
	end
);
=TEX
\subsection{THE SID functions new\_scope\_stmtlabel and end\_scope\_stmt\_label}
=SML
val €new_scope_stmt_label›: LABEL -> unit = new_scope_speclabel;
val €end_scope_stmt_label›: unit -> unit = end_scope_speclabel;
=TEX
\section{SPARK PROGRAM ENVIRONMENT}
\subsection{The SID Function update\_replacement\_env}
=IGNORE
The error reporting here could usefully be made more sophisticated.
(By checking that $repl$ and the replacement environment entry are of the same sort.)
=SML
fun €update_replacement_env› ((label, repl) : LABEL * REPLACEMENT) : unit = (
	let	val msg_no =
			case s_lookup label (!repl_env) of
				Value(UnReplaced (_, name)) => 0
			|	Value _ => 507004
			|	Nil => 507003;
		val side_effect =
				if	msg_no <> 0
				then	warn "update_replacement_env" msg_no
					[fn () => label]
				else	();
	in	repl_env := s_enter label repl (!repl_env)
	end
);
=TEX
=SML
fun €update_spark_prog› (comp : KSLOT_COMPILATION_UNIT list) : unit = (
	spark_prog := !spark_prog @ comp
);
=TEX
=SML
fun €new_k_slot› (label : LABEL, sort : REPL_SORT, theory : string) : unit = (
	(repl_env := s_extend label (UnReplaced (sort, theory)) (!repl_env))
			handle Fail _ => fail "new_k_slot" 507005 [fn () => label]
);
=TEX
\section{INVOKING THE SID FUNCTIONS}
For various reasons, the command for opening a theory in {\Product} does some work even if the theory being opened is already current.
We use a more optimal approach here:
=SML
fun €lazy_open_theory› (thy : string) : unit = (
	if	thy = "-" orelse thy = get_current_theory_name()
	then	()
	else	open_theory thy
);
=TEX
=SML
fun €open_label_theory› (lab : string) : unit = (
	case s_lookup lab (!repl_env) of
		Value(UnReplaced(_, thy)) => lazy_open_theory thy
	|	_ => ()
);
=TEX
Except where an annotation occurs as a statement or a declaration, we need to record the k-slots in an annotation in the replacement environment:
=SML
fun €do_annotation› (anns : ANNOTATION) : unit = (
	let	fun do_ann (ANString _) = ()
		|   do_ann (ANKSlot {content, label}) = (
			new_k_slot(label, RSAnnotation, get_current_theory_name())
		);
	in	map do_ann anns; ()
	end
);
=TEX
{\it expand\_names} looks for schema names appearing in frames 
or global dependency lists and expands them
into the corresponding list of signature variables.
=SML
fun expand_names (ns : ID list) : Z_ID list = (
	let	fun aux n = (
			((map fst o dest_z_schema_type o dest_z_power_type o
				force_value o get_const_type) ("z'" ^ n))
			handle Fail _ => [n]
		);
	in	flat (map aux ns)
	end
);
=TEX
When the frame is expanded, {\it expand\_frame}
uses {\it expand\_names} to make the frame {\it w}
and the list {\it w0} of initial variables.
It is applied to any {\it SPEC} before passing it into the SID functions.
=SML
fun €expand_frame› ({w, w0, pre, post} : SPEC) : SPEC = (
	let	val new_w = expand_names w;
		val new_w0 = (map (fn s => s ^ "â0")) new_w;
	in	{w = new_w, w0 = new_w0, pre = pre, post = post}
	end
);
=TEX
The following function does the common processing for the various sorts of for loop
in the abstract syntax.
It returns the inner statement of the loop (with frames expanded).
=SML
fun €do_for_loop› (t : Z_TM OPT, i : ID, stmt : STATEMENT,
			tmark : TMARK OPT, dir : LOOP_DIRECTION)
		: STATEMENT = (
	new_scope_loop();
	for_param (i, case tmark of Value t => t | _ => universal_discrete_type);
	(case t of Value till => till_pred till | Nil => ());
	let val res = do_statement stmt; in end_scope(); res end
)
(*
=TEX
The following reflects the SID functions for $statement$ (see also $loop\_statement$ and $loop\_parameter\_specification$.

To have the same order of invocation of the SID functions for for- and while- loop statements as in the specification, it is necessary to ``expand in line'' the processing for their constituent loops.

Note that the parser is not expected to produce the {\it SSpecIvars}, {\it SProcIvars} or {\it SForNonStatic} alternatives, since it cannot carry out the necessary analysis of free variables.
It uses the no-initial-variables or static forms to carry the information
on, since these forms are adequately general.
The $STATEMENT$ alternatives are produced where necessary in the VC generator.
=SML
*)
and €do_statement› (y as STNull : STATEMENT) : STATEMENT = (y
) | do_statement (y as STImplicitNull : STATEMENT) = (y
) | do_statement (y as (STAssign x) : STATEMENT) = (y
) | do_statement (y as (STSpecNoIvars {spec, label}) : STATEMENT) = (
	let	val expanded = {spec = expand_frame spec, label = label};
		val _ = new_k_slot(label, RSSpecStatement, get_current_theory_name());
		val spec' = spec_stmt expanded;
	in	STSpecNoIvars {spec = spec', label = label}
	end
) | do_statement (y as (STSemicolon (x1, x2)) : STATEMENT) = (
	let	val expanded1 = do_statement x1;
		val expanded2 = do_statement x2;
	in	STSemicolon(expanded1, expanded2)
	end
) | do_statement (y as (STIfThenElse {p, q, g, elsif}) : STATEMENT) = (
	let	val expanded_p = do_statement p;
		val expanded_q = do_statement q;
	in	STIfThenElse {p = expanded_p, q = expanded_q, g = g, elsif = elsif}
	end
) | do_statement (y as (STCase {s, others, e}) : STATEMENT) = (
	let	fun expand_s {choices, p} = {choices = choices, p = do_statement p};
		val expanded_s = map expand_s s;
		val expanded_others = do_statement others;
	in	STCase{s = expanded_s, others = expanded_others, e = e}
	end
) | do_statement (y as (STLoop {t= t, stmt}) : STATEMENT) = (
	new_scope_loop();
	(case t of Value till => till_pred till | Nil => ());
	let	val expanded_stmt = do_statement stmt;
	in	end_scope();
		STLoop{t = t, stmt = expanded_stmt}
	end
) | do_statement (y as (STNamedLoop {t, stmt, name}) : STATEMENT) = (
	new_scope_loop();
	(case t of Value till => till_pred till | Nil => ());
	let	val expanded_stmt = do_statement stmt;
	in	end_scope();
		STNamedLoop{t = t, stmt = expanded_stmt, name = name}
	end
) | do_statement (y as (STWhile {loop as {t, stmt}, name, g}) : STATEMENT) = (
	new_scope_loop();
	(case t of Value till => till_pred till | Nil => ());
	let	val expanded_stmt = do_statement stmt;
	in	end_scope();
		STWhile{loop = {t = t, stmt = expanded_stmt}, name = name, g = g}
	end
) | do_statement
	(y as (STForStatic {name, i, tmark, range, dir, loop as {stmt, t}}) : STATEMENT) = (
	let	val expanded_stmt = do_for_loop(t, i, stmt, tmark, dir);
	in	STForStatic {name = name, i = i, tmark = tmark, range = range, dir = dir,
			loop= {stmt=expanded_stmt, t = t}}
	end
) | do_statement
	(y as (STForTmark {name, i, tmark, dir, loop as {stmt, t}}) : STATEMENT) = (
	let	val expanded_stmt = do_for_loop(t, i, stmt, Value tmark, dir);
	in	STForTmark {name = name, i = i, tmark = tmark, dir = dir,
			loop= {stmt=expanded_stmt, t = t}}
	end
) | do_statement (y as (STExitWhen x) : STATEMENT) = (y
) | do_statement (y as STExit : STATEMENT) = (y
) | do_statement (y as (STRet x) : STATEMENT)  = (y
) | do_statement (y as (STProcNoIvars x) : STATEMENT) = (y
) | do_statement (y as (STKSlot {label, content}) : STATEMENT) = (
	new_k_slot(label, RSStatement, get_current_theory_name());
	k_slot_stmt label;
	y
) | do_statement (y as (STPragma _) : STATEMENT) = (y
) | do_statement (y as (STAnnotation _) : STATEMENT) = (y
) | do_statement (y as (SSpecIvars x) : STATEMENT) = (
	error "do_statement" 507019 []
) | do_statement (y as (SForNonStatic x) : STATEMENT) = (
	error "do_statement" 507019 []
) | do_statement (y as (SLogCon (log_con as {defs, spec, pre1, label})) : STATEMENT) = (
	let	val expanded_spec = expand_frame spec;
		val _ = new_k_slot(label, RSSpecStatement, get_current_theory_name());
		val _ = add_log_con_env defs;
		val spec' = spec_stmt {spec = expanded_spec, label = label};
		val _ = remove_log_con_env();
	in	SLogCon {defs = defs, spec = spec', pre1 = pre1, label = label}
	end
) | do_statement (y as (SProcIvars x) : STATEMENT) = (
	error "do_statement" 507019 []
);
=TEX
The following processes a single {\itBASIC\_DECL}.
=SML
fun €do_basic_declaration› (x : BASIC_DECL) : unit = (
	diag_basic_decl_list := x :: !diag_basic_decl_list;
	case x of
		BDTypeDecl _ => (basic_declaration x
	) |	BDSubtypeDecl _ => (basic_declaration x
	) |	BDConstDecl _ => (basic_declaration x
	) |	BDVarDecl v => (
			var_pack_spec v;
			update_envs_var v;
			add_var_env v
	) |	BDVarDeclInit (v, e) => (
			var_pack_spec v;
			update_envs_var v;
			add_var_init_env (v, e);
			add_var_env (v)
	) |	BDDeferredConstDecl _ => (comment "do_declaration" 507021 []
	) |	BDPrivateTypeDecl _ => (
	) |	BDPragma _ => (
	) |	BDAnnotation _ => (
	)
);
=TEX
The following functions look
after the passage from {\it SI\_BASIC\_DECL}s to {\it BASIC\_DECL}s
in a using declaration.
=SML
=TEX
=SML
fun €extract_vardecls› ((bd::more) : BASIC_DECL list) : VAR_DECL list = (
	case bd of
		BDVarDecl vd => vd::extract_vardecls more
	|	BDVarDeclInit (vd, init) => vd::extract_vardecls more
	|	_ => extract_vardecls more
) | extract_vardecls _ = [];
=TEX
=SML
fun €adjust_using_dec› ({aux, basic_decls, invariant} : SI_USING_DEC)
	: USING_DEC = (
	let	val basic_decls' = adjust_basic_decls basic_decls;
	in	{aux = aux,
		 concrete_vars = extract_vardecls basic_decls',
		 basic_decls = basic_decls',
		 invariant = invariant}
	end
);
=TEX
The following reflects the SID functions for $dec$, $basic\_declaration$, $renaming\_declaration$, $subprogram\_declaration$ and {\it pack\_stub}.
Note that the $with\_context$ is an argument used for package declarations so that when the package theories are created, the $with$ packages can become parents.

=SML
fun €do_declaration› (y as (DDeclarationKSlot (
	{label, content}, dkty)) : DECLARATION) = (
	let	val rsty = case dkty of
					DKDeclaration => RSDeclaration
				|	DKPrivate => RSPrivatePart
				|	DKVisible => RSVisiblePart;
		val ident = trans_id label;
	in	(case s_lookup ident (!pack_env) of
			Value _ => ( pack_stub ident
		) |	Nil => ());
		new_k_slot(label, rsty, get_current_theory_name())
	end;
	k_slot_dec label;
	update_envs_k_slot label
) | do_declaration (y as (DRenamingDeclaration x) : DECLARATION) = (
	case x of
		RDSubprogram
		(y as {subprogram_specification = SSProcedure _, ...}) =>
				renames_proc y
	|	RDSubprogram
		(y as {subprogram_specification = SSFunction _, ...}) =>
				renames_fun y
	|	RDFunction _ => ()
) | do_declaration (y as (DBasicDecl x) : DECLARATION) = (
	map do_basic_declaration (adjust_basic_decls [x]); ()
) | do_declaration (y as (DRepresentationClause x) : DECLARATION) = (
	comment "do_declaration" 507017 []
) | do_declaration (y as (DProperBody x) : DECLARATION) = (
	do_proper_body x
) | do_declaration (y as (DProcedureDeclaration x) : DECLARATION) = (
	do_procedure_spec x;
	end_scope()
) | do_declaration (y as (DFunctionDeclaration x) : DECLARATION) = (
	do_function_spec x;
	end_scope()
) | do_declaration (y as (DPackageDeclaration x) : DECLARATION) = (
	do_package_spec x
) | do_declaration (y as (DProcedureStub x) : DECLARATION) = (
	do_procedure_stub x
) | do_declaration (y as (DFunctionStub x) : DECLARATION) = (
	do_function_stub x
) | do_declaration (y as (DPackageStub x) : DECLARATION) = (
	do_package_stub x
) | do_declaration (y as (DExternalProcedureStub x) : DECLARATION) = (
	do_external_procedure_stub x
) | do_declaration (y as (DExternalFunctionStub x) : DECLARATION) = (
	do_external_function_stub x
) | do_declaration (y as (DAuxiliary x) : DECLARATION) = (
	aux_var x
) | do_declaration (y as (DUsing x) : DECLARATION) = (
	let	val z as {basic_decls, ...} = adjust_using_dec x;
	in	map do_basic_declaration basic_decls;
		using_dec z
	end
)
(*
=TEX
The following reflects the SID functions for $procedure\_specification$:
=SML
*)
and €do_procedure_spec› (
	{name, formal_part, globals, spec as Value sp, annotation}
		: PROCEDURE_SPECIFICATION) = (
	let	val esp = expand_frame sp;
		val eg = #w esp @ expand_names globals @ flat (map #idlist formal_part);
		val formal_proc : FORMAL_PROC =
		{name=name, spec=esp, globals = eg, formal_ids = map mk_param_spec formal_part};
	in	subunit_form name;
		new_scope_proc_form name;
		do_annotation annotation;
		stub();
		fformal_part formal_part;
		check_19 current_cn_env esp;
		curr_form_proc formal_proc;
		form_proc formal_proc;
		stub_spec_proc formal_proc;
		check_stub_spec_proc formal_proc
	end
) | €do_procedure_spec› (
	{name, formal_part, spec as Nil, annotation, globals} : PROCEDURE_SPECIFICATION) = (
	subunit_inf name;
	new_scope_proc_inf name;
	fformal_part formal_part;
	do_annotation annotation;
	stub()
)
(*
=TEX
The following reflects the SID functions for $function\_specification$:
=SML
*)
and €do_function_spec› (
	{designator, return, formal_part,
		spec as Value sp, annotation, globals, ...}
			: FUNCTION_SPECIFICATION) = (
	let	val informal_fun : INFORMAL_FUN =
		{name=designator,
		formal_pars = map mk_param_spec formal_part,
		return_type = return};
		val eg = expand_names globals;
		val formal_fun : FORMAL_FUN =
		{spec = expand_frame sp, informal_fun = informal_fun, globals = eg};
	in	subunit_form designator;
		new_scope_fun_form designator;
		do_annotation annotation;
		stub();
		fformal_part formal_part;
		curr_form_fun formal_fun;
		stub_spec_fun formal_fun;
		form_fun formal_fun
	end
) | €do_function_spec› (
	{designator, return, formal_part, spec as Nil, annotation, ...}
			: FUNCTION_SPECIFICATION) = (
	let	val informal_fun : INFORMAL_FUN =
		{name=designator,
		formal_pars = map mk_param_spec formal_part,
		return_type = return};
	in	subunit_inf designator;
		new_scope_fun_inf designator;
		do_annotation annotation;
		stub();
		fformal_part formal_part;
		inf_fun informal_fun
	end
)
(*
=TEX
The following reflects the SID functions for $package\_specification$:
=SML
*)
and €do_package_spec› ({name, visible_decs, private_decs, annotation}
			: DECLARATION PACKAGE_DECLARATION) = (
	let	val thy_name = pack_spec_name name;
	in	if	not (thy_name mem get_theory_names())
		then (	new_scope_pack_spec name;
			do_annotation annotation;
			map do_declaration visible_decs;
			map do_declaration private_decs;
			end_scope();
			update_envs_pack_spec name )
		else	fail "do_package_name" 507040
			[(fn()=>name), (fn()=>thy_name)]
	end
)
(*
=TEX
The following reflects the SID functions for $package\_body$:
=SML
*)
and €do_procedure_stub› (
	proc_spec : PROCEDURE_DECLARATION) = (
	begin_stub();
	do_procedure_spec proc_spec;
	update_envs_proc();
	add_proc_env();
	end_scope();
	end_stub()
)
and €do_function_stub› (
	fun_spec : FUNCTION_DECLARATION) = (
	begin_stub();
	do_function_spec fun_spec;
	end_scope();
	end_stub()
)
and €do_package_stub› (name : ID) = (
	pack_stub name
)
(*
=TEX
The following reflects the agreed treatment of external procedure and function ``stubs''.
=SML
*)
and €do_external_procedure_stub› (
	proc_spec : PROCEDURE_DECLARATION) = (
	do_procedure_spec proc_spec;
	add_proc_env();
	end_scope()
)
and €do_external_function_stub› (
	fun_spec : FUNCTION_DECLARATION) = (
	do_function_spec fun_spec;
	end_scope()
)
(*
=TEX
The following reflects the SID functions for:

\begin{tabular}{c}
subprogram\_body\\
subprogram\_implementation\\
package\_body\\
\end{tabular}

=SML
*)
and €do_proper_body› (y as (PBProcedure 
	{procedure_spec as {name,...}, declarative_part, statement}) : PROPER_BODY)
	: unit = (
	do_procedure_spec procedure_spec;
	subprogram_implementation();
	map do_declaration declarative_part;
	vcs_body (do_statement statement);
	update_envs_proc();
	add_proc_env();
	end_scope()
) | do_proper_body (y as (PBFunction 
	{function_spec as {designator,...}, declarative_part, statement}) : PROPER_BODY) = (
	do_function_spec function_spec;
	subprogram_implementation();
	map do_declaration declarative_part;
	vcs_body (do_statement statement);
	end_scope()
) | do_proper_body (y as (PBPackage 
	{name, decls, statement, annotation}) : PROPER_BODY) = (
	new_scope_pack_body name;
	set_body_name (trans_id name);
	do_annotation annotation;
	map do_declaration decls;
	(if any decls (fn d => case d of DUsing _ => true |_ => false)
	then	(vcs_aux_initial(do_statement statement); ())
	else	(do_statement statement; ()));
	end_scope()
);
=TEX
The following reflects the SID functions for $subunit$ (in its final clause).
=SML
fun €do_compilation_unit›
	(y as (CUPackageDeclaration (x as {name, ...})) : COMPILATION_UNIT)
	: unit = (
	set_cu(spec_script_desc name);
	do_declaration (DPackageDeclaration x)
) | do_compilation_unit (y as (CUProperBody x)) = (
	case x of
	PBProcedure _ => set_cu(subprogram_desc (compilation_unit_name y))
	| PBFunction _ => set_cu(subprogram_desc (compilation_unit_name y))
	| PBPackage _ => set_cu(pack_body_desc (compilation_unit_name y));
	do_declaration (DProperBody x)
) | do_compilation_unit (y as (CUSubUnit {name, proper_body})) = (
	set_cu (subunit_desc (compilation_unit_name y));
	new_parent_subunit_theory (name, proper_body);
	new_scope_subunit name;
	do_declaration (DProperBody proper_body);
	end_scope()
);
=TEX
The following reflects the SID functions for the productions $compilation\_unit$ and $simple\_name\_list$ (occuring in a $with\_clause$). Note that the package specification theory and the package body theory are created when the package specification is processed and not when the $with$ or $references$ clause is encountered; i.e., $new\_scope\_with$ is called in those places.

Also note that a missing with clause package name only raises a comment,
whereas a references clause raises a failure.
=SML
fun €context_clause_check› (ws : ID list) (rfs : ID list) = (
let  val chk_exists_r = map (fn w => case s_lookup w (!pack_env) of
	Value _ => ()
	| Nil => fail "context_clause_check" 507038 [fn () => w]) rfs;
     val chk_exists_w = map (fn w => case s_lookup w (!pack_env) of
	Value _ => ()
	| Nil => comment "context_clause_check" 507038 [fn () => w]) ws;
     fun aux (w::context) = (
	if w mem context
	then	fail "context_clause_check" 507031 [fn () => w]
	else	aux context
     ) | aux [] = ();
in
	aux (ws @ rfs)
end);

fun €do_context_compilation_unit›
	({context, references, comp_unit, annotation, ...}
		: CONTEXT_COMPILATION_UNIT) : unit = (
	let	val withed_packs = flat (map fst (context));
	in	context_clause_check withed_packs references;
		map new_scope_with withed_packs;
		map new_scope_with references;
		do_annotation annotation;
		do_compilation_unit comp_unit;
		end_scope_comp_unit()
	end
);
=TEX
The following reflects the need to register compilation k-slots .
=SML
fun €do_kslot_compilation_unit›
	(y as (KCUKSlot {label, content}) : KSLOT_COMPILATION_UNIT) : unit = (
	set_bottom_block_name (kslot_compilation_unit_name y);
	new_k_slot (label, RSCompilation, get_current_theory_name())
) | do_kslot_compilation_unit
	(y as (KCUUnit x) : KSLOT_COMPILATION_UNIT) = (
	set_bottom_block_name (kslot_compilation_unit_name y);
	do_context_compilation_unit x
) | do_kslot_compilation_unit
	(KCUPragma _ : KSLOT_COMPILATION_UNIT) = (
);
=TEX
The following reflects the SID functions for the production $web\_clause$.
(Note that we set up the label on the bottom block for possible use in generating VC names except in the first two cases, where the processing of the constituent k-slots or compilations units will do this.)
=SML
fun €do_web_clause› (y as (WCCompilation x) : WEB_CLAUSE) : unit = (
let	val current_theory = get_current_theory_name ();
in	update_spark_prog x;
	map do_kslot_compilation_unit x;
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByCompilation x) : WEB_CLAUSE) = (
let	val {label=label, comp=comp} = x;
in	case (s_lookup label (!repl_env), comp) of
		(Value (UnReplaced _), _) => (
		let	val current_theory = get_current_theory_name ();
		in	open_label_theory label;
			update_replacement_env(label, ReplaceComp x);
			map do_kslot_compilation_unit (#comp x);
			lazy_open_theory current_theory
		end
	) |	(Nil, [KCUUnit {comp_unit = CUProperBody (pb as PBPackage {name, ...}),
			context=[], references=[], ...}]) => (
			case s_lookup (trans_id name) (!repl_env) of
				Value (UnReplaced _) => (
					update_replacement_env
						(name, ReplaceComp{label = name, comp=comp});
					do_compilation_unit
						(CUSubUnit {name=label, proper_body=pb})
			) |	_ => (fail "do_web_clause" 507065 [fn _ => label])
	) | _ => fail "do_web_clause" 507065 [fn _ => label]
end
) | do_web_clause (y as (WCReplacedByPrivatePart x) : WEB_CLAUSE) = (
let	val {label=label, private=private} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplacePPart x);
	set_bottom_block_name label;
	new_scope_dec_replace 
		((fn {label,private} => {label=label, decls=private}) x);
	map do_declaration (#private x);
	update_envs_remove_declabel 
		((fn {label,private} => {label=label, decls=private}) x);
	end_scope();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByVisiblePart x) : WEB_CLAUSE) = (
let	val {label=label,visible=visible} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplaceVPart x);
	set_bottom_block_name label;
	new_scope_dec_replace  
		((fn {label,visible} => {label=label, decls=visible}) x);
	map do_declaration (#visible x);
	update_envs_remove_declabel 
		((fn {label,visible} => {label=label, decls=visible}) x);
	end_scope();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByDecl x) : WEB_CLAUSE) = (
let	val {label=label,decls=decls} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplaceDecl x);
	set_bottom_block_name label;
	new_scope_dec_replace x;
	map do_declaration decls;
	update_envs_remove_declabel x;
	end_scope();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCRefinedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	set_bottom_block_name label;
	new_scope_speclabel label;
	let	val expanded_statement = do_statement statement;
		val expanded_x = {label = label, statement = expanded_statement};
	in	update_replacement_env(label, RefineStat expanded_x);
		vcs_speclabel expanded_x
	end;
	end_scope_speclabel();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	set_bottom_block_name label;
	new_scope_stmt_label label;
	let	val expanded_statement = do_statement statement;
		val expanded_x = {label = label, statement = expanded_statement};
	in	update_replacement_env(label, RefineStat expanded_x)
	end;
	end_scope_stmt_label();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByArbitraryAda x) : WEB_CLAUSE) = (
let	val {label=label, ...} = x;
in	comment "do_web_clause" 507039 [];
	store_message_vc 507039 [];
	update_replacement_env(label, ReplaceArbitrary x)
end
) | do_web_clause (y as (WCReplacedByAnnotation x) : WEB_CLAUSE) = (
let	val {label=label, replacement=ann} = x;
in	update_replacement_env(label, ReplaceAnnotation x);
	do_annotation ann
end
);
=TEX
\section{INTERFACE}
The following function is called from \cite{ISS/HAT/DAZ/IMP504} to classify a label.
=SML
fun €classify_label› (lab : string) : REPL_SORT OPT = (
	case s_lookup lab (!repl_env) of
		Value(UnReplaced(rs, _)) => Value rs
	|	_ => (
			case (s_lookup (trans_id lab) (!pack_env)) of
				Value _ => Value RSCompilation
			|	Nil => Nil
	)
);
=TEX
=SML
fun €get_replacement› (lab : string) : REPLACEMENT OPT = (
	s_lookup lab (!repl_env)
);
=TEX
=SML
abstype €CN_STATE› = CNState of Z_GENERATOR_STATE with
=TEX
=SML
	val €initial_cn_state› as CNState init_z_generator_state : CN_STATE = (
		CNState {pack_env = pack_env0,
			subunit_env = subunit_env0,
			dec_env = dec_env0,
			spec_env = spec_env0,
			blocks = env0,
			repl_env = repl_env0,
			spark_prog = spark_prog0,
			script_name = ""}
	);

	val €state_db› : Z_GENERATOR_STATE E_DICT ref = 
		ref (e_enter "" init_z_generator_state initial_e_dict);
(*
=TEX
=SML
*)
	fun €save_cn_state› (() : unit) : unit = (
		let	val zgs as {script_name, ...} = get_z_generator_state();
		in	state_db := e_enter script_name zgs (!state_db)
		end
	);

	fun €get_saved_cn_state› (s : string) : CN_STATE = (
		let	val s' = case s of "-" => get_current_theory_name() | _ => s;
		in	case e_lookup s' (!state_db) of
				Value st => CNState st
			|	Nil => fail "get_saved_cn_state" 507070 [fn _ => s]
		end
	);
(*
=TEX
It is tricky in the following to know whether or not to save the state
if an exception is raised. The current approach is to save.
=SML
*)
	fun €cn_z_generator› (w : WEB_CLAUSE) : unit = (
		let	val save_zg_state = get_z_generator_state();
			val save_ti_cxt = get_ti_context();
		in	diag_vc_args := [];
			diag_basic_decl_list := [];
			diag_web_clause := w;
			(do_web_clause w)
			handle ex => (
				diag_z_generator_state := get_z_generator_state();
				save_cn_state();
				set_z_generator_state save_zg_state;
				set_ti_context save_ti_cxt;
				raise ex
			);
			save_cn_state();
			set_ti_context save_ti_cxt
		end
	);
(*
=TEX
=SML
*)
	fun €restart_cn_z_generator› (():unit) : unit = (
		set_z_generator_state init_z_generator_state;
		reset_cn_parser_state()
	);
(*
=TEX
=SML
*)
	fun €init_cn_z_generator› 
		(continue : bool)
		(script_name : string) : unit = (
		set_z_generator_state
		(if continue
		then	let	val {repl_env, spark_prog, ...} = get_z_generator_state();
			in	{	pack_env = !pack_env,
					subunit_env = !subunit_env,
					dec_env = dec_env0,
					spec_env = spec_env0,
					blocks = env0,
					repl_env = repl_env,
					spark_prog = spark_prog,
					script_name = script_name}
			end
		else	{	pack_env = !pack_env,
				subunit_env = !subunit_env,
				dec_env = dec_env0,
				spec_env = spec_env0,
				blocks = env0,
				repl_env = repl_env0,
				spark_prog = spark_prog0,
				script_name = script_name});
		save_cn_state();
		reset_cn_parser_state()
	);
(*
=TEX
{init\_cn\_z\_generator\_state} does the state-saving that one might have
expected to see in the following.
=SML
*)
	fun €do_new_script› (continue : bool)
		{	name : string,
			state = CNState zg_state : CN_STATE} : unit = (
		let	val old_state = get_z_generator_state ();
			val thy = get_current_theory_name();
		in
		(	set_z_generator_state zg_state;
			open_theory "cn";
			new_theory_aux [] name;
			set_cn_created();
			CaseIndependence.reset_names ();
			init_cn_z_generator continue name
		) handle ex => (
			set_z_generator_state old_state;
			open_theory thy;
			reraise ex "new_script"
			)
		end		
	);
(*
=TEX
Again, {init\_cn\_z\_generator\_state} does the state-saving that one might have
expected to see in the following.
=SML
*)
	fun €do_new_script1› (continue : bool)
		{	name : string,
			state = CNState zg_state : CN_STATE,
			library_theories : string list} : unit = (
		let	val old_state = get_z_generator_state ();
			val thy = get_current_theory_name();
		in
		(	set_z_generator_state zg_state;
			open_theory "cn";
			new_theory_aux [] name;
			set_cn_created();
			CaseIndependence.reset_names ();
			init_cn_z_generator continue name;
			(map (fn t => new_parent_aux false t
				handle (Fail m) =>
				fail "new_script1"
				507042 [fn ()=> t, fn () => get_message_text m])
				 library_theories);
			map add_library_theory library_theories;
			()
		) handle ex => (
			set_z_generator_state old_state;
			open_theory thy;
			reraise ex "new_script1"
			)
		end		
	);
(*
=TEX
=SML
*)
	val €new_script› : {name : string, state : CN_STATE} -> unit
		= do_new_script false;
	val €new_script1› :
		{name : string, state : CN_STATE, library_theories : string list} -> unit
		= do_new_script1 false;
	val €new_continuation_script› : {name : string, state : CN_STATE} -> unit
		= do_new_script true;
	val €new_continuation_script1› :
		{name : string, state : CN_STATE, library_theories : string list} -> unit
		= do_new_script1 true;

	fun €get_cn_state› (() : unit) : CN_STATE = (
		CNState (get_z_generator_state())
	);

	fun €set_cn_state› (CNState zg_state : CN_STATE) : unit = (
		set_z_generator_state zg_state;
		save_cn_state();
		(open_theory o #script_name) zg_state
			handle Fail _ => open_theory "cn"
	);
(*
=TEX
=SML
*)
end (* ... abstype *);
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNZGenerator *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
=IGN





