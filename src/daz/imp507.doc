% imp507.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP507}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
Sections \ref{BASICDECLARATIONS} to \ref{WEBCLAUSES} implement the material defined in the corresponding sections of \cite{ISS/HAT/DAZ/DTD507}.

Section \ref{PREAMBLE} contains various material which supports this, e.g. the component update functions and initial environment values of \cite{ISS/HAT/DAZ/DTD513}.
Because the implementations of the component update functions are rather long-winded, they are all given together and the other material is not interleaved with them.
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE AND AUXILIARIES}\ref{PREAMBLE}
=SML
structure €CNZGenerator› (* : CNZGenerator *) = struct
open CNTypes CNTypes1 CNTypes2 CNBasicDeclsAndExprs ZParagraphs;
=TEX
\subsection{TBS}
The following gets around the use of a separate data type for labels.
It is much more convenient here to represent an omitted label as an empty string.
It would be better to make this change of representation throughout.
=SML
fun €string_of_label› (LExplicit s : LABEL) : string = s
|    string_of_label LImplicit = "";
=TEX
\subsection{Component Update Functions}
=SML
fun €package_vc_vars› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_vc_vars : VAR_DECL list) : PACKAGE = (
	{	vc_vars		=	new_vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_consts_types› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_consts_types : BASIC_DECL list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	new_consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_formal_procs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_procs : FORMAL_PROC list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	new_formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_informal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_informal_funs : INFORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	new_informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_formal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	new_formal_funs	}	
);
=TEX
=SML
fun €subunit_vc_vars›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_vc_vars : VAR_DECL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €package_formal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	new_formal_funs	}	
);
=TEX
=SML
fun €subunit_formal_procs›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_formal_procs : FORMAL_PROC list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €subunit_dec_labels›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_dec_labels : LABEL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}
	}
);
=TEX
=SML
fun €declab_declabel_flag›  (
	{	block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope
	} : DECLAB,
	new_declabel_flag : FLAG) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	{
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	new_declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag
		},
		in_scope	=	in_scope
	}
);
=TEX
=SML
fun €declab_vc_vars›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_vc_vars : VAR_DECL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	new_vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun €declab_formal_procs›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_formal_procs : FORMAL_PROC list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	new_formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun €declab_dec_labels›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_dec_labels : LABEL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	formal_procs,
			dec_labels		=	new_dec_labels
		}
	}
);
=TEX
=SML
fun €speclab_w›  (
	{spec as  { w, w0, pre, post, label},
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope
	} : SPECLAB,
	new_w : Z_ID list) : SPECLAB = (
	{spec 			=	{w = new_w, w0 = w0, pre = pre,
						post = post, label = label},
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	in_scope
	}
);
=TEX
=SML
fun €speclab_vc_vars›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SPECLAB,
	new_vc_vars : VAR_DECL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €speclab_formal_procs›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SPECLAB,
	new_formal_procs : FORMAL_PROC list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}

	}
);
=TEX
=SML
fun €speclab_dec_labels›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SPECLAB,
	new_dec_labels : LABEL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}

	}
);
=TEX
=SML
fun €block_stub_flag›  (
	{
	declab as {block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_stub_flag : FLAG) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	new_stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag
				},
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_till_flag›  (
	{
	declab as {block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_till_flag : FLAG) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	new_till_flag
				},
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_vc_vars›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_vc_vars : VAR_DECL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_vc_pars›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_vc_pars : PARAM_SPEC list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	new_vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_vc_log_cons›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_vc_log_cons : Z_DECL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	new_vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_formal_procs›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_formal_procs : FORMAL_PROC list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_current_formal_proc›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till} : BLOCK,
	new_current_formal_proc : FORMAL_PROC) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = new_current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_current_formal_fun›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till} : BLOCK,
	new_current_formal_fun : FORMAL_FUN) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = new_current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_till›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till} : BLOCK,
	new_till : Z_PRED) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = new_till
	}
);
=TEX
\subsection{Initial Values}

=TEX
=SML
val €pack_env0› : PACK_ENV = initial_s_dict;
val €subunit_env0› : SUBUNIT_ENV = initial_s_dict;
val €dec_env0› : DEC_ENV = initial_s_dict;
val €spec_env0› : SPEC_ENV = initial_s_dict;
=TEX
$empty\_block$ is the initial value for a block, as loosely specified in \cite{ISS/HAT/DTD513}.
Fields which are not specified there are given place-holder values.
All the flags are set false, for convenience in defining $env0$.
It is convenient to define some shared dummy values first:
=SML
val €dummy_spec› : SPEC = {
		w 		= 	[],
		w0		=	[],
		pre		=	mk_z_true,
		post		=	mk_z_true,
		label		=	LImplicit};
val €dummy_informal_fun› : INFORMAL_FUN = {
		name		=	"*dummy fun*",
		formal_pars	=	[],
		return_type	=	"*dummy type*"};
val €dummy_formal_fun› : FORMAL_FUN = {
		informal_fun	=	dummy_informal_fun,
		spec		=	dummy_spec};
val €dummy_formal_proc› : FORMAL_PROC = {
		name		=	"*dummy formal proc*",
		formal_ids	=	[],
		spec		=	dummy_spec};
val €empty_in_scope› : IN_SCOPE = {
		vc_vars		=	[],
		vc_pars		=	[],
		vc_log_cons	=	[],
		formal_procs	=	[],
		dec_labels	=	[]};
val €false_flags› : FLAGS = {
		pack_spec_flag		=	false,
		pack_body_flag		=	false,
		stub_flag		=	false,
		subunit_flag		=	false,
		formal_body_flag	=	false,
		fun_flag		=	false,
		declabel_flag		=	false,
		speclabel_flag		=	false,
		till_flag		=	false};
val €dummy_declab› : DECLAB = {
		block_name	=	"*empty block*",
		flags		=	false_flags,
		in_scope	=	empty_in_scope};
=TEX
=SML
val €empty_block› : BLOCK = 	{
	declab		=	dummy_declab,
	current_formal_proc = dummy_formal_proc,
	current_formal_fun = dummy_formal_fun,
	dec_lab = LImplicit,
	spec_lab = LImplicit,
	till = mk_z_true
};
=TEX
Now we can define $env0$, exploiting the fact that all the flags are set to $false$ in $empty\_block$.
=SML
val €env0› : ENV = [empty_block];
=TEX
We also require initial values for the SPARK program and replacement environments discussed in \cite{ISS/HAT/DTD513}
=SML
val €repl_env0› : REPL_ENV = initial_s_dict;
val €spark_prog0› : SPARK_PROG = [];
=TEX
For uniformity, we give the initial value for the theory name component of the global state here.
We use the string ``-'' which by convention in {\Product} means the current theory.
=SML
val €script_name0› : string = "-";
=TEX
\subsection{$flatten\_env$}
To implement $flatten\_env$, we first need a function to merge two $IN\_SCOPE$s.
=SML
fun €merge_in_scopes›
	({	vc_vars = vc_vars1,
		vc_pars = vc_pars1,
		vc_log_cons = vc_log_cons1,
		formal_procs = formal_procs1,
		dec_labels = dec_labels1} : IN_SCOPE)
	({	vc_vars = vc_vars2,
		vc_pars = vc_pars2,
		vc_log_cons = vc_log_cons2,
		formal_procs = formal_procs2,
		dec_labels = dec_labels2} : IN_SCOPE) : IN_SCOPE = (
	{	vc_vars = vc_vars1 @ vc_vars2,
		vc_pars = vc_pars1 @ vc_pars2,
		vc_log_cons = vc_log_cons1 @ vc_log_cons2,
		formal_procs = formal_procs1 @ formal_procs2,
		dec_labels = dec_labels1 @dec_labels2}
);
=TEX
Now we define $flatten\_env$, which uses $merge\_in\_scopes$ to merge all the $in\_scope$ components of the blocks in a running environment.
To avoid unnecessary merging with the empty $in\_scope$ value, the case of a singleton list in the environment is treated separately (the function would compute the same value if the second clause were omitted but would be less efficient with space).

=SML
fun €flatten_env› ([] : ENV) : IN_SCOPE = (
	empty_in_scope
) |  flatten_env [blk] = (
	#in_scope(#declab blk)
) |  flatten_env (blk :: blks) = (
	merge_in_scopes (#in_scope(#declab blk)) (flatten_env blks)
);
=TEX
\subsection{The Global State}
For convenience in the implementation, the eight components of the state are held in eight assignable variables:
=SML
val €pack_env› : PACK_ENV ref = ref pack_env0;
val €subunit_env› : SUBUNIT_ENV ref = ref subunit_env0;
val €dec_env› : DEC_ENV ref = ref dec_env0;
val €spec_env› : SPEC_ENV ref = ref spec_env0;
val €blocks› : ENV ref = ref env0;
val €repl_env› : REPL_ENV ref = ref repl_env0;
val €spark_prog› : SPARK_PROG ref = ref spark_prog0;
val €script_name› : string ref = ref script_name0;
=TEX
The global state may be set from a given value of type $CN\_STATE$ using the following function:
=SML
fun €set_cn_state› ({
		pack_env = new_pack_env,
		subunit_env = new_subunit_env,
		dec_env = new_dec_env,
		spec_env = new_spec_env,
		blocks = new_blocks,
		repl_env = new_repl_env,
		spark_prog = new_spark_prog,
		script_name = new_script_name
	} : CN_STATE) : unit = (
		pack_env := new_pack_env;
		subunit_env := new_subunit_env;
		dec_env := new_dec_env;
		spec_env := new_spec_env;
		blocks := new_blocks;
		repl_env := new_repl_env;
		spark_prog := new_spark_prog;
		script_name := new_script_name
);
=TEX
=SML
fun €get_cn_state› (() : unit) : CN_STATE = (
		{pack_env = !pack_env,
		subunit_env = !subunit_env,
		dec_env = !dec_env,
		spec_env = !spec_env,
		blocks = !blocks,
		repl_env = !repl_env,
		spark_prog = !spark_prog,
		script_name = !script_name}
);
=TEX
\subsection{Function Parameter Lists}
When the global variable representing a SPARK function is stored in a theory, a user data entry giving its formal parameter list is also stored.
This is later accessed via the $CN\_ENV$ when function calls using named parameter associations are translated into Z.
=SML
local
val €cn_ud_key› = "CN'formal_pars";
fun €dest_ud_string› (UD_String (n, uds)) = (n, uds)
|   dest_ud_string _ = fail "" 0 [] (* always caught below *);
fun €wanted› (fun_name : ID) (UD_String (i, _)) = (i = fun_name)
|   wanted _ _ = false;
in
fun €get_par_names› (fun_name : Z_ID) : ID list OPT = (
	((Value o map (fst o dest_ud_string) o snd o dest_ud_string o
		switch find (wanted fun_name) o snd o dest_ud_string o
		get_user_datum (get_const_theory fun_name))
	cn_ud_key)
	handle Fail _ => Nil
);
fun €set_par_names› (fun_name : ID) (pars : ID list) : unit = (
	let	val old = (snd o dest_ud_string o get_user_datum "-") cn_ud_key
			handle Fail _ => [];
		val new = 
			UD_String(fun_name, map (fn p => UD_String(p, [])) pars)
			:: (old drop wanted fun_name);
	in	set_user_datum(cn_ud_key, UD_String("", new))
	end
);
end;
=TEX
=IGN
new_const("fruit", BOOL);
get_par_names "fruit";
set_par_names "fruit" ["apple", "banana", "cherry"];
get_par_names "fruit";
set_par_names "fruit" ["apple", "banana", "cherry", "date"];
get_par_names "fruit";
new_const("veg", BOOL);
get_par_names "veg";
set_par_names "veg" ["artichoke", "bean", "carrot"];
get_par_names "veg";
set_par_names "veg" ["leek", "marrow"];
get_par_names "veg";
get_par_names "fruit";
=TEX
\subsection{Constructing $CN\_ENV$s}
The code here must pass type information into the functions defined in \cite{ISS/HAT/DAZ/DTD505,ISS/HAT/DAZ/DTD508} using the data type $CN\_ENV$ defined in \cite{ISS/HAT/DAZ/DTD508}.
The following functions are used to do this.

=SML
fun €z_id_of_id› (n : ID) : Z_ID = (
	(fst o dest_const o mk_z_gvar)(trans_id n, BOOL, [])
);
=TEX
$get\_tmark\_from\_inscope$ searches an $IN\_SCOPE$ value for the type mark associated with a variable or parameter name:
=SML
fun €get_tmark_from_inscope› (n : Z_ID) (inscope : IN_SCOPE) : TMARK OPT = (
	let	fun do_vars [] = Nil
		|   do_vars ({vars, tmark} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_vars more
		);
		fun do_pars [] = Nil
		|   do_pars ({var_decl as {vars, tmark}, mode} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_pars more
		);
	in	case do_vars (#vc_vars inscope) of
			Nil		=> do_pars (#vc_pars inscope)
		|	value_tmark	=> value_tmark
	end
);
=TEX
Now $get\_tmark\_from\_env$, which searches the running environment using the previous function to look for the required type mark.
=SML
fun €get_tmark_from_env› (_ : Z_ID) ([] : ENV) : TMARK OPT = (
	Nil
) | €get_tmark_from_env› (n : Z_ID) (block :: more) : TMARK OPT = (
	case get_tmark_from_inscope n (#in_scope (#declab block)) of
			Nil		=> get_tmark_from_env n more
		|	value_tmark	=> value_tmark
);
=TEX
Now, if we find a type mark, we need to convert it to an HOL type.
This is done by looking in the theory database.
The type there for a type $\tau$ will be $\tau$.
We must strip off the .
=SML
fun €type_of_tmark› (tmark : TMARK) : TYPE OPT = (
	(case (get_const_type (z_id_of_id(tmark))) of
		Value ty => (Value (dest_z_power_type ty))
	|	Nil => Nil)
	handle Fail _ => Nil
);
=TEX
If we don't find a type mark, then the only possibility is that the name is that of a SPARK function, constant or type stored as a global variable in the theory database.
In this case the stored type is correct as it stands (no  to take away).
=SML
fun €type_of_g_var› (zn : Z_ID) : TYPE OPT = (
	(case get_const_type zn of
		Value ty => (Value ty)
	|	Nil => Nil)
);
=TEX
If we have the a global variable, then we need to classify it as a function, or record type type mark or other sort of SPARK entity.
for a function, we also need the formal parameter list.
To make this classification, we first check to see whether any formal parameters have been associated with the name:
if so, then it's a function and we have the parameter names to hand;
if not, then we dismantle the type: if its a set of bindings, then this is a record type mark; otherwise its an `other'.
=SML
fun €env_info_of_g_var› (zn : Z_ID) (ty : TYPE) = (
	case get_par_names zn of
		Value pars => (ty, EIEnvFunction pars)
	|	Nil => (
		(ty,
		(dest_z_schema_type (dest_z_power_type ty); EIEnvRecord)
		handle Fail _ => EIEnvOther)
	)
);
=TEX
=SML
fun €current_cn_env› (n : ID) : (TYPE * ENV_INFO) OPT = (
	case get_tmark_from_env (trans_id n) (!blocks) of
		Value tmark => (
			case type_of_tmark tmark of
				Value ty => Value (ty, EIEnvVar tmark)
			|	Nil => Nil
	) | 	Nil => (
			case type_of_g_var n of
				Value ty => Value(env_info_of_g_var n ty)
			|	Nil => Nil
	)
);
=TEX
\section{BASIC DECLARATIONS}\label{BASICDECLARATIONS}
The decision about which function to call is made in $basic\_declaration$ itself.
=SML
fun €basic_decl_pack_spec› (basic_decl : BASIC_DECL) : unit = (
	let	val block_name1 = #block_name(#declab (hd (!blocks)));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "basic_decl_pack_spec" 507001 [];
	in	pack_env :=
		s_extend
		block_name1
		(package_consts_types(package,
				#consts_types package @ [basic_decl]))
		(!pack_env)
	end
);
=TEX
=SML
fun €basic_decl_otherwise› (basic_decl : BASIC_DECL) : unit = (
	let	val para_infos = trans_basic_decl current_cn_env basic_decl;
	in	map update_theory_db_with_parainfo para_infos; ()
	end
);
=TEX	
=SML
fun €basic_declaration› (basic_decl : BASIC_DECL) : unit = (
	if	#pack_spec_flag(#flags(#declab (hd (!blocks))))
	then	basic_decl_pack_spec basic_decl
	else	basic_decl_otherwise basic_decl
);
=TEX
=SML
fun €var_pack_spec› (var_decl : VAR_DECL) : unit = (
	let	val block_name1 = #block_name(#declab (hd (!blocks)));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "var_pack_spec" 507001 [];
	in	pack_env :=
		s_extend
		block_name1
		(package_vc_vars(package,
				#vc_vars package @ [var_decl]))
		(!pack_env)
	end
);
=TEX
In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (hd (!blocks));
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab1 mem dec_labels
			then	(id1_id2,
				subunit_vc_vars(s, vc_vars grab var_decl))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (hd (!blocks));
		fun do1_dec_label
			(dec_label_s as
				(dec_label,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(dec_label,
				declab_vc_vars(s, vc_vars grab var_decl))
			else	dec_label_s
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
The identifiers in the variable declaration are translated first.
=SML
fun €update_spec_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (hd (!blocks));
		val trans_vars = map trans_id (#vars var_decl);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(spec_label,
				speclab_w(
					speclab_vc_vars(s, vc_vars grab var_decl),
					trans_vars cup w))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun €update_envs_var› (var_decl : VAR_DECL) : unit = (
	update_subunit_env_var var_decl;
	update_dec_env_var var_decl;	
	update_spec_env_var var_decl
);
=TEX
=IGN
val d1 = cn_basic_decl_of_string "x : constant Integer := 42;";
val d2 = cn_basic_decl_of_string "x : constant Integer;";
val d3 = cn_basic_decl_of_string "type zed is range 0 .. 20;";
val d4 = cn_basic_decl_of_string "y : Integer;";
val d5 = cn_basic_decl_of_string "type why is private;";
trans_basic_decl env d5;


=TEX
\section{DECLARATIONS}\label{DECLARATIONS}
\section{STATEMENTS}\label{STATEMENTS}
\section{LOOPS}\label{LOOPS}
\section{SUBPROGRAM DECLARATIONS}\label{SUBPROGRAMDECLARATIONS}
\section{PROCEDURES}\label{PROCEDURES}
\section{FUNCTIONS}\label{FUNCTIONS}
\section{FORMAL PARAMETERS}\label{FORMALPARAMETERS}
\section{SUBPROGRAM BODIES}\label{SUBPROGRAMBODIES}
\section{PACKAGES}\label{PACKAGES}
\section{STUBS AND SUBUNITS}\label{STUBSANDSUBUNITS}
\section{WEB CLAUSES}\label{WEBCLAUSES}
=TEX
In the following, those fields for the new block which are left undefined in the Z specification are borrowed from the empty block value.
=SML
fun €new_scope_dec_replace› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	val lab = string_of_label label;
	in
	case s_lookup lab (!dec_env) of
		Value declab => (
			let	val block = {
		declab = declab,
		current_formal_proc = #current_formal_proc empty_block,
		current_formal_fun = #current_formal_fun empty_block,
		dec_lab = label,
		spec_lab = #spec_lab empty_block,
		till = #till empty_block};
			in	blocks := block :: !blocks;
				dec_env := s_delete lab (!dec_env)
			end
	) |	Nil => fail "new_scope_dec_replace" 507002
			[fn () => lab]
	end
);
=TEX
In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_remove_declabel› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_subunit
			((id1_id2,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SUBUNIT) = (
			(id1_id2,
			subunit_dec_labels(s, dec_labels less label))
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_remove_declabel› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_dec_label
			((dec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * DECLAB) = (
			(dec_label,
			declab_dec_labels(s, dec_labels less label))
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
=SML
fun €update_spec_env_var› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_spec_label
			((spec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SPECLAB) = (
			(spec_label,
			speclab_dec_labels(s, dec_labels less label))
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
TBS - the error reporting here could usefully be made more sophisticated.
(By checking that $repl$ and the replacement environment entry are of the same sort.)
=SML
fun €update_replacement_env› ((label, repl) : LABEL * REPLACEMENT) : unit = (
	let	val lab = string_of_label label;
		val msg_no = case s_lookup lab (!repl_env) of
			Value(UnReplaced _) => 0
		|	Value _ => 507004
		|	Nil => 507003;
		val side_effect =
				if	msg_no <> 0
				then	warn "update_replacement_env" 507003
					[fn () => lab]
				else	();
	in	repl_env := s_enter lab repl (!repl_env)
	end
);
=TEX
=SML
fun €update_spark_prog› (comp : KSLOT_COMPILATION_UNIT list) : unit = (
	spark_prog := !spark_prog @ comp
);
=TEX
\section{INTERFACE}
The following function is called from \cite{ISS/HAT/DAZ/IMP504} to classify a label.
=SML
fun €classify_label› (lab : string) : REPL_SORT OPT = (
	case s_lookup lab (!repl_env) of
		Value(UnReplaced(rs, _)) => Value rs
	|	_ => Nil
);
=TEX
=SML
fun €do_basic_decl› (y as (x) : BASIC_DECL) = (y
);
fun €do_case_choice› (y as (CCCaseExp x) : CASE_CHOICE) = (y
) | do_case_choice (y as (CCCaseRange x) : CASE_CHOICE) = (y
);
fun €do_loop_direction› (y as LDForwards : LOOP_DIRECTION) = (y
) | do_loop_direction (y as LDReverse : LOOP_DIRECTION) = (y
);
fun €do_stmt› (y as STNull : STMT) = (y
) | do_stmt (y as STImplicitNull : STMT) = (y
) | do_stmt (y as (STAssign x) : STMT) = (y
) | do_stmt (y as (STSpecNoIvars x) : STMT) = (y
) | do_stmt (y as (STSemicolon x) : STMT) = (y
) | do_stmt (y as (STIfThenElse x) : STMT) = (y
) | do_stmt (y as (STCase x) : STMT) = (y
) | do_stmt (y as (STLoop x) : STMT) = (y
) | do_stmt (y as (STNamedLoop x) : STMT) = (y
) | do_stmt (y as (STWhile x) : STMT) = (y
) | do_stmt (y as (STForStatic x) : STMT) = (y
) | do_stmt (y as (STForTmark x) : STMT) = (y
) | do_stmt (y as (STExitWhen x) : STMT) = (y
) | do_stmt (y as STExit : STMT) = (y
) | do_stmt (y as (STRet x) : STMT)  = (y
) | do_stmt (y as (STProcNoIvars x) : STMT) = (y
) | do_stmt (y as (STKSlot x) : STMT) = (y
);
fun €do_statement› (y as (SStmt x) : STATEMENT) = (y
) | do_statement (y as (SSpecIvars x) : STATEMENT) = (y
) | do_statement (y as (SForNonStatic x) : STATEMENT) = (y
) | do_statement (y as (SLogCon x) : STATEMENT) = (y
) | do_statement (y as (SProcIvars x) : STATEMENT) = (y
);
fun €do_mode› (y as MSparkIn) = ( y
) | do_mode (y as MSparkOut) = (y
) | do_mode (y as MSparkInOut) = (y
);

fun €do_subprogram_specification› (y as (SSProcedure x) : SUBPROGRAM_SPECIFICATION) = (y
) | do_subprogram_specification (y as (SSFunction x) : SUBPROGRAM_SPECIFICATION) = (y
);
fun €do_actual_parameter_part› (y as (APPNamed x) : ACTUAL_PARAMETER_PART) = (y
) | do_actual_parameter_part (y as (APPPositional x) : ACTUAL_PARAMETER_PART) = (y
);
fun €do_renaming_declaration› (y as (RDFunction x) : RENAMING_DECLARATION) = (y
) | do_renaming_declaration (y as (RDSubprogram x) : RENAMING_DECLARATION) = (y
);
fun €do_representation_clause› (y as (RCLength x) : REPRESENTATION_CLAUSE) = (y
) | do_representation_clause (y as (RCEnumeration x) : REPRESENTATION_CLAUSE) = (y
) | do_representation_clause (y as (RCRecord x) : REPRESENTATION_CLAUSE) = (y
) | do_representation_clause (y as (RCAddress x) : REPRESENTATION_CLAUSE) = (y
);
fun €do_declaration› (y as (DDeclarationKSlot x) : DECLARATION) = (y
) | do_declaration (y as (DRenamingDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DBasicDecl x) : DECLARATION) = (y
) | do_declaration (y as (DRepresentationClause x) : DECLARATION) = (y
) | do_declaration (y as (DProperBody x) : DECLARATION) = (y
) | do_declaration (y as (DProcedureDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DFunctionDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DPackageDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DProcedureStub x) : DECLARATION) = (y
) | do_declaration (y as (DFunctionStub x) : DECLARATION) = (y
) | do_declaration (y as (DPackageStub x) : DECLARATION) = (y
);

fun €do_compilation_unit› (y as (CUPackageDeclaration x) : COMPILATION_UNIT) = (y
) | do_compilation_unit (y as (CUProperBody x) : COMPILATION_UNIT) = (y
) | do_compilation_unit (y as (CUSubUnit x) : COMPILATION_UNIT) = (y
);
fun €do_proper_body› (y as (PBProcedure x) : PROPER_BODY) = (y
) | do_proper_body (y as (PBFunction x) : PROPER_BODY) = (y
) | do_proper_body (y as (PBPackage x) : PROPER_BODY) = (y
);
fun €do_kslot_compilation_unit› (y as (KCUKSlot x) : KSLOT_COMPILATION_UNIT) = (y
) | do_kslot_compilation_unit (y as (KCUUnit x) : KSLOT_COMPILATION_UNIT) = (y
);
fun €do_web_clause› (y as (WCCompilation x) : WEB_CLAUSE) : unit = (
	update_spark_prog x
) | do_web_clause (y as (WCReplacedByCompilation x) : WEB_CLAUSE) = (
let	val {label=label, comp=comp} = x;
in	update_replacement_env(label, ReplaceComp x)
end
) | do_web_clause (y as (WCReplacedByPrivatePart x) : WEB_CLAUSE) = (
let	val {label=label, private=private} = x;
in	update_replacement_env(label, ReplacePPart x)
end
) | do_web_clause (y as (WCReplacedByVisiblePart x) : WEB_CLAUSE) = (
let	val {label=label,visible=visible} = x;
in	update_replacement_env(label, ReplaceVPart x)
end
) | do_web_clause (y as (WCReplacedByDecl x) : WEB_CLAUSE) = (
let	val {label=label,decls=decls} = x;
in	update_replacement_env(label, ReplaceDecl x)
end
) | do_web_clause (y as (WCRefinedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
in	update_replacement_env(label, ReplaceStat x)
end
) | do_web_clause (y as (WCReplacedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
in	update_replacement_env(label, ReplaceStat x)
end
);

=TEX
=SML
fun cn_z_generator (w : WEB_CLAUSE) : unit = (
()
);
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNZGenerator *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
