% imp507.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP507}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\raggedright{\TPPabstract{This document contains the implementation for the Z generation functions of Volume 1 of DRA's specification.}}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz,hatdocs}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{94/06/10%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
Sections \ref{BASICDECLARATIONS} to \ref{WEBCLAUSES} implement the material defined in the corresponding sections of \cite{ISS/HAT/DAZ/DTD507}. Section \ref{PREAMBLE} contains various material which supports this, e.g. the component update functions and initial environment values of \cite{ISS/HAT/DAZ/DTD513}. Because the implementations of the component update functions are rather long-winded, they are all given together and the other material is not interleaved with them.
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE AND AUXILIARIES}\label{PREAMBLE}
=SML
structure ÛCNZGeneratorÝ : CNZGenerator = struct
open CNTypes CNTypes1 CNTypes2 CNBasicDeclsAndExprs ZParagraphs
	CNVCGenerator CNParser ZUserInterfaceSupport;
=TEX

The following functions are used to identify names for web clauses and are used in the naming of VCs.
=SML
fun Ûk_slot_nameÝ ({content, label} : K_SLOT) : string = label;
fun Ûpackage_declaration_nameÝ
	({name, visible_decs, private_decs} : DECLARATION PACKAGE_DECLARATION)
	: string = (
	name
);
fun Ûprocedure_specification_nameÝ
	({name, ...} : PROCEDURE_SPECIFICATION) : string = (
	name
);
fun Ûfunction_specification_nameÝ
	({designator, ...} : FUNCTION_SPECIFICATION) : string = (
	designator
);

fun Ûprocedure_body_nameÝ ({procedure_spec, ...} : DECLARATION PROCEDURE_BODY)
	: string = (
	procedure_specification_name procedure_spec
);
fun Ûfunction_body_nameÝ ({function_spec,...} : DECLARATION FUNCTION_BODY)
	: string = (
	function_specification_name function_spec
);
fun Ûpackage_body_nameÝ ({name, ...} : DECLARATION PACKAGE_BODY) : string = (
	name
);
=TEX
=SML
fun Ûproper_body_nameÝ (pb : PROPER_BODY) : string = (
	case pb of
		PBProcedure prc => procedure_body_name prc
	|	PBFunction fnc =>  function_body_name fnc
	|	PBPackage pck => package_body_name pck
);
fun Ûsubunit_nameÝ ({name, proper_body} : COMP_SUBUNIT) : string = (
	name ^ "o" ^ proper_body_name proper_body
);
fun Ûcompilation_unit_nameÝ (cu : COMPILATION_UNIT) : string = (
	case cu of
		CUPackageDeclaration d => package_declaration_name d
	|	CUProperBody b => proper_body_name b
	|	CUSubUnit s => subunit_name s
);

fun Ûcontext_compilation_unit_nameÝ
	({context, comp_unit} : CONTEXT_COMPILATION_UNIT) = (
	compilation_unit_name comp_unit
);
fun Ûk_slot_compilation_unit_nameÝ (kcu : KSLOT_COMPILATION_UNIT) : string = (
	case kcu of
		KCUKSlot ks => k_slot_name ks
	|	KCUUnit ccu => context_compilation_unit_name ccu
);
=TEX
\subsection{Component Update Functions}
=SML
fun Ûpackage_vc_varsÝ (
	{vc_vars, consts_types, formal_procs, informal_funs ,
		formal_funs, aux_vars}
	: PACKAGE,
	new_vc_vars : VAR_DECL list) : PACKAGE = (
	{	vc_vars		=	new_vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs,
		aux_vars	=	aux_vars	}	
);
=TEX
=SML
fun Ûpackage_consts_typesÝ (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars}
	: PACKAGE,
	new_consts_types : BASIC_DECL list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	new_consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs,	
		aux_vars	=	aux_vars	}	
);
=TEX
=SML
fun Ûpackage_formal_procsÝ (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars}
	: PACKAGE,
	new_formal_procs : FORMAL_PROC list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	new_formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs,	
		aux_vars	=	aux_vars	}
);
=TEX
=SML
fun Ûpackage_informal_funsÝ (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars}
	: PACKAGE,
	new_informal_funs : INFORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	new_informal_funs,
		formal_funs	=	formal_funs,	
		aux_vars	=	aux_vars	}
);
=TEX
=SML
fun Ûpackage_formal_funsÝ (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	new_formal_funs,	
		aux_vars	=	aux_vars	}
);
=TEX
=SML
fun Ûpackage_aux_varsÝ (
	{vc_vars, consts_types, formal_procs, informal_funs,
		formal_funs, aux_vars}
	: PACKAGE,
	new_aux_vars : Z_DECL list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs,
		aux_vars	=	new_aux_vars	}	
);
=TEX
=SML
fun Ûsubunit_vc_varsÝ  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SUBUNIT,
	new_vc_vars : VAR_DECL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun Ûsubunit_formal_procsÝ  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SUBUNIT,
	new_formal_procs : FORMAL_PROC list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun Ûsubunit_dec_labelsÝ  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SUBUNIT,
	new_dec_labels : LABEL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}
	}
);
=TEX
=SML
fun Ûdeclab_declabel_flagÝ  (
	{	block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope
	} : DECLAB,
	new_declabel_flag : FLAG) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	{
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	new_declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag
		},
		in_scope	=	in_scope
	}
);
=TEX
=SML
fun Ûdeclab_vc_varsÝ  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : DECLAB,
	new_vc_vars : VAR_DECL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	new_vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			vc_aux_vars		=	vc_aux_vars,
			formal_procs		=	formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun Ûdeclab_formal_procsÝ  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : DECLAB,
	new_formal_procs : FORMAL_PROC list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			vc_aux_vars		=	vc_aux_vars,
			formal_procs		=	new_formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun Ûdeclab_dec_labelsÝ  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : DECLAB,
	new_dec_labels : LABEL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			vc_aux_vars		=	vc_aux_vars,
			formal_procs		=	formal_procs,
			dec_labels		=	new_dec_labels
		}
	}
);
=TEX
=SML
fun Ûspeclab_wÝ  (
	{spec as {w, w0, pre, post},
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope
	} : SPECLAB,
	new_w : Z_ID list) : SPECLAB = (
	{spec 			=	{w = new_w, w0 = w0, pre = pre,
						post = post},
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	in_scope
	}
);
=TEX
=SML
fun Ûspeclab_vc_varsÝ  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SPECLAB,
	new_vc_vars : VAR_DECL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun Ûspeclab_formal_procsÝ  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SPECLAB,
	new_formal_procs : FORMAL_PROC list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}

	}
);
=TEX
=SML
fun Ûspeclab_dec_labelsÝ  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons,
					vc_aux_vars, formal_procs, dec_labels}
	} : SPECLAB,
	new_dec_labels : LABEL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}

	}
);
=TEX
=SML
fun Ûblock_stub_flagÝ  (
	{
	declab as {block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_stub_flag : FLAG) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	new_stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag
				},
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_till_flagÝ  (
	{
	declab as {block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_till_flag : FLAG) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	new_till_flag
				},
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_vc_varsÝ  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_vc_vars : VAR_DECL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_vc_parsÝ  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_vc_pars : PARAM_SPEC list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	new_vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_vc_log_consÝ  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_vc_log_cons : Z_DECL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	new_vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_vc_aux_varsÝ  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_vc_aux_vars : Z_DECL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	new_vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_formal_procsÝ  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_formal_procs : FORMAL_PROC list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_current_formal_procÝ  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs} : BLOCK,
	new_current_formal_proc : FORMAL_PROC) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = new_current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_current_formal_funÝ  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs} : BLOCK,
	new_current_formal_fun : FORMAL_FUN) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = new_current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_tillÝ  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs} : BLOCK,
	new_till : Z_PRED) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = new_till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_using_decsÝ  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs} : BLOCK,
	new_using_decs : (Z_ID * (VAR_DECL list * Z_PRED)) list) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = new_using_decs
	}
);
=TEX
In the implementation, the following are useful additions to the component update functions defined in the Z spec.
=SML
fun Ûblock_flagsÝ  (
	{
	declab as {block_name,
		flags,
		in_scope},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_flags : FLAGS) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = new_flags,
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_spec_labÝ  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_spec_lab : LABEL) : BLOCK = (
	{declab		=	declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = new_spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_block_nameÝ  (
	{
	declab as {block_name,
		flags,
		in_scope},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_block_name : ID) : BLOCK = (
	{declab		=	{block_name = new_block_name,
				flags = flags,
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_in_scopeÝ  (
	{
	declab as {block_name,
		flags,
		in_scope},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_in_scope : IN_SCOPE) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = new_in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_dec_labelsÝ  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				vc_aux_vars, formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_dec_labels : LABEL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			vc_aux_vars	=	vc_aux_vars,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_current_for_varsÝ  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_current_for_vars : PARAM_SPEC list) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = new_current_for_vars,
	current_log_cons = current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX
=SML
fun Ûblock_current_log_consÝ  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	current_for_vars,
	current_log_cons,
	dec_lab,
	spec_lab,
	till,
	using_decs
	} : BLOCK,
	new_current_log_cons : Z_DECL list) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	current_for_vars = current_for_vars,
	current_log_cons = new_current_log_cons,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till,
	using_decs = using_decs
	}
);
=TEX

\subsection{Initial Values}

=TEX
=SML
val Ûpack_env0Ý : PACK_ENV = initial_s_dict;
val Ûsubunit_env0Ý : SUBUNIT_ENV = initial_s_dict;
val Ûdec_env0Ý : DEC_ENV = initial_s_dict;
val Ûspec_env0Ý : SPEC_ENV = initial_s_dict;
=TEX
$empty\_block$ is the initial value for a block, as loosely specified in \cite{ISS/HAT/DAZ/DTD513}.
Fields which are not specified there are given place-holder values.
All the flags are set false, for convenience in defining $env0$.
It is convenient to define some shared dummy values first:
=SML
val Ûdummy_specÝ : SPEC = {
		w 		= 	[],
		w0		=	[],
		pre		=	ZUserInterfaceSupport.ZTmTruth true,
		post		=	ZUserInterfaceSupport.ZTmTruth true};
val Ûdummy_informal_funÝ : INFORMAL_FUN = {
		name		=	"*dummy fun*",
		formal_pars	=	[],
		return_type	=	"*dummy type*"};
val Ûdummy_formal_funÝ : FORMAL_FUN = {
		informal_fun	=	dummy_informal_fun,
		spec		=	dummy_spec};
val Ûdummy_formal_procÝ : FORMAL_PROC = {
		name		=	"*dummy formal proc*",
		formal_ids	=	[],
		spec		=	dummy_spec};
val Ûempty_in_scopeÝ : IN_SCOPE = {
		vc_vars		=	[],
		vc_pars		=	[],
		vc_log_cons	=	[],
		vc_aux_vars	=	[],
		formal_procs	=	[],
		dec_labels	=	[]};
val Ûfalse_flagsÝ : FLAGS = {
		pack_spec_flag		=	false,
		pack_body_flag		=	false,
		stub_flag		=	false,
		subunit_flag		=	false,
		formal_body_flag	=	false,
		fun_flag		=	false,
		declabel_flag		=	false,
		speclabel_flag		=	false,
		till_flag		=	false};
val Ûdummy_declabÝ : DECLAB = {
		block_name	=	"*empty block*",
		flags		=	false_flags,
		in_scope	=	empty_in_scope};
=TEX
=SML
val Ûempty_blockÝ : BLOCK = 	{
	declab		=	dummy_declab,
	current_formal_proc = dummy_formal_proc,
	current_formal_fun = dummy_formal_fun,
	current_for_vars = [],
	current_log_cons = [],
	dec_lab = "",
	spec_lab = "",
	till = mk_z_true,
	using_decs = []
};
=TEX
Now we can define $env0$, exploiting the fact that all the flags are set to $false$ in $empty\_block$.
=SML
val Ûenv0Ý : ENV = [empty_block];
=TEX
We also require initial values for the SPARK program and replacement environments discussed in \cite{ISS/HAT/DAZ/DTD513}
=SML
val Ûrepl_env0Ý : REPL_ENV = initial_s_dict;
val Ûspark_prog0Ý : SPARK_PROG = [];
=TEX
For uniformity, we give the initial value for the theory name component of the global state here.
We use the string ``-'' which by convention in {\Product} means the current theory.
=SML
val Ûscript_name0Ý : string = "-";
=TEX
\subsection{$flatten\_env$}
To implement $flatten\_env$, we first need a function to merge two $IN\_SCOPE$s.
=SML
fun Ûmerge_in_scopesÝ
	({	vc_vars = vc_vars1,
		vc_pars = vc_pars1,
		vc_log_cons = vc_log_cons1,
		vc_aux_vars = vc_aux_vars1,
		formal_procs = formal_procs1,
		dec_labels = dec_labels1} : IN_SCOPE)
	({	vc_vars = vc_vars2,
		vc_pars = vc_pars2,
		vc_log_cons = vc_log_cons2,
		vc_aux_vars = vc_aux_vars2,
		formal_procs = formal_procs2,
		dec_labels = dec_labels2} : IN_SCOPE) : IN_SCOPE = (
	{	vc_vars = vc_vars1 @ vc_vars2,
		vc_pars = vc_pars1 @ vc_pars2,
		vc_log_cons = vc_log_cons1 @ vc_log_cons2,
		vc_aux_vars = vc_aux_vars1 @ vc_aux_vars2,
		formal_procs = formal_procs1 @ formal_procs2,
		dec_labels = dec_labels1 @dec_labels2}
);
=TEX
Now we define $flatten\_env$, which uses $merge\_in\_scopes$ to merge all the $in\_scope$ components of the blocks in a running environment.
To avoid unnecessary merging with the empty $in\_scope$ value, the case of a singleton list in the environment is treated separately (the function would compute the same value if the second clause were omitted but would be less efficient with space).

=SML
fun Ûflatten_envÝ ([] : ENV) : IN_SCOPE = (
	empty_in_scope
) |  flatten_env [blk] = (
	#in_scope(#declab blk)
) |  flatten_env (blk :: blks) = (
	merge_in_scopes (#in_scope(#declab blk)) (flatten_env blks)
);
=TEX
\subsection{The Global State}
For convenience in the implementation, the eight components of the state are held in eight assignable variables.
=SML
val Ûpack_envÝ : PACK_ENV ref = ref pack_env0;
val Ûsubunit_envÝ : SUBUNIT_ENV ref = ref subunit_env0;
val Ûdec_envÝ : DEC_ENV ref = ref dec_env0;
val Ûspec_envÝ : SPEC_ENV ref = ref spec_env0;
val ÛblocksÝ : ENV ref = ref env0;
val Ûrepl_envÝ : REPL_ENV ref = ref repl_env0;
val Ûspark_progÝ : SPARK_PROG ref = ref spark_prog0;
val Ûscript_nameÝ : string ref = ref script_name0;
=TEX
The global state may be set from a given value of type $CN\_STATE$ using the following function:
=SML
fun Ûset_cn_stateÝ ({
		pack_env = new_pack_env,
		subunit_env = new_subunit_env,
		dec_env = new_dec_env,
		spec_env = new_spec_env,
		blocks = new_blocks,
		repl_env = new_repl_env,
		spark_prog = new_spark_prog,
		script_name = new_script_name
	} : CN_STATE) : unit = (
		pack_env := new_pack_env;
		subunit_env := new_subunit_env;
		dec_env := new_dec_env;
		spec_env := new_spec_env;
		blocks := new_blocks;
		repl_env := new_repl_env;
		spark_prog := new_spark_prog;
		script_name := new_script_name
);
=TEX
=SML
fun Ûget_cn_stateÝ (() : unit) : CN_STATE = (
		{pack_env = !pack_env,
		subunit_env = !subunit_env,
		dec_env = !dec_env,
		spec_env = !spec_env,
		blocks = !blocks,
		repl_env = !repl_env,
		spark_prog = !spark_prog,
		script_name = !script_name}
);
=TEX
\subsection{Accessing the Running Environment}
The function $block$ below implements the 1-based indexing of the running environment which is such a common feature of te Z spec.
=SML
fun ÛblockÝ (index : int) : BLOCK = (
	(nth (index - 1) (!blocks))
	handle Fail _ => error "test_flag" 507006 []
); 
=TEX
The following function is convenient for accessing the flags in the running environment.
The first parameter is the functions to extract the flag value: it will always be one of the ML built-in selection functions, $\#pack\_spec\_flag$ etc.
The second parameter gives the block to get the flag from: with $1$ identifying the topmost block.
=SML
fun Ûtest_flagÝ (selector : FLAGS -> bool) (index : int) : bool = (
	(selector o #flags o #declab o block) index
);
=TEX
The specification does not specify the block name to be used in the bottom block in the running environment.
It is convenient to use this to tell the code which stores VCs the name of the current web clause.
The following two functions assist in this.
=SML
fun Ûset_bottom_block_nameÝ (n : ID) : unit = (
	let	fun aux [] = [block_block_name(empty_block, n)]
		|   aux [blk] = [block_block_name(blk, n)]
		|   aux (blk :: more) = blk :: aux more;
	in	blocks := aux (!blocks)
	end
);
fun Ûget_bottom_block_nameÝ (() : unit) : ID = (
	let	fun aux [] = ""
		|   aux [blk :BLOCK] = #block_name(#declab blk)
		|   aux (blk :: more) = aux more;
	in	aux (!blocks)
	end
);
=TEX
\subsection{Function Parameter Lists}
When the global variable representing a SPARK function is stored in a theory, a user data entry giving its formal parameter list is also stored.
This is later accessed via the $CN\_ENV$ when function calls using named parameter associations are translated into Z.

The following function is used here and elsewhere to find the HOL name corresponding to a Z one.
=SML
fun Ûz_id_of_idÝ (n : ID) : Z_ID = (
	(fst o dest_const o mk_z_gvar)(n, BOOL, [])
);
=TEX
=SML
local
val Ûcn_pars_ud_keyÝ = "CN'formal_pars";
fun Ûdest_ud_stringÝ (UD_String (n, uds)) = (n, uds)
|   dest_ud_string _ = fail "" 0 [] (* always caught below *);
fun ÛwantedÝ (fun_name : ID) (UD_String (i, _)) = (i = fun_name)
|   wanted _ _ = false;
fun Ûfun_name_par_namesÝ ({name, formal_pars, ...} : INFORMAL_FUN)
	: ID * ID list= (
	(name, (flat o map (#vars o #var_decl)) formal_pars)
);
in
fun Ûget_par_namesÝ (fun_name : Z_ID) : ID list OPT = (
	((Value o map (fst o dest_ud_string) o snd o dest_ud_string o
		switch find (wanted fun_name) o snd o dest_ud_string o
		get_user_datum (get_const_theory (z_id_of_id fun_name)))
	cn_pars_ud_key)
	handle Fail _ => Nil
);
fun Ûset_par_namesÝ (inf_fun : INFORMAL_FUN) : unit = (
	let	val (fun_name, pars) = fun_name_par_names inf_fun;
		val old = (snd o dest_ud_string o get_user_datum "-") cn_pars_ud_key
			handle Fail _ => [];
		val new = 
			UD_String(fun_name, map (fn p => UD_String(p, [])) pars)
			:: (old drop wanted fun_name);
	in	set_user_datum(cn_pars_ud_key, UD_String("", new))
	end
);
end;
=TEX
\subsection{Classifying Type Marks}
When a basic declaration causes a Z global variable to be defined,
we may later need to know whether the Z global variable corresponds to
a SPARK type or a SPARK constant.
To do this a list of the names from the SPARK type declaration is maintained in the theory.
=TEX
=SML
local
val Ûcn_types_ud_keyÝ = "CN'types";
fun Ûdest_ud_stringÝ (UD_String (n, uds)) = (n, uds)
|   dest_ud_string _ = fail "" 0 [] (* always caught below *);
in
fun Ûget_type_namesÝ (thy : string) : ID list = (
	((map (fst o dest_ud_string) o snd o dest_ud_string o get_user_datum thy)
	cn_types_ud_key)
	handle Fail _ => []
);
fun Ûadd_type_nameÝ (tyn : ID) : unit = (
	let	val old = (snd o dest_ud_string o get_user_datum "-")
				 cn_types_ud_key
			handle Fail _ => [];
		val new = UD_String(tyn, []) :: old;
	in	set_user_datum(cn_types_ud_key, UD_String("", new))
	end
);
fun Ûis_type_nameÝ (n : ID) : bool = (
	(n mem get_type_names (get_const_theory (z_id_of_id n)))
	handle Fail _ => false
);
fun Ûset_basic_decl_infoÝ (bd : BASIC_DECL) : unit = (
	case bd of
		BDTypeDecl td => add_type_name (#name td)
	|	BDSubtypeDecl std => add_type_name (#name std)
	|	BDPrivateTypeDecl ptd => add_type_name (#id ptd)
	|	_ => ()
);
end;
=TEX
\subsection{Constructing $CN\_ENV$s}
The code here must pass type information into the functions defined in \cite{ISS/HAT/DAZ/DTD505,ISS/HAT/DAZ/DTD508} using the data type $CN\_ENV$ defined in \cite{ISS/HAT/DAZ/DTD508}.
This happens when declarations are translated for output to the Z document and when VCs are generated;
in the first case, the $CN\_ENV$ value required is taken from the running environment, in the second from the $In\_Scope$ part of the $Speclab$ which is the first part of the arguments to $vcs$.
In either case, Z global variables are sought from the theory data base if there is no local declaration for them.

\subsection{\ldots for declarations}
$get\_tmark\_from\_inscope$ searches an $IN\_SCOPE$ value for the type mark associated with a variable or parameter name:
=SML
fun Ûget_tmark_from_inscopeÝ (n : Z_ID) (inscope : IN_SCOPE) : TMARK OPT = (
	let	fun do_vars [] = Nil
		|   do_vars ({vars, tmark} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_vars more
		);
		fun do_pars [] = Nil
		|   do_pars ({var_decl as {vars, tmark}, mode} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_pars more
		);
	in	case do_vars (#vc_vars inscope) of
			Nil		=> do_pars (#vc_pars inscope)
		|	value_tmark	=> value_tmark
	end
);
=TEX
Now $get\_tmark\_from\_env$, which searches the running environment using the previous function to look for the required type mark.
=SML
fun Ûget_tmark_from_envÝ (_ : Z_ID) ([] : ENV) : TMARK OPT = (
	Nil
) | Ûget_tmark_from_envÝ (n : Z_ID) (block :: more) : TMARK OPT = (
	case get_tmark_from_inscope n (#in_scope (#declab block)) of
			Nil		=> get_tmark_from_env n more
		|	value_tmark	=> value_tmark
);
=TEX
Now, if we find a type mark, we need to convert it to an HOL type.
This is done by looking in the theory database.
The type there for a type $\tau$ will be $ð\tau$.
We must strip off the ð.
=SML
fun Ûtype_of_tmarkÝ (tmark : TMARK) : TYPE OPT = (
	(case (get_const_type (z_id_of_id tmark)) of
		Value ty => (Value (dest_z_power_type ty))
	|	Nil => Nil)
	handle Fail _ => Nil
);
=TEX
If we don't find a type mark, then the only possibility is that the name is that of a SPARK function, constant or type stored as a global variable in the theory database.
In this case the stored type is correct as it stands (no ð to take away).
=SML
fun Ûtype_of_g_varÝ (zn : Z_ID) : TYPE OPT = (
	(case get_const_type zn of
		Value ty => (Value ty)
	|	Nil => Nil)
);
=TEX
If we have the a global variable, then we need to classify it as a function, or record type type mark or other sort of SPARK entity.
for a function, we also need the formal parameter list.
To make this classification, we first check to see whether any formal parameters have been associated with the name:
if so, then it's a function and we have the parameter names to hand;
if it's not a function but is a type name, we dismantle the type: if its a set of bindings, then this is a record type mark; otherwise it's an `other type';
if it's neither a function nor a type name, its an `other'.


(TBS - Pending updates to the rest of the code, we forge the constructor
for `other types').
=SML
fun Ûenv_info_of_g_varÝ (zn : ID) (ty : TYPE) = (
	case get_par_names zn of
		Value pars => (ty, EIEnvFunction pars)
	|	Nil => (
			ty,
			if is_type_name zn
			then	(dest_z_schema_type (dest_z_power_type ty);
				EIEnvRecordType)
				handle Fail _ => EIEnvOtherType
			else	EIEnvOther
	)
);
=TEX
=SML
fun Ûcurrent_cn_envÝ (n : ID) : (TYPE * ENV_INFO) OPT = (
	case get_tmark_from_env n (!blocks) of
		Value tmark => (
			case type_of_tmark tmark of
				Value ty => Value (ty, EIEnvVar tmark)
			|	Nil => Nil
	) | 	Nil => (
			case type_of_g_var (z_id_of_id n) of
				Value ty => Value(env_info_of_g_var n ty)
			|	Nil => Nil
	)
);
=TEX
\subsection{\ldots for VC generation}
=SML
fun Ûcn_env_of_in_scopeÝ (in_scope : IN_SCOPE) (n : Z_ID)
	: (TYPE * ENV_INFO) OPT = (
	case get_tmark_from_inscope n in_scope of
		Value tmark => (
			case type_of_tmark tmark of
				Value ty => Value (ty, EIEnvVar tmark)
			|	Nil => Nil
		)
	|	Nil => (
			case type_of_g_var (z_id_of_id n) of
				Value ty => Value(env_info_of_g_var n ty)
			|	Nil => Nil
	)
);
=TEX
\subsection{ProofPower Type Inference Context}
=TEX
=SML
fun Ûti_context_of_in_scopeÝ (inscope : IN_SCOPE) : TERM list = (
	let	fun v_v0 (in_mode : bool) (ty : TYPE) (v : ID) : TERM list = (
			if	in_mode
			then	[mk_var(v, ty)]
			else	[mk_var(v ^ "‰0", ty), mk_var(v, ty)]
		);
		fun do_vars [] = []
		|   do_vars ({vars, tmark} :: more) = (
			case type_of_tmark tmark of
				Nil => do_vars more
			|	Value ty => (
				flat
				(do_vars more :: map (v_v0 true ty) vars)
			)
		);
		fun do_pars [] = []
		|   do_pars ({var_decl as {vars, tmark}, mode} :: more) = (
			case type_of_tmark tmark of
				Nil => do_pars more
			|	Value ty => (
				flat
				(do_pars more :: map (v_v0 false ty) vars)
			)
		);
		fun do_log_cons (log_cons : Z_DECL list) = (
			(flat o map (fst o dest_z_dec)) log_cons
		);
		val {vc_log_cons, vc_pars, vc_vars, ...} = inscope;
	in	do_log_cons vc_log_cons @ do_pars vc_pars @ do_vars vc_vars
	end
);
=TEX
=SML
fun Ûcurrent_ti_contextÝ (() : unit) : TERM list = (
	flat (map (ti_context_of_in_scope o #in_scope o #declab) (!blocks))
);
=TEX
\subsection{Updating the Z Theory Database}
=SML
fun Ûstore_vc_termÝ (label : LABEL) (tm : TERM) : unit = (
	let	val bbn = get_bottom_block_name ();
		val vc_lab =	if 	bbn = "" orelse bbn = label
				then	"VC_" ^ label ^ "__"
				else	"VC_" ^ bbn ^ "__" ^ label ^ "_";
		fun aux i = (
			let val vc_name = vc_lab ^ string_of_int i;
			in	if (get_conjecture "-" vc_name; false)
						handle Fail _ => true
				then	(new_conjecture ([vc_name], tm); ())
				else	aux (i + 1)
			end
		);
	in	aux 1
	end
);
=TEX
=SML
fun Ûterm_of_vcÝ (vc as (decs, (asms, conc)) : VC) : TERM = (
	case (decs, asms) of
		([], []) =>	conc
	|	([], _) => 	mk_z_´ (list_mk_± asms, conc)
	|	(_, []) =>	mk_z_µ(mk_z_decl decs, mk_z_true, conc)
	|	(_, _) =>	mk_z_µ(mk_z_decl decs, list_mk_± asms, conc)
);
=TEX
=SML
fun Ûstore_vcsÝ (label : LABEL, vcs: VC list) : unit = (
	map ((store_vc_term label) o term_of_vc) vcs;
	()
);
=TEX
\subsection{Creating ProofPower Theories}
The material in this section uses the following function, which is also required for the DRA specs.
=SML
infix dot;
fun (x : ID) ÛdotÝ (y : ID) = x ^ "." ^ y;
=TEX
See \cite{ISS/HAT/DAZ/HLD501} for further information on the reasons for having the following functions which are invoked when compilation units are processed and when a new script is started.
=SML
fun Ûnew_script_theoryÝ (name : string) : unit = (
	let	val thy = (trans_id name) ^ "__SCRIPT";
	in	new_theory thy
	end
);
=TEX
The following needs no error handling --- it is only called when the theory is known to exist already.
=SML
fun Ûpack_spec_nameÝ (name : string) : string = (
	(trans_id name) ^ "__SPEC"
);
=TEX
=SML
fun Ûpack_tmpbody_nameÝ (name : string) : string = (
	(trans_id name) ^ "__TMPBODY"
);
=TEX
=SML
fun Ûnew_package_spec_theoryÝ (name : string) : unit = (
	let	val thy = pack_spec_name name;
	in	new_theory thy
		handle Fail _ =>
		fail "new_package_spec_theory" 507023 [fn()=>thy, fn()=>name]
	end
);
=TEX
=SML
fun Ûopen_package_spec_theoryÝ (name : string) : unit = (
	let	val thy = pack_spec_name name;
	in	open_theory thy
	end
);
=TEX
=SML
fun Ûnew_package_tmpbody_theoryÝ (name : string) : unit = (
	let	val thy = pack_tmpbody_name name;
	in	new_theory thy
		handle Fail _ =>
		fail "new_package_tmpbody_theory" 507024 [fn()=>thy, fn()=>name]
	end
);
=TEX
=SML
fun Ûopen_package_tmpbody_theoryÝ (name : string) : unit = (
	let	val thy = pack_tmpbody_name name;
	in	open_theory thy
		handle Fail _ => 
		fail "open_package_tmpbody_theory" 507028 [fn()=>thy, fn()=>name]
	end
);
=TEX
=SML
fun Ûnew_body_stub_theoryÝ (unit_name : string, subunit_name : string) : unit = (
	let	val su_name = unit_name dot subunit_name;
		val thy = trans_id (su_name ^ "__STUB");
	in	duplicate_theory ("-", thy)
		handle Fail _ =>
		fail "new_body_stub_theory" 507026 [fn()=>thy, fn()=>su_name]
	end
);
=TEX
=SML
fun Ûopen_subunit_theoryÝ (unit_name : string, x : PROPER_BODY) : unit = (
	let	val subunit_name =(case x of
			PBProcedure {procedure_spec as {name, ...}, ...} => (
				name
		) |	PBFunction {function_spec as {designator, ...}, ...} => (
				designator
		) |	PBPackage {name, ...} => (
				name
		));
		val su_name = unit_name dot subunit_name;
		val thy = trans_id (su_name ^ "__STUB");
	in	open_theory thy
		handle Fail _ => 
		fail "open_subunit_theory" 507027 [fn()=>thy, fn()=>su_name]
	end
);
=TEX
\subsection{Diagnostic Aids}
=SML
val Ûdiag_cn_stateÝ : CN_STATE ref = ref (get_cn_state());
val Ûdiag_web_clauseÝ : WEB_CLAUSE ref = ref (WCCompilation []);
val Ûdiag_vc_argsÝ : (SPECLAB * STATEMENT) list ref = ref [];
=TEX
\subsection{Interface to VC Generator}
=TEX
=SML
fun Ûadd_init_vars_specÝ ({w, pre, post, w0} : SPEC) : SPEC = (
	{w = w,
	pre = pre,
	post = post,
	w0 = map (fn s => s ^ "‰0") w} 
);
=TEX
=SML
fun Ûadd_init_vars_speclabÝ ({spec, wp_env, fun_flag, in_scope,
	till_flag, formal_body_flag} : SPECLAB) : SPECLAB = (
	{spec = add_init_vars_spec spec,
	wp_env = wp_env,
	fun_flag = fun_flag,
	in_scope = in_scope,
	till_flag = till_flag,
	formal_body_flag = formal_body_flag}
);
=TEX
=SML
fun Ûadd_formal_procs_wp_envÝ
	({spec, formal_body_flag, fun_flag, till_flag,
		wp_env as {fun_header, env, return, till, formal_procs},
		in_scope} : SPECLAB) : SPECLAB = (
	{spec = spec,
	formal_body_flag = formal_body_flag,
	fun_flag = fun_flag,
	till_flag = till_flag,
	wp_env = {	fun_header = fun_header,
			env = env,
			return = return,
			till = till,
			formal_procs = #formal_procs in_scope},
	in_scope = in_scope}
);
=TEX
=SML
fun Ûcall_vcsÝ ((sl, st) : SPECLAB * STATEMENT) : VC list = (
	let	val sl1 = add_init_vars_speclab sl;
		val sl1_st = (add_formal_procs_wp_env sl1, st);
	in	diag_vc_args := sl1_st :: !diag_vc_args;
		TypeInference.set_ti_context
			(ti_context_of_in_scope (#in_scope sl));
		vcs sl1_st
	end
);
=TEX
\section{BASIC DECLARATIONS}\label{BASICDECLARATIONS}
\subsection{The SID Function basic\_declaration}
The decision about which function to call is made in $basic\_declaration$ itself.
=SML
fun Ûbasic_decl_pack_specÝ (basic_decl : BASIC_DECL) : unit = (
	let	val block_name1 = #block_name(#declab (block 1));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "basic_decl_pack_spec" 507001 [];
	in	pack_env :=
		s_enter
		block_name1
		(package_consts_types(package,
				#consts_types package @ [basic_decl]))
		(!pack_env)
	end
);
=TEX
=SML
fun Ûbasic_decl_otherwiseÝ (basic_decl : BASIC_DECL) : unit = (
	let	val side = TypeInference.set_ti_context (current_ti_context ());
		val para_info_opt = trans_basic_decl1 current_cn_env basic_decl;
	in
		case para_info_opt of
			Value para_infos => (
				map update_theory_db_with_parainfo para_infos;
				set_basic_decl_info basic_decl
		)|	Nil =>	fail "basic_decl_otherwise" 507041 []
	end
);
=TEX	
=SML
fun Ûbasic_declarationÝ (basic_decl : BASIC_DECL) : unit = (
	if	test_flag #pack_spec_flag 1
	then	basic_decl_pack_spec basic_decl
	else	basic_decl_otherwise basic_decl
);
=TEX
=SML
fun Ûvar_pack_specÝ (var_decl : VAR_DECL) : unit = (
	if	test_flag #pack_spec_flag 1
	then	let	val block_name1 = #block_name(#declab (block 1));
			val package = case (s_lookup block_name1 (!pack_env)) of
				Value p => p
			|	Nil => error "var_pack_spec" 507001 [];
		in	pack_env :=
			s_enter
			block_name1
			(package_vc_vars(package,
					#vc_vars package @ [var_decl]))
			(!pack_env);
(* **** **** Commented out comment:
	(* TBS *)		comment "var_pack_spec: " 503001
				[fn()=>"pack_spec_flag is set"];()
*)				()
		end
	else
(* **** **** Commented out comment:
	(* TBS *)		comment "var_pack_spec: " 503001
				[fn()=>"pack_spec_flag not set"];
*)				()
);
=TEX
\subsection{The SID Function update\_envs\_var}
The decision making as to whether to call the three support functions is done in $update\_envs\_var$ itself (since it is the same test in each case).

In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun Ûupdate_subunit_env_varÝ (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab1 mem dec_labels
			then	(id1_id2,
				subunit_vc_vars(s, vc_vars grab var_decl))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun Ûupdate_dec_env_varÝ (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_dec_label
			(dec_label_s as
				(dec_label,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(dec_label,
				declab_vc_vars(s, vc_vars grab var_decl))
			else	dec_label_s
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
The identifiers in the variable declaration are translated first.
=SML
fun Ûupdate_spec_env_varÝ (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		val trans_vars = map trans_id (#vars var_decl);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(spec_label,
				speclab_w(
					speclab_vc_vars(s, vc_vars grab var_decl),
					trans_vars cup w))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun Ûupdate_envs_varÝ (var_decl : VAR_DECL) : unit = (
	if	test_flag #declabel_flag 1
	then	(update_subunit_env_var var_decl;
		update_dec_env_var var_decl;	
		update_spec_env_var var_decl)
	else	()
);
=TEX
=IGN
val d1 = cn_basic_decl_of_string "x : constant Integer := 42;";
val d2 = cn_basic_decl_of_string "x : constant Integer;";
val d3 = cn_basic_decl_of_string "type zed is range 0 .. 20;";
val d4 = cn_basic_decl_of_string "y : Integer;";
val d5 = cn_basic_decl_of_string "type why is private;";
trans_basic_decl env d5;
=TEX
\subsection{The SID Function add\_var\_env}
=SML
fun Ûadd_var_envÝ (var_decl : VAR_DECL) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "add_var_env" 507006 [];
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
	in	blocks :=
		block_vc_vars(block1, vc_vars1 grab var_decl):: tl (!blocks)
	end
);
=TEX
\section{DECLARATIONS}\label{DECLARATIONS}
In the following, $block2$ is bound first to catch possible errors with a corrupt environment.

The following function accomodates change request ??.
=SML
fun Ûk_slot_decÝ (label : LABEL) : unit = (
	let	val block2 = block 2
			handle Fail _ => error "k_slot_dec" 507006 [];
		val block1 = block 1;
		val subunit_flag2 = test_flag #subunit_flag 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val declab = {
			block_name 	=	if	subunit_flag2
						then	block_name2 dot block_name1
						else	block_name1,
			flags		=	#flags(#declab block1),
			in_scope	= 	flatten_env (!blocks)			
		};
		val dec_labels1 = #dec_labels (#in_scope (#declab block1));
	in	(dec_env := s_extend label declab (!dec_env)
		handle Fail _ => fail "k_slot_dec" 507010 [fn () => label];
		blocks :=
			block_dec_labels (block1, dec_labels1 grab label)
								:: tl (!blocks)
		)
	end
);
=TEX
\section{STATEMENTS}\label{STATEMENTS}
\subsection{The SID function spec\_stmt}
The decision about which support function to call is made in $spec\_stmt$ itself.
=SML
fun Ûspec_stmt_speclabelÝ ({spec : SPEC, label : LABEL}) : unit = (
	let	val block1 = block 1;
		val spec_lab1 = #spec_lab block1;
		val speclab2 = force_value(s_lookup spec_lab1 (!spec_env))
			handle Fail _ =>
			fail "spec_stmt_speclabel" 507014 [fn ()=> spec_lab1];
		val {formal_body_flag, fun_flag,
			wp_env as {fun_header, return, ...}, 
			in_scope as {
				vc_vars = vc_vars2,
				vc_pars = vc_pars2,
				vc_log_cons = vc_log_cons2,
				vc_aux_vars = vc_aux_vars2,
				dec_labels = dec_labels2,
				formal_procs = formal_procs2}, ...} = speclab2;
		val till = #till block1;
		val till_flag = #till_flag (#flags (#declab block1));
		val env_pars = #vc_pars (flatten_env(!blocks));
		val vc_pars = vc_pars2 @ env_pars;
		val vc_log_cons1 = #vc_log_cons(#in_scope(#declab block1));
		val vc_log_cons = vc_log_cons2 @ vc_log_cons1;
		val in_scope1 : IN_SCOPE = {
			dec_labels = dec_labels2,
			formal_procs = formal_procs2,
			vc_log_cons = vc_log_cons,
			vc_aux_vars = vc_aux_vars2,
			vc_vars = vc_vars2,
			vc_pars = vc_pars			
		};
		val wp_env1 :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = till,
			return = return,
			fun_header = fun_header,
			formal_procs = formal_procs2
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1			
		};
		val side = TypeInference.set_ti_context
					(ti_context_of_in_scope in_scope1);
	in	spec_env := s_extend label speclab (!spec_env)
		handle Fail _ =>
		fail "spec_stmt_speclabel" 507015 [fn ()=> label]
	end
);
=TEX
=SML
fun Ûspec_stmt_otherwiseÝ ({spec : SPEC, label : LABEL}) : unit = (
	let	val block1 = block 1;
		val {declab as {flags =
			{formal_body_flag,
			fun_flag,
			till_flag, ...}, ...},
			till,
			current_formal_fun = formal_fun1 as
					{informal_fun = fun_header,
					spec = spec1 as {post = return, ...}},
			...} = block1;
		val in_scope1 : IN_SCOPE = flatten_env(!blocks);
		val wp_env1 :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = till,
			return = z_predexp_of_z_tm return,
			fun_header = fun_header,
			formal_procs = []
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1			
		}; 
	in	spec_env := s_extend label speclab (!spec_env)
		handle Fail _ =>
		fail "spec_stmt_otherwise" 507015 [fn ()=> label]
	end
);
=TEX
=SML
fun Ûspec_stmtÝ (specstmt as {spec : SPEC, label : LABEL}) : unit = (
	(if	test_flag #speclabel_flag 1
	then	spec_stmt_speclabel
	else	spec_stmt_otherwise) specstmt
);
=TEX
\subsection{The SID function k\_slot\_stmt}
=SML
fun Ûk_slot_stmtÝ (label : LABEL) : unit = (
	spec_stmt {	spec=
			{w = [], w0 = [], pre = z_tm_true, post = z_tm_true},
			label = label}
);
=TEX
\subsection{The SID function add\_log\_con\_env}
=SML
fun Ûadd_log_con_envÝ (logical_con as {x, t, ...}: LOG_CON) : unit = (
	let	val block1 = block 1;
		val zt = z_predexp_of_z_tm t;
		val zvar = mk_z_lvar(x, (dest_z_power_type o type_of) zt, []);
		val zdecl = mk_z_dec([zvar], zt);
		val current_log_cons1 = #current_log_cons block1;
	in	blocks := block_current_log_cons (
					block_vc_log_cons(block1, [zdecl]),
					zdecl :: current_log_cons1)
				 :: tl (!blocks)
	end
);
=TEX
\subsection{The SID function remove\_log\_con\_env}
=SML
fun Ûremove_log_con_envÝ (() : unit) : unit = (
	let	val block1 = block 1;
	in	blocks := block_vc_log_cons(block1, []) :: tl (!blocks)
	end
);
=TEX
\section{LOOPS}\label{LOOPS}
\subsection{The SID function new\_scope\_loop}
=SML
fun Ûnew_scope_loopÝ (() : unit) : unit = (
	let	val block1 = block 1;
		val {declab as {flags as 
			{fun_flag, formal_body_flag, speclabel_flag, ...},
			in_scope, ...},
			current_formal_proc,
			current_formal_fun,
			current_for_vars,
			current_log_cons,
			dec_lab,
			spec_lab,
			till,
			using_decs}
				= block 1;
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			declabel_flag = false,
			speclabel_flag = speclabel_flag,
			till_flag = false
		};
		val block = {
			declab	= {
				block_name = "",
				flags = flags,
				in_scope = in_scope},
			current_formal_proc = current_formal_proc,
			current_formal_fun = current_formal_fun,
			current_for_vars = current_for_vars,
			current_log_cons = current_log_cons,
			dec_lab = dec_lab,
			spec_lab = spec_lab,
			till = till,
			using_decs = using_decs
	}

	in	blocks := block :: !blocks
	end		
);
=TEX

\subsection{The SID function end\_scope}
=SML
fun Ûend_scopeÝ (():unit) : unit = (
	(blocks := tl (! blocks))
	handle Fail _ => error "end_scope" 507006 []
);
=TEX
\subsection{The SID function for\_param}
=SML
fun Ûfor_paramÝ (i : ID) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val param_spec = {	mode = MSparkIn,
					var_decl = {vars = [i], tmark = "INTEGER"}};
		val for_vars = #current_for_vars block2;
	in	blocks := block_vc_pars (block1, [param_spec])
				:: block_current_for_vars
					(block2, for_vars grab param_spec)
				:: (tl o tl) (!blocks)
	end
);
=TEX
\subsection{The SID function till\_pred}
=SML
fun Ûtill_predÝ (t : Z_TM) : unit = (
	let	val block1 = block 1;
		val till = z_predexp_of_z_tm t;
	in	blocks := block_till (block_till_flag(block1, true), till)
		:: !blocks
	end
);
=TEX
\section{SUBPROGRAM DECLARATIONS}\label{SUBPROGRAMDECLARATIONS}
The SID function $end\_scope$ used in processing these has already been defined in section \ref{LOOPS}.
\section{PROCEDURES}\label{PROCEDURES}
\subsection{The SID function subunit\_form}
This SID function and the next are best handled by a common function with a parameter to determine what to do:
=SML
fun Ûsubunit_form_infÝ (ident : ID, is_inf : bool) : unit = (
	if	test_flag #subunit_flag 1
	then	let	val block = hd(!blocks);
			val block_name = #block_name(#declab block);
			val bn_id = block_name dot ident;
			val subunit1 = (force_value(s_lookup bn_id (!subunit_env)))
				handle Fail _ =>
				error "subunit_form_inf" 507011 [fn()=>bn_id];
			val in_scope' = #in_scope subunit1;
			val block' = block_in_scope(block, in_scope');
		in	blocks := block' :: tl (!blocks);
			if	is_inf
			then	subunit_env := s_delete bn_id (!subunit_env)
			else	()
		end
	else	()
);
=TEX
=SML
fun Ûsubunit_formÝ (ident : ID) : unit = (
	subunit_form_inf (ident, false)
);
=TEX
\subsection{The SID function subunit\_inf}
=SML
fun Ûsubunit_infÝ (ident : ID) : unit = (
	subunit_form_inf (ident, true)
);
=TEX
\subsection{The SID function new\_scope\_proc\_inf}
=SML
fun Ûnew_scope_proc_infÝ (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_proc\_inf}
=SML
fun Ûnew_scope_proc_formÝ (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = true,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_fun\_inf}
In the following the call to the {\Product} function $duplicate\_theory$ creates a new theory which is a copy of the current theory.
This corresponds to $make\_module$ as used in the Z spec.
=SML
fun ÛstubÝ (() : unit) : unit = (
	if	test_flag #stub_flag 2
	then	let	val block1 = block 1;
			val block2 = block 2;
			val block3 = block 3;
			val block_name1 = #block_name (#declab block1);
			val block_name2 = #block_name (#declab block2);
			val block_name3 = #block_name (#declab block3);
			val id2 = block_name1;
			val id1 =
				if	test_flag #subunit_flag 3
				then	block_name3 dot block_name2
				else	block_name2;
			val id1_id2 = id1 dot id2;
			val subunit = {
				in_scope	=	flatten_env(!blocks),
				specif		=	dummy_spec,
				specif_flag	=	false,			
				zmod		=	id1_id2
			};
		in	new_body_stub_theory(id1, id2)
			handle Fail _ => fail "stub" 507013 [fn() => id1_id2];
			subunit_env := s_enter id1_id2 subunit (!subunit_env)
		end
	else	()
);
=TEX
The following does the main work for $stub\_spec\_proc$ and $stub\_spec\_fun$.
=SML
fun Ûstub_spec_proc_funÝ (spec : SPEC) : unit = (
	if	test_flag #stub_flag 2
	then	let	val block1 = block 1;
			val block2 = block 2;
			val block3 = block 3;
			val block_name1 = #block_name (#declab block1);
			val block_name2 = #block_name (#declab block2);
			val block_name3 = #block_name (#declab block3);
			val id2 = block_name1;
			val id1 =
				if	test_flag #subunit_flag 3
				then	block_name3 dot block_name2
				else	block_name2;
			val id1_id2 = id1 dot id2;
			val subunit = force_value(s_lookup id1_id2 (!subunit_env))
				handle Fail _ =>
				error "stub_spec_proc_fun" 507011 [fn()=>id1_id2];
			val subunit' = {
				in_scope	=	#in_scope subunit,
				specif		=	spec,
				specif_flag	=	true,			
				zmod		=	#zmod subunit
			};
		in	subunit_env := s_enter id1_id2 subunit' (!subunit_env)
		end
	else	()
);
=TEX
=SML
fun Ûstub_spec_procÝ (form_proc : FORMAL_PROC) : unit = (
	stub_spec_proc_fun (#spec form_proc)
);
=TEX
\subsection{The SID function form\_proc}
=SML
fun Ûform_proc_pack_specÝ (form_proc: FORMAL_PROC) : unit = (
	let	val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_proc_pack_spec" 507012 [fn()=>block_name2];
		val formal_procs = #formal_procs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_formal_procs(package,
				formal_procs @ [form_proc]))
		(!pack_env)
	end
);
=TEX
=TEX
The VC generator is responsible for distinguishing specification between statements with and without initial variables.
Here, we follow the parser in generating the form without initial variables for it to modify as necessary.
=SML
fun Ûform_proc_pack_body_commonÝ (form_proc: FORMAL_PROC)
		= (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val package4 = (force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_proc_pack_body_common" 507012
					[fn()=>block_name2];
		val formal_procs4 = #formal_procs package4;
	in	if	any
			formal_procs4
			(fn p => #name p = block_name1)
		then	
	let
		val formal_proc3 =
			find 
			formal_procs4
			(fn p => #name p = block_name1);
		val vc_vars2 = #vc_vars(#in_scope(#declab block2));
		val vc_vars4 = #vc_vars package4;
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val in_scope5 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_aux_vars = [],
			vc_vars = vc_vars2,
			vc_pars = vc_pars1			
		};
		val wp_env5 :WP_ENV = {
			env = cn_env_of_in_scope in_scope5,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = []
		};
		val pack_body_vars = vc_vars2 diff vc_vars4;
		val spec3 = #spec formal_proc3;
		val w5 = (#w spec3) cup
				(flat (map (map trans_id o #vars) pack_body_vars));
		val spec5 : SPEC = {
			w = w5,
			w0 = map (fn s => s^"‰0") w5,
			pre = #pre spec3,
			post = #post spec3
		};
		val speclab5 : SPECLAB = {
			spec = spec5,
			formal_body_flag = false,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env5,
			in_scope = in_scope5
		};
	in
		Value (block2, formal_proc3, package4, speclab5)
	end
	else
		Nil
	end
);
=TEX
The default values for the $speclab$ in the following function are set up by the common function above. 
=SML
fun Ûform_proc_pack_bodyÝ (form_proc: FORMAL_PROC) : unit = (
	case form_proc_pack_body_common form_proc of
	Value (_, formal_proc3, _, speclab5) => (
		let	val st = SStmt(STSpecNoIvars{spec= #spec form_proc,
					label=""});
		in	store_vcs (#name formal_proc3, call_vcs(speclab5, st))
		end
	) |Nil => ()
);
=TEX
=SML
fun Ûform_proc_pack_body_auxÝ (frees : Z_ID list, aux_vars : Z_ID list)
			(form_proc: FORMAL_PROC) : unit = (
	case form_proc_pack_body_common form_proc of
	Value (block2, formal_proc3, package4, speclab5) => (

	let	val block1 = block 1;
		val spec3 = #spec formal_proc3;
		val w3 = #w spec3;
		val add_aux = aux_vars diff (#w o #spec) formal_proc3;
		val w6 = w3 cup add_aux;
		val pre6 = #pre spec3;
		val post3 = #post spec3;
		val add_aux0 = map (fn s => s^"‰0") add_aux;
		val post6 = ZTmQuotation (z_many_and ([z_predexp_of_z_tm post3] @
				 (map (fn a => z_eq (zid current_cn_env a,
					subs_exp (zid current_cn_env a, add_aux,
					add_aux0))) add_aux)),
				Nil);
		val aux_vars4 = #aux_vars package4;
		val aux_vars_decs = map dest_z_dec aux_vars4;
		val aux_vars_newdecs = flat (map (fn (tml,ty) =>
						map (fn t => (t,ty)) tml)
							aux_vars_decs);
		val aux_vars_tab = map (fn (tm, ty) => (dest_z_lvar tm, ty))
								aux_vars_newdecs;
		val aux_vars_tab1 = aux_vars_tab drop
					(fn ((s, _, _), _) => s mem w6);
		val aux_vars = map (fn (lv,ty) => mk_z_dec([mk_z_lvar lv], ty))
					aux_vars_tab1;
		val aux_vars_tab0 = map (fn ((s,y,z),t) => ((s^"‰0",y,z),t))
							aux_vars_tab1;
		val aux_vars0 = map (fn (lv,ty) => mk_z_dec([mk_z_lvar lv], ty))
					aux_vars_tab0;
		val seq_aux = aux_vars0;
		val using_decs2 = #using_decs block2;
		val ud2_rel_image = (using_decs2 drop
						(fn n => not (fst n mem w6)));
		val conc_vars = (list_cup o map fst o map snd) ud2_rel_image;
		val invs = (map snd o map snd) ud2_rel_image;
		val frame_aux_conc = w6 cup (list_cup (
					map (map trans_id o #vars) conc_vars));
		val frame_aux_conc0 = map (fn s => s^"‰0") frame_aux_conc;
		val seq_aux = aux_vars0;

		val w5 = frame_aux_conc cup (#w (#spec speclab5));
		
		val pre5 = ZTmQuotation (z_exists (aux_vars,
				z_many_and(z_predexp_of_z_tm pre6::invs)),
				Nil);
		val post5 = ZTmQuotation (z_forall (seq_aux, z_imp (subs_pred (
			  z_many_and (z_predexp_of_z_tm pre6::invs),
					frame_aux_conc, frame_aux_conc0),
			    z_exists (aux_vars,
				z_many_and(z_predexp_of_z_tm post6::invs)))),
			Nil);

		val in_scope5 = #in_scope speclab5;
		val vc_vars5 = #vc_vars in_scope5;
		val vc_vars1 = #vc_vars (#in_scope (#declab block1));
		val in_scope5a = {
			dec_labels = #dec_labels in_scope5,
			formal_procs = #formal_procs in_scope5,
			vc_log_cons = #vc_log_cons in_scope5,
			vc_aux_vars = #vc_aux_vars in_scope5,
			vc_vars = vc_vars5 cup conc_vars,
			vc_pars = #vc_pars in_scope5		
		};
		val wp_env5 :WP_ENV = {
			env = cn_env_of_in_scope in_scope5a,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = #formal_procs (#wp_env speclab5)
		};
		val spec5 : SPEC = {
			w = w5,
			w0 = map (fn s => s^"‰0") w5,
			pre = pre5,
			post = post5
		};
		val speclab5a : SPECLAB = {
			spec = spec5,
			formal_body_flag = false,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env5,
			in_scope = in_scope5a
		};
		val st = SStmt(STSpecNoIvars{spec= #spec form_proc, label=""});
	in	
		blocks :=
		block_vc_vars(block1, vc_vars1 cup conc_vars):: tl (!blocks);
		store_vcs (#name formal_proc3, call_vcs(speclab5a, st));
(* **** **** Commented out comment: 
		comment "form_proc_pack_body_aux" 503001
			[fn()=>"is being called here"] (* TBS *)
*)		()
	end
	) | Nil => ()
);
=TEX
=SML
fun Ûform_proc_subunitÝ (form_proc: FORMAL_PROC) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val bn1_bn2 = block_name2 dot block_name1
		val subunit3 = (force_value(s_lookup bn1_bn2 (!subunit_env)))
			handle Fail _ =>
			error "form_proc_subunit" 507011 [fn()=>bn1_bn2];
	in	subunit_env := s_delete bn1_bn2 (!subunit_env);
		if	#specif_flag subunit3
		then	
	let
		val st = SStmt(STSpecNoIvars{spec= #spec form_proc,
			label=""});
		val vc_vars3 = #vc_vars(#in_scope(subunit3));
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val vc_aux_vars3 = #vc_aux_vars (#in_scope (subunit3));
		val in_scope4 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_aux_vars = vc_aux_vars3,
			vc_vars = vc_vars3,
			vc_pars = vc_pars1			
		}
		val wp_env4 :WP_ENV = {
			env = cn_env_of_in_scope in_scope4,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = []
		};
		val speclab4 : SPECLAB = {
			spec = #specif subunit3,
			formal_body_flag = false,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env4,
			in_scope = in_scope4
		};
	in	store_vcs (block_name1, call_vcs(speclab4, st))
	end
		else	()
	end
);
=TEX
The following function is required to determine whether $form\_proc$ should call $form\_proc\_pack\_body$ or $form\_proc\_pack\_body\_aux$.
=SML
fun Ûaux_vars_in_fp_frameÝ (formal_proc3 : FORMAL_PROC)
			(package4 : PACKAGE) : (Z_ID list * Z_ID list) = (
	let	val free_fn = map ((fn (n, _, _) => n) o dest_z_lvar) o frees
					o z_predexp_of_z_tm;
		val spec3 = #spec formal_proc3;
		val free = (free_fn o #pre) spec3 cup (free_fn o #post) spec3;
		val w3 = #w (#spec formal_proc3);
		val w3free = w3 cup free;
		val aux_vars4 = #aux_vars package4;
		val aux_vars4z = (flat o map fst o map dest_z_dec) aux_vars4;
		val aux_vars4_names = map ((fn (n, _, _) => n) o dest_z_lvar)
						aux_vars4z;
	in
		(free, aux_vars4_names drop (fn n => not (n mem w3free)))
	end
);
=TEX
=SML
fun Ûform_procÝ (form_proc: FORMAL_PROC) : unit = (
	(if		test_flag #pack_spec_flag 2
	then		form_proc_pack_spec
	else if		test_flag #pack_body_flag 2
	then
		case form_proc_pack_body_common form_proc of
		Value (_, formal_proc3, package4, _) => (
			case aux_vars_in_fp_frame formal_proc3 package4 of
			(_, []) =>
					form_proc_pack_body
			|freeinfo =>
					form_proc_pack_body_aux freeinfo
		) | Nil =>
			(fn _ => ())
	else if		test_flag #subunit_flag 2
	then		form_proc_subunit
	else		(fn _ => ())) form_proc
);
=TEX
\subsection{The SID function curr\_form\_proc}
=SML
fun Ûcurr_form_procÝ (formal_proc : FORMAL_PROC) : unit = (
	let	val block1 = block 1;
	in	blocks :=
		block_current_formal_proc (block1, formal_proc) :: tl(!blocks)
	end
);
=TEX
\section{FUNCTIONS}\label{FUNCTIONS}
\subsection{The SID function new\_scope\_fun\_inf}
=TEX
=SML
fun Ûnew_scope_fun_infÝ (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = true,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_fun\_form}
=TEX
=SML
fun Ûnew_scope_fun_formÝ (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = true,
			fun_flag = true,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function stub\_spec\_fun}
=SML
fun Ûstub_spec_funÝ (form_fun : FORMAL_FUN) : unit = (
	stub_spec_proc_fun (#spec form_fun)
);
=TEX
\subsection{The SID function inf\_fun}
=SML
val Ûcart_prod1Ý = CNVCGenerator.cart_prod current_cn_env;
=TEX
=SML
val Ûfun_decl1Ý = CNVCGenerator.fun_decl current_cn_env;
=TEX
The decision of which of the following two functions to call is made in $inf\_fun$
=SML
fun Ûinf_fun_pack_specÝ (inf_fun: INFORMAL_FUN) : unit = (
	let	val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "inf_fun_pack_spec" 507012 [fn()=>block_name2];
		val informal_funs = #informal_funs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_informal_funs(package,
				informal_funs @ [inf_fun]))
		(!pack_env)
	end
);
=TEX
=SML
fun Ûtrans_informal_funÝ (f: INFORMAL_FUN) : PARAINFO = (
	let	val dec = fun_decl1 f;
		val ntys = (map dest_var o fst o dest_z_dec) dec;
	in	AxDesInfo([], mk_z_decl[dec], Nil, ntys)
	end
);
=TEX
=SML
fun Ûinf_fun_otherwiseÝ (inf_fun: INFORMAL_FUN) : unit = (
	update_theory_db_with_parainfo(trans_informal_fun inf_fun);
	set_par_names inf_fun
);
=TEX
=SML
fun Ûinf_funÝ (informal_fun: INFORMAL_FUN) : unit = (
	(if	test_flag #pack_spec_flag 2
	then	inf_fun_pack_spec
	else	inf_fun_otherwise) informal_fun
);
=TEX
\subsection{The SID function form\_fun}
The decision of which of the four cases to apply is made in $form\_fun$
=SML
fun Ûform_fun_pack_specÝ (form_fun: FORMAL_FUN) : unit = (
	let	val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_fun_pack_spec" 507012 [fn()=>block_name2];
		val formal_funs = #formal_funs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_formal_funs(package,
				formal_funs @ [form_fun]))
		(!pack_env)
	end
);
=TEX
=SML
fun Ûz_declsÝ (par_specs : PARAM_SPEC list) : Z_DECL list = (
	let	fun aux1 ({vars, tmark} : VAR_DECL) : Z_DECL = (
			let	val e = (zid current_cn_env o trans_id) tmark;
				val ty = (dest_z_power_type o type_of) e;
				fun v var = mk_z_lvar(var, ty, []);
			in	mk_z_dec(map v vars, e)
			end
		);
	in	map (aux1 o #var_decl) par_specs
	end
);
=TEX
=SML
fun Ûtrans_formal_funÝ ({spec as {pre, post, ...},
			informal_fun as {formal_pars, ...}} : FORMAL_FUN)
				: PARAINFO = (
	let	val dec = fun_decl1 informal_fun;
		val pardecs = z_decls formal_pars;
		val ntys = (map dest_var o fst o dest_z_dec) dec;
		val save_ti_cxt = TypeInference.get_ti_context();
		val new_ti_cxt = frees dec term_union flat (map frees pardecs)
					term_union save_ti_cxt;
		val old_cxt = TypeInference.set_ti_context new_ti_cxt;
		val imp = z_imp(z_predexp_of_z_tm pre, z_predexp_of_z_tm post);
		val old_cxt = TypeInference.set_ti_context save_ti_cxt;
		val pred = (
			case formal_pars of
				[] => imp
			|	non_empty => z_forall(pardecs, imp));
	in	AxDesInfo([], mk_z_decl[dec], Value pred, ntys)
	end
);
=TEX
The VC generator is responsible for distinguishing specification between statements with and without initial variables.
Here, we follow the parser in generating the form without initial variables for it to modify as necessary.
=SML
fun Ûform_fun_pack_bodyÝ (form_fun: FORMAL_FUN) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val package4 = (force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_fun_pack_body" 507012 [fn()=>block_name2];
		val formal_funs4 = #formal_funs package4;
	in	update_theory_db_with_parainfo(trans_formal_fun form_fun);
		set_par_names (#informal_fun form_fun);
		if	any
			formal_funs4
			(fn f => #name(#informal_fun f) = block_name1)
		then	
	let
		val formal_fun3 =
			find 
			formal_funs4
			(fn f => #name(#informal_fun f) = block_name1);
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val in_scope5 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_aux_vars = [],
			vc_vars = [],
			vc_pars = vc_pars1			
		}
		val wp_env5 :WP_ENV = {
			env = cn_env_of_in_scope in_scope5,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = #informal_fun form_fun,
			formal_procs = []
		};
		val speclab5 : SPECLAB = {
			spec = #spec formal_fun3,
			formal_body_flag = false,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env5,
			in_scope = in_scope5
		};
		val st = SStmt(STSpecNoIvars{spec= #spec form_fun, label=""});
	in	store_vcs (block_name2, call_vcs(speclab5, st))
	end
		else	()
	end
);
=TEX
=SML
fun Ûform_fun_subunitÝ (form_fun: FORMAL_FUN) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val bn1_bn2 = block_name2 dot block_name1
		val subunit3 = (force_value(s_lookup bn1_bn2 (!subunit_env)))
			handle Fail _ =>
			error "form_fun_subunit" 507011 [fn()=>bn1_bn2];
	in	update_theory_db_with_parainfo(trans_formal_fun form_fun);
		set_par_names (#informal_fun form_fun);
		subunit_env := s_delete bn1_bn2 (!subunit_env);
		if	#specif_flag subunit3
		then	
	let
		val st = SStmt(STSpecNoIvars{spec= #spec form_fun,
				label=""});
		val in_scope4 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_aux_vars = [],
			vc_vars = [],
			vc_pars = []			
		};
		val wp_env4 :WP_ENV = {
			env = cn_env_of_in_scope in_scope4,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = #informal_fun form_fun,
			formal_procs = []
		};
		val speclab4 : SPECLAB = {
			spec = #specif subunit3,
			formal_body_flag = false,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env4,
			in_scope = in_scope4
		};
	in	store_vcs (block_name2, call_vcs(speclab4, st))
	end
		else	()
	end
);
=TEX
=SML
fun Ûform_fun_otherwiseÝ (form_fun: FORMAL_FUN) : unit = (
	update_theory_db_with_parainfo(trans_formal_fun form_fun);
	set_par_names (#informal_fun form_fun)
);
=TEX
=SML
fun Ûform_funÝ (form_fun: FORMAL_FUN) : unit = (
	(if		test_flag #pack_spec_flag 2
	then		form_fun_pack_spec
	else if		test_flag #pack_body_flag 2
	then		form_fun_pack_body
	else if		test_flag #subunit_flag 2
	then		form_fun_subunit
	else		form_fun_otherwise) form_fun
);
=TEX
\subsection{The SID function curr\_form\_fun}
=SML
fun Ûcurr_form_funÝ (formal_fun : FORMAL_FUN) : unit = (
	let	val block1 = block 1;
	in	blocks :=
		block_current_formal_fun (block1, formal_fun) :: tl(!blocks)
	end
);
=TEX
\section{FORMAL PARAMETERS}\label{FORMALPARAMETERS}
\subsection{The SID function formal\_part}
=TEX
=SML
fun Ûmk_param_specÝ ({idlist, mode, name} : PARAMETER_SPECIFICATION)
		: PARAM_SPEC = (
	{mode = mode, var_decl = {vars = idlist, tmark = name}}
);
=TEX
=SML
fun Ûfformal_partÝ (par_specs : PARAMETER_SPECIFICATION list) : unit = (
	let	val block1 = block 1;
		val formals = map mk_param_spec par_specs;
	in	blocks := block_vc_pars (block1, formals) :: tl(!blocks)
	end
);
=TEX

\section{SUBPROGRAM BODIES}\label{SUBPROGRAMBODIES}
\subsection{The SID function update\_envs\_proc}
The decision whether to call the three auxiliary functions is made in $update\_envs\_proc$ itself (since the test is the same in each case).

In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun Ûupdate_subunit_env_procÝ (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab2 mem dec_labels
			then	(id1_id2,
				subunit_formal_procs(s,
					current_formal_proc1 :: formal_procs))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun Ûupdate_dec_env_procÝ (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_dec_label
			(dec_label_d as
				(dec_label,
				d as {in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab2 mem dec_labels
			then	(dec_label,
				declab_formal_procs(d, 
					current_formal_proc1 :: formal_procs))
			else	dec_label_d
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
The identifiers in the variable declaration are translated first.
=SML
fun Ûupdate_spec_env_procÝ (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab2 mem dec_labels
			then	(spec_label,
				speclab_formal_procs(s, 
					current_formal_proc1 :: formal_procs))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun Ûupdate_envs_procÝ (() : unit) : unit = (
	if	test_flag #declabel_flag 2 andalso test_flag #formal_body_flag 1
	then	(update_subunit_env_proc ();
		update_dec_env_proc ();	
		update_spec_env_proc ())
	else	()
);
=TEX
\subsection{The SID function add\_proc\_env}
=SML
fun Ûadd_proc_envÝ (() : unit) : unit = (
	if	test_flag #formal_body_flag 1
	then	let	val block1 = block 1;
			val current_formal_proc1 =
					#current_formal_proc(block 1);
			val block2 = block 2;
			val formal_procs2 =
					#formal_procs(#in_scope(#declab block2));
			val block2' = block_formal_procs(block2,
					current_formal_proc1 :: formal_procs2);
		in	blocks := block1 :: block2' :: tl(tl(!blocks))
		end
	else	()
);
=TEX
\subsection{The SID function vcs\_body}
The decision about which support function to call (if any) is made in $vcs\_body$ itself.

=SML
fun Ûvcs_body_procÝ (st : STATEMENT) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val pack_body_flag2 = #pack_body_flag (#flags (#declab block2));
		val current_formal_proc1 = #current_formal_proc block1;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val pre1 = #pre(#spec current_formal_proc1);
		val post1 = #post(#spec current_formal_proc1);
		val w1 = #w(#spec current_formal_proc1);
		val w_vcvars = list_cup (map (map trans_id o #vars) vc_vars1);
		val w = if pack_body_flag2
			then let val ran_uds = (map snd o #using_decs) block2;
				  val w_vars_uds = (list_cup o map #vars
						o list_cup o map fst) ran_uds;
			     in	
				w1 cup w_vars_uds
			     end
			else w1 cup w_vcvars;
		val in_scope = flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val current_for_vars1 = #current_for_vars block1;
		val current_log_cons1 = #current_log_cons block1;
		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = (#vc_pars in_scope) cup current_for_vars1,
			vc_log_cons = (#vc_log_cons in_scope) @ current_log_cons1,
			vc_aux_vars = (#vc_aux_vars in_scope),
			formal_procs = #formal_procs in_scope,
			dec_labels = #dec_labels in_scope
		};
		val wp_env :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = formal_procs
		};
		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "‰0") w,
			pre = pre1,
			post = post1
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = true,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope1
		};
	in	store_vcs(#name current_formal_proc1,
				call_vcs(speclab, st))
	end	
);
=TEX
=SML
fun Ûvcs_body_funÝ (st : STATEMENT) : unit = (
	let	val block1 = block 1;
		val current_formal_fun1 = #current_formal_fun block1;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val pre1 = #pre(#spec current_formal_fun1);
		val post1 = #post(#spec current_formal_fun1);
		val w = flat (map (map trans_id o #vars) vc_vars1);
		val in_scope = flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val current_for_vars1 = #current_for_vars block1;
		val current_log_cons1 = #current_log_cons block1;
		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = (#vc_pars in_scope) cup current_for_vars1,
			vc_log_cons = (#vc_log_cons in_scope) @ current_log_cons1,
			vc_aux_vars = (#vc_aux_vars in_scope),
			formal_procs = #formal_procs in_scope,
			dec_labels = #dec_labels in_scope
		};
		val wp_env :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = mk_z_true,
			return = z_predexp_of_z_tm post1,
			fun_header = #informal_fun current_formal_fun1,
			formal_procs = formal_procs
		};
		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "‰0") w,
			pre = pre1,
			post = post1
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = true,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope1
		};
	in	store_vcs((#name o #informal_fun) current_formal_fun1,
			call_vcs(speclab, st))
	end	
);
=TEX
=SML
fun Ûvcs_bodyÝ (st : STATEMENT) : unit = (
	if	test_flag #formal_body_flag 1
	then	if	test_flag #fun_flag 1
		then	vcs_body_fun st
		else	vcs_body_proc st
	else	()
);
=TEX
\section{PACKAGES}\label{PACKAGES}
\subsection{The SID function new\_scope\_pack\_spec}
=SML
val Ûempty_packageÝ : PACKAGE = 
	{	vc_vars		=	[],
		consts_types	=	[],
		formal_procs	=	[],
		informal_funs	=	[],
		formal_funs	=	[],
		aux_vars	=	[]	};
=TEX
=SML
fun Ûnew_scope_pack_specÝ (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = true,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks;
		pack_env := s_extend ident empty_package (!pack_env) 
	end	handle Fail _ => fail "new_scope_pack_spec" 507007 [fn () => ident]
);
=TEX
\subsection{The SID function new\_scope\_pack\_body}
=SML
fun Ûpopulate_theory_with_types_constsÝ (ident : ID) : unit = (
	let	val package1 = force_value(s_lookup ident (!pack_env))
			handle Fail _ =>
			error "populate_theory_with_types_consts" 507029 
				[fn() => ident];
		val consts_types1 = #consts_types package1;
	in
		map basic_decl_otherwise consts_types1
			handle ex => reraise ex
					 "populate_theory_with_types_consts";
		()
	end
);
=TEX
=SML
fun Ûpopulate_theory_with_functionsÝ (ident : ID) : unit = (
	let	val package1 = force_value(s_lookup ident (!pack_env))
			handle Fail _ =>
			error "populate_theory_with_functions" 507029 
				[fn() => ident];

		val informal_funs = #informal_funs package1;
		val informal_fun_paras = map trans_informal_fun informal_funs;
		val formal_funs = #formal_funs package1;
		val formal_fun_paras = map trans_formal_fun formal_funs;
		val consts_types = #consts_types package1;
	in
		map update_theory_db_with_parainfo informal_fun_paras;
		map update_theory_db_with_parainfo formal_fun_paras;
		map set_par_names informal_funs;
		map (set_par_names o #informal_fun) formal_funs;
		map set_basic_decl_info consts_types;
		()
	end
);
=TEX
=SML
fun Ûnew_scope_pack_bodyÝ (ident : ID) : unit = (
	let	val package1 = force_value(s_lookup ident (!pack_env))
			handle Fail _ =>
			fail "new_scope_pack_body" 507030 [fn()=>ident];
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = true,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val vc_vars1 = #vc_vars package1;
		val block = block_vc_vars(
			block_flags(empty_block, flags), vc_vars1);
		val block' = block_block_name(block, ident);
	in
		populate_theory_with_types_consts ident;
		blocks := block' :: !blocks
	end	
);
=TEX

\subsection{The SID function new\_scope\_with}

=SML
fun Ûgenerate_spec_theoryÝ (ident : ID) = (
	let	val side = open_package_tmpbody_theory ident;
		fun prefix n = trans_id (ident dot "")^n;
		fun mk_subs_pair mkx (tm : TERM) : (TERM * TERM) = (
			let val (id, ty, _) = dest_z_gvar tm
				handle ex => reraise ex
					"generate_spec_theory";
			in
				(mkx (prefix id, ty, []), tm)
			end
		);
		val consts = get_consts "-";

		val const_thms = rev (map (fn x => (x, (Value (get_spec x)
						handle Fail _=> Nil))) consts);
		
		val type_names = get_type_names "-";

		val side = open_package_spec_theory ident;
		fun do_const_thms subs ((const, Nil) :: more) = (
			let	val (name, ty, _) = dest_z_gvar const;
			in
				new_const ((z_id_of_id o prefix) name, ty);
				do_const_thms subs more
			end
		) | do_const_thms subs ((const, Value thm) :: more) = (
			let	val (pty, tm) = (dest_app o snd o dest_thm) thm;
				val (name, ty, _) = dest_z_gvar const;
				val subs' = mk_subs_pair mk_z_gvar const::subs;
				val subs'' = mk_subs_pair mk_z_lvar const::subs;
				val prename = prefix name;
			in
			   	case (fst o dest_const) pty of
				"Z'AxDes" => (
					let val (decl, vp) = ((Combinators.I **
								Value) o dest_± o
								subst subs'') tm
							handle Fail _ =>
								(tm, Nil)
					in
						AxDesInfo ([],
							decl, vp,
							 [(prename, ty)])
					end :: do_const_thms subs' more
				) |"Z'AbbDef" => (
					AbbDefInfo (prename, [], (subst subs''
								o snd o dest_eq) tm)
							 :: do_const_thms subs' more
				) | _ => do_const_thms subs' more
			end
		) | do_const_thms _ [] = [];

		val paras = do_const_thms [] const_thms;

		val package = force_value(s_lookup ident (!pack_env))
				handle Fail _ =>
				error "generate_spec_theory" 507029 
					[fn() => ident];

		fun prefix_informal_fun {name, formal_pars, return_type} = (
			{name = prefix name,
			formal_pars = formal_pars,
			return_type = return_type}
		);

		val inf_funs = map prefix_informal_fun(
				#informal_funs package @
				map #informal_fun (#formal_funs package));

		val new_type_names = map prefix type_names;
	in
		map update_theory_db_with_parainfo paras;
		map set_par_names inf_funs;
		map add_type_name new_type_names;
		()
	end handle Fail _ =>
		fail "generate_spec_theory" 507029 [fn()=>ident]
);
=TEX

=SML
fun Ûpopulate_package_spec_theoryÝ (ident : ID) : unit = (
	let	val thy = get_current_theory_name();
		val parents_of_pack = (rev o get_parents) thy;
		val father = hd parents_of_pack;
	in
		open_theory father;
		new_package_tmpbody_theory ident
			handle Fail _ => open_package_tmpbody_theory ident;

		populate_theory_with_types_consts ident;
		populate_theory_with_functions ident;

		open_theory father;
		new_package_spec_theory ident
			handle Fail _ => open_package_spec_theory ident;
		generate_spec_theory ident;

		open_theory father;
		force_delete_theory (pack_tmpbody_name ident)
			handle _ => ();
		open_theory thy
	end
);
=TEX
$do\_pack\_spec$ updates the specification theory rather than $new\_scope\_with$. When $new\_scope\_with$ is called, the specification theory will have already been populated with the appropriate constants, types and functions.
=SML
fun Ûnew_scope_withÝ (ident : ID) : unit = (

	case s_lookup ident (!pack_env) of
	Nil => ()
	|Value package1 => (
		   let	val flags = {
				pack_spec_flag = false,
				pack_body_flag = false,
				stub_flag = false,
				subunit_flag = false,
				formal_body_flag = false,
				fun_flag = false,
				declabel_flag = false,
				speclabel_flag = false,
				till_flag = false
			};
			val vc_vars1 = #vc_vars package1;
			val vc_aux_vars1 = #aux_vars package1;
			val formal_procs1 = #formal_procs package1;
			val block = block_vc_vars(empty_block, vc_vars1);
			val block = block_vc_aux_vars(empty_block, vc_aux_vars1);
			val block = block_formal_procs(block, formal_procs1);
		in	populate_package_spec_theory ident;
			new_parent (pack_spec_name ident) handle Fail _ => ();
			blocks := block :: !blocks
		end
	)
);
=TEX
\subsection{The SID function end\_scope\_comp\_unit}
=SML
fun Ûend_scope_comp_unitÝ ((): unit) : unit = (
	blocks := [block 1]
);
=TEX
\subsection{The SID function aux\_var}
=SML
fun Ûz_decl_of_auxÝ ({aux, t} : AUX_VAR) : Z_DECL = (
	let	val zt = z_predexp_of_z_tm t;
		val zvar = mk_z_lvar(aux, (dest_z_power_type o type_of) zt, []);
	in	mk_z_dec([zvar], zt)
	end
);
=TEX
=SML
fun Ûaux_varÝ (av : AUX_VAR) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "aux_var" 507006 [];
		val block_name1 = #block_name(#declab (block1));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "aux_var" 507001 [];
		val {aux, t} = av;
		val zt = z_predexp_of_z_tm t;
		val zvar = mk_z_lvar(aux, (dest_z_power_type o type_of) zt, []);
		val zdecl = mk_z_dec([zvar], zt);
		val aux_vars1 = #aux_vars package drop (fn x => zdecl =$ x);
	in	pack_env :=
		s_enter
		block_name1
		(package_aux_vars(package, aux_vars1 @ [zdecl]))
		(!pack_env)
	end
);
=TEX

\subsection{The SID function using\_dec}

=SML
fun Ûud_fun_of_using_decÝ (ud : USING_DEC)
		: Z_ID * (VAR_DECL list * CNTypes.Z_PRED)= (
	let	val {	aux,
			concrete_vars,
			invariant, ...}		= ud;
		val (id, _, _) = (dest_z_lvar o z_predexp_of_z_tm) aux;
	in	(id, (concrete_vars, z_predexp_of_z_tm invariant))
	end
);
=TEX
=SML
fun Ûusing_decÝ (ud: USING_DEC) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "using_dec" 507006 [];
		val using_decs1 = #using_decs block1;
		val ud_fn as (id, _) = ud_fun_of_using_dec ud;
		fun ud_fun_match (id1, (bd1, tm1)) (id2, (bd2, tm2)) = (
			id1 = id2 andalso bd1 = bd2
				andalso tm1 =$ tm2
		);
		val using_decs2 = using_decs1 drop
			(fn u => ud_fun_match ud_fn u);			
	in	blocks :=
		block_using_decs(block1, using_decs2 @ [ud_fn]):: tl (!blocks)
	end
);
=TEX
=SML
fun Ûadd_conc_vars_envÝ ((): unit) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "add_conc_vars_env" 507006 [];
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val using_decs = #using_decs block1;
		val var_decls = (list_cup o map fst o map snd) using_decs;
	in	blocks :=
		block_vc_vars(block1, vc_vars1 cup var_decls):: tl (!blocks)
	end
);
=TEX
\subsection{The SID function vcs\_aux\_initial}
=SML
fun Ûvcs_aux_initialÝ (st : STATEMENT) : unit = (
	let	val block1 = block 1;
		val block_name1 = #block_name(#declab (block1));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "vcs_aux_initial" 507001 [];
		val aux_vars1 = #aux_vars package;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val w = flat (map (map trans_id o #vars) vc_vars1);
		val in_scope = flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val using_decs1 = #using_decs block1;

		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = [],
			vc_log_cons = [],
			vc_aux_vars = [],
			formal_procs = formal_procs,
			dec_labels = []
		};
		val wp_env :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = formal_procs
		};
		val invariants = (map snd o map snd) using_decs1;
		val post1 = z_exists (aux_vars1, z_many_and invariants);
		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "‰0") w,
			pre = z_tm_true,
			post = ZTmQuotation (post1, Nil)
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = true,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope1
		};
	in	store_vcs(block_name1,
			call_vcs(speclab, st))
	end
);
=TEX

\section{STUBS AND SUBUNITS}\label{STUBSANDSUBUNITS}
\subsection{The SID function begin\_stub}
=SML
fun Ûbegin_stubÝ (():unit) : unit = (
	let	val block1 = block 1;
	in	blocks :=  block_stub_flag (block1, true) :: tl (!blocks)
	end	handle Fail _ => error "begin_stub" 507006 []
);
=TEX
\subsection{The SID function end\_stub}
=SML
fun Ûend_stubÝ (():unit) : unit = (
	let	val block1 = block 1;
	in	blocks :=  block_stub_flag (block1, false) :: tl (!blocks)
	end	handle Fail _ => error "begin_stub" 507006 []
);
=TEX
\subsection{The SID function new\_scope\_subunit}
=SML
fun Ûnew_scope_subunitÝ (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = true,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end
);
=TEX
\section{WEB CLAUSES}\label{WEBCLAUSES}
=TEX
\subsection{THE SID function new\_scope\_dec\_replace}
In the following, those fields for the new block which are left undefined in the Z specification are borrowed from the empty block value.
=SML
fun Ûnew_scope_dec_replaceÝ ({label, decls} : REPLACED_BY_DECL) : unit = (
	case s_lookup label (!dec_env) of
		Value declab => (
			let	val block = {
		declab = declab_declabel_flag (declab, true),
		current_formal_proc = #current_formal_proc empty_block,
		current_formal_fun = #current_formal_fun empty_block,
		current_for_vars = #current_for_vars empty_block,
		current_log_cons = #current_log_cons empty_block,
		dec_lab = label,
		spec_lab = #spec_lab empty_block,
		till = #till empty_block,
		using_decs = #using_decs empty_block};
			in	blocks := block :: !blocks;
				dec_env := s_delete label (!dec_env)
			end
	) |	Nil => fail "new_scope_dec_replace" 507002
			[fn () => label]
);
=TEX
\subsection{THE SID function update\_envs\_remove\_declabel}
In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun Ûupdate_subunit_env_remove_declabelÝ
		({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_subunit
			((id1_id2,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SUBUNIT) = (
			(id1_id2,
			subunit_dec_labels(s, dec_labels less label))
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun Ûupdate_dec_env_remove_declabelÝ ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_dec_label
			((dec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * DECLAB) = (
			(dec_label,
			declab_dec_labels(s, dec_labels less label))
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
=SML
fun Ûupdate_spec_env_remove_declabelÝ ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_spec_label
			((spec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SPECLAB) = (
			(spec_label,
			speclab_dec_labels(s, dec_labels less label))
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
=SML
fun Ûupdate_envs_remove_declabelÝ (label_decls : REPLACED_BY_DECL) : unit = (
	update_subunit_env_remove_declabel label_decls;
	update_dec_env_remove_declabel label_decls;	
	update_spec_env_remove_declabel label_decls
);
=TEX
\subsection{THE SID function new\_scope\_speclabel}
=SML
fun Ûnew_scope_speclabelÝ (label : LABEL) : unit = (
	let	val spec_env_lab = force_value( s_lookup label (!spec_env) )
			handle Fail _ => fail "new_scope_speclabel" 507003
				[fn () => label];
		val till_flag = #till_flag spec_env_lab;
		val till = #till (#wp_env (spec_env_lab));
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = true,
			till_flag = till_flag
		};
		val block =	block_till(
					block_spec_lab(
						block_flags(empty_block, flags),
					label),
				till);
	in	blocks := block :: !blocks
	end
);
=TEX
\subsection{THE SID function vcs\_speclabel}
The following follows the specification in fishing the label out of the environment (although it will be the same as the label in the argument).

The speclab is augmented by any variables brought into scope by a for-loop.

=SML
fun Ûvcs_speclabelÝ ({label = unused, statement} :REFINED_BY) : unit = (
	let	val block1 = block 1;
		val label = #spec_lab block1;
		val spec_env_lab = force_value( s_lookup label (!spec_env) )
			handle Fail _ => fail "vcs_speclabel" 507003
				[fn () => label];
		val {wp_env as {env, till, return, fun_header, formal_procs},
			spec, in_scope, formal_body_flag, fun_flag, till_flag}
			= spec_env_lab;
		val current_for_vars1 = #current_for_vars block1;
		val current_log_cons1 = #current_log_cons block1;
		val in_scope1 = {
			vc_vars = #vc_vars in_scope,
			vc_pars = (#vc_pars in_scope) cup current_for_vars1,
			vc_log_cons = (#vc_log_cons in_scope) @ current_log_cons1,
			vc_aux_vars = #vc_aux_vars in_scope,
			formal_procs = #formal_procs in_scope,
			dec_labels = #dec_labels in_scope
		};
		val wp_env1 :WP_ENV = {
			env = cn_env_of_in_scope in_scope1,
			till = till,
			return = return,
			fun_header = fun_header,
			formal_procs = formal_procs
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1
		};
	in	store_vcs (label, call_vcs (speclab, statement))
	end
);
=TEX
\subsection{THE SID function end\_scope\_speclabel}
=SML
fun Ûend_scope_speclabelÝ (():unit) : unit = (
	let	val label = #spec_lab(block 1);
	in	end_scope();
		spec_env := s_delete label (!spec_env)
	end
);
=TEX
\subsection{THE SID functions new\_scope\_stmtlabel and end\_scope\_stmt\_label}
=SML
val Ûnew_scope_stmt_labelÝ: LABEL -> unit = new_scope_speclabel;
val Ûend_scope_stmt_labelÝ: unit -> unit = end_scope_speclabel;
=TEX
\section{SPARK PROGRAM ENVIRONMENT}
\subsection{The SID Function update\_replacement\_env}
TBS - the error reporting here could usefully be made more sophisticated.
(By checking that $repl$ and the replacement environment entry are of the same sort.)
=SML
fun Ûupdate_replacement_envÝ ((label, repl) : LABEL * REPLACEMENT) : unit = (
	let	val msg_no =
			case s_lookup label (!repl_env) of
				Value(UnReplaced (_, name)) => 0
			|	Value _ => 507004
			|	Nil => 507003;
		val side_effect =
				if	msg_no <> 0
				then	warn "update_replacement_env" 507003
					[fn () => label]
				else	();
	in	repl_env := s_enter label repl (!repl_env)
	end
);
=TEX
=SML
fun Ûupdate_spark_progÝ (comp : KSLOT_COMPILATION_UNIT list) : unit = (
	spark_prog := !spark_prog @ comp
);
=TEX
=SML
fun Ûnew_k_slotÝ (label : LABEL, sort : REPL_SORT, theory : string) : unit = (
	(repl_env := s_enter label (UnReplaced (sort, theory)) (!repl_env))
			handle Fail _ => fail "new_k_slot" 507005 [fn () => label]
);
=TEX
\section{INVOKING THE SID FUNCTIONS}
For various reasons, the command for opening a theory in {\Product} does some work even if the theory being opened is already current.
We use a more optimal approach here:
=SML
fun Ûlazy_open_theoryÝ (thy : string) : unit = (
	if	thy = "-" orelse thy = get_current_theory_name()
	then	()
	else	open_theory thy
);
=TEX
=SML
fun Ûopen_label_theoryÝ (lab : string) : unit = (
	case s_lookup lab (!repl_env) of
		Value(UnReplaced(_, thy)) => lazy_open_theory thy
	|	_ => ()
);
=TEX
The abstract syntax separates two forms of for-loop which are processed identically here.
The following function does the common processing.
=SML
fun Ûdo_for_loopÝ (i : ID, stmt : STMT, dir : LOOP_DIRECTION) = (
	if	dir = LDForwards
	then	(new_scope_loop();
		for_param i;
		do_stmt stmt;
		end_scope())
	else	(comment "do_stmt" 507012 [];
		do_stmt stmt)
)
(*
=TEX
The following reflects the SID functions for $statement$ (see also $do\_statement$), $loop\_statement$ and $loop\_parameter\_specification$.

To have the same order of invocation of the SID functions for for- and while- loop statements as in the specification, it is necessary to ``expand in line'' the processing for their constituent loops.
=SML
*)
and Ûdo_stmtÝ (y as STNull : STMT) = (
) | do_stmt (y as STImplicitNull : STMT) = (
) | do_stmt (y as (STAssign x) : STMT) = (
) | do_stmt (y as (STSpecNoIvars x) : STMT) = (
	new_k_slot(#label x, RSSpecStatement, get_current_theory_name());
	spec_stmt x
) | do_stmt (y as (STSemicolon (x1, x2)) : STMT) = (
	do_stmt x1;
	do_stmt x2
) | do_stmt (y as (STIfThenElse {p, q, ...}) : STMT) = (
	do_stmt p;
	do_stmt q
) | do_stmt (y as (STCase {s, others, ...}) : STMT) = (
	map (do_stmt o #p) s;
	do_stmt others
) | do_stmt (y as (STLoop {t=Value till, stmt}) : STMT) = (
	new_scope_loop();
	till_pred till;
	do_stmt stmt;
	end_scope()
) | do_stmt (y as (STLoop {t=Nil, stmt}) : STMT) = (
	new_scope_loop();
	do_stmt stmt;
	end_scope()
) | do_stmt (y as (STNamedLoop {t, stmt, ...}) : STMT) = (
	do_stmt (STLoop {t = t, stmt = stmt})
) | do_stmt (y as (STWhile {loop as {t, stmt}, ...}) : STMT) = (
	do_stmt (STLoop {t = t , stmt = stmt})
) | do_stmt (y as (STForStatic {i, loop as {stmt, ...}, dir, ...}) : STMT) = (
	do_for_loop(i, stmt, dir)
) | do_stmt (y as (STForTmark {i, loop as {stmt, ...}, dir, ...}) : STMT) = (
	do_for_loop(i, stmt, dir)
) | do_stmt (y as (STExitWhen x) : STMT) = (
) | do_stmt (y as STExit : STMT) = (
) | do_stmt (y as (STRet x) : STMT)  = (
) | do_stmt (y as (STProcNoIvars x) : STMT) = (
) | do_stmt (y as (STKSlot {label, content}) : STMT) = (
	new_k_slot(label, RSStatement, get_current_theory_name());
	k_slot_stmt label
);
=TEX
The following reflects the SID functions for $statement$ (see also $do\_stmt$).
Note that the parser is not expected to produce the $SSpecIvars$, $SForNonStatic$ or $SProcIvars$ alternatives, since it cannot carry out the necessary analysis of free variables.
It uses the $STMT$ forms to carry the information on, since the $STATEMENT$ form is inadequately general.
The $STATEMENT$ alternatives are produced where necessary in the VC generator.
=SML
fun Ûdo_statementÝ (y as (SStmt x) : STATEMENT) = (
	do_stmt x
) | do_statement (y as (SSpecIvars x) : STATEMENT) = (
	error "do_statement" 507019 []
) | do_statement (y as (SForNonStatic x) : STATEMENT) = (
	error "do_statement" 507019 []
) | do_statement (y as (SLogCon (log_con, stmt)) : STATEMENT) = (
	new_k_slot(#label log_con,
		RSSpecStatement, get_current_theory_name());
	add_log_con_env log_con;
	spec_stmt {spec= #spec log_con, label= #label log_con};
	remove_log_con_env()
) | do_statement (y as (SProcIvars x) : STATEMENT) = (
	error "do_statement" 507019 []
);
=TEX

The following reflects the SID functions for $dec$, $basic\_declaration$ and $subprogram\_declaration$. Note that the $with\_context$ is an argument used for package declarations so that when the package theories are created, the $with$ packages can become parents.
=SML
fun Ûdo_declarationÝ (with_context : ID list) (y as (DDeclarationKSlot (
	{label, content}, dkty)) : DECLARATION) = (
	let	val rsty = case dkty of
					DKDeclaration => RSDeclaration
				|	DKPrivate => RSPrivatePart
				|	DKVisible => RSVisiblePart;
	in
		new_k_slot(label, rsty, get_current_theory_name())
	end;
	k_slot_dec label
) | do_declaration _ (y as (DRenamingDeclaration x) : DECLARATION) = (
	comment "do_declaration" 507016 []
) | do_declaration _ (y as (DBasicDecl x) : DECLARATION) = (
	case x of
		BDTypeDecl _ => (basic_declaration x
	) |	BDSubtypeDecl _ => (basic_declaration x
	) |	BDConstDecl _ => (basic_declaration x
	) |	BDVarDecl v => (
			var_pack_spec v;
			update_envs_var v;
			add_var_env v
	) |	BDDeferredConstDecl _ => (comment "do_declaration" 507021 []
	) |	BDPrivateTypeDecl _ => ()
) | do_declaration _ (y as (DRepresentationClause x) : DECLARATION) = (
	comment "do_declaration" 507017 []
) | do_declaration _ (y as (DProperBody x) : DECLARATION) = (
	do_proper_body x
) | do_declaration _ (y as (DProcedureDeclaration x) : DECLARATION) = (
	do_procedure_spec x;
	end_scope()
) | do_declaration _ (y as (DFunctionDeclaration x) : DECLARATION) = (
	do_function_spec x;
	end_scope()
) | do_declaration with_context (y as (DPackageDeclaration x) : DECLARATION) = (
	do_package_spec with_context x
) | do_declaration _ (y as (DProcedureStub x) : DECLARATION) = (
	do_procedure_stub x
) | do_declaration _ (y as (DFunctionStub x) : DECLARATION) = (
	do_function_stub x
) | do_declaration _ (y as (DPackageStub x) : DECLARATION) = (
	do_package_stub x
) | do_declaration _ (y as (DAuxiliary x) : DECLARATION) = (
	aux_var x
) | do_declaration _ (y as (DUsing x) : DECLARATION) = (
	using_dec x;
	add_conc_vars_env()
)
(*
=TEX
The following reflects the SID functions for $procedure\_specification$:
=SML
*)
and Ûdo_procedure_specÝ (
	{name, formal_part, spec as Value sp} : PROCEDURE_SPECIFICATION) = (
	let	val formal_proc : FORMAL_PROC =
		{name=name, spec=sp, formal_ids = map mk_param_spec formal_part};
	in	subunit_form name;
		new_scope_proc_form name;
		stub();
		fformal_part formal_part;
		stub_spec_proc formal_proc;
		form_proc formal_proc;
		curr_form_proc formal_proc
	end
) | Ûdo_procedure_specÝ (
	{name, formal_part, spec as Nil} : PROCEDURE_SPECIFICATION) = (
	subunit_inf name;
	new_scope_proc_inf name;
	stub();
	fformal_part formal_part
)
(*
=TEX
The following reflects the SID functions for $function\_specification$:
=SML
*)
and Ûdo_function_specÝ (
	{designator, return, formal_part, spec as Value sp}
			: FUNCTION_SPECIFICATION) = (
	let	val informal_fun : INFORMAL_FUN =
		{name=designator,
		formal_pars = map mk_param_spec formal_part,
		return_type = return};
		val formal_fun : FORMAL_FUN =
			{spec = sp, informal_fun = informal_fun};
	in	subunit_form designator;
		new_scope_fun_form designator;
		stub();
		fformal_part formal_part;
		stub_spec_fun formal_fun;
		form_fun formal_fun;
		curr_form_fun formal_fun
	end
) | Ûdo_function_specÝ (
	{designator, return, formal_part, spec as Nil}
			: FUNCTION_SPECIFICATION) = (
	let	val informal_fun : INFORMAL_FUN =
		{name=designator,
		formal_pars = map mk_param_spec formal_part,
		return_type = return};
	in	subunit_inf designator;
		new_scope_fun_inf designator;
		stub();
		fformal_part formal_part;
		inf_fun informal_fun
	end
)
(*
=TEX
The following reflects the SID functions for $package\_specification$:
Note that the package specification and package body theories are created and populated here rather than during $new\_scope\_pack\_body$ and $new\_scope\_with$.
=SML
*)
and Ûdo_package_specÝ (with_context : ID list) (
	{name, visible_decs, private_decs}
			: DECLARATION PACKAGE_DECLARATION) = (
	new_scope_pack_spec name;
	map (do_declaration with_context) visible_decs;
	map (do_declaration with_context) private_decs;
	end_scope()
)
(*
=TEX
The following reflects the SID functions for $package\_body$:
=SML
*)
and Ûdo_procedure_stubÝ (
	proc_spec : PROCEDURE_DECLARATION) = (
	begin_stub();
	do_procedure_spec proc_spec;
	add_proc_env();
	end_scope();
	end_stub()
)
and Ûdo_function_stubÝ (
	fun_spec : FUNCTION_DECLARATION) = (
	begin_stub();
	do_function_spec fun_spec;
	end_scope();
	end_stub()
)
and Ûdo_package_stubÝ (
	name : ID) = (
	comment "do_package_stub" 507018 []
)
(*
=TEX
The following reflects the SID functions for:

\begin{tabular}{c}
subprogram\_body\\
subprogram\_implementation\\
package\_body\\
\end{tabular}

=SML
*)
and Ûdo_proper_bodyÝ (y as (PBProcedure 
	{procedure_spec, declarative_part, statement}) : PROPER_BODY) : unit = (
	do_procedure_spec procedure_spec;
	map (do_declaration []) declarative_part;
	do_statement statement;
	vcs_body statement;
	update_envs_proc();
	add_proc_env();
	end_scope()
) | do_proper_body (y as (PBFunction 
	{function_spec, declarative_part, statement}) : PROPER_BODY) = (
	do_function_spec function_spec;
	map (do_declaration []) declarative_part;
	do_statement statement;
	vcs_body statement;
	end_scope()
) | do_proper_body (y as (PBPackage 
	{name, decls, statement}) : PROPER_BODY) = (
	new_scope_pack_body name;
	map (do_declaration []) decls;
	do_statement statement;
	if any decls (fn d => case d of DUsing _ => true |_ => false)
	then
		vcs_aux_initial statement
	else
		();
	end_scope()
);
=TEX
The following reflects the SID functions for $subunit$.
=SML
fun Ûdo_compilation_unitÝ (with_context : ID list)
	(y as (CUPackageDeclaration (x as {name, ...})) : COMPILATION_UNIT) : unit = (
	do_declaration with_context (DPackageDeclaration x)
) | do_compilation_unit with_context (y as (CUProperBody x)) = (
	do_declaration with_context (DProperBody x)
) | do_compilation_unit with_context (y as (CUSubUnit {name, proper_body})) = (
	open_subunit_theory (name, proper_body);
	new_scope_subunit name;
	do_declaration with_context (DProperBody proper_body);
	end_scope()
);
=TEX
The following reflects the SID functions for the productions $compilation\_unit$ and $simple\_name\_list$ (occuring in a $with\_clause$). Note that the package specification theory and the package body theory are created when the package specification is processed and not when the $with$ clause is encountered; i.e., $new\_scope\_with$ is called in those places.

=SML
fun Ûdo_context_compilation_unitÝ
	({context, comp_unit} : CONTEXT_COMPILATION_UNIT) : unit = (
	map new_scope_with context;
	do_compilation_unit context comp_unit;
	end_scope_comp_unit()
);
=TEX
The following reflects the need to register compilation k-slots .
=SML
fun Ûdo_kslot_compilation_unitÝ
	(y as (KCUKSlot {label, content}) : KSLOT_COMPILATION_UNIT) : unit = (
	set_bottom_block_name (k_slot_compilation_unit_name y);
	new_k_slot (label, RSCompilation, get_current_theory_name())
) | do_kslot_compilation_unit
	(y as (KCUUnit x) : KSLOT_COMPILATION_UNIT) = (
	set_bottom_block_name (k_slot_compilation_unit_name y);
	do_context_compilation_unit x
);
=TEX
The following reflects the SID functions for the production $web\_clause$.
(Note that we set up the label on the bottom block for possible use in generating VC names except in the first two cases, where the processing of the constituent k-slots or compilations units will do this.)
=SML
fun Ûdo_web_clauseÝ (y as (WCCompilation x) : WEB_CLAUSE) : unit = (
let	val current_theory = get_current_theory_name ();
in	update_spark_prog x;
	map do_kslot_compilation_unit x;
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByCompilation x) : WEB_CLAUSE) = (
let	val {label=label, comp=comp} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplaceComp x);
	map do_kslot_compilation_unit (#comp x);
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByPrivatePart x) : WEB_CLAUSE) = (
let	val {label=label, private=private} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplacePPart x);
	set_bottom_block_name label;
	map (do_declaration []) (#private x);
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByVisiblePart x) : WEB_CLAUSE) = (
let	val {label=label,visible=visible} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplaceVPart x);
	set_bottom_block_name label;
	map (do_declaration []) (#visible x);
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByDecl x) : WEB_CLAUSE) = (
let	val {label=label,decls=decls} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplaceDecl x);
	set_bottom_block_name label;
	new_scope_dec_replace x;
	map (do_declaration []) decls;
	update_envs_remove_declabel x;
	end_scope();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCRefinedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplaceStat x);
	set_bottom_block_name label;
	new_scope_speclabel label;
	do_statement statement;
	vcs_speclabel x;
	end_scope_speclabel();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory label;
	update_replacement_env(label, ReplaceStat x);
	set_bottom_block_name label;
	new_scope_stmt_label label;
	do_statement statement;
	end_scope_stmt_label();
	lazy_open_theory current_theory
end
);
=TEX
\section{INTERFACE}
The following function is called from \cite{ISS/HAT/DAZ/IMP504} to classify a label.
=SML
fun Ûclassify_labelÝ (lab : string) : REPL_SORT OPT = (
	case s_lookup lab (!repl_env) of
		Value(UnReplaced(rs, _)) => Value rs
	|	_ => Nil
);
=TEX
=SML
fun Ûget_replacementÝ (lab : string) : REPLACEMENT OPT = (
	s_lookup lab (!repl_env)
);
=TEX
=SML
fun Ûcn_z_generatorÝ (w : WEB_CLAUSE) : unit = (
	let	val save_cn_state = get_cn_state();
		val save_ti_cxt = TypeInference.get_ti_context();
	in	diag_vc_args := [];
		diag_web_clause := w;
		(do_web_clause w)
		handle ex => (
			diag_cn_state := get_cn_state();
			set_cn_state save_cn_state;
			TypeInference.set_ti_context save_ti_cxt;
			raise ex
		);
		TypeInference.set_ti_context save_ti_cxt
	end
);
=TEX
=SML
fun Ûrestart_cn_z_generatorÝ (():unit) : unit = (
	set_cn_state{pack_env = pack_env0,
		subunit_env = subunit_env0,
		dec_env = dec_env0,
		spec_env = spec_env0,
		blocks = env0,
		repl_env = repl_env0,
		spark_prog = spark_prog0,
		script_name = ""}

);
=TEX
=SML
fun Ûinit_cn_z_generatorÝ (script_name : string) : unit = (
	set_cn_state{pack_env = !pack_env,
		subunit_env = !subunit_env,
		dec_env = dec_env0,
		spec_env = spec_env0,
		blocks = env0,
		repl_env = repl_env0,
		spark_prog = spark_prog0,
		script_name = script_name}
);
=TEX
=SML
fun Ûnew_literate_scriptÝ (script_name : string) : unit = (
	open_theory "daz_toolkit_extensions";
	new_theory script_name;
	init_cn_z_generator script_name
);
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNZGenerator *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
=IGN





