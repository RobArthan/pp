% imp507.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP507}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz,hatdocs}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
Sections \ref{BASICDECLARATIONS} to \ref{WEBCLAUSES} implement the material defined in the corresponding sections of \cite{ISS/HAT/DAZ/DTD507}.

Section \ref{PREAMBLE} contains various material which supports this, e.g. the component update functions and initial environment values of \cite{ISS/HAT/DAZ/DTD513}.
Because the implementations of the component update functions are rather long-winded, they are all given together and the other material is not interleaved with them.
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE AND AUXILIARIES}\label{PREAMBLE}
=SML
structure €CNZGenerator› (* : CNZGenerator *) = struct
open CNTypes CNTypes1 CNTypes2 CNBasicDeclsAndExprs ZParagraphs
	CNVCGenerator CNParser;
=TEX
\subsection{TBS}
The following gets around the use of a separate data type for labels.
It is much more convenient here to represent an omitted label as an empty string.
It would be better to make this change of representation throughout.
=SML
fun €string_of_label› (LExplicit s : LABEL) : string = s
|    string_of_label LImplicit = "";
=TEX
\subsection{Component Update Functions}
=SML
fun €package_vc_vars› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_vc_vars : VAR_DECL list) : PACKAGE = (
	{	vc_vars		=	new_vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_consts_types› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_consts_types : BASIC_DECL list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	new_consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_formal_procs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_procs : FORMAL_PROC list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	new_formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_informal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_informal_funs : INFORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	new_informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_formal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	new_formal_funs	}	
);
=TEX
=SML
fun €subunit_vc_vars›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_vc_vars : VAR_DECL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €package_formal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	new_formal_funs	}	
);
=TEX
=SML
fun €subunit_formal_procs›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_formal_procs : FORMAL_PROC list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €subunit_dec_labels›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_dec_labels : LABEL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}
	}
);
=TEX
=SML
fun €declab_declabel_flag›  (
	{	block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope
	} : DECLAB,
	new_declabel_flag : FLAG) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	{
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	new_declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag
		},
		in_scope	=	in_scope
	}
);
=TEX
=SML
fun €declab_vc_vars›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_vc_vars : VAR_DECL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	new_vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun €declab_formal_procs›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_formal_procs : FORMAL_PROC list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	new_formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun €declab_dec_labels›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_dec_labels : LABEL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	formal_procs,
			dec_labels		=	new_dec_labels
		}
	}
);
=TEX
=SML
fun €speclab_w›  (
	{spec as  { w, w0, pre, post, label},
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope
	} : SPECLAB,
	new_w : Z_ID list) : SPECLAB = (
	{spec 			=	{w = new_w, w0 = w0, pre = pre,
						post = post, label = label},
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	in_scope
	}
);
=TEX
=SML
fun €speclab_vc_vars›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SPECLAB,
	new_vc_vars : VAR_DECL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €speclab_formal_procs›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SPECLAB,
	new_formal_procs : FORMAL_PROC list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}

	}
);
=TEX
=SML
fun €speclab_dec_labels›  (
	{spec,
	formal_body_flag,
	fun_flag,
	till_flag,
	wp_env,
	in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SPECLAB,
	new_dec_labels : LABEL list) : SPECLAB = (
	{spec 			=	spec,
	formal_body_flag	=	formal_body_flag,
	fun_flag		=	fun_flag,
	till_flag		=	till_flag,
	wp_env			=	wp_env,
	in_scope		=	{
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}

	}
);
=TEX
=SML
fun €block_stub_flag›  (
	{
	declab as {block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_stub_flag : FLAG) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	new_stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag
				},
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_till_flag›  (
	{
	declab as {block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_till_flag : FLAG) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = {
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	new_till_flag
				},
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_vc_vars›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_vc_vars : VAR_DECL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_vc_pars›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_vc_pars : PARAM_SPEC list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	new_vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_vc_log_cons›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_vc_log_cons : Z_DECL list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	new_vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_formal_procs›  (
	{
	declab as {block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons,
				formal_procs, dec_labels}},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_formal_procs : FORMAL_PROC list) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
				}},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_current_formal_proc›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till} : BLOCK,
	new_current_formal_proc : FORMAL_PROC) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = new_current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_current_formal_fun›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till} : BLOCK,
	new_current_formal_fun : FORMAL_FUN) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = new_current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_till›  (
	{declab,
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till} : BLOCK,
	new_till : Z_PRED) : BLOCK = (
	{declab	 = declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = new_till
	}
);
=TEX
In the implementation, the following are useful additions to the component update functions defined in the Z spec.
=SML
fun €block_flags›  (
	{
	declab as {block_name,
		flags,
		in_scope},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_flags : FLAGS) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = new_flags,
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_spec_lab›  (
	{
	declab,
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_spec_lab : LABEL) : BLOCK = (
	{declab		=	declab,
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = new_spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_block_name›  (
	{
	declab as {block_name,
		flags,
		in_scope},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_block_name : ID) : BLOCK = (
	{declab		=	{block_name = new_block_name,
				flags = flags,
				in_scope = in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
=SML
fun €block_in_scope›  (
	{
	declab as {block_name,
		flags,
		in_scope},
	current_formal_proc,
	current_formal_fun,
	dec_lab,
	spec_lab,
	till
	} : BLOCK,
	new_in_scope : IN_SCOPE) : BLOCK = (
	{declab		=	{block_name = block_name,
				flags = flags,
				in_scope = new_in_scope},
	current_formal_proc = current_formal_proc,
	current_formal_fun = current_formal_fun,
	dec_lab = dec_lab,
	spec_lab = spec_lab,
	till = till
	}
);
=TEX
\subsection{Initial Values}

=TEX
=SML
val €pack_env0› : PACK_ENV = initial_s_dict;
val €subunit_env0› : SUBUNIT_ENV = initial_s_dict;
val €dec_env0› : DEC_ENV = initial_s_dict;
val €spec_env0› : SPEC_ENV = initial_s_dict;
=TEX
$empty\_block$ is the initial value for a block, as loosely specified in \cite{ISS/HAT/DAZ/DTD513}.
Fields which are not specified there are given place-holder values.
All the flags are set false, for convenience in defining $env0$.
It is convenient to define some shared dummy values first:
=SML
val €dummy_spec› : SPEC = {
		w 		= 	[],
		w0		=	[],
		pre		=	ZUserInterfaceSupport.ZTmTruth true,
		post		=	ZUserInterfaceSupport.ZTmTruth true,
		label		=	LImplicit};
val €dummy_informal_fun› : INFORMAL_FUN = {
		name		=	"*dummy fun*",
		formal_pars	=	[],
		return_type	=	"*dummy type*"};
val €dummy_formal_fun› : FORMAL_FUN = {
		informal_fun	=	dummy_informal_fun,
		spec		=	dummy_spec};
val €dummy_formal_proc› : FORMAL_PROC = {
		name		=	"*dummy formal proc*",
		formal_ids	=	[],
		spec		=	dummy_spec};
val €empty_in_scope› : IN_SCOPE = {
		vc_vars		=	[],
		vc_pars		=	[],
		vc_log_cons	=	[],
		formal_procs	=	[],
		dec_labels	=	[]};
val €false_flags› : FLAGS = {
		pack_spec_flag		=	false,
		pack_body_flag		=	false,
		stub_flag		=	false,
		subunit_flag		=	false,
		formal_body_flag	=	false,
		fun_flag		=	false,
		declabel_flag		=	false,
		speclabel_flag		=	false,
		till_flag		=	false};
val €dummy_declab› : DECLAB = {
		block_name	=	"*empty block*",
		flags		=	false_flags,
		in_scope	=	empty_in_scope};
=TEX
=SML
val €empty_block› : BLOCK = 	{
	declab		=	dummy_declab,
	current_formal_proc = dummy_formal_proc,
	current_formal_fun = dummy_formal_fun,
	dec_lab = LImplicit,
	spec_lab = LImplicit,
	till = mk_z_true
};
=TEX
Now we can define $env0$, exploiting the fact that all the flags are set to $false$ in $empty\_block$.
=SML
val €env0› : ENV = [empty_block];
=TEX
We also require initial values for the SPARK program and replacement environments discussed in \cite{ISS/HAT/DAZ/DTD513}
=SML
val €repl_env0› : REPL_ENV = initial_s_dict;
val €spark_prog0› : SPARK_PROG = [];
=TEX
For uniformity, we give the initial value for the theory name component of the global state here.
We use the string ``-'' which by convention in {\Product} means the current theory.
=SML
val €script_name0› : string = "-";
=TEX
\subsection{$flatten\_env$}
To implement $flatten\_env$, we first need a function to merge two $IN\_SCOPE$s.
=SML
fun €merge_in_scopes›
	({	vc_vars = vc_vars1,
		vc_pars = vc_pars1,
		vc_log_cons = vc_log_cons1,
		formal_procs = formal_procs1,
		dec_labels = dec_labels1} : IN_SCOPE)
	({	vc_vars = vc_vars2,
		vc_pars = vc_pars2,
		vc_log_cons = vc_log_cons2,
		formal_procs = formal_procs2,
		dec_labels = dec_labels2} : IN_SCOPE) : IN_SCOPE = (
	{	vc_vars = vc_vars1 @ vc_vars2,
		vc_pars = vc_pars1 @ vc_pars2,
		vc_log_cons = vc_log_cons1 @ vc_log_cons2,
		formal_procs = formal_procs1 @ formal_procs2,
		dec_labels = dec_labels1 @dec_labels2}
);
=TEX
Now we define $flatten\_env$, which uses $merge\_in\_scopes$ to merge all the $in\_scope$ components of the blocks in a running environment.
To avoid unnecessary merging with the empty $in\_scope$ value, the case of a singleton list in the environment is treated separately (the function would compute the same value if the second clause were omitted but would be less efficient with space).

=SML
fun €flatten_env› ([] : ENV) : IN_SCOPE = (
	empty_in_scope
) |  flatten_env [blk] = (
	#in_scope(#declab blk)
) |  flatten_env (blk :: blks) = (
	merge_in_scopes (#in_scope(#declab blk)) (flatten_env blks)
);
=TEX
\subsection{The Global State}
For convenience in the implementation, the eight components of the state are held in eight assignable variables.
=SML
val €pack_env› : PACK_ENV ref = ref pack_env0;
val €subunit_env› : SUBUNIT_ENV ref = ref subunit_env0;
val €dec_env› : DEC_ENV ref = ref dec_env0;
val €spec_env› : SPEC_ENV ref = ref spec_env0;
val €blocks› : ENV ref = ref env0;
val €repl_env› : REPL_ENV ref = ref repl_env0;
val €spark_prog› : SPARK_PROG ref = ref spark_prog0;
val €script_name› : string ref = ref script_name0;
=TEX
The global state may be set from a given value of type $CN\_STATE$ using the following function:
=SML
fun €set_cn_state› ({
		pack_env = new_pack_env,
		subunit_env = new_subunit_env,
		dec_env = new_dec_env,
		spec_env = new_spec_env,
		blocks = new_blocks,
		repl_env = new_repl_env,
		spark_prog = new_spark_prog,
		script_name = new_script_name
	} : CN_STATE) : unit = (
		pack_env := new_pack_env;
		subunit_env := new_subunit_env;
		dec_env := new_dec_env;
		spec_env := new_spec_env;
		blocks := new_blocks;
		repl_env := new_repl_env;
		spark_prog := new_spark_prog;
		script_name := new_script_name
);
=TEX
=SML
fun €get_cn_state› (() : unit) : CN_STATE = (
		{pack_env = !pack_env,
		subunit_env = !subunit_env,
		dec_env = !dec_env,
		spec_env = !spec_env,
		blocks = !blocks,
		repl_env = !repl_env,
		spark_prog = !spark_prog,
		script_name = !script_name}
);
=TEX
\subsection{Accessing the Running Environment}
The function $block$ below implements the 1-based indexing of the running environment which is such a common feature of te Z spec.
=SML
fun €block› (index : int) : BLOCK = (
	(nth (index - 1) (!blocks))
	handle Fail _ => error "test_flag" 507006 []
); 
=TEX
The following function is convenient for accessing the flags in the running environment.
The first parameter is the functions to extract the flag value: it will always be one of the ML built-in selection functions, $\#pack\_spec\_flag$ etc.
The second parameter gives the block to get the flag from: with $1$ identifying the topmost block.
=SML
fun €test_flag› (selector : FLAGS -> bool) (index : int) : bool = (
	(selector o #flags o #declab o block) index
);
=TEX
\subsection{Function Parameter Lists}
When the global variable representing a SPARK function is stored in a theory, a user data entry giving its formal parameter list is also stored.
This is later accessed via the $CN\_ENV$ when function calls using named parameter associations are translated into Z.
=SML
local
val €cn_ud_key› = "CN'formal_pars";
fun €dest_ud_string› (UD_String (n, uds)) = (n, uds)
|   dest_ud_string _ = fail "" 0 [] (* always caught below *);
fun €wanted› (fun_name : ID) (UD_String (i, _)) = (i = fun_name)
|   wanted _ _ = false;
in
fun €get_par_names› (fun_name : Z_ID) : ID list OPT = (
	((Value o map (fst o dest_ud_string) o snd o dest_ud_string o
		switch find (wanted fun_name) o snd o dest_ud_string o
		get_user_datum (get_const_theory fun_name))
	cn_ud_key)
	handle Fail _ => Nil
);
fun €set_par_names› (fun_name : ID) (pars : ID list) : unit = (
	let	val old = (snd o dest_ud_string o get_user_datum "-") cn_ud_key
			handle Fail _ => [];
		val new = 
			UD_String(fun_name, map (fn p => UD_String(p, [])) pars)
			:: (old drop wanted fun_name);
	in	set_user_datum(cn_ud_key, UD_String("", new))
	end
);
end;
=TEX
=IGN
new_const("fruit", BOOL);
get_par_names "fruit";
set_par_names "fruit" ["apple", "banana", "cherry"];
get_par_names "fruit";
set_par_names "fruit" ["apple", "banana", "cherry", "date"];
get_par_names "fruit";
new_const("veg", BOOL);
get_par_names "veg";
set_par_names "veg" ["artichoke", "bean", "carrot"];
get_par_names "veg";
set_par_names "veg" ["leek", "marrow"];
get_par_names "veg";
get_par_names "fruit";
=TEX
\subsection{Constructing $CN\_ENV$s}
The code here must pass type information into the functions defined in \cite{ISS/HAT/DAZ/DTD505,ISS/HAT/DAZ/DTD508} using the data type $CN\_ENV$ defined in \cite{ISS/HAT/DAZ/DTD508}.
The following functions are used to do this.

=SML
fun €z_id_of_id› (n : ID) : Z_ID = (
	(fst o dest_const o mk_z_gvar)(trans_id n, BOOL, [])
);
=TEX
$get\_tmark\_from\_inscope$ searches an $IN\_SCOPE$ value for the type mark associated with a variable or parameter name:
=SML
fun €get_tmark_from_inscope› (n : Z_ID) (inscope : IN_SCOPE) : TMARK OPT = (
	let	fun do_vars [] = Nil
		|   do_vars ({vars, tmark} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_vars more
		);
		fun do_pars [] = Nil
		|   do_pars ({var_decl as {vars, tmark}, mode} :: more) = (
			if	n mem vars
			then	Value tmark
			else	do_pars more
		);
	in	case do_vars (#vc_vars inscope) of
			Nil		=> do_pars (#vc_pars inscope)
		|	value_tmark	=> value_tmark
	end
);
=TEX
Now $get\_tmark\_from\_env$, which searches the running environment using the previous function to look for the required type mark.
=SML
fun €get_tmark_from_env› (_ : Z_ID) ([] : ENV) : TMARK OPT = (
	Nil
) | €get_tmark_from_env› (n : Z_ID) (block :: more) : TMARK OPT = (
	case get_tmark_from_inscope n (#in_scope (#declab block)) of
			Nil		=> get_tmark_from_env n more
		|	value_tmark	=> value_tmark
);
=TEX
Now, if we find a type mark, we need to convert it to an HOL type.
This is done by looking in the theory database.
The type there for a type $\tau$ will be $\tau$.
We must strip off the .
=SML
fun €type_of_tmark› (tmark : TMARK) : TYPE OPT = (
	(case (get_const_type (z_id_of_id(tmark))) of
		Value ty => (Value (dest_z_power_type ty))
	|	Nil => Nil)
	handle Fail _ => Nil
);
=TEX
If we don't find a type mark, then the only possibility is that the name is that of a SPARK function, constant or type stored as a global variable in the theory database.
In this case the stored type is correct as it stands (no  to take away).
=SML
fun €type_of_g_var› (zn : Z_ID) : TYPE OPT = (
	(case get_const_type zn of
		Value ty => (Value ty)
	|	Nil => Nil)
);
=TEX
If we have the a global variable, then we need to classify it as a function, or record type type mark or other sort of SPARK entity.
for a function, we also need the formal parameter list.
To make this classification, we first check to see whether any formal parameters have been associated with the name:
if so, then it's a function and we have the parameter names to hand;
if not, then we dismantle the type: if its a set of bindings, then this is a record type mark; otherwise its an `other'.
=SML
fun €env_info_of_g_var› (zn : Z_ID) (ty : TYPE) = (
	case get_par_names zn of
		Value pars => (ty, EIEnvFunction pars)
	|	Nil => (
		(ty,
		(dest_z_schema_type (dest_z_power_type ty); EIEnvRecord)
		handle Fail _ => EIEnvOther)
	)
);
=TEX
=SML
fun €current_cn_env› (n : ID) : (TYPE * ENV_INFO) OPT = (
	case get_tmark_from_env (trans_id n) (!blocks) of
		Value tmark => (
			case type_of_tmark tmark of
				Value ty => Value (ty, EIEnvVar tmark)
			|	Nil => Nil
	) | 	Nil => (
			case type_of_g_var (z_id_of_id n) of
				Value ty => Value(env_info_of_g_var n ty)
			|	Nil => Nil
	)
);
=TEX
\subsection{Updating the Z Theory Database}
=SML
fun €store_vc_term› (tm : TERM) : unit = (
	let	fun aux i = (
			let val vc_name = "VC_" ^ string_of_int i;
			in	if (get_thm "-" vc_name; false)
						handle Fail _ => true
				then	(save_thm (vc_name, asm_rule tm); ())
				else	aux (i + 1)
			end
		);
	in	aux 1
	end
);
=TEX
=SML
fun €term_of_vc› (vc as (decs, (asms, conc)) : VC) : TERM = (
	mk_z_µ(mk_z_decl decs, list_mk_± asms, conc)
);
=TEX
=SML
fun €store_vcs› (vcs: VC list) : unit = (
	map (store_vc_term o term_of_vc) vcs;
	()
);
=TEX
\section{BASIC DECLARATIONS}\label{BASICDECLARATIONS}
\subsection{The SID Function basic\_declaration}
The decision about which function to call is made in $basic\_declaration$ itself.
=SML
fun €basic_decl_pack_spec› (basic_decl : BASIC_DECL) : unit = (
	let	val block_name1 = #block_name(#declab (block 1));
		val package = case (s_lookup block_name1 (!pack_env)) of
			Value p => p
		|	Nil => error "basic_decl_pack_spec" 507001 [];
	in	pack_env :=
		s_extend
		block_name1
		(package_consts_types(package,
				#consts_types package @ [basic_decl]))
		(!pack_env)
	end
);
=TEX
=SML
fun €basic_decl_otherwise› (basic_decl : BASIC_DECL) : unit = (
	let	val para_infos = trans_basic_decl current_cn_env basic_decl;
	in	map update_theory_db_with_parainfo para_infos; ()
	end
);
=TEX	
=SML
fun €basic_declaration› (basic_decl : BASIC_DECL) : unit = (
	if	test_flag #pack_spec_flag 1
	then	basic_decl_pack_spec basic_decl
	else	basic_decl_otherwise basic_decl
);
=TEX
=SML
fun €var_pack_spec› (var_decl : VAR_DECL) : unit = (
	if	test_flag #pack_spec_flag 1
	then	let	val block_name1 = #block_name(#declab (block 1));
			val package = case (s_lookup block_name1 (!pack_env)) of
				Value p => p
			|	Nil => error "var_pack_spec" 507001 [];
		in	pack_env :=
			s_extend
			block_name1
			(package_vc_vars(package,
					#vc_vars package @ [var_decl]))
			(!pack_env)
		end
	else	()
);
=TEX
\subsection{The SID Function update\_envs\_var}
The decision making as to whether to call the three support functions is done in $update\_envs\_var$ itself (since it is the same test in each case).

In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab1 mem dec_labels
			then	(id1_id2,
				subunit_vc_vars(s, vc_vars grab var_decl))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		fun do1_dec_label
			(dec_label_s as
				(dec_label,
				s as {in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(dec_label,
				declab_vc_vars(s, vc_vars grab var_decl))
			else	dec_label_s
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
The identifiers in the variable declaration are translated first.
=SML
fun €update_spec_env_var› (var_decl : VAR_DECL) : unit = (
	let	val dec_lab1 = #dec_lab (block 1);
		val trans_vars = map trans_id (#vars var_decl);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, vc_vars, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab1 mem dec_labels
			then	(spec_label,
				speclab_w(
					speclab_vc_vars(s, vc_vars grab var_decl),
					trans_vars cup w))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun €update_envs_var› (var_decl : VAR_DECL) : unit = (
	if	test_flag #declabel_flag 1
	then	(update_subunit_env_var var_decl;
		update_dec_env_var var_decl;	
		update_spec_env_var var_decl)
	else	()
);
=TEX
=IGN
val d1 = cn_basic_decl_of_string "x : constant Integer := 42;";
val d2 = cn_basic_decl_of_string "x : constant Integer;";
val d3 = cn_basic_decl_of_string "type zed is range 0 .. 20;";
val d4 = cn_basic_decl_of_string "y : Integer;";
val d5 = cn_basic_decl_of_string "type why is private;";
trans_basic_decl env d5;
=TEX
\subsection{The SID Function add\_var\_env}
=SML
fun €add_var_env› (var_decl : VAR_DECL) : unit = (
	let	val block1 = block 1
			handle Fail _ => error "add_var_env" 507006 [];
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
	in	blocks :=
		block_vc_vars(block1, vc_vars1 grab var_decl):: tl (!blocks)
	end
);
=TEX
\section{DECLARATIONS}\label{DECLARATIONS}
=SML
infix dot;
fun (x : ID) €dot› (y : ID) = x ^ "." ^ y;
=TEX
In the following, $block2$ is bound first to catch possible errors with a corrupt environment.
=SML
fun €k_slot_dec› (label : LABEL) : unit = (
	let	val lab = string_of_label label;
		val block2 = block 2
			handle Fail _ => error "k_slot_dec" 507006 [];
		val block1 = block 1;
		val subunit_flag2 = test_flag #subunit_flag 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val declab = {
			block_name 	=	if	subunit_flag2
						then	block_name2 dot block_name1
						else	block_name1,
			flags		=	#flags(#declab block1),
			in_scope	= 	flatten_env (!blocks)			
		};
	in	dec_env := s_extend lab declab (!dec_env)
		handle Fail _ => fail "k_slot_dec" 507010 [fn () => lab]
	end
);
=TEX
\section{STATEMENTS}\label{STATEMENTS}
\subsection{The SID function spec\_stmt}
The decision about which support function to call is made in $spec\_stmt$ itself.
=SML
fun €spec_stmt_speclabel› (spec : SPEC) : unit = (
	let	val lab = string_of_label (#label spec);
		val block1 = block 1;
		val spec_lab1 = string_of_label(#spec_lab block1);
		val speclab2 = force_value(s_lookup spec_lab1 (!spec_env))
			handle Fail _ =>
			fail "spec_stmt_speclabel" 507014 [fn ()=> spec_lab1];
		val {formal_body_flag, fun_flag, till_flag,
			wp_env as {fun_header, return, ...}, 
			in_scope as {
				vc_vars = vc_vars,
				vc_pars = vc_pars2,
				vc_log_cons = vc_log_cons2,
				dec_labels = dec_labels2,
				formal_procs = formal_procs2}, ...} = speclab2;
		val till = #till block1;
		val env_pars = #vc_pars (flatten_env(!blocks));
		val vc_pars = vc_pars2 @ env_pars;
		val vc_log_cons1 = #vc_log_cons(#in_scope(#declab block1));
		val vc_log_cons = vc_log_cons2 @ vc_log_cons1;
		val wp_env1 :WP_ENV = {
			env = current_cn_env,
			till = till,
			return = return,
			fun_header = fun_header,
			formal_procs = formal_procs2
		};
		val in_scope1 : IN_SCOPE = {
			dec_labels = dec_labels2,
			formal_procs = formal_procs2,
			vc_log_cons = vc_log_cons,
			vc_vars = vc_vars,
			vc_pars = vc_pars			
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1			
		}; 
	in	spec_env := s_extend lab speclab (!spec_env)
		handle Fail _ =>
		fail "spec_stmt_speclabel" 507015 [fn ()=> lab]
	end
);
=TEX
=SML
fun €spec_stmt_otherwise› (spec : SPEC) : unit = (
	let	val lab = string_of_label (#label spec);
		val block1 = block 1;
		val {declab as {flags =
			{formal_body_flag,
			fun_flag,
			till_flag, ...}, ...},
			till,
			current_formal_fun = formal_fun1 as
					{informal_fun = fun_header,
					spec as {post = return, ...}},
			...} = block1;
		val wp_env1 :WP_ENV = {
			env = current_cn_env,
			till = till,
			return = z_predexp_of_z_tm return,
			fun_header = fun_header,
			formal_procs = []
		};
		val in_scope1 : IN_SCOPE = flatten_env(!blocks);
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			till_flag = till_flag,
			wp_env = wp_env1,
			in_scope = in_scope1			
		}; 
	in	spec_env := s_extend lab speclab (!spec_env)
		handle Fail _ =>
		fail "spec_stmt_otherwise" 507015 [fn ()=> lab]
	end
);
=TEX
=SML
fun €spec_stmt› (spec : SPEC) : unit = (
	(if	test_flag #speclabel_flag 1
	then	spec_stmt_speclabel
	else	spec_stmt_otherwise) spec
);
=TEX
\subsection{The SID function k\_slot\_stmt}
=SML
fun €k_slot_stmt› (label : LABEL) : unit = (
	spec_stmt
	{w = [], w0 = [], pre = z_tm_true, post = z_tm_true, label = label}
);
=TEX
\subsection{The SID function add\_log\_con\_env}
=SML
fun €add_log_con_env› (logical_con as {x, t, ...}: LOG_CON) : unit = (
	let	val block1 = block 1;
	 	val zx = trans_id x;
		val zt = z_predexp_of_z_tm t;
		val zvar = mk_z_lvar(zx, (dest_z_power_type o type_of) zt, []);
		val zdecl = mk_z_dec([zvar], zt);
	in	blocks := block_vc_log_cons(block1, [zdecl]) :: tl (!blocks)
	end
);
=TEX
\subsection{The SID function remove\_log\_con\_env}
=SML
fun €remove_log_con_env› (() : unit) : unit = (
	let	val block1 = block 1;
	in	blocks := block_vc_log_cons(block1, []) :: tl (!blocks)
	end
);
=TEX
\section{LOOPS}\label{LOOPS}
\subsection{The SID function new\_scope\_loop}
=SML
fun €new_scope_loop› (() : unit) : unit = (
	let	val block1 = block 1;
		val {declab as {flags as 
			{fun_flag, formal_body_flag, speclabel_flag, ...},
			in_scope, ...},
			current_formal_proc,
			current_formal_fun,
			dec_lab,
			spec_lab,
			till}
				= block 1;
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = formal_body_flag,
			fun_flag = fun_flag,
			declabel_flag = false,
			speclabel_flag = speclabel_flag,
			till_flag = false
		};
		val block = {
			declab	= {
				block_name = "",
				flags = flags,
				in_scope = in_scope},
			current_formal_proc = current_formal_proc,
			current_formal_fun = current_formal_fun,
			dec_lab = dec_lab,
			spec_lab = spec_lab,
			till = till
	}

	in	blocks := block :: !blocks
	end		
);
=TEX

\subsection{The SID function end\_scope}
=SML
fun €end_scope› (():unit) : unit = (
	(blocks := tl (! blocks))
	handle Fail _ => error "end_scope" 507006 []
);
=TEX
\subsection{The SID function for\_param}
=SML
fun €for_param› (i : ID) : unit = (
	let	val block1 = block 1;
		val param_spec = (
			{mode = MSparkIn, var_decl = {vars = [i], tmark = "˙"}}
		);
	in	blocks := block_vc_pars (block1, [param_spec]) :: !blocks
	end
);
=TEX
\subsection{The SID function till\_pred}
=SML
fun €till_pred› (till : Z_PRED) : unit = (
	let	val block1 = block 1;
	in	blocks := block_till (block_till_flag(block1, true), till)
		:: !blocks
	end
);
=TEX
\section{SUBPROGRAM DECLARATIONS}\label{SUBPROGRAMDECLARATIONS}
The SID function $end\_scope$ used in processing these has already been defined in section \ref{LOOPS}.
\section{PROCEDURES}\label{PROCEDURES}
\subsection{The SID function subunit\_form}
This SID function and the next are best handled by a common function with a parameter to determine what to do:
=SML
fun €subunit_form_inf_aux› (ident : ID, is_inf : bool) : unit = (
	let	val block = hd(!blocks);
		val block_name = #block_name(#declab block);
		val bn_id = block_name dot ident;
		val subunit1 = (force_value(s_lookup bn_id (!subunit_env)))
			handle Fail _ =>
			error "subunit_form_inf_aux" 507011 [fn()=>bn_id];
		val in_scope' = #in_scope subunit1;
		val block' = block_in_scope(block, in_scope');
	in	blocks := block' :: tl (!blocks);
		if	is_inf
		then	subunit_env := s_delete bn_id (!subunit_env)
		else	()
	end
);
=TEX
=SML
fun €subunit_form› (ident : ID) : unit = (
	subunit_form_inf_aux (ident, false)
);
=TEX
\subsection{The SID function subunit\_inf}
=SML
fun €subunit_inf› (ident : ID) : unit = (
	subunit_form_inf_aux (ident, true)
);
=TEX
\subsection{The SID function new\_scope\_proc\_inf}
=SML
fun €new_scope_proc_inf› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_proc\_inf}
=SML
fun €new_scope_proc_form› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = true,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_fun\_inf}
In the following the call to the {\Product} function $duplicate\_theory$ creates a new theory which is a copy of the current theory.
This corresponds to $make\_module$ as used in the Z spec.
=SML
fun €stub› (() : unit) : unit = (
	if	test_flag #stub_flag 2
	then	let	val block1 = block 1;
			val block2 = block 2;
			val block3 = block 3;
			val block_name1 = #block_name (#declab block1);
			val block_name2 = #block_name (#declab block2);
			val block_name3 = #block_name (#declab block3);
			val id2 = block_name1;
			val id1 =
				if	test_flag #subunit_flag 3
				then	block_name3 dot block_name2
				else	block_name2;
			val id1_id2 = id1 dot id2;
			val subunit = {
				in_scope	=	flatten_env(!blocks),
				specif		=	dummy_spec,
				specif_flag	=	false,			
				zmod		=	id1_id2
			};
		in	duplicate_theory("-", id1_id2)
			handle Fail _ => fail "stub" 507013 [fn() => id1_id2];
			subunit_env := s_enter id1_id2 subunit (!subunit_env)
		end
	else	()
);
=TEX
The following does the main work for $stub\_spec\_proc$ and $stub\_spec\_fun$.
=SML
fun €stub_spec_proc_fun› (spec : SPEC) : unit = (
	if	test_flag #stub_flag 2
	then	let	val block1 = block 1;
			val block2 = block 2;
			val block3 = block 3;
			val block_name1 = #block_name (#declab block1);
			val block_name2 = #block_name (#declab block2);
			val block_name3 = #block_name (#declab block3);
			val id2 = block_name1;
			val id1 =
				if	test_flag #subunit_flag 3
				then	block_name3 dot block_name2
				else	block_name2;
			val id1_id2 = id1 dot id2;
			val subunit = force_value(s_lookup id1_id2 (!subunit_env))
				handle Fail _ =>
				error "stub_spec_proc_fun" 507011 [fn()=>id1_id2];
			val subunit' = {
				in_scope	=	#in_scope subunit,
				specif		=	spec,
				specif_flag	=	true,			
				zmod		=	#zmod subunit
			};
		in	subunit_env := s_enter id1_id2 subunit' (!subunit_env)
		end
	else	()
);
=TEX
=SML
fun €stub_spec_proc› (form_proc : FORMAL_PROC) : unit = (
	stub_spec_proc_fun (#spec form_proc)
);
=TEX
\subsection{The SID function form\_proc}
=SML
fun €form_proc_pack_spec› (form_proc: FORMAL_PROC) : unit = (
	let	val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_proc_pack_spec" 507012 [fn()=>block_name2];
		val formal_procs = #formal_procs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_formal_procs(package,
				formal_procs @ [form_proc]))
		(!pack_env)
	end
);
=TEX
=TEX
The VC generator is responsible for distinguishing specification between statements with and without initial variables.
Here, we follow the parser in generating the form without initial variables for it to modify as necessary.
=SML
fun €form_proc_pack_body› (form_proc: FORMAL_PROC) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package4 = (force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_fun_pack_body" 507012 [fn()=>block_name2];
		val formal_procs4 = #formal_procs package4;
	in	if	any
			formal_procs4
			(fn p => #name p = block_name2)
		then	
	let
		val formal_proc3 =
			find 
			formal_procs4
			(fn p => #name p = block_name2)
		val st = SStmt(STSpecNoIvars(#spec form_proc));
		val vc_vars2 = #vc_vars(#in_scope(#declab block2));
		val vc_vars4 = #vc_vars(package4);
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val wp_env5 :WP_ENV = {
			env = current_cn_env,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = []
		};
		val in_scope5 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_vars = vc_vars4 @ vc_vars2,
			vc_pars = vc_pars1			
		}
		val speclab5 : SPECLAB = {
			spec = #spec formal_proc3,
			formal_body_flag = false,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env5,
			in_scope = in_scope5
		};
	in	store_vcs (vcs(speclab5, st))
	end
		else	()
	end
);
=TEX
=SML
fun €form_proc_subunit› (form_proc: FORMAL_PROC) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val bn1_bn2 = block_name2 dot block_name1
		val subunit3 = (force_value(s_lookup bn1_bn2 (!subunit_env)))
			handle Fail _ =>
			error "form_fun_subunit" 507011 [fn()=>bn1_bn2];
	in	subunit_env := s_delete bn1_bn2 (!subunit_env);
		if	#specif_flag subunit3
		then	
	let
		val st = SStmt(STSpecNoIvars(#spec form_proc));
		val vc_vars3 = #vc_vars(#in_scope(subunit3));
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val wp_env4 :WP_ENV = {
			env = current_cn_env,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = []
		};
		val in_scope4 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_vars = vc_vars3,
			vc_pars = vc_pars1			
		}
		val speclab4 : SPECLAB = {
			spec = #specif subunit3,
			formal_body_flag = false,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env4,
			in_scope = in_scope4
		};
	in	store_vcs (vcs(speclab4, st))
	end
		else	()
	end
);
=TEX
=SML
fun €form_proc› (form_proc: FORMAL_PROC) : unit = (
	(if		test_flag #pack_spec_flag 2
	then		form_proc_pack_spec
	else if		test_flag #pack_body_flag 2
	then		form_proc_pack_body
	else if		test_flag #subunit_flag 2
	then		form_proc_subunit
	else		(fn _ => ())) form_proc
);
=TEX
\subsection{The SID function curr\_form\_proc}
=SML
fun €curr_form_proc› (formal_proc : FORMAL_PROC) : unit = (
	let	val block1 = block 1;
	in	blocks :=
		block_current_formal_proc (block1, formal_proc) :: tl(!blocks)
	end
);
=TEX
\section{FUNCTIONS}\label{FUNCTIONS}
\subsection{The SID function new\_scope\_fun\_inf}
=TEX
=SML
fun €new_scope_fun_inf› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = true,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function new\_scope\_fun\_form}
=TEX
=SML
fun €new_scope_fun_form› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = true,
			fun_flag = true,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end		
);
=TEX
\subsection{The SID function stub\_spec\_fun}
=SML
fun €stub_spec_fun› (form_fun : FORMAL_FUN) : unit = (
	stub_spec_proc_fun (#spec form_fun)
);
=TEX
\subsection{The SID function inf\_fun}
=SML
fun €cart_prod› (par_specs : PARAM_SPEC list) : Z_EXP = (
	let	fun aux (par_spec : PARAM_SPEC) = (
			(zid current_cn_env o trans_id o #tmark o #var_decl)
			par_spec
		);
	in	case par_specs of
			[]	=>	error "cart_prod" 507009 []
		|	[ps]	=>	aux ps
		|	several =>	mk_z_∏ (map aux par_specs)
	end
);
=TEX
=SML
fun €fun_decl› ({name, formal_pars, return_type} : INFORMAL_FUN) : Z_DECL = (
	let	val zn = trans_id name;
		val z_ret_ty = zid current_cn_env (trans_id return_type);
		val zexp = (
			case formal_pars of
				[] => z_ret_ty
			|	non_empty => z_tfun(cart_prod formal_pars,
						 z_ret_ty));
		val zvar = mk_z_lvar(zn, (dest_z_power_type o type_of) zexp, []);
	in	mk_z_dec([zvar], zexp)
	end
);
=TEX
The decision of which of the following two functions to call is made in $inf\_fun$
=SML
fun €inf_fun_pack_spec› (inf_fun: INFORMAL_FUN) : unit = (
	let	val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "inf_fun_pack_spec" 507012 [fn()=>block_name2];
		val informal_funs = #informal_funs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_informal_funs(package,
				informal_funs @ [inf_fun]))
		(!pack_env)
	end
);
=TEX
=SML
fun €trans_informal_fun› (f: INFORMAL_FUN) : PARAINFO = (
	let	val dec = fun_decl f;
		val ntys = (map dest_var o fst o dest_z_dec) dec;
	in	AxDesInfo([], mk_z_decl[dec], Nil, ntys)
	end
);
=TEX
=SML
fun €inf_fun_otherwise› (inf_fun: INFORMAL_FUN) : unit = (
	update_theory_db_with_parainfo(trans_informal_fun inf_fun)
);
=TEX
=SML
fun €inf_fun› (informal_fun: INFORMAL_FUN) : unit = (
	(if	test_flag #pack_spec_flag 2
	then	inf_fun_pack_spec
	else	inf_fun_otherwise) informal_fun
);
=TEX
\subsection{The SID function form\_fun}
The decision of which of the four cases to apply is made in $form\_fun$
=SML
fun €form_fun_pack_spec› (form_fun: FORMAL_FUN) : unit = (
	let	val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package =
			(force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_fun_pack_spec" 507012 [fn()=>block_name2];
		val formal_funs = #formal_funs package;
	in	pack_env :=
		s_enter
		block_name2
		(package_formal_funs(package,
				formal_funs @ [form_fun]))
		(!pack_env)
	end
);
=TEX
=SML
fun €z_decls› (par_specs : PARAM_SPEC list) : Z_DECL list = (
	let	fun aux1 ({vars, tmark} : VAR_DECL) : Z_DECL = (
			let	val e = (zid current_cn_env o trans_id) tmark;
				val ty = (dest_z_power_type o type_of) e;
				fun v var = mk_z_lvar(var, ty, []);
			in	mk_z_dec(map v vars, e)
			end
		);
	in	map (aux1 o #var_decl) par_specs
	end
);
=TEX
=SML
fun €trans_formal_fun› ({spec as {pre, post, ...},
			informal_fun as {formal_pars, ...}} : FORMAL_FUN)
				: PARAINFO = (
	let	val dec = fun_decl informal_fun;
		val ntys = (map dest_var o fst o dest_z_dec) dec;
		val imp = z_imp(z_predexp_of_z_tm pre, z_predexp_of_z_tm post);
		val pred = (
			case formal_pars of
				[] => imp
			|	non_empty => z_forall(z_decls formal_pars, imp));
	in	AxDesInfo([], mk_z_decl[dec], Value pred, ntys)
	end
);
=TEX
The VC generator is responsible for distinguishing specification between statements with and without initial variables.
Here, we follow the parser in generating the form without initial variables for it to modify as necessary.
=SML
fun €form_fun_pack_body› (form_fun: FORMAL_FUN) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name2 = #block_name(#declab block2);
		val package4 = (force_value(s_lookup block_name2 (!pack_env)))
			handle Fail _ =>
			error "form_fun_pack_body" 507012 [fn()=>block_name2];
		val formal_funs4 = #formal_funs package4;
	in	update_theory_db_with_parainfo(trans_formal_fun form_fun);
		if	any
			formal_funs4
			(fn f => #name(#informal_fun f) = block_name2)
		then	
	let
		val formal_fun3 =
			find 
			formal_funs4
			(fn f => #name(#informal_fun f) = block_name2);
		val st = SStmt(STSpecNoIvars(#spec form_fun));
		val vc_pars1 = #vc_pars (#in_scope (#declab block1));
		val wp_env5 :WP_ENV = {
			env = current_cn_env,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = #informal_fun form_fun,
			formal_procs = []
		};
		val in_scope5 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_vars = [],
			vc_pars = vc_pars1			
		}
		val speclab5 : SPECLAB = {
			spec = #spec formal_fun3,
			formal_body_flag = false,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env5,
			in_scope = in_scope5
		};
	in	store_vcs (vcs(speclab5, st))
	end
		else	()
	end
);
=TEX
=SML
fun €form_fun_subunit› (form_fun: FORMAL_FUN) : unit = (
	let	val block1 = block 1;
		val block2 = block 2;
		val block_name1 = #block_name(#declab block1);
		val block_name2 = #block_name(#declab block2);
		val bn1_bn2 = block_name2 dot block_name1
		val subunit3 = (force_value(s_lookup bn1_bn2 (!subunit_env)))
			handle Fail _ =>
			error "form_fun_subunit" 507011 [fn()=>bn1_bn2];
	in	update_theory_db_with_parainfo(trans_formal_fun form_fun);
		subunit_env := s_delete bn1_bn2 (!subunit_env);
		if	#specif_flag subunit3
		then	
	let
		val st = SStmt(STSpecNoIvars(#spec form_fun));
		val wp_env4 :WP_ENV = {
			env = current_cn_env,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = #informal_fun form_fun,
			formal_procs = []
		};
		val in_scope4 = {
			dec_labels = [],
			formal_procs = [],
			vc_log_cons = [],
			vc_vars = [],
			vc_pars = []			
		}
		val speclab4 : SPECLAB = {
			spec = #specif subunit3,
			formal_body_flag = false,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env4,
			in_scope = in_scope4
		};
	in	store_vcs (vcs(speclab4, st))
	end
		else	()
	end
);
=TEX
=SML
fun €form_fun_otherwise› (form_fun: FORMAL_FUN) : unit = (
	update_theory_db_with_parainfo(trans_formal_fun form_fun)
);
=TEX
=SML
fun €form_fun› (form_fun: FORMAL_FUN) : unit = (
	(if		test_flag #pack_spec_flag 2
	then		form_fun_pack_spec
	else if		test_flag #pack_body_flag 2
	then		form_fun_pack_body
	else if		test_flag #subunit_flag 2
	then		form_fun_subunit
	else		form_fun_otherwise) form_fun
);
=TEX
\subsection{The SID function curr\_form\_fun}
=SML
fun €curr_form_fun› (formal_fun : FORMAL_FUN) : unit = (
	let	val block1 = block 1;
	in	blocks :=
		block_current_formal_fun (block1, formal_fun) :: tl(!blocks)
	end
);
=TEX
\section{FORMAL PARAMETERS}\label{FORMALPARAMETERS}
\subsection{The SID function formal\_part}
=TEX
=SML
fun €mk_param_spec› ({idlist, mode, name} : PARAMETER_SPECIFICATION)
		: PARAM_SPEC = (
	{mode = mode, var_decl = {vars = idlist, tmark = name}}
);
=TEX
=SML
fun €formal_part› (par_specs : PARAMETER_SPECIFICATION list) : unit = (
	let	val block1 = block 1;
		val formals = map mk_param_spec par_specs;
	in	blocks := block_vc_pars (block1, formals) :: tl(!blocks)
	end
);
=TEX

\section{SUBPROGRAM BODIES}\label{SUBPROGRAMBODIES}
\subsection{The SID function update\_envs\_proc}
The decision whether to call the three auxiliary functions is made in $update\_envs\_proc$ itself (since the test is the same in each case).

In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_proc› (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_subunit
			(id1_id2_s as
				(id1_id2,
				s as {in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * SUBUNIT) = (
			if	dec_lab2 mem dec_labels
			then	(id1_id2,
				subunit_formal_procs(s,
					current_formal_proc1 :: formal_procs))
			else	id1_id2_s
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_proc› (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_dec_label
			(dec_label_d as
				(dec_label,
				d as {in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * DECLAB) = (
			if	dec_lab2 mem dec_labels
			then	(dec_label,
				declab_formal_procs(d, 
					current_formal_proc1 :: formal_procs))
			else	dec_label_d
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
The identifiers in the variable declaration are translated first.
=SML
fun €update_spec_env_proc› (() : unit) : unit = (
	let	val dec_lab2 = #dec_lab (block 2);
		val current_formal_proc1 = #current_formal_proc(block 1);
		fun do1_spec_label
			(spec_label_s as
				(spec_label,
				s as {spec as {w, ...},
					in_scope as {dec_labels, formal_procs, ...}, ...})
					: string * SPECLAB) = (
			if	dec_lab2 mem dec_labels
			then	(spec_label,
				speclab_formal_procs(s, 
					current_formal_proc1 :: formal_procs))
			else	spec_label_s
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
The schema conjunction from the specification is implemented as sequential composition.
=SML
fun €update_envs_proc› (() : unit) : unit = (
	if	test_flag #declabel_flag 2 andalso test_flag #formal_body_flag 1
	then	(update_subunit_env_proc ();
		update_dec_env_proc ();	
		update_spec_env_proc ())
	else	()
);
=TEX
\subsection{The SID function add\_proc\_env}
=SML
fun €add_proc_env› (() : unit) : unit = (
	if	test_flag #formal_body_flag 1
	then	let	val block1 = block 1;
			val current_formal_proc1 =
					#current_formal_proc(block 1);
			val block2 = block 2;
			val formal_procs2 =
					#formal_procs(#in_scope(#declab block2));
			val block2' = block_formal_procs(block2,
					current_formal_proc1 :: formal_procs2);
		in	blocks := block1 :: block2' :: tl(tl(!blocks))
		end
	else	()
);
=TEX
\subsection{The SID function vcs\_body}
The decision about which support function to call (if any) is made in $vcs\_body$ itself.

=SML
fun €vcs_body_proc› (st : STATEMENT) : unit = (
	let	val block1 = block 1;
		val current_formal_proc1 = #current_formal_proc block1;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val pre1 = #pre(#spec current_formal_proc1);
		val post1 = #post(#spec current_formal_proc1);
		val w1 = #w(#spec current_formal_proc1);
		val w = flat (map (map trans_id o #vars) vc_vars1);
		val in_scope = flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val wp_env :WP_ENV = {
			env = current_cn_env,
			till = mk_z_true,
			return = mk_z_true,
			fun_header = dummy_informal_fun,
			formal_procs = formal_procs
		};
		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "â0") w,
			pre = pre1,
			post = post1,
			label = #spec_lab block1
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = false,
			fun_flag = false,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope
		};
	in	store_vcs(vcs(speclab, st))
	end	
);
=TEX
=SML
fun €vcs_body_fun› (st : STATEMENT) : unit = (
	let	val block1 = block 1;
		val current_formal_fun1 = #current_formal_fun block1;
		val vc_vars1 = #vc_vars(#in_scope(#declab block1));
		val pre1 = #pre(#spec current_formal_fun1);
		val post1 = #post(#spec current_formal_fun1);
		val w1 = #w(#spec current_formal_fun1);
		val w = flat (map (map trans_id o #vars) vc_vars1);
		val in_scope = flatten_env (!blocks);
		val formal_procs = #formal_procs in_scope;
		val wp_env :WP_ENV = {
			env = current_cn_env,
			till = mk_z_true,
			return = z_predexp_of_z_tm post1,
			fun_header = #informal_fun current_formal_fun1,
			formal_procs = formal_procs
		};
		val spec : SPEC = {
			w = w,
			w0 = map (fn n => n ^ "â0") w,
			pre = pre1,
			post = post1,
			label = #spec_lab block1
		};
		val speclab : SPECLAB = {
			spec = spec,
			formal_body_flag = true,
			fun_flag = true,
			till_flag = false,
			wp_env = wp_env,
			in_scope = in_scope
		};
	in	store_vcs(vcs(speclab, st))
	end	
);
=TEX
=SML
fun €vcs_body› (st : STATEMENT) : unit = (
	if	test_flag #formal_body_flag 1
	then	if	test_flag #fun_flag 1
		then	vcs_body_fun st
		else	vcs_body_proc st
	else	()
);
=TEX
\section{PACKAGES}\label{PACKAGES}
\subsection{The SID function new\_scope\_pack\_spec}
=SML
val €empty_package› : PACKAGE = 
	{	vc_vars		=	[],
		consts_types	=	[],
		formal_procs	=	[],
		informal_funs	=	[],
		formal_funs	=	[]	};
=TEX
=SML
fun €new_scope_pack_spec› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = true,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks;
		pack_env := s_extend ident empty_package (!pack_env) 
	end	handle Fail _ => fail "new_scope_pack_spec" 507007 [fn () => ident]
);
=TEX
\subsection{The SID function new\_scope\_pack\_body}
=SML
fun €new_scope_pack_body› (ident : ID) : unit = (
	let	val package1 = force_value(s_lookup ident (!pack_env));
		val flags = {
			pack_spec_flag = true,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val vc_vars1 = #vc_vars package1;
		val block = block_vc_vars(empty_block, vc_vars1);
		val consts_types = #consts_types package1;
		val side_effect = (blocks := block :: !blocks);
		val para_infos = flat (map (trans_basic_decl current_cn_env) consts_types);
	in	map update_theory_db_with_parainfo para_infos; ()
	end	handle Fail _ => fail "new_scope_pack_body" 507008 [fn () => ident]	
);
=TEX
\subsection{The SID function new\_scope\_with}
=SML
fun €new_scope_with› (ident : ID) : unit = (
	diag_line "***** NOT YET IMPLEMENTED ---- TBS ****"
);
=TEX
\subsection{The SID function end\_scope\_comp\_unit}
=SML
fun €end_scope_comp_unit› ((): unit) : unit = (
	blocks := [block 1]
);
=TEX
\section{STUBS AND SUBUNITS}\label{STUBSANDSUBUNITS}
\subsection{The SID function begin\_stub}
=SML
fun €begin_stub› (():unit) : unit = (
	let	val block1 = block 1;
	in	blocks :=  block_stub_flag (block1, true) :: tl (!blocks)
	end	handle Fail _ => error "begin_stub" 507006 []
);
=TEX
\subsection{The SID function end\_stub}
=SML
fun €end_stub› (():unit) : unit = (
	let	val block1 = block 1;
	in	blocks :=  block_stub_flag (block1, false) :: tl (!blocks)
	end	handle Fail _ => error "begin_stub" 507006 []
);
=TEX
\subsection{The SID function new\_scope\_subunit}
=SML
fun €new_scope_subunit› (ident : ID) : unit = (
	let	val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = true,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = false,
			till_flag = false
		};
		val block = block_block_name(
				block_flags(empty_block, flags), ident);
	in	blocks := block :: !blocks
	end
);
=TEX
\section{WEB CLAUSES}\label{WEBCLAUSES}
=TEX
\subsection{THE SID function new\_scope\_dec\_replace}
In the following, those fields for the new block which are left undefined in the Z specification are borrowed from the empty block value.
=SML
fun €new_scope_dec_replace› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	val lab = string_of_label label;
	in
	case s_lookup lab (!dec_env) of
		Value declab => (
			let	val block = {
		declab = declab,
		current_formal_proc = #current_formal_proc empty_block,
		current_formal_fun = #current_formal_fun empty_block,
		dec_lab = label,
		spec_lab = #spec_lab empty_block,
		till = #till empty_block};
			in	blocks := block :: !blocks;
				dec_env := s_delete lab (!dec_env)
			end
	) |	Nil => fail "new_scope_dec_replace" 507002
			[fn () => lab]
	end
);
=TEX
\subsection{THE SID function update\_envs\_remove\_declabel}
In the following, the local function, $do1\_subunit$ does the work specified in the Z spec for one unit-name-subunit-name pair.
=SML
fun €update_subunit_env_remove_declabel›
		({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_subunit
			((id1_id2,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SUBUNIT) = (
			(id1_id2,
			subunit_dec_labels(s, dec_labels less label))
		);
	in	subunit_env := map do1_subunit (!subunit_env)
	end
);
=TEX
In the following, the local function, $do1\_dec\_label$ does the work specified in the Z spec for one dec label.
=SML
fun €update_dec_env_remove_declabel› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_dec_label
			((dec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * DECLAB) = (
			(dec_label,
			declab_dec_labels(s, dec_labels less label))
		);
	in	dec_env := map do1_dec_label (!dec_env)
	end
);
=TEX
In the following, the local function, $do1\_spec\_label$ does the work specified in the Z spec for one spec label.
=SML
fun €update_spec_env_remove_declabel› ({label, decls} : REPLACED_BY_DECL) : unit = (
	let	fun do1_spec_label
			((spec_label,
				s as {in_scope as {dec_labels, ...}, ...})
					: string * SPECLAB) = (
			(spec_label,
			speclab_dec_labels(s, dec_labels less label))
		);
	in	spec_env := map do1_spec_label (!spec_env)
	end
);
=TEX
=SML
fun €update_envs_remove_declabel› (label_decls : REPLACED_BY_DECL) : unit = (
	update_subunit_env_remove_declabel label_decls;
	update_dec_env_remove_declabel label_decls;	
	update_spec_env_remove_declabel label_decls
);
=TEX
\subsection{THE SID function new\_scope\_speclabel}
=SML
fun €new_scope_speclabel› (label : LABEL) : unit = (
	let	val lab = string_of_label label;
		val spec_env_lab = force_value( s_lookup lab (!spec_env) )
			handle Fail _ => fail "new_scope_speclabel" 507003
				[fn () => lab];
		val till_flag = #till_flag spec_env_lab;
		val till = #till (#wp_env (spec_env_lab));
		val flags = {
			pack_spec_flag = false,
			pack_body_flag = false,
			stub_flag = false,
			subunit_flag = false,
			formal_body_flag = false,
			fun_flag = false,
			declabel_flag = false,
			speclabel_flag = true,
			till_flag = till_flag
		};
		val block =	block_till(
					block_spec_lab(
						block_flags(empty_block, flags),
					label),
				till);
	in	blocks := block :: !blocks
	end
);
=TEX
\subsection{THE SID function vcs\_speclabel}
The following follows the specification in fishing the label out of the environment (although it will be the same as the label in the argument).
=SML
fun €vcs_speclabel› ({label = unused, statement} :REFINED_BY) : unit = (
	let	val lab = string_of_label (#spec_lab(block 1));
		val spec_env_lab = force_value( s_lookup lab (!spec_env) )
			handle Fail _ => fail "vcs_speclabel" 507003
				[fn () => lab];
	in	store_vcs (vcs (spec_env_lab, statement))
	end
);
=TEX
\subsection{THE SID function end\_scope\_speclabel}
=SML
fun €end_scope_speclabel› (():unit) : unit = (
	let	val lab = string_of_label (#spec_lab(block 1));
	in	end_scope();
		spec_env := s_delete lab (!spec_env)
	end
);
=TEX
\subsection{THE SID functions new\_scope\_stmtlabel and end\_scope\_stmt\_label}
=SML
val €new_scope_stmt_label›: LABEL -> unit = new_scope_speclabel;
val €end_scope_stmt_label›: unit -> unit = end_scope_speclabel;
=TEX
\section{SPARK PROGRAM ENVIRONMENT}
\subsection{The SID Function update\_replacement\_env}
TBS - the error reporting here could usefully be made more sophisticated.
(By checking that $repl$ and the replacement environment entry are of the same sort.)
=SML
fun €update_replacement_env› ((label, repl) : LABEL * REPLACEMENT) : unit = (
	let	val lab = string_of_label label;
		val msg_no =
			case s_lookup lab (!repl_env) of
				Value(UnReplaced (_, name)) => 0
			|	Value _ => 507004
			|	Nil => 507003;
		val side_effect =
				if	msg_no <> 0
				then	warn "update_replacement_env" 507003
					[fn () => lab]
				else	();
	in	repl_env := s_enter lab repl (!repl_env)
	end
);
=TEX
=SML
fun €update_spark_prog› (comp : KSLOT_COMPILATION_UNIT list) : unit = (
	spark_prog := !spark_prog @ comp
);
=TEX
=SML
fun €new_k_slot› (label : LABEL, sort : REPL_SORT, theory : string) : unit = (
	let	val lab = string_of_label label;
	in	(repl_env := s_enter lab (UnReplaced (sort, theory)) (!repl_env))
			handle Fail _ => fail "new_k_slot" 507005 [fn () => lab]
	end
);
=TEX
\section{INTERFACE}
The following function is called from \cite{ISS/HAT/DAZ/IMP504} to classify a label.
=SML
fun €classify_label› (lab : string) : REPL_SORT OPT = (
	case s_lookup lab (!repl_env) of
		Value(UnReplaced(rs, _)) => Value rs
	|	_ => Nil
);
=TEX
=SML
fun €get_replacement› (lab : string) : REPLACEMENT OPT = (
	s_lookup lab (!repl_env)
);
=TEX
For various reasons, the command for opening a theory in {\Product} does some work even if the theory being opened is already current.
Since in CN processing the theory may change a lot, we use a more optimal approach here:
=SML
fun €lazy_open_theory› (thy : string) : unit = (
	if	thy = "-" orelse thy = get_current_theory_name()
	then	()
	else	open_theory thy
);
=TEX
=SML
fun €open_label_theory› (lab : string) : unit = (
	case s_lookup lab (!repl_env) of
		Value(UnReplaced(_, thy)) => lazy_open_theory thy
	|	_ => ()
);
=TEX
The abstract syntax separates two forms of for-loop which are processed identically here.
The following function does the common processing.
=SML
fun €do_for_loop› (i : ID, stmt : STMT, dir : LOOP_DIRECTION) = (
	if	dir = LDForwards
	then	(new_scope_loop();
		for_param i;
		do_stmt stmt;
		end_scope())
	else	(comment "do_stmt" 507012 [];
		do_stmt stmt)
)
(*
=TEX
The following reflects the SID functions for $statement$ (see also $do\_statement$), $loop\_statement$ and $loop\_parameter\_specification$.

To have the same order of invocation of the SID functions for for- and while- loop statements as in the specification, it is necessary to ``expand in line'' the processing for their constituent loops.
=SML
*)
and €do_stmt› (y as STNull : STMT) = (
) | do_stmt (y as STImplicitNull : STMT) = (
) | do_stmt (y as (STAssign x) : STMT) = (
) | do_stmt (y as (STSpecNoIvars x) : STMT) = (
	new_k_slot(#label x, RSStatement, get_current_theory_name());
	spec_stmt x
) | do_stmt (y as (STSemicolon (x1, x2)) : STMT) = (
	do_stmt x1;
	do_stmt x2
) | do_stmt (y as (STIfThenElse {p, q, ...}) : STMT) = (
	do_stmt p;
	do_stmt q
) | do_stmt (y as (STCase {s, others, ...}) : STMT) = (
	map (do_stmt o #p) s;
	do_stmt others
) | do_stmt (y as (STLoop {t, stmt}) : STMT) = (
	new_scope_loop();
	do_stmt stmt;
	end_scope()
) | do_stmt (y as (STNamedLoop {t, stmt, ...}) : STMT) = (
	do_stmt (STLoop {t = t, stmt = stmt})
) | do_stmt (y as (STWhile {loop as {t, stmt}, ...}) : STMT) = (
	do_stmt (STLoop {t = t , stmt = stmt})
) | do_stmt (y as (STForStatic {i, loop as {stmt, ...}, dir, ...}) : STMT) = (
	do_for_loop(i, stmt, dir)
) | do_stmt (y as (STForTmark {i, loop as {stmt, ...}, dir, ...}) : STMT) = (
	do_for_loop(i, stmt, dir)
) | do_stmt (y as (STExitWhen x) : STMT) = (
) | do_stmt (y as STExit : STMT) = (
) | do_stmt (y as (STRet x) : STMT)  = (
) | do_stmt (y as (STProcNoIvars x) : STMT) = (
) | do_stmt (y as (STKSlot {label, content}) : STMT) = (
	new_k_slot(label, RSStatement, get_current_theory_name());
	k_slot_stmt label
);
=TEX
The following reflects the SID functions for $statement$ (see also $do\_stmt$).
Note that the parser is not expected to produce the $SSpecIvars$, $SForNonStatic$ or $SProcIvars$ alternatives, since it cannot carry out the necessary analysis of free variables.
It uses the $STMT$ forms to carry the information on, since the $STATEMENT$ form is inadequately general.
The $STATEMENT$ alternatives are produced where necessary in the VC generator.
=SML
fun €do_statement› (y as (SStmt x) : STATEMENT) = (
	do_stmt x
) | do_statement (y as (SSpecIvars x) : STATEMENT) = (
	error "do_statement" 507019 []
) | do_statement (y as (SForNonStatic x) : STATEMENT) = (
	error "do_statement" 507019 []
) | do_statement (y as (SLogCon (log_con, stmt)) : STATEMENT) = (
	new_k_slot(#label(#spec(log_con)),
		RSStatement, get_current_theory_name());
	add_log_con_env log_con;
	spec_stmt (#spec log_con);
	remove_log_con_env()
) | do_statement (y as (SProcIvars x) : STATEMENT) = (
	error "do_statement" 507019 []
);
=TEX
=SML
fun €do_declaration› (y as (DDeclarationKSlot 
	{label, content}) : DECLARATION) = (
	new_k_slot(label, RSDeclaration, get_current_theory_name());
	k_slot_dec label
) | do_declaration (y as (DRenamingDeclaration x) : DECLARATION) = (
	comment "do_declaration" 507016 []
) | do_declaration (y as (DBasicDecl x) : DECLARATION) = (
	case x of
		BDTypeDecl _ => (basic_declaration x
	) |	BDSubtypeDecl _ => (basic_declaration x
	) |	BDConstDecl _ => (basic_declaration x
	) |	BDVarDecl v => (
			var_pack_spec v;
			update_envs_var v;
			add_var_env v
	) |	BDDeferredConstDecl _ => (comment "do_declaration" 507021 []
	) |	BDPrivateTypeDecl _ => (comment "do_declaration" 507022 []
	)
) | do_declaration (y as (DRepresentationClause x) : DECLARATION) = (
	comment "do_declaration" 507017 []
) | do_declaration (y as (DProperBody x) : DECLARATION) = (
	do_proper_body x
) | do_declaration (y as (DProcedureDeclaration x) : DECLARATION) = (
	do_procedure_spec x
) | do_declaration (y as (DFunctionDeclaration x) : DECLARATION) = (
	do_function_spec x
) | do_declaration (y as (DPackageDeclaration x) : DECLARATION) = (
	do_package_spec x
) | do_declaration (y as (DProcedureStub x) : DECLARATION) = (
	do_procedure_stub x
) | do_declaration (y as (DFunctionStub x) : DECLARATION) = (
	do_function_stub x
) | do_declaration (y as (DPackageStub x) : DECLARATION) = (
	do_package_stub x
)
(*
=TEX
The following reflects the SID functions for $procedure\_specification$:
=SML
*)
and €do_procedure_spec› (
	{name, formal_part, spec as Value sp} : PROCEDURE_SPECIFICATION) = (
	let	 val formal_proc : FORMAL_PROC =
		{name=name, spec=sp, formal_ids = map mk_param_spec formal_part};
	in	subunit_form name;
		new_scope_proc_form name;
		stub();
		stub_spec_proc formal_proc;
		form_proc formal_proc;
		curr_form_proc formal_proc
	end
) | €do_procedure_spec› (
	{name, formal_part, spec as Nil} : PROCEDURE_SPECIFICATION) = (
	subunit_inf name;
	new_scope_proc_inf name;
	stub()
)
(*
=TEX
The following reflects the SID functions for $function\_specification$:
=SML
*)
and €do_function_spec› (
	{designator, return, formal_part, spec as Value sp}
			: FUNCTION_SPECIFICATION) = (
	let	val informal_fun : INFORMAL_FUN =
		{name=designator,
		formal_pars = map mk_param_spec formal_part,
		return_type = return};
		val formal_fun : FORMAL_FUN =
			{spec = sp, informal_fun = informal_fun};
	in	subunit_form designator;
		new_scope_fun_form designator;
		stub();
		stub_spec_fun formal_fun;
		form_fun formal_fun;
		curr_form_fun formal_fun
	end
) | €do_function_spec› (
	{designator, return, formal_part, spec as Nil}
			: FUNCTION_SPECIFICATION) = (
	let	val informal_fun : INFORMAL_FUN =
		{name=designator,
		formal_pars = map mk_param_spec formal_part,
		return_type = return};
	in	subunit_inf designator;
		new_scope_fun_inf designator;
		stub();
		inf_fun informal_fun
	end
)
(*
=TEX
The following reflects the SID functions for $body\_stub$:
=SML
*)
and €do_package_spec› (
	{name, visible_decs, private_decs}
			: DECLARATION PACKAGE_DECLARATION) = (
	new_scope_pack_spec name;
	map do_declaration visible_decs;
	map do_declaration private_decs;
	end_scope()
)
(*
=TEX
The following reflects the SID functions for $package\_body$:
=SML
*)
and €do_procedure_stub› (
	proc_spec : PROCEDURE_DECLARATION) = (
	begin_stub();
	do_procedure_spec proc_spec;
	add_proc_env();
	end_scope();
	end_stub()
)
and €do_function_stub› (
	fun_spec : FUNCTION_DECLARATION) = (
	begin_stub();
	do_function_spec fun_spec;
	end_scope();
	end_stub()
)
and €do_package_stub› (
	name : ID) = (
	comment "do_package_stub" 507018 []
)
(*
=TEX
The following reflects the SID functions for:

\begin{tabular}{c}
subprogram\_body\\
subprogram\_implementation\\
package\_body\\
\end{tabular}

=SML
*)
and €do_proper_body› (y as (PBProcedure 
	{procedure_spec, declarative_part, statement}) : PROPER_BODY) : unit = (
	do_procedure_spec procedure_spec;
	map do_declaration declarative_part;
	do_statement statement;
	vcs_body statement;
	update_envs_proc();
	add_proc_env();
	end_scope()
) | do_proper_body (y as (PBFunction 
	{function_spec, declarative_part, statement}) : PROPER_BODY) = (
	do_function_spec function_spec;
	map do_declaration declarative_part;
	do_statement statement;
	vcs_body statement;
	end_scope()
) | do_proper_body (y as (PBPackage 
	{name, decls, statement}) : PROPER_BODY) = (
	new_scope_pack_body name;
	map do_declaration decls;
	do_statement statement;
	end_scope()
);
=TEX
The following reflects the SID functions for $subunit$:
=SML
fun €do_compilation_unit›
	(y as (CUPackageDeclaration x) : COMPILATION_UNIT) : unit = (
	do_declaration (DPackageDeclaration x)
) | do_compilation_unit (y as (CUProperBody x) : COMPILATION_UNIT) = (
	do_declaration (DProperBody x)
) | do_compilation_unit (y as (CUSubUnit {name, proper_body}) : COMPILATION_UNIT) = (
	new_scope_subunit (name_to_tmark name);
	do_declaration(DProperBody proper_body);
	end_scope()
);
=TEX
The following reflects the SID functions for the production $with\_clause$:
=SML
fun €do_context_compilation_unit›
	({context, comp_unit} : CONTEXT_COMPILATION_UNIT) : unit = (
	map new_scope_with context;
	do_compilation_unit comp_unit
);
=TEX
The following reflects the need to register compilation k-slots .
=SML
fun €do_kslot_compilation_unit›
	(y as (KCUKSlot {label, content}) : KSLOT_COMPILATION_UNIT) : unit = (
	new_k_slot (label, RSCompilation, get_current_theory_name())
) | do_kslot_compilation_unit
	(y as (KCUUnit x) : KSLOT_COMPILATION_UNIT) = (
	do_context_compilation_unit x
);
=TEX
The following reflects the SID functions for the production $web\_clause$:
=SML
fun €do_web_clause› (y as (WCCompilation x) : WEB_CLAUSE) : unit = (
	update_spark_prog x;
	map do_kslot_compilation_unit x;
	()
) | do_web_clause (y as (WCReplacedByCompilation x) : WEB_CLAUSE) = (
let	val {label=label, comp=comp} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory(string_of_label label);
	update_replacement_env(label, ReplaceComp x);
	map do_kslot_compilation_unit (#comp x);
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByPrivatePart x) : WEB_CLAUSE) = (
let	val {label=label, private=private} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory(string_of_label label);
	update_replacement_env(label, ReplacePPart x);
	map do_declaration (#private x);
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByVisiblePart x) : WEB_CLAUSE) = (
let	val {label=label,visible=visible} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory(string_of_label label);
	update_replacement_env(label, ReplaceVPart x);
	map do_declaration (#visible x);
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedByDecl x) : WEB_CLAUSE) = (
let	val {label=label,decls=decls} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory(string_of_label label);
	update_replacement_env(label, ReplaceDecl x);
	new_scope_dec_replace x;
	map do_declaration decls;
	update_envs_remove_declabel x;
	end_scope();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCRefinedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory(string_of_label label);
	update_replacement_env(label, ReplaceStat x);
	new_scope_speclabel label;
	do_statement statement;
	vcs_speclabel x;
	end_scope_speclabel();
	lazy_open_theory current_theory
end
) | do_web_clause (y as (WCReplacedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
	val current_theory = get_current_theory_name ();
in	open_label_theory(string_of_label label);
	update_replacement_env(label, ReplaceStat x);
	new_scope_stmt_label label;
	do_statement statement;
	end_scope_stmt_label();
	lazy_open_theory current_theory
end
);
=TEX
=SML
fun cn_z_generator (w : WEB_CLAUSE) : unit = (
()
);
=TEX
=IGN
fun get_spark_prog ((): unit) : string = (
	let	fun expand (label : LABEL) : WEB
	diag_line (
		"Start of Web Clause\n"^
		(fmt_info_string_list (fmt_web_clause FmtInfo x ))^
		"End of Web Clause");
);
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNZGenerator *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
