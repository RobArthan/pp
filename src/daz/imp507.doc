% imp507.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP507}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK paragraph processor.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE AND AUXILIARIES}
=SML
structure €CNZGenerator› : CNZGenerator = struct
open CNTypes CNTypes1 CNTypes2;
=TEX
\subsection{Component Update Functions}
=SML
fun €package_vc_vars› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_vc_vars : VAR_DECL list) : PACKAGE = (
	{	vc_vars		=	new_vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_consts_types› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_consts_types : BASIC_DECL list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	new_consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_formal_procs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_procs : FORMAL_PROC list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	new_formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_informal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_informal_funs : INFORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	new_informal_funs,
		formal_funs	=	formal_funs	}	
);
=TEX
=SML
fun €package_formal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	new_formal_funs	}	
);
=TEX
=SML
fun €subunit_vc_vars›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_vc_vars : VAR_DECL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	new_vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €package_formal_funs› (
	{vc_vars, consts_types, formal_procs, informal_funs , formal_funs}
	: PACKAGE,
	new_formal_funs : FORMAL_FUN list) : PACKAGE = (
	{	vc_vars		=	vc_vars,
		consts_types	=	consts_types,
		formal_procs	=	formal_procs,
		informal_funs	=	informal_funs,
		formal_funs	=	new_formal_funs	}	
);
=TEX
=SML
fun €subunit_formal_procs›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_formal_procs : FORMAL_PROC list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	new_formal_procs,
			dec_labels	=	dec_labels
		}
	}
);
=TEX
=SML
fun €subunit_dec_labels›  (
	{	zmod,
		specif_flag,
		specif,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : SUBUNIT,
	new_dec_labels : LABEL list) : SUBUNIT = (
	{	zmod		=	zmod,
		specif_flag	=	specif_flag,
		specif		=	specif,
		in_scope		= {
			vc_vars		=	vc_vars,
			vc_pars		=	vc_pars,
			vc_log_cons	=	vc_log_cons,
			formal_procs	=	formal_procs,
			dec_labels	=	new_dec_labels
		}
	}
);
=TEX
=SML
fun €declab_declabel_flag›  (
	{	block_name,
		flags as
			{pack_spec_flag, pack_body_flag, stub_flag,
			subunit_flag, formal_body_flag, fun_flag,
			declabel_flag, speclabel_flag, till_flag},
		in_scope
	} : DECLAB,
	new_declabel_flag : FLAG) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	{
			pack_spec_flag		=	pack_spec_flag	,
			pack_body_flag		=	pack_body_flag,
			stub_flag		=	stub_flag,
			subunit_flag		=	subunit_flag,
			formal_body_flag	=	formal_body_flag,
			fun_flag		=	fun_flag,
			declabel_flag		=	new_declabel_flag,
			speclabel_flag		=	speclabel_flag,
			till_flag		=	till_flag
		},
		in_scope	=	in_scope
	}
);
=TEX
=SML
fun €declab_vc_vars›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_vc_vars : VAR_DECL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	new_vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun €declab_formal_procs›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_formal_procs : FORMAL_PROC list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	new_formal_procs,
			dec_labels		=	dec_labels
		}
	}
);
=TEX
=SML
fun €declab_dec_labels›  (
	{	block_name,
		flags,
		in_scope as
			{vc_vars, vc_pars, vc_log_cons, formal_procs, dec_labels}
	} : DECLAB,
	new_dec_labels : LABEL list) : DECLAB = (
	{	block_name	=	block_name,
		flags		=	flags,
		in_scope		= {
			vc_vars			=	vc_vars,
			vc_pars			=	vc_pars,
			vc_log_cons		=	vc_log_cons,
			formal_procs		=	formal_procs,
			dec_labels		=	new_dec_labels
		}
	}
);
=TEX
\section{BASIC DECLARATIONS}\label{BASICDECLARATIONS}
\section{DECLARATIONS}\label{DECLARATIONS}
\section{STATEMENTS}\label{STATEMENTS}
\section{LOOPS}\label{LOOPS}
\section{SUBPROGRAM DECLARATIONS}\label{SUBPROGRAMDECLARATIONS}
\section{PROCEDURES}\label{PROCEDURES}
\section{FUNCTIONS}\label{FUNCTIONS}
\section{FORMAL PARAMETERS}\label{FORMALPARAMETERS}
\section{SUBPROGRAM BODIES}\label{SUBPROGRAMBODIES}
\section{PACKAGES}\label{PACKAGES}
\section{STUBS AND SUBUNITS}\label{STUBSANDSUBUNITS}
\section{WEB CLAUSES}\label{WEBCLAUSES}

\section{INTERFACE}
=SML
=SML
fun €do_unary_op› (y : UNARY_OP) = (y
);
fun €do_bin_op› (y : BIN_OP) = (y
);
fun €do_type_def› (y as (x) : TYPE_DEF) = (y
);
fun €do_constraint› (y as (x) : CONSTRAINT) = (y
);
fun €do_basic_decl› (y as (x) : BASIC_DECL) = (y
);
fun €do_agg_choice› (y as (ACAggChoiceRange x) : AGG_CHOICE) = (y
) | do_agg_choice (y as (ACAggChoiceSingle x) : AGG_CHOICE) = (y
);
fun €do_attrib_desig› (y as (ADAttrib x) : ATTRIB_DESIG) = (y
) | do_attrib_desig (y as (ADAttribArg x) : ATTRIB_DESIG) = (y
);
fun €do_exp› (y as (EId x) : EXP) = (y
) | do_exp (y as (EInt x) : EXP) = (y
) | do_exp (y as (EArrayAggPos x) : EXP) = (y
) | do_exp (y as (EArrayAggPosOthers x) : EXP) = (y
) | do_exp (y as (EArrayAggOthers x) : EXP) = (y
) | do_exp (y as (EArrayAggNamed x) : EXP) = (y
) | do_exp (y as (EArrayAggNamedOthers x) : EXP) = (y
) | do_exp (y as (ERecAggPos x) : EXP) = (y
) | do_exp (y as (ERecAggNamed x) : EXP) = (y
) | do_exp (y as (EUnaryExp x) : EXP) = (y
) | do_exp (y as (EBinExp x) : EXP) = (y
) | do_exp (y as (EMemRange x) : EXP) = (y
) | do_exp (y as (EAttribute x) : EXP) = (y
) | do_exp (y as (EIndexedComp x) : EXP) = (y
) | do_exp (y as (ESelectedComp x) : EXP) = (y
) | do_exp (y as (EFunCall x) : EXP) = (y
) | do_exp (y as (EAuxiliaryExp x) : EXP) = (y
) | do_exp (y as (EBracketed x) : EXP) = (y
) | do_exp (y as (ECharacterLiteral x) : EXP) = (y
) | do_exp (y as (EStringLiteral x) : EXP) = (y
);
fun €do_label› (y as (LExplicit lab) : LABEL) = (y
) | do_label (y as LImplicit) = (y
);
fun €do_case_choice› (y as (CCCaseExp x) : CASE_CHOICE) = (y
) | do_case_choice (y as (CCCaseRange x) : CASE_CHOICE) = (y
);
fun €do_loop_direction› (y as LDForwards : LOOP_DIRECTION) = (y
) | do_loop_direction (y as LDReverse : LOOP_DIRECTION) = (y
);
fun €do_stmt› (y as STNull : STMT) = (y
) | do_stmt (y as STImplicitNull : STMT) = (y
) | do_stmt (y as (STAssign x) : STMT) = (y
) | do_stmt (y as (STSpecNoIvars x) : STMT) = (y
) | do_stmt (y as (STSemicolon x) : STMT) = (y
) | do_stmt (y as (STIfThenElse x) : STMT) = (y
) | do_stmt (y as (STCase x) : STMT) = (y
) | do_stmt (y as (STLoop x) : STMT) = (y
) | do_stmt (y as (STNamedLoop x) : STMT) = (y
) | do_stmt (y as (STWhile x) : STMT) = (y
) | do_stmt (y as (STForStatic x) : STMT) = (y
) | do_stmt (y as (STForTmark x) : STMT) = (y
) | do_stmt (y as (STExitWhen x) : STMT) = (y
) | do_stmt (y as STExit : STMT) = (y
) | do_stmt (y as (STRet x) : STMT)  = (y
) | do_stmt (y as (STProcNoIvars x) : STMT) = (y
) | do_stmt (y as (STKSlot x) : STMT) = (y
);
fun €do_statement› (y as (SStmt x) : STATEMENT) = (y
) | do_statement (y as (SSpecIvars x) : STATEMENT) = (y
) | do_statement (y as (SForNonStatic x) : STATEMENT) = (y
) | do_statement (y as (SLogCon x) : STATEMENT) = (y
) | do_statement (y as (SProcIvars x) : STATEMENT) = (y
);
fun €do_mode› (y as MSparkIn) = ( y
) | do_mode (y as MSparkOut) = (y
) | do_mode (y as MSparkInOut) = (y
);

fun €do_subprogram_specification› (y as (SSProcedure x) : SUBPROGRAM_SPECIFICATION) = (y
) | do_subprogram_specification (y as (SSFunction x) : SUBPROGRAM_SPECIFICATION) = (y
);
fun €do_actual_parameter_part› (y as (APPNamed x) : ACTUAL_PARAMETER_PART) = (y
) | do_actual_parameter_part (y as (APPPositional x) : ACTUAL_PARAMETER_PART) = (y
);
fun €do_renaming_declaration› (y as (RDFunction x) : RENAMING_DECLARATION) = (y
) | do_renaming_declaration (y as (RDSubprogram x) : RENAMING_DECLARATION) = (y
);
fun €do_representation_clause› (y as (RCLength x) : REPRESENTATION_CLAUSE) = (y
) | do_representation_clause (y as (RCEnumeration x) : REPRESENTATION_CLAUSE) = (y
) | do_representation_clause (y as (RCRecord x) : REPRESENTATION_CLAUSE) = (y
) | do_representation_clause (y as (RCAddress x) : REPRESENTATION_CLAUSE) = (y
);
fun €do_declaration› (y as (DDeclarationKSlot x) : DECLARATION) = (y
) | do_declaration (y as (DRenamingDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DBasicDecl x) : DECLARATION) = (y
) | do_declaration (y as (DRepresentationClause x) : DECLARATION) = (y
) | do_declaration (y as (DProperBody x) : DECLARATION) = (y
) | do_declaration (y as (DProcedureDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DFunctionDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DPackageDeclaration x) : DECLARATION) = (y
) | do_declaration (y as (DProcedureStub x) : DECLARATION) = (y
) | do_declaration (y as (DFunctionStub x) : DECLARATION) = (y
) | do_declaration (y as (DPackageStub x) : DECLARATION) = (y
);

fun €do_compilation_unit› (y as (CUPackageDeclaration x) : COMPILATION_UNIT) = (y
) | do_compilation_unit (y as (CUProperBody x) : COMPILATION_UNIT) = (y
) | do_compilation_unit (y as (CUSubUnit x) : COMPILATION_UNIT) = (y
);
fun €do_proper_body› (y as (PBProcedure x) : PROPER_BODY) = (y
) | do_proper_body (y as (PBFunction x) : PROPER_BODY) = (y
) | do_proper_body (y as (PBPackage x) : PROPER_BODY) = (y
);
fun €do_kslot_compilation_unit› (y as (KCUKSlot x) : KSLOT_COMPILATION_UNIT) = (y
) | do_kslot_compilation_unit (y as (KCUUnit x) : KSLOT_COMPILATION_UNIT) = (y
);
fun €do_web_clause› (y as (WCCompilation x) : WEB_CLAUSE) = (y
) | do_web_clause (y as (WCReplacedByCompilation x) : WEB_CLAUSE) = (
let	val {label=label,comp=comp} = x;
in	WCReplacedByCompilation{
		label=do_label label,
		comp=map do_kslot_compilation_unit comp
	}
end
) | do_web_clause (y as (WCReplacedByPrivatePart x) : WEB_CLAUSE) = (
let	val {label=label,private=private} = x;
in	WCReplacedByPrivatePart{
		label=do_label label,
		private=map do_declaration private
	}
end
) | do_web_clause (y as (WCReplacedByVisiblePart x) : WEB_CLAUSE) = (
let	val {label=label,visible=visible} = x;
in	WCReplacedByVisiblePart{
		label=do_label label,
		visible=map do_declaration visible
	}
end
) | do_web_clause (y as (WCReplacedByDecl x) : WEB_CLAUSE) = (
let	val {label=label,decls=decls} = x;
in	WCReplacedByDecl{
		label=do_label label,
		decls=map do_declaration decls
	}
end
) | do_web_clause (y as (WCRefinedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
in	WCRefinedBy{
		label=do_label label,
		statement=do_statement statement
	}
end
) | do_web_clause (y as (WCReplacedBy x) : WEB_CLAUSE) = (
let	val {label=label,statement=statement} = x;
in	WCReplacedBy{
		label=do_label label,
		statement=do_statement statement
	}
end
);

=TEX
=SML
fun cn_z_generator (w : WEB_CLAUSE) : unit = (
()
);
=TEX
\section{EPILOGUE}
=SML
end (* of structure CNZGenerator *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
