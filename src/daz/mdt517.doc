% %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Script Proof Support}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT517}  %% Mandatory field
\def\SCCSversion{$Revision: 1.19 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/10/30 17:40:35 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthor{K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Manager}
\TPPabstract{This document contains tests for the material defined
in ISS/HAT/DAZ/DTD517\cite{ISS/HAT/DAZ/DTD517}.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.1, 1.2]
First drafts.
\item[Issue 1.3]
To match issue 1.5 of dtd517.
\item[Issue 1.4 - 1.9]
Fixing use of Q's.
\item[Issue 1.11]
Changing to one compilation unit per script.
\item[Issue 1.12]
\item[Issue 1.11]
IUCT WP 7 changes.
\item[Issue 1.12-1.15]
Changes for IUCT WP3 and 4;
attempt to make it more robust in various build/test environments.
\item[Issue 1.16]
test for fix to make it accomodate spaces in file names.
\item[Issue 1.17]
Adjustments for June 2000 enhancements.
\item[Issues 1.18-1.20]
Adjustments for CTLE II enhancements;
linked in some tests that were not being run;
general tidy-up.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for the module defined 
in \cite{ISS/HAT/DAZ/DTD517}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD517}. The tests are intended to meet
the requirements for module tests identified in the quality plan
\cite{ISS/HAT/DAZ/PLN002}.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
Overriding of pre-existing theorems not tested.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
\section{TEST POLICY}
Integration tests check some of the fine details of the script proof support functions.
The tests here have more of the flavour of ``soak'' tests, hitting the functions
with reasonably large and/or unusual input to see what happens. In this document
a frequent method of checking results is just to compare counts of the numbers
of constants, axioms, theorems
etc. that have been produced by processing some compliance notation and some Z paragraphs
and then calling the script proof support functions. Some or all of these counts
will change with the evolving design of the compliance tool. When changes to
the tool make the counts change, testers should do a visual spot check of the
actual constants, axioms, theorems etc. (e.g., using {\it ``print\_z\_document''}
to determine whether the results are as expected.
If the results are as expected, then the counts in the test criteria in this document
need to be adjusted accordingly.
=TEX
\section{THE TESTS}
=SML
val thy_name = "test!&$#+-/:<>=?@\\~`^|*\"517";
force_delete_theory thy_name handle Fail _ => ();
force_delete_theory "mdt517" handle _ => ();
open_theory "imp517" handle _ => open_theory "cn";
set_pc"z_library1";
new_theory"mdt517";
diag_string "Cache theory is: ";
force_get_cache_theory();
=TEX


=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX
Ready to start a new script for a test theory.
=SML
new_script{name=thy_name, state=initial_cn_state};
new_parent "mdt517";
if (is_nil (cn_simplify_canon (z_get_spec ÒBOOLEANvPOSÆ)))
then diag_string "*** THEORY SCOPE TROUBLES, THESE TESTS ARE NOT LIKELY TO BE RIGHT ***"
else();
=TEX
\subsection{Useful functions}
=SML
fun €tac_solve› tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX

Functions for recording some statistics of theories.

=SML
type theory_stats = {ng : int, na : int, nd : int, nc : int, nt : int};
local
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
    fun noof_thms thy = (length o get_thms) thy;
in
    fun get_theory_stats (thy : string) : theory_stats = (
    let
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
        val nt = noof_thms thy;
   in
        {ng = ng, na = na, nd = nd, nc = nc, nt = nt}
   end);
end;
=TEX
\pagebreak
\section{EXPRESSIONS} \label{EXP}
\subsection{Identifier} 
πCN
procedure P is
   C1 : constant INTEGER := 9;
   C2 : constant INTEGER := C1;


-- {Aggregates} 
-- {Positional Array} 
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 2 .. 4;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(THU, FRI, SAT);
-- {Positional Array With Others} 
   C3 : constant ARR := ARR'(THU, FRI, SAT, others => SUN);
-- {Positional Array With Just Others} 
   C4 : constant ARR := ARR'(others => SUN);
-- {Named Array} 
   type ARR1 is array (DAY) of DAY;
   C5 : constant ARR1 := ARR1'(MON .. THU | FRI => WED, SAT | SUN => TUE);
-- {Named Array With Others} 
   C6 : constant ARR1 := ARR1'(1 .. 5 => WED, others => TUE);
-- {Positional Record} 
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   type REC1 is 
	record
	   START, FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   type REC2 is 
	record
	   FINISH, START		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
		
   C7 : constant REC := REC'(WED,SUN,ARR'(others => THU));
   Ca7 : constant REC1 := REC1'(WED,SUN,ARR'(others => THU));
   Cb7 : constant REC2 := REC2'(WED,SUN,ARR'(others => THU));
-- {Named Record} 
   C8 : constant REC := REC'(START => THU,
				FINISH => FRI,
				YESTERDAY => ARR'(others => SUN));
-- {Unary} 
   C9 : constant INTEGER := abs (-6);
   C10 : constant BOOLEAN := not FALSE;
-- {Binary} 
   C11 : constant BOOLEAN := ((5<5 and 6<=4) or (2>1 and then -1>=0)); 
   C12 : constant INTEGER := 5-3+2*7;
   C13 : constant INTEGER := (17 / 3) * 3 + (17 rem 3);
   C14 : constant INTEGER := (-17 / 3) * 3 + (-17 mod 3);
   C15 : constant INTEGER := 2 ** 3;
   subtype WEEKDAY is DAY range MON..FRI;
   C16 : constant BOOLEAN := SUN in WEEKDAY or SUN not in WEEKDAY;
-- {Membership of a Range} 
   C17 : constant BOOLEAN := 6 in 5..10 or 6 not in 5..10;
-- {Attributes} 
   subtype WEEK is DAY range MON..SUN;
   C21 : constant DAY := WEEKDAY'FIRST;
   C22 : constant DAY := WEEKDAY'LAST;
   C23 : constant DAY := WEEKDAY'SUCC(FRI);
   C24 : constant DAY := WEEKDAY'PRED(WED);
   C25 : constant INTEGER := WEEKDAY'POS(TUE);
   C26 : constant DAY := WEEKDAY'VAL(6);
   C27 : constant DAY := ARR'FIRST;
   C28 : constant DAY := ARR'LAST;
   C29 : constant INTEGER := ARR'LENGTH;
-- {Indexed Components}
   TOMORROW : constant ARR := ARR'(TUE,WED,THU,FRI,SAT,SUN,MON);
   C30 : constant DAY := TOMORROW(DAY'FIRST);
-- {Selected Components}
   R : constant REC := REC'(WED,FRI,ARR'(others => SUN));		
   C31 : constant DAY := R.FINISH;
-- {Function Calls}
   function MAX (x,y: DAY) return DAY;
   R1 : constant REC := REC'(WED,FRI,ARR'(others => SUN)); 	 
   C32 : constant DAY := MAX(THU,R.FINISH);
-- {Qualified Expressionss}
   C33 : constant DAY := DAY'(THU);
-- {Type Conversions}
   subtype COUNT is INTEGER range 1.. 10;
   subtype ALTCOUNT is COUNT;
   C34 : constant COUNT := COUNT(4);
   C34A : constant ALTCOUNT := ALTCOUNT(4);
-- {Integer Literals}
   C35 : constant INTEGER := 4;
-- {Auxiliary Expressions}
   C36 : constant INTEGER := ˚6˝;
-- {BASIC DECLARATIONS}
-- {Constants}
   subtype INDEX1 is INTEGER range 1..2;
   type STRING_ARRAY is array(INDEX1) of STRING;
   A : constant STRING_ARRAY := STRING_ARRAY'("abc", "xyz");
-- {Enumeration Types} 
-- {Array Types}
   type HOURS is range 0..23;
   type ARR3 is array (DAY) of DAY;
   type ARR2 is array (DAY,HOURS) of DAY;
   type UNCON1 is array (DAY range <>) of DAY;
   type UNCON2 is array (DAY range <>,HOURS range <>) of DAY;
-- {Record Types}
-- {Integer Types}
-- {Real Types}
   type FIX is delta 0.1 range 5.1 .. 10.0;
-- {Subtypes}
   subtype SUBFIX1 is FIX range 7.0 .. 9.0;
   subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;
   type FLOAT1 is digits 4  range -5.1 .. 10.0;
   subtype SUBFLOAT1 is FLOAT1 digits 4 range -0.8 .. 0.8;
   subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;
   type UNCON is array (DAY range <>) of DAY;
   subtype SUB is UNCON(WEEKDAY);
   type UNCON3 is array (DAY range <>,HOURS range<>) of DAY;
   subtype SUB2 is UNCON3(WEEKDAY,HOURS);
   subtype SUB3 is INTEGER;
   type Q is range 1 .. 1;
   type QQQQ is range 1 .. 3;
   type EQUAL_TEST is range 1 .. 4;
   type EQQQQUAL_TEST2 is range 1 .. 6;
begin 
   null;
end P;
∞
=TEX
Now we use some Z to add interest to the current theory:
=SML
set_flag("standard_z_paras", false);
open ZParagraphs;
val C_Q = chr(81);
val C_pc = chr(37);
val S_pQp = C_pc ^ C_Q ^ C_pc;
πZ
‹ START ¶ 1
∞
πZ
‹ END ¶ 10
∞
πZAX
‹ test1, test2 : ˙
˜¸¸¸¸¸¸
‹ test1 > 0 ± test2 > 0
∞
=TEX
To make things even more interesting, the following function
fakes up and loads some Z paragraphs that look like the
translations of Ada declarations:
=SML
fun fake_compliance_stuff (name_string : string) = (
update_theory_db_with_parainfo(AbbDefInfo (name_string, [], ÒSTART .. ENDÆ));
(let
val local_gvar = mk_z_gvar(name_string, î˙ SETÆ, []);
val local_gvarvlast = mk_z_gvar(name_string ^ "vLAST", î˙Æ, []);
in
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vFIRST", [], ÒSTARTÆ));
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vLAST", [], ÒENDÆ));
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vSUCC", [], 
	Ò(ëlocal_gvarÆ \ { ëlocal_gvarvlastÆ }) Ú succÆ));
(let
val local_gvarvsucc = mk_z_gvar(name_string ^ "vSUCC", î(˙, ˙) $"Z'T[2]" SETÆ, []);
in
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vPRED", [], 
	Ò (ëlocal_gvarvsuccÆ)  Á~ÍÆ));
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vPOS", [], 
	Òid ëlocal_gvarÆÆ));
(let
val local_gvarvpos = mk_z_gvar(name_string ^ "vPOS", î(˙, ˙) $"Z'T[2]" SETÆ, []);
in
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vVAL", [], 
	Òëlocal_gvarvposÆ  Á~ÍÆ))
end)
end)
end)
);
=TEX
=SML
fake_compliance_stuff( "Q1");
fake_compliance_stuff( "B");
=SML
fake_compliance_stuff(C_Q);
fake_compliance_stuff( S_pQp);
fake_compliance_stuff( "E" ^ S_pQp ^ "UAL_TEST1");
fake_compliance_stuff( "E%%" ^ C_Q ^ "%%UAL_TEST3");
=TEX
Some more bits and bobs of Z:
πZ
‹ %calA% ¶ 1
∞
πZ
‹ %delta% ¶ 1
∞
πZ
‹ ƒ' ¶ 1
∞
πZ
‹ stest1 ¶ "abcd"
∞
πZ
‹ stest2 ¶ "Q"
∞
πZ
‹ stest3 ¶ ëmk_z_string(C_Q)Æ
∞
πZ
‹ stest4 ¶ "EQU"
∞
πZ
‹ stest5 ¶ ëmk_z_string("E" ^ C_Q ^ "U")Æ
∞
πZ
‹ stest6 ¶ "%delta%"
∞
πZ
‹ stest7 ¶ "%calA%"
∞
πZ
‹ rel ste _ st8
∞
πZ
‹ ste X st8 ¶  (X ∏ X)
∞
=TEX
Now see what we've got --- or at least how many constants theorems etc. we've got.
=SML
val gts1 = get_theory_stats thy_name;
store_mt_results
mt_run [("create source theory", get_theory_stats, thy_name,
	{na = 30, nc = 1, nd = 274, ng = 311, nt = 0})];
=TEX
\section{Use of Test Theory}
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
fun my_show_length x = (diag_string ("Length is " ^ string_of_int (length x));
	length x);

store_mt_results
mt_run [("all_cn_make_script_support", 
	my_show_length o all_cn_make_script_support, "test_517",
	343)];
push_pc "test_517";
=TEX
Have we created the sort of theorems we expected?
=SML
val gts2 = get_theory_stats "test_517";
store_mt_results
mt_run [("create support theory 1", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 343})];
store_mt_results
(mt_runf (op =$)) [
	("cn_thm.1", snd o dest_eq o concl, cn_SUB2_thm, Ò(WEEKDAY ∏ HOURS ≠ DAY) ° UNCON3Æ),
	("cn_thm.2", snd o dest_eq o concl, cn_SUBvRANGE_thm, ÒWEEKDAYÆ),
	("cn_thm.3", snd o dest_eq o concl, cn_SUB_thm, Ò(WEEKDAY ≠ DAY) ° UNCONÆ),
	("cn_thm.4", concl, cn_FIX_thm, ÒFIX = 51 e (~ 1) ..âR 1 e 1Æ),
	("cn_thm.5", snd o dest_eq o concl, cn_R_thm, Ò(FINISH ¶ FRI, START ¶ WED, YESTERDAY ¶ ARRvRANGE ∏ {SUN})Æ),
	("cn_thm.6", snd o dest_eq o concl, cn_REC_thm, Ò[FINISH : DAY; START : DAY; YESTERDAY : ARR]Æ),
	("cn_thm.7", snd o dest_eq o concl, cn_REC1_thm, Ò[FINISH : DAY; START : DAY; YESTERDAY : ARR]Æ),
	("cn_thm.8", snd o dest_eq o concl, cn_REC2_thm, Ò[FINISH : DAY; START : DAY; YESTERDAY : ARR]Æ),
	("cn_thm.9", concl, cn_DAYvVAL_thm, Òµ i : DAY ∑ DAYvVAL i = iÆ),
	("cn_thm.10", concl, cn_DAYvPOS_thm, Òµ i : DAY ∑ DAYvPOS i = iÆ),
	("cn_thm.11", concl, cn_DAYvVAL_sig_thm, ÒDAYvVAL ç DAY ≠ DAYÆ),
	("cn_thm.12", concl, cn_DAYvPOS_sig_thm, ÒDAYvPOS ç DAY ≠ DAYÆ),
	("cn_thm.13", concl, cn_DAYvPRED_thm, Òµ i : MON + 1 .. SUN ∑ DAYvPRED i = i + ~ 1Æ),
	("cn_thm.14", concl, cn_DAYvPRED_sig_thm, ÒDAYvPRED ç MON + 1 .. SUN ≠ MON .. SUN + ~ 1Æ),
	("cn_thm.15", concl, cn_DAYvSUCC_thm, Òµ i : MON .. SUN + ~ 1 ∑ DAYvSUCC i = i + 1Æ),
	("cn_thm.16", concl, cn_DAYvSUCC_sig_thm, ÒDAYvSUCC ç MON .. SUN + ~ 1 ≠ MON + 1 .. SUNÆ),
	("cn_thm.17", snd o dest_eq o concl, cn_C1_thm, Ò9Æ)
];
=TEX
The success of this indirectly tests:
=SML
z_norm_sig_h_schema_conv;
cn_simplify_canon;
list_cn_script_support_thms;
list_cn_make_script_support;
cn_spec_rule;
=TEX

Does the proof context perform properly?
=SML
rewrite_rule[] (asm_rule Òp ç SUB2Æ);
rewrite_rule[] (asm_rule Òp ç FLOAT1Æ);
rewrite_rule[] (asm_rule Òp ç STRING_ARRAYvRANGEÆ);
store_mt_results_show (mt_runf (op =$)) [
	("Proof 1", concl o prove_rule [],  
		Òp ç DAY ¥ DAYvVAL p = pÆ, Òp ç DAY ¥ DAYvVAL p = pÆ),
	("Proof 2", concl o prove_rule [],  
		Òp ç DAY ¥ DAYvPOS p = pÆ, Òp ç DAY ¥ DAYvPOS p = pÆ)
	];
=TEX
=SML
val goal_concl = ÒWED ç MON + 1 .. SUN ¥ DAYvPRED WED = WED - 1Æ;
set_goal([],goal_concl);
a strip_tac;
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvPRED_thm]);
store_mt_results
(mt_runf (op =$))
	 [("Proof 3", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ÒDAYvSUCC MON = TUEÆ;
set_goal([],goal_concl);
a(PC_T1 "z_sets_alg" lemma_tac ÒMON º MON ± MON º SUN  + ~ 1Æ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvSUCC_thm]);
store_mt_results
(mt_runf (op =$))
	 [("Proof 4", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ÒDAYvPRED WED = TUEÆ;
set_goal([],goal_concl);
a(lemma_tac ÒWED ç MON + 1 .. SUNÆ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvPRED_thm]);
store_mt_results
(mt_runf (op =$))
	 [("Proof 5", concl o pop_thm, (), goal_concl)];
fc_canon cn_DAYvPRED_thm;
=TEX
=SML
val goal_concl = ÒDAYvSUCC MON = TUEÆ;
set_goal([],goal_concl);
a(rewrite_tac[]);
a(PC_T1 "z_sets_alg" lemma_tac Ò0 º 0 ± 0 º 5Æ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [rewrite_rule[]cn_DAYvSUCC_thm]);
store_mt_results
(mt_runf (op =$))
	 [("Proof 6", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ÒDAYvPRED WED = TUEÆ;
set_goal([],goal_concl);
a(rewrite_tac[]);
a(PC_T1 "z_sets_alg" lemma_tac Ò1 º 2 ± 2 º 6Æ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [rewrite_rule[]cn_DAYvPRED_thm]);
store_mt_results
(mt_runf (op =$))
	 [("Proof 7", concl o pop_thm, (), goal_concl)];
=SML
val goal_concl = ÒALTCOUNTvFIRST = 1Æ;
set_goal([],goal_concl);
a(prove_tac[]);
store_mt_results
(mt_runf (op =$))
	 [("Proof 8", concl o pop_thm, (), goal_concl)];
=TEX
Check a few bindings:
=SML
cn_Q_thm;
cn_QQQQ_thm;
cn_EQUAL_TEST_thm;
cn_EQQQQUAL_TEST2_thm;
cn_ƒ_thm;
cn_%delta%_thm;
cn_%delta%'_thm;
cn__pc_calA_pc__thm;
fun prot_use_string s = (use_string s; 0) handle _ => 1;

store_mt_results_show mt_run [
	("bind_var1", prot_use_string, 
	 "cn_E_pc_" ^ S_pQp ^ "_pc_UAL_TEST3_thm", 0),
	("bind_var2", prot_use_string, 
	 "cn_E_pc_" ^ S_pQp ^ "_pc_UAL_TEST1_thm", 0),
	("bind_var3", prot_use_string, "cn_" ^ S_pQp ^ "_thm", 0),
	("bind_var4", prot_use_string, "cn_" ^ S_pQp ^ "vVAL_thm", 0),
	("bind_var5", prot_use_string, "absolute_rubbish", 1)
];

=TEX
Lets check the remaining items in a cursory manner:
=SML
pop_pc();
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
store_mt_results
mt_run [("cn_script_support_thms", my_show_length o 
	cn_script_support_thms, thy_name,	343)];
=TEX
Have we created the sort of theorems we expected?
=SML
val gts3 = get_theory_stats "test_517";
store_mt_results
mt_run [("create support theory 2", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 343})];
=TEX
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
store_mt_results
mt_run [("list_cn_spec_rule", my_show_length o 
	list_cn_spec_rule,
	(map snd (get_defns thy_name @ get_axioms thy_name)),
	343)];
=TEX
Have we created the sort of theorems we expected?
=SML
val gts4 = get_theory_stats "test_517";
store_mt_results
mt_run [("create support theory 3", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 343})];
=TEX
A simple test for $z\_norm\_sig\_h\_schema\_conv$:
=SML
ˇT¸¸¸¸¸¸¸¸¸¸¸
‹ p : ˙
˜¸¸¸¸¸¸
‹ p = 1
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇS¸¸¸¸¸¸¸¸¸¸¸
‹ q : ˙
˜¸¸¸¸¸¸
‹ q = 1
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
val rhs = snd o dest_eq o snd o dest_thm;

store_mt_results
(mt_runf (op =$)) [("z_norm_sig_h_schema_conv 1",
	rhs o z_norm_sig_h_schema_conv, Ò[a,b : X; T ; S; f : Z]Æ,
	Ò[a : X; b : X; f : Z; T; S]Æ)];

store_mt_results
mt_run_fail [("z_norm_sig_h_schema_conv", z_norm_sig_h_schema_conv, Ò1Æ,
                gen_fail_msg "z_norm_sig_h_schema_conv" 47940 [string_of_term Ò1Æ])
];
=TEX
Nasty cases for $cn\_spec\_rule$:
=SML
πZAX
‹ S;
‹ jjj : ˙ ≠ ˙
˜¸¸¸¸¸¸
‹ jjj 0 = 1;
‹ q = 2
‹ 
∞
=SML
store_mt_results
mt_run [("cn_spec_rule_nasty 1", length, 
	cn_spec_rule (get_spec ÒqÆ), 4)];
=TEX
=SML
πZ
‹ CC1 ::= CC1Null | CC1A ( ˙ )  
∞
=SML
store_mt_results
mt_run [("cn_spec_rule_nasty 2", length, 
	cn_spec_rule (get_spec ÒCC1Æ), 1),
	("cn_spec_rule_nasty 3", length, 
	cn_spec_rule (get_spec ÒCC1AÆ), 4)];
=TEX
=SML
πZ
‹ [ AA, BB ]
∞
=SML
store_mt_results
mt_run [("cn_spec_rule_nasty 4", length, 
	cn_spec_rule (get_spec ÒAAÆ), 1)];
=TEX
=SML
ù[X]úúúúúúúúúúú
‹ DD : X ≠ X
˜¸¸¸¸¸¸
‹ DD = id X
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
store_mt_results
mt_run [("cn_spec_rule_nasty 5", length, 
	cn_spec_rule (get_spec ÒDDÆ), 2)];
store_mt_results
mt_run [("cn_spec_rule_nasty 6", length, 
	cn_spec_rule (get_spec ÒSÆ), 1)];
=TEX
=SML
πZ
‹ PP[X] ¶ id X
∞
store_mt_results
mt_run [("cn_spec_rule_nasty 7", length, 
	cn_spec_rule (get_spec Ò(PP[˙])Æ), 2)];
=TEX
Warnings:
=SML
store_mt_results_show mt_run [("cn_spec_rule 517001 a", length, 
	list_cn_spec_rule [(get_spec Ò(PP[˙])Æ)], 2)];
val was = set_flag("ignore_warnings",true);
store_mt_results_show mt_run [("cn_spec_rule 517001 b", length, 
	list_cn_spec_rule [(get_spec Ò(PP[˙])Æ)], 2)];
val was = set_flag("ignore_warnings",was);
=TEX
A few failure types:
=SML
val old_thy = get_current_theory_name();
open_theory "z_library";
new_theory"cn_not_in_scope";
set_cache_theories("cn_not_in_scope"::get_cache_theories());
store_mt_results_show mt_run_fail [("cn_spec_rule 517006",cn_spec_rule,
	get_spec Ò(_+_)Æ,
	gen_fail_msg "cn_spec_rule" 517006 [])];
set_cache_theories(tl(get_cache_theories()));
open_theory old_thy;
store_mt_results_show mt_run_fail [("cn_spec_rule 517004",cn_spec_rule,
	t_thm,
	gen_fail_msg "cn_spec_rule" 517004 [string_of_thm t_thm])];
=TEX
Just to see what theory cn looks like:
=SML
force_delete_theory "cn_cn" handle _ => ();
open_theory "imp517" handle _ => open_theory "cn";
new_theory "cn_cn";
delete_pc "cn_cn" handle _ => ();

store_mt_results_show mt_run [("cn_make_script_support cn", 
	(fn x => let val tmp = cn_make_script_support "cn" x
		in my_show_length tmp
		end), "cn_cn",
	165)];
=TEX
Have we created the sort of theorems we expected?
=SML
val gts5 = get_theory_stats "cn_cn";
store_mt_results
mt_run [("create support theory 5", get_theory_stats, "cn_cn",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 165})];
=TEX
\subsection{Testing Material from DTD518}
=SML
open_theory "cn";
=TEX
=SML
force_delete_theory"test" handle Fail _ => ();
new_script{name="test", state=initial_cn_state};
πCN
 procedure TEST1
 is
     type int4 is range 1 .. 4;
     type enum3 is (EINS, ZWEI, DREI);
     type arr3_4 is array(enum3) of int4;
     function func1 (x : enum3) return NATURAL
     is begin return NATURAL(x);
     end func1;
     function func2 (x : enum3) return int4 ò [ true ]
     is begin return int4(x);
     end func2;

 begin
   null;
 end TEST1;
∞
=SML
val statea = get_cn_state();
force_delete_theory"testa" handle Fail _ => ();
new_script{name="testa", state=statea};
πCN
 procedure TEST2
 is
     type bit is (ZERO, ONE);
     function func3 (x : bit) return bit
     ò [FUNC3(X) = 1 - X]
     is begin return 1 - x;
     end func3;

 begin
   null;
 end TEST2;
∞
=SML
val stateb = get_cn_state();
force_delete_theory"testb" handle Fail _ => ();
new_script{name="testb", state=stateb};
πCN
 procedure TEST3
 is
     type ABC is (A, B, C);
     type BYTE is range 0 .. 255;
     type MARKED_BYTE is record x : ABC; y : BYTE; z : BOOLEAN; end record;
     type AMB is array (BYTE) of MARKED_BYTE;
 begin
   null;
 end TEST3;
∞
=TEX
=SML
force_delete_theory"test_proofs" handle Fail _ => ();
open_theory"test";
set_pc"cn1";
new_theory"test_proofs";
new_parent "testa" handle Fail _ => ();
new_parent "testb" handle Fail _ => ();
new_parent"imp518" handle Fail _ => ();
open_theory"test_proofs";
val test_proof_thms = all_cn_make_script_support "test_proofs";
=TEX
=SML
set_pc"cn1";
=TEX
First the native stuff in ``cn1'', then the new proof context.
=SML
store_mt_results
mt_run [
	("cn_ç_type_tac 1",
	tac_solve (REPEAT strip_tac THEN cn_ç_type_tac[]),
	([],ÒX ç BOOLEAN ¥ not X ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 2",
	tac_solve (REPEAT strip_tac THEN cn_ç_type_tac[]),
	([],ÒX ç BOOLEAN ± Y ç BOOLEAN ¥ not X and Y ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 3",
	tac_solve  (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],ÒX ç BOOLEAN ¥ not X ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 4",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],ÒX ç BOOLEAN ± Y ç BOOLEAN ¥ not X and Y ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 5",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Òx ç ENUM3 ¥ FUNC2 x ç INT4Æ),
	true),
	("cn_ç_type_tac 6",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Òµx : AMB ∑ (x(42)).Z ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 7",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Òµx : AMB ∑ (x(42)).Y greater (x(43)).Y ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 8",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Òµx : AMB ∑ x ´ {99 Ì (X¶A, Y¶255, Z¶TRUE)} ç AMBÆ),
	true),
	("cn_ç_type_tac 9",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Òµx : AMB; i : BYTE∑ (x i) ç MARKED_BYTEÆ),
	true),
	("cn_ç_type_tac 10",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Òµx : AMB; i : BYTE∑ (x ´ {99 Ì (X¶A, Y¶255, Z¶TRUE)})  ç AMBÆ),
	true),
	("cn_ç_type_tac 11",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Òµx : U; y : U; i : BYTE| x y ç AMB ∑  x y i ç MARKED_BYTE Æ),
	true),
	("cn_ç_type_tac 12",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Ò27 ç BYTEÆ),
	true),
	("cn_ç_type_tac 13",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Ò(1,2,3) ç BYTE ∏ BYTE ∏ BYTEÆ),
	true),
	("cn_ç_type_tac 14",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Ò(X¶A,Y¶2,Z¶TRUE) ç MARKED_BYTEÆ),
	true),
	("cn_ç_type_tac 15",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Ò(X¶A,Y¶2,Z¶TRUE).Z and TRUE ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 16",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Ò(FALSE,2,3,4,5).1 and FALSE ç BOOLEANÆ),
	true),
	("cn_ç_type_tac 17",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],ÒINT4vFIRST ç BITÆ),
	true),
	("cn_ç_type_tac 18",
	tac_solve (REPEAT strip_tac THEN PC_T1 "test_proofs" cn_ç_type_tac[]),
	([],Ò3 ç INT4Æ),
	true)

];
=TEX


\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

