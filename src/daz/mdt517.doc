% %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Script Proof Support}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT517}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthor{K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Manager}
\TPPabstract{This document contains tests for the material defined
in ISS/HAT/DAZ/DTD517\cite{ISS/HAT/DAZ/DTD517}.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.1, 1.2]
First drafts.
\item[Issue 1.3]
To match issue 1.5 of dtd517.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for the module defined 
in \cite{ISS/HAT/DAZ/DTD517}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD517}. The tests are intended to meet
the requirements for module tests identified in the quality plan
\cite{ISS/HAT/DAZ/PLN002}.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
Overriding of pre-existing theorems not tested.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
\section{THE TESTS}
=SML
set_pc"z_library";
val thy_name = "test!&$#+-/:<>=?@\\~`^|*\"517";
force_delete_theory thy_name handle Fail _ => ();
force_delete_theory "mdt517" handle _ => ();
open_theory "imp517" handle _ => open_theory "cn";
set_pc"z_library1";
new_theory"mdt517";
diag_string "Cache theory is: ";
force_get_cache_theory();
=TEX


=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX
Ready to start a new script for a test theory.
=SML
new_script{name=thy_name, state=initial_cn_state};
new_parent "mdt517";
if (is_nil (cn_simplify_canon (z_get_spec ÒBOOLEANvPOSÆ)))
then diag_string "*** THEORY SCOPE TROUBLES, THESE TESTS ARE NOT LIKELY TO BE RIGHT ***"
else();
=TEX
\subsection{Useful functions}

Functions for recording some statistics of theories.

=SML
type theory_stats = {ng : int, na : int, nd : int, nc : int, nt : int};
local
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
    fun noof_thms thy = (length o get_thms) thy;
in
    fun get_theory_stats (thy : string) : theory_stats = (
    let
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
        val nt = noof_thms thy;
   in
        {ng = ng, na = na, nd = nd, nc = nc, nt = nt}
   end);
end;
=TEX
\pagebreak
\section{EXPRESSIONS} \label{EXP}
\subsection{Identifier} 
πCN
procedure P is
   C1 : constant INTEGER := 9;
   C2 : constant INTEGER := C1;


-- {Aggregates} 
-- {Positional Array} 
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 2 .. 4;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(THU, FRI, SAT);
-- {Positional Array With Others} 
   C3 : constant ARR := ARR'(THU, FRI, SAT, others => SUN);
-- {Positional Array With Just Others} 
   C4 : constant ARR := ARR'(others => SUN);
-- {Named Array} 
   type ARR1 is array (DAY) of DAY;
   C5 : constant ARR1 := ARR1'(MON .. THU | FRI => WED, SAT | SUN => TUE);
-- {Named Array With Others} 
   C6 : constant ARR1 := ARR1'(1 .. 5 => WED, others => TUE);
-- {Positional Record} 
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   type REC1 is 
	record
	   START, FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   type REC2 is 
	record
	   FINISH, START		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
		
   C7 : constant REC := REC'(WED,SUN,ARR'(others => THU));
   Ca7 : constant REC1 := REC1'(WED,SUN,ARR'(others => THU));
   Cb7 : constant REC2 := REC2'(WED,SUN,ARR'(others => THU));
-- {Named Record} 
   C8 : constant REC := REC'(START => THU,
				FINISH => FRI,
				YESTERDAY => ARR'(others => SUN));
-- {Unary} 
   C9 : constant INTEGER := abs (-6);
   C10 : constant BOOLEAN := not FALSE;
-- {Binary} 
   C11 : constant BOOLEAN := ((5<5 and 6<=4) or (2>1 and then -1>=0)); 
   C12 : constant INTEGER := 5-3+2*7;
   C13 : constant INTEGER := (17 / 3) * 3 + (17 rem 3);
   C14 : constant INTEGER := (-17 / 3) * 3 + (-17 mod 3);
   C15 : constant INTEGER := 2 ** 3;
   subtype WEEKDAY is DAY range MON..FRI;
   C16 : constant BOOLEAN := SUN in WEEKDAY or SUN not in WEEKDAY;
-- {Membership of a Range} 
   C17 : constant BOOLEAN := 6 in 5..10 or 6 not in 5..10;
-- {Attributes} 
   subtype WEEK is DAY range MON..SUN;
   C21 : constant DAY := WEEKDAY'FIRST;
   C22 : constant DAY := WEEKDAY'LAST;
   C23 : constant DAY := WEEKDAY'SUCC(FRI);
   C24 : constant DAY := WEEKDAY'PRED(WED);
   C25 : constant INTEGER := WEEKDAY'POS(TUE);
   C26 : constant DAY := WEEKDAY'VAL(6);
   C27 : constant DAY := ARR'FIRST;
   C28 : constant DAY := ARR'LAST;
   C29 : constant INTEGER := ARR'LENGTH;
-- {Indexed Components}
   TOMORROW : constant ARR := ARR'(TUE,WED,THU,FRI,SAT,SUN,MON);
   C30 : constant DAY := TOMORROW(DAY'FIRST);
-- {Selected Components}
   R : constant REC := REC'(WED,FRI,ARR'(others => SUN));		
   C31 : constant DAY := R.FINISH;
-- {Function Calls}
   function MAX (x,y: DAY) return DAY;
   R1 : constant REC := REC'(WED,FRI,ARR'(others => SUN)); 	 
   C32 : constant DAY := MAX(THU,R.FINISH);
-- {Qualified Expressionss}
   C33 : constant DAY := DAY'(THU);
-- {Type Conversions}
   subtype COUNT is INTEGER range 1.. 10;
   C34 : constant COUNT := COUNT(4);
-- {Integer Literals}
   C35 : constant INTEGER := 4;
-- {Auxiliary Expressions}
   C36 : constant INTEGER := ˚6˝;
-- {BASIC DECLARATIONS}
-- {Constants}
   subtype INDEX1 is INTEGER range 1..2;
   type STRING_ARRAY is array(INDEX1) of STRING;
   A : constant STRING_ARRAY := STRING_ARRAY'("abc", "xyz");
-- {Enumeration Types} 
-- {Array Types}
   type HOURS is range 0..23;
   type ARR3 is array (DAY) of DAY;
   type ARR2 is array (DAY,HOURS) of DAY;
   type UNCON1 is array (DAY range <>) of DAY;
   type UNCON2 is array (DAY range <>,HOURS range <>) of DAY;
-- {Record Types}
-- {Integer Types}
-- {Real Types}
   type FIX is delta 0.1 range 5.1 .. 10.0;
-- {Subtypes}
   subtype SUBFIX1 is FIX range 7.0 .. 9.0;
   subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;
   type FLOAT1 is digits 4  range -5.1 .. 10.0;
   subtype SUBFLOAT1 is FLOAT1 digits 4 range -0.8 .. 0.8;
   subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;
   type UNCON is array (DAY range <>) of DAY;
   subtype SUB is UNCON(WEEKDAY);
   type UNCON3 is array (DAY range <>,HOURS range<>) of DAY;
   subtype SUB2 is UNCON3(WEEKDAY,HOURS);
begin 
   null;
end P;
∞
=SML
(* It the theory still approximately what it was at the time of creating the module tests? *)
store_mt_results mt_run [("create source theory", get_theory_stats, thy_name,
	{na = 14, nc = 0, nd = 123, ng = 137, nt = 0})];

=TEX
\section{Use of Test Theory}
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
val thy_thms = all_cn_make_script_support "test517";
push_pc "test517";
=TEX
Have we created the sort of theorems we expected?
=SML
store_mt_results mt_run [("create support theory 1", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 141 + 32})];

store_mt_results (mt_runf (op =$)) [
	("cn_thm.1", snd o dest_eq o concl, cn_SUB2_thm, Ò(WEEKDAY ∏ HOURS ≠ DAY) ° UNCON3Æ),
	("cn_thm.2", snd o dest_eq o concl, cn_SUBvRANGE_thm, ÒWEEKDAYÆ),
	("cn_thm.3", snd o dest_eq o concl, cn_SUB_thm, Ò(WEEKDAY ≠ DAY) ° UNCONÆ),
	("cn_thm.4", concl, cn_FIX_thm, ÒFIX = UÆ),
	("cn_thm.5", snd o dest_eq o concl, cn_R_thm, Ò(FINISH ¶ FRI, START ¶ WED, YESTERDAY ¶ ARRvRANGE ∏ {SUN})Æ),
	("cn_thm.6", snd o dest_eq o concl, cn_REC_thm, Ò[FINISH : DAY; START : DAY; YESTERDAY : ARR]Æ),
	("cn_thm.7", snd o dest_eq o concl, cn_REC1_thm, Ò[FINISH : DAY; START : DAY; YESTERDAY : ARR]Æ),
	("cn_thm.8", snd o dest_eq o concl, cn_REC2_thm, Ò[FINISH : DAY; START : DAY; YESTERDAY : ARR]Æ),
	("cn_thm.9", concl, cn_DAYvVAL_thm, Òµ i : DAY ∑ DAYvVAL i = iÆ),
	("cn_thm.10", concl, cn_DAYvPOS_thm, Òµ i : DAY ∑ DAYvPOS i = iÆ),
	("cn_thm.11", concl, cn_DAYvVAL_ty_thm, ÒDAYvVAL ç DAY ≠ DAYÆ),
	("cn_thm.12", concl, cn_DAYvPOS_ty_thm, ÒDAYvPOS ç DAY ≠ DAYÆ),
	("cn_thm.13", concl, cn_DAYvPRED_thm, Òµ i : MON + 1 .. SUN ∑ DAYvPRED i = i + ~ 1Æ),
	("cn_thm.14", concl, cn_DAYvPRED_ty_thm, ÒDAYvPRED ç MON + 1 .. SUN ≠ MON .. SUN + ~ 1Æ),
	("cn_thm.15", concl, cn_DAYvSUCC_thm, Òµ i : MON .. SUN + ~ 1 ∑ DAYvSUCC i = i + 1Æ),
	("cn_thm.16", concl, cn_DAYvSUCC_ty_thm, ÒDAYvSUCC ç MON .. SUN + ~ 1 ≠ MON + 1 .. SUNÆ),
	("cn_thm.17", snd o dest_eq o concl, cn_C1_thm, Ò9Æ)
];
=TEX
The success of this indirectly tests:
=SML
z_norm_sig_h_schema_conv;
cn_simplify_canon;
list_cn_script_support_thms;
list_cn_make_script_support;
cn_spec_rule;
=TEX

Does the proof context perform properly?
=SML
rewrite_rule[] (asm_rule Òp ç SUB2Æ);
rewrite_rule[] (asm_rule Òp ç FLOAT1Æ);
rewrite_rule[] (asm_rule Òp ç STRING_ARRAYvRANGEÆ);
store_mt_results_show (mt_runf (op =$)) [
	("Proof 1", concl o prove_rule [],  
		Òp ç DAY ¥ DAYvVAL p = pÆ, Òp ç DAY ¥ DAYvVAL p = pÆ),
	("Proof 2", concl o prove_rule [],  
		Òp ç DAY ¥ DAYvPOS p = pÆ, Òp ç DAY ¥ DAYvPOS p = pÆ)
	];
=TEX
=SML
val goal_concl = ÒWED ç MON + 1 .. SUN ¥ DAYvPRED WED = WED - 1Æ;
set_goal([],goal_concl);
a strip_tac;
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvPRED_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 3", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ÒDAYvSUCC MON = TUEÆ;
set_goal([],goal_concl);
a(PC_T1 "z_sets_alg" lemma_tac ÒMON º MON ± MON º SUN  + ~ 1Æ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvSUCC_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 4", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ÒDAYvPRED WED = TUEÆ;
set_goal([],goal_concl);
a(lemma_tac ÒWED ç MON + 1 .. SUNÆ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvPRED_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 5", concl o pop_thm, (), goal_concl)];
fc_canon cn_DAYvPRED_thm;
=TEX
=SML
val goal_concl = ÒDAYvSUCC MON = TUEÆ;
set_goal([],goal_concl);
a(rewrite_tac[]);
a(PC_T1 "z_sets_alg" lemma_tac Ò0 º 0 ± 0 º 5Æ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [rewrite_rule[]cn_DAYvSUCC_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 6", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ÒDAYvPRED WED = TUEÆ;
set_goal([],goal_concl);
a(rewrite_tac[]);
a(PC_T1 "z_sets_alg" lemma_tac Ò1 º 2 ± 2 º 6Æ THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [rewrite_rule[]cn_DAYvPRED_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 7", concl o pop_thm, (), goal_concl)];
=TEX
Lets check the remaining items in a cursory manner:
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
val thy_thms = cn_script_support_thms thy_name;
=TEX
Have we created the sort of theorems we expected?
=SML
store_mt_results mt_run [("create support theory 2", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 141})];

store_mt_results mt_run [("cn_ML_binding 2", length, thy_thms,
	141)];
=TEX
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
val thy_thms = list_cn_spec_rule (map snd (get_defns thy_name @ get_axioms thy_name));
=TEX
Have we created the sort of theorems we expected?
=SML

store_mt_results mt_run [("cn_ML_binding 3", length, thy_thms, 141)];
store_mt_results mt_run [("create support theory 3", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 141})];
=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
pop_pc();
=TEX

\end{document}

