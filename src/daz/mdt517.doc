% %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Script Proof Support}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT517}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthor{K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Manager}
\TPPabstract{This document contains tests for the material defined
in ISS/HAT/DAZ/DTD517\cite{ISS/HAT/DAZ/DTD517}.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.1, 1.2]
First drafts.
\item[Issue 1.3]
To match issue 1.5 of dtd517.
\item[Issue 1.4, 1.5]
Fixed use of Q's.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for the module defined 
in \cite{ISS/HAT/DAZ/DTD517}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD517}. The tests are intended to meet
the requirements for module tests identified in the quality plan
\cite{ISS/HAT/DAZ/PLN002}.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
Overriding of pre-existing theorems not tested.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
\section{THE TESTS}
=SML
set_pc"z_library";
val thy_name = "test!&$#+-/:<>=?@\\~`^|*\"517";
force_delete_theory thy_name handle Fail _ => ();
force_delete_theory "mdt517" handle _ => ();
open_theory "imp517" handle _ => open_theory "cn";
set_pc"z_library1";
new_theory"mdt517";
diag_string "Cache theory is: ";
force_get_cache_theory();
=TEX


=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX
Ready to start a new script for a test theory.
=SML
new_script{name=thy_name, state=initial_cn_state};
new_parent "mdt517";
if (is_nil (cn_simplify_canon (z_get_spec ñBOOLEANvPOS®)))
then diag_string "*** THEORY SCOPE TROUBLES, THESE TESTS ARE NOT LIKELY TO BE RIGHT ***"
else();
=TEX
\subsection{Useful functions}

Functions for recording some statistics of theories.

=SML
type theory_stats = {ng : int, na : int, nd : int, nc : int, nt : int};
local
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
    fun noof_thms thy = (length o get_thms) thy;
in
    fun get_theory_stats (thy : string) : theory_stats = (
    let
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
        val nt = noof_thms thy;
   in
        {ng = ng, na = na, nd = nd, nc = nc, nt = nt}
   end);
end;
=TEX
\pagebreak
\section{EXPRESSIONS} \label{EXP}
\subsection{Identifier} 
¹CN
procedure P is
   C1 : constant INTEGER := 9;
   C2 : constant INTEGER := C1;


-- {Aggregates} 
-- {Positional Array} 
   type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
   subtype INDEX is INTEGER range 2 .. 4;
   type ARR is array (INDEX) of DAY;
   C : constant ARR := ARR'(THU, FRI, SAT);
-- {Positional Array With Others} 
   C3 : constant ARR := ARR'(THU, FRI, SAT, others => SUN);
-- {Positional Array With Just Others} 
   C4 : constant ARR := ARR'(others => SUN);
-- {Named Array} 
   type ARR1 is array (DAY) of DAY;
   C5 : constant ARR1 := ARR1'(MON .. THU | FRI => WED, SAT | SUN => TUE);
-- {Named Array With Others} 
   C6 : constant ARR1 := ARR1'(1 .. 5 => WED, others => TUE);
-- {Positional Record} 
   type REC is 
	record
	   START		: DAY;
	   FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   type REC1 is 
	record
	   START, FINISH		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
   type REC2 is 
	record
	   FINISH, START		: DAY;
	   YESTERDAY	: ARR;
	end record; 	 
		
   C7 : constant REC := REC'(WED,SUN,ARR'(others => THU));
   Ca7 : constant REC1 := REC1'(WED,SUN,ARR'(others => THU));
   Cb7 : constant REC2 := REC2'(WED,SUN,ARR'(others => THU));
-- {Named Record} 
   C8 : constant REC := REC'(START => THU,
				FINISH => FRI,
				YESTERDAY => ARR'(others => SUN));
-- {Unary} 
   C9 : constant INTEGER := abs (-6);
   C10 : constant BOOLEAN := not FALSE;
-- {Binary} 
   C11 : constant BOOLEAN := ((5<5 and 6<=4) or (2>1 and then -1>=0)); 
   C12 : constant INTEGER := 5-3+2*7;
   C13 : constant INTEGER := (17 / 3) * 3 + (17 rem 3);
   C14 : constant INTEGER := (-17 / 3) * 3 + (-17 mod 3);
   C15 : constant INTEGER := 2 ** 3;
   subtype WEEKDAY is DAY range MON..FRI;
   C16 : constant BOOLEAN := SUN in WEEKDAY or SUN not in WEEKDAY;
-- {Membership of a Range} 
   C17 : constant BOOLEAN := 6 in 5..10 or 6 not in 5..10;
-- {Attributes} 
   subtype WEEK is DAY range MON..SUN;
   C21 : constant DAY := WEEKDAY'FIRST;
   C22 : constant DAY := WEEKDAY'LAST;
   C23 : constant DAY := WEEKDAY'SUCC(FRI);
   C24 : constant DAY := WEEKDAY'PRED(WED);
   C25 : constant INTEGER := WEEKDAY'POS(TUE);
   C26 : constant DAY := WEEKDAY'VAL(6);
   C27 : constant DAY := ARR'FIRST;
   C28 : constant DAY := ARR'LAST;
   C29 : constant INTEGER := ARR'LENGTH;
-- {Indexed Components}
   TOMORROW : constant ARR := ARR'(TUE,WED,THU,FRI,SAT,SUN,MON);
   C30 : constant DAY := TOMORROW(DAY'FIRST);
-- {Selected Components}
   R : constant REC := REC'(WED,FRI,ARR'(others => SUN));		
   C31 : constant DAY := R.FINISH;
-- {Function Calls}
   function MAX (x,y: DAY) return DAY;
   R1 : constant REC := REC'(WED,FRI,ARR'(others => SUN)); 	 
   C32 : constant DAY := MAX(THU,R.FINISH);
-- {Qualified Expressionss}
   C33 : constant DAY := DAY'(THU);
-- {Type Conversions}
   subtype COUNT is INTEGER range 1.. 10;
   C34 : constant COUNT := COUNT(4);
-- {Integer Literals}
   C35 : constant INTEGER := 4;
-- {Auxiliary Expressions}
   C36 : constant INTEGER := û6ý;
-- {BASIC DECLARATIONS}
-- {Constants}
   subtype INDEX1 is INTEGER range 1..2;
   type STRING_ARRAY is array(INDEX1) of STRING;
   A : constant STRING_ARRAY := STRING_ARRAY'("abc", "xyz");
-- {Enumeration Types} 
-- {Array Types}
   type HOURS is range 0..23;
   type ARR3 is array (DAY) of DAY;
   type ARR2 is array (DAY,HOURS) of DAY;
   type UNCON1 is array (DAY range <>) of DAY;
   type UNCON2 is array (DAY range <>,HOURS range <>) of DAY;
-- {Record Types}
-- {Integer Types}
-- {Real Types}
   type FIX is delta 0.1 range 5.1 .. 10.0;
-- {Subtypes}
   subtype SUBFIX1 is FIX range 7.0 .. 9.0;
   subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;
   type FLOAT1 is digits 4  range -5.1 .. 10.0;
   subtype SUBFLOAT1 is FLOAT1 digits 4 range -0.8 .. 0.8;
   subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;
   type UNCON is array (DAY range <>) of DAY;
   subtype SUB is UNCON(WEEKDAY);
   type UNCON3 is array (DAY range <>,HOURS range<>) of DAY;
   subtype SUB2 is UNCON3(WEEKDAY,HOURS);
   type Q is range 1 .. 1;
   type QQQQ is range 1 .. 3;
   type EQUAL_TEST is range 1 .. 4;
   type EQQQQUAL_TEST2 is range 1 .. 6;
begin 
   null;
end P;
°
=TEX
Faking entries:
=IGN
open_theory "cn";
force_delete_theory "temp1";
new_theory "temp1";
set_pc "z_library";
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=SML
set_flag("standard_z_paras", false);
open ZParagraphs;
val C_Q = chr(81);
val C_pc = chr(37);
val S_pQp = C_pc ^ C_Q ^ C_pc;
¹Z
Ü START ¦ 1
°
¹Z
Ü END ¦ 10
°
¹ZAX
Ü test1, test2 : ú
÷üüüüüü
Ü test1 > 0 ± test2 > 0
°

=SML
fun fake_compliance_stuff (name_string : string) = (
update_theory_db_with_parainfo(AbbDefInfo (name_string, [], ñSTART .. END®));
(let
val local_gvar = mk_z_gvar(name_string, ”ú SET®, []);
val local_gvarvlast = mk_z_gvar(name_string ^ "vLAST", ”ú®, []);
in
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vFIRST", [], ñSTART®));
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vLAST", [], ñEND®));
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vSUCC", [], 
	ñ(‘local_gvar® \ { ‘local_gvarvlast® }) ò succ®));
(let
val local_gvarvsucc = mk_z_gvar(name_string ^ "vSUCC", ”(ú, ú) $"Z'T[2]" SET®, []);
in
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vPRED", [], 
	ñ (‘local_gvarvsucc®)  ç~ê®));
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vPOS", [], 
	ñid ‘local_gvar®®));
(let
val local_gvarvpos = mk_z_gvar(name_string ^ "vPOS", ”(ú, ú) $"Z'T[2]" SET®, []);
in
update_theory_db_with_parainfo(AbbDefInfo (name_string ^ "vVAL", [], 
	ñ‘local_gvarvpos®  ç~ê®))
end)
end)
end)
);
=TEX
=SML
diag_string("Error: XXX FEEBLE TESTS XXX Error");
fake_compliance_stuff( "Q1");
fake_compliance_stuff( "B");
=IGN
fake_compliance_stuff("Q3"); (* see below *)
fake_compliance_stuff("Q2"); (* see below *)
fake_compliance_stuff( "EQUAL_TEST3"); (* see below *)
fake_compliance_stuff( "EQUAL_TEST1"); (* see below *)
=SML
fake_compliance_stuff(C_Q);
fake_compliance_stuff( S_pQp);
fake_compliance_stuff( "E" ^ S_pQp ^ "UAL_TEST1");
fake_compliance_stuff( "E%%" ^ C_Q ^ "%%UAL_TEST3");
=TEX
¹Z
Ü %calA% ¦ 1
°
¹Z
Ü %delta% ¦ 1
°
¹Z
Ü Ä' ¦ 1
°
¹Z
Ü stest1 ¦ "abcd"
°
¹Z
Ü stest2 ¦ "Q"
°
¹Z
Ü stest3 ¦ ‘mk_z_string(C_Q)®
°
¹Z
Ü stest4 ¦ "EQU"
°
¹Z
Ü stest5 ¦ ‘mk_z_string("E" ^ C_Q ^ "U")®
°
¹Z
Ü stest6 ¦ "%delta%"
°
¹Z
Ü stest7 ¦ "%calA%"
°
=SML
(* It the theory still approximately what it was at the time of creating the module tests? *)
val gts1 = get_theory_stats thy_name;
store_mt_results mt_run [("create source theory", get_theory_stats, thy_name,
	{na = 31, nc = 0, nd = 189, ng = 219, nt = 0})];
=TEX
\section{Use of Test Theory}
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
fun show_length x = (diag_string ("Length is " ^ string_of_int (length x));
	length x);

store_mt_results mt_run [("all_cn_make_script_support", 
	show_length o all_cn_make_script_support, "test_517",
	250)];
push_pc "test_517";
=TEX
Have we created the sort of theorems we expected?
=SML
val gts2 = get_theory_stats "test_517";
store_mt_results mt_run [("create support theory 1", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 250})];

store_mt_results (mt_runf (op =$)) [
	("cn_thm.1", snd o dest_eq o concl, cn_SUB2_thm, ñ(WEEKDAY ¸ HOURS ­ DAY) ¡ UNCON3®),
	("cn_thm.2", snd o dest_eq o concl, cn_SUBvRANGE_thm, ñWEEKDAY®),
	("cn_thm.3", snd o dest_eq o concl, cn_SUB_thm, ñ(WEEKDAY ­ DAY) ¡ UNCON®),
	("cn_thm.4", concl, cn_FIX_thm, ñFIX = U®),
	("cn_thm.5", snd o dest_eq o concl, cn_R_thm, ñ(FINISH ¦ FRI, START ¦ WED, YESTERDAY ¦ ARRvRANGE ¸ {SUN})®),
	("cn_thm.6", snd o dest_eq o concl, cn_REC_thm, ñ[FINISH : DAY; START : DAY; YESTERDAY : ARR]®),
	("cn_thm.7", snd o dest_eq o concl, cn_REC1_thm, ñ[FINISH : DAY; START : DAY; YESTERDAY : ARR]®),
	("cn_thm.8", snd o dest_eq o concl, cn_REC2_thm, ñ[FINISH : DAY; START : DAY; YESTERDAY : ARR]®),
	("cn_thm.9", concl, cn_DAYvVAL_thm, ñµ i : DAY · DAYvVAL i = i®),
	("cn_thm.10", concl, cn_DAYvPOS_thm, ñµ i : DAY · DAYvPOS i = i®),
	("cn_thm.11", concl, cn_DAYvVAL_sig_thm, ñDAYvVAL  DAY ­ DAY®),
	("cn_thm.12", concl, cn_DAYvPOS_sig_thm, ñDAYvPOS  DAY ­ DAY®),
	("cn_thm.13", concl, cn_DAYvPRED_thm, ñµ i : MON + 1 .. SUN · DAYvPRED i = i + ~ 1®),
	("cn_thm.14", concl, cn_DAYvPRED_sig_thm, ñDAYvPRED  MON + 1 .. SUN ­ MON .. SUN + ~ 1®),
	("cn_thm.15", concl, cn_DAYvSUCC_thm, ñµ i : MON .. SUN + ~ 1 · DAYvSUCC i = i + 1®),
	("cn_thm.16", concl, cn_DAYvSUCC_sig_thm, ñDAYvSUCC  MON .. SUN + ~ 1 ­ MON + 1 .. SUN®),
	("cn_thm.17", snd o dest_eq o concl, cn_C1_thm, ñ9®)
];
=TEX
The success of this indirectly tests:
=SML
z_norm_sig_h_schema_conv;
cn_simplify_canon;
list_cn_script_support_thms;
list_cn_make_script_support;
cn_spec_rule;
=TEX

Does the proof context perform properly?
=SML
rewrite_rule[] (asm_rule ñp  SUB2®);
rewrite_rule[] (asm_rule ñp  FLOAT1®);
rewrite_rule[] (asm_rule ñp  STRING_ARRAYvRANGE®);
store_mt_results_show (mt_runf (op =$)) [
	("Proof 1", concl o prove_rule [],  
		ñp  DAY ´ DAYvVAL p = p®, ñp  DAY ´ DAYvVAL p = p®),
	("Proof 2", concl o prove_rule [],  
		ñp  DAY ´ DAYvPOS p = p®, ñp  DAY ´ DAYvPOS p = p®)
	];
=TEX
=SML
val goal_concl = ñWED  MON + 1 .. SUN ´ DAYvPRED WED = WED - 1®;
set_goal([],goal_concl);
a strip_tac;
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvPRED_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 3", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ñDAYvSUCC MON = TUE®;
set_goal([],goal_concl);
a(PC_T1 "z_sets_alg" lemma_tac ñMON ¼ MON ± MON ¼ SUN  + ~ 1® THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvSUCC_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 4", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ñDAYvPRED WED = TUE®;
set_goal([],goal_concl);
a(lemma_tac ñWED  MON + 1 .. SUN® THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [cn_DAYvPRED_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 5", concl o pop_thm, (), goal_concl)];
fc_canon cn_DAYvPRED_thm;
=TEX
=SML
val goal_concl = ñDAYvSUCC MON = TUE®;
set_goal([],goal_concl);
a(rewrite_tac[]);
a(PC_T1 "z_sets_alg" lemma_tac ñ0 ¼ 0 ± 0 ¼ 5® THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [rewrite_rule[]cn_DAYvSUCC_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 6", concl o pop_thm, (), goal_concl)];
=TEX
=SML
val goal_concl = ñDAYvPRED WED = TUE®;
set_goal([],goal_concl);
a(rewrite_tac[]);
a(PC_T1 "z_sets_alg" lemma_tac ñ1 ¼ 2 ± 2 ¼ 6® THEN1 prove_tac[]);
a(ALL_ASM_FC_T rewrite_tac [rewrite_rule[]cn_DAYvPRED_thm]);
store_mt_results (mt_runf (op =$))
	 [("Proof 7", concl o pop_thm, (), goal_concl)];
=TEX
Check a few bindings:
=SML
cn_Q_thm;
cn_QQQQ_thm;
cn_EQUAL_TEST_thm;
cn_EQQQQUAL_TEST2_thm;
cn_Ä_thm;
cn_%delta%_thm;
cn_%delta%'_thm;
cn__pc_calA_pc__thm;
fun prot_use_string s = (use_string s; 0) handle _ => 1;

store_mt_results mt_run [
	("bind_var1", prot_use_string, 
	 "cn_E_pc__pc__pc_" ^ C_Q ^ "_pc__pc__pc_UAL_TEST3_thm", 0),
	("bind_var2", prot_use_string, 
	 "cn_E" ^ C_Q ^ "UAL_TEST1_thm", 0),
	("bind_var3", prot_use_string, "cn_" ^ C_Q ^ "_thm", 0),
	("bind_var4", prot_use_string, "cn_" ^ C_Q ^ "vVAL_thm", 0),
	("bind_var5", prot_use_string, "absolute_rubbish", 1)
];

=TEX
Lets check the remaining items in a cursory manner:
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
store_mt_results mt_run [("cn_script_support_thms", show_length o 
	cn_script_support_thms, thy_name,	250)];
=TEX
Have we created the sort of theorems we expected?
=SML
val gts3 = get_theory_stats "test_517";
store_mt_results mt_run [("create support theory 2", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 250})];
=TEX
=SML
force_delete_theory "test_517" handle _ => ();
open_theory thy_name;
new_theory "test_517";
store_mt_results mt_run [("list_cn_spec_rule", show_length o 
	list_cn_spec_rule,
	(map snd (get_defns thy_name @ get_axioms thy_name)),
	250)];
=TEX
Have we created the sort of theorems we expected?
=SML
val gts4 = get_theory_stats "test_517";
store_mt_results mt_run [("create support theory 3", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 250})];
=TEX
Finally, a simple test for $z\_norm\_sig\_h\_schema\_conv$:
=SML
ÿTüüüüüüüüüüü
Ü p : ú
÷üüüüüü
Ü p = 1
ˆüüüüüüüüüüüüüü
ÿSüüüüüüüüüüü
Ü q : ú
÷üüüüüü
Ü q = 1
ˆüüüüüüüüüüüüüü

store_mt_results (mt_runf (op =$)) [("z_norm_sig_h_schema_conv 1",
	z_norm_sig_h_schema_conv, ñ[a,b : X; T ; S; e : Z]®,
	ñ[a : X; b : X; e : Z; T; S]®)];

store_mt_results mt_run_fail [("z_norm_sig_h_schema_conv", z_norm_sig_h_schema_conv, ñ1®,
                gen_fail_msg "z_norm_sig_h_schema_conv" 47940 [string_of_term ¬1®])
];
=TEX
Nasty cases for $cn\_spec\_rule$:
=SML
¹ZAX
Ü S;
jjj : ú ­ ú
÷üüüüüü
jjj 0 = 1;
q = 2
Ü 
°

store_mt_results mt_run [("cn_spec_rule_nasty 1", length, 
	cn_spec_rule (get_spec ñq®), 4)];
=TEX
=SML
¹Z
Ü CC1 ::= CC1Null | CC1A ( ú )  
°
store_mt_results mt_run [("cn_spec_rule_nasty 2", length, 
	cn_spec_rule (get_spec ñCC1®), 1),
	("cn_spec_rule_nasty 3", length, 
	cn_spec_rule (get_spec ñCC1A®), 4)];
=TEX
=SML
¹Z
Ü [ AA, BB ]
°

store_mt_results mt_run [("cn_spec_rule_nasty 4", length, 
	cn_spec_rule (get_spec ñAA®), 1)];
=TEX
=SML
[X]œœœœœœœœœœœ
Ü DD : X ­ X
÷üüüüüü
Ü DD = id X
ˆüüüüüüüüüüüüüü
store_mt_results mt_run [("cn_spec_rule_nasty 5", length, 
	cn_spec_rule (get_spec ñDD®), 2)];
store_mt_results mt_run [("cn_spec_rule_nasty 5", length, 
	cn_spec_rule (get_spec ñS®), 1)];
=TEX
=SML
¹Z
Ü PP[X] ¦ id X
°
store_mt_results mt_run [("cn_spec_rule_nasty 5", length, 
	cn_spec_rule (get_spec ñ(PP[ú])®), 2)];
=TEX
Warnings:
=SML
store_mt_results_show mt_run [("cn_spec_rule 517001 a", length, 
	list_cn_spec_rule [(get_spec ñ(PP[ú])®)], 2)];
val was = set_flag("ignore_warnings",true);
store_mt_results_show mt_run [("cn_spec_rule 517001 b", length, 
	list_cn_spec_rule [(get_spec ñ(PP[ú])®)], 2)];
val was = set_flag("ignore_warnings",was);
=TEX
A few failure types:
=SML
val old_thy = get_current_theory_name();
open_theory "z_library";
store_mt_results_show mt_run_fail [("cn_spec_rule 517006",cn_spec_rule,
	get_spec ñ(_+_)®,
	gen_fail_msg "cn_spec_rule" 517006 [])];
open_theory old_thy;
store_mt_results_show mt_run_fail [("cn_spec_rule 517004",cn_spec_rule,
	t_thm,
	gen_fail_msg "cn_spec_rule" 517004 [string_of_thm t_thm])];
=TEX
Just to see what theory cn looks like:
=SML
force_delete_theory "cn_cn";
open_theory "imp517" handle _ => open_theory "cn";
new_theory "cn_cn";

store_mt_results mt_run [("cn_make_script_support cn", 
	show_length o cn_make_script_support "cn", "cn_cn",
	73)];
=TEX
Have we created the sort of theorems we expected?
=SML
val gts5 = get_theory_stats "cn_cn";
store_mt_results mt_run [("create support theory 5", get_theory_stats, "test_517",
	{na = 0, nc = 0, nd = 0, ng = 0, nt = 73})];

\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
pop_pc();
=TEX

\end{document}

