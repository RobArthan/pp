%  %Z%
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999

\def\DRASpecs{\cite{DRA/CIS/CSE3/TR/94/27/2.1}}
\def\Volume#1{\cite[volume #1]{DRA/CIS/CSE3/TR/94/27/2.1}\/}
\def\VolumeOne{\Volume 1}
\def\VolumeTwo{\Volume 2}
\def\VolumeThree{\Volume 3}

\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Theory Proof Support}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD509}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthors{K.~Blackburn&WIN01}
%\TPPauthors{K.~Blackburn&WIN01\\R.D.~Arthan&WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Team}
\TPPabstract{
This is a structure containing methods of making the paragraphs generated by the compliance notation available to the user in a
normalised form.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1 - 1.2] Initial Drafts.
\item[Issue 1.3] Specifically working towards fulfilling item 6 of \cite{ISS/HAT/DAZ/MIN09} v1.2.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document responds to the first and second recommendations of \cite{ISS/HAT/DAZ/WRK509}.
This is with the intent of fulfilling item 6 of \cite{ISS/HAT/DAZ/MIN09} v1.2.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This document gives the detailed designs for tools that provide an easy user interface to the non-conjecture paragraphs generated by the  Compliance Notation Tool.

\subsubsection{Dependencies}
This relies on the presence of the compliance notation material that comes prior to it in the DAZ build of \Product.

\subsubsection{Possible Enhancements}
See \cite{ISS/HAT/DAZ/WRK509}.

\section{DESIGN ISSUES}\label{DESIGNISSUES}
=IGN
\subsection{Pure Tools}
These tools take as input a list of axioms and definitions (or just extracts them from a nominated theory or theories) and saves theorems that are the best rewrite theorems that
can be derived using knowledge of Compliance Notation forms, as discussed in \cite{ISS/HAT/DAZ/WRK509}.
The theorems should be saved in the current theory (the user may wish to use $new\_theory$ first).
It should also bind all the derived theorems to ML value names, and produce one or more
ML bindings of lists of theorems (most importantly, all generated theorems).

This will not expand out the definitions of any Compliance Notation constants, even those linked by apparently being generated from the same
basic declaration.

The new theorems should be sufficient that the original axioms and definitions need no longer be used 
(this ability to hide the original items is the only reason for processing axioms, as the
only relevant axioms are of the form $name : type$ which has little processing that
can be done).

The names of these tools are all prefixed $pure\_cn\_$.

\subsection{Alternative Tools}
=TEX
These tools follow the alternative categorisation of definitions in
\cite{ISS/HAT/DAZ/WRK509}.

This was as follows:
\begin{itemize}
\item
The definition is of a constant -- doesn't use other compliance notation definitions for simplification.
\item
The definition is of a kind of type attribute that is always a function
(e.g. the successor attribute). 
Such definitions will be presented as a conditional rewrite for the
application of the function.
This will use definitions for the type and its other attributes for simplification.
\item
The definition is of a kind of type attribute that is not always a function (e.g. scalar or a range) -- doesn't use other compliance notation definitions for simplification.
\item
The definition equates a type to a set abstraction of a standard form for the
Compliance Notation (e.g. cases 2 and 3 of subtypes).
Such definitions will be presented as defining the type equal to the intersection of a total function
and some pre-existing type, which may be more convenient for reasoning.
This will use definition of the master type for the subtype for simplification.
\item
The definition is of a type, but is some other form than one of the standard set abstraction forms -- doesn't use other compliance notation definitions for simplification.
\end{itemize}

The names of these tools are all prefixed $cn\_$.

=IGN

The following preamble creates the theory ``cn_theory_support'' as a child of ``z\_library''.

=IGN
open_theory"cn";
push_pc "z_library";
delete_theory"cn_theory_support" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
new_theory"cn_theory_support";
=TEX
\section{THE STRUCTURE}\label{THESTRUCTURE}
\subsection{Preamble}

=DOC
signature ÛCNTheoryProofSupportÝ = sig
=DESCRIBE
This is the signature for the Theory Proof Support Tools.
=ENDDOC
=IGN
\subsection{Pure Tools}

 =DOC
val Ûpure_cn_support_theoryÝ : string -> unit;
val Ûlist_pure_cn_support_theoryÝ : string list -> unit;
 =DESCRIBE
$pure\_cn\_support\_theory$ takes a theory name as argument.
Assuming the theory is in scope it will examine each of the definitions and
axioms in the theory.

For definitions, if they are of the form:
 =GFT
name == RHS
 =TEX
they will be processed as below, and likewise if an axiom is of the form:
 =GFT
name : TYPE
 =TEX
or
 =GFT
[ name ]
 =TEX
they will be processed as below.
Otherwise, any other forms of definition or axiom will be ignored.

The processing will attempt to save theorems of the form:
 =GFT
ô name = RHS'
ô name  TYPE'
ô name = U
 =TEX
respectively, where $RHS'$, $TYPE'$ may be $RHS$ and $TYPE$ or may be simplified versions.
The simplifications will be by reasoning about constructs from $z\_library$ or its ancestors.

The theorems will be saved in the current theory under the name $cts\_name\_thm$,
and will also be bound to an ML variable of the same name.
If the theorem name is already in use then it is assumed to be for an earlier
use of a compliance notation support tool, and the theorem will be replaced, and a warning issued.

Finally, a list of the theorems generated will be bound to the ML name $cts\_theoryname\_thms$.
$theoryname$ will usually be the name of the source theory, but this can contain characters that may not be used in ML variable names, and these will be replaced
with suitable ASCII variants.
The actual name used can be determined from the output of making the ML bindings 
generated by the function.

$list\_pure\_cn\_support\_theory$ acts like $pure\_cn\_support\_theory$ mapped over a list of theory names, except that duplicate names in the list will be ignored.

The theorem saved will imply the source axiom or definition, i.e. no information is lost if only the new theorems are used.
 =SEEALSO
$cn\_support\_theory$, 
$pure\_cn\_support\_thms$, 
$pure\_cn\_support\_thm$
 =FAILURE
517001	Theorem ?0 in theory ?1 has been replaced by a new Compliance Notation
	support theorem
517002	Cannot force the saving of theorem ?0 in theory ?1
 =ENDDOC

 =DOC
val Ûpure_cn_support_thmsÝ : THM list -> string -> unit;
 =DESCRIBE
$pure\_cn\_support\_thms$ takes a list of theorems and processes those that are Z paragraphs, as if by $pure\_cn\_support\_theory$,
except that it binds the list of created theorems to the ML name that is the function's second argument, failing before saving any theorems if that is not a valid ML name.
 =FAILURE
517001	Theorem ?0 in theory ?1 has been replaced by a new Compliance Notation
	support theorem
517002	Cannot force the saving of theorem ?0 in theory ?1
517003	?0 is not a valid ML variable name
 =ENDDOC

 =DOC
val Ûpure_cn_support_thmÝ : THM -> string * THM;
 =DESCRIBE
$pure\_cn\_support\_thm$ processes its single theorem as if by $pure\_cn\_support\_theory$,
except that it does not save the resulting theorem, or bind it to an ML variable.
The function instead returns the name that $pure\_cn\_support\_theory$ would have used,
and the theorem it would have saved.
 =FAILURE
517004	?0 is not capable of being supported
 =ENDDOC

\subsection{Alternative Tools}
=TEX
=DOC
val Ûz_norm_sig_h_schema_convÝ : CONV;
=DESCRIBE
Given an arbitrary hozitonal schema, $ñ[ sig | body ]®$, this conversion will
return the theorem that states that the original horizontal schema is equal to one with
the signature variables placed in $z\_sig\_order$ in a list of declarations
(SDECLs) each with only a single variable.
E.g. 
=GFT
[x, z: X; y : Y; v, w :Z | (v, w, x, z, y, w)  p ]
will become
[ v : Z; w : Z; x : X; y : Y; z : X | (v, w, x, z, y, w)  p ]
=TEX
=FRULE 1 Conversion
z_norm_sig_h_schema_conv
ñ[ sig | pred ]®
÷
÷
ô [ sig | pred ] = [ sig' | pred ]
=TEX
and
=FRULE 1 Conversion
z_norm_sig_h_schema_conv
ñ[ sig ]®
÷
÷
ô [ sig ] = [ sig' ]
=TEX
where $sig'$ is the normalised form of sig.
It is possible for this conversion to cause no change.
=FAILURE
517005	?0 is not a horizontal schema
=ENDDOC

=DOC
val Ûcn_simplify_canonÝ : THM -> THM list;
=DESCRIBE
This does some Compliance Notation specific simplifications, if
the appropriate definitions are available:
=GFT
ô namevSUCC = (name \ {namevLAST} ) ò succ
	becomes 	
	ô µ i : int‰1 .. (name‰1 - 1) · namevSUCC i = i + 1
	where int‰1 is the first natural number of the range name, and name‰1
	is the top expression of the range that name translates to, and
	ô namevSUCC  name \ {namevLAST} ­ name

ô namevPRED = namevSUCC ç~ê
	becomes 	
	ô µ i : int‰1 .. name‰2 · namevPRED i = i - 1
	where int‰1 is the second natural number of the range name, and name‰1
	is the top expression of the range that name translates to, and
	ô namevPRED  name \ {int‰2} ­ name
	where int‰2 is the first natural number in the range

ô namevPOS = id name
	becomes 	
	ô µ i : name · namevPOS i = i
	and
	namevPOS  name ­ name

ô namevVAL = namevPOS ç~ê
	becomes 	
	ô µ i : name · namevVAL i = i
	and
	namevVAL  name ­ name

ô name = {u : master | dom u = index}
	becomes 	
	ô name = (index ­ comp) ¡ master

ô name = [ sig ]
	becomes
	ô name = [ sig' ]
	where sig' is the normalised form of sig, via z_norm_sig_z_schema_conv

ô name = [ sig | pred ]
	becomes
	ô name = [ sig' | pred ]
	where sig' is the normalised form of sig, via z_norm_sig_z_schema_conv
=TEX
The canonicalisation may also do some limited simplification to theorems that
partially match the patterns given above.

If none of simplifications apply
then the canon returns the empty list.
=ENDDOC

=DOC
val Ûcn_support_theoryÝ : string -> unit;
val Ûlist_cn_support_theoryÝ : string list -> unit;
=DESCRIBE
$cn\_support\_theory$ $pure\_cn\_support\_theory$ takes a theory name as argument.
Assuming the theory is in scope it will examine each of the definitions and
axioms in the theory.

For definitions, if they are of the form:
=GFT
name == RHS
=TEX
they will be processed as below, and likewise if an axiom is of the form:
=GFT
name : TYPE
=TEX
or
=GFT
[ name ]
=TEX
they will be processed as below.
Otherwise, any other forms of definition or axiom will be ignored.

Unless other simplifications apply, processing will attempt to save theorems of the form:
=GFT
ô name = RHS'
ô name  TYPE'
ô name = U
=TEX
respectively, where $RHS'$, $TYPE'$ may be $RHS$ and $TYPE$ or may be simplified versions.

These generic simplifications may be supplimented by some changes specific
to the compliance notation, provided by applying $cn\_simplify\_canon$ to the generic theorem of the above (which may return multiple theorems), as follows.

The first theorem, if any, returned by $cn\_simplify\_canon$ will be saved in the current theory under the name $cn\_name\_thm$;
the second theorem returned will be saved under the name $cn\_name\_ty\_thm$;
and if it returns no theorems then the generic form of the theorem will be saved in the current theory under the name $cn\_name\_thm$.
Saved theorems will also be bound to an ML variable of the same name.
If the theorem name is already in use then it is assumed to be for an earlier
use of the support tool, and the theorem will be replaced, and a warning issued.

Finally, a list of the theorems generated will be bound to the ML name $cn\_theoryname\_thms$.

$list\_cn\_support_theory$ acts like $cn\_support\_theory$ mapped over a list of theory names, except that duplicate names in the list will be ignored.
=SEEALSO
$cn\_support\_thms$, 
$cn\_support\_thm$,
=FAILURE
517001	Theorem ?0 in theory ?1 has been replaced by a new Compliance Notation
	support theorem
517002	Cannot force the saving of theorem ?0 in theory ?1
=ENDDOC

=DOC
val Ûcn_support_thmsÝ : THM list -> string -> unit;
=DESCRIBE
$cn\_support\_thms$ takes a list of theorems and analyses those that are Z paragraphs as if by $cn\_support\_theory$,
except that it binds the list of created theorems to the ML name that is the function's second argument, failing before saving any theorems if that is not a valid ML name.

Note that in particular this means that the function can be applied to the results of $get\_spec$, but not those of $z\_get\_spec$.
=FAILURE
517001	Theorem ?0 in theory ?1 has been replaced by a new Compliance Notation
	support theorem
517002	Cannot force the saving of theorem ?0 in theory ?1
517003	?0 is not a valid ML variable name
=ENDDOC

=DOC
val Ûcn_support_thmÝ : THM -> (string * THM) list;
=DESCRIBE
$cn\_support\_thm$ analyses its single theorem as if by $cn\_support\_theory$,
except that it does not save the resulting theorem, or bind it to an ML variable.
The function instead returns the name or names that $cn\_support\_theory$ would have used,
and the theorem or theorems it would have saved, except that
unchanged theorems will result in an empty list being returned.
=ENDDOC

=DOC
val Ûcn_pc_support_theoryÝ : string -> string -> unit;
val Ûlist_cn_pc_support_theoryÝ : string list -> string -> unit;
=DESCRIBE
$cn\_pc\_support\_theory$ $thyname$ $pcname$ 
will first attempt to act as $cn\_support\_theory$ $thyname$, and will then 
create (overwriting previous versions) a complete proof context called $pcname$.

$list\_cn\_pc\_support\_theory$  $thynames$ $pcname$ will first attempt to act as $list\_cn\_support\_theory$ $thynames$, and will then 
create (overwriting previous versions) a complete proof context called $pcname$.

The proof context created will be ``cn1'' extended by:
\paragraph{Contents}
Rewriting: all saved support theorems (except equations with U);

Stripping theorems: bi-implications from support theorems, plus support theorem equations of sets promoted to biimplications of 
memberships (except where U elimation will apply).

Stripping conclusions:  as stripping conclusions.

Rewriting canonicalisation: no change;

Automatic proof procedures: no change.

Existence prover: no change.

The U simplification material will be extended by appending equation context by the one formed from the equations of the form $nm = U$, via $set\_u\_simp\_eqn\_cxt$.

\paragraph{Usage Notes}
It requires its creation theory and theory $thyname$ to be in scope.
It is not intended to be mixed with HOL proof contexts.

=FAILURE
517001	Theorem ?0 in theory ?1 has been replaced by a new Compliance Notation
	support theorem
517002	Cannot force the saving of theorem ?0 in theory ?1
=ENDDOC

=DOC
val Ûfull_cn_pc_support_theoryÝ : string -> unit;
=DESCRIBE
$full\_cn\_pc\_support\_theory$ $pcname$ will determine all the theories that 
are parents of the current one, that are not also ``cn'' or parents of ``cn'',
and will execute $list\_cn\_pc\_support\_theory$ on this list.

That is, this will create a proof context based on all the in scope Compliance Notation packages.
\subsection{Epilogue}
=SML
end (* end of signature CNTheoryProofSupport *);
=TEX
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
reset_flag("standard_z_paras");
=TEX


=TEX
\section{TEST POLICY}

The module tests for this module are to follow the guidelines
identified in the quality plan~\cite{ISS/HAT/DAZ/PLN003}.
There are no special testing considerations.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



