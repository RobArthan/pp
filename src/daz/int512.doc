=IGN
********************************************************************************
int512.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Date: 2002/10/17 15:46:52 $ $Revision: 1.14 $ $RCSfile: int512.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Tests for Annotations}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT512}  %% Mandatory field
\def\SCCSversion{$Revision: 1.14 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/10/17 15:46:52 $%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{K.~Blackburn & WIN01}
\TPPabstract{%
This document gives Compliance Notation scripts which test the treatment of SPARK annotations.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.4] Initial Drafts.
\item[Issue 1.5] Addressed comments from DRA and Praxis.
\item[Issue 1.6] Allowed for one-compilation-unit-per-script rule.
Added a line length test.
\item[Issue 1.7] Made it defensive about the absence of the SPARK examiner.
\item[Issue 1.8] Allowed for bizarre behaviour of {\tt which} on Solaris.
\item[Issue 1.9] Made life a bit easier for running the MS Windows demo copy
\item[Issue 1.10] New symbol for expansion of statement labels.
\item[Issue 1.11] {\it ExtendedIO.execute} has been withdrawn.
\item[Issue 1.12] Removed use of ICL logo font.
\item[Issue 1.13] Copyright and banner updates for open source release.
\item[Issue 1.14] DAZ-specific updates to banner for open source release
\item[Issue 1.15] DAZ-specific updates to banner for open source release
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool.
It exemplifies the enhancements required under contract ref. CSM/452 (see \cite{ISS/HAT/DAZ/PLN013}).

\subsection{Introduction}

From version 0.6 on, the Compliance Tool has supported the use of SPARK annotations in all places where the SPARK definition requires or permits them.
The method used to implement annotations at version 0.6 allows k-slots to be used in place of annotations in some, but not all, places where an annotation is permitted.
Under contract ref. CSM/452, an enhancement is implemented permitting k-slots to appear wherever an annotation may appear.

This document provides examples of each syntactic position in which an annotation may appear.
This is intended as a cross-check on the enhancement carried out under CSM/452.


\newpage
\section{TEST CASES}
The following list identifies the syntactic positions where the definition of SPARK \cite{PVL92} permits or requires annotations to appear.
The numeric references (6.1, 6.3 etc.) below refer to the sections of the Ada Language Reference Manual \cite{AJPO83} as used to organise the syntax in \cite{PVL92}.

\begin{description}
\item[1. Procedure/function annotations (6.1)]
immediately after the semi-colon which terminates a subprogram declaration.
\item[2. Procedure/function annotations (6.3)]
between the subprogram specification and the reserved word ``{\tt is}'' at the head of a subprogram body.
\item[3. Hide directive (6.3)]
as a substitute for part of a subprogram body.
In the Compliance Tool, hide directives do {\em not} suppress processing of the subprogram body; an arbitrary Ada replacement must be used to achieve that effect.
The Compliance Tool treats the hide directive as an annotation standing as a declaration in the declarative part of the subprogram.
\item[4. Inherit clause (7.1)]
Immediately before a package specification.
\item[5. Package annotation (7.1)]
Immediately after the package name at the head of a package specification.
\item[6. Refinement Definition (7.1)]
Immediately after the package name at the head of a package body.
\item[7.Hide directive (7.1)]
as a substitute for part of a package body or for the private part of package specification.
Much as for hide directives in subprogram bodies, the Compliance Tool treats the hide directive as an annotation standing as a declaration in the declarative part of the package body.
\item[8. Inherit clause (10.1)]
Immediately before a main program annotation.
\item[9. Main program annotation (10.1)]
Immediately before the subprogram body for the main program.
\item[10.  Procedure/function annotations (10.2)]
immediately after the semi-colon which terminates a subprogram declaration considered as a body stub in SPARK.
(These are treated identically with the procedure/function annotations of section 6.1 in the Compliance Tool.)
\end{description}

The SPARK Examiner supports a few other annotations; procedure and function constraints, assert and check predicates and proof functions.
These appear in positions where the annotations above are allowed, and are tried at convenient points in the test below.

The remainder of this document is organised around the above test cases as follows:

\begin{description}
\item[Section \ref{NOKSLOTS}] exhibits each of the test cases not using k-slots
\item[Section \ref{OKKSLOTS}] exhibits the cases where k-slots are already supported at V0.6
\item[Section \ref{BADKSLOTS}] exhibits the cases where k-slots are not supported at V0.6
\end{description}

The Ada files produced by processing this document are intended to be valid input for the SPARK Examiner.
The files intended for the SPARK Examiner are named ``int512??.ada'' where the
first question mark is a letter in the range `a-d'  and the second one is a digit.
Each of these files is intended to be a self-contained piece of input for
a run of the SPARK Examiner. Processing more than one of the files in a run
may cause unintended errors.

The demo version of the SPARK Examiner runs under MS Windows or MS-DOS.
DOS is most convenient for batch processing. This document generates a .BAT file
``int512.bat'' which
will run the tests after shipping the files ``int512??.ada'' and ``int512.wrn''
into a suitable DOS directory.
The necessary files are packed into a zip archive ``int512.zip'' for shipping
to the DOS machine (or ``int512.tar'' if zip is not available).
Unpacking the archive on DOS and running ``int512.bat'' will run the SPARK
Examiner on all the test files and produce an archive of reports and listings
in ``results.zip''.

Currently two test files, ``int512a6.ada'' and ``int512B4.ada''
result in an error under demo version 5.01 of the SPARK Examiner.
This is because SPARK'95 insists on the IMPORT pragma rather than the older
INTERFACE pragma and the documented command-line options to select SPARK'83
do not appear to work.

The tests for the HIDE directive are expected to generate SPARK Examiner warnings.
The options used in the .BAT file help avoid confusing these with errors.


\subsection{Test Setup}
This section gives some ML preliminaries to help run the tests.

Load the test harness:
=SML
use_file "dtd013";
use_file "imp013";
=TEX
Define a function to initialise system for a test case.
=SML
fun test_case (name : string) = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;   
	new_script{name=name, state=initial_cn_state}
);

=TEX
\newpage
\section{EXAMPLES WITHOUT K-SLOTS}\label{NOKSLOTS}
This section exhibits each of the test cases without using k-slots.
Since this material is only for regression testing, the test cases are grouped together sa convenient.

\subsection{Cases 1 and 5}
This is a convenient point to check proof functions.
=SML
test_case"int512a.1";
=TEX

¹CN
  package INT512A_1
    --# own A ;			-- package annotation (case 5)
  is
    procedure P (X : in INTEGER; Y : out INTEGER) ;
   --# derives Y from X ;		-- procedure annotation (case 1)
   A : INTEGER;
   function F return INTEGER ;
   --# global A ;			-- function annotation (case 1)
   --# function H ( X : INTEGER ) return INTEGER ;
					-- proof function
  end INT512A_1 ;
°
=TEX
=SML
output_spark_program{out_file="int512a1.ada"};
=TEX
\subsection{Cases 1, 2, 5, 8 and 9}\label{CASES12589}
Note: when the SPARK Examiner with VC Generator is used, procedure and function annotations may be immediately followed by procedure and function constraints.
These give pre- and post-conditions for the subprogram and are syntactically just annotations.
For completeness, this facility is tested here, as are assert predicates.
=SML
test_case"int512a.2";
=TEX


¹CN
 package INT512A_2
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (A : in INTEGER; B : out INTEGER) ;
   --# derives B from A ;		-- procedure annotation (case 1)
   --# pre true ;			-- procedure constraint
   --# post B = 2 * A ;		-- procedure constraint
    G : INTEGER;
 end INT512A_2 ;
°
=SML
output_spark_program{out_file="int512a2a.ada"};
val state1 = get_cn_state();
new_script{name="int512a.2a", state=state1};
¹CN
 package body INT512A_2 is
  procedure Q(A : in INTEGER; B : out INTEGER)
  is
   procedure P (X : in INTEGER; Y : out INTEGER)
   --# derives Y from X ;		-- procedure annotation (case 2)
   is
   begin
       Y := X + X;
	--# assert Y = X + X ;
   end P ;
 begin
   P(A, B);
 end Q ;
 begin
   G := 1001;
 end INT512A_2 ;
°
=SML
output_spark_program{out_file="int512a2b.ada"};
val state2 = get_cn_state();
new_script{name="int512a.2b", state=state2};
¹CN
 with INT512A_2;
 --# inherit INT512A_2 ;		-- inherit clause (case 8)
 --# main_program			-- main program annotation (case 9)
 function INT512AB return INTEGER
 --# global INT512A_2.G ;		-- function annotation (case 2)
 --# return INT512A_2.G ;		-- function constraint
 is
 begin
    return INT512A_2.G ;
 end INT512AB ;
°

=SML
output_spark_program{out_file="int512a2c.ada"};
ExtendedIO.system"cat int512a2a.ada int512a2b.ada int512a2c.ada > int512a2.ada";
=TEX
\subsection{Cases 3 and 9}
=SML
test_case"int512a.3";
=TEX

¹CN
 --# main_program			-- main program annotation (case 9)
 procedure INT512A3
 --# derives ;
 is
 --# hide INT512A3				-- hide directive (case 3)
 begin
    null;
 end INT512A3 ;
°
=TEX
=SML
output_spark_program{out_file="int512a3.ada"};
=TEX
\subsection{Cases 2 and 4}
=SML
test_case"int512a.4";
=TEX


¹CN
 package INT512A_4_A
 is
   type T is range 1 .. 10 ;
 end INT512A_4_A ;
°
=SML
output_spark_program{out_file="int512a4a.ada"};
val state3 = get_cn_state();
new_script{name="int512a.4a", state=state3};
¹CN
 with INT512A_4_A;
 --# inherit INT512A_4_A ;		-- inherit clause (case 4)
 package INT512A_4_B
 is
   procedure P (X : in INT512A_4_A.T; Y : OUT INT512A_4_A.T) ;
   --# derives Y from X ;			-- procedure annotation (case 2)
 end INT512A_4_B ;
°

=SML
output_spark_program{out_file="int512a4b.ada"};
ExtendedIO.system"cat int512a4a.ada int512a4b.ada > int512a4.ada";
=TEX
\subsection{Cases 1, 5 and 6}
=SML
test_case"int512a.5";
=TEX


¹CN
 package INT512A_5
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (B : out INTEGER) ;
    --# global G ;			-- procedure annotation (case 1)
    --# derives B from G ;		-- procedure annotation (case 1)
 end INT512A_5 ;
°
=SML
output_spark_program{out_file="int512a5a.ada"};
val state4 = get_cn_state();
new_script{name="int512a.5a", state=state4};
¹CN
 package body INT512A_5
 --# own G is X, Y ;			-- refinement definition (case 6)
 is
  X : INTEGER ;
  Y : INTEGER ;
  procedure Q(B : out INTEGER)
   --# global X, Y ;			-- procedure annotation (case 1)
   --# derives B from X, Y ;		-- procedure annotation (case 1)
  is
 begin
   B := X + Y ;
 end Q ;
 begin
   X := 1001;
   Y := 999;
 end INT512A_5 ;
°

=SML
output_spark_program{out_file="int512a5b.ada"};
ExtendedIO.system"cat int512a5a.ada int512a5b.ada > int512a5.ada";
=TEX
\subsection{Cases 1, 6 and 10}
=SML
test_case"int512a.6";
=TEX


¹CN
 package INT512A_6
 --# own G ;
 is
    procedure Q (B : out INTEGER) ;
   --# global G ;			-- procedure annotation (case 1)
    --# derives B from G;		-- procedure annotation (case 1)
 end INT512A_6 ;
°
=SML
output_spark_program{out_file="int512a6a.ada"};
val state5 = get_cn_state();
new_script{name="int512a.6a", state=state5};
¹CN
 package body INT512A_6
 --# own G is X ;			-- refinement definition (case 6)
 is
  X : INTEGER;
  procedure Q(B : out INTEGER) ;
  --# global X ;			-- procedure annotation (case 10)
  --# derives B from X ;		-- procedure annotation (case 10)
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512A_6 ;
°

=SML
output_spark_program{out_file="int512a6b.ada"};
ExtendedIO.system"cat int512a6a.ada int512a6b.ada > int512a6.ada";
=TEX
\subsection{Cases 1 and 7}
=SML
test_case"int512a.7";
=TEX


¹CN
 package INT512A_7
 is
    type T is private ;
    procedure Q (B : out INTEGER) ;
    --# derives B from ;		-- procedure annotation (case 1)
 private
--# hide INT512A_7			-- hide directive (case 7)
    type T is range 1 .. 10 ;
 end INT512A_7 ;
°
=SML
output_spark_program{out_file="int512a7a.ada"};
val state6 = get_cn_state();
new_script{name="int512a.7a", state=state6};
¹CN
 package body INT512A_7
 is
  --# hide INT512A_7			-- hide directive (case 7)
  procedure Q(B : out INTEGER) ;
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512A_7 ;
°

=SML
output_spark_program{out_file="int512a7b.ada"};
ExtendedIO.system"cat int512a7a.ada int512a7b.ada > int512a7.ada";
=TEX
\newpage
\section{EXAMPLES WITH K-SLOTS (WORKING AT V0.6)}\label{OKKSLOTS}
This section tests the cases of k-slots as annotations which are already supported at V0.6.
The examples are generally based on the ones in section \ref{NOKSLOTS}.
However, in this section we give a single test for each case, rather than grouping the test cases.

\subsection{Case 1}
This is a convenient point to check procedure and function constraints as well as proof functions.

=SML
test_case"int512b.1";
=TEX

¹CN
  package INT512B_1
    --# own A ;			-- package annotation (case 5)
  is
    procedure P (X : in INTEGER; Y : out INTEGER) ;
  § procedure annotation (case 1) ¢			( 1001 )

   A : INTEGER;
   function F return INTEGER ;
  § function annotation (case 1) ¢			( 1002 )
  end INT512B_1 ;
°
¹CN
 (1001) é 
  --# derives Y from X ;		-- procedure annotation (case 1)
  --# pre true ;			-- procedure constraint
  --# post Y = 2 * X ;		-- procedure constraint
°
¹CN
 (1002) é 
   --# global A ;			-- function annotation (case 1)
   --# return 1000 ;			-- function constraint
   --# function H ( X : INTEGER ) return INTEGER ;
					-- proof function
°
=TEX
=SML
output_spark_program{out_file="int512b1.ada"};
=TEX
\subsection{Case 3}
For completeness, we also try the assert annotation here.
=SML
test_case"int512b.2";
=TEX

¹CN
 --# main_program			-- main program annotation (case 9)
 procedure INT512B2
 --# derives ;
 is
 § hide directive (case 3) ¢			( 1011 )
 
 begin
 § assert annotation ¢			( 1012 )
    null ;
 end INT512B2 ;
°
¹CN
 (1011) é --# hide INT512B2		-- hide directive (case 3)
°
¹CN
  (1012) !Ã --# assert true ;
°

=TEX
=SML
output_spark_program{out_file="int512b2.ada"};
=TEX
\subsection{Case  7}
=SML
test_case"int512b.3";
=TEX

¹CN
 package INT512B_3
 is
    type T is private ;
    procedure Q (B : out INTEGER) ;
    --# derives B from ;		-- procedure annotation (case 1)
 private
 § hide directive (case 7) ¢			( 1021 )

    type T is range 1 .. 10 ;
 end INT512B_3 ;
°
¹CN
 (1021) é --# hide INT512B_3	-- hide directive (case 7)
°
=SML
output_spark_program{out_file="int512b3a.ada"};
val state7 = get_cn_state();
new_script{name="int512b.3a", state=state7};
¹CN
 package body INT512B_3
 is
 § hide directive (case 7) ¢			( 1022 )
  procedure Q(B : out INTEGER) ;
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512B_3 ;
°
¹CN
 (1022) é --# hide INT512B_3	-- hide directive (case 7)
°
=SML
output_spark_program{out_file="int512b3b.ada"};
ExtendedIO.system"cat int512b3a.ada int512b3b.ada > int512b3.ada";
=TEX
=TEX
\subsection{Case 10}
=SML
test_case"int512b.4";
=TEX


¹CN
 package INT512B_4
 --# own G ;
 is
    procedure Q (B : out INTEGER) ;
   --# global G ;			-- procedure annotation (case 1)
   --# derives B from G;		-- procedure annotation (case 1)
 end INT512B_4 ;
°
=SML
output_spark_program{out_file="int512b4a.ada"};
val state8 = get_cn_state();
new_script{name="int512b.4a", state=state8};
¹CN
 package body INT512B_4
 --# own G is X ;			-- refinement definition (case 6)
 is
  X : INTEGER;
  procedure Q(B : out INTEGER) ;
 § procedure annotations (case 10) ¢			( 1031 )
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512B_4 ;
°
¹CN
 (1031) é
  --# global X ;			-- procedure annotation (case 10)
  --# derives B from X ;		-- procedure annotation (case 10)
°

=SML
output_spark_program{out_file="int512b4b.ada"};
ExtendedIO.system"cat int512b4a.ada int512b4b.ada > int512b4.ada";
=TEX
=TEX
\newpage
\section{EXAMPLES WITH K-SLOTS (NOT WORKING AT V0.6)}\label{BADKSLOTS}
This section tests the cases of k-slots as annotations which are not supported at V0.6.
As in section \ref{OKKSLOTS}, the examples are based on the ones in section \ref{NOKSLOTS} and each case is given a test of its own.
=TEX
\subsection{Case 2}
=SML
diag_line"**** REMAINING TESTS WILL FAIL AT V0.6/V0.7 ****";
test_case"int512c.1";
=TEX


¹CN
 package INT512C_1
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (A : in INTEGER; B : out INTEGER) ;
   --# derives B from A ;		-- procedure annotation (case 1)
    G : INTEGER;
 end INT512C_1 ;
°
=SML
output_spark_program{out_file="int512c1a.ada"};
val state9 = get_cn_state();
new_script{name="int512c.1a", state=state9};
¹CN
 package body INT512C_1 is
  procedure Q(A : in INTEGER; B : out INTEGER)
  is
   procedure P (X : in INTEGER; Y : out INTEGER)
 § procedure annotation (case 2) ¢			( 3001 )
   is
   begin 
       Y := X + X;
   end P ;
 begin
   P(A, B);
 end Q ;
 begin
   G := 1001;
 end INT512C_1 ;
°
¹CN
 (3001) é
    --# derives Y from X ;		-- procedure annotation (case 2)
°
=SML
output_spark_program{out_file="int512c1b.ada"};
val state10 = get_cn_state();
new_script{name="int512c.1b", state=state10};
¹CN
 with INT512C_1;
 --# inherit INT512C_1 ;		-- inherit clause (case 8)
 --# main_program			-- main program annotation (case 9)
 function INT512C1 return INTEGER
 § function annotation (case 2) ¢			( 3002 )
 is
 begin
    return INT512C_1.G ;
 end INT512C1 ;
°
¹CN
 (3002) é
 --# global INT512C_1.G ;	-- function annotation (case 2)
°

=SML
output_spark_program{out_file="int512c1c.ada"};
ExtendedIO.system"cat int512c1a.ada int512c1b.ada int512c1c.ada > int512c1.ada";
=TEX
\subsection{Case 4}
=SML
test_case"int512c.2";
=TEX


¹CN
 package INT512C_2_A
 is
   type T is range 1 .. 10 ;
 end INT512C_2_A ;
°
=SML
output_spark_program{out_file="int512c2a.ada"};
val state11 = get_cn_state();
new_script{name="int512c.2a", state=state11};
¹CN
 with INT512C_2_A;
 § inherit clause (case 4) ¢			( 3011 )
 package INT512C_2_B
 is
   procedure P (X : in INT512C_2_A.T; Y : OUT INT512C_2_A.T) ;
   --# derives Y from X ;		-- procedure annotation (case 2)
 end INT512C_2_B ;
°
¹CN
 (3011) é --# inherit INT512C_2_A ;	-- inherit clause (case 4)
°
=SML
output_spark_program{out_file="int512c2b.ada"};
ExtendedIO.system"cat int512c2a.ada int512c2b.ada > int512c2.ada";
=TEX
\subsection{Case 5}
=SML
test_case"int512c.3";
=TEX


¹CN
 package INT512C_3
 § package annotations (case 5) ¢			( 3021 )
 is
    procedure Q (B : out INTEGER) ;
    --# global G ;			-- procedure annotation (case 1)
    --# derives B from G ;		-- procedure annotation (case 1)
 end INT512C_3 ;
°
¹CN
 (3021) é 
 --# own G ;				-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
°

=SML
output_spark_program{out_file="int512c3.ada"};
=TEX
\subsection{Case 6}
=SML
test_case"int512c.4";
=TEX


¹CN
 package INT512C_4
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (B : out INTEGER) ;
    --# global G ;		-- procedure annotation (case 1)
    --# derives B from G ;		-- procedure annotation (case 1)
 end INT512C_4 ;
°
=SML
output_spark_program{out_file="int512c4a.ada"};
val state12 = get_cn_state();
new_script{name="int512c.4a", state=state12};
¹CN
 package body INT512C_4
 § refinement definition (case 6) ¢			( 3031 )
 is
  X : INTEGER ;
  Y : INTEGER ;
  procedure Q(B : out INTEGER)
   --# global X, Y ;			-- procedure annotation (case 1)
   --# derives B from X, Y ;		-- procedure annotation (case 1)
  is
 begin
   B := X + Y ;
 end Q ;
begin
   X := 1001;
   Y := 999;
 end INT512C_4 ;
°
¹CN
 (3031) é 
 --# own G is X, Y ;			-- refinement definition (case 6)
°

=SML
output_spark_program{out_file="int512c4b.ada"};
ExtendedIO.system"cat int512c4a.ada int512c4b.ada > int512c4.ada";
=TEX

=TEX
\subsection{Cases 8 and 9}
=SML
test_case"int512c.5";
=TEX

¹CN
 package INT512C_5
 is
    procedure Q (B : out INTEGER) ;
    --# derives B from ;		-- procedure annotation (case 1)
 end INT512C_5 ;
°
=SML
output_spark_program{out_file="int512c5a.ada"};
val state13 = get_cn_state();
new_script{name="int512c.5a", state=state13};
¹CN
 with INT512C_5;
 § inherit clause etc. (cases 8 and 9) ¢			( 3041 )
 function INT512C5A return INTEGER
 is
 begin
    return 99 ;
 end INT512C5A ;
°
¹CN
 (3041) é
 --# inherit INT512C_5 ;	-- inherit clause (case 8)
 --# main_program			-- main program annotation (case 9)
°
=SML
output_spark_program{out_file="int512c5b.ada"};
ExtendedIO.system"cat int512c5a.ada int512c5b.ada > int512c5.ada";
=TEX
\section{LINES TOO LONG}
If the output line length was not controlled, the following would cause an
SPARK error.
=SML
test_case"int512d.1";
=TEX

¹CN
  package INT512D_1
    --# own A ,		-- package annotation (case 5)
    --#  A11111111, B11111111, C11111111, 
     --#  D11111111, E11111111, F11111111,
     --#  G11111111, H11111111, I11111111,
     --# J11111111, K11111111, L11111111, M11111111,
      --# N11111111, O11111111, P11111111, Q11111111, 
      --# R11111111, S11111111, T11111111,
      --# U11111111, V11111111, W11111111,
      --# X11111111, Y11111111, Z11111111, AA11111111,
      --# BB11111111, CC11111111, DD11111111,
      --# EE11111111, FF11111111, GG11111111,
      --# HH11111111, II11111111;
  is
    procedure P (X : in INTEGER; Y : out INTEGER) ;
   --# derives Y from X ;
     A, A11111111, B11111111, C11111111, 
     D11111111, E11111111, F11111111,
     G11111111, H11111111, I11111111,
     J11111111, K11111111, L11111111, M11111111,
     N11111111, O11111111, P11111111, Q11111111, 
     R11111111, S11111111, T11111111,
     U11111111, V11111111, W11111111,
     X11111111, Y11111111, Z11111111, AA11111111,
     BB11111111, CC11111111, DD11111111,
     EE11111111, FF11111111, GG11111111,
     HH11111111, II11111111 : INTEGER;
function F return INTEGER ;
   --# global A ,
      --#  A11111111, B11111111, C11111111, 
      --#  D11111111, E11111111, F11111111,
      --#  G11111111, H11111111, I11111111,
      --# J11111111, K11111111, L11111111, M11111111,
      --# N11111111, O11111111, P11111111, Q11111111, 
      --# R11111111, S11111111, T11111111,
      --# U11111111, V11111111, W11111111,
      --# X11111111, Y11111111, Z11111111, AA11111111,
      --# BB11111111, CC11111111, DD11111111,
      --# EE11111111, FF11111111, GG11111111,
      --# HH11111111, II11111111;
   --# function H ( X : INTEGER ) return INTEGER ;
					-- proof function
  end INT512D_1 ;
°
=TEX
=SML
output_spark_program{out_file="int512d1.ada"};
=TEX

\section{EPILOGUE}
The main check on the tests here is that the generated SPARK code is acceptable input for the SPARK examiner.
The shell script created by the following runs the SPARK examiner and generates an ML file which can be used to pass the names of any problematic source files back to the test harness.

We use {\tt test} to test the standard output from {\tt findfile} below
to see if {\tt gnatchop} is on the path. This is because {\tt which}
(a) returns 0 (success) when it cannot find the program on Solaris
and (b) behaves strangely (e.g., hangs) when not called from {\tt csh}.

=DUMP int512.sh
MLFILE=int512.errorfiles.ML
echo hidden_parts >int512.wrn
echo pragma interface >>int512.wrn
echo "==== Test Report from INT512 ====" > int512.run.log
BAD=
if	test -f `findfile spark $PATH`
then	for source in int512??.ada
	do
		spark -noecho -warning_file=int512.wrn $source
		echo "=== "$source" ===" >> int512.run.log
		cat spark.rep >> int512.run.log
		egrep -s 'No errors found' spark.rep || BAD=$BAD" "$source
	done
	{	echo 'val error_files = '
		for i in $BAD
		do	echo '"'$i'"::'
		done
		echo 'nil;' ; } >$MLFILE
else	cat int512??.ada > int512.ada
	echo '***' The module test generated a warning: SPARK Examiner is not available
	echo '***' Please inspect the file int512.ada for errors
	echo 'val error_files = [];' >$MLFILE
fi
# The following is a desperate attempt to work on Solaris (with mostly naff echo)
# and Linux (which often doesn't come with dos2unix). 
if	test "`echo -e`" != ""
then	ECHO='echo'
else	ECHO='echo -e'
fi
for f in int512??.ada
do
	$ECHO '\\winspark\\examiner\\dosspark /w=int512.wrn /r='`basename $f .ada` $f'\r'
done	> int512.bat
	$ECHO 'zip results.zip *.lst *.rep\r' >>int512.bat
if	test -f `findfile zip $PATH`
then	zip int512.zip int512??.ada int512.wrn int512.bat
else	tar -f int512.tar int512??.ada int512.wrn int512.bat
fi
=TEX
The following ML executes the shell script and then loads the ML file it generates.

=SML
fun go () = 
let	val _ = ExtendedIO.system"sh int512.sh >int512.ML 2>&1";
	val s = open_in "int512.ML";
	val buf :string ref = ref "";
in	while (buf := ExtendedIO.input_line s; !buf <> "")
		do  BasicIO.output(std_out, !buf);
	close_in s
end;
go();
val error_files = ["int512.sh"];
use_file"int512.errorfiles.ML";
store_mt_results (fn _ => (map (fn x => (x, false)) error_files)) ();
=TEX

The following command reports on the results.

=SML
diag_line (summarize_mt_results());
=TEX

\pagebreak
%\HOLindexOff
\let\oldsection=\section
\let\oldsubsection=\subsection
\def\section{\pagebreak\oldsubsection}
\def\subsection{\subsubsection}
%\HOLindexOn
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}

