% %Z% $Date: 1997/05/23 14:10:18 $ $Revision: 1.6 $ $RCSfile: int512.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Tests for Annotations}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT512}  %% Mandatory field
\def\SCCSversion{$Revision: 1.6 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 1997/05/23 14:10:18 $%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{K.~Blackburn & WIN01}
\TPPabstract{%
This document gives Compliance Notation scripts which test the treatment of SPARK annotations.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.4] Initial Drafts.
\item[Issue 1.5] Addressed comments from DRA and Praxis.
\item[Issue 1.6] Allowed for one-compilation-unit-per-script rule.
Added a line length test.
\item[Issue 1.7] Made it defensive about the absence of the SPARK examiner.
\end{description}

\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool.
It exemplifies the enhancements required under contract ref. CSM/452 (see \cite{ISS/HAT/DAZ/PLN013}).

\subsection{Introduction}

From version 0.6 on, the Compliance Tool has supported the use of SPARK annotations in all places where the SPARK definition requires or permits them.
The method used to implement annotations at version 0.6 allows k-slots to be used in place of annotations in some, but not all, places where an annotation is permitted.
Under contract ref. CSM/452, an enhancement is implemented permitting k-slots to appear wherever an annotation may appear.

This document provides examples of each syntactic position in which an annotation may appear.
This is intended as a cross-check on the enhancement carried out under CSM/452.


\newpage
\section{TEST CASES}
The following list identifies the syntactic positions where the definition of SPARK \cite{PVL92} permits or requires annotations to appear.
The numeric references (6.1, 6.3 etc.) below refer to the sections of the Ada Language Reference Manual \cite{AJPO83} as used to organise the syntax in \cite{PVL92}.

\begin{description}
\item[1. Procedure/function annotations (6.1)]
immediately after the semi-colon which terminates a subprogram declaration.
\item[2. Procedure/function annotations (6.3)]
between the subprogram specification and the reserved word ``{\tt is}'' at the head of a subprogram body.
\item[3. Hide directive (6.3)]
as a substitute for part of a subprogram body.
In the Compliance Tool, hide directives do {\em not} suppress processing of the subprogram body; an arbitrary Ada replacement must be used to achieve that effect.
The Compliance Tool treats the hide directive as an annotation standing as a declaration in the declarative part of the subprogram.
\item[4. Inherit clause (7.1)]
Immediately before a package specification.
\item[5. Package annotation (7.1)]
Immediately after the package name at the head of a package specification.
\item[6. Refinement Definition (7.1)]
Immediately after the package name at the head of a package body.
\item[7.Hide directive (7.1)]
as a substitute for part of a package body or for the private part of package specification.
Much as for hide directives in subprogram bodies, the Compliance Tool treats the hide directive as an annotation standing as a declaration in the declarative part of the package body.
\item[8. Inherit clause (10.1)]
Immediately before a main program annotation.
\item[9. Main program annotation (10.1)]
Immediately before the subprogram body for the main program.
\item[10.  Procedure/function annotations (10.2)]
immediately after the semi-colon which terminates a subprogram declaration considered as a body stub in SPARK.
(These are treated identically with the procedure/function annotations of section 6.1 in the Compliance Tool.)
\end{description}

The SPARK Examiner supports a few other annotations; procedure and function constraints, assert and check predicates and proof functions.
These appear in positions where the annotations above are allowed, and are tried at convenient points in the test below.

The remainder of this document is organised around the above test cases as follows:

\begin{description}
\item[Section \ref{NOKSLOTS}] exhibits each of the test cases not using k-slots
\item[Section \ref{OKKSLOTS}] exhibits the cases where k-slots are already supported at V0.6
\item[Section \ref{BADKSLOTS}] exhibits the cases where k-slots are not supported at V0.6
\end{description}

The Ada files produced by processing this document are intended to be valid input for the SPARK Examiner.

\subsection{Test Setup}
This section gives some ML preliminaries to help run the tests.

Load the test harness:
=SML
use_file "dtd013";
use_file "imp013";
=TEX
Define a function to initialise system for a test case.
=SML
fun test_case (name : string) = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;   
	new_script{name=name, state=initial_cn_state}
);

=TEX
\newpage
\section{EXAMPLES WITHOUT K-SLOTS}\label{NOKSLOTS}
This section exhibits each of the test cases without using k-slots.
Since this material is only for regression testing, the test cases are grouped together sa convenient.

\subsection{Cases 1 and 5}
This is a convenient point to check proof functions.
=SML
test_case"int512A.1";
=TEX

¹CN
  package INT512A_1
    --# own A ;			-- package annotation (case 5)
  is
    procedure P (X : in INTEGER; Y : out INTEGER) ;
   --# derives Y from X ;		-- procedure annotation (case 1)
   A : INTEGER;
   function F return INTEGER ;
   --# global A ;			-- function annotation (case 1)
   --# function H ( X : INTEGER ) return INTEGER ;
					-- proof function
  end INT512A_1 ;
°
=TEX
=SML
output_spark_program{out_file="int512A.1.ada"};
=TEX
\subsection{Cases 1, 2, 5, 8 and 9}\label{CASES12589}
Note: when the SPARK Examiner with VC Generator is used, procedure and function annotations may be immediately followed by procedure and function constraints.
These give pre- and post-conditions for the subprogram and are syntactically just annotations.
For completeness, this facility is tested here, as are assert predicates.
=SML
test_case"int512A.2";
=TEX


¹CN
 package INT512A_2
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (A : in INTEGER; B : out INTEGER) ;
   --# derives B from A ;		-- procedure annotation (case 1)
   --# pre true ;			-- procedure constraint
   --# post B = 2 * A ;		-- procedure constraint
    G : INTEGER;
 end INT512A_2 ;
°
=SML
output_spark_program{out_file="int512A.2a.ada"};
val state1 = get_cn_state();
new_script{name="int512A.2a", state=state1};
¹CN
 package body INT512A_2 is
  procedure Q(A : in INTEGER; B : out INTEGER)
  is
   procedure P (X : in INTEGER; Y : out INTEGER)
   --# derives Y from X ;		-- procedure annotation (case 2)
   is
   begin
       Y := X + X;
	--# assert Y = X + X ;
   end P ;
 begin
   P(A, B);
 end Q ;
 begin
   G := 1001;
 end INT512A_2 ;
°
=SML
output_spark_program{out_file="int512A.2b.ada"};
val state2 = get_cn_state();
new_script{name="int512A.2b", state=state2};
¹CN
 with INT512A_2;
 --# inherit INT512A_2 ;		-- inherit clause (case 8)
 --# main_program			-- main program annotation (case 9)
 function F return INTEGER
 --# global INT512A_2.G ;		-- function annotation (case 2)
 --# return INT512A_2.G ;		-- function constraint
 is
 begin
    return INT512A_2.G ;
 end F ;
°

=SML
output_spark_program{out_file="int512A.2c.ada"};
ExtendedIO.execute"cat int512A.2a.ada int512A.2b.ada int512A.2c.ada > int512A.2.ada";
=TEX
\subsection{Cases 3 and 9}
=SML
test_case"int512A.3";
=TEX

¹CN
 --# main_program			-- main program annotation (case 9)
 procedure P
 --# derives ;
 is
 --# hide P				-- hide directive (case 3)
 begin
    null;
 end P ;
°
=TEX
=SML
output_spark_program{out_file="int512A.3.ada"};
=TEX
\subsection{Cases 2 and 4}
=SML
test_case"int512A.4";
=TEX


¹CN
 package INT512A_4_A
 is
   type T is range 1 .. 10 ;
 end INT512A_4_A ;
°
=SML
output_spark_program{out_file="int512A.4a.ada"};
val state3 = get_cn_state();
new_script{name="int512A.4a", state=state3};
¹CN
 with INT512A_4_A;
 --# inherit INT512A_4_A ;		-- inherit clause (case 4)
 package INT512A_4_B
 is
   procedure P (X : in INT512A_4_A.T; Y : OUT INT512A_4_A.T) ;
   --# derives Y from X ;			-- procedure annotation (case 2)
 end INT512A_4_B ;
°

=SML
output_spark_program{out_file="int512A.4b.ada"};
ExtendedIO.execute"cat int512A.4a.ada int512A.4b.ada > int512A.4.ada";
=TEX
\subsection{Cases 1, 5 and 6}
=SML
test_case"int512A.5";
=TEX


¹CN
 package INT512A_5
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (B : out INTEGER) ;
    --# global G ;			-- procedure annotation (case 1)
    --# derives B from G ;		-- procedure annotation (case 1)
 end INT512A_5 ;
°
=SML
output_spark_program{out_file="int512A.5a.ada"};
val state4 = get_cn_state();
new_script{name="int512A.5a", state=state4};
¹CN
 package body INT512A_5
 --# own G is X, Y ;			-- refinement definition (case 6)
 is
  X : INTEGER ;
  Y : INTEGER ;
  procedure Q(B : out INTEGER)
   --# global X, Y ;			-- procedure annotation (case 1)
   --# derives B from X, Y ;		-- procedure annotation (case 1)
  is
 begin
   B := X + Y ;
 end Q ;
 begin
   X := 1001;
   Y := 999;
 end INT512A_5 ;
°

=SML
output_spark_program{out_file="int512A.5b.ada"};
ExtendedIO.execute"cat int512A.5a.ada int512A.5b.ada > int512A.5.ada";
=TEX
\subsection{Cases 1, 6 and 10}
=SML
test_case"int512A.6";
=TEX


¹CN
 package INT512A_6
 --# own G ;
 is
    procedure Q (B : out INTEGER) ;
   --# global G ;			-- procedure annotation (case 1)
    --# derives B from G;		-- procedure annotation (case 1)
 end INT512A_6 ;
°
=SML
output_spark_program{out_file="int512A.6a.ada"};
val state5 = get_cn_state();
new_script{name="int512A.6a", state=state5};
¹CN
 package body INT512A_6
 --# own G is X ;			-- refinement definition (case 6)
 is
  X : INTEGER;
  procedure Q(B : out INTEGER) ;
  --# global X ;			-- procedure annotation (case 10)
  --# derives B from X ;		-- procedure annotation (case 10)
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512A_6 ;
°

=SML
output_spark_program{out_file="int512A.6b.ada"};
ExtendedIO.execute"cat int512A.6a.ada int512A.6b.ada > int512A.6.ada";
=TEX
\subsection{Cases 1 and 7}
=SML
test_case"int512A.7";
=TEX


¹CN
 package INT512A_7
 is
    type T is private ;
    procedure Q (B : out INTEGER) ;
    --# derives B from ;		-- procedure annotation (case 1)
 private
--# hide INT512A_7			-- hide directive (case 7)
    type T is range 1 .. 10 ;
 end INT512A_7 ;
°
=SML
output_spark_program{out_file="int512A.7a.ada"};
val state6 = get_cn_state();
new_script{name="int512A.7a", state=state6};
¹CN
 package body INT512A_7
 is
  --# hide INT512A_7			-- hide directive (case 7)
  procedure Q(B : out INTEGER) ;
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512A_7 ;
°

=SML
output_spark_program{out_file="int512A.7b.ada"};
ExtendedIO.execute"cat int512A.7a.ada int512A.7b.ada > int512A.7.ada";
=TEX
\newpage
\section{EXAMPLES WITH K-SLOTS (WORKING AT V0.6)}\label{OKKSLOTS}
This section tests the cases of k-slots as annotations which are already supported at V0.6.
The examples are generally based on the ones in section \ref{NOKSLOTS}.
However, in this section we give a single test for each case, rather than grouping the test cases.

\subsection{Case 1}
This is a convenient point to check procedure and function constraints as well as proof functions.

=SML
test_case"int512B.1";
=TEX

¹CN
  package INT512B_1
    --# own A ;			-- package annotation (case 5)
  is
    procedure P (X : in INTEGER; Y : out INTEGER) ;
  § procedure annotation (case 1) ¢			( 1001 )

   A : INTEGER;
   function F return INTEGER ;
  § function annotation (case 1) ¢			( 1002 )
  end INT512B_1 ;
°
¹CN
 (1001) é 
  --# derives Y from X ;		-- procedure annotation (case 1)
  --# pre true ;			-- procedure constraint
  --# post Y = 2 * X ;		-- procedure constraint
°
¹CN
 (1002) é 
   --# global A ;			-- function annotation (case 1)
   --# return 1000 ;			-- function constraint
   --# function H ( X : INTEGER ) return INTEGER ;
					-- proof function
°
=TEX
=SML
output_spark_program{out_file="int512B.1.ada"};
=TEX
\subsection{Case 3}
For completeness, we also try the assert annotation here.
=SML
test_case"int512B.2";
=TEX

¹CN
 --# main_program			-- main program annotation (case 9)
 procedure P
 --# derives ;
 is
 § hide directive (case 3) ¢			( 1011 )
 
 begin
 § assert annotation ¢			( 1012 )
    null ;
 end P ;
°
¹CN
 (1011) é --# hide P		-- hide directive (case 3)
°
¹CN
  (1012) é --# assert true ;
°

=TEX
=SML
output_spark_program{out_file="int512B.2.ada"};
=TEX
\subsection{Case  7}
=SML
test_case"int512B.3";
=TEX

¹CN
 package INT512B_3
 is
    type T is private ;
    procedure Q (B : out INTEGER) ;
    --# derives B from ;		-- procedure annotation (case 1)
 private
 § hide directive (case 7) ¢			( 1021 )

    type T is range 1 .. 10 ;
 end INT512B_3 ;
°
¹CN
 (1021) é --# hide INT512B_3	-- hide directive (case 7)
°
=SML
output_spark_program{out_file="int512B.3a.ada"};
val state7 = get_cn_state();
new_script{name="int512B.3a", state=state7};
¹CN
 package body INT512B_3
 is
 § hide directive (case 7) ¢			( 1022 )
  procedure Q(B : out INTEGER) ;
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512B_3 ;
°
¹CN
 (1022) é --# hide INT512B_3	-- hide directive (case 7)
°
=SML
output_spark_program{out_file="int512B.3b.ada"};
ExtendedIO.execute"cat int512B.3a.ada int512B.3b.ada > int512B.3.ada";
=TEX
=TEX
\subsection{Case 10}
=SML
test_case"int512B.4";
=TEX


¹CN
 package INT512B_4
 --# own G ;
 is
    procedure Q (B : out INTEGER) ;
   --# global G ;			-- procedure annotation (case 1)
   --# derives B from G;		-- procedure annotation (case 1)
 end INT512B_4 ;
°
=SML
output_spark_program{out_file="int512B.4a.ada"};
val state8 = get_cn_state();
new_script{name="int512B.4a", state=state8};
¹CN
 package body INT512B_4
 --# own G is X ;			-- refinement definition (case 6)
 is
  X : INTEGER;
  procedure Q(B : out INTEGER) ;
 § procedure annotations (case 10) ¢			( 1031 )
  pragma INTERFACE(FORTRAN, Q) ;
 end INT512B_4 ;
°
¹CN
 (1031) é
  --# global X ;			-- procedure annotation (case 10)
  --# derives B from X ;		-- procedure annotation (case 10)
°

=SML
output_spark_program{out_file="int512B.4b.ada"};
ExtendedIO.execute"cat int512B.4a.ada int512B.4b.ada > int512B.4.ada";
=TEX
=TEX
\newpage
\section{EXAMPLES WITH K-SLOTS (NOT WORKING AT V0.6)}\label{BADKSLOTS}
This section tests the cases of k-slots as annotations which are not supported at V0.6.
As in section \ref{OKKSLOTS}, the examples are based on the ones in section \ref{NOKSLOTS} and each case is given a test of its own.
=TEX
\subsection{Case 2}
=SML
diag_line"**** REMAINING TESTS WILL FAIL AT V0.6/V0.7 ****";
test_case"int512C.1";
=TEX


¹CN
 package INT512C_1
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (A : in INTEGER; B : out INTEGER) ;
   --# derives B from A ;		-- procedure annotation (case 1)
    G : INTEGER;
 end INT512C_1 ;
°
=SML
output_spark_program{out_file="int512C.1a.ada"};
val state9 = get_cn_state();
new_script{name="int512C.1a", state=state9};
¹CN
 package body INT512C_1 is
  procedure Q(A : in INTEGER; B : out INTEGER)
  is
   procedure P (X : in INTEGER; Y : out INTEGER)
 § procedure annotation (case 2) ¢			( 3001 )
   is
   begin 
       Y := X + X;
   end P ;
 begin
   P(A, B);
 end Q ;
 begin
   G := 1001;
 end INT512C_1 ;
°
¹CN
 (3001) é
    --# derives Y from X ;		-- procedure annotation (case 2)
°
=SML
output_spark_program{out_file="int512C.1b.ada"};
val state10 = get_cn_state();
new_script{name="int512C.1b", state=state10};
¹CN
 with INT512C_1;
 --# inherit INT512C_1 ;		-- inherit clause (case 8)
 --# main_program			-- main program annotation (case 9)
 function F return INTEGER
 § function annotation (case 2) ¢			( 3002 )
 is
 begin
    return INT512C_1.G ;
 end F ;
°
¹CN
 (3002) é
 --# global INT512C_1.G ;	-- function annotation (case 2)
°

=SML
output_spark_program{out_file="int512C.1c.ada"};
ExtendedIO.execute"cat int512C.1a.ada int512C.1b.ada int512C.1c.ada > int512C.1.ada";
=TEX
\subsection{Case 4}
=SML
test_case"int512C.2";
=TEX


¹CN
 package INT512C_2_A
 is
   type T is range 1 .. 10 ;
 end INT512C_2_A ;
°
=SML
output_spark_program{out_file="int512C.2a.ada"};
val state11 = get_cn_state();
new_script{name="int512C.2a", state=state11};
¹CN
 with INT512C_2_A;
 § inherit clause (case 4) ¢			( 3011 )
 package INT512C_2_B
 is
   procedure P (X : in INT512C_2_A.T; Y : OUT INT512C_2_A.T) ;
   --# derives Y from X ;		-- procedure annotation (case 2)
 end INT512C_2_B ;
°
¹CN
 (3011) é --# inherit INT512C_2_A ;	-- inherit clause (case 4)
°
=SML
output_spark_program{out_file="int512C.2b.ada"};
ExtendedIO.execute"cat int512C.2a.ada int512C.2b.ada > int512C.2.ada";
=TEX
\subsection{Case 5}
=SML
test_case"int512C.3";
=TEX


¹CN
 package INT512C_3
 § package annotations (case 5) ¢			( 3021 )
 is
    procedure Q (B : out INTEGER) ;
    --# global G ;			-- procedure annotation (case 1)
    --# derives B from G ;		-- procedure annotation (case 1)
 end INT512C_3 ;
°
¹CN
 (3021) é 
 --# own G ;				-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
°

=SML
output_spark_program{out_file="int512C.3.ada"};
=TEX
\subsection{Case 6}
=SML
test_case"int512C.4";
=TEX


¹CN
 package INT512C_4
 --# own G ;			-- package annotation (case 5)
 --# initializes G ;			-- package annotation (case 5)
 is
    procedure Q (B : out INTEGER) ;
    --# global G ;		-- procedure annotation (case 1)
    --# derives B from G ;		-- procedure annotation (case 1)
 end INT512C_4 ;
°
=SML
output_spark_program{out_file="int512C.4a.ada"};
val state12 = get_cn_state();
new_script{name="int512C.4a", state=state12};
¹CN
 package body INT512C_4
 § refinement definition (case 6) ¢			( 3031 )
 is
  X : INTEGER ;
  Y : INTEGER ;
  procedure Q(B : out INTEGER)
   --# global X, Y ;			-- procedure annotation (case 1)
   --# derives B from X, Y ;		-- procedure annotation (case 1)
  is
 begin
   B := X + Y ;
 end Q ;
begin
   X := 1001;
   Y := 999;
 end INT512C_4 ;
°
¹CN
 (3031) é 
 --# own G is X, Y ;			-- refinement definition (case 6)
°

=SML
output_spark_program{out_file="int512C.4b.ada"};
ExtendedIO.execute"cat int512C.4a.ada int512C.4b.ada > int512C.4.ada";
=TEX

=TEX
\subsection{Cases 8 and 9}
=SML
test_case"int512C.5";
=TEX

¹CN
 package INT512C_5
 is
    procedure Q (B : out INTEGER) ;
    --# derives B from ;		-- procedure annotation (case 1)
 end INT512C_5 ;
°
=SML
output_spark_program{out_file="int512C.5a.ada"};
val state13 = get_cn_state();
new_script{name="int512C.5a", state=state13};
¹CN
 with INT512C_5;
 § inherit clause etc. (cases 8 and 9) ¢			( 3041 )
 function F return INTEGER
 is
 begin
    return 99 ;
 end F ;
°
¹CN
 (3041) é
 --# inherit INT512C_5 ;	-- inherit clause (case 8)
 --# main_program			-- main program annotation (case 9)
°
=SML
output_spark_program{out_file="int512C.5b.ada"};
ExtendedIO.execute"cat int512C.5a.ada int512C.5b.ada > int512C.5.ada";
=TEX
\section{LINES TOO LONG}
If the output line length was not controlled, the following would cause an
SPARK error.
=SML
test_case"int512D.1";
=TEX

¹CN
  package INT512D_1
    --# own A ,		-- package annotation (case 5)
    --#  A11111111, B11111111, C11111111, 
     --#  D11111111, E11111111, F11111111,
     --#  G11111111, H11111111, I11111111,
     --# J11111111, K11111111, L11111111, M11111111,
      --# N11111111, O11111111, P11111111, Q11111111, 
      --# R11111111, S11111111, T11111111,
      --# U11111111, V11111111, W11111111,
      --# X11111111, Y11111111, Z11111111, AA11111111,
      --# BB11111111, CC11111111, DD11111111,
      --# EE11111111, FF11111111, GG11111111,
      --# HH11111111, II11111111;
  is
    procedure P (X : in INTEGER; Y : out INTEGER) ;
   --# derives Y from X ;
     A, A11111111, B11111111, C11111111, 
     D11111111, E11111111, F11111111,
     G11111111, H11111111, I11111111,
     J11111111, K11111111, L11111111, M11111111,
     N11111111, O11111111, P11111111, Q11111111, 
     R11111111, S11111111, T11111111,
     U11111111, V11111111, W11111111,
     X11111111, Y11111111, Z11111111, AA11111111,
     BB11111111, CC11111111, DD11111111,
     EE11111111, FF11111111, GG11111111,
     HH11111111, II11111111 : INTEGER;
function F return INTEGER ;
   --# global A ,
      --#  A11111111, B11111111, C11111111, 
      --#  D11111111, E11111111, F11111111,
      --#  G11111111, H11111111, I11111111,
      --# J11111111, K11111111, L11111111, M11111111,
      --# N11111111, O11111111, P11111111, Q11111111, 
      --# R11111111, S11111111, T11111111,
      --# U11111111, V11111111, W11111111,
      --# X11111111, Y11111111, Z11111111, AA11111111,
      --# BB11111111, CC11111111, DD11111111,
      --# EE11111111, FF11111111, GG11111111,
      --# HH11111111, II11111111;
   --# function H ( X : INTEGER ) return INTEGER ;
					-- proof function
  end INT512D_1 ;
°
=TEX
=SML
output_spark_program{out_file="int512D.1.ada"};
=TEX

\section{EPILOGUE}
The main check on the tests here is that the generated SPARK code is acceptable input for the SPARK examiner.
The shell script created by the following runs the SPARK examiner and generates an ML file which can be used to pass the names of any problematic source files back to the test harness.

=DUMP int512.sh
MLFILE=int512.errorfiles.ML
echo hidden_parts >int512.wrn
echo pragma interface >>int512.wrn
echo "==== Test Report from INT512 ====" > int512.run.log
BAD=
if	which spark
then	for source in int512?.?.ada
	do
		spark -noecho -warning_file=int512.wrn $source
		echo "=== "$source" ===" >> int512.run.log
		cat spark.rep >> int512.run.log
		egrep -s 'No errors found' spark.rep || BAD=$BAD" "$source
	done
	{	echo 'val error_files = '
		for i in $BAD
		do	echo '"'$i'"::'
		done
		echo 'nil;' ; } >$MLFILE
else	cat int512?.?.ada > int512.ada
	echo '***' The module test generated a warning: SPARK Examiner is not available
	echo '***' Please inspect the file int512.ada for errors
	echo 'val error_files = [];' >$MLFILE
fi
=TEX
The following ML executes the shell script and then loads the ML file it generates.

=SML
fun go () = 
let	val (s1, s2) = ExtendedIO.execute"sh int512.sh 2>&1";
	val buf :string ref = ref "";
in	while (buf := ExtendedIO.input_line s1; !buf <> "")
       do  BasicIO.output(std_out, !buf);
	close_in s1;
	close_out s2
end;
go();
val error_files = ["int512.sh"];
use_file"int512.errorfiles.ML";
store_mt_results (fn _ => (map (fn x => (x, false)) error_files)) ();
=TEX

The following command reports on the results.

=SML
diag_line (summarize_mt_results());
=TEX

\pagebreak
%\HOLindexOff
\let\oldsection=\section
\let\oldsubsection=\subsection
\def\section{\pagebreak\oldsubsection}
\def\subsection{\subsubsection}
%\HOLindexOn
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}

