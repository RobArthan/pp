% imp515.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Compliance Tool Test Utilities}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP515}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This document contains the implementation of test utilities for module testing the compliance tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.7] Initial Drafts.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD515}.
\subsection{Introduction}
\subsection{Purpose and Background}

See \cite{ISS/HAT/DAZ/DTD515}.
%\subsection{Algorithms}
%\subsection{Dependencies}
%\subsection{Known Deficencies}
\subsection{Possible Enhancements}
None known.
=TEX

\section{THE STRUCTURE $CNTestUtilities$}
=SML
structure €CNTestUtilities› : CNTestUtilities = struct
	open CaseIndependence CNBasicDeclsAndExprs CNParser CNTypes;
	open CNTypes1 CNTypes2 ZParagraphs ZUserInterfaceSupport;
	open CNPrettyPrinterSupport CNZGenerator;
=TEX
\section{CREATING ABSTRACT SYNTAX FROM STRINGS}
=SML
local
fun classify_label (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list =
  (case itemlist
    of (LCOrd, _)::(LCNumericLiteral, CNText ntxt)::(LCCrd, _)::rest =>
      (
        (
          (case nat_of_string ntxt
            of 1 => LCCompLabel
             | 2 => LCPPartLabel
             | 3 => LCVPartLabel
             | 4 => LCDecLabel
             | 5 => LCStmtLabel
             | 6 => LCSpecLabel
             | _ => LCCompLabel
          ),
          CNText ("("^ntxt^")")
        )::rest
      )
     |_ => itemlist
  );
in
=TEX
=SML
fun €cn_of_string› (s : string) : CNTypes.WEB_CLAUSE = (
  let
    val inp = [Lex.Text s];
  in
    (CNParser.cn_parser o (CNLex.cn_lex classify_label)) inp
  end)
end;
=TEX
=SML
fun €cn_decl_of_string› (s : string) : DECLARATION = (
let	val prefix = "package mdt505 is ";
	val epilogue = " end mdt505;"
	val result = cn_of_string (prefix^s^epilogue);
in
	case result of
	WCCompilation[KCUUnit{
		comp_unit=CUPackageDeclaration{
			visible_decs = [decl], ...}, ...}] => decl
	|_ => fail "cn_decl_of_string" 508001 []
end);
=TEX

=SML
fun €cn_basic_decl_of_string› (s : string) : BASIC_DECL = (
let	val prefix = "(4) È ";
	val result = cn_of_string (prefix^s);
in
	case result of
	WCReplacedByDecl{decls=[DBasicDecl d],...} => d
	|_ => fail "cn_decl_of_string" 508001 []
end);
=TEX
=SML
fun €cn_exp_of_string› (s : string) : EXP = (
let	val prefix = "(6) √ a:= ";
	val epilogue = ";";
	val result = cn_of_string (prefix^s^epilogue);
in
	case result of
	WCRefinedBy{statement=SStmt(STAssign{e,...}),...} => e
	|_ => fail "cn_exp_of_string" 508001 []
end);
=TEX
=SML
fun €cn_statement_of_string› (s : string) : STATEMENT = (
let	val prefix = "(6) √";
	val result = cn_of_string (prefix^s);
in
	case result of
	WCRefinedBy{statement=st,...} => st
	|_ => fail "cn_statement_of_string" 508001 []
end);
=TEX
=SML
fun €cn_prepost_of_string› (s : string) : (Z_TM * Z_TM) = (
let	val prefix = "(6) √";
	val epilogue = "(100)";
	val result = cn_of_string (prefix^s^epilogue);
in
	case result of
	WCRefinedBy{statement=SStmt(STSpecNoIvars{pre, post, ...}), ...} =>
		(pre, post)
	|_ => fail "cn_prepost_of_string" 508001 []
end);
=TEX
\section{A TEST ENVIRONMENT}
=SML
val €var_info› : (ID * (TYPE * ENV_INFO)) list ref = ref [];

fun €init_env› (() : unit) : unit = (
	var_info := []
);

val €env› = (fn id =>
	case lassoc5 (!var_info) id of
	Value te => Value te
	|Nil =>	 (
		case get_const_info ("z'"^id) of
		Value (ty,_) => Value (ty, EIEnvOther)
		|Nil => Nil
	)
);
=TEX

=SML
fun €extend_env› (id : ID) (ty : TYPE) (envty : ENV_INFO) : unit = (
	(var_info := (id,(ty, envty))::(!var_info))
);

fun €change_env› (id : ID) (envty : ENV_INFO) : unit = (
	case env id of
	Value(ty, _) => (var_info := (id, (ty, envty))::(!var_info))
	|Nil => fail "change_env" 505001 [fn()=>"name not in scope"]
);
=TEX
=SML
fun €update_env_with_vars› ({vars, tmark} : VAR_DECL) : unit = (
let	val vars' = map to_upper vars;
	val tmark' = to_upper tmark;
	val ty = case env tmark' of
				Value (ty, _) => dest_z_power_type ty
				|_ => fail "" 505001 [fn()=>tmark^" not declared"];
in
	((map (fn s => extend_env s ty (EIEnvVar tmark')) vars');())
end
);
=TEX

=SML
fun €update_db_with_function› ({designator, return, formal_part, ...}
	 : FUNCTION_SPECIFICATION) : unit = (
let	val des = to_upper designator;
	fun get_ty (id : ID) : TYPE = (
		 (dest_z_power_type o type_of) (trans_exp env (EId id))
	);
	val ret_ty = get_ty return;
	fun mk_pars ({name, idlist, ...}:PARAMETER_SPECIFICATION) = (
		map (fn id => (id,get_ty name)) idlist
	);
	val (pars, par_tys) = (split o flat) (map mk_pars formal_part);
	val par_ty = case par_tys of
			[par_ty] => par_ty
			|_ => mk_z_tuple_type par_tys;
	val ty = mk_z_power_type(mk_z_tuple_type [par_ty, ret_ty]);
	val tci = TypeCheckInfo ([(des, ty)], []);
	val side = update_theory_db_with_parainfo tci;
in
	extend_env des ty (EIEnvFunction pars)
end
);
=TEX
\section{INTRODUCING NEW CONSTANTS/VARIABLES}
=SML
fun €cn_declare› (s : string) : unit = (
	case cn_decl_of_string s of
	DBasicDecl (BDVarDecl vd) => (
		update_env_with_vars vd
	)| DBasicDecl bd => (
		let	val paras = trans_basic_decl env bd;
			
			val side = map update_theory_db_with_parainfo paras;
		in
			()
		end
	)| DFunctionDeclaration fd => (
		update_db_with_function fd

	)| _ => ()
);
=TEX
\section{PRINTING VOLUME I ENVIRONMENTS}

=SML

val pp_info = {tabs=0, line_length=80, fmtfn= Nil};

local
	val pp_info = {tabs=0, line_length=80, fmtfn= Nil};
in
	fun €f_of_fmt› (f : PP_FMT_INFO -> 'a -> (PP_FMT_INFO * string) list)
			: ('a -> string list) = (
		fn arg => (
			((map snd) o (f pp_info)) arg
		)			
	);
end;

fun €list_fmt› (sl : string list) (fmt : string): string = (
	format_list (fn x => x) sl fmt
);


fun €aux_var_decl_list› (vdl : VAR_DECL list) : string = (
	list_fmt (f_of_fmt fmt_var_decl_list vdl) ""
);

fun €aux_param_spec› (ps : PARAM_SPEC) = (
	(
	case (#mode ps) of
		MSparkIn => "IN "
		|MSparkOut => "OUT "
		|MSparkInOut => "IN OUT "
	) ^
	aux_var_decl_list [(#var_decl ps)]
);
=TEX
=SML

fun €aux_formal_proc› (fp : FORMAL_PROC)  = (
	(#name fp) ^
	" (" ^
	list_fmt (map aux_param_spec (#formal_ids fp)) " " ^
	")"
);

fun €aux_informal_fun› (inf : INFORMAL_FUN) = (
	(#name inf) ^
	" (" ^
	list_fmt (map aux_param_spec (#formal_pars inf)) " " ^
	") : " ^
	(#return_type inf) ^
	";"
);

fun €aux_formal_fun› (form : FORMAL_FUN) = (
	aux_informal_fun (#informal_fun form) ^
	" " ^
	fmt_spec (#spec form)
);

fun €cond_diag_string› (s : string) (s1 : string) : unit = (
	case s1 of
	"" =>	()
	|_ =>	diag_string (s ^ s1)
);
=TEX
=SML
fun €print_pack_env› (pack_env : PACK_ENV) : unit = (
let	fun aux (id, pack : CNTypes1.PACKAGE) = (
		diag_line ("PACKAGE: "^id);
		cond_diag_string "\tvars: " (
			aux_var_decl_list (#vc_vars pack));
		cond_diag_string "\tconsts_types: " (
			list_fmt ((flat o (map (f_of_fmt fmt_basic_decl)))
				(#consts_types pack)) "");
		cond_diag_string "\tformal_procs: " (
			list_fmt (map aux_formal_proc (#formal_procs pack)) "");
		cond_diag_string "\tinformal_funs: " (
			list_fmt (map aux_informal_fun (#informal_funs pack)) "");
		cond_diag_string "\tformal_funs: " (
			list_fmt (map aux_formal_fun (#formal_funs pack)) "")
	);
in
	(
		map aux pack_env;
		()
	)
end
);
=TEX
=SML
fun €aux_flag› (s : string) (fl : FLAG) : unit = (
	
	if fl
	then	diag_string (s ^ ": true")
	else ()
);

fun €aux_in_scope› (p : string) (insc : IN_SCOPE) : unit = (
	cond_diag_string (p ^ "vc_vars: ") (
		aux_var_decl_list (#vc_vars insc));
	cond_diag_string (p ^ "vc_pars: ") (
		list_fmt (map aux_param_spec (#vc_pars insc)) " ");
	cond_diag_string (p ^ "vc_log_cons: ") (
		list_fmt (map string_of_term (#vc_log_cons insc)) ", ");
	cond_diag_string (p ^ "formal_procs: ") (
			list_fmt (map aux_formal_proc (#formal_procs insc)) "");
	cond_diag_string (p ^ "dec_labels") (
		list_fmt (#dec_labels insc) ", ")
);
=TEX
=SML
fun €print_subunit_env› (subunit_env : SUBUNIT_ENV) : unit = (
let	fun aux (id, subunit : SUBUNIT) = (
		diag_line ("SUBUNIT: "^id);
		cond_diag_string "\tzmod: " (
			#zmod subunit);
			aux_flag "\tspecif_flag" (#specif_flag subunit);
		cond_diag_string "\tspecif: " (
			fmt_spec (#specif subunit));
		aux_in_scope "\tin_scope." (#in_scope subunit)
	);
in
	(
		map aux subunit_env;
		()
	)
end
);
=TEX
=SML
fun €aux_flags› (pre : string) (fl : FLAGS) : unit = (
let	val flags = [
		("pack_spec_flag",	(#pack_spec_flag fl)),
		("pack_body_flag",	(#pack_body_flag fl)),
		("stub_flag",		(#stub_flag fl)),
		("subunit_flag",	(#subunit_flag fl)),
		("formal_body_flag", (#formal_body_flag fl)),
		("fun_flag",		(#fun_flag fl)),
		("declabel_flag",	(#declabel_flag fl)),
		("speclabel_flag",	(#speclabel_flag fl)),
		("till_flag",		(#till_flag fl))];
	val flist = list_fmt (map fst (flags drop (fn (_,v) => not v))) ", ";
in
	case flist of
	"" =>	()
	|_ =>	diag_string (pre ^ ": {" ^ flist ^"}")
end
);
=TEX
=SML
fun €print_dec_env› (dec_env : DEC_ENV) : unit = (
let	fun aux (id, declab : DECLAB) = (
		diag_line ("DECLAB: "^id);
		cond_diag_string "\tblock_name: " (
			#block_name declab);
		aux_flags "\tflags: " (#flags declab);
		aux_in_scope "\tin_scope." (#in_scope declab)
	);
in
	(
		map aux dec_env;
		()
	)
end
);
=TEX
=SML
fun €aux_wp_env› (p : string) (wp : WP_ENV) : unit = (
	cond_diag_string (p ^ "fun_header: ") (
		aux_informal_fun (#fun_header wp));
	diag_string (p ^ "return: " ^ (string_of_term (#return wp)));
	diag_string (p ^ "till: " ^ (string_of_term (#till wp)));
	cond_diag_string (p ^ "formal_procs: ") (
			list_fmt (map aux_formal_proc (#formal_procs wp)) "")

);
=TEX
=SML
fun €print_spec_env› (spec_env : SPEC_ENV) : unit = (
let	fun aux (id, speclab : SPECLAB) = (
		diag_line ("SPECLAB: " ^ id);
		fmt_spec (#spec speclab);
		aux_flag "\tformal_body_flag" (#formal_body_flag speclab);
		aux_flag "\tfun_flag" (#fun_flag speclab);
		aux_flag "\ttill_flag" (#till_flag speclab);
		aux_wp_env "\twp_env." (#wp_env speclab);
		aux_in_scope "\tin_scope." (#in_scope speclab)
	);
in
	(
		map aux spec_env;
		()
	)
end
);
=TEX
=SML
fun €print_repl_env› (repl_env : REPL_ENV) : unit = (
let	fun aux (id, repl : REPLACEMENT) = (
		diag_string (
			"REPLACEMENT: " ^
			 id ^
			(
			case repl of
			UnReplaced _ => " Unreplaced"
			|ReplaceComp comp => list_fmt
						 ((f_of_fmt
							fmt_replaced_by_comp)
						 comp) ""
			|ReplacePPart pp =>  list_fmt
						 ((f_of_fmt
							fmt_replaced_by_private_part)
						 pp) ""
			|ReplaceVPart vp =>  list_fmt
						 ((f_of_fmt
							fmt_replaced_by_visible_part)
						 vp) ""
			|ReplaceDecl decl =>  list_fmt
						 ((f_of_fmt
							fmt_replaced_by_decl)
						 decl) ""
			|ReplaceStat st =>  list_fmt
						 ((f_of_fmt
							fmt_replaced_by)
						 st) ""
			)
		)
	);
in
	(
		map aux repl_env;
		()
	)
end
);
=TEX
=SML
fun €aux_dec_lab› (declab : DECLAB) : unit = (
	diag_string ("\tdeclab.block_name: " ^ (#block_name declab));
	cond_diag_string "\tdeclab.";
	aux_flags "\tdeclab." (#flags declab);
	aux_in_scope "\tdeclab." (#in_scope declab)
);
=TEX

=SML
fun €print_blocks› (env : ENV) : unit = (
let	fun aux (block : BLOCK) = (
		diag_string "BLOCK:";
		aux_dec_lab (#declab block);
		cond_diag_string "\tcurrent_formal_proc: " (
			aux_formal_proc (#current_formal_proc block));
		cond_diag_string "\tcurrent_formal_fun: " (
			aux_formal_fun (#current_formal_fun block));
		cond_diag_string "\tdec_lab: " (
			(#dec_lab block));
		cond_diag_string "\tspec_lab: " (
			(#spec_lab block));
		cond_diag_string "\ttill: " (
			string_of_term (#till block))

	);
in
	(
		map aux env;
		()
	)
end
);
=TEX
=SML
fun €print_envs› (() : unit) : unit = (
let	val cn_state = get_cn_state();
in
	(print_pack_env o #pack_env) cn_state;
	(print_subunit_env o #subunit_env) cn_state;
	(print_dec_env o #dec_env) cn_state;
	(print_spec_env o #spec_env) cn_state;
	(print_blocks o #blocks) cn_state;
	(print_repl_env o #repl_env) cn_state
end
);
=TEX

\section{EPILOGUE}
=SML
end (* of structure CNTestUtilities *);
open CNTestUtilities;
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

=IGN
CNZGenerator.get_cn_state;
