%  dtd513.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation (Volume I) Types}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD513}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the detailed design for the data types used in Volume 1 of the compliance notation specification (``Obtaining the Z Document'').}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,hatdocs,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.15] Initial Drafts.
\item[Issues 1.16, 1.17, 1.18] Added support for auxiliary variables.
\item[Issue 1.19] Replacement environment now distinguishes refinements from replacements.
\item[Issue 1.20] Bug fixing.
\item[Issue 1.21] Updated document references.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Standard ML types representing the data structures used in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}; it is called for in \cite{ISS/HAT/DAZ/HLD503}.

\subsection{Introduction}
As discussed in \cite{ISS/HAT/DAZ/HLD503}, it is convenient in the Standard ML implementation for the definitions of types used in the Compliance Notation Processing to be placed in a separate structure (i.e., module) from the functions which act on those types.
This document gives the structure (i.e., module) containing the types used in implementing \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}.
As usual it also includes a transcription into {\ProductZ} of the relevant parts of the DRA specification.

The SPARK Program Extractor is also largely implemented as a by-product of the processing which extracts the Z.
A Z specification of the relevant data structures is also given here in section \ref{SPARKProgramEnvironment}.

\subsubsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/HLD503}.

\subsubsection{Dependencies}
See \cite{ISS/HAT/DAZ/HLD503}.
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}
\subsection{Representation of the State}
\cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2} identifies several environments and some global variables which are modelled as being the subject of assignments during the Compliance Notation Processing.
It turns out that what are referred to as global variables are all used to hold fragments of abstract syntax which will be directly available in the implementation (and so these variables are not mentioned further in this document).

It is convenient in the implementation to bring the various environments together into a single ML record which acts as the state.
The type of this state record is given in section \ref{STATERECORD} below.

\subsection{Representation of Z Functions in the Environnments}
The environments in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2} make some use of (finite) Z functions, e.g., for the package specification environment.
The domains of these functions are (subsets of) the type $ID$ of identifiers (which are represented as ML strings, see \cite{ISS/HAT/DAZ/DTD502}).
{\Product} provides some ML library support for string-indexed look-up tables called dictionaries and these are convenient for representing the Z finite functions.

\subsection{Component Update Functions}

In order not to fragment the DRA specifications, the Z signatures of the component update functions ($Package\_vc\_vars$) are given here.
These functions are implemented as private functions in the ML structure $CNZGenerator$ of \cite{ISS/HAT/DAZ/IMP507}.


\section{PREAMBLE}
=DOC
signature ÛCNTypes1İ = sig
=DESCRIBE
=ENDDOC

=SML
local
open	CNTypes CNBasicDeclsAndExprs CNTypes2;
in
=TEX

\subsection{Preamble for Z Type-Checking}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd514";
push_pc "z_library";
force_delete_theory"dtd513" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
new_theory "dtd513";
=TEX

\section{Z DOCUMENT}
For completeness, we give the Z from section 2 of \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2} here.
However, the implementation of this
 is provided by the existing {\Product} support for Z.

It might be better to replace the simple linear view of the Z document here with something which more accurately reflected the modular structure of the {\Product} theory hierarchy.

ÿÛZ_DOCİüüüüüüüüüüüüüüüüüüü
Ü	z : seq Z_PARA
ˆüüüüüüüüüüüüüüüüüüüüüüüü

¹ZAX
Ü	Ûtoolkitİ, Ûextendİ : Z_PARA
°
¹Z
Ü	ÛZ_DOC0İ ¦ [Z_DOC | z = §toolkit, extend¢]
°

\section{COMPLIANCE NOTATION ENVIRONMENTS}
\subsection{Package Specification Environment}


=DOC
type ÛFORMAL_FUNİ
=TYPESTRUCT
      = {
	informal_fun : INFORMAL_FUN,
	spec : SPEC
	};
=DESCRIBE
ÿFormal_Funüüüüüüüüüüüüüüüüü
Ü	Informal_Fun;
Ü	Spec
÷üüüüüüüüüüüüü
Ü	w = {}
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type ÛPACKAGEİ
=TYPESTRUCT
      = {
	vc_vars : VAR_DECL list,
	consts_types : BASIC_DECL list,
	formal_procs : FORMAL_PROC list,
	informal_funs : INFORMAL_FUN list,
	formal_funs : FORMAL_FUN list,
	aux_vars : Z_DECL list
	};
=DESCRIBE
ÿPackageüüüüüüüüüüüüüüüüü
Ü	vc_vars : ğ Var_Decl;
Ü	consts_types : seq BASIC_DECL;
Ü	formal_procs : ğ Formal_Proc;
Ü	informal_funs : seq Informal_Fun;
Ü	formal_funs : seq Formal_Fun;
Ü	aux_vars : ğ Z_Decl[Z_EXP]
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type ÛPACK_ENVİ
=TYPESTRUCT
      =  PACKAGE S_DICT;
=DESCRIBE
¹ZAX
Ü	Package_vc_vars : (Package ¸ ğ Var_Decl) ­ Package;
Ü	Package_consts_types :
Ü		(Package ¸ seq BASIC_DECL) ­ Package;
Ü	Package_formal_procs : (Package ¸ ğ Formal_Proc) ­ Package;
Ü	Package_informal_funs :
Ü		(Package ¸ seq Informal_Fun) ­ Package;
Ü	Package_formal_funs : (Package ¸ seq Formal_Fun) ­ Package;
Ü	Package_aux_vars : (Package ¸ ğ Z_Decl[Z_EXP]) ­ Package
°

ÿPACK_ENVüüüüüüüüüüüüüüüüü
Ü	pack_env : ID ß Package
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	PACK_ENV0 ¦ [PACK_ENV | pack_env = {}]
°
=ENDDOC


\subsection{Subunit Environment}


The z module is represented simply as an identifier.
=DOC
type ÛSUBUNITİ
=TYPESTRUCT
      = {
	zmod : ID,
	specif_flag : FLAG,
	specif : SPEC,
	in_scope : IN_SCOPE
	};
=DESCRIBE
ÿSubunitüüüüüüüüüüüüüüüüü
Ü	zmod : Z_MODULE;
Ü	specif_flag : FLAG;
Ü	specif : Spec;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


The pair of identifiers used to index the subunit environment will be represented by a single string. E.g., if `child' is a subunit of `parent', the string will be `parent\_\_child'. (C.f. the construction of a theory name for a subunit as described in \cite{ISS/HAT/DAZ/HLD501}).

=DOC
type ÛSUBUNIT_ENVİ
=TYPESTRUCT
      = SUBUNIT S_DICT;
=DESCRIBE
¹ZAX
Ü	Subunit_vc_vars : (Subunit ¸ ğ Var_Decl) ­ Subunit;
Ü	Subunit_formal_procs : (Subunit ¸ ğ Formal_Proc) ­ Subunit;
Ü	Subunit_dec_labels : (Subunit ¸ ğ LABEL) ­ Subunit
°

ÿSUBUNIT_ENVüüüüüüüüüüüüüüüüü
Ü	subunit_env : (ID ¸ ID) ß Subunit
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	SUBUNIT_ENV0 ¦ [SUBUNIT_ENV | subunit_env = {}]
°
=ENDDOC


\subsection{Dec Label Environment}


=DOC
type ÛFLAGSİ
=TYPESTRUCT
      = {
	pack_spec_flag : FLAG,
	pack_body_flag : FLAG,
	stub_flag : FLAG,
	subunit_flag : FLAG,
	formal_body_flag : FLAG,
	fun_flag : FLAG,
	declabel_flag : FLAG,
	speclabel_flag : FLAG,
	till_flag : FLAG
	};
=DESCRIBE
ÿFlagsüüüüüüüüüüüüüüüüü
Ü	pack_spec_flag, pack_body_flag, stub_flag, subunit_flag,
Ü	formal_body_flag, fun_flag, declabel_flag, speclabel_flag, till_flag :
Ü		FLAG
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
type ÛDECLABİ
=TYPESTRUCT
      = {
	block_name : ID,
	flags : FLAGS,
	in_scope : IN_SCOPE
	};
=DESCRIBE
ÿDeclabüüüüüüüüüüüüüüüüü
Ü	block_name : ID;
Ü	Flags;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


A $LABEL$ is either a string or a special marker for an implicit label  (see \cite{ISS/HAT/DAZ/DTD502}).
The latter form will be mapped into an internally generated string here and so we can still use the string-indexed dictionaries for the dec label environment.

=DOC
type ÛDEC_ENVİ
=TYPESTRUCT
      = DECLAB S_DICT;
=DESCRIBE
¹ZAX
Ü	Declab_declab_flag : (Declab ¸ FLAG) ­ Declab;
Ü	Declab_vc_vars : (Declab ¸ ğ Var_Decl) ­ Declab;
Ü	Declab_formal_procs : (Declab ¸ ğ Formal_Proc) ­ Declab;
Ü	Declab_dec_labels : (Declab ¸ ğ LABEL) ­ Declab
°

ÿDEC_ENVüüüüüüüüüüüüüüüüü
Ü	dec_env : LABEL ß Declab
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	DEC_ENV0 ¦ [DEC_ENV | dec_env = {}]
°
=ENDDOC


\subsection{Spec Label Environment}


The remarks above concerning labels and $DEC\_ENV$ also apply to $SPEC\_ENV$.

=DOC
type ÛSPEC_ENVİ
=TYPESTRUCT
      = SPECLAB S_DICT;
=DESCRIBE
¹ZAX
Ü	Speclab_w : (Speclab ¸ ğ Z_ID) ­ Speclab;
Ü	Speclab_vc_vars : (Speclab ¸ ğ Var_Decl) ­ Speclab;
Ü	Speclab_formal_procs : (Speclab ¸ ğ Formal_Proc) ­ Speclab;
Ü	Speclab_dec_labels : (Speclab ¸ ğ LABEL) ­ Speclab
°

ÿSPEC_ENVüüüüüüüüüüüüüüüüü
Ü	spec_env : LABEL ß Speclab
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	SPEC_ENV0 ¦ [SPEC_ENV | spec_env = {}]
°
=ENDDOC


\subsection{Running Environment}

The components $current\_for\_vars$ and $current\_log\_cons$ are required to add the for loop variables and logical constants to the scope of the block. This constitutes part of the implementation for \cite[volume 1, section 16.4.1]{DRA/CIS/CSE3/TR/94/27/1.2}.
=DOC
type ÛBLOCKİ
=TYPESTRUCT
      = {
	declab : DECLAB,
	current_formal_proc : FORMAL_PROC,
	current_formal_fun : FORMAL_FUN,
	current_for_vars : PARAM_SPEC list,
	current_log_cons : Z_DECL list,
	dec_lab : LABEL,
	spec_lab : LABEL,
	till : Z_PRED,
	using_decs : (Z_ID * (VAR_DECL list * Z_PRED)) list
	};
=DESCRIBE
ÿBlocküüüüüüüüüüüüüüüüü
Ü	Declab;
Ü	current_formal_proc : Formal_Proc;
Ü	current_formal_fun : Formal_Fun;
Ü	dec_lab, spec_lab : LABEL;
Ü	till : Z_PRED;
Ü	using_decs : Z_ID ß (ğ Var_Decl ¸ Z_PRED)
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type ÛENVİ
=TYPESTRUCT
      = BLOCK list;
=DESCRIBE
¹ZAX
Ü	Block_stub_flag, Block_till_flag : (Block ¸ FLAG) ­ Block;
Ü	Block_vc_vars : (Block ¸ ğ Var_Decl) ­ Block;
Ü	Block_vc_pars : (Block ¸ ğ Param_Spec) ­ Block;
Ü	Block_vc_log_cons : (Block ¸ ğ Z_Decl[Z_EXP]) ­ Block;
Ü	Block_formal_procs : (Block ¸ ğ Formal_Proc) ­ Block;
Ü	Block_dec_labels : (Block ¸ ğ LABEL) ­ Block;
Ü	Block_current_formal_proc : (Block ¸ Formal_Proc) ­ Block;
Ü	Block_current_formal_fun : (Block ¸ Formal_Fun) ­ Block;
Ü	Block_till : (Block ¸ Z_PRED) ­ Block;
Ü	Block_using_decs : (Block ¸ Z_ID ß (ğ Var_Decl ¸ Z_PRED)) ­ Block
°

ÿENVüüüüüüüüüüüüüüüüü
Ü	blocks : seq Block
ˆüüüüüüüüüüüüüüüüüüüü

¹ZAX
Ü	flatten_env : ENV ­ In_Scope
°

ÿEmpty_Blocküüüüüüüüüüüüüüüüü
Ü	Block
÷üüüüüüüüüüüüü
Ü	vc_vars = {};
Ü	vc_pars = {};
Ü	vc_log_cons = {};
Ü	vc_aux_vars = {};
Ü	formal_procs = {};
Ü	dec_labels = {}
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

ÿENV0üüüüüüüüüüüüüüüüü
Ü	ENV;
Ü	Empty_Block
÷üüüüüüüüüüüüü
Ü	blocks =  § Ê Block ¢;
Ü	pack_spec_flag =
Ü	pack_body_flag =
Ü	stub_flag =
Ü	subunit_flag =
Ü	formal_body_flag =
Ü	fun_flag = declabel_flag = speclabel_flag = till_flag = False
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{SPARK Program Environment}\label{SPARKProgramEnvironment}
As the literate script is processed, a data structure is maintained which enables the SPARK Program to be extracted.
This data structure is in two parts: {\em(i)}, $SPARK\_PROG$: a list of the compilation units, or compilation unit k-slots which will eventually make up the top-level parts of the program, and {\em(ii)}, $REPL\_ENV$: a table giving the association of k-slot labels with program fragments determined by the refinement and replacement web clauses contained in the literate script.
The intention is that when processing of a literate script is complete these two data structures will enable a pretty-printing function to use $REPL\_ENV$ to expand all the k-slots in $SPARK\_PROG$ (both at the top-level and inside any constituent compilation units) and so output the required SPARK program.

To describe the data structures in Z, we first need given sets to stand for the necessary parts of the abstract syntax which have not been formally specified before.

=DOC
type ÛSPARK_PROGİ
=TYPESTRUCT
	= KSLOT_COMPILATION_UNIT list;
=DESCRIBE
¹Z
Ü	[	ÛCompilation_Unitİ,
Ü		ÛPrivate_Partİ,
Ü		ÛVisible_Partİ,
Ü		ÛDeclarative_Partİ]
°

¹Z
Ü	ÛK_Slot_Compilation_Unitİ	::=	Ûkcu_k_slotİ (LABEL)
Ü					|	Ûkcu_unitİ (Compilation_Unit)
°

ÿÛSPARK_Progİüüüüüüüüüüüüüüüüü
Ü	spark : seq K_Slot_Compilation_Unit
ˆüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

¹Z
Ü	ÛReplacementİ	::=	Ûreplace_compİ (seq Compilation_Unit)
Ü			|	Ûreplace_ppartİ (Private_Part)
Ü			|	Ûreplace_vpartİ (Visible_Part)
Ü			|	Ûreplace_declİ (Declarative_Part)
Ü			|	Ûrefine_statİ (seq Statement)
Ü			|	Ûreplace_statİ (seq Statement)
°
ÿÛREPL_ENVİüüüüüüüüüüüüüüüüü
Ü	repl_env : LABEL ß Replacement
ˆüüüüüüüüüüüüüüüüüüüüüüüüü

Some of the ML types which help to implement the above are already available from \cite{ISS/HAT/DAZ/DTD502}.

For the branches of the data type for $Replacement$ we can use the $REPLACED\_BY\_XXX$ types  (which contain the label as well as the replacement, but that is no hardship).
In addition, we extend the replacement environment to allow for some error detection which is not catered for in the above Z.
When a k-slot is encountered an entry is made in the replacement environment indicating what sort of replacement is later to be expected for this object and giving the name of the {\Product} theory to be made current for type inference purposes when the replacement (or refinement) is made.

=SML
datatype ÛREPL_SORTİ		=	ÛRSCompilationİ
				|	ÛRSPrivatePartİ
				|	ÛRSVisiblePartİ
				|	ÛRSDeclarationİ
				|	ÛRSSpecStatementİ
				|	ÛRSStatementİ;
=TEX
=SML
datatype ÛREPLACEMENTİ	=	ÛReplaceCompİ of REPLACED_BY_COMP
				|	ÛReplacePPartİ of REPLACED_BY_PRIVATE_PART
				|	ÛReplaceVPartİ of REPLACED_BY_VISIBLE_PART
				|	ÛReplaceDeclİ of REPLACED_BY_DECL
				|	ÛReplaceStatİ of REPLACED_BY
				|	ÛRefineStatİ of REPLACED_BY
				|	ÛUnReplacedİ of (REPL_SORT * string);
=TEX
=SML
type ÛREPL_ENVİ
=TYPESTRUCT
      = REPLACEMENT S_DICT;
=TEX
\section{STATE RECORD}\label{STATERECORD}
The state of the Compliance Notation Processing is recorded in the following type.
Here, in addition to the five environments required by the DRA specifications, we have the SPARK program and replacement environment discussed in section \ref{SPARKProgramEnvironment} and a slot for the name of the literate script being processed.
=SML
type ÛCN_STATEİ
=TYPESTRUCT
	= {
		pack_env : PACK_ENV,
		subunit_env : SUBUNIT_ENV,
		dec_env : DEC_ENV,
		spec_env : SPEC_ENV,
		blocks : ENV,
		repl_env : REPL_ENV,
		spark_prog : SPARK_PROG,
		script_name : string
		
	};
=TEX
\section{EPILOGUE}
=SML
end; (* local...in *)
end; (* signature CNTypes1 *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



