=IGN
********************************************************************************
dtd513.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  dtd513.doc %Z% $Date: 2008/11/29 14:12:24 $ $Revision: 1.82 $ $RCSfile: dtd513.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Notation (Volume I) Types}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD513}  %% Mandatory field
\def\SCCSversion{$Revision: 1.82 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2008/11/29 14:12:24 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the detailed design for the data types used in Volume 1 of the compliance notation specification (``Obtaining the Z Document'').}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,hatdocs,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.15] Initial Drafts.
\item[Issues 1.16, 1.17, 1.18] Added support for auxiliary variables.
\item[Issue 1.19] Replacement environment now distinguishes refinements from replacements.
\item[Issue 1.20] Bug fixing.
\item[Issue 1.21] Updated document references.
\item[Issue 1.22] Carried out document rework according to desk check report 012.
\item[Issue 1.23] Reworked the test policy section.
\item[Issue 1.24] Corrected the type of $toolkit$ and $extend$ in the Z to $Z\_MODULE$.
\item[Issue 1.25] Renamed $CN\_STATE$ to be $Z\_GENERATOR\_STATE$.
\item[Issue 1.26] Batch A enhancements (just requires an extra component in the $PACKAGE$ type)
\item[Issue 1.27] Tidy-up for review.
\item[Issue 1.28] Syntax changes.
\item[Issue 1.29-30] IUCT WP 7 changes.
\item[Issue 1.31] Changes for IUCT WP 2.
\item[Issue 1.32,1.33] Changes for IUCT WP 4.
\item[Issue 1.34] Corrected Z syntax and type errors.
\item[Issue 1.35] Updated Z for HLD504 Appendix Material.
\item[Issue 1.36] Updated references.
\item[Issue 1.37] Tidying.
\item[Issue 1.38] Added conditional compilation labels FULLVERSION and CUTDOWNVERSION for 
open of CNBasicDeclsAndExprs.
\item[Issue 1.39] Changes for NJML port.
\item[Issues 1.40, 1.41] Brought into line with latest specifications.
\item[Issue 1.42] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.43,1.44] CTLE II R1/11: nested packages.
\item[Issue 1.45] Removed local declarations for Poly/ML port.
\item[Issue 1.46] Index brackets added.
\item[Issue 1.47] Type mark now required in variable initialisers.
\item[Issue 1.48] Applying specification changes from HLD508.
\item[Issue 1.49] Fixing {\LaTeX} errors for SPC501.
\item[Issue 1.50] Fixed error in spec of {\it subprog\_flatten\_env}.
\item[Issue 1.51] Spring 2002 enhancements: return and exit statements.
\item[Issue 1.52]  Support for R0047: renaming.
\item[Issue 1.53] {\it renamings} is now called {\it var\_renamings} in the specs.
\item[Issue 1.54, 1.55] Spec updates for interim release.
\item[Issue 1.56] R0054: reworked treatment of use clauses.
\item[Issue 1.57] Removed use of ICL logo font.
\item[Issue 1.58] Merged in changes for R00962. Add type for VC info used in browser.
\item[Issue 1.59] Copyright and banner updates for open source release.
\item[Issue 1.60] DAZ-specific updates to banner for open source release
\item[Issue 1.61] DAZ-specific updates to banner for open source release
\item[Issue 1.62] Script deletion
\item[Issue 1.63] Schemas-as-declarations now catered for in output Z syntax.
\item[Issue 1.64, 1.65] Schemas in function $\Xi$-lists.
\item[Issue 1.66] Updates to the Z after GMP's preliminary review.
\item[Issue 1.67] Package environment now includes the complete compiltation unit for each package.
(to support R0091, which requires us to record the context clause for the package).
\item[Issue 1.68-1.70] Environment reform.
\item[Issue 1.71] Using clauses now allowed anywhere in package body.
\item[Issue 1.72] Added to package data type to enable fix to informal procedure unsoundness problem.
\item[Issue 1.73] Added field to the FORAML\_FUN data type so that renamings of functions in package specifications can be handled more nicely.
\item[Issue 1.74] Fixed problem with object renamings in package specifications.
\item[Issue 1.75] First clean compile for enhancement 117.
\item[Issue 1.76] Support for general expanded names.
\item[Issue 1.77] Added the SCOPE\_ENV.
\item[Issue 1.78] Elements of a block name are now optional so that scopes within anonymous blocks and loops can be represented.
\item[Issue 1.79] Added information required to support deletion of deferred subprograms.
\item[Issue 1.80, 1.81] Child packages.
\item[Issue 1.82] Made {\em FORMAL\_FUN} type match current treatment of function renaming.
\item[Issue 1.83] Added data types for the evaluation report generator.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Standard ML types representing the data structures used in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}; it is called for in \cite{ISS/HAT/DAZ/HLD503}.

\subsection{Introduction}
As discussed in \cite{ISS/HAT/DAZ/HLD503}, it is convenient in the Standard ML implementation for the definitions of types used in the Compliance Notation Processing to be placed in a separate structure (i.e., module) from the functions which act on those types.
This document gives the structure (i.e., module) containing the types used in implementing \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.
As usual it also includes a transcription into {\ProductZ} of the relevant parts of the DRA specification.

The SPARK Program Extractor is also largely implemented as a by-product of the processing which extracts the Z.
A Z specification of the relevant data structures is also given here in section \ref{SPARKProgramEnvironment}.

\subsubsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/HLD503}.

\subsubsection{Dependencies}
See \cite{ISS/HAT/DAZ/HLD503}.
\subsection{Compliance}
For a justification of the style of presenting Z types used in this document, see \cite[section 1.3]{ISS/HAT/DAZ/DTD502}.

It is intended that the compliance of the Z to the implementation can be done with a visual check in this document.

\section{DESIGN ISSUES}
\subsection{Representation of the State}
\cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} identifies several environments and some global variables which are modelled as being the subject of assignments during the Compliance Notation Processing.
It turns out that what are referred to as global variables are all used to hold fragments of abstract syntax which will be directly available in the implementation (and so these variables are not mentioned further in this document).

It is convenient in the implementation to bring the various environments together into a single ML record which acts as the state.
The type of this state record is given in section \ref{STATERECORD} below.

\subsection{Representation of Z Functions in the Environnments}
The environments in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} make some use of (finite) Z functions, e.g., for the package specification environment.
The domains of these functions are (subsets of) the type $ID$ of identifiers (which are represented as ML strings, see \cite{ISS/HAT/DAZ/DTD502}).
{\Product} provides some ML library support for string-indexed look-up tables called dictionaries and these are convenient for representing the Z finite functions.

\subsection{Component Update Functions}

In order not to fragment the DRA specifications, the Z signatures of the component update functions ($Package\_vc\_vars$) are given here.
These functions are implemented as private functions in the ML structure $CNZGenerator$ of \cite{ISS/HAT/DAZ/IMP507}.


\section{PREAMBLE}
\subsection{Preamble for Z Type-Checking}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd508";
push_pc "z_library";
force_delete_theory"dtd513" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory "dtd513";
new_parent"dtd514";
=TEX
\subsection{The Signature}
=TEX

=DOC
signature ÛCNTypes1İ = sig
=DESCRIBE
=ENDDOC

As in the other signatures that define types, it would
be much nicer to use local declarations rather than includes,
but SML '97 doesn't support that.
=FULLVERSION
include	(* CNTypes CNBasicDeclsAndExprs *) CNTypes2;
=CUTDOWNVERSION
include	(* CNTypes *) CNTypes2;
=TEX
\section{Z DOCUMENT}
For completeness, we give the Z from section 2 of \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} here.
However, the implementation of this
 is provided by the existing {\Product} support for Z.

ÿÛZ_DOCİüüüüüüüüüüüüüüüüüüü
Ü	z : seq Z_PARA
ˆüüüüüüüüüüüüüüüüüüüüüüüü

¹ZAX
Ü ÛZ_toolkitİ, ÛSPARK_toolkitİ : Z_ID
°
ÿ ÛSCRIPT_NAMEİ üüüüüüüüüüü
Ü script_name? : Z_ID
ˆüüüüüüüüüüüüüü
ÿ ÛINIT_Z_DOCİ üüüüüüüüüüü
Ü SCRIPT_NAME;
Ü Z_DOC
÷üüüüüü
Ü	¶ mod_name : Z_ID; parents : ğZ_ID
Ü	| mod_name = script_name? ± {Z_toolkit, SPARK_toolkit} € parents
Ü 	· z = §z_module(ÊZ_MODULE), z_parents(ÊZ_PARENTS)¢
ˆüüüüüüüüüüüüüü

\section{COMPLIANCE NOTATION ENVIRONMENTS}
\subsection{Handling of Expanded Names}
=DOC
type ÛPREFIX_INFOİ
=TYPESTRUCT
	= {
	    canon : Z_ID list,
	    aliases : Z_ID list list
	};
=DESCRIBE
This type is used to represent a set of prefixes to be applied to the name of
an Ada entity when it is stored in an environment.
=ENDDOC

\subsection{Package Specification Environment}


=DOC
type ÛFORMAL_FUNİ
=TYPESTRUCT
      = {
	informal_fun : INFORMAL_FUN,
	spec : SPEC,
	globals : Z_ID list
	};
=DESCRIBE
ÿÛFormal_Funİüüüüüüüüüüüüüüüüü
Ü	Informal_Fun;
Ü	Spec;
Ü	globals : seq Z_ID
÷üüüüüüüüüüüüü
Ü	w = {}
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

In the following the context compilation unit is used to carry the package declaration
for use in checking whether the package declaration contains any unexpanded k-slots
together with its with and use clauses for use in processing the corresponding package body.
=DOC
type ÛPACKAGEİ
=TYPESTRUCT
      = {
	vc_vars : VAR_DECL list,
	consts_types : BASIC_DECL list,
	formal_procs : FORMAL_PROC list,
	informal_procs : ID list,
	informal_funs : INFORMAL_FUN list,
	formal_funs : FORMAL_FUN list,
	aux_vars : Z_DECL list,
	obj_renamings : (Z_ID * Z_ID OPT) list,
	zmod : ID,
	decl : CONTEXT_COMPILATION_UNIT,
	local_dict : ENV_DICT,
	private_dict : ENV_DICT,
	with_dict : ENV_DICT
	};
=DESCRIBE
ÿÛPackageİüüüüüüüüüüüüüüüüü
Ü	vc_vars : ğ Var_Decl;
Ü	consts_types : seq BASIC_DECL;
Ü	formal_procs : ğ Formal_Proc;
Ü	informal_funs : seq Informal_Fun;
Ü	formal_funs : seq Formal_Fun;
Ü	aux_vars : ğ Z_Decl[Z_EXP];
Ü	obj_renamings : Z_ID ß Z_ID;
Ü	zmod : Z_MODULE
ˆüüüüüüüüüüüüüüüüüüüü
The extra component {\it decl} in the ML allows us to check, where necessary, that formal
development of the package is complete.
=ENDDOC


=DOC
type ÛPACK_ENVİ
=TYPESTRUCT
      =  PACKAGE S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛPackage_vc_varsİ : (Package ¸ ğ Var_Decl) ­ Package;
Ü	ÛPackage_consts_typesİ :
Ü		(Package ¸ seq BASIC_DECL) ­ Package;
Ü	ÛPackage_formal_procsİ : (Package ¸ ğ Formal_Proc) ­ Package;
Ü	ÛPackage_informal_funsİ :
Ü		(Package ¸ seq Informal_Fun) ­ Package;
Ü	ÛPackage_formal_funsİ : (Package ¸ seq Formal_Fun) ­ Package;
Ü	ÛPackage_aux_varsİ : (Package ¸ ğ Z_Decl[Z_EXP]) ­ Package;
Ü	ÛPackage_obj_renamingsİ : (Package ¸ (Z_ID ß Z_ID)) ­ Package
°

ÿÛPACK_ENVİüüüüüüüüüüüüüüüüü
Ü	pack_env : ID ß Package
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛPACK_ENV0İ ¦ [PACK_ENV | pack_env = {}]
°
=ENDDOC


\subsection{Subunit Environment}


The z module is represented simply as an identifier.
=DOC
type ÛSUBUNITİ
=TYPESTRUCT
      = {
	zmod : ID,
	specif_flag : FLAG,
	specif : SPEC,
	in_scope : IN_SCOPE,
	globs : Z_ID list
	};
=DESCRIBE
ÿÛSubunitİüüüüüüüüüüüüüüüüü
Ü	zmod : Z_MODULE;
Ü	specif_flag : FLAG;
Ü	specif : Spec;
Ü	globs : seq Z_ID;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


The pair of identifiers used to index the subunit environment will be represented by a single string. E.g., if `child' is a subunit of `parent', the string will be `parent\_\_child'. (C.f. the construction of a theory name for a subunit as described in \cite{ISS/HAT/DAZ/HLD501}).

=DOC
type ÛSUBUNIT_ENVİ
=TYPESTRUCT
      = SUBUNIT S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛSubunit_vc_varsİ : (Subunit ¸ ğ Var_Decl) ­ Subunit;
Ü	ÛSubunit_formal_procsİ : (Subunit ¸ ğ Formal_Proc) ­ Subunit;
Ü	ÛSubunit_dec_labelsİ : (Subunit ¸ ğ LABEL) ­ Subunit
°

ÿÛSUBUNIT_ENVİüüüüüüüüüüüüüüüüü
Ü	subunit_env : (ID ¸ ID) ß Subunit
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛSUBUNIT_ENV0İ ¦ [SUBUNIT_ENV | subunit_env = {}]
°
=ENDDOC


\subsection{Dec Label Environment}


=DOC
type ÛFLAGSİ
=TYPESTRUCT
      = {
	pack_spec_flag : FLAG,
	pack_body_flag : FLAG,
	stub_flag : FLAG,
	subunit_flag : FLAG,
	body_flag : FLAG,
	formal_body_flag : FLAG,
	fun_flag : FLAG,
	declabel_flag : FLAG,
	speclabel_flag : FLAG,
	till_flag : FLAG,
	private_flag : FLAG
	};
=DESCRIBE
ÿÛFlagsİüüüüüüüüüüüüüüüüü
Ü	pack_spec_flag, pack_body_flag, stub_flag, subunit_flag, body_flag,
Ü	formal_body_flag, fun_flag, declabel_flag, speclabel_flag, till_flag :
Ü		FLAG
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
type ÛDECLABİ
=TYPESTRUCT
      = {
	block_name : ID OPT list,
	flags : FLAGS,
	using_decs : (Z_ID * (VAR_DECL list * Z_PRED)) list,
	in_scope : IN_SCOPE
	};
=DESCRIBE
ÿÛDeclabİüüüüüüüüüüüüüüüüü
Ü	block_name : ID;
Ü	Flags;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


A $LABEL$ is either a string or a special marker for an implicit label  (see \cite{ISS/HAT/DAZ/DTD502}).
The latter form will be mapped into an internally generated string here and so we can still use the string-indexed dictionaries for the dec label environment.

=DOC
type ÛDEC_ENVİ
=TYPESTRUCT
      = DECLAB S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛDeclab_declabel_flagİ : (Declab ¸ FLAG) ­ Declab;
Ü	ÛDeclab_vc_varsİ : (Declab ¸ ğ Var_Decl) ­ Declab;
Ü	ÛDeclab_formal_procsİ : (Declab ¸ ğ Formal_Proc) ­ Declab;
Ü	ÛDeclab_dec_labelsİ : (Declab ¸ ğ LABEL) ­ Declab
°

ÿÛDEC_ENVİüüüüüüüüüüüüüüüüü
Ü	dec_env : LABEL ß Declab
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛDEC_ENV0İ ¦ [DEC_ENV | dec_env = {}]
°
=ENDDOC


\subsection{Spec Label Environment}


The remarks above concerning labels and $DEC\_ENV$ also apply to $SPEC\_ENV$.

=DOC
type ÛSPEC_ENVİ
=TYPESTRUCT
      = SPECLAB S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛSpeclab_wİ : (Speclab ¸ ğ Z_ID) ­ Speclab;
Ü	ÛSpeclab_vc_varsİ : (Speclab ¸ ğ Var_Decl) ­ Speclab;
Ü	ÛSpeclab_formal_procsİ : (Speclab ¸ ğ Formal_Proc) ­ Speclab;
Ü	ÛSpeclab_dec_labelsİ : (Speclab ¸ ğ LABEL) ­ Speclab;
Ü	ÛSpeclab_preİ : Speclab ¸ Z_PRED ­ Speclab;
Ü	ÛSpeclab_in_scopeİ : Speclab ¸ In_Scope ­ Speclab
°

ÿÛSPEC_ENVİüüüüüüüüüüüüüüüüü
Ü	spec_env : LABEL ß Speclab
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛSPEC_ENV0İ ¦ [SPEC_ENV | spec_env = {}]
°
=ENDDOC


\subsection{Running Environment}

The components $current\_for\_vars$ and $current\_log\_cons$ are required to add the for loop variables and logical constants to the scope of the block. This constitutes part of the implementation for \cite[volume 1, section 16.4.1]{DRA/CIS/CSE3/TR/94/27/3.0}.
=DOC
type ÛBLOCKİ
=TYPESTRUCT
      = {
	declab : DECLAB,
	current_formal_proc : FORMAL_PROC,
	current_formal_fun : FORMAL_FUN,
	current_for_vars : PARAM_SPEC list,
	current_log_cons : Z_DECL list,
	current_loop_name : ID OPT,
	dec_lab : LABEL,
	spec_lab : LABEL,
	till : Z_PRED,
	var_inits : (EXP * TMARK) S_DICT
	};
=DESCRIBE
ÿÛBlockİüüüüüüüüüüüüüüüüü
Ü	Declab;
Ü	current_formal_proc : Formal_Proc;
Ü	current_formal_fun : Formal_Fun;
Ü	current_loop_name : OPT[ID];
Ü	dec_lab, spec_lab : LABEL;
Ü	till : Z_PRED;
Ü	using_decs : Z_ID ß (ğ Var_Decl ¸ Z_PRED);
Ü	var_inits : ID ß (EXP ¸ TMARK)
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type ÛENVİ
=TYPESTRUCT
      = BLOCK list;
=DESCRIBE
¹ZAX
Ü	ÛBlock_stub_flagİ,
Ü	ÛBlock_body_flagİ,
Ü	ÛBlock_till_flagİ : (Block ¸ FLAG) ­ Block;
Ü	ÛBlock_vc_varsİ : (Block ¸ ğ Var_Decl) ­ Block;
Ü	ÛBlock_vc_parsİ : (Block ¸ ğ Param_Spec) ­ Block;
Ü	ÛBlock_vc_log_consİ : (Block ¸ ğ Z_Decl[Z_EXP]) ­ Block;
Ü	ÛBlock_formal_procsİ : (Block ¸ ğ Formal_Proc) ­ Block;
Ü	ÛBlock_dec_labelsİ : (Block ¸ ğ LABEL) ­ Block;
Ü	ÛBlock_current_formal_procİ : (Block ¸ Formal_Proc) ­ Block;
Ü	ÛBlock_current_formal_funİ : (Block ¸ Formal_Fun) ­ Block;
Ü	ÛBlock_current_loop_nameİ : (Block ¸ ID) ­ Block;
Ü	ÛBlock_tillİ : (Block ¸ Z_PRED) ­ Block;
Ü	ÛBlock_using_decsİ :
Ü		(Block ¸ (Z_ID ß (ğ Var_Decl ¸ Z_PRED))) ­ Block;
Ü	ÛBlock_var_initsİ : (Block ¸ (ID ß EXP ¸ TMARK)) ­ Block;
Ü 	ÛBlock_vc_aux_varsİ : (Block ¸ ğ Z_Decl) ­ Block;
Ü 	ÛBlock_obj_renamingsİ : (Block ¸ (Z_ID ß Z_ID)) ­ Block;
Ü	ÛBlock_use_clause_subsİ : (Block ¸ (Z_ID ß Z_EXP)) ­ Block;
Ü 	ÛBlock_in_scopeİ : (Block ¸ In_Scope) ­ Block
°

ÿÛENVİüüüüüüüüüüüüüüüüü
Ü	blocks : seq‰1 Block
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

¹ZAX
Ü Ûflatten_envİ : ENV ­ In_Scope
÷üüüüüü
Ü µ ENV; In_Scope; n : ID | n = (blocks 1).block_name·
Ü flatten_env(ÊENV) = ÊIn_Scope ¤
Ü 	vc_vars = Ş{b:ran blocks · b.vc_vars}
Ü ±	vc_pars = Ş{b:ran blocks · b.vc_pars}
Ü ±	vc_log_cons = Ş{b:ran blocks · b.vc_log_cons}
Ü ±	vc_aux_vars = Ş{b:ran blocks · b.vc_aux_vars}
Ü ±	formal_procs = Ş{b:ran blocks · b.formal_procs}
Ü ±	dec_labels = Ş{b:ran blocks | b.block_name = n · b.dec_labels}
°

¹ZAX
Ü Ûmerge_in_scopesİ : In_Scope ¸ In_Scope ­ In_Scope
÷
Ü µ In_Scope; In_Scope'; In_Scope''·
Ü   ÊIn_Scope'' = merge_in_scopes (ÊIn_Scope', ÊIn_Scope)
Ü ¤	vc_vars'' = vc_vars À vc_vars'
Ü   ±	vc_pars'' = vc_pars À vc_pars'
Ü   ±	vc_log_cons'' = vc_log_cons À vc_log_cons'
Ü   ±	vc_aux_vars'' = vc_aux_vars À vc_aux_vars'
Ü   ±	formal_procs'' = formal_procs À formal_procs'
Ü   ±	dec_labels'' = dec_labels À dec_labels'
°

¹ZAX
Ü Ûexpand_schema_sigsİ : ğZ_ID ­ ğZ_ID
°
¹ZAX
Ü Ûsubprog_flatten_envİ : ENV ­ In_Scope
÷üüüüüü
Ü µ ENV; Block' | ÊBlock' = blocks 1·
Ü formal_body_flag' = False ±
Ü	subprog_flatten_env(ÊENV) = flatten_env(ÊENV) ²
Ü formal_body_flag' = True ±
Ü 	(¶globs : ğZ_ID; ENV''; In_Scope'''; In_Scope''''; In_Scope'''''; name : ID
Ü	·  subprog_flatten_env (ÊENV) = ÊIn_Scope'''''
Ü	± (	fun_flag' = True
Ü		±	globs = expand_schema_sigs(ran(current_formal_fun'.globals))
Ü		±	name = current_formal_fun'.name
Ü	²	fun_flag' = False
Ü		±	globs = expand_schema_sigs(ran(current_formal_proc'.globals))
Ü		±	name = current_formal_proc'.name)
Ü	± blocks'' = blocks ù { Block | block_name = name · ÊBlock }
Ü	± ÊIn_Scope''' = flatten_env(ÊENV)
Ü	± ÊIn_Scope'''' = flatten_env(ÊENV'')
Ü	± vc_vars''''' = vc_vars'''' À {v : vc_vars''' | (trans_id v.var)  globs}
Ü	± vc_pars''''' = vc_pars'''' À {p : vc_pars''' | (trans_id p.var)  globs}
Ü	± vc_log_cons''''' = vc_log_cons''''
Ü	± vc_aux_vars''''' = vc_aux_vars'''' À {a : vc_aux_vars''' | (Valueç~ê)a.zvar  globs}
Ü	± formal_procs'''''  = formal_procs'''
Ü	± dec_labels''''' = dec_labels'''')
°

ÿÛEmpty_Blockİüüüüüüüüüüüüüüüüü
Ü	Block
÷üüüüüüüüüüüüü
Ü	vc_vars = {};
Ü	vc_pars = {};
Ü	vc_log_cons = {};
Ü	vc_aux_vars = {};
Ü	formal_procs = {};
Ü	dec_labels = {};
Ü	var_inits = {};
Ü	current_loop_name = Nil
ˆüüüüüüüüüüüüüüüüüüüü

ÿÛENV0İüüüüüüüüüüüüüüüüü
Ü	ENV;
Ü	Empty_Block
÷üüüüüüüüüüüüü
Ü	blocks =  § Ê Block ¢;
Ü	pack_spec_flag =
Ü	pack_body_flag =
Ü	stub_flag =
Ü	subunit_flag =
Ü	formal_body_flag =
Ü	fun_flag = declabel_flag = speclabel_flag = till_flag = False
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{SPARK Program Environment}\label{SPARKProgramEnvironment}
As the literate script is processed, a data structure is maintained which enables the SPARK Program to be extracted.
This data structure is in two parts: {\em(i)}, $SPARK\_PROG$: a list of the compilation units, or compilation unit k-slots which will eventually make up the top-level parts of the program, and {\em(ii)}, $REPL\_ENV$: a table giving the association of k-slot labels with program fragments determined by the refinement and replacement web clauses contained in the literate script.
The intention is that when processing of a literate script is complete these two data structures will enable a pretty-printing function to use $REPL\_ENV$ to expand all the k-slots in $SPARK\_PROG$ (both at the top-level and inside any constituent compilation units) and so output the required SPARK program.

To describe the data structures in Z, we first need given sets to stand for the necessary parts of the abstract syntax which have not been formally specified before.

=DOC
type ÛSPARK_PROGİ
=TYPESTRUCT
	= KSLOT_COMPILATION_UNIT list;
=DESCRIBE
¹Z
Ü	[	ÛCompilation_Unitİ,
Ü		ÛPrivate_Partİ,
Ü		ÛVisible_Partİ,
Ü		ÛDeclarative_Partİ,
Ü		ÛAnnotationİ]
°

¹Z
Ü	ÛK_Slot_Compilation_Unitİ	::=	Ûkcu_k_slotİ (LABEL)
Ü					|	Ûkcu_unitİ (Compilation_Unit)
°

ÿÛSPARK_Progİüüüüüüüüüüüüüüüüü
Ü	spark : seq K_Slot_Compilation_Unit
ˆüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

¹Z
Ü	ÛReplacementİ	::=	Ûreplace_compİ (seq Compilation_Unit)
Ü			|	Ûreplace_ppartİ (Private_Part)
Ü			|	Ûreplace_vpartİ (Visible_Part)
Ü			|	Ûreplace_declİ (Declarative_Part)
Ü			|	Ûrefine_statİ (seq Statement)
Ü			|	Ûreplace_statİ (seq Statement)
Ü			|	Ûreplace_annotationİ (seq Annotation)
°
ÿÛREPL_ENVİüüüüüüüüüüüüüüüüü
Ü	repl_env : LABEL ß Replacement
ˆüüüüüüüüüüüüüüüüüüüüüüüüü

Some of the ML types which help to implement the above are already available from \cite{ISS/HAT/DAZ/DTD502}.

For the branches of the data type for $Replacement$ we can use the $REPLACED\_BY\_XXX$ types  (which contain the label as well as the replacement, but that is no hardship).
In addition, we extend the replacement environment to allow for some error detection which is not catered for in the above Z.
When a k-slot is encountered an entry is made in the replacement environment indicating what sort of replacement is later to be expected for this object and giving the name of the {\Product} theory to be made current for type inference purposes when the replacement (or refinement) is made.

=SML
datatype ÛREPL_SORTİ		=	ÛRSCompilationİ
				|	ÛRSPrivatePartİ
				|	ÛRSVisiblePartİ
				|	ÛRSDeclarationİ
				|	ÛRSSpecStatementİ
				|	ÛRSStatementİ
				|	ÛRSAnnotationİ;
=TEX
=SML
datatype ÛREPLACEMENTİ	=	ÛReplaceCompİ of REPLACED_BY_COMP
				|	ÛReplacePPartİ of REPLACED_BY_PRIVATE_PART
				|	ÛReplaceVPartİ of REPLACED_BY_VISIBLE_PART
				|	ÛReplaceDeclİ of REPLACED_BY_DECL
				|	ÛReplaceStatİ of REPLACED_BY
				|	ÛReplaceArbitraryİ of REPLACED_BY_ARBITRARY_ADA
				|	ÛRefineStatİ of REPLACED_BY
				|	ÛReplaceAnnotationİ of REPLACED_BY_ANNOTATION
				|	ÛUnReplacedİ of (REPL_SORT * string);
=TEX
Replacments are tagged with the name of the immediately enclosing scope in order
to support deletion of deferred subprograms.
=SML
type ÛSCOPED_REPLACEMENTİ = {
	scope_name : ID OPT list,
	repl : REPLACEMENT};
=TEX
=SML
type ÛREPL_ENVİ
=TYPESTRUCT
      = SCOPED_REPLACEMENT S_DICT;
=TEX
The SCOPE\_ENV maps a subprogram name (translated into Z) to a pair comprising
the name of the theory in which the body of the subprogram (or package) and a an indicator
of the state of a possibly deferred subprogram.
=SML
datatype ÛDEFERRED_STATEİ = 
		ÛDSNotDeferredİ
	|	ÛDSPendingIntroductionİ
	|	ÛDSIntroducedİ;
type ÛSCOPE_ENVİ
=TYPESTRUCT
      = {
	theory : string,
	deferred : DEFERRED_STATE,
	body_labels : (DECLAB S_DICT * (LABEL * SPECLAB)) OPT} E_DICT;
=TEX
\section{STATE RECORD}\label{STATERECORD}
The state of the Compliance Notation Processing is recorded in the following type.
The Z Generator maintains a database of states one for each Compliance Notation script.
Here, in addition to the five environments required by the DRA specifications, we have the SPARK program and replacement environment discussed in section \ref{SPARKProgramEnvironment}, a slot for the name of the literate script being processed and the information needed to restore the environments if this script
is subsequently deleted.
=SML
type ÛZ_GENERATOR_STATEİ
=TYPESTRUCT
	= {
		pack_env : PACK_ENV,
		subunit_env : SUBUNIT_ENV,
		dec_env : DEC_ENV,
		spec_env : SPEC_ENV,
		blocks : ENV,
		repl_env : REPL_ENV,
		scope_env : SCOPE_ENV,
		spark_prog : SPARK_PROG,
		script_name : string,
		deletion_info : SUBUNIT_ENV		
	};
=TEX
\subsection{Browser VC Info Type}
=TEX
This is the type used to distinguish different cases of VC generation.
=SML
datatype ÛVC_GEN_CONTEXTİ  = 
		VCG_refinement
	|	VCG_subprogram_body
	|	VCG_subprogram_spec
	|	VCG_subunit_spec
	|	VCG_package_init
	|	VCG_basic_declaration
	|	VCG_unknown
=TEX
The next two types are used to hand information relating to VCs as stored and 
retrieved by Volume 1 functions to other parts.
=SML
type Ûvc_clause_contextİ
=TYPESTRUCT
	= {
		w : ID list,
		pre : Z_PRED,
		post : Z_PRED,
		till : Z_PRED,
		return : Z_PRED,
		named_tills : ( ID * Z_PRED ) list
	  }
=SML
type Ûvc_context_routeİ
=TYPESTRUCT
	= {	
		route : ROUTE OPT,
		blockids : ID list,
		context : vc_clause_context OPT,
		vcg_context : VC_GEN_CONTEXT
	}; 
=TEX
This is the type used in deconstructing routes.
=SML
datatype Ûvc_route_argİ = 	  VRA_unit of unit
			| VRA_rte of ROUTE 	
			| VRA_bool_rte  of bool * ROUTE 
			| VRA_int_rte of int * ROUTE 	
			| VRA_str of string;
=TEX
\subsection{Evaluation Report Data Types}
A scope is the expanded name of a package, subprogram, block or loop
together with an indicator of the type of declarative region.
As a special case, we may have a ``context'' scope representing
what is in scope at the head of the declarative region.
Anonymous elements of the name are omitted:
e.g., "SUBPROG.BLOCK1..LOOP2." might be the name of
an anoymous block inside a named loop inside an anonymous loop.
=SML
datatype ÛSCOPE_TYPEİ =
		ÛSTSpecİ
	|	ÛSTBodyİ
	|	ÛSTProcİ
	|	ÛSTFuncİ
	|	ÛSTBlockİ
	|	ÛSTContextİ;
type ÛSCOPEİ = {
	name : CNTypes.EXPANDED_NAME,
	scope_type : SCOPE_TYPE};
=TEX
Theories are classified as one of: HOL, Z, The theory ``cn'', CN context theory or CN scope theory (either a script theory or the theory for a subprogram, block or loop, or the corresponding context theory).
=SML
datatype ÛEV_THEORY_TYPEİ =
		ÛETTHolİ
	|	ÛETTZedİ
	|	ÛETTCnİ
	|	ÛETTScopeİ of SCOPE;
=TEX
The information we associate with a theory is its name, its type (as above) and the lists of axioms, of proved and unproved VCs and of defining theorems that have not been proved consistent.
=SML
type ÛEV_THEORY_INFOİ = {
	name : string,
	theory_type : EV_THEORY_TYPE,
	proved_vcs : (string * THM) list,
	unproved_vcs : (string * TERM) list,
	axioms : (string list * THM) list};
=TEX
The report data structure is essentially a forest whose trees are given by the following ML type.
We treat stubs and subunits differently from ordinary nested scopes: a stub corresponds to a leaf in the forest
containing a scope name that will appear as a root if the corresponding subunit is included in the report.
For a nested scope we have its name and type, the info for the scope theory and the context theory if any
and the infos for any descendant scopes.
(The scope attribute duplicates information that will also
be inside the type attribute of the scope theory, but that
is harmless and convenient.)
=SML
datatype ÛEV_SCOPE_INFOİ =
		ÛEvNestedScopeİ of {
			scope : SCOPE,
			scope_theory_info : EV_THEORY_INFO,
			context_theory_info : EV_THEORY_INFO OPT,
			scopes : EV_SCOPE_INFO list}
	|	ÛEvStubİ of SCOPE;
=TEX
The exception log is a dictionary mapping script names to
a list of strings, each string comprising an error or warning message.
=SML
type ÛCN_EXCEPTION_LOGİ = string list S_DICT;
=TEX
Associated with a script we have the scope info for the compilation unit of the script, the exception log, the list
of withed and referenced packages and the list of library theories.
=SML
type ÛEV_SCRIPT_INFOİ = {
	exception_log : CN_EXCEPTION_LOG,
	referenced_packages : string list,
	library_theories : string list,
	scope_info : EV_SCOPE_INFO};
=TEX
For a script theory we have the script info, for a theory associated with a scope we have the scope info, while for
other theories we have just the theory info.
=SML
datatype ÛEV_INFOİ =
		ÛEIScriptInfoİ of EV_SCRIPT_INFO
	|	ÛEIScopeInfoİ of EV_SCOPE_INFO
	|	ÛEITheoryInfoİ of EV_THEORY_INFO;
=TEX
\section{EPILOGUE}
=SML
end; (* signature CNTypes1 *)
=TEX
\section{TEST POLICY}
There are no module tests for the design in this document since it specifies no functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



