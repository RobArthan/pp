%  dtd513.doc %Z% $Date: 2002/02/14 15:57:18 $ $Revision: 1.48 $ $RCSfile: dtd513.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Notation (Volume I) Types}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD513}  %% Mandatory field
\def\SCCSversion{$Revision: 1.48 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/02/14 15:57:18 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document contains the detailed design for the data types used in Volume 1 of the compliance notation specification (``Obtaining the Z Document'').}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,hatdocs,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.15] Initial Drafts.
\item[Issues 1.16, 1.17, 1.18] Added support for auxiliary variables.
\item[Issue 1.19] Replacement environment now distinguishes refinements from replacements.
\item[Issue 1.20] Bug fixing.
\item[Issue 1.21] Updated document references.
\item[Issue 1.22] Carried out document rework according to desk check report 012.
\item[Issue 1.23] Reworked the test policy section.
\item[Issue 1.24] Corrected the type of $toolkit$ and $extend$ in the Z to $Z\_MODULE$.
\item[Issue 1.25] Renamed $CN\_STATE$ to be $Z\_GENERATOR\_STATE$.
\item[Issue 1.26] Batch A enhancements (just requires an extra component in the $PACKAGE$ type)
\item[Issue 1.27] Tidy-up for review.
\item[Issue 1.28] Syntax changes.
\item[Issue 1.29-30] IUCT WP 7 changes.
\item[Issue 1.31] Changes for IUCT WP 2.
\item[Issue 1.32,1.33] Changes for IUCT WP 4.
\item[Issue 1.34] Corrected Z syntax and type errors.
\item[Issue 1.35] Updated Z for HLD504 Appendix Material.
\item[Issue 1.36] Updated references.
\item[Issue 1.37] Tidying.
\item[Issue 1.38] Added conditional compilation labels FULLVERSION and CUTDOWNVERSION for 
open of CNBasicDeclsAndExprs.
\item[Issue 1.39] Changes for NJML port.
\item[Issues 1.40, 1.41] Brought into line with latest specifications.
\item[Issue 1.42] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.43,1.44] CTLE II R1/11: nested packages.
\item[Issue 1.45] Removed local declarations for Poly/ML port.
\item[Issue 1.46] Index brackets added.
\item[Issue 1.47] Type mark now required in variable initialisers.
\item[Issue 1.48] Applying specification changes from HLD508.
\item[Issue 1.49] Fixing {\LaTeX} errors for SPC501.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Standard ML types representing the data structures used in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}; it is called for in \cite{ISS/HAT/DAZ/HLD503}.

\subsection{Introduction}
As discussed in \cite{ISS/HAT/DAZ/HLD503}, it is convenient in the Standard ML implementation for the definitions of types used in the Compliance Notation Processing to be placed in a separate structure (i.e., module) from the functions which act on those types.
This document gives the structure (i.e., module) containing the types used in implementing \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.
As usual it also includes a transcription into {\ProductZ} of the relevant parts of the DRA specification.

The SPARK Program Extractor is also largely implemented as a by-product of the processing which extracts the Z.
A Z specification of the relevant data structures is also given here in section \ref{SPARKProgramEnvironment}.

\subsubsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/HLD503}.

\subsubsection{Dependencies}
See \cite{ISS/HAT/DAZ/HLD503}.
\subsection{Compliance}
For a justification of the style of presenting Z types used in this document, see \cite[section 1.3]{ISS/HAT/DAZ/DTD502}.

It is intended that the compliance of the Z to the implementation can be done with a visual check in this document.

\section{DESIGN ISSUES}
\subsection{Representation of the State}
\cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} identifies several environments and some global variables which are modelled as being the subject of assignments during the Compliance Notation Processing.
It turns out that what are referred to as global variables are all used to hold fragments of abstract syntax which will be directly available in the implementation (and so these variables are not mentioned further in this document).

It is convenient in the implementation to bring the various environments together into a single ML record which acts as the state.
The type of this state record is given in section \ref{STATERECORD} below.

\subsection{Representation of Z Functions in the Environnments}
The environments in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} make some use of (finite) Z functions, e.g., for the package specification environment.
The domains of these functions are (subsets of) the type $ID$ of identifiers (which are represented as ML strings, see \cite{ISS/HAT/DAZ/DTD502}).
{\Product} provides some ML library support for string-indexed look-up tables called dictionaries and these are convenient for representing the Z finite functions.

\subsection{Component Update Functions}

In order not to fragment the DRA specifications, the Z signatures of the component update functions ($Package\_vc\_vars$) are given here.
These functions are implemented as private functions in the ML structure $CNZGenerator$ of \cite{ISS/HAT/DAZ/IMP507}.


\section{PREAMBLE}
\subsection{Preamble for Z Type-Checking}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd508";
push_pc "z_library";
force_delete_theory"dtd513" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory "dtd513";
new_parent"dtd514";
=TEX
\subsection{The Signature}
=TEX

=DOC
signature ÛCNTypes1İ = sig
=DESCRIBE
=ENDDOC

As in the other signatures that define types, it would
be much nicer to use local declarations rather than includes,
but SML '97 doesn't support that.
=FULLVERSION
include	(* CNTypes CNBasicDeclsAndExprs *) CNTypes2;
=CUTDOWNVERSION
include	(* CNTypes *) CNTypes2;
=TEX
\section{Z DOCUMENT}
For completeness, we give the Z from section 2 of \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} here.
However, the implementation of this
 is provided by the existing {\Product} support for Z.

ÿÛZ_DOCİüüüüüüüüüüüüüüüüüüü
Ü	z : seq Z_PARA
ˆüüüüüüüüüüüüüüüüüüüüüüüü

¹ZAX
Ü ÛZ_toolkitİ, ÛSPARK_toolkitİ : Z_ID
°
ÿ ÛSCRIPT_NAMEİ üüüüüüüüüüü
Ü script_name? : Z_ID
ˆüüüüüüüüüüüüüü
ÿ ÛINIT_Z_DOCİ üüüüüüüüüüü
Ü SCRIPT_NAME;
Ü Z_DOC
÷üüüüüü
Ü	¶ mod_name : Z_ID; parents : ğZ_ID
Ü	| mod_name = script_name? ± {Z_toolkit, SPARK_toolkit} € parents
Ü 	· z = §z_module(ÊZ_MODULE), z_parents(ÊZ_PARENTS)¢
ˆüüüüüüüüüüüüüü

\section{COMPLIANCE NOTATION ENVIRONMENTS}
\subsection{Package Specification Environment}


=DOC
type ÛFORMAL_FUNİ
=TYPESTRUCT
      = {
	informal_fun : INFORMAL_FUN,
	spec : SPEC,
	globals : Z_ID list
	};
=DESCRIBE
ÿÛFormal_Funİüüüüüüüüüüüüüüüüü
Ü	Informal_Fun;
Ü	Spec;
Ü	globals : seq Z_ID
÷üüüüüüüüüüüüü
Ü	w = {}
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type ÛPACKAGEİ
=TYPESTRUCT
      = {
	vc_vars : VAR_DECL list,
	consts_types : BASIC_DECL list,
	formal_procs : FORMAL_PROC list,
	informal_funs : INFORMAL_FUN list,
	formal_funs : FORMAL_FUN list,
	aux_vars : Z_DECL list,
	zmod : ID
	};
=DESCRIBE
ÿÛPackageİüüüüüüüüüüüüüüüüü
Ü	vc_vars : ğ Var_Decl;
Ü	consts_types : seq BASIC_DECL;
Ü	formal_procs : ğ Formal_Proc;
Ü	informal_funs : seq Informal_Fun;
Ü	formal_funs : seq Formal_Fun;
Ü	aux_vars : ğ Z_Decl[Z_EXP];
Ü	zmod : Z_MODULE
ˆüüüüüüüüüüüüüüüüüüüü
The extra field in the ML type is used to implement the global variable $PACK\_SPEC\_WITH\_MODULES$ used in $new\_scope\_pack\_body$ (q.v.) and elsewhere (see \cite{ISS/HAT/DAZ/DTD507}).
=ENDDOC


=DOC
type ÛPACK_ENVİ
=TYPESTRUCT
      =  PACKAGE S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛPackage_vc_varsİ : (Package ¸ ğ Var_Decl) ­ Package;
Ü	ÛPackage_consts_typesİ :
Ü		(Package ¸ seq BASIC_DECL) ­ Package;
Ü	ÛPackage_formal_procsİ : (Package ¸ ğ Formal_Proc) ­ Package;
Ü	ÛPackage_informal_funsİ :
Ü		(Package ¸ seq Informal_Fun) ­ Package;
Ü	ÛPackage_formal_funsİ : (Package ¸ seq Formal_Fun) ­ Package;
Ü	ÛPackage_aux_varsİ : (Package ¸ ğ Z_Decl[Z_EXP]) ­ Package
°

ÿÛPACK_ENVİüüüüüüüüüüüüüüüüü
Ü	pack_env : ID ß Package
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛPACK_ENV0İ ¦ [PACK_ENV | pack_env = {}]
°
=ENDDOC


\subsection{Subunit Environment}


The z module is represented simply as an identifier.
=DOC
type ÛSUBUNITİ
=TYPESTRUCT
      = {
	zmod : ID,
	specif_flag : FLAG,
	specif : SPEC,
	in_scope : IN_SCOPE,
	globs : Z_ID list
	};
=DESCRIBE
ÿÛSubunitİüüüüüüüüüüüüüüüüü
Ü	zmod : Z_MODULE;
Ü	specif_flag : FLAG;
Ü	specif : Spec;
Ü	globs : seq Z_ID;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


The pair of identifiers used to index the subunit environment will be represented by a single string. E.g., if `child' is a subunit of `parent', the string will be `parent\_\_child'. (C.f. the construction of a theory name for a subunit as described in \cite{ISS/HAT/DAZ/HLD501}).

=DOC
type ÛSUBUNIT_ENVİ
=TYPESTRUCT
      = SUBUNIT S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛSubunit_vc_varsİ : (Subunit ¸ ğ Var_Decl) ­ Subunit;
Ü	ÛSubunit_formal_procsİ : (Subunit ¸ ğ Formal_Proc) ­ Subunit;
Ü	ÛSubunit_dec_labelsİ : (Subunit ¸ ğ LABEL) ­ Subunit
°

ÿÛSUBUNIT_ENVİüüüüüüüüüüüüüüüüü
Ü	subunit_env : (ID ¸ ID) ß Subunit
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛSUBUNIT_ENV0İ ¦ [SUBUNIT_ENV | subunit_env = {}]
°
=ENDDOC


\subsection{Dec Label Environment}


=DOC
type ÛFLAGSİ
=TYPESTRUCT
      = {
	pack_spec_flag : FLAG,
	pack_body_flag : FLAG,
	stub_flag : FLAG,
	subunit_flag : FLAG,
	body_flag : FLAG,
	formal_body_flag : FLAG,
	fun_flag : FLAG,
	declabel_flag : FLAG,
	speclabel_flag : FLAG,
	till_flag : FLAG
	};
=DESCRIBE
ÿÛFlagsİüüüüüüüüüüüüüüüüü
Ü	pack_spec_flag, pack_body_flag, stub_flag, subunit_flag, body_flag,
Ü	formal_body_flag, fun_flag, declabel_flag, speclabel_flag, till_flag :
Ü		FLAG
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
type ÛDECLABİ
=TYPESTRUCT
      = {
	block_name : ID,
	flags : FLAGS,
	in_scope : IN_SCOPE
	};
=DESCRIBE
ÿÛDeclabİüüüüüüüüüüüüüüüüü
Ü	block_name : ID;
Ü	Flags;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


A $LABEL$ is either a string or a special marker for an implicit label  (see \cite{ISS/HAT/DAZ/DTD502}).
The latter form will be mapped into an internally generated string here and so we can still use the string-indexed dictionaries for the dec label environment.

=DOC
type ÛDEC_ENVİ
=TYPESTRUCT
      = DECLAB S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛDeclab_declabel_flagİ : (Declab ¸ FLAG) ­ Declab;
Ü	ÛDeclab_vc_varsİ : (Declab ¸ ğ Var_Decl) ­ Declab;
Ü	ÛDeclab_formal_procsİ : (Declab ¸ ğ Formal_Proc) ­ Declab;
Ü	ÛDeclab_dec_labelsİ : (Declab ¸ ğ LABEL) ­ Declab
°

ÿÛDEC_ENVİüüüüüüüüüüüüüüüüü
Ü	dec_env : LABEL ß Declab
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛDEC_ENV0İ ¦ [DEC_ENV | dec_env = {}]
°
=ENDDOC


\subsection{Spec Label Environment}


The remarks above concerning labels and $DEC\_ENV$ also apply to $SPEC\_ENV$.

=DOC
type ÛSPEC_ENVİ
=TYPESTRUCT
      = SPECLAB S_DICT;
=DESCRIBE
¹ZAX
Ü	ÛSpeclab_wİ : (Speclab ¸ ğ Z_ID) ­ Speclab;
Ü	ÛSpeclab_vc_varsİ : (Speclab ¸ ğ Var_Decl) ­ Speclab;
Ü	ÛSpeclab_formal_procsİ : (Speclab ¸ ğ Formal_Proc) ­ Speclab;
Ü	ÛSpeclab_dec_labelsİ : (Speclab ¸ ğ LABEL) ­ Speclab
°

ÿÛSPEC_ENVİüüüüüüüüüüüüüüüüü
Ü	spec_env : LABEL ß Speclab
ˆüüüüüüüüüüüüüüüüüüüü
¹Z
Ü	ÛSPEC_ENV0İ ¦ [SPEC_ENV | spec_env = {}]
°
=ENDDOC


\subsection{Running Environment}

The components $current\_for\_vars$ and $current\_log\_cons$ are required to add the for loop variables and logical constants to the scope of the block. This constitutes part of the implementation for \cite[volume 1, section 16.4.1]{DRA/CIS/CSE3/TR/94/27/3.0}.
=DOC
type ÛBLOCKİ
=TYPESTRUCT
      = {
	declab : DECLAB,
	current_formal_proc : FORMAL_PROC,
	current_formal_fun : FORMAL_FUN,
	current_for_vars : PARAM_SPEC list,
	current_log_cons : Z_DECL list,
	dec_lab : LABEL,
	spec_lab : LABEL,
	till : Z_PRED,
	using_decs : (Z_ID * (VAR_DECL list * Z_PRED)) list,
	var_inits : (EXP * TMARK) S_DICT
	};
=DESCRIBE
ÿÛBlockİüüüüüüüüüüüüüüüüü
Ü	Declab;
Ü	current_formal_proc : Formal_Proc;
Ü	current_formal_fun : Formal_Fun;
Ü	dec_lab, spec_lab : LABEL;
Ü	till : Z_PRED;
Ü	using_decs : Z_ID ß (ğ Var_Decl ¸ Z_PRED);
Ü	var_inits : ID ß (EXP ¸ TMARK)
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type ÛENVİ
=TYPESTRUCT
      = BLOCK list;
=DESCRIBE
¹ZAX
Ü	ÛBlock_stub_flagİ,
Ü	ÛBlock_body_flagİ,
Ü	ÛBlock_till_flagİ : (Block ¸ FLAG) ­ Block;
Ü	ÛBlock_vc_varsİ : (Block ¸ ğ Var_Decl) ­ Block;
Ü	ÛBlock_vc_parsİ : (Block ¸ ğ Param_Spec) ­ Block;
Ü	ÛBlock_vc_log_consİ : (Block ¸ ğ Z_Decl[Z_EXP]) ­ Block;
Ü	ÛBlock_formal_procsİ : (Block ¸ ğ Formal_Proc) ­ Block;
Ü	ÛBlock_dec_labelsİ : (Block ¸ ğ LABEL) ­ Block;
Ü	ÛBlock_current_formal_procİ : (Block ¸ Formal_Proc) ­ Block;
Ü	ÛBlock_current_formal_funİ : (Block ¸ Formal_Fun) ­ Block;
Ü	ÛBlock_tillİ : (Block ¸ Z_PRED) ­ Block;
Ü	ÛBlock_using_decsİ :
Ü		(Block ¸ (Z_ID ß (ğ Var_Decl ¸ Z_PRED))) ­ Block;
Ü	ÛBlock_var_initsİ : (Block ¸ (ID ß EXP ¸ TMARK)) ­ Block;
Ü 	ÛBlock_vc_aux_varsİ : (Block ¸ ğ Z_Decl) ­ Block;
Ü 	ÛBlock_in_scopeİ : (Block ¸ In_Scope) ­ Block
°

ÿÛENVİüüüüüüüüüüüüüüüüü
Ü	blocks : seq‰1 Block
ˆüüüüüüüüüüüüüüüüüüüü
=ENDDOC

¹ZAX
Ü Ûflatten_envİ : ENV ­ In_Scope
÷üüüüüü
Ü µ ENV; In_Scope; n : ID | n = (blocks 1).block_name·
Ü flatten_env(ÊENV) = ÊIn_Scope ¤
Ü 	vc_vars = Ş{b:ran blocks · b.vc_vars}
Ü ±	vc_pars = Ş{b:ran blocks · b.vc_pars}
Ü ±	vc_log_cons = Ş{b:ran blocks · b.vc_log_cons}
Ü ±	vc_aux_vars = Ş{b:ran blocks · b.vc_aux_vars}
Ü ±	formal_procs = Ş{b:ran blocks · b.formal_procs}
Ü ±	dec_labels = Ş{b:ran blocks | b.block_name = n · b.dec_labels}
°
¹ZAX
Ü Ûsubprog_flatten_envİ : ENV ­ In_Scope
÷üüüüüü
Ü µ ENV; Block' | ÊBlock' = blocks 1·
Ü (fun_flag' = False ² formal_body_flag' = False) ±
Ü	subprog_flatten_env(ÊENV) = flatten_env(ÊENV) ²
Ü formal_body_flag' = True ±
Ü 	(¶globs : ğZ_ID; ENV''; In_Scope'''; In_Scope''''; In_Scope'''''; name : ID
Ü	·  subprog_flatten_env (ÊENV) = ÊIn_Scope'''''
Ü	± (	fun_flag' = True
Ü		±	globs = ran(current_formal_fun'.globals)
Ü		±	name = current_formal_fun'.name
Ü	²	fun_flag' = False
Ü		±	globs = ran(current_formal_proc'.globals)
Ü		±	name = current_formal_proc'.name)
Ü	± blocks'' = blocks ù { Block | block_name = name · ÊBlock }
Ü	± ÊIn_Scope''' = flatten_env(ÊENV)
Ü	± ÊIn_Scope'''' = flatten_env(ÊENV'')
Ü	± vc_vars''''' = vc_vars'''' À {v : vc_vars''' | (trans_id v.var)  globs}
Ü	± vc_pars''''' = vc_pars'''' À {p : vc_pars''' | (trans_id p.var)  globs}
Ü	± vc_log_cons''''' = vc_log_cons''''
Ü	± vc_aux_vars''''' = vc_aux_vars'''' À {a : vc_aux_vars''' | a.zvar  globs}
Ü	± formal_procs'''''  = formal_procs'''
Ü	± dec_labels''''' = dec_labels'''')
°

ÿÛEmpty_Blockİüüüüüüüüüüüüüüüüü
Ü	Block
÷üüüüüüüüüüüüü
Ü	vc_vars = {};
Ü	vc_pars = {};
Ü	vc_log_cons = {};
Ü	vc_aux_vars = {};
Ü	formal_procs = {};
Ü	dec_labels = {};
Ü	var_inits = {}
ˆüüüüüüüüüüüüüüüüüüüü

ÿÛENV0İüüüüüüüüüüüüüüüüü
Ü	ENV;
Ü	Empty_Block
÷üüüüüüüüüüüüü
Ü	blocks =  § Ê Block ¢;
Ü	pack_spec_flag =
Ü	pack_body_flag =
Ü	stub_flag =
Ü	subunit_flag =
Ü	formal_body_flag =
Ü	fun_flag = declabel_flag = speclabel_flag = till_flag = False
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{SPARK Program Environment}\label{SPARKProgramEnvironment}
As the literate script is processed, a data structure is maintained which enables the SPARK Program to be extracted.
This data structure is in two parts: {\em(i)}, $SPARK\_PROG$: a list of the compilation units, or compilation unit k-slots which will eventually make up the top-level parts of the program, and {\em(ii)}, $REPL\_ENV$: a table giving the association of k-slot labels with program fragments determined by the refinement and replacement web clauses contained in the literate script.
The intention is that when processing of a literate script is complete these two data structures will enable a pretty-printing function to use $REPL\_ENV$ to expand all the k-slots in $SPARK\_PROG$ (both at the top-level and inside any constituent compilation units) and so output the required SPARK program.

To describe the data structures in Z, we first need given sets to stand for the necessary parts of the abstract syntax which have not been formally specified before.

=DOC
type ÛSPARK_PROGİ
=TYPESTRUCT
	= KSLOT_COMPILATION_UNIT list;
=DESCRIBE
¹Z
Ü	[	ÛCompilation_Unitİ,
Ü		ÛPrivate_Partİ,
Ü		ÛVisible_Partİ,
Ü		ÛDeclarative_Partİ,
Ü		ÛAnnotationİ]
°

¹Z
Ü	ÛK_Slot_Compilation_Unitİ	::=	Ûkcu_k_slotİ (LABEL)
Ü					|	Ûkcu_unitİ (Compilation_Unit)
°

ÿÛSPARK_Progİüüüüüüüüüüüüüüüüü
Ü	spark : seq K_Slot_Compilation_Unit
ˆüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

¹Z
Ü	ÛReplacementİ	::=	Ûreplace_compİ (seq Compilation_Unit)
Ü			|	Ûreplace_ppartİ (Private_Part)
Ü			|	Ûreplace_vpartİ (Visible_Part)
Ü			|	Ûreplace_declİ (Declarative_Part)
Ü			|	Ûrefine_statİ (seq Statement)
Ü			|	Ûreplace_statİ (seq Statement)
Ü			|	Ûreplace_annotationİ (seq Annotation)
°
ÿÛREPL_ENVİüüüüüüüüüüüüüüüüü
Ü	repl_env : LABEL ß Replacement
ˆüüüüüüüüüüüüüüüüüüüüüüüüü

Some of the ML types which help to implement the above are already available from \cite{ISS/HAT/DAZ/DTD502}.

For the branches of the data type for $Replacement$ we can use the $REPLACED\_BY\_XXX$ types  (which contain the label as well as the replacement, but that is no hardship).
In addition, we extend the replacement environment to allow for some error detection which is not catered for in the above Z.
When a k-slot is encountered an entry is made in the replacement environment indicating what sort of replacement is later to be expected for this object and giving the name of the {\Product} theory to be made current for type inference purposes when the replacement (or refinement) is made.

=SML
datatype ÛREPL_SORTİ		=	ÛRSCompilationİ
				|	ÛRSPrivatePartİ
				|	ÛRSVisiblePartİ
				|	ÛRSDeclarationİ
				|	ÛRSSpecStatementİ
				|	ÛRSStatementİ
				|	ÛRSAnnotationİ;
=TEX
=SML
datatype ÛREPLACEMENTİ	=	ÛReplaceCompİ of REPLACED_BY_COMP
				|	ÛReplacePPartİ of REPLACED_BY_PRIVATE_PART
				|	ÛReplaceVPartİ of REPLACED_BY_VISIBLE_PART
				|	ÛReplaceDeclİ of REPLACED_BY_DECL
				|	ÛReplaceStatİ of REPLACED_BY
				|	ÛReplaceArbitraryİ of REPLACED_BY_ARBITRARY_ADA
				|	ÛRefineStatİ of REPLACED_BY
				|	ÛReplaceAnnotationİ of REPLACED_BY_ANNOTATION
				|	ÛUnReplacedİ of (REPL_SORT * string);
=TEX
=SML
type ÛREPL_ENVİ
=TYPESTRUCT
      = REPLACEMENT S_DICT;
=TEX
\section{STATE RECORD}\label{STATERECORD}
The state of the Compliance Notation Processing is recorded in the following type.
Here, in addition to the five environments required by the DRA specifications, we have the SPARK program and replacement environment discussed in section \ref{SPARKProgramEnvironment} and a slot for the name of the literate script being processed.
=SML
type ÛZ_GENERATOR_STATEİ
=TYPESTRUCT
	= {
		pack_env : PACK_ENV,
		subunit_env : SUBUNIT_ENV,
		dec_env : DEC_ENV,
		spec_env : SPEC_ENV,
		blocks : ENV,
		repl_env : REPL_ENV,
		spark_prog : SPARK_PROG,
		script_name : string
		
	};
=TEX
\section{EPILOGUE}
=SML
end; (* signature CNTypes1 *)
=TEX
\section{TEST POLICY}
There are no module tests for the design in this document since it specifies no functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



