=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Autumn 2001 Enhancement Tests }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document provides integration tests to support the enhancements developed 
under the enhancements programme carried out in late 2001.}
\end{center}}

\def\Reference{LEMMA1/DAZ/INT519}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.6 $%
}
\def\Date{\FormatDate{$Date: 2001/12/17 16:51:51 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\underscoreoff
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu,daz}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1, 1.2] First drafts
\item[Issues 1.3] Live version for V2.5.3.
\item[Issues 1.4, 1.5] R0037: support for named numbers.
\item[Issue 1.6] R0034: formal procedures as stubs
\item[Issue 1.6] R0040: scope of formal parameter names
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Rob Arthan & Lemma 1\\
Gill Prout & Home \\
Roger Jones & Home
\end{tabular}
\end{center}


\section{INTRODUCTION}\label{INTRODUCTION}
This document is intended to provide integration tests to cover
the enhancements undertaken under the programme
of enhancements carried out in late 2001. See \cite{LEMMA1/DAZ/HLD508}
for the detailed specification of the enhancements.

The interim releases of the Compliance Tool have been
fully regression-tested and the new features have been module-
and integration-tested to a certain extent by the existing tests.
This document provides specific integration tests to
complete the coverage. 
\section{PREAMBLE}
Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.

=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX
=TEX
For batch use turn off subgoal package output:
=SML
set_flag("subgoal_package_quiet", not(ExtendedIO.is_term_in std_in));
=TEX
\section{THE TESTS}
\subsection{R0003: Record and array components as exported parameters}\label{ROne}

Some test coverage in INT513 (which fully tests the anti-aliasing checks).
The following tests the new functionality.

=SML
clean_up();
new_script{name = "r1", state = initial_cn_state};
=TEX

πCN
procedure p is
  type index is range 1 .. 4;
  type arr1 is array(index) of integer;
  type rec1 is record arr : arr1; num : integer; end record;
  type arr2 is array(index) of rec1;
  a : integer;
  a1 : arr1;
  r1 : rec1;
  a2 : arr2; 
  procedure q (x : out integer)
  Ñ X ò A [ X = A ] is begin x := a; end q;
begin 
   Ñ A, A1, R1, A2 [ (A2 1).NUM = 4 ] (10)
end p;
∞
πCN
 (10) √ a := 1; q(a1(a));
         a := a1(a)+a1(a); q(r1.num);
         a := r1.num + r1.num; q(a2(1).num);
∞
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_1");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.2", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_1")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_2");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.3", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_2")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_3");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.4", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_3")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_4");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[z_´_Ì_app_thm]);
a(rewrite_tac[z_gen_pred_elim(dest_z_tupleÒ(U, U)Æ) (z_get_specÒREC1uNUMÆ)]);
store_mt_results
(mt_runf (op =$))
 [("r1.5", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_4")];
=TEX
\subsection {R0021: domain condition generation}\label{RTwo}
Tested explicitly here.
=SML
clean_up();
new_script{name="r2_types", state=initial_cn_state};
πCN
package types is
  type small_nat is range 0 .. 9_999;
  type interval is digits 4 range -1.0 .. +1.0;
  type index is range 1 .. 4;
  type colour is (RED, BLUE, GREEN);
  type arr is array(colour) of small_nat;
end types;
∞
=SML
val types_state = get_cn_state();
=SML
new_script{name="r2.a", state=types_state};
set_int_control("cn_domain_conds", cn_standard_domain_conds);

πCN
with types;
procedure p(i : in types.small_nat; result : out types.small_nat)
Ñ RESULT [RESULT = 99 + I]
is
  x : types.small_nat;
  c : constant types.small_nat := 10;
begin
  if    i > 0 and then c mod i = 0
  then  x := c mod i;
  else  x := i;
  end if;
  x := x + 1;
  x := 99 / x;
  x := x rem x;
  result := x + 99 + i;
end p;
∞

=SML
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r2.a.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX
=SML
set_goal([Òµx:U | ≥x = 0 ∑ x rem x = 0Æ], get_conjecture"-""vcP_2");
a(cn_vc_simp_tac[z_get_specÒTYPESoSMALL_NATÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_ASM_T Ò≥I+1=0Æ discard_tac THEN LEMMA_T ÒI = 0Æ rewrite_thm_tac
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_ASM_T Ò≥I+1=0Æ discard_tac THEN LEMMA_T ÒI = 0Æ rewrite_thm_tac
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(DROP_ASM_T Ò≥I+1=0Æ discard_tac THEN LEMMA_T ÒI = 0Æ rewrite_thm_tac
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r2.a.2", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_2")];
=TEX
=SML
new_script{name="r2.b", state=types_state};
set_int_control("cn_domain_conds", cn_all_domain_conds);

πCN
with types;
procedure p(i : in types.small_nat)
Ñ [≥I < 0]
is
  x : types.interval := 0.0;
begin
 x := x ** i;
end p;
∞

=SML
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
store_mt_results
(mt_runf (op =$))
 [("r2.b.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX
=SML
new_script{name="r2.c", state=types_state};
set_int_control("cn_domain_conds", cn_standard_domain_conds);

πCN
with types;
procedure p(i, j : in types.colour;  a : in types.arr)
Ñ [I ç dom TYPESoCOLOURvSUCC ± J ç dom A]
is
  x : boolean;
begin
  x := a(j) = 0 and types.colour'succ(i) > 0;
end p;
∞

=SML
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
store_mt_results
(mt_runf (op =$))
 [("r2.c.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX
\subsection {R0034: Formal procedures as stubs}\label{RTwelve}
Regression tests {\it passim}. New feature tested explicitly here.
=SML
clean_up();
new_script{name="r12_spec", state=initial_cn_state};
=TEX

πCN
package TEST is
  procedure R;
  procedure P;
end TEST;
∞

=SML
new_script { name = "r12_body", state = get_cn_state() };
=TEX

πCN
package body TEST is
  x : Integer;
  ß R ¢	(0)
  ß P ¢	(1)
end TEST;
∞

πCN
 (0) È
  procedure R
    Ñ X [ X = Xâ0 - 7 ]
  is separate;
∞

πCN
 (1) È
  procedure P
    Ñ X [ X = Xâ0 + 1 ]
  is separate;
∞

=SML
new_script { name = "r12_subunit_r", state = get_cn_state() };
=TEX

πCN
separate(TEST)
procedure R
  Ñ X [ X = Xâ0 - 7 ]
is
begin
  x := x - 7;
end R;
∞

=SML
new_script { name = "r12_subunit_p", state = get_cn_state() };
=TEX

πCN
separate(TEST)
procedure P
  Ñ X [ X = Xâ0 + 1 ]
is
begin
  R;
  x := x + 8;
end P;
∞
=SML
fun check_r12_proof cnj = (
	set_goal([], get_conjecture"-" cnj);
	a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[]
		THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
	store_mt_results
	(mt_runf (op =$))
	 [("r12." ^ cnj , snd o dest_thm o pop_thm , (), get_conjecture"-" cnj)]
);
open_theory"r12_subunit_r";
val vcs_subunit_r = map (hd o fst) (get_conjectures"-");
val _ = map check_r12_proof vcs_subunit_r;
open_theory"r12_subunit_p";
val vcs_subunit_p = map (hd o fst) (get_conjectures"-");
val _ = map check_r12_proof vcs_subunit_p;
=TEX
\subsection{R0037: Support for named numbers}
\label{RThirteen}
The SPARK output functionality is covered in INT511.
We test the Z generation here.
=SML
clean_up();
new_script{name = "r13", state = initial_cn_state};
=TEX
In addition to the basic functionality,
the following also tests the use of mixed real/integer multiplication
and division for universal expressions as per ALRM section 4.10.
πCN
procedure p is
  c1 : constant := 999;
  c2 : constant := 1.5;
  c3 : constant := 1.5 * 3 + 3 * 1.5;
  c4 : constant := (2.0 * (3.0 * 3.0)) / 2;
  v1 : integer;
  v2 : float;
  v3 : float;
begin 
   Ñ V1, V2, V3 [ V1 = 1998 ± V2 = real 3 ± V3 = real 0 ± V2 *âR V2 = C4] (10)
end p;
∞
πCN
 (10) √ v1 := (c1 - 997)*c1; v2 := (c2 + 15.0E-1); v3 := c3 - c4;
∞
=SML
set_goal([Òµx:˙∑integer_to_real x = real xÆ], get_conjecture"-""vc10_1");
a(cn_vc_simp_tac(cn_e_thm :: map z_get_spec[ÒC1Æ, ÒC2Æ, ÒC3Æ, ÒC4Æ]));
a(asm_rewrite_tac[]);
a(MERGE_PCS_T1 ["'z_reals", "z_library"]prove_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r13.1.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_1")];
=TEX
\subsection{Bug fixes}
\label{REleven}
\subsubsection{R0038: Bug in processing auxiliary variables in global dependency lists}
\label{RElevenOne}
Tested explicitly here:
=SML
clean_up();
new_script {name="aux_var_spec", state=initial_cn_state};

πCN
package aux_var is
auxiliary x : ˙ ;
function f return integer
ò x [F x = x];
end aux_var;
∞
With the current (November 2001) treatment of data refinement, we cannot
expect to be able to implement the above package. However, we should
be able to use it:
=SML
new_script {name="aux_var_client", state=get_cn_state()};

πCN
with aux_var;
procedure read_x (result : out integer)
Ñ RESULT ò AUX_VARox [ RESULT = AUX_VARox ]
is
begin
	result := aux_var.f;
end read_x;
∞
=SML
set_goal([], get_conjecture"-""vcREAD_X_1");
a(cn_vc_simp_tac[z_get_specÒAUX_VARoFÆ]);
store_mt_results
(mt_runf (op =$))
 [("r11.1.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcREAD_X_1")];
=TEX

\subsubsection{R0040: Scope of formal parameter names}
\label{RElevenTwo}
Tested explicitly here:
=SML
clean_up();
new_script {name="form_pars_spec", state=initial_cn_state};
πCN
package Pack is
  type Rec is
  record
    A, B : Integer;
  end record;
  procedure S (X : in out Integer);
  procedure T (X : in out Rec);
end Pack;
∞
=SML
new_script{name = "form_pars_body", state = get_cn_state()};
πCN
package body Pack is
  procedure S (X : in out Integer)
  Ñ X [ true ]
  is separate;
  procedure T (X : in out Rec)
  is separate;
end Pack;
∞
=SML
new_script{name = "form_pars_subunit", state = get_cn_state()};
πCN
separate (Pack)
procedure T (X : in out Rec)
Ñ X [ true ]
is
  V : Integer;
begin
  V := X.A + X.B;
  S(X => V);
  X.A := V; 
  X.B := V;   
end T;
∞
Just to get here is enough --- the problem was that the above raised
an exception:
=SML
store_mt_results
mt_run
 [("r11.2.1", Combinators.I , (), ())];
=TEX
\section{EPILOGUE}
=SML
diag_line(summarize_mt_results());
=TEX
\end{document}
