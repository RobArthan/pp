=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Autumn 2001 Enhancement Tests }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document provides integration tests to support the enhancements developed 
under the enhancements programme carried out in late 2001.}
\end{center}}

\def\Reference{LEMMA1/DAZ/INT519}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.7 $%
}
\def\Date{\FormatDate{$Date: 2001/12/18 15:10:41 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\underscoreoff
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu,daz}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1, 1.2] First drafts
\item[Issues 1.3] Live version for V2.5.3.
\item[Issues 1.4, 1.5] R0037: support for named numbers.
\item[Issue 1.6] R0034: formal procedures as stubs
\item[Issue 1.6] R0040: scope of formal parameter names
\item[Issues 1.7 - 1.8] R0006: Free use of subtype indications and ranges
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Rob Arthan & Lemma 1\\
Gill Prout & Home \\
Roger Jones & Home
\end{tabular}
\end{center}


\section{INTRODUCTION}\label{INTRODUCTION}
This document is intended to provide integration tests to cover
the enhancements undertaken under the programme
of enhancements carried out in late 2001. See \cite{LEMMA1/DAZ/HLD508}
for the detailed specification of the enhancements.

The interim releases of the Compliance Tool have been
fully regression-tested and the new features have been module-
and integration-tested to a certain extent by the existing tests.
This document provides specific integration tests to
complete the coverage. 
\section{PREAMBLE}
Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.

=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX
=TEX
For batch use turn off subgoal package output:
=SML
set_flag("subgoal_package_quiet", not(ExtendedIO.is_term_in std_in));
=TEX
\section{THE TESTS}
\subsection{R0003: Record and array components as exported parameters}\label{ROne}

Some test coverage in INT513 (which fully tests the anti-aliasing checks).
The following tests the new functionality.

=SML
clean_up();
new_script{name = "r1", state = initial_cn_state};
=TEX

¹CN
procedure p is
  type index is range 1 .. 4;
  type arr1 is array(index) of integer;
  type rec1 is record arr : arr1; num : integer; end record;
  type arr2 is array(index) of rec1;
  a : integer;
  a1 : arr1;
  r1 : rec1;
  a2 : arr2; 
  procedure q (x : out integer)
  „ X ˜ A [ X = A ] is begin x := a; end q;
begin 
   „ A, A1, R1, A2 [ (A2 1).NUM = 4 ] (10)
end p;
°
¹CN
 (10) Ã a := 1; q(a1(a));
         a := a1(a)+a1(a); q(r1.num);
         a := r1.num + r1.num; q(a2(1).num);
°
=SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_1");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.2", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_1")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_2");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.3", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_2")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_3");
a(cn_vc_simp_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r1.4", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_3")];
=TEX

=SML
set_goal([], get_conjecture"-""vc10_4");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[z_«_í_app_thm]);
a(rewrite_tac[z_gen_pred_elim(dest_z_tupleñ(U, U)®) (z_get_specñREC1uNUM®)]);
store_mt_results
(mt_runf (op =$))
 [("r1.5", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_4")];

=TEX
\subsection {R0006: Free use of subtype indications and ranges}\label{RThree}
Tests new usages. Tests in INT519 cover ranges and subtypes in loop iteration control except for new syntax.
=SML
clean_up();
new_script{name="r3_types", state=initial_cn_state};
¹CN
package r3_types_etc is
  type small_nat is range 0  .. 9_999;
  type index is range 1 .. 4;
  type colour is (RED, BLUE, GREEN);
  type float_no_range is digits 6;
  type fix_no_range is delta 0.1;
  type uncon_arr_1d is array(colour range <>) of small_nat;
  type uncon_arr_2d is array(colour range <>, index range <>) of index;
  type con_arr_1d is array(colour range RED .. BLUE) of small_nat;
  type con_arr_2d is array(colour range RED .. BLUE, index range 2 .. 4 ) of index;
  a_con_arr_1d, another_con_arr_1d : con_arr_1d;
  a_con_arr_2d, another_con_arr_2d : con_arr_2d;
end types;
°
=SML
val types_state = get_cn_state();
=SML
new_script{name="r3.a", state=types_state};

¹CN
with r3_types_etc;
procedure psr(i : in r3_types_etc.small_nat; result : out r3_types_etc.small_nat)
„ RESULT [RESULT * RESULT > I ² RESULT = 100]
is
begin
   result := 100;
   for k in  reverse 1 .. 99 loop
      „  RESULT [ RESULT = 100 ² RESULT * RESULT > I]            (1)
   end loop  
end p;
°

¹CN
     (1) Ã if k * k > i then result := k;
°


¹CN
with r3_types_etc;
procedure pnr(i,klo,khi : in r3_types_etc.small_nat; result : out r3_types_etc.small_nat)
„ RESULT [RESULT * RESULT > I ² RESULT = 100]
is
begin
   result := 100;
   for k in  reverse klo .. khi loop
      „  RESULT [ RESULT = 100 ² RESULT * RESULT > I]            (2)
   end loop  
end p;
°

¹CN
     (2) Ã if k * k > i then result := k;
°


¹CN
with r3_types_etc;
procedure ps(i : in r3_types_etc.small_nat; result : out r3_types_etc.small_nat)
„ RESULT [RESULT * RESULT < I ² RESULT = 0]
is
begin
   result := 0;
   for k in   1 .. 99 loop
      „  RESULT [ RESULT = 0 ² RESULT * RESULT < I]            (3)
   end loop  
end p;
°

¹CN
     (3) Ã if k * k <  i then result := k;
°



¹CN
with r3_types_etc;
procedure pn(i,klo,khi : in r3_types_etc.small_nat; result : out r3_types_etc.small_nat)
„ RESULT [RESULT * RESULT < I ² RESULT = 0]
is
begin
   result := 0;
   for k in   klo .. khi loop
      „  RESULT [ RESULT = 0 ² RESULT * RESULT < I]            (4)
   end loop  
end p;
°

¹CN
     (4) Ã if k * k <  i then result := k;
°



¹CN
with r3_types_etc;
procedure qsr(i : in r3_types_etc.colour; result : out r3_types_etc.colour)
„ RESULT [RESULT = I ² RESULT = r3_types_etc.GREEN ]
is
begin
   result := GREEN;
   for k in  reverse r3_types_etc.RED .. r3_types_etc.BLUE loop
      „  RESULT [ RESULT = r3_types_etc.GREEN ² RESULT = I]            (5)
   end loop  
end p;
°

¹CN
     (5) Ã if k =  i then result := k;
°



¹CN
with r3_types_etc;
procedure qs(i : in r3_types_etc.colour; result : out r3_types_etc.colour)
„ RESULT [RESULT = I ² RESULT = r3_types_etc.GREEN ]
is
begin
   result := GREEN;
   for k in  r3_types_etc.RED .. r3_types_etc.BLUE loop
      „  RESULT [ RESULT = r3_types_etc.GREEN ² RESULT = I]            (6)
   end loop  
end p;
°

¹CN
     (6) Ã if k =  i then result := k;
°




¹CN
with r3_types_etc;
procedure qnr(i,klo,khi : in r3_types_etc.colour; result : out r3_types_etc.colour)
„ RESULT [RESULT = I ² RESULT = r3_types_etc.GREEN ]
is
begin
   result := GREEN;
   for k in  reverse klo .. khi loop
      „  RESULT [ RESULT = r3_types_etc.GREEN ² RESULT = I]            (7)
   end loop  
end p;
°

¹CN
     (7) Ã if k =  i then result := k;
°



¹CN
with r3_types_etc;
procedure qn(i, klo, khi : in r3_types_etc.colour; result : out r3_types_etc.colour)
„ RESULT [RESULT = I ² RESULT = r3_types_etc.GREEN ]
is
begin
   result := GREEN;
   for k in  klo .. khi loop
      „  RESULT [ RESULT = r3_types_etc.GREEN ² RESULT = I]            (8)
   end loop  
end p;
°

¹CN
     (8) Ã if k =  i then result := k;
°


=TEX
\subsection {R0021: domain condition generation}\label{RTwo}
Tested explicitly here.
=SML
clean_up();
new_script{name="r2_types", state=initial_cn_state};
¹CN
package types is
  type small_nat is range 0 .. 9_999;
  type interval is digits 4 range -1.0 .. +1.0;
  type index is range 1 .. 4;
  type colour is (RED, BLUE, GREEN);
  type arr is array(colour) of small_nat;
end types;
°
=SML
val types_state = get_cn_state();
=SML
new_script{name="r2.a", state=types_state};
set_int_control("cn_domain_conds", cn_standard_domain_conds);

¹CN
with types;
procedure p(i : in types.small_nat; result : out types.small_nat)
„ RESULT [RESULT = 99 + I]
is
  x : types.small_nat;
  c : constant types.small_nat := 10;
begin
  if    i > 0 and then c mod i = 0
  then  x := c mod i;
  else  x := i;
  end if;
  x := x + 1;
  x := 99 / x;
  x := x rem x;
  result := x + 99 + i;
end p;
°

=SML
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r2.a.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX
=SML
set_goal([ñµx:U | ³x = 0 · x rem x = 0®], get_conjecture"-""vcP_2");
a(cn_vc_simp_tac[z_get_specñTYPESoSMALL_NAT®] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_ASM_T ñ³I+1=0® discard_tac THEN LEMMA_T ñI = 0® rewrite_thm_tac
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(DROP_ASM_T ñ³I+1=0® discard_tac THEN LEMMA_T ñI = 0® rewrite_thm_tac
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "3" *** *)
a(DROP_ASM_T ñ³I+1=0® discard_tac THEN LEMMA_T ñI = 0® rewrite_thm_tac
	THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
(* *** Goal "4" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r2.a.2", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_2")];
=TEX
=SML
new_script{name="r2.b", state=types_state};
set_int_control("cn_domain_conds", cn_all_domain_conds);

¹CN
with types;
procedure p(i : in types.small_nat)
„ [³I < 0]
is
  x : types.interval := 0.0;
begin
 x := x ** i;
end p;
°

=SML
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
store_mt_results
(mt_runf (op =$))
 [("r2.b.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX
=SML
new_script{name="r2.c", state=types_state};
set_int_control("cn_domain_conds", cn_standard_domain_conds);

¹CN
with types;
procedure p(i, j : in types.colour;  a : in types.arr)
„ [I  dom TYPESoCOLOURvSUCC ± J  dom A]
is
  x : boolean;
begin
  x := a(j) = 0 and types.colour'succ(i) > 0;
end p;
°

=SML
set_goal([], get_conjecture"-""vcP_1");
a(cn_vc_simp_tac[] THEN REPEAT strip_tac);
store_mt_results
(mt_runf (op =$))
 [("r2.c.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcP_1")];
=TEX
\subsection {R0034: Formal procedures as stubs}\label{RTwelve}
Regression tests {\it passim}. New feature tested explicitly here.
=SML
clean_up();
new_script{name="r12_spec", state=initial_cn_state};
=TEX

¹CN
package TEST is
  procedure R;
  procedure P;
end TEST;
°

=SML
new_script { name = "r12_body", state = get_cn_state() };
=TEX

¹CN
package body TEST is
  x : Integer;
  § R ¢	(0)
  § P ¢	(1)
end TEST;
°

¹CN
 (0) é
  procedure R
    „ X [ X = X‰0 - 7 ]
  is separate;
°

¹CN
 (1) é
  procedure P
    „ X [ X = X‰0 + 1 ]
  is separate;
°

=SML
new_script { name = "r12_subunit_r", state = get_cn_state() };
=TEX

¹CN
separate(TEST)
procedure R
  „ X [ X = X‰0 - 7 ]
is
begin
  x := x - 7;
end R;
°

=SML
new_script { name = "r12_subunit_p", state = get_cn_state() };
=TEX

¹CN
separate(TEST)
procedure P
  „ X [ X = X‰0 + 1 ]
is
begin
  R;
  x := x + 8;
end P;
°
=SML
fun check_r12_proof cnj = (
	set_goal([], get_conjecture"-" cnj);
	a(cn_vc_simp_tac[] THEN REPEAT strip_tac THEN asm_rewrite_tac[]
		THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
	store_mt_results
	(mt_runf (op =$))
	 [("r12." ^ cnj , snd o dest_thm o pop_thm , (), get_conjecture"-" cnj)]
);
open_theory"r12_subunit_r";
val vcs_subunit_r = map (hd o fst) (get_conjectures"-");
val _ = map check_r12_proof vcs_subunit_r;
open_theory"r12_subunit_p";
val vcs_subunit_p = map (hd o fst) (get_conjectures"-");
val _ = map check_r12_proof vcs_subunit_p;
=TEX
\subsection{R0037: Support for named numbers}
\label{RThirteen}
The SPARK output functionality is covered in INT511.
We test the Z generation here.
=SML
clean_up();
new_script{name = "r13", state = initial_cn_state};
=TEX
In addition to the basic functionality,
the following also tests the use of mixed real/integer multiplication
and division for universal expressions as per ALRM section 4.10.
¹CN
procedure p is
  c1 : constant := 999;
  c2 : constant := 1.5;
  c3 : constant := 1.5 * 3 + 3 * 1.5;
  c4 : constant := (2.0 * (3.0 * 3.0)) / 2;
  v1 : integer;
  v2 : float;
  v3 : float;
begin 
   „ V1, V2, V3 [ V1 = 1998 ± V2 = real 3 ± V3 = real 0 ± V2 *‰R V2 = C4] (10)
end p;
°
¹CN
 (10) Ã v1 := (c1 - 997)*c1; v2 := (c2 + 15.0E-1); v3 := c3 - c4;
°
=SML
set_goal([ñµx:ú·integer_to_real x = real x®], get_conjecture"-""vc10_1");
a(cn_vc_simp_tac(cn_e_thm :: map z_get_spec[ñC1®, ñC2®, ñC3®, ñC4®]));
a(asm_rewrite_tac[]);
a(MERGE_PCS_T1 ["'z_reals", "z_library"]prove_tac[]);
store_mt_results
(mt_runf (op =$))
 [("r13.1.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vc10_1")];
=TEX
\subsection{Bug fixes}
\label{REleven}
\subsubsection{R0038: Bug in processing auxiliary variables in global dependency lists}
\label{RElevenOne}
Tested explicitly here:
=SML
clean_up();
new_script {name="aux_var_spec", state=initial_cn_state};

¹CN
package aux_var is
auxiliary x : ú ;
function f return integer
˜ x [F x = x];
end aux_var;
°
With the current (November 2001) treatment of data refinement, we cannot
expect to be able to implement the above package. However, we should
be able to use it:
=SML
new_script {name="aux_var_client", state=get_cn_state()};

¹CN
with aux_var;
procedure read_x (result : out integer)
„ RESULT ˜ AUX_VARox [ RESULT = AUX_VARox ]
is
begin
	result := aux_var.f;
end read_x;
°
=SML
set_goal([], get_conjecture"-""vcREAD_X_1");
a(cn_vc_simp_tac[z_get_specñAUX_VARoF®]);
store_mt_results
(mt_runf (op =$))
 [("r11.1.1", snd o dest_thm o pop_thm , (), get_conjecture"-""vcREAD_X_1")];
=TEX

\subsubsection{R0040: Scope of formal parameter names}
\label{RElevenTwo}
Tested explicitly here:
=SML
clean_up();
new_script {name="form_pars_spec", state=initial_cn_state};
¹CN
package Pack is
  type Rec is
  record
    A, B : Integer;
  end record;
  procedure S (X : in out Integer);
  procedure T (X : in out Rec);
end Pack;
°
=SML
new_script{name = "form_pars_body", state = get_cn_state()};
¹CN
package body Pack is
  procedure S (X : in out Integer)
  „ X [ true ]
  is separate;
  procedure T (X : in out Rec)
  is separate;
end Pack;
°
=SML
new_script{name = "form_pars_subunit", state = get_cn_state()};
¹CN
separate (Pack)
procedure T (X : in out Rec)
„ X [ true ]
is
  V : Integer;
begin
  V := X.A + X.B;
  S(X => V);
  X.A := V; 
  X.B := V;   
end T;
°
Just to get here is enough --- the problem was that the above raised
an exception:
=SML
store_mt_results
mt_run
 [("r11.2.1", Combinators.I , (), ())];
=TEX
\section{EPILOGUE}
=SML
diag_line(summarize_mt_results());
=TEX
\end{document}
