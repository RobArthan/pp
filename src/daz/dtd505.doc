%  %Z% $Revision: 1.67 $ $RCSfile: dtd505.doc,v $ $Date: 2001/11/06 17:31:03 $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Verification Condition Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD505}  %% Mandatory field
\def\SCCSversion{$Revision: 1.67 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2001/11/06 17:31:03 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This document contains the detailed design for the Verification Condition Generator for the Compliance Tool.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.11] Initial Drafts.
\item[Issue 1.12 (26th September 1994)] Reworked according to desk check report 009.
\item[Issues 1.13-1.23] Bug fixing, added support for checks.
\item[Issue 1.24] Added new error message for $check\_1\_a$.
\item[Issue 1.25] Improved error messages for checks 1b, 1c and 1d.
\item[Issue 1.26] Changed signature of $check\_new\_z\_id$.
\item[Issue 1.26] Changed signature of $check\_new\_z\_id$.
\item[Issue 1.27-1.29] Batch 1 bug fixing.
\item[Issue 1.30] Enhancements 13 and 14.
\item[Issue 1.31,1.32] Bug fixing (batch 2 bug 13); also improved wording of many error messages.
\item[Issue 1.33] Corrected spelling mistake in error message.
\item[Issue 1.34] Fixed DRA bug 15 (V0.6).
\item[Issue 1.36-1.37] Fixing $analyse\_log\_con$.
\item[Issue 1.38] Improved message 505063.
\item[Issue 1.39] IUCT WP 4 changes.
\item[Issue 1.40] Corrected Z syntax and type errors.
\item[Issue 1.41] Slight improvement to error message 505080.
\item[Issue 1.42] Check 1(a) now applies to procedure calls to. This changes
the signature and description of some of the checks.
\item[Issue 1.43] Added new check 16.
\item[Issue 1.44] Updated references.
\item[Issue 1.45] Tidying.
\item[Issue 1.46,1.47] Update for SML97. Fixed broken error messages.
\item[Issue 1.48]
Trialling enhancement ref. R5 from \cite{LEMMA1/DAZ/HLD506}
At this version only the Z and a few of the ML types have been changed.
The main ML changes will come later.
\item[Issue 1.49] Trialling remaining enhancements from \cite{LEMMA1/DAZ/HLD506}.
\item[Issue 1.50] Prototyping enhancement R5 --- Initial Variables in Conditionals.
\item[Issue 1.51] Typechecking corrected approach to enhancement R2 --- Multiple Logical Constant Definitions.
\item[Issue 1.52] Typechecking new approach to enhancement R3 --- Assignment to Record Components.
\item[Issue 1.53,1.54,1.55] Prototyping enhancement R2 --- Multiple Logical Constant Definitions
(adjusted error messages for new syntax).
\item[Issue 1.56] Check on initial variables in pre-conditions added.
\item[Issue 1.57] CTLE II R1/2: ``others'' in case statements.
\item[Issues 1.58-1.60] CTLE II R1/3: reverse loops.
\item[Issues 1.61] CTLE II R1/9: SPARK 83 attributes.
\item[Issue 1.62] CTLE II R2/1 --- global variable unsoundness.
\item[Issue 1.63] Fixed typo in Z spec of {\it FOR\_STATIC}.
\item[Issue 1.64] Perfomance enhancement for type-checking of specification statements.
\item[Issue 1.65] Added option to compactify pre- and post-conditions.
\item[Issues 1.66-1.68] Enhancement R0003 --- record and array components as exported parameters.
\end{description}
\subsection{Changes Forecast}
None.

\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the Verification Condition (VC) Generator. The design is in response to the high level design for compliance notation processing \cite{ISS/HAT/DAZ/HLD503}.

The document provides a design which implements DRA's specification for VC Generation described in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

The VC generator is called by the Z document generator \cite{ISS/HAT/DAZ/IMP507} to generate VCs for inclusion into the generated Z document according to the algorithms specified in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

The Z of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0} is reproduced in this document (suitable for type-checking with {\Product}) adjacent to the signature declarations of the functions which implement the Z. The corresponding implementatation is in \cite{ISS/HAT/DAZ/IMP505}.

\subsection{Compliance}

This detailed design contains signatures for Standard ML functions with the Z specification of these functions, transcribed from \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}. The names of these functions corresponds to the names used in the Z, and where they differ, justification has been provided.

The implementation of this design can be found in \cite{ISS/HAT/DAZ/IMP505} where the style of coding is intended to make the compliance with the Z specification evident by a visual comparison.

In {\ProductZ}, subscripts are not decoration. In order to achieve the effect required by \cite[Volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}, multiple priming has been used and generally, the number of primes in a decoration corresponds to the numeric value of the subcript in \cite[Volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

The checks which have been implemented are introduced in section \ref{APPLICATIONOFCHECKS} and are listed in table \ref{ImplementedChecks}.

\begin{table}
\center
\begin{tabular}{||l|l||}\hline\hline
Volume 1: & 17.1.1: 1. (a), (b), (c) \& (d) \\
      & 17.1.1: 2. \\
      & 17.1.1: 3. \\
      & 17.1.1: 4. \\
      & 17.1.1: 12. \\
      & 17.1.1: 16. \\ \hline
Volume 2: & 5.2 (aliasing) \& 5.3 (variable capture) \\
\hline\hline
\end{tabular}
\caption{Implemented Checks}\label{ImplementedChecks}
\end{table}

The implementation of the function {\it domain\_conds} that calculates the domain conditions
of an expression fits much more naturally into the implementation of the expression
translator in \cite{ISS/HAT/DAZ/IMP508}. Consequently the Z specification and ML
signature of {\it domain\_conds} is in \cite{ISS/HAT/DAZ/DTD508} rather than in this
document.

%\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}

\section{PREAMBLE FOR Z TYPE CHECKING}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd508";
push_pc "z_library";
force_delete_theory"dtd505" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory"dtd505";
new_parent"dtd514";
=TEX

\section{THE SIGNATURE $CNVCGenerator$}

=DOC
local
	open CNTypes CNBasicDeclsAndExprs CNTypes1 CNTypes2;
in
signature ÛCNVCGeneratorÝ = sig
=DESCRIBE
=FAILURE
505001	?0
=ENDDOC

\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}

This section implements section 2 of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

\subsection{Sequents}

=DOC
val ÛôÝ : Z_PRED list * Z_PRED -> SEQUENT;
=DESCRIBE
¹Z
fun 3 _ ô _
°

¹ZAX
Ü	_ ÛôÝ _ : (ð Z_PRED ¸ Z_PRED) ­ Sequent
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ Sequent · H ô c = Ê Sequent
°
=ENDDOC

=DOC
val Û%Longrightarrow%Ý : Z_PRED * SEQUENT list -> SEQUENT list;
=DESCRIBE
¹Z
fun 4 _ %Longrightarrow% _
°

¹ZAX
Ü	_ Û%Longrightarrow%Ý _ : (Z_PRED ¸ ð Sequent) ­ ð Sequent
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ h : Z_PRED; S : ð Sequent ·
Ü	h %Longrightarrow% S = { Sequent | H ô c  S · ({h} À H) ô c }
°
=ENDDOC

\subsection{Substitutions}

=DOC
val ÛsubÝ : Z_PRED * Z_ID * Z_EXP -> Z_PRED;
=DESCRIBE
¹ZAX
Ü	sub : (Z_PRED ¸ Z_ID ¸ Z_EXP) ­ Z_PRED
°
=ENDDOC

=DOC
val Ûsubs_expÝ : Z_EXP * Z_ID list * Z_ID list -> Z_EXP;
=DESCRIBE
¹ZAX
Ü	subs_exp : (Z_EXP ¸ ð Z_ID ¸ ð Z_ID) ß Z_EXP
°
=ENDDOC

=DOC
val Ûsubs_predÝ : Z_PRED * Z_ID list * Z_ID list -> Z_PRED;
=DESCRIBE
¹ZAX
Ü	subs_pred : (Z_PRED ¸ ð Z_ID ¸ ð Z_ID) ß Z_PRED
°
=ENDDOC

=DOC
val ÛsubseqÝ : SEQUENT list * Z_ID * Z_EXP -> SEQUENT list;
=DESCRIBE
¹ZAX
Ü	subseq : (ð Sequent ¸ Z_ID ¸ Z_EXP) ­ ð Sequent
÷üüüüüüüüüüüüüüü
Ü	µ S : ð Sequent; x : Z_ID; E : Z_EXP ·
Ü	   subseq (S,x,E) =
Ü		{ Sequent | H ô c  S · { h : H · sub (h,x,E)} ô sub (c,x,E) }
°
=ENDDOC
=DOC
(* Flag Ûcn_use_let_in_vcsÝ - boolean control, default false *)
=DESCRIBE
This flag controls the way substitution of expressions for variables is treated during VC generation.

If the flag is false (the default), then the substitution is carried out using the HOL $subst$ function and then conversions are used to transform the result into Z: this results in a Z term in which the variables have actually been replaced by their substitutes, and declarations and other constructs have been adjusted as necessary to avoid variable capture.

If the flag is set true (using $set\_flag$), then an HOL $let$ construct is used to give the semantics of substitution without actually replacing any variables with their substitutes.
The result is {\em not} Z, but may help to abbreviate the VC and make its structure clearer.
=ENDDOC

\section{WEAKEST PRECONDITIONS}
This section implements section 4 of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.
Note that the design for the datatypes is in \cite{ISS/HAT/DAZ/DTD514}. The type $RESULT$ is defined in that document.

\subsection{Null Statement}\label{wp-null}
=DOC
val ÛnullÝ : WP_PARS -> RESULT  
=DESCRIBE
ÿNULLüüüüüüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüüü
Ü	st = null;
Ü	WP = A;
Ü	SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Assignment Statement}\label{wp-assignment}


=DOC
val Ûsimple_assignÝ : WP_PARS -> ID -> Z_EXP -> RESULT  
=DESCRIBE
ÿSIMPLE_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü  ¶ Assign; x : ID ·
Ü	st = assign(Ê Assign) ± name = Id x ±
Ü	WP = subseq(A, trans_id x, trans_exp E) ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûarray_assignÝ : WP_PARS -> EXP INDEXED_COMP -> Z_EXP -> RESULT  
=DESCRIBE
ÿARRAY_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Assign; Indexed_Comp; Assign' ·
Ü		st = assign(Ê Assign) ±
Ü		name = indexed_comp (Ê Indexed_Comp) ±
Ü		Ê Result = wp (assign(Ê Assign'), A, ÊWp_Env) ±
Ü		name' = prefix ±
Ü		E' =
Ü		auxiliary_exp
Ü		(z_override
Ü		   (trans_exp prefix, z_set {
Ü				z_maplet(z_tuple(map trans_exp index), trans_exp E)} ))
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
val Ûz_record_updateÝ : TMARK * ID * Z_EXP * Z_EXP -> Z_EXP;
=DESCRIBE
¹ZAX
Ü tmark_of_prefix : Z_EXP ß TMARK
°
{\it tmark\_of\_prefix} is provided in \cite{ISS/HAT/DAZ/DTD508}, since
it is used in the translation of attributes.
¹ZAX
Ü z_record_update : TMARK ¸ ID ¸ Z_EXP ¸ Z_EXP ­ Z_EXP
°
=ENDDOC


=DOC
val Ûrecord_assignÝ : WP_PARS -> EXP SELECTED_COMP -> Z_EXP -> RESULT;  
=DESCRIBE
ÿRECORD_ASSIGNüüüüüüüü
Ü	Pars
÷üüüüü
Ü   ¶ Assign; Selected_Comp; Assign'; zprefix : Z_EXP ·
Ü	st = assign(Ê Assign) ±
Ü	name = selected_comp (Ê Selected_Comp) ±
Ü	Ê Result = wp (assign (Ê Assign'), A, ÊWp_Env) ±
Ü	name' = prefix ±
Ü	zprefix = trans_exp prefix ±
Ü	E' = auxiliary_exp(z_record_update(tmark_of_prefix zprefix, selector,
Ü		zprefix, trans_exp E))
ˆüüüüüüüüüüüüüüüü
=FAILURE
505027	The operand of the component selection is not a record
505028	Type error on left-hand side of assignment statement
=ENDDOC

=DOC
val ÛassignÝ : WP_PARS -> EXP * Z_EXP -> RESULT  
=DESCRIBE
$assign$ recognises the kind of assignment statement by looking at the LHS supplied as $EXP$, and calls the appropriate function, i.e., $simple\_assign$, $array\_assign$ or $record\_assign$, to generate the wp.
=FAILURE
505029	the lhs of the assignment statement is not an assignable identifier
=ENDDOC

\subsection{Specification Statement (No initial variables)} \label{wp-specification-no-ivars}

=DOC
val Ûspec_no_ivarsÝ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
ÿSPEC_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = spec_no_ivars (Ê Spec_No_Ivars) ± w ½ š ±
Ü	WP = { š ô Pre } ± SIDE = post %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûspec_no_ivars_emptyÝ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
ÿSPEC_NO_IVARS_EMPTYüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = spec_no_ivars (Ê Spec_No_Ivars) ± w = š ±
Ü	WP = { š ô Pre } À post %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûspec_no_ivars_eitherÝ :
	WP_PARS -> Z_ID list -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
$spec\_no\_ivars\_either$ calls $spec\_no\_ivars\_empty$ or $spec\_no\_ivars$ depending on whether the frame is empty.
=ENDDOC

\subsection{Semicolon}\label{wp-semicolon}

=DOC
val ÛsemicolonÝ : WP_PARS -> STATEMENT * STATEMENT -> RESULT  
=DESCRIBE
ÿResultsüüüüüüüüüüüü
Ü	Result';
Ü	Result''
ˆüüüüüüüüüüüüüüüüüüüüü
ÿSEMICOLONüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ P, Q : Statement; Results ·
Ü	st = semicolon (P, Q) ± WP = WP' ±
Ü	SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (P, WP'', Ê Wp_Env) ±
Ü	Ê Result'' = wp (Q, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{If Statement}\label{wp-if-then-else}


=DOC
val Ûif_then_elseÝ : WP_PARS -> STATEMENT IF_THEN_ELSE -> RESULT  
=DESCRIBE
¹ZAX
Ü	TRUE, FALSE : Z_ID
°
ÿIF_THEN_ELSEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ If_Then_Else; Results ·
Ü	st = if_then_else (Ê If_Then_Else) ±
Ü	WP =
Ü	z_eq (trans_exp G, zid TRUE) %Longrightarrow% WP' À
Ü	z_eq (trans_exp G, zid FALSE) %Longrightarrow% WP'' ±
Ü			SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (P, A, ÊWp_Env) ±
Ü	Ê Result'' = wp (Q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Case Statement}\label{wp-case}


=DOC
val Ûtrans_case_choicesÝ : CN_ENV -> CASE_CHOICE list -> Z_EXP  
=DESCRIBE
¹ZAX
Ü	trans_case_choices : ð CASE_CHOICE ­ Z_EXP
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü µ choices : ð CASE_CHOICE ·
Ü   ¶ zranges : ð Z_EXP; zsingles : Z_EXP ·
Ü	zranges = 
Ü	{ Range | case_range (Ê Range)  choices ·
Ü		z_rng (trans_exp lo, trans_exp hi) } ±
Ü	zsingles =
Ü	z_set {ex : EXP | case_exp ex  choices · trans_exp ex } ±
Ü	trans_case_choices choices = z_many_union (zranges À {zsingles} )
°
=FAILURE
505020	VCs cannot be generated for a statement containing a range attribute
=ENDDOC



=DOC
val Ûcase_baseÝ :
	WP_PARS -> EXP -> STATEMENT CASE_ALTERNATIVE ->
	RESULT * Z_EXP 
=DESCRIBE
The implementation returns the translated case choices to save having
to recompute it in {\it case\_others}. 
ÿCase_Baseüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Statement]
÷üüüüüüüüüüüüüü
Ü	s = § Ê(Case_Alternative[Statement]) ¢
ˆüüüüüüüüüüüüüüüüüüüüü
ÿCASE_BASEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Base; Result' ·
Ü	st = case (Ê Case) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' ±
Ü	SIDE = SIDE' ± Ê Result' = wp (P, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûcase_stepÝ : WP_PARS -> STATEMENT CASE -> RESULT * Z_EXP list

=DESCRIBE
ÿCase_Stepüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Statement];
Ü	Case'
÷üüüüüüüüüüüüüü
Ü	E = E';
Ü	s = § Ê(Case_Alternative[Statement]) ¢ ë s'
ˆüüüüüüüüüüüüüüüüüüüüü
ÿCASE_STEPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Step; Results ·
Ü	st = case (Ê Case) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' À WP'' ±
Ü	SIDE = SIDE' À SIDE'' ± Ê Result' = wp (P, A, Ê Wp_Env) ±
Ü	Ê Result'' = wp (case (Ê Case'), A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505030	Internal error: case statement with no alternatives found
=ENDDOC

=DOC
val Ûcase_othersÝ : WP_PARS -> STATEMENT CASE -> RESULT  
=DESCRIBE
The implementation
of {\it case\_others} is analogous to {\it spec\_no\_ivars\_either} in that it is sensitive to the input and processes a case statement with or without an others part
using {\it case\_step} to do the work directly that the first recursive
call in the Z would do less directly.
ÿCASE_OTHERSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Others; Results; exps : ðZ_EXP ·
Ü	st = case_others (Ê Case_Others) ±
Ü	WP = WP' À z_notelem(trans_exp E, z_many_union exps) %Longrightarrow% WP'' ±
Ü	SIDE = SIDE' À SIDE'' ±
Ü	exps = {alt : ran s· trans_case_choices(alt.choices)} ±
Ü	Ê Result' = wp (case (Ê Case), A, ÊWp_Env) ±
Ü	Ê Result'' = wp (Q, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505030	Internal error: case statement with no alternatives found
=ENDDOC


\subsection{Undecorated Loop}\label{wp-loop}

$named\_loop$ below is required to handle named loops. Its semantics are the same as for $loop$.
=DOC
val ÛloopÝ : WP_PARS -> STATEMENT LOOP -> RESULT  
val Ûnamed_loopÝ : WP_PARS -> STATEMENT NAMED_LOOP -> RESULT  
=DESCRIBE
ÿLOOPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Loop ·
Ü	st = loop (Ê Loop) ± WP = {š ô Pre} ±
Ü	SIDE = { {post} ô Pre } À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC

\subsection{While Loop}\label{wp-while-loop}

$while$ is a reserved word in Standard ML; hence we use the name $cn\_while$.

=DOC
val Ûcn_whileÝ : WP_PARS -> STATEMENT WHILE -> RESULT  
=DESCRIBE
ÿWHILEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ While ·
Ü	st = while (Ê While) ±
Ü	WP =
Ü	{ {z_eq(trans_exp G, zid TRUE)} ô Pre} À
Ü	z_eq(trans_exp G, zid FALSE) %Longrightarrow% A ±
Ü	SIDE = post %Longrightarrow% WP À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC


=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-value}

=DOC
val Ûfor_staticÝ : WP_PARS -> STATEMENT FOR_STATIC -> RESULT  
=DESCRIBE
If the loop does not contain a $till$ predicate, then $T %Longrightarrow% A$ is removed from $SIDE$.

ÿFOR_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Static; Z_Bin_Exp; zi : Z_ID; zlo, zhi, zinitial, zfinal : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = for_static (Ê For_Static) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (Pre, zi, zinitial) } À
Ü		z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { zran, z_noteq(zid zi, zfinal), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zfinal) %Longrightarrow% A À
Ü		zran %Longrightarrow% (T %Longrightarrow% A) ±
Ü	zran = z_elem (zid zi, z_rng (zlo, zhi)) ±
Ü	zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü	(dir = Forwards ± zinitial = zlo ± zfinal = zhi ± zop = z_add ²
Ü	 dir = Reverse ± zinitial = zhi ± zfinal = zlo ± zop = z_minus) ±
Ü	zleft = zid zi ± zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505020	VCs cannot be generated for a statement containing a range attribute
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC

\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}


=DOC
val Ûfor_tmarkÝ : WP_PARS -> STATEMENT FOR_TMARK -> RESULT  
=DESCRIBE
ÿFOR_TMARKüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Tmark; Z_Bin_Exp; zi : Z_ID; zlo, zhi, zinitial, zfinal : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = for_tmark (Ê For_Tmark) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (Pre, zi, zinitial) } À
Ü	z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { z_noteq(zid zi, zfinal), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zfinal) %Longrightarrow% A À
Ü	T %Longrightarrow% A ± zi = trans_id i ± zlo = zid (trans_id tmark ^ zfst) ±
Ü	zhi = zid (trans_id tmark ^ zlst) ± 
Ü	(dir = Forwards ± zinitial = zlo ± zfinal = zhi ± zop = z_add ²
Ü	 dir = Reverse ± zinitial = zhi ± zfinal = zlo ± zop = z_minus) ±
Ü	zleft = zid zi ± zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC

\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}



=DOC
val Ûexit_whenÝ : WP_PARS -> EXIT_WHEN -> RESULT  
=DESCRIBE
ÿEXIT_WHENüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Exit_When ·
Ü	st = exit_when (Ê Exit_When) ±
Ü	WP =
Ü	{ { z_eq (trans_exp G, zid TRUE) } ô till} À
Ü	z_eq (trans_exp G, zid FALSE)  %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Exit Statement}\label{wp-exit}

$exit$ is already bound in {\Product}; hence we use $cn\_exit$.
=DOC
val Ûcn_exitÝ : WP_PARS -> RESULT  
=DESCRIBE
ÿEXITüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	st = exit;
Ü	WP = { š ô till };
Ü	SIDE= š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Return Statement}\label{wp-return}

$return$ is already bound in {\Product}; hence we use $cn\_return$.
=DOC
val Ûcn_returnÝ : WP_PARS -> RETURN -> RESULT  
=DESCRIBE
ÿRETURNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Return; Z_Fun_Call; Informal_Fun ·
Ü	st = ret (Ê Return) ±
Ü	WP = { { z_eq (z_fun_call (Ê Z_Fun_Call), trans_exp E) } ô return } ±
Ü	SIDE = š ± fun_header = Ê Informal_Fun ±
Ü	zfun = zid (trans_id name) ±
Ü	zargs = { i : dom formal_pars · i ízid (trans_id (formal_pars i).var) }
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Procedure Call (No Initial Variables in Spec)} \label{wp-proc-call-no-ivars}


=DOC
val Ûproc_call_specÝ : CN_ENV -> (AGG_CHOICE, EXP) PROC_CALL -> FORMAL_PROC ->
		Z_PRED * Z_PRED * STATEMENT * Z_PRED list;
=DESCRIBE
¹ZAX
Ü	proc_call_spec : (Proc_Call ¸ Formal_Proc) ß Spec
°
=FAILURE
505026	Call to ?0 does not match its declaration
=ENDDOC

=DOC
val Ûproc_call_no_ivarsÝ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL
							-> RESULT  
=DESCRIBE
ÿPROC_CALL_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call; fp : Formal_Proc ·
Ü	st = proc_no_ivars pc ±
Ü	Ê Result =
Ü	wp (spec_no_ivars (proc_call_spec (pc, fp)), A, Ê Wp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505031	Procedure ?0 has not been declared
=ENDDOC

\subsection{Specification (With Initial Variables)}\label{wp-spec-ivars}

=DOC
val Ûspec_ivarsÝ : WP_PARS -> (Z_EXP * Z_EXP) -> RESULT  
=DESCRIBE
ÿSPEC_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_Ivars ·
Ü	st = spec_ivars (Ê Spec_Ivars) ± WP = {š ô Pre} ±
Ü	SIDE = post %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}

=DOC
val Ûfor_non_staticÝ : WP_PARS -> STATEMENT FOR_NON_STATIC -> RESULT  
=DESCRIBE
ÿFOR_NON_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Non_Static; Z_Bin_Exp; zi : Z_ID;
Ü	zlo, zhi, zlo‰0, zhi‰0, zinitial‰0, zfinal‰0 : Z_EXP; zran : Z_PRED ·
Ü		st = for_non_static (Ê For_Non_Static) ±
Ü		WP =
Ü		{ {z_less_eq (zlo, zhi)} ô  sub (Pre, zi, zlo)} À
Ü		z_greater (zlo, zhi) %Longrightarrow% A ±
Ü		SIDE =
Ü		{ { zran, z_noteq (zid zi, zfinal‰0), post} ô
Ü			sub (Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zfinal‰0) %Longrightarrow% A À zran %Longrightarrow% (T %Longrightarrow% A) ±
Ü		zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü		(dir = Forwards ± zinitial‰0 = zlo‰0 ± zfinal‰0 = zhi‰0 ± zop = z_add ²
Ü		 dir = Reverse ±  zinitial‰0 = zhi‰0 ± zfinal‰0 = zlo‰0 ± zop = z_minus) ±
Ü		zleft = zid zi ± zright = z_num 1 ±
Ü		zlo‰0 = subs_exp (zlo, w, w‰0) ±
Ü		zhi‰0 = subs_exp (zhi, w, w‰0) ±
Ü		zran = z_elem (zid zi, z_rng (zlo‰0, zhi‰0))
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505020	VCs cannot be generated for a statement containing a range attribute
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC

\subsection{Logical Constant}\label{wp-log-con}


=DOC
val Ûanalyse_log_conÝ :
	LOG_CON_DEF list -> Z_PRED -> LOG_CON_DEF list * Z_PRED  
=DESCRIBE
$analyse\_log\_con$ $c$ $pre$ breaks down a precondition, $pre$ associated with a logical constant specification statement and returns the constituent parts.
It takes the information from the declarations of the logical constants
(with dummy defining terms inserted by the parser)
together with a pre-conditions of the form
=INLINEFT
x1 = E1 ± x2 = E2 ± ... pre1
=TEX
and yields an updated set of {\it LOG\_CON\_DEF}s with
the proper defining terms in the proper order
together with a predicate containing $pre1$.
It will fail if $pre$ is not of the right form or if the declarations don't agree in
number and names with the defining equations or if the equations violate the definition
before use rule.
=USES
It is used by the $log\_con$ function in the process of generating VCs for logical constants. 
=FAILURE
505024	Logical constant statement with precondition ?0 does not have the required form 
	CON x1 : t1; x2 : t2; ... · „ w [x1 = E1 ± x2 = E2 ± ... ± pre1, post]
505025	In a logical constant statement: 
	CON x1 : t1; x2 : t2; ... · „ w [x1 = E1 ± x2 = E2 ± ... ± pre1, post]
	x1 must not appear free in E1, x2 must not appear free
	in E1 or E2 and so on; here ?0 appears free in ?1
=ENDDOC
¹ZAX
Ü z_log_con_def : ðZ_ID ¸ ðZ_ID ­ Log_Con_Def ­ Z_PRED
÷üüüüüü
Ü µ u, v : ðZ_ID; Log_Con_Def·
Ü	z_log_con_def(u,v)(ÊLog_Con_Def) = z_eq(zid X, subs_exp(E, u, v))
°
¹ZAX
Ü add_hyps : (seq‰1 Z_PRED) ¸ ðSequent ­ ðSequent
÷üüüüüü
Üµ h : Z_PRED; S : ðSequent· add_hyps (§h¢, S) = h %Longrightarrow% S;
Üµ h‰1, h‰2 : seq‰1 Z_PRED; S : ðSequent·
Ü	add_hyps (h‰1 ë h‰2, S) = add_hyps (h‰1, add_hyps(h‰2, S))
°

=DOC
val Ûlog_conÝ : WP_PARS -> LOG_CON -> RESULT  
=DESCRIBE
ÿÛLOG_CONÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü¶ Log_Con ·
Ü	st = log_con (Ê Log_Con) ±
Ü	WP = { (z_log_con_def(š, š))¨ ran defs © ô pre‰1}  À
Ü	     {i : 1 .. #defs· 
Ü		(z_log_con_def(š, š))¨ defs ¨1..i-1© © ô z_mem((defs i).E, (defs i).T)} ±
Ü	SIDE = add_hyps(map (z_log_con_def(w, w‰0)) defs, post %Longrightarrow% A)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Procedure Call (Initial Variables in Spec)} \label{wp-proc-call-ivars}

=DOC
val Ûproc_call_ivarsÝ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL
							-> RESULT  
=DESCRIBE
ÿÛPROC_CALL_IVARSÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call_Ivars; fp : Formal_Proc ·
Ü	st = proc_ivars pc ±
Ü	Ê Result =
Ü	wp (spec_ivars (proc_call_spec (pc, fp)), A, ÊWp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{The Function $wp$}\label{wp}

=DOC
val ÛwpÝ : STATEMENT * SEQUENT list * WP_ENV -> RESULT  
=DESCRIBE
¹Z
Ü   µPars·
Ü	wp (st, A, ÊWp_Env) = Ê Result ¤
Ü		NULL ² SIMPLE_ASSIGN ² ARRAY_ASSIGN ² RECORD_ASSIGN ²
Ü		SPEC_NO_IVARS ² SPEC_NO_IVARS_EMPTY ² SEMICOLON ²
Ü		IF_THEN_ELSE ² CASE_BASE ² CASE_STEP ² CASE_OTHERS ²
Ü		LOOP ² WHILE ² FOR_STATIC ² FOR_TMARK ²
Ü		EXIT_WHEN ² EXIT ² RETURN ²
Ü		PROC_CALL_NO_IVARS ² FOR_NON_STATIC ² SPEC_IVARS ²
Ü		LOG_CON ² PROC_CALL_IVARS
°
=FAILURE
505040	VCs cannot be generated for a k-slot statement
=ENDDOC

\section{ADJUSTING STATEMENTS}

=DOC
val Ûadjust_statementÝ : WP_ENV -> STATEMENT -> STATEMENT
=DESCRIBE
$adjust\_statement$ takes a statement (represented as abstract syntax) and transforms the data representation according to the following rules depending on the data constructor of the statement within the outermost $SStmt$.
{\raggedright
\begin{description}
\item[STSpecNoIVars]
If the statement is a specification statement then it checks if there are any initial variables used in the post-condition. If so the statement is converted to a $SpecIVars$. 
\item[STForStatic]
If the for-loop is non-static then the abstract syntax is converted to a $STForNonStatic$.
\item[STProcNoIvars]
If the procedure contains initial variables, then the statement is transformed into a SProcIvars.
\item[STSemicolon]
If the statement comprises a sequence of statements, then the tree of statements is traversed until the first actual statement is found, this is adjusted. 
\end{description}}

The function also makes the checks which detect the following error conditions
(corresponding to the new check 17.1.1.20, and the check implicit in
the predicate of the schema {\it Spec} in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}).
=FAILURE
505091	A specification statement containing initial variables may only
	appear as the first statement in a sequence of statements and may
	not be used as the body of a loop
505092	A for loop with non-static bounds may only
	appear as the first statement in a sequence of statements
505093	A call to a procedure whose specification statement contains initial
	variables may only appear as the first statement in a
	sequence of statements
505094	A logical constant statement may only appear as the first statement in a
	sequence of statements
505095	The pre-condition of a specification statement must not contain initial variables
=ENDDOC
=TEX
\pagebreak
\section{APPLICATION OF CHECKS}\label{APPLICATIONOFCHECKS}

In \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} various checks are specified. The checks appropriate to VC generation are carried out by the functions described below:

=DOC
val Ûchecking_errorÝ : string -> int -> (unit -> string) list -> unit
=DESCRIBE
This is the error handling function which is called when a violation of one of the checks is detected.
=FAILURE
505050	VC Soundness Check failed:
=ENDDOC

=DOC
val Ûcheck_1_aÝ : (ID list * SPECLAB) -> unit
=DESCRIBE
This implements check 17.1.1.1 (a)
=FAILURE
505060	Each variable whose value could be changed by a refinement step
	must appear (implicitly or explicitly) in the frame 
	of the specification statement being refined.
	This refinement step refines a specification statement with no
	variables in its frame but could change the value of ?0.
505064	Each variable whose value could be changed by a refinement step
	must appear (implicitly or explicitly) in the frame 
	of the specification statement being refined.
	This refinement step refines a specification statement with a frame
	comprising ?0 but could change the value of ?1.
505080	An invalid expression has been encountered on the left-hand side
	of an assignment or as an out or in out mode parameter
=ENDDOC

=DOC
val Ûcheck_1_bÝ : SPECLAB -> unit
=DESCRIBE
This implements check 17.1.1.1 (b)
=FAILURE
505061	A RETURN statement can only appear in the body of a function which
	has a formal specification.  
=ENDDOC

=DOC
val Ûcheck_1_cÝ : SPECLAB -> unit
=DESCRIBE
This implements check 17.1.1.1 (c)
=FAILURE
505062	An EXIT statement can only appear in a LOOP whose exit condition is
	expressed within a TILL clause.
=ENDDOC

=DOC
val Ûcheck_1_dÝ : (ID * SPECLAB) -> unit
=DESCRIBE
This implements check 17.1.1.1 (d)
=FAILURE
505063	For ?0: a procedure call can only appear if the procedure has a formal
	specification. 
=ENDDOC

=DOC
datatype ÛCHECK_STATEÝ = ÛCSTopÝ | ÛCSInLoopÝ | ÛCSInCaseÝ
		| ÛCSOKToExitÝ | ÛCSInIfThenElseÝ;
datatype ÛENDINGÝ = ÛEndsInReturnÝ | ÛEndsInOtherÝ;
=DESCRIBE
=ENDDOC

=DOC
val Ûcheck_3aÝ : (CHECK_STATE * STATEMENT) -> unit
=DESCRIBE
This implements check 17.1.1.3 (first part)
=FAILURE
505065	The closest-containing compound statement of an EXIT WHEN G
	statement must be a LOOP statement
505076	Internal error:  argument must be an EXIT WHEN statement
=ENDDOC

=DOC
val Ûcheck_3bÝ : (CHECK_STATE * STATEMENT) -> unit
=DESCRIBE
This implements check 17.1.1.3 (second part)
=FAILURE
505066	The closest-containing compound statement of an EXIT statement must be
	an IF statement with no ELSIF or ELSE parts; the closest-containing
	compound statement of this IF statement must be a loop and the EXIT
	statement must be the last statement inside the IF statement.
505077	Internal error:  argument must be an EXIT statement
=ENDDOC
=DOC
val Ûcheck_4aÝ : bool -> unit
=DESCRIBE
This implements check 17.1.1.4 (first part)
=FAILURE
505078	A RETURN statement is only allowed within the body of a function subprogram.
=ENDDOC

=DOC
val Ûcheck_4bÝ : (bool * ENDING) -> unit
=DESCRIBE
This implements check 17.1.1.4 (second part)
=FAILURE
505079	The last statement in the body of a function must be either a RETURN
	statement or a CASE statement whose alternatives all end with
	RETURN statement.
=ENDDOC

=DOC
val Ûcheck_19Ý : CN_ENV -> SPEC -> unit
=DESCRIBE
This implements check 17.1.1.16.
It also checks that the things in the frame are actually (program or auxiliary) variables
=FAILURE
505082	The variables in the frame of a specification statement must be in
	scope. ?0 is not in scope here.
505083	The names in the frame of a specification statement must be
	variables. ?0 is not a variable here.
=ENDDOC

\subsection{Anti-Aliasing Checks}
=DOC
val Ûfree_vars_zpredÝ : Z_PRED -> Z_ID list
val Ûfind_formal_procÝ : SPECLAB -> ID -> FORMAL_PROC
val Ûanti_aliasing_parsÝ : FORMAL_PROC -> (AGG_CHOICE,EXP) PROC_CALL ->
					ID list * ID list
val Ûanti_aliasing_actuals_modesÝ : CN_ENV -> FORMAL_PROC ->
		(AGG_CHOICE, EXP) PROC_CALL -> (EXP * MODE) list
=DESCRIBE
¹ZAX
Ü	free_vars_zpred : Z_PRED ­ ð Z_ID
°
ÿAnti_Aliasing_Parsüüüüüüüü
Ü	Formal_Proc;
Ü	Proc_Call;
Ü	formals : ð ID
÷üüüüüüüüüüüüü
Ü	formals = {par : ran formal_ids · par.var}
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505067	There is no specification statement for the procedure ?0
505068	The number of actuals provided does not match those in the declaration of ?0
=ENDDOC


=DOC
val Ûanti_aliasing_check_1Ý :
	FORMAL_PROC -> (AGG_CHOICE, EXP) PROC_CALL ->
	(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_1üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	(zid ¨ ran globals \ trans_id ¨ formals © © ) ¡
Ü	trans_exp¨{i : dom actuals | (formal_ids i).mode  {in_out, out}
Ü		· actuals i}© = š
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505070	In a procedure call each actual parameter of mode OUT or IN OUT must
	be a variable or be formed from a variable using array indexing
	and/or record component selection.
	Procedure ?0 has been passed an invalid actual parameter
505071	In a procedure call, a variable in the frame or global dependencies list
	of the procedure must not appear as the entire variable in an actual parameter
	of mode OUT or IN OUT.
	The variable?0 ?1 in a call of the procedure ?2 violated this rule
=ENDDOC

=DOC
val Ûvars_expÝ : CN_ENV -> EXP -> ID list
val Ûanti_aliasing_check_2Ý :
	SPECLAB -> FORMAL_PROC -> (AGG_CHOICE, EXP) PROC_CALL ->
	(EXP * MODE) list -> unit
=DESCRIBE
¹ZAX
Ü	vars_exp : EXP ­ ð ID
°
ÿAnti_Aliasing_Check_2üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	(w \ trans_id ¨ formals ©) ¡ trans_id ¨ Þ (vars_exp ¨ ran actuals © ) © = š
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505072	In a procedure call, a variable that appears in the frame of the
	procedure must not appear anywhere in the actual parameter list.
	The variable?0 ?1 in a call of the procedure ?2 violated this rule
=ENDDOC

=DOC
val Ûanti_aliasing_check_3Ý :
		SPECLAB -> FORMAL_PROC ->
		(AGG_CHOICE, EXP) PROC_CALL ->
		(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_3üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	µ i, j : dom actuals |
Ü	   i ½ j ± vars_exp (actuals i) ¡ vars_exp (actuals j) ½ š ·
Ü	(formal_ids i).mode = inn ± (formal_ids j).mode = inn
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505073	In a procedure call, the entire variable of an actual parameter
	of mode OUT or IN OUT must not occur anywhere else in the parameter list.
	The variable ?0 in a call of the procedure ?1 violated this rule
=ENDDOC

=DOC
val Ûanti_aliasing_checkÝ :
	CN_ENV -> (SPECLAB * (AGG_CHOICE,EXP)PROC_CALL) -> unit
=DESCRIBE
¹Z
Ü Anti_Aliasing_Check ¦
Ü   Anti_Aliasing_Check_1 ± Anti_Aliasing_Check_1 ±
Ü   Anti_Aliasing_Check_2 ± Anti_Aliasing_Check_3
°
This invokes each of the anti-aliasing checks 1 to 4.
It also invokes that part of check 1(a) concerned with procedure calls.
=FAILURE
505068	The number of actuals provided does not match those in the declaration of ?0
=ENDDOC

\subsection{Variable Capture Checks}

ÿID_ENVüüüüüüüüüüüüüüü
Ü	spark_ids : ð ID;
Ü	z_log_aux, z_attribs : ð Z_ID
ˆüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcheck_new_spark_idsÝ : CN_ENV -> ID list -> unit
=DESCRIBE
ÿNew_Spark_Idüüüüüüüüüüüüüüü
Ü	ID_ENV;
Ü	Id? : ID
÷üüüüüüüüüü
Ü	trans_id Id? Ž 
Ü		(trans_id ¨ spark_ids ©) À z_log_aux À z_attribs
ˆüüüüüüüüüüüüüüüüüüü
=FAILURE
505074	A declaration of ?0 has already been introduced
505075	Variable declaration contains repeated instances of the same name
=ENDDOC
=DOC
val Ûcheck_new_z_idÝ : Z_ID list -> Z_ID -> unit
=DESCRIBE
ÿNew_Z_Idüüüüüüüüüüüüüüü
Ü	ID_ENV;
Ü	z_id? : Z_ID
÷üüüüüüüüüü
Ü	z_id? Ž 
Ü		(trans_id ¨ spark_ids ©) À z_log_aux À z_attribs
ˆüüüüüüüüüüüüüüüüüüü
=FAILURE
505074	A declaration of ?0 has already been introduced
=ENDDOC

=DOC
val Ûdo_soundness_checks1Ý : SPECLAB * STATEMENT -> unit
=DESCRIBE
This function applies those soundness checks which can be called directly from the VC generator.
=ENDDOC

=DOC
val Ûdo_soundness_checks2Ý : (LABEL -> REPLACEMENT OPT)
				-> bool -> STATEMENT -> unit
=DESCRIBE
This function applies those soundness checks which should be called from the Spark Program Generator. It invokes checks which require information from the environments in ISS/HAT/DAZ/DTD507, and therefore cannot be called from the VC generator directly.

The second argument is a boolean function which should be set to true if the statement (argument 3) is part of a function subprogram.
=ENDDOC

\pagebreak
\section{VERIFICATION CONDITIONS}

=DOC
val Ûfun_sigÝ : (Z_EXP list * Z_EXP) -> Z_EXP;
val Ûpar_tmarkÝ : CN_ENV -> PARAM_SPEC -> Z_ID list;
val Ûvar_sigÝ : CN_ENV -> Z_ID -> Z_EXP;
val Ûfun_declÝ : CN_ENV -> FORMAL_FUN -> Z_DECL;
=DESCRIBE
The Z specifications of these functions can be found in ISS/HAT/DAZ/DTD507.
=FAILURE
505041	The global dependencies of a function must be variables: ?0
	is neither a program variable nor an auxiliary variable
=ENDDOC

=DOC
val Ûvc_local_declsÝ : SEQUENT list * SPECLAB -> VC list  
=DESCRIBE
¹ZAX
Ü	Ûvc_local_declsÝ : (ð Sequent ¸ Speclab) ­ ð VC
°
=ENDDOC

=DOC
val ÛvcsÝ : SPECLAB * STATEMENT -> VC list * SPEC
=DESCRIBE
¹ZAX
Ü	ÛvcsÝ : (Speclab ¸ Statement) ß ð VC
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ Speclab; st : Statement ·
Ü		¶ Result; WP‰1, s : ð Sequent ·
Ü			vcs (Ê Speclab, st) = vc_local_decls (s, Ê Speclab) ±
Ü			s = Pre %Longrightarrow% WP‰1 À subs_pred(Pre, w, w‰0) %Longrightarrow% SIDE ±
Ü			ÊResult = wp (st, {š ô post}, Ê Wp_Env) ±
Ü			WP‰1 =
Ü			{ Sequent | H ô c  WP · H ô subs_pred (c, w‰0, w)}
°
In addition to the list of VCs, the implementation also returns the specification
statement being refined with its pre- and post-condition type-checked.
This is used in \cite{ISS/HAT/DAZ/IMP507} when specification statements are
first processed so that pre- and post-conditions do not get type-checked
unnecessarily.
=ENDDOC

\section{STORAGE OF Z TERMS}
=DOC
(* Flag Ûcn_compactify_termsÝ - boolean control, default true *)
=DESCRIBE
The Compliance Tool has an feature which attempts to reduce the memory space
occupied by the Z terms stored in its internal data structures.
The feature is optional, but is enabled by default.
This feature can be disabled by
setting the flag {\it cn\_compactify\_terms} to {\it false} and
enabled by setting it to {\it true}.
=ENDDOC

=DOC
val Ûz_quoteÝ : TERM * Unification.EXTYPE OPT -> ZUserInterfaceSupport.Z_TM
=DESCRIBE
This function is logically equivalent to the constructor
function {\it ZTmQuotation}. It implements the feature for
reducing the space used for the Z terms in internal data structures
by optionally applying {\it compact\_term} to the term argument before
applying {\it ZTmQuotation}.
This optional feature can be enabled and disabled using the flag
{\it cn\_compactify\_terms}.
=ENDDOC


\section{EPILOGUE}

=SML
end (* local...in *);
end (* signature CNBasicDeclsAndExprs *);
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



