%  dtd505.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Verification Condition Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD505}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This document contains the detailed design for the Verification Condition Generator for the Compliance Tool.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	C.~O'Halloran, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.11] Initial Drafts.
\item[Issue 1.12 (26th September 1994)] Reworked according to desk check report 009.
\item[Issues 1.13-1.23] Bug fixing, added support for checks.
\item[Issue 1.24] Added new error message for $check\_1\_a$.
\item[Issue 1.25] Improved error messages for checks 1b, 1c and 1d.
\item[Issue 1.26] Changed signature of $check\_new\_z\_id$.

\end{description}
\subsection{Changes Forecast}
Various checks need to be implemented which are described in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}.

\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the Verification Condition (VC) Generator. The design is in response to the high level design for compliance notation processing \cite{ISS/HAT/DAZ/HLD503}.

The document provides a design which implements DRA's specification for VC Generation described in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

The VC generator is called by the Z document generator \cite{ISS/HAT/DAZ/IMP507} to generate VCs for inclusion into the generated Z document according to the algorithms specified in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}.

The Z of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2} is reproduced in this document (suitable for type-checking with {\Product}) adjacent to the signature declarations of the functions which implement the Z. The corresponding implementatation is in \cite{ISS/HAT/DAZ/IMP505}.

\subsection{Compliance}

This detailed design contains signatures for Standard ML functions with the Z specification of these functions, transcribed from \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}. The names of these functions corresponds to the names used in the Z, and where they differ, justification has been provided.

The implementation of this design can be found in \cite{ISS/HAT/DAZ/IMP505} where the style of coding is intended to make the compliance with the Z specification evident by a visual comparison.

In {\ProductZ}, subscripts are not decoration. In order to achieve the effect required by \cite[Volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}, multiple priming has been used and generally, the number of primes in a decoration corresponds to the numeric value of the subcript in \cite[Volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}.

The checks which have been implemented are introduced in section \ref{APPLICATIONOFCHECKS} and are listed in table \ref{ImplementedChecks}.

\begin{table}
\center
\begin{tabular}{||l|l||}\hline\hline
Volume 1: & 16.1.1: 1. (a), (b), (c) \& (d) \\
      & 16.1.1: 2. \\
      & 16.1.1: 3. \\
      & 16.1.1: 4. \\
      & 16.1.1: 12. \\ \hline
Volume 2: & 5.2 (aliasing) \& 5.3 (variable capture) \\
\hline\hline
\end{tabular}
\caption{Implemented Checks}\label{ImplementedChecks}
\end{table}



%\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}

\section{PREAMBLE FOR Z TYPE CHECKING}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd508";
push_pc "z_library";
force_delete_theory"dtd505" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
new_theory"dtd505";
=TEX

\section{THE SIGNATURE $CNVCGenerator$}

=DOC
signature ÛCNVCGeneratorİ = sig
local
	open CNTypes CNBasicDeclsAndExprs CNTypes1 CNTypes2;
in
=DESCRIBE
=FAILURE
505001	?0
=ENDDOC

\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}

This section implements section 2 of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}.

\subsection{Sequents}

=DOC
val Ûôİ : Z_PRED list * Z_PRED -> SEQUENT;
=DESCRIBE
¹Z
fun 3 _ ô _
°

¹ZAX
Ü	_ Ûôİ _ : (ğ Z_PRED ¸ Z_PRED) ­ Sequent
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ Sequent · H ô c = Ê Sequent
°
=ENDDOC

=DOC
val Û%Longrightarrow%İ : Z_PRED * SEQUENT list -> SEQUENT list;
=DESCRIBE
¹Z
fun 4 _ %Longrightarrow% _
°

¹ZAX
Ü	_ Û%Longrightarrow%İ _ : (Z_PRED ¸ ğ Sequent) ­ ğ Sequent
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ h : Z_PRED; S : ğ Sequent ·
Ü	h %Longrightarrow% S = { Sequent | H ô c  S · ({h} À H) ô c }
°
=ENDDOC

\subsection{Substitutions}

=DOC
val Ûsubİ : Z_PRED * Z_ID * Z_EXP -> Z_PRED;
=DESCRIBE
¹ZAX
Ü	sub : (Z_PRED ¸ Z_ID ¸ Z_EXP) ­ Z_PRED
°
=ENDDOC

=DOC
val Ûsubs_expİ : Z_EXP * Z_ID list * Z_ID list -> Z_EXP;
=DESCRIBE
¹ZAX
Ü	subs_exp : (Z_EXP ¸ ğ Z_ID ¸ ğ Z_ID) ß Z_EXP
°
=ENDDOC

=DOC
val Ûsubs_predİ : Z_PRED * Z_ID list * Z_ID list -> Z_PRED;
=DESCRIBE
¹ZAX
Ü	subs_pred : (Z_PRED ¸ ğ Z_ID ¸ ğ Z_ID) ß Z_PRED
°
=ENDDOC

=DOC
val Ûsubseqİ : SEQUENT list * Z_ID * Z_EXP -> SEQUENT list;
=DESCRIBE
¹ZAX
Ü	subseq : (ğ Sequent ¸ Z_ID ¸ Z_EXP) ­ ğ Sequent
÷üüüüüüüüüüüüüüü
Ü	µ S : ğ Sequent; x : Z_ID; E : Z_EXP ·
Ü	   subseq (S,x,E) =
Ü		{ Sequent | H ô c  S · { h : H · sub (h,x,E)} ô sub (c,x,E) }
°
=ENDDOC
=DOC
(* Flag Ûcn_use_let_in_vcsİ - boolean control, default false *)
=DESCRIBE
This flag controls the way substitution of expressions for variables is treated during VC generation.

If the flag is false (the default), then the substitution is carried out using the HOL $subst$ function and then conversions are used to transform the result into Z: this results in a Z term in which the variables have actually been replaced by their substitutes, and declarations and other constructs have been adjusted as necessary to avoid variable capture.

If the flag is set true (using $set\_flag$), then an HOL $let$ construct is used to give the semantics of substitution without actually replacing any variables with their substitutes.
The result is {\em not} Z, but may help to abbreviate the VC and make its structure clearer.
=ENDDOC

\section{WEAKEST PRECONDITIONS}
This section implements section 4 of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}.
Note that the design for the datatypes is in \cite{ISS/HAT/DAZ/DTD514}. The type $RESULT$ is defined in that document.

\subsection{Null Statement}\label{wp-null}
=DOC
val Ûnullİ : WP_PARS -> RESULT  
=DESCRIBE
ÿNULLüüüüüüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüüü
Ü	st = stmt null;
Ü	WP = A;
Ü	SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Assignment Statement}\label{wp-assignment}


=DOC
val Ûsimple_assignİ : WP_PARS -> ID -> Z_EXP -> RESULT  
=DESCRIBE
ÿSIMPLE_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü  ¶ Assign; x : ID ·
Ü	st = stmt(assign(Ê Assign)) ± name = Id x ±
Ü	WP = subseq(A, trans_id x, trans_exp E) ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûarray_assignİ : WP_PARS -> EXP INDEXED_COMP -> Z_EXP -> RESULT  
=DESCRIBE
ÿARRAY_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Assign; Indexed_Comp; Assign' ·
Ü		st = stmt(assign(Ê Assign)) ±
Ü		name = indexed_comp (Ê Indexed_Comp) ±
Ü		Ê Result = wp (stmt(assign(Ê Assign')), A, ÊWp_Env) ±
Ü		name' = prefix ±
Ü		E' =
Ü		auxiliary_exp
Ü		(z_override
Ü		   (trans_exp prefix, z_set {
Ü				z_maplet(trans_exp index, trans_exp E)} ))
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
val Ûretrieve_type_markİ  : CN_ENV -> EXP -> TMARK;
=DESCRIBE
¹ZAX
Ü	retrieve_type_mark : EXP ­ TMARK
°
=FAILURE
505028	There is no type mark for ?0
=ENDDOC

=DOC
val Ûrecord_assignİ : WP_PARS -> EXP SELECTED_COMP -> Z_EXP -> RESULT;  
=DESCRIBE

ÿRECORD_ASSIGNüüüüüüüü
Ü	Pars
÷üüüüü
Ü   ¶ Assign; Selected_Comp; Assign'; Record_Type_Def; Agg_Pos ·
Ü	st = stmt (assign(Ê Assign)) ±
Ü	name = selected_comp (Ê Selected_Comp) ±
Ü	Ê Result = wp (stmt (assign (Ê Assign')), A, ÊWp_Env) ±
Ü	name' = prefix ± E' = rec_agg_pos (Ê Agg_Pos) ±
Ü	tmark = retrieve_type_mark prefix ±
Ü	retrieve_type_def tmark = record_type_def (Ê Record_Type_Def) ±
Ü	comps = 
Ü	{ i : dom decl; Selected_Comp'; e : EXP |
Ü	  (decl i).var = selector ± e = E ²
Ü	  (decl i).var ½ selector ± e = selected_comp (Ê Selected_Comp') ±
Ü	  prefix' = prefix ± selector' = (decl i).var · i í e }
ˆüüüüüüüüüüüüüüüü
=FAILURE
505027	The type mark ?0 is not a record type
=ENDDOC


=DOC
val Ûassignİ : WP_PARS -> EXP * Z_EXP -> RESULT  
=DESCRIBE
$assign$ recognises the kind of assignment statement by looking at the LHS supplied as $EXP$, and calls the appropriate function, i.e., $simple\_assign$, $array\_assign$ or $record\_assign$, to generate the wp.
=FAILURE
505029	the lhs of the assignment statement is not an assignable identifier
=ENDDOC

\subsection{Specification Statement (No initial variables)} \label{wp-specification-no-ivars}

=DOC
val Ûspec_no_ivarsİ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
ÿSPEC_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = stmt (spec_no_ivars (Ê Spec_No_Ivars)) ± w ½ š ±
Ü	WP = { š ô Pre } ± SIDE = post %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûspec_no_ivars_emptyİ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
ÿSPEC_NO_IVARS_EMPTYüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = stmt (spec_no_ivars (Ê Spec_No_Ivars)) ± w = š ±
Ü	WP = { š ô Pre } À post %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûspec_no_ivars_eitherİ :
	WP_PARS -> Z_ID list -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
$spec\_no\_ivars\_either$ calls $spec\_no\_ivars\_empty$ or $spec\_no\_ivars$ depending on whether the frame is empty.
=ENDDOC

\subsection{Semicolon}\label{wp-semicolon}

=DOC
val Ûsemicolonİ : WP_PARS -> STMT * STMT -> RESULT  
=DESCRIBE
ÿResultsüüüüüüüüüüüü
Ü	Result';
Ü	Result''
ˆüüüüüüüüüüüüüüüüüüüüü
ÿSEMICOLONüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ P, Q : Stmt; Results ·
Ü	st = stmt (semicolon (P, Q)) ± WP = WP' ±
Ü	SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (stmt P, WP'', Ê Wp_Env) ±
Ü	Ê Result'' = wp (stmt Q, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{If Statement}\label{wp-if-then-else}


=DOC
val Ûif_then_elseİ : WP_PARS -> STMT IF_THEN_ELSE -> RESULT  
=DESCRIBE
¹ZAX
Ü	TRUE, FALSE : Z_ID
°
ÿIF_THEN_ELSEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ If_Then_Else; Results ·
Ü	st = stmt (if_then_else (Ê If_Then_Else)) ±
Ü	WP =
Ü	z_eq (trans_exp G, zid TRUE) %Longrightarrow% WP' À
Ü	z_eq (trans_exp G, zid FALSE) %Longrightarrow% WP'' ±
Ü			SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (stmt P, A, ÊWp_Env) ±
Ü	Ê Result'' = wp (stmt Q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Case Statement}\label{wp-case}


=DOC
val Ûtrans_case_choicesİ : CN_ENV -> CASE_CHOICE list -> Z_EXP  
=DESCRIBE
¹ZAX
Ü	trans_case_choices : ğ CASE_CHOICE ­ Z_EXP
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü µ choices : ğ CASE_CHOICE ·
Ü   ¶ zranges : ğ Z_EXP; zsingles : Z_EXP ·
Ü	zranges = 
Ü	{ Range | case_range (Ê Range)  choices ·
Ü		z_rng (trans_exp lo, trans_exp hi) } ±
Ü	zsingles =
Ü	z_set {ex : EXP | case_exp ex  choices · trans_exp ex } ±
Ü	trans_case_choices choices = z_many_union (zranges À {zsingles} )
°
=FAILURE
505020	Range attributes are not handled formally
=ENDDOC



=DOC
val Ûcase_baseİ : WP_PARS -> EXP -> STMT CASE_ALTERNATIVE -> RESULT  
=DESCRIBE
ÿCase_Baseüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Stmt]
÷üüüüüüüüüüüüüü
Ü	s = § Ê(Case_Alternative[Stmt]) ¢
ˆüüüüüüüüüüüüüüüüüüüüü
ÿCASE_BASEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Base; Result' ·
Ü	st = stmt (case (Ê Case)) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' ±
Ü	SIDE = SIDE' ± Ê Result' = wp (stmt P, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûcase_stepİ : WP_PARS -> STMT CASE -> RESULT  

=DESCRIBE
ÿCase_Stepüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Stmt];
Ü	Case'
÷üüüüüüüüüüüüüü
Ü	E = E';
Ü	s = § Ê(Case_Alternative[Stmt]) ¢ ë s'
ˆüüüüüüüüüüüüüüüüüüüüü
ÿCASE_STEPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Step; Results ·
Ü	st = stmt (case (Ê Case)) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' À WP'' ±
Ü	SIDE = SIDE' À SIDE'' ± Ê Result' = wp (stmt P, A, Ê Wp_Env) ±
Ü	Ê Result'' = wp (stmt (case (Ê Case')), A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505021	Others part of a case statement is not handled formally
505030	Internal error: case statement with no alternatives found
=ENDDOC


=DOC
val Ûcase_eitherİ : WP_PARS -> STMT CASE -> RESULT  
=DESCRIBE
$case\_either$ is analogous to $spec\_no\_ivars\_either$ in that it is sensitive to the input and processes either a case base or a case step. Note that $case\_step$ can in the implementation process either. Therefore this function is identical to $case\_step$.
=ENDDOC


\subsection{Undecorated Loop}\label{wp-loop}

$named\_loop$ below is required to handle named loops. Its semantics are the same as for $loop$.
=DOC
val Ûloopİ : WP_PARS -> STMT LOOP -> RESULT  
val Ûnamed_loopİ : WP_PARS -> STMT NAMED_LOOP -> RESULT  
=DESCRIBE
ÿLOOPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Loop ·
Ü	st = stmt (loop (Ê Loop)) ± WP = {š ô Pre} ±
Ü	SIDE = { {post} ô Pre } À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	Loop bodies other than a specification statements are not handled formally
=ENDDOC

\subsection{While Loop}\label{wp-while-loop}

$while$ is a reserved word in Standard ML; hence we use the name $cn\_while$.

=DOC
val Ûcn_whileİ : WP_PARS -> STMT WHILE -> RESULT  
=DESCRIBE
ÿWHILEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ While ·
Ü	st = stmt (while (Ê While)) ±
Ü	WP =
Ü	{ {z_eq(trans_exp G, zid TRUE)} ô Pre} À
Ü	z_eq(trans_exp G, zid FALSE) %Longrightarrow% A ±
Ü	SIDE = post %Longrightarrow% WP À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	Loop bodies other than a specification statements are not handled formally
=ENDDOC


=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-value}

=DOC
val Ûfor_staticİ : WP_PARS -> STMT FOR_STATIC -> RESULT  
=DESCRIBE
If the loop does not contain a $till$ predicate, then $T %Longrightarrow% A$ is removed from $SIDE$.

ÿFOR_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Static; Z_Bin_Exp; zi : Z_ID; zlo, zhi : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = stmt (for_static (Ê For_Static)) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (Pre, zi, zlo) } À
Ü		z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { zran, z_noteq(zid zi, zhi), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi) %Longrightarrow% A À
Ü		zran %Longrightarrow% (T %Longrightarrow% A) ±
Ü	zran = z_elem (zid zi, z_rng (zlo, zhi)) ±
Ü	zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü	zop = z_add ± zleft = zid zi ± zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505020	Range attributes are not handled formally
505022	Loop bodies other than a specification statements are not handled formally
505023	Reverse loops are not handled formally
=ENDDOC

\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}


=DOC
val Ûfor_tmarkİ : WP_PARS -> STMT FOR_TMARK -> RESULT  
=DESCRIBE
ÿFOR_TMARKüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Tmark; Z_Bin_Exp; zi : Z_ID; zlo, zhi : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = stmt (for_tmark (Ê For_Tmark)) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (Pre, zi, zlo) } À
Ü	z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { z_noteq(zid zi, zhi), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi) %Longrightarrow% A À
Ü	T %Longrightarrow% A ± zi = trans_id i ± zlo = zid (trans_id tmark ^ zfst) ±
Ü	zhi = zid (trans_id tmark ^ zlst) ± zop = z_add ± zleft = zid zi ±
Ü	zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	Loop bodies other than a specification statements are not handled formally
505023	Reverse loops are not handled formally
=ENDDOC

\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}



=DOC
val Ûexit_whenİ : WP_PARS -> EXIT_WHEN -> RESULT  
=DESCRIBE
ÿEXIT_WHENüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Exit_When ·
Ü	st = stmt (exit_when (Ê Exit_When)) ±
Ü	WP =
Ü	{ { z_eq (trans_exp G, zid TRUE) } ô till} À
Ü	z_eq (trans_exp G, zid FALSE)  %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Exit Statement}\label{wp-exit}

$exit$ is already bound in {\Product}; hence we use $cn\_exit$.
=DOC
val Ûcn_exitİ : WP_PARS -> RESULT  
=DESCRIBE
ÿEXITüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	st = stmt exit;
Ü	WP = { š ô till };
Ü	SIDE= š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Return Statement}\label{wp-return}

$return$ is already bound in {\Product}; hence we use $cn\_return$.
=DOC
val Ûcn_returnİ : WP_PARS -> RETURN -> RESULT  
=DESCRIBE
ÿRETURNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Return; Z_Fun_Call; Informal_Fun ·
Ü	st = stmt (ret (Ê Return)) ±
Ü	WP = { { z_eq (z_fun_call (Ê Z_Fun_Call), trans_exp E) } ô return } ±
Ü	SIDE = š ± fun_header = Ê Informal_Fun ±
Ü	zfun = zid (trans_id name) ±
Ü	zargs = { i : dom formal_pars · i ízid (trans_id (formal_pars i).var) }
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Procedure Call (No Initial Variables in Spec)} \label{wp-proc-call-no-ivars}


=DOC
val Ûproc_call_specİ : CN_ENV -> (AGG_CHOICE, EXP) PROC_CALL ->
					FORMAL_PROC -> Z_EXP * Z_EXP  
=DESCRIBE
¹ZAX
Ü	proc_call_spec : (Proc_Call ¸ Formal_Proc) ß Spec
°
=FAILURE
505026	Call to ?0 does not match its declaration
=ENDDOC

=DOC
val Ûproc_call_no_ivarsİ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL
							-> RESULT  
=DESCRIBE
ÿPROC_CALL_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call; fp : Formal_Proc ·
Ü	st = stmt (proc_no_ivars pc) ±
Ü	Ê Result =
Ü	wp (stmt (spec_no_ivars (proc_call_spec (pc, fp))), A, Ê Wp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505031	Procedure ?0 has not been declared
=ENDDOC

\subsection{Specification (With Initial Variables)}\label{wp-spec-ivars}

=DOC
val Ûspec_ivarsİ : WP_PARS -> (Z_EXP * Z_EXP) * STMT -> RESULT  
=DESCRIBE
ÿSPEC_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_Ivars; q : Stmt; Result' ·
Ü	st = spec_ivars (Ê Spec_Ivars, q) ± WP = {š ô Pre} ±
Ü	SIDE = post %Longrightarrow% WP' À SIDE' ±
Ü	Ê Result' = wp (stmt q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}

=DOC
val Ûfor_non_staticİ : WP_PARS -> FOR_NON_STATIC * STMT -> RESULT  
=DESCRIBE
ÿFOR_NON_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Non_Static; Z_Bin_Exp; q : Stmt; Result'; zi : Z_ID;
Ü	zlo, zhi, zlo‰0, zhi‰0 : Z_EXP; zran : Z_PRED ·
Ü		st = for_non_static (Ê For_Non_Static, q) ±
Ü		WP =
Ü		{ {z_less_eq (zlo, zhi)} ô  sub (Pre, zi, zlo)} À
Ü		z_greater (zlo, zhi) %Longrightarrow% WP' ±
Ü		SIDE =
Ü		{ { zran, z_noteq (zid zi, zhi‰0), post} ô
Ü			sub (Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi‰0) %Longrightarrow% WP' À zran %Longrightarrow% (T %Longrightarrow% A) À
Ü		SIDE' ± ÊResult' = wp(stmt q, A, ÊWp_Env) ±
Ü		zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü		zop = z_add ± zleft = zid zi ± zright = z_num 1 ±
Ü		zlo‰0 = subs_exp (zlo, w, w‰0) ±
Ü		zhi‰0 = subs_exp (zhi, w, w‰0) ±
Ü		zran = z_elem (zid zi, z_rng (zlo‰0, zhi‰0))
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505020	Range attributes are not handled formally
505022	Loop bodies other than a specification statements are not handled formally
=ENDDOC

\subsection{Logical Constant}\label{wp-log-con}


=DOC
val Ûanalyse_log_conİ : Z_PRED -> Z_EXP * Z_PRED  
=DESCRIBE
$analyse\_log\_con$ breaks down a precondition associated with a logical constant specification statement and returns the constituent parts.
It takes an expression of the form $c = E ± pre1$ and yields an expression containing $E$ and a predicate containing $pre1$.
=USES
It is used by the $log\_con$ function in the process of generating VCs for logical constants. 
=FAILURE
505024	Logical constant not of form CON c : t · „ w [c = E ± pre1, post]
=ENDDOC

=DOC
val Ûlog_conİ : WP_PARS -> LOG_CON * STMT -> RESULT  
=DESCRIBE
ÿÛLOG_CONİüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Log_Con; q : Stmt; Result' ·
Ü	st = log_con (Ê Log_Con, q) ± WP = {š ô sub(pre‰1, X, E)} ±
Ü	SIDE =
Ü	z_eq(zid X, subs_exp(E, w, w‰0)) %Longrightarrow% (post %Longrightarrow% WP') À SIDE' ±
Ü	Ê Result' = wp (stmt q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Procedure Call (Initial Variables in Spec)} \label{wp-proc-call-ivars}

=DOC
val Ûproc_call_ivarsİ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL * STMT
							-> RESULT  
=DESCRIBE
ÿÛPROC_CALL_IVARSİüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call_Ivars; q : Stmt; fp : Formal_Proc ·
Ü	st = proc_ivars(pc, q) ±
Ü	Ê Result =
Ü	wp (spec_ivars (proc_call_spec (pc, fp), q), A, ÊWp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{The Function $wp$}\label{wp}

=DOC
val Ûwpİ : STATEMENT * SEQUENT list * WP_ENV -> RESULT  
=DESCRIBE
¹Z
Ü   µPars·
Ü	wp (st, A, ÊWp_Env) = Ê Result ¤
Ü		NULL ² SIMPLE_ASSIGN ² ARRAY_ASSIGN ² RECORD_ASSIGN ²
Ü		SPEC_NO_IVARS ² SPEC_NO_IVARS_EMPTY ² SEMICOLON ²
Ü		IF_THEN_ELSE ² CASE_BASE ² CASE_STEP ² LOOP ² WHILE ²
Ü		FOR_STATIC ² FOR_TMARK ² EXIT_WHEN ² EXIT ² RETURN ²
Ü		PROC_CALL_NO_IVARS ² FOR_NON_STATIC ² SPEC_IVARS ²
Ü		LOG_CON ² PROC_CALL_IVARS
°
=ENDDOC

\section{ADJUSTING STATEMENTS}

=DOC
val Ûadjust_statementİ : WP_ENV -> STATEMENT -> STATEMENT
=DESCRIBE
$adjust\_statement$ takes a statement (represented as abstract syntax) and transforms the data representation according to the following rules depending on the data constructor of the statement within the outermost $SStmt$.
\begin{description}
\item[STSpecNoIVars]
If the statement is a specification statement then it checks if there are any initial variables used in the post-condition. If so the statement is converted to a $SpecIVars$. 
\item[STForStatic]
If the for-loop is non-static then the abstract syntax is converted to a $STForNonStatic$.
\item[STProcNoIvars]
If the procedure contains initial variables, then the statement is transformed into a SProcIvars.
\item[STSemicolon]
If the statement comprises a sequence of statements, then the tree of statements is traversed until the first actual statement is found, this is adjusted. 
\end{description} 
=ENDDOC


=TEX
\pagebreak
\section{APPLICATION OF CHECKS}\label{APPLICATIONOFCHECKS}

In \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.2} various checks are specified. The checks appropriate to VC generation are carried out by the functions described below:

=DOC
val Ûchecking_errorİ : string -> int -> (unit -> string) list -> unit
=DESCRIBE
This is the error handling function which is called when a violation of one of the checks is detected.
=FAILURE
505050 VC Soundness Check failed:
=ENDDOC

=DOC
val Ûcheck_1_aİ : (ID list * SPECLAB) -> unit
=DESCRIBE
This implements check 16.1.1.1 (a)
=FAILURE
505060	Each variable whose value may be changed by a refinement step
	must appear (implicitly or explicitly) in the frame 
	of the specification statement being refined.
	This refinement step refines a specification statement with no
	variables in its frame but may change the value of ?0.
505064	Each variable whose value may be changed by a refinement step
	must appear (implicitly or explicitly) in the frame 
	of the specification statement being refined.
	This refinement step refines a specification statement with a frame
	comprising ?0 but may change the value of ?1.
505080	An unrecognised form of a variable has been encountered 
=ENDDOC

=DOC
val Ûcheck_1_bİ : SPECLAB -> unit
=DESCRIBE
This implements check 16.1.1.1 (b)
=FAILURE
505061	A RETURN statement can only appear in the body of a function which
	has a formal specification.  
=ENDDOC

=DOC
val Ûcheck_1_cİ : SPECLAB -> unit
=DESCRIBE
This implements check 16.1.1.1 (c)
=FAILURE
505062	An EXIT statement can only appear in a LOOP whose exit condition is
	expressed within a TILL clause.
=ENDDOC

=DOC
val Ûcheck_1_dİ : (ID * SPECLAB) -> unit
=DESCRIBE
This implements check 16.1.1.1 (d)
=FAILURE
505063	A procedure call can only appear if the procedure has a formal
	specification. 
=ENDDOC

=DOC
datatype ÛCHECK_STATEİ = ÛCSTopİ | ÛCSInLoopİ | ÛCSInCaseİ
		| ÛCSOKToExitİ | ÛCSInIfThenElseİ;
datatype ÛENDINGİ = ÛEndsInReturnİ | ÛEndsInOtherİ;
=DESCRIBE
=ENDDOC

=DOC
val Ûcheck_3aİ : (CHECK_STATE * STMT) -> unit
=DESCRIBE
This implements check 16.1.1.3 (first part)
=FAILURE
505065	The closest-containing compound statement of an EXIT WHEN G statement must be a LOOP statement
505076	Internal error:  argument must be an EXIT WHEN statement
=ENDDOC

=DOC
val Ûcheck_3bİ : (CHECK_STATE * STMT) -> unit
=DESCRIBE
This implements check 16.1.1.3 (second part)
=FAILURE
505066	The closest-containing compound statement of an EXIT statement must be
	an IF statement with no ELSIF or ELSE parts; the closest-containing
	compound statement of this IF statement must be a loop and the EXIT
	statement must be the last statement inside tje IF statement.
505077	Internal error:  argument must be an EXIT statement
=ENDDOC
=DOC
val Ûcheck_4aİ : bool -> unit
=DESCRIBE
This implements check 16.1.1.4 (first part)
=FAILURE
505078	A RETURN statement is only allowed within the body of a function subprogram.
=ENDDOC

=DOC
val Ûcheck_4bİ : (bool * ENDING) -> unit
=DESCRIBE
This implements check 16.1.1.4 (second part)
=FAILURE
505079	The last statement in the body of a function must be either a RETURN
	statement or a CASE statement whose alternatives all end with
	RETURN statement.
=ENDDOC

\subsection{Anti-Aliasing Checks}
=DOC
val Ûfree_vars_zpredİ : Z_PRED -> Z_ID list
val Ûfind_formal_procİ : SPECLAB -> ID -> FORMAL_PROC
val Ûanti_aliasing_parsİ : FORMAL_PROC -> (AGG_CHOICE,EXP) PROC_CALL ->
					ID list * ID list
val Ûanti_aliasing_actuals_modesİ : SPECLAB -> (AGG_CHOICE, EXP) PROC_CALL -> (EXP * MODE) list
=DESCRIBE
¹ZAX
Ü	free_vars_zpred : Z_PRED ­ ğ Z_ID
°
ÿAnti_Aliasing_Parsüüüüüüüü
Ü	Formal_Proc;
Ü	Proc_Call;
Ü	formals, globals : ğ ID
÷üüüüüüüüüüüüü
Ü	formals = {par : ran formal_ids · par.var};
Ü	trans_id ¨ globals © =
Ü	free_vars_zpred Pre À free_vars_zpred post \
Ü			(trans_id ¨ formals © )
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505067	There is no specification statement for the procedure ?0
505068	The number of actuals provided does not match those in the declaration of ?0
=ENDDOC

=DOC
val Ûanti_aliasing_check_1İ : (AGG_CHOICE, EXP) PROC_CALL ->
				(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_1üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	{i : dom actuals | (formal_ids i).mode  {in_out, out}
Ü		· actuals i} € ran Id
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505069	In a procedure call, each actual parameter of mode OUT
	or IN OUT must be an entire variable (i.e., a name).
	A parameter to ?0 violated this rule.
=ENDDOC

=DOC
val Ûanti_aliasing_check_2İ : SPECLAB -> (AGG_CHOICE, EXP) PROC_CALL ->
				(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_2üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	(Id ¨ globals © ) ¡
Ü	{i : dom actuals | (formal_ids i).mode  {in_out, out}
Ü		· actuals i} = š
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505070	Actual parameter to ?0 is not an entire variable
505071 In a procedure call, no actual parameter of mode OUT or IN OUT
	may contain a variable used in the global definition of
	the procedure.
	The following parameter?0 of ?1 violated this rule: ?2
=ENDDOC

=DOC
val Ûvars_expİ : CN_ENV -> EXP -> ID list
val Ûanti_aliasing_check_3İ : SPECLAB -> (AGG_CHOICE, EXP) PROC_CALL ->
				(EXP * MODE) list -> unit
=DESCRIBE
¹ZAX
Ü	vars_exp : EXP ­ ğ ID
°
ÿAnti_Aliasing_Check_3üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	(trans_id ¨ globals © ) ¡ w ¡
Ü	(trans_id ¨ Ş (vars_exp ¨ ran actuals © ) © ) = š
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505072	In a procedure call, no variable occurring in the actual parameters
	may appear exported in the global definition of the procedure.
	The following parameter?0 of ?1 violated this rule: ?2
=ENDDOC

=DOC
val Ûanti_aliasing_check_4İ : SPECLAB -> (AGG_CHOICE, EXP) PROC_CALL ->
				(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_4üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	µ i, j : dom actuals |
Ü	   i ½ j ± vars_exp (actuals i) ¡ vars_exp (actuals j) ½ š ·
Ü	(formal_ids i).mode = inn ± (formal_ids j).mode = inn
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505073	In a procedure call, a variable appearing as an actual parameter
	of mode OUT or IN OUT may not occur in some other actual parameter.
	The following parameter?0 of ?1 violated this rule: ?2
=ENDDOC

=DOC
val Ûanti_aliasing_checkİ : (SPECLAB * (AGG_CHOICE,EXP)PROC_CALL) -> unit
=DESCRIBE
¹Z
Ü Anti_Aliasing_Check ¦
Ü   Anti_Aliasing_Check_1 ± Anti_Aliasing_Check_2 ±
Ü   Anti_Aliasing_Check_3 ± Anti_Aliasing_Check_4
°
This implements the intersection of the anti-aliasing checks 1 to 4.
=FAILURE
505068	The number of actuals provided does not match those in the declaration of ?0
=ENDDOC

\subsection{Variable Capture Checks}

ÿID_ENVüüüüüüüüüüüüüüü
Ü	spark_ids : ğ ID;
Ü	z_log_aux, z_attribs : ğ Z_ID
ˆüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcheck_new_spark_idsİ : CN_ENV -> ID list -> unit
=DESCRIBE
ÿNew_Spark_Idüüüüüüüüüüüüüüü
Ü	ID_ENV;
Ü	Id? : ID
÷üüüüüüüüüü
Ü	trans_id Id?  
Ü		(trans_id ¨ spark_ids ©) À z_log_aux À z_attribs
ˆüüüüüüüüüüüüüüüüüüü
=FAILURE
505074	A declaration of ?0 has already been introduced
505075	Variable declaration contains repeated instances of the same name
=ENDDOC
=DOC
val Ûcheck_new_z_idİ : Z_ID list -> Z_ID -> unit
=DESCRIBE
ÿNew_Z_Idüüüüüüüüüüüüüüü
Ü	ID_ENV;
Ü	z_id? : Z_ID
÷üüüüüüüüüü
Ü	z_id?  
Ü		(trans_id ¨ spark_ids ©) À z_log_aux À z_attribs
ˆüüüüüüüüüüüüüüüüüüü
=FAILURE
505074	A declaration of ?0 has already been introduced
=ENDDOC

=DOC
val Ûdo_soundness_checks1İ : SPECLAB * STATEMENT -> unit
=DESCRIBE
This function applies those soundness checks which can be called directly from the VC generator.
=ENDDOC

=DOC
val Ûdo_soundness_checks2İ : (LABEL -> REPLACEMENT OPT)
				-> bool -> STATEMENT -> unit
=DESCRIBE
This function applies those soundness checks which should be called from the Spark Program Generator. It invokes checks which require information from the environments in ISS/HAT/DAZ/DTD507, and therefore cannot be called from the VC generator directly.

The second argument is a boolean function which should be set to true if the statement (argument 3) is part of a function subprogram.
=ENDDOC

\pagebreak
\section{VERIFICATION CONDITIONS}

=DOC
val Ûcart_prodİ : CN_ENV -> PARAM_SPEC list -> Z_EXP;
=DESCRIBE
The Z specification of this function can be found in ISS/HAT/DAZ/DTD507.
=FAILURE
505009	Internal error: unexpected nil argument
=ENDDOC

=DOC
val Ûfun_declİ : CN_ENV -> INFORMAL_FUN -> Z_DECL;
=DESCRIBE
This Z specification of this function can be found in ISS/HAT/DAZ/DTD507.
=ENDDOC

=DOC
val Ûvc_local_declsİ : SEQUENT list * SPECLAB -> VC list  
=DESCRIBE
¹ZAX
Ü	Ûvc_local_declsİ : (ğ Sequent ¸ Speclab) ­ ğ VC
°
=ENDDOC

=DOC
val Ûvcsİ : SPECLAB * STATEMENT -> VC list
=DESCRIBE
¹ZAX
Ü	Ûvcsİ : (Speclab ¸ Statement) ß ğ VC
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ Speclab; st : Statement ·
Ü		¶ Result; WP‰1, s : ğ Sequent ·
Ü			vcs (Ê Speclab, st) = vc_local_decls (s, Ê Speclab) ±
Ü			s = Pre %Longrightarrow% WP‰1 À subs_pred(Pre, w, w‰0) %Longrightarrow% SIDE ±
Ü			ÊResult = wp (st, {š ô post}, Ê Wp_Env) ±
Ü			WP‰1 =
Ü			{ Sequent | H ô c  WP · H ô subs_pred (c, w‰0, w)}
°
=ENDDOC

\section{EPILOGUE}

=SML
end (* local...in *);
end (* signature CNBasicDeclsAndExprs *);
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



