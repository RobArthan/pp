%  %Z% $Revision: 1.53 $ $RCSfile: dtd505.doc,v $ $Date: 2000/06/02 10:41:43 $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Verification Condition Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD505}  %% Mandatory field
\def\SCCSversion{$Revision: 1.53 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/06/02 10:41:43 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{This document contains the detailed design for the Verification Condition Generator for the Compliance Tool.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.11] Initial Drafts.
\item[Issue 1.12 (26th September 1994)] Reworked according to desk check report 009.
\item[Issues 1.13-1.23] Bug fixing, added support for checks.
\item[Issue 1.24] Added new error message for $check\_1\_a$.
\item[Issue 1.25] Improved error messages for checks 1b, 1c and 1d.
\item[Issue 1.26] Changed signature of $check\_new\_z\_id$.
\item[Issue 1.26] Changed signature of $check\_new\_z\_id$.
\item[Issue 1.27-1.29] Batch 1 bug fixing.
\item[Issue 1.30] Enhancements 13 and 14.
\item[Issue 1.31,1.32] Bug fixing (batch 2 bug 13); also improved wording of many error messages.
\item[Issue 1.33] Corrected spelling mistake in error message.
\item[Issue 1.34] Fixed DRA bug 15 (V0.6).
\item[Issue 1.36-1.37] Fixing $analyse\_log\_con$.
\item[Issue 1.38] Improved message 505063.
\item[Issue 1.39] IUCT WP 4 changes.
\item[Issue 1.40] Corrected Z syntax and type errors.
\item[Issue 1.41] Slight improvement to error message 505080.
\item[Issue 1.42] Check 1(a) now applies to procedure calls to. This changes
the signature and description of some of the checks.
\item[Issue 1.43] Added new check 16.
\item[Issue 1.44] Updated references.
\item[Issue 1.45] Tidying.
\item[Issue 1.46,1.47] Update for SML97. Fixed broken error messages.
\item[Issue 1.48]
Trialling enhancement ref. R5 from \cite{LEMMA1/DAZ/HLD506}
At this version only the Z and a few of the ML types have been changed.
The main ML changes will come later.
\item[Issue 1.49] Trialling remaining enhancements from \cite{LEMMA1/DAZ/HLD506}.
\item[Issue 1.50] Prototyping enhancement R5 --- Initial Variables in Conditionals.
\item[Issue 1.51] Typechecking corrected approach to enhancement R2 --- Multiple Logical Constant Definitions.
\item[Issue 1.52] Typechecking new approach to enhancement R3 --- Assignment to Record Components.
\item[Issue 1.53] Prototyping enhancement R2 --- Multiple Logical Constant Definitions
(adjusted error messages for new syntax).
\end{description}
\subsection{Changes Forecast}
Various checks need to be implemented which are described in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.

\section{GENERAL}
\subsection{Scope}

This document contains the detailed design for the Verification Condition (VC) Generator. The design is in response to the high level design for compliance notation processing \cite{ISS/HAT/DAZ/HLD503}.

The document provides a design which implements DRA's specification for VC Generation described in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

The VC generator is called by the Z document generator \cite{ISS/HAT/DAZ/IMP507} to generate VCs for inclusion into the generated Z document according to the algorithms specified in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

The Z of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0} is reproduced in this document (suitable for type-checking with {\Product}) adjacent to the signature declarations of the functions which implement the Z. The corresponding implementatation is in \cite{ISS/HAT/DAZ/IMP505}.

\subsection{Compliance}

This detailed design contains signatures for Standard ML functions with the Z specification of these functions, transcribed from \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}. The names of these functions corresponds to the names used in the Z, and where they differ, justification has been provided.

The implementation of this design can be found in \cite{ISS/HAT/DAZ/IMP505} where the style of coding is intended to make the compliance with the Z specification evident by a visual comparison.

In {\ProductZ}, subscripts are not decoration. In order to achieve the effect required by \cite[Volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}, multiple priming has been used and generally, the number of primes in a decoration corresponds to the numeric value of the subcript in \cite[Volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

The checks which have been implemented are introduced in section \ref{APPLICATIONOFCHECKS} and are listed in table \ref{ImplementedChecks}.

\begin{table}
\center
\begin{tabular}{||l|l||}\hline\hline
Volume 1: & 17.1.1: 1. (a), (b), (c) \& (d) \\
      & 17.1.1: 2. \\
      & 17.1.1: 3. \\
      & 17.1.1: 4. \\
      & 17.1.1: 12. \\
      & 17.1.1: 16. \\ \hline
Volume 2: & 5.2 (aliasing) \& 5.3 (variable capture) \\
\hline\hline
\end{tabular}
\caption{Implemented Checks}\label{ImplementedChecks}
\end{table}



%\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}

\section{PREAMBLE FOR Z TYPE CHECKING}

The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"dtd508";
push_pc "z_library";
force_delete_theory"dtd505" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory"dtd505";
=TEX

\section{THE SIGNATURE $CNVCGenerator$}

=DOC
local
	open CNTypes CNBasicDeclsAndExprs CNTypes1 CNTypes2;
in
signature ÛCNVCGeneratorİ = sig
=DESCRIBE
=FAILURE
505001	?0
=ENDDOC

\section{STRUCTURE OF VERIFICATION CONDITIONS}\label{VCSTRUCTURE}

This section implements section 2 of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

\subsection{Sequents}

=DOC
val Ûôİ : Z_PRED list * Z_PRED -> SEQUENT;
=DESCRIBE
¹Z
fun 3 _ ô _
°

¹ZAX
Ü	_ Ûôİ _ : (ğ Z_PRED ¸ Z_PRED) ­ Sequent
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ Sequent · H ô c = Ê Sequent
°
=ENDDOC

=DOC
val Û%Longrightarrow%İ : Z_PRED * SEQUENT list -> SEQUENT list;
=DESCRIBE
¹Z
fun 4 _ %Longrightarrow% _
°

¹ZAX
Ü	_ Û%Longrightarrow%İ _ : (Z_PRED ¸ ğ Sequent) ­ ğ Sequent
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ h : Z_PRED; S : ğ Sequent ·
Ü	h %Longrightarrow% S = { Sequent | H ô c  S · ({h} À H) ô c }
°
=ENDDOC

\subsection{Substitutions}

=DOC
val Ûsubİ : Z_PRED * Z_ID * Z_EXP -> Z_PRED;
=DESCRIBE
¹ZAX
Ü	sub : (Z_PRED ¸ Z_ID ¸ Z_EXP) ­ Z_PRED
°
=ENDDOC

=DOC
val Ûsubs_expİ : Z_EXP * Z_ID list * Z_ID list -> Z_EXP;
=DESCRIBE
¹ZAX
Ü	subs_exp : (Z_EXP ¸ ğ Z_ID ¸ ğ Z_ID) ß Z_EXP
°
=ENDDOC

=DOC
val Ûsubs_predİ : Z_PRED * Z_ID list * Z_ID list -> Z_PRED;
=DESCRIBE
¹ZAX
Ü	subs_pred : (Z_PRED ¸ ğ Z_ID ¸ ğ Z_ID) ß Z_PRED
°
=ENDDOC

=DOC
val Ûsubseqİ : SEQUENT list * Z_ID * Z_EXP -> SEQUENT list;
=DESCRIBE
¹ZAX
Ü	subseq : (ğ Sequent ¸ Z_ID ¸ Z_EXP) ­ ğ Sequent
÷üüüüüüüüüüüüüüü
Ü	µ S : ğ Sequent; x : Z_ID; E : Z_EXP ·
Ü	   subseq (S,x,E) =
Ü		{ Sequent | H ô c  S · { h : H · sub (h,x,E)} ô sub (c,x,E) }
°
=ENDDOC
=DOC
(* Flag Ûcn_use_let_in_vcsİ - boolean control, default false *)
=DESCRIBE
This flag controls the way substitution of expressions for variables is treated during VC generation.

If the flag is false (the default), then the substitution is carried out using the HOL $subst$ function and then conversions are used to transform the result into Z: this results in a Z term in which the variables have actually been replaced by their substitutes, and declarations and other constructs have been adjusted as necessary to avoid variable capture.

If the flag is set true (using $set\_flag$), then an HOL $let$ construct is used to give the semantics of substitution without actually replacing any variables with their substitutes.
The result is {\em not} Z, but may help to abbreviate the VC and make its structure clearer.
=ENDDOC

\section{WEAKEST PRECONDITIONS}
This section implements section 4 of \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.
Note that the design for the datatypes is in \cite{ISS/HAT/DAZ/DTD514}. The type $RESULT$ is defined in that document.

\subsection{Null Statement}\label{wp-null}
=DOC
val Ûnullİ : WP_PARS -> RESULT  
=DESCRIBE
ÿNULLüüüüüüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüüü
Ü	st = null;
Ü	WP = A;
Ü	SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Assignment Statement}\label{wp-assignment}


=DOC
val Ûsimple_assignİ : WP_PARS -> ID -> Z_EXP -> RESULT  
=DESCRIBE
ÿSIMPLE_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü  ¶ Assign; x : ID ·
Ü	st = assign(Ê Assign) ± name = Id x ±
Ü	WP = subseq(A, trans_id x, trans_exp E) ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûarray_assignİ : WP_PARS -> EXP INDEXED_COMP -> Z_EXP -> RESULT  
=DESCRIBE
ÿARRAY_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Assign; Indexed_Comp; Assign' ·
Ü		st = assign(Ê Assign) ±
Ü		name = indexed_comp (Ê Indexed_Comp) ±
Ü		Ê Result = wp (assign(Ê Assign'), A, ÊWp_Env) ±
Ü		name' = prefix ±
Ü		E' =
Ü		auxiliary_exp
Ü		(z_override
Ü		   (trans_exp prefix, z_set {
Ü				z_maplet(z_tuple(map trans_exp index), trans_exp E)} ))
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
val Ûtmark_of_prefixİ : CN_ENV -> Z_EXP -> TMARK;
val Ûz_record_updateİ : TMARK * ID * Z_EXP * Z_EXP -> Z_EXP;
=DESCRIBE
¹ZAX
Ü tmark_of_prefix : Z_EXP ß TMARK
°

¹ZAX
Ü z_record_update : TMARK ¸ ID ¸ Z_EXP ¸ Z_EXP ­ Z_EXP
°
=FAILURE
505028	Type error on left-hand side of assignment statement
=ENDDOC


=DOC
val Ûrecord_assignİ : WP_PARS -> EXP SELECTED_COMP -> Z_EXP -> RESULT;  
=DESCRIBE
ÿRECORD_ASSIGNüüüüüüüü
Ü	Pars
÷üüüüü
Ü   ¶ Assign; Selected_Comp; Assign'; zprefix : Z_EXP ·
Ü	st = assign(Ê Assign) ±
Ü	name = selected_comp (Ê Selected_Comp) ±
Ü	Ê Result = wp (assign (Ê Assign'), A, ÊWp_Env) ±
Ü	name' = prefix ±
Ü	zprefix = trans_exp prefix ±
Ü	E' = auxiliary_exp(z_record_update(tmark_of_prefix zprefix, selector,
Ü		zprefix, trans_exp E))
ˆüüüüüüüüüüüüüüüü
=FAILURE
505027	The operand of the component selection is not a record
=ENDDOC

=DOC
val Ûassignİ : WP_PARS -> EXP * Z_EXP -> RESULT  
=DESCRIBE
$assign$ recognises the kind of assignment statement by looking at the LHS supplied as $EXP$, and calls the appropriate function, i.e., $simple\_assign$, $array\_assign$ or $record\_assign$, to generate the wp.
=FAILURE
505029	the lhs of the assignment statement is not an assignable identifier
=ENDDOC

\subsection{Specification Statement (No initial variables)} \label{wp-specification-no-ivars}

=DOC
val Ûspec_no_ivarsİ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
ÿSPEC_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = spec_no_ivars (Ê Spec_No_Ivars) ± w ½ š ±
Ü	WP = { š ô Pre } ± SIDE = post %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûspec_no_ivars_emptyİ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
ÿSPEC_NO_IVARS_EMPTYüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = spec_no_ivars (Ê Spec_No_Ivars) ± w = š ±
Ü	WP = { š ô Pre } À post %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûspec_no_ivars_eitherİ :
	WP_PARS -> Z_ID list -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
$spec\_no\_ivars\_either$ calls $spec\_no\_ivars\_empty$ or $spec\_no\_ivars$ depending on whether the frame is empty.
=ENDDOC

\subsection{Semicolon}\label{wp-semicolon}

=DOC
val Ûsemicolonİ : WP_PARS -> STATEMENT * STATEMENT -> RESULT  
=DESCRIBE
ÿResultsüüüüüüüüüüüü
Ü	Result';
Ü	Result''
ˆüüüüüüüüüüüüüüüüüüüüü
ÿSEMICOLONüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ P, Q : Statement; Results ·
Ü	st = semicolon (P, Q) ± WP = WP' ±
Ü	SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (P, WP'', Ê Wp_Env) ±
Ü	Ê Result'' = wp (Q, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{If Statement}\label{wp-if-then-else}


=DOC
val Ûif_then_elseİ : WP_PARS -> STATEMENT IF_THEN_ELSE -> RESULT  
=DESCRIBE
¹ZAX
Ü	TRUE, FALSE : Z_ID
°
ÿIF_THEN_ELSEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ If_Then_Else; Results ·
Ü	st = if_then_else (Ê If_Then_Else) ±
Ü	WP =
Ü	z_eq (trans_exp G, zid TRUE) %Longrightarrow% WP' À
Ü	z_eq (trans_exp G, zid FALSE) %Longrightarrow% WP'' ±
Ü			SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (P, A, ÊWp_Env) ±
Ü	Ê Result'' = wp (Q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Case Statement}\label{wp-case}


=DOC
val Ûtrans_case_choicesİ : CN_ENV -> CASE_CHOICE list -> Z_EXP  
=DESCRIBE
¹ZAX
Ü	trans_case_choices : ğ CASE_CHOICE ­ Z_EXP
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü µ choices : ğ CASE_CHOICE ·
Ü   ¶ zranges : ğ Z_EXP; zsingles : Z_EXP ·
Ü	zranges = 
Ü	{ Range | case_range (Ê Range)  choices ·
Ü		z_rng (trans_exp lo, trans_exp hi) } ±
Ü	zsingles =
Ü	z_set {ex : EXP | case_exp ex  choices · trans_exp ex } ±
Ü	trans_case_choices choices = z_many_union (zranges À {zsingles} )
°
=FAILURE
505020	VCs cannot be generated for a statement containing a range attribute
=ENDDOC



=DOC
val Ûcase_baseİ : WP_PARS -> EXP -> STATEMENT CASE_ALTERNATIVE -> RESULT  
=DESCRIBE
ÿCase_Baseüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Statement]
÷üüüüüüüüüüüüüü
Ü	s = § Ê(Case_Alternative[Statement]) ¢
ˆüüüüüüüüüüüüüüüüüüüüü
ÿCASE_BASEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Base; Result' ·
Ü	st = case (Ê Case) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' ±
Ü	SIDE = SIDE' ± Ê Result' = wp (P, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
val Ûcase_stepİ : WP_PARS -> STATEMENT CASE -> RESULT  

=DESCRIBE
ÿCase_Stepüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Statement];
Ü	Case'
÷üüüüüüüüüüüüüü
Ü	E = E';
Ü	s = § Ê(Case_Alternative[Statement]) ¢ ë s'
ˆüüüüüüüüüüüüüüüüüüüüü
ÿCASE_STEPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Step; Results ·
Ü	st = case (Ê Case) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' À WP'' ±
Ü	SIDE = SIDE' À SIDE'' ± Ê Result' = wp (P, A, Ê Wp_Env) ±
Ü	Ê Result'' = wp (case (Ê Case'), A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505021	VCs cannot be generated for a case statement with an OTHERS part
505030	Internal error: case statement with no alternatives found
=ENDDOC


=DOC
val Ûcase_eitherİ : WP_PARS -> STATEMENT CASE -> RESULT  
=DESCRIBE
$case\_either$ is analogous to $spec\_no\_ivars\_either$ in that it is sensitive to the input and processes either a case base or a case step. Note that $case\_step$ can in the implementation process either. Therefore this function is identical to $case\_step$.
=ENDDOC


\subsection{Undecorated Loop}\label{wp-loop}

$named\_loop$ below is required to handle named loops. Its semantics are the same as for $loop$.
=DOC
val Ûloopİ : WP_PARS -> STATEMENT LOOP -> RESULT  
val Ûnamed_loopİ : WP_PARS -> STATEMENT NAMED_LOOP -> RESULT  
=DESCRIBE
ÿLOOPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Loop ·
Ü	st = loop (Ê Loop) ± WP = {š ô Pre} ±
Ü	SIDE = { {post} ô Pre } À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC

\subsection{While Loop}\label{wp-while-loop}

$while$ is a reserved word in Standard ML; hence we use the name $cn\_while$.

=DOC
val Ûcn_whileİ : WP_PARS -> STATEMENT WHILE -> RESULT  
=DESCRIBE
ÿWHILEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ While ·
Ü	st = while (Ê While) ±
Ü	WP =
Ü	{ {z_eq(trans_exp G, zid TRUE)} ô Pre} À
Ü	z_eq(trans_exp G, zid FALSE) %Longrightarrow% A ±
Ü	SIDE = post %Longrightarrow% WP À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC


=TEX
\subsection{For Loop (Static Bounds)}\label{wp-for-value}

=DOC
val Ûfor_staticİ : WP_PARS -> STATEMENT FOR_STATIC -> RESULT  
=DESCRIBE
If the loop does not contain a $till$ predicate, then $T %Longrightarrow% A$ is removed from $SIDE$.

ÿFOR_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Static; Z_Bin_Exp; zi : Z_ID; zlo, zhi : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = for_static (Ê For_Static) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (Pre, zi, zlo) } À
Ü		z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { zran, z_noteq(zid zi, zhi), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi) %Longrightarrow% A À
Ü		zran %Longrightarrow% (T %Longrightarrow% A) ±
Ü	zran = z_elem (zid zi, z_rng (zlo, zhi)) ±
Ü	zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü	zop = z_add ± zleft = zid zi ± zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505020	VCs cannot be generated for a statement containing a range attribute
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
505023	VCs cannot be generated for a reverse loop
=ENDDOC

\subsection{For Loop (Type Mark as Range)}\label{wp-for-tmark}


=DOC
val Ûfor_tmarkİ : WP_PARS -> STATEMENT FOR_TMARK -> RESULT  
=DESCRIBE
ÿFOR_TMARKüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Tmark; Z_Bin_Exp; zi : Z_ID; zlo, zhi : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = for_tmark (Ê For_Tmark) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (Pre, zi, zlo) } À
Ü	z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { z_noteq(zid zi, zhi), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi) %Longrightarrow% A À
Ü	T %Longrightarrow% A ± zi = trans_id i ± zlo = zid (trans_id tmark ^ zfst) ±
Ü	zhi = zid (trans_id tmark ^ zlst) ± zop = z_add ± zleft = zid zi ±
Ü	zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
505023	VCs cannot be generated for a reverse loop
=ENDDOC

\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}



=DOC
val Ûexit_whenİ : WP_PARS -> EXIT_WHEN -> RESULT  
=DESCRIBE
ÿEXIT_WHENüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Exit_When ·
Ü	st = exit_when (Ê Exit_When) ±
Ü	WP =
Ü	{ { z_eq (trans_exp G, zid TRUE) } ô till} À
Ü	z_eq (trans_exp G, zid FALSE)  %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Exit Statement}\label{wp-exit}

$exit$ is already bound in {\Product}; hence we use $cn\_exit$.
=DOC
val Ûcn_exitİ : WP_PARS -> RESULT  
=DESCRIBE
ÿEXITüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	st = exit;
Ü	WP = { š ô till };
Ü	SIDE= š
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Return Statement}\label{wp-return}

$return$ is already bound in {\Product}; hence we use $cn\_return$.
=DOC
val Ûcn_returnİ : WP_PARS -> RETURN -> RESULT  
=DESCRIBE
ÿRETURNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Return; Z_Fun_Call; Informal_Fun ·
Ü	st = ret (Ê Return) ±
Ü	WP = { { z_eq (z_fun_call (Ê Z_Fun_Call), trans_exp E) } ô return } ±
Ü	SIDE = š ± fun_header = Ê Informal_Fun ±
Ü	zfun = zid (trans_id name) ±
Ü	zargs = { i : dom formal_pars · i ízid (trans_id (formal_pars i).var) }
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Procedure Call (No Initial Variables in Spec)} \label{wp-proc-call-no-ivars}


=DOC
val Ûproc_call_specİ : CN_ENV -> (AGG_CHOICE, EXP) PROC_CALL ->
					FORMAL_PROC -> Z_EXP * Z_EXP  
=DESCRIBE
¹ZAX
Ü	proc_call_spec : (Proc_Call ¸ Formal_Proc) ß Spec
°
=FAILURE
505026	Call to ?0 does not match its declaration
=ENDDOC

=DOC
val Ûproc_call_no_ivarsİ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL
							-> RESULT  
=DESCRIBE
ÿPROC_CALL_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call; fp : Formal_Proc ·
Ü	st = proc_no_ivars pc ±
Ü	Ê Result =
Ü	wp (spec_no_ivars (proc_call_spec (pc, fp)), A, Ê Wp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505031	Procedure ?0 has not been declared
=ENDDOC

\subsection{Specification (With Initial Variables)}\label{wp-spec-ivars}

=DOC
val Ûspec_ivarsİ : WP_PARS -> (Z_EXP * Z_EXP) -> RESULT  
=DESCRIBE
ÿSPEC_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_Ivars ·
Ü	st = spec_ivars (Ê Spec_Ivars) ± WP = {š ô Pre} ±
Ü	SIDE = post %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{For Loop (Non-Static Bounds)}\label{wp-for-var}

=DOC
val Ûfor_non_staticİ : WP_PARS -> STATEMENT FOR_NON_STATIC -> RESULT  
=DESCRIBE
ÿFOR_NON_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Non_Static; Z_Bin_Exp; zi : Z_ID;
Ü	zlo, zhi, zlo‰0, zhi‰0 : Z_EXP; zran : Z_PRED ·
Ü		st = for_non_static (Ê For_Non_Static) ±
Ü		WP =
Ü		{ {z_less_eq (zlo, zhi)} ô  sub (Pre, zi, zlo)} À
Ü		z_greater (zlo, zhi) %Longrightarrow% A ±
Ü		SIDE =
Ü		{ { zran, z_noteq (zid zi, zhi‰0), post} ô
Ü			sub (Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi‰0) %Longrightarrow% A À zran %Longrightarrow% (T %Longrightarrow% A) ±
Ü		zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü		zop = z_add ± zleft = zid zi ± zright = z_num 1 ±
Ü		zlo‰0 = subs_exp (zlo, w, w‰0) ±
Ü		zhi‰0 = subs_exp (zhi, w, w‰0) ±
Ü		zran = z_elem (zid zi, z_rng (zlo‰0, zhi‰0))
ˆüüüüüüüüüüüüüüüüüüüüü
=FAILURE
505020	VCs cannot be generated for a statement containing a range attribute
505022	VCs cannot be generated for a loop whose body is not a
	specification statement
=ENDDOC

\subsection{Logical Constant}\label{wp-log-con}


=DOC
val Ûanalyse_log_conİ : LOG_CON_DEF list -> Z_PRED -> LOG_CON_DEF list * Z_PRED  
=DESCRIBE
$analyse\_log\_con$ $c$ $pre$ breaks down a precondition, $pre$ associated with a logical constant specification statement and returns the constituent parts.
It takes the information from the declarations of the logical constants
(with dummy defining terms inserted by the parser)
together with a pre-conditions of the form
=INLINEFT
x1 = E1 ± x2 = E2 ± ... pre1
=TEX
and yields an updated set of {\it LOG\_CON\_DEF}s with
the proper defining terms in the proper order
together with a predicate containing $pre1$.
It will fail if $pre$ is not of the right form or if the declarations don't agree in
number and names with the defining equations or if the equations violate the definition
before use rule.
=USES
It is used by the $log\_con$ function in the process of generating VCs for logical constants. 
=FAILURE
505024	Logical constant statement with precondition ?1 does not have the required form 
	CON x1 : t1; x2 : t2; ... · „ w [x1 = E1 ± x2 = E2 ± ... ± pre1, post]
505025	In a logical constant statement: 
	CON x1 : t1; x2 : t2; ... · „ w [x1 = E1 ± x2 = E2 ± ... ± pre1, post]
	x1 must not appear free in E1, x2 must not appear free
	in E1 or E2 and so on; here ?1 appears free in ?2
=ENDDOC
¹ZAX
Ü z_log_con_def : ğZ_ID ¸ ğZ_ID ­ Log_Con_Def ­ Z_PRED
÷üüüüüü
Ü µ u, v : ğZ_ID; Log_Con_Def·
Ü	z_log_con_def(u,v)(ÊLog_Con_Def) = z_eq(zid X, subs_exp(E, u, v))
°
¹ZAX
Ü add_hyps : (seq‰1 Z_PRED) ¸ ğSequent ­ ğSequent
÷üüüüüü
Üµ h : Z_PRED; S : ğSequent· add_hyps (§h¢, S) = h %Longrightarrow% S;
Üµ h‰1, h‰2 : seq‰1 Z_PRED; S : ğSequent· add_hyps (h‰1 ë h‰2, S) = add_hyps (h‰1, add_hyps(h‰2, S))
°

=DOC
val Ûlog_conİ : WP_PARS -> LOG_CON -> RESULT  
=DESCRIBE
ÿÛLOG_CONİüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü¶ Log_Con ·
Ü	st = log_con (Ê Log_Con) ±
Ü	WP = { (z_log_con_def(š, š))¨ ran defs © ô pre‰1}  À
Ü	     {i : 1 .. #defs· 
Ü		(z_log_con_def(š, š))¨ defs ¨1..i-1© © ô z_mem((defs i).E, (defs i).T)} ±
Ü	SIDE = add_hyps(map (z_log_con_def(w, w‰0)) defs, post %Longrightarrow% A)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{Procedure Call (Initial Variables in Spec)} \label{wp-proc-call-ivars}

=DOC
val Ûproc_call_ivarsİ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL
							-> RESULT  
=DESCRIBE
ÿÛPROC_CALL_IVARSİüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call_Ivars; fp : Formal_Proc ·
Ü	st = proc_ivars pc ±
Ü	Ê Result =
Ü	wp (spec_ivars (proc_call_spec (pc, fp)), A, ÊWp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsection{The Function $wp$}\label{wp}

=DOC
val Ûwpİ : STATEMENT * SEQUENT list * WP_ENV -> RESULT  
=DESCRIBE
¹Z
Ü   µPars·
Ü	wp (st, A, ÊWp_Env) = Ê Result ¤
Ü		NULL ² SIMPLE_ASSIGN ² ARRAY_ASSIGN ² RECORD_ASSIGN ²
Ü		SPEC_NO_IVARS ² SPEC_NO_IVARS_EMPTY ² SEMICOLON ²
Ü		IF_THEN_ELSE ² CASE_BASE ² CASE_STEP ² LOOP ² WHILE ²
Ü		FOR_STATIC ² FOR_TMARK ² EXIT_WHEN ² EXIT ² RETURN ²
Ü		PROC_CALL_NO_IVARS ² FOR_NON_STATIC ² SPEC_IVARS ²
Ü		LOG_CON ² PROC_CALL_IVARS
°
=FAILURE
505040	VCs cannot be generated for a k-slot statement
=ENDDOC

\section{ADJUSTING STATEMENTS}

=DOC
val Ûadjust_statementİ : WP_ENV -> STATEMENT -> STATEMENT
=DESCRIBE
$adjust\_statement$ takes a statement (represented as abstract syntax) and transforms the data representation according to the following rules depending on the data constructor of the statement within the outermost $SStmt$.
\begin{description}
\item[STSpecNoIVars]
If the statement is a specification statement then it checks if there are any initial variables used in the post-condition. If so the statement is converted to a $SpecIVars$. 
\item[STForStatic]
If the for-loop is non-static then the abstract syntax is converted to a $STForNonStatic$.
\item[STProcNoIvars]
If the procedure contains initial variables, then the statement is transformed into a SProcIvars.
\item[STSemicolon]
If the statement comprises a sequence of statements, then the tree of statements is traversed until the first actual statement is found, this is adjusted. 
\end{description} 

The function also makes the checks which detect the following error conditions
(corresponding to the new check 17.1.1.20).
=FAILURE
505091	A specification statement containing initial variables may only
	appear as the first statement in a sequence of statements and may
	not be used as the body of a loop
505092	A for loop with non-static bounds may only
	appear as the first statement in a sequence of statements
505093	A call to a procedure whose specification statement contains initial
	variables may only appear as the first statement in a
	sequence of statements
505094	A logical constant statement may only appear as the first statement in a
	sequence of statements
=ENDDOC
The following error condition is for a branch in the code which should never be taken:
=FAILURE
505094	DESIGN ERROR: unexpected return value from support function
=TEX
\pagebreak
\section{APPLICATION OF CHECKS}\label{APPLICATIONOFCHECKS}

In \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} various checks are specified. The checks appropriate to VC generation are carried out by the functions described below:

=DOC
val Ûchecking_errorİ : string -> int -> (unit -> string) list -> unit
=DESCRIBE
This is the error handling function which is called when a violation of one of the checks is detected.
=FAILURE
505050	VC Soundness Check failed:
=ENDDOC

=DOC
val Ûcheck_1_aİ : (ID list * SPECLAB) -> unit
=DESCRIBE
This implements check 17.1.1.1 (a)
=FAILURE
505060	Each variable whose value could be changed by a refinement step
	must appear (implicitly or explicitly) in the frame 
	of the specification statement being refined.
	This refinement step refines a specification statement with no
	variables in its frame but could change the value of ?0.
505064	Each variable whose value could be changed by a refinement step
	must appear (implicitly or explicitly) in the frame 
	of the specification statement being refined.
	This refinement step refines a specification statement with a frame
	comprising ?0 but could change the value of ?1.
505080	An invalid expression has been encountered on the left-hand side
	of an assignment or as an out or in out mode parameter
=ENDDOC

=DOC
val Ûcheck_1_bİ : SPECLAB -> unit
=DESCRIBE
This implements check 17.1.1.1 (b)
=FAILURE
505061	A RETURN statement can only appear in the body of a function which
	has a formal specification.  
=ENDDOC

=DOC
val Ûcheck_1_cİ : SPECLAB -> unit
=DESCRIBE
This implements check 17.1.1.1 (c)
=FAILURE
505062	An EXIT statement can only appear in a LOOP whose exit condition is
	expressed within a TILL clause.
=ENDDOC

=DOC
val Ûcheck_1_dİ : (ID * SPECLAB) -> unit
=DESCRIBE
This implements check 17.1.1.1 (d)
=FAILURE
505063	For ?0: a procedure call can only appear if the procedure has a formal
	specification. 
=ENDDOC

=DOC
datatype ÛCHECK_STATEİ = ÛCSTopİ | ÛCSInLoopİ | ÛCSInCaseİ
		| ÛCSOKToExitİ | ÛCSInIfThenElseİ;
datatype ÛENDINGİ = ÛEndsInReturnİ | ÛEndsInOtherİ;
=DESCRIBE
=ENDDOC

=DOC
val Ûcheck_3aİ : (CHECK_STATE * STATEMENT) -> unit
=DESCRIBE
This implements check 17.1.1.3 (first part)
=FAILURE
505065	The closest-containing compound statement of an EXIT WHEN G
	statement must be a LOOP statement
505076	Internal error:  argument must be an EXIT WHEN statement
=ENDDOC

=DOC
val Ûcheck_3bİ : (CHECK_STATE * STATEMENT) -> unit
=DESCRIBE
This implements check 17.1.1.3 (second part)
=FAILURE
505066	The closest-containing compound statement of an EXIT statement must be
	an IF statement with no ELSIF or ELSE parts; the closest-containing
	compound statement of this IF statement must be a loop and the EXIT
	statement must be the last statement inside the IF statement.
505077	Internal error:  argument must be an EXIT statement
=ENDDOC
=DOC
val Ûcheck_4aİ : bool -> unit
=DESCRIBE
This implements check 17.1.1.4 (first part)
=FAILURE
505078	A RETURN statement is only allowed within the body of a function subprogram.
=ENDDOC

=DOC
val Ûcheck_4bİ : (bool * ENDING) -> unit
=DESCRIBE
This implements check 17.1.1.4 (second part)
=FAILURE
505079	The last statement in the body of a function must be either a RETURN
	statement or a CASE statement whose alternatives all end with
	RETURN statement.
=ENDDOC

=DOC
val Ûcheck_19İ : CN_ENV -> SPEC -> unit
=DESCRIBE
This implements check 17.1.1.16.
It also checks that the things in the frame are actually (program or auxiliary) variables
=FAILURE
505082	The variables in the frame of a specification statement must be in
	scope. ?0 is not in scope here.
505083	The names in the frame of a specification statement must be
	variables. ?0 is not a variable here.
=ENDDOC

\subsection{Anti-Aliasing Checks}
=DOC
val Ûfree_vars_zpredİ : Z_PRED -> Z_ID list
val Ûfind_formal_procİ : SPECLAB -> ID -> FORMAL_PROC
val Ûanti_aliasing_parsİ : FORMAL_PROC -> (AGG_CHOICE,EXP) PROC_CALL ->
					ID list * ID list
val Ûanti_aliasing_actuals_modesİ : CN_ENV -> FORMAL_PROC ->
		(AGG_CHOICE, EXP) PROC_CALL -> (EXP * MODE) list
=DESCRIBE
¹ZAX
Ü	free_vars_zpred : Z_PRED ­ ğ Z_ID
°
ÿAnti_Aliasing_Parsüüüüüüüü
Ü	Formal_Proc;
Ü	Proc_Call;
Ü	formals, globals : ğ ID
÷üüüüüüüüüüüüü
Ü	formals = {par : ran formal_ids · par.var};
Ü	trans_id ¨ globals © =
Ü	free_vars_zpred Pre À free_vars_zpred post \
Ü			(trans_id ¨ formals © )
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505067	There is no specification statement for the procedure ?0
505068	The number of actuals provided does not match those in the declaration of ?0
=ENDDOC

=DOC
val Ûanti_aliasing_check_1İ : (AGG_CHOICE, EXP) PROC_CALL ->
				(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_1üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	{i : dom actuals | (formal_ids i).mode  {in_out, out}
Ü		· actuals i} € ran Id
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505069	In a procedure call, each actual parameter of mode OUT
	or IN OUT must be an entire variable (i.e., a name).
	A parameter to ?0 violated this rule.
=ENDDOC

=DOC
val Ûanti_aliasing_check_2İ : FORMAL_PROC -> (AGG_CHOICE, EXP) PROC_CALL ->
				(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_2üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	(Id ¨ globals © ) ¡
Ü	{i : dom actuals | (formal_ids i).mode  {in_out, out}
Ü		· actuals i} = š
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505070	Actual parameter to ?0 is not an entire variable
505071	In a procedure call, no actual parameter of mode OUT or IN OUT
	may contain a variable used in the global definition of
	the procedure.
	The following parameter?0 of ?1 violated this rule: ?2
=ENDDOC

=DOC
val Ûvars_expİ : CN_ENV -> EXP -> ID list
val Ûanti_aliasing_check_3İ :
	SPECLAB -> FORMAL_PROC -> (AGG_CHOICE, EXP) PROC_CALL ->
	(EXP * MODE) list -> unit
=DESCRIBE
¹ZAX
Ü	vars_exp : EXP ­ ğ ID
°
ÿAnti_Aliasing_Check_3üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	(trans_id ¨ globals © ) ¡ w ¡
Ü	(trans_id ¨ Ş (vars_exp ¨ ran actuals © ) © ) = š
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505072	In a procedure call, no variable occurring in the actual parameters
	may appear exported in the global definition of the procedure.
	The following parameter?0 of ?1 violated this rule: ?2
=ENDDOC

=DOC
val Ûanti_aliasing_check_4İ :
		SPECLAB -> FORMAL_PROC -> (AGG_CHOICE, EXP) PROC_CALL ->
		(EXP * MODE) list -> unit
=DESCRIBE
ÿAnti_Aliasing_Check_4üüüüüüüü
Ü	Anti_Aliasing_Pars
÷üüüüüüüüüüüüü
Ü	µ i, j : dom actuals |
Ü	   i ½ j ± vars_exp (actuals i) ¡ vars_exp (actuals j) ½ š ·
Ü	(formal_ids i).mode = inn ± (formal_ids j).mode = inn
ˆüüüüüüüüüüüüüüüüüüüü
=FAILURE
505073	In a procedure call, a variable appearing as an actual parameter
	of mode OUT or IN OUT may not occur in some other actual parameter.
	The following parameter?0 of ?1 violated this rule: ?2
=ENDDOC

=DOC
val Ûanti_aliasing_checkİ : CN_ENV -> (SPECLAB * (AGG_CHOICE,EXP)PROC_CALL)
	-> unit
=DESCRIBE
¹Z
Ü Anti_Aliasing_Check ¦
Ü   Anti_Aliasing_Check_1 ± Anti_Aliasing_Check_2 ±
Ü   Anti_Aliasing_Check_3 ± Anti_Aliasing_Check_4
°
This invokes each of the anti-aliasing checks 1 to 4.
It also invokes that part of check 1(a) concerned with procedure calls.
=FAILURE
505068	The number of actuals provided does not match those in the declaration of ?0
=ENDDOC

\subsection{Variable Capture Checks}

ÿID_ENVüüüüüüüüüüüüüüü
Ü	spark_ids : ğ ID;
Ü	z_log_aux, z_attribs : ğ Z_ID
ˆüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcheck_new_spark_idsİ : CN_ENV -> ID list -> unit
=DESCRIBE
ÿNew_Spark_Idüüüüüüüüüüüüüüü
Ü	ID_ENV;
Ü	Id? : ID
÷üüüüüüüüüü
Ü	trans_id Id?  
Ü		(trans_id ¨ spark_ids ©) À z_log_aux À z_attribs
ˆüüüüüüüüüüüüüüüüüüü
=FAILURE
505074	A declaration of ?0 has already been introduced
505075	Variable declaration contains repeated instances of the same name
=ENDDOC
=DOC
val Ûcheck_new_z_idİ : Z_ID list -> Z_ID -> unit
=DESCRIBE
ÿNew_Z_Idüüüüüüüüüüüüüüü
Ü	ID_ENV;
Ü	z_id? : Z_ID
÷üüüüüüüüüü
Ü	z_id?  
Ü		(trans_id ¨ spark_ids ©) À z_log_aux À z_attribs
ˆüüüüüüüüüüüüüüüüüüü
=FAILURE
505074	A declaration of ?0 has already been introduced
=ENDDOC

=DOC
val Ûdo_soundness_checks1İ : SPECLAB * STATEMENT -> unit
=DESCRIBE
This function applies those soundness checks which can be called directly from the VC generator.
=ENDDOC

=DOC
val Ûdo_soundness_checks2İ : (LABEL -> REPLACEMENT OPT)
				-> bool -> STATEMENT -> unit
=DESCRIBE
This function applies those soundness checks which should be called from the Spark Program Generator. It invokes checks which require information from the environments in ISS/HAT/DAZ/DTD507, and therefore cannot be called from the VC generator directly.

The second argument is a boolean function which should be set to true if the statement (argument 3) is part of a function subprogram.
=ENDDOC

\pagebreak
\section{VERIFICATION CONDITIONS}

=DOC
val Ûfun_sigİ : (Z_EXP list * Z_EXP) -> Z_EXP;
val Ûpar_tmarkİ : CN_ENV -> PARAM_SPEC -> Z_ID list;
val Ûvar_sigİ : CN_ENV -> Z_ID -> Z_EXP;
val Ûfun_declİ : CN_ENV -> FORMAL_FUN -> Z_DECL;
=DESCRIBE
The Z specifications of these functions can be found in ISS/HAT/DAZ/DTD507.
=FAILURE
505041	The global dependencies of a function must be variables: ?0
	is neither a program variable nor an auxiliary variable
=ENDDOC

=DOC
val Ûvc_local_declsİ : SEQUENT list * SPECLAB -> VC list  
=DESCRIBE
¹ZAX
Ü	Ûvc_local_declsİ : (ğ Sequent ¸ Speclab) ­ ğ VC
°
=ENDDOC

=DOC
val Ûvcsİ : SPECLAB * STATEMENT -> VC list
=DESCRIBE
¹ZAX
Ü	Ûvcsİ : (Speclab ¸ Statement) ß ğ VC
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ Speclab; st : Statement ·
Ü		¶ Result; WP‰1, s : ğ Sequent ·
Ü			vcs (Ê Speclab, st) = vc_local_decls (s, Ê Speclab) ±
Ü			s = Pre %Longrightarrow% WP‰1 À subs_pred(Pre, w, w‰0) %Longrightarrow% SIDE ±
Ü			ÊResult = wp (st, {š ô post}, Ê Wp_Env) ±
Ü			WP‰1 =
Ü			{ Sequent | H ô c  WP · H ô subs_pred (c, w‰0, w)}
°
=ENDDOC

\section{EPILOGUE}

=SML
end (* local...in *);
end (* signature CNBasicDeclsAndExprs *);
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



