%  dtd505.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Verification Condition Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD505}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
The Z in this document is completely out of sync both with DRA's specs and the implementation. This needs to be rectified.

\section{GENERAL}
\subsection{Scope}

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
infix 3 ô;
infix 4 %Longrightarrow%;
=TEX
=DOC
signature ÛCNVCGeneratorÝ = sig
local
	open CNTypes CNBasicDeclsAndExprs CNTypes2 ZProofMode;
in
=DESCRIBE
=FAILURE
505001	?0
=ENDDOC
ÿÛNULLÝüüüüüüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüüü
Ü	st = stmt null;
Ü	WP = A;
Ü	SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val null : WP_PARS -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Assignment Statement}\label{wp-assignment}
ÿÛASSIGNÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Assign·
Ü		st = stmt(assign(Ê Assign)) ±
Ü		WP = subseq(A, trans_id x, trans_exp E) ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü


=DOC
val simple_assign : WP_PARS -> ID -> EXP -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Array Assignment Statement}\label{wp-array-assignment}
ÿÛARRAY_ASSIGNÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Array_Assign; ze : Z_EXP·
Ü		st = stmt(arr_assign(Ê Array_Assign)) ±
Ü		WP = subseq(A, trans_id a, ze) ± SIDE = š ±
Ü		ze =
Ü		z_override
Ü		(zid (trans_id a),
Ü		z_set {z_maplet (trans_exp E‰1, trans_exp E‰2)})
ˆüüüüüüüüüüüüüüüüüüüüü


=DOC
val Ûarray_assignÝ : WP_PARS -> EXP INDEXED_COMP -> EXP -> RESULT  
=DESCRIBE
=ENDDOC


=DOC
val Ûrecord_assignÝ : WP_PARS -> EXP SELECTED_COMP -> EXP -> RESULT  
=DESCRIBE
=ENDDOC


=DOC
val ÛassignÝ : WP_PARS -> ASSIGN -> RESULT  
=DESCRIBE
=ENDDOC


To implement the above it is convenient for present purposes to use \Product's nested quotation facility, (although more efficient means would be advisable in a real implementation).
=TEX
\subsubsection{Specification (No initial variables)}\label{wp-specification-no-ivars}
Empty frame:

Non-empty frame.
ÿÛSPEC_NO_IVARSÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Spec_No_Ivars·
Ü		st = stmt(spec_no_ivars(Ê Spec_No_Ivars)) ± w ½ š ±
Ü		WP = { š ô Pre } ± SIDE = post %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü


=DOC
val Ûspec_no_ivarsÝ : WP_PARS -> SPEC_NO_IVARS -> RESULT  
=DESCRIBE
=ENDDOC



ÿÛSPEC_NO_IVARS_EMPTYÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Spec_No_Ivars·
Ü		st = stmt(spec_no_ivars(Ê Spec_No_Ivars)) ± w = š ±
Ü		WP = { š ô Pre } À post %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûspec_no_ivars_emptyÝ : WP_PARS -> SPEC_NO_IVARS -> RESULT  
=DESCRIBE
=ENDDOC

=DOC
val Ûspec_no_ivars_eitherÝ : WP_PARS -> SPEC_NO_IVARS -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Semicolon}\label{wp-semicolon}
Like the current draft Z standard, \Product\ does not support subscripts as a form of decoration, so we use priming instead of subscription here.

ÿÛResultsÝüüüüüüüüüüüü
Ü	Result';
Ü	Result''
ˆüüüüüüüüüüüüüüüüüüüüü
ÿÛSEMICOLONÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶P, Q : Stmt; Results·
Ü		st = stmt(semicolon(P, Q)) ± WP = WP' ±
Ü		SIDE = SIDE' À SIDE'' ±
Ü		Ê Result' = wp(stmt P, WP'', ÊWp_Env) ±
Ü		Ê Result'' = wp(stmt Q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val ÛsemicolonÝ : WP_PARS -> STMT * STMT -> RESULT  
=DESCRIBE
=ENDDOC


\subsubsection{If-then-else}\label{wp-if-then-else}

¹ZAX
Ü	TRUE, FALSE : Z_ID
°
ÿÛIF_THEN_ELSEÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶If_Then_Else; Results·
Ü		st = stmt(if_then_else(ÊIf_Then_Else)) ±
Ü		WP =
Ü		z_eq(trans_exp G, zid TRUE) %Longrightarrow% WP' À
Ü		z_eq(trans_exp G, zid FALSE) %Longrightarrow% WP'' ±
Ü		SIDE = SIDE' À SIDE'' ±
Ü		Ê Result' = wp(stmt P, A, ÊWp_Env) ±
Ü		Ê Result'' = wp(stmt Q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûif_then_elseÝ : WP_PARS -> STMT IF_THEN_ELSE -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Case}\label{wp-case}

=DOC
val Ûtrans_case_choicesÝ : CN_ENV -> CASE_CHOICE list -> Z_EXP  
=DESCRIBE
=ENDDOC


ÿÛCase_BaseÝüüüüüüüüüüüü
Ü	Case;
Ü	Case_Seg[Stmt]
÷üüüüüüüüüüüüüü
Ü	s = § Ê(Case_Seg[Stmt]) ¢
ˆüüüüüüüüüüüüüüüüüüüüü
ÿÛCASE_BASEÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Case_Base; Result'·
Ü		st = stmt(case(Ê(Case[Stmt]))) ±
Ü		WP =
Ü		z_elem (trans_exp E, z_set(trans_exp¨when©)) %Longrightarrow% WP' ±
Ü		SIDE = SIDE' ± ÊResult' = wp(stmt P, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcase_baseÝ : WP_PARS -> EXP -> STMT CASE_ALTERNATIVE -> RESULT  
=DESCRIBE
=ENDDOC


ÿÛCase_StepÝüüüüüüüüüüüü
Ü	Case;
Ü	Case_Seg[Stmt];
Ü	Case'
÷üüüüüüüüüüüüüü
Ü	E = E';
Ü	s = § Ê(Case_Seg[Stmt]) ¢ ë s'
ˆüüüüüüüüüüüüüüüüüüüüü
ÿÛCASE_STEPÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Case_Step; Results·
Ü		st = stmt(case(Ê(Case[Stmt]))) ±
Ü		WP =
Ü		z_elem (trans_exp E, z_set(trans_exp¨when©)) %Longrightarrow% WP'À
Ü		WP'' ± SIDE = SIDE' À SIDE'' ±
Ü		ÊResult' = wp(stmt P, A, ÊWp_Env) ±
Ü		ÊResult'' = wp(stmt (case(ÊCase')), A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcase_stepÝ : WP_PARS -> STMT CASE -> RESULT  
=DESCRIBE
=ENDDOC


Note that $CASE\_STEP$ is recursive and does the full job. 
But by analogy with the naming convention we chose to adopt for the
two case of specification statement in section \ref{wp-specification-no-ivars},
we define the following.

=DOC
val Ûcase_eitherÝ : WP_PARS -> STMT CASE -> RESULT  
=DESCRIBE
=ENDDOC


\subsubsection{Loop}\label{wp-loop}
ÿÛLOOPÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Loop·
Ü		st = stmt(loop(ÊLoop)) ± WP = {š ô Pre} ±
Ü		SIDE = { {post} ô Pre } À u %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü
=DOC
val ÛloopÝ : WP_PARS -> STMT LOOP -> RESULT  
=DESCRIBE
=ENDDOC

=DOC
val Ûnamed_loopÝ : WP_PARS -> STMT NAMED_LOOP -> RESULT  
=DESCRIBE
=ENDDOC


\subsubsection{While Loop}\label{wp-while-loop}
ÿÛWHILEÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶While·
Ü		st = stmt(while(ÊWhile)) ±
Ü		WP = {{z_eq(trans_exp G, zid TRUE)} ô Pre} À
Ü		z_eq(trans_exp G, zid FALSE) %Longrightarrow% A ±
Ü		SIDE = post %Longrightarrow% WP À u %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcn_whileÝ : WP_PARS -> STMT WHILE -> RESULT  
=DESCRIBE
=ENDDOC


=TEX
\subsubsection{For Loop (Values as Bounds)}\label{wp-for-value}
ÿÛFOR_VALUEÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶For_Value; Z_Bin_Exp; zi : Z_ID; zlo, zhi : Z_EXP;
Ü		zran : Z_PRED·
Ü		st = stmt(for_value(ÊFor_Value)) ±
Ü		WP = {š ô sub(Pre, zi, zlo)} ±
Ü		SIDE =
Ü		{ { zran, z_noteq(zid zi, zhi), post } ô
Ü			sub(Pre, zi, z_bin_exp(ÊZ_Bin_Exp))} À
Ü			sub(post, zi, zhi) %Longrightarrow% A À zran %Longrightarrow% (u %Longrightarrow% A) ±
Ü		zran = z_elem(zid zi, z_rng(zlo, zhi)) ± zi = trans_id i ±
Ü		zlo = trans_exp lo ± zhi = trans_exp hi ± zop = z_add ±
Ü		zleft = zid zi ± zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûfor_staticÝ : WP_PARS -> STMT FOR_STATIC -> RESULT  
=DESCRIBE
=ENDDOC

=DOC
val Ûfor_tmarkÝ : WP_PARS -> STMT FOR_TMARK -> RESULT  
=DESCRIBE
=ENDDOC
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}
=DOC
val Ûexit_whenÝ : WP_PARS -> EXIT_WHEN -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Exit}\label{wp-exit}
ÿÛEXITÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Exit·
Ü		st = stmt(exit(ÊExit)) ±
Ü		WP =
Ü		{ {z_eq(trans_exp G, zid TRUE)} ô until } À
Ü		z_eq(trans_exp G, zid FALSE) %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
As a reminder to implementers of a real-life version, the following avoids computing $trans\_exp\,G$ twice.
=DOC
val Ûcn_exitÝ : WP_PARS -> RESULT  
=DESCRIBE
=ENDDOC
\subsubsection{Return}\label{wp-return}
¹ZAX
Ü	make_fun_call : Informal_Fun ­ Z_EXP
°
ÿÛRETURNÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Return·
Ü		st = stmt(ret(ÊReturn)) ±
Ü		WP =
Ü		{ {z_eq(make_fun_call fun_header, trans_exp E)} ô
Ü			return } ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
The following is a simplistic approximation/guess.
=DOC
val Ûcn_returnÝ : WP_PARS -> RETURN -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}

¹ZAX
Ü	proc_spec : (Proc_Call ¸ Formal_Proc) ß Spec
°
ÿÛPROC_CALL_NO_IVARSÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶pc : Proc_Call; fp : Formal_Proc·
Ü		st = stmt(proc_no_ivars pc) ±
Ü		ÊResult =
Ü		wp(stmt(spec_no_ivars(proc_spec(pc, fp))), A, ÊWp_Env) ±
Ü		fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
Contextual errors may need to be reported in the implementation of the above.
An exception is declared for the purpose.
=SML
=TEX
Like the implementation of $make\_fun\_call$ above the following is another simplistic approximation/guess.
It is assumed that the caller will have supplied the correct $Formal\_Proc$ from the environment.
The formals and actuals must agree in number, and the library function $combine$, which turns a pair of equal length lists into a list of pairs, will raise the exception $Fail$ if they do not.

=DOC
val Ûproc_call_specÝ : CN_ENV -> (AGG_CHOICE, EXP) PROC_CALL -> FORMAL_PROC -> SPEC  
=DESCRIBE
=ENDDOC



The relevant formal procedure may not be in the environment here.
The library function $find$ will raise the exception $Fail$ if this is the case.
=DOC
val Ûproc_call_no_ivarsÝ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL -> RESULT  
=DESCRIBE
=ENDDOC
\subsubsection{Specification (With Initial Variables)}\label{wp-spec-ivars}
ÿÛSPEC_IVARSÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Spec_Ivars; q : Stmt; Result'·
Ü		st = spec_ivars(ÊSpec_Ivars, q) ± WP = {š ô Pre} ±
Ü		SIDE = post %Longrightarrow% WP' À SIDE' ±
Ü		ÊResult' = wp(stmt q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûspec_ivarsÝ : WP_PARS -> SPEC_IVARS * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{For Loop (Bounds with Variables)}\label{wp-for-var}
ÿÛFOR_VARÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶For_Value; Z_Bin_Exp; q : Stmt; Result'; zi : Z_ID;
Ü		zlo, zhi, zlo‰0, zhi‰0 : Z_EXP; zran : Z_PRED·
Ü		st = for_exp(ÊFor_Var, q) ±
Ü		WP =
Ü		{ {z_less_eq(zlo, zhi)} ô  sub(Pre, zi, zlo)} À
Ü		z_greater(zlo, zhi) %Longrightarrow% WP' ±
Ü		SIDE =
Ü		{ { zran, z_noteq(zid zi, zhi‰0), post} ô
Ü			sub(Pre, zi, z_bin_exp(ÊZ_Bin_Exp))} À
Ü		sub(post, zi, zhi‰0) %Longrightarrow% WP' À zran %Longrightarrow% (u %Longrightarrow% A) À
Ü		SIDE' ± ÊResult' = wp(stmt q, A, ÊWp_Env) ±
Ü		zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü		zop = z_add ± zleft = zid zi ± zright = z_num 1 ±
Ü		zlo‰0 = subs_exp(zlo, w, w‰0) ±
Ü		zhi‰0 = subs_exp(zhi, w, w‰0) ±
Ü		zran = z_elem(zid zi, z_rng(zlo‰0, zhi‰0))
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûfor_non_staticÝ : WP_PARS -> FOR_NON_STATIC * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Logical Constant}\label{wp-log-con}
ÿÛLOG_CONÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶Log_Con; q : Stmt; Result'·
Ü		st = log_con(ÊLog_Con, q) ±
Ü		WP = {š ô sub(pre‰1, X, E)} ±
Ü		SIDE =
Ü		z_eq(zid X, subs_exp(E, w, w‰0)) %Longrightarrow% (post %Longrightarrow% WP') À
Ü		SIDE' ± ÊResult' = wp(stmt q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûanalyse_log_conÝ : Z_PRED -> Z_EXP * Z_PRED  
=DESCRIBE
=ENDDOC

=DOC
val Ûlog_conÝ : WP_PARS -> LOG_CON * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}
ÿÛPROC_CALL_IVARSÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü	¶pc : Proc_Call; q : Stmt; fp : Formal_Proc·
Ü		st = proc_ivars(pc, q) ±
Ü		ÊResult =
Ü		wp(spec_ivars(proc_spec(pc, fp), q), A, ÊWp_Env) ±
Ü		fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûproc_call_ivarsÝ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsection{$wp$}\label{wp}
In Z, $wp$ is now defined by the following axiom:
¹Z
Ü	µPars·
Ü		wp(st, A, ÊWp_Env) = ÊResult ¤
Ü			NULL ² ASSIGN ² ARRAY_ASSIGN ²
Ü			SPEC_NO_IVARS_EMPTY ² SPEC_NO_IVARS ²
Ü			SEMICOLON ² IF_THEN_ELSE ² CASE_BASE ²
Ü			CASE_STEP ² LOOP ² WHILE ² FOR_VALUE ² EXIT ²
Ü			RETURN ² PROC_CALL_NO_IVARS ² FOR_VAR ²
Ü			SPEC_IVARS ² LOG_CON ² PROC_CALL_IVARS
°

=DOC
val ÛwpÝ : STATEMENT * SEQUENT list * WP_ENV -> RESULT  
=DESCRIBE
=ENDDOC

=TEX
\pagebreak
\section{VERIFICATION CONDITIONS}
¹Z
Ü	ÛFLAGÝ ::= ÛTrueÝ | ÛFalseÝ
°
¹Z
Ü	[ÛDEC_LABELÝ]
°
ÿÛIn_ScopeÝüüüüüüüüüüüü
Ü	vc_vars : ð Var_Decl;
Ü	vc_pars : ð Param_Spec;
Ü	formal_procs : ð Formal_Proc;
Ü	dec_label : ð DEC_LABEL
ˆüüüüüüüüüüüüüüüüüüüüü
ÿÛSpeclabÝüüüüüüüüüüüü
Ü	Spec;
Ü	formal_body_flag, fun_flag, until_flag : FLAG;
Ü	Wp_Env;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüüü
¹ZAX
Ü	Ûvc_local_declsÝ : (ð Sequent ¸ Speclab) ­ ðVC
°
The above function is described informally in reasonable detail in \cite{DRA/CIS/CSE3/SWI/WP/1}.
¹ZAX
Ü	ÛvcsÝ : (Speclab ¸ Statement) ­ ðVC
÷üüüüüüüüüüüüüüüüüüüü
Ü	µSpeclab; st : Statement·
Ü		¶Result; WP‰1, s : ð Sequent·
Ü			vcs(ÊSpeclab, st) = vc_local_decls(s, ÊSpeclab) ±
Ü			s = Pre %Longrightarrow% WP‰1 À subs_pred(Pre, w, w‰0) %Longrightarrow% SIDE ±
Ü			ÊResult = wp(st, {š ô post}, ÊWp_Env) ±
Ü			WP‰1 =
Ü			{ Sequent | H ô c  WP· H ô subs_pred(c, w‰0, w)}
°
We use the built-in type of booleans for flags and take it that $DEC\_LABEL$s may be represented as strings.
=SML
=TEX
$Speclab$ is the first schema we have had to accomodate in which included schema have overlapping signatures ($In\_Scope$ and $Wp\_Env$ share the component $formal\_procs$
How this situation is handled in Standard ML is probably best decided from case to case.
Here we choose to precede as if a schema like $In\_Scope$ but with the common component removed had been used instead.
=SML
=TEX
Retrieving the declaration of a function from the function header is not done in the following simplistic approximation to the real $vc\_local\_decls$.
=DOC
val Ûvc_local_declsÝ : SEQUENT list * SPECLAB -> VC list  
=DESCRIBE
=ENDDOC
=DOC
val ÛvcsÝ : SPECLAB * STATEMENT -> VC list
=DESCRIBE
=ENDDOC

\section{EPILOGUE}

=SML
end (* local...in *);
end (* signature CNBasicDeclsAndExprs *);
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



