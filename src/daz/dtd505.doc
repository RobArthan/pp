%  dtd505.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Verification Condition Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD505}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{SPARK}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
The Z in this document is completely out of sync both with DRA's specs and the implementation. This needs to be rectified.

\section{GENERAL}
\subsection{Scope}

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
infix 3 ô;
infix 4 %Longrightarrow%;
=TEX
=DOC
signature ÛCNVCGeneratorÝ = sig
local
	open CNTypes CNBasicDeclsAndExprs CNTypes2;
in
=DESCRIBE
=FAILURE
505001	?0
=ENDDOC
ÿNULLüüüüüüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüüü
Ü	st = stmt null;
Ü	WP = A;
Ü	SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val null : WP_PARS -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Assignment Statement}\label{wp-assignment}
ÿSIMPLE_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü  ¶ Assign; x : ID ·
Ü	st = stmt(assign(Ê Assign)) ± name id x ±
Ü	WP = subseq(A, trans_id x, trans_exp E) ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü


=DOC
val simple_assign : WP_PARS -> ID -> Z_EXP -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Array Assignment Statement}\label{wp-array-assignment}
ÿARRAY_ASSIGNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Assign; Indexed_Comp; Assign' ·
Ü		st = stmt(assign(Ê Assign)) ±
Ü		name = indexed_comp (Ê Indexed_Comp) ±
Ü		Ê Result = wp (stmt(assign(Ê Assign')), A, ÊWp_Env) ±
Ü		name' = prefix ±
Ü		E' =
Ü		auxiliary_exp
Ü		(z_override
Ü		   (trans_exp prefix, z_set {
Ü				z_maplet(trans_exp index, trans_exp )} ))
ˆüüüüüüüüüüüüüüüüüüüüü


=DOC
val Ûarray_assignÝ : WP_PARS -> EXP INDEXED_COMP -> Z_EXP -> RESULT  
=DESCRIBE
=ENDDOC

¹ZAX
Ü	retrieve_type_mark : EXP ­ TMARK
°

ÿRECORD_ASSIGNüüüüüüüü
Ü	Pars
÷üüüüü
Ü   ¶ Assign; Selected_Comp; Assign'; Record_Type_Def; Agg_Pos ·
Ü	st = stmt (assign(Ê Assign)) ±
Ü	name = selected_comp (Ê Selected_Comp) ±
Ü	Ê Result = wp (stmt (assign (Ê Assign')), A, ÊWp_Env) ±
Ü	name' = prefix ± E' = rec_agg_pos (Ê Agg_Pos) ±
Ü	tmark = retrieve_type_mark prefix ±
Ü	retrieve_type_def tmark = record_type_def (Ê Record_Type_Def) ±
Ü	comps = 
Ü	{ i : dom decl; Selected_Comp‰1; e : EXP |
Ü	  (decl i).var = selector ± e = E ²
Ü	  (decl i).var ½ selector ± e = selected_comp (Ê Selected_Comp') ±
Ü	  prefix' = prefix ± selector' = (decl i).var · i í e }
ˆüüüüüüüüüüüüüüüü

=DOC
val Ûrecord_assignÝ : WP_PARS -> EXP SELECTED_COMP -> Z_EXP -> RESULT  
=DESCRIBE
=ENDDOC


=DOC
val ÛassignÝ : WP_PARS -> EXP * Z_EXP -> RESULT  
=DESCRIBE
=ENDDOC


To implement the above it is convenient for present purposes to use \Product's nested quotation facility, (although more efficient means would be advisable in a real implementation).
=TEX
\subsubsection{Specification (No initial variables)}\label{wp-specification-no-ivars}
Empty frame:

Non-empty frame.
ÿSPEC_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = stmt (spec_no_ivars (Ê Spec_No_Ivars)) ± w ½ š ±
Ü	WP = { š ô Pre } ± SIDE = post %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü


=DOC
val Ûspec_no_ivarsÝ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
=ENDDOC



ÿSPEC_NO_IVARS_EMPTYüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_No_Ivars ·
Ü	st = stmt (spec_no_ivars (Ê Spec_No_Ivars)) ± w = š ±
Ü	WP = { š ô Pre } À post %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûspec_no_ivars_emptyÝ : WP_PARS -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
=ENDDOC

=DOC
val Ûspec_no_ivars_eitherÝ : WP_PARS -> Z_ID list -> Z_EXP * Z_EXP -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Semicolon}\label{wp-semicolon}
Like the current draft Z standard, \Product\ does not support subscripts as a form of decoration, so we use priming instead of subscription here.

ÿResultsüüüüüüüüüüüü
Ü	Result';
Ü	Result''
ˆüüüüüüüüüüüüüüüüüüüüü
ÿSEMICOLONüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ P, Q : Stmt; Results ·
Ü	st = stmt (semicolon (P, Q)) ± WP = WP' ±
Ü	SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (stmt P, WP'', Ê Wp_Env) ±
Ü	Ê Result'' = wp (stmt Q, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val ÛsemicolonÝ : WP_PARS -> STMT * STMT -> RESULT  
=DESCRIBE
=ENDDOC


\subsubsection{If-then-else}\label{wp-if-then-else}

¹ZAX
Ü	TRUE, FALSE : Z_ID
°
ÿIF_THEN_ELSEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ If_Then_Else; Results ·
Ü	st = stmt (if_then_else (Ê If_Then_Else)) ±
Ü	WP =
Ü	z_eq (trans_exp G, zid TRUE) %Longrightarrow% WP' À
Ü	z_eq (trans_exp G, zid FALSE) %Longrightarrow% WP'' ±
Ü			SIDE = SIDE' À SIDE'' ±
Ü	Ê Result' = wp (stmt P, A, ÊWp_Env) ±
Ü	Ê Result'' = wp (stmt Q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûif_then_elseÝ : WP_PARS -> STMT IF_THEN_ELSE -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Case}\label{wp-case}

¹ZAX
Ü	trans_case_choices : ð CASE_CHOICE ­ Z_EXP
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü µ choices : ð CASE_CHOICE ·
Ü   ¶ ranges : ð Z_EXP; zsingles : Z_EXP ·
Ü	zranges = 
Ü	{ Range | case_range (Ê Range)  choices ·
Ü		z_rng (trans_exp lo, trans_exp hi) } ±
Ü	zsingles =
Ü	z_set {ex : EXP | case_exp ex  choices · trans_exp ex } ±
Ü	trans_case_choices choices = z_many_union (zranges À {zsingles} )
°

=DOC
val Ûtrans_case_choicesÝ : CN_ENV -> CASE_CHOICE list -> Z_EXP  
=DESCRIBE
=ENDDOC


ÿCase_Baseüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Stmt]
÷üüüüüüüüüüüüüü
Ü	s = § Ê(Case_Alternative[Stmt]) ¢
ˆüüüüüüüüüüüüüüüüüüüüü
ÿCASE_BASEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Base; Result' ·
Ü	st = stmt (case (Ê (Case[Stmt]))) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' ±
Ü	SIDE = SIDE' ± Ê Result' = wp (stmt P, A, Ê Wp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcase_baseÝ : WP_PARS -> EXP -> STMT CASE_ALTERNATIVE -> RESULT  
=DESCRIBE
=ENDDOC


ÿCase_Stepüüüüüüüüüüüü
Ü	Case;
Ü	Case_Alternative[Stmt];
Ü	Case'
÷üüüüüüüüüüüüüü
Ü	E = E';
Ü	s = § Ê(Case_Alternative[Stmt]) ¢ ë s'
ˆüüüüüüüüüüüüüüüüüüüüü

ÿCASE_STEPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Case_Step; Results ·
Ü	st = stmt (case (Ê (Case[Stmt]))) ±
Ü	WP =
Ü	z_elem (trans_exp E, trans_case_choices choices) %Longrightarrow% WP' À WP'' ±
Ü	SIDE = SIDE' À SIDE'' ± Ê Result' = wp (stmt P, A, Ê Wp_Env) ±
Ü	Ê Result'' = wp (stmt (case (Ê Case')), A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcase_stepÝ : WP_PARS -> STMT CASE -> RESULT  
=DESCRIBE
=ENDDOC


Note that $CASE\_STEP$ is recursive and does the full job. 
But by analogy with the naming convention we chose to adopt for the
two case of specification statement in section \ref{wp-specification-no-ivars},
we define the following.

=DOC
val Ûcase_eitherÝ : WP_PARS -> STMT CASE -> RESULT  
=DESCRIBE
=ENDDOC


\subsubsection{Loop}\label{wp-loop}
ÿLOOPüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Loop ·
Ü	st = stmt (loop (Ê Loop)) ± WP = {š ô Pre} ±
Ü	SIDE = { {post} ô Pre } À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val ÛloopÝ : WP_PARS -> STMT LOOP -> RESULT  
val Ûnamed_loopÝ : WP_PARS -> STMT NAMED_LOOP -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{While Loop}\label{wp-while-loop}
ÿWHILEüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ While ·
Ü	st = stmt (while (Ê While)) ±
Ü	WP =
Ü	{ {z_eq(trans_exp G, zid TRUE)} ô Pre} À
Ü	z_eq(trans_exp G, zid FALSE) %Longrightarrow% A ±
Ü	SIDE = post %Longrightarrow% WP À T %Longrightarrow% A
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcn_whileÝ : WP_PARS -> STMT WHILE -> RESULT  
=DESCRIBE
=ENDDOC


=TEX
\subsubsection{For Loop (Values as Bounds)}\label{wp-for-value}

ÿFOR_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Static; Z_Bin_Exp; zi : Z_ID; zlo, zhi : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = stmt (for_static (Ê For_Static)) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (pre, zi, zlo) } À
Ü	z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { zran, z_noteq(zid zi, zhi), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi) %Longrightarrow% A À
Ü	zran %Longrightarrow% (T %Longrightarrow% A) ±
Ü	zran = z_elem (zid zi, z_rng (zlo, zhi)) ±
Ü	zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü	zop = z_add ± zleft = zid zi ± zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûfor_staticÝ : WP_PARS -> STMT FOR_STATIC -> RESULT  
=DESCRIBE
=ENDDOC

ÿFOR_TMARKüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Tmark; Z_Bin_Exp; zi : Z_ID; zlo, zhi : Z_EXP;
Ü	zran : Z_PRED ·
Ü	st = stmt (for_tmark (Ê For_Tmark)) ±
Ü	WP =
Ü	{ { z_less_eq (zlo, zhi)} ô sub (pre, zi, zlo) } À
Ü	z_greater (zlo, zhi) %Longrightarrow% A ±
Ü	SIDE =
Ü	{ { z_noteq(zid zi, zhi), post } ô
Ü		sub(Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi) %Longrightarrow% A À
Ü	T %Longrightarrow% A ± zi = trans_id i ± zlo = zid (trans_id tmark ^ zfst) ±
Ü	zhi = zid (trans_id tmark ^ zlst) ± zop = z_add ± zleft = zid zi ±
Ü	zright = z_num 1
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûfor_tmarkÝ : WP_PARS -> STMT FOR_TMARK -> RESULT  
=DESCRIBE
=ENDDOC
\subsection{Exit Statement (with Condition)}\label{wp-exit-with-cond}

ÿEXIT_WHENüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Exit_When ·
Ü	st = stmt (exit_when (Ê Exit_When)) ±
Ü	WP =
Ü	{ { z_eq (trans_exp G, zid TRUE) } ô till} À
Ü	z_eq (trans_exp G, zid FALSE)  %Longrightarrow% A ± SIDE = š
ˆüüüüüüüüüüüüüüüüü


=DOC
val Ûexit_whenÝ : WP_PARS -> EXIT_WHEN -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Exit}\label{wp-exit}

ÿEXITüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   st = stmt exit;
Ü	WP = { š ô till };
Ü	SIDE= š
ˆüüüüüüüüüüüüüüüüüüüüü

=TEX
As a reminder to implementers of a real-life version, the following avoids computing $trans\_exp\,G$ twice.
=DOC
val Ûcn_exitÝ : WP_PARS -> RESULT  
=DESCRIBE
=ENDDOC
\subsubsection{Return}\label{wp-return}
¹ZAX
Ü	make_fun_call : Informal_Fun ­ Z_EXP
°
ÿRETURNüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Return ·
Ü	st = stmt (ret (Ê Return)) ±
Ü	WP = { { z_eq (z_fun_call (Ê Z_Fun_Call), trans_exp E) } ô return } ±
Ü	SIDE = š ± fun_header = Ê Informal_Fun ±
Ü	zfun = zid (trans_id name) ±
Ü	zargs = { i : dom formal_pars · i ízid (trans_id (formal_pars i).var) }
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûcn_returnÝ : WP_PARS -> RETURN -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Procedure Call (No Initial Variables in Spec)}\label{wp-proc-call-no-ivars}

¹ZAX
Ü	proc_call_spec : (Proc_Call ¸ Formal_Proc) ß Spec
°

=DOC
val Ûproc_call_specÝ : CN_ENV -> (AGG_CHOICE, EXP) PROC_CALL -> FORMAL_PROC -> Z_EXP * Z_EXP  
=DESCRIBE
=ENDDOC

ÿPROC_CALL_NO_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call; fp : Formal_Proc ·
Ü	st = stmt (proc_no_ivars pc) ±
Ü	Ê Result =
Ü	wp (stmt (spec_no_ivars (proc_call_spec (pc, fp))), A, Ê Wp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü
Contextual errors may need to be reported in the implementation of the above.
An exception is declared for the purpose.
=SML
=TEX
Like the implementation of $make\_fun\_call$ above the following is another simplistic approximation/guess.
It is assumed that the caller will have supplied the correct $Formal\_Proc$ from the environment.
The formals and actuals must agree in number, and the library function $combine$, which turns a pair of equal length lists into a list of pairs, will raise the exception $Fail$ if they do not.


The relevant formal procedure may not be in the environment here.
The library function $find$ will raise the exception $Fail$ if this is the case.

=DOC
val Ûproc_call_no_ivarsÝ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Specification (With Initial Variables)}\label{wp-spec-ivars}

ÿSPEC_IVARSüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Spec_Ivars; q : Stmt; Result' ·
Ü	st = spec_ivars (Ê Spec_Ivars, q) ± WP = {š ô Pre} ±
Ü	SIDE = post %Longrightarrow% WP' À SIDE' ±
Ü	Ê Result' = wp (stmt q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûspec_ivarsÝ : WP_PARS -> (Z_EXP * Z_EXP) * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{For Loop (Bounds with Variables)}\label{wp-for-var}
ÿFOR_NON_STATICüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ For_Non_Static; Z_Bin_Exp; q : Stmt; Result'; zi : Z_ID;
Ü	zlo, zhi, zlo‰0, zhi‰0 : Z_EXP; zran : Z_PRED ·
Ü		st = for_non_static (Ê For_Non_Static, q) ±
Ü		WP =
Ü		{ {z_less_eq (zlo, zhi)} ô  sub (Pre, zi, zlo)} À
Ü		z_greater (zlo, zhi) %Longrightarrow% WP' ±
Ü		SIDE =
Ü		{ { zran, z_noteq (zid zi, zhi‰0), post} ô
Ü			sub (Pre, zi, z_bin_exp (Ê Z_Bin_Exp))} À
Ü		sub(post, zi, zhi‰0) %Longrightarrow% WP' À zran %Longrightarrow% (T %Longrightarrow% A) À
Ü		SIDE' ± ÊResult' = wp(stmt q, A, ÊWp_Env) ±
Ü		zi = trans_id i ± zlo = trans_exp lo ± zhi = trans_exp hi ±
Ü		zop = z_add ± zleft = zid zi ± zright = z_num 1 ±
Ü		zlo‰0 = subs_exp (zlo, w, w‰0) ±
Ü		zhi‰0 = subs_exp (zhi, w, w‰0) ±
Ü		zran = z_elem (zid zi, z_rng (zlo‰0, zhi‰0))
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûfor_non_staticÝ : WP_PARS -> FOR_NON_STATIC * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Logical Constant}\label{wp-log-con}
ÿÛLOG_CONÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ Log_Con; q : Stmt; Result' ·
Ü	st = log_con (Ê Log_Con, q) ± WP = {š ô sub(pre‰1, X, E)} ±
Ü	SIDE =
Ü	z_eq(zid X, subs_exp(E, w, w‰0)) %Longrightarrow% (post %Longrightarrow% WP') ÀSIDE' ±
Ü	Ê Result' = wp (stmt q, A, ÊWp_Env)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûanalyse_log_conÝ : Z_PRED -> Z_EXP * Z_PRED  
=DESCRIBE
=ENDDOC

=DOC
val Ûlog_conÝ : WP_PARS -> LOG_CON * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsubsection{Procedure Call (Initial Variables in Spec)}\label{wp-proc-call-ivars}

ÿÛPROC_CALL_IVARSÝüüüüüüüüüüüü
Ü	Pars
÷üüüüüüüüüüüüüü
Ü   ¶ pc : Proc_Call_Ivars; q : Stmt; fp : Formal_Proc ·
Ü	st = proc_ivars(pc, q) ±
Ü	Ê Result =
Ü	wp (spec_ivars (proc_spec (pc, fp), q), A, ÊWp_Env) ±
Ü	fp  formal_procs ± fp.name = pc.name
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
val Ûproc_call_ivarsÝ : WP_PARS -> (AGG_CHOICE, EXP) PROC_CALL * STMT -> RESULT  
=DESCRIBE
=ENDDOC

\subsection{$wp$}\label{wp}
In Z, $wp$ is now defined by the following axiom:
¹Z
Ü	µPars·
Ü		wp (st, A, ÊWp_Env) = Ê Result ¤
Ü			NULL ² SIMPLE_ASSIGN ² ARRAY_ASSIGN ² RECORD_ASSIGN ²
Ü			SPEC_NO_IVARS ² SPEC_NO_IVARS_EMPTY ² SEMICOLON ²
Ü			IF_THEN_ELSE ² CASE_BASE ² CASE_STEP ² LOOP ² WHILE ²
Ü			FOR_STATIC ² FO_TMARK ² EXIT_WHEN ² EXIT ² RETURN ²
Ü			PROC_CALL_NO_IVARS ² FOR_NON_STATIC ² SPEC_IVARS ²
Ü			LOG_CON ² PROC_CALL_IVARS
°

=DOC
val ÛwpÝ : STATEMENT * SEQUENT list * WP_ENV -> RESULT  
=DESCRIBE
=ENDDOC

=TEX
\pagebreak
\section{VERIFICATION CONDITIONS}
¹Z
Ü	ÛFLAGÝ ::= ÛTrueÝ | ÛFalseÝ
°

ÿÛIn_ScopeÝüüüüüüüüüüüü
Ü	vc_vars : ð Var_Decl;
Ü	vc_pars : ð Param_Spec;
Ü	vc_log_cons : ð Z_Decl;
Ü	formal_procs : ð Formal_Proc;
Ü	dec_labels : ð LABEL
ˆüüüüüüüüüüüüüüüüüüüüü
ÿÛSpeclabÝüüüüüüüüüüüü
Ü	Spec;
Ü	formal_body_flag, fun_flag, till_flag : FLAG;
Ü	Wp_Env;
Ü	In_Scope
ˆüüüüüüüüüüüüüüüüüüüüü

¹ZAX
Ü	Ûvc_local_declsÝ : (ð Sequent ¸ Speclab) ­ ð VC
°
The above function is described informally in reasonable detail in \cite{DRA/CIS/CSE3/SWI/WP/1}.
¹ZAX
Ü	ÛvcsÝ : (Speclab ¸ Statement) ­ ð VC
÷üüüüüüüüüüüüüüüüüüüü
Ü	µ Speclab; st : Statement ·
Ü		¶ Result; WP‰1, s : ð Sequent ·
Ü			vcs (Ê Speclab, st) = vc_local_decls (s, Ê Speclab) ±
Ü			s = Pre %Longrightarrow% WP‰1 À subs_pred(Pre, w, w‰0) %Longrightarrow% SIDE ±
Ü			ÊResult = wp (st, {š ô post}, Ê Wp_Env) ±
Ü			WP‰1 =
Ü			{ Sequent | H ô c  WP · H ô subs_pred (c, w‰0, w)}
°
We use the built-in type of booleans for flags and take it that $DEC\_LABEL$s may be represented as strings.
=SML
=TEX
$Speclab$ is the first schema we have had to accomodate in which included schema have overlapping signatures ($In\_Scope$ and $Wp\_Env$ share the component $formal\_procs$
How this situation is handled in Standard ML is probably best decided from case to case.
Here we choose to precede as if a schema like $In\_Scope$ but with the common component removed had been used instead.
=SML
=TEX
Retrieving the declaration of a function from the function header is not done in the following simplistic approximation to the real $vc\_local\_decls$.
=DOC
val Ûvc_local_declsÝ : SEQUENT list * SPECLAB -> VC list  
=DESCRIBE
=ENDDOC
=DOC
val ÛvcsÝ : SPECLAB * STATEMENT -> VC list
=DESCRIBE
=ENDDOC

\section{EPILOGUE}

=SML
end (* local...in *);
end (* signature CNBasicDeclsAndExprs *);
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



