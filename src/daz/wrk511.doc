% @(#) 96/01/10 1.2 wrk511.doc
=TEX
\documentstyle[hol1,11pt,TQ,hyperbasics]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Report on Proofs of SHOLIS VCs}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/WRK511}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthors{R.D.~Arthan &WIN01\\G.M.~Prout&WIN01}
%\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{%
As part of the requirements analysis for proof tools for the Compliance Notation, an attempt has been made to prove a set of VCs supplied by DRA.
This document reports on that aspect of the work.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\listoftables
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}
\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1 
] Initial Draft.
\end{description}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document reports on a the attempt on proving the SHOLIS VCs called for in \cite{ISS/HAT/DAZ/PLN010,ISS/HAT/DAZ/PLN012}.
\subsection{Introduction}
As part of the requirements analysis for proof tools for the Compliance Notation, an attempt has been made at proving the VCs arising from one package from the SHOLIS development.

The method adopted was to load up the Z document supplied with the ITT \cite{CSM/235} and then to attempt to prove the VCs with a view to identifying important issues.
Some prototyping of {\em ad hoc} tactics to discharge the more trivial VCs was also carried out and of more general tools which were found useful.

\begin{description}
\item[Section \ref{PROGRESS}] reports on the progress made with proofs.
\item[Section \ref{DISCUSSION}] summarises what was learnt from the proof attempts.
\item[Section \ref{RECOMMENDATIONS}] gives some recommendations for future work on proof procedures.
\end{description}

\section{PROGRESS WITH THE PROOFS}\label{PROGRESS}
\subsection{Process}
The work began by loading the Z document supplied with the ITT.
The Z document required only one modification, namely to comment out the line which makes a new parent of the cache theory for the database in which the Z document was created.

Proofs of the VCs were then attempted in turn with a view to identifying important issues.
It was found that many of the VCs permit proofs following some very simple common patterns. E.g., many of the VCs are universally quantified tautologies or become such after simple transformations.
{\em Ad hoc} tactics were written to automate these proofs and these were able to discharge 28 of the 62 VCs automatically.

Since the Z document had been prepared using version 0.5 of the tool, which does not include the enhanced treatment of SPARK record aggregates.
Initially, any $\mu$ expressions arising from record aggregates were translated manually into the new binding display format.
When the original literate script was made available, a new Z document was generated using the version 0.6 tool.
Subsequent proof work concentrated on the new VCs (which were found to differ from the original ones only in respect of the changed treatment of record aggregates).

$vc702\_2$ was found to be unprovable. This seemed to come from leaving the brackets out of two predicates of the form
=INLINEFT
Inv ± (A ¤ B)
=TEX
\ in the corresponding specification statement.
Inserting the missing brackets made the VC provable (without making the other VCs affected by the change unprovable).

$vc902\_2$ was also found to be unprovable. Again, this seemed to have arisen from missing brackets. In this case, leaving the brackets out of an arithmetic expression ofthe form
=INLINEFT
(x - y) + z
=TEX
\ in the corresponding specification statement.
As before, inserting the missing brackets made the VC provable (without making the other VCs affected by the change unprovable).

$vc120704\_2$ is believed to be unprovable.  This VC arises from the
first step in refining the body of a for-loop, with loop parameter
$ATYPE$, in the $ACCEPTALARM$ procedure.
 
The loop is intended to make all components of the arrays $STATE$ and
$TIMERS$ satisfy a certain predicate (given by renaming the conjunction
of the schemas $FirstAcceptance$, $NoAcceptance$ and
$InactiveAcceptance$).
 
The pre-condition for the refinement of the loop body requires that the
$ATYPE$-th components of the arrays should not have been changed by
earlier iterations and that the values of the arrays before execution
of the loop should have satisfied a certain condition.  The
pre-condition gives no information about any components of the arrays
on the current iteration other than the $ATYPE$-th ones.
 
The post-condition insists that only the $ATYPE$-th components of the
arrays should have changed and that the desired condition should now
hold of the $ATYPE$-th components.  The post-condition does not require
that the desired condition hold for the  components which have been
processed on previous iterations, nor is this implied by the
pre-condition.
 
The pre- and post-conditions seem therefore to make true statements
which are too weak for the resulting VCs to be provable.  It seems
plausible that the proofs would go through if this step were simply
skipped, i.e., if the loop body were refined directly to code.
However, this adjustment to the script has not been attempted.
 


\subsection{The Proofs}
In order to prove the VCs, two classes of auxiliary lemmas are required. The first class comprises general purpose lemmas, described in section \ref{GENPUR}, and the second class comprises application specific lemmas, described in section \ref{APPSPEC}. 

An attempt has been made to classify the 61 VC proofs as follows:

\begin{tabular}{llp{5in}}
{\bf Class} & {\bf Number} & {\bf Description} \\
& &\\
{\bf A} & 28 & Can be proved automatically. \\
{\bf B} & 9 & Straightforward to prove manually. Automatic proof typically fails either because stripping needs to be carefully controlled, or because linear arithmetic is required. No expansion of specification definitions needed. Auxiliary results not required. \\
{\bf C} & 15 & May require top level unwinding,  but in-depth understanding of specification not necessary. Auxiliary results usually required. \\
{\bf D} & 9 & More subtle unwinding necessary. Auxiliary results required. \\
\end{tabular}

A summary of the 61 VC proofs with respect to this classifiction is given in the the following two tables:



\begin{table}[p]
\begin{center}
\begin{tabular}{|l|l|p{5in}|}\hline
{\bf VC	}		& {\bf Class}&	{\bf Comments} \\\hline\hline
$vc501\_1$		& C	& Defn of $DisplayAttribute$	 \\\hline
$vc501\_2$		& C	& Defn of $DisplayAttribute$	 \\\hline
$vc501\_3$		& C	& Defn of $DisplayAttribute$	 \\\hline
$vc701\_1$		& B	& Range $First..First -1$ invalid\\\hline
$vc701\_2$		& A	& \\\hline
$vc701\_3$		& A	& \\\hline
$vc701\_4$		& A	& \\\hline
$vc702\_1$		& C	& Defns	 of $AudioVisualFlashAlarms$, $TimerInvariant$ \\\hline
$vc702\_2$		& C	& Defns	 of $AudioVisualFlashAlarms$, $TimerInvariant$	 \\\hline
$vc807\_1$		& D	& {\parbox {5.0in}{\raggedright Defns of $RaiseAlarm$, $AudioVisualFlashAlarms$, $TimerInvariant$, $WithinTimeoutAlarms$, $TimedOutAlarms$ }}	 \\\hline
$vc807\_2$		& D	& {\parbox {5.0in}{\raggedright Defns of $RaiseAlarm$, $InactiveAlarms$, $WithinTimeoutAlarms$, $TimerInvariant$, $AudioVisualFlashAlarms$, $TimedOutAlarms$	}} \\\hline
$vc807\_3$		& D	& {\parbox {5.0in}{\raggedright Defns of $RaiseAlarm$, $InactiveAlarms$, $WithinTimeoutAlarms$, $VisualFlashAlarms$, $AudioVisualFlashAlarms$, $TimedOutAlarms$	}} \\\hline
$vc807\_4$		& D	& {\parbox {5.0in}{\raggedright Defns of $RaiseAlarm$, $InactiveAlarms$, $WithinTimeoutAlarms$, $TimerInvariant$, $TimedOutAlarms$}}	 \\\hline
$vc901\_1$		& A	& 	 \\\hline
$vc901\_2$		& D	& {\parbox {5.0in}{\raggedright Defn of $TimeoutAlarm$; reasoning about $intmod$; numerical values in spec are significant }}	 \\\hline
$vc902\_1$		& C	& Defns of $TimedOutAlarms$, $WithinTimeoutAlarms$ \\\hline
$vc902\_2$		& C	& Defn of $WithinTimeoutAlarms$; numerical values in spec are significant	 \\\hline
$vc1001\_1$		& B	& Conjecture sames as $vc1501\_1$	 \\\hline
$vc11\_1$		& B	& Range $First..First -1$ invalid	 \\\hline
$vc11\_2$		& A	& 	 \\\hline
$vc11\_3$		& A	& 	 \\\hline
$vc11\_4$		& A	& 	 \\\hline
$vc1101\_1$		& D	& Defn of $InactiveAlarms$; need to split $x\ \ a..b$ into $x\  a..b-1\ ²\ x\ =\ b$\\\hline
$vc1202\_1$		& A	& 	 \\\hline
$vc1202\_2$		& B	& Variable elimination required	 \\\hline
$vc1203\_1$		& A	& 	 \\\hline
$vc1203\_2$		& B	& Variable elimination required	 \\\hline
$vc1204\_1$		& A	& 	 \\\hline
$vc1204\_2$		& B	& Stripping needs to be carefully controlled	 \\\hline
$vc1204\_3$		& A	& 	 \\\hline
$vc1205\_1$		& B	& Range $First..First -1$ invalid	 \\\hline
$vc1205\_2$		& A	& 	 \\\hline
$vc1205\_3$		& A	& 	 \\\hline
$vc1205\_4$		& A	& 	 \\\hline
\end{tabular}

\end{center}
\caption{Proof Summary I}\label{tab1}
\end{table}


\begin{table}[p]
\begin{center}
\begin{tabular}{|l|l|p{5in}|}\hline
{\bf VC	}		& {\bf Class}&	{\bf Comments} \\\hline\hline
$vc120501\_1$		& C	& Defn of $NonAcceptedAlarms$	 \\\hline
$vc120501\_2$		& C	& Defn of $NonAcceptedAlarms$	 \\\hline
$vc1206\_1$		& A	& 	 \\\hline
$vc1206\_2$		& B	& Stripping needs to be carefully controlled	 \\\hline
$vc1206\_3$		& A	& 	 \\\hline
$vc1206\_4$		& A	& 	 \\\hline
$vc1207\_1$		& A	& 	 \\\hline
$vc1207\_2$		& C	& Defns of $SecondAcceptance$, $AcceptAlarm$	 \\\hline
$vc120701\_1$		& A	& 	 \\\hline
$vc120701\_2$		& A	& 	 \\\hline
$vc120701\_3$		& A	& 	 \\\hline
$vc120702\_1$		& A	& 	 \\\hline
$vc120702\_2$		& A	& 	 \\\hline
$vc120703\_1$		& B	& Range $First..First -1$ invalid	 \\\hline
$vc120703\_2$		& A	& 	 \\\hline
$vc120703\_3$		& A	& 	 \\\hline
$vc120703\_4$		& A	& 	 \\\hline
$vc120704\_1$		& C	& Defn of $ALARMTYPE$	; auxiliary results not used \\\hline
$vc120705\_1$		& D	& {\parbox {5.0in}{\raggedright Defns of $InactiveAcceptance$, $NoAcceptance$, $FirstAcceptance$, $NonAcceptedAlarms$, $AcceptedAlarm$, $AudioVisualFlashAlarms$, $WithinTimeoutAlarms$, $InactiveAlarms$}}	 \\\hline
$vc120705\_2$		& D	& {\parbox {5.0in}{\raggedright Defns of $InactiveAcceptance$, $NoAcceptance$, $FirstAcceptance$, $NonAcceptedAlarms$, $AcceptedAlarm$, $AudioVisualFlashAlarms$, $WithinTimeoutAlarms$, $InactiveAlarms$}}	 \\\hline
$vc120705\_3$		& D	& {\parbox {5.0in}{\raggedright Defns of $InactiveAcceptance$, $NoAcceptance$, $FirstAcceptance$, $NonAcceptedAlarms$, $AcceptedAlarm$, $AudioVisualFlashAlarms$, $WithinTimeoutAlarms$, $InactiveAlarms$}}	 \\\hline
$vc120705\_4$		& C	& {\parbox {5.0in}{\raggedright Defns of $InactiveAcceptance$, $NoAcceptance$, $FirstAcceptance$, $NonAcceptedAlarms$, $AcceptedAlarm$, $AudioVisualFlashAlarms$, $WithinTimeoutAlarms$, $InactiveAlarms$; auxiliary results not used}}	 \\\hline
$vc1208\_1$		& A	& 	 \\\hline
$vc1208\_2$		& C	& {\parbox {5.0in}{\raggedright Defns of $FirstAcceptance$, $SecondAcceptance$, $InactiveAcceptance$, $AcceptedAlarms$, $NonAcceptedAlarm$, $InactiveAlarms$ $AudioVisualFlashAlarms$, $WithinTimeoutAlarms$; auxiliary results not used}}	 \\\hline
$vc120801\_1$		& A	& 	 \\\hline
$vc120801\_2$		& C	& {\parbox {5.0in}{\raggedright Defns of $SecondAcceptance$, $InactiveAcceptance$; auxiliary results not used}}	 \\\hline
$vc1501\_1$		& C	& Defns of $InactiveAlarms$	 \\\hline

\end{tabular}

\end{center}
\caption{Proof Summary II}\label{tab2}
\end{table}

\newpage
\subsection{General Purpose Lemmas} \label {GENPUR}
The 22 lemmas described in this section are general purpose results that arise from particular SPARK constructs. They fall into four groups:
\begin{itemize}
\item
Results about override, $«$
\item
Results about 
=INLINEFT
not True
=TEX
\item
Results about $intmod$
\item
Results about 
=INLINEFT
X ¸ {y}
=TEX
\end{itemize}
\subsubsection{Override Lemmas}\label{OVER}
The occurrence of functional overrides in the VCs arise from SPARK array assignments. Eight lemmas have been proven, 
=INLINEFT
«_lemma1 to «_lemma8
=TEX
\ For example:
=GFT
«_lemma4
ô [X,Y,Z](µ f : X ­ Y ­ Z; x : X; y : Y; z : Z
    · (f « {x í f x « {y í z}}) x y = z)
=TEX
is used in the proof of $vc807\_1$ to verify that

=GFT
(STATE
                  « {DISPLAY
                        í STATE DISPLAY
                            « {ATYPE
                                  í (LEVEL ¦ AUDIOVISUALFLASH, RAISED ¦ Boolean true,
                                      REOCCURS ¦ NORESET)}})
		DISPLAY ATYPE =
	(LEVEL ¦ AUDIOVISUALFLASH,RAISED ¦ TRUE, REOCCURS ¦ NORESET)
=TEX
where $STATE$ is an $ALARMSTATE$, $DISPLAY$ is of type $BASICTYPESoDISPLAYPOSITION$ and $ATYPE$ is an $ALARMTYPE$.
\subsubsection{not TRUE}\label{NT}
Two lemmas, $bool\_lemma1$ and $bool\_lemma2$ are provided.
\ For example:
=GFT
bool_lemma1
ô µ X : BOOLEAN · not X = Boolean true ´ X = Boolean false    
=TEX
There are many cases in the proofs where the fact that
\newline
=INLINEFT
not (STATE DISPLAY ATYPE).RAISED = FALSE
=TEX
\ is equivalent to 
\newline
=INLINEFT
(STATE DISPLAY ATYPE).RAISED = TRUE
=TEX
\newline
is required. The compliance tool is unable to deduce this because it requires unwinding of definitions to demonstrate that 
\newline
=INLINEFT
(STATE DISPLAY ATYPE).RAISED  BOOLEAN.
=TEX
\newline
$bool\_lemma1$ is used in conjuction with this membership result to achieve the desired equivalence.
\subsubsection{Intmod Lemmas}
The proof of $vc901\_2$ requires reasoning about $intmod$, used in the specification of $TimeoutAlarm$. There are 8 lemmas in this group:
\begin{itemize}
\item
$mod\_lemma1$
\item
$mod\_lemma2$
\item
$¼\_times\_zero\_lemma$
\item
$minus\_times\_zero\_lemma$
\item
$intmod\_mod\_lemma1$
\item
$intmod\_mod\_lemma2$
\item
$intmod\_lemma1$
\item
$intmod\_lemma2$
\end{itemize}
The first 6 of the above are  subsidiary results used to prove the two main lemmas of this section:
=GFT
intmod_lemma1
ô µ i : î; j : î · j > i ´ i intmod j = i    
intmod_lemma2
ô µ i : ú; j : î · i < 0 ± j > ~ i ´ i intmod j = j + i   
=TEX
They are used directly in the proof of $vc901\_2$ which consists essentially of a case analysis on 
=GFT
CURRENTTIME - (TIMERS DISPLAY ATYPE).TIMEOUT ¾ 0
²
CURRENTTIME - (TIMERS DISPLAY ATYPE).TIMEOUT < 0
=TEX
\subsubsection{Singleton Set Lemmas}
There are four results in this section:
\begin{itemize}
\item
$¸\_singleton\_fun\_lemma$
\item
$singleton\_¸\_fun\_lemma$
\item
$¸\_singleton\_app\_lemma$
\item
$singleton\_¸\_app\_lemma$
\end{itemize}
For example:
=GFT
singleton_¸_fun_lemma
ô µ x : U; y : U; z : U · {x} ¸ {y}  {x} ­ z ¤ y  z   
=TEX
The need for these lemmas arises from the use of the SPARK constructs Array Aggregates in the Package Initialisation ($vc1501\_1$) and Resetting Alarms  ($vc1001\_1$).

 
\subsection{Application Specific Lemmas} \label {APPSPEC}
All the 13 results in this section are application specific.  They are proven as separate lemmas either because they are results that are found to be needed repeatedly during the process of proving the VCs, or because proving them in isolation is simpler than proving them in the context of a VC proof. The lemmas have been named to correspond to a VC, but this is simply the first VC encountered that requires that partiular subsidiary result. For example, $vc501\_lemma$ is the lemma mentioned in section \ref{NT} that asserts a particular membership of $BOOLEAN$. This lemma is first used in the proof of VC $vc501\_1$, but is also used many times over in subsequent VC proofs.

The lemmas in this section fall into 3 main groups:
\begin{itemize}
\item
Set Membership of Record Fields
\item
Enumeration Types
\item
Specific Record a Member of a Record Set
\end{itemize}
These groups are discussed below. In addition, there is one lemma about singleton sets that is application specific in the sense that it contains actual values which are relevant to the application specification:
=GFT
vc1501_1_lemma
µ y : U; z : U · 0 .. 2 ¸ {y}  0 .. 2 ­ z ¤ y  z 
=TEX
\subsubsection{Set Membership of Record Fields}
The three lemmas:
\begin{itemize}
\item
$vc501\_lemma$
\item
$vc807\_lemma2$
\item
$vc901\_lemma$
\end{itemize}

are of the form
=INLINEFT
(STATE DISPLAY ACTIVE).field  set
=TEX
\ where the types of $STATE$, $DISPLAY$ and $ACTIVE$ are as in section\ref{OVER}. For example: 
=GFT
vc501_lemma
ô µ s : ALARMSTATE; d : BASICTYPESoDISPLAYPOSITION; a : ALARMTYPE
    · (s d a).RAISED  BOOLEAN 
=TEX
This result is used with $bool\_lemma1$ and $bool\_lemma2$, as described in section \ref{NT}, to provide results of the form
=INLINEFT
Not X:BOOLEAN = TRUE ´ X=FALSE
=TEX

These set memberships arise from indexing into an array of records in SPARK. 
\subsubsection{Enumeration Types}
The three lemmas:
\begin{itemize}
\item
$vc807\_lemma2$
\item
$vc807\_lemma3$
\item
$vc807\_lemma4$
\end{itemize}
provide results about the enumeration types $ALARMLEVEL$ and $ALARMRESET$. For example:
=GFT
vc807_lemma3;
val it = ô µ s : ALARMSTATE; d : BASICTYPESoDISPLAYPOSITION; a : ALARMTYPE
    · ³ (s d a).REOCCURS = RESET ´ (s d a).REOCCURS = NORESET : THM
=TEX
This result is needed when unwinding the definitions in the proof of $vc807\_3$. 
\subsubsection{Record a Member of Record Set}
There are six lemmas in this group 
\begin{itemize}
\item
$vc807\_lemma5$
\item
$vc807\_lemma6$
\item
$vc902\_lemma1$
\item
$vc902\_lemma2$
\item
$vc1101\_lemma$
\item
$vc120705\_lemma$
\end{itemize}

For example:
=GFT
vc807_lemma5
ô (LEVEL ¦ AUDIOVISUALFLASH, RAISED ¦ Boolean true,
        REOCCURS ¦ NORESET)
     ALARMDATA
=TEX
and
=GFT
vc902_lemma1
ô µ s : ALARMSTATE; d : BASICTYPESoDISPLAYPOSITION; a : ALARMTYPE
    · (LEVEL ¦ (s d a).LEVEL, RAISED ¦ (s d a).RAISED, REOCCURS ¦ RESET)
       ALARMDATA 
=TEX
These lemmas are used in conjunction with the override lemmas.   For example, in order to apply $«\_lemma4$ in the proof of $vc807\_1$, as described in  section \ref{OVER}, it is necessary to prove that the $z$, i.e. 
=INLINEFT
(LEVEL ¦ AUDIOVISUALFLASH, RAISED ¦ Boolean true, REOCCURS ¦ NORESET)
=TEX
\ is indeed of type $Z$, i.e.
=INLINEFT
ALARMDATA.
=TEX

The SPARK construct which gives rise to these forms is assignment to an array of records.

\section{DISCUSSION}\label{DISCUSSION}
\section{RECOMMENDATIONS} \label{RECOMMENDATIONS}
\end{document}
=IGN

