%  mdt061.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Parser}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT061}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Z parser described in the document
DS/FMU/IED/DTD061.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[issue \SCCSissue~\FormatDate{$Date$%
}]
First draft

\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the parser as specified in \cite{DS/FMU/IED/DTD061}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Z parser
as defined in \cite{DS/FMU/IED/DTD061} and implemented
in \cite{DS/FMU/IED/IMP061}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{TEST CASES}
\begin{description}
\item[ZParser.1] In this group of tests an instance of each alternative in the
grammar of \cite{DS/FMU/IED/DEF007}
is parsed and the form of the result is checked.
If an alternative contains an optional construct, then a form with and a form
without that construct are checked. Similarly an iterated construct is
checked with 0, 1 and 2 occurrences.
\item[ZParser.2] This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
It is further subdivided as follows:
\begin{description}
\item[ZParser.2.1] This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
\item[ZParser.2.2] This subgroup tests the relative precedences and
association rules of fancy-fix operators.
\item[ZParser.2.3] This subgroup tests the remaining rules about
expressions.
\end{description}
Note that some of the rules just say that in such and such a production
such and such a constituent must have some property, the tests
against these rules are in group $ZParser.4$.
\item[ZParser.3] This group of tests the differences between extended and
standard Z.
\item[ZParser.4] This group of tests exhibits the reachable error
messages.
\end{description}
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
open_theory "hol" handle (Fail _) => open_theory "misc";
new_theory"test_mdt061";
init_mt_results();
open ZParser ZUserInterfaceSupport ZLex;
=TEX
The following code is a modification of
what appears in the parser interface, see \cite{DS/FMU/IED/IMP022}, and
causes HOL term quotations to evaluate to the corresponding stream
of lexical tokens. N.B. we use the HOL quotation form, not the Z form
so that the tests may be run independently of the Z paragraph processor of
\cite{DS/FMU/IED/DTD064}.
=SML
fun HOL_term_recogniser (_, _, x, _) = ZLex.zlex  x;
=TEX
The following code sets up some useful values and utilities:
=SML
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
=SML
fun para_eq (p1 : Z_PARA, p2 : Z_PARA) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun tm_eq (p1 : Z_TM, p2 : Z_TM) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun id_of_string s = (template_of_string s, "") : IDENT;
fun z_tm_of_string s = ZTmLVar(id_of_string s, Nil, []);
val a = z_tm_of_string "a";
val b = z_tm_of_string "b";
val c = z_tm_of_string "c";
val p = z_tm_of_string "p";
val P = z_tm_of_string "P";
val Q = z_tm_of_string "Q";
val X = z_tm_of_string "X";
val Y = z_tm_of_string "Y";
fun para_of_string s = ZParaTerm([], z_tm_of_string s, Nil);
val zeq = (template_of_string "_ = _", "") : IDENT;
val zmem = (template_of_string "_  _", "") : IDENT;
val zneq = (template_of_string "_ ½ _", "") : IDENT;
val znmem = (template_of_string "_  _", "") : IDENT;
val zplus = (template_of_string "_ + _", "") : IDENT;
val zif = (template_of_string "if _ then _ else _", "") : IDENT;
val zfun = (template_of_string "_ ­ _", "") : IDENT;
val zinj = (template_of_string "_ ß _", "") : IDENT;
val zbag = (template_of_string "û ; ı", "") : IDENT;
fun pair (a, b) = ZTmTuple[a, b];
fun triple (a, b, c) = ZTmTuple[a, b, c];
=TEX
=SML
new_error_message{id= ~61001,
	text="unexpected result from Z Parser detected in module tests"};
fun tp x = (
	case zparser {is_quot = true, standard = false} x of
		ZParaTerm(_, tm, _) => tm
	|	_	=> fail "mdt061" ~61001 []
);
fun sp x = (
	case zparser {is_quot = true, standard = false}
		(ZTLsqbrack :: (rev(tl(rev x))) @ [ZTRsqbrack, ZTEos]) of
		ZParaTerm(_, ZTmHorizSchema([ZSchemaDec (s, Nil)], Nil, Nil), _) => s
	|	_	=> fail "mdt061" ~61001 []
);

val _ = set_zfixity_info (ZClRel, map template_of_string [ "_ = _", "_  _"]);
val _ = set_zfixity_info (ZClRel, map template_of_string [ "_  _", "_ ½ _"]);
val _ = set_zfixity_info (ZClFun 1, map template_of_string [ "if _ then _ else _ "]);
val _ = set_zfixity_info (ZClFun 2, map template_of_string [ "_ + _"]);
val _ = set_zfixity_info (ZClFun 0, map template_of_string [ "û ; ı"]);
val _ = set_zfixity_info (ZClGen 1, map template_of_string [ "_ ­ _"]);
val _ = set_zfixity_info (ZClGen 2, map template_of_string [ "_ ß _"]);
=TEX
\section{THE TESTS}
\subsection{Group 1}
The first block of tests in group 1 checks out the alternatives
for predicate:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.1.1", tp, ¬a ; b®, ZTmLogInOp‰F(ZLogInOpSemi, a , b)),
	("ZParser.1.1.2", tp, ¬µx:Y|Q x·P x ; b®,
			ZTmLogInOp‰F(ZLogInOpSemi, tp ¬µx:Y|Q x·P x® , b)),
	("ZParser.1.1.3", tp, ¬µa·b®,
			ZTmQuant‰F(ZQuantµ, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.4", tp, ¬¶a·b®,
			ZTmQuant‰F(ZQuant¶, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.5", tp, ¬¶‰1a·b®,
			ZTmQuant‰F(ZQuant¶‰1, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.6", tp, ¬a ± b®, ZTmLogInOp‰F(ZLogInOp±, a , b)),
	("ZParser.1.1.7", tp, ¬a ² b®, ZTmLogInOp‰F(ZLogInOp², a , b)),
	("ZParser.1.1.8", tp, ¬a ´ b®, ZTmLogInOp‰F(ZLogInOp´, a , b)),
	("ZParser.1.1.9", tp, ¬a ¤ b®, ZTmLogInOp‰F(ZLogInOp¤, a , b)),
	("ZParser.1.1.10", tp, ¬³ b®, ZTm³‰F b)
,
	("ZParser.1.1.11", tp, ¬a  b®, ZTmFancyApp(zmem, pair (a,b)))
,
	("ZParser.1.1.12", tp, ¬a  b = c®,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zeq, pair (b,c))))),
	("ZParser.1.1.13", tp, ¬a  b ½ c®,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zneq, pair (b,c))))),
	("ZParser.1.1.14", tp, ¬(a  b)®, ZTmBracketed(ZTmFancyApp(zmem, pair (a,b))))
];
=TEX
The second block of tests in group 1 checks out the alternatives
for schema:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.2.1", sp, ¬µa·b®, 
			ZTmQuant‰S(ZQuantµ, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.2", sp, ¬¶a·b®, 
			ZTmQuant‰S(ZQuant¶, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.3", sp, ¬¶‰1a·b®, 
			ZTmQuant‰S(ZQuant¶‰1, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.4", sp, ¬a ± b®, ZTmLogInOp‰S(ZLogInOp±, a , b)),
	("ZParser.1.2.5", sp, ¬a ² b®, ZTmLogInOp‰S(ZLogInOp², a , b)),
	("ZParser.1.2.6", sp, ¬a ´ b®, ZTmLogInOp‰S(ZLogInOp´, a , b)),
	("ZParser.1.2.7", sp, ¬a ¤ b®, ZTmLogInOp‰S(ZLogInOp¤, a , b)),
	("ZParser.1.2.8", sp, ¬a ù b®, ZTmù(a , b)),
	("ZParser.1.2.9", sp, ¬a » b®, ZTm»(a , b)),
	("ZParser.1.2.10", sp, ¬³ a®, ZTm³‰S a),
	("ZParser.1.2.11", sp, ¬pre a®, ZTmPre a),
	("ZParser.1.2.12", sp, ¬„a®, ZTm„ a),
	("ZParser.1.2.13", sp, ¬˜a®, ZTm˜ a),
	("ZParser.1.2.14", sp, ¬(a)'?!®, ZTmDecor(ZTmBracketed a, "'?!")),
	("ZParser.1.2.15", sp, ¬a[b/c]®,
			ZTmRename(a, [(id_of_string "b",id_of_string "c")])),
	("ZParser.1.2.16", sp, ¬[b|c]®,
		ZTmHorizSchema([ZSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.2.17", sp, ¬a\(b)®,
		ZTmHide(a, [id_of_string "b"]))
];
=TEX
The third block of tests in group 1 checks out the two
forms of schema text:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.3.1", sp, ¬[b|c]®,
		ZTmHorizSchema([ZSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.3.2", sp, ¬[b]®,
		ZTmHorizSchema([ZSchemaDec(b, Nil)], Nil, Nil))
];
=TEX
The fourth block of tests in group 1 checks out the various
forms of expression:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.4.1", tp, ¬(Ía)®,
		ZTmÍ1([ZSchemaDec(a, Nil)], Nil, Nil)),
	("ZParser.1.4.2", tp, ¬(Ía|b)®,
		ZTmÍ1([ZSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.3", tp, ¬Ía|b·c®,
		ZTmÍ2(([ZSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.4", tp, ¬Ía·c®,
		ZTmÍ2(([ZSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.5", tp, ¬Ìa|b·c®,
		ZTmÌ(([ZSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.6", tp, ¬Ìa·c®,
		ZTmÌ(([ZSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.7", tp, ¬a + b®,
		ZTmFancyApp(zplus, pair (a,b))),
	("ZParser.1.4.8", tp, ¬if a then b else c®,
		ZTmFancyApp(zif, triple (a,b,c))),
	("ZParser.1.4.9", tp, ¬û ı®,
		ZTmFancyApp(zbag, ZTmTuple[ZTm§¢(Nil, [])])),
	("ZParser.1.4.10", tp, ¬ûaı®,
		ZTmFancyApp(zbag, ZTmTuple[ZTm§¢(Nil, [a])])),
	("ZParser.1.4.11", tp, ¬ûa,b,cı®,
		ZTmFancyApp(zbag, ZTmTuple[ZTm§¢(Nil, [a,b,c])])),
	("ZParser.1.4.12", tp, ¬a ¸ b®, ZTm¸[a,b]),
	("ZParser.1.4.13", tp, ¬a ¸ b ¸ c®, ZTm¸[a,b,c]),
	("ZParser.1.4.14", tp, ¬ğ a®, ZTmğ a),
	("ZParser.1.4.15", tp, ¬a[b]®, ZTmLVar(id_of_string "a", Nil, [b])),
	("ZParser.1.4.16", tp, ¬a[b,c]®, ZTmLVar(id_of_string "a", Nil, [b,c])),
	("ZParser.1.4.17", tp, ¬1001®, ZTmú 1001),
	("ZParser.1.4.18", tp, [ZTAqTm mk_t, ZTEos], ZTmQuotation mk_t),
	("ZParser.1.4.19", tp, ¬(a)®, ZTmBracketed a),
	("ZParser.1.4.20", tp, ¬(a,b)®, pair (a,b)),
	("ZParser.1.4.21", tp, ¬(a,b,c)®, triple (a,b,c)),
	("ZParser.1.4.22", tp, ¬[a|b]®,
		ZTmHorizSchema([ZSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.23", tp, ¬(a¦1, b¦2)®,
		ZTmBinding[(id_of_string "a",ZTmú 1), (id_of_string "b",ZTmú 2)]),
	("ZParser.1.4.24", tp, ¬{}®, ZTmSetd(Nil, [])),
	("ZParser.1.4.25", tp, ¬{a}®, ZTmSetd(Nil, [a])),
	("ZParser.1.4.26", tp, ¬{a,b,c}®, ZTmSetd(Nil, [a,b,c])),
	("ZParser.1.4.27", tp, ¬{a|b}®,
		ZTmSeta1([ZSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.28", tp, ¬{a; b}®,
		ZTmSeta1([ZSchemaDec(a, Nil), ZSchemaDec(b, Nil)], Nil, Nil)),
	("ZParser.1.4.29", tp, ¬{a·b}®,
		ZTmSeta2(([ZSchemaDec(a, Nil)], Nil, Nil), b)),
	("ZParser.1.4.30", tp, ¬{a|b·c}®,
		ZTmSeta2(([ZSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.31", tp, ¬a.b®, ZTmSel‰B(a, id_of_string "b")),
	("ZParser.1.4.32", tp, ¬a.2®, ZTmSel‰T(a, 2))
];
=TEX
\subsection{Group 2}
This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
\subsection{Subgroup 1}
This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
=SML
fun gp2_chk1 (ZTmLogInOp‰S(op1, a1, b1), ZTmLogInOp‰S(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTmù(a1, b1), ZTmù(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTm»(a1, b1), ZTm»(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (t1, ZTmBracketed t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (ZTmBracketed t1, t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (t1, t2) = tm_eq (t1, t2);
=TEX
The first block tests schema conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.1.1", sp, ¬a ± b ² c®, sp ¬(a ± b) ² c® ),
	("ZParser.2.1.1.2", sp, ¬a ± b ´ c®, sp ¬(a ± b) ´ c® ),
	("ZParser.2.1.1.3", sp, ¬a ± b ¤ c®, sp ¬(a ± b) ¤ c® ),
	("ZParser.2.1.1.4", sp, ¬a ± b » c®, sp ¬(a ± b) » c® ),
	("ZParser.2.1.1.5", sp, ¬a ± b ù c®, sp ¬(a ± b) ù c® ),
	("ZParser.2.1.1.6", sp, ¬b ² c ± a®, sp ¬b ² (c ± a)® ),
	("ZParser.2.1.1.7", sp, ¬b ´ c ± a®, sp ¬b ´ (c ± a)® ),
	("ZParser.2.1.1.8", sp, ¬b ¤ c ± a®, sp ¬b ¤ (c ± a)® ),
	("ZParser.2.1.1.9", sp, ¬b » c ± a®, sp ¬b » (c ± a)® ),
	("ZParser.2.1.1.10", sp, ¬b ù c ± a®, sp ¬b ù (c ± a)® )
];
=TEX
The second block tests schema disjunction with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.2.1", sp, ¬a ² b ´ c®, sp ¬(a ² b) ´ c® ),
	("ZParser.2.1.2.2", sp, ¬a ² b ¤ c®, sp ¬(a ² b) ¤ c® ),
	("ZParser.2.1.2.3", sp, ¬a ² b » c®, sp ¬(a ² b) » c® ),
	("ZParser.2.1.2.4", sp, ¬a ² b ù c®, sp ¬(a ² b) ù c® ),
	("ZParser.2.1.2.5", sp, ¬b ´ c ² a®, sp ¬b ´ (c ² a)® ),
	("ZParser.2.1.2.6", sp, ¬b ¤ c ² a®, sp ¬b ¤ (c ² a)® ),
	("ZParser.2.1.2.7", sp, ¬b » c ² a®, sp ¬b » (c ² a)® ),
	("ZParser.2.1.2.8", sp, ¬b ù c ² a®, sp ¬b ù (c ² a)® )
];
=TEX
The third block tests schema implication with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.3.1", sp, ¬a ´ b ¤ c®, sp ¬(a ´ b) ¤ c® ),
	("ZParser.2.1.3.2", sp, ¬a ´ b » c®, sp ¬(a ´ b) » c® ),
	("ZParser.2.1.3.3", sp, ¬a ´ b ù c®, sp ¬(a ´ b) ù c® ),
	("ZParser.2.1.3.4", sp, ¬b ¤ c ´ a®, sp ¬b ¤ (c ´ a)® ),
	("ZParser.2.1.3.5", sp, ¬b » c ´ a®, sp ¬b » (c ´ a)® ),
	("ZParser.2.1.3.6", sp, ¬b ù c ´ a®, sp ¬b ù (c ´ a)® )
];
=TEX
The fourth block tests schema bi-implication with the two others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.4.1", sp, ¬a ¤ b » c®, sp ¬(a ¤ b) » c® ),
	("ZParser.2.1.4.2", sp, ¬a ¤ b ù c®, sp ¬(a ¤ b) ù c® ),
	("ZParser.2.1.4.3", sp, ¬b » c ¤ a®, sp ¬b » (c ¤ a)® ),
	("ZParser.2.1.4.4", sp, ¬b ù c ¤ a®, sp ¬b ù (c ¤ a)® )
];
=TEX
The fourth block tests the two non-logical schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.4.1", sp, ¬a » b ù c®, sp ¬(a » b) ù c® ),
	("ZParser.2.1.4.2", sp, ¬b ù c » a®, sp ¬b ù (c » a)® )
];
=TEX
The fifth block tests the left association rule for schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.5.1", sp, ¬a ± b ± c®, sp ¬a ± (b ± c)® ),
	("ZParser.2.1.5.2", sp, ¬a ² b ² c®, sp ¬a ² (b ² c)® ),
	("ZParser.2.1.5.3", sp, ¬a ´ b ´ c®, sp ¬a ´ (b ´ c)® ),
	("ZParser.2.1.5.4", sp, ¬a ¤ b ¤ c®, sp ¬a ¤ (b ¤ c)® ),
	("ZParser.2.1.5.5", sp, ¬a ù b ù c®, sp ¬a ù (b ù c)® ),
	("ZParser.2.1.5.6", sp, ¬a » b » c®, sptp ¬a » (b » c)® )
];
=SML
fun gp2_chk2 (ZTmLogInOp‰F(op1, a1, b1), ZTmLogInOp‰F(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk2(a1, a2) andalso gp2_chk2(b1, b2)
) | gp2_chk2 (t1, ZTmBracketed t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (ZTmBracketed t1, t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (t1, t2) = tm_eq (t1, t2);
=TEX
The sixth block tests logical conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.6.1", tp, ¬a ± b ² c®, tp ¬(a ± b) ² c® ),
	("ZParser.2.1.6.2", tp, ¬a ± b ´ c®, tp ¬(a ± b) ´ c® ),
	("ZParser.2.1.6.3", tp, ¬a ± b ¤ c®, tp ¬(a ± b) ¤ c® ),
	("ZParser.2.1.6.6", tp, ¬b ² c ± a®, tp ¬b ² (c ± a)® ),
	("ZParser.2.1.6.7", tp, ¬b ´ c ± a®, tp ¬b ´ (c ± a)® ),
	("ZParser.2.1.6.8", tp, ¬b ¤ c ± a®, tp ¬b ¤ (c ± a)® )
];
=TEX
The seventh block tests logical disjunction with the othesr of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.7.1", tp, ¬a ² b ´ c®, tp ¬(a ² b) ´ c® ),
	("ZParser.2.1.7.2", tp, ¬a ² b ¤ c®, tp ¬(a ² b) ¤ c® ),
	("ZParser.2.1.7.3", tp, ¬b ´ c ² a®, tp ¬b ´ (c ² a)® ),
	("ZParser.2.1.7.4", tp, ¬b ¤ c ² a®, tp ¬b ¤ (c ² a)® )
];
=TEX
The eighth block tests logical implication and bi-implication:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.8.1", tp, ¬a ´ b ¤ c®, tp ¬(a ´ b) ¤ c® ),
	("ZParser.2.1.8.2", tp, ¬b ¤ c ´ a®, tp ¬b ¤ (c ´ a)® )
];
=TEX
The ninth block tests the left association rule for logical operators:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.9.1", tp, ¬a ± b ± c®, tp ¬a ± (b ± c)® ),
	("ZParser.2.1.9.2", tp, ¬a ² b ² c®, tp ¬a ² (b ² c)® ),
	("ZParser.2.1.9.3", tp, ¬a ´ b ´ c®, tp ¬a ´ (b ´ c)® ),
	("ZParser.2.1.9.4", tp, ¬a ¤ b ¤ c®, tp ¬a ¤ (b ¤ c)® )
];
=TEX
The tenth block tests the unary schema operators against the
binary schema operators.
=SML
fun gp2_chk4 (ZTmLogInOp‰S(op1, a1, b1), ZTmLogInOp‰S(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTmù(a1, b1), ZTmù(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTm»(a1, b1), ZTm»(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (t1, ZTmBracketed t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmBracketed t1, t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm³‰S t1, ZTm³‰S t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm„ t1, ZTm„ t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm˜ t1, ZTm˜ t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmPre t1, ZTmPre t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (t1, t2) = tm_eq (t1, t2);
=SML
store_mt_results_show (mt_runf gp2_chk4)
[
	("ZParser.2.1.10.1", sp, ¬³ b ² c®, sp ¬(³ b) ² c® ),
	("ZParser.2.1.10.2", sp, ¬³ b ² c®, sp ¬(³ b) ² c® ),
	("ZParser.2.1.10.3", sp, ¬³ b ´ c®, sp ¬(³ b) ´ c® ),
	("ZParser.2.1.10.4", sp, ¬³ b ¤ c®, sp ¬(³ b) ¤ c® ),
	("ZParser.2.1.10.5", sp, ¬³ b » c®, sp ¬(³ b) » c® ),
	("ZParser.2.1.10.6", sp, ¬³ b ù c®, sp ¬(³ b) ù c® ),
	("ZParser.2.1.10.7", sp, ¬„ b ² c®, sp ¬(„ b) ² c® ),
	("ZParser.2.1.10.8", sp, ¬„ b ² c®, sp ¬(„ b) ² c® ),
	("ZParser.2.1.10.9", sp, ¬„ b ´ c®, sp ¬(„ b) ´ c® ),
	("ZParser.2.1.10.10", sp, ¬„ b ¤ c®, sp ¬(„ b) ¤ c® ),
	("ZParser.2.1.10.11", sp, ¬„ b » c®, sp ¬(„ b) » c® ),
	("ZParser.2.1.10.12", sp, ¬„ b ù c®, sp ¬(„ b) ù c® ),
	("ZParser.2.1.10.13", sp, ¬˜ b ² c®, sp ¬(˜ b) ² c® ),
	("ZParser.2.1.10.14", sp, ¬˜ b ² c®, sp ¬(˜ b) ² c® ),
	("ZParser.2.1.10.15", sp, ¬˜ b ´ c®, sp ¬(˜ b) ´ c® ),
	("ZParser.2.1.10.16", sp, ¬˜ b ¤ c®, sp ¬(˜ b) ¤ c® ),
	("ZParser.2.1.10.17", sp, ¬˜ b » c®, sp ¬(˜ b) » c® ),
	("ZParser.2.1.10.18", sp, ¬˜ b ù c®, sp ¬(˜ b) ù c® ),
	("ZParser.2.1.10.19", sp, ¬pre b ² c®, sp ¬(pre b) ² c® ),
	("ZParser.2.1.10.20", sp, ¬pre b ² c®, sp ¬(pre b) ² c® ),
	("ZParser.2.1.10.21", sp, ¬pre b ´ c®, sp ¬(pre b) ´ c® ),
	("ZParser.2.1.10.22", sp, ¬pre b ¤ c®, sp ¬(pre b) ¤ c® ),
	("ZParser.2.1.10.23", sp, ¬pre b » c®, sp ¬(pre b) » c® ),
	("ZParser.2.1.10.24", sp, ¬pre b ù c®, sp ¬(pre b) ù c® )
];
=TEX
\subsection{Subgroup 2}
This subgroup tests the relative precedences and
association rules of fancy-fix operators.
\subsection{Subgroup 3}
This subgroup tests the remaining rules about
expressions.

=TEX
\subsection{Group 3}
This group of tests the differences between extended and
standard Z.
\subsubsection{Group 4}
This group of tests exhibits the reachable error
messages.
=TEX
\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
