%  mdt061.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Parser}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT061}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Z parser described in the document
DS/FMU/IED/DTD061.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[issue \SCCSissue~\FormatDate{$Date$%
}]
First draft

\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the parser as specified in \cite{DS/FMU/IED/DTD061}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Z parser
as defined in \cite{DS/FMU/IED/DTD061} and implemented
in \cite{DS/FMU/IED/IMP061}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{TEST CASES}
\begin{description}
\item[ZParser.1] In this group of tests an instance of each alternative in the
grammar of \cite{DS/FMU/IED/DEF007}
is parsed and the form of the result is checked.
If an alternative contains an optional construct, then a form with and a form
without that construct are checked. Similarly an iterated construct is
checked with 0, 1 and 2 occurrences.
\item[ZParser.2] This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
It is further subdivided as follows:
\begin{description}
\item[ZParser.2.1] This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
\item[ZParser.2.2] This subgroup tests the relative precedences and
association rules of fancy-fix operators.
\item[ZParser.2.3] This subgroup tests the remaining rules about
expressions.
\end{description}
Note that some of the rules just say that in such and such a production
such and such a constituent must have some property, the tests
against these rules are in group $ZParser.4$.
\item[ZParser.3] This group of tests the differences between extended and
standard Z.
\item[ZParser.4] This group of tests exhibits the reachable error
messages.
\end{description}
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
open_theory "hol" handle (Fail _) => open_theory "misc";
new_theory"test_mdt061";
init_mt_results();
open ZParser ZUserInterfaceSupport ZLex;
=TEX
The following code is a modification of
what appears in the parser interface, see \cite{DS/FMU/IED/IMP022}, and
causes HOL term quotations to evaluate to the corresponding stream
of lexical tokens. N.B. we use the HOL quotation form, not the Z form
so that the tests may be run independently of the Z paragraph processor of
\cite{DS/FMU/IED/DTD064}.
=SML
fun HOL_term_recogniser (_, _, x, _) = ZLex.zlex  x;
=TEX
The following code sets up some useful values and utilities:
=SML
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
=SML
fun para_eq (p1 : Z_PARA, p2 : Z_PARA) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun tm_eq (p1 : Z_TM, p2 : Z_TM) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun id_of_string s = (template_of_string s, "") : IDENT;
fun z_tm_of_string s = ZTmLVar(id_of_string s, Nil, []);
val a = z_tm_of_string "a";
val b = z_tm_of_string "b";
val c = z_tm_of_string "c";
val p = z_tm_of_string "p";
val P = z_tm_of_string "P";
val Q = z_tm_of_string "Q";
val X = z_tm_of_string "X";
val Y = z_tm_of_string "Y";
fun para_of_string s = ZParaTerm([], z_tm_of_string s, Nil);
val zeq = (template_of_string "_ = _", "") : IDENT;
val zmem = (template_of_string "_ ç _", "") : IDENT;
val zneq = (template_of_string "_ Ω _", "") : IDENT;
val znmem = (template_of_string "_ é _", "") : IDENT;
val zplus = (template_of_string "_ + _", "") : IDENT;
val zif = (template_of_string "if _ then _ else _", "") : IDENT;
val zfun = (template_of_string "_ ≠ _", "") : IDENT;
val zinj = (template_of_string "_ ﬂ _", "") : IDENT;
val zbag = (template_of_string "˚ ; ˝", "") : IDENT;
fun pair (a, b) = ZTmTuple[a, b];
fun triple (a, b, c) = ZTmTuple[a, b, c];
=TEX
=SML
new_error_message{id= ~61001,
	text="unexpected result from Z Parser detected in module tests"};
fun tp x = (
	case zparser {is_quot = true, standard = false} x of
		ZParaTerm(_, tm, _) => tm
	|	_	=> fail "mdt061" ~61001 []
);
fun sp x = (
	case zparser {is_quot = true, standard = false}
		(ZTLsqbrack :: (rev(tl(rev x))) @ [ZTRsqbrack, ZTEos]) of
		ZParaTerm(_, ZTmHorizSchema([ZSchemaDec (s, Nil)], Nil, Nil), _) => s
	|	_	=> fail "mdt061" ~61001 []
);

val _ = set_zfixity_info (ZClRel, map template_of_string [ "_ = _", "_ ç _"]);
val _ = set_zfixity_info (ZClRel, map template_of_string [ "_ é _", "_ Ω _"]);
val _ = set_zfixity_info (ZClFun 1, map template_of_string [ "if _ then _ else _ "]);
val _ = set_zfixity_info (ZClFun 2, map template_of_string [ "_ + _"]);
val _ = set_zfixity_info (ZClFun 0, map template_of_string [ "˚ ; ˝"]);
val _ = set_zfixity_info (ZClGen 1, map template_of_string [ "_ ≠ _"]);
val _ = set_zfixity_info (ZClGen 2, map template_of_string [ "_ ﬂ _"]);
=TEX
\section{THE TESTS}
\subsection{Group 1}
The first block of tests in group 1 checks out the alternatives
for predicate:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.1.1", tp, ¨a ; bÆ, ZTmLogInOpâF(ZLogInOpSemi, a , b)),
	("ZParser.1.1.2", tp, ¨µx:Y|Q x∑P x ; bÆ,
			ZTmLogInOpâF(ZLogInOpSemi, tp ¨µx:Y|Q x∑P xÆ , b)),
	("ZParser.1.1.3", tp, ¨µa∑bÆ,
			ZTmQuantâF(ZQuantµ, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.4", tp, ¨∂a∑bÆ,
			ZTmQuantâF(ZQuant∂, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.5", tp, ¨∂â1a∑bÆ,
			ZTmQuantâF(ZQuant∂â1, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.6", tp, ¨a ± bÆ, ZTmLogInOpâF(ZLogInOp±, a , b)),
	("ZParser.1.1.7", tp, ¨a ≤ bÆ, ZTmLogInOpâF(ZLogInOp≤, a , b)),
	("ZParser.1.1.8", tp, ¨a ¥ bÆ, ZTmLogInOpâF(ZLogInOp¥, a , b)),
	("ZParser.1.1.9", tp, ¨a § bÆ, ZTmLogInOpâF(ZLogInOp§, a , b)),
	("ZParser.1.1.10", tp, ¨≥ bÆ, ZTm≥âF b)
,
	("ZParser.1.1.11", tp, ¨a ç bÆ, ZTmFancyApp(zmem, pair (a,b)))
,
	("ZParser.1.1.12", tp, ¨a ç b = cÆ,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zeq, pair (b,c))))),
	("ZParser.1.1.13", tp, ¨a ç b Ω cÆ,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zneq, pair (b,c))))),
	("ZParser.1.1.14", tp, ¨(a ç b)Æ, ZTmBracketed(ZTmFancyApp(zmem, pair (a,b))))
];
=TEX
The second block of tests in group 1 checks out the alternatives
for schema:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.2.1", sp, ¨µa∑bÆ, 
			ZTmQuantâS(ZQuantµ, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.2", sp, ¨∂a∑bÆ, 
			ZTmQuantâS(ZQuant∂, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.3", sp, ¨∂â1a∑bÆ, 
			ZTmQuantâS(ZQuant∂â1, ([ZSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.4", sp, ¨a ± bÆ, ZTmLogInOpâS(ZLogInOp±, a , b)),
	("ZParser.1.2.5", sp, ¨a ≤ bÆ, ZTmLogInOpâS(ZLogInOp≤, a , b)),
	("ZParser.1.2.6", sp, ¨a ¥ bÆ, ZTmLogInOpâS(ZLogInOp¥, a , b)),
	("ZParser.1.2.7", sp, ¨a § bÆ, ZTmLogInOpâS(ZLogInOp§, a , b)),
	("ZParser.1.2.8", sp, ¨a ˘ bÆ, ZTm˘(a , b)),
	("ZParser.1.2.9", sp, ¨a ª bÆ, ZTmª(a , b)),
	("ZParser.1.2.10", sp, ¨≥ aÆ, ZTm≥âS a),
	("ZParser.1.2.11", sp, ¨pre aÆ, ZTmPre a),
	("ZParser.1.2.12", sp, ¨ÑaÆ, ZTmÑ a),
	("ZParser.1.2.13", sp, ¨òaÆ, ZTmò a),
	("ZParser.1.2.14", sp, ¨(a)'?!Æ, ZTmDecor(ZTmBracketed a, "'?!")),
	("ZParser.1.2.15", sp, ¨a[b/c]Æ,
			ZTmRename(a, [(id_of_string "b",id_of_string "c")])),
	("ZParser.1.2.16", sp, ¨[b|c]Æ,
		ZTmHorizSchema([ZSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.2.17", sp, ¨a\(b)Æ,
		ZTmHide(a, [id_of_string "b"]))
];
=TEX
The third block of tests in group 1 checks out the two
forms of schema text:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.3.1", sp, ¨[b|c]Æ,
		ZTmHorizSchema([ZSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.3.2", sp, ¨[b]Æ,
		ZTmHorizSchema([ZSchemaDec(b, Nil)], Nil, Nil))
];
=TEX
The fourth block of tests in group 1 checks out the various
forms of expression:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.4.1", tp, ¨(Õa)Æ,
		ZTmÕ1([ZSchemaDec(a, Nil)], Nil, Nil)),
	("ZParser.1.4.2", tp, ¨(Õa|b)Æ,
		ZTmÕ1([ZSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.3", tp, ¨Õa|b∑cÆ,
		ZTmÕ2(([ZSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.4", tp, ¨Õa∑cÆ,
		ZTmÕ2(([ZSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.5", tp, ¨Ãa|b∑cÆ,
		ZTmÃ(([ZSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.6", tp, ¨Ãa∑cÆ,
		ZTmÃ(([ZSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.7", tp, ¨a + bÆ,
		ZTmFancyApp(zplus, pair (a,b))),
	("ZParser.1.4.8", tp, ¨if a then b else cÆ,
		ZTmFancyApp(zif, triple (a,b,c))),
	("ZParser.1.4.9", tp, ¨˚ ˝Æ,
		ZTmFancyApp(zbag, ZTmTuple[ZTmß¢(Nil, [])])),
	("ZParser.1.4.10", tp, ¨˚a˝Æ,
		ZTmFancyApp(zbag, ZTmTuple[ZTmß¢(Nil, [a])])),
	("ZParser.1.4.11", tp, ¨˚a,b,c˝Æ,
		ZTmFancyApp(zbag, ZTmTuple[ZTmß¢(Nil, [a,b,c])])),
	("ZParser.1.4.12", tp, ¨a ∏ bÆ, ZTm∏[a,b]),
	("ZParser.1.4.13", tp, ¨a ∏ b ∏ cÆ, ZTm∏[a,b,c]),
	("ZParser.1.4.14", tp, ¨ aÆ, ZTm a),
	("ZParser.1.4.15", tp, ¨a[b]Æ, ZTmLVar(id_of_string "a", Nil, [b])),
	("ZParser.1.4.16", tp, ¨a[b,c]Æ, ZTmLVar(id_of_string "a", Nil, [b,c])),
	("ZParser.1.4.17", tp, ¨1001Æ, ZTm˙ 1001),
	("ZParser.1.4.18", tp, [ZTAqTm mk_t, ZTEos], ZTmQuotation mk_t),
	("ZParser.1.4.19", tp, ¨(a)Æ, ZTmBracketed a),
	("ZParser.1.4.20", tp, ¨(a,b)Æ, pair (a,b)),
	("ZParser.1.4.21", tp, ¨(a,b,c)Æ, triple (a,b,c)),
	("ZParser.1.4.22", tp, ¨[a|b]Æ,
		ZTmHorizSchema([ZSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.23", tp, ¨(a¶1, b¶2)Æ,
		ZTmBinding[(id_of_string "a",ZTm˙ 1), (id_of_string "b",ZTm˙ 2)]),
	("ZParser.1.4.24", tp, ¨{}Æ, ZTmSetd(Nil, [])),
	("ZParser.1.4.25", tp, ¨{a}Æ, ZTmSetd(Nil, [a])),
	("ZParser.1.4.26", tp, ¨{a,b,c}Æ, ZTmSetd(Nil, [a,b,c])),
	("ZParser.1.4.27", tp, ¨{a|b}Æ,
		ZTmSeta1([ZSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.28", tp, ¨{a; b}Æ,
		ZTmSeta1([ZSchemaDec(a, Nil), ZSchemaDec(b, Nil)], Nil, Nil)),
	("ZParser.1.4.29", tp, ¨{a∑b}Æ,
		ZTmSeta2(([ZSchemaDec(a, Nil)], Nil, Nil), b)),
	("ZParser.1.4.30", tp, ¨{a|b∑c}Æ,
		ZTmSeta2(([ZSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.31", tp, ¨a.bÆ, ZTmSelâB(a, id_of_string "b")),
	("ZParser.1.4.32", tp, ¨a.2Æ, ZTmSelâT(a, 2))
];
=TEX
\subsection{Group 2}
This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
\subsection{Subgroup 1}
This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
=SML
fun gp2_chk1 (ZTmLogInOpâS(op1, a1, b1), ZTmLogInOpâS(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTm˘(a1, b1), ZTm˘(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTmª(a1, b1), ZTmª(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (t1, ZTmBracketed t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (ZTmBracketed t1, t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (t1, t2) = tm_eq (t1, t2);
=TEX
The first block tests schema conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.1.1", sp, ¨a ± b ≤ cÆ, sp ¨(a ± b) ≤ cÆ ),
	("ZParser.2.1.1.2", sp, ¨a ± b ¥ cÆ, sp ¨(a ± b) ¥ cÆ ),
	("ZParser.2.1.1.3", sp, ¨a ± b § cÆ, sp ¨(a ± b) § cÆ ),
	("ZParser.2.1.1.4", sp, ¨a ± b ª cÆ, sp ¨(a ± b) ª cÆ ),
	("ZParser.2.1.1.5", sp, ¨a ± b ˘ cÆ, sp ¨(a ± b) ˘ cÆ ),
	("ZParser.2.1.1.6", sp, ¨b ≤ c ± aÆ, sp ¨b ≤ (c ± a)Æ ),
	("ZParser.2.1.1.7", sp, ¨b ¥ c ± aÆ, sp ¨b ¥ (c ± a)Æ ),
	("ZParser.2.1.1.8", sp, ¨b § c ± aÆ, sp ¨b § (c ± a)Æ ),
	("ZParser.2.1.1.9", sp, ¨b ª c ± aÆ, sp ¨b ª (c ± a)Æ ),
	("ZParser.2.1.1.10", sp, ¨b ˘ c ± aÆ, sp ¨b ˘ (c ± a)Æ )
];
=TEX
The second block tests schema disjunction with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.2.1", sp, ¨a ≤ b ¥ cÆ, sp ¨(a ≤ b) ¥ cÆ ),
	("ZParser.2.1.2.2", sp, ¨a ≤ b § cÆ, sp ¨(a ≤ b) § cÆ ),
	("ZParser.2.1.2.3", sp, ¨a ≤ b ª cÆ, sp ¨(a ≤ b) ª cÆ ),
	("ZParser.2.1.2.4", sp, ¨a ≤ b ˘ cÆ, sp ¨(a ≤ b) ˘ cÆ ),
	("ZParser.2.1.2.5", sp, ¨b ¥ c ≤ aÆ, sp ¨b ¥ (c ≤ a)Æ ),
	("ZParser.2.1.2.6", sp, ¨b § c ≤ aÆ, sp ¨b § (c ≤ a)Æ ),
	("ZParser.2.1.2.7", sp, ¨b ª c ≤ aÆ, sp ¨b ª (c ≤ a)Æ ),
	("ZParser.2.1.2.8", sp, ¨b ˘ c ≤ aÆ, sp ¨b ˘ (c ≤ a)Æ )
];
=TEX
The third block tests schema implication with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.3.1", sp, ¨a ¥ b § cÆ, sp ¨(a ¥ b) § cÆ ),
	("ZParser.2.1.3.2", sp, ¨a ¥ b ª cÆ, sp ¨(a ¥ b) ª cÆ ),
	("ZParser.2.1.3.3", sp, ¨a ¥ b ˘ cÆ, sp ¨(a ¥ b) ˘ cÆ ),
	("ZParser.2.1.3.4", sp, ¨b § c ¥ aÆ, sp ¨b § (c ¥ a)Æ ),
	("ZParser.2.1.3.5", sp, ¨b ª c ¥ aÆ, sp ¨b ª (c ¥ a)Æ ),
	("ZParser.2.1.3.6", sp, ¨b ˘ c ¥ aÆ, sp ¨b ˘ (c ¥ a)Æ )
];
=TEX
The fourth block tests schema bi-implication with the two others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.4.1", sp, ¨a § b ª cÆ, sp ¨(a § b) ª cÆ ),
	("ZParser.2.1.4.2", sp, ¨a § b ˘ cÆ, sp ¨(a § b) ˘ cÆ ),
	("ZParser.2.1.4.3", sp, ¨b ª c § aÆ, sp ¨b ª (c § a)Æ ),
	("ZParser.2.1.4.4", sp, ¨b ˘ c § aÆ, sp ¨b ˘ (c § a)Æ )
];
=TEX
The fourth block tests the two non-logical schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.4.1", sp, ¨a ª b ˘ cÆ, sp ¨(a ª b) ˘ cÆ ),
	("ZParser.2.1.4.2", sp, ¨b ˘ c ª aÆ, sp ¨b ˘ (c ª a)Æ )
];
=TEX
The fifth block tests the left association rule for schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.5.1", sp, ¨a ± b ± cÆ, sp ¨a ± (b ± c)Æ ),
	("ZParser.2.1.5.2", sp, ¨a ≤ b ≤ cÆ, sp ¨a ≤ (b ≤ c)Æ ),
	("ZParser.2.1.5.3", sp, ¨a ¥ b ¥ cÆ, sp ¨a ¥ (b ¥ c)Æ ),
	("ZParser.2.1.5.4", sp, ¨a § b § cÆ, sp ¨a § (b § c)Æ ),
	("ZParser.2.1.5.5", sp, ¨a ˘ b ˘ cÆ, sp ¨a ˘ (b ˘ c)Æ ),
	("ZParser.2.1.5.6", sp, ¨a ª b ª cÆ, sptp ¨a ª (b ª c)Æ )
];
=SML
fun gp2_chk2 (ZTmLogInOpâF(op1, a1, b1), ZTmLogInOpâF(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk2(a1, a2) andalso gp2_chk2(b1, b2)
) | gp2_chk2 (t1, ZTmBracketed t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (ZTmBracketed t1, t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (t1, t2) = tm_eq (t1, t2);
=TEX
The sixth block tests logical conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.6.1", tp, ¨a ± b ≤ cÆ, tp ¨(a ± b) ≤ cÆ ),
	("ZParser.2.1.6.2", tp, ¨a ± b ¥ cÆ, tp ¨(a ± b) ¥ cÆ ),
	("ZParser.2.1.6.3", tp, ¨a ± b § cÆ, tp ¨(a ± b) § cÆ ),
	("ZParser.2.1.6.6", tp, ¨b ≤ c ± aÆ, tp ¨b ≤ (c ± a)Æ ),
	("ZParser.2.1.6.7", tp, ¨b ¥ c ± aÆ, tp ¨b ¥ (c ± a)Æ ),
	("ZParser.2.1.6.8", tp, ¨b § c ± aÆ, tp ¨b § (c ± a)Æ )
];
=TEX
The seventh block tests logical disjunction with the othesr of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.7.1", tp, ¨a ≤ b ¥ cÆ, tp ¨(a ≤ b) ¥ cÆ ),
	("ZParser.2.1.7.2", tp, ¨a ≤ b § cÆ, tp ¨(a ≤ b) § cÆ ),
	("ZParser.2.1.7.3", tp, ¨b ¥ c ≤ aÆ, tp ¨b ¥ (c ≤ a)Æ ),
	("ZParser.2.1.7.4", tp, ¨b § c ≤ aÆ, tp ¨b § (c ≤ a)Æ )
];
=TEX
The eighth block tests logical implication and bi-implication:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.8.1", tp, ¨a ¥ b § cÆ, tp ¨(a ¥ b) § cÆ ),
	("ZParser.2.1.8.2", tp, ¨b § c ¥ aÆ, tp ¨b § (c ¥ a)Æ )
];
=TEX
The ninth block tests the left association rule for logical operators:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.9.1", tp, ¨a ± b ± cÆ, tp ¨a ± (b ± c)Æ ),
	("ZParser.2.1.9.2", tp, ¨a ≤ b ≤ cÆ, tp ¨a ≤ (b ≤ c)Æ ),
	("ZParser.2.1.9.3", tp, ¨a ¥ b ¥ cÆ, tp ¨a ¥ (b ¥ c)Æ ),
	("ZParser.2.1.9.4", tp, ¨a § b § cÆ, tp ¨a § (b § c)Æ )
];
=TEX
The tenth block tests the unary schema operators against the
binary schema operators.
=SML
fun gp2_chk4 (ZTmLogInOpâS(op1, a1, b1), ZTmLogInOpâS(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTm˘(a1, b1), ZTm˘(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTmª(a1, b1), ZTmª(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (t1, ZTmBracketed t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmBracketed t1, t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm≥âS t1, ZTm≥âS t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmÑ t1, ZTmÑ t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmò t1, ZTmò t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmPre t1, ZTmPre t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (t1, t2) = tm_eq (t1, t2);
=SML
store_mt_results_show (mt_runf gp2_chk4)
[
	("ZParser.2.1.10.1", sp, ¨≥ b ≤ cÆ, sp ¨(≥ b) ≤ cÆ ),
	("ZParser.2.1.10.2", sp, ¨≥ b ≤ cÆ, sp ¨(≥ b) ≤ cÆ ),
	("ZParser.2.1.10.3", sp, ¨≥ b ¥ cÆ, sp ¨(≥ b) ¥ cÆ ),
	("ZParser.2.1.10.4", sp, ¨≥ b § cÆ, sp ¨(≥ b) § cÆ ),
	("ZParser.2.1.10.5", sp, ¨≥ b ª cÆ, sp ¨(≥ b) ª cÆ ),
	("ZParser.2.1.10.6", sp, ¨≥ b ˘ cÆ, sp ¨(≥ b) ˘ cÆ ),
	("ZParser.2.1.10.7", sp, ¨Ñ b ≤ cÆ, sp ¨(Ñ b) ≤ cÆ ),
	("ZParser.2.1.10.8", sp, ¨Ñ b ≤ cÆ, sp ¨(Ñ b) ≤ cÆ ),
	("ZParser.2.1.10.9", sp, ¨Ñ b ¥ cÆ, sp ¨(Ñ b) ¥ cÆ ),
	("ZParser.2.1.10.10", sp, ¨Ñ b § cÆ, sp ¨(Ñ b) § cÆ ),
	("ZParser.2.1.10.11", sp, ¨Ñ b ª cÆ, sp ¨(Ñ b) ª cÆ ),
	("ZParser.2.1.10.12", sp, ¨Ñ b ˘ cÆ, sp ¨(Ñ b) ˘ cÆ ),
	("ZParser.2.1.10.13", sp, ¨ò b ≤ cÆ, sp ¨(ò b) ≤ cÆ ),
	("ZParser.2.1.10.14", sp, ¨ò b ≤ cÆ, sp ¨(ò b) ≤ cÆ ),
	("ZParser.2.1.10.15", sp, ¨ò b ¥ cÆ, sp ¨(ò b) ¥ cÆ ),
	("ZParser.2.1.10.16", sp, ¨ò b § cÆ, sp ¨(ò b) § cÆ ),
	("ZParser.2.1.10.17", sp, ¨ò b ª cÆ, sp ¨(ò b) ª cÆ ),
	("ZParser.2.1.10.18", sp, ¨ò b ˘ cÆ, sp ¨(ò b) ˘ cÆ ),
	("ZParser.2.1.10.19", sp, ¨pre b ≤ cÆ, sp ¨(pre b) ≤ cÆ ),
	("ZParser.2.1.10.20", sp, ¨pre b ≤ cÆ, sp ¨(pre b) ≤ cÆ ),
	("ZParser.2.1.10.21", sp, ¨pre b ¥ cÆ, sp ¨(pre b) ¥ cÆ ),
	("ZParser.2.1.10.22", sp, ¨pre b § cÆ, sp ¨(pre b) § cÆ ),
	("ZParser.2.1.10.23", sp, ¨pre b ª cÆ, sp ¨(pre b) ª cÆ ),
	("ZParser.2.1.10.24", sp, ¨pre b ˘ cÆ, sp ¨(pre b) ˘ cÆ )
];
=TEX
\subsection{Subgroup 2}
This subgroup tests the relative precedences and
association rules of fancy-fix operators.
\subsection{Subgroup 3}
This subgroup tests the remaining rules about
expressions.

=TEX
\subsection{Group 3}
This group of tests the differences between extended and
standard Z.
\subsubsection{Group 4}
This group of tests exhibits the reachable error
messages.
=TEX
\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
