%  mdt061.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Parser}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT061}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Z parser described in the document
DS/FMU/IED/DTD061.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.4 }]
First drafts
\item[Issue \SCCSversion \FormatDate{$Date$%
}]
Checks for various fixes added.

\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the parser as specified in \cite{DS/FMU/IED/DTD061}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Z parser
as defined in \cite{DS/FMU/IED/DTD061} and implemented
in \cite{DS/FMU/IED/IMP061}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

The test coverage could be extended (e.g. to investigate the differences
between extended and standard Z), however this was not felt to be
cost-effective in the first intance..

\section{TEST CASES}
\begin{description}
\item[ZParser.1] In this group of tests an instance of each alternative in the
grammar of \cite{DS/FMU/IED/DEF007}
is parsed and the form of the result is checked.
If an alternative contains an optional construct, then a form with and a form
without that construct are checked. Similarly an iterated construct is
checked with 0, 1 and 2 occurrences.
\item[ZParser.2] This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
It is further subdivided as follows:
\begin{description}
\item[ZParser.2.1] This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
\item[ZParser.2.2] This subgroup tests the relative precedences and
association rules of fancy-fix operators.
\item[ZParser.2.3] This subgroup tests the remaining rules about
expressions.
\end{description}
Note that some of the rules just say that in such and such a production
such and such a constituent must have some property, the tests
against these rules are in group $ZParser.4$.
\item[ZParser.3] This group of tests the differences between extended and
standard Z.
\item[ZParser.3] This group tests the paragraph processing.
\item[ZParser.4] This group of tests exhibits the reachable error
messages.
\end{description}
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
open_theory "hol" handle (Fail _) => open_theory "misc";
new_theory"test_mdt061";
init_mt_results();
open ZParser ZUserInterfaceSupport ZLex;
=TEX
The following code is a modification of
what appears in the parser interface, see \cite{DS/FMU/IED/IMP022}, and
causes HOL term quotations to evaluate to the corresponding stream
of lexical tokens. N.B. we use the HOL quotation form, not the Z form
so that the tests may be run independently of the Z paragraph processor of
\cite{DS/FMU/IED/DTD064}.
=SML
fun HOL_term_recogniser (_, _, x, _) = ZLex.z_lex  x;
=TEX
The following code sets up some useful values and utilities:
=SML
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
=SML
fun para_eq (p1 : Z_PARA, p2 : Z_PARA) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun tm_eq (p1 : Z_TM, p2 : Z_TM) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun id_of_string s = (template_of_string s, "") : IDENT;
fun z_tm_of_string s = ZTmLVar(id_of_string s, Nil, []);
val a = z_tm_of_string "a";
val b = z_tm_of_string "b";
val c = z_tm_of_string "c";
val p = z_tm_of_string "p";
val P = z_tm_of_string "P";
val Q = z_tm_of_string "Q";
val X = z_tm_of_string "X";
val Y = z_tm_of_string "Y";
fun para_of_string s = ZParaTerm([], z_tm_of_string s, Nil);
val zeq = (template_of_string "_ = _", "") : IDENT;
val zmem = (template_of_string "_  _", "") : IDENT;
val zneq = (template_of_string "_ ½ _", "") : IDENT;
val znmem = (template_of_string "_ Ž _", "") : IDENT;
val zplus = (template_of_string "_ + _", "") : IDENT;
val zif = (template_of_string "if _ then _ else _", "") : IDENT;
val zfun = (template_of_string "_ ­ _", "") : IDENT;
val zpfun = (template_of_string "_ ß _", "") : IDENT;
val zbag = (template_of_string "û ; ý", "") : IDENT;
fun pair (a, b) = ZTmTuple[a, b];
fun triple (a, b, c) = ZTmTuple[a, b, c];
=TEX
=SML
new_error_message{id= ~61001,
	text="unexpected result from Z Parser detected in module tests"};
fun tp x = (
	case z_parser {is_quot = true, standard = false} x of
		ZParaTerm(_, tm, _) => tm
	|	_	=> fail "mdt061" ~61001 []
);
fun sp x = (
	case z_parser {is_quot = true, standard = false}
		(ZTLsqbrack :: (rev(tl(rev x))) @ [ZTRsqbrack, ZTEos]) of
		ZParaTerm(_, ZTmHorizSchema([ZDSchemaDec (s, Nil)], Nil, Nil), _) => s
	|	_	=> fail "mdt061" ~61001 []
);

val _ = set_zfixity_info (ZClRel, map template_of_string [ "_ = _", "_  _"]);
val _ = set_zfixity_info (ZClRel, map template_of_string [ "_ Ž _", "_ ½ _"]);
val _ = set_zfixity_info (ZClFun 1, map template_of_string [ "if _ then _ else _ "]);
val _ = set_zfixity_info (ZClFun 2, map template_of_string [ "_ + _"]);
val _ = set_zfixity_info (ZClFun 1, map template_of_string [ "_ º _"]);
val _ = set_zfixity_info (ZClFun 0, map template_of_string [ "û ; ý"]);
val _ = set_zfixity_info (ZClGen 1, map template_of_string [ "_ ­ _"]);
val _ = set_zfixity_info (ZClGen 2, map template_of_string [ "_ ß _"]);
=TEX
\section{THE TESTS}
\subsection{Group 1}
The first block of tests in group 1 checks out the alternatives
for predicate:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.1.1", tp, ¬a ; b®, ZTmLogInOp‰F(ZLogInOpSemi, a , b)),
	("ZParser.1.1.2", tp, ¬µx:Y|Q x·P x ; b®,
			ZTmLogInOp‰F(ZLogInOpSemi, tp ¬µx:Y|Q x·P x® , b)),
	("ZParser.1.1.3", tp, ¬µa·b®,
			ZTmQuant‰F(ZQuantµ, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.4", tp, ¬¶a·b®,
			ZTmQuant‰F(ZQuant¶, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.5", tp, ¬¶‰1a·b®,
			ZTmQuant‰F(ZQuant¶‰1, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.6", tp, ¬a ± b®, ZTmLogInOp‰F(ZLogInOp±, a , b)),
	("ZParser.1.1.7", tp, ¬a ² b®, ZTmLogInOp‰F(ZLogInOp², a , b)),
	("ZParser.1.1.8", tp, ¬a ´ b®, ZTmLogInOp‰F(ZLogInOp´, a , b)),
	("ZParser.1.1.9", tp, ¬a ¤ b®, ZTmLogInOp‰F(ZLogInOp¤, a , b)),
	("ZParser.1.1.10", tp, ¬³ b®, ZTm³‰F b)
,
	("ZParser.1.1.11", tp, ¬a  b®, ZTmFancyApp(zmem, pair (a,b)))
,
	("ZParser.1.1.12", tp, ¬a  b = c®,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zeq, pair (b,c))))),
	("ZParser.1.1.13", tp, ¬a  b ½ c®,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zneq, pair (b,c))))),
	("ZParser.1.1.14", tp, ¬(a  b)®, ZTmBracketed(ZTmFancyApp(zmem, pair (a,b))))
];
=TEX
The second block of tests in group 1 checks out the alternatives
for schema:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.2.1", sp, ¬µa·b®, 
			ZTmQuant‰S(ZQuantµ, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.2", sp, ¬¶a·b®, 
			ZTmQuant‰S(ZQuant¶, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.3", sp, ¬¶‰1a·b®, 
			ZTmQuant‰S(ZQuant¶‰1, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.4", sp, ¬a ± b®, ZTmLogInOp‰S(ZLogInOp±, a , b)),
	("ZParser.1.2.5", sp, ¬a ² b®, ZTmLogInOp‰S(ZLogInOp², a , b)),
	("ZParser.1.2.6", sp, ¬a ´ b®, ZTmLogInOp‰S(ZLogInOp´, a , b)),
	("ZParser.1.2.7", sp, ¬a ¤ b®, ZTmLogInOp‰S(ZLogInOp¤, a , b)),
	("ZParser.1.2.8", sp, ¬a ù‰s b®, ZTmù(a , b)),
	("ZParser.1.2.9", sp, ¬a »‰s b®, ZTm»(a , b)),
	("ZParser.1.2.10", sp, ¬³ a®, ZTm³‰S a),
	("ZParser.1.2.11", sp, ¬pre a®, ZTmPre a),
	("ZParser.1.2.12", sp, ¬„a®, ZTm„ a),
	("ZParser.1.2.13", sp, ¬˜a®, ZTm˜ a),
	("ZParser.1.2.14", sp, ¬(a)'?!®, ZTmDecor(ZTmBracketed a, "'?!")),
	("ZParser.1.2.15", sp, ¬a[b/c]®,
			ZTmRename(a, [(id_of_string "b",id_of_string "c")])),
	("ZParser.1.2.16", sp, ¬[b|c]®,
		ZTmHorizSchema([ZDSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.2.17", sp, ¬a\‰s(b)®,
		ZTmHide(a, [id_of_string "b"]))
];
=TEX
The third block of tests in group 1 checks out the two
forms of schema text:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.3.1", sp, ¬[b|c]®,
		ZTmHorizSchema([ZDSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.3.2", sp, ¬[b]®,
		ZTmHorizSchema([ZDSchemaDec(b, Nil)], Nil, Nil))
];
=TEX
The fourth block of tests in group 1 checks out the various
forms of expression:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.4.1", tp, ¬(Ía)®,
		ZTmÍ1([ZDSchemaDec(a, Nil)], Nil, Nil)),
	("ZParser.1.4.2", tp, ¬(Ía|b)®,
		ZTmÍ1([ZDSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.3", tp, ¬Ía|b·c®,
		ZTmÍ2(([ZDSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.4", tp, ¬Ía·c®,
		ZTmÍ2(([ZDSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.5", tp, ¬Ìa|b·c®,
		ZTmÌ(([ZDSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.6", tp, ¬Ìa·c®,
		ZTmÌ(([ZDSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.7", tp, ¬a + b®,
		ZTmFancyApp(zplus, pair (a,b))),
	("ZParser.1.4.8", tp, ¬if a then b else c®,
		ZTmFancyApp(zif, triple (a,b,c))),
	("ZParser.1.4.9", tp, ¬û ý®,
		ZTmFancyApp(zbag, ZTmTuple[ZTm§¢(Nil, [])])),
	("ZParser.1.4.10", tp, ¬ûaý®,
		ZTmFancyApp(zbag, ZTmTuple[ZTm§¢(Nil, [a])])),
	("ZParser.1.4.11", tp, ¬ûa,b,cý®,
		ZTmFancyApp(zbag, ZTmTuple[ZTm§¢(Nil, [a,b,c])])),
	("ZParser.1.4.12", tp, ¬a ¸ b®, ZTm¸[a,b]),
	("ZParser.1.4.13", tp, ¬a ¸ b ¸ c®, ZTm¸[a,b,c]),
	("ZParser.1.4.14", tp, ¬ð a®, ZTmð a),
	("ZParser.1.4.15", tp, ¬a[b]®, ZTmLVar(id_of_string "a", Nil, [b])),
	("ZParser.1.4.16", tp, ¬a[b,c]®, ZTmLVar(id_of_string "a", Nil, [b,c])),
	("ZParser.1.4.17", tp, ¬1001®, ZTmú 1001),
	("ZParser.1.4.18", tp, [ZTAqTm mk_t, ZTEos], ZTmQuotation (mk_t, Nil)),
	("ZParser.1.4.19", tp, ¬(a)®, ZTmBracketed a),
	("ZParser.1.4.20", tp, ¬(a,b)®, pair (a,b)),
	("ZParser.1.4.21", tp, ¬(a,b,c)®, triple (a,b,c)),
	("ZParser.1.4.22", tp, ¬[a|b]®,
		ZTmHorizSchema([ZDSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.23", tp, ¬(a¦1, b¦2)®,
		ZTmBinding[(id_of_string "a",ZTmú 1), (id_of_string "b",ZTmú 2)]),
	("ZParser.1.4.24", tp, ¬{}®, ZTmSetd(Nil, [])),
	("ZParser.1.4.25", tp, ¬{a}®, ZTmSetd(Nil, [a])),
	("ZParser.1.4.26", tp, ¬{a,b,c}®, ZTmSetd(Nil, [a,b,c])),
	("ZParser.1.4.27", tp, ¬{a|b}®,
		ZTmSeta1([ZDSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.28", tp, ¬{a; b}®,
		ZTmSeta1([ZDSchemaDec(a, Nil), ZDSchemaDec(b, Nil)], Nil, Nil)),
	("ZParser.1.4.29", tp, ¬{a·b}®,
		ZTmSeta2(([ZDSchemaDec(a, Nil)], Nil, Nil), b)),
	("ZParser.1.4.30", tp, ¬{a|b·c}®,
		ZTmSeta2(([ZDSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.31", tp, ¬a.b®, ZTmSel‰B(a, id_of_string "b")),
	("ZParser.1.4.32", tp, ¬a.2®, ZTmSel‰T(a, 2))
];
=TEX
\subsection{Group 2}
This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
\subsection{Subgroup 1}
This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
=SML
fun gp2_chk1 (ZTmLogInOp‰S(op1, a1, b1), ZTmLogInOp‰S(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTmù(a1, b1), ZTmù(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTm»(a1, b1), ZTm»(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (t1, ZTmBracketed t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (ZTmBracketed t1, t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (t1, t2) = tm_eq (t1, t2);
=TEX
The first block tests schema conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.1.1", sp, ¬a ± b ² c®, sp ¬(a ± b) ² c® ),
	("ZParser.2.1.1.2", sp, ¬a ± b ´ c®, sp ¬(a ± b) ´ c® ),
	("ZParser.2.1.1.3", sp, ¬a ± b ¤ c®, sp ¬(a ± b) ¤ c® ),
	("ZParser.2.1.1.4", sp, ¬a ± b »‰s c®, sp ¬(a ± b) »‰s c® ),
	("ZParser.2.1.1.5", sp, ¬a ± b ù‰s c®, sp ¬(a ± b) ù‰s c® ),
	("ZParser.2.1.1.6", sp, ¬b ² c ± a®, sp ¬b ² (c ± a)® ),
	("ZParser.2.1.1.7", sp, ¬b ´ c ± a®, sp ¬b ´ (c ± a)® ),
	("ZParser.2.1.1.8", sp, ¬b ¤ c ± a®, sp ¬b ¤ (c ± a)® ),
	("ZParser.2.1.1.9", sp, ¬b »‰s c ± a®, sp ¬b »‰s (c ± a)® ),
	("ZParser.2.1.1.10", sp, ¬b ù‰s c ± a®, sp ¬b ù‰s (c ± a)® )
];
=TEX
The second block tests schema disjunction with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.2.1", sp, ¬a ² b ´ c®, sp ¬(a ² b) ´ c® ),
	("ZParser.2.1.2.2", sp, ¬a ² b ¤ c®, sp ¬(a ² b) ¤ c® ),
	("ZParser.2.1.2.3", sp, ¬a ² b »‰s c®, sp ¬(a ² b) »‰s c® ),
	("ZParser.2.1.2.4", sp, ¬a ² b ù‰s c®, sp ¬(a ² b) ù‰s c® ),
	("ZParser.2.1.2.5", sp, ¬b ´ c ² a®, sp ¬b ´ (c ² a)® ),
	("ZParser.2.1.2.6", sp, ¬b ¤ c ² a®, sp ¬b ¤ (c ² a)® ),
	("ZParser.2.1.2.7", sp, ¬b »‰s c ² a®, sp ¬b »‰s (c ² a)® ),
	("ZParser.2.1.2.8", sp, ¬b ù‰s c ² a®, sp ¬b ù‰s (c ² a)® )
];
=TEX
The third block tests schema implication with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.3.1", sp, ¬a ´ b ¤ c®, sp ¬(a ´ b) ¤ c® ),
	("ZParser.2.1.3.2", sp, ¬a ´ b »‰s c®, sp ¬(a ´ b) »‰s c® ),
	("ZParser.2.1.3.3", sp, ¬a ´ b ù‰s c®, sp ¬(a ´ b) ù‰s c® ),
	("ZParser.2.1.3.4", sp, ¬b ¤ c ´ a®, sp ¬b ¤ (c ´ a)® ),
	("ZParser.2.1.3.5", sp, ¬b »‰s c ´ a®, sp ¬b »‰s (c ´ a)® ),
	("ZParser.2.1.3.6", sp, ¬b ù‰s c ´ a®, sp ¬b ù‰s (c ´ a)® )
];
=TEX
The fourth block tests schema bi-implication with the two others of lower precedence and the two non-logical schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.4.1", sp, ¬a ¤ b »‰s c®, sp ¬(a ¤ b) »‰s c® ),
	("ZParser.2.1.4.2", sp, ¬a ¤ b ù‰s c®, sp ¬(a ¤ b) ù‰s c® ),
	("ZParser.2.1.4.3", sp, ¬b »‰s c ¤ a®, sp ¬b »‰s (c ¤ a)® ),
	("ZParser.2.1.4.4", sp, ¬b ù‰s c ¤ a®, sp ¬b ù‰s (c ¤ a)® ),
	("ZParser.2.1.4.5", sp, ¬a »‰s b ù‰s c®, sp ¬a »‰s (b ù‰s c)® ),
	("ZParser.2.1.4.6", sp, ¬b ù‰s c »‰s a®, sp ¬(b ù‰s c) »‰s a® )
];
=TEX
The fifth block tests the left association rule for schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.5.1", sp, ¬a ± b ± c®, sp ¬a ± (b ± c)® ),
	("ZParser.2.1.5.2", sp, ¬a ² b ² c®, sp ¬a ² (b ² c)® ),
	("ZParser.2.1.5.3", sp, ¬a ´ b ´ c®, sp ¬a ´ (b ´ c)® ),
	("ZParser.2.1.5.4", sp, ¬a ¤ b ¤ c®, sp ¬a ¤ (b ¤ c)® ),
	("ZParser.2.1.5.5", sp, ¬a ù‰s b ù‰s c®, sp ¬a ù‰s (b ù‰s c)® ),
	("ZParser.2.1.5.6", sp, ¬a »‰s b »‰s c®, sp ¬a »‰s (b »‰s c)® )
];
=SML
fun gp2_chk2 (ZTmLogInOp‰F(op1, a1, b1), ZTmLogInOp‰F(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk2(a1, a2) andalso gp2_chk2(b1, b2)
) | gp2_chk2 (t1, ZTmBracketed t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (ZTmBracketed t1, t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (t1, t2) = tm_eq (t1, t2);
=TEX
The sixth block tests logical conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.6.1", tp, ¬a ± b ² c®, tp ¬(a ± b) ² c® ),
	("ZParser.2.1.6.2", tp, ¬a ± b ´ c®, tp ¬(a ± b) ´ c® ),
	("ZParser.2.1.6.3", tp, ¬a ± b ¤ c®, tp ¬(a ± b) ¤ c® ),
	("ZParser.2.1.6.6", tp, ¬b ² c ± a®, tp ¬b ² (c ± a)® ),
	("ZParser.2.1.6.7", tp, ¬b ´ c ± a®, tp ¬b ´ (c ± a)® ),
	("ZParser.2.1.6.8", tp, ¬b ¤ c ± a®, tp ¬b ¤ (c ± a)® )
];
=TEX
The seventh block tests logical disjunction with the othesr of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.7.1", tp, ¬a ² b ´ c®, tp ¬(a ² b) ´ c® ),
	("ZParser.2.1.7.2", tp, ¬a ² b ¤ c®, tp ¬(a ² b) ¤ c® ),
	("ZParser.2.1.7.3", tp, ¬b ´ c ² a®, tp ¬b ´ (c ² a)® ),
	("ZParser.2.1.7.4", tp, ¬b ¤ c ² a®, tp ¬b ¤ (c ² a)® )
];
=TEX
The eighth block tests logical implication and bi-implication:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.8.1", tp, ¬a ´ b ¤ c®, tp ¬(a ´ b) ¤ c® ),
	("ZParser.2.1.8.2", tp, ¬b ¤ c ´ a®, tp ¬b ¤ (c ´ a)® )
];
=TEX
The ninth block tests the left association rule for logical operators:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.9.1", tp, ¬a ± b ± c®, tp ¬a ± (b ± c)® ),
	("ZParser.2.1.9.2", tp, ¬a ² b ² c®, tp ¬a ² (b ² c)® ),
	("ZParser.2.1.9.3", tp, ¬a ´ b ´ c®, tp ¬a ´ (b ´ c)® ),
	("ZParser.2.1.9.4", tp, ¬a ¤ b ¤ c®, tp ¬a ¤ (b ¤ c)® )
];
=TEX
The tenth block tests the unary schema operators against the
binary schema operators.
=SML
fun gp2_chk4 (ZTmLogInOp‰S(op1, a1, b1), ZTmLogInOp‰S(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTmù(a1, b1), ZTmù(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTm»(a1, b1), ZTm»(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (t1, ZTmBracketed t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmBracketed t1, t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm³‰S t1, ZTm³‰S t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm„ t1, ZTm„ t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm˜ t1, ZTm˜ t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmPre t1, ZTmPre t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (t1, t2) = tm_eq (t1, t2);
=SML
store_mt_results_show (mt_runf gp2_chk4)
[
	("ZParser.2.1.10.1", sp, ¬³ b ² c®, sp ¬(³ b) ² c® ),
	("ZParser.2.1.10.2", sp, ¬³ b ² c®, sp ¬(³ b) ² c® ),
	("ZParser.2.1.10.3", sp, ¬³ b ´ c®, sp ¬(³ b) ´ c® ),
	("ZParser.2.1.10.4", sp, ¬³ b ¤ c®, sp ¬(³ b) ¤ c® ),
	("ZParser.2.1.10.5", sp, ¬³ b »‰s c®, sp ¬(³ b) »‰s c® ),
	("ZParser.2.1.10.6", sp, ¬³ b ù‰s c®, sp ¬(³ b) ù‰s c® ),
	("ZParser.2.1.10.7", sp, ¬„ b ² c®, sp ¬(„ b) ² c® ),
	("ZParser.2.1.10.8", sp, ¬„ b ² c®, sp ¬(„ b) ² c® ),
	("ZParser.2.1.10.9", sp, ¬„ b ´ c®, sp ¬(„ b) ´ c® ),
	("ZParser.2.1.10.10", sp, ¬„ b ¤ c®, sp ¬(„ b) ¤ c® ),
	("ZParser.2.1.10.11", sp, ¬„ b »‰s c®, sp ¬(„ b) »‰s c® ),
	("ZParser.2.1.10.12", sp, ¬„ b ù‰s c®, sp ¬(„ b) ù‰s c® ),
	("ZParser.2.1.10.13", sp, ¬˜ b ² c®, sp ¬(˜ b) ² c® ),
	("ZParser.2.1.10.14", sp, ¬˜ b ² c®, sp ¬(˜ b) ² c® ),
	("ZParser.2.1.10.15", sp, ¬˜ b ´ c®, sp ¬(˜ b) ´ c® ),
	("ZParser.2.1.10.16", sp, ¬˜ b ¤ c®, sp ¬(˜ b) ¤ c® ),
	("ZParser.2.1.10.17", sp, ¬˜ b »‰s c®, sp ¬(˜ b) »‰s c® ),
	("ZParser.2.1.10.18", sp, ¬˜ b ù‰s c®, sp ¬(˜ b) ù‰s c® ),
	("ZParser.2.1.10.19", sp, ¬pre b ² c®, sp ¬(pre b) ² c® ),
	("ZParser.2.1.10.20", sp, ¬pre b ² c®, sp ¬(pre b) ² c® ),
	("ZParser.2.1.10.21", sp, ¬pre b ´ c®, sp ¬(pre b) ´ c® ),
	("ZParser.2.1.10.22", sp, ¬pre b ¤ c®, sp ¬(pre b) ¤ c® ),
	("ZParser.2.1.10.23", sp, ¬pre b »‰s c®, sp ¬(pre b) »‰s c® ),
	("ZParser.2.1.10.24", sp, ¬pre b ù‰s c®, sp ¬(pre b) ù‰s c® )
];
=TEX
\subsection{Subgroup 2}
This subgroup tests the relative precedences and
association rules of fancy-fix operators.
=SML
fun Ûtop_connectiveÝ (ZTmFancyApp (id, _)) = id
|   top_connective _ = fail "mdt061" ~61001 [];

fun assoc_left (ZTmFancyApp (_, ZTmTuple[ZTmFancyApp _, _])) = true
|   assoc_left _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.2.1.1", top_connective o tp, ¬if a then b else 1 + 2®, zif),
	("ZParser.2.2.1.2", top_connective o tp, ¬a ­ b + c®, zfun),
	("ZParser.2.2.1.3", top_connective o tp, ¬a ­ b ß c®, zfun)
];
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.2.2.1", assoc_left o tp, ¬i1 + 2 + 3®, false),
	("ZParser.2.2.2.2", assoc_left o tp, ¬a ­ b ­ c®, false),
	("ZParser.2.2.2.3", assoc_left o tp, ¬a ß b ß c®, false)
];
=TEX
\subsection{Subgroup 3}
This subgroup tests the remaining rules about
expressions.
=TEX
=SML
fun Ûis_set_dispÝ (ZTmSetd _) = true | is_set_disp _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.1.1", is_set_disp o tp, ¬{X}®, true)
];
=TEX
=SML
fun Ûis_varÝ (ZTmLVar _) = true | is_var _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.2.1", is_var o tp, ¬X[Y]®, true)
];
=TEX
=SML
fun Ûis_pred_opÝ (ZTmLogInOp‰F _) = true
|   Ûis_pred_opÝ (ZTmQuant‰F _) = true
|   Ûis_pred_opÝ (ZTm³‰F _) = true
| is_pred_op _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.3.1", is_pred_op o tp, ¬X ± Y®, true),
	("ZParser.2.3.3.2", is_pred_op o tp, ¬X ² Y®, true),
	("ZParser.2.3.3.3", is_pred_op o tp, ¬X ´ Y®, true),
	("ZParser.2.3.3.4", is_pred_op o tp, ¬X ¤ Y®, true),
	("ZParser.2.3.3.5", is_pred_op o tp, ¬³ Y®, true),
	("ZParser.2.3.3.6", is_pred_op o tp, ¬µX|Y·Q®, true),
	("ZParser.2.3.3.7", is_pred_op o tp, ¬¶X|Y·Q®, true),
	("ZParser.2.3.3.8", is_pred_op o tp, ¬¶‰1X|Y·Q®, true)
];
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.4.1", is_pred_op o sp, ¬X ± Y®, false),
	("ZParser.2.3.4.2", is_pred_op o sp, ¬X ² Y®, false),
	("ZParser.2.3.4.3", is_pred_op o sp, ¬X ´ Y®, false),
	("ZParser.2.3.4.4", is_pred_op o sp, ¬X ¤ Y®, false),
	("ZParser.2.3.4.5", is_pred_op o sp, ¬³ Y®, false),
	("ZParser.2.3.4.6", is_pred_op o sp, ¬µX|Y·Q®, false),
	("ZParser.2.3.4.7", is_pred_op o sp, ¬¶X|Y·Q®, false),
	("ZParser.2.3.4.8", is_pred_op o sp, ¬¶‰1X|Y·Q®, false)
];
=TEX
=SML
fun chk_2_3_5 (ZTmFancyApp(_, ZTmTuple[ZTmBracketed p,_ ])) = is_pred_op p
|    chk_2_3_5 _ = fail "mdt061.2.3.5 test failed" 16000 [];

store_mt_results_show mt_run
[
	("ZParser.2.3.5.1", chk_2_3_5 o tp, ¬(µX|Y·Q) º Z®, false)
];
=TEX
\subsubsection{Group 3}
This group tests the paragraph processing.
The semantics of paragraph processing will be checked out in the
tests for the paragraph processor \cite{DS/FMU/IED/DTD049} so here
we just check that the parser classifies the paragraphs correctly.
=SML
fun pp x = (
	case z_parser {is_quot = false, standard = false} x of
		ZParaFixity _ => "fixity"
	|	ZParaAbbDef _ => "abbdef"
	|	ZParaSchBox _ => "schbox"
	|	ZParaAxDes _ => "axdes"
	|	ZParaFreeType _ => "freetype"
	|	ZParaGivenSet _ => "givenset"
	|	ZParaConstraint _ => "constraint"
	|	ZParaConjecture _ => "conjecture"
	|	ZParaTerm _ => "term"
);
=TEX
=SML
fun ÛdÝ l = rev (tl (rev l));
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.3.1", pp, ¬f a®, "constraint"),
	("ZParser.3.2", pp, ¬[x]®, "givenset"),
	("ZParser.3.3", pp, ¬[x, y, z]®, "givenset"),
	("ZParser.3.4", pp, ¬[x, y, z] & a = b®, "givenset"),
	("ZParser.3.5", pp, ¬x ::= f a | g b®, "freetype"),
	("ZParser.3.6", pp, ¬x ::= f a | g b & y ::= h x®, "freetype")
,
	("ZParser.3.7", pp, ZTAx :: ¬x : X®, "axdes"),
	("ZParser.3.8", pp, ZTAx :: ¬x : X ÷ x = x®, "axdes"),
	("ZParser.3.9", pp, ZTAx :: d ¬[A,B]® @ [ZTBar] @¬x : X ÷ x = x®, "axdes"),
	("ZParser.3.10", pp, ZTSch :: d ¬X® @ [ZTIs] @ ¬x : X ÷ x = x®, "schbox"),
	("ZParser.3.11", pp, ZTSch :: d ¬X[A,B,C]® @ [ZTIs] @ ¬x : X ÷ x = x®, "schbox"),
	("ZParser.3.12", pp, ZTSch :: d ¬X[A,B,C]® @ [ZTIs] @ ¬x : X ÷ x = x®, "schbox"),
	("ZParser.3.13", pp, ¬x ¦ y®, "abbdef"),
	("ZParser.3.14", pp, ¬fun _ = _®, "fixity"),
	("ZParser.3.15", pp, ¬fun 99 _ = _, _x®, "fixity"),
	("ZParser.3.16", pp, ¬gen 99 _ = _, _x®, "fixity"),
	("ZParser.3.17", pp, ¬rel _ = _, _x®, "fixity")
];
=TEX
\subsubsection{Group 4}
This group of tests exhibits the reachable error
messages. (Since local definitions are not currently in \cite{DS/FMU/IED/DEF007}
we do not test this error.)
=SML
diag_line"*** mdt061 here: expect 3 Z-Parser error reports after this message ***";
store_mt_results_show mt_run_fail
[
	("ZParser.4.1", pp, ¬f(a®, gen_fail_msg "Z-Parser" 61000 []),
	("ZParser.4.2", pp, ¬f)a®, gen_fail_msg "Z-Parser" 61000 []),
	("ZParser.4.3", pp, ¬[]][®, gen_fail_msg "Z-Parser" 61000 [])
];
=TEX

=TEX
\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
