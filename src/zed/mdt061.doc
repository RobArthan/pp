%  mdt061.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Parser}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT061}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Z parser described in the document
DS/FMU/IED/DTD061.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.4 }]
First drafts
\item[Issue \SCCSversion \FormatDate{$Date$%
}]
Checks for various fixes added.

\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the parser as specified in \cite{DS/FMU/IED/DTD061}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Z parser
as defined in \cite{DS/FMU/IED/DTD061} and implemented
in \cite{DS/FMU/IED/IMP061}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

The test coverage could be extended (e.g. to investigate the differences
between extended and standard Z), however this was not felt to be
cost-effective in the first intance..

\section{TEST CASES}
\begin{description}
\item[ZParser.1] In this group of tests an instance of each alternative in the
grammar of \cite{DS/FMU/IED/DEF007}
is parsed and the form of the result is checked.
If an alternative contains an optional construct, then a form with and a form
without that construct are checked. Similarly an iterated construct is
checked with 0, 1 and 2 occurrences.
\item[ZParser.2] This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
It is further subdivided as follows:
\begin{description}
\item[ZParser.2.1] This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
\item[ZParser.2.2] This subgroup tests the relative precedences and
association rules of fancy-fix operators.
\item[ZParser.2.3] This subgroup tests the remaining rules about
expressions.
\end{description}
Note that some of the rules just say that in such and such a production
such and such a constituent must have some property, the tests
against these rules are in group $ZParser.4$.
\item[ZParser.3] This group of tests the differences between extended and
standard Z.
\item[ZParser.3] This group tests the paragraph processing.
\item[ZParser.4] This group of tests exhibits the reachable error
messages.
\end{description}
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
open_theory "hol" handle (Fail _) => open_theory "misc";
new_theory"test_mdt061";
init_mt_results();
open ZParser ZUserInterfaceSupport ZLex;
=TEX
The following code is a modification of
what appears in the parser interface, see \cite{DS/FMU/IED/IMP022}, and
causes HOL term quotations to evaluate to the corresponding stream
of lexical tokens. N.B. we use the HOL quotation form, not the Z form
so that the tests may be run independently of the Z paragraph processor of
\cite{DS/FMU/IED/DTD064}.
=SML
fun HOL_term_recogniser (_, _, x, _) = ZLex.z_lex  x;
=TEX
The following code sets up some useful values and utilities:
=SML
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
=SML
fun para_eq (p1 : Z_PARA, p2 : Z_PARA) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun tm_eq (p1 : Z_TM, p2 : Z_TM) : bool = (
	PolyML.makestring p1 = PolyML.makestring p2
);
=TEX
=SML
fun id_of_string s = (template_of_string s, "") : IDENT;
fun z_tm_of_string s = ZTmLVar(id_of_string s, Nil, []);
val a = z_tm_of_string "a";
val b = z_tm_of_string "b";
val c = z_tm_of_string "c";
val p = z_tm_of_string "p";
val P = z_tm_of_string "P";
val Q = z_tm_of_string "Q";
val X = z_tm_of_string "X";
val Y = z_tm_of_string "Y";
fun para_of_string s = ZParaTerm([], z_tm_of_string s, Nil);
val zeq = (template_of_string "_ = _", "") : IDENT;
val zmem = (template_of_string "_ ç _", "") : IDENT;
val zneq = (template_of_string "_ Ω _", "") : IDENT;
val znmem = (template_of_string "_ é _", "") : IDENT;
val zplus = (template_of_string "_ + _", "") : IDENT;
val zif = (template_of_string "if _ then _ else _", "") : IDENT;
val zfun = (template_of_string "_ ≠ _", "") : IDENT;
val zpfun = (template_of_string "_ ﬂ _", "") : IDENT;
val zbag = (template_of_string "˚ ; ˝", "") : IDENT;
fun pair (a, b) = ZTmTuple[a, b];
fun triple (a, b, c) = ZTmTuple[a, b, c];
=TEX
=SML
new_error_message{id= ~61001,
	text="unexpected result from Z Parser detected in module tests"};
fun tp x = (
	case z_parser {is_quot = true, standard = false} x of
		ZParaTerm(_, tm, _) => tm
	|	_	=> fail "mdt061" ~61001 []
);
fun sp x = (
	case z_parser {is_quot = true, standard = false}
		(ZTLsqbrack :: (rev(tl(rev x))) @ [ZTRsqbrack, ZTEos]) of
		ZParaTerm(_, ZTmHorizSchema([ZDSchemaDec (s, Nil)], Nil, Nil), _) => s
	|	_	=> fail "mdt061" ~61001 []
);

val _ = set_zfixity_info (ZClRel, map template_of_string [ "_ = _", "_ ç _"]);
val _ = set_zfixity_info (ZClRel, map template_of_string [ "_ é _", "_ Ω _"]);
val _ = set_zfixity_info (ZClFun 1, map template_of_string [ "if _ then _ else _ "]);
val _ = set_zfixity_info (ZClFun 2, map template_of_string [ "_ + _"]);
val _ = set_zfixity_info (ZClFun 1, map template_of_string [ "_ ∫ _"]);
val _ = set_zfixity_info (ZClFun 0, map template_of_string [ "˚ ; ˝"]);
val _ = set_zfixity_info (ZClGen 1, map template_of_string [ "_ ≠ _"]);
val _ = set_zfixity_info (ZClGen 2, map template_of_string [ "_ ﬂ _"]);
=TEX
\section{THE TESTS}
\subsection{Group 1}
The first block of tests in group 1 checks out the alternatives
for predicate:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.1.1", tp, ¨a ; bÆ, ZTmLogInOpâF(ZLogInOpSemi, a , b)),
	("ZParser.1.1.2", tp, ¨µx:Y|Q x∑P x ; bÆ,
			ZTmLogInOpâF(ZLogInOpSemi, tp ¨µx:Y|Q x∑P xÆ , b)),
	("ZParser.1.1.3", tp, ¨µa∑bÆ,
			ZTmQuantâF(ZQuantµ, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.4", tp, ¨∂a∑bÆ,
			ZTmQuantâF(ZQuant∂, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.5", tp, ¨∂â1a∑bÆ,
			ZTmQuantâF(ZQuant∂â1, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.1.6", tp, ¨a ± bÆ, ZTmLogInOpâF(ZLogInOp±, a , b)),
	("ZParser.1.1.7", tp, ¨a ≤ bÆ, ZTmLogInOpâF(ZLogInOp≤, a , b)),
	("ZParser.1.1.8", tp, ¨a ¥ bÆ, ZTmLogInOpâF(ZLogInOp¥, a , b)),
	("ZParser.1.1.9", tp, ¨a § bÆ, ZTmLogInOpâF(ZLogInOp§, a , b)),
	("ZParser.1.1.10", tp, ¨≥ bÆ, ZTm≥âF b)
,
	("ZParser.1.1.11", tp, ¨a ç bÆ, ZTmFancyApp(zmem, pair (a,b)))
,
	("ZParser.1.1.12", tp, ¨a ç b = cÆ,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zeq, pair (b,c))))),
	("ZParser.1.1.13", tp, ¨a ç b Ω cÆ,
		ZTmFancyApp(zmem, pair (a,ZTmFancyApp(zneq, pair (b,c))))),
	("ZParser.1.1.14", tp, ¨(a ç b)Æ, ZTmBracketed(ZTmFancyApp(zmem, pair (a,b))))
];
=TEX
The second block of tests in group 1 checks out the alternatives
for schema:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.2.1", sp, ¨µa∑bÆ, 
			ZTmQuantâS(ZQuantµ, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.2", sp, ¨∂a∑bÆ, 
			ZTmQuantâS(ZQuant∂, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.3", sp, ¨∂â1a∑bÆ, 
			ZTmQuantâS(ZQuant∂â1, ([ZDSchemaDec (a, Nil)], Nil, Nil), b)),
	("ZParser.1.2.4", sp, ¨a ± bÆ, ZTmLogInOpâS(ZLogInOp±, a , b)),
	("ZParser.1.2.5", sp, ¨a ≤ bÆ, ZTmLogInOpâS(ZLogInOp≤, a , b)),
	("ZParser.1.2.6", sp, ¨a ¥ bÆ, ZTmLogInOpâS(ZLogInOp¥, a , b)),
	("ZParser.1.2.7", sp, ¨a § bÆ, ZTmLogInOpâS(ZLogInOp§, a , b)),
	("ZParser.1.2.8", sp, ¨a ˘âs bÆ, ZTm˘(a , b)),
	("ZParser.1.2.9", sp, ¨a ªâs bÆ, ZTmª(a , b)),
	("ZParser.1.2.10", sp, ¨≥ aÆ, ZTm≥âS a),
	("ZParser.1.2.11", sp, ¨pre aÆ, ZTmPre a),
	("ZParser.1.2.12", sp, ¨ÑaÆ, ZTmÑ a),
	("ZParser.1.2.13", sp, ¨òaÆ, ZTmò a),
	("ZParser.1.2.14", sp, ¨(a)'?!Æ, ZTmDecor(ZTmBracketed a, "'?!")),
	("ZParser.1.2.15", sp, ¨a[b/c]Æ,
			ZTmRename(a, [(id_of_string "b",id_of_string "c")])),
	("ZParser.1.2.16", sp, ¨[b|c]Æ,
		ZTmHorizSchema([ZDSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.2.17", sp, ¨a\âs(b)Æ,
		ZTmHide(a, [id_of_string "b"]))
];
=TEX
The third block of tests in group 1 checks out the two
forms of schema text:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.3.1", sp, ¨[b|c]Æ,
		ZTmHorizSchema([ZDSchemaDec(b, Nil)], Value c, Nil)),
	("ZParser.1.3.2", sp, ¨[b]Æ,
		ZTmHorizSchema([ZDSchemaDec(b, Nil)], Nil, Nil))
];
=TEX
The fourth block of tests in group 1 checks out the various
forms of expression:
=SML
store_mt_results_show (mt_runf tm_eq)
[
	("ZParser.1.4.1", tp, ¨(Õa)Æ,
		ZTmÕ1([ZDSchemaDec(a, Nil)], Nil, Nil)),
	("ZParser.1.4.2", tp, ¨(Õa|b)Æ,
		ZTmÕ1([ZDSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.3", tp, ¨Õa|b∑cÆ,
		ZTmÕ2(([ZDSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.4", tp, ¨Õa∑cÆ,
		ZTmÕ2(([ZDSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.5", tp, ¨Ãa|b∑cÆ,
		ZTmÃ(([ZDSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.6", tp, ¨Ãa∑cÆ,
		ZTmÃ(([ZDSchemaDec(a, Nil)], Nil, Nil), c)),
	("ZParser.1.4.7", tp, ¨a + bÆ,
		ZTmFancyApp(zplus, pair (a,b))),
	("ZParser.1.4.8", tp, ¨if a then b else cÆ,
		ZTmFancyApp(zif, triple (a,b,c))),
	("ZParser.1.4.9", tp, ¨˚ ˝Æ,
		ZTmFancyApp(zbag, ZTmTuple[ZTmß¢(Nil, [])])),
	("ZParser.1.4.10", tp, ¨˚a˝Æ,
		ZTmFancyApp(zbag, ZTmTuple[ZTmß¢(Nil, [a])])),
	("ZParser.1.4.11", tp, ¨˚a,b,c˝Æ,
		ZTmFancyApp(zbag, ZTmTuple[ZTmß¢(Nil, [a,b,c])])),
	("ZParser.1.4.12", tp, ¨a ∏ bÆ, ZTm∏[a,b]),
	("ZParser.1.4.13", tp, ¨a ∏ b ∏ cÆ, ZTm∏[a,b,c]),
	("ZParser.1.4.14", tp, ¨ aÆ, ZTm a),
	("ZParser.1.4.15", tp, ¨a[b]Æ, ZTmLVar(id_of_string "a", Nil, [b])),
	("ZParser.1.4.16", tp, ¨a[b,c]Æ, ZTmLVar(id_of_string "a", Nil, [b,c])),
	("ZParser.1.4.17", tp, ¨1001Æ, ZTm˙ 1001),
	("ZParser.1.4.18", tp, [ZTAqTm mk_t, ZTEos], ZTmQuotation (mk_t, Nil)),
	("ZParser.1.4.19", tp, ¨(a)Æ, ZTmBracketed a),
	("ZParser.1.4.20", tp, ¨(a,b)Æ, pair (a,b)),
	("ZParser.1.4.21", tp, ¨(a,b,c)Æ, triple (a,b,c)),
	("ZParser.1.4.22", tp, ¨[a|b]Æ,
		ZTmHorizSchema([ZDSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.23", tp, ¨(a¶1, b¶2)Æ,
		ZTmBinding[(id_of_string "a",ZTm˙ 1), (id_of_string "b",ZTm˙ 2)]),
	("ZParser.1.4.24", tp, ¨{}Æ, ZTmSetd(Nil, [])),
	("ZParser.1.4.25", tp, ¨{a}Æ, ZTmSetd(Nil, [a])),
	("ZParser.1.4.26", tp, ¨{a,b,c}Æ, ZTmSetd(Nil, [a,b,c])),
	("ZParser.1.4.27", tp, ¨{a|b}Æ,
		ZTmSeta1([ZDSchemaDec(a, Nil)], Value b, Nil)),
	("ZParser.1.4.28", tp, ¨{a; b}Æ,
		ZTmSeta1([ZDSchemaDec(a, Nil), ZDSchemaDec(b, Nil)], Nil, Nil)),
	("ZParser.1.4.29", tp, ¨{a∑b}Æ,
		ZTmSeta2(([ZDSchemaDec(a, Nil)], Nil, Nil), b)),
	("ZParser.1.4.30", tp, ¨{a|b∑c}Æ,
		ZTmSeta2(([ZDSchemaDec(a, Nil)], Value b, Nil), c)),
	("ZParser.1.4.31", tp, ¨a.bÆ, ZTmSelâB(a, id_of_string "b")),
	("ZParser.1.4.32", tp, ¨a.2Æ, ZTmSelâT(a, 2))
];
=TEX
\subsection{Group 2}
This group of tests checks that the disambiguation rules
given in sections 4.12, 4.14 and 4.15 of \cite{DS/FMU/IED/DEF007}
are implemented correctly.
\subsection{Subgroup 1}
This subgroup tests the relative precedences and
association rules for the schema and logical connectives.
=SML
fun gp2_chk1 (ZTmLogInOpâS(op1, a1, b1), ZTmLogInOpâS(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTm˘(a1, b1), ZTm˘(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (ZTmª(a1, b1), ZTmª(a2, b2)) : bool = (
	gp2_chk1(a1, a2) andalso gp2_chk1(b1, b2)
) | gp2_chk1 (t1, ZTmBracketed t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (ZTmBracketed t1, t2) = (gp2_chk1 (t1, t2)
) | gp2_chk1 (t1, t2) = tm_eq (t1, t2);
=TEX
The first block tests schema conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.1.1", sp, ¨a ± b ≤ cÆ, sp ¨(a ± b) ≤ cÆ ),
	("ZParser.2.1.1.2", sp, ¨a ± b ¥ cÆ, sp ¨(a ± b) ¥ cÆ ),
	("ZParser.2.1.1.3", sp, ¨a ± b § cÆ, sp ¨(a ± b) § cÆ ),
	("ZParser.2.1.1.4", sp, ¨a ± b ªâs cÆ, sp ¨(a ± b) ªâs cÆ ),
	("ZParser.2.1.1.5", sp, ¨a ± b ˘âs cÆ, sp ¨(a ± b) ˘âs cÆ ),
	("ZParser.2.1.1.6", sp, ¨b ≤ c ± aÆ, sp ¨b ≤ (c ± a)Æ ),
	("ZParser.2.1.1.7", sp, ¨b ¥ c ± aÆ, sp ¨b ¥ (c ± a)Æ ),
	("ZParser.2.1.1.8", sp, ¨b § c ± aÆ, sp ¨b § (c ± a)Æ ),
	("ZParser.2.1.1.9", sp, ¨b ªâs c ± aÆ, sp ¨b ªâs (c ± a)Æ ),
	("ZParser.2.1.1.10", sp, ¨b ˘âs c ± aÆ, sp ¨b ˘âs (c ± a)Æ )
];
=TEX
The second block tests schema disjunction with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.2.1", sp, ¨a ≤ b ¥ cÆ, sp ¨(a ≤ b) ¥ cÆ ),
	("ZParser.2.1.2.2", sp, ¨a ≤ b § cÆ, sp ¨(a ≤ b) § cÆ ),
	("ZParser.2.1.2.3", sp, ¨a ≤ b ªâs cÆ, sp ¨(a ≤ b) ªâs cÆ ),
	("ZParser.2.1.2.4", sp, ¨a ≤ b ˘âs cÆ, sp ¨(a ≤ b) ˘âs cÆ ),
	("ZParser.2.1.2.5", sp, ¨b ¥ c ≤ aÆ, sp ¨b ¥ (c ≤ a)Æ ),
	("ZParser.2.1.2.6", sp, ¨b § c ≤ aÆ, sp ¨b § (c ≤ a)Æ ),
	("ZParser.2.1.2.7", sp, ¨b ªâs c ≤ aÆ, sp ¨b ªâs (c ≤ a)Æ ),
	("ZParser.2.1.2.8", sp, ¨b ˘âs c ≤ aÆ, sp ¨b ˘âs (c ≤ a)Æ )
];
=TEX
The third block tests schema implication with all others of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.3.1", sp, ¨a ¥ b § cÆ, sp ¨(a ¥ b) § cÆ ),
	("ZParser.2.1.3.2", sp, ¨a ¥ b ªâs cÆ, sp ¨(a ¥ b) ªâs cÆ ),
	("ZParser.2.1.3.3", sp, ¨a ¥ b ˘âs cÆ, sp ¨(a ¥ b) ˘âs cÆ ),
	("ZParser.2.1.3.4", sp, ¨b § c ¥ aÆ, sp ¨b § (c ¥ a)Æ ),
	("ZParser.2.1.3.5", sp, ¨b ªâs c ¥ aÆ, sp ¨b ªâs (c ¥ a)Æ ),
	("ZParser.2.1.3.6", sp, ¨b ˘âs c ¥ aÆ, sp ¨b ˘âs (c ¥ a)Æ )
];
=TEX
The fourth block tests schema bi-implication with the two others of lower precedence and the two non-logical schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.4.1", sp, ¨a § b ªâs cÆ, sp ¨(a § b) ªâs cÆ ),
	("ZParser.2.1.4.2", sp, ¨a § b ˘âs cÆ, sp ¨(a § b) ˘âs cÆ ),
	("ZParser.2.1.4.3", sp, ¨b ªâs c § aÆ, sp ¨b ªâs (c § a)Æ ),
	("ZParser.2.1.4.4", sp, ¨b ˘âs c § aÆ, sp ¨b ˘âs (c § a)Æ ),
	("ZParser.2.1.4.5", sp, ¨a ªâs b ˘âs cÆ, sp ¨a ªâs (b ˘âs c)Æ ),
	("ZParser.2.1.4.6", sp, ¨b ˘âs c ªâs aÆ, sp ¨(b ˘âs c) ªâs aÆ )
];
=TEX
The fifth block tests the left association rule for schema operators:
=SML
store_mt_results_show (mt_runf gp2_chk1)
[
	("ZParser.2.1.5.1", sp, ¨a ± b ± cÆ, sp ¨a ± (b ± c)Æ ),
	("ZParser.2.1.5.2", sp, ¨a ≤ b ≤ cÆ, sp ¨a ≤ (b ≤ c)Æ ),
	("ZParser.2.1.5.3", sp, ¨a ¥ b ¥ cÆ, sp ¨a ¥ (b ¥ c)Æ ),
	("ZParser.2.1.5.4", sp, ¨a § b § cÆ, sp ¨a § (b § c)Æ ),
	("ZParser.2.1.5.5", sp, ¨a ˘âs b ˘âs cÆ, sp ¨a ˘âs (b ˘âs c)Æ ),
	("ZParser.2.1.5.6", sp, ¨a ªâs b ªâs cÆ, sp ¨a ªâs (b ªâs c)Æ )
];
=SML
fun gp2_chk2 (ZTmLogInOpâF(op1, a1, b1), ZTmLogInOpâF(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk2(a1, a2) andalso gp2_chk2(b1, b2)
) | gp2_chk2 (t1, ZTmBracketed t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (ZTmBracketed t1, t2) = (gp2_chk2 (t1, t2)
) | gp2_chk2 (t1, t2) = tm_eq (t1, t2);
=TEX
The sixth block tests logical conjunction with all others:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.6.1", tp, ¨a ± b ≤ cÆ, tp ¨(a ± b) ≤ cÆ ),
	("ZParser.2.1.6.2", tp, ¨a ± b ¥ cÆ, tp ¨(a ± b) ¥ cÆ ),
	("ZParser.2.1.6.3", tp, ¨a ± b § cÆ, tp ¨(a ± b) § cÆ ),
	("ZParser.2.1.6.6", tp, ¨b ≤ c ± aÆ, tp ¨b ≤ (c ± a)Æ ),
	("ZParser.2.1.6.7", tp, ¨b ¥ c ± aÆ, tp ¨b ¥ (c ± a)Æ ),
	("ZParser.2.1.6.8", tp, ¨b § c ± aÆ, tp ¨b § (c ± a)Æ )
];
=TEX
The seventh block tests logical disjunction with the othesr of lower precedence:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.7.1", tp, ¨a ≤ b ¥ cÆ, tp ¨(a ≤ b) ¥ cÆ ),
	("ZParser.2.1.7.2", tp, ¨a ≤ b § cÆ, tp ¨(a ≤ b) § cÆ ),
	("ZParser.2.1.7.3", tp, ¨b ¥ c ≤ aÆ, tp ¨b ¥ (c ≤ a)Æ ),
	("ZParser.2.1.7.4", tp, ¨b § c ≤ aÆ, tp ¨b § (c ≤ a)Æ )
];
=TEX
The eighth block tests logical implication and bi-implication:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.8.1", tp, ¨a ¥ b § cÆ, tp ¨(a ¥ b) § cÆ ),
	("ZParser.2.1.8.2", tp, ¨b § c ¥ aÆ, tp ¨b § (c ¥ a)Æ )
];
=TEX
The ninth block tests the left association rule for logical operators:
=SML
store_mt_results_show (mt_runf gp2_chk2)
[
	("ZParser.2.1.9.1", tp, ¨a ± b ± cÆ, tp ¨a ± (b ± c)Æ ),
	("ZParser.2.1.9.2", tp, ¨a ≤ b ≤ cÆ, tp ¨a ≤ (b ≤ c)Æ ),
	("ZParser.2.1.9.3", tp, ¨a ¥ b ¥ cÆ, tp ¨a ¥ (b ¥ c)Æ ),
	("ZParser.2.1.9.4", tp, ¨a § b § cÆ, tp ¨a § (b § c)Æ )
];
=TEX
The tenth block tests the unary schema operators against the
binary schema operators.
=SML
fun gp2_chk4 (ZTmLogInOpâS(op1, a1, b1), ZTmLogInOpâS(op2, a2, b2)) : bool = (
	op1 = op2 andalso gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTm˘(a1, b1), ZTm˘(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (ZTmª(a1, b1), ZTmª(a2, b2)) : bool = (
	gp2_chk4(a1, a2) andalso gp2_chk4(b1, b2)
) | gp2_chk4 (t1, ZTmBracketed t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmBracketed t1, t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTm≥âS t1, ZTm≥âS t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmÑ t1, ZTmÑ t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmò t1, ZTmò t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (ZTmPre t1, ZTmPre t2) = (gp2_chk4 (t1, t2)
) | gp2_chk4 (t1, t2) = tm_eq (t1, t2);
=SML
store_mt_results_show (mt_runf gp2_chk4)
[
	("ZParser.2.1.10.1", sp, ¨≥ b ≤ cÆ, sp ¨(≥ b) ≤ cÆ ),
	("ZParser.2.1.10.2", sp, ¨≥ b ≤ cÆ, sp ¨(≥ b) ≤ cÆ ),
	("ZParser.2.1.10.3", sp, ¨≥ b ¥ cÆ, sp ¨(≥ b) ¥ cÆ ),
	("ZParser.2.1.10.4", sp, ¨≥ b § cÆ, sp ¨(≥ b) § cÆ ),
	("ZParser.2.1.10.5", sp, ¨≥ b ªâs cÆ, sp ¨(≥ b) ªâs cÆ ),
	("ZParser.2.1.10.6", sp, ¨≥ b ˘âs cÆ, sp ¨(≥ b) ˘âs cÆ ),
	("ZParser.2.1.10.7", sp, ¨Ñ b ≤ cÆ, sp ¨(Ñ b) ≤ cÆ ),
	("ZParser.2.1.10.8", sp, ¨Ñ b ≤ cÆ, sp ¨(Ñ b) ≤ cÆ ),
	("ZParser.2.1.10.9", sp, ¨Ñ b ¥ cÆ, sp ¨(Ñ b) ¥ cÆ ),
	("ZParser.2.1.10.10", sp, ¨Ñ b § cÆ, sp ¨(Ñ b) § cÆ ),
	("ZParser.2.1.10.11", sp, ¨Ñ b ªâs cÆ, sp ¨(Ñ b) ªâs cÆ ),
	("ZParser.2.1.10.12", sp, ¨Ñ b ˘âs cÆ, sp ¨(Ñ b) ˘âs cÆ ),
	("ZParser.2.1.10.13", sp, ¨ò b ≤ cÆ, sp ¨(ò b) ≤ cÆ ),
	("ZParser.2.1.10.14", sp, ¨ò b ≤ cÆ, sp ¨(ò b) ≤ cÆ ),
	("ZParser.2.1.10.15", sp, ¨ò b ¥ cÆ, sp ¨(ò b) ¥ cÆ ),
	("ZParser.2.1.10.16", sp, ¨ò b § cÆ, sp ¨(ò b) § cÆ ),
	("ZParser.2.1.10.17", sp, ¨ò b ªâs cÆ, sp ¨(ò b) ªâs cÆ ),
	("ZParser.2.1.10.18", sp, ¨ò b ˘âs cÆ, sp ¨(ò b) ˘âs cÆ ),
	("ZParser.2.1.10.19", sp, ¨pre b ≤ cÆ, sp ¨(pre b) ≤ cÆ ),
	("ZParser.2.1.10.20", sp, ¨pre b ≤ cÆ, sp ¨(pre b) ≤ cÆ ),
	("ZParser.2.1.10.21", sp, ¨pre b ¥ cÆ, sp ¨(pre b) ¥ cÆ ),
	("ZParser.2.1.10.22", sp, ¨pre b § cÆ, sp ¨(pre b) § cÆ ),
	("ZParser.2.1.10.23", sp, ¨pre b ªâs cÆ, sp ¨(pre b) ªâs cÆ ),
	("ZParser.2.1.10.24", sp, ¨pre b ˘âs cÆ, sp ¨(pre b) ˘âs cÆ )
];
=TEX
\subsection{Subgroup 2}
This subgroup tests the relative precedences and
association rules of fancy-fix operators.
=SML
fun €top_connective› (ZTmFancyApp (id, _)) = id
|   top_connective _ = fail "mdt061" ~61001 [];

fun assoc_left (ZTmFancyApp (_, ZTmTuple[ZTmFancyApp _, _])) = true
|   assoc_left _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.2.1.1", top_connective o tp, ¨if a then b else 1 + 2Æ, zif),
	("ZParser.2.2.1.2", top_connective o tp, ¨a ≠ b + cÆ, zfun),
	("ZParser.2.2.1.3", top_connective o tp, ¨a ≠ b ﬂ cÆ, zfun)
];
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.2.2.1", assoc_left o tp, ¨i1 + 2 + 3Æ, false),
	("ZParser.2.2.2.2", assoc_left o tp, ¨a ≠ b ≠ cÆ, false),
	("ZParser.2.2.2.3", assoc_left o tp, ¨a ﬂ b ﬂ cÆ, false)
];
=TEX
\subsection{Subgroup 3}
This subgroup tests the remaining rules about
expressions.
=TEX
=SML
fun €is_set_disp› (ZTmSetd _) = true | is_set_disp _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.1.1", is_set_disp o tp, ¨{X}Æ, true)
];
=TEX
=SML
fun €is_var› (ZTmLVar _) = true | is_var _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.2.1", is_var o tp, ¨X[Y]Æ, true)
];
=TEX
=SML
fun €is_pred_op› (ZTmLogInOpâF _) = true
|   €is_pred_op› (ZTmQuantâF _) = true
|   €is_pred_op› (ZTm≥âF _) = true
| is_pred_op _ = false;
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.3.1", is_pred_op o tp, ¨X ± YÆ, true),
	("ZParser.2.3.3.2", is_pred_op o tp, ¨X ≤ YÆ, true),
	("ZParser.2.3.3.3", is_pred_op o tp, ¨X ¥ YÆ, true),
	("ZParser.2.3.3.4", is_pred_op o tp, ¨X § YÆ, true),
	("ZParser.2.3.3.5", is_pred_op o tp, ¨≥ YÆ, true),
	("ZParser.2.3.3.6", is_pred_op o tp, ¨µX|Y∑QÆ, true),
	("ZParser.2.3.3.7", is_pred_op o tp, ¨∂X|Y∑QÆ, true),
	("ZParser.2.3.3.8", is_pred_op o tp, ¨∂â1X|Y∑QÆ, true)
];
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.2.3.4.1", is_pred_op o sp, ¨X ± YÆ, false),
	("ZParser.2.3.4.2", is_pred_op o sp, ¨X ≤ YÆ, false),
	("ZParser.2.3.4.3", is_pred_op o sp, ¨X ¥ YÆ, false),
	("ZParser.2.3.4.4", is_pred_op o sp, ¨X § YÆ, false),
	("ZParser.2.3.4.5", is_pred_op o sp, ¨≥ YÆ, false),
	("ZParser.2.3.4.6", is_pred_op o sp, ¨µX|Y∑QÆ, false),
	("ZParser.2.3.4.7", is_pred_op o sp, ¨∂X|Y∑QÆ, false),
	("ZParser.2.3.4.8", is_pred_op o sp, ¨∂â1X|Y∑QÆ, false)
];
=TEX
=SML
fun chk_2_3_5 (ZTmFancyApp(_, ZTmTuple[ZTmBracketed p,_ ])) = is_pred_op p
|    chk_2_3_5 _ = fail "mdt061.2.3.5 test failed" 16000 [];

store_mt_results_show mt_run
[
	("ZParser.2.3.5.1", chk_2_3_5 o tp, ¨(µX|Y∑Q) ∫ ZÆ, false)
];
=TEX
\subsubsection{Group 3}
This group tests the paragraph processing.
The semantics of paragraph processing will be checked out in the
tests for the paragraph processor \cite{DS/FMU/IED/DTD049} so here
we just check that the parser classifies the paragraphs correctly.
=SML
fun pp x = (
	case z_parser {is_quot = false, standard = false} x of
		ZParaFixity _ => "fixity"
	|	ZParaAbbDef _ => "abbdef"
	|	ZParaSchBox _ => "schbox"
	|	ZParaAxDes _ => "axdes"
	|	ZParaFreeType _ => "freetype"
	|	ZParaGivenSet _ => "givenset"
	|	ZParaConstraint _ => "constraint"
	|	ZParaConjecture _ => "conjecture"
	|	ZParaTerm _ => "term"
);
=TEX
=SML
fun €d› l = rev (tl (rev l));
=TEX
=SML
store_mt_results_show mt_run
[
	("ZParser.3.1", pp, ¨f aÆ, "constraint"),
	("ZParser.3.2", pp, ¨[x]Æ, "givenset"),
	("ZParser.3.3", pp, ¨[x, y, z]Æ, "givenset"),
	("ZParser.3.4", pp, ¨[x, y, z] & a = bÆ, "givenset"),
	("ZParser.3.5", pp, ¨x ::= f a | g bÆ, "freetype"),
	("ZParser.3.6", pp, ¨x ::= f a | g b & y ::= h xÆ, "freetype")
,
	("ZParser.3.7", pp, ZTAx :: ¨x : XÆ, "axdes"),
	("ZParser.3.8", pp, ZTAx :: ¨x : X ˜ x = xÆ, "axdes"),
	("ZParser.3.9", pp, ZTAx :: d ¨[A,B]Æ @ [ZTBar] @¨x : X ˜ x = xÆ, "axdes"),
	("ZParser.3.10", pp, ZTSch :: d ¨XÆ @ [ZTIs] @ ¨x : X ˜ x = xÆ, "schbox"),
	("ZParser.3.11", pp, ZTSch :: d ¨X[A,B,C]Æ @ [ZTIs] @ ¨x : X ˜ x = xÆ, "schbox"),
	("ZParser.3.12", pp, ZTSch :: d ¨X[A,B,C]Æ @ [ZTIs] @ ¨x : X ˜ x = xÆ, "schbox"),
	("ZParser.3.13", pp, ¨x ¶ yÆ, "abbdef"),
	("ZParser.3.14", pp, ¨fun _ = _Æ, "fixity"),
	("ZParser.3.15", pp, ¨fun 99 _ = _, _xÆ, "fixity"),
	("ZParser.3.16", pp, ¨gen 99 _ = _, _xÆ, "fixity"),
	("ZParser.3.17", pp, ¨rel _ = _, _xÆ, "fixity")
];
=TEX
\subsubsection{Group 4}
This group of tests exhibits the reachable error
messages. (Since local definitions are not currently in \cite{DS/FMU/IED/DEF007}
we do not test this error.)
=SML
diag_line"*** mdt061 here: expect 3 Z-Parser error reports after this message ***";
store_mt_results_show mt_run_fail
[
	("ZParser.4.1", pp, ¨f(aÆ, gen_fail_msg "Z-Parser" 61000 []),
	("ZParser.4.2", pp, ¨f)aÆ, gen_fail_msg "Z-Parser" 61000 []),
	("ZParser.4.3", pp, ¨[]][Æ, gen_fail_msg "Z-Parser" 61000 [])
];
=TEX

=TEX
\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
