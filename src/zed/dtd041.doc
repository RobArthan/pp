=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for the  Z Predicate Calculus}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Z in HOL Predicate Calculus}
\TPPref{DS/FMU/IED/SML049}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.~Prout & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and tactics for the Z Proof Support System predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.B.~Jones
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Removed $Z\_STRIP\_GOAL\_T$, $Z\_STRIP\_THM\_THEN$, $Z\_strip\_tac$, \newline $Z\_strip\_asm\_tac$, $Z\_check\_asm\_tac$, $Z\_Œ\_IN\_THEN$ and $Z\_Œ\_in\_tac$.

Tidied up theorems and conversion about $U$ into a single conversion $Z\_U\_true\_conv$ (for use in stripping and rewriting).
\item [Issue 1.3]
Added signature $ZPredicateCalculus$, and references to HLDS etc.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})] 
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference and conversions and tactics for
the Z Proof Support System (see \cite{DS/FMU/IED/SML052}) predicate calculus.
This is called for in \cite{DS/FMU/IED/SML053}.
The design is
implemented in \cite{DS/FMU/IED/IMP???}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and tactics for the predicate calculus of the Z Proof Support System. In section \ref{U} there are some conversions and theorems which assist in enabling set  generic definitions to be treated as polymorphic definitions.   
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the Z proof support system makefile.

\section{Z PREDICATE CALCULUS}
=DOC
signatureâZPredicateCalculusá = sig
=DESCRIBE
This provides the rules of inference, conversions and tactics for predicate calculus in the Z proof support system.
=FAILURE
=ENDDOC

\section{SET GENERIC DEFINITIONS} \label{U}

In \cite{DS/FMU/IED/DTD???} the following `transparent type' definition is given.


 ëU[X]ü
ÝU : ‘ X
É
ÝU = X
Ë



This definition is supplied purely for convenience. If a set is not specified, the type inferer substitutes $: U$. This leads to terms which are polymorphic, rather than truly set generic. The following theorems and conversion about $U$ are provided to facilitate discharging the proof obligation of implicit predicates in Z declarations.
=DOC
val âZ_‘U_thmá : THM;
val âZ_U_thmá : THM;
val âZ_‘U_thm1á : THM;
val âZ_U‰U_thmá : THM;
val âZ_UUthmá : THM;
=DESCRIBE
Theorems which simplify types and membership of types constructed from $U$ and the type constructors $‘$, $‰$ and $$.
=THEOREM
Z_‘U_thm
É
É
‘ U = U
=TEX
=THEOREM
Z_U_thm
É
É
P  U
=TEX
=THEOREM
Z_‘U_thm1
É
É
P  ‘ U
=TEX
=THEOREM
Z_U‰U_thm
É
É
(U ‰ U) = U
=TEX
=THEOREM
Z_thm
É
É
(U  U) = U
=TEX
=ENDDOC
=DOC
val âZ_U‰_convá : CONV;
=DESCRIBE
Simplifies to $U$ an n-tuple cartesian product whose constituents are $U$. 
=CONVERSION
Z_U‰_conv
»(U ‰ U) ‰ U ‰ (U ‰ U ‰ U) ‰ ...¼
É
É
… ((U ‰ U) ‰ U ‰ (U ‰ U ‰ U) ‰ ...) = U
=TEX
=ENDDOC


We give two rules for specialising generic variables to $U$.

=DOC
val âƒU_elimá : THM -> THM;
=DESCRIBE
A rule that specialises one generic variable of a Z generic universal to U ( of the right type ).
=RULE
ƒU_elim
É
ö … [X°,X¬,...] ƒ D | P° Ž P¬
É
ö … [X¬,...] ƒ D' | P°' Ž P¬'
=TEX
where D', P°', P¬' are the result of replacing all occurrences of X° in D , P° and P¬ by U, with type corresponding to X°. 
=ENDDOC


=DOC
val âall_ƒU_elimá : THM -> THM;
=DESCRIBE
A rule that specialises all generic  variables of a Z generic universal to U ( of the right type ).
=RULE
all_ƒU_elim
É
ö … [X°,X¬,...] ƒ D | P° Ž P¬
É
ö … ƒ D' | P°' Ž P¬'
=TEX
where D' , P°', P¬' are the result of replacing all occurrences of X°, X¬, ... in D, P° and P¬  by U, each U with type corresponding to X°, X¬,... respectively.
=ENDDOC



\section{CONVERSIONS AND RULES}
This section is divided into two main areas. Section \ref{ZCONV} describes conversions and rules which always produce Z terms. In section \ref{OTHERCONV} conversions and rules are described which convert Z terms to HOL terms and vice versa. These constructs are designed for the  more sophisticated user who may, for example, wish to write his own conversions and tactics.
\subsection{Z Conversions}\label{ZCONV}
\subsubsection{Z Universal Quantification}
=DOC
val âZ_ƒ_elimá : TERM list -> THM -> THM;
=DESCRIBE
Instantiate all Z universally quantified variables to given values of the right type in a list.

=RULE
Z_ƒ_elim
[»y° : X°¼,»y¬ : X¬¼,...]
É
ö … ƒx°:X°;x¬:X¬;... | P° Ž P¬
É
ö … ((y°  X°) € (y¬  X¬) € ... 
€ P° Š P¬)
=TEX
=ENDDOC




=DOC
val âZ_ƒ_introá :  THM -> THM;
=DESCRIBE
A rule to introduce a Z universal. The variables to be quantified over must not occur free in the assumptions.
=RULE
Z_ƒ_intro
É
ö … ((x  X) € R) € P° Š P¬
É
ö … ƒx:X;R | P° Ž P¬
=TEX
=FAILURE
	theorem not of the form ö … D € P° Š P¬
	x appears free in the assumptions
=ENDDOC



=DOC
val âZ_ƒ_U_convá : CONV;
=DESCRIBE
A conversion that converts those Z universals whose declaration parts  are $true$ (under the conversion $decl\_true\_conv$) and predicate parts are $true$ into  Z generic  predicates.

=CONVERSION

Z_ƒ_U_conv 
»ƒx° ... xÔ :U | true Ž  P¼
É

É
… (ƒx° ... xÔ :U | true Ž  P) = 
[x°, ... xÔ] P
=TEX
and
=CONVERSION

Z_ƒ_U_conv 
»ƒx° ... xÔ :‘ U | true Ž  P¼
É

É
… (ƒx° ... xÔ :‘ U | true Ž  P) = 
[x°, ... xÔ] P
=TEX
and
=CONVERSION

Z_ƒ_U_conv 
»ƒx° ... xÔ : (U ‰ U) ‰ U ‰..| true Ž  P¼
É

É
… (ƒx° ... xÔ : (U ‰ U) ‰ U ‰..| true Ž  P) = 
[x°, ... xÔ] P
=TEX
and
=CONVERSION

Z_ƒ_U_conv 
»ƒx° ... xÔ : U  U | true Ž  P¼
É

É
… (ƒx° ... xÔ : U  U | true Ž  P) = 
[x°, ... xÔ] P
=TEX
=FAILURE
	term is not a universal quantification
	term not convertible to a generic predicate

=ENDDOC
It is not a requirement that all variables in the declaration have the same type ( in the above examples this is simply done for convenience ). Arbitrary iterations of the type constructors $‘$, $‰$ and $$ are permitted.


\subsubsection{Z Existential Quantification}

=DOC
val âZ_„°_convá : CONV;
=DESCRIBE
Converts a Z unique existential quantification to a Z existential quantification. 
=CONVERSION
Z_„_conv 
»„°D | P° Ž P¬¼
É

É
… („°D | P° Ž P¬) = 
(„D | P° Ž P¬ ) €
(ƒ D D' | P P' Ž n° = n°' € ...)
=TEX
=FAILURE
	term is not a unique existential quantification
=ENDDOC
\subsubsection{Conversions between Z Universal and Existential Quantifications}


=DOC
val âZ_Œƒ_convá : CONV;
=DESCRIBE
Converts a negated Z universal to a Z existential quantification.
=CONVERSION
Z_Œƒ_conv 
»Œ(ƒ D | P° Ž P¬)¼
É

É
… Œ(ƒ D | P° Ž P¬) = („ D | P° Ž Œ P¬)

=TEX
=FAILURE
	term not a negation
	term is not a universal quantification
=ENDDOC



=DOC
val âZ_Œ„_convá : CONV;
=DESCRIBE
Converts a negated Z existential to a Z universal quantification.
=CONVERSION
Z_Œ„_conv 
»Œ(„ D | P° Ž P¬)¼
É

É
… Œ(„ D | P° Ž P¬) = (ƒ D | P° Ž Œ P¬)

=TEX
=FAILURE
	term not a negation
	term is not an existential quantification
=ENDDOC



=DOC
val âZ_„Œ_convá : CONV;
=DESCRIBE
Converts a  Z existential with a negated predicate to a negated Z universal quantification.
=CONVERSION
Z_„Œ_conv 
»„ D | P° Ž Œ P¬¼
É

É
… („ D | P° Ž Œ P¬) = Œ (ƒ D | P° Ž P¬)

=TEX
=FAILURE
	term is not an existential quantification
	term not a negation
=ENDDOC


=DOC
val âZ_ƒŒ_convá : CONV;
=DESCRIBE
Converts a  Z universal with a negated predicate to a negated Z existential quantification.
=CONVERSION
Z_ƒŒ_conv 
»ƒ D | P° Ž Œ P¬¼
É

É
… (ƒ D | P° Ž Œ P¬) = Œ („ D | P° Ž P¬)

=TEX
=FAILURE
	term is not a universal quantification
	term not a negation

=ENDDOC
\subsection{Other Conversions}\label{OTHERCONV}
\subsubsection{Conversions betweens Declarations and Predicates}
=DOC
val âdec_elim_convá : CONV;
=DESCRIBE
A conversion which rewrites a $dec$ type of declaration  to set membership. A $decsexp$ type of declaration remains unchanged (since $decsexp$ and $predsexp$ are, in fact, the same thing). 
=CONVERSION
dec_elim_conv »x : X¼
É
É
… (x : X) = x  X
=TEX
and
=CONVERSION
dec_elim_conv »S¼ 
É

É
… S = S
=TEX
where S is a schema (here promoted to a predicate).
=ENDDOC



=DOC
val âdecl_elim_Cá : CONV -> CONV;
=DESCRIBE
$decl\_elim\_C$ applies the supplied conversion to each member of a declaration and returns the conjunction of the results. 
=ENDDOC


=DOC
val âdec_intro_convá : CONV;
=DESCRIBE
A conversion which rewrites to declarations the three cases : set membership, schema promoted to predicate and theta term.
=CONVERSION
dec_intro_conv »x  X¼
É

É
… x  X = (x : X)
=TEX
and
=CONVERSION
dec_intro_conv »S º bool¼ 
É

É
… S = S
=TEX
and
=CONVERSION
dec_intro_conv »­S  S¼ 
É

É
… (­S  S) = S
=TEX
=FAILURE
	term cannot be a declaration
=ENDDOC



=DOC
val âdecl_intro_Cá : CONV -> CONV;
=DESCRIBE
$decl\_intro\_C$ reduces a predicate to conjunctive normal form, then applies the supplied conversion to each conjunct.
If this is successful, it produces a declaration from the results.

=ENDDOC


=DOC
val âdecl_true_convá : CONV;
=DESCRIBE
A conversion which rewrites a declaration to $true$ where possible. 
=SEEALSO
$Z\_ƒ\_U\_conv$
=ENDDOC

Theorems  and conversion described in section \ref{U} are used in this conversion.
\subsubsection{Z Universal Quantification}
=DOC
val âZ_ƒ_elim_convá : CONV;
=DESCRIBE
Convert a Z universal quantification to a HOL universal quantification. 

The implicit predicate in the declaration part of the Z term (x°:X°..), becomes explicit  in the HOL term (x°  X°..). The variables are renamed to those of the Z universal definition with the appropriate number of quantified variables.
=CONVERSION
Z_ƒ_elim_conv 
»ƒx°:X°;x¬:X¬;... | P° Ž P¬¼
É
É
… (ƒx°:X°;x¬:X¬;... | P° Ž P¬) = 
(ƒa° a¬ ... Ž ((a°  X°) € (a¬  X¬) € ..) 
€ P° Š P¬)
=TEX
=FAILURE
	term is not a universal quantification
=SEEALSO
$Z\_ƒ\_elim\_aconv$
=ENDDOC



=DOC
val âZ_ƒ_elim_aconvá : CONV;
=DESCRIBE
Convert a Z universal quantification to a HOL universal quantification. 

The implicit predicate in the declaration part of the Z term (x°:X°..),becomes explicit  in the HOL term (x°  X°..). Variable names are those of the Z term.
=CONVERSION
Z_ƒ_elim_aconv 
»ƒx°:X°;x¬:X¬;... | P° Ž P¬¼
É
É
… (ƒx°:X°;x¬:X¬;... | P° Ž P¬) = 
(ƒx° x¬ ... Ž ((x°  X°) € (x¬  X¬) € ..) 
€ P° Š P¬)
=TEX
=FAILURE
	term is not a universal quantification
=SEEALSO
$Z\_ƒ\_elim\_conv$
=ENDDOC
=DOC
val âZ_ƒ_intro_convá : CONV;
=DESCRIBE
This conversion is a strict inverse of $Z\_ƒ\_elim\_conv$. It will convert a HOL universal quantification to a Z universal quantification, provided the HOL term is producible by $Z\_ƒ\_elim\_conv$.

=CONVERSION

Z_ƒ_intro_conv 
»ƒx° ... xÔ Ž 
(((x°  X°) € ... € R € S) € P°) Š P¬¼
É

É
… (ƒx° ... xÔŽ 
(((x°  X°) € ... € (R € S)) € P°) Š P¬) = 
(ƒx° : X° ; ... ; R ; S | P° Ž P¬)
=TEX
=FAILURE
	term not convertible
=ENDDOC
\subsubsection{Z Existential Quantification}
=DOC
val âZ_„_elim_convá : CONV;
=DESCRIBE
Converts a Z existential quantification to a HOL existential quantification. The variables are renamed to those of the Z existential definition with the appropriate number of quantified variables.
=CONVERSION
Z_„_elim_conv 
»„x°:X°;x¬:X¬;... | P° Ž P¬¼
É

É
… („x°:X°;x¬:X¬;... | P° Ž P¬) = 
(„a° a¬ ... Ž ((a°  X°) € (a¬  X¬) € ..)
€ P° € P¬)
=TEX
=FAILURE
	term is not an existential quantification
=SEEALSO
$Z\_„\_elim\_aconv$
=ENDDOC



=DOC
val âZ_„_elim_aconvá : CONV;
=DESCRIBE
Converts a Z existential quantification to a HOL existential quantification. Variable names are those of the Z term.
=CONVERSION
Z_„_elim_aconv 
»„x°:X°;x¬:X¬;... | P° Ž P¬¼
É

É
… („x°:X°;x¬:X¬;... | P° Ž P¬) = 
(„x° x¬ ... Ž ((x°  X°) € (x¬  X¬) € ..)
 € P° € P¬)
=TEX
=FAILURE
	term is not an existential quantification
=SEEALSO
$Z\_„\_elim\_conv$
=ENDDOC



=DOC
val âZ_„_intro_convá : CONV;
=DESCRIBE
An exists introduction conversion, the inverse of $Z\_„\_elim\_conv$.
=CONVERSION
Z_„_intro_conv 
»„x° ... xÔ Ž 
((x°  X°) € ... € R € S) € P° € P¬¼
É

É
… („x° ... xÔ Ž ((x°  X°) € ... € (R € S))
€ P° € P¬) =
(„x° : X° ; ... ; R ; S | P° Ž P¬)
=TEX
=FAILURE
	term not convertible
=ENDDOC






\section{TACTICS}
\subsection{Z Universal Goal}
=DOC
val âZ_ƒ_tacá : TACTIC ;
=DESCRIBE
Simplify a universally quantified subgoal.
=TACTIC
Z_ƒ_tac
É
{ ö } »ƒ x°:X°;x¬:X¬;... | P° Ž P¬¼
É
{ ö } ((x°'  X°) € (x¬'  X¬) € ..) 
€ P° Š P¬
=TEX
where $x°'$ , $x¬'$ ,..are  variant names of $x°$, $x¬$,.., different from any 
variable in $ö$ or $P°$ or $P¬$.
=USES
Tactic programming.

=SEEALSO
$ƒ\_tac$
=FAILURE
	Subgoal is not of the form: `{ ö } ƒ D | P° Ž P¬`

=ENDDOC

\subsection{Z Existential Goal}
=IGN
Extra error message required when too many witnesses supplied:(check Z_„_match_tac as well)
fun	(âZ_„_tacá  tml) : tactic = (fn (asms,conc) =>
	let	val(subgoals,prf) =
		((CONV_TAC Z_„_elim_conv) THEN 
		MAP_EVERY (fn x => EXISTS_TAC x) tml)(asms,conc);
		val (asms,new_conc) = hd subgoals;
	in
	(if(is_exists(new_conc)) 
		then (NO_TAC(asms,conc))
	else ([(asms,new_conc)],prf))
	end
	handle complaint =>
	divertl complaint "Z_„_tac"
	[("Z_„_elim_conv","goal not of form `?x.P'" ),
	("EXISTS_TAC","witness type error"),
	("FAIL_TAC","not enough witnesses supplied"),
	("dest_exists","too many witnesses supplied")]);
=TEX

=DOC
val âZ_„_tacá : TERM list -> TACTIC ;
=DESCRIBE
Provide a list of witnesses for all bound variables of an existential subgoal.
=TACTIC
Z_„_tac
[»t°¼,»t¬¼,...]
É
{ ö } »„ x°:X°;x¬:X¬;... | P° Ž P¬¼
É
{ ö } ((t°  X°) € (t¬  X¬) € ..) € P° € P¬
=TEX
where $t°$, $t¬$  etc. must have the same type as $x°$, $x¬$ etc.
=USES
Tactic programming.
=FAILURE
	Subgoal is not of the form: `{ ö } „ D | P° Ž P¬`
	witness type error
	not enough witnesses supplied
	too many witnesses supplied

=ENDDOC
Differs from $„\_tac$ in ICL HOL in that $„\_tac$ provides a single witness for an existential subgoal.
=DOC
val âZ_„_match_tacá : TERM list -> TACTIC ;
=DESCRIBE
Provide a list of untyped terms as witnesses for an existential subgoal.
=TACTIC
Z_„_match_tac
[»t°¼,»t¬¼,...]
É
{ ö } »„ x°:X°;x¬:X¬;... | P° Ž P¬¼
É
{ ö } ((t°  X°) € (t¬  X¬) € ..) € P° € P¬
=TEX
=FAILURE
	Subgoal is not of the form: `{ ö } „ D | P° Ž P¬`
	witness type error
	not enough witnesses supplied
	too many witnesses supplied

=ENDDOC
\section{STRIPPING TECHNIQUES}
In ICL HOL there is a group of tactics and tacticals mainly concerned with supplying support for predicate calculus connectives, documented in \cite{DS/FMU/IED/DTD028}. We use the mechanisms provided in \cite{DS/FMU/IED/DTD028} to supply appropriate conversions to these tactics and tacticals which correspond to the inference rules for the Z predicate calculus connectives. 

\subsection{Stripping Goals, Theorems and Assumptions}

The goal stripping techniques are packaged as a tactical
$STRIP\_GOAL\_T$ whose argument is a theorem tactic which
is used to process any new assumptions which may arise from stripping
the goal. The theorem stripping techniques are packaged as a theorem
tactical $STRIP\_THM\_THEN$. The actual capabilities of
$STRIP\_GOAL\_T$ and $STRIP\_THM\_THEN$ are determined by assignable
variables containing lists of additional conversions to be attempted on a
given goal or a theorem. This allows application-specific transformations
to be handled in a uniform manner with the predicate calculus transformations
dealt with in \cite{DS/FMU/IED/DTD028}. We provide some basic conversions to handle the Z predicate calculus connectives. In addition,  within a Z application, conversions appropriate to that application could be added to that list. For example, in Z set theory proofs it would be desirable to include the set elimination conversion $Z\_seta\_elim\_conv$, described in \cite{DS/FMU/IED/DTD???},  in the list of conversions to be attempted on the
given goal or theorem.


\subsubsection{Stripping Goals}
$STRIP\_GOAL\_T$ attempts to apply a tactic from a list of primitive tactics. If no member of the list applies, then $STRIP\_GOAL\_T$ attempts to find an applicable conversion in the list maintained by  $set\_strip\_goal\_convs$ and
$get\_strip\_goal\_convs$ to rewrite the outermost connective in the goal. For Z, the following conversions are included in this list :

\begin{enumerate}
\item
$Z\_ƒ\_elim\_aconv$ to eliminate Z universal quantifications.
\item
$Z\_Œ\_in\_conv$ for handling Z negations, described in section \ref{NEG}.
\end{enumerate}


\subsubsection{Stripping Theorems}
$STRIP\_THM\_THEN$ provides a general purpose way of
stripping theorems into primitive constituents before
using them in a tactic proof. It attempts to apply a theorem tactical from a list of primitive theorem tacticals. If no member of the list applies, then $STRIP\_THM\_THEN$ attempts to find an applicable conversion in the list maintained by  $set\_strip\_thm\_convs$ and
$get\_strip\_thm\_convs$ to rewrite the outermost connective in the theorem. For Z, the following conversions are included in this list :

\begin{enumerate}
\item
$Z\_„\_elim\_aconv$ to eliminate Z existential quantifications.
\item
$Z\_À\_elim\_conv$ for converting Z unique existential quantifications into Z existential quantifications.
\item
$Z\_Œ\_in\_conv$ for handling Z negations, described in section \ref{NEG}.
\item
$Z\_U\_true\_conv$ for converting terms of the form $ x  U $ into $ true$, described in section \ref{UTRUE}.
\end{enumerate}

\subsubsection{Stripping Assumptions}

$strip\_asm\_tac$ is a theorem tactic which repeatedly applies
$STRIP\_THM\_THEN$ to a theorem tactic $check\_asm\_tac$ which
acts as follows:

ó
check_asm_tac (ñ … true) ({ö} t)		‹ ({ö} t)
check_asm_tac (ñ … false) ({ö} t)		‹ []
check_asm_tac (ñ … t) ({ö} t)			‹ []
check_asm_tac (ñ … Œa) ({ö, a} t)		‹ []
check_asm_tac (ñ … a) ({ö, Œa} t)		‹ []
check_asm_tac (ñ … a) ({ö} t)			‹ ({a, ö}, t)
æ

where $[]$ denotes an empty list of subgoals, i.e. that the tactic proves
the goal. 



\subsection{Concerning Œ}\label{NEG}
We give the conversion for pushing $Œ$ through Z logical connectives:
=DOC
val âZ_Œ_in_convá : conv;
=DESCRIBE
A conversion which  moves $Œ$ inside other Z predicate calculus
connectives.
=CONVERSION
Z_Œ_in_conv
»Œ(Œt)¼
É
É
… Œ(Œt) = t
=TEX
=CONVERSION
Z_Œ_in_conv
»Œ(t1 € t2)¼
É
É
… Œ(t1 € t2) = (Œt1  Œt2)
=TEX
=CONVERSION
Z_Œ_in_conv
»Œ(t1  t2)¼
É
É
… Œ(t1  t2) = (Œt1 € Œt2)
=TEX
=CONVERSION
Z_Œ_in_conv
»Œ(t1 Š t2)¼
É
É
… Œ(t1 Š t2) = (t1 € Œt2)
=TEX
=CONVERSION
Z_Œ_in_conv
»Œ(t1 ‚ t2)¼
É
É
… Œ(t1 ‚ t2) = (t1 € Œt2)  (t2 € Œt1)
=TEX
=CONVERSION
Z_Œ_in_conv
»Œ(ƒD | P° Ž P¬)¼
É
É
… Œ(ƒD | P° Ž P¬) = („D | P° Ž Œ P¬)
=TEX
=CONVERSION
Z_Œ_in_conv
»Œ(„D | P° Ž P¬)¼
É
É
… Œ(„D | P° Ž P¬) = (ƒD | P° Ž Œ P¬)
=TEX
=CONVERSION
Z_Œ_in_conv
»Œ(ÀD | P° Ž P¬)¼
É
É
… Œ(ÀD | P° Ž P¬) = 
Œ(„D | P° Ž P¬)  
Œ(ƒD D' | P P' Ž n° = n°' € ...)
=TEX
=CONVERSION
Z_Œ_in_conv		Z_Œ_in_conv
»Œfalse¼		»Œtrue¼
É
É
… Œ false = true 	 … Œ true = false
=TEX
=ENDDOC
\subsection{Concerning U}\label{UTRUE}
=DOC
val âZ_U_true_convá : CONV;
=DESCRIBE
A conversion which  asserts membership of $U$ or any type constructed from $U$ by the type constructors $‘$, $‰$ and $$, is $true$.
=CONVERSION
Z_U_true_conv 
» x  (U ‰ U ‰ U) ‰ ((‘ U)  U) ‰ ..¼
É

É
… ( x  (U ‰ U ‰ U) ‰ ((‘ U)  U) ‰ ..) 
 = true
=TEX
=ENDDOC


\section{REWRITING}\label{REWRITE}
The detailed design for the rewriting rules of inference of ICL HOL is to be found in \cite{DS/FMU/IED/DTD026}. ICL HOL provides for parameterised rewriting via the functions:
ó
set_rewrite_canons
set_basic_rewrites
set_rewrite_convs
æ
\subsection{Canonicalisation Functions}
$set\_rewrite\_canons$ sets  the canonicalisation functions used in rewriting. A list of suggested processing for individual theorems is given in \cite{DS/FMU/IED/DTD026}. In Z rewriting, we may choose to add to this list:
\begin{itemize}
\item
$Z\_\_U\_conv$ to convert Z universals to Z generic  predicates, where possible.
\end{itemize}

\subsection{Basic Rewriting Theorems}

$set\_basic\_rewrites$ sets the list of default rewrites used. In \cite{DS/FMU/IED/DTD026}, a list of basic rewriting theorems for ICL HOL is given. For Z rewriting, the following  theorems are irrelevant and are removed from the basic rewrites:
ó
if_rewrite_thm … ƒ t1 t2:BOOLŽ((if T then t1 else t2) = t1) 
				€ (if F then t1 else t2) = t2

ƒ_rewrite_thm … ƒ tŽ(ƒ xŽt) = t

„_rewrite_thm … ƒ tŽ(„ xŽt) = t

simple_%beta%_rewrite_thm … ƒ t1:'a; t2:'bŽ(( xŽt1)t2) = t1
æ



\subsection{Basic Rewriting Conversions}
$set\_rewrite\_convs$ sets the list of conversions used in rewriting. The following conversions constitute basic rewriting conversions:
\begin{enumerate}
\item
$Z\_U\_true\_conv$ to simplify membership of $U$ or any type constructed from $U$ by the type constructors $‘$, $‰$ and $$, to $true$.
\item
$Z\_ƒ\_true\_conv$ to simplify a Z universal quantification whose body is $true$ to $true$, described below.
\end{enumerate}

=DOC
val âZ_ƒ_true_convá : CONV;
=DESCRIBE
Simplifies a Z universal quantification whose body is $true$ to $true$. 
=CONVERSION
Z_ƒ_true_conv
»ƒx°:X°;x¬:X¬;... | P° Ž true¼
É
É
… (ƒx°:X°;x¬:X¬;... | P° Ž true) = true
=TEX
=ENDDOC


It is envisaged that the list of conversions provided be amended depending on the application. For example, the conversion $Z\_seta\_elim\_conv$ of \cite{DS/FMU/IED/DTD???} would be included in applications involving set theory.

\section{END OF THE SIGNATURE}

=SML
end; (* signature of ZPredicateCalculus *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.



\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=DOC
val â„_match_tacá : TERM -> TACTIC ;
=DESCRIBE
An ICL HOL tactic  which instantiates an untyped witness term to the type of the bound variable.
=TACTIC
„_match_tac
»t1¼
É
{ ö } „ x Ž t2[x]
É
{ ö } t2[t1]
where »t1¼ may be type instantiated to x.
=TEX

 





