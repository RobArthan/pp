=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for the Z Predicate Calculus}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Z Predicate Calculus}
\TPPref{DS/FMU/IED/DTD041}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{G.~Prout & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and tactics for the ProofPower Z predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    FST Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Removed $Z\_STRIP\_GOAL\_T$, $Z\_STRIP\_THM\_THEN$, $Z\_strip\_tac$, \newline $Z\_strip\_asm\_tac$, $Z\_check\_asm\_tac$, $Z\_≥\_IN\_THEN$ and $Z\_≥\_in\_tac$.

Tidied up theorems and conversion about $U$ into a single conversion $Z\_U\_true\_conv$ (for use in stripping and rewriting).
\item [Issue 1.3 (9th July 1992)]
Taken over by KB, and reworked, new fonts.
\item [Issue 1.4 (14th July 1992)]
Significant changes after RBJ, RDA comments.
\item [Issue 1.5 (16th July 1992)]
Changes after RDA comments.
\item [Issue 1.6-1.8]
Changes during implementation.
\item [Issue 1.9 (20th August 1992)]
Added further Z checking functions.
\item [Issue 1.9 (8th September 1992)]
Minor corrections in text.
\item [Issue 1.11 (10th September 1992)]
Corrections after comments.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) predicate calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP041}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and tactics for the predicate calculus of the ProofPower Z.
\subsubsection{Dependencies}
Loading this document is dependent on 
the Z Library \cite{DS/FMU/IED/DTD078} and Z Term generator
\cite{DS/FMU/IED/DTD063}.
\subsubsection{Deficiencies}
The coverage in initial releases of ProofPower Z is aimed at the basic reasoning
tools, rather than a full coverage.
Thus we aim only to cover:
\begin{itemize}
\item
Rewriting
\item
Stripping goals and theorems
\item
$µ$ elimination as inference rule
\item
Contradiction tactic
\item
$∂\_tac$
\end{itemize}
plus some of the auxiliary functions necessary for implementing these.
Thus, initial releases of the ProofPower Z tools will be
deficient in many areas in which reasoning is supported
for HOL.
\section{OVERLAP WITH HOL}
Some functions operating on Z have the same purpose
as an equivalent for HOL,
but perhaps different functionality.

Where this happens we will
\begin{itemize}
\item
By preference use the HOL function, with, if necessary, parameterisation
changes provided by proof contexts (or, more rarely,
if at all, by other parameterisation).
In particular, if the functionality is the same, use the 
same function (e.g. $±\_tac$).
\item
Otherwise we will provide a separately named function for Z work.
The Z name will usually be formed by prefixing by
``$z\_$'', ``$Z\_$'' or ``Z'' (according to naming convention case and atom composition rules
followed by the object's name)
to indicate the object of
concern in the Z variant of the object.
\end{itemize}
Later releases might provide structures whose sole purpose is to
override HOL (i.e. primary language) objects by
their Z equivalents, and to undo this step.
There are both benefits and problems with this, and the final
approach is yet to be decided.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $Ò\ ...\ Æ$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $¡\_to\_z\_conv$ to correct
what problems it can.

Legitimately, we use HOL universal quantification
to represent generic formals.
However we will also allow arbitrary outer universally quantified terms to be considered ``within the Z language'' 
where this is convenient - the most notable example of this
is in $strip\_tac$ when a Z universal quantification is broken into a sequence of HOL universal quantifications.
\section{Z PREDICATE CALCULUS}
=DOC
signature €ZPredicateCalculus› = sig
=DESCRIBE
This provides a set of rules of inference, conversions and tactics sufficient for reasoning about the Z predicate calculus in ProofPower.
This structure declares the theory $z\_set\_theory$,
which is also used by structure $ZSetTheory$.
=ENDDOC
As theory $z\_set\_theory$ is also used by structure
$ZSetTheory$ we delay its theory design until 
\cite{DS/FMU/IED/DTD042}.
\subsection{Subsidiary Functions}
\subsubsection{What is Z}
The following are extensions of work done in \cite{DS/FMU/IED/DTD047},
and perhaps some of this material should be moved to that document.

Errors start with 4100.
=DOC
val €full_dest_z_term› : TERM -> Z_TERM;
=DESCRIBE
This function acts as $dest\_z\_term$ on terms
in the Z language, but checks the full form of the
outermost Z syntactic construction in a
term to see whether it is in the Z language.
Thus, if the consituents of the construction
are valid Z, of appropriate syntactic classes,
then the overall term is also valid Z.
This is in contrast to $dest\_z\_term$ whose
intended purpose is to categorise Z terms,
and it only detects that terms are outside of the Z language if
the categorisation fails.

The function does not check that the constituents of the outermost Z syntactic construction
are as required.
For example, it does not check that the constituents
of a Z $decl$ are individually in the syntactic category $dec$.
=USES
To replace $dest\_z\_term$ when a term may be ``almost Z'',
but must not be categorised as Z.
=FAILURE
41002	Not within the Z language due to subterm ?0
=ENDDOC
=DOC
val €is_z› : TERM -> bool;
val €is_all_z_type› : TYPE -> bool;
=DESCRIBE
If the term or type given is in the range of the Z mapping
for a term or type respectively
then these functions will return true.
They will otherwise return false, unless the
only form of incorrectness is
that the constituents of a Z syntactic construction
are not as required.
For example, it does not check that the constituents
of a Z $decl$ are individually in the syntactic category $dec$.

The test is to traverse the provided object 
by using $full\_dest\_z\-\_term$ or $dest\_z\-\_type$ - the test is passed
if the entire term can be broken into non-type and non-term parts.
Otherwise it will fail with the given error message.

Note that a term is a subterm of itself for these purposes.
=FAILURE
41002	Not within the Z language due to subterm ?0
41003	Not within the Z language due to containing type ?0
=ENDDOC
We use the name $is\_all\_z\_type$ to distinguish
from the previously defined $is\_z\_type$.
=DOC
val €not_z_subterms› : TERM -> TERM list;
=DESCRIBE
This function will return a list (perhaps empty)
of all the subterms that prevent a term being within the
Z language (by the checks of $is\_z$, q.v.), starting with the rightmost subterm that is not Z.
The subterms given will be maximal in the sense that subterms of those given will not be included in the list.
=ENDDOC
=DOC
(* €check_is_z› : boolean flag *)
=DESCRIBE
This flag, if true (the default), will cause all Z inference rules and tactics that claim to remain in the Z langauge
to check any terms they change (i.e. assumptions and conclusions) for remaining within the Z 
language.
If any fail then the informational message 41004 is used
to output text to the user.
If the flag is false, no such checks are made.
The checks are computationally expensive,
and the results may be excessively verbose if terms are not 
all Z.
=FAILURE
41004	The following subterms in the result are not in the Z language: ?0
=ENDDOC
Actually, only initial work the flag will be defaulted to true,
it perhaps later should be false.
=DOC
val €check_is_z_thm› : string -> THM -> THM;
val €check_is_z_goal› : string -> GOAL -> GOAL;
val €check_is_z_term› : string -> TERM -> TERM;
val €CHECK_IS_Z_T› : string -> TACTIC -> TACTIC;
val €check_is_z_conv_result› : string -> THM -> THM;
=DESCRIBE
For $check\_is\_z\_thm$,
if flag $check\_is\_z$ is true then the conclusion and
assumptions of the provided theorem are checked for being 
within the Z language (except for outermost HOL universal quantification), and informational message 41005 used if not.
The string argument is used as the name of the calling function in the error message.
If the flag is false then there is no effect.
In either case the theorem is passed through unchanged.

$check\_is\_z\_goal$ and $check\_is\_z\_term$ are analogous.
$CHECK\-\_IS\-\_Z\-\_T$ checks each of the subgoals
a tactic requests.

$check\-\_is\-\_z\-\_conv\-\_result$ checks
that the RHS of the resulting equational theorem,
and any assumptions are within the
Z language.
This allows the RHS side of the equation to have outer HOL 
universal quantification, and the LHS not to be Z (e.g. in an Z introduction conversion) without complaint.
=FAILURE
41005	In the result of ?0 the following subterms are not in the Z language: ?1
=ENDDOC

\subsubsection{Adjustment after ¡-conversion}
Errors start with 4110.

If a substitution via $var\_subst$ is made upon a term in Z (that may be
part of a theorem or subgoal) by the 
many important functions that call $var\_subst$
(e.g. rewriting and $µ$ elimination),
and if this substitution causes bound variable renaming, the
resulting term may no longer be in the Z language.
This may be because either the types of 
$decl$-style bindings
(see \cite{DS/FMU/IED/ZED002}, the section upon ``Variable Binding Constructs'') may no longer match the variable names bound,
or because the variables in the binding have ceased being in a canonical order.
Either of these two problems can be ``fixed'' by post-processing.
The problems may be adjusted back to Z by using
Z renaming constructs, returning the term to being within
the Z language.

Other ProofPower functions, such as $inst$ may also cause
undesirable renaming.

The following two functions fulfil this need:
=DOC
val €¡_to_z› : TERM -> TERM;
=DESCRIBE
This function will adjust all sub-terms that fail to be 
Z because either:
\begin{itemize}
\item
The subterm is involves a $decl$-style binding, and the type of the binding
does not match the names of the variables bound.
This is adjusted using the Z renaming construct.
\item
The subterm is a $decl$-style binding whose bound variables are not
in the canonical ordering that would result from the Z mapping.
This is adjusted by reorganising the order of abstractions and arguments.
\end{itemize}
If a HOL $¡$-conversion will suffice then that will be
used instead.

Subterms that are not covered by these two cases will be traversed and their own subterms checked, regardless of their language.

NOT YET IMPLEMENTED.
=SEEALSO
$¡\_to\_z\_conv$
=FAILURE
41100	No adjustment took place
=ENDDOC
=DOC
val €¡_to_z_conv› : CONV;
=DESCRIBE
This function will return the equality theorem between a term
and one that adjusts all sub-terms that fail to be 
Z because either:
\begin{itemize}
\item
The subterm is a $decl$-style binding, and the type of the binding
does not match the names of the variables bound.
This is adjusted using the Z renaming construct.
\item
The subterm is a $decl$-style binding whose bound variables are not
in the canonical ordering that would result from the Z mapping.
This is adjusted by reorganising the order of abstractions and arguments.
\end{itemize}
If a HOL $¡$-conversion will suffice then that will be
used instead.

Subterms that are not covered by these two cases will be traversed and their own subterms checked, regardless of their language.

NOT YET IMPLEMENTED.
=SEEALSO
$¡\-\_to\_z$
=FAILURE
41100	No adjustment took place
=ENDDOC

\subsubsection{Concerning The Universe, U} \label{U}
Errors start with 4106.

In \cite{DS/FMU/IED/DTD078} the following definition is given.
 
πù U[X]ú
‹ U :  X
˜
‹ U = X
à

This definition is supplied purely for convenience. 
If a generic global variable appears without any supplied generic actuals then the variable is taken to be generic 
in $ÒUÆ$.
This leads to terms which are polymorphic, rather than truly set generic. The following material about $U$ is provided to facilitate discharging the proof obligation of implicit predicates in Z declarations.
=DOC
val €u_conv› : CONV;
=DESCRIBE
Simplify an expression made from solely from $U$, and one of: $$, arbitrary sized cartesian products, set abstractions, schemas, and $™$. 
Remains within the Z language, though this is not checked.
=FRULE 1 Conversion
u_conv
ÒStructure[U]Æ
˜
˜
Ù Structure[U] = U
=TEX
by one application of one of the following:
=GFT
Ù  U = U
Ù (U ∏ U ∏ ...) = U
Ù {lab1 : U; lab2 : U; lab3,lab4 : U; ... } = U
Ù [lab1 : U; lab2 : U; lab3,lab4 : U; ... ] = U
Ù (U ™ U) = U
=TEX
=USES
In the rewriting section of a proof context,
and to simplify declarations as predicates, while preserving
their declaration as predicate form.
=SEEALSO
$ç\_u\_conv$
=FAILURE
41060	?0 cannot be proven equal to ÒUÆ in one step
=ENDDOC
Later releases may react to introduced generic type abbreviations
that collapse to Universe, introduced given sets
(which are defined to be equal to Universe),
and schema selection from Universe.
=DOC
val €ç_u_conv› : CONV;
=DESCRIBE
Simplifies to $true$ a term of the form 
=INLINEFT
Òx ç S[U]Æ
=TEX
{} or 
=INLINEFT
Òx Ä S[U]Æ
=TEX
{} or  a schema as an expression:
=INLINEFT
Ò[a,b: S[U]; c : S'[U]; ...]Æ
=TEX
{}, where
$S[U]$ and $S'[U]$ are structures made solely from $U$, arbitrary sized cartesian products, set abstractions, schemas, $™$ and $$.
Remains within the Z language, though this is not checked.
=FRULE 1 Conversion
ç_u_conv
Òx ç S[U]Æ
˜
˜
Ù x ç S[U] § true
=TEX
=FRULE 1 Conversion
ç_u_conv
Òx Ä S[U]Æ
˜
˜
Ù x Ä S[U] § true
=TEX
=FRULE 1 Conversion
ç_u_conv
Ò[a,b: S[U]; c : S'[U]; ...]Æ
˜
˜
Ù [a,b: S[U]; c : S'[U]; ...] § true
=TEX
based on recursively using
=GFT
Ù  U = U
Ù (U ∏ U ∏ ...) = U
Ù {lab1 : U; lab2 : U; lab3,lab4 : U; ... } = U
Ù [lab1 : U; lab2 : U; lab3,lab4 : U; ... ] = U
Ù (U ™ U) = U
Ù µ x∑ x ç U
Ù µ x∑ x Ä U
=TEX
=USES
In stripping proof contexts, and in eliminating redundant declarations that have been
converted to predicates.
=SEEALSO
$u\_conv$
=FAILURE
41061	?0 cannot be proven true
41062	?0 is not of the form Òx Ä sÆ, Òx ç sÆ or a schema as a predicate
=ENDDOC
Later releases may react to introduced generic type abbreviations
that collapse to Universe, introduced given sets
(which are defined to be equal to Universe),
and schema selection from Universe.

\subsubsection{Concerning Generic Formals}
These are represented by HOL universals and may thus
be manipulated by $µ\_elim$, etc.
\subsection{Concerning Z Universal Quantification}
Errors start with  4102 or 4107
=DOC
val €z_µ_elim› : TERM -> THM -> THM;
=DESCRIBE
Specialise all Z universally quantified variables 
in a single universal binding to given values of the right type in a binding.
=FRULE 1 Rule
z_µ_elim
Ò(xâ1 ¶ tâ1, ... )Æ
˜
á Ù µ D[xâ1,...] | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
á Ù "D[tâ1,...] as predicate"
    ± Pâ1'[tâ1,...] ¥ Pâ2'[tâ1,...]
=TEX
where $D$ is a declaration that binds the $xâi$,
that is converted to a predicate form, by 
=INLINEFT
DECL_C dec_pred_conv
=TEX
. 
The theorem may be type instantiated to allow the 
specialisation to be valid, thus the primed $Pâi$.

If both the supplied binding and the declaration are
recognisably ``empty'' then the universal quantification will be eliminated.

If instead the theorem's conclusion has a single universally quantified variable and the theorem can be type instantiated to match the supplied argument, then that supplied argument will be used directly.
=FRULE 1 Rule
z_µ_elim
ÒtÆ
˜
á Ù µ x:X | Pâ1[x]∑ Pâ2[x]
˜
á Ù t ç X' ± Pâ1'[t] ¥ Pâ2'[t]
=TEX

If neither of the above apply then the supplied binding may instead be 
anything else that can be taken to be to an appropriate binding type.
In such cases projection functions will be used:
=FRULE 2 Tactic
z_µ_elim
ÒtÆ
˜
á Ù µ D[xâ1,...] | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
á Ù "D[t.xâ1,...] as predicate" ± 
	Pâ1'[t.xâ1,...] ¥ Pâ2'[t.xâ1,...]
=TEX
Remains within the Z language.
=SEEALSO
$z\_µ\_elim\_conv$
=FAILURE
47310	?0 is not a Z universal quantification
41021	?0 cannot be interpreted as a binding that matches ?1
=ENDDOC

=DOC
val €z_µ_intro› :  THM -> THM;
=DESCRIBE
A rule to introduce a Z universal quantification. The variables to be quantified over must not occur free in the assumptions, and are determined from the form of the input theorem.
=FRULE 1 Rule
z_µ_intro
˜
á Ù "D as predicate" ± Pâ1 ¥ Pâ2
˜
á Ù µ D | Pâ1∑ Pâ2
=TEX
where D is converted to a declaration by
=INLINEFT
DECL_INTRO_C pred_dec_conv
=TEX
.
As a special case (applicable whenever the entire antecedent of the implication
can be interpreted as a declaration):
=FRULE 1 Rule
z_µ_intro
˜
á Ù "D as predicate" ¥ P
˜
á Ù µ D | true∑ P
=TEX

An arbitrary conjunctive structure is allowed in $D$,
including repeated bindings of single variables: the
order of the resulting binding is canonical, rather than dependent on the conjunctive structure.

This rule will not introduce empty bindings.

Remains within the Z language.
=SEEALSO
$Z\_µ\_intro1$ for implicit $xâi\ ç\ U$ conjuncts,
$all\-\_Z\-\_µ\-\_intro$,
$z\_µ\_intro\_conv$.
=FAILURE
6005	?0 occurs free in assumption list
41026	?0 not of the form `á Ù Decl ± Pâ1 ¥ Pâ2` or `á Ù Decl ¥ Pâ2`
41027	?0 cannot be made into a binding
=ENDDOC
This rule, and the following are included in the initial release from a belief that they are likely to be necessary at some point,
rather than any more rigorous requirement.
=DOC
val €z_µ_intro1› :  TERM list -> THM -> THM;
=DESCRIBE
A rule to introduce a Z universal quantification. The variables to be quantified over must not occur free in the assumptions,
and are determined from the form of the input theorem,
with additional variables from the supplied list.
=FRULE 1 Rule
z_µ_intro1
[ÒxâiÆ,...]
˜
á Ù "D as predicate" ± Pâ1 ¥ Pâ2
˜
á Ù µ D;xâi:U;... | Pâ1∑ Pâ2
=TEX
where D is converted to a declaration by
=INLINEFT
DECL_INTRO_C pred_dec_conv
=TEX
.
As special cases:
=FRULE 1 Rule
z_µ_intro1
[ÒxâiÆ,...]
˜
á Ù Pâ1 ¥ Pâ2
˜
á Ù µxâi:U;... | Pâ1∑ Pâ2
=TEX
I.e. an antecedent that is not a conjunction is taken 
to be a predicate, not, unlike $z\-\_µ\-\_intro$, a declaration.
=FRULE 1 Rule
z_µ_intro1
[ÒxâiÆ,...]
˜
á Ù P
˜
á Ù µxâi:U;... | true∑ Pâ2
=TEX
An arbitrary conjunctive structure is allowed,
including repeated bindings of single variables: the
order of the resulting binding is canonical, rather than dependent on the conjunctive structure.

This rule will not introduce empty bindings.

Remains within the Z language.
=SEEALSO
$Z\_µ\_intro$ for use without additional $xâi\ ç\ U$,
$all\-\_Z\-\_µ\-\_intro$,
$z\-\_µ\-\_intro\-\_conv$.
=FAILURE
3007	?0 is not a term variable
6005	?0 occurs free in assumption list
41027	?0 cannot be made into a binding
41028	?0 has no declaration part, and no declarations are requested in term list argument
=ENDDOC
This could be extended to accept terms of the form $Òx ç XÆ$,
to indicate that a type constraint other than $ÒUÆ$ is desired.
=DOC
val €z_µ_elim_conv› : CONV;
val €z_µ_intro_conv› : CONV;
=DESCRIBE
$z\_µ\_elim\_conv$ turns a Z universally quantified term into
a HOL universally quantified term.
=FRULE 1 Conversion
z_µ_elim_conv
Òµ D[xâ1,...] | Pâ1∑ Pâ2Æ
˜
˜
Ù (µ D[xâ1,...] | Pâ1∑ Pâ2) §
	¨µ xâ1 ...∑
	ÒD[xâ1,...]Æ ± ÒPâ1Æ ¥ ÒPâ2ÆÆ
=TEX
The order of the resulting universally quantified variables
will be in a sorted order, rather than what the declaration
part might suggest.
 
$Z\_µ\_intro\_conv$ undoes this process, returning a theorem
whose RHS should be in the Z language.
=FRULE 1 Conversion
z_µ_intro_conv
¨µ xâ1 ...∑
ÒD[xâ1,...] ± Pâ1 ¥ Pâ2ÆÆ
˜
˜
Ù ¨µ xâ1 ...∑
	D[xâ1,...] ± Pâ1 ¥ Pâ2Æ §
  Ò(µ D[xâ1,...] | Pâ1∑ Pâ2)Æ	
=TEX
=USES
Used in the Z form of $strip\_tac$,
and handling negations with quantifiers.
It will handle paired quantifiers, and quantifiers in any order, so long as the quantifiers and declaration can be matched
in names and types.
=SEEALSO
$z\_µ\_elim\_conv1$
=FAILURE
41022	?0 is not of the form: Òµ D | Pâ1∑ Pâ2Æ
41023	?0 is not of the form: ¨µ xâ1 ...∑ Decl ± Pâ1 ¥ Pâ2Æ
41024	?0 is not of the form: ¨µ xâ1 ...∑ Decl ± Pâ1 ¥ Pâ2Æ
	where the ¨xâiÆ do not match the declaration
=ENDDOC
=DOC
val €all_z_µ_intro› : THM -> THM;
=DESCRIBE
This will Z universally quantify all free variables in the conclusion
of a theorem, that don't occur in the assumptions.
The declaration part will state the variables are of type $Universe$,
and the predicate part will just be $true$.
If no variables can be introduced then the original theorem will be returned.

Remains within the Z language.
=ENDDOC
=DOC
val €z_µ_elim_conv1› : CONV;
=DESCRIBE
Turn a Z universally quantified term into
a HOL universally quantified term,
eliminating the declaration part of the original quantification using $ç\_u\_conv$.
The function fails if the declaration cannot be eliminated.
=FRULE 1 Conversion
z_µ_elim_conv1
Òµ D[xâ1,...] | Pâ1∑ Pâ2Æ
˜
˜
Ù (µ D[xâ1,...] | Pâ1∑ Pâ2) §
	¨µ xâ1 ...∑ ÒPâ1 ¥ Pâ2ÆÆ
=TEX
The order of the resulting universally quantified variables
will be in a sorted order, rather than what the declaration
part might suggest.
 
Simplifications based on $Pâi$ being $true$ or $false$
will also be applied.

Remains within the Z language (as outer HOL universal quantification doesn't count).
=USES
For stripping in proof contexts.
=FAILURE
41022	?0 is not of the form: Òµ D | Pâ1∑ Pâ2Æ
41071	?0 is of the form: Òµ D | Pâ1∑ Pâ2Æ but D non-trivial
=ENDDOC
=DOC
val €z_µ_inv_conv› : CONV;
=DESCRIBE
Simplifies a Z universal quantification whose predicate or
constraint is invariant w.r.t. the free variables bound by the declaration. 
=FRULE 1 Conversion
z_µ_inv_conv
Òµ D | Pâ1∑ Pâ2Æ
˜
˜
Ù µ D | Pâ1∑ Pâ2 § 
	(µ D | Pâ1∑ false) ≤ Pâ2
=TEX
if $Pâ2$ has no free variables bound by $D$, and
=FRULE 1 Conversion
z_µ_inv_conv
Òµ D | Pâ1∑ Pâ2Æ
˜
˜
Ù µ D | Pâ1∑ Pâ2 § 
	Pâ1 ¥ (µ D | true∑ Pâ2)
=TEX
if $Pâ1$ has no free variables bound by $D$, and
=FRULE 1 Conversion
z_µ_inv_conv
Òµ D | Pâ1∑ Pâ2Æ
˜
˜
Ù µ D | Pâ1∑ Pâ2 § 
	Pâ1 ¥ (µ D | true∑ false) ≤ Pâ2
=TEX
if both have no free variables bound by $D$.
The appropriate simplification will be avoided where the predicate $Pâ1$, is $ÒtrueÆ$ or the value, $Pâ2$ is $ÒfalseÆ$.

Remains within the Z language.
=SEEALSO
$Z\_∂\_inv\_conv$
=FAILURE
47310	?0 is not a Z universal quantification
41025	?0 is not of the form Òµ D | Pâ1∑ Pâ2Æ where at least
	one of Pâ1 or Pâ2 are unbound by D
=ENDDOC
=DOC
val €z_intro_µ_tac› : TERM -> TACTIC;
=DESCRIBE
Introduce a Z universal with reference to a binding.
=FRULE 2 Tactic
z_intro_µ_tac
Ò(xâ1 ¶ tâ1, ...)Æ
˜
{ á } t
˜
{ á } µ xâ1:U; ... | true∑ t[xâ1/tâ1,...]
=TEX
Remains within the Z language.
=FAILURE
41029	?0 cannot be interpreted to be of the form: Ò(xâ1 ¶ tâ1, ...)Æ
=ENDDOC
Something like the following could be added:

``If the supplied term is a schema object then:
=FRULE 2 Tactic
z_intro_µ_tac
ÒSÆ
˜
{ á } t
˜
{ á } µ S∑ t[xâ1/S.xâ1,...]
=TEX
where the $S.xâi$ substituted for are the actual values 
bound by the schema, or the expression $¨S.xâiÆ$.''

=DOC
val €z_spec_asm_tac› : TERM -> TERM -> TACTIC;
val €z_spec_nth_asm_tac› : int -> TERM -> TACTIC;
=DESCRIBE
These are two methods of specialising a Z universally quantified assumption.
Both leave the old assumption in place, and place the
 instantiated assumption onto the assumption list using $strip\_asm\_tac$.
If the desired behaviour differs from any of those supplied
then use $GET\_ASM\_T$ and its cousins to create the desired functionality.
=FRULE 2 Tactic
z_spec_asm_tac
Òµ D[xâ1,...] | Pâ1∑ Pâ2Æ
Ò(xâ1 ¶ tâ1, ...)Æ
˜
{ á, Òµ D[xâ1,...] | Pâ1∑ Pâ2Æ } t
˜
{strip ¨ÒD'[tâ1,...]Æ ± ÒPâ1'Æ ¥ ÒPâ2'ÆÆ, 
á, Òµ D | Pâ1∑ Pâ2Æ} t1
=TEX
where $D'$, $Pâ1'$ and $Pâ2'$ are specialised appropriately.
Remains within the Z language
(though failure to do this will be reported to be from
$z\_µ\_elim$).

$z\_spec\_nth\_asm\_tac$ uses an assumption number rather than an explicit statement of the assumption to be specialised.
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $GET\_ASM\_T$ and $z\_µ\_elim$).
=ENDDOC
\subsection{Concerning Z Existential Quantification}
Errors start with 4104
=DOC
val €z_∂_elim_conv› : CONV;
val €z_∂_intro_conv› : CONV;
=DESCRIBE
$z\_∂\_elim\_conv$ turns a Z existentially quantified term into
a HOL existentially quantified term.
=FRULE 1 Conversion
z_∂_elim_conv
Ò∂ D[xâ1,...] | Pâ1∑ Pâ2Æ
˜
˜
Ù (∂ D[xâ1,...] | Pâ1∑ Pâ2) §
	¨∂ xâ1 ...∑
	ÒD[xâ1,...]Æ ± ÒPâ1Æ ± ÒPâ2ÆÆ
=TEX
The order of the resulting existentially quantified variables
will be in a sorted order, rather than what the declaration
part might suggest.
 

$Z\_∂\_intro\_conv$ undoes this process,
returning a theorem whose RHS should be in the Z language
(though this is not checked for).
=FRULE 1 Conversion
z_∂_intro_conv
¨∂ xâ1 ...∑
	D[xâ1,...] ± Pâ1 ± Pâ2Æ
˜
˜
Ù ¨∂ xâ1 ...∑
	D[xâ1,...] ± Pâ1 ± Pâ2Æ §
  (∂ D[xâ1,...] | Pâ1∑ Pâ2)
=TEX
=USES
Used in the Z form of $strip\_tac$,
and handling negations with quantifiers.
=SEEALSO
$z\_∂\_elim\_conv1$,$z\_∂\_intro\_conv1$
=FAILURE
41044	?0 is not of the form: Ò∂ D | Pâ1∑ Pâ2Æ
41045	?0 is not of the form: ¨∂ xâ1 ...∑ D[xâ1,...] ± Pâ1 ± Pâ2Æ
41041	?0 is not of the form: ¨µ xâ1 ...∑ D ± Pâ1 ¥ Pâ2Æ
	where the ¨xâiÆ do not match the declaration
=ENDDOC
=DOC
val €z_∂_intro_conv1› : CONV;
=DESCRIBE
$Z\_∂\_intro\_conv1$ converts an arbitrary simple HOL existentially quantified term into the corresponding Z,
returning a theorem whose RHS should be in the Z language
(though this is not checked for).
=FRULE 1 Conversion
z_∂_intro_conv1
¨∂ xâ1 ...∑ PÆ
˜
˜
Ù ¨∂ xâ1 ...∑ PÆ §
  (∂ xâ1:U; ... | true∑ P)
=TEX
=SEEALSO
$z\_∂\_intro\_conv$
=FAILURE
41046	?0 is not of the form ¨∂ xâ1 ... ∑ PÆ
=ENDDOC
=DOC
val €z_∂_elim_conv1› : CONV;
=DESCRIBE
Turn a Z existentially quantified term into
a HOL existentially quantified term,
eliminating the declaration part of the original quantification using $ç\_u\_conv$.
The function fails if the declaration cannot be eliminated.
=FRULE 1 Conversion
z_∂_elim_conv1
Ò∂ D[xâ1,...] | Pâ1∑ Pâ2Æ
˜
˜
Ù (∂ D[xâ1,...] | Pâ1∑ Pâ2) §
	¨∂ xâ1 ...∑ ÒPâ1 ¥ Pâ2ÆÆ
=TEX
The order of the resulting existentially quantified variables
will be in a sorted order, rather than what the declaration
part might suggest.
 
Simplifications based on $Pâi$ being $true$ or $false$
will also be applied.
=USES
For stripping proof contexts.
=FAILURE
41042	?0 is not of the form: Ò∂ D | Pâ1∑ Pâ2Æ
41043	?0 is of the form: Ò∂ D | Pâ1∑ Pâ2Æ, but D non-trivial
=ENDDOC

=DOC
val €z_∂â1_conv› : CONV;
=DESCRIBE
Converts a Z unique existential quantification to a Z existential quantification. 
=FRULE 1 Conversion
z_∂â1_conv 
Ò∂â1 D | Pâ1∑ Pâ2Æ
˜
˜
Ù (∂â1 D | Pâ1∑ Pâ2) 
§ 
(∂ D | Pâ1∑ Pâ2 ±
(µ D' | Pâ1' ± Pâ2'∑ 
"characteristic tuples 
 component-wise equal"))
=TEX
where the $Pâi'$ are variants of the $Pâi$, to
correspond to the difference between $D$ and $D'$.

Additional decoration may be introduced as necessary to 
avoid free variable names, while maintaining an ``even'' decoration.

Remains within the Z language.
=EXAMPLE
z_∂â1_conv Ò ∂â1 [x,y : X; z:Y] | x = x' y∑ z = f xÆ;
  -->
Ù (∂â1 [x, y : X; z : Y | true] | x = x' y∑ z = f x)
  § (∂ [x, y : X; z : Y | true]
    | (x = x' y) ± (z = f x)
∑ µ [x, y : X; z : Y | true]''
      | (x'' = x' y'') ± (z'' = f x'')
∑ (x'' = x) ± (y'' = y) ± (z'' = z))
=FAILURE
41122	?0 is not of the form: Ò∂â1D | Pâ1∑ Pâ2Æ
=ENDDOC
=DOC
val €z_∂_tac› : TERM -> TACTIC ;
=DESCRIBE
Given a binding of identifiers to witnesses,
accept this as a ``group witness'' for a Z existentially
quantified goal.
=FRULE 2 Tactic
z_∂_tac
Ò(xâ1 ¶ tâ1,...) Æ
˜
{ á } ∂ D[xâ1,...] | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
{ á } "D[tâ1',...] as predicate" ± 
	Pâ1[tâ1',...] ± Pâ2[tâ1',...]
=TEX
where the $tâi'$ are appropriately type instantiated
forms of the $tâi$.
See $dec\_pred\_conv$ for the conversion of a declaration to a predicate.

Remains within the Z language.

An empty declaration may be given an empty binding.

If the goal's conclusion has a single Z existentially bound variable, and the supplied argument can be type instantiated to match that, then it will be used as a witness.
=FRULE 2 Tactic
z_∂_tac
ÒtÆ
˜
{ á } ∂ x:X | Pâ1[xâ1]∑ Pâ2[xâ1]
˜
{ á } t' ç X ± Pâ1[t'] ± Pâ2[t']
=TEX
where $t'$ is an appropriately type instantiated
form of the $t$.

Finally, if none of the above apply, the supplied binding may instead be 
anything else that can be type instantiated to the appropriate binding type.
In such cases projection functions will be used:
=FRULE 2 Tactic
z_∂_tac
ÒtÆ
˜
{ á } ∂ D[xâ1,...] | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
{ á } "D[t.xâ1',...] as predicate" ± 
	Pâ1[t'.xâ1,...] ± Pâ2[t'.xâ1,...]
=TEX
where $t'$ is an appropriately type instantiated
form of the $t$.
=FAILURE
47290	?0 is not a Z existential quantification
41021	?0 cannot be interpreted as a binding that matches ?1
=ENDDOC
=DOC
val €z_∂_inv_conv› : CONV;
=DESCRIBE
Simplifies a Z existential quantification whose predicate or
constraint is inveriant w.r.t. the free variables bound by the declaration. 
=FRULE 1 Conversion
z_∂_inv_conv
Ò∂ D | Pâ1∑ Pâ2Æ
˜
˜
Ù ∂ D | Pâ1∑ Pâ2 §
	 (∂ D | Pâ1∑ true) ± Pâ2
=TEX
if $Pâ2$  has no free variables bound by $D$, and
=FRULE 1 Conversion
z_∂_inv_conv
Ò∂ D | Pâ1∑ Pâ2Æ
˜
˜
Ù ∂ D | Pâ1∑ Pâ2 § 
	Pâ1 ± (∂ D | true∑ Pâ2)
=TEX
if $Pâ1$  has no free variables bound by $D$, and
=FRULE 1 Conversion
z_∂_inv_conv
Ò∂ D | Pâ1∑ Pâ2Æ
˜
˜
Ù ∂ D | Pâ1∑ Pâ2 § 
	Pâ1 ± (∂ D | true∑ true) ± Pâ2
=TEX
if both have no free variables bound by $D$.

Remains within the Z language.

$Pâ1$ nor $Pâ2$ will be ``extracted'' if identical to $true$.
=SEEALSO
$Z\_µ\_inv\_conv$
=FAILURE
47290	?0 is not a Z existential quantification
41040	?0 is not of the form Ò∂ D | Pâ1∑ Pâ2Æ where at least
	one of Pâ1 or Pâ2 are unbound by D
=ENDDOC

\subsection{Concerning Õ}
=DOC
val €z_Õ_rule› : TERM -> THM;
=DESCRIBE
This rule is given a Z $Õ$ term (i.e. a Z definite description), and returns a theorem
that states what is reqired for this $Õ$ term
to be equal to some value, $x$.
The requirement is
that if any value satisfies the schema text of the $Õ$ term
then it must equal $x$,
and that $x$ satisfies the schema text of the $Õ$ term.
=FRULE 1 Rule
z_Õ_rule
ÒÕ D | P∑ VÆ
˜
˜
Ù ¨µ x∑
 Ò (µ D | P∑ V = x) ±
   (∂ D | P∑ V = x)
   ¥
   (Õ D | P∑ V) = xÆÆ
=TEX
Remains within the Z language.
=FAILURE
47210	?0 is not a Z Õ term
=ENDDOC
\subsection{Concerning Function Application}
Errors start with 4109
=DOC
val €z_app_conv› : CONV;
=DESCRIBE
A function to convert a Z application into the
corresponding $Õ$ term (i.e. definite description).
=FRULE 1 Conversion
z_app_conv
Òf aÆ
˜
˜
Ù f a = (Õ f_a :U | (a,f_a) ç f∑ f_a) 
=TEX
Remains within the Z language though this is not checked.
=SEEALSO 
$z\_app\_rule$, $z\_app\_tac$
=FAILURE
47190	?0 is not a Z function application
=ENDDOC
=DOC
val €z_app_rule› : TERM -> THM;
=DESCRIBE
A rule that, given a Z application, returns a theorem that states sufficient conditions to prove that the application
is equal to an arbitrary variable.
=FRULE 1 Rule
z_app_rule
Òf aÆ
˜
˜
Ù ¨µ x∑ 
  Òµ f_a : U | (a, f_a) ç f∑ f_a = x ± 
     (a, x) ç f
      ¥ f a = xÆÆ
=TEX
$x$ will be renamed to be distinct from any variables in the
supplied term.

Remains within the Z language.
=USES
In implementing methods of reasoning about applications.
=SEEALSO
$z\_app\_conv$, $z\_app\_tac$
=FAILURE
47190	?0 is not a Z function application
=ENDDOC
=DOC
val €z_app_tac› : TACTIC;
=DESCRIBE
Reduces a subgoal that states a Z application is equal to
something to sufficient conditions for this to be provable.
The conditions are not ``necessary'' only because they
ignore the fact that in ProofPower Z every term is 
equal to itself, and other vacuous variants of this.
=FRULE 2 Tactic
z_app_tac
˜
{á} f a = v
˜
{á} (µ f_a : U | (a, f_a) ç f∑ f_a = v)
	± (a,v) ç f
=TEX
If this does not match the pattern of the goal then
=FRULE 2 Tactic
z_app_tac
˜
{á} v = f a
˜
{á} (µ f_a : U | (a, f_a) ç f∑ f_a = v)
	± (a,v) ç f
=TEX
will be tried instead.
In addition an implicit ``$=\ true$'' will be used
if the conclusion of the goal is an application.

Remains within the Z language.
=FAILURE
41090	Goal is not of the forms: Òf a = vÆ or Òv = f aÆ
=ENDDOC

\subsection{Concerning Ã}
Errors begin with 4111
=DOC
val €z_Ã_conv› : CONV;
=DESCRIBE
Convert a Z $Ã$ abstraction into a set abstraction.
=FRULE 1 Conversion
z_Ã_conv
ÒÃ D | P∑ VÆ
˜
˜
Ù (Ã D | P∑ V) = { D | P∑ (charD,V)}
=TEX
Where $charD$ is the characteristic tuple of $D$.

Remains within the Z language.
=SEEALSO
$z\_¬\_rule$, $z\_¬\_tac$
=FAILURE
47200	?0 is not a Z Ã abstraction
=ENDDOC
=DOC
val €z_¬_rule› : TERM -> THM;
=DESCRIBE
Given a Z $¬$ redex this function will return a theorem
stating sufficient conditions for this redex
to be proven equal to some arbitrary value.
=FRULE 1 Rule
z_¬_rule
Ò(Ã D | P∑ V) tÆ
˜
˜
Ù ¨µ x∑ Ò(µ f_a :U | (∂ D | P∑ 
charD = t ± V = f_a) ∑ f_a = x)
  ±
  (∂ D | P∑ (charD = t) ± V = x)
  ¥
  (Ã D | P∑ V) t = xÆÆ
=TEX
Remains within the Z language.
=FAILURE
41110	?0 is not of the form Ò(Ã D | P∑ V) tÆ
=ENDDOC
=DOC
val €z_¬_conv› : CONV;
=DESCRIBE
Given a simple Z $¬$ redex this function will return a theorem
stating sufficient conditions for this redex
to be proven equal to some arbitrary value.
The $Ã$ must have only a single variable in its declaration
part. 
=FRULE 1 Conversion
z_¬_conv
Ò(Ã x:X | P[x]∑ V[x]) tÆ
˜
˜
t ç X,
P[t]
Ù  (Ã x:X | P[x]∑ V[x]) t = V[t]
=TEX
The assumptions will be eliminated if trivial
(i.e. if the first assumption can be proven true by $ç\_u\_conv$,
the second if the assumption is just $ÒtrueÆ$).

Remains within the Z language.
=FAILURE
41111	?0 is not of the form Ò(Ã x:X | P∑ V) tÆ
=ENDDOC
Later releases could make this function more intelligent.

\subsection{Conversions between Z Universal and Existential Quantifications}
Errors start with 4105
=DOC
val €z_≥_µ_conv› : CONV;
val €z_≥_∂_conv› : CONV;
=DESCRIBE
$z\_≥\_µ\_conv$ converts a negated Z universal quantification to a Z existential quantification.
=FRULE 1 Conversion
≥_z_µ_conv 
Ò≥(µ D | Pâ1∑ Pâ2)Æ
˜
˜
Ù ≥(µ D | Pâ1∑ Pâ2) § 
	(∂ D | Pâ1∑ ≥ Pâ2)
=TEX
The dual is $z\_≥\_∂\_conv$:
=FRULE 1 Conversion
z_≥_∂_conv 
Ò≥(∂ D | Pâ1∑ Pâ2)Æ
˜
˜
Ù ≥(∂ D | Pâ1∑ Pâ2) § 
	(µ D | Pâ1∑ ≥ Pâ2)
=TEX
These two functions remain within the Z language, though this is not checked.
=FAILURE
41050	?0 not of the form: Ò≥(µ D | Pâ1∑ Pâ2)Æ
41051	?0 not of the form: Ò≥(∂ D | Pâ1∑ Pâ2)Æ
=ENDDOC
We are not immediately interested in providing support for pulling
out $≥$.

We are now in a position to give:
=DOC
val €z_≥_in_conv› : CONV;
=DESCRIBE
This is a conversion which moves an outermost negation inside other Z predicate
calculus connectives using whichever of the following rules applies:
=GFT
		≥≥t			=	t
		≥(t1 ± t2)		=	≥t1 ≤ ≥t2
		≥(t1 ≤ t2)		=	≥t1 ± ≥t2
		≥(t1 ¥ t2)		=	t1 ± ≥t2
		≥(t1 § t1)		=	false
		≥(t1 § t2)		=	(t1 ± ≥t2) ≤ (t2 ± ≥t1)
		≥(t1 = t1)		=	false
		≥(µ D | P∑ V) 		=	∂ D | P∑ ≥ V
		≥(∂D | P∑ V)		=	µ D | P∑ ≥ V
		≥(∂â1 D|P∑ V)	=	µD|P∑≥(V ± µD'|P'∑V' ¥ D = D')
		≥true			=	false
		≥false			=	true
=TEX
Remains within the Z language.
=USES
Tactic and conversion programming.
=FAILURE
47240	?0 is not a Z negation
28131	No applicable rules for the term ?0
=ENDDOC

\subsection{Conversions betweens Declarations and Predicates}
Errors start with 4101.
=DOC
val €dec_pred_conv› : CONV;
=DESCRIBE
A conversion which rewrites a $dec$ type of declaration to a predicate. A $decsexp$ type of declaration remains unchanged (since $decsexp$ and $predsexp$ are, in fact, the same thing). 
=FRULE 1 Conversion
dec_pred_conv 
¨x : XÆ
˜
˜
Ù ¨(x : X)Æ § x ç X
=TEX
and
=FRULE 1 Conversion
dec_pred_conv 
¨xâ1, ... : XÆ
˜
˜
Ù ¨(xâ1, ... : X)Æ § {xâ1,...} Ä X
=TEX
and
=FRULE 1 Conversion
dec_pred_conv 
ÒSÆ 
˜
˜
Ù S = S
=TEX
where S is a schema (here promoted to a predicate).

Note that a declaration on its own is not a Z expression,
though it may be correctly embedded within certain
forms of Z expressions.
=SEEALSO
$pred\_dec\_conv$
=FAILURE
41010	?0 is not a declaration
=ENDDOC

=DOC
val €DECL_C› : CONV -> CONV;
=DESCRIBE
$DECL\_C$ applies the supplied conversion to each member of a declaration and returns the conjunction of the results.
It fails if its conversion fails on any member of the declaration.

=INLINEFT
DECL_C dec_pred_conv
=TEX
{} will convert a valid Z declaration into a Z predicate.
=FAILURE
47912	?0 is not a Z declaration
41012	Supplied conversion failed on one or more members of ?0
=ENDDOC

=DOC
val €pred_dec_conv› : CONV;
=DESCRIBE
A conversion which rewrites to declarations the four cases: set membership, subsetting, schema promoted to predicate and $ $ term.
=FRULE 1 Conversion
pred_dec_conv Òx ç XÆ
˜
˜
Ù x ç X § (x : X)
=TEX
where the $x$ must be variable,
and
=FRULE 1 Conversion
pred_dec_conv Ò{xâ1,...} Ä XÆ
˜
˜
Ù {xâ1,...} Ä X § (xâ1,... : X)
=TEX
where the $xâi$ must be variables,
and
=FRULE 1 Conversion
pred_dec_conv ÒSÆ 
˜
˜
Ù S = S
=TEX
and
=FRULE 1 Conversion
pred_dec_conv Ò S ç SÆ 
˜
˜
Ù ( S ç S) § S
=TEX
=SEEALSO
$dec\_pred\_conv$
=FAILURE
41011	?0 cannot be rewritten to a declaration
=ENDDOC

=DOC
val €DECL_INTRO_C› : CONV -> CONV;
=DESCRIBE
$DECL\_INTRO\_C$ applies the supplied conversion to each conjunct of a predicate, flattening the conjunctive structure.
If this is successful, it attempts to produce a declaration from the results.

=INLINEFT
DECL_INTRO_C pred_dec_conv
=TEX
{} will convert certain Z predicates into Z declarations,
and otherwise will fail.
=FAILURE
41013	?0 not of the form: Ò câ1 ± ...Æ where all the câi
	may have the supplied conversion applied
41014	?0 when converted to ?1 cannot be viewed as a declaration
=FAILUREC
The conversion fails if the supplied conversion fails on any conjunct,
returning the error message of that conversion application.
=ENDDOC

\section{Z REWRITING}
\subsection{Canonicalisation}
Errors begin with 4108
=DOC
val €z_defn_canon› : CANON;
val €z_defn_conv› : CONV;
=DESCRIBE
Some definitions entered by the Z parser have ``markers''
applied to the rest of the theorem body to indicate their origin.
$z\-\_defn\-\_canon$ is a canonicalistisation function that removes these markers,
$z\-\_defn\-\_conv$ is a conversion that removes them.

The following are instances in which markers are used:
=GFT
Constraint Definitions
Free Type Definitions
Given Set Definitions
Axiomatic Definitions
Schema Boxes
Abbreviation Definitions
=TEX
Remains within the Z language, though this is not checked.
=FAILURE
41080	No Z markers found applied to conclusion body of ?0
41082	No Z markers found applied to body of ?0
=ENDDOC
=DOC
val €z_µ_rewrite_canon› : CANON;
=DESCRIBE
Take a possibly Z universally quantified theorem and
make it into, as far as possible, a HOL universally quantified
theorem usable for rewriting.
Simplifications due to $U$ and $true$ will be carried out.
=FRULE 1 Canon
z_µ_rewrite_canon
˜
á Ù Ò(µ D[xâ1,...] | Pâ1∑ Pâ2)Æ
˜
[á Ù ¨µ xâ1 ...∑ 
	Ò"D[xâ1,...] as predicate"
	± Pâ1 ¥ Pâ2ÆÆ]
=TEX
where if any portion of the body of the result can be simplified away due to $U$, $true$ or $false$ it will be.

Remains within the Z language, though this is not checked.
=SEEALSO
$z\_defn\_canon$
=FAILURE
41081	?0 is not of the form: Ò(µ D | Pâ1∑ Pâ2)Æ
=ENDDOC
=DOC
val €z_≥_rewrite_canon› : THM -> THM list
=DESCRIBE
This is a canonicalisation function used for breaking theorems up into
lists of equations for use in rewriting. It performs the following
transformations:
=GFT
z_≥_rewrite_canon	(á Ù ≥(t1 ≤ t2))	= (á Ù ≥t1 ± ≥t2)	
z_≥_rewrite_canon	(á Ù ≥∂D | P∑ V)= (á Ù µD | P∑ ≥V)	
z_≥_rewrite_canon	(á Ù ≥≥t)		= (á Ù t)
z_≥_rewrite_canon	(á Ù ≥t)		= (á Ù t = false)	
=TEX
Remains within the Z language, though this is not checked.
=SEEALSO
$simple\_≥\_rewrite\_canon$, $simple\_µ\_rewrite\_canon$.
=FAILURE
26201	Failed as requested
=FAILUREC
The area given by the failure will be $fail\_canon$.
=ENDDOC
Should this recognise 
=INLINEFT
Ù ≥ (∂â1 ...)
=TEX
?
\subsection{Conditional Rewriting}
This is a yet to be implemented part of the HOL system,
that may have some Z specific features.
\section{Z STRIPPING AND PROOF CONTEXTS}
In designing the following proof context we assume
it will be used in combination with at least proof context
``$'$propositions'' and ``$'$paired$\_$abstractions''.

=DOC
(* Proof Context: €z_predicates› *)
=DESCRIBE
A component proof context for handling the additional requirements of Z predicates.
\paragraph{Contents}\ 

Rewriting:
=GFT
§_rewrite_thm, ≥_rewrite_thm,  eq_rewrite_thm, ±_rewrite_thm, ≤_rewrite_thm, 
¥_rewrite_thm, u_conv, z_µ_inv_conv, z_∂_inv_conv, ç_u_thm,
z_¬_conv if its resulting theorem has no assumptions, 
simplifications as z_defn_canon
=TEX
Stripping theorems:
=GFT
z_≥_in_conv, z_µ_elim_conv1, z_∂_elim_conv, z_∂â1_conv, ç_u_conv, z_µ_inv_conv, 
DECL_C dec_pred_conv, ¥_thm, §_thm, eq_rewrite_thm, 
simplifications as z_defn_canon
=TEX
Note that we only break apart a Z $µ$ into HOL quantifiers
if the declaration will be eliminated.

Stripping conclusions:
=GFT
z_µ_elim_conv THEN_C 
	ALL_SIMPLE_µ_C(LEFT_C(LEFT_C(DECL_C dec_pred_conv)))),
z_∂â1_conv, z_≥_in_conv, ç_u_conv, z_∂_inv_conv
§_thm, eq_rewrite_thm,
`Ù µa b∑(a ≤ ≥b) § (b ¥ a)` `Ù µ a b∑ ≥ a ≤ b § a ¥ b`
`Ù µ a b∑ a ≤ b § ≥ a ¥ b`
simplifications as z_defn_canon
=TEX
Note that we never break apart a Z $∂$ into HOL quantifiers.

Rewriting canonicalisation:
=GFT
µ_rewrite_canon, z_≥_rewrite_canon, ±_rewrite_canon, 
f_rewrite_canon, z_µ_rewrite_canon, z_defn_canon
=TEX
Notice in particular the use of the HOL $µ\_rewrite\_canon$.

Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$,
and
the list
=GFT
z_∂_elim_conv,
ALL_SIMPLE_∂_C ``simplifications as z_defn_canon'',
basic_prove_∂_conv
=TEX
Pattern matching in $∂$ proofs understands Z 2-tuples.
\paragraph{Usage Notes}
It requires theory $z\-\_predicate\-\_calculus$.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC

This proof context
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language if its argument starts there.
\subsection{Z Contradiction Tactics}
The tactics supplied for HOL contradiction tactics extend to Z without
change, if appropriate proof contexts are used.
\section{END OF THE SIGNATURE}

=SML
end; (* signature of ZPredicateCalculus *)
=TEX

\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}







