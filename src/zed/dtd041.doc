=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for the Z Predicate Calculus}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Z Predicate Calculus}
\TPPref{DS/FMU/IED/DTD041}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{G.~Prout & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and tactics for the Z Proof Support System predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.B.~Jones
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Removed $Z\_STRIP\_GOAL\_T$, $Z\_STRIP\_THM\_THEN$, $Z\_strip\_tac$, \newline $Z\_strip\_asm\_tac$, $Z\_check\_asm\_tac$, $Z\_≥\_IN\_THEN$ and $Z\_≥\_in\_tac$.

Tidied up theorems and conversion about $U$ into a single conversion $Z\_U\_true\_conv$ (for use in stripping and rewriting).
\item [Issue 1.3 (9th July 1992)]
Taken over by KB, and reworked, new fonts.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference and conversions and tactics for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}) predicate calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP041}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and tactics for the predicate calculus of the Z Proof Support System.
\subsubsection{Dependencies}
Loading this document is dependent on 
the Z Library \cite{DS/FMU/IED/DTD078} and Z Term generator
\cite{DS/FMU/IED/DTD063}.
\subsubsection{Deficiencies}
The coverage in initial releases of ProofPower Z is aimed at the basic reasoning
tools, rather than a full coverage.
Thus we only cover:
\begin{itemize}
\item
Rewriting
\item
Stripping goals and theorems
\item
$µ$ elimination as inference rule
\item
Contradiction tactic
\item
$∂\_$tac
\end{itemize}
plus some of the auxiliary functions necessary for implementing these.
\section{OVERLAP WITH ProofPower HOL}
Some functions operating on Z have the same purpose
as an equivalent for ProofPower HOL,
but perhaps different functionality.

Where this happens, in order of desirability, highest first, we:
\begin{itemize}
\item
Use the HOL function, with, if necessary, parameterisation
changes provided by proof contexts (or, more rarely,
if at all, by other parameterisation).
In particular, if the functionality is the same, use the 
same function (e.g. $±\_tac$).
\item
Override the HOL function with a new one that tries
Z specific approaches, and if that fails, reverts
to a HOL mode of behaviour.
Where this is used it will be necessary to provide a
method of returning to purely HOL mode, and then, later,
restoring the Z mode.
This mode swap will probably be done by ML structure opening.
For example, see treatment of $strip\_tac$ below.
\item
Provide a separately named function for Z work.
The Z name will usually be formed by prefixing appropriate
atoms of the name by Z to indicate the object of
concern in the Z variant of the object (e.g. we use
the atom $Z\_µ$ in referring to functions about a Z language universal quantifier).
\end{itemize}
\section{Z PREDICATE CALCULUS}
=DOC
signature€ZPredicateCalculus› = sig
=DESCRIBE
This provides a set of rules of inference, conversions and tactics sufficient for reasoning about the Z predicate calculus in ProofPower.
=FAILURE
=ENDDOC

\subsection{Subsidiary Functions}
\subsubsection{Concerning The Universe, U} \label{U}

In \cite{DS/FMU/IED/DTD078} the following `transparent type' definition is given.
 
πù U[X]ú
‹ U :  X
˜
‹ U = X
à

This definition is supplied purely for convenience. If a set is not specified, the Z type inferrer inserts $Ò...: UÆ$. This leads to terms which are polymorphic, rather than truly set generic. The following material about $U$ is provided to facilitate discharging the proof obligation of implicit predicates in Z declarations.
=DOC
val €u_clauses› : THM;
=DESCRIBE
A theorem concerning the simplification of $U$.
=FRULE 1 Theorem
u_clauses
˜
˜
 U = U ±
(U ∏ U) = U ±
(U ™ U) = U ±
¨µ x∑ x ç UÆ
=TEX
=ENDDOC
=DOC
val €u_conv› : CONV;
=DESCRIBE
Simplify to $U$ a structure made from $U$, $∏$, $™$ and $$. 
=FRULE 1 Conversion
u_conv
ÒStructure[U]Æ
˜
˜
Ù Structure[U] = U
=TEX
based on recursively using
=GFT
Ù  U = U
Ù (U ∏ U) = U
Ù (U ™ U) = U
=TEX
=SEEALSO
$ç\_u\_conv$
=FAILURE
	?0 cannot be proven equal to ÒUÆ
=ENDDOC
=DOC
val €ç_u_conv› : CONV;
=DESCRIBE
Simplifies to $true$ a term of the form 
=INLINEFT
Òx ç S[U]Æ
=TEX
{}, where
$S[U]$ is a structure made from $U$, $∏$, $™$ and $$.
=FRULE 1 Conversion
ç_u_conv
Òx ç S[U]Æ
˜
˜
Ù x ç S[U] § true
=TEX
based on recursively using
=GFT
Ù  U = U
Ù (U ∏ U) = U
Ù (U ™ U) = U
Ù µ x∑ x ç U
=TEX
=FAILURE
	?0 cannot be proven equal to ÒUÆ
	?0 is not of the form: Òx ç S[U]Æ
=ENDDOC

\subsubsection{Concerning Generic Formals}

=DOC
val €gen_formal_elim› : (TERM * TERM) -> THM -> THM;
val €list_gen_formal_elim› : (TERM * TERM) list -> THM -> THM;
=DESCRIBE
$gen\_formal\_elim$ is a rule that specialises one outer generic formal to a chosen set.
=FRULE 1 Rule
gen_formal_elim
(ÒXâiÆ, ÒSÆ)
˜
á Ù [...,Xâi,...] P[Xâi]
˜
á Ù [...,...] P'[S]
=TEX
where $P'$ is a type instantiated $P$, if necessary, to allow
the specialisation.

$list\_gen\_formal\_elim$ simultaneously specialises with all its arguments.
=FAILURE
	?0 is not a generic variable of ?1
6006	Trying to instantiate type variable ?0, which occurs in assumption list
=ENDDOC

=DOC
val €all_gen_formal_elim› : THM -> THM;
=DESCRIBE
A rule that specialises all generic variables of a Z predicate to $U$ (of the right type).
=FRULE 1 Rule
all_gen_formal_elim
˜
á Ù [Xâ1,...] P[Xâ1,...]
˜
á Ù P[U, ...]
=TEX
=ENDDOC
\subsection{Concerning Z Universal Quantification}
=DOC
val €Z_µ_elim› : TERM -> THM -> THM;
=DESCRIBE
Specialise all Z universally quantified variables to given values of the right type in a binding.
=FRULE 1 Rule
Z_µ_elim
(mk_z_binding[("xâ1", Òtâ1Æ),...])
˜
á Ù µxâ1:Xâ1;... | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
á Ù (tâ1 ç Xâ1 ± ... )
    ± Pâ1[tâ1,...] ¥ Pâ2[tâ1,...]
=TEX
The supplied binding may instead be 
anything else that can be type instantiated to the appropriate binding type.
In such cases projection functions will be used:
=FRULE 2 Tactic
Z_µ_elim
ÒtÆ
˜
á Ù µ xâ1:Xâ1;... | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
á Ù (t'.xâ1 ç Xâ1 ± ..) ± 
	Pâ1[t'.xâ1,...] ¥ Pâ2[t'.xâ1,...]
=TEX
where $t'$ is an appropriately type instantiated
form of the $t$.

Finally, if the theorem's conclusion has a single universally quantified variable, and the supplied argument can be type instantiated to match that, then it will be used as a witness.
=FRULE 2 Tactic
Z_µ_elim
ÒtÆ
˜
á Ù µ x:X | Pâ1[x]∑ Pâ2[x]
˜
á Ù t' ç X ± Pâ1[t'] ¥ Pâ2[t']
=TEX
where $t'$ is an appropriately type instantiated
form of the $t$.

=FAILURE
	Supplied binding ?0 does not match conclusions binding ?1
	?0 cannot be interpreted as an appropriate binding
=ENDDOC
What happens with an empty binding?

Where:
=GFT
fun mk_z_binding[("xâ1", Òtâ1Æ),...] = (
	ÒS_[xâ1,...] tâ1 ...Æ
);
=TEX
=DOC
val €Z_µ_intro› :  THM -> THM;
=DESCRIBE
A rule to introduce a Z universal quantification. The variables to be quantified over must not occur free in the assumptions, and are determined from the form of the input theorem.
=FRULE 1 Rule
Z_µ_intro
˜
á Ù (xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2
˜
á Ù µxâ1:Xâ1;... | Pâ1∑ Pâ2
=TEX
As an edge condition:
=FRULE 1 Rule
Z_µ_intro
˜
á Ù (xâ1 ç Xâ1 ± ...) ¥ P
˜
á Ù µxâ1:Xâ1; ... | true∑ P
=TEX

=SEEALSO
$Z\_µ\_intro1$ for implicit $xâi\ ç\ U$ conjuncts.
=FAILURE
	?0 not of the form á Ù D ± Pâ1 ¥ Pâ2
	?0 cannot be made into a binding
	?0 appears free in the assumptions
=ENDDOC
What happens with an empty binding?
Should an implicit $true$ be inserted for $Pâ1$, if necessary?

This rule, and the following are included in the initial release from a belief that they are likely to be necessary at some point,
rather than any more rigourous requirement.
=DOC
val €Z_µ_intro1› :  TERM list -> THM -> THM;
=DESCRIBE
A rule to introduce a Z universal quantification. The variables to be quantified over must not occur free in the assumptions,
and are determined from the form of the input theorem,
with additional variables from the supplied list.
=FRULE 1 Rule
Z_µ_intro1
[ÒxâiÆ,...]
˜
á Ù (xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2
˜
á Ù µxâ1:Xâ1;...;xâi:U;... | Pâ1∑ Pâ2
=TEX
and as edge conditions:
=FRULE 1 Rule
Z_µ_intro1
[ÒxâiÆ,...]
˜
á Ù Pâ1 ¥ Pâ2
˜
á Ù µxâi:U;... | Pâ1∑ Pâ2
=TEX
=FRULE 1 Rule
Z_µ_intro1
[ÒxâiÆ,...]
˜
á Ù P
˜
á Ù µxâi:U;... | true∑ Pâ2
=TEX
=FRULE 1 Rule
Z_µ_intro1
[ÒxâiÆ,...]
˜
á Ù (xâ1 ç Xâ1 ± ...) ¥ P
˜
á Ù µxâ1:Xâ1; ... xâi:U;... | true∑ P
=TEX
=SEEALSO
$Z\_µ\_intro$ for use without additional $xâi\ ç\ U$.
=FAILURE
	?0 not of the form á Ù Pâ1 ¥ Pâ2
	?0 cannot be made into a binding
	?0 appears free in the assumptions
	?0 is not a variable
=ENDDOC
=DOC
val €Z_µ_conv› : CONV;
val €Z_µ_conv1› : CONV;
=DESCRIBE
Turn a Z universally quantified term into
a ProofPower HOL universally quantified term.
=FRULE 1 Conversion
Z_µ_conv
Òµxâ1:Xâ1;... | Pâ1∑ Pâ2Æ
˜
˜
Ù (µxâ1:Xâ1;... | Pâ1∑ Pâ2) §
	¨µ xâ1 ...∑
	Ò(xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2ÆÆ
=TEX

$Z\_µ\_conv1$ undoes this process
=FRULE 1 Conversion
Z_µ_conv1
¨µ xâ1 ...∑
Ò(xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2ÆÆ
˜
˜
Ù ¨µ xâ1 ...∑
	Ò(xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2Æ §
  Ò(µxâ1:Xâ1;... | Pâ1∑ Pâ2)Æ	
=TEX
=USES
Used in the Z form of $strip\_tac$,
and handling negations with quantifiers.
=FAILURE
	?0 is not of the form: Òµxâ1:Xâ1;... | Pâ1∑ Pâ2Æ
	?0 is not of the form: ¨µ xâ1 ...∑
	Ò(xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2ÆÆ
=ENDDOC
=DOC
val €Z_µ_true_conv› : CONV;
=DESCRIBE
Simplifies a Z universal quantification whose body is $true$ to $true$. 
=FRULE 1 Conversion
Z_µ_true_conv
Òµxâ1:Xâ1;... | P∑ trueÆ
˜
˜
Ù (µxâ1:Xâ1;... | P∑ true) § true
=TEX
Note that the analogue with $false$ rather than $true$ 
is not always valid,
e.g., consider the case where $P$ is also $false$.
=SEEALSO
$Z\_∂\_false\_conv$
=ENDDOC

\subsection{Concerning Z Existential Quantification}
=DOC
val €Z_∂_conv› : CONV;
val €Z_∂_conv1› : CONV;
=DESCRIBE
Turn a Z existentially quantified term into
a ProofPower HOL existentially quantified term.
=FRULE 1 Conversion
Z_∂_conv
Ò∂xâ1:Xâ1;... | Pâ1∑ Pâ2Æ
˜
˜
Ù (∂xâ1:Xâ1;... | Pâ1∑ Pâ2) §
	¨ xâ1 ...∑
	Ò(xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2ÆÆ
=TEX

$Z\_∂\_conv1$ undoes this process
=FRULE 1 Conversion
Z_∂_conv1
¨∂ xâ1 ...∑
	Ò(xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2ÆÆ
˜
˜
Ù ¨∂ xâ1 ...∑
	Ò(xâ1 ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2ÆÆ §
  (∂xâ1:Xâ1;... | Pâ1∑ Pâ2)
=TEX
=USES
Used in the Z form of $strip\_tac$,
and handling negations with quantifiers.
=FAILURE
	?0 is not of the form: Òµxâ1:Xâ1;... | Pâ1∑ Pâ2Æ
=ENDDOC

=DOC
val €Z_∂â1_conv› : CONV;
=DESCRIBE
Converts a Z unique existential quantification to a Z existential quantification. 
=FRULE 1 Conversion
Z_∂_conv 
Ò∂â1 xâ1:Xâ1; ... | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]Æ
˜
˜
Ù (∂â1 xâ1:Xâ1; ... | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]) § 
(∂ xâ1:Xâ1; ... | Pâ1[xâ1,...]∑ Pâ2[xâ1,...] ±
(µ yâ1:Xâ1; ... | Pâ1[yâ1,...] ± Pâ2[yâ1,...]∑ 
	xâ1 = yâ1 ± ...))
=TEX
=FAILURE
	?0 is not of the form: Ò∂â1D | Pâ1∑ Pâ2Æ
=ENDDOC
=DOC
val €Z_∂_tac› : TERM -> TACTIC ;
=DESCRIBE
Given a binding of identifiers to witnesses,
accept this as a ``group witness'' for a Z existentially
quantified goal.
=FRULE 2 Tactic
Z_∂_tac
(mk_z_binding[("xâ1",Òtâ1Æ),...])
˜
{ á } ∂ xâ1:Xâ1;... | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
{ á } (tâ1' ç Xâ1 ± ..) ± 
	Pâ1[tâ1',...] ± Pâ2[tâ1',...]
=TEX
where the $tâi'$ are appropriately type instantiated
forms of the $tâi$.

The supplied binding may instead be 
anything else that can be type instantiated to the appropriate binding type.
In such cases projection functions will be used:
=FRULE 2 Tactic
Z_∂_tac
ÒtÆ
˜
{ á } ∂ xâ1:Xâ1;... | Pâ1[xâ1,...]∑ Pâ2[xâ1,...]
˜
{ á } (t'.xâ1 ç Xâ1 ± ..) ± 
	Pâ1[t'.xâ1,...] ± Pâ2[t'.xâ1,...]
=TEX
where $t'$ is an appropriately type instantiated
form of the $t$.

Finally, if the goal's conclusion has a single Z existentially bound variable, and the supplied argument can be type instantiated to match that, then it will be used as a witness.
=FRULE 2 Tactic
Z_∂_tac
ÒtÆ
˜
{ á } ∂ x:X | Pâ1[xâ1]∑ Pâ2[xâ1]
˜
{ á } t' ç X ± Pâ1[t'] ± Pâ2[t']
=TEX
where $t'$ is an appropriately type instantiated
form of the $t$.
=FAILURE
	Subgoal is not of the form: `{ á } ∂ D | Pâ1∑ Pâ2`
	Supplied binding ?0 does not match conclusions binding ?1
	?0 cannot be interpreted as an appropriate binding
=ENDDOC
What about an empty binding?
=DOC
val €Z_∂_false_conv› : CONV;
=DESCRIBE
Simplifies a Z existential quantification whose body is $false$ to $false$. 
=FRULE 1 Conversion
Z_∂_false_conv
Ò∂xâ1:Xâ1;... | P∑ falseÆ
˜
˜
Ù (∂xâ1:Xâ1;... | P∑ false) § false
=TEX
Note that the analogue with $true$ rather than $false$ 
is not always valid,
e.g., consider the case where $P$ is $false$.
=SEEALSO
$Z\_µ\_true\_conv$
=ENDDOC

\subsection{Conversions between Z Universal and Existential Quantifications}

=DOC
val €≥_Z_µ_conv› : CONV;
val €≥_Z_∂_conv› : CONV;
=DESCRIBE
$≥\_Z\_µ\_conv$ converts a negated Z universal quantification to a Z existential quantification.
=FRULE 1 Conversion
≥_Z_µ_conv 
Ò≥(µ D | Pâ1∑ Pâ2)Æ
˜
˜
Ù ≥(µ D | Pâ1∑ Pâ2) § 
	(∂ D | Pâ1∑ ≥ Pâ2)
=TEX
The dual is $Z\_≥\_∂\_conv$:
=FRULE 1 Conversion
≥_Z_∂_conv 
Ò≥(∂ D | Pâ1∑ Pâ2)Æ
˜
˜
Ù ≥(∂ D | Pâ1∑ Pâ2) § 
	(µ D | Pâ1∑ ≥ Pâ2)
=TEX

=FAILURE
	?0 not of the form: Ò≥(µ D | Pâ1∑ Pâ2)Æ
	?0 not of the form: Ò≥(∂ D | Pâ1∑ Pâ2)Æ
=ENDDOC
We are not immediately interested in providing support for pulling
out $≥$.

\subsection{Conversions betweens Declarations and Predicates}
=DOC
val €dec_elim_conv› : CONV;
=DESCRIBE
A conversion which rewrites a $dec$ type of declaration  to set membership. A $decsexp$ type of declaration remains unchanged (since $decsexp$ and $predsexp$ are, in fact, the same thing). 
=FRULE 1 Conversion
dec_elim_conv 
Òx : XÆ
˜
˜
Ù (x : X) § x ç X
=TEX
and
=FRULE 1 Conversion
dec_elim_conv 
ÒSÆ 
˜
˜
Ù S = S
=TEX
where S is a schema (here promoted to a predicate).
=ENDDOC

=DOC
val €DEC_C› : CONV -> CONV;
=DESCRIBE
$DEC\_C$ applies the supplied conversion to each member of a declaration and returns the conjunction of the results. 
=ENDDOC

=DOC
val €dec_intro_conv› : CONV;
=DESCRIBE
A conversion which rewrites to declarations the three cases : set membership, schema promoted to predicate and $ $ term.
=FRULE 1 Conversion
dec_intro_conv Òx ç XÆ
˜
˜
Ù x ç X § (x : X)
=TEX
and
=FRULE 1 Conversion
dec_intro_conv ÒS ∫ boolÆ 
˜
˜
Ù S = S
=TEX
and
=FRULE 1 Conversion
dec_intro_conv Ò S ç SÆ 
˜
˜
Ù ( S ç S) § S
=TEX
=FAILURE
	?0 cannot be rewritten to a declaration
=ENDDOC

=DOC
val €DEC_INTRO_C› : CONV -> CONV;
=DESCRIBE
$DEC\_INTRO\_C$ reduces a predicate to conjunctive normal form, then applies the supplied conversion to each conjunct.
If this is successful, it produces a declaration from the results.
=FAILURE
	?0 not of appropriate form
=ENDDOC

\section{Z REWRITING}
\subsection{Canonicalisation}
=DOC
val €Z_µ_rewrite_canon› : CANON;
=DESCRIBE
Take a Z universally quantified theorem and
make it into, as far as possible, a ProofPower HOL universally quantified
theorem usable for rewriting.
Simplifications due to $U$ and $true$ will be carried out.
=FRULE 1 Canon
Z_µ_rewrite_canon
˜
á Ù Ò(µ xâ1 : Xâ1; ... | Pâ1∑ Pâ2)Æ
˜
[á Ù ¨µ xâ1 ...∑ 
	Ò(x ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2ÆÆ]
=TEX
Where if any 
=INLINEFT
Òx ç Xâ1Æ
=TEX
or $Pâ1$ can be simplified to $true$ this will be
done and the $true$ then simplified away.
=FAILURE
	?0 is not of the form: Ò(µ xâ1 : Xâ1; ... | Pâ1∑ Pâ2)Æ
=ENDDOC
\subsection{Conditional Rewriting}
This is a yet to be implemented part of the ProofPower HOL system,
that may have some Z specific features.
\section{Z STRIPPING AND PROOF CONTEXTS}
In designing the following proof context we assume
it will be used in combination with at least proof context
``$'$propositions'' and ``$'$paired$\_$abstractions''.

=DOC
(* Proof Context: €'z_predicates› *)
=DESCRIBE
A component proof context for handling the additional requirements of Z predicate.
\paragraph{Contents}\ 

Rewriting:
=GFT
u_clauses,
Z_µ_true_conv, Z_∂_false_conv
=TEX
Stripping theorems:
=GFT
Z_∂_conv, Z_∂â1_conv,
≥_Z_µ_conv, ≥_Z_∂_conv,
RAND_C Z_∂â1_conv THEN ≥_Z_∂_conv,
ç_u_conv, Z_µ_true_conv, Z_∂_false_conv
=TEX
Stripping conclusions:
=GFT
Z_µ_conv, Z_∂â1_conv,
≥_Z_µ_conv, ≥_Z_∂_conv,
RAND_C Z_∂â1_conv THEN ≥_Z_∂_conv,
ç_u_conv, Z_µ_true_conv, Z_∂_false_conv
=TEX
Rewriting canonicalisation:
=GFT
Z_µ_rewrite_canon
=TEX
Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$ and no existence prover.

\paragraph{Usage Notes}
To be used with proof contexts ``$'$paired$\-\_$abstractions'' and ``$'$propositions''. It requires
theory $z\-\_language$.
=ENDDOC
=DOC
val €strip_tac› : TACTIC;
=DESCRIBE
This is a tactic that normally has the behaviour of $strip\_tac$ of signature $Tactics2$, but overrides it exactly
in the case of a Z universally quantified conclusion.

For Z universal quantifications it acts, independent of the current proof context, as:
=FRULE 2 Tactic
strip_tac
˜
á Ù Òµ xâ1 : Xâ1; ... | Pâ1∑ Pâ2Æ
˜
á Ù Ò(x ç Xâ1 ± ...) ± Pâ1 ¥ Pâ2Æ
=TEX
Otherwise:
=FRULE 2 Tactic
strip_tac
˜
á Ù t
˜
Tactics2.strip_tac  {á Ù t}
=TEX
=ENDDOC
As a documentation box to be read in isolation this leaves
something to be desired.

$step\_strip\_tac$ will be left untouched, and is thus able to
leave the Z language, which it does for 
stripping Z universally quantified conclusion or
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
will remain within the Z language if its argument starts there.
\subsection{contradiction Tactics}
The tactics supplied for ProofPower HOL extend to Z without
change.
\section{END OF THE SIGNATURE}

=SML
end; (* signature of ZPredicateCalculus *)
=TEX

\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}







