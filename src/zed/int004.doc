=IGN
********************************************************************************
int003.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Further Integration Tests for the ProofPower-Z System}  %% Mandatory field
\TPPref{DS/FMU/IED/INT003}  %% Mandatory field
\def\SCCSversion{$Revision: 1.12 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2011/08/05 14:37:29 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
\TPPauthor{R.D.Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{This document provides a description of the \ProductZ{} system integration tests.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.1,1.2]
First drafts with a miscellany of regression tests for recent bug fixes relating to term generation for schema operators.
\item[Issue 1.3]
Added tests for new \verb!$"..."! syntax.
\item[Issue 1.4]
Added test for bugfix in term generation for let expressions.
\item[Issue 1.5]
Revised tests for new \verb!$"..."! syntax.
\item[Issue 1.6, 1.7]
Tests for decorated fancyfix identifiers.
\item[Issue 1.8] Added pretty-printer loopback tests as regression tests for recent fix.
\item[Issue 1.9] Allowed for changes to lexical rules for underscores.
\item[Issue 1.10] Updated for empty schemas.
\item[Issue 1.10] Tested fix to calculation of characteristic tuples.
\item[Issue 1.11,1.12] Added tests for fix to$\alpha$-conversion and conversion of HOL quantifiers to Z.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}\label{Scope}
This document provides some additional system integration tests for {\ProductZ}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives additional integration tests for the \ProductZ{} system, excluding the generic HOL support tools.
It either describes the tests to be made, or gives a reference
to the test documents.

It mainly comprises regression tests relating to fixes that are are either most easily carried out using the full facilities of the system or which do not have a natural home in the module test documents.

\subsubsection{Dependencies}
The usual test harness of \cite{DS/FMU/IED/DTD013,DS/FMU/IED/IMP013} is used.

\subsubsection{Deficiencies}
None known.
\subsubsection{Changes Forecast}
N/A
\section{TEST CASES}
There are currently the following batches of tests
corresponding to the subsections of section~\ref{THETESTS} below.
The test cases may be further subdivided in those subsections.

\begin{description}
\item[Schema Operations] This tests a number of potentially anomalous cases of term generation for schema operations(e.g., unlikely combinations of signatures).
\item[Duplicate Declarations] This tests Z constructs in which a signature variable appears more than once in a declaration.
\item[Nonstandard Identifiers] This tests the feature supporting names containing arbitrary strings.
\item[Term Generation for Let Expressions] Regression tests
for a bug.
\item[Decorated Fancyfix Operators] Tests for an enhancement.
\item[Pretty-printer Loopback Tests] Regression tests for pretty-printing that are nicer to conduct with the Z library in place.
\end{description}

\section{PRELIMINARIES}
=SML
val Ûorig_thysİ = get_descendants "min";
val Ûclean_upİ : unit -> unit = (fn () =>
	let	val to_go = get_descendants "min" diff orig_thys;
		fun kill thy = force_delete_theory thy handle Fail _ => ();
	in	app kill to_go
	end
);
use_file "dtd013.sml";
use_file "imp013.sml";
=TEX
=SML
fun Ûcheck_convİ (conv : CONV)
	(expected_rhs : TERM -> bool)
	: TERM -> bool = (
	expected_rhs o snd o dest_eq o concl o conv
);
=TEX
=SML
fun Ûcheck_failİ f = (f (); false) handle Fail _ => true;
=TEX
\section{THE TESTS}\label{THETESTS}
\subsection{Schema Operators}
In this batch, there are test cases as follows:
\begin{description}
\item[Block 1] Edge cases for schema projection.
\item[Block 2] Edge cases for schema quantification.
\item[Block 3] Error cases for schema hiding.
\item[Block 4] Unusual cases for schema composition.
\end{description}
=SML
clean_up();
open_theory "z_library";
new_theory "block_1";
¹Z
Ü rel P _, Q _, R _
°
[ X ]œœœœœœœœœœœ
Ü P _, Q _, R _: ğX
ˆüüüüüüüüüüüüüü
ÿ A üüüüüüüüüüü
Ü a, ab, ac, abc : ú
÷üüüüüü
Ü P(a, ab, ac, abc)
ˆüüüüüüüüüüüüüü
ÿ B üüüüüüüüüüü
Ü b, ab, bc, abc : ú
÷üüüüüü
Ü P(b, ab, bc, abc)
ˆüüüüüüüüüüüüüü
ÿ C üüüüüüüüüüü
Ü c, ac, bc, abc : ú
÷üüüüüü
Ü P(c, ac, bc, abc)
ˆüüüüüüüüüüüüüü

=TEX

=SML
store_mt_results
(mt_run o map (fn (n, t) => (n, check_conv z_ù‰s_conv is_z_±‰s, t, true))) [
("so.1.1", ñA ù‰s A®),
("so.1.2", ñA ù‰s (A ± B)®),
("so.1.3", ñA ù‰s (A ± B ± C)®)
];

=TEX
=SML
store_mt_results
(mt_run o map (fn (n, t) => (n, check_conv z_µ‰s_conv is_z_seta, t, true))) [
("so.2.1", ñ(µA · A ± B ) º ƒ®),
("so.2.2", ñ(µA · A ± B ) º ƒ®)
];
=TEX
=SML
store_mt_results
mt_run [
("so.3.1", check_fail, (fn () => ñA \‰s (x, y, z)®), true)
];
store_mt_results
mt_run [
("so.3.2", fn tm => dest_z_schema_type (dest_z_power_type (type_of tm)) = [], ñA \‰s (a, ab, ac, abc)®, true)
];
=TEX
=TEX
=SML
store_mt_results
(mt_run o map (fn (n, t) => (n, check_conv z_»‰s_conv is_z_h_schema, t, true))) [
("so.4.1",  ñ[a,a',b,b':ú| P(a, a')] »‰s [a,a',c:ú| R(a, a')]®),
("so.4.2", ñ[a:ú| P(a, a')] »‰s [a:ú| R(a, a')]®),
("so.4.3", ñ[a:ú;b,b':ú;a:ú| P(b, b')] »‰s [a:ú| R(a, a')]®)
];
=TEX
\subsection{Duplicate Declarations}

=TEX
=SML
store_mt_results
(mt_run o map (fn (n, t) => (n, check_conv z_¶‰1_conv is_z_¶, t, true))) [
("dd.2.1", ñ¶‰1 x:X; x:X·P(x, y)®)
];
=TEX
=SML
store_mt_results
(mt_run o map (fn (n, t) => (n, check_conv z__seta_conv is_z_¶, t, true))) [
("dd.2.2", ña  {x : X; x : X  | P(x, x) · f (x, x)}®)
];
=TEX
=SML
store_mt_results
(mt_run o map (fn (n, t) => (n, check_conv z__Ì_conv is_z_, t, true))) [
("dd.2.3", ña  (Ìx : X; x : X  | P(x, y) · f (x, y))®),
("dd.2.4", ña  (Ìx : X; [a, b: X]; x : X  | P(x, y) · f (x, y))®)
];
=TEX
=SML
fun all_undisch_rule thm = 
	all_undisch_rule (undisch_rule thm) handle Fail _ => thm;
val Ûz_Í_convİ : CONV = all_undisch_rule o all_µ_elim o conv_rule z_µ_elim_conv o z_Í_rule;
=TEX
=SML
store_mt_results
(mt_run o map (fn (n, t) => (n, check_conv z_Í_conv is_z_lvar, t, true))) [
("dd.2.5", ñ(Íx : X; x : X  | P(x, y) · f (x, y))®)
];
=TEX
\subsection{Support for Nonstandard Identifiers}
The new \verb!$"..."! syntax allows an arbitrary string to be used as the identifier part of a name.
=SML
store_mt_results
mt_run [
("ni.1.1", fst o dest_var, ñ $"abc"®, "$\"abc\""),
("ni.1.2", fst o dest_var, ñ $" a b c "®, "$\" a b c \""),
("ni.1.3", fst o dest_var, ñ $""®, "$\"\""),
("ni.1.4", fst o dest_var, ñ $"!!!"®, "$\"!!!\"")
];
=TEX
As part of the support for the new syntax, {\em unpack\_ident} has been redesigned so that it treats any string as legal and only takes trailing decoration characters as decoration.
=SML
val upi = ZTypesAndTermsSupport.unpack_ident;
store_mt_results
mt_run [
("ni.2.1", upi, "abc", ("abc", "")),
("ni.2.2", upi, "a'b'c", ("a'b'c", "")),
("ni.2.3", upi, "a'b'c'", ("a'b'c", "'")),
("ni.2.4", upi, "a'b'c'!?", ("a'b'c", "'!?")),
("ni.2.5", upi, "'!?", ("", "'!?")),
("ni.2.6", upi, "", ("", ""))
];
=TEX
The pretty-printer should use the new syntax when it can to print non-standard terms.
=SML
val pp_s = string_of_termñµ $"a'b'c'" : X · $"a'b'c'" = x®;
val my_s = "ñµ $\"a'b'c'\" : X · $\"a'b'c'\" = x®";
store_mt_results
mt_run [
("ni.3.1", (op =), (explode pp_s less " ", explode my_s less " "), true)
];
=TEX
\subsection{Term Generation for Let Expressions}
The following should not fail:
ÿ S_LET2 üüüüüüüüüüü
Ü A : ú
÷üüüüüü
Ü let X ¦ 4; Y ¦ 7 · true
ˆüüüüüüüüüüüüüü
ÿ S_LET5 üüüüüüüüüüü
Ü A : ú
÷üüüüüü
Ü let X ¦ 4; Y ¦ 7; Z ¦ 10; A ¦ 13; B ¦ 16 · true
ˆüüüüüüüüüüüüüü
=TEX
\subsection{Decorated Fancyfix Operators}
=TEX
As part of the support for the new syntax, {\em unpack\_ident}  and  {\em pack\_ident} have been redesigned to put the decoration in the right place.
=SML
val upi = ZTypesAndTermsSupport.unpack_ident;
store_mt_results
mt_run [
("ffo.1.1", upi, "abc' _", ("abc _", "'")),
("ffo.1.2", upi, "_ +!?' _", ("_ + _", "!?'"))
];
=TEX
=SML
val pi = ZTypesAndTermsSupport.pack_ident;
store_mt_results
mt_run [
("ffo.2.1", pi, ("abc _", "!"), "abc! _"),
("ffo.2.2", pi, ("_ + _", "!?'"), "_ +!?' _")
];
=SML
clean_up();
open_theory "z_library" ;
new_theory "fancyfix" ;
¹Z
Ü function 10 _--_, _++_
°
ÿ OPS üüüüüüüüüüü
Ü _--_ : ú ¸ ú ­ ú;
Ü _++_ : ú ¸ ú ­ ú
÷üüüüüü
Ü µx, y: ú·(x ++ y) -- y = x
ˆüüüüüüüüüüüüüü
=TEX
=SML
store_mt_results
(mt_runf (op =$)) [
("ffo.3.1", z_type_of, ñOPS®, ñğ[_ ++ _, _ -- _ : ú ¸ ú ª ú]®),
("ffo.3.2", z_type_of, ñOPS!®, ñğ[_ ++! _, _ --! _ : ú ¸ ú ª ú]®),
("ffo.3.3", z_type_of, ñ[OPS; OPS']®, ñğ[_ ++ _, _ ++' _, _ -- _, _ --' _ : ú ¸ ú ª ú]®),
("ffo.3.4", z_type_of, ñ[OPS; OPS'] »‰s [OPS; OPS']®, ñğ[_ ++ _, _ ++' _, _ -- _, _ --' _ : ú ¸ ú ª ú]®)
];
¹Z
Ü relation Known _
°

ÿ ST üüüüüüüüüüü
Ü Known _ : ğú
ˆüüüüüüüüüüüüüü
ÿ Learn üüüüüüüüüüü
Ü „ST;
Ü what? : ú
÷
Ü ³Known what?;
Ü (Known' _) = (Known _) À {what?}
ˆüüüüüüüüüüüüüü
=SML
fun check_pop_thm () = (
	(pop_thm(); true) handle Fail _ => false
);
set_pc"z_library";
set_goal([], ñpre Learn ¤ ³Known what?®);
a(rewrite_tac(map z_get_spec[ñST®, ñLearn®]));
a(cases_tacñ³Known what?® THEN asm_rewrite_tac[]);
a(z_¶_tacñ(Known _) À {what?}® THEN rewrite_tac[]);
store_mt_results
mt_run [
("ffo.4.1", check_pop_thm, (), true)
];
=TEX
=SML
set_goal([], ñST! = {a : ğú· (Known! _ ¦ a)}®);
a(PC_T1 "z_library_ext" rewrite_tac(map z_get_spec[ñST®]));
store_mt_results
mt_run [
("ffo.4.2", check_pop_thm, (), true)
];
=TEX
=SML
set_goal([], ñ(„ST) = {a, b : ğú· (Known _ ¦ a, Known'_ ¦ b)}®);
a(PC_T1 "z_library_ext" rewrite_tac(map z_get_spec[ñST®]));
store_mt_results
mt_run [
("ffo.4.3", check_pop_thm, (), true)
];
=TEX
=SML
set_goal([], ñ(˜ST) = {a : ğú· (Known _ ¦ a, Known'_ ¦ a)}®);
a(PC_T1 "z_library_ext" rewrite_tac(map z_get_spec[ñST®]));
store_mt_results
mt_run [
("ffo.4.4", check_pop_thm, (), true)
];
=TEX
\subsection{Pretty-printer Loopback Tests}
=SML
val test_cases1 =
[	(1, ñseq X ¸ Y®),
	(2, ñseq (X ¸ Y)®),
	(3, ñid (A À B)®),
	(4, ñ~ (A + B) + C + (D + E) + (F + G)®),
	(5, ñ(A À B) ¸ C®),
	(6, ñA À (B ¸ C)®),
	(7, ñA ­ (B ¸ C)®),
	(8, ñA ­ B ¸ C®), 
	(9, ñ(A ­ B) ¸ C®),
	(10, ñ(A ­ B) ¸ (C ­ D)®),
	(11, ñæ (A ¸ B) ¸ (A ¸ B)®),
	(12, ñ(A ¸ B ¸ C) ¸ (D ¸ E ¸ F) ¸ G®),
	(13, ñA À B ¸ C À D®),
	(14, ñA À (B ¸ C) À D®),
	(15, ñid A À (B ¸ C) À D®)];

=TEX
=SML
val returned : (int * TERM) list ref = ref [];
=TEX
=SML
fun loopback (file : string) (tcs : (int * TERM) list)
	: (int * TERM) list = (
	let	val strm = open_out file;
		fun fmt1 (i, t) = "(" ^ string_of_int i ^ ", " ^ string_of_term t ^ ")";
		fun do1 p = (
			output(strm, "returned := ");
			output(strm, fmt1 p);
			output(strm, " :: !returned;\n")
		);
	in	app do1 (rev tcs);
		close_out strm;
		returned := [];
		use_file file;
		!returned
	end
);
=TEX
=SML
fun check_pairs [] [] = true
|   check_pairs [] _ = false
|   check_pairs _ [] = false
|   check_pairs ((i1, tm1)::more1) ((i2, tm2)::more2) = (
	i1 = i2 andalso tm1 =$ tm2 andalso check_pairs more1 more2
);
=TEX
=SML
val results1 = loopback "int004A.ML" test_cases1;
=TEX
=SML
store_mt_results
mt_run [
("pp_loopback.1", check_pairs test_cases1, results1, true)
];
=TEX
\subsection{Characteristic Tuples}
=SML
clean_up();
open_theory "z_library";
new_theory "t";
=TEX
¹Z
Ü S ¦ [X : ú]
°
=TEX
=SML
store_mt_results
mt_run [
	("chartuple.1.1", fn _ => z_type_of ñ {S; S'} ®, (),
			ñ[X : ú] ª [X : ú]®),
	("chartuple.1.2", fn _ => z_type_of ñ (Ì S; S' · 0) ®, (),
			ñ [X : ú] ¸ [X : ú] ª ú ® ),
	("chartuple.1.3", fn _ => z_type_of ñ (Í S; S') ®, (),
			ñ [X : ú] ¸ [X : ú] ® ),
	("chartuple.1.4", fn _ => z_type_of ñ {{ S; S' }} ®, (),
			ñ ğ([X : ú] ª [X : ú]) ® )
];
=TEX
\subsection{$\alpha$-conversion and conversion of HOL quantifiers to Z}
=SML
clean_up();
open_theory "z_library";
new_theory "t";
set_pc "z_predicates";
=TEX
=SML
val tm1 = (snd o dest_eq o concl o z_µ_elim_conv2) ñµ [a : X; x : X] · y = x®;
val tm2 = subst[(¬x:'a®, ¬y:'a®)] tm1;
val tm3 = (snd o dest_eq o concl o z_¶_elim_conv2) ñ¶ [a : X; x : X] · y = x®;
val tm4 = subst[(¬x:'a®, ¬y:'a®)] tm3;
fun check_no_asms thm = (
	case dest_thm thm of
		([], tm) => tm
	|	_ => fail "check_no_asms" 7061 []
);
=TEX
=SML
store_mt_results
mt_run [
	("alpha-conv.1.1", fst o dest_eq o check_no_asms o z_µ_intro_conv1, tm2,
			tm2),
	("alpha-conv.1.2", snd o dest_eq o check_no_asms o z_µ_intro_conv1, tm2,
			ñµ ([a : X; x : X] [x'/x]) · x = x'®),
	("alpha-conv.1.3", fst o dest_eq o check_no_asms o z_¶_intro_conv1, tm4,
			tm4),
	("alpha-conv.1.4", snd o dest_eq o check_no_asms o z_¶_intro_conv1, tm4,
			ñ¶ ([a : X; x : X] [x'/x]) · x = x'®)
];
=TEX
=SML
val tm5 = ñb  { a : ú; b : ú  · a}®;
val tm6 = ñb  {[a : ú; b : ú] · a}®;
store_mt_results
mt_run [
	("alpha-conv.2.1", fst o dest_eq o check_no_asms o z__seta_conv, tm5,
			tm5),
	("alpha-conv.2.2", snd o dest_eq o check_no_asms o z__seta_conv, tm5,
			ñ¶ a : ú; b' : ú · a = b®),
	("alpha-conv.2.3", fst o dest_eq o check_no_asms o z__seta_conv, tm6,
			tm6),
	("alpha-conv.2.4", snd o dest_eq o check_no_asms o z__seta_conv, tm6,
			ñ¶ ([a : ú; b : ú] [b'/b]) · a = b®)
];
=SML
val tm7 =  ñ [X] (µ A : ğ X; f : ğ [x : X; y : Y]·
		{f · (x, y)} ¨ A © = {f | x  A · y})®;
set_goal ([], tm7);
a (PC_T1 "z_rel_ext" REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a (z_¶_tac ñ(x ¦ x, y ¦ x1)® THEN asm_rewrite_tac []);
(* *** Goal "2" *** *)
a all_var_elim_asm_tac;
a (z_¶_tac ñx® THEN asm_rewrite_tac []);
a (PC_T1 "z_rel_ext" REPEAT z_strip_tac);
store_mt_results
mt_run [("alpha-conv.3.1", check_no_asms o pop_thm, (), tm7)];
=TEX
\section{EPILOGUE}
=SML
val _ = diag_line(summarize_mt_results());

=TEX
\end{document}
