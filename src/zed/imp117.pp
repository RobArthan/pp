=IGN
********************************************************************************
imp117.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Implementation of the Z Library Real Numbers }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the implementation for the theory
of real numbers in \ProductZ.}
\end{center}}

\def\Reference{LEMMA1/HOL/IMP117}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}

\def\Date{\FormatDate{\VCDate}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1 (2000/12/10)-1.4 (2000/12/13)] Initial development drafts.
\item[Issues 1.5 (2001/05/28)-1.8 (2001/07/05)] Corrected errors in theorems about associativity and multiplication and
some improvements to the treatment of unary negation in the proof contexts.
\item[Issue 1.9 (2001/08/29)] Corrections to conversion for exponentiation; tidy-up of
error-handling.
\item[Issue 1.10 (2001/11/12), 1.11 (2002/01/23)] Fixed botched bindings for theorems relating to division.
\item[Issue 1.12 (2002/10/17)] More on the ML bindings for the two theorems about division.
\item[Issue 1.12 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.13 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.14 (2004/01/19)] The Z universal set is now called ùïå.
\item[Issue 1.15 (2005/02/26)] Precedences and associativity of toolkit operators now follow \cite{ISO02}.
\item[Issue 1.16 (2005/08/01)] Allowed for new associativity of division in statement of
=INLINEFT
z_‚Ñù_over_clauses
=TEX
.
\item[Issue 1.17 (2006/04/20)] Added support for floating point literals
\item[Issue 1.18 (2006/05/08)] The proof context now normalises literal fractions.
\item[Issue 1.19 (2007/11/22)] Added lower bounds, greatest lower, upper bounds and least upper bounds.
\item[Issue 1.20 (2008/02/10)] Allowed for changes to lexical rules for underscores.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

%%%% END OF CHANGES HISTORY %%%%
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document contains the implementation
of the Z Library theory of real numbers and their proof support.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.


\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{PREAMBLE}

=SML
structure ‚¶èZReals‚¶é : ZReals = struct
=SML
val _ = open_theory"z_reals";
=TEX
\section{DEFINITIONS}
=SML
val ‚¶èz_‚Ñù_def‚¶é = z_get_spec‚ì©‚Ñù‚åù;
val ‚¶èz_‚Ñù_less_def‚¶é = z_get_spec‚ì©(_ <‚ãéR _)‚åù;
val ‚¶èz_‚Ñù_‚â§_def‚¶é = z_‚Ñù_less_def;
val ‚¶èz_‚Ñù_minus_def‚¶é = z_‚Ñù_less_def;
val ‚¶èz_‚Ñù_plus_def‚¶é = z_‚Ñù_less_def;
val ‚¶èz_‚Ñù_times_def‚¶é = z_‚Ñù_less_def;
val ‚¶èz_‚Ñù_over_def‚¶é = z_‚Ñù_less_def;
val ‚¶èz_‚Ñù_abs_def‚¶é = z_‚Ñù_less_def;

val ‚¶èz_‚Ñù_greater_def‚¶é = z_get_spec‚ì©(_ >‚ãéR _)‚åù;
val ‚¶èz_‚Ñù_‚â•_def‚¶é = z_‚Ñù_greater_def;
val ‚¶èz_‚Ñù_subtract_def‚¶é = z_‚Ñù_greater_def;

val ‚¶èz_‚Ñù_real_def‚¶é = z_get_spec‚ì©real‚åù;
val ‚¶èz_‚Ñù_frac_def‚¶é = z_get_spec‚ì©(_ /‚ãéZ _)‚åù;
val ‚¶èz_‚Ñù_‚Ñ§_exp_def‚¶é = z_get_spec‚ì©(_ ^‚ãéZ _)‚åù;
val ‚¶èz_‚Ñù_dot_dot_def‚¶é = z_get_spec‚ì©(_ ..‚ãéR _)‚åù;

val ‚¶èz_‚Ñù_lb_def‚¶é = z_get_spec‚ì©(_ lb‚ãéR _)‚åù;
val ‚¶èz_‚Ñù_glb_def‚¶é = z_get_spec‚ì©glb‚ãéR‚åù;
val ‚¶èz_‚Ñù_ub_def‚¶é = z_get_spec‚ì©(_ lb‚ãéR _)‚åù;
val ‚¶èz_‚Ñù_lub_def‚¶é = z_get_spec‚ì©lub‚ãéR‚åù;
=TEX
\section{THEOREMS}
\subsection{Preamble}
=SML
val _ = set_merge_pcs["z_predicates", "'z_numbers", "'‚Ñù"];
val  ‚¶èmain_defs‚¶é = list_‚àß_intro[
	z_‚Ñù_def,
	rewrite_rule[z_get_spec‚ì©‚Ñù‚åù] z_‚Ñù_less_def,
	rewrite_rule[z_get_spec‚ì©‚Ñù‚åù] z_‚Ñù_minus_def,
	rewrite_rule[z_get_spec‚ì©‚Ñ§‚åù] z_‚Ñù_real_def,
	rewrite_rule[z_get_spec‚ì©‚Ñ§‚åù] z_‚Ñù_frac_def,
	rewrite_rule[z_get_spec‚ì©‚Ñ§‚åù, z_get_spec‚ì©‚Ñù‚åù] z_‚Ñù_‚Ñ§_exp_def,
	rewrite_rule[z_get_spec‚ì©‚Ñù‚åù] z_‚Ñù_dot_dot_def
];
=TEX
\subsection{Order Structure}
In this section we prove basic facts about the less-than relation on the reals:
=SML
val ‚¶èz_‚Ñù_unbounded_below_thm‚¶é = (
set_goal([], ‚ì©‚àÄx: ‚Ñù‚¶Å ‚àÉy:‚Ñù‚¶Å y <‚ãéR x‚åù);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(strip_asm_tac (‚àÄ_elim‚åúx‚åù‚Ñù_unbounded_below_thm));
a(contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "z_‚Ñù_unbounded_below_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_unbounded_above_thm‚¶é = (
set_goal([], ‚ì©‚àÄx: ‚Ñù‚¶Å ‚àÉy : ‚Ñù‚¶Å x <‚ãéR y‚åù);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(strip_asm_tac (‚àÄ_elim‚åúx‚åù‚Ñù_unbounded_above_thm));
a(contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "z_‚Ñù_unbounded_above_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_less_irrefl_thm‚¶é = (
set_goal([], ‚ì©‚àÄx: ‚Ñù‚¶Å ¬¨x <‚ãéR x‚åù);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
save_pop_thm "z_‚Ñù_less_irrefl_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_less_antisym_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å ¬¨(x <‚ãéR y ‚àß y <‚ãéR x)‚åù);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(all_fc_tac[‚Ñù_less_antisym_thm]);
save_pop_thm "z_‚Ñù_less_antisym_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_less_trans_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y, z: ‚Ñù‚¶Å x <‚ãéR y ‚àß y <‚ãéR z ‚áí x <‚ãéR z‚åù);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(all_fc_tac[‚Ñù_less_trans_thm]);
save_pop_thm "z_‚Ñù_less_trans_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_less_cases_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x <‚ãéR y ‚à® x = y ‚à® y <‚ãéR x‚åù);
a(rewrite_tac[main_defs, ‚Ñù_less_cases_thm]);
save_pop_thm "z_‚Ñù_less_cases_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_cases_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x ‚â§‚ãéR y ‚à® y ‚â§‚ãéR x‚åù);
a(rewrite_tac[main_defs, ‚Ñù_‚â§_cases_thm]);
save_pop_thm "z_‚Ñù_‚â§_cases_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_less_cases_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x ‚â§‚ãéR y ‚à® y <‚ãéR x‚åù);
a(rewrite_tac[main_defs, ‚Ñù_‚â§_less_cases_thm]);
save_pop_thm "z_‚Ñù_‚â§_less_cases_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_eq_‚â§_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x = y ‚áî x ‚â§‚ãéR y ‚àß y ‚â§‚ãéR x‚åù);
a(rewrite_tac[main_defs, ‚Ñù_eq_‚â§_thm]);
save_pop_thm "z_‚Ñù_eq_‚â§_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_antisym_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x ‚â§‚ãéR y ‚àß y ‚â§‚ãéR x  ‚áí x = y‚åù);
a(rewrite_tac[main_defs, ‚Ñù_eq_‚â§_thm]);
save_pop_thm "z_‚Ñù_‚â§_antisym_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_less_‚â§_trans_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y, z: ‚Ñù‚¶Å x <‚ãéR y ‚àß y ‚â§‚ãéR z ‚áí x <‚ãéR z‚åù);
a(rewrite_tac[main_defs, ‚Ñù_less_‚â§_trans_thm]);
save_pop_thm "z_‚Ñù_less_‚â§_trans_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_less_trans_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y, z: ‚Ñù‚¶Å x ‚â§‚ãéR y ‚àß y <‚ãéR z ‚áí x <‚ãéR z‚åù);
a(rewrite_tac[main_defs, ‚Ñù_‚â§_less_trans_thm]);
save_pop_thm "z_‚Ñù_‚â§_less_trans_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_refl_thm‚¶é = (
set_goal([], ‚ì©‚àÄx: ‚Ñù‚¶Å x ‚â§‚ãéR x‚åù);
a(rewrite_tac[main_defs, ‚Ñù_‚â§_refl_thm]);
save_pop_thm "z_‚Ñù_‚â§_refl_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_trans_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y, z: ‚Ñù‚¶Å x ‚â§‚ãéR y ‚àß y ‚â§‚ãéR z ‚áí x ‚â§‚ãéR z‚åù);
a(rewrite_tac[main_defs, ‚Ñù_‚â§_trans_thm]);
save_pop_thm "z_‚Ñù_‚â§_trans_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_¬¨_less_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x ‚â§‚ãéR y ‚áî ¬¨y <‚ãéR x‚åù);
a(rewrite_tac[main_defs, ‚Ñù_‚â§_¬¨_less_thm]);
save_pop_thm "z_‚Ñù_‚â§_¬¨_less_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_¬¨_‚â§_less_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å ¬¨x ‚â§‚ãéR y ‚áî y <‚ãéR x‚åù);
a(rewrite_tac[main_defs, ‚Ñù_¬¨_‚â§_less_thm]);
save_pop_thm "z_‚Ñù_¬¨_‚â§_less_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_less_¬¨_eq_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x <‚ãéR y ‚áí ¬¨x = y‚åù);
a(rewrite_tac[main_defs, ‚Ñù_less_¬¨_eq_thm]);
save_pop_thm "z_‚Ñù_less_¬¨_eq_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_¬¨_less_‚â§_thm‚¶é = conv_rule (ONCE_MAP_C eq_sym_conv) z_‚Ñù_‚â§_¬¨_less_thm;
=TEX
=SML
val ‚¶èz_‚Ñù_less_dense_thm‚¶é = (
set_goal([], ‚ì©‚àÄx, y: ‚Ñù‚¶Å x <‚ãéR y ‚áí (‚àÉz:‚Ñù‚¶Å x <‚ãéR z ‚àß z <‚ãéR y)‚åù);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(all_fc_tac[‚Ñù_less_dense_thm]);
a(z_‚àÉ_tac‚ì©z‚åù THEN REPEAT strip_tac);
save_pop_thm "z_‚Ñù_less_dense_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_complete_thm‚¶é = (
set_goal([], ‚ì©‚àÄA : ‚Ñô ‚Ñù‚¶Å
	¬¨A = {} ‚àß (‚àÉb:‚Ñù‚¶Å‚àÄ x:‚Ñù‚¶Å x ‚àà A ‚áí x ‚â§‚ãéR b) ‚áí
	(‚àÉs:‚Ñù‚¶Å  (‚àÄ x:‚Ñù‚¶Å x ‚àà A ‚áí x ‚â§‚ãéR s)
‚àß	(‚àÄ b:‚Ñù‚¶Å (‚àÄ x:‚Ñù‚¶Å x ‚àà A ‚áí x ‚â§‚ãéR b) ‚áí s ‚â§‚ãéR b))
‚åù);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(strip_asm_tac(‚àÄ_elim‚åúA‚åù‚Ñù_complete_thm));
(* *** Goal "1" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[get_spec‚ì©{}‚åù]);
(* *** Goal "2" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 1);
a(‚àÉ_tac‚åúb‚åù THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(z_‚àÉ_tac‚åús‚åù THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[]);
save_pop_thm"z_‚Ñù_complete_thm"
);
=TEX
\subsection{Additive Structure}
=SML
val ‚¶èz_‚Ñù_plus_assoc_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx, y, z: ‚Ñù‚¶Å (x +‚ãéR y) +‚ãéR z = x +‚ãéR (y +‚ãéR z)‚åù);
a(REPEAT strip_tac THEN rewrite_tac[main_defs, ‚Ñù_plus_assoc_thm]);
save_pop_thm"z_‚Ñù_plus_assoc_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_assoc_thm1‚¶é = (
set_goal([], ‚ì© ‚àÄx, y, z: ‚Ñù‚¶Å x +‚ãéR (y +‚ãéR z) = (x +‚ãéR y) +‚ãéR z‚åù);
a(rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_assoc_thm]);
save_pop_thm"z_‚Ñù_plus_assoc_thm1"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_comm_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx, y: ‚Ñù‚¶Å x +‚ãéR y = y +‚ãéR x ‚åù);
a(REPEAT strip_tac THEN rewrite_tac[main_defs, ‚àÄ_elim‚åúx:‚Ñù‚åù‚Ñù_plus_order_thm]);
save_pop_thm"z_‚Ñù_plus_comm_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_real_0_thm‚¶é = (
set_goal([], ‚ì© real 0 = ‚åú‚Ñï‚Ñù 0‚åù ‚åù);
a(LEMMA_T ‚ì©real 0 = real (0 + ~0)‚åù pure_rewrite_thm_tac THEN1 rewrite_tac[]);
a(pure_rewrite_tac[main_defs]);
a(rewrite_tac[‚Ñù_minus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_real_‚Ñï‚Ñù_thm‚¶é = (
set_goal([], ‚åú ‚àÄm:‚Ñï‚¶Å ‚ì©real ‚åú(Z'Int m)‚åù‚åù = ‚Ñï‚Ñù m ‚åù);
a(REPEAT strip_tac THEN induction_tac ‚åúm:‚Ñï‚åù);
(* *** Goal "1" *** *)
a(rewrite_tac[z_‚Ñù_real_0_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_int_homomorphism_thm, ‚Ñï‚Ñù_plus_homomorphism_thm]);
a(asm_rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_unit_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx: ‚Ñù‚¶Å x +‚ãéR real 0 = x ‚åù);
a(rewrite_tac[main_defs, z_‚Ñù_real_0_thm, ‚Ñù_plus_clauses]);
save_pop_thm "z_‚Ñù_plus_unit_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_mono_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx, y, z: ‚Ñù‚¶Å y <‚ãéR z ‚áí x +‚ãéR y <‚ãéR x +‚ãéR z ‚åù);
a(rewrite_tac [main_defs] THEN REPEAT strip_tac);
save_pop_thm "z_‚Ñù_plus_mono_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_mono_thm1‚¶é = (
set_goal([], ‚ì© ‚àÄx, y, z: ‚Ñù‚¶Å y <‚ãéR z ‚áí y +‚ãéR x <‚ãéR z +‚ãéR x‚åù);
a(once_rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_comm_thm]);
a(rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_mono_thm]);
save_pop_thm"z_‚Ñù_plus_mono_thm1"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_mono_thm2‚¶é = (
set_goal([], ‚ì© ‚àÄx, y, s, t: ‚Ñù‚¶Å x <‚ãéR y ‚àß s <‚ãéR t ‚áí x +‚ãéR s <‚ãéR y +‚ãéR t‚åù);
a(rewrite_tac [main_defs] THEN REPEAT strip_tac);
a(bc_thm_tac ‚Ñù_less_trans_thm THEN ‚àÉ_tac‚åúy +‚ãéR s‚åù THEN asm_rewrite_tac[]);
save_pop_thm"z_‚Ñù_plus_mono_thm2"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_0_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx: ‚Ñù‚¶Å x +‚ãéR real 0 = x ‚àß real 0 +‚ãéR x = x ‚åù);
a(rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_unit_thm]);
a(once_rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_comm_thm]);
a(rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_unit_thm]);
save_pop_thm"z_‚Ñù_plus_0_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_order_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx, y, z: ‚Ñù‚¶Å y +‚ãéR x = x +‚ãéR y
		      ‚àß (x +‚ãéR y) +‚ãéR z = x +‚ãéR (y +‚ãéR z)
		      ‚àß y +‚ãéR (x +‚ãéR z) = x +‚ãéR (y +‚ãéR z)‚åù);
a(rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(conv_tac (LEFT_C (once_rewrite_conv
	[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_comm_thm]))
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_assoc_thm1]);
a(conv_tac (RAND_C (ONCE_MAP_C(LEFT_C(once_rewrite_conv
	[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_comm_thm]))))
	THEN REPEAT strip_tac);
save_pop_thm"z_‚Ñù_plus_order_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_minus_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx: ‚Ñù‚¶Å x +‚ãéR ~‚ãéR x = real 0 ‚àß ~‚ãéR x +‚ãéR x = real 0‚åù);
a(z_‚àÄ_tac THEN strip_tac);
a(conv_tac (RIGHT_C
	(once_rewrite_conv[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù]z_‚Ñù_plus_comm_thm])));
a(rewrite_tac[main_defs, ‚Ñù_minus_clauses, z_‚Ñù_real_0_thm]);
save_pop_thm"z_‚Ñù_plus_minus_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_eq_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx, y: ‚Ñù‚¶Å x = y ‚áî x +‚ãéR ~‚ãéR y = real 0 ‚åù);
a(z_‚àÄ_tac THEN strip_tac);
a(rewrite_tac[main_defs, z_‚Ñù_real_0_thm]);
a(conv_tac (LEFT_C (once_rewrite_conv[‚Ñù_eq_thm])));
a(rewrite_tac[]);
save_pop_thm"z_‚Ñù_eq_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_minus_clauses‚¶é = (
set_goal([], ‚ì© ‚àÄx, y : ‚Ñù‚¶Å
	~‚ãéR (~‚ãéR x) = x
‚àß	x +‚ãéR ~‚ãéR x = real 0
‚àß	~‚ãéR x +‚ãéR x = real 0
‚àß	 ~‚ãéR (x +‚ãéR y) = ~‚ãéR x +‚ãéR ~‚ãéR y
‚àß	~‚ãéR (real 0) = real 0‚åù);
a(z_‚àÄ_tac THEN strip_tac);
a(rewrite_tac[main_defs, z_‚Ñù_real_0_thm]);
save_pop_thm"z_‚Ñù_minus_clauses"
);
=TEX
=SML
val ‚¶èz_‚Ñù_minus_eq_thm‚¶é = (
set_goal([], ‚ì© ‚àÄx, y: ‚Ñù‚¶Å ~‚ãéR x = ~‚ãéR y ‚áî x = y ‚åù);
a(z_‚àÄ_tac THEN strip_tac);
a(rewrite_tac[main_defs, ‚Ñù_minus_eq_thm]);
save_pop_thm"z_‚Ñù_minus_eq_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_clauses‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y, z : ‚Ñù‚¶Å
		         (x +‚ãéR z = y +‚ãéR z ‚áî x = y)
		      ‚àß (z +‚ãéR x = y +‚ãéR z ‚áî x = y)
		      ‚àß (x +‚ãéR z = z +‚ãéR y ‚áî x = y)
		      ‚àß (z +‚ãéR x = z +‚ãéR y ‚áî x = y)
		      ‚àß (x +‚ãéR z = z ‚áî x = real 0)
		      ‚àß (z +‚ãéR x = z ‚áî x = real 0)
		      ‚àß (z = z +‚ãéR y ‚áî y = real 0)
		      ‚àß (z = y +‚ãéR z ‚áî y = real 0)
		      ‚àß x +‚ãéR real 0 = x
		      ‚àß real 0 +‚ãéR x = x
		      ‚àß ¬¨ real 1 = real 0
		      ‚àß ¬¨ real 0 = real 1‚åù);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm, ‚Ñù_plus_clauses]);
save_pop_thm"z_‚Ñù_plus_clauses"
);
=TEX
=SML
val ‚¶èz_‚Ñù_less_clauses‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y, z : ‚Ñù‚¶Å
		         (x +‚ãéR z <‚ãéR y +‚ãéR z ‚áî x <‚ãéR y)
		      ‚àß (z +‚ãéR x <‚ãéR y +‚ãéR z ‚áî x <‚ãéR y)
		      ‚àß (x +‚ãéR z <‚ãéR z +‚ãéR y ‚áî x <‚ãéR y)
		      ‚àß (z +‚ãéR x <‚ãéR z +‚ãéR y ‚áî x <‚ãéR y)
		      ‚àß (x +‚ãéR z <‚ãéR z ‚áî x <‚ãéR real 0)
		      ‚àß (z +‚ãéR x <‚ãéR z ‚áî x <‚ãéR real 0)
		      ‚àß (x <‚ãéR z +‚ãéR x ‚áî real 0 <‚ãéR z)
		      ‚àß (x <‚ãéR x +‚ãéR z ‚áî real 0 <‚ãéR z)
		      ‚àß ¬¨x <‚ãéR x
		      ‚àß real 0 <‚ãéR real 1
		      ‚àß ¬¨ real 1 <‚ãéR real 0
‚åù);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm, ‚Ñù_less_clauses]);
save_pop_thm"z_‚Ñù_less_clauses"
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â§_clauses‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y, z : ‚Ñù‚¶Å
		         (x +‚ãéR z ‚â§‚ãéR y +‚ãéR z ‚áî x ‚â§‚ãéR y)
		      ‚àß (z +‚ãéR x ‚â§‚ãéR y +‚ãéR z ‚áî x ‚â§‚ãéR y)
		      ‚àß (x +‚ãéR z ‚â§‚ãéR z +‚ãéR y ‚áî x ‚â§‚ãéR y)
		      ‚àß (z +‚ãéR x ‚â§‚ãéR z +‚ãéR y ‚áî x ‚â§‚ãéR y)
		      ‚àß (x +‚ãéR z ‚â§‚ãéR z ‚áî x ‚â§‚ãéR real 0)
		      ‚àß (z +‚ãéR x ‚â§‚ãéR z ‚áî x ‚â§‚ãéR real 0)
		      ‚àß (x ‚â§‚ãéR z +‚ãéR x ‚áî real 0 ‚â§‚ãéR z)
		      ‚àß (x ‚â§‚ãéR x +‚ãéR z ‚áî real 0 ‚â§‚ãéR z)
		      ‚àß x ‚â§‚ãéR x
		      ‚àß real 0 ‚â§‚ãéR real 1
		      ‚àß ¬¨ real 1 ‚â§‚ãéR real 0
‚åù);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm, ‚Ñù_‚â§_clauses]);
save_pop_thm"z_‚Ñù_‚â§_clauses"
);
=TEX
\subsection{Multipicative Structure}
=SML
val ‚¶èz_‚Ñù_times_assoc_thm‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y, z: ‚Ñù‚¶Å (x *‚ãéR y) *‚ãéR z = x *‚ãéR (y *‚ãéR z)‚åù);
a(rewrite_tac[main_defs, ‚Ñù_times_assoc_thm]);
save_pop_thm"z_‚Ñù_times_assoc_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_times_comm_thm‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y: ‚Ñù‚¶Å x *‚ãéR y = y *‚ãéR x‚åù);
a(REPEAT strip_tac THEN rewrite_tac[main_defs, ‚àÄ_elim‚åúx:‚Ñù‚åù ‚Ñù_times_order_thm]);
save_pop_thm"z_‚Ñù_times_comm_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_times_unit_thm‚¶é = (
set_goal([], ‚ì© ‚àÄ x:‚Ñù‚¶Å x *‚ãéR real 1 = x‚åù);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm]);
save_pop_thm"z_‚Ñù_times_unit_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_0_less_0_less_times_thm‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y:‚Ñù‚¶Å real 0 <‚ãéR x ‚àß real 0 <‚ãéR y ‚áí real 0 <‚ãéR x *‚ãéR y‚åù);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm, ‚Ñù_0_less_0_less_times_thm]);
save_pop_thm"z_‚Ñù_0_less_0_less_times_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_times_assoc_thm1‚¶é = save_thm("z_‚Ñù_times_assoc_thm1",
	conv_rule (ONCE_MAP_C eq_sym_conv) z_‚Ñù_times_assoc_thm);
=TEX
=SML
val ‚¶èz_‚Ñù_times_plus_distrib_thm‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y, z: ‚Ñù‚¶Å
	x *‚ãéR (y +‚ãéR z) = x *‚ãéR y +‚ãéR x *‚ãéR z ‚àß (x +‚ãéR y) *‚ãéR z = x *‚ãéR z +‚ãéR y *‚ãéR z‚åù);
a(rewrite_tac[main_defs, ‚Ñù_times_plus_distrib_thm]);
save_pop_thm"z_‚Ñù_times_plus_distrib_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_times_order_thm‚¶é = (
set_goal([], ‚ì© ‚àÄ x, y, z: ‚Ñù‚¶Å y *‚ãéR x = x *‚ãéR y
		      ‚àß (x *‚ãéR y) *‚ãéR z = x *‚ãéR (y *‚ãéR z)
		      ‚àß y *‚ãéR (x *‚ãéR z) = x *‚ãéR (y *‚ãéR z)‚åù);
a(z_‚àÄ_tac THEN strip_tac THEN rewrite_tac[main_defs]);
a(rewrite_tac[‚àÄ_elim‚åúy‚åù‚Ñù_times_order_thm]);
save_pop_thm"z_‚Ñù_times_order_thm"
);
=TEX
=SML
val ‚¶èz_‚Ñù_times_clauses‚¶é = (
set_goal([], ‚ì© ‚àÄ x :‚Ñù ‚¶Å
	real 0 *‚ãéR x = real 0
‚àß	x *‚ãéR real 0 = real 0
‚àß	x *‚ãéR real 1 = x
‚àß	real 1 *‚ãéR x = x‚åù);
a(z_‚àÄ_tac THEN strip_tac THEN rewrite_tac[main_defs]);
a(rewrite_tac[‚Ñù_times_clauses, z_‚Ñù_real_0_thm]);
save_pop_thm"z_‚Ñù_times_clauses"
);
=TEX
=SML
val ‚¶èz_‚Ñù_over_clauses‚¶é = (
set_goal([], ‚ì©
	(‚àÄ y, z : ‚Ñù‚¶Å ¬¨ z = real 0 ‚áí (y *‚ãéR z) /‚ãéR z = y)
‚àß	(‚àÄ x, y, z:‚Ñù‚¶Å ¬¨ z = real 0 ‚áí (x *‚ãéR y) /‚ãéR z = x *‚ãéR (y /‚ãéR z))‚åù);
a(rewrite_tac[main_defs, z_‚Ñù_real_0_thm, get_spec‚åú$/‚ãéR‚åù]);
save_pop_thm "z_‚Ñù_over_clauses"
);
=TEX
\subsection{Floating Point Literals}
=SML
val ‚¶èz_float_thm‚¶é = (
set_goal([], ‚ì© ‚àÄ m, p, e : ‚Ñ§‚¶Å ‚åúZ'Float m p e‚åù = real m *‚ãéR (real 10 ^‚ãéZ (e + ~p))‚åù);
a(rewrite_tac[get_spec‚åúZ'Float‚åù]);
save_pop_thm "z_float_thm"
);
=TEX
\section{SYNTAX FUNCTIONS}
=SML
val ‚¶è‚Ñù‚¶é = ‚ì£‚Ñù‚åù;
val ‚¶è‚Ñ§‚¶é = ‚ì£‚Ñ§‚åù;
val ‚¶èminus‚¶é = (fst o dest_z_app) ‚ì©~‚ãéR x‚åù;
val ‚¶èminusn‚¶é = (fst o dest_const) minus;
val ‚¶èzabs‚¶é = (fst o dest_z_app) ‚ì©abs‚ãéR x‚åù;
val ‚¶èzabsn‚¶é = (fst o dest_const) zabs;
val ‚¶èzreal‚¶é = (fst o dest_z_app) ‚ì©real x‚åù;
val ‚¶èzrealn‚¶é = (fst o dest_const) zreal;
=TEX
=SML
fun ‚¶èdest_z_‚Ñù_minus‚¶é (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_z_app tm;
		val (s, _) = dest_const sgn;
	in	if s = minusn
		then a
		else term_fail "dest_z_‚Ñù_minus" 117107 [tm]
	end	handle Fail _ => term_fail "dest_z_‚Ñù_minus" 117107 [tm]
);
=TEX
=SML
fun ‚¶èis_z_‚Ñù_minus‚¶é (tm : TERM) : bool = (
	(dest_z_‚Ñù_minus tm; true) handle Fail _ => false
);
=TEX
=SML
fun ‚¶èmk_z_‚Ñù_minus‚¶é (tm : TERM) : TERM = (
	if	type_of tm =: ‚Ñù
	then	mk_z_app (minus, tm)
	else	term_fail "mk_z_‚Ñù_minus"  117201 [tm]
);
=TEX
=SML
fun ‚¶èdest_z_‚Ñù_abs‚¶é (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_z_app tm;
		val (s, _) = dest_const sgn;
	in	if s = zabsn
		then a
		else term_fail "dest_z_‚Ñù_abs" 117103 [tm]
	end	handle Fail _ => term_fail "dest_z_‚Ñù_abs" 117103 [tm]
);
=TEX
=SML
fun ‚¶èis_z_‚Ñù_abs‚¶é (tm : TERM) : bool = (
	(dest_z_‚Ñù_abs tm; true) handle Fail _ => false
);
=TEX
=SML
fun ‚¶èmk_z_‚Ñù_abs‚¶é (tm : TERM) : TERM = (
	if	type_of tm =: ‚Ñù
	then	mk_z_app (zabs, tm)
	else	term_fail "mk_z_‚Ñù_abs"  117201 [tm]
);
=TEX
=SML
fun ‚¶èdest_z_real‚¶é (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_z_app tm;
		val (s, _) = dest_const sgn;
	in	if s = zrealn
		then a
		else term_fail "dest_z_real" 117113 [tm]
	end	handle Fail _ => term_fail "dest_z_real" 117113 [tm]
);
=TEX
=SML
fun ‚¶èis_z_real‚¶é (tm : TERM) : bool = (
	(dest_z_real tm; true) handle Fail _ => false
);
=TEX
=SML
fun ‚¶èmk_z_real‚¶é (tm : TERM) : TERM = (
	if	type_of tm =: ‚Ñ§
	then	mk_z_app (zreal, tm)
	else	term_fail "mk_z_real"  86201 [tm]
);
=TEX
=SML
fun ‚¶èdest_z_bin_op‚¶é (area : string) (msg : int)
	(n : string) : TERM -> TERM * TERM = (fn tm =>
	let	val (f, args) = (dest_z_app tm);
		val (cn, _) = dest_const f;
		val ops = dest_z_tuple args;
	in	if n = cn
		then (hd ops, hd(tl ops))
		else term_fail area msg [tm]
	end	handle Fail _ => term_fail area msg [tm]
);
=TEX
=SML
fun is_z_bin_op (n : string) : TERM -> bool = (
	let	val dest = dest_z_bin_op "is_z_bin_op" 0 n
	in	(fn tm =>
			(dest tm; true) handle Fail _ => false
		)
	end
);
=TEX
=SML
fun mk_z_simple_bin_op (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_z_app(tm, mk_z_tuple [a1, a2])
);
=TEX
=SML
fun ‚¶èdest_z_bin_rel‚¶é (area : string) (msg : int)
	(n : string) : TERM -> TERM * TERM = (fn tm =>
	let	val (args, r) = (dest_z_‚àà tm);
		val (cn, _) = dest_const r;
		val ops = dest_z_tuple args;
	in	if n = cn
		then (hd ops, hd(tl ops))
		else term_fail area msg [tm]
	end	handle Fail _ => term_fail area msg [tm]
);
=TEX
=SML
fun is_z_bin_rel (n : string) : TERM -> bool = (
	let	val dest = dest_z_bin_rel "is_z_bin_rel" 0 n
	in	(fn tm =>
			(dest tm; true) handle Fail _ => false
		)
	end
);
=TEX
=SML
fun mk_z_simple_bin_rel (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_z_‚àà(mk_z_tuple [a1, a2], tm)
);
=TEX
=SML
val ‚¶èdest_z_‚Ñù_plus‚¶é = dest_z_bin_op "dest_‚Ñù_plus" 117109 (fst(dest_const‚ì©(_ +‚ãéR _)‚åù));
val ‚¶èdest_z_‚Ñù_subtract‚¶é = dest_z_bin_op "dest_‚Ñù_subtract" 117111 (fst(dest_const‚ì©(_ -‚ãéR _)‚åù));
val ‚¶èdest_z_‚Ñù_times‚¶é = dest_z_bin_op "dest_z_‚Ñù_times" 117112 (fst(dest_const‚ì©(_ *‚ãéR _)‚åù));
val ‚¶èdest_z_‚Ñù_over‚¶é = dest_z_bin_op "dest_z_‚Ñù_over" 117108 (fst(dest_const‚ì©(_ /‚ãéR _)‚åù));
val ‚¶èdest_z_‚Ñù_frac‚¶é = dest_z_bin_op "dest_z_‚Ñù_frac" 117104 (fst(dest_const‚ì©(_ /‚ãéZ _)‚åù));
val ‚¶èdest_z_‚Ñù_‚Ñ§_exp‚¶é = dest_z_bin_op "dest_z_‚Ñù_‚Ñ§_exp" 117104 (fst(dest_const‚ì©(_ ^‚ãéZ _)‚åù));

val ‚¶èdest_z_‚Ñù_less‚¶é = dest_z_bin_rel "dest_z_‚Ñù_less" 117106 (fst(dest_const‚ì©(_ <‚ãéR _)‚åù));
val ‚¶èdest_z_‚Ñù_‚â§‚¶é = dest_z_bin_rel "dest_z_‚Ñù_‚â§" 117101 (fst(dest_const‚ì©(_ ‚â§‚ãéR _)‚åù));
val ‚¶èdest_z_‚Ñù_greater‚¶é = dest_z_bin_rel "dest_z_‚Ñù_greater" 117105
	(fst(dest_const‚ì©(_ >‚ãéR _)‚åù));
val ‚¶èdest_z_‚Ñù_‚â•‚¶é = dest_z_bin_rel "dest_z_‚Ñù_‚â•" 117102 (fst(dest_const‚ì©(_ ‚â•‚ãéR _)‚åù));

val ‚¶èis_z_‚Ñù_plus‚¶é = is_z_bin_op (fst(dest_const‚ì©(_ +‚ãéR _)‚åù));
val ‚¶èis_z_‚Ñù_subtract‚¶é = is_z_bin_op (fst(dest_const‚ì©(_ -‚ãéR _)‚åù));
val ‚¶èis_z_‚Ñù_times‚¶é = is_z_bin_op (fst(dest_const‚ì©(_ *‚ãéR _)‚åù));
val ‚¶èis_z_‚Ñù_frac‚¶é = is_z_bin_op (fst(dest_const‚ì©(_ /‚ãéZ _)‚åù));
val ‚¶èis_z_‚Ñù_over‚¶é = is_z_bin_op (fst(dest_const‚ì©(_ /‚ãéR _)‚åù));
val ‚¶èis_z_‚Ñù_‚Ñ§_exp‚¶é = is_z_bin_op (fst(dest_const‚ì©(_ ^‚ãéZ _)‚åù));

val ‚¶èis_z_‚Ñù_less‚¶é = is_z_bin_rel (fst(dest_const‚ì©(_ <‚ãéR _)‚åù));
val ‚¶èis_z_‚Ñù_‚â§‚¶é = is_z_bin_rel (fst(dest_const‚ì©(_ ‚â§‚ãéR _)‚åù));
val ‚¶èis_z_‚Ñù_greater‚¶é = is_z_bin_rel (fst(dest_const‚ì©(_ >‚ãéR _)‚åù));
val ‚¶èis_z_‚Ñù_‚â•‚¶é = is_z_bin_rel (fst(dest_const‚ì©(_ ‚â•‚ãéR _)‚åù));
=TEX
=SML
fun ‚¶èmk_‚Ñù_bin_op‚¶é (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let	val f = mk_z_simple_bin_op tm;
	in	(fn tt as (t1, t2) => (
			if	type_of t1 =: ‚Ñù
			then	if	type_of t2 =: ‚Ñù
				then	f tt
				else	term_fail area 117201 [t2]
			else	term_fail area 117201 [t1]
		))
	end
);
=TEX
=SML
val ‚¶èmk_z_‚Ñù_plus‚¶é = mk_‚Ñù_bin_op "mk_z_‚Ñù_plus" ‚ì©(_ +‚ãéR _)‚åù;
val ‚¶èmk_z_‚Ñù_subtract‚¶é = mk_‚Ñù_bin_op "mk_z_‚Ñù_subtract" ‚ì©(_ -‚ãéR _)‚åù;
val ‚¶èmk_z_‚Ñù_times‚¶é = mk_‚Ñù_bin_op	"mk_z_‚Ñù_times" ‚ì©(_ *‚ãéR _)‚åù;
val ‚¶èmk_z_‚Ñù_frac‚¶é = (fn tt as (t1, t2) =>
	if	type_of t1 =: ‚Ñ§
	then	if	type_of t2 =: ‚Ñ§
		then	mk_z_simple_bin_op ‚ì©(_ /‚ãéZ _)‚åù tt
		else	term_fail "mk_z_‚Ñù_frac"  86201 [t2]
	else	term_fail "mk_z_‚Ñù_frac" 86201 [t1]
);
val ‚¶èmk_z_‚Ñù_over‚¶é = mk_‚Ñù_bin_op "mk_z_‚Ñù_over" ‚ì©(_ /‚ãéR _)‚åù;
val ‚¶èmk_z_‚Ñù_‚Ñ§_exp‚¶é = (fn tt as (t1, t2) =>
	if	type_of t1 =: ‚Ñù
	then	if	type_of t2 =: ‚Ñ§
		then	mk_z_simple_bin_op ‚ì©(_ ^‚ãéZ _)‚åù tt
		else	term_fail "mk_z_‚Ñù_‚Ñ§_exp"  86201 [t2]
	else	term_fail "mk_z_‚Ñù_‚Ñ§_exp" 117201 [t1]
);
=TEX
=SML
fun ‚¶èmk_‚Ñ§_bin_rel‚¶é (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let	val f = mk_z_simple_bin_rel tm;
	in	(fn tt as (t1, t2) => (
			if	type_of t1 =: ‚Ñù
			then	if	type_of t2 =: ‚Ñù
				then	f tt
				else	term_fail area 117201 [t2]
			else	term_fail area 117201 [t1]
		))
	end
);
=TEX
=SML
val ‚¶èmk_z_‚Ñù_less‚¶é = mk_‚Ñ§_bin_rel "mk_z_‚Ñù_less" ‚ì©(_ <‚ãéR _)‚åù;
val ‚¶èmk_z_‚Ñù_‚â§‚¶é = mk_‚Ñ§_bin_rel "mk_z_‚Ñù_‚â§" ‚ì©(_ ‚â§‚ãéR _)‚åù;
val ‚¶èmk_z_‚Ñù_greater‚¶é = mk_‚Ñ§_bin_rel "mk_z_‚Ñù_greater" ‚ì©(_ >‚ãéR _)‚åù;
val ‚¶èmk_z_‚Ñù_‚â•‚¶é = mk_‚Ñ§_bin_rel "mk_z_‚Ñù_‚â•" ‚ì©(_ ‚â•‚ãéR _)‚åù;
=TEX

\section{COMPUTATIONAL CONVERSIONS}
=TEX
=SML
val ‚¶èz_‚Ñù_lit_lemma1‚¶é = (
set_goal([], ‚åú‚àÄm n‚¶Å ‚ì©‚åúZ'Int m‚åù /‚ãéZ ‚åúZ'Int n‚åù‚åù = m/n‚åù);
a(rewrite_tac[get_spec‚ì©(_ /‚ãéZ _)‚åù, z_‚Ñù_real_‚Ñï‚Ñù_thm, get_spec‚åú$/‚ãéN‚åù]);
a(rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_lit_lemma2‚¶é = (
set_goal([], ‚åú‚àÄm n‚¶Å ‚ì©‚åúZ'Int m‚åù /‚ãéZ ~ ‚åúZ'Int (n + 1)‚åù‚åù = ~‚ãéR(m/(n+1))‚åù);
a(rewrite_tac[get_spec‚ì©(_ /‚ãéZ _)‚åù, z_‚Ñù_real_‚Ñï‚Ñù_thm, get_spec‚åú$/‚ãéN‚åù]);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm] THEN REPEAT strip_tac);
a(lemma_tac‚åú¬¨ ‚Ñï‚Ñù (n + 1) = ‚Ñï‚Ñù 0‚åù THEN1
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]);
a(lemma_tac‚åú¬¨ (~‚ãéR(‚Ñï‚Ñù (n + 1)) = ‚Ñï‚Ñù 0)‚åù THEN1
	(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[‚Ñù_eq_thm]
	THEN rewrite_tac[‚Ñù_minus_clauses] THEN
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]));
a(LEMMA_T ‚åú~‚ãéR(‚Ñï‚Ñù m / ‚Ñï‚Ñù (n + 1)) = ~‚ãéR(‚Ñï‚Ñù m) / ‚Ñï‚Ñù (n+1)‚åù rewrite_thm_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[‚Ñù_over_times_recip_thm]);
a(rewrite_tac[‚Ñù_times_minus_thm]);
(* *** Goal "2" *** *)
a(ante_tac (list_‚àÄ_elim[ ‚åú~‚ãéR(‚Ñï‚Ñù (n + 1))‚åù, ‚åú‚Ñï‚Ñù (n + 1)‚åù]‚Ñù_cross_mult_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(rewrite_tac[‚Ñù_times_minus_thm, ‚àÄ_elim‚åú‚Ñï‚Ñù m‚åù‚Ñù_times_order_thm]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_lit_lemma3‚¶é = (
set_goal([], ‚åú‚àÄm n‚¶Å ‚ì©(~ ‚åúZ'Int m‚åù) /‚ãéZ ‚åúZ'Int (n + 1)‚åù‚åù = ~‚ãéR(m/(n+1))‚åù);
a(rewrite_tac[get_spec‚ì©(_ /‚ãéZ _)‚åù, z_‚Ñù_real_‚Ñï‚Ñù_thm, get_spec‚åú$/‚ãéN‚åù]);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm] THEN REPEAT strip_tac);
a(lemma_tac‚åú¬¨ ‚Ñï‚Ñù (n + 1) = ‚Ñï‚Ñù 0‚åù THEN1
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]);
a(ALL_FC_T rewrite_tac[‚Ñù_over_times_recip_thm]);
a(rewrite_tac[‚Ñù_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_lit_lemma4‚¶é = (
set_goal([], ‚åú‚àÄm n‚¶Å ‚ì©(~‚åúZ'Int m‚åù) /‚ãéZ ~ ‚åúZ'Int (n + 1)‚åù‚åù = m/(n+1)‚åù);
a(rewrite_tac[get_spec‚ì©(_ /‚ãéZ _)‚åù, z_‚Ñù_real_‚Ñï‚Ñù_thm, get_spec‚åú$/‚ãéN‚åù]);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm] THEN REPEAT strip_tac);
a(lemma_tac‚åú¬¨ ‚Ñï‚Ñù (n + 1) = ‚Ñï‚Ñù 0‚åù THEN1
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]);
a(lemma_tac‚åú¬¨ (~‚ãéR(‚Ñï‚Ñù (n + 1)) = ‚Ñï‚Ñù 0)‚åù THEN1
	(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[‚Ñù_eq_thm]
	THEN rewrite_tac[‚Ñù_minus_clauses] THEN
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]));
a(ante_tac (list_‚àÄ_elim[ ‚åú~‚ãéR(‚Ñï‚Ñù (n + 1))‚åù, ‚åú‚Ñï‚Ñù (n + 1)‚åù]‚Ñù_cross_mult_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(rewrite_tac[‚Ñù_times_minus_thm, ‚àÄ_elim‚åú‚Ñï‚Ñù m‚åù‚Ñù_times_order_thm]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_lit_lemma5‚¶é = z_‚Ñù_real_‚Ñï‚Ñù_thm;
val ‚¶èz_‚Ñù_minus_thm‚¶é = tac_proof(
	([], ‚åú‚àÄx‚¶Å‚ì©~‚ãéR x‚åù = ~‚ãéR x‚åù),
	rewrite_tac[main_defs]);
val ‚¶è‚Ñù_minus_minus_thm‚¶é = tac_proof(
	([], ‚åú‚àÄx‚¶Å‚åú~‚ãéR (~‚ãéR x)‚åù = x‚åù),
	rewrite_tac[‚Ñù_minus_clauses]);
=TEX
=SML
val ‚¶èz_real_minus_thm‚¶é = tac_proof(
	([], ‚åú‚àÄi‚¶Å‚ì©real (~i) = ~‚ãéR (real i)‚åù‚åù),
	rewrite_tac[main_defs]);
=SML
fun ‚¶èZ_LEFT_C‚¶é (c : CONV) : CONV = RAND_C (LEFT_C c);
fun ‚¶èZ_RIGHT_C‚¶é (c : CONV) : CONV = RAND_C (RIGHT_C c);
fun ‚¶èZ_RANDS_C‚¶é (c : CONV) : CONV = RAND_C (RANDS_C c);
val ‚¶èZ_RAND_C‚¶é : CONV -> CONV = RAND_C;
=IGN
Z_RIGHT_C z_plus_conv ‚ì©1 /‚ãéZ (1+2)‚åù;
Z_LEFT_C z_plus_conv ‚ì© (2+3) /‚ãéZ (1+2)‚åù;
Z_RANDS_C z_plus_conv ‚ì© (2+3) /‚ãéZ (1+2)‚åù;
Z_RAND_C z_plus_conv ‚ì© f x (1+2)‚åù;
=TEX
=SML
val ‚¶è‚Ñï_one‚¶é = ‚åú1‚åù;
val ‚¶èpos_conv‚¶é : CONV = (fn tm =>
	let	val n = dest_‚Ñï tm;
	in	eq_sym_rule (plus_conv(mk_plus(mk_‚Ñï(n @- one), ‚Ñï_one)))
	end
);
=TEX
=SML
val rec  ‚¶èz_‚Ñù_lit_conv‚¶é : CONV = (fn tm =>
	(FIRST_C [
		simple_eq_match_conv z_‚Ñù_lit_lemma1,
		Z_RIGHT_C (Z_RAND_C(RAND_C pos_conv)) THEN_C
			simple_eq_match_conv z_‚Ñù_lit_lemma2 THEN_C
			RAND_C (RIGHT_C plus_conv),
		Z_RIGHT_C (RAND_C pos_conv) THEN_C
			simple_eq_match_conv z_‚Ñù_lit_lemma3 THEN_C
			RAND_C (RIGHT_C plus_conv),
		Z_RIGHT_C (Z_RAND_C(RAND_C pos_conv)) THEN_C
			simple_eq_match_conv z_‚Ñù_lit_lemma4 THEN_C
			RIGHT_C plus_conv,
		simple_eq_match_conv z_‚Ñù_lit_lemma5,
		simple_eq_match_conv z_‚Ñù_minus_thm THEN_TRY_C
			RAND_C z_‚Ñù_lit_conv THEN_TRY_C
			simple_eq_match_conv ‚Ñù_minus_minus_thm,
		simple_eq_match_conv z_real_minus_thm THEN_TRY_C z_‚Ñù_lit_conv
	] THEN_TRY_C ‚Ñù_eval_conv) tm
	handle Fail _ => term_fail "z_‚Ñù_lit_conv" 117001 [tm]
);
=IGN
z_‚Ñù_lit_conv‚ì© 1/‚ãéZ 2‚åù;
z_‚Ñù_lit_conv‚ì© 1/‚ãéZ ~2‚åù;
z_‚Ñù_lit_conv‚ì© ~ 1/‚ãéZ 2‚åù;
z_‚Ñù_lit_conv‚ì© ~ 1/‚ãéZ ~2‚åù;
z_‚Ñù_lit_conv‚ì© real 42‚åù;
z_‚Ñù_lit_conv‚ì© ~‚ãéR real 42‚åù;
z_‚Ñù_lit_conv‚ì© 0 /‚ãéZ 42‚åù;
z_‚Ñù_lit_conv‚ì©~‚ãéR (1 /‚ãéZ 6)‚åù;
=TEX
=SML
val ‚¶èz_‚Ñù_lit_lemma6‚¶é = conv_rule (ONCE_MAP_C eq_sym_conv) z_‚Ñù_lit_lemma1;
val ‚¶èz_‚Ñù_lit_lemma7‚¶é = conv_rule (ONCE_MAP_C eq_sym_conv) z_‚Ñù_lit_lemma5;
val ‚¶èz_‚Ñù_lit_lemma8‚¶é = conv_rule (ONCE_MAP_C eq_sym_conv) z_‚Ñù_minus_thm;
val ‚¶èz_‚Ñù_lit_lemma9‚¶é = tac_proof(([], ‚ì©~‚ãéR (real 0) = real 0‚åù),
	rewrite_tac[rewrite_rule[z_get_spec‚ì©‚Ñù‚åù] z_‚Ñù_minus_clauses]);

val ‚¶èz_‚Ñù_lit_conv1‚¶é : CONV = (fn tm =>
	(TRY_C ‚Ñù_eval_conv
	THEN_C FIRST_C [
		simple_eq_match_conv z_‚Ñù_lit_lemma6,
		simple_eq_match_conv z_‚Ñù_lit_lemma7,
		RAND_C (simple_eq_match_conv z_‚Ñù_lit_lemma6) THEN_C
			simple_eq_match_conv z_‚Ñù_lit_lemma8,
		RAND_C (simple_eq_match_conv z_‚Ñù_lit_lemma7) THEN_C
			simple_eq_match_conv z_‚Ñù_lit_lemma8
	] THEN_TRY_C simple_eq_match_conv z_‚Ñù_lit_lemma9) tm
	handle Fail _ => term_fail "z_‚Ñù_lit_conv1" 117002 [tm]
);
=SML
val ‚¶èz_‚Ñù_lit_norm_conv‚¶é = (fn tm =>
	(CHANGED_C (z_‚Ñù_lit_conv THEN_TRY_C
	(‚Ñù_frac_norm_conv ORELSE_C RAND_C ‚Ñù_frac_norm_conv)	THEN_C
	z_‚Ñù_lit_conv1)) tm
	handle Fail _ => term_fail "z_‚Ñù_lit_norm_conv" 117001 [tm]
);
=IGN
z_‚Ñù_lit_norm_conv‚ì©1 /‚ãéZ 9‚åù;
=IGN
z_‚Ñù_lit_conv1 ‚åú1/2‚åù;
z_‚Ñù_lit_conv1 ‚åú~‚ãéR(1/2)‚åù;
z_‚Ñù_lit_conv1 ‚åú‚Ñï‚Ñù 87‚åù;
z_‚Ñù_lit_conv1 ‚åú~‚ãéR(‚Ñï‚Ñù 87)‚åù;
z_‚Ñù_lit_norm_conv ‚ì©~87 /‚ãéZ 3‚åù;
z_‚Ñù_lit_norm_conv ‚ì©~88 /‚ãéZ 3‚åù;
z_‚Ñù_lit_norm_conv ‚ì©88 /‚ãéZ ~4‚åù;
z_‚Ñù_lit_norm_conv ‚ì©88 /‚ãéZ 4‚åù;
z_‚Ñù_lit_norm_conv ‚ì©0 /‚ãéZ 4‚åù;
z_‚Ñù_lit_norm_conv ‚ì©~0 /‚ãéZ 4‚åù;
z_‚Ñù_lit_norm_conv ‚ì©0 /‚ãéZ ~4‚åù;
z_‚Ñù_lit_norm_conv ‚ì©~0 /‚ãéZ 4‚åù;
z_‚Ñù_lit_norm_conv ‚ì©~‚ãéR(~0 /‚ãéZ ~2)‚åù;
=TEX

=SML
val z_‚Ñù_plus_thm = tac_proof(
	([], ‚åú‚àÄx y‚¶Å‚ì©x +‚ãéR y‚åù = x +‚ãéR y‚åù),
	rewrite_tac[main_defs]);
val z_‚Ñù_times_thm = tac_proof(
	([], ‚åú‚àÄx y‚¶Å‚ì©x *‚ãéR y‚åù = x *‚ãéR y‚åù),
	rewrite_tac[main_defs]);
val z_‚Ñù_less_thm = tac_proof(
	([], ‚åú‚àÄx y‚¶Å‚ì©x <‚ãéR y‚åù ‚áî x <‚ãéR y‚åù),
	rewrite_tac[main_defs]);
val z_‚Ñù_‚â§_thm = tac_proof(
	([], ‚åú‚àÄx y:‚Ñù‚¶Å‚ì©x ‚â§‚ãéR y‚åù ‚áî x ‚â§‚ãéR y‚åù),
	rewrite_tac[main_defs]);
val z_‚Ñù_over_thm = tac_proof(
	([], ‚åú‚àÄx y‚¶Å‚ì©x /‚ãéR y‚åù = x /‚ãéR y‚åù),
	rewrite_tac[main_defs]);
val z_‚Ñù_abs_thm = tac_proof(
	([], ‚åú‚àÄx‚¶Å‚ì©abs‚ãéR x‚åù = Abs‚ãéR x‚åù),
	rewrite_tac[main_defs]);
=TEX
=SML
fun ‚¶èmk_bin_rel_conv‚¶é (nm : string) (pat : TERM) (th : THM) (c : CONV) : CONV = (fn tm =>
	(LEFT_C (RANDS_C z_‚Ñù_lit_conv) THEN_C simple_eq_match_conv th THEN_C c) tm
	handle Fail _ => term_fail nm 117003 [tm, pat]
);
=TEX
=SML
fun ‚¶èmk_bin_comp_conv‚¶é (nm : string) (pat : TERM) (th : THM) (c : CONV) : CONV = (fn tm =>
	(Z_RANDS_C z_‚Ñù_lit_conv THEN_C simple_eq_match_conv th THEN_C c THEN_C z_‚Ñù_lit_conv1) tm
	handle Fail _ => term_fail nm 117003 [tm, pat]
);
=TEX
=SML
val ‚¶èz_‚Ñù_plus_conv‚¶é : CONV = mk_bin_comp_conv "z_‚Ñù_plus_conv" ‚ì©x +‚ãéR y‚åù z_‚Ñù_plus_thm ‚Ñù_plus_conv;
val ‚¶èz_‚Ñù_times_conv‚¶é : CONV = mk_bin_comp_conv "z_‚Ñù_times_conv"‚ì©x *‚ãéR y‚åù  z_‚Ñù_times_thm ‚Ñù_times_conv;

val ‚¶èz_‚Ñù_over_conv‚¶é : CONV = mk_bin_comp_conv "z_‚Ñù_over_conv" ‚ì©x /‚ãéR y‚åù  z_‚Ñù_over_thm ‚Ñù_over_conv;
val ‚¶èz_‚Ñù_less_conv‚¶é : CONV = mk_bin_rel_conv "z_‚Ñù_less_conv" ‚ì©x <‚ãéR y‚åù  z_‚Ñù_less_thm ‚Ñù_less_conv;
val ‚¶èz_‚Ñù_‚â§_conv‚¶é : CONV = mk_bin_rel_conv "z_‚Ñù_‚â§_conv" ‚ì©x ‚â§‚ãéR y‚åù z_‚Ñù_‚â§_thm ‚Ñù_‚â§_conv;
val ‚¶èz_‚Ñù_eq_conv‚¶é : CONV = (fn tm =>
	(RANDS_C z_‚Ñù_lit_conv THEN_C ‚Ñù_eq_conv) tm
	handle Fail _ => term_fail "z_‚Ñù_eq_conv" 117003 [tm, ‚ì©x = y‚åù]
);
=IGN
z_‚Ñù_plus_conv‚ì©1 /‚ãéZ 2 +‚ãéR 1 /‚ãéZ 2‚åù;
z_‚Ñù_times_conv‚ì©(1 /‚ãéZ 2) *‚ãéR (1 /‚ãéZ 2)‚åù;
z_‚Ñù_over_conv‚ì©(1 /‚ãéZ 2) /‚ãéR (1 /‚ãéZ 2)‚åù;
=TEX
=SML
val ‚¶èz_‚Ñù_abs_conv‚¶é : CONV = (fn tm =>
	(Z_RAND_C z_‚Ñù_lit_conv THEN_C simple_eq_match_conv z_‚Ñù_abs_thm
	THEN_C ‚Ñù_abs_conv THEN_C z_‚Ñù_lit_conv1) tm
	handle Fail _ => term_fail "z_‚Ñù_abs_conv" 117004 [tm, ‚ì©abs‚ãéR x‚åù]
);
=IGN
z_‚Ñù_abs_conv‚ì©abs‚ãéR (real 42)‚åù;
z_‚Ñù_abs_conv‚ì©abs‚ãéR ~‚ãéR (real 42)‚åù;
=TEX
=SML
val ‚¶èz_‚Ñù_minus_conv_thm1‚¶é = (
set_goal([], ‚åú‚àÄm n‚¶Å ‚ì© ~ x /‚ãéZ  ‚åúZ'Int (n + 1)‚åù = ~‚ãéR ( x /‚ãéZ ‚åúZ'Int (n + 1)‚åù ) ‚åù ‚åù);
a(rewrite_tac[get_spec‚ì©(_ /‚ãéZ _)‚åù, get_spec‚åú$/‚ãéN‚åù]);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(rewrite_tac[z_‚Ñù_real_‚Ñï‚Ñù_thm]);
a(lemma_tac‚åú¬¨ ‚Ñï‚Ñù (n + 1) = ‚Ñï‚Ñù 0‚åù THEN1
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]);
a(ALL_FC_T rewrite_tac[‚Ñù_over_times_recip_thm]);
a(rewrite_tac[‚Ñù_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_minus_conv_thm2‚¶é = (
set_goal([], ‚åú‚àÄx n‚¶Å ‚ì© x /‚ãéZ  ~ ‚åúZ'Int (n + 1)‚åù = ~‚ãéR ( x /‚ãéZ ‚åúZ'Int (n + 1)‚åù ) ‚åù‚åù);
a(rewrite_tac[get_spec‚ì©(_ /‚ãéZ _)‚åù, get_spec‚åú$/‚ãéN‚åù]);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm] THEN REPEAT strip_tac);
a(lemma_tac‚åú¬¨ ‚Ñï‚Ñù (n + 1) = ‚Ñï‚Ñù 0‚åù THEN1
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]);
a(lemma_tac‚åú¬¨ ~‚ãéR(‚Ñï‚Ñù (n + 1)) = ‚Ñï‚Ñù 0‚åù THEN1
	(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[‚Ñù_eq_thm]
	THEN rewrite_tac[‚Ñù_minus_clauses] THEN
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]));
a(ALL_FC_T rewrite_tac[‚Ñù_over_times_recip_thm, ‚Ñù_minus_recip_thm]);
a(rewrite_tac[‚Ñù_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_minus_conv_thm3‚¶é = (
set_goal([], ‚åú‚àÄx n‚¶Å ‚ì©~x /‚ãéZ ~ ‚åúZ'Int (n + 1)‚åù = x /‚ãéZ ‚åúZ'Int (n + 1)‚åù‚åù‚åù);
a(rewrite_tac[get_spec‚ì©(_ /‚ãéZ _)‚åù, z_‚Ñù_real_‚Ñï‚Ñù_thm, get_spec‚åú$/‚ãéN‚åù]);
a(rewrite_tac[main_defs, z_‚Ñù_real_‚Ñï‚Ñù_thm] THEN REPEAT strip_tac);
a(lemma_tac‚åú¬¨ ‚Ñï‚Ñù (n + 1) = ‚Ñï‚Ñù 0‚åù THEN1
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]);
a(lemma_tac‚åú¬¨ (~‚ãéR(‚Ñï‚Ñù (n + 1)) = ‚Ñï‚Ñù 0)‚åù THEN1
	(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[‚Ñù_eq_thm]
	THEN rewrite_tac[‚Ñù_minus_clauses] THEN
	PC_T1 "basic_hol" rewrite_tac[‚Ñï‚Ñù_one_one_thm]));
a(ALL_FC_T rewrite_tac[‚Ñù_over_times_recip_thm, ‚Ñù_minus_recip_thm]);
a(rewrite_tac[‚Ñù_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_minus_conv_thm3‚¶é = tac_proof(
	([], ‚åú‚àÄx‚¶Å‚ì©~‚ãéR (~‚ãéR x) = x‚åù‚åù),
	rewrite_tac[main_defs, ‚Ñù_minus_clauses]);
=TEX
=SML
val ‚¶èz_‚Ñù_minus_conv‚¶é : CONV = (fn tm =>
	REPEAT_C1 (FIRST_C [
		simple_eq_match_conv z_real_minus_thm,
		Z_RIGHT_C(RAND_C pos_conv) THEN_C
			simple_eq_match_conv z_‚Ñù_minus_conv_thm1 THEN_C
			RAND_C(Z_RIGHT_C (RAND_C plus_conv)),
		Z_RIGHT_C (RAND_C (RAND_C pos_conv)) THEN_C
			(
			(simple_eq_match_conv z_‚Ñù_minus_conv_thm3 THEN_C
				Z_RIGHT_C (RAND_C plus_conv))  ORELSE_C
			(simple_eq_match_conv z_‚Ñù_minus_conv_thm2 THEN_C
				RAND_C(Z_RIGHT_C (RAND_C plus_conv)))),
		simple_eq_match_conv z_‚Ñù_minus_conv_thm3
	] THEN_TRY_C z_‚Ñù_lit_norm_conv) tm
	handle Fail _ => term_fail "z_‚Ñù_minus_conv" 117107 [tm]
);
=IGN
z_‚Ñù_minus_conv‚ì©real (~(42))‚åù;
z_‚Ñù_minus_conv‚ì©(~3 /‚ãéZ 7)‚åù;
z_‚Ñù_minus_conv‚ì©(3 /‚ãéZ ~7)‚åù;
z_‚Ñù_minus_conv‚ì©(~3 /‚ãéZ ~7)‚åù;
=TEX
=SML
val ‚¶èz_‚Ñ§_exp_lemma1‚¶é = (
set_goal([], ‚åú‚àÄx m‚¶Å‚ì©x ^‚ãéZ ‚åú(Z'Int m)‚åù‚åù = x ^‚ãéN m‚åù);
a(rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñ§_exp_lemma2‚¶é = (
set_goal([], ‚åú‚àÄx m‚¶Å‚ì©x ^‚ãéZ ~‚åú(Z'Int (m+1))‚åù‚åù = ‚Ñï‚Ñù 1 /‚ãéR (x ^‚ãéN (m+1))‚åù);
a(REPEAT strip_tac THEN rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñ§_exp_lemma3‚¶é = (
set_goal([], ‚åú‚àÄx m‚¶Å‚ì©x ^‚ãéZ ‚åú(Z'Int 0)‚åù‚åù = ‚ì©real 1‚åù‚åù);
a(REPEAT strip_tac THEN rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñ§_exp_lemma4‚¶é = (
set_goal([], ‚åú‚àÄx m‚¶Å‚ì©x ^‚ãéZ ~‚åú(Z'Int 0)‚åù‚åù = ‚ì©real 1‚åù‚åù);
a(REPEAT strip_tac THEN rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val ‚¶èz_‚Ñù_‚Ñ§_exp_conv‚¶é : CONV = (fn tm =>
	(FIRST_C [
	(simple_eq_match_conv z_‚Ñ§_exp_lemma3),
	(simple_eq_match_conv z_‚Ñ§_exp_lemma4),
	(simple_eq_match_conv z_‚Ñ§_exp_lemma1 THEN_C
		LEFT_C z_‚Ñù_lit_conv THEN_C ‚Ñù_‚Ñï_exp_conv THEN_C z_‚Ñù_lit_conv1),
	(RIGHT_C(RIGHT_C(RIGHT_C(RAND_C(pos_conv)))) THEN_C
	simple_eq_match_conv z_‚Ñ§_exp_lemma2 THEN_C
		RIGHT_C (RIGHT_C plus_conv THEN_C LEFT_C z_‚Ñù_lit_conv THEN_C ‚Ñù_‚Ñï_exp_conv) THEN_C
		‚Ñù_over_conv THEN_TRY_C
		RIGHT_C (TRY_C(‚Ñù_recip_conv THEN_C ‚Ñù_times_conv)) THEN_C z_‚Ñù_lit_conv1)
]	THEN_TRY_C z_‚Ñù_lit_norm_conv) tm
	handle Fail _ => term_fail "z_‚Ñù_‚Ñ§_exp_conv" 117005 [tm]
);
=IGN
z_‚Ñù_‚Ñ§_exp_conv‚ì©real 5 ^‚ãéZ 2‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(3/‚ãéZ 7) ^‚ãéZ 2‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©real 10 ^‚ãéZ 3‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©real 10 ^‚ãéZ ~3‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(real 7) ^‚ãéZ ~2‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(3/‚ãéZ 7) ^‚ãéZ ~2‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(3/‚ãéZ 7) ^‚ãéZ ~1‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(3/‚ãéZ 7) ^‚ãéZ ~0‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(3/‚ãéZ 7) ^‚ãéZ 0‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(3/‚ãéZ 7) ^‚ãéZ 1‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(3/‚ãéZ 7) ^‚ãéZ 2‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(1/‚ãéZ 7) ^‚ãéZ ~2‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(1/‚ãéZ 7) ^‚ãéZ ~1‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(1/‚ãéZ 7) ^‚ãéZ ~0‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(1/‚ãéZ 7) ^‚ãéZ 0‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(1/‚ãéZ 7) ^‚ãéZ 1‚åù;
z_‚Ñù_‚Ñ§_exp_conv‚ì©(1/‚ãéZ 7) ^‚ãéZ 2‚åù;
=TEX
=SML
val z_‚Ñù_‚â•_thm = tac_proof(
	([], ‚åú‚àÄx y:‚Ñù‚¶Å‚ì©x ‚â•‚ãéR y ‚áî y ‚â§‚ãéR x‚åù‚åù),
	rewrite_tac[rewrite_rule[main_defs]z_‚Ñù_‚â•_def, main_defs]);
val z_‚Ñù_greater_thm = tac_proof(
	([], ‚åú‚àÄx y:‚Ñù‚¶Å‚ì©x >‚ãéR y ‚áî y <‚ãéR x‚åù‚åù),
	rewrite_tac[rewrite_rule[main_defs]z_‚Ñù_greater_def, main_defs]);
val z_‚Ñù_subtract_thm = tac_proof(
	([], ‚åú‚àÄx y:‚Ñù‚¶Å‚ì©x -‚ãéR y  = x +‚ãéR ~‚ãéR y‚åù‚åù),
	rewrite_tac[rewrite_rule[main_defs]z_‚Ñù_subtract_def, main_defs]);
=TEX
=SML
val ‚¶èz_‚Ñù_‚â•_conv‚¶é = (fn tm =>
	simple_eq_match_conv z_‚Ñù_‚â•_thm tm
	handle Fail _ => term_fail "z_‚Ñù_‚â•_conv" 117102 [tm]
);
val ‚¶èz_‚Ñù_greater_conv‚¶é = (fn tm =>
	simple_eq_match_conv z_‚Ñù_greater_thm tm
	handle Fail _ => term_fail "z_‚Ñù_greater_conv" 117105 [tm]
);
val ‚¶èz_‚Ñù_subtract_conv‚¶é = (fn tm =>
	simple_eq_match_conv z_‚Ñù_subtract_thm tm
	handle Fail _ => term_fail "z_‚Ñù_subtract_conv" 117111 [tm]
);
=IGN
z_‚Ñù_‚â•_conv‚ì©x ‚â•‚ãéR y‚åù;
z_‚Ñù_greater_conv‚ì©x >‚ãéR y‚åù;
z_‚Ñù_subtract_conv‚ì©x -‚ãéR y‚åù;
=TEX
\subsection{General Evaluation Conversion}
The following are also used in the linear arithmetic proof context.
=SML
val ‚¶èto_hol_plus_conv‚¶é = simple_eq_match_conv z_‚Ñù_plus_thm;
val ‚¶èto_hol_minus_conv‚¶é = simple_eq_match_conv z_‚Ñù_minus_thm;
val ‚¶èto_hol_times_conv‚¶é = simple_eq_match_conv z_‚Ñù_times_thm;
val ‚¶èto_hol_over_conv‚¶é = simple_eq_match_conv z_‚Ñù_over_thm;
val ‚¶èto_hol_less_conv‚¶é = simple_eq_match_conv z_‚Ñù_less_thm;
val ‚¶èto_hol_‚â§_conv‚¶é = simple_eq_match_conv z_‚Ñù_‚â§_thm;
val ‚¶èto_hol_abs_conv‚¶é = simple_eq_match_conv z_‚Ñù_abs_thm;
val ‚¶èto_hol_lit_conv‚¶é = z_‚Ñù_lit_conv;
val ‚¶èto_hol_‚Ñ§_exp_conv‚¶é =
	simple_eq_match_conv z_‚Ñ§_exp_lemma1 ORELSE_C simple_eq_match_conv z_‚Ñ§_exp_lemma2;
=IGN
to_hol_plus_conv‚ì©x +‚ãéR y‚åù;
to_hol_minus_conv‚ì©~‚ãéR y‚åù;
to_hol_times_conv‚ì©x *‚ãéR y‚åù;
to_hol_over_conv‚ì©x /‚ãéR y‚åù;
to_hol_less_conv‚ì©x <‚ãéR y‚åù;
to_hol_‚â§_conv‚ì©real 9 ‚â§‚ãéR y‚åù;
to_hol_lit_conv‚ì©real 99‚åù;
to_hol_lit_conv‚ì©~ 4/‚ãéZ 5‚åù;
to_hol_‚Ñ§_exp_conv‚ì©real 1 ^‚ãéZ 9‚åù;
to_hol_‚Ñ§_exp_conv‚ì©real 1 ^‚ãéZ ~9‚åù;
=TEX
=SML
val ‚¶èz_eval_net‚¶é = switch list_net_enter empty_net
[
	(‚ì©x +‚ãéR y‚åù, (Z_RANDS_C, z_‚Ñù_plus_conv)),
	(‚ì©x -‚ãéR y‚åù, (Z_RANDS_C, z_‚Ñù_subtract_conv THEN_C z_‚Ñù_plus_conv)),
	(‚ì©x *‚ãéR y‚åù, (Z_RANDS_C, z_‚Ñù_times_conv)),
	(‚ì©x /‚ãéR y‚åù, (Z_RANDS_C, z_‚Ñù_over_conv)),
	(‚ì©abs‚ãéR x‚åù, (Z_RANDS_C, z_‚Ñù_abs_conv)),
	(‚ì©~‚ãéR x‚åù, (Z_RAND_C, z_‚Ñù_minus_conv))
];
=TEX
=SML
val rec ‚¶èZ_‚Ñù_EVAL_C‚¶é : CONV -> CONV = (fn user_conv => fn tm =>
	let	fun chk tm = (
			let	val tm2 = dest_‚Ñù_minus tm	handle Fail _=> tm;
			in	let	val (a, b) = dest_z_‚Ñù_frac tm2;
					val (_, bi) = (dest_z_signed_int a, dest_z_signed_int b);
				in	bi <> zero
				end	handle Fail _ =>
				let	val m = dest_z_real tm2;
				in	is_z_signed_int m
				end	handle Fail _ => false
			end
		);
	in	case net_lookup z_eval_net tm of
			[(C, conv)] => C (TRY_C(Z_‚Ñù_EVAL_C user_conv)) THEN_C conv
		|	_ => TRY_C (user_conv ORELSE_C z_‚Ñù_minus_conv)
				THEN_C COND_C chk id_conv fail_conv
	end	tm
	handle	Fail _ => term_fail "Z_‚Ñù_EVAL_C" 117020 [tm]
);
val ‚¶èz_‚Ñù_eval_conv‚¶é : CONV = Z_‚Ñù_EVAL_C fail_conv;
=TEX
=SML
val ‚¶èz_minus_minus_conv‚¶é = simple_eq_match_conv
	(prove_rule[]‚åú‚àÄx : ‚Ñ§ ‚¶Å‚ì©~(~x) = x‚åù‚åù);
=TEX
=SML
val ‚¶èz'float_def‚¶é = get_spec ‚åúZ'Float‚åù;
val ‚¶èz_float_conv‚¶é : CONV = (fn tm =>
	(simple_eq_match_conv z'float_def THEN_C
	Z_RIGHT_C(Z_RIGHT_C(
		Z_RIGHT_C (TRY_C z_minus_minus_conv)
			THEN_C z_plus_conv)) THEN_C
	Z_RIGHT_C z_‚Ñù_‚Ñ§_exp_conv THEN_C
	z_‚Ñù_times_conv) tm
	handle Fail _ => term_fail "z_float_conv" 117006 [tm]
);
=TEX
\section{PROOF CONTEXTS}
=SML
fun ‚¶èthms_to_eqn_cxt‚¶é (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	
=SML
val _ = delete_pc "'z_reals" handle Fail _ => ();
val _ = new_pc "'z_reals";
val _ = set_rw_eqn_cxt	
		[	(‚ì©i +‚ãéR j‚åù, z_‚Ñù_plus_conv),
			(‚ì©i *‚ãéR j‚åù, z_‚Ñù_times_conv),
			(‚ì©i /‚ãéR j‚åù, z_‚Ñù_over_conv),
			(‚ì©i *‚ãéR j‚åù, z_‚Ñù_times_conv),
			(‚ì©i ^‚ãéZ j‚åù, z_‚Ñù_‚Ñ§_exp_conv),
			(‚ì©i -‚ãéR j‚åù, z_‚Ñù_subtract_conv),
			(‚ì©(i‚¶ÇR) = j‚åù, z_‚Ñù_eq_conv),
			(‚ì©~‚ãéR i‚åù, z_‚Ñù_minus_conv),
			(‚ì©real(~ i)‚åù, z_‚Ñù_minus_conv),
			(‚ì©abs‚ãéR i‚åù, z_‚Ñù_abs_conv),
			(‚ì©i ‚â§‚ãéR j‚åù, z_‚Ñù_‚â§_conv),
			(‚ì©i <‚ãéR j‚åù, z_‚Ñù_less_conv),
			(‚ì©i ‚â•‚ãéR j‚åù, z_‚Ñù_‚â•_conv),
			(‚ì©i >‚ãéR j‚åù, z_‚Ñù_greater_conv),
			(‚ì©‚åúZ'Int m‚åù /‚ãéZ ‚åúZ'Int n‚åù‚åù, z_‚Ñù_lit_norm_conv)
		] "'z_reals";
fun ‚¶èu_simp‚¶é (thm : THM) : THM = rewrite_rule[z_‚Ñù_def] thm;

val _ = add_rw_thms (map u_simp[z_‚Ñù_plus_clauses, z_‚Ñù_minus_clauses, z_‚Ñù_‚â§_clauses,
	 z_‚Ñù_less_clauses, z_‚Ñù_times_clauses])
	"'z_reals";
val pos = (thms_to_eqn_cxt(map u_simp[z_‚Ñù_minus_clauses,
		z_‚Ñù_‚â§_clauses,
		z_‚Ñù_less_clauses])) @
	[(‚ì©(i‚¶Ç‚Ñù) = j‚åù, z_‚Ñù_eq_conv),
	(‚ì©i ‚â•‚ãéR j‚åù, z_‚Ñù_‚â•_conv),
	(‚ì©i >‚ãéR j‚åù, z_‚Ñù_greater_conv)];
val neg = mapfilter (mk_¬¨ ** RAND_C) pos;
val neutral = [(‚ì©i ‚â§‚ãéR j‚åù, z_‚â§_conv),
	(‚ì©i <‚ãéR j‚åù, z_less_conv)];

val ‚¶èstrip_eqn_cxt‚¶é = neutral @ pos @ neg;

val _ = set_st_eqn_cxt strip_eqn_cxt "'z_reals";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'z_reals";
val _ = set_u_simp_eqn_cxt (theory_u_simp_eqn_cxt"z_reals") "'z_reals";
val _ = set_pr_tac z_basic_prove_tac "'z_reals";
val _ = set_pr_conv z_basic_prove_conv "'z_reals";
val _ = commit_pc "'z_reals";
=TEX
=IGN
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©x ‚àà ‚Ñù‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) +‚ãéR (1 /‚ãéZ 2)‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) <‚ãéR (1 /‚ãéZ 2)‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) *‚ãéR (1 /‚ãéZ 2)‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) /‚ãéR (1 /‚ãéZ 2)‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) ^‚ãéZ 3‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) -‚ãéZ real 3‚åù;

MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) >‚ãéR (1 /‚ãéZ 2)‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) <‚ãéR (1 /‚ãéZ 2)‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) ‚â§‚ãéR (1 /‚ãéZ 2)‚åù;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]‚ì©(1 /‚ãéZ 2) ‚â•‚ãéR (1 /‚ãéZ 2)‚åù;
=TEX
=TEX	
=SML
val _ = delete_pc "z_‚Ñù_lin_arith" handle Fail _ => ();
val _ = new_pc "z_‚Ñù_lin_arith";
val _ = set_rw_eqn_cxt	
		[	(‚ì©i +‚ãéR j‚åù, to_hol_plus_conv),
			(‚ì©i *‚ãéR j‚åù, to_hol_times_conv),
			(‚ì©i /‚ãéR j‚åù, to_hol_over_conv),
			(‚ì©i *‚ãéR j‚åù, to_hol_times_conv),
			(‚ì©i ^‚ãéZ j‚åù, to_hol_‚Ñ§_exp_conv),
			(‚ì©i *‚ãéR j‚åù, to_hol_times_conv),
			(‚ì©i -‚ãéR j‚åù, z_‚Ñù_subtract_conv),
			(‚ì©~‚ãéR i‚åù, to_hol_minus_conv),
			(‚ì©i ‚â§‚ãéR j‚åù, to_hol_‚â§_conv),
			(‚ì©i <‚ãéR j‚åù, to_hol_less_conv),
			(‚ì©i ‚â•‚ãéR j‚åù, z_‚Ñù_‚â•_conv),
			(‚ì©i >‚ãéR j‚åù, z_‚Ñù_greater_conv),
			(‚ì©real m‚åù, to_hol_lit_conv),
			(‚ì©abs‚ãéR m‚åù, to_hol_abs_conv),
			(‚ì©‚åúZ'Int m‚åù /‚ãéZ ‚åúZ'Int n‚åù‚åù, to_hol_lit_conv),
			(‚åúZ'Float x p e‚åù, z_float_conv)
		] "z_‚Ñù_lin_arith";
=TEX
Now the tactic which is the automatic proof tactic.
=SML
val ‚¶èz_‚Ñù_lin_arith_prove_tac‚¶é : THM list -> TACTIC = (fn thl => fn gl =>
	((	DROP_ASMS_T (MAP_EVERY ante_tac)
	THEN_TRY	rewrite_tac thl
	THEN	PC_T1 "‚Ñù_lin_arith" prove_tac[]) gl)
	handle ex => reraise ex "z_‚Ñù_lin_arith_prove_conv"
);
=TEX
and the associated conversion:
=SML
val ‚¶èz_‚Ñù_lin_arith_prove_conv‚¶é : THM list -> CONV = (fn thl => fn tm =>
	let	val th = tac_proof(([], tm), z_‚Ñù_lin_arith_prove_tac thl);
	in	‚áî_t_intro  th
	end	handle ex => reraise ex "z_‚Ñù_lin_arith_prove_conv"
);
=TEX
=SML
val _ = set_u_simp_eqn_cxt (theory_u_simp_eqn_cxt"z_reals") "z_‚Ñù_lin_arith";
val _ = set_pr_tac z_‚Ñù_lin_arith_prove_tac "z_‚Ñù_lin_arith";
val _ = set_pr_conv z_‚Ñù_lin_arith_prove_conv "z_‚Ñù_lin_arith";
val _ = commit_pc "z_‚Ñù_lin_arith";
=IGN
PC_C1 "z_‚Ñù_lin_arith" rewrite_conv[]‚ì©x +‚ãéR y *‚ãéR real 42 +‚ãéR 9 /‚ãéZ 10‚åù;
PC_C1 "z_‚Ñù_lin_arith" prove_conv[]	‚ì©x <‚ãéR y <‚ãéR z ‚áí x <‚ãéR z‚åù;
PC_C1 "z_‚Ñù_lin_arith" rewrite_conv[]	‚ì©
	(real 2 ^‚ãéZ 5) *‚ãéR x <‚ãéR y <‚ãéR z ‚áí x <‚ãéR z /‚ãéR real 31‚åù;

val gl : GOAL = ([], ‚ì©x <‚ãéR y <‚ãéR z ‚áí x <‚ãéR z‚åù);
tac_proof(gl, PC_T1 "z_‚Ñù_lin_arith" prove_tac[]);

=TEX
\section{EPILOGUE}
=SML
end (* of structure ZReals *);
open ZReals;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







