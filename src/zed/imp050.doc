=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Implementation of Z Constant Generation}
\TPPref{DS/FMU/IED/IMP050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
%\TPPauthors{G.T.Scullard&WIN01\\G.M.Prout&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the implementation of the dynamic generation of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] (\TPPdate{\FormatDate{$Date$
}})
First draft version.

\item [Issue 1.2] (\TPPdate{\FormatDate{$Date$
}})
Changed to new fonts.

\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The detailed design may be found in
\cite{DS/FMU/IED/DTD050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{STRUCTURE}
=SML
structure €ZGeneratedConstants› = struct
=TEX
\section{AUXILIARY FUNCTIONS}

=SML
fun (€int_to_tyvl› : int -> TYPE list) 1 = [mk_ZvarT (string_of_int 1)]
| int_to_tyvl n = (int_to_tyvl(n - 1)) @ [mk_ZvarT (string_of_int n)];
=TEX
=SML
fun (€int_to_sl› : int -> string list) 1 = [string_of_int 1]
| int_to_sl n = (int_to_sl(n - 1)) @ [string_of_int n];
=TEX
function to make an ``itym'' from a list of strings:
=SML
fun	€stringl_to_itym› (sl : string list):(string * TYPE)list =
	combine sl (map mk_ZvarT sl);
=TEX
function to make an ``itym'' from an integer
=SML
fun (€int_to_itym› : int -> (string * TYPE) list) 1 = 
	[("1", mk_ZvarT "1")]
|	int_to_itym n = (
		let 	val s = string_of_int n 
		in	int_to_itym (n - 1) @ [(s,mk_ZvarT s)]
		end); 
=TEX
function to make an ``itym'' from a string 
=SML
fun (€string_to_itym› : string -> (string * TYPE) list) s = 
	int_to_itym(nat_of_string s);
=TEX
function to make a type list from a string 
=SML
fun (€string_to_styl› : string -> TYPE list) s = 
	int_to_tyvl(nat_of_string s);
=TEX
=SML
fun	€list_mk_≠_type1› ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_≠_type tyl ty;
=TEX
And its inverse:
=SML
fun €strip_≠_type1› (ty : TYPE): TYPE list * TYPE = (
	let fun aux typ l= (
		if is_≠_type typ
		then 	let 	val (ty1,ty2) = dest_≠_type typ
			in aux  ty2 (l @ [ty1]) 
			end
		else (l,typ)
		);
	in	aux ty [] 
	end
);
=TEX

=TEX
=SML
fun €last› (l : 'a list)  = (hd (rev l));
fun €front› (l : 'a list)  = rev(tl (rev l));
=TEX
The function $match\_mk\_app$ below should perhaps
be elsewhere.
Given terms $f:\tau≠\sigma$
and $a:\tau_0$ $match\_mk\_app$ checks whether $\tau_0$
is an instance of $\tau$ and, if so, it returns
$(f:\tau_0≠\sigma_0)(a:\tau_0)$, where $\sigma_0$  is the
corresponding instance of $\sigma$.
=SML

fun €match_mk_app› (f : TERM, a : TERM) : TERM = (
let  val ty = type_of f
in
	if is_≠_type ty
	then	
		let 	val(ty1,_) = dest_≠_type ty;
			val tym = type_match (type_of a) ty1;
		in
			mk_app(
		inst [] tym f,
		a)
		end
	else fail "match_mk_app" 0 []
end);

=TEX
A function which takes a binding type and returns a pair consisting
of the name of the binding type constructor and a list of names of the projections.
=SML
fun €bind_con_proj›(ty:TYPE) =
let	val (sl,tyl) = split(dest_ZschemaT ty)
		handle complaint => 
		divert complaint "dest_ZschemaT" "bind_con_proj" 47050 
			[fn () => string_of_type ty];
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val pnaml = map (curry (op ^) nam)  sl;
in
	(cnam,pnaml)
end;
=TEX
A function which takes a tuple type and returns  a pair consisting
of the name of the tuple type constructor and a list of names of the projections.

=SML
fun €tuple_con_proj›(ty:TYPE) =
let	val tyl = dest_ZtupleT ty
		handle complaint => 
		divert complaint "dest_ZtupleT" "tuple_con_proj" 47040 
			[fn () => string_of_type ty];
	val n = length tyl;
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val isl = int_to_sl n;
	val pnaml = map (curry (op ^) nam)  isl;
in	
	(cnam,pnaml)
end;
=TEX
\section{STORING Z CONSTANTS}
=SML
fun €local_const_spec› ((nam, var, defn) : string * TERM * TERM) : THM = (
let	val curr_theory = get_current_theory_name();
	val side = open_theory (current_cache_theory());
	val thm = get_defn  "-" nam
		handle  Fail _ =>
		const_spec ([nam], [var], defn)
			handle ex => (open_theory curr_theory;
				reraise ex "local_const_spec");
	val side = open_theory curr_theory;
in
	thm
end);
=TEX
The signature for the next function is the same as that for $labelled\_product\_spec$.
=SML
fun €local_labelled_product_spec› {tykey: string, labels: (string * TYPE) list, tyname: string,
  tyvars: TYPE list OPT, conname: string, constkeys: string list} : THM = (
let	val curr_theory = get_current_theory_name();
	val side = open_theory (current_cache_theory());
	val thm = get_defn  "-" tyname
		handle  Fail _ =>
			(labelled_product_spec{
					tykey = tykey,
					labels = labels,
					tyname= tyname,
					tyvars = tyvars,
					conname = conname,
					constkeys = constkeys}
				handle ex => (open_theory curr_theory;
					reraise ex "local_labelled_product_spec"));
	val side = open_theory curr_theory;
in
	thm
end);
=TEX

=TEX
\section{BINDING TYPES}
Everything stored in current theory for now.
=SML
fun €binding_type_spec› (ty : TYPE) : unit =
let 	
	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "binding_type_spec" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_ZschemaT ty);
	val (nam,tyl) = dest_ctype ty;
	val tyvl = map mk_ZvarT sl;
	val thm = local_labelled_product_spec{
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml};
in
	()
end;
=TEX
=SML
fun €get_binding_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "get_binding_info" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_ZschemaT ty);
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = map mk_ZvarT sl;	
		val	(_,bty) = strip_≠_type1 pty;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end	
	| _ => fail "get_binding_info" 50001 [fn () => cnam]
end;
=TEX
\section{TUPLE TYPES}
=SML
fun €tuple_type_spec›(ty : TYPE) : unit =
let 	
	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "tuple_type_spec" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
	val nam = fst(dest_ctype ty);
	val tyvl = int_to_tyvl n;
	val thm = local_labelled_product_spec{
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml};
in
	()
end;
=TEX
=SML
fun €get_tuple_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "get_tuple_info" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = int_to_tyvl n;	
		val 	bty = mk_ZtupleT tyvl;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end		| _ => fail "get_tuple_info" 50002 [fn () => cnam]
end;
=TEX
\section{RETRIEVING TYPE INFORMATION}
These don't work - $µ\_±\_conv$ requires theory $combin$ as parent.
=SML
fun €get_constructor_defn› (ty : TYPE) : THM =
let 	val (cnam,_) = 
			if is_ZschemaT ty
				then (binding_type_spec ty;bind_con_proj ty)
			else 	if is_ZtupleT ty
					then (tuple_type_spec ty;tuple_con_proj ty)
				else fail  "get_constructor_defn" 5003 
				[fn () => string_of_type ty];
	val thm = get_defn (current_cache_theory()) cnam
		handle complaint => 
		divert complaint "get_defn""get_constructor_defn" 50004[fn () => cnam]
in
	hd(strip_±_rule((conv_rule µ_±_conv)thm))
end;
=TEX
=SML
fun €get_projections_defn›(ty : TYPE) : THM list =
let 	val (cnam,_) = 
			if is_ZschemaT ty
				then (binding_type_spec ty;bind_con_proj ty)
			else 	if is_ZtupleT ty
					then (tuple_type_spec ty;tuple_con_proj ty)
				else fail  "get_projections_defn" 5003 
				[fn () => string_of_type ty];
	val thm = get_defn (current_cache_theory()) cnam
		handle complaint => 
		divert complaint "get_defn""get_projections_defn" 50005[fn () => cnam]
in
	strip_±_rule(hd(tl(strip_±_rule((conv_rule µ_±_conv)thm))))
end;
=TEX

\section{Z CONSTANT DEFINITION GENERATION}

=SML
fun €local_const_spec› ((nam, var, defn) : string * TERM * TERM) : THM = (
let	val curr_theory = get_current_theory_name();
	val side = open_theory (current_cache_theory());
	val thm = get_defn  "-" nam
		handle  Fail _ =>
		const_spec ([nam], [var], defn)
			handle ex => (open_theory curr_theory;
				reraise ex "local_const_spec");
	val side = open_theory curr_theory;
in
	thm
end);

=TEX
\subsection{Set Abstraction}

=SML
fun €seta_const_spec› (tm : TERM) : THM = (
let	val nam = fst (dest_const (fst (dest_app tm)));
in
	case dest_Z_name nam of
	("Z'seta", [[sn]]) => (get_defn (current_cache_theory()) (nam^"_def")
		handle Fail _ => (
		let	val tyvl = map (fn x => mk_vartype ("'"^string_of_int (next_name())))
				(interval 1 (nat_of_string sn));
			val tyv = mk_ZvarT "v";
			val dpvty = mk_ZschemaT [("d", BOOL),("p", BOOL),("v", tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon, dpvprojs) = get_binding_info dpvty;
			val resty = mk_ZpowerT tyv;
			val argty = list_mk_≠_type (tyvl@[dpvty]);
			val cvar = mk_var(nam, mk_≠_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type (tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec (nam, cvar, defn)
		end))
	| _ => error "seta_const_spec" 50100 []
end);
=TEX
\subsection{Ã Abstraction}

=SML
fun	€Ã_const_spec› (tm : TERM) : THM = (
let	val nam = fst(dest_const (fst (dest_app tm)));
in
	case dest_Z_name nam of
	("Z'Ã",[[sn]]) => (get_defn (current_cache_theory()) (nam ^ "_def")
		handle Fail _ => (
		let	val tyvl = map (fn x => mk_vartype ("'"^string_of_int (next_name())))
				(interval 1 (nat_of_string sn));
			val tyv = mk_ZvarT "v";
			val tyt = mk_ZvarT "t";
			val dptvty = mk_ZschemaT[("d",BOOL),("p",BOOL),("t",tyt),("v",tyv)];
			val side = binding_type_spec dptvty;
			val (dptvcon,dptvprojs) = get_binding_info dptvty;
			val resty = mk_ZpowerT(mk_ZtupleT[tyt,tyv]);
			val argty = list_mk_≠_type(tyvl@[dptvty]);
			val cvar = mk_var(nam,mk_≠_type(argty,resty));
			val x = mk_var("x",mk_ZtupleT[tyt,tyv]);
			val side = tuple_type_spec(type_of x);
			val (_,xprjs) = get_tuple_info(type_of x);
			val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type(tyvl@[dptvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dptvprojs;
			val pred = list_mk_± (
					[hd projs,hd(tl projs)] @
					(map 	mk_eq 
						(combine 	(projs from 2)
								(	(map 	(fn y => match_mk_app(y,x)) 
										xprjs)))));
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec (nam, cvar, defn)
		end))
	| _ => error "Ã_const_spec" 50100 []
end);

=IGN
fun	€types_in_zcon_spec› (ty : TYPE) : unit = 	
	if 	is_ZgivenT ty then ()
	else 	if	is_ZvarT ty then ()
	else 	if	is_ZpowerT ty then types_in_zcon_spec (dest_ZpowerT ty)
	else 	if	is_ZtupleT ty then 
			let	val(s,tyl) = dest_ctype ty
			in	map types_in_zcon_spec tyl;(tuple_type_spec ty;())
			end
	else 	if	is_ZschemaT ty then 
			let	val(s,tyl) = dest_ctype ty
			in	map types_in_zcon_spec tyl;(binding_type_spec ty;())
			end
	else 	if	is_≠_type ty then
			let	val (ty1,ty2) = dest_≠_type ty
			in  	types_in_zcon_spec ty1;types_in_zcon_spec ty2 
			end
	else 	fail "types_in_zcon_spec" 50006 [fn () => string_of_type ty];

=TEX
\subsection{Constants for Schema Calculus}

First, we will need the schema type $Z'S[d,p]$, type instantiated to $BOOL$, and the``d'' and ``p'' projections of the schema type $Z'S[d,p]$, type instantiated to $BOOL$:
=IGN
val get_dpty : TYPE =
let 	val ty = mk_ZschemaT(stringl_to_itym["d","p"]);
	val side_effect	= binding_type_spec  ty;
in
	inst_type[(¨:BOOLÆ,¨:'dÆ),(¨:BOOLÆ,¨:'pÆ)] ty
end;
=TEX
=IGN
val get_dpprojs : TERM list =
let 	val ty = mk_ZschemaT(stringl_to_itym["d","p"]);
	val side_effect	= binding_type_spec ty;
	val(_,projs) = get_binding_info ty;
in
	map (inst[][(¨:BOOLÆ,¨:'dÆ),(¨:BOOLÆ,¨:'pÆ)]) projs
end;
=TEX
Should I remove call to $binding\_type\_spec$ on the
grounds that types will always be put in place first?
=IGN
fun €z_schema_defn› (znam : string)(sl : string list):TERM * TERM =
let 	
	val  zty = bind_ctype (stringl_to_itym sl);
	val schtm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val p = mk_Zlvar("p",ty1,[]);
	val lhs = mk_app(schtm,p); 
	val schty = dest_ZpowerT ty2;	
	val x = mk_Zlvar("x",schty,[]);
	val side_effect = binding_type_spec schty;
	val(_,projsx) = get_binding_info schty;
	val substm = list_mk_app(p,map (fn pr => mk_app(pr,x))projsx);
	val t = mk_Zlvar("t",type_of substm,[]);
	val conj = list_mk_±(map (fn pr => mk_app(pr,t))get_dpprojs);
	val absttm = mk_Ã(t,conj);
	val absxtm = mk_Ã(x,mk_app(absttm,substm));
	val rhs = match_mk_app(¨$"Z'abs"Æ,absxtm);
in
	(schtm,mk_µ(p,mk_eq(lhs,rhs)))
end;
=TEX
First a function which makes the right sort of signature for the resultant schema.
Something wrong here - shouldn't I be using $U$?
=IGN
fun (mk_Zdecty (styl:(string * TYPE) list)):TERM = (
let 	val varl = map ((fn x => [x]) o mk_var) styl	
 	val tyl = map (fn x => mk_var("S" ^ (fst x),mk_ZpowerT(snd x))) styl;
in
mk_Zdecl(map mk_Zdec (combine varl tyl))
end);
=TEX
=IGN
fun €z_dysc_defn› (znam : string)(sl1 : string list)(sl2 : string list)(dyop : string):TERM * TERM =
let 	
	val  zty = bind_dysc_type (stringl_to_itym sl1)(stringl_to_itym sl2);
	val dysctm = mk_var(znam,zty);	
	val (ty1,ty) = dest_≠_type zty;
	val (ty2,ty3) = dest_≠_type ty;
	val schty = dest_ZpowerT ty3;
	val styl = dest_ZschemaT schty;
	val d = mk_Zdecty styl;
	val (sc1,sc2) = (mk_Zlvar("sc1",ty1,[]),mk_Zlvar("sc2",ty2,[]));
	val lhs = list_mk_app(dysctm,[sc1,sc2]);
	val p = case dyop of
		"±" => mk_Z±âs(sc1,sc2)
		| "≤" => mk_Z≤âs(sc1,sc2)
		| "¥" => mk_Z¥âs(sc1,sc2)
		| "§" => mk_Z§âs(sc1,sc2)
		| _ => fail "z_dysc_defn" 0 [] ;
	val rhs = mk_Zâs(d,mk_Zpredsexp(p,""));	
in
	(dysctm,list_mk_µ([sc1,sc2],mk_eq(lhs,rhs)))
end;
=TEX
=IGN
fun €z_pre_defn› (znam : string)(sl : string list):TERM * TERM =
let 	
	val  zty = bind_pre_type (stringl_to_itym sl);
	val pretm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val s = mk_Zlvar("s",ty1,[]);
	val lhs = mk_app(pretm,s); 
	val schty1 = dest_ZpowerT ty1;
	val schty2 = dest_ZpowerT ty2;
	val styl1 = dest_ZschemaT schty1;
	val styl2 = dest_ZschemaT schty2;
	val d1 = mk_Zdecty styl2;
	val d2 = mk_Zdecty (styl1 diff' styl2);
	val p = mk_Z∂(d2,mk_Ztrue,mk_Zpredsexp(s,""));
	val rhs = mk_Zâs(d1,p);
in
	(pretm,mk_µ(s,mk_eq(lhs,rhs)))
end;
=TEX

=IGN
fun €z_pro_defn› (znam : string)(sl1 : string list)(sl2 : string list):TERM * TERM =
let 	
	val  zty = bind_˘_type (stringl_to_itym sl1)(stringl_to_itym sl2);
	val protm = mk_var(znam,zty);	
	val (ty1,ty) = dest_≠_type zty;
	val (ty2,ty3) = dest_≠_type ty;
	val (sc1,sc2) = (mk_Zlvar("sc1",ty1,[]),mk_Zlvar("sc2",ty2,[]));
	val lhs = list_mk_app(protm,[sc1,sc2]);
	val schconj = mk_Z±âs(sc1,sc2)
	val schty1 = dest_ZpowerT ty1;
	val styl1 = dest_ZschemaT schty1;
	val schty2 = dest_ZpowerT ty2;
	val styl2 = dest_ZschemaT schty2;
	val sl = fst(split(styl1 diff' styl2));
	val rhs = (mk_Zhideâs (schconj,sl));
in
	(protm,list_mk_µ([sc1,sc2],mk_eq(lhs,rhs)))
end;
=TEX
=IGN
fun €z_hide_defn› (znam : string)(sl1 : string list)(sl2 : string list):TERM * TERM =
let 	
	val  zty = bind_hide_type (stringl_to_itym sl1) sl2;
	val hidtm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val sc = mk_Zlvar("sc",ty1,[]);
	val lhs = mk_app(hidtm,sc); 
	val schty1 = dest_ZpowerT ty1;
	val schty2 = dest_ZpowerT ty2;
	val styl1 = dest_ZschemaT schty1;
	val styl2 = dest_ZschemaT schty2;
	val styl = styl1 diff' styl2;
	val d1 = mk_Zdecty styl2;
	val d2 = mk_Zdecty styl;
	val p = mk_Z∂(d2,mk_Ztrue,mk_Zpredsexp(sc,""));
	val rhs = mk_Zâs(d1,p);
in
	(hidtm,mk_µ(sc,mk_eq(lhs,rhs)))
end;
=TEX
=IGN
fun €z_dec_defn› (znam : string) (sl : string list) (s : string):TERM * TERM =
let 	
	val  zty = bind_decor_type(stringl_to_itym sl) s;
	val dectm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val schty1 = dest_ZpowerT ty1;
	val styl1 = dest_ZschemaT schty1;
	val schtm1 = schema_bterm styl1; 
	val schty2 = dest_ZpowerT ty2;
	val styl2 = dest_ZschemaT schty2;
	val schtm2 = schema_bterm styl2; 
	val tyvl = snd(split styl1);
	val p = mk_Zlvar("p",list_mk_≠_type1(tyvl,get_dpty),[]);
	val lhs = mk_app(dectm,mk_app(schtm1,p)); 
	val rhs = mk_app(schtm2,p);
in
	(dectm,mk_µ(p,mk_eq(lhs,rhs)))
end;
=TEX
First a function which sorts a list of pairs according to  the first of each pair:
=IGN
fun €idsetseq_pairs› (x : (string * 'a) list) : (string * 'a) list =
	let 	val orderfn = fn (s1,a1) => (fn (s2,a2) => Sort.string_order s1 s2)
	in
		Sort.sort orderfn x
	end;
=TEX
=IGN
fun €z_schquant_defn› (znam : string)(sl1 : string list)(sl2 : string list)
	(quant:string):TERM * TERM =
let 	
	val sl = idsetseq(sl1 @ sl2);
	val (zty,mktm)= case quant of
		"∂" => (∂âs_btype (stringl_to_itym sl1)(stringl_to_itym sl),mk_∂)
		| "∂â1" =>(∂â1âs_btype 
		(stringl_to_itym sl1)(stringl_to_itym sl),mk_∂â1)
		| "µ" => (µâs_btype (stringl_to_itym sl1)(stringl_to_itym sl),mk_µ)
		| _ => fail "z_schquant_defn" 0 [] ;
	val schquantm = mk_var(znam,zty);	
	val (ty1,ty) = dest_≠_type zty;
	val (ty2,ty3) = dest_≠_type ty;
	val (p,q) = (mk_Zlvar("p",ty1,[]),mk_Zlvar("q",ty2,[]));
	val lhs = list_mk_app(schquantm,[p,q]); 
	val schty1 = dest_ZpowerT ty3;	
	val x = mk_Zlvar("x",schty1,[]);
	val side_effect = binding_type_spec schty1;
	val(_,projsx) = get_binding_info schty1;
	val xprojs = map (fn f => mk_app(f,x)) projsx;
	val schty2 = mk_ZschemaT(stringl_to_itym sl1);	
	val y = mk_Zlvar("y",schty2,[]);
	val side_effect = binding_type_spec schty2;
	val(_,projsy) = get_binding_info schty2;
	val yprojs = map (fn f => mk_app(f,y)) projsy
	val substm = list_mk_app(p,yprojs);
	val t = mk_Zlvar("t",type_of substm,[]);
	val dandp = list_mk_±(map (fn pr => mk_app(pr,t))get_dpprojs);
	val schty3 = dest_ZpowerT ty2;	
	val side_effect = binding_type_spec schty3;
	val(con,_) = get_binding_info schty3;
	val projs = xprojs @ yprojs;
	val sorted_projs = snd(split(idsetseq_pairs
		(combine (map (dest_ZvarT o type_of) projs) projs)));

	val projtm = list_mk_app(con,sorted_projs);
	val memtm = mk_Zç(projtm,q);
	val absttm = mk_Ã(t,mk_±(dandp,memtm));
	val qtm = mktm(y,mk_app(absttm,substm));
	val absxtm = mk_Ã(x,qtm);
	val rhs = match_mk_app(¨$"Z'abs"Æ,absxtm);
in
	(schquantm,list_mk_µ([p,q],mk_eq(lhs,rhs)))
end;
=TEX
\section{END OF STRUCTURE}
The structure is left open.
=SML
end (* end of ZGeneratedConstants structure *);
open ZGeneratedConstants;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


