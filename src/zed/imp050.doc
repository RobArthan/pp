% imp050.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Implementation of Z Constant Generation}
\TPPref{DS/FMU/IED/IMP050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
\TPPauthors{D.J.~King&WIN01\\G.M.~Prout&WIN01 }
\TPPauthorisation{R.D.~Arthan & Project Manager}
\TPPabstract{This document contains the implementation of the dynamic generation of constants generated by the
Z Term generator in the Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] (\TPPdate{\FormatDate{$Date$
}})
First draft version.

\item [Issue 1.2]Changed to new fonts.
\item [Issue 1.10 (17th July 1992)]
Gave ``caller'' parameter to $local\_labelled\_product\_spec$.
\item [Issue 1.11 (20th July 1992)]
Added schema renaming definition mechanism.
Used all in-scope caches for look-up, rather than just current one.
\item [Issue 1.12 (21st July 1992)]
Correction to schema renaming definition mechanism.
\item [Issue 1.14 (27th July 1992)]
Critical code is now protected by interrupt handling.
\item [Issue 1.20 (13th August 1992)]
Corrected error handling for interrupts.
\item [Issue 1.22 (21st August 1992)]
First implementation to pass all its module tests.
\item [Issue 1.23 (5th October 1992)]
Modifying $local\_...$ to write to current cache theory.
\item [Issue 1.24 (15th October 1992)]
Improved error message 50001.
\item [Issue 1.24 (20th November 1992)]
Changes in cache theory handling.
\item [Issue 1.25 (8th December 1992)]
Fixed consequence of change elsewhere.
\item[Issue 1.27 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.28 (18th December 1992)]
Changed generated constant for $ªâs$.
\item[Issue 1.29 (18th December 1992)]
Change to $get\_cache\_theories$.
\item[Issue 1.30 (8th January 1993)]
Fixed error handling bug in $hideâs\_gen\_semantic\_const$.
\item[Issue 1.31 (8th January 1993)]
Defended functions better against failure with inputs not given
by paragraph processor.
\item[Issue 1.32 (19th January 1993)]
Improved error handling of $renameâs\_gen\_semantic\_const$.
\item[Issue 1.33 (10th February 1993)]
Corrected incorrect mapping of $µâs$.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The detailed design may be found in
\cite{DS/FMU/IED/DTD050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD050}.
\subsubsection{Dependencies}
The semantic constant generation code depends
upon the structures $ZUserInterfaceSupport$ and $ZTypesAndTermsSupport$
described in \cite{DS/FMU/IED/DTD079} and \cite{DS/FMU/IED/DTD048}
respectively.
\subsubsection{Deficiencies}
None Known.

\section{GENERATED CONSTANTS SUPPORT}
=SML
structure €ZGeneratedConstants› : ZGeneratedConstants = struct
=SML
open ZUserInterfaceSupport ZTypesAndTermsSupport;
=TEX
\subsection{Auxiliary Functions}
=SML
fun (€int_to_tyvl› : int -> TYPE list) 1 = [mk_z_var_type (string_of_int 1)]
| int_to_tyvl n = (int_to_tyvl(n - 1)) @ [mk_z_var_type (string_of_int n)];
=TEX
=SML
fun (€int_to_sl› : int -> string list) 1 = [string_of_int 1]
| int_to_sl n = (int_to_sl(n - 1)) @ [string_of_int n];
=TEX
function to make an ``itym'' from a list of strings:
=SML
fun	€stringl_to_itym› (sl : string list):(string * TYPE)list =
	combine sl (map mk_z_var_type sl);
=TEX
function to make an ``itym'' from an integer
=SML
fun (€int_to_itym› : int -> (string * TYPE) list) 1 = 
	[("1", mk_z_var_type "1")]
|	int_to_itym n = (
		let 	val s = string_of_int n 
		in	int_to_itym (n - 1) @ [(s,mk_z_var_type s)]
		end); 
=TEX
function to make an ``itym'' from a string 
=SML
fun (€string_to_itym› : string -> (string * TYPE) list) s = 
	int_to_itym(nat_of_string s);
=TEX
function to make a type list from a string 
=SML
fun (€string_to_styl› : string -> TYPE list) s = 
	int_to_tyvl(nat_of_string s);
=TEX
=SML
fun €mk_ç› (tm1,tm2) = (
let	val ty = type_of tm1;
	val memconst = mk_const("ç",mk_≠_type(ty,
		mk_≠_type(mk_ctype("SET",[ty]),BOOL)));
in
	mk_app (mk_app (memconst, tm1), tm2)
end
	handle ex => reraise ex "mk_ç"
);
=TEX
=SML
fun €match_mk_app›(ftm:TERM, xtm:TERM) : TERM = (
let	val (fty1,_) = dest_≠_type (type_of ftm);
	val tyinsts = type_match (type_of xtm) fty1 ;
in
	mk_app(inst [] tyinsts ftm, xtm)
end
handle complaint =>
list_divert complaint "match_mk_app" 
	[("dest_≠_type",3006,[fn () => string_of_term ftm]),
	 ("type_match",3005,[fn () => string_of_term ftm,
		fn () => string_of_term xtm])]);
=IGN
match_mk_app(¨FstÆ,¨(T,F)Æ);
=TEX
=SML
fun €list_match_mk_app› (f : TERM, (a::rest) : TERM list) : TERM = (
	list_match_mk_app ((match_mk_app (f, a)), rest)
)  | list_match_mk_app (f, []) = f;

=TEX
=SML
fun €list_mk_pair› [a] = a
  | list_mk_pair [a,b] = mk_pair (a,b)
  | list_mk_pair (a::rest) =
	mk_pair (a,list_mk_pair rest)
  | list_mk_pair _ = fail "Z Term-Generator" 50002 [];
=IGN
This has been disabled since the abstract machine does
not support empty signatures.
val €empty_sig› = (
let	val thing1 = mk_const("Z'Mk_S[]",(mk_ctype("Z'S[]",[])));
	val thing2 = mk_enum_set [thing1];
in
	mk_z_schema_dec(thing2,"")
end);
=TEX
=SML
fun €mk_z_empty_decl› () = (
	fail "Z Term-Generator" 50002 []
(*
	mk_z_decl [empty_sig]
*)
);
=TEX
=SML
fun €mk_z_decl1› dl = (
	mk_z_decl dl handle Fail _ => mk_z_empty_decl()
);
=TEX
=SML
val €strip_type› = hd o rev o strip_≠_type;
=TEX
=SML
fun €mk_z_univ_decl› (s,ty) = ( 
let	val totty = mk_z_power_type ty;
	val tot = mk_const("Totality",totty)
	val U = mk_const("z'U",mk_≠_type(mk_z_tuple_type[totty],totty))
in
	mk_z_dec([mk_var(s,ty)],mk_app(U,mk_z_tuple[tot]))
end);

fun €mk_z_univ_decl1› tm = ( 
let	val ty = type_of tm;
	val totty = mk_z_power_type ty;
	val tot = mk_const("Totality",totty)
	val U = mk_const("z'U",mk_≠_type(mk_z_tuple_type[totty],totty))
in
	mk_z_dec([tm],mk_app(U,mk_z_tuple[tot]))
end);
=TEX
A function which takes a binding type and returns a pair consisting
of the name of the binding type constructor and a list of names of the projections.
=SML
fun €bind_con_proj›(ty:TYPE) =
let	val (sl,tyl) = split(dest_z_schema_type ty)
		handle complaint => 
		divert complaint "dest_z_schema_type" "bind_con_proj" 47050 
			[fn () => string_of_type ty];
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val pnaml = map (curry (op ^) nam)  sl;
in
	(cnam,pnaml)
end;
=TEX
A function which takes a tuple type and returns  a pair consisting
of the name of the tuple type constructor and a list of names of the projections.

=SML
fun €tuple_con_proj›(ty:TYPE) =
let	val tyl = dest_z_tuple_type ty
		handle complaint => 
		divert complaint "dest_z_tuple_type" "tuple_con_proj" 47040 
			[fn () => string_of_type ty];
	val n = length tyl;
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val isl = int_to_sl n;
	val pnaml = map (curry (op ^) nam)  isl;
in	
	(cnam,pnaml)
end;
=TEX
\subsection{Storing Z Constants}
\subsubsection{Retrieving from Some Cache theory}
=SML
fun €get_cached_defn› (nm:string):THM = (
let	val cs = get_valid_cache_theories();
	fun aux (a :: x) = (get_defn a nm
		handle (Fail _) => aux x)
	| aux [] = fail "get_cached_defn" 0 [];
in
	aux cs
end);
=TEX
\subsection{Local Constant Specification Wrappers}
=SML
fun €local_const_spec› (caller:string) ((nam, var, defn) : string * TERM * TERM) : THM = (
	get_cached_defn nam
		handle  Fail _ => (
	let	val cct = force_get_cache_theory();
	in
		do_in_theory cct
			(pc_rule "hol" const_spec)
			([nam], [var], defn)
		handle ex =>
			reraise ex caller
	end)
);
=TEX
$pc\_rule$ could be replaced by $pending\_push\_pc$ plus wrapping
for more safety.
=TEX
The signature for the next function is the same as that for $labelled\_product\_spec$.
=SML
fun €local_labelled_product_spec› (caller : string)
	{tykey: string, labels: (string * TYPE) list, tyname: string,
	tyvars: TYPE list OPT, conname: string, constkeys: string list} : THM = (
	get_cached_defn conname
		handle  Fail _ => (
	let	val cct = force_get_cache_theory() handle (Fail _) => "-";
	in
		(do_in_theory cct
			labelled_product_spec 
			{
				tykey = tykey,
				labels = labels,
				tyname= tyname,
				tyvars = tyvars,
				conname = conname,
				constkeys = constkeys}
		handle ex => reraise ex caller)
	end)
);

=TEX

=TEX
\subsection{Binding Types}
Everything stored in current theory for now.
=SML
fun €binding_type_spec› (ty : TYPE) : THM =
let 	
	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "binding_type_spec" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_type ty);
	val (nam,tyl) = dest_ctype ty;
	val tyvl = map mk_z_var_type sl;
in	local_labelled_product_spec "binding_type_spec" {
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml}

end;
=TEX
=SML
fun €get_binding_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "get_binding_info" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_type ty);
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = map mk_z_var_type sl;	
		val	bty = (hd o rev o strip_≠_type) pty;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end	
	| _ => fail "get_binding_info" 50003 [fn () => cnam]
end;
=TEX
\subsection{Tuple Types}
=SML
fun €tuple_type_spec› (ty : TYPE) : THM =
let 	
	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "tuple_type_spec" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
	val nam = fst(dest_ctype ty);
	val tyvl = int_to_tyvl n;
in	local_labelled_product_spec "tuple_type_spec" {
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml}
end;
=TEX
=SML
fun €get_tuple_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "get_tuple_info" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = int_to_tyvl n;	
		val 	bty = mk_z_tuple_type tyvl;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end		| _ => fail "get_tuple_info" 50003 [fn () => cnam]
end;
=TEX

\section{Z CONSTANT DEFINITION GENERATION}\label{ZCONST}

\subsection{Tuples}
=IGN
val tm = mk_z_tuple[Ò1Æ,Ò2Æ];
=SML
fun €tuple_gen_semantic_const› (tm : TERM) : THM = (
	tuple_type_spec ((hd o rev o strip_≠_type o
		snd o dest_const o fst o strip_app) tm)
	handle complaint =>
	divert complaint "tuple_type_spec" "tuple_gen_semantic_const" 50001 [fn () => string_of_term tm]
);
=TEX
\subsection{Set Abstraction}
=IGN
val tm = mk_z_seta (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Seta",[[sn]], Nil) = dest_z_name nam;
=SML
fun €seta_gen_semantic_const› (tm : TERM) : THM = (
let	val nam = fst (dest_const (fst (strip_app tm)));
in
	case dest_z_name nam of
	("Z'Seta", [[sn]], Nil) => (get_cached_defn (nam^"_def")
		handle Fail _ => (
		let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "seta_gen_semantic_const" 50001 [tm];
			val tyv = mk_z_var_type "v";
			val dpvty = mk_z_schema_type [("d", BOOL),("p", BOOL),("v", tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon, dpvprojs) = get_binding_info dpvty;
			val resty = mk_z_power_type tyv;
			val argty = list_mk_≠_type (tyvl@[dpvty]);
			val cvar = mk_var(nam, mk_≠_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s)))
				(map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type (tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "seta_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "seta_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Ã Abstraction}
=IGN
val tm = mk_z_Ã (mk_z_decl([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Ã",[[sn]], Nil) = dest_z_name nam;
=SML
fun	€Ã_gen_semantic_const› (tm : TERM) : THM = (
let	val nam = fst(dest_const (fst (strip_app tm)));
in
	case dest_z_name nam of
	("Z'Ã",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle Fail _ => (
		let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "Ã_gen_semantic_const" 50001 [tm];
			val tyv = mk_z_var_type "v";
			val tyt = mk_z_var_type "t";
			val dptvty = mk_z_schema_type[("d",BOOL),("p",BOOL),("t",tyt),("v",tyv)];
			val side = binding_type_spec dptvty;
			val (dptvcon,dptvprojs) = get_binding_info dptvty;
			val resty = mk_z_power_type(mk_z_tuple_type[tyt,tyv]);
			val argty = list_mk_≠_type(tyvl@[dptvty]);
			val cvar = mk_var(nam,mk_≠_type(argty,resty));
			val x = mk_var("x",mk_z_tuple_type[tyt,tyv]);
			val side = tuple_type_spec(type_of x);
			val (_,xprjs) = get_tuple_info(type_of x);
			val anaml = map (fn s => implode("a" :: tl(explode s)))
				(map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type(tyvl@[dptvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dptvprojs;
			val pred = list_mk_± ([hd projs,hd(tl projs)] @
				(map mk_eq (combine (projs from 2)
					((map (fn y => match_mk_app(y,x)) 
						xprjs)))));
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "Ã_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "Ã_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Definite Description}
=IGN
val tm = mk_z_Õ (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Õ",[[sn]], Nil) = dest_z_name nam;
=SML
fun €Õ_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)));
in
	case dest_z_name nam of
	("Z'Õ",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle (Fail _) => (
		let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "Õ_gen_semantic_const" 50001 [tm];
			val tyv = mk_z_var_type "v";
			val dpvty = mk_z_schema_type[("d",BOOL),("p",BOOL),("v",tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon,dpvprojs) = get_binding_info dpvty;
			val resty = tyv;
			val argty = list_mk_≠_type(tyvl@[dpvty]);
			val cvar = mk_var(nam,mk_≠_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s)))
				(map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type(tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val desc = mk_app(mk_const("Z'Õ",
				mk_≠_type(mk_ctype("SET",[tyv]),tyv)),
				setcomp);
			val exists = list_mk_∂ (al, pred);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,desc);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "Õ_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "Õ_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Cartesian Products}
=IGN
val tm = mk_z_∏ [Ò˙Æ,Ò˙Æ];
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'∏",[[sn]], Nil) = dest_z_name nam;
=SML
fun €∏_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)));
in
	case dest_z_name nam of
	("Z'∏",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle Fail _ => (
		let	val aty = dest_z_power_type(type_of tm)
				handle (Fail _) =>
				term_fail "∏_gen_semantic_const" 50001 [tm];
			val (tnam, ttyl) = dest_ctype aty;
			val bty = mk_ctype (tnam, int_to_tyvl (length ttyl));
			val tyvl = dest_z_tuple_type bty;
			val side = tuple_type_spec(mk_z_tuple_type tyvl);
			val (con,projs) = get_tuple_info (mk_z_tuple_type tyvl);
			val resty = mk_z_power_type bty;
			val argty = list_mk_≠_type ((map mk_z_power_type tyvl)@[resty]);
			val cvar = mk_var(nam, argty);
			val args = (map (fn (id,ty) => mk_var("X"^id, mk_z_power_type ty))
				(string_to_itym sn))
				handle (Fail _) =>
				term_fail "∏_gen_semantic_const" 50001 [tm];

			val t = mk_var("t",bty);
			val comps = combine projs args; 
			val conjl = map	(fn (p,a) => mk_z_ç(
				match_mk_app(p,t), a))
				comps;
			val conj = list_mk_± conjl;
			val setcomp = mk_set_comp (t, conj);
			val lhs = list_mk_app(cvar, args);
			val body = mk_eq(lhs, setcomp);
			val defn = list_mk_µ (args, body);
		in
			local_const_spec "∏_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "∏_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Binding Display}
=IGN
val tm = mk_z_binding [("x", Ò1Æ), ("y",Ò2Æ)];
=SML
fun €binding_gen_semantic_const› (tm : TERM) : THM = (
	((binding_type_spec o hd o rev o strip_≠_type
	o type_of o fst o strip_app) tm)
	handle Fail _ => term_fail "binding_gen_semantic_const" 50001 [tm]
);
=TEX
\subsection{Unique Existential Quantification}
=IGN
val tm = mk_z_∂â1 (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, mk_z_true);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'∂â1",[[sn]], Nil) = dest_z_name nam;
=SML
fun €∂â1_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)));
in
	case dest_z_name nam of
	("Z'∂â1",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "∂â1_gen_semantic_const" 50001 [tm];
		val tyv = BOOL;
		val dpvty = mk_z_schema_type[("d",BOOL),("p",BOOL),("v",tyv)];
		val side = binding_type_spec dpvty;
		val (dpvcon,dpvprojs) = get_binding_info dpvty;
		val resty = BOOL;
		val argty = list_mk_≠_type(tyvl@[dpvty]);
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val anaml = map (fn s => implode("a" :: tl(explode s)))
			(map dest_vartype tyvl);
		val al = map mk_var (combine anaml tyvl);
		val alt = list_mk_pair al;
		val pack = mk_var("pack",list_mk_≠_type(tyvl@[dpvty]));
		val pack_al = list_mk_app (pack, al);
		val t = mk_var("t",type_of pack_al);
		val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
		val pred = list_mk_± projs;
		val abs_pred = mk_Ã(t,pred);
		val abs_pred_pack_al = mk_app(abs_pred,pack_al);
		val exists = mk_∂â1 (alt, abs_pred_pack_al);
		val lhs = mk_app(cvar,pack);
		val body = mk_eq(lhs,exists);
		val defn = mk_µ(pack,body);
	in
		local_const_spec "∂â1_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "∂â1_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Constructor}
=IGN
val tm = mk_z_h_schema (mk_z_decl1([mk_z_dec([¨a:˙Æ, ¨b:˙Æ],Ò˙Æ)]), mk_z_true);
val nam = (fst(dest_const (fst (strip_app tm))));
val ("Z'âs",[cpl], Nil) = dest_z_name nam;

=SML
fun €schema_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = (fst(dest_const (fst (strip_app tm))));
in
	case dest_z_name nam of
	("Z'âs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val ty = dest_z_power_type(type_of tm)
			handle (Fail _) =>
			term_fail "schema_gen_semantic_const" 50001 [tm];
		val tyvl = map mk_z_var_type cpl;
		val dpty = mk_z_schema_type[("d",BOOL),("p",BOOL)];
		val side = binding_type_spec dpty;
		val (dpcon,dpprojs) = get_binding_info dpty;
		val side = binding_type_spec ty;
		val (con,projs) = get_binding_info ty;
		val bty = (strip_type o type_of) con;
		val argty = list_mk_≠_type(tyvl@[dpty]);
		val resty = mk_z_power_type bty;
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val x = mk_var("x",bty);
		val p = mk_var("p",argty);
		val t = list_match_mk_app(p,map (fn pr => match_mk_app(pr,x)) projs);
		val conj = list_mk_±(map (fn pr => match_mk_app(pr,t)) dpprojs);
		val setcomp = mk_set_comp (x, conj);
		val lhs = mk_app(cvar, p);
		val body = mk_eq(lhs, setcomp);
		val defn = mk_µ (p, body);
	in
		local_const_spec "schema_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "schema_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Decoration}
=IGN
val tm = mk_z_decâs(Ò[x,y,xy:˙]Æ,"''");
val tm' = fst (strip_app tm);
val nam = (fst(dest_const tm'));
val ("Z'Decâs",[cpl,decor], Nil) = dest_z_name nam;
=SML
fun €decâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = (fst(dest_const tm'));
in
	case dest_z_name nam of
	("Z'Decâs",[cpl,decor], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty,rresty) = (
			case strip_≠_type(type_of tm') of [ty1,ty2] =>
			(dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "decâs_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty;
		val (con,proj) = get_binding_info rargty;
		val side = binding_type_spec rresty;
		val (con',proj') = get_binding_info rresty;
		val bty = (strip_type o type_of) con;
		val resty = (strip_type o type_of) con';
		val tym = dest_z_schema_type bty;
		val tym' = dest_z_schema_type resty;
		val rbty = mk_z_schema_type(combine (fst(split tym')) (snd(split tym)));
		val sch = mk_var("sch",mk_z_power_type bty);
		val sch' = mk_var("sch",mk_z_power_type rbty);
		val bvar = mk_var ("bind", bty);
		val bdecvar = mk_var ("bind'", rbty);
		val bmem = mk_ç (bvar, sch);
		val varl = map ((switch o curry) match_mk_app bvar) proj;
		val bind = (list_match_mk_app (con', varl));
		val bdeceq = mk_eq(bdecvar,bind);
		val pred = mk_± (bmem, bdeceq);
		val nam' = fst(dest_const tm');
		val cvar = mk_var(nam',mk_≠_type(type_of sch,type_of sch'));
		val exists = mk_∂(bvar, pred);
		val setcomp = mk_set_comp(bdecvar,exists);
		val lhs = mk_app(cvar, sch);
		val body = mk_eq(lhs, setcomp);
		val defn = mk_µ (sch, body);
		in
			local_const_spec "decâs_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "decâs_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Precondition}
=IGN
val tm = mk_z_preâsÒ[a',b',c:˙]Æ;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Preâs",[cpl], Nil) = dest_z_name nam;
=SML
fun €schema_results› (itym:((string*string) * TYPE)list) =
	(map fst itym) drop (fn (_,d) => (not(d = "'") andalso not(d = "!")));
=TEX
=SML
fun €preâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'Preâs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty,rresty) = (
		case strip_≠_type(type_of tm') of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "preâs_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty;
		val (con, _) = get_binding_info rargty;
		val bty = (strip_type o type_of) con;
		val atym = dest_z_schema_type bty;
		val aidtym = map (fn (s,t) => (unpack_ident s,t)) atym;
		val hidtym = map (fn x => (x,lassoc3 aidtym x)) (schema_results aidtym);
		val htym = map (fn (s,t) => (pack_ident s,t)) hidtym;
		val rtym = (op diff') (atym, htym);
		val side = binding_type_spec(mk_z_schema_type rtym);
		val argty = mk_z_power_type(mk_z_schema_type atym);
		val resty = mk_z_power_type(mk_z_schema_type rtym);
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1(map mk_z_univ_decl rtym);
		val pd = mk_z_decl1(map mk_z_univ_decl htym);
		val p = mk_z_∂(pd,mk_z_true,mk_z_schema_pred(s,""));
		val sch = mk_z_h_schema(d,p);
		val dummy = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs, sch);
		val defn = mk_µ (s, body);
	in
		local_const_spec "preâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "preâs_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Hiding}
=IGN
val tm = mk_z_hideâs (Ò[a,b,c:˙]Æ, ["c"]);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Hideâs",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €hideâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = fst(dest_const tm');

in
	case dest_z_name nam of
	("Z'Hideâs",[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty,rresty) = (
		case (strip_≠_type(type_of tm')) of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "hideâs_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (con,_) = get_binding_info rargty;
		val bty = (strip_type o type_of) con;
		val tym = dest_z_schema_type bty;
		val rtym = map (fn s => (s,lassoc3 tym s)) (cpl1 diff cpl2);
		val htym = map (fn s => (s,(lassoc3 tym s
			handle complaint =>
			divert complaint "lassoc3" "hideâs_gen_semantic_const"
			50004 [fn () => s, fn () => string_of_term tm]))) cpl2;
		val argty = mk_z_power_type bty;
		val resty = mk_z_power_type(mk_z_schema_type(rtym));
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1(map mk_z_univ_decl rtym)
		val pd = mk_z_decl1(map mk_z_univ_decl htym);
		val p = mk_z_∂(pd,mk_z_true,mk_z_schema_pred(s,""));
		val sch = mk_z_h_schema(d,p);
		val dummy = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs, sch);
		val defn = mk_µ (s, body);
	in
		local_const_spec "hideâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "hideâs_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Dyadic Operators}
=IGN
val schexpr = fst o dest_z_schema_dec o
		hd o dest_z_decl o
		fst o dest_z_h_schema;
val tm = mk_z_±âs (Ò[a,b,c:˙]Æ, Ò[d:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val (oper,[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €dyopâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	(oper,[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (ra1ty,ra2ty,rresty) = (
			case strip_≠_type(type_of tm') of 
			[ty1,ty2,ty3] => (dest_z_power_type ty1,dest_z_power_type ty2,
						dest_z_power_type ty3)
			|_ => term_fail "dyopâs_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec ra1ty;
		val side = binding_type_spec ra2ty;
		val side = binding_type_spec rresty;
		val (cona1,proja1) = get_binding_info ra1ty;
		val (cona2,proja2) = get_binding_info ra2ty;
		val (conr,projr) = get_binding_info rresty;
		val rbty = (strip_type o type_of) conr;
		val tym = map 	(fn(s,ty) => (s,mk_vartype((dest_vartype ty) ^ "a"))) 
					(dest_z_schema_type rbty);
		val tym1 = combine cpl1 (map (fn s => (lassoc3 tym s
			handle complaint => divert complaint
			"lassoc3" "dyopâs_gen_semantic_const" 50006 
			[fn () => s, fn () => string_of_term tm])) cpl1);
		val tym2 = combine cpl2 (map (fn s => (lassoc3 tym s
			handle complaint => divert complaint
			"lassoc3" "dyopâs_gen_semantic_const" 50006 
			[fn () => s, fn () => string_of_term tm])) cpl2);
		val a1bty = mk_z_schema_type tym1;
		val a2bty = mk_z_schema_type tym2;
		val rbty' = mk_z_schema_type tym;
		val sch1 = mk_var("sch1",mk_z_power_type a1bty);
		val sch2 = mk_var("sch2",mk_z_power_type a2bty);
		val sch = mk_var("sch",mk_z_power_type rbty');
		val bvar = mk_var ("bind", rbty');
		fun dopr pr =
		let	val tup = (map (fn x=>((dest_z_name
				o fst o dest_const) x,x)) pr);
		in
			map (fn ((_,_, x), y)=>(x,y)) tup
		end;
		val pr1 = map snd ((dopr projr) drop (fn (x,_) =>
			not(x mem (map fst (dopr proja1)))));
		val pr2 = map snd ((dopr projr) drop (fn (x,_) =>
			not(x mem (map fst (dopr proja2)))));
		val varl1 = map ((switch o curry) match_mk_app bvar) pr1;
		val varl2 = map ((switch o curry) match_mk_app bvar) pr2;
		val memb1 = mk_ç(list_match_mk_app (cona1, varl1),sch1);
		val memb2 = mk_ç(list_match_mk_app (cona2, varl2),sch2);
		val desc = (
			case oper of 	"Z'±âs" => mk_±(memb1,memb2)
			|		"Z'≤âs" => mk_≤(memb1,memb2)
			|		"Z'¥âs" => mk_¥(memb1,memb2)
			|		"Z'§âs" => mk_§(memb1,memb2)
			|		_ => term_fail "dyopâs_gen_semantic_const" 50001 [tm]
			);
		val setcomp = mk_set_comp (bvar, desc);
		val cvar = mk_var(nam,list_mk_≠_type([type_of sch1,type_of sch2,
			type_of sch]));
		val lhs = list_mk_app(cvar, [sch1, sch2]);
		val body = mk_eq(lhs,setcomp);
		val defn = list_mk_µ ([sch1,sch2], body);
	in
		local_const_spec "dyopâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "dyopâs_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Projection}
=IGN
val tm = mk_z_˘âs (Ò[a,b,c:˙]Æ, Ò[b:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'˘âs",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €˘âs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'˘âs",[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty1,rargty2,rresty) = (
		case (strip_≠_type(type_of tm')) of
			[ty1,ty2,ty3] => (
				(dest_z_power_type ty1,dest_z_power_type ty2,
					dest_z_power_type ty3)
				)
			|_ => term_fail "˘âs_gen_semantic_const" 50001 [tm]
			);
		val side = binding_type_spec rargty1;
		val side = binding_type_spec rargty2;
		val tym = combine (cpl1 cup cpl2) (map mk_z_var_type(cpl1 cup cpl2));
		val argty1 = mk_z_power_type(mk_z_schema_type(map (fn s =>
			(s,lassoc3 tym s)) cpl1));
		val argty2 = mk_z_power_type(mk_z_schema_type(map (fn s =>
			(s,lassoc3 tym s)) cpl2));
		val resty = argty2;
		val cvar = mk_var(nam,list_mk_≠_type([argty1,argty2,resty]));
		val s1 = mk_var("sch1",argty1);
		val s2 = mk_var("sch2",argty2);
		val hidel = cpl1 diff cpl2;
		val schand = mk_z_±âs(s1,s2);
		val dummy = dyopâs_gen_semantic_const schand;
		val sch = mk_z_hideâs(schand,hidel);
		val side = hideâs_gen_semantic_const sch;
		val lhs = list_mk_app(cvar, [s1,s2]);
		val body = mk_eq(lhs, sch);
		val defn = list_mk_µ ([s1,s2], body);
	in
		local_const_spec "˘âs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "˘âs_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Delta Constructor}
=IGN
val tm = mk_z_Ñâs Ò[a,b,c:˙]Æ;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Ñâs",[cpl], Nil) = dest_z_name nam;
=SML
fun €Ñâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'Ñâs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty,rresty) = (
			case strip_≠_type(type_of tm') of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "Ñâs_gen_semantic_const" 50001 [tm]
			);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (cona,_) = get_binding_info rargty;
		val (conr,_) = get_binding_info rresty;
		val bty = (strip_type o type_of) cona;
		val rbty = (strip_type o type_of) conr;
		val tym = dest_z_schema_type bty;
		val tym' = map (fn(s,ty) => ((s ^ "'"),ty)) tym;
		val argty = mk_z_power_type(mk_z_schema_type tym);
		val resty = mk_z_power_type(mk_z_schema_type(tym @ tym'));
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1[mk_z_schema_dec(s,""),mk_z_schema_dec(s,"'")];
		val p = mk_z_true;
		val sch = mk_z_h_schema(d,p);
		val side = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs,sch);
		val defn = mk_µ(s,body);
	in
		local_const_spec "Ñâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "Ñâs_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Xi Constructor}
=IGN
val tm = mk_z_òâsÒ[a,b,c:˙]Æ;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'òâs",[cpl], Nil) = dest_z_name nam;
=SML
fun €òâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'òâs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty,rresty) = (
			case strip_≠_type(type_of tm') of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "òâs_gen_semantic_const" 50001 [tm]
			);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (cona,_) = get_binding_info rargty;
		val (conr,_) = get_binding_info rresty;
		val bty = (strip_type o type_of) cona;
		val rbty = (strip_type o type_of) conr;
		val tym = dest_z_schema_type bty;
		val tym' = map (fn(s,ty) => ((s ^ "'"),ty)) tym;
		val argty = mk_z_power_type(mk_z_schema_type tym);
		val resty = mk_z_power_type(mk_z_schema_type(tym @ tym'));
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1[mk_z_schema_dec(s,""),mk_z_schema_dec(s,"'")];
		val p = mk_z_eq(mk_z_ (s,""),mk_z_ (s,"'"));
		val sch = mk_z_h_schema(d,p);
		val side = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq (lhs, sch);
		val defn = mk_µ(s, body);
	in
		local_const_spec "òâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "òâs_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Quantification}
=SML
fun €sort_projs› (pr : TERM list) : TERM list = (
let	val pr' = map (fn p => (((dest_vartype o type_of) p)^
		hd(PrettyPrinter.format_term false p), p)) pr;
	fun rsort (s1,_) (s2,_) =
			Sort.string_order s1 s2;
in
	map snd (Sort.sort rsort pr')
end);
=TEX

=IGN
val tm = mk_z_µâs (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm = mk_z_∂âs (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val (oper,[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €quantâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	(oper,[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty1,rargty2,rresty) = (
			case (strip_≠_type(type_of tm')) of
			[ty1,ty2,ty3] => (ty1,dest_z_power_type ty2,dest_z_power_type ty3)
			|_ => term_fail "quantâs_gen_semantic_const" 50001 [tm]
			);
		val sdp = (hd o rev o strip_≠_type) rargty1;
		val side = binding_type_spec sdp;
		val (_,tprojs) = get_binding_info sdp;
		val side = binding_type_spec rargty2;
		val (con,_) = get_binding_info rargty2;
		val side = binding_type_spec rresty;
		val (xcon,xprojs) = get_binding_info rresty;
		val bty2 = (strip_type o type_of) con;
		val rbty = (strip_type o type_of) xcon;
		val tym = dest_z_schema_type bty2;
		val argty1 = list_mk_≠_type((map 
			(fn s => (lassoc3 tym s handle complaint =>
			divert complaint "lassoc3" "quantâs_gen_semantic_const" 50005
			[fn () => s, fn () => string_of_term tm])) cpl1)@[sdp]);
		val argty2 = mk_z_power_type(mk_z_schema_type tym);
		val resty = mk_z_power_type(mk_z_schema_type(map (fn s =>
			(s,lassoc3 tym s)) cpl2));
		val ybty = mk_z_schema_type
			(map (fn s => (s,lassoc3 tym s)) cpl1);
		val side = binding_type_spec ybty;
		val (_,yprojs) = get_binding_info ybty;
		val cvar = mk_var(nam,list_mk_≠_type
			([argty1,argty2,resty]));
		val p = mk_var("p",argty1);
		val q = mk_var("q",argty2);
		val x = mk_var("x",dest_z_power_type resty);
		val y = mk_var("y",ybty);
		val xprojections = map (fn f => match_mk_app(f,x)) xprojs;
		val yprojections = map (fn f => match_mk_app(f,y)) yprojs;
		val projections = xprojections @ yprojections;
		val sorted_projections = sort_projs projections;
		val t = list_mk_app (p, yprojections);
		val conj1 = list_mk_±(map (fn pf => match_mk_app(pf,t)) tprojs);
		val conj2 = mk_ç(list_match_mk_app (con, sorted_projections),q);
		val pred = (case oper of "Z'µâs" => mk_¥(conj1,conj2)
			|		"Z'∂âs" => mk_±(conj1,conj2)
			|		"Z'∂â1âs" => mk_±(conj1,conj2)
			|		_ => term_fail "quantâs_gen_semantic_const" 50001 [tm]
			);
		val desc = (
			case oper of 	"Z'µâs" => mk_µ(y,pred)
			|		"Z'∂âs" => mk_∂(y,pred)
			|		"Z'∂â1âs" => mk_∂â1(y,pred)
			|		_ => term_fail "quantâs_gen_semantic_const" 50001 [tm]
			);
		val setcomp = mk_set_comp(x,desc);
		val lhs = list_mk_app (cvar, [p,q]);
		val body = mk_eq(lhs, setcomp);
		val defn = list_mk_µ ([p, q], body);
	in
		local_const_spec "quantâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "quantâs_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Composition}
=IGN
val tm = mk_z_ªâs (Ò[x,b,c,d':X]Æ, Ò[d:X;e:Y]Æ);
val tm = mk_z_ªâs (Ò[qq',b,c,d':X]Æ, Ò[qq,d:X;e:Y]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'ªâs",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun give_n_names nn lst = (
=SMLLITERAL
let	fun nextn n = (let val poss = "x" ^ string_of_int n
=SML
		in
		if poss mem lst
		then nextn (n+1)
		else (n,poss)
		end);
	fun nextnm 0 m = []
	| nextnm n m = (let val (ind,next) = nextn m
		in
		(next :: nextnm (n-1) (ind+1))
		end)
in
	nextnm nn 1
end);

=TEX
=SML
fun €ªâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'ªâs",[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty1,rargty2,rresty) = (
			case strip_≠_type(type_of tm') of
			[ty1,ty2,ty3] => (dest_z_power_type ty1,
					dest_z_power_type ty2,dest_z_power_type ty3)
			|_ => term_fail "ªâs_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty1;
		val side = binding_type_spec rargty2;
		val side = binding_type_spec rresty;
		val (conr,_) = get_binding_info rresty;
		val rbty = (strip_type o type_of) conr;
		val rcpl = map fst (dest_z_schema_type rbty);
		val ocpl = cpl1 drop (fn s => snd(unpack_ident s) <> "'");
		val icpl = cpl2 drop (fn s => snd(unpack_ident s) <> "");
		val icpl' = map (fn s => (s ^ "'")) icpl;
		val (mcpl,mcpl') = split ((combine icpl icpl')
			drop (fn (i,i') => not (i' mem ocpl)));
		val rtyvars = map mk_z_var_type rcpl;
		val mtyvars = map mk_z_var_type mcpl;
		val rtym = combine rcpl rtyvars;
		val mtym = combine mcpl mtyvars;
		val mtym' = combine mcpl' mtyvars;
		val alist1 = (mtym' @ rtym);
		val alist2 = (mtym @ rtym);
		val a1tym = map (fn s => (s,(lassoc3 alist1 s
			handle complaint => divert complaint
			"lassoc3" "ªâs_gen_semantic_const" 50006 
			[fn () => s, fn () => string_of_term tm]))) cpl1;
		val a2tym = map (fn s => (s,(lassoc3 alist2 s
			handle complaint => divert complaint
			"lassoc3" "ªâs_gen_semantic_const" 50006 
			[fn () => s, fn () => string_of_term tm]))) cpl2;
		val a1 = map mk_var a1tym;
		val a2 = map mk_var a2tym;
		val argty1 = mk_z_power_type(mk_z_schema_type a1tym);
		val argty2 = mk_z_power_type(mk_z_schema_type a2tym);
		val resty = mk_z_power_type(mk_z_schema_type rtym);
		val cvar = mk_var(nam,list_mk_≠_type([argty1,argty2,resty]));
		val s1_poss = mk_var("sch1",argty1);
		val s2_poss = mk_var("sch2",argty2);
		val (s1,s2) = case list_variant (a1 @ a2) [s1_poss, s2_poss] of
			[s1,s2] => (s1,s2)
			| _ => error "ªâs_gen_semantic_const" 50003 [fn () => string_of_term tm];
		val mreplaces_nms = give_n_names (length  mcpl)
			(cpl1 @ cpl2);
		val mreplaces = map mk_var(combine mreplaces_nms mtyvars);
		val sch1_trans = (map (fn (nm,ty) => (nm,mk_var(nm,ty))) a1tym) list_overwrite (combine mcpl' mreplaces);
		val sch2_trans = (map (fn (nm,ty) => (nm,mk_var(nm,ty))) a2tym) list_overwrite (combine mcpl mreplaces);

		val bind1 = mk_z_binding sch1_trans; (* semantic const already in place *)
		val bind2 = mk_z_binding sch2_trans;
		val inner_tm = mk_z_±(mk_z_ç(bind1, s1), mk_z_ç(bind2,s2));
		val mreplaces_decl = mk_z_decl1 (map mk_z_univ_decl1 mreplaces);
		val ∂_tm = mk_z_∂(mreplaces_decl, mk_z_true, inner_tm);
		val rest = ((rev(frees ∂_tm)) term_less s1) term_less s2;
		val rest_decl = mk_z_decl1 (map mk_z_univ_decl1 rest);
		val rhs = mk_z_h_schema (rest_decl,∂_tm);
		val side = schema_gen_semantic_const rhs;
		val lhs = list_mk_app(cvar,[s1,s2]);
		val defn_tm = list_mk_µ([s1, s2], mk_eq(lhs,rhs));
	in
		local_const_spec "ªâs_gen_semantic_const" (nam, cvar, defn_tm)
	end))
	| _ => term_fail "ªâs_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Renaming Z Schemas}
=SML
fun €renameâs_gen_semantic_const› (tm : TERM) : THM = (
let	val (s,rnl) = dest_z_renameâs tm
		handle complaint =>
		divert complaint "dest_z_renameâs" "renameâs_gen_semantic_const" 
			50001 [fn () => string_of_term tm];
	val nam = fst(dest_const (fst (dest_app tm)));
in
	get_cached_defn (nam ^ "_def")
	handle Fail _ => (
let
	val tyfrom = dest_z_power_type(type_of s);
	val tyto = dest_z_power_type(type_of tm);
=TEX
The following two may be redundant, but ...
=SML
	val side = binding_type_spec tyto;
	val side = binding_type_spec tyfrom;
	val from_comp = map fst (dest_z_schema_type tyfrom);
	val to_comp = map fst (dest_z_schema_type tyto);
	val ty_insts =(map (fn (a,b) => 
		(mk_vartype ("'"^a),
		mk_vartype ("'"^b))) rnl);
	val ty_inst = inst_type ty_insts;
	val tm_inst = inst [] ty_insts;
	val tyfrom_generic = ty_inst (mk_ctype
			(fst(dest_ctype tyfrom),
			map (mk_vartype o (fn y => "'" ^ y)) from_comp));
	val p_tyfrom_generic = mk_z_power_type tyfrom_generic;
	val tyto_generic = ty_inst(mk_ctype
			(fst(dest_ctype tyto),
			map (mk_vartype o (fn y => "'" ^ y)) to_comp));
	val p_tyto_generic = mk_z_power_type tyto_generic;
	val const_generic = mk_var(nam,
		mk_≠_type(p_tyfrom_generic, p_tyto_generic));
	val argS = mk_var("S",p_tyfrom_generic);
	val args = mk_var("s",tyto_generic);
	val args' = mk_var("s'",tyfrom_generic);
	val (to_con,_) = get_binding_info tyto_generic;
	val (_,from_projs) = get_binding_info tyfrom_generic;
	val from_projs' = map tm_inst from_projs;
 	val from_bits = map (fn x => mk_app(x,args')) from_projs';
	val from_bits_assoc = combine from_comp from_bits;
	fun aux tb = (
		lassoc3 from_bits_assoc (lassoc1 rnl tb)
		handle complaint => divert complaint
			"lassoc3" "renameâs_gen_semantic_const" 50006 
			[fn () => (lassoc1 rnl tb), fn () => string_of_term tm]);
	val to_bits = map aux to_comp;
	val inner_rhs = list_mk_app(to_con, to_bits);
	val inner_ç = list_mk_app(
		mk_const("ç",list_mk_≠_type[type_of args',
			type_of argS, BOOL]),
		[args', argS]);	
	val dumy = if type_of args =: type_of inner_rhs
		then ()
		else type_fail "renameâs_gen_semantic_const" 50007 [type_of args, type_of inner_rhs];
	val inner_∂ = mk_∂(args',
		mk_±(inner_ç ,
		mk_eq(args,inner_rhs)));
	val rhs = mk_set_comp(args, inner_∂);
	val lhs = mk_app(const_generic, argS);
	val def_tm = mk_µ(argS, mk_eq(lhs,rhs));
in
	local_const_spec "renameâs_gen_semantic_const" (nam, const_generic, def_tm)
end)
end);
=TEX	 
\section{EPILOGUE}
=SML
end (* of structure ZGeneratedConstants *);
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

