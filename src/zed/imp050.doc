=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Implementation of Z Constant Generation}
\TPPref{DS/FMU/IED/IMP050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
%\TPPauthors{G.T.Scullard&WIN01\\G.M.Prout&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the implementation of the dynamic generation of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] (\TPPdate{\FormatDate{$Date$
}})
First draft version.

\item [Issue 1.2] (\TPPdate{\FormatDate{$Date$
}})
Changed to new fonts.

\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The detailed design may be found in
\cite{DS/FMU/IED/DTD050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{STRUCTURE}
=SML
structure ÛZConstantsÝ = struct
=TEX
\section{AUXILIARY FUNCTIONS}

=SML
fun (Ûint_to_tyvlÝ : int -> TYPE list) 1 = [mk_ZvarT (string_of_int 1)]
| int_to_tyvl n = (int_to_tyvl(n - 1)) @ [mk_ZvarT (string_of_int n)];
=TEX
=SML
fun (Ûint_to_slÝ : int -> string list) 1 = [string_of_int 1]
| int_to_sl n = (int_to_sl(n - 1)) @ [string_of_int n];
=TEX
function to make an ``itym'' from a list of strings:
=SML
fun	Ûstringl_to_itymÝ (sl : string list):(string * TYPE)list =
	combine sl (map mk_ZvarT sl);
=TEX
function to make an ``itym'' from an integer
=SML
fun (Ûint_to_itymÝ : int -> (string * TYPE) list) 1 = 
	[("1", mk_ZvarT "1")]
|	int_to_itym n = (
		let 	val s = string_of_int n 
		in	int_to_itym (n - 1) @ [(s,mk_ZvarT s)]
		end); 
=TEX
function to make an ``itym'' from a string 
=SML
fun (Ûstring_to_itymÝ : string -> (string * TYPE) list) s = 
	int_to_itym(nat_of_string s);
=TEX
function to make a type list from a string 
=SML
fun (Ûstring_to_stylÝ : string -> TYPE list) s = 
	int_to_tyvl(nat_of_string s);
=TEX
Geoff's list\_mk\_­\_type (from \cite{DS/FMU/IED/DTD048}):
=SML
fun	Ûlist_mk_­_typeÝ ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_­_type tyl ty;
=TEX
And its inverse:
=SML
fun Ûstrip_­_typeÝ (ty : TYPE): TYPE list * TYPE = (
	let fun aux typ l= (
		if is_­_type typ
		then 	let 	val (ty1,ty2) = dest_­_type typ
			in aux  ty2 (l @ [ty1]) 
			end
		else (l,typ)
		);
	in	aux ty [] 
	end
);
=TEX

Another version which treats all components of the type the same:
=SML
fun	Ûlist_mk_­_type1Ý ([ty]:TYPE list):TYPE = ty
| list_mk_­_type1 (ty::tyl) = mk_­_type (ty,list_mk_­_type1 tyl)
| list_mk_­_type1 [] = fail "list_mk_­_type1" 3017 [];
=TEX
Inverse of list\_mk\_­\_type1 required:
=SML
fun Ûstrip_­_type1Ý (ty : TYPE): TYPE list = (
	if is_­_type ty
	then 	let 	val (ty1,ty2) = dest_­_type ty
		in
			(ty1 :: strip_­_type1 ty2)
		end
	else [ty]);
=TEX
=SML
fun ÛlastÝ (l : 'a list)  = (hd (rev l));
fun ÛfrontÝ (l : 'a list)  = rev(tl (rev l));
=TEX
The function $match\_mk\_app$ below should perhaps
be elsewhere.
Given terms $f:\tau­\sigma$
and $a:\tau_0$ $match\_mk\_app$ checks whether $\tau_0$
is an instance of $\tau$ and, if so, it returns
$(f:\tau_0­\sigma_0)(a:\tau_0)$, where $\sigma_0$  is the
corresponding instance of $\sigma$.
=SML

fun match_mk_app(f : TERM, a : TERM) : TERM = (
let  val ty = type_of f
in
	if is_­_type ty
	then	
		let 	val(ty1,_) = dest_­_type ty;
			val tym = type_match (type_of a) ty1;
		in
			mk_app(
		inst [] tym f,
		a)
		end
	else fail "match_mk_app" 0 []
end);

=TEX
A function which takes a binding type and returns a pair consisting
of the name of the binding type constructor and a list of names of the projections.
=SML
fun Ûbind_con_projÝ(ty:TYPE) =
let	val (sl,tyl) = split(dest_ZschemaT ty)
		handle complaint => 
		divert complaint "dest_ZschemaT" "bind_con_proj" 47050 
			[fn () => string_of_type ty];
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'mk_"^typart;
	val pnaml = map (curry (op ^) nam)  sl;
in
	(cnam,pnaml)
end;
=TEX
A function which takes a tuple type and returns  a pair consisting
of the name of the tuple type constructor and a list of names of the projections.

=SML
fun Ûtuple_con_projÝ(ty:TYPE) =
let	val tyl = dest_ZtupleT ty
		handle complaint => 
		divert complaint "dest_ZtupleT" "tuple_con_proj" 47040 
			[fn () => string_of_type ty];
	val n = length tyl;
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'mk_"^typart;
	val isl = int_to_sl n;
	val pnaml = map (curry (op ^) nam)  isl;
in	
	(cnam,pnaml)
end;
=TEX
\section{STORING Z CONSTANTS}
=SML
val Ûdefining_theoremÝ : bool ref = ref true;
val _= new_flag{name="defining_theorem",
		control = defining_theorem,
		default = fun_true,
		check = fun_true};
=TEX
\section{BINDING TYPES}
Everything stored in current theory for now.
=SML
	
fun Ûbinding_type_specÝ(ty : TYPE) : unit =
let 	
	val thm_reqd = get_flag"defining_theorem";
	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "binding_type_spec" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_ZschemaT ty);
	val (nam,tyl) = dest_ctype ty;
	val tyvl = map mk_ZvarT sl;
in
	if thm_reqd
	then	
	let 	val side_effect = get_defn  "-" nam 
		handle  Fail _ =>
			(labelled_product_spec{
					tykey = nam,
					labels = combine pnaml tyvl,
					tyname= nam,
					tyvars = Nil,
					conname = cnam,
					constkeys = [cnam] @ pnaml})
	in
		()
	end
	else 	case get_type_arity nam  of Value _ => ()
		| _ => 
			let	val n = length pnaml;
				val side_effect = new_type(nam,n);
				val vty = mk_ZschemaT(combine sl tyvl);
				val pty = list_mk_­_type(tyvl,vty);
				val side_effect = new_const(cnam,pty);
				val ptyl = map (curry mk_­_type vty) tyvl;
				val side_effect = map new_const(combine pnaml ptyl);
			in ()
			end	
end;
	

=TEX
Why isn't there a proper $get\_const$??? 
=SML
fun Ûget_binding_infoÝ(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "get_binding_info" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_ZschemaT ty);
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = map mk_ZvarT sl;	
		val	(_,bty) = strip_­_type pty;
		val 	ptyl = map (curry mk_­_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end	
	| _ => fail "get_binding_info" 50001 [fn () => cnam]
end;
=TEX
\section{TUPLE TYPES}
=SML
fun Ûtuple_type_specÝ(ty : TYPE) : unit =
let 	
	val thm_reqd = get_flag"defining_theorem";
	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "tuple_type_spec" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
	val nam = fst(dest_ctype ty);
	val tyvl = int_to_tyvl n;
in
	if thm_reqd
		then	
	let 	val side_effect = get_defn  "-" nam 
		handle  Fail _ =>
			(labelled_product_spec{
					tykey = nam,
					labels = combine pnaml tyvl,
					tyname= nam,
					tyvars = Nil,
					conname = cnam,
					constkeys = [cnam] @ pnaml})
	in
		()
	end
	else 	case get_type_arity nam  of Value _ => ()
		| _ => 
			let	val vty = new_type(nam,n);
				val pty = list_mk_­_type(tyvl,vty);
				val side_effect = new_const(cnam,pty);
				val ptyl = map (curry mk_­_type vty) tyvl;
				val side_effect = map new_const(combine pnaml ptyl);
			in ()
			end	
end;
=TEX
Why isn't there a proper $get\_const$??? 
=SML
fun Ûget_tuple_infoÝ(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "get_tuple_info" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = int_to_tyvl n;	
		val 	bty = mk_ZtupleT tyvl;
		val 	ptyl = map (curry mk_­_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end		| _ => fail "get_tuple_info" 50002 [fn () => cnam]
end;
=TEX
\section{RETRIEVING TYPE INFORMATION}
These don't work - $µ\_±\_conv$ requires theory $combin$ as parent.
=SML
fun Ûget_constructor_defnÝ(ty : TYPE) : THM =
let 	val (cnam,_) = 
			if is_ZschemaT ty
				then (binding_type_spec ty;bind_con_proj ty)
			else 	if is_ZtupleT ty
					then (tuple_type_spec ty;tuple_con_proj ty)
				else fail  "get_constructor_defn" 5003 
				[fn () => string_of_type ty];
	val thm = get_defn "Z" cnam
		handle complaint => 
		divert complaint "get_defn""get_constructor_defn" 50004[fn () => nam]
in
	hd(strip_±_rule((conv_rule µ_±_conv)thm))
end;
=TEX
=SML
fun Ûget_projections_defnÝ(ty : TYPE) : THM list =
let 	val (cnam,_) = 
			if is_ZschemaT ty
				then (binding_type_spec ty;bind_con_proj ty)
			else 	if is_ZtupleT ty
					then (tuple_type_spec ty;tuple_con_proj ty)
				else fail  "get_projections_defn" 5003 
				[fn () => string_of_type ty];
	val thm = get_defn "Z" cnam
		handle complaint => 
		divert complaint "get_defn""get_projections_defn" 50005[fn () => nam]
in
	strip_±_rule(hd(tl(strip_±_rule((conv_rule µ_±_conv)thm))))
end;
=TEX
\section{Z CONSTANT DEFINITION GENERATION}
THIS SECTION IS INCOMPLETE
!! Nothing that follows has been checked !!
=SML
fun	Ûtypes_in_zcon_specÝ (ty : TYPE) : unit = 	
	if 	is_ZgivenT ty then ()
	else 	if	is_ZvarT ty then ()
	else 	if	is_ZpowerT ty then types_in_zcon_spec (dest_ZpowerT ty)
	else 	if	is_ZtupleT ty then 
			let	val(s,tyl) = dest_ctype ty
			in	map types_in_zcon_spec tyl;(tuple_type_spec ty;())
			end
	else 	if	is_ZschemaT ty then 
			let	val(s,tyl) = dest_ctype ty
			in	map types_in_zcon_spec tyl;(binding_type_spec ty;())
			end
	else 	if	is_­_type ty then
			let	val (ty1,ty2) = dest_­_type ty
			in  	types_in_zcon_spec ty1;types_in_zcon_spec ty2 
			end
	else 	fail "types_in_zcon_spec" 50006 [fn () => string_of_type ty];

=TEX
\subsection{Constants for Schema Calculus}

First, we will need the schema type $Z'S[d,p]$, type instantiated to $BOOL$, and the``d'' and ``p'' projections of the schema type $Z'S[d,p]$, type instantiated to $BOOL$:
=SML
val get_dpty : TYPE =
let 	val ty = mk_ZschemaT(stringl_to_itym["d","p"]);
	val side_effect	= binding_type_spec  ty;
in
	inst_type[(¬:BOOL®,¬:'d®),(¬:BOOL®,¬:'p®)] ty
end;
=TEX
=SML
val get_dpprojs : TERM list =
let 	val ty = mk_ZschemaT(stringl_to_itym["d","p"]);
	val side_effect	= binding_type_spec  ty;
	val(_,projs) = get_binding_info ty;
in
	map (inst[][(¬:BOOL®,¬:'d®),(¬:BOOL®,¬:'p®)]) projs
end;
=TEX
Should I remove call to $binding\_type\_spec$ on the
grounds that types will always be put in place first?
=SML
fun Ûz_schema_defnÝ (znam : string)(sl : string list):TERM * TERM =
let 	
	val  zty = schema_btype (stringl_to_itym sl);
	val schtm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_­_type zty;
	val p = mk_Zlvar("p",ty1,[]);
	val lhs = mk_app(schtm,p); 
	val schty = dest_ZpowerT ty2;	
	val x = mk_Zlvar("x",schty,[]);
	val side_effect = binding_type_spec schty;
	val(_,projsx) = get_binding_info schty;
	val substm = list_mk_app(p,map (fn pr => mk_app(pr,x))projsx);
	val t = mk_Zlvar("t",type_of substm,[]);
	val conj = list_mk_±(map (fn pr => mk_app(pr,t))get_dpprojs);
	val absttm = mk_Ì(t,conj);
	val absxtm = mk_Ì(x,mk_app(absttm,substm));
	val rhs = match_mk_app(¬$"Z'absð"®,absxtm);
in
	(schtm,mk_µ(p,mk_eq(lhs,rhs)))
end;
=TEX
First a function which makes the right sort of signature for the resultant schema.
Something wrong here - shouldn't I be using $U$?
=SML
fun (mk_Zdecty (styl:(string * TYPE) list)):TERM = (
let 	val varl = map ((fn x => [x]) o mk_var) styl	
 	val tyl = map (fn x => mk_var("S" ^ (fst x),mk_ZpowerT(snd x))) styl;
in
mk_Zdecl(map mk_Zdec (combine varl tyl))
end);
=TEX
=SML
fun Ûz_dysc_defnÝ (znam : string)(sl1 : string list)(sl2 : string list)(dyop : string):TERM * TERM =
let 	
	val  zty = bind_dysc_type (stringl_to_itym sl1)(stringl_to_itym sl2);
	val dysctm = mk_var(znam,zty);	
	val (ty1,ty) = dest_­_type zty;
	val (ty2,ty3) = dest_­_type ty;
	val schty = dest_ZpowerT ty3;
	val styl = dest_ZschemaT schty;
	val d = mk_Zdecty styl;
	val (sc1,sc2) = (mk_Zlvar("sc1",ty1,[]),mk_Zlvar("sc2",ty2,[]));
	val lhs = list_mk_app(dysctm,[sc1,sc2]);
	val p = case dyop of
		"±" => mk_Z±%down%s(sc1,sc2)
		| "²" => mk_Z²%down%s(sc1,sc2)
		| "´" => mk_Z´%down%s(sc1,sc2)
		| "¤" => mk_Z¤%down%s(sc1,sc2)
		| _ => fail "z_dysc_defn" 0 [] ;
	val rhs = mk_Z%down%s(d,mk_Zpredsexp(p,""));	
in
	(dysctm,list_mk_µ([sc1,sc2],mk_eq(lhs,rhs)))
end;
=TEX
=SML
fun Ûz_pre_defnÝ (znam : string)(sl : string list):TERM * TERM =
let 	
	val  zty = bind_pre_type (stringl_to_itym sl);
	val pretm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_­_type zty;
	val s = mk_Zlvar("s",ty1,[]);
	val lhs = mk_app(pretm,s); 
	val schty1 = dest_ZpowerT ty1;
	val schty2 = dest_ZpowerT ty2;
	val styl1 = dest_ZschemaT schty1;
	val styl2 = dest_ZschemaT schty2;
	val d1 = mk_Zdecty styl2;
	val d2 = mk_Zdecty (styl1 diff styl2);
	val p = mk_Z¶(d2,mk_Ztrue,mk_Zpredsexp(s,""));
	val rhs = mk_Z%down%s(d1,p);
in
	(pretm,mk_µ(s,mk_eq(lhs,rhs)))
end;
=TEX

=SML
fun Ûz_pro_defnÝ (znam : string)(sl1 : string list)(sl2 : string list):TERM * TERM =
let 	
	val  zty = bind_ù_type (stringl_to_itym sl1)(stringl_to_itym sl2);
	val protm = mk_var(znam,zty);	
	val (ty1,ty) = dest_­_type zty;
	val (ty2,ty3) = dest_­_type ty;
	val (sc1,sc2) = (mk_Zlvar("sc1",ty1,[]),mk_Zlvar("sc2",ty2,[]));
	val lhs = list_mk_app(protm,[sc1,sc2]);
	val schconj = mk_Z±%down%s(sc1,sc2)
	val schty1 = dest_ZpowerT ty1;
	val styl1 = dest_ZschemaT schty1;
	val schty2 = dest_ZpowerT ty2;
	val styl2 = dest_ZschemaT schty2;
	val sl = fst(split(styl1 diff styl2));
	val rhs = (mk_Z\%down%s (schconj,sl));
in
	(protm,list_mk_µ([sc1,sc2],mk_eq(lhs,rhs)))
end;
=TEX
=SML
fun Ûz_hide_defnÝ (znam : string)(sl1 : string list)(sl2 : string list):TERM * TERM =
let 	
	val  zty = bind_\_type (stringl_to_itym sl1) sl2;
	val hidtm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_­_type zty;
	val sc = mk_Zlvar("sc",ty1,[]);
	val lhs = mk_app(hidtm,sc); 
	val schty1 = dest_ZpowerT ty1;
	val schty2 = dest_ZpowerT ty2;
	val styl1 = dest_ZschemaT schty1;
	val styl2 = dest_ZschemaT schty2;
	val styl = styl1 diff styl2;
	val d1 = mk_Zdecty styl2;
	val d2 = mk_Zdecty styl;
	val p = mk_Z¶(d2,mk_Ztrue,mk_Zpredsexp(sc,""));
	val rhs = mk_Z%down%s(d1,p);
in
	(hidtm,mk_µ(sc,mk_eq(lhs,rhs)))
end;
=TEX
=SML
fun Ûz_dec_defnÝ (znam : string) (sl : string list) (s : string):TERM * TERM =
let 	
	val  zty = bind_decor_type(stringl_to_itym sl) s;
	val dectm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_­_type zty;
	val schty1 = dest_ZpowerT ty1;
	val styl1 = dest_ZschemaT schty1;
	val schtm1 = schema_bterm styl1; 
	val schty2 = dest_ZpowerT ty2;
	val styl2 = dest_ZschemaT schty2;
	val schtm2 = schema_bterm styl2; 
	val tyvl = snd(split styl1);
	val p = mk_Zlvar("p",list_mk_­_type(tyvl,get_dpty),[]);
	val lhs = mk_app(dectm,mk_app(schtm1,p)); 
	val rhs = mk_app(schtm2,p);
in
	(dectm,mk_µ(p,mk_eq(lhs,rhs)))
end;
=TEX
First a function which sorts a list of pairs according to  the first of each pair:
=SML
fun Ûidsetseq_pairsÝ (x : (string * 'a) list) : (string * 'a) list =
	let 	val orderfn = fn (s1,a1) => (fn (s2,a2) => Sort.stringorder s1 s2)
	in
		Sort.sort orderfn x
	end;
=TEX
=SML
fun Ûz_schquant_defnÝ (znam : string)(sl1 : string list)(sl2 : string list)
	(quant:string):TERM * TERM =
let 	
	val sl = idsetseq(sl1 @ sl2);
	val (zty,mktm)= case quant of
		"¶" => (¶%down%s_btype (stringl_to_itym sl1)(stringl_to_itym sl),mk_¶)
		| "¶%down%1" =>(¶%down%1%down%s_btype 
		(stringl_to_itym sl1)(stringl_to_itym sl),mk_¶%down%1)
		| "µ" => (µ%down%s_btype (stringl_to_itym sl1)(stringl_to_itym sl),mk_µ)
		| _ => fail "z_schquant_defn" 0 [] ;
	val schquantm = mk_var(znam,zty);	
	val (ty1,ty) = dest_­_type zty;
	val (ty2,ty3) = dest_­_type ty;
	val (p,q) = (mk_Zlvar("p",ty1,[]),mk_Zlvar("q",ty2,[]));
	val lhs = list_mk_app(schquantm,[p,q]); 
	val schty1 = dest_ZpowerT ty3;	
	val x = mk_Zlvar("x",schty1,[]);
	val side_effect = binding_type_spec schty1;
	val(_,projsx) = get_binding_info schty1;
	val xprojs = map (fn f => mk_app(f,x)) projsx;
	val schty2 = mk_ZschemaT(stringl_to_itym sl1);	
	val y = mk_Zlvar("y",schty2,[]);
	val side_effect = binding_type_spec schty2;
	val(_,projsy) = get_binding_info schty2;
	val yprojs = map (fn f => mk_app(f,y)) projsy
	val substm = list_mk_app(p,yprojs);
	val t = mk_Zlvar("t",type_of substm,[]);
	val dandp = list_mk_±(map (fn pr => mk_app(pr,t))get_dpprojs);
	val schty3 = dest_ZpowerT ty2;	
	val side_effect = binding_type_spec schty3;
	val(con,_) = get_binding_info schty3;
	val projs = xprojs @ yprojs;
	val sorted_projs = snd(split(idsetseq_pairs
		(combine (map (dest_ZvarT o type_of) projs) projs)));

	val projtm = list_mk_app(con,sorted_projs);
	val memtm = mk_Z(projtm,q);
	val absttm = mk_Ì(t,mk_±(dandp,memtm));
	val qtm = mktm(y,mk_app(absttm,substm));
	val absxtm = mk_Ì(x,qtm);
	val rhs = match_mk_app(¬$"Z'absð"®,absxtm);
in
	(schquantm,list_mk_µ([p,q],mk_eq(lhs,rhs)))
end;
=TEX
=SML
fun Ûname_to_termprÝ (znam : string):TERM * TERM =
	(case 	dest_Z_name znam of	
	 ("Z'%down%s",[sl]) => z_schema_defn znam sl
	| ("Z'±%down%s",[sl1,sl2]) => z_dysc_defn znam sl1 sl2 "±"
	| ("Z'²%down%s",[sl1,sl2]) =>  z_dysc_defn znam sl1 sl2 "²"
	| ("Z'´%down%s",[sl1,sl2]) =>  z_dysc_defn znam sl1 sl2 "´"
	| ("Z'¤%down%s",[sl1,sl2]) =>  z_dysc_defn znam sl1 sl2 "¤"
	| ("Z'pre%down%s",[sl]) => z_pre_defn znam sl
	| ("Z'ù%down%s",[sl1,sl2]) => z_pro_defn znam sl1 sl2
	| ("Z'\%down%s",[sl1,sl2]) => z_hide_defn znam sl1 sl2
	| ("Z'dec%down%s",[sl,[s]]) =>  z_dec_defn znam sl s
	| ("Z'¶%down%s",[sl1,sl2]) => z_schquant_defn znam sl1 sl2 "¶"
	| ("Z'¶%down%1%down%s",[sl1,sl2]) => z_schquant_defn znam sl1 sl2 "¶%down%1"
	| ("Z'µ%down%s",[sl1,sl2]) => z_schquant_defn znam sl1 sl2 "µ"			
	| _ => fail "name_to_termpr" 47000 [fn () => znam]);

=TEX
If defining theorem required and definition not in place, $z\_const\_spec$ needs to be recursive in order to
ensure that any new constants introduced in the defining term have been defined.
=SML
fun Ûz_const_specÝ (znam : string):unit =
let	val thm_reqd = get_flag"defining_theorem";
	val (ztm,deftm) = name_to_termpr znam
		handle complaint =>
		pass_on complaint "name_to_termpr""z_const_def";
	val side_effect = types_in_zcon_spec (type_of ztm)
		handle complaint =>
		pass_on complaint "types_in_zcon_spec""z_const_def";
in	
	if thm_reqd
	then	
	let	val side_effect = get_defn "-" znam
			handle  Fail _ => const_spec ([znam], [ztm], deftm) 
	in
		()
	end
	else 
		case get_const_type znam  of Value _ => ()
		| _ => (new_const (dest_var ztm);()
		handle complaint =>
		pass_on complaint "new_const""z_const_spec")
end;
=TEX
=SML
fun Ûget_z_const_defnÝ (zcon : TERM):THM =
let	val (znam,zty) = dest_const zcon
	handle complaint =>
		pass_on complaint "dest_const""get_z_const_defn";
	val side_effect = z_const_spec znam
		handle complaint => pass_on complaint "z_const_spec""get_z_const_defn";
	val pzty = case get_const_type znam of 
			Value pzty => pzty
			| _ => fail "get_z_const_defn" 0 []; 
	val tym = type_match zty pzty;
	val thm = get_defn "Z" znam
	handle complaint =>
		pass_on complaint "get_defn""get_z_const_defn";
in	inst_type_rule tym thm
end;
=TEX



\section{END OF STRUCTURE}
The structure is left open.
=SML
end (* end of ZConstants structure *);
open ZConstants;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


A function which maps combine over two lists of lists:
=SML
fun lcombine (a::x)(b::y) =
	(combine a b)::(lcombine x y)
|	lcombine _  _=[];
=TEX
Some(!!) useful terms:
=SML
val d = mk_Zdecl[mk_Zdec([mk_var("a",mk_vartype"X"),mk_var("b",mk_vartype"X")],
	mk_var("S",mk_ZpowerT(mk_vartype"X")))];
val p = mk_eq(mk_var("a",mk_vartype"X"),mk_var("b",mk_vartype"X"));
val schtm = mk_Z%down%s(d,p);
val d' = mk_Zdecl[mk_Zdec([mk_var("c",mk_vartype"X"),mk_var("d",mk_vartype"X")],
	mk_var("S",mk_ZpowerT(mk_vartype"X"))),mk_Zdec([mk_var("h",mk_vartype"Y")],
	mk_var("R",mk_ZpowerT(mk_vartype"Y")))];
val p' = ¬T®;
val schtm' = mk_Z%down%s(d',p');
val d'' =
let 	val X = mk_ZgivenT "X"
	val a = mk_Zlvar("a",X,[]);
	val b = mk_Zlvar("b",X,[]);
	val c = mk_Zlvar("c",X,[]);
in
	mk_Zdecl[mk_Zdec([a,b,c],mk_Zlvar("X",mk_ZpowerT X,[]))]
end;
val d''' = let 	val X = mk_ZgivenT "X"
	val a = mk_Zlvar("a",X,[]);
	val c = mk_Zlvar("c",X,[]);
in
	mk_Zdecl[mk_Zdec([a,c],mk_Zlvar("X",mk_ZpowerT X,[]))]
end;

val d'''' = let 	val X = mk_ZgivenT "X"
	val c' = mk_Zlvar("c'",X,[]);
	val d = mk_Zlvar("d",X,[]);
in
	mk_Zdecl[mk_Zdec([c',d],mk_Zlvar("X",mk_ZpowerT X,[]))]
end;
val d''''' =
let 	val X = mk_ZgivenT "X"
	val d' = mk_Zlvar("d'",X,[]);
	val b = mk_Zlvar("b",X,[]);
	val c = mk_Zlvar("c",X,[]);
in
	mk_Zdecl[mk_Zdec([d',b,c],mk_Zlvar("X",mk_ZpowerT X,[]))]
end;
val d1 =
let 	val Y = mk_ZgivenT "Y";
	val x = mk_Zlvar("x",Y,[]);
	in
	mk_Zdecl[mk_Zdec([x],mk_Zlvar("Y",mk_ZpowerT Y,[]))]
end;
val d2 =
let 	val Y = mk_ZgivenT "Y";
	val X = mk_ZgivenT "X";
	val x = mk_Zlvar("x",Y,[]);
	val y = mk_Zlvar("y",Y,[]);
	val z = mk_Zlvar("z",X,[]);
in
	mk_Zdecl[mk_Zdec([x,y],mk_Zlvar("Y",mk_ZpowerT Y,[])),mk_Zdec([z],mk_Zlvar("X",mk_ZpowerT X,[]))]
end;
val p2 = 
let 	val Y = mk_ZgivenT "Y";
in
	mk_eq(mk_Zlvar("x",Y,[]),mk_Zlvar("y",Y,[]))
end;
val schtm2 = mk_Z%down%s(d2,p2);
val schtm'' = mk_Z%down%s(d'',p');
val schtm''' = mk_Z%down%s(d''',p');
val schtm'''' = mk_Z%down%s(d'''',p');
val schtm''''' = mk_Z%down%s(d''''',p');
val schconjtm = mk_Z±%down%s(schtm,schtm');
val pretm = mk_Zpre%down%s schtm;
val pretm' = mk_Zpre%down%s schtm'';
val pretm'''' = mk_Zpre%down%s schtm'''';
val tm = fst(dest_app schtm);
val tm = fst(strip_app schconjtm);
val schconjtm' = mk_Z±%down%s(schtm',schtm);
val schconjtm'' = mk_Z±%down%s(schtm'',schtm);
val tm = fst(strip_app schconjtm');
val schdisjtm = mk_Z²%down%s(schtm,schtm');
val tm = fst(strip_app schdisjtm);
val schimptm = mk_Z´%down%s(schtm'',schtm);
val tm = fst(strip_app schimptm);
val schifftm = mk_Z¤%down%s(schtm'',schtm');
val tm = fst(strip_app schifftm);
val protm = mk_Zù%down%s(schtm'',schtm''');
val tm = fst(strip_app protm);
val hidtm = mk_Z\%down%s(schtm'',["c"]);
val dectm = mk_Zdec%down%s(schtm'',"!");
val tm = fst(dest_app dectm);
val dectm1 = mk_Zdec%down%s(schtm,"'");
val tm = fst(dest_app dectm1);
val deltm = mk_Z%down%s schtm'';
val tm = fst(dest_app deltm);
val chitm = mk_Z%down%s schtm';
val tm = fst(dest_app chitm);
val scomptm = mk_Z»%down%s (schtm'''',schtm''''');
val tm = fst(strip_app scomptm);
val existm = mk_Z¶%down%s(d''',p',schtm'');
val tm = fst(strip_app existm);
val existm1 = mk_Z¶%down%1%down%s(d''',p',schtm'');
val tm = fst(strip_app existm1);
val existm2 = mk_Z¶%down%s(d1,p',schtm2);
val tm = fst(strip_app existm2);
val d3 =
let 	val X = mk_ZgivenT "X";
	val Y = mk_ZgivenT "Y";
	val x = mk_Zlvar("x",Y,[]);
	val y = mk_Zlvar("y",Y,[]);
	val z = mk_Zlvar("z",X,[]);
in
	mk_Zdecl[mk_Zdec([x,y],mk_Zlvar("Y",mk_ZpowerT Y,[])),mk_Zdec([z],mk_Zlvar("X",mk_ZpowerT X,[]))]
end;
val d4 = 
let 	val Y = mk_ZgivenT "Y";
	val x = mk_Zlvar("x",Y,[]);
in
	mk_Zdecl[mk_Zdec([x],mk_Zlvar("Y",mk_ZpowerT Y,[]))]
end;
val d5 = 
let 	val Y = mk_ZgivenT "Y";
	val y = mk_Zlvar("y",Y,[]);
in
	mk_Zdecl[mk_Zdec([y],mk_Zlvar("Y",mk_ZpowerT Y,[]))]
end;
val d6 = 
let 	val Y = mk_ZgivenT "Y";
	val y = mk_Zlvar("y",Y,[]);
	val X = mk_ZgivenT "X";
	val z = mk_Zlvar("z",X,[]);in
	mk_Zdecl[mk_Zdec([z],mk_Zlvar("X",mk_ZpowerT X,[])),mk_Zdec([y],mk_Zlvar("Y",mk_ZpowerT Y,[]))]
end;
val schtm3  = mk_Z%down%s(d3,p2);
val existm3 = mk_Z¶%down%s(d4,p',schtm3);
val tm = fst(strip_app existm3);
val existm4 = mk_Z¶%down%s(d5,p',schtm3);
val existm5 = mk_Z¶%down%s(d6,p',schtm3);

val foralltm = mk_Zµ%down%s(d''',p',schtm'');
val tm = fst(strip_app foralltm);
val v =
let 	val X = mk_ZgivenT "X"
in	mk_Zlvar("a",X,[])
end;
val setm = mk_Zseta(d'',p,v);
val tm = fst(dest_app setm);
val cptm = 
let 	val PY = mk_ZpowerT(mk_ZgivenT "Y");
	val PX = mk_ZpowerT(mk_ZgivenT "X");
	val x = mk_Zlvar("x",PX,[]);
	val y = mk_Zlvar("y",PY,[]);
in mk_Z¸[x,y]
end;
val tm = fst(strip_app cptm);
val lamtm = mk_ZÌ(d'',p,v);
val tm = fst(dest_app lamtm);
val mutm = mk_ZÍ(d''',p',v);
val tm = fst(dest_app mutm);

=TEX
=SML
val ty = mk_ZschemaT[("a",mk_vartype"Y"),("b",mk_ctype("Z",[mk_vartype"Y"]))];
=TEX
Following function now superceded:
=SML
local
	fun f schty =
	let 	val side_effect = binding_type_spec schty; 
		val tynaml = fst(split(dest_ZschemaT schty));
		val tyvl = map mk_ZvarT tynaml;
	in 	 (mk_ZschemaT(combine tynaml tyvl),tyvl)	
	end;
	fun f1 schty = 
	let	val (ty,tl) = f (dest_ZpowerT schty)
	in	(mk_ZpowerT ty,tl)
	end;
	fun fdp compty tyvl = 
	let 	val schty = last(strip_­_type1 compty);
		val (pschty,_) = f schty;
	in
		list_mk_­_type1 (tyvl @ [schty])
	end;
	fun rep schty 0 = schty
	| rep schty num =
	let 	val schtyl = dest_ZschemaT schty;
		fun change_last tyl 0 = tyl
		| change_last tyl n =
		let 	val (v,ty) = last tyl;
			val frt = front tyl;
		in	(change_last frt (n-1)) @ [(v,mk_ZvarT v)]
		end;
	in 	mk_ZschemaT(change_last schtyl num)
	end;
	fun fdptv compty  n = 
	let 	val comptyl = strip_­_type1 compty;
		val tyvl = int_to_tyvl((length comptyl) - 1);
		val schty = last comptyl;
		val (pschty,_) = f schty;
	in	list_mk_­_type1 (tyvl @ [rep schty n])
	end;
	fun f2 compty = 
	let 	
		val tyl = strip_­_type1 compty;	
	in 	list_mk_­_type1 (fst(split(map f1 tyl)))
	end;
	fun f3 compty =
	let 	
		val (ty1,ty2) = dest_­_type compty;
		val tyl = strip_­_type1 ty2;
		val(x1,x2) = split(map f1 tyl);
		val tyvl = (hd x2) diff (hd(tl x2));
	in 	mk_­_type(fdp ty1 tyvl,list_mk_­_type1 x1)
	end;
	fun f4 setty = 
	let 	val (ty1,ty2) = dest_­_type setty
		val ty2' = mk_ZpowerT(mk_ZvarT"v")
	in
		mk_­_type(fdptv ty1 1,ty2')
	end;
	fun f5 cpty =
	let 	val cptyl = strip_­_type1 cpty;
		val tupty = last cptyl;
		val side_effect = tuple_type_spec tupty;
		val tyvl = int_to_tyvl((length cptyl) - 1);
		val ptyvl = map mk_ZpowerT tyvl;
		val tupty' = mk_ZpowerT(mk_ZtupleT tyvl);
	in
		list_mk_­_type1 (ptyvl @ [tupty'])
	end;
	fun f6 lamty = 
	let 	val (ty1,ty2) = dest_­_type lamty;
		val tupty = mk_ZtupleT[mk_ZvarT"t",mk_ZvarT"v"];
		val side_effect = tuple_type_spec tupty;
		val ty2' = mk_ZpowerT tupty
	in
		mk_­_type(fdptv ty1 2,ty2')
	end;
	fun f7 muty = 
	let 	val (ty1,ty2) = dest_­_type muty;
		val ty2' = mk_ZvarT"v"
	in
		mk_­_type(fdptv ty1 1,ty2')
	end;
in	
fun zconst_spec (tm : TERM):unit =
let 	
	val mode = get_mode();
	val (zcon,zconty) = dest_const tm
		handle complaint => pass_on complaint "dest_const""zconst_spec";
	val (nam, _) = dest_Z_name zcon;
	val side_effect = 
		if mode = 1
		then	case get_const_type zcon of Value _ => ()
			| _ => 
			let	val zty =
					case 	nam of	
					"Z'%down%s" =>
					let 	
						val (ty1,ty2) = dest_­_type zconty;
						val (ty,tyl) = f1 ty2;
					in 	mk_­_type(fdp ty1 tyl,ty)
					end
					| "Z'±%down%s" => f2 zconty
					| "Z'²%down%s" => f2 zconty
					| "Z'´%down%s" => f2 zconty
					| "Z'¤%down%s" => f2 zconty
					| "Z'pre%down%s" => f2 zconty
					| "Z'ù%down%s" => f2 zconty
					| "Z'\%down%s" => f2 zconty
					| "Z'dec%down%s" => 
					let 	
						val (ty1,ty2) = dest_­_type zconty;
						val (ty1',tyvl) = f1 ty1;
						val ty2a = dest_ZpowerT ty2;	
						val side_effect = binding_type_spec ty2a;
						val tynaml = fst(split(dest_ZschemaT ty2a));	
						val ty2' = mk_ZschemaT(combine tynaml tyvl);
					in	mk_­_type(ty1',ty2')
					end
					| "Z'%down%s" => f2 zconty
					| "Z'%down%s" => f2 zconty
					| "Z'»%down%s" => f2 zconty
					| "Z'¶%down%s" => f3 zconty
					| "Z'¶%down%1%down%s" => f3 zconty
					| "Z'µ%down%s" => f3 zconty			
					| "Z'seta" => f4 zconty			
					| "Z'¸" => f5 zconty			
					| "Z'Ì" => f6 zconty			
					| "Z'Í" => f7 zconty			
					| _ => fail "zconst_spec" 47000 [fn () => nam];
			in  (new_const(zcon,zty); ())
			end
		else	case get_defn "Z" nam of _ => ()
			| _ => ()
in () end;
end;
=TEX
=SML
fun Ûget_zconst_defnÝ (tm : TERM): THM =
let	
	val side_effect = zconst_spec tm
		handle complaint => pass_on complaint "zconst_spec""get_zconst_defn";
	val (nam, _) = dest_Z_name zcon;
in
	get_defn "Z" nam
		handle complaint => 
		divert complaint "get_defn""get_zconst_defn" 50007[fn () => nam]
end;
=TEX
$name\_to\_type$ no longer used:
=SML

fun Ûname_to_typeÝ (znam : string):TYPE =
	(case 	dest_Z_name znam of	
	 ("Z'%down%s",[sl]) => schema_btype (stringl_to_itym sl)
	| ("Z'±%down%s",[sl1,sl2]) => bind_dysc_type (stringl_to_itym sl1)(stringl_to_itym sl2)
	| ("Z'²%down%s",[sl1,sl2]) =>  bind_dysc_type(stringl_to_itym sl1)(stringl_to_itym sl2)
	| ("Z'´%down%s",[sl1,sl2]) => bind_dysc_type (stringl_to_itym sl1)(stringl_to_itym sl2)
	| ("Z'¤%down%s",[sl1,sl2]) => bind_dysc_type (stringl_to_itym sl1)(stringl_to_itym sl2)
	| ("Z'pre%down%s",[sl]) => bind_pre_type (stringl_to_itym sl)
	| ("Z'ù%down%s",[sl1,sl2]) => bind_ù_type (stringl_to_itym sl1)(stringl_to_itym sl2)
	| ("Z'\%down%s",[sl1,sl2]) => bind_\_type (stringl_to_itym sl1) sl2
	| ("Z'dec%down%s",[sl,[s]]) =>  bind_decor_type(stringl_to_itym sl) s
	| ("Z'%down%s",[sl]) => bind__type (stringl_to_itym sl)
	| ("Z'%down%s",[sl]) => bind__type (stringl_to_itym sl)
	| ("Z'»%down%s",[sl1,sl2]) => bind_»_type (stringl_to_itym sl1)(stringl_to_itym sl2)
	| ("Z'¶%down%s",[sl1,sl2]) => ¶%down%s_btype (stringl_to_itym sl1)(stringl_to_itym (idsetseq(sl1 @ sl2)))
	| ("Z'¶%down%1%down%s",[sl1,sl2]) => ¶%down%1%down%s_btype (stringl_to_itym sl1)(stringl_to_itym (idsetseq(sl1 @ sl2)))
	| ("Z'µ%down%s",[sl1,sl2]) => µ%down%s_btype(stringl_to_itym sl1)(stringl_to_itym (idsetseq(sl1 @ sl2)))			
	| ("Z'seta",[[s]]) => seta_btype(string_to_itym s)(mk_ZvarT "v")
	| ("Z'¸",[[s]]) => prod_ctype(string_to_styl s)				
	| ("Z'Ì",[[s]]) => Ì_btype(string_to_itym s)(mk_ZvarT "t")(mk_ZvarT "v")			
	| ("Z'Í",[[s]]) => Í_btype(string_to_itym s)(mk_ZvarT "v")			
	| _ => fail "name_to_type" 47000 [fn () => znam]);
=TEX

***Still to do :

	
	| ("Z'seta",[[s]]) => seta_btype(string_to_itym s)(mk_ZvarT "v")
	| ("Z'¸",[[s]]) => prod_ctype(string_to_styl s)				
	| ("Z'Ì",[[s]]) => Ì_btype(string_to_itym s)(mk_ZvarT "t")(mk_ZvarT "v")			
	| ("Z'Í",[[s]]) => Í_btype(string_to_itym s)(mk_ZvarT "v")


