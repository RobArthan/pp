=IGN
********************************************************************************
imp050.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp050.doc %Z% 2004/01/19 12:44:00 1.45 imp050.doc,v
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Implementation of Z Constant Generation}

\def\AbstractText{This document contains the implementation of the dynamic generation of constants generated by the Z Term generator in the Z Proof Support System.}

\def\Reference{DS/FMU/IED/IMP050}

\def\Author{D.J. King, G.M. Prout}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{FST PROJECT}  %% Mandatory field
%% LaTeX2e port: %\TPPvolume{}
%% LaTeX2e port: %\TPPpart{}
%% LaTeX2e port: \TPPtitle{Implementation of Z Constant Generation}  %% Mandatory field
%% LaTeX2e port: \def\TPPheadtitle{Implementation of Z Constant Generation}
%% LaTeX2e port: \TPPref{DS/FMU/IED/IMP050}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{1.45 %
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{\FormatDate{2004/01/19 12:44:00 %
%% LaTeX2e port: }}
%% LaTeX2e port: \TPPstatus{Draft}			%% Mandatory field
%% LaTeX2e port: \TPPtype{SML Literate Script}
%% LaTeX2e port: \TPPkeywords{}
%% LaTeX2e port: %\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
%% LaTeX2e port: \TPPauthors{D.J.~King&WIN01\\G.M.~Prout&WIN01 }
%% LaTeX2e port: \TPPauthorisation{R.D.~Arthan & Project Manager}
%% LaTeX2e port: \TPPabstract{This document contains the implementation of the dynamic generation of constants generated by the
%% LaTeX2e port: Z Term generator in the Z Proof Support System.}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port: 	    Library
%% LaTeX2e port: }}
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 (1992/02/03)]
First draft version.

\item [Issue 1.2 (1992/06/09)]Changed to new fonts.
\item [Issue 1.10 (1992/07/17) (17th July 1992)]
Gave ``caller'' parameter to $local\_labelled\_product\_spec$.
\item [Issue 1.11 (1992/07/20) (20th July 1992)]
Added schema renaming definition mechanism.
Used all in-scope caches for look-up, rather than just current one.
\item [Issue 1.12 (1992/07/20) (21st July 1992)]
Correction to schema renaming definition mechanism.
\item [Issue 1.14 (1992/07/27) (27th July 1992)]
Critical code is now protected by interrupt handling.
\item [Issue 1.20 (1992/08/13) (13th August 1992)]
Corrected error handling for interrupts.
\item [Issue 1.22 (1992/08/21) (21st August 1992)]
First implementation to pass all its module tests.
\item [Issue 1.23 (1992/10/05) (5th October 1992)]
Modifying $local\_...$ to write to current cache theory.
\item [Issue 1.24 (1992/10/15) (15th October 1992)]
Improved error message 50001.
\item [Issue 1.24 (1992/10/15) (20th November 1992)]
Changes in cache theory handling.
\item [Issue 1.25 (1992/11/20) (8th December 1992)]
Fixed consequence of change elsewhere.
\item[Issue 1.27 (1992/12/10) (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.28 (1992/12/18) (18th December 1992)]
Changed generated constant for $»‰s$.
\item[Issue 1.29 (1992/12/18) (18th December 1992)]
Change to $get\_cache\_theories$.
\item[Issue 1.30 (1993/01/08) (8th January 1993)]
Fixed error handling bug in $hide‰s\_gen\_semantic\_const$.
\item[Issue 1.31 (1993/01/11) (8th January 1993)]
Defended functions better against failure with inputs not given
by paragraph processor.
\item[Issue 1.32 (1993/01/19) (19th January 1993)]
Improved error handling of $rename‰s\_gen\_semantic\_const$.
\item[Issue 1.33 (1993/02/10) (10th February 1993)]
Corrected incorrect mapping of $µ‰s$.
\item[Issue 1.34 (1993/08/17) (17th August 1993)]
Now need to turn off type compactification.
\item[Issue 1.35 (1994/05/07) (7th May 1994)]
Added the function $gen\_z\_semantic\_types$ for use by the Z paragraph processor to correct a problem with the performance of type check only mode.
\item[Issue 1.36 (1994/11/02) (2nd Nov 1994)]
Fixed a bug in int\_to\_sl which used to loop endlessly if its argument was zero or negative.
\item[Issue 1.367,1.38 (1995/11/16)] Maintenance.
\item[Issue 1.40 (1997/04/30)]
On doing a forced get of cached theories, now always recheck to see if desired
theorem has come into scope.
\item[Issue 1.41 (1999/02/16)]
Update for SML'97.
\item[Issue 1.42 (2001/08/09)]
Performance improvements.
\item[Issue 1.43 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.44 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.45 (2004/01/19)] The Z universal set is now called ƒ.
\item[Issues 1.46 (2004/07/29), 1.47 (2004/08/04)] Performance enhancements in term generation.
\item[Issue 1.48 (2005/05/17)] Tidied the error handling (and also corrected unintended behaviour in {\em binding\_gen\_semantic\_const}, which should not accept a term variable as an argument).
\item[Issue 1.49 (2005/08/04)] Made schema projection work in the case where the operands have identical signatures.
\item[Issue 1.50 (2005/08/05)] Liberalised schema quantification.
\item[Issue 1.51 (2005/08/09)] Fixed several problems with schema composition.
\item[Issue 1.52 (2006/01/25)] The name of the decoration operator is now based on the stem {\em decor} throughout, rather than {\em decor} in some places and {\em dec} in others.
\item[Issue 1.53 (2006/01/25)] Made it use {\em pack\_ident} throughout when adding decoration to an identifier.
\item[Issue 1.54 (2010/04/01)] Support for empty schemas.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

%%%% END OF CHANGES HISTORY %%%%
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of the
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The detailed design may be found in
\cite{DS/FMU/IED/DTD050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD050}.
\subsubsection{Dependencies}
The semantic constant generation code depends
upon the structures $ZUserInterfaceSupport$ and $ZTypesAndTermsSupport$
described in \cite{DS/FMU/IED/DTD079} and \cite{DS/FMU/IED/DTD048}
respectively.
\subsubsection{Deficiencies}
None Known.

\section{GENERATED CONSTANTS SUPPORT}
=SML
structure ÛZGeneratedConstantsÝ : ZGeneratedConstants = struct
=SML
open ZUserInterfaceSupport ZTypesAndTermsSupport;
=TEX
\subsection{Auxiliary Functions}
=SML
fun Ûint_to_tyvlÝ (n : int) : TYPE list = (
	if n > 0
	then (int_to_tyvl(n - 1)) @ [mk_z_var_type (string_of_int n)]
	else []
);
=TEX
=SML
fun Ûint_to_slÝ (n : int) : string list = (
	if n > 0
	then (int_to_sl(n - 1)) @ [string_of_int n]
	else []
);
=TEX
function to make an ``itym'' from a list of strings:
=SML
fun	Ûstringl_to_itymÝ (sl : string list):(string * TYPE)list =
	combine sl (map mk_z_var_type sl);
=TEX
function to make an ``itym'' from an integer
=SML
fun Ûint_to_itymÝ (1 : int) : (string * TYPE) list =
	[("1", mk_z_var_type "1")]
|	int_to_itym n = (
		let 	val s = string_of_int n
		in	int_to_itym (n - 1) @ [(s,mk_z_var_type s)]
		end);
=TEX
function to make an ``itym'' from a string
=SML
fun Ûstring_to_itymÝ (s : string) : (string * TYPE) list =
	int_to_itym(nat_of_string s);
=TEX
function to make a type list from a string
=SML
fun Ûstring_to_stylÝ (s : string) : TYPE list =
	int_to_tyvl(nat_of_string s);
=TEX
=SML
fun Ûmk_Ý (tm1,tm2) = (
let	val ty = type_of tm1;
	val memconst = mk_const("",mk_­_type(ty,
		mk_­_type(mk_ctype("SET",[ty]),BOOL)));
in
	mk_app (mk_app (memconst, tm1), tm2)
end
	handle ex => reraise ex "mk_"
);
=TEX
=SML
fun Ûmatch_mk_appÝ(ftm:TERM, xtm:TERM) : TERM = (
let	val (fty1,_) = dest_­_type (type_of ftm);
	val tyinsts = type_match (type_of xtm) fty1 ;
in
	mk_app(inst [] tyinsts ftm, xtm)
end
handle complaint =>
list_divert complaint "match_mk_app"
	[("dest_­_type",3006,[fn () => string_of_term ftm]),
	 ("type_match",3005,[fn () => string_of_term ftm,
		fn () => string_of_term xtm])]);
=IGN
match_mk_app(¬Fst®,¬(T,F)®);
=TEX
=SML
fun Ûlist_match_mk_appÝ (f : TERM, (a::rest) : TERM list) : TERM = (
	list_match_mk_app ((match_mk_app (f, a)), rest)
)  | list_match_mk_app (f, []) = f;

=TEX
=SML
fun Ûlist_mk_pairÝ (a, []) = a
  | list_mk_pair (a, b::rest) = mk_pair (a, list_mk_pair (b, rest));
=TEX
=SML
val Ûstrip_typeÝ = hd o rev o strip_­_type;
=TEX
=SML
fun Ûmk_z_univ_declÝ (s,ty) = (
let	val totty = mk_z_power_type ty;
	val tot = mk_const("Totality",totty)
	val U = mk_const("z'ƒ",mk_­_type(mk_z_tuple_type[totty],totty))
in
	mk_z_dec([mk_var(s,ty)],mk_app(U,mk_z_tuple[tot]))
end);

fun Ûmk_z_univ_decl1Ý tm = (
let	val ty = type_of tm;
	val totty = mk_z_power_type ty;
	val tot = mk_const("Totality",totty)
	val U = mk_const("z'ƒ",mk_­_type(mk_z_tuple_type[totty],totty))
in
	mk_z_dec([tm],mk_app(U,mk_z_tuple[tot]))
end);
=TEX
A function which takes a binding type and returns a pair consisting
of the name of the binding type constructor and a list of names of the projections.
=SML
fun Ûbind_con_projÝ(ty:TYPE) =
let	val (sl,tyl) = split(dest_z_schema_type ty)
		handle complaint =>
		divert complaint "dest_z_schema_type" "bind_con_proj" 47050
			[fn () => string_of_type ty];
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val pnaml = map (curry (op ^) nam)  sl;
in
	(cnam,pnaml)
end;
=TEX
A function which takes a tuple type and returns  a pair consisting
of the name of the tuple type constructor and a list of names of the projections.

=SML
fun Ûtuple_con_projÝ(ty:TYPE) =
let	val tyl = dest_z_tuple_type ty
		handle complaint =>
		divert complaint "dest_z_tuple_type" "tuple_con_proj" 47040
			[fn () => string_of_type ty];
	val n = length tyl;
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val isl = int_to_sl n;
	val pnaml = map (curry (op ^) nam)  isl;
in	
	(cnam,pnaml)
end;
=TEX
\subsection{Storing Z Constants}
\subsubsection{Retrieving from Some Cache theory}
The following defends itself against the possibility that the
symbol table function {\it get\_const\_theory} may under rare
circumstances not be in step.
=SML
fun Ûget_cached_defnÝ (nm:string):THM = (
	let	val thy = get_const_theory nm;
	in	get_defn thy nm
	end	handle Fail _ =>
	let	val cs = get_valid_cache_theories();
		fun aux (a :: x) = (get_defn a nm
			handle (Fail _) => aux x)
		| aux [] = fail "get_cached_defn" 0 [];
	in	aux cs
	end
);
=TEX
\subsection{Local Constant Specification Wrappers}
=SML
fun Ûlocal_const_specÝ (caller:string) ((nam, var, defn) : string * TERM * TERM) : THM = (
	get_cached_defn nam
		handle  Fail _ => (
	let	val cct = force_get_cache_theory();
	in
	get_cached_defn nam
		handle  Fail _ => (
	let
		val oldmask = set_int_control("compactification_mask", 63);
		val res = (
		do_in_theory cct
			(pc_rule "hol" const_spec)
			([nam], [var], defn)
		handle ex =>
			(set_int_control("compactification_mask", oldmask);
			reraise ex caller));
	in	set_int_control("compactification_mask", oldmask);
		res
	end)
	end)
);
=TEX
$pc\_rule$ could be replaced by $pending\_push\_pc$ plus wrapping
for more safety.
=TEX
The signature for the next function is the same as that for $labelled\_product\_spec$.
=SML
fun Ûlocal_labelled_product_specÝ (caller : string)
	{tykey: string, labels: (string * TYPE) list, tyname: string,
	tyvars: TYPE list OPT, conname: string, constkeys: string list} : THM = (
	get_cached_defn conname
		handle  Fail _ => (
	let	val cct = force_get_cache_theory() handle (Fail _) => "-";
	in
	get_cached_defn conname
		handle  Fail _ => (
		do_in_theory cct
			labelled_product_spec
			{
				tykey = tykey,
				labels = labels,
				tyname= tyname,
				tyvars = tyvars,
				conname = conname,
				constkeys = constkeys}
		handle ex => reraise ex caller)
	end)
);

=TEX

=TEX
\subsection{Binding Types}
Semantic constants for bindings are stored in a cache theory except for
the empty binding, which is always present in the theory $z\_langauge$.
The empty binding type is checked for to return the theorem
$z'empty\-\_binding\-\_labelled\-\_product\-\_spec$ instead of its definition.
$z'empty\-\_binding\-\_labelled\-\_product\-\_spec$
has a form that is a generalization of the form generated by
$labelled\_product\_spec$, reducing the need for special handling of
the empty binding in proof support.
=SML
local
val z_empty_schema_type = mk_z_schema_type [];
in
fun Ûbinding_type_specÝ (ty : TYPE) : THM =
if ty = z_empty_schema_type
then
	z'empty_binding_labelled_product_spec
else
	let 	
		val (cnam,pnaml) = bind_con_proj ty
			handle complaint =>
			divert complaint "bind_con_proj" "binding_type_spec" 47050
				[fn () => string_of_type ty];
		val (sl,tyl) = split(dest_z_schema_type ty);
		val (nam,tyl) = dest_ctype ty;
		val tyvl = map mk_z_var_type sl;
	in	local_labelled_product_spec "binding_type_spec" {
				tykey = nam,
				labels = combine pnaml tyvl,
				tyname= nam,
				tyvars = Nil,
				conname = cnam,
				constkeys = [cnam] @ pnaml}
	end;
end (* of local ... in ... *);
=TEX
=SML
fun Ûget_binding_infoÝ(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = bind_con_proj ty
		handle complaint =>
		divert complaint "bind_con_proj" "get_binding_info" 47050
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_type ty);
in
	case get_const_type cnam  of Value pty =>
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = map mk_z_var_type sl;	
		val	bty = (hd o rev o strip_­_type) pty;
		val 	ptyl = map (curry mk_­_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end	
	| _ => fail "get_binding_info" 50003 [fn () => cnam]
end;
=TEX
\subsection{Tuple Types}
=SML
fun Ûtuple_type_specÝ (ty : TYPE) : THM =
let 	
	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint =>
		divert complaint "tuple_con_proj" "tuple_type_spec" 47040
			[fn () => string_of_type ty];
	val n = length pnaml;
	val nam = fst(dest_ctype ty);
	val tyvl = int_to_tyvl n;
in	local_labelled_product_spec "tuple_type_spec" {
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml}
end;
=TEX
=SML
fun Ûget_tuple_infoÝ(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint =>
		divert complaint "tuple_con_proj" "get_tuple_info" 47040
			[fn () => string_of_type ty];
	val n = length pnaml;
in
	case get_const_type cnam  of Value pty =>
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = int_to_tyvl n;	
		val 	bty = mk_z_tuple_type tyvl;
		val 	ptyl = map (curry mk_­_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end		| _ => fail "get_tuple_info" 50003 [fn () => cnam]
end;
=TEX
=SML
fun Ûgen_z_semantic_typeÝ (ety : Unification.EXTYPE) : unit = (
	case ety of
		Unification.ExType(tycon, eargs) => (
			(force_value (get_type_arity tycon); ())
			handle Fail _ => (
				let	val args = map (fn _ => mk_vartype "'a") eargs;
					val ty = mk_ctype(tycon, args);
				in	(binding_type_spec ty; ())
					handle Fail _ => (
						(tuple_type_spec ty; ()) handle Fail _ =>()
					)
				end
			)
	) |	_ => ()
);
=TEX

\section{Z CONSTANT DEFINITION GENERATION}\label{ZCONST}
\subsection{Tuples}
=IGN
val tm = mk_z_tuple[ñ1®,ñ2®];
=SML
fun Ûtuple_gen_semantic_constÝ (tm : TERM) : THM = (
	let	val ty = (hd o rev o strip_­_type o
			snd o dest_const o fst o strip_app) tm
			handle Fail _ =>
			term_fail "tuple_gen_semantic_const"
			50001 [tm];
	in	tuple_type_spec ty
		handle ex as (Fail _) =>
		reraise ex "tuple_gen_semantic_const"
	end
);
=TEX
\subsection{Set Abstraction}
=IGN
val tm = mk_z_seta (mk_z_decl [mk_z_dec([¬a:ú®],ñú®)], mk_z_true, ñ[a,b,c:ú]®);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Seta",[[sn]], Nil) = dest_z_name nam;
=SML
fun Ûseta_gen_semantic_constÝ (tm : TERM) : THM = (
let	val nam = fst (dest_const (fst (strip_app tm)))
	handle Fail _ => term_fail "seta_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'Seta", [[sn]], Nil) => (get_cached_defn nam
		handle Fail _ => (
		let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "seta_gen_semantic_const" 50001 [tm];
			val tyv = mk_z_var_type "v";
			val dpvty = mk_z_schema_type [("d", BOOL),("p", BOOL),("v", tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon, dpvprojs) = get_binding_info dpvty;
			val resty = mk_z_power_type tyv;
			val argty = list_mk_­_type (tyvl@[dpvty]);
			val cvar = mk_var(nam, mk_­_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s)))
				(map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_­_type (tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_¶ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "seta_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "seta_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Ì Abstraction}
=IGN
val tm = mk_z_Ì (mk_z_decl([mk_z_dec([¬a:ú®],ñú®)]), mk_z_true, ñ[a,b,c:ú]®);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Ì",[[sn]], Nil) = dest_z_name nam;
=SML
fun	ÛÌ_gen_semantic_constÝ (tm : TERM) : THM = (
let	val nam = fst(dest_const (fst (strip_app tm)))
	handle Fail _ => term_fail "Ì_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'Ì",[[sn]], Nil) => (get_cached_defn nam
		handle Fail _ => (
		let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "Ì_gen_semantic_const" 50001 [tm];
			val tyv = mk_z_var_type "v";
			val tyt = mk_z_var_type "t";
			val dptvty = mk_z_schema_type[("d",BOOL),("p",BOOL),("t",tyt),("v",tyv)];
			val side = binding_type_spec dptvty;
			val (dptvcon,dptvprojs) = get_binding_info dptvty;
			val resty = mk_z_power_type(mk_z_tuple_type[tyt,tyv]);
			val argty = list_mk_­_type(tyvl@[dptvty]);
			val cvar = mk_var(nam,mk_­_type(argty,resty));
			val x = mk_var("x",mk_z_tuple_type[tyt,tyv]);
			val side = tuple_type_spec(type_of x);
			val (_,xprjs) = get_tuple_info(type_of x);
			val anaml = map (fn s => implode("a" :: tl(explode s)))
				(map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_­_type(tyvl@[dptvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dptvprojs;
			val pred = list_mk_± ([hd projs,hd(tl projs)] @
				(map mk_eq (combine (projs from 2)
					((map (fn y => match_mk_app(y,x))
						xprjs)))));
			val exists = list_mk_¶ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "Ì_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "Ì_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Definite Description}
=IGN
val tm = mk_z_Í (mk_z_decl [mk_z_dec([¬a:ú®],ñú®)], mk_z_true, ñ[a,b,c:ú]®);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Í",[[sn]], Nil) = dest_z_name nam;
=SML
fun ÛÍ_gen_semantic_constÝ (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)))
	handle Fail _ => term_fail "Í_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'Í",[[sn]], Nil) => (get_cached_defn nam
		handle (Fail _) => (
		let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "Í_gen_semantic_const" 50001 [tm];
			val tyv = mk_z_var_type "v";
			val dpvty = mk_z_schema_type[("d",BOOL),("p",BOOL),("v",tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon,dpvprojs) = get_binding_info dpvty;
			val resty = tyv;
			val argty = list_mk_­_type(tyvl@[dpvty]);
			val cvar = mk_var(nam,mk_­_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s)))
				(map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_­_type(tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_¶ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val desc = mk_app(mk_const("Z'Í",
				mk_­_type(mk_ctype("SET",[tyv]),tyv)),
				setcomp);
			val exists = list_mk_¶ (al, pred);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,desc);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "Í_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "Í_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Cartesian Products}
=IGN
val tm = mk_z_¸ [ñú®,ñú®];
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'¸",[[sn]], Nil) = dest_z_name nam;
=SML
fun Û¸_gen_semantic_constÝ (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)))
	handle Fail _ => 	term_fail "¸_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'¸",[[sn]], Nil) => (get_cached_defn nam
		handle Fail _ => (
		let	val aty = dest_z_power_type(type_of tm)
				handle (Fail _) =>
				term_fail "¸_gen_semantic_const" 50001 [tm];
			val (tnam, ttyl) = dest_ctype aty;
			val bty = mk_ctype (tnam, int_to_tyvl (length ttyl));
			val tyvl = dest_z_tuple_type bty;
			val side = tuple_type_spec(mk_z_tuple_type tyvl);
			val (con,projs) = get_tuple_info (mk_z_tuple_type tyvl);
			val resty = mk_z_power_type bty;
			val argty = list_mk_­_type ((map mk_z_power_type tyvl)@[resty]);
			val cvar = mk_var(nam, argty);
			val args = (map (fn (id,ty) => mk_var("X"^id, mk_z_power_type ty))
				(string_to_itym sn))
				handle (Fail _) =>
				term_fail "¸_gen_semantic_const" 50001 [tm];

			val t = mk_var("t",bty);
			val comps = combine projs args;
			val conjl = map	(fn (p,a) => mk_z_(
				match_mk_app(p,t), a))
				comps;
			val conj = list_mk_± conjl;
			val setcomp = mk_set_comp (t, conj);
			val lhs = list_mk_app(cvar, args);
			val body = mk_eq(lhs, setcomp);
			val defn = list_mk_µ (args, body);
		in
			local_const_spec "¸_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "¸_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Binding Display}
=IGN
val tm = mk_z_binding [("x", ñ1®), ("y",ñ2®)];
=SML
fun Ûbinding_gen_semantic_constÝ (tm : TERM) : THM = (
	let	fun chk_const c_tm = (
			dest_const c_tm;
			c_tm
		);
		val ty =	(hd o rev o strip_­_type
			o type_of o chk_const o fst o strip_app) tm
		handle Fail _ =>
		term_fail "binding_gen_semantic_const"
		50001 [tm];
	in	binding_type_spec ty
		handle ex as (Fail _) =>
		reraise ex "binding_gen_semantic_const"
	end
);
=TEX
\subsection{Unique Existential Quantification}
=IGN
val tm = mk_z_¶‰1 (mk_z_decl [mk_z_dec([¬a:ú®],ñú®)], mk_z_true, mk_z_true);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'¶‰1",[[sn]], Nil) = dest_z_name nam;
=SML
fun Û¶‰1_gen_semantic_constÝ (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)))
	handle Fail _ => 	term_fail "¶‰1_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'¶‰1",[[sn]], Nil) => (get_cached_defn nam
	handle Fail _ => (
	let	val tyvl = string_to_styl sn
				handle (Fail _) =>
				term_fail "¶‰1_gen_semantic_const" 50001 [tm];
		val tyv = BOOL;
		val dpvty = mk_z_schema_type[("d",BOOL),("p",BOOL),("v",tyv)];
		val side = binding_type_spec dpvty;
		val (dpvcon,dpvprojs) = get_binding_info dpvty;
		val resty = BOOL;
		val argty = list_mk_­_type(tyvl@[dpvty]);
		val cvar = mk_var(nam,mk_­_type(argty,resty));
		val anaml = map (fn s => implode("a" :: tl(explode s)))
			(map dest_vartype tyvl);
		val al = map mk_var (combine anaml tyvl);
		val pack = mk_var("pack",list_mk_­_type(tyvl@[dpvty]));
		val pack_al = list_mk_app (pack, al);
		val t = mk_var("t",type_of pack_al);
		val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
		val pred = list_mk_± projs;
		val abs_pred = mk_Ì(t,pred);
		val abs_pred_pack_al = mk_app(abs_pred,pack_al);
		val exists = case al of
			a1::arest	=>
				let
					val alt = list_mk_pair (a1, arest);
				in
					mk_¶‰1 (alt, abs_pred_pack_al)
				end
		|	[]		=> abs_pred_pack_al;
		val lhs = mk_app(cvar,pack);
		val body = mk_eq(lhs,exists);
		val defn = mk_µ(pack,body);
	in
		local_const_spec "¶‰1_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "¶‰1_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Constructor}
=IGN
val tm = mk_z_h_schema (mk_z_decl [mk_z_dec([¬a:ú®, ¬b:ú®],ñú®)], mk_z_true);
val nam = (fst(dest_const (fst (strip_app tm))));
val ("Z'‰s",[cpl], Nil) = dest_z_name nam;

=SML
fun Ûschema_gen_semantic_constÝ (tm:TERM) : THM = (
let	val nam = (fst(dest_const (fst (strip_app tm))))
	handle Fail _ => 	term_fail "schema_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'‰s",[cpl], Nil) => (get_cached_defn nam
	handle (Fail _) => (
	let	val ty = dest_z_power_type(type_of tm)
			handle (Fail _) =>
			term_fail "schema_gen_semantic_const" 50001 [tm];
		val tyvl = map mk_z_var_type cpl;
		val dpty = mk_z_schema_type[("d",BOOL),("p",BOOL)];
		val side = binding_type_spec dpty;
		val (dpcon,dpprojs) = get_binding_info dpty;
		val side = binding_type_spec ty;
		val (con,projs) = get_binding_info ty;
		val bty = (strip_type o type_of) con;
		val argty = list_mk_­_type(tyvl@[dpty]);
		val resty = mk_z_power_type bty;
		val cvar = mk_var(nam,mk_­_type(argty,resty));
		val x = mk_var("x",bty);
		val p = mk_var("p",argty);
		val t = list_match_mk_app(p,map (fn pr => match_mk_app(pr,x)) projs);
		val conj = list_mk_±(map (fn pr => match_mk_app(pr,t)) dpprojs);
		val setcomp = mk_set_comp (x, conj);
		val lhs = mk_app(cvar, p);
		val body = mk_eq(lhs, setcomp);
		val defn = mk_µ (p, body);
	in
		local_const_spec "schema_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "schema_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Decoration}
=IGN
val tm = mk_z_decor‰s(ñ[x,y,xy:ú]®,"''");
val tm' = fst (strip_app tm);
val nam = (fst(dest_const tm'));
val ("Z'Decor‰s",[cpl,decor], Nil) = dest_z_name nam;
=SML
fun Ûdecor‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = (fst(dest_const tm'))
	handle Fail _ => 	term_fail "decor‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'Decor‰s",[cpl,decor], Nil) => (get_cached_defn nam
	handle Fail _ => (
	let	val (rargty,rresty) = (
			case strip_­_type(type_of tm') of [ty1,ty2] =>
			(dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "decor‰s_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty;
		val (con,proj) = get_binding_info rargty;
		val side = binding_type_spec rresty;
		val (con',proj') = get_binding_info rresty;
		val bty = (strip_type o type_of) con;
		val resty = (strip_type o type_of) con';
		val tym = dest_z_schema_type bty;
		val tym' = dest_z_schema_type resty;
		val rbty = mk_z_schema_type(combine (fst(split tym')) (snd(split tym)));
		val sch = mk_var("sch",mk_z_power_type bty);
		val sch' = mk_var("sch",mk_z_power_type rbty);
		val bvar = mk_var ("bind", bty);
		val bdecvar = mk_var ("bind'", rbty);
		val bmem = mk_ (bvar, sch);
		val varl = map ((switch o curry) match_mk_app bvar) proj;
		val bind = (list_match_mk_app (con', varl));
		val bdeceq = mk_eq(bdecvar,bind);
		val pred = mk_± (bmem, bdeceq);
		val cvar = mk_var(nam, mk_­_type(type_of sch,type_of sch'));
		val exists = mk_¶(bvar, pred);
		val setcomp = mk_set_comp(bdecvar,exists);
		val lhs = mk_app(cvar, sch);
		val body = mk_eq(lhs, setcomp);
		val defn = mk_µ (sch, body);
		in
			local_const_spec "decor‰s_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => term_fail "decor‰s_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Precondition}
=IGN
val tm = mk_z_pre‰sñ[a',b',c:ú]®;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Pre‰s",[cpl], Nil) = dest_z_name nam;
=SML
fun Ûschema_resultsÝ (itym:((string*string) * TYPE)list) =
	(map fst itym) drop (fn (_,d) => (not(d = "'") andalso not(d = "!")));
=TEX
=SML
fun Ûpre‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "pre‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'Pre‰s",[cpl], Nil) => (get_cached_defn nam
	handle Fail _ => (
	let	val (rargty,rresty) = (
		case strip_­_type(type_of tm') of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "pre‰s_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty;
		val (con, _) = get_binding_info rargty;
		val bty = (strip_type o type_of) con;
		val atym = dest_z_schema_type bty;
		val aidtym = map (fn (s,t) => (unpack_ident s,t)) atym;
		val hidtym = map (fn x => (x,lassoc3 aidtym x)) (schema_results aidtym);
		val htym = map (fn (s,t) => (pack_ident s,t)) hidtym;
		val rtym = (op diff') (atym, htym);
		val side = binding_type_spec(mk_z_schema_type rtym);
		val argty = mk_z_power_type(mk_z_schema_type atym);
		val resty = mk_z_power_type(mk_z_schema_type rtym);
		val cvar = mk_var(nam,mk_­_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl(map mk_z_univ_decl rtym);
		val pd = mk_z_decl(map mk_z_univ_decl htym);
		val p = mk_z_¶(pd,mk_z_true,mk_z_schema_pred(s,""));
		val sch = mk_z_h_schema(d,p);
		val dummy = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs, sch);
		val defn = mk_µ (s, body);
	in
		local_const_spec "pre‰s_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "pre‰s_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Hiding}
=IGN
val tm = mk_z_hide‰s (ñ[a,b,c:ú]®, ["c"]);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Hide‰s",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun Ûhide‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "hide‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'Hide‰s",[cpl1,cpl2], Nil) => (get_cached_defn nam
	handle Fail _ => (
	let	val (rargty,rresty) = (
		case (strip_­_type(type_of tm')) of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "hide‰s_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (con,_) = get_binding_info rargty;
		val bty = (strip_type o type_of) con;
		val tym = dest_z_schema_type bty;
		val rtym = map (fn s => (s,lassoc3 tym s)) (cpl1 diff cpl2);
		val htym = map (fn s => (s,(lassoc3 tym s
			handle complaint =>
			divert complaint "lassoc3" "hide‰s_gen_semantic_const"
			50004 [fn () => s, fn () => string_of_term tm]))) cpl2;
		val argty = mk_z_power_type bty;
		val resty = mk_z_power_type(mk_z_schema_type(rtym));
		val cvar = mk_var(nam,mk_­_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl(map mk_z_univ_decl rtym)
		val pd = mk_z_decl(map mk_z_univ_decl htym);
		val p = mk_z_¶(pd,mk_z_true,mk_z_schema_pred(s,""));
		val sch = mk_z_h_schema(d,p);
		val dummy = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs, sch);
		val defn = mk_µ (s, body);
	in
		local_const_spec "hide‰s_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "hide‰s_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Dyadic Operators}
=IGN
val schexpr = fst o dest_z_schema_dec o
		hd o dest_z_decl o
		fst o dest_z_h_schema;
val tm = mk_z_±‰s (ñ[a,b,c:ú]®, ñ[d:ú]®);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val (oper,[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun Ûdyop‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "dyop‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	(oper,[cpl1,cpl2], Nil) => (get_cached_defn nam
	handle Fail _ => (
	let	val (ra1ty,ra2ty,rresty) = (
			case strip_­_type(type_of tm') of
			[ty1,ty2,ty3] => (dest_z_power_type ty1,dest_z_power_type ty2,
						dest_z_power_type ty3)
			|_ => term_fail "dyop‰s_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec ra1ty;
		val side = binding_type_spec ra2ty;
		val side = binding_type_spec rresty;
		val (cona1,proja1) = get_binding_info ra1ty;
		val (cona2,proja2) = get_binding_info ra2ty;
		val (conr,projr) = get_binding_info rresty;
		val rbty = (strip_type o type_of) conr;
		val tym = map 	(fn(s,ty) => (s,mk_vartype((dest_vartype ty) ^ "a")))
					(dest_z_schema_type rbty);
		val tym1 = combine cpl1 (map (fn s => (lassoc3 tym s
			handle complaint => divert complaint
			"lassoc3" "dyop‰s_gen_semantic_const" 50006
			[fn () => s, fn () => string_of_term tm])) cpl1);
		val tym2 = combine cpl2 (map (fn s => (lassoc3 tym s
			handle complaint => divert complaint
			"lassoc3" "dyop‰s_gen_semantic_const" 50006
			[fn () => s, fn () => string_of_term tm])) cpl2);
		val a1bty = mk_z_schema_type tym1;
		val a2bty = mk_z_schema_type tym2;
		val rbty' = mk_z_schema_type tym;
		val sch1 = mk_var("sch1",mk_z_power_type a1bty);
		val sch2 = mk_var("sch2",mk_z_power_type a2bty);
		val sch = mk_var("sch",mk_z_power_type rbty');
		val bvar = mk_var ("bind", rbty');
		fun dopr pr =
		let	val tup = (map (fn x=>((dest_z_name
				o fst o dest_const) x,x)) pr);
		in
			map (fn ((_,_, x), y)=>(x,y)) tup
		end;
		val pr1 = map snd ((dopr projr) drop (fn (x,_) =>
			not(x mem (map fst (dopr proja1)))));
		val pr2 = map snd ((dopr projr) drop (fn (x,_) =>
			not(x mem (map fst (dopr proja2)))));
		val varl1 = map ((switch o curry) match_mk_app bvar) pr1;
		val varl2 = map ((switch o curry) match_mk_app bvar) pr2;
		val memb1 = mk_(list_match_mk_app (cona1, varl1),sch1);
		val memb2 = mk_(list_match_mk_app (cona2, varl2),sch2);
		val desc = (
			case oper of 	"Z'±‰s" => mk_±(memb1,memb2)
			|		"Z'²‰s" => mk_²(memb1,memb2)
			|		"Z'´‰s" => mk_´(memb1,memb2)
			|		"Z'¤‰s" => mk_¤(memb1,memb2)
			|		_ => term_fail "dyop‰s_gen_semantic_const" 50001 [tm]
			);
		val setcomp = mk_set_comp (bvar, desc);
		val cvar = mk_var(nam,list_mk_­_type([type_of sch1,type_of sch2,
			type_of sch]));
		val lhs = list_mk_app(cvar, [sch1, sch2]);
		val body = mk_eq(lhs,setcomp);
		val defn = list_mk_µ ([sch1,sch2], body);
	in
		local_const_spec "dyop‰s_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "dyop‰s_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Projection}
=IGN
val tm = mk_z_ù‰s (ñ[a,b,c:ú]®, ñ[b:ú]®);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'ù‰s",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun Ûù‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "ù‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'ù‰s",[cpl1,cpl2], Nil) => (get_cached_defn nam
	handle Fail _ => (
	let	val (rargty1,rargty2,rresty) = (
		case (strip_­_type(type_of tm')) of
			[ty1,ty2,ty3] => (
				(dest_z_power_type ty1,dest_z_power_type ty2,
					dest_z_power_type ty3)
				)
			|_ => term_fail "ù‰s_gen_semantic_const" 50001 [tm]
			);
		val side = binding_type_spec rargty1;
		val side = binding_type_spec rargty2;
		val tym = combine (cpl1 cup cpl2) (map mk_z_var_type(cpl1 cup cpl2));
		val argty1 = mk_z_power_type(mk_z_schema_type(map (fn s =>
			(s,lassoc3 tym s)) cpl1));
		val argty2 = mk_z_power_type(mk_z_schema_type(map (fn s =>
			(s,lassoc3 tym s)) cpl2));
		val resty = argty2;
		val cvar = mk_var(nam,list_mk_­_type([argty1,argty2,resty]));
		val s1 = mk_var("sch1",argty1);
		val s2 = mk_var("sch2",argty2);
		val hidel = cpl1 diff cpl2;
		val schand = mk_z_±‰s(s1,s2);
		val dummy = dyop‰s_gen_semantic_const schand;
		val sch = case hidel of
			_::_ => (
				let	val sch = mk_z_hide‰s(schand,hidel);
				in	hide‰s_gen_semantic_const sch;
					sch
				end
		) |	[] => schand;
		val lhs = list_mk_app(cvar, [s1,s2]);
		val body = mk_eq(lhs, sch);
		val defn = list_mk_µ ([s1,s2], body);
	in
		local_const_spec "ù‰s_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "ù‰s_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Delta Constructor}
=IGN
val tm = mk_z_„‰s ñ[a,b,c:ú]®;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'„‰s",[cpl], Nil) = dest_z_name nam;
=SML
fun Û„‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "„‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'„‰s",[cpl], Nil) => (get_cached_defn nam
	handle (Fail _) => (
	let	val (rargty,rresty) = (
			case strip_­_type(type_of tm') of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "„‰s_gen_semantic_const" 50001 [tm]
			);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (cona,_) = get_binding_info rargty;
		val (conr,_) = get_binding_info rresty;
		val bty = (strip_type o type_of) cona;
		val rbty = (strip_type o type_of) conr;
		val tym = dest_z_schema_type bty;
		val tym' = map (fn(s,ty) => ((pack_ident(s, "'")),ty)) tym;
		val argty = mk_z_power_type(mk_z_schema_type tym);
		val resty = mk_z_power_type(mk_z_schema_type(tym @ tym'));
		val cvar = mk_var(nam,mk_­_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl[mk_z_schema_dec(s,""),mk_z_schema_dec(s,"'")];
		val p = mk_z_true;
		val sch = mk_z_h_schema(d,p);
		val side = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs,sch);
		val defn = mk_µ(s,body);
	in
		local_const_spec "„‰s_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "„‰s_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Xi Constructor}
=IGN
val tm = mk_z_˜‰sñ[a,b,c:ú]®;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'˜‰s",[cpl], Nil) = dest_z_name nam;
=SML
fun Û˜‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "˜‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'˜‰s",[cpl], Nil) => (get_cached_defn nam
	handle (Fail _) => (
	let	val (rargty,rresty) = (
			case strip_­_type(type_of tm') of
			[ty1,ty2] => (dest_z_power_type ty1,dest_z_power_type ty2)
			|_ => term_fail "˜‰s_gen_semantic_const" 50001 [tm]
			);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (cona,_) = get_binding_info rargty;
		val (conr,_) = get_binding_info rresty;
		val bty = (strip_type o type_of) cona;
		val rbty = (strip_type o type_of) conr;
		val tym = dest_z_schema_type bty;
		val tym' = map (fn(s,ty) => (pack_ident(s, "'"),ty)) tym;
		val argty = mk_z_power_type(mk_z_schema_type tym);
		val resty = mk_z_power_type(mk_z_schema_type(tym @ tym'));
		val cvar = mk_var(nam,mk_­_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl[mk_z_schema_dec(s,""),mk_z_schema_dec(s,"'")];
		val p = mk_z_eq(mk_z_Ê(s,""),mk_z_Ê(s,"'"));
		val sch = mk_z_h_schema(d,p);
		val side = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq (lhs, sch);
		val defn = mk_µ(s, body);
	in
		local_const_spec "˜‰s_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "˜‰s_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Quantification}
=SML
fun sort_projs (pr : TERM list) : TERM list = (
let	val pr' = map (fn p => (snd(dest_z_sel‰s p), p)) pr;
	fun rsort (s1,_) (s2,_) = z_sig_order s1 s2;
in
	map snd (Sort.sort rsort pr')
end);
=TEX

=IGN
val tm = mk_z_µ‰s (mk_z_decl [mk_z_dec([¬a:ú®],ñú®)], mk_z_true, ñ[a,b,c:ú]®);
val tm = mk_z_¶‰s (mk_z_decl [mk_z_dec([¬a:ú®],ñú®)], mk_z_true, ñ[a,b,c:ú]®);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val (oper,[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun Ûquant‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "quant‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	(oper,[cpl1,cpl2], Nil) => (get_cached_defn nam
	handle (Fail _) => (
	let	val (rargty1,rargty2,rresty) = (
			case (strip_­_type(type_of tm')) of
			[ty1,ty2,ty3] => (ty1,dest_z_power_type ty2,dest_z_power_type ty3)
			|_ => term_fail "quant‰s_gen_semantic_const" 50001 [tm]
			);
		val str_rargty1 = strip_­_type rargty1;
		val sdp = hd(rev str_rargty1);
		val side = binding_type_spec sdp;
		val (_,tprojs) = get_binding_info sdp;
		val op1_ty = mk_z_schema_type (
			combine cpl1 (rev(tl(rev str_rargty1))))
			handle Fail _ =>
			term_fail "quant‰s_gen_semantic_const" 50001 [tm];
		val side = binding_type_spec op1_ty;
		val (c1,_) = get_binding_info op1_ty;
		val bty1 = (strip_type o type_of) c1;
		val tym1 = dest_z_schema_type bty1;
		val side = binding_type_spec rargty2;
		val (con,_) = get_binding_info rargty2;
		val side = binding_type_spec rresty;
		val (_,xprojs) = get_binding_info rresty;
		val bty2 = (strip_type o type_of) con;
		val tym2 = dest_z_schema_type bty2;
		val argty1 = list_mk_­_type((map
			(fn s => (lassoc3 tym2 s
			handle ex as Fail _ =>
			lassoc3 tym1 s
			handle ex as Fail _ =>
			divert ex "lassoc3" "quant‰s_gen_semantic_const" 50005
			[fn () => s, fn () => string_of_term tm])) cpl1)@[sdp]);
		val argty2 = mk_z_power_type(mk_z_schema_type tym2);
		val res_cpl = cpl2 diff cpl1;
		val resty = mk_z_power_type(mk_z_schema_type(map (fn s =>
			(s,lassoc3 tym2 s)) res_cpl));
		val ybty = mk_z_schema_type tym1;
		val side = binding_type_spec ybty;
		val (_,yprojs) = get_binding_info ybty;
		val cvar = mk_var(nam,list_mk_­_type
			([argty1,argty2,resty]));
		val p = mk_var("p",argty1);
		val q = mk_var("q",argty2);
		val x = mk_var("x",dest_z_power_type resty);
		val y = mk_var("y",ybty);
		val xprojections = map (fn f => match_mk_app(f,x)) xprojs;
		val yprojections = map (fn f => match_mk_app(f,y)) yprojs;
		val yprojections2 = yprojections drop
			(fn t => not(snd(dest_z_sel‰s t) mem cpl2));
		val projections = xprojections @ yprojections2;
		val sorted_projections = sort_projs projections;
		val t = list_mk_app (p, yprojections);
		val conj1 = list_mk_±(map (fn pf => match_mk_app(pf,t)) tprojs);
		val conj2 = mk_(list_match_mk_app (con, sorted_projections),q);
		val pred = (
			case oper of
				"Z'µ‰s" => mk_´(conj1,conj2)
			|	"Z'¶‰s" => mk_±(conj1,conj2)
			|	"Z'¶‰1‰s" => mk_±(conj1,conj2)
			|	_ => term_fail "quant‰s_gen_semantic_const" 50001 [tm]
		);
		val desc = (
			case yprojs of
				[]	=> pred
			|	_::_	=> (
				case oper of
					"Z'µ‰s" => mk_µ(y,pred)
				|	"Z'¶‰s" => mk_¶(y,pred)
				|	"Z'¶‰1‰s" => mk_¶‰1(y,pred)
				|	_ => term_fail "quant‰s_gen_semantic_const" 50001 [tm]
			)
		);
		val setcomp = mk_set_comp(x,desc);
		val lhs = list_mk_app (cvar, [p,q]);
		val body = mk_eq(lhs, setcomp);
		val defn = list_mk_µ ([p, q], body);
	in
		local_const_spec "quant‰s_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => term_fail "quant‰s_gen_semantic_const" 50001 [tm]
end);
=TEX
\subsection{Schema Composition}
=IGN
val tm = mk_z_»‰s (ñ[x,b,c,d':X]®, ñ[d:X;e:Y]®);
val tm = mk_z_»‰s (ñ[qq',b,c,d':X]®, ñ[qq,d:X;e:Y]®);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'»‰s",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun give_n_names nn lst = (
=SMLLITERAL
let	fun nextn n = (let val poss = "x" ^ string_of_int n
=SML
		in
		if poss mem lst
		then nextn (n+1)
		else (n,poss)
		end);
	fun nextnm 0 m = []
	| nextnm n m = (let val (ind,next) = nextn m
		in
		(next :: nextnm (n-1) (ind+1))
		end)
in
	nextnm nn 1
end);

=TEX
=SML
fun Û»‰s_gen_semantic_constÝ (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm')
	handle Fail _ => 	term_fail "»‰s_gen_semantic_const" 50001 [tm];
in
	case dest_z_name nam of
	("Z'»‰s",[cpl1,cpl2], Nil) => (get_cached_defn nam
	handle (Fail _) => (
	let	val (rargty1,rargty2,rresty) = (
			case strip_­_type(type_of tm') of
			[ty1,ty2,ty3] => (dest_z_power_type ty1,
					dest_z_power_type ty2,dest_z_power_type ty3)
			|_ => term_fail "»‰s_gen_semantic_const" 50001 [tm]);
		val side = binding_type_spec rargty1;
		val side = binding_type_spec rargty2;
		val side = binding_type_spec rresty;
		val (conr,_) = get_binding_info rresty;
		val rbty = (strip_type o type_of) conr;
		val rcpl = map fst (dest_z_schema_type rbty);
		fun mk_mcpls acc acc' (n2::ns2) = (
			let	val n2' = n2 ^ "'";
			in	if	n2' mem cpl1
			then	mk_mcpls (n2::acc) (n2'::acc') ns2
			else	mk_mcpls acc acc' ns2
			end
		) | mk_mcpls acc acc' [] = (acc, acc');
		val (mcpl,mcpl') = mk_mcpls [] [] cpl2;
		val rtyvars = map mk_z_var_type rcpl;
		val mtyvars = map mk_z_var_type mcpl;
		val rtym = combine rcpl rtyvars;
		val mtym = combine mcpl mtyvars;
		val mtym' = combine mcpl' mtyvars;
		val alist1 = (mtym' @ rtym);
		val alist2 = (mtym @ rtym);
		val a1tym = map (fn s => (s,(lassoc3 alist1 s
			handle complaint => divert complaint
			"lassoc3" "»‰s_gen_semantic_const" 50006
			[fn () => s, fn () => string_of_term tm]))) cpl1;
		val a2tym = map (fn s => (s,(lassoc3 alist2 s
			handle complaint => divert complaint
			"lassoc3" "»‰s_gen_semantic_const" 50006
			[fn () => s, fn () => string_of_term tm]))) cpl2;
		val a1 = map mk_var a1tym;
		val a2 = map mk_var a2tym;
		val argty1 = mk_z_power_type(mk_z_schema_type a1tym);
		val argty2 = mk_z_power_type(mk_z_schema_type a2tym);
		val resty = mk_z_power_type(mk_z_schema_type rtym);
		val cvar = mk_var(nam,list_mk_­_type([argty1,argty2,resty]));
		val s1_poss = mk_var("sch1",argty1);
		val s2_poss = mk_var("sch2",argty2);
		val (s1,s2) = case list_variant (a1 @ a2) [s1_poss, s2_poss] of
			[s1,s2] => (s1,s2)
			| _ => error "»‰s_gen_semantic_const" 50003 [fn () => string_of_term tm];
		val mreplaces_nms = give_n_names (length  mcpl)
			(cpl1 @ cpl2);
		val mreplaces = map mk_var(combine mreplaces_nms mtyvars);
		val sch1_trans = (map (fn (nm,ty) => (nm,mk_var(nm,ty))) a1tym)
						list_overwrite (combine mcpl' mreplaces);
		val sch2_trans = (map (fn (nm,ty) => (nm,mk_var(nm,ty))) a2tym)
						list_overwrite (combine mcpl mreplaces);

		val bind1 = mk_z_binding sch1_trans; (* semantic const already in place *)
		val bind2 = mk_z_binding sch2_trans;
		val inner_tm = mk_z_±(mk_z_(bind1, s1), mk_z_(bind2,s2));
		val ¶_tm = mk_z_¶(mk_z_decl (map mk_z_univ_decl1 mreplaces), mk_z_true, inner_tm);
		val rest = ((rev(frees ¶_tm)) term_less s1) term_less s2;
		val rest_decl = mk_z_decl (map mk_z_univ_decl1 rest);
		val rhs = mk_z_h_schema (rest_decl,¶_tm);
		val side = schema_gen_semantic_const rhs;
		val lhs = list_mk_app(cvar,[s1,s2]);
		val defn_tm = list_mk_µ([s1, s2], mk_eq(lhs,rhs));
	in
		local_const_spec "»‰s_gen_semantic_const" (nam, cvar, defn_tm)
	end))
	| _ => term_fail "»‰s_gen_semantic_const" 50001 [tm]
end);
=TEX

\subsection{Renaming Z Schemas}
=SML
fun Ûrename‰s_gen_semantic_constÝ (tm : TERM) : THM = (
let	val (s,rnl) = dest_z_rename‰s tm
		handle complaint =>
		divert complaint "dest_z_rename‰s" "rename‰s_gen_semantic_const"
			50001 [fn () => string_of_term tm];
	val nam = fst(dest_const (fst (dest_app tm)));
in
	get_cached_defn nam
	handle Fail _ => (
let
	val tyfrom = dest_z_power_type(type_of s);
	val tyto = dest_z_power_type(type_of tm);
=TEX
The following two may be redundant, but ...
=SML
	val side = binding_type_spec tyto;
	val side = binding_type_spec tyfrom;
	val from_comp = map fst (dest_z_schema_type tyfrom);
	val to_comp = map fst (dest_z_schema_type tyto);
	val ty_insts =(map (fn (a,b) =>
		(mk_vartype ("'"^a),
		mk_vartype ("'"^b))) rnl);
	val ty_inst = inst_type ty_insts;
	val tm_inst = inst [] ty_insts;
	val tyfrom_generic = ty_inst (mk_ctype
			(fst(dest_ctype tyfrom),
			map (mk_vartype o (fn y => "'" ^ y)) from_comp));
	val p_tyfrom_generic = mk_z_power_type tyfrom_generic;
	val tyto_generic = ty_inst(mk_ctype
			(fst(dest_ctype tyto),
			map (mk_vartype o (fn y => "'" ^ y)) to_comp));
	val p_tyto_generic = mk_z_power_type tyto_generic;
	val const_generic = mk_var(nam,
		mk_­_type(p_tyfrom_generic, p_tyto_generic));
	val argS = mk_var("S",p_tyfrom_generic);
	val args = mk_var("s",tyto_generic);
	val args' = mk_var("s'",tyfrom_generic);
	val (to_con,_) = get_binding_info tyto_generic;
	val (_,from_projs) = get_binding_info tyfrom_generic;
	val from_projs' = map tm_inst from_projs;
 	val from_bits = map (fn x => mk_app(x,args')) from_projs';
	val from_bits_assoc = combine from_comp from_bits;
	fun aux tb = (
		lassoc3 from_bits_assoc (lassoc1 rnl tb)
		handle complaint => divert complaint
			"lassoc3" "rename‰s_gen_semantic_const" 50006
			[fn () => (lassoc1 rnl tb), fn () => string_of_term tm]);
	val to_bits = map aux to_comp;
	val inner_rhs = list_mk_app(to_con, to_bits);
	val inner_ = list_mk_app(
		mk_const("",list_mk_­_type[type_of args',
			type_of argS, BOOL]),
		[args', argS]);	
	val dumy = if type_of args =: type_of inner_rhs
		then ()
		else type_fail "rename‰s_gen_semantic_const" 50007
					[type_of args, type_of inner_rhs];
	val inner_¶ = mk_¶(args',
		mk_±(inner_ ,
		mk_eq(args,inner_rhs)));
	val rhs = mk_set_comp(args, inner_¶);
	val lhs = mk_app(const_generic, argS);
	val def_tm = mk_µ(argS, mk_eq(lhs,rhs));
in
	local_const_spec "rename‰s_gen_semantic_const" (nam, const_generic, def_tm)
end)
end);
=TEX	
\section{EPILOGUE}
=SML
end (* of structure ZGeneratedConstants *);
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

