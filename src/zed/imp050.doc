=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Implementation of Z Constant Generation}
\TPPref{DS/FMU/IED/IMP050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
%\TPPauthors{G.T.Scullard&WIN01\\G.M.Prout&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the implementation of the dynamic generation of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] (\TPPdate{\FormatDate{$Date$
}})
First draft version.

\item [Issue 1.2]Changed to new fonts.
\item [Issue 1.10 (17th July 1992)]
Gave ``caller'' parameter to $local\_labelled\_product\_spec$.
\item [Issue 1.11 (20th July 1992)]
Added schema renaming definition mechanism.
Used all in-scope caches for look-up, rather than just current one.
\item [Issue 1.12 (21st July 1992)]
Correction to schema renaming definition mechanism.
\item [Issue 1.14 (27th July 1992)]
Critical code is now protected by interrupt handling.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The detailed design may be found in
\cite{DS/FMU/IED/DTD050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{STRUCTURE}
=SML
structure €ZGeneratedConstants› = struct
local
	open	Unification;
in
=TEX
\section{AUXILIARY FUNCTIONS}

=SML
fun (€int_to_tyvl› : int -> TYPE list) 1 = [mk_z_var_t (string_of_int 1)]
| int_to_tyvl n = (int_to_tyvl(n - 1)) @ [mk_z_var_t (string_of_int n)];
=TEX
=SML
fun (€int_to_sl› : int -> string list) 1 = [string_of_int 1]
| int_to_sl n = (int_to_sl(n - 1)) @ [string_of_int n];
=TEX
function to make an ``itym'' from a list of strings:
=SML
fun	€stringl_to_itym› (sl : string list):(string * TYPE)list =
	combine sl (map mk_z_var_t sl);
=TEX
function to make an ``itym'' from an integer
=SML
fun (€int_to_itym› : int -> (string * TYPE) list) 1 = 
	[("1", mk_z_var_t "1")]
|	int_to_itym n = (
		let 	val s = string_of_int n 
		in	int_to_itym (n - 1) @ [(s,mk_z_var_t s)]
		end); 
=TEX
function to make an ``itym'' from a string 
=SML
fun (€string_to_itym› : string -> (string * TYPE) list) s = 
	int_to_itym(nat_of_string s);
=TEX
function to make a type list from a string 
=SML
fun (€string_to_styl› : string -> TYPE list) s = 
	int_to_tyvl(nat_of_string s);
=TEX
=SML
fun	€list_mk_≠_type1› ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_≠_type tyl ty;
=TEX
And its inverse:
=SML
fun €strip_≠_type1› (ty : TYPE): TYPE list * TYPE = (
	let fun aux typ l= (
		if is_≠_type typ
		then 	let 	val (ty1,ty2) = dest_≠_type typ
			in aux  ty2 (l @ [ty1]) 
			end
		else (l,typ)
		);
	in	aux ty [] 
	end
);
=TEX

=TEX
=SML
fun €last› (l : 'a list)  = (hd (rev l));
fun €front› (l : 'a list)  = rev(tl (rev l));
=TEX
The function $match\_mk\_app$ below should perhaps
be elsewhere.
Given terms $f:\tau≠\sigma$
and $a:\tau_0$ $match\_mk\_app$ checks whether $\tau_0$
is an instance of $\tau$ and, if so, it returns
$(f:\tau_0≠\sigma_0)(a:\tau_0)$, where $\sigma_0$  is the
corresponding instance of $\sigma$.
=SML

fun €match_mk_app› (f : TERM, a : TERM) : TERM = (
let  val ty = type_of f
in
	if is_≠_type ty
	then	
		let 	val(ty1,_) = dest_≠_type ty;
			val tym = type_match (type_of a) ty1;
		in
			mk_app(
		inst [] tym f,
		a)
		end
	else fail "match_mk_app" 0 []
end);

=TEX
A function which takes a binding type and returns a pair consisting
of the name of the binding type constructor and a list of names of the projections.
=SML
fun €bind_con_proj›(ty:TYPE) =
let	val (sl,tyl) = split(dest_z_schema_t ty)
		handle complaint => 
		divert complaint "dest_z_schema_t" "bind_con_proj" 47050 
			[fn () => string_of_type ty];
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val pnaml = map (curry (op ^) nam)  sl;
in
	(cnam,pnaml)
end;
=TEX
A function which takes a tuple type and returns  a pair consisting
of the name of the tuple type constructor and a list of names of the projections.

=SML
fun €tuple_con_proj›(ty:TYPE) =
let	val tyl = dest_z_tuple_t ty
		handle complaint => 
		divert complaint "dest_z_tuple_t" "tuple_con_proj" 47040 
			[fn () => string_of_type ty];
	val n = length tyl;
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val isl = int_to_sl n;
	val pnaml = map (curry (op ^) nam)  isl;
in	
	(cnam,pnaml)
end;
=TEX
\section{STORING Z CONSTANTS}
=SML
fun €local_const_spec› (caller:string) ((nam, var, defn) : string * TERM * TERM) : THM = (
let	val curr_theory = get_current_theory_name();
in
	let	val side = open_theory (current_cache_theory());
		val thm = get_defn  "-" nam
			handle  Fail _ =>
			pc_rule "hol" const_spec ([nam], [var], defn)
				handle ex => (open_theory curr_theory;
					reraise ex caller);
		val side = open_theory curr_theory;
	in
		thm
	end
	handle ex => (open_theory curr_theory; reraise ex caller)
end);
=TEX
$pc\_rule$ could be replaced by $pending\_push\_pc$ plus wrapping
for more safety.
=TEX
The signature for the next function is the same as that for $labelled\_product\_spec$.
=SML
fun €local_labelled_product_spec› (caller : string) {tykey: string, labels: (string * TYPE) list, tyname: string,
  tyvars: TYPE list OPT, conname: string, constkeys: string list} : THM = (
let	val curr_theory = get_current_theory_name();
in
	let	val side = open_theory (current_cache_theory());
		val thm = get_defn  "-" tyname
			handle  Fail _ =>
				(labelled_product_spec{
						tykey = tykey,
						labels = labels,
						tyname= tyname,
						tyvars = tyvars,
						conname = conname,
						constkeys = constkeys}
					handle ex => (open_theory curr_theory;
						reraise ex caller));
		val side = open_theory curr_theory;
	in
		thm
	end
	handle ex => (open_theory curr_theory; reraise ex caller)
end);

=TEX

=TEX
\section{BINDING TYPES}
Everything stored in current theory for now.
=SML
fun €binding_type_spec› (ty : TYPE) : THM =
let 	
	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "binding_type_spec" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_t ty);
	val (nam,tyl) = dest_ctype ty;
	val tyvl = map mk_z_var_t sl;
in	local_labelled_product_spec "binding_type_spec" {
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml}

end;
=TEX
=SML
fun €get_binding_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "get_binding_info" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_t ty);
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = map mk_z_var_t sl;	
		val	(_,bty) = strip_≠_type1 pty;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end	
	| _ => fail "get_binding_info" 50001 [fn () => cnam]
end;
=TEX
\section{TUPLE TYPES}
=SML
fun €tuple_type_spec›(ty : TYPE) : THM =
let 	
	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "tuple_type_spec" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
	val nam = fst(dest_ctype ty);
	val tyvl = int_to_tyvl n;
in	local_labelled_product_spec "tuple_type_spec" {
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml}
end;
=TEX
=SML
fun €get_tuple_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "get_tuple_info" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = int_to_tyvl n;	
		val 	bty = mk_z_tuple_t tyvl;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end		| _ => fail "get_tuple_info" 50002 [fn () => cnam]
end;
=TEX
\section{RETRIEVING TYPE INFORMATION}
\subsection{Retrieving from Some Cache theory}
=SML
fun €get_cached_defn› (nm:string):THM = (
let	val cs = current_cache_theories();
	fun aux (a :: x) = (get_defn a nm
		handle _ => aux x)
	| aux [] = fail "get_cached_defn" 0 [];
in
	aux cs
end);
=TEX
\subsection{Specific Cases}
These don't work - $µ\_±\_conv$ requires theory $combin$ as parent.
=SML
fun €get_constructor_defn› (ty : TYPE) : THM =
let 	val (cnam,_) = 
			if is_z_schema_t ty
				then (binding_type_spec ty;bind_con_proj ty)
			else 	if is_z_tuple_t ty
					then (tuple_type_spec ty;tuple_con_proj ty)
				else fail  "get_constructor_defn" 5003 
				[fn () => string_of_type ty];
	val thm = get_cached_defn cnam
		handle complaint => 
		divert complaint "get_defn""get_constructor_defn" 50004[fn () => cnam]
in
	hd(strip_±_rule((conv_rule µ_±_conv)thm))
end;
=TEX
=SML
fun €get_projections_defn›(ty : TYPE) : THM list =
let 	val (cnam,_) = 
			if is_z_schema_t ty
				then (binding_type_spec ty;bind_con_proj ty)
			else 	if is_z_tuple_t ty
					then (tuple_type_spec ty;tuple_con_proj ty)
				else fail  "get_projections_defn" 5003 
				[fn () => string_of_type ty];
	val thm = get_cached_defn cnam
		handle complaint => 
		divert complaint "get_defn""get_projections_defn" 50005[fn () => cnam]
in
	strip_±_rule(hd(tl(strip_±_rule((conv_rule µ_±_conv)thm))))
end;
=TEX

\section{Z CONSTANT DEFINITION GENERATION}

\subsection{Temporary Stub for Generated Constants}

=SML
fun	€types_in_zcon_spec› (ty : TYPE) : unit = 	
	if 	is_z_given_t ty then ()
	else 	if	is_z_var_t ty then ()
	else 	if	is_z_power_t ty then types_in_zcon_spec (dest_z_power_t ty)
	else 	if	is_z_tuple_t ty then 
			let	val(s,tyl) = dest_ctype ty
			in	map types_in_zcon_spec tyl;(tuple_type_spec ty;())
			end
	else 	if	is_z_schema_t ty then 
			let	val(s,tyl) = dest_ctype ty
			in	map types_in_zcon_spec tyl;(binding_type_spec ty;())
			end
	else 	if	is_≠_type ty then
			let	val (ty1,ty2) = dest_≠_type ty
			in  	types_in_zcon_spec ty1;types_in_zcon_spec ty2 
			end
	else 	fail "types_in_zcon_spec" 50006 [fn () => string_of_type ty];
=TEX
=IGN
fun €local_new_const› (caller : string) ((nam, ty) : string * TYPE) : unit = (
let	val curr_theory = get_current_theory_name();
in
	let	val side = open_theory (current_cache_theory());
		val side = case get_const_info nam of
				Nil => (new_const (nam, ty);())
				|Value _ => ();
		val side = open_theory curr_theory;
	in
		()
	end
	handle ex => (open_theory curr_theory; reraise ex caller)
end);
=TEX

=SML
fun €stub_const_spec› (tm : TERM) : unit = (
let	val (name, ty) = (dest_const o fst o strip_app) tm;
	val side = types_in_zcon_spec ty;
	val side = (new_const (name, ty); ()) handle Fail _ => ();
in
	()
end);
=TEX


=TEX
\subsection{Set Abstraction}

=SML
fun €seta_const_spec› (tm : TERM) : THM = (
let	val nam = fst (dest_const (fst (dest_app tm)));
in
	case dest_z_name nam of
	("Z'Seta", [[sn]], Nil) => (get_cached_defn (nam^"_def")
		handle Fail _ => (
		let	val tyvl = map (fn x => mk_vartype ("'"^string_of_int (next_name())))
				(interval 1 (nat_of_string sn));
			val tyv = mk_z_var_t "v";
			val dpvty = mk_z_schema_t [("d", BOOL),("p", BOOL),("v", tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon, dpvprojs) = get_binding_info dpvty;
			val resty = mk_z_power_t tyv;
			val argty = list_mk_≠_type (tyvl@[dpvty]);
			val cvar = mk_var(nam, mk_≠_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type (tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "seta_const_spec" (nam, cvar, defn)
		end))
	| _ => error "seta_const_spec" 50100 []
end);
=TEX
\subsection{Ã Abstraction}

=SML
fun	€Ã_const_spec› (tm : TERM) : THM = (
let	val nam = fst(dest_const (fst (dest_app tm)));
in
	case dest_z_name nam of
	("Z'Ã",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle Fail _ => (
		let	val tyvl = map (fn x => mk_vartype ("'"^string_of_int (next_name())))
				(interval 1 (nat_of_string sn));
			val tyv = mk_z_var_t "v";
			val tyt = mk_z_var_t "t";
			val dptvty = mk_z_schema_t[("d",BOOL),("p",BOOL),("t",tyt),("v",tyv)];
			val side = binding_type_spec dptvty;
			val (dptvcon,dptvprojs) = get_binding_info dptvty;
			val resty = mk_z_power_t(mk_z_tuple_t[tyt,tyv]);
			val argty = list_mk_≠_type(tyvl@[dptvty]);
			val cvar = mk_var(nam,mk_≠_type(argty,resty));
			val x = mk_var("x",mk_z_tuple_t[tyt,tyv]);
			val side = tuple_type_spec(type_of x);
			val (_,xprjs) = get_tuple_info(type_of x);
			val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type(tyvl@[dptvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dptvprojs;
			val pred = list_mk_± (
					[hd projs,hd(tl projs)] @
					(map 	mk_eq 
						(combine 	(projs from 2)
								(	(map 	(fn y => match_mk_app(y,x)) 
										xprjs)))));
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "Ã_const_spec" (nam, cvar, defn)
		end))
	| _ => error "Ã_const_spec" 50100 []
end);
=IGN
fun €∏_const_spec› (tm:TERM) : THM = (
let	val nam = fst(dest_const (fst (dest_app tm)));
in
	case dest_z_name nam of
	("Z'∏",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle Fail _ => (
		let	val aty = hd(snd(dest_ctype(type_of tm)));

	(*		val tyvl = mk_vartype(dest_z_tuple_t aty); *)
			val tyvl = [mk_vartype"A"];
			val argty = mk_z_tuple_t(map mk_z_power_t tyvl);
			val side = binding_type_spec(mk_z_tuple_t tyvl);
			val (con,projs) = get_binding_info (mk_z_tuple_t tyvl);
			val resty = mk_z_power_t bty;
			val cvar = mk_var(nam, mk_≠_type (argty,resty));
			val arg = mk_var("A",argty);
			val t = mk_var("t",bty);
			val conjl = map	(fn proj => mk_z_ç(	match_mk_app(proj,t),
								match_mk_app(proj,arg))) 
					projs;
			val conj = list_mk_± conjl;
			val setcomp = mk_set_comp (t, conj);
			val lhs = mk_app(cvar, arg);
			val body = mk_eq(lhs, setcomp);
			val defn = mk_µ (arg, body);
		in
			local_const_spec "∏_const_spec" (nam, cvar, defn)
		end))
	| _ => error "∏_const_spec" 50100 []
end);
=TEX
\subsection{Binding Display}
=SML
fun €binding_const_spec› (tm : TERM) : THM = (
	((binding_type_spec o hd o rev o strip_≠_type
	o type_of o fst o strip_app) tm)
	handle Fail _ => fail "binding_const_spec" 50111 []
);
=IGN

=TEX
\subsection{Constants for Schema Calculus}

First, we will need the schema type $Z'S[d,p]$, type instantiated to $BOOL$, and the``d'' and ``p'' projections of the schema type $Z'S[d,p]$, type instantiated to $BOOL$:
=IGN
val get_dpty : TYPE =
let 	val ty = mk_z_schema_t(stringl_to_itym["d","p"]);
	val side_effect	= binding_type_spec  ty;
in
	inst_type[(¨:BOOLÆ,¨:'dÆ),(¨:BOOLÆ,¨:'pÆ)] ty
end;
=TEX
=IGN
val get_dpprojs : TERM list =
let 	val ty = mk_z_schema_t(stringl_to_itym["d","p"]);
	val side_effect	= binding_type_spec ty;
	val(_,projs) = get_binding_info ty;
in
	map (inst[][(¨:BOOLÆ,¨:'dÆ),(¨:BOOLÆ,¨:'pÆ)]) projs
end;
=TEX
Should I remove call to $binding\_type\_spec$ on the
grounds that types will always be put in place first?
=IGN
fun €z_schema_defn› (znam : string)(sl : string list):TERM * TERM =
let 	
	val  zty = bind_ctype (stringl_to_itym sl);
	val schtm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val p = mk_z_lvar("p",ty1,[]);
	val lhs = mk_app(schtm,p); 
	val schty = dest_z_power_t ty2;	
	val x = mk_z_lvar("x",schty,[]);
	val side_effect = binding_type_spec schty;
	val(_,projsx) = get_binding_info schty;
	val substm = list_mk_app(p,map (fn pr => mk_app(pr,x))projsx);
	val t = mk_z_lvar("t",type_of substm,[]);
	val conj = list_mk_±(map (fn pr => mk_app(pr,t))get_dpprojs);
	val absttm = mk_Ã(t,conj);
	val absxtm = mk_Ã(x,mk_app(absttm,substm));
	val rhs = match_mk_app(¨$"Z'Abs"Æ,absxtm);
in
	(schtm,mk_µ(p,mk_eq(lhs,rhs)))
end;
=TEX
First a function which makes the right sort of signature for the resultant schema.
Something wrong here - shouldn't I be using $U$?
=IGN
fun (mk_z_decty (styl:(string * TYPE) list)):TERM = (
let 	val varl = map ((fn x => [x]) o mk_var) styl	
 	val tyl = map (fn x => mk_var("S" ^ (fst x),mk_z_power_t(snd x))) styl;
in
mk_z_decl(map mk_z_dec (combine varl tyl))
end);
=TEX
=IGN
fun €z_dysc_defn› (znam : string)(sl1 : string list)(sl2 : string list)(dyop : string):TERM * TERM =
let 	
	val  zty = bind_dysc_type (stringl_to_itym sl1)(stringl_to_itym sl2);
	val dysctm = mk_var(znam,zty);	
	val (ty1,ty) = dest_≠_type zty;
	val (ty2,ty3) = dest_≠_type ty;
	val schty = dest_z_power_t ty3;
	val styl = dest_z_schema_t schty;
	val d = mk_z_decty styl;
	val (sc1,sc2) = (mk_z_lvar("sc1",ty1,[]),mk_z_lvar("sc2",ty2,[]));
	val lhs = list_mk_app(dysctm,[sc1,sc2]);
	val p = case dyop of
		"±" => mk_z_±âs(sc1,sc2)
		| "≤" => mk_z_≤âs(sc1,sc2)
		| "¥" => mk_z_¥âs(sc1,sc2)
		| "§" => mk_z_§âs(sc1,sc2)
		| _ => fail "z_dysc_defn" 0 [] ;
	val rhs = mk_z_âs(d,mk_z_predsexp(p,""));	
in
	(dysctm,list_mk_µ([sc1,sc2],mk_eq(lhs,rhs)))
end;
=TEX
=IGN
fun €z_pre_defn› (znam : string)(sl : string list):TERM * TERM =
let 	
	val  zty = bind_pre_type (stringl_to_itym sl);
	val pretm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val s = mk_z_lvar("s",ty1,[]);
	val lhs = mk_app(pretm,s); 
	val schty1 = dest_z_power_t ty1;
	val schty2 = dest_z_power_t ty2;
	val styl1 = dest_z_schema_t schty1;
	val styl2 = dest_z_schema_t schty2;
	val d1 = mk_z_decty styl2;
	val d2 = mk_z_decty (styl1 diff' styl2);
	val p = mk_z_∂(d2,mk_z_true,mk_z_predsexp(s,""));
	val rhs = mk_z_âs(d1,p);
in
	(pretm,mk_µ(s,mk_eq(lhs,rhs)))
end;
=TEX

=IGN
fun €z_pro_defn› (znam : string)(sl1 : string list)(sl2 : string list):TERM * TERM =
let 	
	val  zty = bind_˘_type (stringl_to_itym sl1)(stringl_to_itym sl2);
	val protm = mk_var(znam,zty);	
	val (ty1,ty) = dest_≠_type zty;
	val (ty2,ty3) = dest_≠_type ty;
	val (sc1,sc2) = (mk_z_lvar("sc1",ty1,[]),mk_z_lvar("sc2",ty2,[]));
	val lhs = list_mk_app(protm,[sc1,sc2]);
	val schconj = mk_z_±âs(sc1,sc2)
	val schty1 = dest_z_power_t ty1;
	val styl1 = dest_z_schema_t schty1;
	val schty2 = dest_z_power_t ty2;
	val styl2 = dest_z_schema_t schty2;
	val sl = fst(split(styl1 diff' styl2));
	val rhs = (mk_z_hideâs (schconj,sl));
in
	(protm,list_mk_µ([sc1,sc2],mk_eq(lhs,rhs)))
end;
=TEX
=IGN
fun €z_hide_defn› (znam : string)(sl1 : string list)(sl2 : string list):TERM * TERM =
let 	
	val  zty = bind_hide_type (stringl_to_itym sl1) sl2;
	val hidtm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val sc = mk_z_lvar("sc",ty1,[]);
	val lhs = mk_app(hidtm,sc); 
	val schty1 = dest_z_power_t ty1;
	val schty2 = dest_z_power_t ty2;
	val styl1 = dest_z_schema_t schty1;
	val styl2 = dest_z_schema_t schty2;
	val styl = styl1 diff' styl2;
	val d1 = mk_z_decty styl2;
	val d2 = mk_z_decty styl;
	val p = mk_z_∂(d2,mk_z_true,mk_z_predsexp(sc,""));
	val rhs = mk_z_âs(d1,p);
in
	(hidtm,mk_µ(sc,mk_eq(lhs,rhs)))
end;
=TEX
=IGN
fun €z_dec_defn› (znam : string) (sl : string list) (s : string):TERM * TERM =
let 	
	val  zty = bind_decor_type(stringl_to_itym sl) s;
	val dectm = mk_var(znam,zty);	
	val (ty1,ty2) = dest_≠_type zty;
	val schty1 = dest_z_power_t ty1;
	val styl1 = dest_z_schema_t schty1;
	val schtm1 = schema_bterm styl1; 
	val schty2 = dest_z_power_t ty2;
	val styl2 = dest_z_schema_t schty2;
	val schtm2 = schema_bterm styl2; 
	val tyvl = snd(split styl1);
	val p = mk_z_lvar("p",list_mk_≠_type1(tyvl,get_dpty),[]);
	val lhs = mk_app(dectm,mk_app(schtm1,p)); 
	val rhs = mk_app(schtm2,p);
in
	(dectm,mk_µ(p,mk_eq(lhs,rhs)))
end;
=TEX
First a function which sorts a list of pairs according to  the first of each pair:
=IGN
fun €idsetseq_pairs› (x : (string * 'a) list) : (string * 'a) list =
	let 	val orderfn = fn (s1,a1) => (fn (s2,a2) => Sort.string_order s1 s2)
	in
		Sort.sort orderfn x
	end;
=TEX
=IGN
fun €z_schquant_defn› (znam : string)(sl1 : string list)(sl2 : string list)
	(quant:string):TERM * TERM =
let 	
	val sl = idsetseq(sl1 @ sl2);
	val (zty,mktm)= case quant of
		"∂" => (∂âs_btype (stringl_to_itym sl1)(stringl_to_itym sl),mk_∂)
		| "∂â1" =>(∂â1âs_btype 
		(stringl_to_itym sl1)(stringl_to_itym sl),mk_∂â1)
		| "µ" => (µâs_btype (stringl_to_itym sl1)(stringl_to_itym sl),mk_µ)
		| _ => fail "z_schquant_defn" 0 [] ;
	val schquantm = mk_var(znam,zty);	
	val (ty1,ty) = dest_≠_type zty;
	val (ty2,ty3) = dest_≠_type ty;
	val (p,q) = (mk_z_lvar("p",ty1,[]),mk_z_lvar("q",ty2,[]));
	val lhs = list_mk_app(schquantm,[p,q]); 
	val schty1 = dest_z_power_t ty3;	
	val x = mk_z_lvar("x",schty1,[]);
	val side_effect = binding_type_spec schty1;
	val(_,projsx) = get_binding_info schty1;
	val xprojs = map (fn f => mk_app(f,x)) projsx;
	val schty2 = mk_z_schema_t(stringl_to_itym sl1);	
	val y = mk_z_lvar("y",schty2,[]);
	val side_effect = binding_type_spec schty2;
	val(_,projsy) = get_binding_info schty2;
	val yprojs = map (fn f => mk_app(f,y)) projsy
	val substm = list_mk_app(p,yprojs);
	val t = mk_z_lvar("t",type_of substm,[]);
	val dandp = list_mk_±(map (fn pr => mk_app(pr,t))get_dpprojs);
	val schty3 = dest_z_power_t ty2;	
	val side_effect = binding_type_spec schty3;
	val(con,_) = get_binding_info schty3;
	val projs = xprojs @ yprojs;
	val sorted_projs = snd(split(idsetseq_pairs
		(combine (map (dest_z_var_t o type_of) projs) projs)));

	val projtm = list_mk_app(con,sorted_projs);
	val memtm = mk_z_ç(projtm,q);
	val absttm = mk_Ã(t,mk_±(dandp,memtm));
	val qtm = mktm(y,mk_app(absttm,substm));
	val absxtm = mk_Ã(x,qtm);
	val rhs = match_mk_app(¨$"Z'Abs"Æ,absxtm);
in
	(schquantm,list_mk_µ([p,q],mk_eq(lhs,rhs)))
end;
=TEX
\subsection{Renaming Z Schemas}
=SML
fun €renameâs_const_spec› (tm : TERM) : THM = (
let	val (s,rnl) = dest_z_renameâs tm
		handle complaint =>
		pass_on complaint "dest_z_renameâs" "renameâs_const_spec";
	val nam = fst(dest_const (fst (dest_app tm)));
in
	get_cached_defn (nam ^ "_def")
	handle Fail _ => (
let
	val tyfrom = dest_z_power_t(type_of s);
	val tyto = dest_z_power_t(type_of tm);
=TEX
The following two may be redundant, but ...
=SML
	val side = binding_type_spec tyto;
	val side = binding_type_spec tyfrom;
	val from_comp = map fst (dest_z_schema_t tyfrom);
	val to_comp = map fst (dest_z_schema_t tyto);
	val ty_insts =(map (fn (a,b) => 
		(mk_vartype ("'"^a),
		mk_vartype ("'"^b))) rnl);
	val ty_inst = inst_type ty_insts;
	val tm_inst = inst [] ty_insts;
	val tyfrom_generic = ty_inst (mk_ctype
			(fst(dest_ctype tyfrom),
			map (mk_vartype o (fn y => "'" ^ y)) from_comp));
	val p_tyfrom_generic = mk_z_power_t tyfrom_generic;
	val tyto_generic = ty_inst(mk_ctype
			(fst(dest_ctype tyto),
			map (mk_vartype o (fn y => "'" ^ y)) to_comp));
	val p_tyto_generic = mk_z_power_t tyto_generic;
	val const_generic = mk_var(nam,
		mk_≠_type(p_tyfrom_generic, p_tyto_generic));
	val argS = mk_var("S",p_tyfrom_generic);
	val args = mk_var("s",tyto_generic);
	val args' = mk_var("s'",tyfrom_generic);
	val (to_con,_) = get_binding_info tyto_generic;
	val (_,from_projs) = get_binding_info tyfrom_generic;
	val from_projs' = map tm_inst from_projs;
 	val from_bits = map (fn x => mk_app(x,args')) from_projs';
	val from_bits_assoc = combine from_comp from_bits;
	fun aux tb = lassoc3 from_bits_assoc (lassoc1 rnl tb);
	val to_bits = map aux to_comp;
	val inner_rhs = list_mk_app(to_con, to_bits);
	val inner_ç = list_mk_app(
		mk_const("ç",list_mk_≠_type[type_of args',
			type_of argS, BOOL]),
		[args', argS]);	
	val inner_∂ = mk_∂(args',
		mk_±(inner_ç ,
		mk_eq(args,inner_rhs)));
	val rhs = mk_set_comp(args, inner_∂);
	val lhs = mk_app(const_generic, argS);
	val def_tm = mk_µ(argS, mk_eq(lhs,rhs));
in
	local_const_spec "renameâs_const_spec" (nam, const_generic, def_tm)
end)
end);
=TEX	 
\section{END OF STRUCTURE}
The structure is left closed.
=SML
end (* of local ... in *);
end (* of structure ZGeneratedConstants *);
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


