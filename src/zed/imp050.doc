=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Implementation of Z Constant Generation}
\TPPref{DS/FMU/IED/IMP050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
\TPPauthors{D.J.~King&WIN01\\G.M.~Prout&WIN01 }
\TPPauthorisation{R.D.~Arthan & Project Manager}
\TPPabstract{This document contains the implementation of the dynamic generation of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] (\TPPdate{\FormatDate{$Date$
}})
First draft version.

\item [Issue 1.2]Changed to new fonts.
\item [Issue 1.10 (17th July 1992)]
Gave ``caller'' parameter to $local\_labelled\_product\_spec$.
\item [Issue 1.11 (20th July 1992)]
Added schema renaming definition mechanism.
Used all in-scope caches for look-up, rather than just current one.
\item [Issue 1.12 (21st July 1992)]
Correction to schema renaming definition mechanism.
\item [Issue 1.14 (27th July 1992)]
Critical code is now protected by interrupt handling.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The detailed design may be found in
\cite{DS/FMU/IED/DTD050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{GENERATED CONSTANTS SUPPORT}
=SML
structure €ZGeneratedConstants› : ZGeneratedConstants = struct
local
	open ZUserInterfaceSupport ZTypesAndTermsSupport;
in
=TEX
\subsection{Auxiliary Functions}

=SML
fun (€int_to_tyvl› : int -> TYPE list) 1 = [mk_z_var_t (string_of_int 1)]
| int_to_tyvl n = (int_to_tyvl(n - 1)) @ [mk_z_var_t (string_of_int n)];
=TEX
=SML
fun (€int_to_sl› : int -> string list) 1 = [string_of_int 1]
| int_to_sl n = (int_to_sl(n - 1)) @ [string_of_int n];
=TEX
function to make an ``itym'' from a list of strings:
=SML
fun	€stringl_to_itym› (sl : string list):(string * TYPE)list =
	combine sl (map mk_z_var_t sl);
=TEX
function to make an ``itym'' from an integer
=SML
fun (€int_to_itym› : int -> (string * TYPE) list) 1 = 
	[("1", mk_z_var_t "1")]
|	int_to_itym n = (
		let 	val s = string_of_int n 
		in	int_to_itym (n - 1) @ [(s,mk_z_var_t s)]
		end); 
=TEX
function to make an ``itym'' from a string 
=SML
fun (€string_to_itym› : string -> (string * TYPE) list) s = 
	int_to_itym(nat_of_string s);
=TEX
function to make a type list from a string 
=SML
fun (€string_to_styl› : string -> TYPE list) s = 
	int_to_tyvl(nat_of_string s);
=TEX
=SML
fun €mk_ç› (tm1,tm2) = (
let	val ty = type_of tm1;
	val memconst = mk_const("ç",mk_≠_type(ty,
		mk_≠_type(mk_ctype("SET",[ty]),BOOL)));
in
	mk_app (mk_app (memconst, tm1), tm2)
end
	handle ex => reraise ex "mk_ç"
);
=TEX
=SML
fun €list_match_mk_app› (f : TERM, (a::rest) : TERM list) : TERM = (
	list_match_mk_app ((match_mk_app (f, a)), rest)
)  | list_match_mk_app (f, []) = f;

=TEX
=SML
fun €list_mk_pair› [a] = a
  | list_mk_pair [a,b] = mk_pair (a,b)
  | list_mk_pair (a::rest) =
	mk_pair (a,list_mk_pair rest)
  | list_mk_pair _ = fail "list_mk_pair" 50001 [];
=TEX
val €empty_sig› = (
let	val thing1 = mk_const("Z'Mk_S[]",(mk_ctype("Z'S[]",[])));
	val thing2 = mk_enum_set [thing1];
in
	mk_z_decsexp(thing2,"")
end);
=TEX
=SML
fun €mk_z_empty_decl› () = (
	fail "mk_z_empty_decl" 50001 []
(*
	mk_z_decl [empty_sig]
*)
);
=TEX
=SML
fun €mk_z_decl1› dl = (
	mk_z_decl dl handle Fail _ => mk_z_empty_decl()
);
=TEX
=SML
val €strip_type› = hd o rev o strip_≠_type;
=TEX
=SML
fun €mk_z_univ_decl› (s,ty) = ( 
let	val totty = mk_z_power_t ty;
	val tot = mk_const("Totality",totty)
	val U = mk_const("z'U",mk_≠_type(mk_z_tuple_t[totty],totty))
in
	mk_z_dec([mk_var(s,ty)],mk_app(U,mk_z_tuple[tot]))
end);
=TEX
A function which takes a binding type and returns a pair consisting
of the name of the binding type constructor and a list of names of the projections.
=SML
fun €bind_con_proj›(ty:TYPE) =
let	val (sl,tyl) = split(dest_z_schema_t ty)
		handle complaint => 
		divert complaint "dest_z_schema_t" "bind_con_proj" 47050 
			[fn () => string_of_type ty];
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val pnaml = map (curry (op ^) nam)  sl;
in
	(cnam,pnaml)
end;
=TEX
A function which takes a tuple type and returns  a pair consisting
of the name of the tuple type constructor and a list of names of the projections.

=SML
fun €tuple_con_proj›(ty:TYPE) =
let	val tyl = dest_z_tuple_t ty
		handle complaint => 
		divert complaint "dest_z_tuple_t" "tuple_con_proj" 47040 
			[fn () => string_of_type ty];
	val n = length tyl;
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val isl = int_to_sl n;
	val pnaml = map (curry (op ^) nam)  isl;
in	
	(cnam,pnaml)
end;
=TEX
\subsection{Storing Z Constants}
\subsubsection{Retrieving from Some Cache theory}
=SML
fun €get_cached_defn› (nm:string):THM = (
let	val cs = current_cache_theories();
	fun aux (a :: x) = (get_defn a nm
		handle _ => aux x)
	| aux [] = fail "get_cached_defn" 0 [];
in
	aux cs
end);
=TEX
\subsection{Local Constant Specification Wrappers}
=SML
fun €local_const_spec› (caller:string) ((nam, var, defn) : string * TERM * TERM) : THM = (
	get_cached_defn nam
		handle  Fail _ =>
		pc_rule "hol" const_spec ([nam], [var], defn)
			handle ex =>
				reraise ex caller
);
=TEX
$pc\_rule$ could be replaced by $pending\_push\_pc$ plus wrapping
for more safety.
=TEX
The signature for the next function is the same as that for $labelled\_product\_spec$.
=SML
fun €local_labelled_product_spec› (caller : string) {tykey: string, labels: (string * TYPE) list, tyname: string,
  tyvars: TYPE list OPT, conname: string, constkeys: string list} : THM = (
	get_cached_defn conname
		handle  Fail _ =>
			(labelled_product_spec{
				tykey = tykey,
				labels = labels,
				tyname= tyname,
				tyvars = tyvars,
				conname = conname,
				constkeys = constkeys}
			handle ex => reraise ex caller)
);

=TEX

=TEX
\subsection{Binding Types}
Everything stored in current theory for now.
=SML
fun €binding_type_spec› (ty : TYPE) : THM =
let 	
	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "binding_type_spec" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_t ty);
	val (nam,tyl) = dest_ctype ty;
	val tyvl = map mk_z_var_t sl;
in	local_labelled_product_spec "binding_type_spec" {
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml}

end;
=TEX
=SML
fun €get_binding_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "get_binding_info" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_t ty);
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = map mk_z_var_t sl;	
		val	bty = (hd o rev o strip_≠_type) pty;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end	
	| _ => fail "get_binding_info" 50005 [fn () => cnam]
end;
=TEX
\subsection{Tuple Types}
=SML
fun €tuple_type_spec› (ty : TYPE) : THM =
let 	
	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "tuple_type_spec" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
	val nam = fst(dest_ctype ty);
	val tyvl = int_to_tyvl n;
in	local_labelled_product_spec "tuple_type_spec" {
			tykey = nam,
			labels = combine pnaml tyvl,
			tyname= nam,
			tyvars = Nil,
			conname = cnam,
			constkeys = [cnam] @ pnaml}
end;
=TEX
=SML
fun €get_tuple_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "get_tuple_info" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = int_to_tyvl n;	
		val 	bty = mk_z_tuple_t tyvl;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end		| _ => fail "get_tuple_info" 50006 [fn () => cnam]
end;
=TEX

\section{Z CONSTANT DEFINITION GENERATION}\label{ZCONST}

\subsection{Tuples}
=IGN
val tm = mk_z_tuple[Ò1Æ,Ò2Æ];
=SML
fun €tuple_gen_semantic_const› (tm : TERM) : THM = (
	tuple_type_spec ((hd o rev o strip_≠_type o
		snd o dest_const o fst o strip_app) tm)
);
=TEX
\subsection{Set Abstraction}
=IGN
val tm = mk_z_seta (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Seta",[[sn]], Nil) = dest_z_name nam;
=SML
fun €seta_gen_semantic_const› (tm : TERM) : THM = (
let	val nam = fst (dest_const (fst (strip_app tm)));
in
	case dest_z_name nam of
	("Z'Seta", [[sn]], Nil) => (get_cached_defn (nam^"_def")
		handle Fail _ => (
		let	val tyvl = string_to_styl sn;
			val tyv = mk_z_var_t "v";
			val dpvty = mk_z_schema_t [("d", BOOL),("p", BOOL),("v", tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon, dpvprojs) = get_binding_info dpvty;
			val resty = mk_z_power_t tyv;
			val argty = list_mk_≠_type (tyvl@[dpvty]);
			val cvar = mk_var(nam, mk_≠_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type (tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "seta_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => error "seta_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Ã Abstraction}
=IGN
val tm = mk_z_Ã (mk_z_decl([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Ã",[[sn]], Nil) = dest_z_name nam;
=SML
fun	€Ã_gen_semantic_const› (tm : TERM) : THM = (
let	val nam = fst(dest_const (fst (strip_app tm)));
in
	case dest_z_name nam of
	("Z'Ã",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle Fail _ => (
		let	val tyvl = string_to_styl sn;
			val tyv = mk_z_var_t "v";
			val tyt = mk_z_var_t "t";
			val dptvty = mk_z_schema_t[("d",BOOL),("p",BOOL),("t",tyt),("v",tyv)];
			val side = binding_type_spec dptvty;
			val (dptvcon,dptvprojs) = get_binding_info dptvty;
			val resty = mk_z_power_t(mk_z_tuple_t[tyt,tyv]);
			val argty = list_mk_≠_type(tyvl@[dptvty]);
			val cvar = mk_var(nam,mk_≠_type(argty,resty));
			val x = mk_var("x",mk_z_tuple_t[tyt,tyv]);
			val side = tuple_type_spec(type_of x);
			val (_,xprjs) = get_tuple_info(type_of x);
			val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type(tyvl@[dptvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dptvprojs;
			val pred = list_mk_± (
					[hd projs,hd(tl projs)] @
					(map 	mk_eq 
						(combine 	(projs from 2)
								(	(map 	(fn y => match_mk_app(y,x)) 
										xprjs)))));
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,setcomp);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "Ã_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => error "Ã_gen_semantic_const" 50100 []
end);
=TEX

\subsection{Definite Description}
=IGN
val tm = mk_z_Õ (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Õ",[[sn]], Nil) = dest_z_name nam;
=SML
fun €Õ_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)));
in
	case dest_z_name nam of
	("Z'Õ",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle (Fail _) => (
		let	val tyvl = string_to_styl sn;
			val tyv = mk_z_var_t "v";
			val dpvty = mk_z_schema_t[("d",BOOL),("p",BOOL),("v",tyv)];
			val side = binding_type_spec dpvty;
			val (dpvcon,dpvprojs) = get_binding_info dpvty;
			val resty = tyv;
			val argty = list_mk_≠_type(tyvl@[dpvty]);
			val cvar = mk_var(nam,mk_≠_type(argty,resty));
			val x = mk_var("x",tyv);
			val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
			val al = map mk_var (combine anaml tyvl);
			val pack = mk_var("pack",list_mk_≠_type(tyvl@[dpvty]));
			val t = list_mk_app (pack, al);
			val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
			val pred = list_mk_±[hd projs,hd(tl projs),mk_eq(hd(tl(tl projs)),x)];
			val exists = list_mk_∂ (al, pred);
			val setcomp = mk_set_comp(x,exists);
			val desc = mk_app(mk_const("Z'Õ",
				mk_≠_type(mk_ctype("SET",[tyv]),tyv)),
				setcomp);
			val exists = list_mk_∂ (al, pred);
			val lhs = mk_app(cvar, pack);
			val body = mk_eq(lhs,desc);
			val defn = mk_µ (pack, body);
		in
			local_const_spec "Õ_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => error "Õ_gen_semantic_const" 50100 []
end);
=TEX

\subsection{Cartesian Products}
=IGN
val tm = mk_z_∏ [Ò˙Æ,Ò˙Æ];
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'∏",[[sn]], Nil) = dest_z_name nam;
=SML
fun €∏_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)));
in
	case dest_z_name nam of
	("Z'∏",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
		handle Fail _ => (
		let	val aty = dest_z_power_t(type_of tm);
			val (tnam, ttyl) = dest_ctype aty;
			val bty = mk_ctype (tnam, int_to_tyvl (length ttyl));
			val tyvl = dest_z_tuple_t bty;
			val side = tuple_type_spec(mk_z_tuple_t tyvl);
			val (con,projs) = get_tuple_info (mk_z_tuple_t tyvl);
			val resty = mk_z_power_t bty;
			val argty = list_mk_≠_type ((map mk_z_power_t tyvl)@[resty]);
			val cvar = mk_var(nam, argty);
			val args = map (fn (id,ty) => mk_var("X"^id, mk_z_power_t ty))
				(string_to_itym sn);

			val t = mk_var("t",bty);
			val comps = combine projs args; 
			val conjl = map	(fn (p,a) => mk_z_ç(
				match_mk_app(p,t), a))
				comps;
			val conj = list_mk_± conjl;
			val setcomp = mk_set_comp (t, conj);
			val lhs = list_mk_app(cvar, args);
			val body = mk_eq(lhs, setcomp);
			val defn = list_mk_µ (args, body);
		in
			local_const_spec "∏_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => error "∏_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Binding Display}
=IGN
val tm = mk_z_binding [("x", Ò1Æ), ("y",Ò2Æ)];
=SML
fun €binding_gen_semantic_const› (tm : TERM) : THM = (
	((binding_type_spec o hd o rev o strip_≠_type
	o type_of o fst o strip_app) tm)
	handle Fail _ => fail "binding_gen_semantic_const" 50100 []
);
=TEX
\subsection{Unique Existential Quantification}
=IGN
val tm = mk_z_∂â1 (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, mk_z_true);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'∂â1",[[sn]], Nil) = dest_z_name nam;
=SML
fun €∂â1_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = fst(dest_const(fst(strip_app tm)));
in
	case dest_z_name nam of
	("Z'∂â1",[[sn]], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val tyvl = string_to_styl sn;
		val tyv = BOOL;
		val dpvty = mk_z_schema_t[("d",BOOL),("p",BOOL),("v",tyv)];
		val side = binding_type_spec dpvty;
		val (dpvcon,dpvprojs) = get_binding_info dpvty;
		val resty = BOOL;
		val argty = list_mk_≠_type(tyvl@[dpvty]);
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val anaml = map (fn s => implode("a" :: tl(explode s))) (map dest_vartype tyvl);
		val al = map mk_var (combine anaml tyvl);
		val alt = list_mk_pair al;
		val pack = mk_var("pack",list_mk_≠_type(tyvl@[dpvty]));
		val pack_al = list_mk_app (pack, al);
		val t = mk_var("t",type_of pack_al);
		val projs = map (fn f => match_mk_app(f,t)) dpvprojs;
		val pred = list_mk_± projs;
		val abs_pred = mk_Ã(t,pred);
		val abs_pred_pack_al = mk_app(abs_pred,pack_al);
		val exists = mk_∂â1 (alt, abs_pred_pack_al);
		val lhs = mk_app(cvar,pack);
		val body = mk_eq(lhs,exists);
		val defn = mk_µ(pack,body);
	in
		local_const_spec "∂â1_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "∂â1_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Schema Constructor}
=IGN
val tm = mk_z_âs (mk_z_decl1([mk_z_dec([¨a:˙Æ, ¨b:˙Æ],Ò˙Æ)]), mk_z_true);
val nam = (fst(dest_const (fst (strip_app tm))));
val ("Z'âs",[cpl], Nil) = dest_z_name nam;

=SML
fun €schema_gen_semantic_const› (tm:TERM) : THM = (
let	val nam = (fst(dest_const (fst (strip_app tm))));
in
	case dest_z_name nam of
	("Z'âs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val ty = hd(snd(dest_ctype(type_of tm)));
		val tyvl = map mk_z_var_t cpl;
		val dpty = mk_z_schema_t[("d",BOOL),("p",BOOL)];
		val side = binding_type_spec dpty;
		val (dpcon,dpprojs) = get_binding_info dpty;
		val side = binding_type_spec ty;
		val (con,projs) = get_binding_info ty;
		val bty = (strip_type o type_of) con;
		val argty = list_mk_≠_type(tyvl@[dpty]);
		val resty = mk_z_power_t bty;
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val x = mk_var("x",bty);
		val p = mk_var("p",argty);
		val t = list_match_mk_app(p,map (fn pr => match_mk_app(pr,x)) projs);
		val conj = list_mk_±(map (fn pr => match_mk_app(pr,t)) dpprojs);
		val setcomp = mk_set_comp (x, conj);
		val lhs = mk_app(cvar, p);
		val body = mk_eq(lhs, setcomp);
		val defn = mk_µ (p, body);
	in
		local_const_spec "schema_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "schema_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Decoration}
=IGN
val tm = mk_z_decâs(Ò[x,y,xy:˙]Æ,"''");
val tm' = fst (strip_app tm);
val nam = (fst(dest_const tm'));
val ("Z'Decâs",[cpl,decor], Nil) = dest_z_name nam;
=SML
fun €decâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = (fst(dest_const tm'));
in
	case dest_z_name nam of
	("Z'Decâs",[cpl,decor], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty,rresty) = (
			case snd(dest_ctype(type_of tm')) of [ty1,ty2] => (dest_z_power_t ty1,dest_z_power_t ty2)
			|	_ => fail "" 0 []);
		val side = binding_type_spec rargty;
		val (con,proj) = get_binding_info rargty;
		val side = binding_type_spec rresty;
		val (con',proj') = get_binding_info rresty;
		val bty = (strip_type o type_of) con;
		val resty = (strip_type o type_of) con';
		val tym = dest_z_schema_t bty;
		val tym' = dest_z_schema_t resty;
		val rbty = mk_z_schema_t(combine (fst(split tym')) (snd(split tym)));
		val sch = mk_var("sch",mk_z_power_t bty);
		val sch' = mk_var("sch",mk_z_power_t rbty);
		val bvar = mk_var ("bind", bty);
		val bdecvar = mk_var ("bind'", rbty);
		val bmem = mk_ç (bvar, sch);
		val varl = map ((switch o curry) match_mk_app bvar) proj;
		val bind = (list_match_mk_app (con', varl));
		val bdeceq = mk_eq(bdecvar,bind);
		val pred = mk_± (bmem, bdeceq);
		val nam' = fst(dest_const tm');
		val cvar = mk_var(nam',mk_≠_type(type_of sch,type_of sch'));
		val exists = mk_∂(bvar, pred);
		val setcomp = mk_set_comp(bdecvar,exists);
		val lhs = mk_app(cvar, sch);
		val body = mk_eq(lhs, setcomp);
		val defn = mk_µ (sch, body);
		in
			local_const_spec "decâs_gen_semantic_const" (nam, cvar, defn)
		end))
	| _ => error "decâs_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Schema Precondition}
=IGN
val tm = mk_z_preâsÒ[a',b',c:˙]Æ;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Preâs",[cpl], Nil) = dest_z_name nam;
=SML
fun €schema_results› (itym:((string*string) * TYPE)list) =
	(map fst itym) drop (fn (_,d) => (not(d = "'") andalso not(d = "!")));
=TEX
=SML
fun €preâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'Preâs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty,rresty) = (
		case snd(dest_ctype(type_of tm')) of
			[ty1,ty2] => (dest_z_power_t ty1,dest_z_power_t ty2)
			|_ => fail "" 0 []);
		val side = binding_type_spec rargty;
		val (con, _) = get_binding_info rargty;
		val bty = (strip_type o type_of) con;
		val atym = dest_z_schema_t bty;
		val aidtym = map (fn (s,t) => (unpack_ident s,t)) atym;
		val hidtym = map (fn x => (x,lassoc3 aidtym x)) (schema_results aidtym);
		val htym = map (fn (s,t) => (pack_ident s,t)) hidtym;
		val rtym = (op diff') (atym, htym);
		val side = binding_type_spec(mk_z_schema_t rtym);
		val argty = mk_z_power_t(mk_z_schema_t atym);
		val resty = mk_z_power_t(mk_z_schema_t rtym);
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1(map mk_z_univ_decl rtym);
		val pd = mk_z_decl1(map mk_z_univ_decl htym);
		val p = mk_z_∂(pd,mk_z_true,mk_z_predsexp(s,""));
		val sch = mk_z_âs(d,p);
		val dummy = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs, sch);
		val defn = mk_µ (s, body);
	in
		local_const_spec "preâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "preâs_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Schema Hiding}
=IGN
val tm = mk_z_hideâs (Ò[a,b,c:˙]Æ, ["c"]);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Hideâs",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €hideâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm' = fst (strip_app tm);
	val nam = fst(dest_const tm');

in
	case dest_z_name nam of
	("Z'Hideâs",[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty,rresty) = (
		case snd(dest_ctype(type_of tm')) of
			[ty1,ty2] => (dest_z_power_t ty1,dest_z_power_t ty2)
			|_ => fail "" 0 []);

		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (con,_) = get_binding_info rargty;
		val bty = (strip_type o type_of) con;
		val tym = dest_z_schema_t bty;
		val rtym = map (fn s => (s,lassoc3 tym s)) (cpl1 diff cpl2);
		val htym = map (fn s => (s,lassoc3 tym s)) cpl2;
		val argty = mk_z_power_t bty;
		val resty = mk_z_power_t(mk_z_schema_t(rtym));
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1(map mk_z_univ_decl rtym)
		val pd = mk_z_decl1(map mk_z_univ_decl htym);
		val p = mk_z_∂(pd,mk_z_true,mk_z_predsexp(s,""));
		val sch = mk_z_âs(d,p);
		val dummy = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs, sch);
		val defn = mk_µ (s, body);
	in
		local_const_spec "hideâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "hideâs_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Schema Dyadic Operators}
=IGN
val schexpr = fst o dest_z_decsexp o
		hd o dest_z_decl o
		fst o dest_z_âs;
val tm = mk_z_±âs (Ò[a,b,c:˙]Æ, Ò[d:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val (oper,[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €dyopâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	(oper,[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (ra1ty,ra2ty,rresty) = (
			case snd(dest_ctype(type_of tm')) of 
			[ty1,tya] => (
				case snd(dest_ctype tya) of
				[ty2,ty3] => (dest_z_power_t ty1,dest_z_power_t ty2,dest_z_power_t ty3)
				|_ => fail "" 0 []
				)
			|_ => fail "" 0 []);
		val side = binding_type_spec ra1ty;
		val side = binding_type_spec ra2ty;
		val side = binding_type_spec rresty;
		val (cona1,proja1) = get_binding_info ra1ty;
		val (cona2,proja2) = get_binding_info ra2ty;
		val (conr,projr) = get_binding_info rresty;
		val rbty = (strip_type o type_of) conr;
		val tym = map 	(fn(s,ty) => (s,mk_vartype((dest_vartype ty) ^ "a"))) 
					(dest_z_schema_t rbty);
		val tym1 = combine cpl1 (map (lassoc3 tym) cpl1);
		val tym2 = combine cpl2 (map (lassoc3 tym) cpl2);
		val a1bty = mk_z_schema_t tym1;
		val a2bty = mk_z_schema_t tym2;
		val rbty' = mk_z_schema_t tym;
		val sch1 = mk_var("sch1",mk_z_power_t a1bty);
		val sch2 = mk_var("sch2",mk_z_power_t a2bty);
		val sch = mk_var("sch",mk_z_power_t rbty');
		val bvar = mk_var ("bind", rbty');
		fun dopr pr =
		let	val tup = (map (fn x=>((dest_z_name
				o fst o dest_const) x,x)) pr);
		in
			map (fn ((_,_, x), y)=>(x,y)) tup
		end;
		val pr1 = map snd ((dopr projr) drop (fn (x,_) =>
			not(x mem (map fst (dopr proja1)))));
		val pr2 = map snd ((dopr projr) drop (fn (x,_) =>
			not(x mem (map fst (dopr proja2)))));
		val varl1 = map ((switch o curry) match_mk_app bvar) pr1;
		val varl2 = map ((switch o curry) match_mk_app bvar) pr2;
		val memb1 = mk_ç(list_match_mk_app (cona1, varl1),sch1);
		val memb2 = mk_ç(list_match_mk_app (cona2, varl2),sch2);
		val desc = (
			case oper of 	"Z'±âs" => mk_±(memb1,memb2)
			|		"Z'≤âs" => mk_≤(memb1,memb2)
			|		"Z'¥âs" => mk_¥(memb1,memb2)
			|		"Z'§âs" => mk_§(memb1,memb2)
			|		_ => fail "" 0 []
			);
		val setcomp = mk_set_comp (bvar, desc);
		val cvar = mk_var(nam,list_mk_≠_type([type_of sch1,type_of sch2,type_of sch]));
		val lhs = list_mk_app(cvar, [sch1, sch2]);
		val body = mk_eq(lhs,setcomp);
		val defn = list_mk_µ ([sch1,sch2], body);
	in
		local_const_spec "dyopâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "dyopâs_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Schema Projection}
=IGN
val tm = mk_z_˘âs (Ò[a,b,c:˙]Æ, Ò[b:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'˘âs",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €˘âs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'˘âs",[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle Fail _ => (
	let	val (rargty1,rargty2,rresty) = (
		case snd(dest_ctype(type_of tm')) of
			[ty1,ty] => (
				case snd(dest_ctype ty) of [ty2,ty3] => (dest_z_power_t ty1,dest_z_power_t ty2,dest_z_power_t ty3)
				|_ => fail "" 0 []
				)
			|_ => fail "" 0 []
			);
		val side = binding_type_spec rargty1;
		val side = binding_type_spec rargty2;
		val tym = combine (cpl1 cup cpl2) (map mk_z_var_t(cpl1 cup cpl2));
		val argty1 = mk_z_power_t(mk_z_schema_t(map (fn s => (s,lassoc3 tym s)) cpl1));
		val argty2 = mk_z_power_t(mk_z_schema_t(map (fn s => (s,lassoc3 tym s)) cpl2));
		val resty = argty2;
		val cvar = mk_var(nam,list_mk_≠_type([argty1,argty2,resty]));
		val s1 = mk_var("sch1",argty1);
		val s2 = mk_var("sch2",argty2);
		val hidel = cpl1 diff cpl2;
		val schand = mk_z_±âs(s1,s2);
		val dummy = dyopâs_gen_semantic_const schand;
		val sch = mk_z_hideâs(schand,hidel);
		val side = hideâs_gen_semantic_const sch;
		val lhs = list_mk_app(cvar, [s1,s2]);
		val body = mk_eq(lhs, sch);
		val defn = list_mk_µ ([s1,s2], body);
	in
		local_const_spec "˘âs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "˘âs_gen_semantic_const" 50100 []
end);
=TEX

\subsection{Delta Constructor}
=IGN
val tm = mk_z_Ñâs Ò[a,b,c:˙]Æ;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'Ñâs",[cpl], Nil) = dest_z_name nam;
=SML
fun €Ñâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'Ñâs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty,rresty) = (
			case snd(dest_ctype(type_of tm')) of
			[ty1,ty2] => (dest_z_power_t ty1,dest_z_power_t ty2)
			|_ => fail "" 0 []
			);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (cona,_) = get_binding_info rargty;
		val (conr,_) = get_binding_info rresty;
		val bty = (strip_type o type_of) cona;
		val rbty = (strip_type o type_of) conr;
		val tym = dest_z_schema_t bty;
		val tym' = map (fn(s,ty) => ((s ^ "'"),ty)) tym;
		val argty = mk_z_power_t(mk_z_schema_t tym);
		val resty = mk_z_power_t(mk_z_schema_t(tym @ tym'));
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1[mk_z_decsexp(s,""),mk_z_decsexp(s,"'")];
		val p = mk_z_true;
		val sch = mk_z_âs(d,p);
		val side = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq(lhs,sch);
		val defn = mk_µ(s,body);
	in
		local_const_spec "Ñâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "Ñâs_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Xi Constructor}
=IGN
val tm = mk_z_òâsÒ[a,b,c:˙]Æ;
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'òâs",[cpl], Nil) = dest_z_name nam;
=SML
fun €òâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'òâs",[cpl], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty,rresty) = (
			case snd(dest_ctype(type_of tm')) of
			[ty1,ty2] => (dest_z_power_t ty1,dest_z_power_t ty2)
			|_ => fail "" 0 []
			);
		val side = binding_type_spec rargty;
		val side = binding_type_spec rresty;
		val (cona,_) = get_binding_info rargty;
		val (conr,_) = get_binding_info rresty;
		val bty = (strip_type o type_of) cona;
		val rbty = (strip_type o type_of) conr;
		val tym = dest_z_schema_t bty;
		val tym' = map (fn(s,ty) => ((s ^ "'"),ty)) tym;
		val argty = mk_z_power_t(mk_z_schema_t tym);
		val resty = mk_z_power_t(mk_z_schema_t(tym @ tym'));
		val cvar = mk_var(nam,mk_≠_type(argty,resty));
		val s = mk_var("sch",argty);
		val d = mk_z_decl1[mk_z_decsexp(s,""),mk_z_decsexp(s,"'")];
		val p = mk_z_eq(mk_z_ (s,""),mk_z_ (s,"'"));
		val sch = mk_z_âs(d,p);
		val side = schema_gen_semantic_const sch;
		val lhs = mk_app(cvar, s);
		val body = mk_eq (lhs, sch);
		val defn = mk_µ(s, body);
	in
		local_const_spec "òâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "òâs_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Schema Quantification}
=SML
fun €sort_projs› (pr : TERM list) : TERM list = (
let	val pr' = map (fn p => (((dest_vartype o type_of) p)^
		hd(PrettyPrinter.format_term false p), p)) pr;
	fun rsort (s1,_) (s2,_) =
			Sort.string_order s1 s2;
in
	map snd (Sort.sort rsort pr')
end);
=TEX

=IGN
val tm = mk_z_∂âs (mk_z_decl1([mk_z_dec([¨a:˙Æ],Ò˙Æ)]), mk_z_true, Ò[a,b,c:˙]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val (oper,[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €quantâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	(oper,[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty1,rargty2,rresty) = (
			case snd(dest_ctype(type_of tm')) of
			[ty1,ty] => (
				case snd(dest_ctype ty) of
				[ty2,ty3] => (ty1,dest_z_power_t ty2,dest_z_power_t ty3)
				|_ => fail "" 0 []
				)
			|_ => fail "" 0 []
			);
		val sdp = (hd o rev o strip_≠_type) rargty1;
		val side = binding_type_spec sdp;
		val (_,tprojs) = get_binding_info sdp;
		val side = binding_type_spec rargty2;
		val (con,_) = get_binding_info rargty2;
		val side = binding_type_spec rresty;
		val (xcon,xprojs) = get_binding_info rresty;
		val bty2 = (strip_type o type_of) con;
		val rbty = (strip_type o type_of) xcon;
		val tym = dest_z_schema_t bty2;
		val argty1 = list_mk_≠_type((map (lassoc3 tym) cpl1)@[sdp]);
		val argty2 = mk_z_power_t(mk_z_schema_t tym);
		val resty = mk_z_power_t(mk_z_schema_t(map (fn s => (s,lassoc3 tym s)) cpl2));
		val ybty = mk_z_schema_t(map (fn s => (s,lassoc3 tym s)) cpl1);
		val side = binding_type_spec ybty;
		val (_,yprojs) = get_binding_info ybty;
		val cvar = mk_var(nam,list_mk_≠_type([argty1,argty2,resty]));
		val p = mk_var("p",argty1);
		val q = mk_var("q",argty2);
		val x = mk_var("x",dest_z_power_t resty);
		val y = mk_var("y",ybty);
		val xprojections = map (fn f => match_mk_app(f,x)) xprojs;
		val yprojections = map (fn f => match_mk_app(f,y)) yprojs;
		val projections = xprojections @ yprojections;
		val sorted_projections = sort_projs projections;
		val t = list_mk_app (p, yprojections);
		val conj1 = list_mk_±(map (fn pf => match_mk_app(pf,t)) tprojs);
		val conj2 = mk_ç(list_match_mk_app (con, sorted_projections),q);
		val pred = mk_±(conj1,conj2);
		val desc = (
			case oper of 	"Z'µâs" => mk_µ(y,pred)
			|		"Z'∂âs" => mk_∂(y,pred)
			|		"Z'∂â1âs" => mk_∂â1(y,pred)
			|		_ => fail "" 0 []
			);
		val setcomp = mk_set_comp(x,desc);
		val lhs = list_mk_app (cvar, [p,q]);
		val body = mk_eq(lhs, setcomp);
		val defn = list_mk_µ ([p, q], body);
	in
		local_const_spec "quantâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "quantâs_gen_semantic_const" 50100 []
end);
=TEX
\subsection{Schema Composition}
=IGN
val tm = mk_z_ªâs (Ò[x,b,c,d':X]Æ, Ò[d:X;e:Y]Æ);
val tm = mk_z_ªâs (Ò[x:X]Æ, Ò[y:Y]Æ);
val tm'= fst (strip_app tm);
val nam = fst(dest_const tm');
val ("Z'ªâs",[cpl1,cpl2], Nil) = dest_z_name nam;
=SML
fun €ªâs_gen_semantic_const› (tm:TERM) : THM = (
let	val tm'= fst (strip_app tm);
	val nam = fst(dest_const tm');
in
	case dest_z_name nam of
	("Z'ªâs",[cpl1,cpl2], Nil) => (get_cached_defn (nam ^ "_def")
	handle (Fail _) => (
	let	val (rargty1,rargty2,rresty) = (
			case snd(dest_ctype(type_of tm')) of
			[ty1,ty] => (
				case snd(dest_ctype ty) of
				[ty2,ty3] => (dest_z_power_t ty1,
					dest_z_power_t ty2,dest_z_power_t ty3)
				|_ => fail "" 0 []
				)
			|_ => fail "" 0 []);
		val side = binding_type_spec rargty1;
		val side = binding_type_spec rargty2;
		val side = binding_type_spec rresty;
		val (conr,_) = get_binding_info rresty;
		val rbty = (strip_type o type_of) conr;
		val rcpl = map fst (dest_z_schema_t rbty);
		val ocpl = cpl1 drop (fn s => snd(unpack_ident s) <> "'");
		val icpl = cpl2 drop (fn s => snd(unpack_ident s) <> "");
		val icpl' = map (fn s => (s ^ "'")) icpl;
		val (mcpl,mcpl') = split ((combine icpl icpl')
			drop (fn (i,i') => not (i' mem ocpl)));
		val rtyvars = map mk_z_var_t rcpl;
		val mtyvars = map mk_z_var_t mcpl;
		val rtym = combine rcpl rtyvars;
		val mtym = combine mcpl mtyvars;
		val mtym' = combine mcpl' mtyvars;
		val a1tym = map (fn s => (s,lassoc3 (mtym' @ rtym) s)) cpl1;
		val a2tym = map (fn s => (s,lassoc3 (mtym @ rtym) s)) cpl2;
		val argty1 = mk_z_power_t(mk_z_schema_t a1tym);
		val argty2 = mk_z_power_t(mk_z_schema_t a2tym);
		val resty = mk_z_power_t(mk_z_schema_t rtym);
		val mty = mk_z_power_t(mk_z_schema_t mtym);
		val cvar = mk_var(nam,list_mk_≠_type([argty1,argty2,resty]));
		val s1 = mk_var("sch1",argty1);
		val s2 = mk_var("sch2",argty2);
		val std = mk_z_decl1 (map mk_z_univ_decl mtym)
		val st = mk_z_âs (std,mk_z_true);
		val sch1 = mk_z_âs(	mk_z_decl1[mk_z_decsexp(s1,""),mk_z_decsexp(st,"''")],
						mk_z_eq(mk_z_ (st,"'"),mk_z_ (st,"''")));
		val side = schema_gen_semantic_const sch1;
		val sch2 = mk_z_âs(	mk_z_decl1[mk_z_decsexp(s2,""),mk_z_decsexp(st,"''")],
						mk_z_eq(mk_z_ (st,""),mk_z_ (st,"''")));
		val side = schema_gen_semantic_const sch2;
		val conj1 = mk_z_∂âs(mk_z_decl1[mk_z_decsexp(st,"'")],mk_z_true,sch1);
		val side = quantâs_gen_semantic_const conj1;
		val conj2 = mk_z_∂âs(mk_z_decl1[mk_z_decsexp(st,"")],mk_z_true,sch2);
		val dummy = quantâs_gen_semantic_const conj2;
		val conj = mk_z_±âs(conj1,conj2);
		val side = dyopâs_gen_semantic_const conj;
		val sch = mk_z_∂âs(mk_z_decl1[mk_z_decsexp(st,"''")],mk_z_true,conj);
		val side = quantâs_gen_semantic_const sch;
		val lhs = list_mk_app (cvar,[s1,s2]);
		val body = mk_eq(lhs,sch);
		val defn = list_mk_µ([s1, s2],body);
	in
		local_const_spec "ªâs_gen_semantic_const" (nam, cvar, defn)
	end))
	| _ => error "ªâs_gen_semantic_const" 50100 []
end);
=TEX

\subsection{Renaming Z Schemas}
=SML
fun €renameâs_gen_semantic_const› (tm : TERM) : THM = (
let	val (s,rnl) = dest_z_renameâs tm
		handle complaint =>
		pass_on complaint "dest_z_renameâs" "renameâs_gen_semantic_const";
	val nam = fst(dest_const (fst (dest_app tm)));
in
	get_cached_defn (nam ^ "_def")
	handle Fail _ => (
let
	val tyfrom = dest_z_power_t(type_of s);
	val tyto = dest_z_power_t(type_of tm);
=TEX
The following two may be redundant, but ...
=SML
	val side = binding_type_spec tyto;
	val side = binding_type_spec tyfrom;
	val from_comp = map fst (dest_z_schema_t tyfrom);
	val to_comp = map fst (dest_z_schema_t tyto);
	val ty_insts =(map (fn (a,b) => 
		(mk_vartype ("'"^a),
		mk_vartype ("'"^b))) rnl);
	val ty_inst = inst_type ty_insts;
	val tm_inst = inst [] ty_insts;
	val tyfrom_generic = ty_inst (mk_ctype
			(fst(dest_ctype tyfrom),
			map (mk_vartype o (fn y => "'" ^ y)) from_comp));
	val p_tyfrom_generic = mk_z_power_t tyfrom_generic;
	val tyto_generic = ty_inst(mk_ctype
			(fst(dest_ctype tyto),
			map (mk_vartype o (fn y => "'" ^ y)) to_comp));
	val p_tyto_generic = mk_z_power_t tyto_generic;
	val const_generic = mk_var(nam,
		mk_≠_type(p_tyfrom_generic, p_tyto_generic));
	val argS = mk_var("S",p_tyfrom_generic);
	val args = mk_var("s",tyto_generic);
	val args' = mk_var("s'",tyfrom_generic);
	val (to_con,_) = get_binding_info tyto_generic;
	val (_,from_projs) = get_binding_info tyfrom_generic;
	val from_projs' = map tm_inst from_projs;
 	val from_bits = map (fn x => mk_app(x,args')) from_projs';
	val from_bits_assoc = combine from_comp from_bits;
	fun aux tb = lassoc3 from_bits_assoc (lassoc1 rnl tb);
	val to_bits = map aux to_comp;
	val inner_rhs = list_mk_app(to_con, to_bits);
	val inner_ç = list_mk_app(
		mk_const("ç",list_mk_≠_type[type_of args',
			type_of argS, BOOL]),
		[args', argS]);	
	val inner_∂ = mk_∂(args',
		mk_±(inner_ç ,
		mk_eq(args,inner_rhs)));
	val rhs = mk_set_comp(args, inner_∂);
	val lhs = mk_app(const_generic, argS);
	val def_tm = mk_µ(argS, mk_eq(lhs,rhs));
in
	local_const_spec "renameâs_gen_semantic_const" (nam, const_generic, def_tm)
end)
end);
=TEX	 
\section{END OF STRUCTURE}
The structure is left closed.
=SML
end (* of local ... in *);
end (* of structure ZGeneratedConstants *);
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

