%  dtd085.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of the Z Library Functions}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD085}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
% \TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\K.~Blackburn & WIN01}
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design of
the Z Library Functions and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Project Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (22nd October 1992)]
First version, derived from 078 and 083.
\item [Issue 1.2 (30th October 1992)]
Tidying up.
\item [Issue 1.3, 12th November 1992] 
Changes as a consequence of changes in dependences.
\item [Issue 1.4, 16th November 1992] 
Added additional theorems for reasoning about applications.
\item[Issue 1.5 (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.6 (17th December 1992)]
Removed spurious ML bindings.
\item[Issue 1.7,1.8 (8th-11th February 1993)]
Rearranging proof contexts.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design
of the mathematical toolkit for HOL/Z.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD017}.
\subsection{Dependencies}
Loading this document and its implementation requires that
\cite{DS/FMU/IED/IMP083} has been loaded.
\subsection{Possible Enhancements}
The only current proof context expands out memberships of Z functions, which
is too brutal for a general-purpose mild proof context. The only alternative,
which is interesting, but still doesn't fit the bill, is:
=GFT
x ﬂ y   ---> unchanged
x ≠ y   ---> (x ﬂ y) ° {f:U | dom f = x}
x ˛ y   ---> (x ﬂ y) ° {f:U | µx1,x2:dom f∑ f x1 = f x2 ¥ x1 = x2}
x ‡ y   ---> (x ﬂ y) ° {f:U | dom f = x} °
			{f:U | µx1,x2:dom f∑ f x1 = f x2 ¥ x1 = x2}
x œ y   ---> (x ﬂ y) ° {f:U | ran f = y}
x Ô y   ---> (x ﬂ y) ° {f:U | dom f = x} ° {f:U | ran f = y}
x è y   ---> (x ﬂ y) ° {f:U | dom f = x} ° {f:U | ran f = y} °
			{f:U | µx1,x2:dom f∑ f x1 = f x2 ¥ x1 = x2}
=TEX
This normalises onto $ﬂ$, which seems a potentially interesting idea.
A variant of the idea would "protect" the set comprehensions against
expansion becase of a membership, by introducing 3 appropriate constants.

\subsection{Deficiencies}
None known.
\section{PROLOGUE}

=SML
open_theory"z_relations";
push_pc "z_sets_ext";
delete_theory"z_functions" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
new_theory"z_functions";
=TEX
\section {DEFINITION OF FIXITY}

The following fixity information has been taken from \cite{Spivey89}.



πZ
gen 5 _ ﬂ _, _ ˛ _, _ ‡ _, _ œ _, _ Ô _
∞

πZ
gen 5 _ è _, _ ü _, _ û _
∞

\section{FUNCTIONS}
Note that $≠$ is defined in \cite{DS/FMU/IED/DTD078},
as it is required to define the Z Library set material.

\subsection{Partial Functions}

πZ
X €ﬂ› Y ¶ {f : X ™ Y |
	(µ x : X; y1, y2 : Y ∑ (x Ì y1) ç f ± (x Ì y2) ç f ¥ (y1 = y2))}
∞

\subsection{Injections}

πZ
X €˛› Y ¶ {f : X ﬂ Y | (µ x1, x2 : dom f ∑ f (x1) = f (x2) ¥ x1 = x2)}
∞

πZ
X €‡› Y ¶ (X ˛ Y) ° (X ≠ Y)
∞

\subsection{Surjections}

πZ
X €œ› Y ¶ {f : X ﬂ Y | ran f = Y}
∞

πZ
X €Ô› Y ¶ (X œ Y) ° (X ≠ Y)
∞

\subsection{Bijection}

πZ
X €è› Y ¶ (X Ô Y) ° (X ‡ Y)
∞
\section{START OF STRUCTURE}
=DOC
signature €ZFunctions› = sig
=DESCRIBE
This provides the basic proof support for the Z library functions.
It creates the theory $z\_functions$.
=ENDDOC
=THDOC
req_name €"z_functions"› (Value "z_relations");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_functions$ contains various definitions of function operators, and ``defining theorems'' derived from these definitions.
It is created in structure $ZFunctions$.
=ENDDOC

=THDOC
req_thm(€"z_ﬂ_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ﬂ Y
      § f ç X ™ Y
	± (µ x : X; y1, y2 : Y∑ (x, y1) ç f ± (x, y2) ç f ¥ y1 = y2)Æ));
req_thm(€"z_ﬂ_thm1"›, ([],Òµ f : U; X : U; Y : U
          ∑ f ç (X ﬂ Y)
            § f ç (X ™ Y)
              ± (µ x : U; y1, y2 : U |
		x ç X ± y1 ç Y ± y2 ç Y
                ∑ (x, y1) ç f ± (x, y2) ç f ¥ y1 = y2)Æ));
req_thm(€"z_≠_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ≠ Y § f ç X ﬂ Y ± dom f = XÆ));
req_thm(€"z_≠_app_thm"›, ([],Òµ X: U; Y: U; 
	f: U; x: U∑
	f ç X ≠ Y ± x ç X ¥ f x ç Y ± (x, f x) ç fÆ));
req_thm(€"z_ﬂ_clauses"›, ([], Òµ Y:U ∑
	{} ﬂ Y = {{}} ±
	Y ﬂ {} = {{}}Æ));
req_thm(€"z_≠_clauses"›, ([], Òµ Y:U ∑
	{} ≠ Y = {{}} ±
	Y ≠ {} = {x:U| x = {} ± Y = {}}Æ));

=DESCRIBE
Partial and total functions.
$z\_ﬂ\_thm$ is compact, but $z\_ﬂ\_thm1$ is better for
rewriting.
=ENDDOC
Spivey Ed 1. page 105

=THDOC
req_thm(€"z_˛_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ˛ Y
      § f ç X ﬂ Y ± (µ x1, x2 : U | 
		x1 ç dom f ± x2 ç dom f ∑ f x1 = f x2 ¥ x1 = x2)Æ));
req_thm(€"z_‡_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ‡ Y
      § f ç X ≠ Y ± (µ x1, x2 : U | 
		x1 ç dom f ± x2 ç dom f∑ 
		f x1 = f x2 ¥ x1 = x2)Æ));
req_thm(€"z_˛_clauses"›, ([], Òµ Y:U ∑
	{} ˛ Y = {{}} ±
	Y ˛ {} = {{}}Æ));
req_thm(€"z_‡_clauses"›, ([], Òµ Y:U ∑
	{} ‡ Y = {{}} ±
	Y ‡ {} = {x:U| x = {} ± Y = {}}Æ));
=DESCRIBE
Partial and total injections.
=ENDDOC
Spivey Ed 1. page 106

=THDOC
req_thm(€"z_œ_thm"›, ([], Òµ f: U;
	X: U; Y: U∑
	f ç X œ Y § f ç X ﬂ Y ± ran f = YÆ));
req_thm(€"z_Ô_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X Ô Y § f ç X ≠ Y ± ran f = YÆ));
req_thm(€"z_è_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X è Y
	§ f ç X ≠ Y
	 ± ran f = Y
	 ± (µ x1, x2 : U |
		x1 ç dom f ± x2 ç dom f ∑
		f x1 = f x2 ¥ x1 = x2)Æ));
req_thm(€"z_œ_clauses"›, ([], Òµ Y:U ∑
	{} œ Y = {x:U| x = {} ± Y = {}} ±
	Y œ {} = {{}}Æ));
req_thm(€"z_Ô_clauses"›, ([], Òµ Y:U ∑
	{} Ô Y = {x:U| x = {} ± Y = {}} ±
	Y Ô {} = {x:U| x = {} ± Y = {}}Æ));
req_thm(€"z_è_clauses"›, ([], Òµ Y:U ∑
	{} è Y = {x:U| x = {} ± Y = {}} ±
	Y è {} = {x:U| x = {} ± Y = {}}Æ));

=DESCRIBE
Partial and total surjections, and bijections.
=ENDDOC
Spivey Ed 1. page 106

=THDOC
req_thm(€"z_≠_app_ç_rel_thm"›, ([],
	ÒµX: U; Y : U∑µf : X ≠ Y; x : X∑(x, f x) ç fÆ));
req_thm(€"z_≠_app_eq_§_ç_rel_thm"›, ([],
	ÒµX: U; Y : U∑µf : X ≠ Y; x : X∑f x = z § (x, z) ç fÆ));
req_thm(€"z_≠_ç_rel_§_app_eq_thm"›, ([],
	ÒµX: U; Y : U∑µf : X ≠ Y; x : X∑(x, z) ç f § f x = zÆ));
=DESCRIBE
These theorems are convenient for use in a forward or backwards
chaining style to reason about function application.
=ENDDOC

The following are here because they rely on functional
reasoning in their implementation.
=THDOC
req_thm(€"z_ç_first_thm"›, ([],Òµ x: U ∑
	x ç first § x.1.1 = x.2Æ));
req_thm(€"z_ç_second_thm"›, ([],Òµ x: U ∑
	x ç second § x.1.2 = x.2Æ));
=DESCRIBE
Projections from pairs considered as relations.
=SEEALSO
$z\_first\_thm$, $z\_second\_thm$.
=ENDDOC
These theorems reflect a preference for the
general tuple selection functions.
Spivey Ed 1. page 89.


\subsection{Definitions of the Theory}

=DOC
val €z_ﬂ_def› : THM;				val €z_˛_def› : THM;
val €z_‡_def› : THM;				val €z_œ_def› : THM;
val €z_Ô_def› : THM;				val €z_è_def› : THM;	
=DESCRIBE
These are the ML bindings of the defining theorems in the theory $z\_functions$.
=ENDDOC
=DOC
val €z_ﬂ_thm› : THM;			val €z_ﬂ_thm1› : THM;
val €z_≠_thm› : THM;			val €z_≠_app_thm› : THM;
val €z_˛_thm› : THM;			val €z_‡_thm› : THM;
val €z_œ_thm› : THM;			val €z_Ô_thm› : THM;
val €z_è_thm› : THM;			val €z_ç_first_thm› : THM;
val €z_ç_second_thm› : THM;		val €z_≠_app_ç_rel_thm› : THM;
val €z_≠_app_eq_§_ç_rel_thm› : THM;	val €z_≠_ç_rel_§_app_eq_thm› : THM;
val €z_ﬂ_clauses› : THM; 		val €z_≠_clauses› : THM; 
val €z_˛_clauses› : THM;			val €z_‡_clauses› : THM; 
val €z_œ_clauses› : THM;			val €z_Ô_clauses› : THM;
val €z_è_clauses› : THM; 
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_functions$.
=ENDDOC
\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{4in}}
$'z\_ç\_fun$ & Membership of Z functions (e.g. $ﬂ$). \\
\end{tabular}
=DOC
(* Proof Context: €'z_ç_fun› *)
=DESCRIBE
A component proof context for handling the membership of Z functions created by Z library operations.
Expressions and predicates treated by this proof context are constructs formed from:
=GFT
œ, Ô, è, ˛, ‡, ﬂ, ≠
=TEX

\paragraph{Contents}\ 

Rewriting:
=GFT
=TEX

Stripping theorems:
=GFT
=TEX

Stripping conclusions:
=GFT
=TEX
All three of the above also have theorems concerning the membership of terms generated by the following operators:
=GFT
œ, Ô, è, ˛, ‡, ﬂ, ≠
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``$'$z$\_ç\_$rel''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
=DOC
(* Proof Context: €'z_fun_alg› *)
=DESCRIBE
A component proof context for handling the simplification of Z functions created by Z library operations.
Expressions and predicates treated by this proof context are constructs formed from:
=GFT
ﬂ, ≠, ˛, ‡, œ, Ô, è
=TEX

\paragraph{Contents}\ 

Rewriting:
=GFT
z_ﬂ_clauses, z_≠_clauses, z_˛_clauses,
z_‡_clauses, z_Ô_clauses, z_œ_clauses, z_è_clauses
=TEX

Stripping theorems:
=GFT
z_ﬂ_clauses, z_≠_clauses, z_˛_clauses,
z_‡_clauses, z_Ô_clauses, z_œ_clauses, z_è_clauses
Expressed as membership statements as necessary, using ç_C.
All also pushed through ≥.
=TEX

Stripping conclusions:
=GFT
z_ﬂ_clauses, z_≠_clauses, z_˛_clauses,
z_‡_clauses, z_Ô_clauses, z_œ_clauses, z_è_clauses
Expressed as membership statements as necessary, using ç_C.
All also pushed through ≥.
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``$'$z$\_ç\_$rel''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC

\section{EPILOGUE}
=SML
end; (* of signature ZFunctions *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX

\section{TEST POLICY}
The module tests for this module are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


