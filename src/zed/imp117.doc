=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Implementation of the Z Library Real Numbers }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the implementation for the theory
of real numbers in \ProductZ.}
\end{center}}

\def\Reference{LEMMA1/HOL/IMP117}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.5 $%
}
\def\Date{\FormatDate{$Date: 2001/05/28 13:57:46 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1-1.4] Initial development drafts.
\item[Issues 1.5,1.6] Corrected errors in theorems about associativity and multiplication and
some improvements to the treatment of unary negation in the proof contexts.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document contains the implementation
of the Z Library theory of real numbers and their proof support.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.


\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{PREAMBLE}

=SML
structure ÛZRealsÝ (* : ZReals *) = struct
=SML
val _ = open_theory"z_reals";
=TEX
\section{DEFINITIONS}
=SML
val Ûz_¯_defÝ = z_get_specñ¯®;
val Ûz_¯_less_defÝ = z_get_specñ(_<‰R_)®;
val Ûz_¯_¼_defÝ = z_¯_less_def;
val Ûz_¯_minus_defÝ = z_¯_less_def;
val Ûz_¯_plus_defÝ = z_¯_less_def;
val Ûz_¯_times_defÝ = z_¯_less_def;
val Ûz_¯_over_defÝ = z_¯_less_def;
val Ûz_¯_abs_defÝ = z_¯_less_def;

val Ûz_¯_greater_defÝ = z_get_specñ(_>‰R_)®;
val Ûz_¯_¾_defÝ = z_¯_greater_def;
val Ûz_¯_subtract_defÝ = z_¯_greater_def;

val Ûz_¯_real_defÝ = z_get_specñreal®;
val Ûz_¯_frac_defÝ = z_get_specñ(_/‰Z_)®;
val Ûz_¯_ú_exp_defÝ = z_get_specñ(_^‰Z_)®;
val Ûz_¯_dot_dot_defÝ = z_get_specñ(_..‰R_)®;

=TEX
\section{THEOREMS}
\subsection{Preamble}
=SML
val _ = set_merge_pcs["z_predicates", "'z_numbers", "'¯"];
val  Ûmain_defsÝ = list_±_intro[
	z_¯_def,
	rewrite_rule[z_get_specñ¯®] z_¯_less_def,
	rewrite_rule[z_get_specñ¯®] z_¯_minus_def,
	rewrite_rule[z_get_specñú®] z_¯_real_def,
	rewrite_rule[z_get_specñú®] z_¯_frac_def,
	rewrite_rule[z_get_specñú®, z_get_specñ¯®] z_¯_ú_exp_def,
	rewrite_rule[z_get_specñ¯®] z_¯_dot_dot_def
];
=TEX
\subsection{Order Structure}
In this section we prove basic facts about the less-than relation on the reals:
=SML
val Ûz_¯_unbounded_below_thmÝ = (
set_goal([], ñµx: ¯· ¶y:¯· y <‰R x®);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(strip_asm_tac (µ_elim¬x®¯_unbounded_below_thm));
a(contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "z_¯_unbounded_below_thm"
);
=TEX
=SML
val Ûz_¯_unbounded_above_thmÝ = (
set_goal([], ñµx: ¯· ¶y : ¯· x <‰R y®);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(strip_asm_tac (µ_elim¬x®¯_unbounded_above_thm));
a(contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "z_¯_unbounded_above_thm"
);
=TEX
=SML
val Ûz_¯_less_irrefl_thmÝ = (
set_goal([], ñµx: ¯· ³x <‰R x®);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
save_pop_thm "z_¯_less_irrefl_thm"
);
=TEX
=SML
val Ûz_¯_less_antisym_thmÝ = (
set_goal([], ñµx, y: ¯· ³(x <‰R y ± y <‰R x)®);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(all_fc_tac[¯_less_antisym_thm]);
save_pop_thm "z_¯_less_antisym_thm"
);
=TEX
=SML
val Ûz_¯_less_trans_thmÝ = (
set_goal([], ñµx, y, z: ¯· x <‰R y ± y <‰R z ´ x <‰R z®);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(all_fc_tac[¯_less_trans_thm]);
save_pop_thm "z_¯_less_trans_thm"
);
=TEX
=SML
val Ûz_¯_less_cases_thmÝ = (
set_goal([], ñµx, y: ¯· x <‰R y ² x = y ² y <‰R x®);
a(rewrite_tac[main_defs, ¯_less_cases_thm]);
save_pop_thm "z_¯_less_cases_thm"
);
=TEX
=SML
val Ûz_¯_¼_cases_thmÝ = (
set_goal([], ñµx, y: ¯· x ¼‰R y ² y ¼‰R x®);
a(rewrite_tac[main_defs, ¯_¼_cases_thm]);
save_pop_thm "z_¯_¼_cases_thm"
);
=TEX
=SML
val Ûz_¯_¼_less_cases_thmÝ = (
set_goal([], ñµx, y: ¯· x ¼‰R y ² y <‰R x®);
a(rewrite_tac[main_defs, ¯_¼_less_cases_thm]);
save_pop_thm "z_¯_¼_less_cases_thm"
);
=TEX
=SML
val Ûz_¯_eq_¼_thmÝ = (
set_goal([], ñµx, y: ¯· x = y ¤ x ¼‰R y ± y ¼‰R x®);
a(rewrite_tac[main_defs, ¯_eq_¼_thm]);
save_pop_thm "z_¯_eq_¼_thm"
);
=TEX
=SML
val Ûz_¯_¼_antisym_thmÝ = (
set_goal([], ñµx, y: ¯· x ¼‰R y ± y ¼‰R x  ´ x = y®);
a(rewrite_tac[main_defs, ¯_eq_¼_thm]);
save_pop_thm "z_¯_¼_antisym_thm"
);
=TEX
=SML
val Ûz_¯_less_¼_trans_thmÝ = (
set_goal([], ñµx, y, z: ¯· x <‰R y ± y ¼‰R z ´ x <‰R z®);
a(rewrite_tac[main_defs, ¯_less_¼_trans_thm]);
save_pop_thm "z_¯_less_¼_trans_thm"
);
=TEX
=SML
val Ûz_¯_¼_less_trans_thmÝ = (
set_goal([], ñµx, y, z: ¯· x ¼‰R y ± y <‰R z ´ x <‰R z®);
a(rewrite_tac[main_defs, ¯_¼_less_trans_thm]);
save_pop_thm "z_¯_¼_less_trans_thm"
);
=TEX
=SML
val Ûz_¯_¼_refl_thmÝ = (
set_goal([], ñµx: ¯· x ¼‰R x®);
a(rewrite_tac[main_defs, ¯_¼_refl_thm]);
save_pop_thm "z_¯_¼_refl_thm"
);
=TEX
=SML
val Ûz_¯_¼_trans_thmÝ = (
set_goal([], ñµx, y, z: ¯· x ¼‰R y ± y ¼‰R z ´ x ¼‰R z®);
a(rewrite_tac[main_defs, ¯_¼_trans_thm]);
save_pop_thm "z_¯_¼_trans_thm"
);
=TEX
=SML
val Ûz_¯_¼_³_less_thmÝ = (
set_goal([], ñµx, y: ¯· x ¼‰R y ¤ ³y <‰R x®);
a(rewrite_tac[main_defs, ¯_¼_³_less_thm]);
save_pop_thm "z_¯_¼_³_less_thm"
);
=TEX
=SML
val Ûz_¯_³_¼_less_thmÝ = (
set_goal([], ñµx, y: ¯· ³x ¼‰R y ¤ y <‰R x®);
a(rewrite_tac[main_defs, ¯_³_¼_less_thm]);
save_pop_thm "z_¯_³_¼_less_thm"
);
=TEX
=SML
val Ûz_¯_less_³_eq_thmÝ = (
set_goal([], ñµx, y: ¯· x <‰R y ´ ³x = y®);
a(rewrite_tac[main_defs, ¯_less_³_eq_thm]);
save_pop_thm "z_¯_less_³_eq_thm"
);
=TEX
=SML
val Ûz_¯_³_less_¼_thmÝ = conv_rule (ONCE_MAP_C eq_sym_conv) z_¯_¼_³_less_thm;
=TEX
=SML
val Ûz_¯_less_dense_thmÝ = (
set_goal([], ñµx, y: ¯· x <‰R y ´ (¶z:¯· x <‰R z ± z <‰R y)®);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(all_fc_tac[¯_less_dense_thm]);
a(z_¶_tacñz® THEN REPEAT strip_tac);
save_pop_thm "z_¯_less_dense_thm"
);
=TEX
=SML
val Ûz_¯_complete_thmÝ = (
set_goal([], ñµA : ð ¯·
	³A = {} ± (¶b:¯·µ x:¯· x  A ´ x ¼‰R b) ´
	(¶s:¯·  (µ x:¯· x  A ´ x ¼‰R s)
±	(µ b:¯· (µ x:¯· x  A ´ x ¼‰R b) ´ s ¼‰R b))
®);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¬A®¯_complete_thm));
(* *** Goal "1" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[get_specñ{}®]);
(* *** Goal "2" *** *)
a(i_contr_tac THEN swap_nth_asm_concl_tac 1);
a(¶_tac¬b® THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(z_¶_tac¬s® THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[]);
save_pop_thm"z_¯_complete_thm"
);
=TEX
\subsection{Additive Structure}
=SML
val Ûz_¯_plus_assoc_thmÝ = (
set_goal([], ñ µx, y, z: ¯· (x +‰R y) +‰R z = x +‰R y +‰R z®);
a(REPEAT strip_tac THEN rewrite_tac[main_defs, ¯_plus_assoc_thm]);
save_pop_thm"z_¯_plus_assoc_thm"
);
=TEX
=SML
val Ûz_¯_plus_assoc_thm1Ý = (
set_goal([], ñ µx, y, z: ¯· x +‰R y +‰R z = (x +‰R y) +‰R z®);
a(rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_assoc_thm]);
save_pop_thm"z_¯_plus_assoc_thm1"
);
=TEX
=SML
val Ûz_¯_plus_comm_thmÝ = (
set_goal([], ñ µx, y: ¯· x +‰R y = y +‰R x ®);
a(REPEAT strip_tac THEN rewrite_tac[main_defs, µ_elim¬x:¯®¯_plus_order_thm]);
save_pop_thm"z_¯_plus_comm_thm"
);
=TEX
=SML
val Ûz_¯_real_0_thmÝ = (
set_goal([], ñ real 0 = ¬î¯ 0® ®);
a(LEMMA_T ñreal 0 = real (0 + ~0)® pure_rewrite_thm_tac THEN1 rewrite_tac[]);
a(pure_rewrite_tac[main_defs]);
a(rewrite_tac[¯_minus_clauses]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_real_î¯_thmÝ = (
set_goal([], ¬ µm:î· ñreal ¬(Z'Int m)®® = î¯ m ®);
a(REPEAT strip_tac THEN induction_tac ¬m:î®);
(* *** Goal "1" *** *)
a(rewrite_tac[z_¯_real_0_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_int_homomorphism_thm, î¯_plus_homomorphism_thm]);
a(asm_rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_plus_unit_thmÝ = (
set_goal([], ñ µx: ¯· x +‰R real 0 = x ®);
a(rewrite_tac[main_defs, z_¯_real_0_thm, ¯_plus_clauses]);
save_pop_thm "z_¯_plus_unit_thm"
);
=TEX
=SML
val Ûz_¯_plus_mono_thmÝ = (
set_goal([], ñ µx, y, z: ¯· y <‰R z ´ x +‰R y <‰R x +‰R z ®);
a(rewrite_tac [main_defs] THEN REPEAT strip_tac);
save_pop_thm "z_¯_plus_mono_thm"
);
=TEX
=SML
val Ûz_¯_plus_mono_thm1Ý = (
set_goal([], ñ µx, y, z: ¯· y <‰R z ´ y +‰R x <‰R z +‰R x®);
a(once_rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_comm_thm]);
a(rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_mono_thm]);
save_pop_thm"z_¯_plus_mono_thm1"
);
=TEX
=SML
val Ûz_¯_plus_mono_thm2Ý = (
set_goal([], ñ µx, y, s, t: ¯· x <‰R y ± s <‰R t ´ x +‰R s <‰R y +‰R t®);
a(rewrite_tac [main_defs] THEN REPEAT strip_tac);
a(bc_thm_tac ¯_less_trans_thm THEN ¶_tac¬y +‰R s® THEN asm_rewrite_tac[]);
save_pop_thm"z_¯_plus_mono_thm2"
);
=TEX
=SML
val Ûz_¯_plus_0_thmÝ = (
set_goal([], ñ µx: ¯· x +‰R real 0 = x ± real 0 +‰R x = x ®);
a(rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_unit_thm]);
a(once_rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_comm_thm]);
a(rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_unit_thm]);
save_pop_thm"z_¯_plus_0_thm"
);
=TEX
=SML
val Ûz_¯_plus_order_thmÝ = (
set_goal([], ñ µx, y, z: ¯· y +‰R x = x +‰R y
		      ± (x +‰R y) +‰R z = x +‰R y +‰R z
		      ± y +‰R x +‰R z = x +‰R y +‰R z®);
a(rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_assoc_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(conv_tac (LEFT_C (once_rewrite_conv
	[rewrite_rule[z_get_specñ¯®]z_¯_plus_comm_thm]))
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[rewrite_rule[z_get_specñ¯®]z_¯_plus_assoc_thm1]);
a(conv_tac (RAND_C (ONCE_MAP_C(LEFT_C(once_rewrite_conv
	[rewrite_rule[z_get_specñ¯®]z_¯_plus_comm_thm]))))
	THEN REPEAT strip_tac);
save_pop_thm"z_¯_plus_order_thm"
);
=TEX
=SML
val Ûz_¯_plus_minus_thmÝ = (
set_goal([], ñ µx: ¯· x +‰R ~‰R x = real 0 ± ~‰R x +‰R x = real 0®);
a(z_µ_tac THEN strip_tac);
a(conv_tac (RIGHT_C
	(once_rewrite_conv[rewrite_rule[z_get_specñ¯®]z_¯_plus_comm_thm])));
a(rewrite_tac[main_defs, ¯_minus_clauses, z_¯_real_0_thm]);
save_pop_thm"z_¯_plus_minus_thm"
);
=TEX
=SML
val Ûz_¯_eq_thmÝ = (
set_goal([], ñ µx, y: ¯· x = y ¤ x +‰R ~‰R y = real 0 ®);
a(z_µ_tac THEN strip_tac);
a(rewrite_tac[main_defs, z_¯_real_0_thm]);
a(conv_tac (LEFT_C (once_rewrite_conv[¯_eq_thm])));
a(rewrite_tac[]);
save_pop_thm"z_¯_eq_thm"
);
=TEX
=SML
val Ûz_¯_minus_clausesÝ = (
set_goal([], ñ µx, y : ¯·
	~‰R (~‰R x) = x
±	x +‰R ~‰R x = real 0
±	~‰R x +‰R x = real 0
±	 ~‰R (x +‰R y) = ~‰R x +‰R ~‰R y
±	~‰R (real 0) = real 0®);
a(z_µ_tac THEN strip_tac);
a(rewrite_tac[main_defs, z_¯_real_0_thm]);
save_pop_thm"z_¯_minus_clauses"
);
=TEX
=SML
val Ûz_¯_minus_eq_thmÝ = (
set_goal([], ñ µx, y: ¯· ~‰R x = ~‰R y ¤ x = y ®);
a(z_µ_tac THEN strip_tac);
a(rewrite_tac[main_defs, ¯_minus_eq_thm]);
save_pop_thm"z_¯_minus_eq_thm"
);
=TEX
=SML
val Ûz_¯_plus_clausesÝ = (
set_goal([], ñ µ x, y, z : ¯·
		         (x +‰R z = y +‰R z ¤ x = y)
		      ± (z +‰R x = y +‰R z ¤ x = y)
		      ± (x +‰R z = z +‰R y ¤ x = y)
		      ± (z +‰R x = z +‰R y ¤ x = y)
		      ± (x +‰R z = z ¤ x = real 0)
		      ± (z +‰R x = z ¤ x = real 0)
		      ± (z = z +‰R y ¤ y = real 0)
		      ± (z = y +‰R z ¤ y = real 0)
		      ± x +‰R real 0 = x
		      ± real 0 +‰R x = x
		      ± ³ real 1 = real 0
		      ± ³ real 0 = real 1®);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm, ¯_plus_clauses]);
save_pop_thm"z_¯_plus_clauses"
);
=TEX
=SML
val Ûz_¯_less_clausesÝ = (
set_goal([], ñ µ x, y, z : ¯·
		         (x +‰R z <‰R y +‰R z ¤ x <‰R y)
		      ± (z +‰R x <‰R y +‰R z ¤ x <‰R y)
		      ± (x +‰R z <‰R z +‰R y ¤ x <‰R y)
		      ± (z +‰R x <‰R z +‰R y ¤ x <‰R y)
		      ± (x +‰R z <‰R z ¤ x <‰R real 0)
		      ± (z +‰R x <‰R z ¤ x <‰R real 0)
		      ± (x <‰R z +‰R x ¤ real 0 <‰R z)
		      ± (x <‰R x +‰R z ¤ real 0 <‰R z)
		      ± ³x <‰R x
		      ± real 0 <‰R real 1
		      ± ³ real 1 <‰R real 0
®);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm, ¯_less_clauses]);
save_pop_thm"z_¯_less_clauses"
);
=TEX
=SML
val Ûz_¯_¼_clausesÝ = (
set_goal([], ñ µ x, y, z : ¯·
		         (x +‰R z ¼‰R y +‰R z ¤ x ¼‰R y)
		      ± (z +‰R x ¼‰R y +‰R z ¤ x ¼‰R y)
		      ± (x +‰R z ¼‰R z +‰R y ¤ x ¼‰R y)
		      ± (z +‰R x ¼‰R z +‰R y ¤ x ¼‰R y)
		      ± (x +‰R z ¼‰R z ¤ x ¼‰R real 0)
		      ± (z +‰R x ¼‰R z ¤ x ¼‰R real 0)
		      ± (x ¼‰R z +‰R x ¤ real 0 ¼‰R z)
		      ± (x ¼‰R x +‰R z ¤ real 0 ¼‰R z)
		      ± x ¼‰R x
		      ± real 0 ¼‰R real 1
		      ± ³ real 1 ¼‰R real 0
®);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm, ¯_¼_clauses]);
save_pop_thm"z_¯_¼_clauses"
);
=TEX
\subsection{Multipicative Structure}
=SML
val Ûz_¯_times_assoc_thmÝ = (
set_goal([], ñ µ x, y, z: ¯· (x *‰R y) *‰R z = x *‰R y *‰R z®);
a(rewrite_tac[main_defs, ¯_times_assoc_thm]);
save_pop_thm"z_¯_times_assoc_thm"
);
=TEX
=SML
val Ûz_¯_times_comm_thmÝ = (
set_goal([], ñ µ x, y: ¯· x *‰R y = y *‰R x®);
a(REPEAT strip_tac THEN rewrite_tac[main_defs, µ_elim¬x:¯® ¯_times_order_thm]);
save_pop_thm"z_¯_times_comm_thm"
);
=TEX
=SML
val Ûz_¯_times_unit_thmÝ = (
set_goal([], ñ µ x:¯· x *‰R real 1 = x®);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm]);
save_pop_thm"z_¯_times_unit_thm"
);
=TEX
=SML
val Ûz_¯_0_less_0_less_times_thmÝ = (
set_goal([], ñ µ x, y:¯· real 0 <‰R x ± real 0 <‰R y ´ real 0 <‰R x *‰R y®);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm, ¯_0_less_0_less_times_thm]);
save_pop_thm"z_¯_0_less_0_less_times_thm"
);
=TEX
=SML
val Ûz_¯_times_assoc_thm1Ý = save_thm("z_¯_times_assoc_thm1",
	conv_rule (ONCE_MAP_C eq_sym_conv) z_¯_times_assoc_thm);
=TEX
=SML
val Ûz_¯_times_plus_distrib_thmÝ = (
set_goal([], ñ µ x, y, z: ¯·
	x *‰R (y +‰R z) = x *‰R y +‰R x *‰R z ± (x +‰R y) *‰R z = x *‰R z +‰R y *‰R z®);
a(rewrite_tac[main_defs, ¯_times_plus_distrib_thm]);
save_pop_thm"z_¯_times_plus_distrib_thm"
);
=TEX
=SML
val Ûz_¯_times_order_thmÝ = (
set_goal([], ñ µ x, y, z: ¯· y *‰R x = x *‰R y
		      ± (x *‰R y) *‰R z = x *‰R y *‰R z
		      ± y *‰R x *‰R z = x *‰R y *‰R z®);
a(z_µ_tac THEN strip_tac THEN rewrite_tac[main_defs]);
a(rewrite_tac[µ_elim¬y®¯_times_order_thm]);
save_pop_thm"z_¯_times_order_thm"
);
=TEX
=SML
val Ûz_¯_times_clausesÝ = (
set_goal([], ñ µ x :¯ ·
	real 0 *‰R x = real 0
±	x *‰R real 0 = real 0
±	x *‰R real 1 = x
±	real 1 *‰R x = x®);
a(z_µ_tac THEN strip_tac THEN rewrite_tac[main_defs]);
a(rewrite_tac[¯_times_clauses, z_¯_real_0_thm]);
save_pop_thm"z_¯_times_clauses"
);
=TEX
=SML
val Ûz_¯_over_thmÝ = (
set_goal([], ñ
	(µ y, z : ¯· ³ z = real 0 ´ (y *‰R z) /‰R z = y)
±	(µ x, y, z:¯· ³ z = real 0 ´ (x *‰R y) /‰R z = x *‰R y /‰R z)®);
a(rewrite_tac[main_defs, z_¯_real_0_thm, get_spec¬$/‰R®]);
save_pop_thm "z_¯_over_thm"
);
=TEX
\section{COMPUTATIONAL CONVERSIONS}
=TEX
=SML
val Ûz_¯_lit_lemma1Ý = (
set_goal([], ¬µm n· ñ¬Z'Int m® /‰Z ¬Z'Int n®® = m/n®);
a(rewrite_tac[get_specñ(_/‰Z_)®, z_¯_real_î¯_thm, get_spec¬$/‰N®]);
a(rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_lit_lemma2Ý = (
set_goal([], ¬µm n· ñ¬Z'Int m® /‰Z ~ ¬Z'Int (n + 1)®® = ~‰R(m/(n+1))®);
a(rewrite_tac[get_specñ(_/‰Z_)®, z_¯_real_î¯_thm, get_spec¬$/‰N®]);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm] THEN REPEAT strip_tac);
a(lemma_tac¬³ î¯ (n + 1) = î¯ 0® THEN1
	PC_T1 "basic_hol" rewrite_tac[î¯_one_one_thm]);
a(lemma_tac¬³ (~‰R(î¯ (n + 1)) = î¯ 0)® THEN1
	(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[¯_eq_thm]
	THEN rewrite_tac[¯_minus_clauses] THEN
	PC_T1 "basic_hol" rewrite_tac[î¯_one_one_thm]));
a(LEMMA_T ¬~‰R(î¯ m / î¯ (n + 1)) = ~‰R(î¯ m) / î¯ (n+1)® rewrite_thm_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[¯_over_times_recip_thm]);
a(rewrite_tac[¯_times_minus_thm]);
(* *** Goal "2" *** *)
a(ante_tac (list_µ_elim[ ¬~‰R(î¯ (n + 1))®, ¬î¯ (n + 1)®]¯_cross_mult_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(rewrite_tac[¯_times_minus_thm, µ_elim¬î¯ m®¯_times_order_thm]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_lit_lemma3Ý = (
set_goal([], ¬µm n· ñ(~ ¬Z'Int m®) /‰Z ¬Z'Int (n + 1)®® = ~‰R(m/(n+1))®);
a(rewrite_tac[get_specñ(_/‰Z_)®, z_¯_real_î¯_thm, get_spec¬$/‰N®]);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm] THEN REPEAT strip_tac);
a(lemma_tac¬³ î¯ (n + 1) = î¯ 0® THEN1
	PC_T1 "basic_hol" rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T rewrite_tac[¯_over_times_recip_thm]);
a(rewrite_tac[¯_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_lit_lemma4Ý = (
set_goal([], ¬µm n· ñ(~¬Z'Int m®) /‰Z ~ ¬Z'Int (n + 1)®® = m/(n+1)®);
a(rewrite_tac[get_specñ(_/‰Z_)®, z_¯_real_î¯_thm, get_spec¬$/‰N®]);
a(rewrite_tac[main_defs, z_¯_real_î¯_thm] THEN REPEAT strip_tac);
a(lemma_tac¬³ î¯ (n + 1) = î¯ 0® THEN1
	PC_T1 "basic_hol" rewrite_tac[î¯_one_one_thm]);
a(lemma_tac¬³ (~‰R(î¯ (n + 1)) = î¯ 0)® THEN1
	(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[¯_eq_thm]
	THEN rewrite_tac[¯_minus_clauses] THEN
	PC_T1 "basic_hol" rewrite_tac[î¯_one_one_thm]));
a(ante_tac (list_µ_elim[ ¬~‰R(î¯ (n + 1))®, ¬î¯ (n + 1)®]¯_cross_mult_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(rewrite_tac[¯_times_minus_thm, µ_elim¬î¯ m®¯_times_order_thm]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_lit_lemma5Ý = z_¯_real_î¯_thm;
val Ûz_¯_minus_thmÝ = tac_proof(
	([], ¬µx·ñ~‰R x® = ~‰R x®),
	rewrite_tac[main_defs]);
=SML
fun ÛZ_LEFT_CÝ (c : CONV) : CONV = RAND_C (LEFT_C c);
fun ÛZ_RIGHT_CÝ (c : CONV) : CONV = RAND_C (RIGHT_C c);
fun ÛZ_RANDS_CÝ (c : CONV) : CONV = RAND_C (RANDS_C c);
val ÛZ_RAND_CÝ : CONV -> CONV = RAND_C;
=IGN
Z_RIGHT_C z_plus_conv ñ1 /‰Z (1+2)®;
Z_LEFT_C z_plus_conv ñ (2+3) /‰Z (1+2)®;
Z_RANDS_C z_plus_conv ñ (2+3) /‰Z (1+2)®;
Z_RAND_C z_plus_conv ñ f x (1+2)®;
=TEX
=SML
val Ûî_oneÝ = ¬1®;
val Ûpos_convÝ : CONV = (fn tm =>
	let	val n = dest_î tm;
	in	eq_sym_rule (plus_conv(mk_plus(mk_î(n @- one), î_one)))
	end
);
=TEX
=SML
val Ûz_¯_lit_convÝ : CONV = (fn tm =>
	FIRST_C [
		simple_eq_match_conv z_¯_lit_lemma1,
		Z_RIGHT_C (Z_RAND_C(RAND_C pos_conv)) THEN_C
			simple_eq_match_conv z_¯_lit_lemma2 THEN_C
			RAND_C (RIGHT_C plus_conv),
		Z_RIGHT_C (RAND_C pos_conv) THEN_C
			simple_eq_match_conv z_¯_lit_lemma3 THEN_C
			RAND_C (RIGHT_C plus_conv),
		Z_RIGHT_C (Z_RAND_C(RAND_C pos_conv)) THEN_C
			simple_eq_match_conv z_¯_lit_lemma4 THEN_C
			RIGHT_C plus_conv,
		simple_eq_match_conv z_¯_lit_lemma5, 
		simple_eq_match_conv z_¯_minus_thm THEN_C
			RAND_C(simple_eq_match_conv z_¯_lit_lemma5)
	] tm
	handle Fail _ => term_fail "z_¯_lit_conv" 117001 [tm]
);
=IGN
z_¯_lit_convñ 1/‰Z 2®;
z_¯_lit_convñ 1/‰Z ~2®;
z_¯_lit_convñ ~ 1/‰Z 2®;
z_¯_lit_convñ ~ 1/‰Z ~2®;
z_¯_lit_convñ real 42®;
z_¯_lit_convñ ~‰R real 42®;
z_¯_lit_convñ 0 /‰Z 42®;
=TEX
=SML
val Ûz_¯_lit_lemma6Ý = conv_rule (ONCE_MAP_C eq_sym_conv) z_¯_lit_lemma1;
val Ûz_¯_lit_lemma7Ý = conv_rule (ONCE_MAP_C eq_sym_conv) z_¯_lit_lemma5;
val Ûz_¯_lit_lemma8Ý = conv_rule (ONCE_MAP_C eq_sym_conv) z_¯_minus_thm;
val Ûz_¯_lit_lemma9Ý = tac_proof(([], ñ~‰R (real 0) = real 0®),
	rewrite_tac[rewrite_rule[z_get_specñ¯®] z_¯_minus_clauses]);

val Ûz_¯_lit_conv1Ý : CONV = (fn tm =>
	(FIRST_C [
		simple_eq_match_conv z_¯_lit_lemma6,
		simple_eq_match_conv z_¯_lit_lemma7,
		RAND_C (simple_eq_match_conv z_¯_lit_lemma6) THEN_C
			simple_eq_match_conv z_¯_lit_lemma8,
		RAND_C (simple_eq_match_conv z_¯_lit_lemma7) THEN_C
			simple_eq_match_conv z_¯_lit_lemma8
	] THEN_TRY_C simple_eq_match_conv z_¯_lit_lemma9) tm
	handle Fail _ => term_fail "z_¯_lit_conv1" 117002 [tm]
);
=SML
val Ûz_¯_lit_norm_convÝ = (
	CHANGED_C (z_¯_lit_conv THEN_TRY_C
	(¯_frac_norm_conv ORELSE_C RAND_C ¯_frac_norm_conv)	THEN_C
	z_¯_lit_conv1));
=IGN
z_¯_lit_norm_convñ1 /‰Z 9®;
=IGN
z_¯_lit_conv1 ¬1/2®;
z_¯_lit_conv1 ¬~‰R(1/2)®;
z_¯_lit_conv1 ¬î¯ 87®;
z_¯_lit_conv1 ¬~‰R(î¯ 87)®;
z_¯_lit_norm_conv ñ~87 /‰Z 3®;
z_¯_lit_norm_conv ñ~88 /‰Z 3®;
z_¯_lit_norm_conv ñ88 /‰Z ~4®;
z_¯_lit_norm_conv ñ88 /‰Z 4®;
z_¯_lit_norm_conv ñ0 /‰Z 4®;
z_¯_lit_norm_conv ñ~0 /‰Z 4®;
z_¯_lit_norm_conv ñ0 /‰Z ~4®;
z_¯_lit_norm_conv ñ~0 /‰Z 4®;
z_¯_lit_norm_conv ñ~‰R(~0 /‰Z ~2)®;
=TEX

=SML
val z_¯_plus_thm = tac_proof(
	([], ¬µx y·ñx +‰R y® = x +‰R y®),
	rewrite_tac[main_defs]);
val z_¯_times_thm = tac_proof(
	([], ¬µx y·ñx *‰R y® = x *‰R y®),
	rewrite_tac[main_defs]);
val z_¯_less_thm = tac_proof(
	([], ¬µx y·ñx <‰R y® ¤ x <‰R y®),
	rewrite_tac[main_defs]);
val z_¯_¼_thm = tac_proof(
	([], ¬µx y:¯·ñx ¼‰R y® ¤ x ¼‰R y®),
	rewrite_tac[main_defs]);
val z_¯_over_thm = tac_proof(
	([], ¬µx y·ñx /‰R y® = x /‰R y®),
	rewrite_tac[main_defs]);
=TEX
=SML
fun Ûmk_bin_rel_convÝ (th : THM) (c : CONV) : CONV = (
	LEFT_C (RANDS_C z_¯_lit_conv) THEN_C simple_eq_match_conv th THEN_C c
);
=TEX
=SML
fun Ûmk_bin_comp_convÝ (th : THM) (c : CONV) : CONV = (
	Z_RANDS_C z_¯_lit_conv THEN_C simple_eq_match_conv th THEN_C c THEN_C z_¯_lit_conv1
);
=TEX
=SML
val Ûz_¯_plus_convÝ : CONV = mk_bin_comp_conv z_¯_plus_thm ¯_plus_conv;
val Ûz_¯_times_convÝ : CONV = mk_bin_comp_conv z_¯_times_thm ¯_times_conv;

val Ûmy_¯_over_convÝ = ¯_over_conv THEN_C RIGHT_C ¯_recip_conv THEN_C ¯_times_conv;
 
val Ûz_¯_over_convÝ : CONV = mk_bin_comp_conv z_¯_over_thm my_¯_over_conv;
val Ûz_¯_less_convÝ : CONV = mk_bin_rel_conv z_¯_less_thm ¯_less_conv;
val Ûz_¯_¼_convÝ : CONV = mk_bin_rel_conv z_¯_¼_thm ¯_¼_conv;
val Ûz_¯_eq_convÝ : CONV = RANDS_C z_¯_lit_conv THEN_C ¯_eq_conv;
=IGN
z_¯_plus_convñ1 /‰Z 2 +‰R 1 /‰Z 2®;
z_¯_times_convñ(1 /‰Z 2) *‰R (1 /‰Z 2)®;
z_¯_over_convñ(1 /‰Z 2) /‰R (1 /‰Z 2)®;

z_¯_¼_convñ1 /‰Z 2 ¼‰R 1 /‰Z 2®;
z_¯_less_convñ1 /‰Z 2 <‰R 1 /‰Z 2®;
=TEX
=SML
val Ûz_¯_minus_lit_thm1Ý = tac_proof(
	([], ¬µi·ñ~‰R (real i) = real (~i)®®),
	rewrite_tac[main_defs]);
=TEX
=SML
val Ûz_¯_minus_lit_thm2Ý = (
set_goal([], ¬µx n· ñ ~‰R ( x /‰Z ¬Z'Int (n + 1)® ) = ~ x /‰Z  ¬Z'Int (n + 1)® ® ®);
a(rewrite_tac[get_specñ(_/‰Z_)®, get_spec¬$/‰N®]);
a(rewrite_tac[main_defs] THEN REPEAT strip_tac);
a(rewrite_tac[z_¯_real_î¯_thm]);
a(lemma_tac¬³ î¯ (n + 1) = î¯ 0® THEN1
	PC_T1 "basic_hol" rewrite_tac[î¯_one_one_thm]);
a(ALL_FC_T rewrite_tac[¯_over_times_recip_thm]);
a(rewrite_tac[¯_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_minus_convÝ : CONV = (fn tm =>
	FIRST_C [
		simple_eq_match_conv z_¯_minus_lit_thm1,
		Z_RAND_C (Z_RIGHT_C(RAND_C pos_conv)) THEN_C
			simple_eq_match_conv z_¯_minus_lit_thm2 THEN_C
			Z_RIGHT_C (RAND_C plus_conv)
	] tm
	handle Fail _ => term_fail "z_¯_minus_conv" 117001 [tm]
);

=IGN
z_¯_minus_convñ~‰R (real 42)®;
z_¯_minus_convñ~‰R (3 /‰Z 7)®;
z_¯_minus_convñ~‰R (9 /‰Z 21)®;
=TEX
=SML
val Ûz_ú_exp_lemma1Ý = (
set_goal([], ¬µm·ñx ^‰Z ¬(Z'Int m)®® = x ^‰N m®);
a(rewrite_tac[main_defs]);
pop_thm()
);
val Ûz_ú_exp_lemma2Ý = (
set_goal([], ¬µm·ñx ^‰Z ~¬(Z'Int m)®® = î¯ 1 /‰R (x ^‰N m)®);
a(REPEAT strip_tac THEN rewrite_tac[main_defs]);
pop_thm()
);
=TEX
=SML
val Ûz_¯_ú_exp_convÝ : CONV = (
	(simple_eq_match_conv z_ú_exp_lemma1 THEN_C
		LEFT_C z_¯_lit_conv THEN_C ¯_î_exp_conv THEN_C z_¯_lit_conv1)
ORELSE_C
	(simple_eq_match_conv z_ú_exp_lemma2 THEN_C
		RIGHT_C (LEFT_C z_¯_lit_conv) THEN_C
		RIGHT_C ¯_î_exp_conv THEN_C ¯_over_conv THEN_C
		RIGHT_C ¯_recip_conv THEN_C ¯_times_conv THEN_C z_¯_lit_conv1)
)	THEN_TRY_C z_¯_lit_norm_conv;
=IGN
z_¯_ú_exp_convñreal 5 ^‰Z 2®;
z_¯_ú_exp_convñ(3/‰Z 7) ^‰Z 2®;
z_¯_ú_exp_convñreal 10 ^‰Z 3®;
z_¯_ú_exp_convñ(real 7) ^‰Z ~2®;
z_¯_ú_exp_convñ(3/‰Z 7) ^‰Z ~2®;
z_¯_ú_exp_convñ(3/‰Z 7) ^‰Z ~1®;
z_¯_ú_exp_convñ(3/‰Z 7) ^‰Z ~0®;
z_¯_ú_exp_convñ(3/‰Z 7) ^‰Z 0®;
z_¯_ú_exp_convñ(3/‰Z 7) ^‰Z 1®;
z_¯_ú_exp_convñ(3/‰Z 7) ^‰Z 2®;
=TEX
=SML
val z_¯_¾_thm = tac_proof(
	([], ¬µx y:¯·ñx ¾‰R y ¤ y ¼‰R x®®),
	rewrite_tac[rewrite_rule[main_defs]z_¯_¾_def, main_defs]);
val z_¯_greater_thm = tac_proof(
	([], ¬µx y:¯·ñx >‰R y ¤ y <‰R x®®),
	rewrite_tac[rewrite_rule[main_defs]z_¯_greater_def, main_defs]);
val z_¯_subtract_thm = tac_proof(
	([], ¬µx y:¯·ñx -‰R y  = x +‰R ~‰R y®®),
	rewrite_tac[rewrite_rule[main_defs]z_¯_subtract_def, main_defs]);
=TEX
=SML
val Ûz_¯_¾_convÝ = simple_eq_match_conv z_¯_¾_thm;
val Ûz_¯_greater_convÝ = simple_eq_match_conv z_¯_greater_thm;
val Ûz_¯_subtract_convÝ = simple_eq_match_conv z_¯_subtract_thm;
=IGN
z_¯_¾_convñx ¾‰R y®;
z_¯_greater_convñx >‰R y®;
z_¯_subtract_convñx -‰R y®;
=TEX
\subsection{Conversion to HOL}
=SML
val Ûto_hol_plus_convÝ = simple_eq_match_conv z_¯_plus_thm;
val Ûto_hol_minus_convÝ = simple_eq_match_conv z_¯_minus_thm;
val Ûto_hol_times_convÝ = simple_eq_match_conv z_¯_times_thm;
val Ûto_hol_over_convÝ = simple_eq_match_conv z_¯_over_thm;
val Ûto_hol_less_convÝ = simple_eq_match_conv z_¯_less_thm;
val Ûto_hol_¼_convÝ = simple_eq_match_conv z_¯_¼_thm;
val Ûto_hol_lit_convÝ = z_¯_lit_conv;
val Ûto_hol_ú_exp_convÝ =
	simple_eq_match_conv z_ú_exp_lemma1 ORELSE_C simple_eq_match_conv z_ú_exp_lemma2;

=IGN
to_hol_plus_convñx +‰R y®;
to_hol_minus_convñ~‰R y®;
to_hol_times_convñx *‰R y®;
to_hol_over_convñx /‰R y®;
to_hol_less_convñx <‰R y®;
to_hol_¼_convñreal 9 ¼‰R y®;
to_hol_lit_convñreal 99®;
to_hol_lit_convñ~ 4/‰Z 5®;
to_hol_ú_exp_convñreal 1 ^‰Z 9®;
to_hol_ú_exp_convñreal 1 ^‰Z ~9®;
=TEX
\section{PROOF CONTEXTS}
=SML
fun Ûthms_to_eqn_cxtÝ (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	
=SML
val _ = delete_pc "'z_reals" handle Fail _ => ();
val _ = new_pc "'z_reals";
val _ = set_rw_eqn_cxt	
		[	(ñi +‰R j®, z_¯_plus_conv),
			(ñi *‰R j®, z_¯_times_conv),
			(ñi /‰R j®, z_¯_over_conv),
			(ñi *‰R j®, z_¯_times_conv),
			(ñi ^‰Z j®, z_¯_ú_exp_conv),
			(ñi -‰R j®, z_¯_subtract_conv),
			(ñ(iºR) = j®, z_¯_eq_conv),
			(ñ~‰R i®, z_¯_minus_conv),
			(ñi ¼‰R j®, z_¯_¼_conv),
			(ñi <‰R j®, z_¯_less_conv),
			(ñi ¾‰R j®, z_¯_¾_conv),
			(ñi >‰R j®, z_¯_greater_conv),
			(ñ¬Z'Int 0® /‰Z x®, z_¯_lit_norm_conv)
		] "'z_reals";
fun Ûu_simpÝ (thm : THM) : THM = rewrite_rule[z_¯_def] thm;

val _ = add_rw_thms (map u_simp[z_¯_plus_clauses, z_¯_minus_clauses, z_¯_¼_clauses,
	 z_¯_less_clauses, z_¯_times_clauses])
	"'z_reals";
val pos = (thms_to_eqn_cxt(map u_simp[z_¯_minus_clauses, 
		z_¯_¼_clauses, 
		z_¯_less_clauses])) @
	[(ñ(iº¯) = j®, z_¯_eq_conv),
	(ñi ¾‰R j®, z_¯_¾_conv),
	(ñi >‰R j®, z_¯_greater_conv)];
val neg = mapfilter (mk_³ ** RAND_C) pos;
val neutral = [(ñi ¼‰R j®, z_¼_conv),
	(ñi <‰R j®, z_less_conv)];

val Ûstrip_eqn_cxtÝ = neutral @ pos @ neg;

val _ = set_st_eqn_cxt strip_eqn_cxt "'z_reals";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'z_reals";
val _ = set_u_simp_eqn_cxt (theory_u_simp_eqn_cxt"z_reals") "'z_reals";
val _ = set_pr_tac z_basic_prove_tac "'z_reals";
val _ = set_pr_conv z_basic_prove_conv "'z_reals";
val _ = commit_pc "'z_reals";
=TEX
=IGN
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñx  ¯®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) +‰R (1 /‰Z 2)®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) <‰R (1 /‰Z 2)®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) *‰R (1 /‰Z 2)®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) /‰R (1 /‰Z 2)®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) ^‰Z 3®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) -‰Z real 3®;

MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) >‰R (1 /‰Z 2)®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) <‰R (1 /‰Z 2)®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) ¼‰R (1 /‰Z 2)®;
MERGE_PCS_C1 ["'z_reals", "z_sets_alg"] rewrite_conv[]ñ(1 /‰Z 2) ¾‰R (1 /‰Z 2)®;
=TEX
=TEX	
=SML
val _ = delete_pc "z_¯_lin_arith" handle Fail _ => ();
val _ = new_pc "z_¯_lin_arith";
val _ = set_rw_eqn_cxt	
		[	(ñi +‰R j®, to_hol_plus_conv),
			(ñi *‰R j®, to_hol_times_conv),
			(ñi /‰R j®, to_hol_over_conv),
			(ñi *‰R j®, to_hol_times_conv),
			(ñi ^‰Z j®, to_hol_ú_exp_conv),
			(ñi *‰R j®, to_hol_times_conv),
			(ñi -‰R j®, z_¯_subtract_conv),
			(ñ~‰R i®, to_hol_minus_conv),
			(ñi ¾‰R j®, z_¯_¾_conv),
			(ñi >‰R j®, z_¯_greater_conv),
			(ñreal m®, to_hol_lit_conv),
			(ñ¬Z'Int m® /‰Z ¬Z'Int n®®, to_hol_lit_conv)
		] "z_¯_lin_arith";
=TEX
Now the tactic which is the automatic proof tactic.
=SML
val Ûz_¯_lin_arith_prove_tacÝ : THM list -> TACTIC = (fn thl => fn gl =>
	((	DROP_ASMS_T (MAP_EVERY ante_tac)
	THEN_TRY	rewrite_tac thl 
	THEN	PC_T1 "¯_lin_arith" prove_tac[]) gl)
	handle ex => reraise ex "z_¯_lin_arith_prove_conv"
);
=TEX
and the associated conversion:
=SML
val Ûz_¯_lin_arith_prove_convÝ : THM list -> CONV = (fn thl => fn tm =>
	let	val th = tac_proof(([], tm), z_¯_lin_arith_prove_tac thl);
	in	¤_t_intro  th
	end	handle ex => reraise ex "z_¯_lin_arith_prove_conv"
);
=TEX
=SML
val _ = set_u_simp_eqn_cxt (theory_u_simp_eqn_cxt"z_reals") "z_¯_lin_arith";
val _ = set_pr_tac z_¯_lin_arith_prove_tac "z_¯_lin_arith";
val _ = set_pr_conv z_¯_lin_arith_prove_conv "z_¯_lin_arith";
val _ = commit_pc "z_¯_lin_arith";
=IGN
PC_C1 "z_¯_lin_arith" rewrite_conv[]ñx +‰R y *‰R real 42 +‰R 9 /‰Z 10®;
PC_C1 "z_¯_lin_arith" prove_conv[]	ñx <‰R y <‰R z ´ x <‰R z®;
PC_C1 "z_¯_lin_arith" rewrite_conv[]	ñ
	(real 2 ^‰Z 5) *‰R x <‰R y <‰R z ´ x <‰R z /‰R real 31®;

val gl : GOAL = ([], ñx <‰R y <‰R z ´ x <‰R z®);
tac_proof(gl, PC_T1 "z_¯_lin_arith" prove_tac[]);

=TEX
\section{EPILOGUE}
=SML
end (* of structure ZReals *);
open ZReals;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







