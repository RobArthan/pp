% usr011X.doc   %Z% $Date$ $Revision$ $RCSfile$
% this should form a Chapter of the document
% Exercises
=TEX

\ftlmargin=0.25in\ftrmargin=0.25in

These exercises are presented in sections which correspond to chapters in the tutorial as follows:

\begin{enumerate}
\item
The Z Predicate Calculus
\begin{itemize}
\item
Forward Propositional Proofs
\item
Goal Oriented Propositional Proofs
\item
Forward Predicate Calculus Proofs
\item
Goal Oriented Predicate Calculus Proofs
\item
Rewriting
\end{itemize}
\item
Expressions and Schema Expressions
\item
Z Paragraphs and Theories
\item
The Z ToolKit
\begin{enumerate}
\item
Sets
\item
Relations
\item
Functions
\item
Numbers and Finiteness
\item
Sequences
\item
Bags
\end{enumerate}
\end{enumerate}

In order to save labour at the keyboard, the student is expected to do the exercises by working with a specially prepared database.   To prepare this `exercises' database, refer to the Installation Guide. The predefined material in the `exercises' database is documented in this chapter by being marked with a sidebar, thus:

=SML
   
=TEX

A sidebar like this:
=GFT Student

=TEX

marks material which the student is expected to enter, either through the keyboard or by cut-and-paste.  


The prepared database contains 4 theories, each with some predefined material:  in particular, lists of goals.  A goal can be conveniently selected by name and set up to be worked on by the subgoal package, by using the function predefined by: 
=SML
fun setlg name goallist = set_goal([],lassoc3 goallist name);
=TEX
For example, to work on the goal  which is the first in the list $PM2$ (see \ref{PM2} below), noting that this goal is named `*2.02', execute:
=GFT Student
	setlg "*2.02" PM2;
=TEX

Another useful function attempts to prove a conjecture using $prove_rule$ and store the results in the current theory.  It is predefined by:

=SML
fun prove_and_store (key, term) = save_thm (key, prove_rule[] term);
=TEX

It is important that each exercise be attempted in the correct context. For this reason, at various points in the sequence of exercises,  instructions are given to set up the appropriate context for the group of exercises which follow, up to the next setting of context.  Setting up the context covers clearing the goal-stack, opening the appropriate `exercise' theory, setting the proof-context and flags.             


The following lines of ML are for preparing the database:
=SML
repeat drop_main_goal;
open_theory "z_library";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX

\section{Predicate Calculus Exercises}

The following lines of ML are for preparing the database by setting up the first exercise theory:
 
=SML
open_theory "z_library";
new_theory "z_exercises_1";
=TEX

\subsection{Forward Propositional Proofs}\label{PropositionalReasoningExercises}
%   context setting point 1
Set the context by:
=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc "z_library";
=TEX


and then, using the methods described in \ref{PropositionalReasoning} prove a selection of the following results by use of
=INLINEFT
¥_elim
=TEX
,  
=INLINEFT
asm_rule
=TEX
{} and
=INLINEFT
¥_intro
=TEX
: 

\begin{description}
\item[(a)]
=INLINEFT
b¥c, a¥b, a Ù c
=TEX
\item[(b)]
=INLINEFT
a¥b¥c, a, b Ù c
=TEX
\item[(c)] 
=INLINEFT
a¥b¥c, b Ù a¥c
=TEX
\item[(d)]
=INLINEFT
Ù (a¥b¥c)¥b¥(a¥c)
=TEX
\end{description}

\subsection{Goal Oriented Propositional Proofs}

=IGN
("bits and pieces for use by  cut and paste

a contr_tac;
a z_strip_tac;
a strip_tac;
a step_strip_tac;
prove_rule[]

*)
=TEX
\begin{itemize}
\item
Choose examples from $PM2$ below to set up as a goal.  E.g. to choose as a goal 
=INLINEFT
Òq ¥ ( p ¥ q)Æ
=TEX
, execute 
=INLINEFT
setlg "*2.02" PM2;
=TEX
.  Work the example with
\begin{enumerate}
\item 
=INLINEFT
a z_strip_tac;
=TEX
\item and/or:
=INLINEFT
a step_strip_tac;
=TEX
\end{enumerate}
\item
Observe the steps taken and try to identify the reasons for discharge of subgoals.
\item
Select the weakest ``proof context'':
=GFT Student
	push_pc "initial";
=TEX
then retry the examples (or previous exercises).
\item
When you have finished restore the original proof context by:
=GFT Student
	pop_pc();
=TEX
\end{itemize}

The following lines of ML are for preparing the `exercises' database. They are taken from Principia Mathematica *2, and are shown together with their reference numbers.

\label{PM2}

=SML
val PM2 =[
("*2.02", Òq ¥ ( p ¥ q)Æ),
("*2.03", Ò(p ¥ ≥ q) ¥ (q ¥ ≥ p)Æ),
("*2.15", Ò(≥ p ¥ q) ¥ (≥ q ¥ p)Æ),
("*2.16", Ò(p ¥ q) ¥ (≥ q ¥ ≥ p)Æ),
("*2.17", Ò(≥ q ¥ ≥ p) ¥ (p ¥ q)Æ),
("*2.04", Ò(p ¥ q ¥ r) ¥ (q ¥ p ¥ r)Æ),
("*2.05", Ò(q ¥ r) ¥ (p ¥ q) ¥ (p ¥ r)Æ),
("*2.06", Ò(p ¥ q) ¥ (q ¥ r) ¥ (p ¥ r)Æ),
("*2.08", Òp ¥ pÆ),
("*2.21", Ò≥ p ¥ (p ¥ q)Æ)];
=TEX
The following are from Principia Mathematica *3.
=SML
val PM3 =[
("*3.01", Òp ± q § ≥(≥ p ≤ ≥ q)Æ),
("*3.2", Òp ¥ q ¥ p ± qÆ),
("*3.26", Òp ± q ¥ pÆ),
("*3.27", Òp ± q ¥ qÆ),
("*3.3", Ò(p ± q ¥ r) ¥ (p ¥ q ¥ r)Æ),
("*3.31", Ò(p ¥ q ¥ r) ¥ (p ± q ¥ r)Æ),
("*3.35", Ò(p ± (p ¥ q)) ¥ qÆ),
("*3.43", Ò(p ¥ q) ± (p ¥ r) ¥ (p ¥ q ± r)Æ),
("*3.45", Ò(p ¥ q) ¥ (p ± r ¥ q ± r)Æ),
("*3.47", Ò(p ¥ r) ± (q ¥ s) ¥ (p ± q ¥ r ± s)Æ)];
=TEX
Results from Principia Mathematica *4
=SML
val PM4 =[
("*4.1", Òp ¥ q § ≥ q ¥ ≥ pÆ),
("*4.11", Ò(p § q) § (≥ p § ≥ q)Æ),
("*4.13", Òp § ≥ ≥ pÆ),
("*4.2", Òp § pÆ),
("*4.21", Ò(p § q) § (q § p)Æ),
("*4.22", Ò(p § q) ± (q § r) ¥ (p § r)Æ),
("*4.24", Òp § p ± pÆ),
("*4.25", Òp § p ≤ pÆ),
("*4.3", Òp ± q § q ± pÆ),
("*4.31", Òp ≤ q § q ≤ pÆ),
("*4.33", Ò(p ± q) ± r § p ± (q ± r)Æ),
("*4.4", Òp ± (q ≤ r) § (p ± q) ≤ (p ± r)Æ),
("*4.41", Òp ≤ (q ± r) § (p ≤ q) ± (p ≤ r)Æ),
("*4.71", Ò(p ¥ q) § (p § (p ± q))Æ),
("*4.73", Òq ¥ (p § (p ± q))Æ)];
=TEX
Results from Principia Mathematica *5
=SML
val PM5 =[
("*5.1", Òp ± q ¥ (p § q)Æ),
("*5.32", Ò(p ¥ (q § r)) ¥ ((p ± q) § (p ± r))Æ),
("*5.6", Ò(p ± ≥ q ¥ r) ¥ (p ¥ (q ≤ r))Æ)];
=TEX

%***4***  7.1.3
\subsection{Forward Predicate Calculus Proofs}

The following exercises concern proof in the predicate calculus in Z. Set the context by:

% context setting point 2

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_1";
set_merge_pcs ["z_language", "'z_numbers"];
=TEX
{} and then
\begin{enumerate} 
\item Using 
=INLINEFT
z_µ_elim
=TEX
{} with 
=INLINEFT
z_Ó_≥_plus1_thm
=TEX
{} prove:

\begin{description}
\item[(a)] 
=INLINEFT
0 ç Ó ± true ¥ ≥ 0 + 1 = 0
=TEX
\item[(b)] 
=INLINEFT
x * x ç Ó ± true ¥ ≥ x * x + 1 = 0  
=TEX
\end{description}

\item Using 
=INLINEFT
prove_rule
=TEX
{} with 
=INLINEFT
z_º_trans_thm
=TEX
{} prove:
\begin{description}
\item[\ \ \ ] 
=INLINEFT
i º j ± j º k ¥ i º k 
=TEX
\end{description}

\item Using 
=INLINEFT
prove_rule
=TEX
{} and  
=INLINEFT
z_Ó_≥_plus1_thm
=TEX
{} and 
=INLINEFT
z_0_Ó_thm
=TEX
{} prove:
\begin{description}
\item[(a)] 
=INLINEFT
≥ 0 + 1 = 0   
=TEX
\item[(b)] 
=INLINEFT
x * x ç Ó ¥ ≥ x * x + 1 = 0 
=TEX
\end{description}

\item Using 
=INLINEFT
prove_rule 
=TEX
{} prove:
\begin{description}
\item[(a)] 
=INLINEFT
≥ 0 < 1 § 1 º 0
=TEX
{} (using 
=INLINEFT
z_≥_less_thm
=TEX
), and 
=TEX
\item[(b)] 
=INLINEFT
µ n:˙ ∑ 3 º x * x ± x * x º n ¥ 3 º n
=TEX
{} (using 
=INLINEFT
z_º_trans_thm
=TEX
)
\end{description}
 
\item Using 
=INLINEFT
prove_rule
=TEX
{} with  
=INLINEFT
º_clauses
=TEX
{} prove:
\begin{description}
\item[\ \ \ ] 
=INLINEFT
µ i, m, n: ˙ ∑ i + m º i + n § m º n
=TEX
\end{description}
\end{enumerate}
	  
%   7.1.4

\subsection{Goal Oriented Predicate Calculus Proofs}

The methods of proof,  described in Chapter \ref{ZPredicateCalculus}, to be illustrated in these exercises are:

\begin{enumerate}
\item
Proof by stripping.
\item
Automatic proof.
\item
Proof by the ``two tactic method''.
\item
Proof using forward chaining.
\end{enumerate}

% context setting point 3

Set the context:
=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc ["z_language"];
=TEX
{} and then use the following bits and pieces to try a variety of proofs of the following conjectures (PM9 to PM11b) in the predicate calculus in Z, 
=GFT 
a contr_tac;
a z_strip_tac;
a strip_tac;
a step_strip_tac;
a (prove_tac[]);
a (asm_prove_tac[]);
a (z_spec_asm_tac Ò Æ Ò Æ);
a (z_spec_nth_asm_tac 1 Ò Æ);
a (all_asm_fc_tac[]);
=TEX

The following are essentially the same results, taken from Principia Mathematica, as were previously used for exercises in HOL.
However, the results are set generic rather than polymorphic, and quantifiers range over sets rather than types.
The required proofs are similar to those in HOL, but slightly complicated by the set relativisation of the quantification.

The following are from Principia Mathematica *9.

=SML
val PM9 =[
("*9.01", Ò[X](≥ (µx:X∑ ∆x)) § (∂x: X∑ ≥ ∆x)Æ),
("*9.02", Ò[X](≥ (∂x:X∑ ∆x) § (µx:X∑ ≥ ∆x))Æ),
("*9.03", Ò[X](µx:X∑ ∆x ≤ p) § (µx:X∑ ∆x) ≤ pÆ),
("*9.04", Ò[X]p ≤ (µx:X∑ ∆x) § (µx:X∑ p ≤ ∆x)Æ),
("*9.05", Ò[X](∂ x:X∑true) ¥ ((∂x:X∑ ∆x ≤ p) § (∂x:X∑ ∆x) ≤ p)Æ),
("*9.06", Ò[X]p ≤ (∂x:X∑ ∆x) § p ≤ (∂x:X∑ ∆x)Æ)];
=TEX

The following are from Principia Mathematica *10.
=SML
val PM10 =[
("*10.01", Ò[X](∂x:X∑ ∆x) § ≥ (µy:X∑ ≥ ∆y)Æ),
("*10.1", Ò(µx:U∑ ∆x) ¥ ∆yÆ),
("*10.21", Ò[X](µx:X∑ p ¥ ∆x) § p ¥ (µy:X∑ ∆y)Æ),
("*10.22", Ò[X](µx:X∑ ∆x ± Ÿx) § (µy:X∑ ∆y) ± (µz:X∑ Ÿz)Æ),
("*10.24", Ò[X](µx:X∑ ∆x ¥ p) § (∂y:X∑ ∆y) ¥ pÆ),
("*10.27", Ò[X](µx:X∑ ∆x ¥ Ÿx) ¥ ((µy:X∑ ∆y) ¥ (µz:X∑ Ÿz))Æ),
("*10.28", Ò[X](µx:X∑ ∆x ¥ Ÿx) ¥ ((∂y:X∑ ∆y) ¥ (∂z:X∑ Ÿz))Æ),
("*10.35", Ò[X](∂x:X∑ p ± ∆x) § p ± (∂y:X∑ ∆y)Æ),
("*10.42", Ò[X](∂x:X∑ ∆x) ≤ (∂y:X∑ Ÿy) § (∂z:X∑ ∆z ≤ Ÿz)Æ),
("*10.5", Ò[X](∂x:X∑ ∆x ± Ÿx) ¥ (∂y:X∑ ∆y) ± (∂z:X∑ Ÿz)Æ),
("*10.51", Ò[X] (≥ (∂x:X∑ ∆x ± Ÿx) ¥ (µy:X∑ ∆y ¥ ≥ Ÿy))Æ)];
=TEX
=SML
val PM10b =[
("*10.271", Ò[X](µx:X∑ ∆x § Ÿx) ¥ ((µy:X∑ ∆y) § (µz:X∑ Ÿz))Æ),
("*10.281", Ò[X](µx:X∑ ∆x § Ÿx) ¥ ((∂y:X∑ ∆y) § (∂z:X∑ Ÿz))Æ)];

=TEX
The following are from Principia Mathematica *11.
=SML
val PM11 =[
("*11.1", Ò(µx, y:U∑ ∆(x,y)) ¥ ∆(z,w)Æ),
("*11.2", Ò[X](µx, y:X∑ ∆(x,y)) § (µy, x:X∑ ∆(x,y))Æ),
("*11.3", Ò[Y](p ¥ (µx, y:Y∑ ∆(x,y)))
		§ (µx, y:Y∑ p ¥ ∆(x,y))Æ),
("*11.35", Ò[Y](µx, y:Y∑ ∆(x,y) ¥ p) § (∂x, y:Y∑ ∆(x,y)) ¥ pÆ)
];
=TEX
=SML
val PM11b =[
("*11.32", Ò[Y](µx, y:Y∑ ∆(x,y) ¥ Ÿ(x,y))
		¥ (µx, y:Y∑ ∆(x,y)) ¥ (µx, y:Y∑ Ÿ(x,y))Æ),
("*11.45", Ò[Y](∂x, y:Y∑ true) ¥ ((∂x, y:Y∑ p ¥ ∆(x,y))
		§ (p ¥ (∂x, y:Y∑ ∆(x,y))))Æ),
("*11.54", Ò[Y](∂x, y:Y∑ ∆x ± Ÿy) § (∂x:Y∑ ∆x) ± (∂y:Y∑ Ÿy)Æ),
("*11.55", Ò[Y](∂x, y:Y∑ ∆x ± Ÿ(x,y))
		§ (∂x:Y∑ ∆x ± (∂y:Y∑ Ÿ(x,y)))Æ),
("*11.6", Ò[X](∂x:X∑ (∂y:Y∑ ∆(x,y) ± Ÿy) ± —x)
		§ (∂y:Y∑ (∂x:X∑ ∆(x,y) ± —x) ± Ÿy)Æ),
("*11.62", Ò(µx:X; y:Y∑ ∆x ± Ÿ(x,y) ¥ —(x,y))
  		§ (µx:X∑ ∆x ¥ (µy:Y∑ Ÿ(x,y) ¥ —(x,y)))Æ)
];
=TEX


% 7.1.5
\subsection{Rewriting}

% ***5***  7.1.5.1
\subsubsection{Rewriting with the Subgoal Package}

% context setting point 4

Set the context with:
=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc "z_library_ext";
=TEX
{} and then

\begin{enumerate}
\item
choose a goal from set theory, e.g.:
=GFT Student
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
=TEX
\item
rewrite the goal using the current proof context:
=GFT Student
	a (rewrite_tac[]);
=TEX
\item
step back using undo:
=GFT Student
	undo 1;
=TEX
\item
now try rewriting without using the proof context:
=GFT Student
	a (pure_rewrite_tac[]);
=TEX
(this should fail)
\item
try rewriting one layer at a time:
=GFT Student
	a (once_rewrite_tac[]);
=TEX
repeat until it fails.
\item
now try rewriting with specific theorems:
=GFT Student
	set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
	a (pure_rewrite_tac[z_sets_ext_clauses]);
	a (pure_rewrite_tac[z_set_dif_thm]);
	a (pure_rewrite_tac[z_°_thm, z_¿_thm]);
	a (pure_rewrite_tac[z_set_dif_thm]);
=TEX
\item
finish the proof by stripping:
=GFT Student
	a (REPEAT strip_tac);
=TEX
\item
extract the theorem
=GFT Student
	top_thm();
=TEX
\item repeat the above then try repeating:
=GFT Student
	pop_thm();
=TEX
\end{enumerate}

% ***6***  7.1.5.2
\subsubsection{Combining Forward and Backward Proof}

The following exercise illustrates how forward inference may be helpful in specialising results for use in rewriting.  Some hints are given about the method. For each example try the methods suggested for the previous example to see how they fail before following the hint.

% context setting point 5

Set the context with 
=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc "z_library";
=TEX

and then prove the following results by rewriting using the goal package.


\begin{enumerate}
\item :
=GFT Student
set_goal([],Ò x + y = y + xÆ);
=TEX
\item :
=GFT Student
set_goal([],Ò x + y + z = (x + y) + zÆ);
(* hint : try using z_plus_assoc_thm *)
=TEX
\item :
=GFT Student
set_goal([],Ò z + y + x = y + z + xÆ);
(* hint : try using z_plus_assoc_thm1 *)
=TEX
\item :
=GFT Student
set_goal([],Ò x + y + z = y + z + xÆ);
(* hint : try using z_µ_elim with z_plus_assoc_thm1 *)
=TEX
\item :
=GFT Student
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
(* hint : try using z_µ_elim with z_plus_order_thm *)
=TEX
\end{enumerate}

\subsection{Stripping}
\begin{itemize}
\item
Use the examples from Principia Mathematica and also ZRM, e.g.:
=SML
	set_goal([],Ò p ± q ¥ (p § q)Æ);
=TEX
with
\begin{enumerate}
\item :
=SML
	a z_strip_tac;
=TEX
\item and/or:
=SML
	a step_strip_tac;
=TEX
\end{enumerate}
\item
Observe the steps taken and try to identify the reasons for discharge of subgoals.
\item
Select the weakest ``proof context'':
=SML
	push_pc "initial";
=TEX
then retry the examples (or previous exercises).
\item
When you have finished restore the original proof context by:
=SML
	pop_pc();
=TEX
\end{itemize}

\section{Expressions and Schema Expressions}

The following lines of ML are for preparing the exercise database:
=SML
open_theory "z_library";
new_theory "z_exercises_2";
new_parent "usr011";
=TEX
\subsection{Expressions}

The following examples are provable by $prove_tac$ or $prove_rule$ in proof context $z_library$. so first set the context by:

% context setting point 6

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_2";
set_pc "z_library";
=TEX

=SML
val ZE1 = [
("ZE1.1", Ò(2,4) ç (Ãx:Ó ∑ 2*x)Æ),
("ZE1.2", Ò{1,2,3} ç  {1,2,3,4}Æ),
("ZE1.3", ÒÓ ç  ˙Æ),
("ZE1.4", Ò"a" ç {"a", "b"}Æ),
("ZE1.5", Ò≥ 2 ç {3,4}Æ),
("ZE1.6", Òx ç {1,2} ¥ x ç {1,2,3}Æ),
("ZE1.7", Òx*x ç {y:˙ | ∂z:˙ ∑ y = z*z}Æ),
("ZE1.8", Ò(x,y,z) = (v,w,x) ¥ (y,z) = (w,v)Æ),
("ZE1.9", Ò(x ¶ a, y ¶ b) = (x ¶ v, y ¶ w) ¥ (v ¶ a, w ¶ w) = (w ¶ b, v ¶ v)Æ),
("ZE1.10", ÒµFile;File'∑  File =  File' ¥ age = age'Æ),
("ZE1.11", ÒµFile∑ ( File').age = age'Æ),
("ZE1.12", ÒµFile;File'∑( File).age = age' ± ( File).people = people'
		¥  File =  File'Æ)];
=TEX

The next examples are provable by $prove_tac$ or $prove_rule$ in proof context $z_language_ext$, so set the context by:

% context setting point 7

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_2";
set_pc "z_language_ext" ;
=TEX


=SML
val ZE2 = [
("ZE2.1", Òµa:U∏U∑(a.1,a.2) = aÆ),
("ZE2.2", Ò[X,Y](µ p:  (X ∏ Y)∑
			{x:X; y:Y | (x,y) ç p}
		=	{z:X ∏ Y | z ç p})Æ),
("ZE2.3", Ò[x:˙ | x > 0] = {x:˙ | x>0 ∑ (x ¶ x)}Æ)];
=TEX

The following problems are more difficult, typically the proofs involve about four steps each.
=SML
val ZE3 = [
("ZE3.1", Ò(Ãx:˙∑ x+1) 3 = 4Æ),
("ZE3.2", Ò{(1,2), (3,4)} 3 = 4Æ),
("ZE3.3", Ò(1, ~2) ç (abs _) ¥ abs 1 = ~2Æ),
("ZE3.4", Òµ i,j:˙∑ (i,j) ç (abs _) ¥ abs i = jÆ),
("ZE3.5", Òµi:˙∑ abs i ç ÓÆ),
("ZE3.6", Ò(Õx:X | x=3 ∑ x*x) = 9Æ),
("ZE3.7", Ò25 ç {y:˙ ∑ y*y}Æ),
("ZE3.8", Ò(a ∏ b ∏ c) = (d ∏ e ∏ f) ¥ (a ∏ b) = (d ∏ e) ≤ (c ° f) = öÆ),
("ZE3.9", Ò[X,Y](µ p:  (X ∏ Y)∑
			(µ x:X; y:Y∑ (x,y) ç p)
		§	(µ z:X ∏ Y∑ z ç p))Æ),
("ZE3.10", Ò[File | people = {}] = {File | people = {}}Æ),
("ZE3.11", Òßa,b¢ = ßc,d¢ ¥ a=c ± b=dÆ),
("ZE3.12", Òßa,b¢ = ßd,e¢ ¥ ßb,d¢ = ße,a¢Æ)];
=TEX

Hints for group ZE3:
\begin{enumerate}
\item
Use $conv_tac (MAP_C\ z_¬_conv)$.
\item
Use $z_app_eq_tac$.
\item
Forward chain ($all_fc_tac$) using $z_≠_ç_rel_§_app_eq_thm$.
But first you need to get into the assumptions the things it needs to chain on.
\item
Very similar to number 3.
\item
Forward chain using $z_fun_ç_clauses$.
\item
Specialise the result of applying $z_Õ_rule$ to the $Õ$ expression (using $z_µ_elim$) and strip this into the assumptions.
Then use the ``two tactic'' method (i.e. specialise assumptions as necessary) to derive a contradiction.
The last step requires rewriting an assumption to make the contradiction apparent.
\item
Rewriting gives and existential which can be solved using $z_∂_tac$.
Alternatively a proof by contradiction can be used, but this needs rewriting an assumption at the end to get the contradiction out.
\item
The proof must begin by using extensionality (either use proof context $z_library_ext$ or rewrite with $z_sets_ext_clauses$).
A straightforward proof by contradiction is possible using the ``two tactic method''.
\item
Use of $z_selât_intro_conv$ is necessary in this proof.
\item
The easiest proof is obtained by a single $z_strip_tac$ in proof context "z_library_ext" followed by $prove_tac$ in proof context $z_library$ which leaves just one existential subgoal.
\item
Two tactic method in proof context $z_library_ext$ suffices.
\item (No hint.)
\end{enumerate}


\subsection{Propositional Schema Calculus}

We define four schemas with distinct but compatible signatures called Pab, Qac, Rbc, Sabc and Tde and then prove the following goals showing that the schema calculus operators behave in the same way as the ordinary logical connectives.
The names of the schemas are chosen to remind us of the signatures, since this is of significance in the examples. ( The following lines of Z are for preparing the exercises database.)

πZ
Pab ¶ [a,b:˙]
∞
πZ
Qac ¶ [a,c:˙]
∞
πZ
Rbc ¶ [b,c:˙]
∞
πZ
Sabc ¶ [a,b,c:˙]
∞
πZ
Tde ¶ [d,e:˙]
∞
=TEX
The following problems are analogous to theorems taken from Principia Mathematica *2, and are shown together with their reference numbers.

=SML
val SCPM2 = [
("*2.02", Ò ê((Qac ¥ (Pab ¥ Qac))∫U)Æ),
("*2.03", Ò ê(((Pab ¥ ≥ Qac) ¥ (Qac ¥ ≥ Pab))∫U)Æ),
("*2.15", Ò ê(((≥ Pab ¥ Qac) ¥ (≥ Qac ¥ Pab))∫U)Æ),
("*2.16", Ò ê(((Pab ¥ Qac) ¥ (≥ Qac ¥ ≥ Pab))∫U)Æ),
("*2.17", Ò ê(((≥ Qac ¥ ≥ Pab) ¥ (Pab ¥ Qac))∫U)Æ),
("*2.04", Ò ê(((Pab ¥ Qac ¥ Rbc) ¥ (Qac ¥ Pab ¥ Rbc))∫U)Æ),
("*2.05", Ò ê(((Qac ¥ Rbc) ¥ (Pab ¥ Qac) ¥ (Pab ¥ Rbc))∫U)Æ),
("*2.06", Ò ê(((Pab ¥ Qac) ¥ (Qac ¥ Rbc) ¥ (Pab ¥ Rbc))∫U)Æ),
("*2.08", Ò ê((Pab ¥ Pab)∫U)Æ),
("*2.21", Ò ê((≥ Pab ¥ (Pab ¥ Qac))∫U)Æ)];
=TEX
The following are analogous to Principia Mathematica *3
=SML
val SCPM3 = [
("*3.01", Ò ê((Pab ± Qac § ≥(≥ Pab ≤ ≥ Qac))∫U)Æ),
("*3.2", Ò ê((Pab ¥ Qac ¥ Pab ± Qac)∫U)Æ),
("*3.26", Ò ê((Pab ± Qac ¥ Pab)∫U)Æ),
("*3.27", Ò ê((Pab ± Qac ¥ Qac)∫U)Æ),
("*3.3", Ò ê(((Pab ± Qac ¥ Rbc) ¥ (Pab ¥ Qac ¥ Rbc))∫U)Æ),
("*3.31", Ò ê(((Pab ¥ Qac ¥ Rbc) ¥ (Pab ± Qac ¥ Rbc))∫U)Æ),
("*3.35", Ò ê(((Pab ± (Pab ¥ Qac)) ¥ Qac)∫U)Æ),
("*3.43", Ò ê(((Pab ¥ Qac) ± (Pab ¥ Rbc) ¥ (Pab ¥ Qac ± Rbc))∫U)Æ),
("*3.45", Ò ê(((Pab ¥ Qac) ¥ (Pab ± Rbc ¥ Qac ± Rbc))∫U)Æ),
("*3.47", Ò ê(((Pab ¥ Rbc) ± (Qac ¥ Sabc) ¥ (Pab ± Qac ¥ Rbc ± Sabc))∫U)Æ)];

=TEX
Problems analogous to results in Principia Mathematica *4.
=SML
val SCPM4 = [
("*4.1", Ò ê((Pab ¥ Qac) § (≥ Qac ¥ ≥ Pab)∫U)Æ),
("*4.11", Ò ê((Pab § Qac) § (≥ Pab § ≥ Qac)∫U)Æ),
("*4.13", Ò ê((Pab § (≥ ≥ Pab))∫U)Æ),
("*4.2", Ò ê((Pab § Pab)∫U)Æ),
("*4.21", Ò ê((Pab § Qac) § (Qac § Pab)∫U)Æ),
("*4.22", Ò ê(((Pab § Qac) ± (Qac § Rbc) ¥ (Pab § Rbc))∫U)Æ),
("*4.24", Ò ê((Pab § (Pab ± Pab))∫U)Æ),
("*4.25", Ò ê((Pab § (Pab ≤ Pab))∫U)Æ),
("*4.3", Ò ê((Pab ± Qac § Qac ± Pab)∫U)Æ),
("*4.31", Ò ê((Pab ≤ Qac § Qac ≤ Pab)∫U)Æ),
("*4.33", Ò ê(((Pab ± Qac) ± Rbc § Pab ± (Qac ± Rbc))∫U)Æ),
("*4.4", Ò ê((Pab ± (Qac ≤ Rbc) § (Pab ± Qac) ≤ (Pab ± Rbc))∫U)Æ),
("*4.41", Ò ê((Pab ≤ (Qac ± Rbc) § (Pab ≤ Qac) ± (Pab ≤ Rbc))∫U)Æ),
("*4.71", Ò ê(((Pab ¥ Qac) § (Pab § (Pab ± Qac)))∫U)Æ),
("*4.73", Ò ê((Qac ¥ (Pab § (Pab ± Qac)))∫U)Æ)];
=TEX
Problems analogous to results in Principia Mathematica *5.
=SML
val SCPM5 = [
("*5.1", Ò ê((Pab ± Qac ¥ (Pab § Qac))∫U)Æ),
("*5.32", Ò ê(((Pab ¥ (Qac § Rbc)) ¥ ((Pab ± Qac) § (Pab ± Rbc)))∫U)Æ),
("*5.6", Ò ê(((Pab ± ≥ Qac ¥ Rbc) ¥ (Pab ¥ (Qac ≤ Rbc)))∫U)Æ)];

repeat drop_main_goal;
=TEX
\subsection{Predicate Calculus Quantification}
=SML
val SCPM9 =[
("*9.01", Òê(((≥ (µQac∑ Sabc)) § (∂Qac∑ ≥ Sabc))∫U)Æ),
("*9.02", Òê(((≥ (∂Qac∑ Sabc) § (µQac∑ ≥ Sabc)))∫U)Æ)];
=TEX
=SML
val SCPM10 =[
("*10.01", Òê(((∂Qac∑ Sabc) § ≥ (µQac∑ ≥ Sabc))∫U)Æ),
("*10.21", Òê(((µQac∑ Tde ¥ Sabc) § Tde ¥ (µQac∑ Sabc))∫U)Æ),
("*10.22", Òê(((µRbc∑ Sabc ± Rbc) § (µRbc∑ Sabc) ± (µRbc∑ Rbc))∫U)Æ)];
=TEX

\section{Paragraphs}

=SML
open_theory "z_library";
new_theory "z_exercises_3";
=TEX

\subsection{Axiomatic Descriptions and Generics}

Do the following exercises in axiomatic mode to avoid the consistency proofs which would otherwise be necessary.
(Consistency-proof examples follow.)  Thus set the context as follows: 

% context setting point 8

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX

\begin{enumerate}
\item
In this context, using a $fun$ fixity paragraph and a generic axiomatic description define a conditional construct $if$ a $then$ b $else$ c.
(Hints: you will need to use the higher order capabilities of ProofPower HOL for this one.
The first parameter will have type BOOL.)
\item
Using the specification prove the following result:
=GFT
set_goal ([], Òif 2>1 then 1 else 0 = 1Æ);
=TEX
\end{enumerate}

\subsection{Consistency Proofs}

% context setting point 9

\begin{enumerate}
\item
Set the  context as follows:

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", false)];
=TEX

\item
Use an axiomatic description to define a global variable $num$ whose value is a natural number between 4 and 50.
\item
Prove the consistency result for this description and save it.
%(set up the goal with $push_consistency_goal$, rewrite with)
\item
now use the specification to prove that:
=GFT
	?Ù num æ 0
=TEX
and save the result in the theory.
\end{enumerate}

\subsection{Reasoning using Schema Definitions}

% context setting point 10

Set the context as follows:

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", false)];
=TEX

and, using the following definitions (which are predefined in the `exercises' database):

ˇSTATE¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	r : ˙ ™ ˙
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇOP¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	STATE; STATE'; i?:Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇOP2¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	OP
˜¸¸¸¸¸¸¸¸¸¸¸
‹	r' = {i?} · r 
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸


formulate and prove the following simple conjectures:

\begin{enumerate}
\item 
=INLINEFT 
?Ù pre OP § i? æ 0
=TEX
\item $OP2$ is a correct refinement of $OP$, that is,
=INLINEFT 
?Ù (pre OP ¥ pre OP2) ± (pre OP ± OP2 ¥ OP)
=TEX

\item
=INLINEFT
?Ù pre OP § true
=TEX
\end{enumerate}

\section{The Z ToolKit}

=SML
open_theory "z_library";
new_theory "z_exercises_4";
=TEX

\subsection{Sets}

The following problems are all in the theory of elementary sets as defined in section 4.1 of {\it The Z Notation} \cite{spivey92}.
Following \cite{spivey92} we have used free-variable formulations, though this is not usually recommended, since universally quantified results (over \verb!"U"!) are usually needed for rewriting.
Proofs of the results quantified over U are very similar.

All the results are provable  using the proof context \verb!z_sets_ext! (which provides for extensional proofs of results in elementary set theory).  Set the context as follows:

% context setting point 11

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_sets_ext";
=TEX

\subsubsection{Results Provable by Stripping}

=SML
val Z1 = [
("Z1.1", Ò a ¿ a = a ¿ {} = a ° a = a \ {} = aÆ),
("Z1.2", Ò a ° {} = a \ a = {} \ a = {}Æ),
("Z1.3", Ò a ¿ b = b ¿ aÆ),
("Z1.4", Ò a ° b = b ° aÆ),
("Z1.5", Ò a ¿ (b ¿ c) = (a ¿ b) ¿ cÆ),
("Z1.6", Ò a ° (b ° c) = (a ° b) ° cÆ),
("Z1.7", Ò a ¿ (b ° c) = (a ¿ b) ° (a ¿ c)Æ),
("Z1.8", Ò a ° (b ¿ c) = (a ° b) ¿ (a ° c)Æ),
("Z1.9", Ò (a ° b) ¿ (a \ b) = aÆ),
("Z1.10", Ò ((a \ b) ° b) = {}Æ),
("Z1.11", Ò a \ (b \ c) = (a \ b) ¿ (a ° c)Æ),
("Z1.12", Ò (a \ b) \ c = a \ (b ¿ c)Æ),
("Z1.13", Ò a ¿ (b \ c) = (a ¿ b) \ (c \ a)Æ),
("Z1.14", Ò a ° (b \ c) = (a ° b) \ cÆ),
("Z1.15", Ò (a ¿ b) \ c = (a \ c) ¿ (b \ c)Æ)];
=TEX
\vfill
=SML
val Z2 = [
("Z2.1", Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ),
("Z2.2", Ò ≥ x ç {}Æ),
("Z2.3", Ò a Ä aÆ),
("Z2.4", Ò ≥ a † aÆ),
("Z2.5", Ò {} Ä aÆ),
("Z2.6", Ò ﬁ {} = {}Æ),
("Z2.7", Ò • {} = UÆ)];
=TEX
\vfill

For the following stripping alone will not suffice.
The ``two tactic method'' will solve them all, so will ``prove\_tac''.

\vfill
=SML
val Z3 = [
("Z3.1", Ò a Ä b § a ç  bÆ),
("Z3.2", Ò a Ä b ± b Ä a § a = bÆ),
("Z3.3", Ò ≥ (a † b ± b † a)Æ),
("Z3.4", Ò a Ä b ± b Ä c ¥ a Ä cÆ),
("Z3.5", Ò a † b ± b † c ¥ a † cÆ),
("Z3.6", Ò {} † a § ≥ a = {}Æ),
("Z3.7", Ò ﬁ (a ¿ b) = (ﬁ a) ¿ (ﬁ b)Æ),
("Z3.8", Ò • (a ¿ b) = (• a) ° (• b)Æ),
("Z3.9", Ò  a Ä b ¥ ﬁ a Ä ﬁ b Æ),
("Z3.10", Ò  a Ä b ¥ • b Ä • a Æ)];
=TEX
\vfill
=SML
val Z3b = [
("Z3b.1", Ò a Ä b ± b Ä a § a = bÆ),
("Z3b.2", Ò a † b ± b † c ¥ a † cÆ),
("Z3b.3", Ò {} † a § ≥ a = {}Æ)];
=TEX

\vfill

\subsection{Relations}

\vfill


% context setting point 12

Set the context by:

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_rel_ext";
=TEX


\vfill


=SML
val Z4 = [
("Z4.1", Ò[X,Y] (R ç X ™ Y) ¥ (µ x : X ∑ x ç dom R § (∂ y : Y ∑ (x,y) ç R))Æ),
("Z4.2", Ò[X,Y] (R ç X ™ Y) ¥ (µ y : Y ∑ y ç ran R § (∂ x : X ∑ (x,y) ç R))Æ),
("Z4.3", Òdom {x1 Ì y1, x2 Ì y2} = {x1, x2}Æ),
("Z4.4", Òran {x1 Ì y1, x2 Ì y2} = {y1, y2}Æ),
("Z4.5", Òdom (Q ¿ R) = dom Q ¿ dom RÆ),
("Z4.6", Òran (Q ¿ R) = ran Q ¿ ran RÆ),
("Z4.7", Òdom (Q ° R) Ä dom Q ° dom RÆ),
("Z4.8", Òran (Q ° R) Ä ran Q ° ran RÆ),
("Z4.9", Òdom {} = {}Æ),
("Z4.10", Òran {} = {}Æ)];
=TEX
\vfill
=SML
val Z5 = [
("Z5.1", Ò[X,Y,Z] P ç X ™ Y ± Q ç Y ™ Z ¥ 
	((x Ì z) ç P ª Q § (∂ y : Y ∑ (x,y) ç P ± (y,z) ç Q))Æ),
("Z5.2", ÒP ª (Q ª R) = (P ª Q) ª RÆ)];
=TEX
\vfill
=SML
val Z5b = [
("Z5b.1", Ò[X] (x Ì x') ç id X § x = x' ç XÆ),
("Z5b.2", Ò(id X) ª P = X Ú PÆ),
("Z5b.3", ÒP ª id Y = P í YÆ),
("Z5b.4", Ò(id V) ª id W = id (V ° W)Æ)];
=TEX

\vfill

=SML
val Z5c = [
("Z5c.1", Ò[X,Y,Z] (µx:U;g:U∑ g ç X ﬂ Y ± x ç dom g ¥ (x, g x) ç g)Æ),
("Z5c.2", Ò[X,Y,Z] x ç dom g ± g x ç dom f ± g ç X ﬂ Y
	± f ç Y ﬂ Z ¥ (f o g)(x) = f(g(x))Æ)];
=TEX
\vfill
=SML
val Z6 = [
("Z6.1", Òdom (S Ú R) = S ° dom RÆ),
("Z6.2", Òran (R í T) = ran R ° TÆ),
("Z6.3", ÒS Ú R Ä RÆ),
("Z6.4", ÒR í T Ä RÆ),
("Z6.5", Ò(S Ú R) í T = S Ú (R í T)Æ),
("Z6.6", ÒS Ú (V Ú R) = (S ° V) Ú RÆ),
("Z6.7", Ò(R í T) í W = R í (T ° W)Æ)];
=TEX
\vfill
=SML
val Z6b = [
("Z6b.1", Òran R Ä Y ¥ (S Ú R = (id S) ª R = (S ∏ Y) ° R)Æ),
("Z6b.2", Òdom R Ä X ¥ (R í T = R ª (id T) = R ° (X ∏ T))Æ)];
=TEX
\vfill
=SML
val Z7 = [
("Z7.1", Òdom R Ä X ¥ S · R = (X \ S) Ú RÆ),
("Z7.2", Òran R Ä Y ¥ R Å T = R í (Y \ T)Æ),
("Z7.3", Ò(S Ú R) ¿ (S · R) = RÆ),
("Z7.4", Ò(R í T) ¿ (R Å T) = RÆ)];
=TEX
\vfill
=SML
val Z8 = [
(* ("Z8.1", Ò(y Ì x) ç R Á~Í § (x Ì y) ç RÆ), *)
("Z8.2", Ò(R Á~Í) Á~Í = RÆ),
("Z8.3", Ò(Q ª R) Á~Í = R Á~Í ª Q Á~ÍÆ),
("Z8.4", Òdom(R Á~Í) = ran RÆ),
("Z8.5", Òran(R Á~Í) = dom RÆ)];
=TEX
\vfill
=SML
val Z8b = [
("Z8b.1", Ò(id V) Á~Í = id VÆ),
("Z8b.2", Òid(dom R) Ä R ª (R Á~Í)Æ),
("Z8b.3", Òid(ran R) Ä (R Á~Í) ª RÆ)];
=TEX
\vfill
=SML
val Z9 = [
("Z9.1", ÒS Ä X ¥ (y ç R ® S © § (∂ x : X ∑ x ç S ± (x,y) ç R))Æ),
("Z9.2", ÒR ® S © = ran(S Ú R)Æ),
("Z9.3", Òdom(Q ª R) = (Q Á~Í) ® dom R ©Æ),
("Z9.4", Òran(Q ª R) = R ® ran Q ©Æ),
("Z9.5", ÒR ® S ¿ T © = R ® S © ¿ R ® T ©Æ),
("Z9.6", ÒR ® S ° T © Ä R ® S © ° R ® T ©Æ),
("Z9.7", ÒR ® dom R © = ran RÆ)];
=TEX
\vfill
=SML
val Z9b = [
("Z9b.1", Òdom R = first ® R ©Æ),
("Z9b.2", Òran R = second ® R ©Æ)];
=TEX
\vfill
=SML
val Z10 = [
("Z10.1", ÒR ´ R = RÆ),
("Z10.2", ÒP ´ (Q ´ R) = (P ´ Q) ´ RÆ),
("Z10.3", Òö ´ R = R ´ ö = RÆ),
("Z10.4", Òdom Q ° dom R = ö ¥ Q ´ R = Q ¿ RÆ),
("Z10.5", ÒV Ú (Q ´ R) = (V Ú Q) ´ (V Ú R)Æ),
("Z10.6", Ò(Q ´ R) í W Ä (Q í W) ´ (R í W)Æ)];
=TEX
\vfill
=SML
val Z10b = [
("Z10b.1", Òdom(Q ´ R) = (dom Q) ¿ (dom R)Æ),
("Z10b.2", Òf ç X ﬂ Y ± g ç X ﬂ Y ¥ 
	x ç (dom f) \ (dom g) ¥ (f ´ g) x = f xÆ),
("Z10b.3", Òg ç X ﬂ Y ± x ç dom g ¥ (f ´ g) x = g xÆ)];
=TEX
\vfill
=SML
val Z11 = [
("Z11.1", ÒR Ä R Á+ÍÆ),
("Z11.2", Òid X Ä R Á*ÍÆ),
("Z11.3", ÒR Ä RÁ*ÍÆ)];
=TEX
\vfill
=SML
val Z11b = [
("Z11b.1", ÒR Á+Í ª (R Á+Í) Ä R Á+ÍÆ),
("Z11b.2", Ò(R Á+Í) Á+Í = R Á+ÍÆ),
("Z11b.3", Ò(R Á*Í) Á*Í = R Á*ÍÆ),
("Z11b.4", ÒR Ä Q ± Q ª Q Ä Q ¥ R Á+Í Ä QÆ),
("Z11b.5", ÒRÁ*Í ª RÁ*Í = RÁ*ÍÆ),
("Z11b.6", Òid X Ä Q ± R Ä Q ± Q ª Q Ä Q ¥ RÁ*Í Ä QÆ),
("Z11b.7", ÒRÁ*Í = R Á+Í ¿ id X = (R ¿ id X)Á+ÍÆ),
("Z11b.8", ÒRÁ+Í = R ª R Á*Í = R Á*Í ª RÆ),
("Z11b.9", ÒS Ä R Á*Í ® S ©Æ),
("Z11b.10", ÒS Ä T ± R ® T © Ä T ¥ R Á*Í ®S© Ä TÆ),
("Z11b.11", ÒR ®R Á*Í ® S © © Ä R Á*Í ®S©Æ)];
=TEX
\subsection{Functions}

Set the context:

% context setting point 13

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_fun_ext";
=TEX

=SML
val Z12 = [
("Z12.1", Ò f ç X ﬂ Y ± (x, y) ç f ¥ f x = y Æ),
("Z12.2", Ò f ç X ˛ Y ± (x, y) ç f ¥ f x = y Æ),
("Z12.3", Ò f ç X ‡ Y ± (x, y) ç f ¥ f x = y Æ),
("Z12.4", Ò f ç X ˛ Y ± (x, y) ç f ¥ f x = y Æ),
("Z12.5", Ò f ç X è Y ± (x, y) ç f ¥ f x = y Æ),
("Z12.6", Ò f ç X œ Y ± (x, y) ç f ¥ f x = y Æ)
];
val Z12a = [
("Z12a.1", Ò f ç (X ﬂ Y) ¿ (X ˛ Y) ¿ (X ‡ Y)
		¿ (X ˛ Y) ¿ (X è Y) ¿ (X œ Y)
		± (x, y) ç f ¥ f x = y Æ)];
=TEX
\vfill
=SML
val Z12b = [
("Z12b.1", Òf ç X ™ Y ¥ (f ç X ﬂ Y § f o fÁ~Í = id(ran f))Æ),
("Z12b.2", Òf ç X ˛ Y § (f ç X ﬂ Y ± f Á~Í ç Y ﬂ X)Æ),
("Z12b.3", Òf ç X ˛ Y § (f ç X ﬂ Y ± f Á~Í ç Y ﬂ X)Æ),
("Z12b.4", Òf ç X ‡ Y § (f ç X ≠ Y ± f Á~Í ç Y ﬂ X)Æ),
("Z12b.5", Òf ç X ˛ Y ¥ f ®S ° T© = f ®S© ° f ®T©Æ),
("Z12b.6", Òf ç X è Y § (f ç X ≠ Y ± f Á~Í ç Y ≠ X)Æ),
("Z12b.7", Òf ç X œ Y ¥ f o f Á~Í = id YÆ)];
=TEX
\vfill

\subsection{Numbers and Finiteness}


\begin{enumerate}
\item
Set the context to axiomatic mode as follows:

% context setting point 14

=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
{} and then give an inductive definition using a Z axiomatic description of the function $ì$ which maps the natural number $n$ to the sum of the first $n$ natural numbers.
\item
Using $z_Ó_induction_tac$ prove that:
=INLINEFT
µn: Ó∑ (ì n) * 2 = n * (n+1)`
=TEX
\item
Set the context as follows:

% context setting point 15


=GFT Student
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_library_ext";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX

{} and then, using the specification of 
=INLINEFT
(_.._)
=TEX
 (obtained using $z_get_spec$) and forward chaining ($all_fc_tac$) with the theorem $z_º_trans_thm$ prove that:
 
=INLINEFT
µ x, y : ˙ ∑ x º y ¥ (0 .. x) Ä (0 .. y)
=TEX
\item
Now prove the harder result:
=INLINEFT
µ x, y : ˙ ∑ ≥ x º y ¥ (0 .. y) Ä (0 .. (x - 1))
=TEX

Helpful theorems in this case are $z_º_less_trans_thm$, $z_º_º_0_thm$, $z_plus_order_thm$ and $z_minus_thm$.
\end{enumerate}

=SML
val ZNum = [
("ZNum.2", Òµ x, y : ˙ ∑ x º y ¥ (0 .. x) Ä (0 .. y)Æ),
("ZNum.3", Òµ x, y : ˙ ∑ ≥ x º y ¥ (0 .. y) Ä (0 .. (x - 1))Æ)];
=TEX
(The term for the first goal cannot be entered until the definition of $ì$ has been processed).

=IGNORE

\subsection{Sequences}


\subsection{Bags}

\section{Case Studies}

