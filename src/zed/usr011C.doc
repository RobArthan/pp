% usr011C.doc   %Z% $Date$ $Revision$ $RCSfile$
% this should form a Chapter of the document
% Z Expressions
=TEX
{\ftlmargin=0.5in
\section{Expressions}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* function application:  Ò f xÆ  *)
	
 |	€ZApp› 		of TERM * TERM	(* expressions *)
 		
	(* lambda expression: Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
	
 |	€ZÃ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 	
	(* definite description: Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
	
 |	€ZÕ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
			* TERM		(* expression *)
 		
	(* power set construction: Ò  ˙Æ *)
	
 |	€Z›		of TERM		(* expression *)

	(* set display: Ò {1,2,3,4} Æ *)
	
 |	€ZSetd›		of TYPE	(* HOL type of elements *)
 			* TERM list	(* expressions *)
 		
	(* set abstraction: Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
	
 |	€ZSeta› 		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 		
	(* tuple: Ò (1,2,3,4) Æ *)
	
 |	€ZTuple› 	of TERM list		(* expressions *)
 		
	(* tuple element selection: Ò (x,y).2Æ *)
	
 |	€ZSelât› 		of TERM		(* expression *)
 			* int			(* element number *)

 	(* cartesian product: Ò (˙ ∏ Ó) Æ *)
 	
 |	€Z∏›		of TERM list		(* expressions *)
 		
	(* binding: Ò (people ¶ {}, age ¶ {}) Æ *)
	
 |	€ZBinding›	of (	string		(* component name *)
 			* TERM		(* component value *)
 			) list
 		
	(* theta term: Ò  File' Æ *)
	
 |	€Z ›		of TERM		(* schema expression *)
			* string		(* decoration *)
 		
	(* binding component selection: Ò (a ¶ 1, b ¶ "4").b Æ *)
	
 |	€ZSelâs›		of TERM		(* expression *)
 			* string		(* component name *)

	(* horizontal schema expression: Ò [x:˙ | x>0] Æ *)
	
 |	€Zâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
		
	(* sequence display: Ò ß1,2,3¢Æ *)
	
 |	€Zß¢›		of TYPE		(* type of elements *)
			* TERM list		(* values of elements *)
=TEX
}

The main new feature here is the binding display, which is important in expressing convenient proof rules.

Though absent from the first edition of the ZRM \cite{spivey89}, binding displays have been introduced into the second edition \cite{spivey92} for exposition, but not as part of Z, and have now appeared in the draft standard, with two distinct concrete syntaxes neither of which corresponds to our proposal.

Bag displays and relational image, which were once considered part of the language, can now be introduced in the library using appropriate fixity declarations.


\subsection{Function Application}\label{FunctionApplication}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* function application:  Ò f xÆ  *)
	
 |	€ZApp› 		of TERM * TERM		(* expressions *)
=TEX
}

Function application may also use infix, postfix or ``fancyfix'' notation if an appropriate fixity paragraph has been entered.
In such cases the arguments are effectively the name of the global variable and the second is the term consisting of a tuple of arguments.

=SML
dest_z_term Òf aÆ;
=GFT ProofPower output
val it = ZApp (ÒfÆ, ÒaÆ) : Z_TERM   
=TEX

=SML
dest_z_term Òa ¿ bÆ;
=GFT ProofPower output
val it = ZApp (Ò(_ ¿ _)Æ, Ò(a, b)Æ) : Z_TERM   
=TEX

In the following case the fixity declaration for bag brackets required a single argument which is a sequence (with sequence brackets elided in the concrete syntax of the bag display).

=SML
dest_z_term Ò˚1,2,3,2,1˝Æ;
=GFT ProofPower output
val it = ZApp (Ò(˚ ... ˝)Æ, Òß1, 2, 3, 2, 1¢Æ) : Z_TERM   
=TEX

\subsubsection{Proof Support}

Applications of lambda abstractions can be eliminated by (conditional) ¬-conversion.

=SML
z_¬_conv Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower output
val it = P a, a ç X Ù (Ã x : X | P x ∑ f x) a = f a : THM   
=TEX
Applications may also be eliminated in favour of definite descriptions (though this is not particularly helpful).

=SML
z_app_conv Ò f aÆ;
=GFT ProofPower output
val it = Ù f a = Õ f_a : U | (a, f_a) ç f ∑ f_a : THM   
=TEX

More commonly function applications will be eliminated by rewriting with the definition of the relevant function.


\subsection{Lambda Abstraction}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* lambda expression Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
	
 |	€ZÃ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
=TEX
}
\subsubsection{Proof Support}

$Ã$-abstractions when applied to arguments may be eliminated by $z_¬_conv$ (see \ref{FunctionApplication}).

Assertions about membership of $Ã$-abstractions may be directly eliminated.
=SML
rewrite_conv [] Òz ç (Ã x:X | P x ∑ f x)Æ;
=GFT ProofPower output
val it = Ù z ç Ã x : X | P x ∑ f x § z.1 ç X ± P z.1 ± f z.1 = z.2 : THM  
=TEX

Since $Ã$-abstractions denote sets they may also be eliminated in favour of set comprehensions using $z_Ã_conv$. 

=SML
z_Ã_conv ÒÃ x:X | P x ∑ f xÆ;
=GFT ProofPower output
val it = Ù (Ã x : X | P x ∑ f x) = {x : X | P x ∑ (x, f x)} : THM   
=TEX

\subsection{Definite Description}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* definite description Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
	
 |	€ZÕ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
			* TERM		(* expression *)
=TEX
}
\subsubsection{Proof Support}

Definite descriptions may be eliminated using $z_Õ_rule$.

=SML
z_Õ_rule Ò Õ x:X | P ∑ yÆ;
=GFT ProofPower output
val it = Ù µ x' : U
    ∑ (µ x : X | P ∑ y = x') ± (∂ x : X | P ∑ y = x')
      ¥ (Õ x : X | P ∑ y) = x' : THM
=TEX

\subsection{The Power Set}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* power set construction, Ò  ˙Æ *)
	
 |	€Z›		of TERM		(* expression *)
=TEX
}
\subsubsection{Proof Support}

Membership statements concerning power sets may be eliminated using $z_ç__conv$, or by rewriting in proof context ``$z_language_ext$''.

=SML
PC_C1 "z_language_ext" rewrite_conv[] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § (µ x1 : U ∑ x1 ç z ¥ x1 ç y) : THM   
=TEX

\subsection{Set Displays}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* set display, Ò {1,2,3,4} Æ *)
	
 |	€ZSetd›		of TYPE	(* HOL type of elements *)
 			* TERM list	(* expressions *)
=TEX
}
\subsubsection{Proof Support}

Membership statements sets displays may be eliminated using $z_ç_setd_conv$, or by rewriting in proof context ``$z_language$''.

=SML
rewrite_conv[] Ò z ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù z ç {1, 2, 3, 4, 5} §
	z = 1 ≤ z = 2 ≤ z = 3 ≤ z = 4 ≤ z = 5 : THM
=TEX

\subsection{Set Abstractions}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM		
	(* set abstraction, Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
	
 |	€ZSeta› 		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 		
=TEX
}
\subsubsection{Proof Support}

Statements about membership of set abstractions may be eliminated using $z_ç_seta_conv$, or by rewriting in proof context ``$z_language$''.

A simple abstraction results in straightforward substitution into the body of the abstraction:

=SML
rewrite_conv[] Ò 9 ç {x:Ó | x < 12}Æ;
=GFT ProofPower output
val it = Ù 9 ç {x : Ó | x < 12} § 9 ç Ó ± 9 < 12 : THM   
=TEX

Where the signature is more complex tuple projections are introduced:

=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y}Æ;
=GFT ProofPower output
val it = Ù z ç {x, y : Ó | x < y}
§ (z.1 ç Ó ± z.2 ç Ó) ± z ç (_ < _) : THM
=TEX

Where membership is asserted of a tuple the projections are undertaken automatically.

=SML
rewrite_conv[]Ò (v,w) ç {x, y:Ó | x < y}Æ;
=GFT ProofPower output
val it = Ù (v, w) ç {x, y : Ó | x < y}
§ (v ç Ó ± w ç Ó) ± v < w : THM   
=TEX

In the general case introduction of an existential is necessary, though this is avoided whenever possible.

=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y ∑ x * y - x}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y ∑ x * y - x}
§ (∂ x, y : Ó | x < y ∑ x * y - x = z) :THM
=TEX

\subsection{Tuple Displays}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* tuple, Ò (1,2,3,4) Æ *)
	
 |	€ZTuple› 	of TERM list		(* expressions *)
=TEX
}

Note that $n-$tuples for $n > 2$ are not iterated pairs.

\subsubsection{Proof Support}

Two tuple displays are equal iff each of their respective components are equal.
This fact is built into the proof context $z_language$ both for rewriting and stripping assumptions or conclusions.

=SML
rewrite_conv[] Ò(x,y) = (a,b)Æ;
=GFT ProofPower output
val it = Ù (x, y) = (a, b) § x = a ± y = b : THM   
=TEX

\subsection{Tuple Element Selection}\label{TupleSelection}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* tuple element selection, Ò (x,y).2Æ *)
	
 |	€ZSelât› 		of TERM		(* expression *)
 			* int			(* element number *)
=TEX
}
\subsubsection{Proof Support}

Conversions to effect projection from tuple displays are also built into proof context ``$z_language$''.
=SML
rewrite_conv[] Ò (x,y).1Æ;
=GFT ProofPower output
val it = Ù (x, y).1 = x : THM   
=TEX

\subsection{Cartesian Products}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
 	(* cartesian product, Ò (˙ ∏ Ó) Æ *)
 	
 |	€Z∏›		of TERM list		(* expressions *)
=TEX
}

Note that the n-ary cartesian products for $n>2$ are not formed by iteration of the binary cartesian product.

\subsubsection{Proof Support}

The membership conversion for n-ary cartesian products is $z_ç_∏_conv$ which is built into proof context $z_language$.

=SML
rewrite_conv[] Ò (a, b, c) ç (x ∏ y ∏ z)Æ;
=GFT ProofPower output
val it = Ù (a, b, c) ç x ∏ y ∏ z
	§ a ç x ± b ç y ± c ç z : THM   
=TEX

Cartesian products may also be converted into set abstractions using $z_∏_conv$.
=SML
z_∏_conv	Ò (x ∏ y ∏ z)Æ;
=GFT ProofPower output
val it = Ù x ∏ y ∏ z = {tâ1 : x; tâ2 : y; tâ3 : z} : THM   
=TEX

Extensional proof contexts incorporate an extensional understanding of equality of cartesian products:

=SML
PC_C1 "z_language_ext"
rewrite_conv[] Ò (x ∏ y ∏ z) = (x' ∏ y' ∏ z')Æ;
=GFT ProofPower output
val it = Ù x ∏ y ∏ z = x' ∏ y' ∏ z'
    § (µ x1 : U; x2 : U; x3 : U
      ∑ x1 ç x ± x2 ç y ± x3 ç z
      § x1 ç x' ± x2 ç y' ± x3 ç z') : THM
=TEX

Such an equation can also be demonstrated by rewriting if each of the respective components can be proven equal, however this is not a necessary condition for the equality (since any single empty component set will render the cartesian product empty).

\subsection{Binding Displays}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* binding Ò (people ¶ {}, age ¶ {}) Æ *)
	
 |	€ZBinding›	of (	string		(* component name *)
 			* TERM		(* component value *)
 			) list
=TEX
}

\subsubsection{Proof Support}

Two binding displays are equal iff each of their respective components are equal.
This fact is built into the proof context $z_language$ for rewriting and for stripping assumptions and conclusions.

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b) = (y ¶ d, x ¶ c)Æ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) = (x ¶ c, y ¶ d) § a = c ± b = d : THM   
=TEX


\subsection{Theta Terms}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* theta term Ò  File' Æ *)
	
 |	€Z ›		of TERM		(* schema expression *)
			* string		(* decoration *)
=TEX
}

The extended syntax allows arbitrary expressions of appropriate type in place of the schema reference usually required.

\subsubsection{Proof Support}

Theta terms may be though of as abbreviations for explicit binding constructions.
Rewriting with $z' _def$ will reveal the underlying binding construction:

=SML
rewrite_conv[z' _def] Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' = (age ¶ age', people ¶ people') : THM   
=TEX

Alternatively $z_ _conv$ may be used to secure the same effect:
 
=SML
z_ _conv Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' = (age ¶ age', people ¶ people') : THM   
=TEX

\subsection{Binding Component Selection}\label{BindCompSel}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* binding component selection Ò (a ¶ 1, b ¶ "4").b Æ *)
	
 |	€ZSelâs›		of TERM		(* expression *)
 			* string		(* component name *)
=TEX
}

The $âs$ here and in the following is entered into the source document as:
=GFTSHOW
		âs
=TEX

Which is typed ``Meta-tab s''.

\subsubsection{Proof Support}

Projection from binding displays is built in to proof context ``$z_language$''.

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM   
=TEX

Projection from theta terms is also built in to proof context ``$z_language$''.
=SML
rewrite_conv[] Ò ( File').ageÆ;
=GFT ProofPower output
val it = Ù ( File').age = age' : THM   
=TEX

\subsection{Horizontal Schemas}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* horizontal schema expression: Ò [x:˙ | x>0] Æ *)
	
 |	€Zâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
=TEX
}

\subsubsection{Proof Support}

The basic rule for horisontal schemas is the conversion $z_ç_horiz_schema_conv1$, which is built into the standard rewrites for proof context "z_language".

=SML
rewrite_conv[]Òz ç [x:˙;y:Ó]Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç [x : ˙; y : Ó]
	§ z.x ç ˙ ± z.y ç Ó : THM   
=TEX

Where a binding display or theta term is used the selections take place automatically.

=SML
rewrite_conv[]Ò(x ¶ a, y ¶ b) ç [x:˙;y:Ó]Æ;
=TEX

=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) ç [x : ˙; y : Ó]
	§ a ç ˙ ± b ç Ó : THM   
=TEX

\subsection{Sequence Displays}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* sequence display: Ò ß1,2,3¢Æ *)
	
 |	€Zß¢›		of TYPE		(* type of elements *)
			* TERM list		(* values of elements *)
=TEX
}

\subsubsection{Proof Support}

The basic rules for sequence displays are the conversion $z_ß¢_conv$ and $z_ç_ß¢_conv$, which differ only in that the latter will trigger only for membership assertions.
$z_ç_ß¢_conv$ is built into the standard rewrites for proof context $z_language$.

=SML
z_ß¢_conv Òßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù ßa, b, c¢ = {(1, a), (2, b), (3, c)} : THM   
=TEX

In the context of a membership assertion the proof context $z_language$ performs the same elimination:

=SML
once_rewrite_conv[]Òz ç ßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç ßa, b, c¢ §
	z ç {(1, a), (2, b), (3, c)} : THM   
=TEX

Which (without the ``once'') is further reduced as follows:

=SML
rewrite_conv[]Òz ç ßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç ßa, b, c¢ §
	z = (1, a) ≤ z = (2, b) ≤ z = (3, c) : THM   
=TEX

\section{Schema Expressions}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema negation: Ò(≥ File)∫UÆ *)
	
 |	€Z≥âs›		of TERM	(* schema expression *)
			
	(* schema conjunction: Ò(File ± File2)∫UÆ *)
	
 |	€Z±âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema disjunction: Ò(File ≤ File2)∫UÆ *)

 |	€Z≤âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema implication Ò(File ¥ File2)∫UÆ *)

 |	€Z¥âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema equivalence: Ò(File § File2)∫UÆ *)

 |	€Z§âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema existential: Ò(∂ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
	(* schema unique existential: Ò(∂â1 File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂â1âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
	(* schema universal: Ò(µ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Zµâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)

	(* decoration: Ò File ''Æ *)
	
 |	€ZDecorâs›	of TERM		(* schema expression *)
 			* string		(* decoration *)
 		
	(* pre-condition: Ò pre FileOpÆ *)
	
 |	€ZPreâs›		of TERM		(* schema expression *)

 	(* schema hiding: Ò FileOp \âs (age, i?)Æ  *)
 	
 |	€ZHideâs›	of TERM		(* schema expression *)
 			* string list		(* component names *)
 		
	(* schema renaming: ÒFile [aged/age, input/i?]Æ *)
	
 |	€ZRenameâs›	of TERM		(* schema expression *)
 			* (string * string) list	(* rename list *)
 		
	(* schema projection: ÒFileOp ˘âs FileÆ*)
	
 |	€Z˘âs›		of TERM * TERM	(* schema expressions *)

	(* schema composition: ÒÑFile ªâs ÑFileÆ *)
	
 |	€Zªâs›	of TERM * TERM	(* schema expressions *)
 		
	(* delta operation: ÒÑFileÆ *)
	
 |	€ZÑâs›		of TERM		(* schema expression *)
 		
	(* ò operation: ÒòFileÆ *)
	
 |	€Zòâs›		of TERM		(* schema expression *)
;
=TEX
}


Note here that though the logical operators have been overloaded, at present the system does not support the overloading of other schema operators which clash with names in the Z ToolKit.
For these operators ($ªâs, ˘âs, \âs$), the name subscripted with s has been used for the schema operator.

\subsection{Schema Negation}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema negation Ò(≥ File)∫UÆ *)
	
 | 	€Z≥âs›		of TERM	(* schema expression *)
=TEX
}

A negation occurring at the outermost level in a term quotation will be interpreted as a logical negation rather than a schema negation, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema negation of a schema iff it is not an element of the schema.

This rule is captured by the conversion $z_ç_≥âs_conv$, which is built into the standard rewrites for proof context ``z_language''.

=SML
rewrite_conv[]Òz ç (≥ File)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (≥ File) § ≥ z ç File : THM   
=TEX

\subsection{Schema Conjunction}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema conjunction: Ò(File ± File2)∫UÆ *)
	
 |	€Z±âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

A conjunction occurring at the outermost level in a term quotation will be interpreted as a logical conjunction rather than a schema conjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema conjunction of two schemas iff both the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z_ç_±âs_conv$, which is built into the standard rewrites for proof context ``z_language''.

=IGN
z_ç_±âs_conv Òz ç (File ± File2)Æ;
=SML
rewrite_conv[] Òz ç (File ± File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ± File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ± (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\subsection{Schema Disjunction}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema disjunction: Ò(File ≤ File2)∫UÆ *)
	
 |	€Z≤âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

A disjunction occurring at the outermost level in a term quotation will be interpreted as a logical disjunction rather than a schema disjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema disjunction of two schemas iff either of the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z_ç_≤âs_conv$, which is built into the standard rewrites for proof context ``z_language''.

=IGN
z_ç_≤âs_conv Òz ç (File ≤ File2)Æ;
=SML
rewrite_conv[] Òz ç (File ≤ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ≤ File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ≤ (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\subsection{Schema Implication}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema implication Ò(File ¥ File2)∫UÆ *)

 |	€Z¥âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

An implication occurring at the outermost level in a term quotation will be interpreted as a logical implication rather than a schema implication, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema implication of two schemas iff whenever the projection of the binding to the signature of the first operand is an element of the corresponding operand schemas, the projections of the binding to the signature of the second operand is also an element of the second operand schema.

This rule is captured by the conversion $z_ç_¥âs_conv$, which is built into the standard rewrites for proof context "z_language".

=IGN
z_ç_¥âs_conv Òz ç (File ¥ File2)Æ;
=SML
rewrite_conv[] Òz ç (File ¥ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ¥ File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ¥ (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX


\subsection{Schema Equivalence}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema equivalence: Ò(File § File2)∫UÆ *)

 |	€Z§âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

An equivalence occurring at the outermost level in a term quotation will be interpreted as a logical equivalence rather than a schema equivalence, unless a cast is applied.


\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema equivalence of two schemas iff the projection of the binding to the signature of the first operand is an element of the corresponding operand schema iff the projection of the binding to the signature of the second operand is an element of the second operand schema.

This rule is captured by the conversion $z_ç_§âs_conv$, which is built into the standard rewrites for proof context "z_language".

=SML
rewrite_conv[]Òz ç (File § File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File § File2)
    § (age ¶ z.age, people ¶ z.people) ç File
    § (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX


\subsection{Schema Existential}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema existential: Ò(∂ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

An existential occurring at the outermost level in a term quotation will be interpreted as a logical existential rather than a schema existential, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema existentials is the conversion $z_ç_∂âs_conv$, which is built into the standard rewrites for proof context "z_language".

=SML
rewrite_conv[]Òz ç (∂ File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (∂ File3 | people = {} ∑ File2)
    § (∂ x1 : U
      ∑ ((people ¶ x1.people) ç File3
        ± x1.people = {})
        ± (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Schema Unique Existence}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema unique existential: Ò(∂â1 File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂â1âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

A unique existential occurring at the outermost level in a term quotation will be interpreted as a logical existential rather than a schema existential, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema existentials is the conversion $z_ç_∂â1âs_conv$, which is built into the standard rewrites for proof context "z_language".

=SML
rewrite_conv[]Òz ç (∂â1 File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (∂â1 File3 | people = {} ∑ File2)
    § (∂â1 x1 : U
      ∑ ((people ¶ x1.people) ç File3
        ± x1.people = {})
        ± (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Schema Universal}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema universal: Ò(µ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Zµâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

A universal occurring at the outermost level in a term quotation will be interpreted as a logical universal rather than a schema universal, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema universals is the conversion $z_ç_µâs_conv$, which is built into the standard rewrites for proof context "z_language".

=SML
rewrite_conv[]Òz ç (µ File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (µ File3 | people = {} ∑ File2)
    § (µ x1 : U
      ∑ (people ¶ x1.people) ç File3 ± x1.people = {}
        ¥ (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Decoration}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* decoration: Ò File ''Æ *)
	
 |	€ZDecorâs›	of TERM		(* schema expression *)
 			* string		(* decoration *)
=TEX
}
\subsubsection{Proof Support}

The operation of decoration is extensionally characterised by $z_ç_decâs_conv$ which is built into the proof context $z_language$.
=SML
rewrite_conv[]Òz ç File ''Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File'') § (age ¶ z.age'', people ¶ z.people'') ç File : THM
=TEX

\subsection{Pre-Condition}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* pre-condition: Ò pre FileOpÆ *)
	
 |	€ZPreâs›		of TERM		(* schema expression *)
=TEX
}
\subsubsection{Proof Support}

The operation of decoration is extensionally characterised by $z_ç_preâs_conv$ which is built into the proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (pre FileOp)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (pre FileOp) §
 z ç	[age : U; i? : U; people : U
	| ∂ age' : U; people' : U ∑ FileOp] : THM
=TEX

Normally the membership of the horizontal schema thus introduced would be immediately eliminated.
Where a binding display or theta term is used selections will be eliminated.

=SML
rewrite_conv[]Ò(age ¶ age, i? ¶ i?, people ¶ people) ç (pre FileOp)Æ;
=TEX

=GFT ProofPower output
val it = Ù (age ¶ age, i? ¶ i?, people ¶ people) ç (pre FileOp)
    § (∂ age' : U; people' : U ∑ FileOp) : THM
=TEX

\subsection{Schema Hiding}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
 	(* schema hiding: Ò FileOp \âs (age, i?)Æ  *)
 	
 |	€ZHideâs›	of TERM		(* schema expression *)
 			* string list		(* component names *)
=TEX
}
\subsubsection{Proof Support}

This is characterised by $z_ç_hideâs_conv$ which is built into the proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File \âs (age)) § z ç [people : U | ∂ age : U ∑ File] : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Ò(people ¶ people) ç (File \âs (age))Æ;
=TEX

=GFT ProofPower output
val it = Ù (people ¶ people) ç (File \âs (age)) § (∂ age : U ∑ File) : THM   
=TEX

\subsection{Schema Renaming}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema renaming: ÒFile [aged/age, input/i?]Æ *)
	
 |	€ZRenameâs›	of TERM		(* schema expression *)
 			* (string * string) list	(* rename list *)
=TEX
}

\subsubsection{Proof Support}

Schema renaming is extensionally characterised by $z_ç_renameâs_conv$ which is built into the proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç File[aged/age]Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File [aged/age]) §
	(age ¶ z.aged, people ¶ z.people) ç File : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Ò(aged ¶ age, people ¶ people) ç File[aged/age]Æ;
=TEX

=GFT ProofPower output
val it = Ù (aged ¶ age, people ¶ people) ç (File [aged/age]) § File : THM   
=TEX

\subsection{Schema Projection}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema projection: ÒFileOp ˘âs FileÆ*)
	
 |	€Z˘âs›		of TERM * TERM	(* schema expressions *)
=TEX
}
\subsubsection{Proof Support}

Schema projection is extensionally characterised by $z_ç_˘âs_conv$, which is built into proof context $z_language$.
=SML
once_rewrite_conv[]Òz ç (FileOp ˘âs File)Æ; 
=TEX

=GFT ProofPower output
val it = Ù z ç (FileOp ˘âs File)
    § z ç ((FileOp ± File) \âs (age', i?, people')) : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Ò(age ¶ age, people ¶ people) ç (FileOp ˘âs File)Æ;
=TEX

=GFT ProofPower output
val it = Ù (age ¶ age, people ¶ people) ç (FileOp ˘âs File)
    § (∂ age' : U; i? : U; people' : U ∑ FileOp ± File) : THM
=TEX

\subsection{Schema Composition}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema composition: ÒFileOp ªâs FileOpÆ *)
	
 |	€Zªâs›	of TERM * TERM	(* schema expressions *)
=TEX
}
\subsubsection{Proof Support}
Schema projection is extensionally characterised by $z_ç_ªâs_conv$, which is built into proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § z
      ç [age : U; i? : U; people : U; age' : U; people' : U
        | ∂ x1 : U; x2 : U
          ∑ (age ¶ age, age' ¶ x1, i? ¶ i?, people ¶ people, people' ¶ x2)
              ç FileOp
            ± (age ¶ x1, age' ¶ age', i? ¶ i?, people ¶ x2,
                  people' ¶ people')
              ç FileOp] : THM
=TEX
Normally further membership eliminations, and possibly selection eliminations, will take place:
=SML
rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ;
=TEX
=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § (∂ x1 : U; x2 : U
      ∑ (age ¶ z.age, age' ¶ x1, i? ¶ z.i?, people ¶ z.people, people' ¶ x2)
          ç FileOp
        ± (age ¶ x1, age' ¶ z.age', i? ¶ z.i?, people ¶ x2,
              people' ¶ z.people')
          ç FileOp) : THM
=TEX

\subsection{$\Delta$}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* delta operation: ÒÑFileÆ *)
	
 |	€ZÑâs›		of TERM		(* schema expression *)
=TEX
}

Delta is currently supplied in {\ProductZ} as a schema operator rather than a convention.

\subsubsection{Proof Support}
Delta is extensionally characterised by $z_ç_Ñâs_conv$, which is built into proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (ÑFile)Æ; 
=TEX

=GFT ProofPower output
val it = Ù z ç (Ñ File) § z ç [File; File'] : THM   
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Òz ç (ÑFile)Æ; 
=TEX
=GFT ProofPower output
val it = Ù z ç (Ñ File)
    § (age ¶ z.age, people ¶ z.people) ç File
      ± (age ¶ z.age', people ¶ z.people') ç File : THM
=TEX

\subsection{$\Xi$}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* ò operation: ÒòFileÆ *)
	
 |	€Zòâs›		of TERM		(* schema expression *)
=TEX
}

Rather than a convention, {\ProductZ} currently provides an operator.

\subsubsection{Proof Support}

This operation is extensionally characterised by $z_ç_òâs_conv$, which is built into proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (òFile)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (ò File) § z ç [File; File' |  File =  File'] : THM   
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Òz ç (òFile)Æ; 
=TEX
=GFT ProofPower output
val it = Ù z ç (ò File)
    § ((age ¶ z.age, people ¶ z.people) ç File
      ± (age ¶ z.age', people ¶ z.people') ç File)
      ± z.age = z.age'
      ± z.people = z.people' : THM
=TEX

\ignore{
Here we have hit one of the points at which {\Product} slips out of Z.
This arises from substitution into the theta expressions.
The correct thing to do at this point is to eliminate the theta terms in favour of explicit binding constructions, which is achieved by adding $z' _def$ into the rewrites as follows:
=SML
rewrite_conv[z' _def]Òz ç (òFile)Æ; 
=TEX
=GFT ProofPower output
val it = Ù z ç (ò File)
    § ((age ¶ z.age, people ¶ z.people) ç File
      ± (age ¶ z.age', people ¶ z.people') ç File)
      ± z.age = z.age'
      ± z.people = z.people' : THM
=TEX
}%\ignore

}%\ftmargins
