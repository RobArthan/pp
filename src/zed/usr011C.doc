=IGN
********************************************************************************
usr011C.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% usr011C.doc   %Z% $Date: 2004/01/19 12:44:00 $ $Revision: 1.14 $ $RCSfile: usr011C.doc,v $
% this should form a Chapter of the document
% Z Expressions
=TEX
{\ftlmargin=0.5in
\section{Expressions}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* function application:  Ò f xÆ  *)
	
 |	€ZApp› 		of TERM * TERM	(* expressions *)
 		
	(* lambda expression: Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
	
 |	€ZÃ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 	
	(* definite description: Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
	
 |	€ZÕ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
			* TERM		(* expression *)
 		
	(* power set construction: Ò  ˙Æ *)
	
 |	€Z›		of TERM		(* expression *)

	(* set display: Ò {1,2,3,4} Æ *)
	
 |	€ZSetd›		of TYPE	(* HOL type of elements *)
 			* TERM list	(* expressions *)
 		
	(* set abstraction: Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
	
 |	€ZSeta› 		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 		
	(* tuple: Ò (1,2,3,4) Æ *)
	
 |	€ZTuple› 	of TERM list		(* expressions *)
 		
	(* tuple element selection: Ò (x,y).2Æ *)
	
 |	€ZSelât› 		of TERM		(* expression *)
 			* int			(* element number *)

 	(* cartesian product: Ò (˙ ∏ Ó) Æ *)
 	
 |	€Z∏›		of TERM list		(* expressions *)
 		
	(* binding display: Ò (people ¶ {}, age ¶ {}) Æ *)
	
 |	€ZBinding›	of (	string		(* component name *)
 			* TERM		(* component value *)
 			) list
 		
	(* theta term: Ò  File' Æ *)
	
 |	€Z ›		of TERM		(* schema expression *)
			* string		(* decoration *)
 		
	(* binding component selection: Ò (a ¶ 1, b ¶ "4").b Æ *)
	
 |	€ZSelâs›		of TERM		(* expression *)
 			* string		(* component name *)

	(* horizontal schema expression: Ò [x:˙ | x>0] Æ *)
	
 |	€Zâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
		
	(* sequence display: Ò ß1,2,3¢Æ *)
	
 |	€Zß¢›		of TYPE		(* type of elements *)
			* TERM list		(* values of elements *)
=TEX
}

The main new feature here is the binding display, which is important in expressing convenient proof rules.

Though absent from the first edition of the ZRM \cite{spivey89}, binding displays have been introduced into the second edition \cite{spivey92} for exposition, but not as part of Z, and have now appeared in the draft standard, with two distinct concrete syntaxes neither of which corresponds to our proposal.

Bag displays and relational image, which were once treated as part of the language, can now be introduced in the library using appropriate fixity declarations.


\subsection{Function Application}\label{FunctionApplication}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* function application:  Ò f xÆ  *)
	
 |	€ZApp› 		of TERM * TERM		(* expressions *)
=TEX
}

Function application may also use infix, postfix or ``fancyfix'' notation if an appropriate fixity paragraph has been entered.
In such cases the arguments are effectively the name of the global variable and the second is the term consisting of a tuple of arguments.

=SML
dest_z_term Òf aÆ;
=GFT ProofPower output
val it = ZApp (ÒfÆ, ÒaÆ) : Z_TERM
=TEX

=SML
dest_z_term Òa ¿ bÆ;
=GFT ProofPower output
val it = ZApp (Ò(_ ¿ _)Æ, Ò(a, b)Æ) : Z_TERM
=TEX

In the following case the fixity declaration for bag brackets required a single argument which is a sequence (with sequence brackets elided in the concrete syntax of the bag display).

=SML
dest_z_term Ò˚1,2,3,2,1˝Æ;
=GFT ProofPower output
val it = ZApp (Ò(˚ ... ˝)Æ, Òß1, 2, 3, 2, 1¢Æ) : Z_TERM
=TEX

\subsubsection{Proof Support}

Applications of lambda abstractions can be eliminated by (conditional) ¬-conversion.

=SML
z_¬_conv Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower output
val it = P a, a ç X Ù (Ã x : X | P x ∑ f x) a = f a : THM
=TEX

Applications may also be eliminated in favour of definite descriptions (though this is not particularly helpful).

=SML
z_app_conv Ò f aÆ;
=GFT ProofPower output
val it = Ù f a = Õ f_a : É | (a, f_a) ç f ∑ f_a : THM
=TEX

More commonly function applications are eliminated by rewriting with the definition of the relevant function.

Reasoning at a low level, $z_app_eq_tac$ may be used to reduce an equation involving an application to sufficient conditions for its truth, in terms of the membership of the function, e.g.:
=SML
set_goal([],Ò f a = vÆ);
a z_app_eq_tac;
=GFT ProofPower output
...
(* ?Ù *)  Ò(µ f_a : É | (a, f_a) ç f ∑ f_a = v) ± (a, v) ç fÆ
...
=TEX

The first conjunct of this result is needed to ensure that $f$ is functional at $a$ (i.e. maps $a$ to only one value).
In the case that $f$ is known to be a function, the theorem $z_fun_app_clauses$ may be used with forward chaining, avoiding the need to prove that $f$ is functional at $a$.
=GFT
val z_fun_app_clauses =
  Ù µ f : É; x : É; y : É; X : É; Y : É
    ∑ (f ç X ﬂ Y
          ≤ f ç X ˛ Y
          ≤ f ç X œ Y
          ≤ f ç X ≠ Y
          ≤ f ç X ‡ Y
          ≤ f ç X Ô Y
          ≤ f ç X è Y)
        ± (x, y) ç f
      ¥ f x = y : THM
=TEX
In this case the result $(a,v)\ ç\ f$ would have to be proven and added to the assumptions before undertaking the forward chaining, e.g.:
=SML
drop_main_goal();
set_goal([], Òf ç Ó Ô ˙ ¥ (4, ~45) ç f ¥ f 4 = ~45Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  2 *)  Òf ç Ó Ô ˙Æ
(*  1 *)  Ò(4, ~ 45) ç fÆ

(* ?Ù *)  Òf 4 = ~ 45Æ

=SML
a (all_fc_tac [z_fun_app_clauses]);
pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

A common problem is to have to establish that the value of some expression formed by application falls within some particular set.
This is often needed to establish the conditions necessary for use of a rewriting equation on the expression.

In these circumstances the theorem $z_fun_ç_clauses$ may be used:
=GFT
val z_fun_ç_clauses = Ù µ f : É; x : É; X : É; Y : É
 ∑ ((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y) ± x ç X
 	¥ f x ç Y)
 ± ((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y) ± x ç dom f
 	¥ f x ç Y) : THM
=TEX
The claim that a global variable is a member of a function space will often be obtained from the specification of the constant (as part of the predicate implicit in the declaration part of the specification).
Where the function is an expression the result is likely to have been established by forward inference using similar methods.
=SML
set_goal([], Ò[X](µ b: bag X∑ count[X] b ç X ≠ Ó)Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  1 *)  Òb ç bag XÆ

(* ?Ù *)  Òcount[X] b ç X ≠ ÓÆ
...
=TEX
We need the fact about $count$ which is found in its defining declaration instantiated to $X$ to make the required inference.
This is added to the assumptions as follows:
=SML
a (strip_asm_tac (z_gen_pred_elim [ÒXÆ] (z_get_spec ÒcountÆ)));
=GFT ProofPower output
...
(*  3 *)  Òb ç bag XÆ
(*  2 *)  Òcount[X] ç bag X è X ≠ ÓÆ
(*  1 *)  Òµ x : X; B : bag X ∑ count[X] B = (Ã x : X ∑ 0) ´ BÆ

(* ?Ù *)  Òcount[X] b ç X ≠ ÓÆ
...
=TEX
Assumption 1 is spurious but harmless.
Next we forward chain using the theorem $z_fun_ç_clauses$, which suffices to discharge the goal.
=SML
a (all_fc_tac [z_fun_ç_clauses]);
save_pop_thm "bag_lemma1";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

Care is sometimes needed when proving membership lemmas which require intermediate results which involve constructs such as cartesian products, since most proof contexts will eliminate these.
=SML
set_goal([],Ò[X](µ b,c: bag X ∑ ((_Ç_)[X](b, c)) ç bag X)Æ);
a (REPEAT strip_tac);
a (strip_asm_tac (z_gen_pred_elim [ÒXÆ] (z_get_spec Ò(_Ç_)Æ)));
=GFT ProofPower output
...
(*  4 *)  Òb ç bag XÆ
(*  3 *)  Òc ç bag XÆ
(*  2 *)  Ò(_ Ç _)[X] ç (bag X) ∏ (bag X) ≠ bag XÆ
(*  1 *)  Òµ B, C : bag X; x : X
             ∑ count ((_ Ç _)[X] (B, C)) x = count B x + count C xÆ

(* ?Ù *)  Ò(_ Ç _)[X] (b, c) ç bag XÆ
...
=TEX
Here the assumption
=INLINEFT
(b,c) ç (bag X) ∏ (bag X)
=TEX
\ is needed to enable the required forward chaining, but the obvious methods of obtaining this, e.g.:
=SML
a (lemma_tac Ò(b,c) ç (bag X) ∏ (bag X)Æ THEN1 contr_tac);
=TEX
have no effect since the lemma is broken up as it is added to the assumptions.
This break-up can be inhibited as follows:
=SML
a (LEMMA_T Ò(b,c) ç (bag X) ∏ (bag X)Æ asm_tac THEN1 contr_tac);
=GFT ProofPower output
...
(*  1 *)  Ò(b, c) ç (bag X) ∏ (bag X)Æ

(* ?Ù *)  Ò(_ Ç _)[X] (b, c) ç bag XÆ
...
=TEX
where $asm_tac$ is used instead of the default $strip_asm_tac$ for processing the new assumption.
Now the forward chaining will work.
=SML
a (all_fc_tac [z_fun_ç_clauses]);
save_pop_thm "bag_lemma2";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

\subsection{Lambda Abstraction}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* lambda expression Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
	
 |	€ZÃ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
=TEX
}
\subsubsection{Proof Support}

$Ã$-abstractions when applied to arguments may be eliminated by $z_¬_conv$ (see \ref{FunctionApplication}).

Assertions about membership of $Ã$-abstractions may be directly eliminated.
=SML
rewrite_conv [] Òz ç (Ã x:X | P x ∑ f x)Æ;
=GFT ProofPower output
val it = Ù z ç Ã x : X | P x ∑ f x § z.1 ç X ± P z.1 ± f z.1 = z.2 : THM
=TEX

Since $Ã$-abstractions denote sets they may also be eliminated in favour of set comprehensions using $z_Ã_conv$.

=SML
z_Ã_conv ÒÃ x:X | P x ∑ f xÆ;
=GFT ProofPower output
val it = Ù (Ã x : X | P x ∑ f x) = {x : X | P x ∑ (x, f x)} : THM
=TEX

\subsection{Definite Description}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* definite description Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
	
 |	€ZÕ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
			* TERM		(* expression *)
=TEX
}
\subsubsection{Proof Support}

Definite descriptions may be eliminated using $z_Õ_rule$.

=SML
z_Õ_rule Ò Õ x:X | P ∑ yÆ;
=GFT ProofPower output
val it = Ù µ x' : É
    ∑ (µ x : X | P ∑ y = x') ± (∂ x : X | P ∑ y = x')
      ¥ (Õ x : X | P ∑ y) = x' : THM
=TEX
\subsection{Let Expression}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
		(* let expression Ò let x ¶ 9 ∑ (x, x+x) Æ *)
 | €ZLet›
 		of (string * TERM) list	(* local definitions *)
 		* TERM	(* expression *)
=TEX
}
\subsubsection{Proof Support}

Let expressions may be expanded using $z_let_conv$.

=SML
z_let_conv Ò let x ¶ 9 ∑ (x, x + x) Æ;
=GFT ProofPower output
val it = Ù
	(let x ¶ 9 ∑ (x, x + x)) = (9, 9 + 9) : THM
=TEX
=TEX

\subsection{The Power Set}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* power set construction, Ò  ˙Æ *)
	
 |	€Z›		of TERM		(* expression *)
=TEX
}
\subsubsection{Proof Support}

Membership statements concerning power sets may be eliminated using $z_ç__conv$, or by rewriting in proof context $z_language_ext$.

=SML
PC_C1 "z_language_ext" rewrite_conv[] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § (µ x1 : É ∑ x1 ç z ¥ x1 ç y) : THM
=TEX

\subsection{Set Displays}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* set display, Ò {1,2,3,4} Æ *)
	
 |	€ZSetd›		of TYPE	(* HOL type of elements *)
 			* TERM list	(* expressions *)
=TEX
}
\subsubsection{Proof Support}

Membership statements sets displays may be eliminated using $z_ç_setd_conv$, or by rewriting in proof context $z_language$.

=SML
rewrite_conv[] Ò z ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù z ç {1, 2, 3, 4, 5} §
	z = 1 ≤ z = 2 ≤ z = 3 ≤ z = 4 ≤ z = 5 : THM
=TEX

\subsection{Set Abstractions}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM		
	(* set abstraction, Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
	
 |	€ZSeta› 		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 		
=TEX
}
\subsubsection{Proof Support}

Statements about membership of set abstractions may be eliminated using $z_ç_seta_conv$, or by rewriting in proof context $z_language$.

A simple abstraction results in straightforward substitution into the body of the abstraction:

=SML
rewrite_conv[] Ò 9 ç {x:Ó | x < 12}Æ;
=GFT ProofPower output
val it = Ù 9 ç {x : Ó | x < 12} § 9 ç Ó ± 9 < 12 : THM
=TEX

Where the signature is more complex tuple projections are introduced:

=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y}Æ;
=GFT ProofPower output
val it = Ù z ç {x, y : Ó | x < y}
§ (z.1 ç Ó ± z.2 ç Ó) ± z ç (_ < _) : THM
=TEX

Where membership is asserted of a tuple the projections are undertaken automatically.

=SML
rewrite_conv[]Ò (v,w) ç {x, y:Ó | x < y}Æ;
=GFT ProofPower output
val it = Ù (v, w) ç {x, y : Ó | x < y}
§ (v ç Ó ± w ç Ó) ± v < w : THM
=TEX

In the general case introduction of an existential is necessary, though this is avoided whenever possible.

=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y ∑ x * y - x}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y ∑ x * y - x}
§ (∂ x, y : Ó | x < y ∑ x * y - x = z) :THM
=TEX

\subsection{Tuple Displays}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* tuple, Ò (1,2,3,4) Æ *)
	
 |	€ZTuple› 	of TERM list		(* expressions *)
=TEX
}

Note that $n-$tuples for $n > 2$ are not iterated pairs, i.e. $Ò(1,(2,3))Æ$ is not the same as $Ò(1,2,3)Æ$ (and doesn't have the same type either).

\subsubsection{Proof Support}

Two tuple displays are equal iff each of their respective components are equal.
This fact is built into the proof context $z_language$ both for rewriting and stripping assumptions or conclusions.

=SML
rewrite_conv[] Ò(x,y) = (a,b)Æ;
=GFT ProofPower output
val it = Ù (x, y) = (a, b) § x = a ± y = b : THM
=TEX

\subsection{Tuple Element Selection}\label{TupleSelection}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* tuple element selection, Ò (x,y).2Æ *)
	
 |	€ZSelât› 		of TERM		(* expression *)
 			* int			(* element number *)
=TEX
}
\subsubsection{Proof Support}

Conversions to effect projection from tuple displays are also built into proof context $z_language$.
=SML
rewrite_conv[] Ò (x,y).1Æ;
=GFT ProofPower output
val it = Ù (x, y).1 = x : THM
=TEX

\subsection{Cartesian Products}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
 	(* cartesian product, Ò (˙ ∏ Ó) Æ *)
 	
 |	€Z∏›		of TERM list		(* expressions *)
=TEX
}

Note that the n-ary cartesian products for $n>2$ are not formed by iteration of the binary cartesian product.

\subsubsection{Proof Support}

The membership conversion for n-ary cartesian products is $z_ç_∏_conv$ which is built into proof context $z_language$.

=SML
rewrite_conv[] Ò (a, b, c) ç (x ∏ y ∏ z)Æ;
=GFT ProofPower output
val it = Ù (a, b, c) ç x ∏ y ∏ z
	§ a ç x ± b ç y ± c ç z : THM
=TEX

Cartesian products may also be converted into set abstractions using $z_∏_conv$.
=SML
z_∏_conv	Ò (x ∏ y ∏ z)Æ;
=GFT ProofPower output
val it = Ù x ∏ y ∏ z = {tâ1 : x; tâ2 : y; tâ3 : z} : THM
=TEX

Extensional proof contexts incorporate an extensional understanding of equality of cartesian products:

=SML
PC_C1 "z_language_ext"
rewrite_conv[] Ò (x ∏ y ∏ z) = (x' ∏ y' ∏ z')Æ;
=GFT ProofPower output
val it = Ù x ∏ y ∏ z = x' ∏ y' ∏ z'
    § (µ x1 : É; x2 : É; x3 : É
      ∑ x1 ç x ± x2 ç y ± x3 ç z
      § x1 ç x' ± x2 ç y' ± x3 ç z') : THM
=TEX

Such an equation can also be demonstrated by rewriting if each of the respective components can be proven equal, however this is not a necessary condition for the equality (since any single empty component set will render the cartesian product empty).

\subsection{Binding Displays}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* binding Ò (people ¶ {}, age ¶ {}) Æ *)
	
 |	€ZBinding›	of (	string		(* component name *)
 			* TERM		(* component value *)
 			) list
=TEX
}

\subsubsection{Proof Support}

Two binding displays are equal iff each of their respective components are equal.
This fact is built into the proof context $z_language$ for rewriting and for stripping assumptions and conclusions.

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b) = (y ¶ d, x ¶ c)Æ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) = (x ¶ c, y ¶ d) § a = c ± b = d : THM
=TEX


\subsection{Theta Terms}
\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* theta term Ò  File' Æ *)
	
 |	€Z ›		of TERM		(* schema expression *)
			* string		(* decoration *)
=TEX
}

The extended syntax allows arbitrary expressions of appropriate type in place of the schema reference usually required.

\subsubsection{Proof Support}

Theta terms may be though of as abbreviations for explicit binding constructions.
Rewriting with $z' _def$ will reveal the underlying binding construction:

=SML
rewrite_conv[z' _def] Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' = (age ¶ age', people ¶ people') : THM
=TEX

Alternatively $z_ _conv$ may be used to secure the same effect:

=SML
z_ _conv Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' = (age ¶ age', people ¶ people') : THM
=TEX

In most respects $ $-terms are treated in the same way as binding displays.

\subsection{Binding Component Selection}\label{BindCompSel}

\subsubsection{Syntax}
{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* binding component selection Ò (a ¶ 1, b ¶ "4").b Æ *)
	
 |	€ZSelâs›		of TERM		(* expression *)
 			* string		(* component name *)
=TEX
}

The $âs$ here and in the following is entered into the source document as:
=GFTSHOW
		âs
=TEX
{\ShowAllImages
The `subscript-shift character',
=INLINEFT
â
=TEX
, here may be obtained from the palette of mathematical symbols or
typed directly (as Meta+tab under SunView, or as Meta+d when using {\tt xpp}).}

\subsubsection{Proof Support}

Projection from binding displays is built in to proof context $z_language$.

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM
=TEX

Projection from theta terms is also built in to proof context $z_language$.
=SML
rewrite_conv[] Ò ( File').ageÆ;
=GFT ProofPower output
val it = Ù ( File').age = age' : THM
=TEX

\subsection{Horizontal Schemas}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* horizontal schema expression: Ò [x:˙ | x>0] Æ *)
	
 |	€Zâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
=TEX
}

\subsubsection{Proof Support}

The basic rule for horizontal schemas is the conversion $z_ç_horiz_schema_conv1$, which is built into the standard rewrites for proof context {\it z_language}.

=SML
rewrite_conv[]Òz ç [x:˙;y:Ó]Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç [x : ˙; y : Ó]
	§ z.x ç ˙ ± z.y ç Ó : THM
=TEX

Where a binding display or theta term is used the selections take place automatically.

=SML
rewrite_conv[]Ò(x ¶ a, y ¶ b) ç [x:˙;y:Ó]Æ;
=TEX

=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) ç [x : ˙; y : Ó]
	§ a ç ˙ ± b ç Ó : THM
=TEX

\subsection{Sequence Displays}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* sequence display: Ò ß1,2,3¢Æ *)
	
 |	€Zß¢›		of TYPE		(* type of elements *)
			* TERM list		(* values of elements *)
=TEX
}

\subsubsection{Proof Support}

The basic rules for sequence displays are the conversion $z_ß¢_conv$ and $z_ç_ß¢_conv$, which differ only in that the latter will trigger only for membership assertions.
$z_ç_ß¢_conv$ is built into the standard rewrites for proof context $z_language$.

=SML
z_ß¢_conv Òßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù ßa, b, c¢ = {(1, a), (2, b), (3, c)} : THM
=TEX

In the context of a membership assertion, rewriting in the proof context $z_language$ performs the same elimination:

=SML
once_rewrite_conv[]Òz ç ßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç ßa, b, c¢ §
	z ç {(1, a), (2, b), (3, c)} : THM
=TEX

Which (without the ``once'') is further reduced as follows:

=SML
rewrite_conv[]Òz ç ßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç ßa, b, c¢ §
	z = (1, a) ≤ z = (2, b) ≤ z = (3, c) : THM
=TEX

\section{Schema Expressions}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema negation: Ò(≥ File)∫ÉÆ *)
	
 |	€Z≥âs›		of TERM	(* schema expression *)
			
	(* schema conjunction: Ò(File ± File2)∫ÉÆ *)
	
 |	€Z±âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema disjunction: Ò(File ≤ File2)∫ÉÆ *)

 |	€Z≤âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema implication Ò(File ¥ File2)∫ÉÆ *)

 |	€Z¥âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema equivalence: Ò(File § File2)∫ÉÆ *)

 |	€Z§âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema existential: Ò(∂ File3 | people = {} ∑ File2)∫ÉÆ *)
	
 |	€Z∂âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
	(* schema unique existential: Ò(∂â1 File3 | people = {} ∑ File2)∫ÉÆ *)
	
 |	€Z∂â1âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
	(* schema universal: Ò(µ File3 | people = {} ∑ File2)∫ÉÆ *)
	
 |	€Zµâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)

	(* decoration: Ò File ''Æ *)
	
 |	€ZDecorâs›	of TERM		(* schema expression *)
 			* string		(* decoration *)
 		
	(* pre-condition: Ò pre FileOpÆ *)
	
 |	€ZPreâs›		of TERM		(* schema expression *)

 	(* schema hiding: Ò FileOp \âs (age, i?)Æ  *)
 	
 |	€ZHideâs›	of TERM		(* schema expression *)
 			* string list		(* component names *)
 		
	(* schema renaming: ÒFile [aged/age, input/i?]Æ *)
	
 |	€ZRenameâs›	of TERM		(* schema expression *)
 			* (string * string) list	(* rename list *)
 		
	(* schema projection: ÒFileOp ˘âs FileÆ*)
	
 |	€Z˘âs›		of TERM * TERM	(* schema expressions *)

	(* schema composition: ÒÑFile ªâs ÑFileÆ *)
	
 |	€Zªâs›	of TERM * TERM	(* schema expressions *)
 		
	(* delta operation: ÒÑFileÆ *)
	
 |	€ZÑâs›		of TERM		(* schema expression *)
 		
	(* ò operation: ÒòFileÆ *)
	
 |	€Zòâs›		of TERM		(* schema expression *)
;
=TEX
}


Note here that though the logical operators have been overloaded, at present the system does not support the overloading of other schema operators which clash with names in the Z ToolKit.
For these operators
=INLINEFT
(ªâs, ˘âs, \âs)
=TEX
, the name subscripted with s has been used for the schema operator.

\subsection{Schema Negation}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema negation Ò(≥ File)∫ÉÆ *)
	
 | 	€Z≥âs›		of TERM	(* schema expression *)
=TEX
}

A negation occurring at the outermost level in a term quotation is interpreted as a logical negation rather than a schema negation, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema negation of a schema iff it is not an element of the schema.

This rule is captured by the conversion $z_ç_≥âs_conv$, which is built into the standard rewrites for proof context $z_language$.

=SML
rewrite_conv[]Òz ç (≥ File)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (≥ File) § ≥ z ç File : THM
=TEX

\subsection{Schema Conjunction}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema conjunction: Ò(File ± File2)∫ÉÆ *)
	
 |	€Z±âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

A conjunction occurring at the outermost level in a term quotation is interpreted as a logical conjunction rather than a schema conjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema conjunction of two schemas iff both the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z_ç_±âs_conv$, which is built into the standard rewrites for proof context $z_language$.

=IGN
z_ç_±âs_conv Òz ç (File ± File2)Æ;
=SML
rewrite_conv[] Òz ç (File ± File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ± File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ± (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\subsection{Schema Disjunction}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema disjunction: Ò(File ≤ File2)∫ÉÆ *)
	
 |	€Z≤âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

A disjunction occurring at the outermost level in a term quotation is interpreted as a logical disjunction rather than a schema disjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema disjunction of two schemas iff either of the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z_ç_≤âs_conv$, which is built into the standard rewrites for proof context $z_language$.

=IGN
z_ç_≤âs_conv Òz ç (File ≤ File2)Æ;
=SML
rewrite_conv[] Òz ç (File ≤ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ≤ File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ≤ (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\subsection{Schema Implication}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema implication Ò(File ¥ File2)∫ÉÆ *)

 |	€Z¥âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

An implication occurring at the outermost level in a term quotation is interpreted as a logical implication rather than a schema implication, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema implication of two schemas iff whenever the projection of the binding to the signature of the first operand is an element of the corresponding operand schemas, the projections of the binding to the signature of the second operand is also an element of the second operand schema.

This rule is captured by the conversion $z_ç_¥âs_conv$, which is built into the standard rewrites for proof context {\it z_language}.

=IGN
z_ç_¥âs_conv Òz ç (File ¥ File2)Æ;
=SML
rewrite_conv[] Òz ç (File ¥ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ¥ File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ¥ (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX


\subsection{Schema Equivalence}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema equivalence: Ò(File § File2)∫ÉÆ *)

 |	€Z§âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

An equivalence occurring at the outermost level in a term quotation is interpreted as a logical equivalence rather than a schema equivalence, unless a cast is applied.


\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema equivalence of two schemas iff the projection of the binding to the signature of the first operand is an element of the corresponding operand schema iff the projection of the binding to the signature of the second operand is an element of the second operand schema.

This rule is captured by the conversion $z_ç_§âs_conv$, which is built into the standard rewrites for proof context {\it z_language}.

=SML
rewrite_conv[]Òz ç (File § File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File § File2)
    § (age ¶ z.age, people ¶ z.people) ç File
    § (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX


\subsection{Schema Existential}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema existential: Ò(∂ File3 | people = {} ∑ File2)∫ÉÆ *)
	
 |	€Z∂âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

An existential occurring at the outermost level in a term quotation is interpreted as a logical existential rather than a schema existential, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema existentials is the conversion $z_ç_∂âs_conv$, which is built into the standard rewrites for proof context {\it z_language}.

=SML
rewrite_conv[]Òz ç (∂ File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (∂ File3 | people = {} ∑ File2)
    § (∂ x1 : É
      ∑ ((people ¶ x1.people) ç File3
        ± x1.people = {})
        ± (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Schema Unique Existence}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema unique existential: Ò(∂â1 File3 | people = {} ∑ File2)∫ÉÆ *)
	
 |	€Z∂â1âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

A unique existential occurring at the outermost level in a term quotation is interpreted as a logical existential rather than a schema existential, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema existentials is the conversion $z_ç_∂â1âs_conv$, which is built into the standard rewrites for proof context {\it z_language}.

=SML
rewrite_conv[]Òz ç (∂â1 File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (∂â1 File3 | people = {} ∑ File2)
    § (∂â1 x1 : É
      ∑ ((people ¶ x1.people) ç File3
        ± x1.people = {})
        ± (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Schema Universal}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema universal: Ò(µ File3 | people = {} ∑ File2)∫ÉÆ *)
	
 |	€Zµâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

A universal occurring at the outermost level in a term quotation is interpreted as a logical universal rather than a schema universal, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema universals is the conversion $z_ç_µâs_conv$, which is built into the standard rewrites for proof context {\it z_language}.

=SML
rewrite_conv[]Òz ç (µ File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (µ File3 | people = {} ∑ File2)
    § (µ x1 : É
      ∑ (people ¶ x1.people) ç File3 ± x1.people = {}
        ¥ (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Decoration}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* decoration: Ò File ''Æ *)
	
 |	€ZDecorâs›	of TERM		(* schema expression *)
 			* string		(* decoration *)
=TEX
}
\subsubsection{Proof Support}

The operation of decoration is extensionally characterised by $z_ç_decâs_conv$ which is built into the proof context $z_language$.
=SML
rewrite_conv[]Òz ç File ''Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File'') § (age ¶ z.age'', people ¶ z.people'') ç File : THM
=TEX

\subsection{Pre-Condition}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* pre-condition: Ò pre FileOpÆ *)
	
 |	€ZPreâs›		of TERM		(* schema expression *)
=TEX
}
\subsubsection{Proof Support}

The operation of forming a pre-condition is extensionally characterised by $z_ç_preâs_conv$ which is built into the proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (pre FileOp)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (pre FileOp) §
 z ç	[age : É; i? : É; people : É
	| ∂ age' : É; people' : É ∑ FileOp] : THM
=TEX

Normally the membership of the horizontal schema thus introduced would be immediately eliminated.
Where a binding display or theta term is used selections are eliminated.

=SML
rewrite_conv[]Ò(age ¶ age, i? ¶ i?, people ¶ people) ç (pre FileOp)Æ;
=TEX

=GFT ProofPower output
val it = Ù (age ¶ age, i? ¶ i?, people ¶ people) ç (pre FileOp)
    § (∂ age' : É; people' : É ∑ FileOp) : THM
=TEX

\subsection{Schema Hiding}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
 	(* schema hiding: Ò FileOp \âs (age, i?)Æ  *)
 	
 |	€ZHideâs›	of TERM		(* schema expression *)
 			* string list		(* component names *)
=TEX
}

This is entered into the source document as:
=GFTSHOW
Ò FileOp \âs (age, i?)Æ
=TEX

\subsubsection{Proof Support}

This is characterised by $z_ç_hideâs_conv$ which is built into the proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File \âs (age)) § z ç [people : É | ∂ age : É ∑ File] : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Ò(people ¶ people) ç (File \âs (age))Æ;
=TEX

=GFT ProofPower output
val it = Ù (people ¶ people) ç (File \âs (age)) § (∂ age : É ∑ File) : THM
=TEX

\subsection{Schema Renaming}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema renaming: ÒFile [aged/age, input/i?]Æ *)
	
 |	€ZRenameâs›	of TERM		(* schema expression *)
 			* (string * string) list	(* rename list *)
=TEX
}

\subsubsection{Proof Support}

Schema renaming is extensionally characterised by $z_ç_renameâs_conv$ which is built into the proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç File[aged/age]Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File [aged/age]) §
	(age ¶ z.aged, people ¶ z.people) ç File : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Ò(aged ¶ age, people ¶ people) ç File[aged/age]Æ;
=TEX

=GFT ProofPower output
val it = Ù (aged ¶ age, people ¶ people) ç (File [aged/age]) § File : THM
=TEX

\subsection{Schema Projection}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema projection: ÒFileOp ˘âs FileÆ*)
	
 |	€Z˘âs›		of TERM * TERM	(* schema expressions *)
=TEX
}
\subsubsection{Proof Support}

Schema projection is extensionally characterised by $z_ç_˘âs_conv$, which is built into proof context $z_language$.
=SML
once_rewrite_conv[]Òz ç (FileOp ˘âs File)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (FileOp ˘âs File)
    § z ç ((FileOp ± File) \âs (age', i?, people')) : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Ò(age ¶ age, people ¶ people) ç (FileOp ˘âs File)Æ;
=TEX

=GFT ProofPower output
val it = Ù (age ¶ age, people ¶ people) ç (FileOp ˘âs File)
    § (∂ age' : É; i? : É; people' : É ∑ FileOp ± File) : THM
=TEX

\subsection{Schema Composition}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema composition: ÒFileOp ªâs FileOpÆ *)
	
 |	€Zªâs›	of TERM * TERM	(* schema expressions *)
=TEX
}
\subsubsection{Proof Support}
Schema projection is extensionally characterised by $z_ç_ªâs_conv$, which is built into proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § z
      ç [age : É; i? : É; people : É; age' : É; people' : É
        | ∂ x1 : É; x2 : É
          ∑ (age ¶ age, age' ¶ x1, i? ¶ i?, people ¶ people, people' ¶ x2)
              ç FileOp
            ± (age ¶ x1, age' ¶ age', i? ¶ i?, people ¶ x2,
                  people' ¶ people')
              ç FileOp] : THM
=TEX
Normally further membership eliminations, and possibly selection eliminations, will take place:
=SML
rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ;
=TEX
=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § (∂ x1 : É; x2 : É
      ∑ (age ¶ z.age, age' ¶ x1, i? ¶ z.i?, people ¶ z.people, people' ¶ x2)
          ç FileOp
        ± (age ¶ x1, age' ¶ z.age', i? ¶ z.i?, people ¶ x2,
              people' ¶ z.people')
          ç FileOp) : THM
=TEX

\subsection{$\Delta$}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* delta operation: ÒÑFileÆ *)
	
 |	€ZÑâs›		of TERM		(* schema expression *)
=TEX
}

Delta is currently supplied in {\ProductZ} as a schema operator rather than a convention.

\subsubsection{Proof Support}
Delta is extensionally characterised by $z_ç_Ñâs_conv$, which is built into proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (ÑFile)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (Ñ File) § z ç [File; File'] : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Òz ç (ÑFile)Æ;
=TEX
=GFT ProofPower output
val it = Ù z ç (Ñ File)
    § (age ¶ z.age, people ¶ z.people) ç File
      ± (age ¶ z.age', people ¶ z.people') ç File : THM
=TEX

\subsection{$\Xi$}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* ò operation: ÒòFileÆ *)
	
 |	€Zòâs›		of TERM		(* schema expression *)
=TEX
}

Rather than a convention, {\ProductZ} currently provides an operator.

\subsubsection{Proof Support}

This operation is extensionally characterised by $z_ç_òâs_conv$, which is built into proof context $z_language$.

=SML
once_rewrite_conv[]Òz ç (òFile)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (ò File) § z ç [File; File' |  File =  File'] : THM
=TEX

Normally further membership eliminations, and possibly selection eliminations, will take place:

=SML
rewrite_conv[]Òz ç (òFile)Æ;
=TEX
=GFT ProofPower output
val it = Ù z ç (ò File)
    § ((age ¶ z.age, people ¶ z.people) ç File
      ± (age ¶ z.age', people ¶ z.people') ç File)
      ± z.age = z.age'
      ± z.people = z.people' : THM
=TEX

}%\ftmargins
