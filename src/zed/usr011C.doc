% usr011C.doc   %Z% $Date$ $Revision$ $RCSfile$
% this should form a Chapter of the document
% Z Expressions
=TEX
{\ftlmargin=0.5in
\section{Expressions}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* function application  Ò f xÆ  *)
	
 |	€ZApp› 		of TERM * TERM	(* expressions *)
 		
	(* lambda expression Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
	
 |	€ZÃ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 	
	(* definite description Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
	
 |	€ZÕ›		of TERM		(* declaration *)
 			* TERM		(* predicate *)
			* TERM		(* expression *)
 		
	(* power set construction, Ò  ˙Æ *)
	
 |	€Z›		of TERM		(* expression *)

	(* set display, Ò {1,2,3,4} Æ *)
	
 |	€ZSetd›		of TYPE	(* HOL type of elements *)
 			* TERM list	(* expressions *)
 		
	(* set abstraction, Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
	
 |	€ZSeta› 		of TERM		(* declaration *)
 			* TERM		(* predicate *)
 			* TERM		(* expression *)
 		
	(* tuple, Ò (1,2,3,4) Æ *)
	
 |	€ZTuple› 	of TERM list		(* expressions *)
 		
	(* tuple element selection, Ò (x,y).2Æ *)
	
 |	€ZSelât› 		of TERM		(* expression *)
 			* int			(* element number *)

 	(* cartesian product, Ò (˙ ∏ Ó) Æ *)
 	
 |	€Z∏›		of TERM list		(* expressions *)
 		
	(* binding Ò (people ¶ {}, age ¶ {}) Æ *)
	
 |	€ZBinding›	of (	string		(* component name *)
 			* TERM		(* component value *)
 			) list
 		
	(* binding component selection Ò (a ¶ 1, b ¶ "4").b Æ *)
	
 |	€ZSelâs›		of TERM		(* expression *)
 			* string		(* component name *)

	(* theta term Ò  File' Æ *)
	
 |	€Z ›		of TERM		(* schema expression *)
			* string		(* decoration *)
 		
	(* sequence display Ò ß1,2,3¢Æ *)
	
 |	€Zß¢›		of TYPE		(* type of elements *)
			* TERM list		(* values of elements *)
=TEX
}

\subsection{Function Application}\label{FunctionApplication}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* function application  Ò f xÆ  *)
	
 |	€ZApp› 		of TERM * TERM		(* expressions *)
=TEX
}

Function application may also use infix, postfix or ``fancyfix'' notation if an appropriate fixity paragraph has been entered.
In such cases the arguments are effectively the name of the constant and the second is the term consisting of a tuple of arguments.

=SML
dest_z_term Òf aÆ;
=GFT ProofPower output
val it = ZApp (ÒfÆ, ÒaÆ) : Z_TERM   
=TEX

=SML
dest_z_term Òa ¿ bÆ;
=GFT ProofPower output
val it = ZApp (Ò(_ ¿ _)Æ, Ò(a, b)Æ) : Z_TERM   
=TEX

In the following case the fixity declaration for bag brackets required a single argument which is a sequence (with sequence brackets elided in the concrete syntax of the bag display).

=SML
dest_z_term Ò˚1,2,3,2,1˝Æ;
=GFT ProofPower output
val it = ZApp (Ò(˚ ... ˝)Æ, Òß1, 2, 3, 2, 1¢Æ) : Z_TERM   
=TEX

\subsubsection{Proof Support}

Applications of lambda abstractions can be eliminated by (conditional) ¬-conversion.

=SML
z_¬_conv Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower output
val it = P a, a ç X Ù (Ã x : X | P x ∑ f x) a = f a : THM   
=TEX
Other applications may be eliminated in favour of definite descriptions.

=SML
z_app_conv Ò f aÆ;
=GFT ProofPower output
val it = Ù f a = Õ f_a : U | (a, f_a) ç f ∑ f_a : THM   
=TEX

More commonly function applications will be eliminated by rewriting with the definition of the relevant function.


\subsection{Lambda Abstraction}

$Ã$-abstractions when applied to arguments may be eliminated by $z\_¬\_conv$ (see \ref{FunctionApplication}).

Assertions about membership of $Ã$-abstractions may be directly eliminated.
=SML
rewrite_conv [] Òz ç (Ã x:X | P x ∑ f x)Æ;
=GFT ProofPower output
val it = Ù z ç Ã x : X | P x ∑ f x § z.1 ç X ± P z.1 ± f z.1 = z.2 : THM  
=TEX

Since they denote sets they may also be eliminated in favour of set comprehensions using $z\_Ã\_conv$. 

=SML
z_Ã_conv ÒÃ x:X | P x ∑ f xÆ;
=GFT ProofPower output
val it = Ù (Ã x : X | P x ∑ f x) = {x : X | P x ∑ (x, f x)} : THM   
=TEX

\subsection{Definite Description}

Definite descriptions may be eliminated using $z\_Õ\_rule$.

=SML
z_Õ_rule Ò Õ x:X | P ∑ yÆ;
=GFT ProofPower output
val it = Ù µ x' ∑ Ò µ x : X | P ∑ y = x'Æ ± Ò ∂ x : X | P ∑ y = x'Æ
  ¥ Ò Õ x : X | P ∑ yÆ = x' : THM
=TEX

\subsection{The Power Set}

Membership statements concerning power sets may be eliminated using $z\_ç\_\_conv$, or by rewriting in proof context ``$z\_language\_ext$''.

=SML
rewrite_conv[] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § (µ x1 : U ∑ x1 ç z ¥ x1 ç y) : THM   
=TEX

\subsection{Set Displays}

Membership statements sets displays may be eliminated using $z\_ç\_setd\_conv$, or by rewriting in proof context ``$z\_language\_ext$''.

=SML
rewrite_conv[] Ò z ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù z ç {1, 2, 3, 4, 5} § z = 1 ≤ z = 2 ≤ z = 3 ≤ z = 4 ≤ z = 5 : THM
=TEX

\subsection{Set Abstractions}

Statements about membership of set abstractions may be eliminated using $z\_ç\_seta\_conv$, or by rewriting in proof context ``$z\_language\_ext$''.

A simple abstraction results in straightforward substitution into the body of the abstraction:

=SML
rewrite_conv[] Ò 9 ç {x:Ó | x < 12}Æ;
=GFT ProofPower output
val it = Ù 9 ç {x : Ó | x < 12} § 9 ç Ó ± 9 < 12 : THM   
=TEX

Where the signature is more complex tuple projections are introduced:

=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y}Æ;
=GFT ProofPower output
val it = Ù z ç {x, y : Ó | x < y}
§ (z.1 ç Ó ± z.2 ç Ó) ± z ç (_ < _) : THM
=TEX

Where membership is asserted of a tuple the projections are undertaken automatically.

=SML
rewrite_conv[]Ò (v,w) ç {x, y:Ó | x < y}Æ;
=GFT ProofPower output
val it = Ù (v, w) ç {x, y : Ó | x < y}
§ (v ç Ó ± w ç Ó) ± v < w : THM   
=TEX

In the general case introduction of an existential is necessary, though this is avoided whenever possible.

=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y ∑ x * y - x}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y ∑ x * y - x}
§ (∂ x, y : Ó | x < y ∑ x * y - x = z) :THM
=TEX

\subsection{Tuple Displays}

Two tuple displays are equal iff each of their respective components are equal.

=SML
rewrite_conv[] Ò(x,y) = (a,b)Æ;
=GFT ProofPower output
val it = Ù (x, y) = (a, b) § x = a ± y = b : THM   
=TEX

Conversions to effect projection from tuple displays are also built into proof context ``$z\_language$''.
=SML
rewrite_conv[] Ò (x,y).1Æ;
=GFT ProofPower output
val it = Ù (x, y).1 = x : THM   
=TEX

\subsection{Binding Displays}

Two binding displays are equal iff each of their respective components are equal.

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b) = (y ¶ d, x ¶ c)Æ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) = (x ¶ c, y ¶ d) § a = c ± b = d : THM   
=TEX

Projection from binding displays is also built in to proof context ``$z\_language$''.

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM   
=TEX

\subsection{Cartesian Products}

=SML
rewrite_conv[] Ò (a, b) ç (x ∏ y)Æ;
=GFT ProofPower output
val it = Ù (a, b) ç x ∏ y § a ç x ± b ç y : THM   
=TEX

=SML
rewrite_conv[z_sets_ext_thm]	Ò (x ∏ y) = (a ∏ b)Æ;
=GFT ProofPower output
val it = Ù x ∏ y = a ∏ b
§ (µ z : U ∑ z.1 ç x ± z.2 ç y § z.1 ç a ± z.2 ç b) : THM
=TEX

\subsection{Theta Terms}

Theta terms may be though of as abbreviations for explicit binding constructions.
Rewriting with $z' \_def$ will reveal the underlying binding construction:

=SML
rewrite_conv[z' _def] Ò  ([x:X; y:Y])'Æ;
=GFT ProofPower output
val it = Ù  ([x : X; y : Y])' = (x ¶ x', y ¶ y') : THM
=TEX

Alternatively $z\_ \_conv$ may be used to secure the same effect:
 
=SML
z_ _conv Ò  ([x:X; y:Y])'Æ;
=GFT ProofPower output
val it = Ù  ([x : X; y : Y])' = (x ¶ x', y ¶ y') : THM   
=TEX

\section{Schema Expressions}


{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema negation: Ò(≥ File)∫UÆ *)
	
 |	€Z≥âs›		of TERM	(* schema expression *)
			
	(* schema conjunction: Ò(File ± File2)∫UÆ *)
	
 |	€Z±âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema disjunction: Ò(File ≤ File2)∫UÆ *)

 |	€Z≤âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema implication Ò(File ¥ File2)∫UÆ *)

 |	€Z¥âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema equivalence: Ò(File § File2)∫UÆ *)

 |	€Z§âs›		of TERM * TERM	(* schema expressions *)
			
	(* schema existential: Ò(∂ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
	(* schema unique existential: Ò(∂â1 File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂â1âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
	(* schema universal: Ò(µ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Zµâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)

	(* horizontal schema expression: Ò [x:˙ | x>0] Æ *)
	
 |	€Zâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
		
	(* decoration: Ò File ''Æ *)
	
 |	€ZDecorâs›	of TERM		(* schema expression *)
 			* string		(* decoration *)
 		
	(* pre-condition: Ò pre FileOpÆ *)
	
 |	€ZPreâs›		of TERM		(* schema expression *)

 	(* schema hiding: Ò FileOp \âs (age, i?)Æ  *)
 	
 |	€ZHideâs›	of TERM		(* schema expression *)
 			* string list		(* component names *)
 		
	(* schema renaming: ÒFile [aged/age, input/i?]Æ *)
	
 |	€ZRenameâs›	of TERM		(* schema expression *)
 			* (string * string) list	(* rename list *)
 		
	(* schema projection: ÒFileOp ˘âs FileÆ*)
	
 |	€Z˘âs›		of TERM * TERM	(* schema expressions *)

	(* schema composition: ÒÑFile ªâs ÑFileÆ *)
	
 |	€Zªâs›	of TERM * TERM	(* schema expressions *)
 		
	(* delta operation: ÒÑFileÆ *)
	
 |	€ZÑâs›		of TERM		(* schema expression *)
 		
	(* ò operation: ÒòFileÆ *)
	
 |	€Zòâs›		of TERM		(* schema expression *)
;
=TEX
}

\subsection{Schema Negation}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema negation Ò(≥ File)∫UÆ *)
	
 | 	€Z≥âs›		of TERM	(* schema expression *)
=TEX
}

A negation occurring at the outermost level in a term quotation will be interpreted as a logical negation rather than a schema negation, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema negation of a schema iff it is not an element of the schema.

This rule is captured by the conversion $z\_ç\_≥âs\_conv$, which is built into the standard rewrites for proof context ``z\_language''.

=SML
rewrite_conv[]Òz ç (≥ File)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (≥ File) § ≥ z ç File : THM   
=TEX

\subsection{Schema Conjunction}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema conjunction: Ò(File ± File2)∫UÆ *)
	
 |	€Z±âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

A conjunction occurring at the outermost level in a term quotation will be interpreted as a logical conjunction rather than a schema conjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema conjunction of two schemas iff both the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z\_ç\_±âs\_conv$, which is built into the standard rewrites for proof context ``z\_language''.

=IGN
z_ç_±âs_conv Òz ç (File ± File2)Æ;
=SML
rewrite_conv[] Òz ç (File ± File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ± File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ± (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\subsection{Schema Disjunction}

\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema disjunction: Ò(File ≤ File2)∫UÆ *)
	
 |	€Z≤âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

A disjunction occurring at the outermost level in a term quotation will be interpreted as a logical disjunction rather than a schema disjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema disjunction of two schemas iff either of the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z\_ç\_≤âs\_conv$, which is built into the standard rewrites for proof context ``z\_language''.

=IGN
z_ç_≤âs_conv Òz ç (File ≤ File2)Æ;
=SML
rewrite_conv[] Òz ç (File ≤ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ≤ File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ≤ (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\subsection{Schema Implication}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema implication Ò(File ¥ File2)∫UÆ *)

 |	€Z¥âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

An implication occurring at the outermost level in a term quotation will be interpreted as a logical implication rather than a schema implication, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema implication of two schemas iff whenever the projection of the binding to the signature of the first operand is an element of the corresponding operand schemas, the projections of the binding to the signature of the second operand is also an element of the second operand schema.

This rule is captured by the conversion $z\_ç\_¥âs\_conv$, which is built into the standard rewrites for proof context "z\_language".

=IGN
z_ç_¥âs_conv Òz ç (File ¥ File2)Æ;
=SML
rewrite_conv[] Òz ç (File ¥ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File ¥ File2)
    § (age ¶ z.age, people ¶ z.people) ç File
      ¥ (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX


\subsection{Schema Equivalence}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema equivalence: Ò(File § File2)∫UÆ *)

 |	€Z§âs›		of TERM * TERM	(* schema expressions *)
=TEX
}

The two operands must be schema expressions with compatible types.

An equivalence occurring at the outermost level in a term quotation will be interpreted as a logical equivalence rather than a schema equivalence, unless a cast is applied.


\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema equivalence of two schemas iff the projection of the binding to the signature of the first operand is an element of the corresponding operand schema iff the projection of the binding to the signature of the second operand is an element of the second operand schema.

This rule is captured by the conversion $z\_ç\_§âs\_conv$, which is built into the standard rewrites for proof context "z\_language".

=SML
rewrite_conv[]Òz ç (File § File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File § File2)
    § (age ¶ z.age, people ¶ z.people) ç File
    § (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX


\subsection{Schema Existential}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema existential: Ò(∂ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

An existential occurring at the outermost level in a term quotation will be interpreted as a logical existential rather than a schema existential, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema existentials is the conversion $z\_ç\_∂âs\_conv$, which is built into the standard rewrites for proof context "z\_language".

=SML
rewrite_conv[]Òz ç (∂ File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (∂ File3 | people = {} ∑ File2)
    § (∂ x1 : U
      ∑ ((people ¶ x1.people) ç File3
        ± x1.people = {})
        ± (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Schema Unique Existence}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema unique existential: Ò(∂â1 File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Z∂â1âs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

A unique existential occurring at the outermost level in a term quotation will be interpreted as a logical existential rather than a schema existential, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema existentials is the conversion $z\_ç\_∂â1âs\_conv$, which is built into the standard rewrites for proof context "z\_language".

=SML
rewrite_conv[]Òz ç (∂â1 File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (∂â1 File3 | people = {} ∑ File2)
    § (∂â1 x1 : U
      ∑ ((people ¶ x1.people) ç File3
        ± x1.people = {})
        ± (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Schema Universal}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* schema universal: Ò(µ File3 | people = {} ∑ File2)∫UÆ *)
	
 |	€Zµâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
=TEX
}

The last operand must be a schema expressions with type compatible with the signature of the declaration.
The signature of the declaration part must be contained in the signature of the body.

A universal occurring at the outermost level in a term quotation will be interpreted as a logical universal rather than a schema universal, unless a cast is applied.

\subsubsection{Proof Support}

The basic rule for schema universals is the conversion $z\_ç\_µâs\_conv$, which is built into the standard rewrites for proof context "z\_language".

=SML
rewrite_conv[]Òz ç (µ File3 | people = {} ∑ File2)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (µ File3 | people = {} ∑ File2)
    § (µ x1 : U
      ∑ ((people ¶ x1.people) ç File3
        ± x1.people = {})
        ± (height ¶ z.height, people ¶ x1.people) ç File2) : THM
=TEX

\subsection{Horizontal Schemas}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* horizontal schema expression: Ò [x:˙ | x>0] Æ *)
	
 |	€Zâs›		of TERM		(* declaration *)
			* TERM		(* predicate *)
=TEX
}

\subsubsection{Proof Support}

The basic rule for horisontal schemas is the conversion $z\_ç\_horiz\_schema\_conv1$, which is built into the standard rewrites for proof context "z\_language".

=SML
rewrite_conv[]Òz ç [x:˙;y:Ó]Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç [x : ˙; y : Ó]
	§ z.x ç ˙ ± z.y ç Ó : THM   
=TEX

\subsection{Decoration}
\subsubsection{Syntax}

{\ftlmargin=0in\ftrmargin=0in
=GFT Z_TERM
	(* decoration: Ò File ''Æ *)
	
 |	€ZDecorâs›	of TERM		(* schema expression *)
 			* string		(* decoration *)
=TEX
}

\subsubsection{Proof Support}

=SML
rewrite_conv[]Òz ç File ''Æ;
=TEX

=GFT ProofPower output
=TEX
\subsection{Pre-Condition}
=SML
once_rewrite_conv[]Òz ç (pre FileOp)Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (pre FileOp) §
 z ç	[age : U; i? : U; people : U
	| ∂ age' : U; people' : U ∑ FileOp] : THM
=TEX
\subsection{Schema Hiding}
=SML
once_rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File \âs (age)) §
	z ç [people : U | ∂ age : U ∑ File] : THM
=TEX

=SML
rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File \âs (age))
    § (∂ age : U ∑
    	(age ¶ age, people ¶ z.people) ç File) : THM
=TEX
\subsection{Schema Renaming}
=SML
once_rewrite_conv[]Òz ç File[aged/age]Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç (File [aged/age]) §
	(age ¶ z.aged, people ¶ z.people) ç File : THM
=TEX
=SML
once_rewrite_conv[]Òz ç (FileOp ˘âs File)Æ; (*  *)
=TEX

=GFT ProofPower output
val it = Ù z ç (FileOp ˘âs File)
    § z ç ((FileOp ± File) \âs (age', i?, people')) : THM
=TEX
\subsection{Schema Composition}

=SML
once_rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ; (*  *)
=TEX

=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § z
      ç [age : U; i? : U; people : U; age' : U; people' : U
        | ∂ x1 : U; x2 : U
          ∑ (age ¶ age, age' ¶ x1, i? ¶ i?, people ¶ people, people' ¶ x2)
              ç FileOp
            ± (age ¶ x1, age' ¶ age', i? ¶ i?, people ¶ x2,
                  people' ¶ people')
              ç FileOp] : THM
=TEX

\subsection{Delta}

=SML
once_rewrite_conv[]Òz ç (ÑFile)Æ; (*  *)
=TEX


=GFT ProofPower output
val it = Ù z ç (Ñ File) § z ç [File; File'] : THM   
=TEX

\subsection{Xi}

=SML
once_rewrite_conv[]Òz ç (òFile)Æ; (*  *)
=TEX

=GFT ProofPower output
val it = Ù z ç (ò File) § z ç [File; File' |  File =  File'] : THM   
=TEX


}%\ftmargins
