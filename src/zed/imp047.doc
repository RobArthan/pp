=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP047}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the constructor, discriminator and destructor functions corresponding to the primitive constructors of Z.
The detailed design of these is found in \cite{DS/FMU/IED/DTD047}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives the implementation of the functions mentioned above.
Additional functions, which are used in other parts of the Z system, may also be included here for convenience.
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{?} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intecepted and reported as helpfully as possible.
\section{STRUCTURE PREAMBLE}
=SML
structure €ZTypesAndTerms› : ZTypesAndTerms = struct
=TEX
We open the structure containing the support package (see \cite{DS/FMU/IED/IMP048}).
=SML
open icl'ZTypesAndTerms;
=TEX
\section{DERIVED HOL CONSTRUCTORS}
The functions defined here are an ad-hoc collection of constructors, destructors and discriminators which, at the time of writing, were not provided by the ICL HOL system.
If they are added in future, they will be removed from here.
=SML
fun	€list_mk_≠_type› ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_≠_type tyl ty;
=TEX
\section{AUXILIARY FUNCTIONS}
\subsection{Name Destruction}
We need the inverse of the name construction functions (defined in \cite{DS/FMU/IED/DTD048}).
=SML
fun	€dest_Z_name› (s:string) :string * string list list =
	let	fun	frt l = rev(tl(rev l));
		fun	lst l = hd(rev l);
		fun	f [] r = r
		|	f ("["::t) (n,[]) = f t (n,[[]])
		|	f ("["::t) (n,cl) = f t (n,cl @ [[]])
		|	f ("]"::t) r = f t r
		|	f (","::t) (n,cl) = 
				let	val (fcl,lcl) = (frt cl,lst cl)
				in
					f t (n,fcl @ [lcl @ [""]])
				end
		|	f (h::t) (n,[]) = f t (n ^ h,[])
		|	f (h::t) (n,cll) = (
				case lst cll of
					[] => f t (n,(frt cll) @ [[h]])
				|	cl => f t (n,(frt cll) @ [(frt cl) @ [(lst cl) ^ h]])
				)
	in
		f (explode s) ("",[])
	end
	handle Fail _ => fail "dest_Z_name" 47000 [fn () => s];
=TEX
\section{Z TYPES}
The following sections describe the constructor, discriminator and destructor functions for each of the five Z type constructors.
\subsection{The Datatype ZTYPE}
This datatype is used by the general mapping functions $mk\_ZTYPE$, $is\_ZTYPE$ and $dest\_ZTYPE$ (q.v.).
=SML
datatype	€ZTYPE› = 	ZgivenT of string
		|		ZvarT of string
		|		ZpowerT of TYPE
		|		ZtupleT of TYPE list
		|		ZschemaT of (string * TYPE) list;
=TEX
\subsection{The General Destructor Function}
This function converts a HOL type to the appropriate form of the above datatype (providing, of course, that it represents a valid Z type).
=SML
fun	dest_ZTYPE (ty:TYPE) :ZTYPE =
	case dest_simple_type ty of
		Vartype s => (
			case explode s of
				("'"::t) => ZvarT(implode t)
			|	_ => fail "" 0 []
		)
	|	Ctype("",[ty1]) => ZpowerT ty1
	|	Ctype(s,tyl) => (
			case (dest_Z_name s,tyl) of
				(("Z'T",[[n]]),tyl) => 
					if PolyML.makestring(length tyl) = n
					then ZtupleT tyl
					else fail "" 0 []
			|	(("Z'S",[cl]),tyl) => 
					ZschemaT(combine cl tyl)
			|	(_,[]) => ZgivenT s
			|	_ => fail "" 0 []
		)
	handle Fail _ => type_fail "dest_ZTYPE" 47800 [ty];
=TEX
\subsection{The General Discriminator Function}
=SML
fun	€is_ZTYPE› (t:TYPE) :bool =
	let	val x = dest_ZTYPE t
	in
		true
	end
	handle Fail _ => false;
=TEX
\subsection{Given Sets}
=SML
fun	€mk_ZgivenT› (s:string) :TYPE = mk_ctype(s,[]);
fun	€is_ZgivenT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZgivenT _ => true
	|	_ => false
	)
	handle Fail _ => false;
fun	€dest_ZgivenT› (ty :TYPE) :string = (
	case dest_ZTYPE ty of
		ZgivenT s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZgivenT" 47010 [ty];
=TEX
\subsection{Generic Variables}
=SML
fun	€mk_ZvarT› (s:string) :TYPE = mk_vartype("'" ^ s);
fun	€is_ZvarT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZvarT _ => true
	|	_ => false
	)
	handle Fail _ => false;
fun	€dest_ZvarT› (ty :TYPE) :string = (
	case dest_ZTYPE ty of
		ZvarT s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZvarT" 47020 [ty];
=TEX
\subsection{Set Types}
=SML
fun	€mk_ZpowerT› (ty:TYPE) :TYPE = mk_ctype("SET",[ty]);
fun	€is_ZpowerT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZpowerT _ => true
	|	_ => false
	)
	handle Fail _ => false;
fun	€dest_ZpowerT› (ty :TYPE) :TYPE = (
	case dest_ZTYPE ty of
		ZpowerT t => t
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZpowerT" 47030 [ty];
=TEX
\subsection{Cartesian Product Types}
=SML
fun	€mk_ZtupleT› (tyl:TYPE list) :TYPE = 
		tuple_type tyl;
fun	€is_ZtupleT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZtupleT _ => true
	|	_ => false
	)
	handle Fail _ => false;
fun	€dest_ZtupleT› (ty :TYPE) :TYPE list = (
	case dest_ZTYPE ty of
		ZtupleT tyl => tyl
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZtupleT" 47040 [ty];
=TEX
\subsection{Binding Types}
=SML
fun	€mk_ZschemaT› (itym:(string * TYPE) list) :TYPE =
		bind_type itym;
fun	€is_ZschemaT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZschemaT _ => true
	|	_ => false
	)
	handle Fail _ => false;
fun	€dest_ZschemaT› (ty :TYPE) :(string * TYPE) list = (
	case dest_ZTYPE ty of
		ZschemaT itym => itym
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZschemaT" 47050 [ty];
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $ZTERM$ to the corresponding $TERM$.
=SML
fun	€mk_ZTYPE›	(ZgivenT(s:string) :ZTYPE) :TYPE = mk_ZgivenT s
|	mk_ZTYPE	(ZvarT(s:string)) = mk_ZvarT s
|	mk_ZTYPE	(ZpowerT(ty:TYPE)) = mk_ZpowerT ty
|	mk_ZTYPE	(ZtupleT(tyl:TYPE list)) = mk_ZtupleT tyl
|	mk_ZTYPE	(ZschemaT(itym:(string * TYPE)list)) = mk_ZschemaT itym;
=TEX
\section{Z TERMS}
The following describes the constructor, discriminator and destructor functions for Z terms.
\subsection{The Datatype ZTERM}
This datatype is used by the generalised mapping functions $mk\_ZTERM$, $is\_ZTERM$ and $dest\_ZTERM$ (q.v.).
=SML
datatype	€ZTERM› = 	Zdec of TERM list * TERM
		|		Zdecsexp of TERM * string
		|		Zdecl of TERM list
		|		Zeq of TERM * TERM
		|		Zç of TERM * TERM
		|		Ztrue
		|		Zfalse
		|		Z≥ of TERM
		|		Z± of TERM * TERM
		|		Z≤ of TERM * TERM
		|		Z¥ of TERM * TERM
		|		Z§ of TERM * TERM
		|		Z∂ of TERM * TERM * TERM
		|		Z∂â1 of TERM * TERM * TERM
		|		Zµ of TERM * TERM * TERM
		|		Zpredsexp of TERM * string
		|		Zlvar of string * TYPE * TERM list
		|		Zgvar of string * TYPE * TERM list
		|		Zint of string
		|		Zß¢ of TYPE * TERM list
		|		Zsetd of TYPE * TERM list
		|		Zseta of TERM * TERM * TERM
		|		Z of TERM
		|		ZT of TERM list
		|		Z∏ of TERM list
		|		Z  of TERM * string
		|		Zsel of TERM * string
		|		Zapp of TERM * TERM
		|		ZÃ of TERM * TERM * TERM
		|		ZÕ of TERM * TERM * TERM
		|		Zâs of TERM * TERM
		|		Zdecâs of TERM * string
		|		Zpreâs of TERM
		|		Z≥âs of TERM
		|		Z±âs of TERM * TERM
		|		Z≤âs of TERM * TERM
		|		Z¥âs of TERM * TERM
		|		Z§âs of TERM * TERM
		|		Z˘âs of TERM * TERM
		|		Zhideâs of TERM * string list
		|		Z∂âs of TERM * TERM * TERM
		|		Z∂â1âs of TERM * TERM * TERM
		|		Zµâs of TERM * TERM * TERM
		|		ZÑâs of TERM
		|		Zòâs of TERM
		|		Zªâs of TERM * TERM;
=TEX
\subsection{The General Destructor Function}
This function converts a HOL term to the appropriate form of the above datatype (providing, of course, that it represents a valid Z object).
It consists of a simple case analysis on the name of the rator of the supplied term and is therefore not foolproof; obvious cases of invalid Z are caught at the end.
=SML
local
val 	CI = Combinators.I;
fun	dest (t:TERM) :string * string list list * TERM list =
	let	val (c,al) = strip_app t;
		val (cn,_) = dest_const c handle Fail _ => dest_var c;
		val (s,cl) = dest_Z_name cn;
	in
		(s,cl,al)
	end
	handle Fail _ => term_fail "dest_ZTERM" 47900 [t];
fun	dest_abstraction (t:TERM) :TERM list =
		snd(strip_app(snd(strip_Ã t)))
	handle Fail _ => term_fail "dest_ZTERM" 47901 [t];
in
fun	€dest_ZTERM› (t:TERM) :ZTERM = (
	case dest t of
=TEX
\subsubsection{Declarations}
First we look for declarations, beginning with variables.
=SML
		("Z'dec",[],[x]) => (
			Zdec((dest_list ** CI)(dest_pair x))
		handle Fail _ => term_fail "dest_ZTERM" 47910 [t]
		)
=TEX
Then schema declarations.
=SML
	|	("Z'decsexp",[],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			Zdecsexp(sch,d)
		end
		handle Fail _ => term_fail "dest_ZTERM" 47911 [t]
		)
=TEX
And composite declarations.
Note that all declarations used in other constructs must be of this form, even if only on of the above forms is used (it is even possible to have an empty declaration under certain circumstances).
=SML
	|	("Z'decl",[],[x]) => (
			Zdecl(dest_list x)
		handle Fail _ => term_fail "dest_ZTERM" 47912 [t]
		)
=TEX
\subsubsection{Predicates}
The logical connectives, true and false map directly on to the equivalent HOL constants.
=SML
	|	("=",[],[x,y]) => (Zeq(x,y))
	|	("ç",[],[x,y]) => (Zç(x,y))
	|	("T",[],[]) => (Ztrue)
	|	("F",[],[]) => (Zfalse)
	|	("≥",[],[x]) => (Z≥(x))
	|	("±",[],[x,y]) => (Z±(x,y))
	|	("≤",[],[x,y]) => (Z≤(x,y))
	|	("¥",[],[x,y]) => (Z¥(x,y))
	|	("§",[],[x,y]) => (Z§(x,y))
=TEX
=SML
	|	("Z'∂",[_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => Z∂(d,p,v)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47920 [t]
		)
=TEX
=SML
	|	("Z'∂â1",[_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => Z∂â1(d,p,v)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47921 [t]
		)
=TEX
=SML
	|	("Z'µ",[_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => Zµ(d,p,v)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47922 [t]
		)
=TEX
=SML
	|	("Z'predsexp",[],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			Zpredsexp(sch,d)
		end
		handle Fail _ => term_fail "dest_ZTERM" 47923 [t]
		)
=TEX
\subsubsection{Terms}
We must postpone the handling of local and global variables until the end because they do not have an easily identifiable constant part.
=SML
	|	("Z'int",[],[tm]) => (Zint(fst(dest_const tm)))
=TEX
=SML
	|	("Z'ß¢",[],[x]) => (
		case dest_ctype(type_of x) of
			("LIST",[t]) => Zß¢(t,dest_list x)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47930 [t]
		)
=TEX
=SML
	|	("Z'setd",[],[x]) => (
		case dest_ctype(type_of x) of
			("LIST",[t]) => Zsetd(t,dest_list x)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47931 [t]
		)
=TEX
=SML
	|	("Z'seta",[_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => Zseta(d,p,v)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47932 [t]
		)
=TEX
=SML
	|	("Z'",[],[x]) => Z(x)
=TEX
=SML
	|	("Z'T",[_],x) => ZT(x)
=TEX
=SML
	|	("Z'∏",[_],x) => Z∏(x)
=TEX
=SML
	|	("Z' ",[],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			Z (sch,d)
		end
		handle Fail _ => term_fail "dest_ZTERM" 47933 [t]
		)
=TEX
=SML
	|	("Z'S",[_,[s]],[x]) => Zsel(x,s)
=TEX
=SML
	|	("Z'app",[],[x]) => (
			Zapp(dest_pair x)
		handle Fail _ => term_fail "dest_ZTERM" 47934 [t]
		)
=TEX
=SML
	|	("Z'Ã",[_],[x]) => (
		case dest_abstraction x of
			[d,p,t,v] => ZÃ(d,p,v)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47935 [t]
		)
=TEX
=SML
	|	("Z'Õ",[_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => ZÕ(d,p,v)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47936 [t]
		)
=TEX
\subsubsection{Schemas}
=SML
	|	("Z'âs",[_],[x]) => (
		case dest_abstraction x of
			[d,p] => Zâs(d,p)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47940 [t]
		)
=TEX
=SML
	|	("Z'decâs",[_,[]],[x]) => Zdecâs(x,"")
	|	("Z'decâs",[_,[s]],[x]) => Zdecâs(x,s)
=TEX
=SML
	|	("Z'preâs",[_],[x]) => Zpreâs(x)
=TEX
=SML
	|	("Z'≥âs",[],[x]) => Z≥âs(x)
=TEX
=SML
	|	("Z'±âs",[_,_],[x,y]) => Z±âs(x,y)
=TEX
=SML
	|	("Z'≤âs",[_,_],[x,y]) => Z≤âs(x,y)
=TEX
=SML
	|	("Z'¥âs",[_,_],[x,y]) => Z¥âs(x,y)
=TEX
=SML
	|	("Z'§âs",[_,_],[x,y]) => Z§âs(x,y)
=TEX
=SML
	|	("Z'˘âs",[_,_],[x,y]) => Z˘âs(x,y)
=TEX
=SML
	|	("Z'hideâs",[_,sl],[x]) => Zhideâs(x,sl)
=TEX
=SML
	|	("Z'∂âs",[_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => Z∂âs(d,p,y)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47941 [t]
		)
=TEX
=SML
	|	("Z'∂â1âs",[_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => Z∂â1âs(d,p,y)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47942 [t]
		)
=TEX
=SML
	|	("Z'µâs",[_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => Zµâs(d,p,y)
		|	_ => fail "" 0 []
		handle Fail _ => term_fail "dest_ZTERM" 47943 [t]
		)
=TEX
=SML
	|	("Z'Ñâs",[_],[x]) => ZÑâs(x)
=TEX
=SML
	|	("Z'òâs",[_],[x]) => Zòâs(x)
=TEX
=SML
	|	("Z'ªâs",[_,_],[x,y]) => Zªâs(x,y)
=TEX
\subsubsection{Local and Global Variables}
=SML
	|	(_,[],[]) => ((
			case dest_const t of
				(n,ty) => Zgvar(n,ty,[]))
			handle Fail _ => (
			case dest_var t of
				(n,ty) => Zlvar(n,ty,[])
			)
			handle Fail _ => term_fail "dest_ZTERM" 47900 [t]
			)
=TEX
=SML
	|	(_,[],[tm]) => (
		let	val (c,_) = strip_app t;
			val tml = (
				case dest tm of
					("Z'T",[_],x) => x
				|	_ => fail "" 0 []);
		in
			(
			case dest_const c of
				(n,ty) => Zgvar(n,snd(dest_≠_type ty),tml)
			)
			handle Fail _ => (
			case dest_var c of
				(n,ty) => Zlvar(n,snd(dest_≠_type ty),tml)
			)
		end
		handle Fail _ => term_fail "dest_ZTERM" 47900 [t]
		)
=TEX
\subsubsection{Errors}
Finally, if all this fails, the supplied term simply isn't Z.
=SML
	|	_ => term_fail "dest_ZTERM" 47900 [t]
	)
	handle X => pass_on X "dest_ZTERM" "dest_ZTERM" 
end (* of function dest_ZTERM *);
=TEX
\subsection{The General Discriminator Function}
=SML
fun	€is_ZTERM› (t:TERM) :bool =
	let	val x = dest_ZTERM t
	in
		true
	end
	handle Fail _ => false;
=TEX
\subsection{Declaration Destructors}
=SML
fun	€dest_Zdec› (t:TERM) :(TERM list * TERM) =
	case dest_ZTERM t of
		Zdec(tml,tm) => (tml,tm)
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdec" 47061 [t];
fun	€dest_Zdecsexp› (t:TERM) :TERM * string =
	case dest_ZTERM t of
		Zdecsexp(tm,s) => (tm,s)
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdecsexp" 47071 [t];
fun	€dest_Zdecl› (t:TERM) :TERM list =
	case dest_ZTERM t of
		Zdecl tml => tml
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdecl" 47080 [t];
=TEX
The following function, which produces a type map from a declaration, will frequently be required below.
=SML
local
fun	f ([] :TERM list) :(string * TYPE)list = []
|	f (h::t) = (
		map dest_var (fst(dest_Zdec h))
		handle Fail _ =>
		let val (sch,d) = dest_Zdecsexp h
		in
			map 	(fn(s,ty)=>(pack_IDENT(s,d),ty)) 
				(dest_ZschemaT(dest_ZpowerT(type_of sch)))
		end) @ (f t);
in
fun	€dest_decl› (t:TERM) :(string * TYPE)list =
		f (dest_Zdecl t)
	handle Fail _ => term_fail "dest_decl" 47080 [t]
end;
=TEX
\subsection{Declaration Discriminators}
=SML
fun	€is_Zdec› (t:TERM) :bool =
	case dest_ZTERM t of
		Zdec(tml,tm) => true
	|	_ => false
	handle Fail _ => false;
fun	€is_Zdecsexp› (t:TERM) :bool =
	case dest_ZTERM t of
		Zdecsexp(tm,s) => true
	|	_ => false
	handle Fail _ => false;
fun	€is_Zdecl› (t:TERM) :bool =
	case dest_ZTERM t of
		Zdecl tml => true
	|	_ => false
	handle Fail _ => false;
=TEX
\subsection{Predicate Destructors}
=SML
fun	€dest_Zeq› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zeq(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zeq" 47220 [t];
=TEX
=SML
fun	€dest_Zç› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zç(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zç" 47230 [t];
=TEX
=SML
fun	€dest_Z≥› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z≥(tm1) => (tm1) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≥" 47240 [t];
=TEX
=SML
fun	€dest_Z±› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z±(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z±" 47250 [t];
=TEX
=SML
fun	€dest_Z≤› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z≤(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≤" 47260 [t];
=TEX
=SML
fun	€dest_Z¥› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z¥(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¥" 47270 [t];
=TEX
=SML
fun	€dest_Z§› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z§(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z§" 47280 [t];
=TEX
=SML
fun	€dest_Z∂› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂" 47290 [t];
=TEX
=SML
fun	€dest_Z∂â1› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂â1(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂â1" 47300 [t];
=TEX
=SML
fun	€dest_Zµ› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zµ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zµ" 47310 [t];
=TEX
=SML
fun	€dest_Zpredsexp› (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zpredsexp(tm1,s) => (tm1,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zpredsexp" 47320 [t];
=TEX
\subsection{Predicate Discriminators}
=SML
fun	€is_Zeq› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zeq(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zç› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zç(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Ztrue› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Ztrue => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zfalse› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zfalse => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z≥› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≥(tm1) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z±› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z±(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z≤› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≤(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z¥› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¥(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z§› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z§(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z∂› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z∂â1› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂â1(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zµ› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zµ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zpredsexp› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zpredsexp(tm1,s) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Term Destructors}
=SML
fun	€dest_Zlvar› (t:TERM) :string * TYPE * TERM list = 
	case dest_ZTERM t of 
		Zlvar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zlvar" 47090 [t];
=TEX
=SML
fun	€dest_Zgvar› (t:TERM) :string * TYPE * TERM list = 
	case dest_ZTERM t of 
		Zgvar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zgvar" 47100 [t];
=TEX
=SML
fun	€dest_Zint› (t:TERM) :string = 
	case dest_ZTERM t of 
		Zint(s) => (s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zint" 47105 [t];
=TEX
=SML
fun	€dest_Zß¢› (t:TERM) :TYPE * TERM list = 
	case dest_ZTERM t of 
		Zß¢(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zß¢" 47110 [t];
=TEX
=SML
fun	€dest_Zsetd› (t:TERM) :TYPE * TERM list = 
	case dest_ZTERM t of 
		Zsetd(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zsetd" 47120 [t];
=TEX
=SML
fun	€dest_Zseta› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zseta(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zseta" 47130 [t];
=TEX
=SML
fun	€dest_Z› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z" 47140 [t];
=TEX
=SML
fun	€dest_Ztuple› (t:TERM) :TERM list = 
	case dest_ZTERM t of 
		ZT(tml) => (tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Ztuple" 47150 [t];
=TEX
=SML
fun	€dest_Z∏› (t:TERM) :TERM list = 
	case dest_ZTERM t of 
		Z∏(tml) => (tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∏" 47160 [t];
=TEX
=SML
fun	€dest_Z › (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Z (tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z " 47170 [t];
=TEX
=SML
fun	€dest_Zsel› (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zsel(tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zsel" 47180 [t];
=TEX
=SML
fun	€dest_Zapp› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zapp(f,a) => (f,a) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zapp" 47190 [t];
=TEX
=SML
fun	€dest_ZÃ› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		ZÃ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÃ" 47200 [t];
=TEX
=SML
fun	€dest_ZÕ› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		ZÕ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÕ" 47210 [t];
=TEX
\subsection{Term Discriminators}
=SML
fun	€is_Zlvar› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zlvar(s,ty,tml) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zgvar› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zgvar(s,ty,tml) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zint› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zint(s) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zß¢› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zß¢(tml) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zsetd› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zsetd(tml) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zseta› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zseta(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z(tm) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Ztuple› (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZT(tml) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z∏› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∏(tml) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z › (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z (tm,s) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zsel› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zsel(tm,s) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zapp› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zapp(f,a) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_ZÃ› (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÃ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_ZÕ› (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÕ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Destructors for the Schema Calculus}
=SML
fun	€dest_Zâs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zâs(d,p) => (d,p) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zâs" 47070 [t];
=TEX
=SML
fun	€dest_Zdecâs› (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zdecâs(tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zdecâs" 47340 [t];
=TEX
=SML
fun	€dest_Zpreâs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zpreâs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zpreâs" 47350 [t];
=TEX
=SML
fun	€dest_Z≥âs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z≥âs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≥âs" 47360 [t];
=TEX
=SML
fun	€dest_Z±âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z±âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z±âs" 47370 [t];
=TEX
=SML
fun	€dest_Z≤âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z≤âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≤âs" 47380 [t];
=TEX
=SML
fun	€dest_Z¥âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z¥âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¥âs" 47390 [t];
=TEX
=SML
fun	€dest_Z§âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z§âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z§âs" 47400 [t];
=TEX
=SML
fun	€dest_Z˘âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z˘âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z˘âs" 47410 [t];
=TEX
=SML
fun	€dest_Zhideâs› (t:TERM) :TERM * string list = 
	case dest_ZTERM t of 
		Zhideâs(tm,sl) => (tm,sl) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zhideâs" 47420 [t];
=TEX
=SML
fun	€dest_Z∂âs› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂âs(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂âs" 47430 [t];
=TEX
=SML
fun	€dest_Z∂â1âs› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂â1âs(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂â1âs" 47440 [t];
=TEX
=SML
fun	€dest_Zµâs› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zµâs(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zµâs" 47450 [t];
=TEX
=SML
fun	€dest_ZÑâs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		ZÑâs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÑâs" 47460 [t];
=TEX
=SML
fun	€dest_Zòâs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zòâs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zòâs" 47470 [t];
=TEX
=SML
fun	€dest_Zªâs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zªâs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zªâs" 47480 [t];
=TEX
\subsection{Discriminators for the Schema Calculus}
=SML
fun	€is_Zâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zâs(d,p) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zdecâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zdecâs(tm,s) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zpreâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zpreâs(tm) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z≥âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≥âs(tm) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z±âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z±âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z≤âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≤âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z¥âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¥âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z§âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z§âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z˘âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z˘âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zhideâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zhideâs(tm,sl) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z∂âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂âs(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Z∂â1âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂â1âs(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zµâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zµâs(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_ZÑâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÑâs(tm) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zòâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zòâs(tm) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
=SML
fun	€is_Zªâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zªâs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Binding Construction}
There are three constructors below which generate systematically decorated bindings from schemas: schema references as declarations, schema references as predicates and theta terms.
We therefore provide the following general function for doing this.
=SML
fun	€mk_binding› ((sch,d):TERM * string) :TERM =
	let	val itym = dest_ZschemaT(dest_ZpowerT(type_of sch));
		val itym' = map (fn(s,t) => (pack_IDENT(s,d),t)) itym;
		val bcons = bind_cterm itym;
		val argl = map mk_var (dest_ZschemaT(mk_ZschemaT itym'));
	in
		list_mk_app(bcons,argl)
	end
	handle Fail _ => term_fail "mk_binding" 47070 [sch];
=TEX
\subsection{Declaration Constructors}
=SML
fun 	€mk_Zdec› ((varl,set):TERM list * TERM) :TERM =
	let	val sty = type_of set;
		val ety = dest_ZpowerT sty;
		val vl = mk_list varl
			handle X => reraise X "mk_Zdec";
		val decty = mk_≠_type(mk_∏_type(type_of vl,sty),¨:BOOLÆ);
		val dec = mk_const("Z'dec",decty);
	in
		mk_app(dec,mk_pair(vl,set))
	end
	handle X => (divert X "mk_Zdec"
			"dest_ZpowerT" 47060 [fn() => string_of_term set]

	);
=TEX
=SML
fun	€mk_Zdecsexp› ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_≠_type(mk_∏_type(bty,sty),BOOL);
		val con = mk_const("Z'decsexp",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;
=TEX
=SML
fun	€mk_Zdecl› (tml:TERM list) :TERM =
	let	val lis = mk_list tml;
		val decl = mk_const("Z'decl",mk_≠_type(type_of lis,BOOL));
	in
		mk_app(decl,lis)
	end
	handle X => pass_on X "mk_list" "mk_Zdecl";
=TEX
\subsection{Predicate Constructors}
=SML
val	€mk_Zeq› :(TERM * TERM) -> TERM = mk_eq
	handle X => pass_on X "mk_eq" "mk_Zeq";
=TEX
=SML
fun	€mk_Zç› ((tm1,tm2):TERM * TERM) :TERM = 
	let	val ty = list_mk_≠_type([type_of tm1, mk_ZpowerT (type_of tm1)],BOOL);
	in
		list_mk_app(mk_const("ç",ty),[tm1,tm2])
	end
	handle X => pass_on X "mk_app" "mk_Zç";
=TEX
True and False and the logical connectives in Z map directly into the corresponding HOL constants.
=SML
val	€mk_Ztrue› :TERM = mk_const("T",BOOL);
=TEX
=SML
val	€mk_Zfalse› :TERM = mk_const("F",BOOL);
=TEX
=SML
val	€mk_Z≥› :TERM -> TERM = mk_≥
	handle X => pass_on X "mk_≥" "mk_Z≥";
=TEX
=SML
val	€mk_Z±› :(TERM * TERM) -> TERM = mk_±
	handle X => pass_on X "mk_±" "mk_Z±";
=TEX
=SML
val	€mk_Z≤› :(TERM * TERM) -> TERM = mk_≤
	handle X => pass_on X "mk_≤" "mk_Z≤";

=TEX
=SML
val	€mk_Z¥› :(TERM * TERM) -> TERM = mk_¥
	handle X => pass_on X "mk_¥" "mk_Z¥";

=TEX
=SML
val	€mk_Z§› :(TERM * TERM) -> TERM = mk_§
	handle X => pass_on X "mk_§" "mk_Z§";

=TEX
=SML
fun	€mk_Z∂› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		mk_app(∂_bterm itym,g2_abs(d,p,v,itym))
	end
	handle X => reraise X "mk_Z∂";
=TEX
=SML
fun	€mk_Z∂â1› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		mk_app(∂â1_bterm itym,g2_abs(d,p,v,itym))
	end
	handle X => reraise X "mk_Z∂â1";
=TEX
=SML
fun	€mk_Zµ› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		mk_app(µ_bterm itym,g2_abs(d,p,v,itym))
	end
	handle X => reraise X "mk_Zµ";
=TEX
=SML
fun	€mk_Zpredsexp› ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_≠_type(mk_∏_type(bty,sty),BOOL);
		val con = mk_const("Z'predsexp",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;
=TEX
\subsection{Term Constructors}
=SML
fun	€mk_Zß¢› ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val seqty = mk_ZpowerT(mk_ZtupleT[mk_ZgivenT "˙",ty]);
		val zseqty = mk_≠_type(listy,seqty);
		val zseq = mk_const("Z'ß¢",zseqty);
	in
		case tml of 
			[] => mk_app(zseq,mk_empty_list ty)
		|	_ => mk_app(zseq,mk_list tml)
	end;
=TEX
=SML
fun	€mk_Zsetd› ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val setty = mk_ZpowerT ty;
		val zsetty = mk_≠_type(listy,setty);
		val zset = mk_const("Z'setd",zsetty);
	in
		case tml of 
			[] => mk_app(zset,mk_empty_list ty)
		|	_ => mk_app(zset,mk_list tml)
	end;
=TEX
=SML
fun	€mk_Zseta› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
		val vty = type_of v;
	in
		mk_app (seta_bterm itym vty, g2_abs(d,p,v,itym))
	end;
=TEX
$mk\_Z$ only makes sense if its argument is a set, but we do not bother to check that here, since the type checker should catch this kind of thing and the definition of the constant $Z$ will prevent us from doing any damage.
=SML
fun	€mk_Z› (tm:TERM) :TERM = 
	let	val ty = type_of tm;
		val psetty = mk_ZpowerT ty;
		val zpsetty = mk_≠_type(ty,psetty);
		val zpset = mk_const("Z'",zpsetty);
	in
		mk_app(zpset,tm)
	end;
=TEX
=SML
fun	€mk_Ztuple› (tml:TERM list) :TERM = 
	let	val tyl = map type_of tml;
	in
		list_mk_app(tuple_cterm tyl,tml)
	end;
=TEX
=SML
fun	€mk_Z∏› (tml:TERM list) :TERM = 
	let	val tyl = map (dest_ZpowerT o type_of) tml;
	in
		list_mk_app(prod_cterm tyl,tml)
	end;
=TEX
=SML
fun	€mk_Z › ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_≠_type(mk_∏_type(bty,sty),bty);
		val con = mk_const("Z' ",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;
=TEX
=SML
fun	€mk_Zsel› ((tm,s):TERM * string) :TERM = 
	let	val tym = dest_ZschemaT(type_of tm);
	in
		mk_app(bind_pterm tym s,tm)
	end;
=TEX
=SML
fun	€mk_Zapp› ((tm1,tm2):TERM * TERM) :TERM = 
	let	val fty = type_of tm1;
		val aty = type_of tm2;
		val rty = 
			case dest_ZtupleT(dest_ZpowerT fty) of
				[_,r] => r
			|	_ => term_fail "mk_Zapp" 0 [];
		val zappty = mk_≠_type(mk_∏_type(fty,aty),rty);
		val zapp = mk_const("Z'app",zappty);
	in
		mk_app(zapp,mk_pair(tm1,tm2))
	end;
=TEX
=SML
local
fun	f ([]:ZTERM list) :TERM list = []
|	f (Zdec(tml,_)::ztml) = tml @ (f ztml)
|	f (Zdecsexp(sch,d)::ztml) = (mk_Z (sch,d)) :: (f ztml)
|	f _ = term_fail "mk_ZÃ" 0 [];
fun	chartuple ((Zdecl tml):ZTERM) :TERM = (
		case (f (map dest_ZTERM tml)) of
			[] => fail "mk_ZÃ" 0 []
		|	[tm] => tm
		|	tml' => mk_Ztuple tml'
		)
|	chartuple _ = fail "mk_ZÃ" 0 [];
in
fun	€mk_ZÃ› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val t = chartuple(dest_ZTERM d);
		val tym = dest_decl d;
		val tty = type_of t;
		val vty = type_of v;
	in
		mk_app(Ã_bterm tym tty vty,g3_abs(t,d,p,v,tym))
	end
	handle	Fail _ => term_fail "mk_ZÃ" 47201 [d,p,v]
end;
=TEX
=SML
fun	€mk_ZÕ› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val tym = dest_decl d;
		val vty = type_of v;
	in
		mk_app(Õ_bterm tym vty,g2_abs(d,p,v,tym))
	end;
=TEX
=SML
fun	€mk_Zlvar› ((s,ty,tml):string * TYPE * TERM list) :TERM = 
		case tml of [] 	=> mk_var(s,ty)
		| _		=> 
			let	val cty = mk_≠_type(mk_ZtupleT(map type_of tml),ty);
			in
				mk_app(mk_var(s,cty),mk_Ztuple tml)
			end;
=TEX
=SML
fun	€mk_Zgvar› ((s,ty,tml):string * TYPE * TERM list) :TERM =
		case tml of [] 	=> mk_const(s,ty)
		| _		=> 
			let	val cty = mk_≠_type(mk_ZtupleT(map type_of tml),ty);
			in
				mk_app(mk_const(s,cty),mk_Ztuple tml)
			end;
=TEX
=SML
fun	€mk_Zint› (s:string) :TERM = 
	let	val nty = mk_ctype("Ó",[]);
		val zty = mk_ctype("˙",[]);
		val zint = mk_const("Z'int",mk_≠_type(nty,zty));
	in
		mk_app(zint,mk_const(s,nty))
	end;
=TEX
\subsection{Constructors for the Schema Calculus}
=SML
fun	€mk_Zâs› ((d,p):TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
	in
		mk_app (schema_bterm itym, g1_abs(d,p,itym))
	end;
=TEX
=SML
fun	€mk_Zdecâs› ((tm,s):TERM * string) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_decor_term tym s,tm)
	end;
=TEX
=SML
fun	€mk_Zpreâs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_pre_term tym,tm)
	end;
=TEX
=SML
fun	€mk_Z≥âs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_≥_term tym,tm)
	end;
=TEX
=SML
fun	€mk_Z±âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_±_term tym1 tym2,[tm1,tm2])
	end;
=TEX
=SML
fun	€mk_Z≤âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_≤_term tym1 tym2,[tm1,tm2])
	end;
=TEX
=SML
fun	€mk_Z¥âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_¥_term tym1 tym2,[tm1,tm2])
	end;
=TEX
=SML
fun	€mk_Z§âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_§_term tym1 tym2,[tm1,tm2])
	end;
=TEX
=SML
fun	€mk_Z˘âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_˘_term tym1 tym2,[tm1,tm2])
	end;
=TEX
=SML
fun	€mk_Zhideâs› ((tm,sl):TERM * string list) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_hide_term tym sl,tm)
	end;
=TEX
=SML
fun	€mk_Z∂âs› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(∂âs_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;
=TEX
=SML
fun	€mk_Z∂â1âs› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(∂â1âs_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;
=TEX
=SML
fun	€mk_Zµâs› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(µâs_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;
=TEX
=SML
fun	€mk_ZÑâs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_Ñ_term tym,tm)
	end;
=TEX
=SML
fun	€mk_Zòâs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_ò_term tym,tm)
	end;
=TEX
=SML
fun	€mk_Zªâs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_ª_term tym1 tym2,[tm1,tm2])
	end;
=TEX
=SML
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $ZTERM$ to the corresponding $TERM$.
=SML
fun	€mk_ZTERM›	(Zdec(tml:TERM list,tm:TERM) :ZTERM) :TERM = mk_Zdec(tml,tm)
|	mk_ZTERM	(Zdecsexp(tm:TERM,s:string)) = mk_Zdecsexp(tm,s)
|	mk_ZTERM	(Zdecl(tml:TERM list)) = mk_Zdecl tml
|	mk_ZTERM	(Zeq(tm1:TERM,tm2:TERM)) = mk_Zeq(tm1,tm2)
|	mk_ZTERM	(Zç(tm1:TERM,tm2:TERM)) = mk_Zç(tm1,tm2)
|	mk_ZTERM	(Ztrue) = mk_Ztrue
|	mk_ZTERM	(Zfalse) = mk_Zfalse
|	mk_ZTERM	(Z≥(tm:TERM)) = mk_Z≥ tm
|	mk_ZTERM	(Z±(tm1:TERM,tm2:TERM)) = mk_Z±(tm1,tm2)
|	mk_ZTERM	(Z≤(tm1:TERM,tm2:TERM)) = mk_Z≤(tm1,tm2)
|	mk_ZTERM	(Z¥(tm1:TERM,tm2:TERM)) = mk_Z¥(tm1,tm2)
|	mk_ZTERM	(Z§(tm1:TERM,tm2:TERM)) = mk_Z§(tm1,tm2)
|	mk_ZTERM	(Z∂(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂(tm1,tm2,tm3)
|	mk_ZTERM	(Z∂â1(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂â1(tm1,tm2,tm3)
|	mk_ZTERM	(Zµ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zµ(tm1,tm2,tm3)
|	mk_ZTERM	(Zpredsexp(tm:TERM,s:string)) = mk_Zpredsexp(tm,s)
|	mk_ZTERM	(Zlvar(s:string,ty:TYPE,tml:TERM list)) = mk_Zlvar(s,ty,tml)
|	mk_ZTERM	(Zgvar(s:string,ty:TYPE,tml:TERM list)) = mk_Zgvar(s,ty,tml)
|	mk_ZTERM	(Zint(s:string)) = mk_Zint(s)
|	mk_ZTERM	(Zß¢(ty:TYPE,tml:TERM list)) = mk_Zß¢(ty,tml)
|	mk_ZTERM	(Zsetd(ty:TYPE,tml:TERM list)) = mk_Zsetd(ty,tml)
|	mk_ZTERM	(Zseta(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zseta(tm1,tm2,tm3)
|	mk_ZTERM	(Z(tm:TERM)) = mk_Z tm
|	mk_ZTERM	(ZT(tml:TERM list)) = mk_Ztuple tml
|	mk_ZTERM	(Z∏(tml:TERM list)) = mk_Z∏ tml
|	mk_ZTERM	(Z (tm:TERM,s:string)) = mk_Z (tm,s)
|	mk_ZTERM	(Zsel(tm:TERM,s:string)) = mk_Zsel(tm,s)
|	mk_ZTERM	(Zapp(tm1:TERM,tm2:TERM)) = mk_Zapp(tm1,tm2)
|	mk_ZTERM	(ZÃ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_ZÃ(tm1,tm2,tm3)
|	mk_ZTERM	(ZÕ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_ZÕ(tm1,tm2,tm3)
|	mk_ZTERM	(Zâs(tm1:TERM,tm2:TERM)) = mk_Zâs(tm1,tm2)
|	mk_ZTERM	(Zdecâs(tm:TERM,s:string)) = mk_Zdecâs(tm,s)
|	mk_ZTERM	(Zpreâs(tm:TERM)) = mk_Zpreâs tm
|	mk_ZTERM	(Z≥âs(tm:TERM)) = mk_Z≥âs tm
|	mk_ZTERM	(Z±âs(tm1:TERM,tm2:TERM)) = mk_Z±âs(tm1,tm2)
|	mk_ZTERM	(Z≤âs(tm1:TERM,tm2:TERM)) = mk_Z≤âs(tm1,tm2)
|	mk_ZTERM	(Z¥âs(tm1:TERM,tm2:TERM)) = mk_Z¥âs(tm1,tm2)
|	mk_ZTERM	(Z§âs(tm1:TERM,tm2:TERM)) = mk_Z§âs(tm1,tm2)
|	mk_ZTERM	(Z˘âs(tm1:TERM,tm2:TERM)) = mk_Z˘âs(tm1,tm2)
|	mk_ZTERM	(Zhideâs(tm:TERM,sl:string list)) = mk_Zhideâs(tm,sl)
|	mk_ZTERM	(Z∂âs(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂âs(tm1,tm2,tm3)
|	mk_ZTERM	(Z∂â1âs(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂â1âs(tm1,tm2,tm3)
|	mk_ZTERM	(Zµâs(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zµâs(tm1,tm2,tm3)
|	mk_ZTERM	(ZÑâs(tm:TERM)) = mk_ZÑâs tm
|	mk_ZTERM	(Zòâs(tm:TERM)) = mk_Zòâs tm
|	mk_ZTERM	(Zªâs(tm1:TERM,tm2:TERM)) = mk_Zªâs(tm1,tm2);
=TEX
Finally, we leave the structure open.
=SML
end (* of structure ZTypesAndTerms *);
open ZTypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

val d1 = mk_Zdecl[mk_Zdec([mk_var("a",mk_ZgivenT"A"),mk_var("x",mk_ZgivenT"A")],mk_var("A",mk_ZpowerT(mk_ZgivenT"A")))];
val p1 = mk_Ztrue;
val sch1 = mk_Zâs(d1,p1);
val d2 = mk_Zdecl[mk_Zdec([mk_var("y",mk_ZgivenT"B"),mk_var("b",mk_ZgivenT"B")],mk_var("B",mk_ZpowerT(mk_ZgivenT"B")))];
val p2 = mk_Ztrue;
val sch2 = mk_Zâs(d2,p2);
val d3 = mk_Zdecl[mk_Zdecsexp(sch1,"'"),mk_Zdecsexp(sch2,"")];
val p3 = mk_Ztrue;
val sch3 = mk_Zâs(d3,p3);



val x = mk_Zlvar("x",mk_ZgivenT "A",[]);
val y = mk_Zlvar("y",mk_ZgivenT "A",[]);
val X = mk_Zlvar("X",mk_ZpowerT(mk_ZgivenT "A"),[]);
val Y = mk_Zlvar("Y",mk_ZpowerT(mk_ZgivenT "B"),[]);
val eq = mk_Zeq(x,y);
val mm = mk_Zç(x,X);

val f = mk_Z∏[X,Y];

val zd = mk_const("Z'Ã",mk_≠_type(BOOL,BOOL));
val tm = mk_app(zd,p1);



