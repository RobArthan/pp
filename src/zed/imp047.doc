% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$

doctex imp047 ; texdvi imp047
bibtex imp047

=TEX
% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP047}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.19 (\TPPdate{\FormatDate{92/03/03}})]
First draft version.

\item [Issue 1.20 to 1.31]
	Restructure function $dest\_z\_term$ to meet the needs of the
	pretty printer.  This is done by adding function
	$basic\_dest\_z\_term$ to do the actual destruction or production
	of error message arguments, this function is used by
	$dest\_z\_term$ and by the pretty printer. Changed handling for naming of
	projection functions (including a change to the interface of
	dest\_z\_name).
\item [Issue 1.32 (July 16th 1992)]
Added support for schema renaming.
$dest\_z\_name$ given protection from subscripted punctuation. 
\item [Issue 1.33] Added binding display.
\item [Issue 1.34 (July 28th 1992)]
Corrected $Ê$ stuff.
Removed local definition of $list\_mk\_­\_type$
\item[Issue 1.37 (30th July 1992)]
Corrected a bug in $mk\_z\_binding$.
\item[Issue 1.38 (31st July 1992)]
Removed redundant code of $split\_on\_bar$.
\item [Issue 1.39 (13th August 1992)]
Corrected error handling for interrupts.
\item [Issue 1.40 (9th September 1992)]
Added some necessary brackets for error handlers.
\item [Issue 1.41]
	Added treatment of $U$ and binding of global variables.
\item [Issue 1.42 (13th November 1992)]
Corrected $mk\_u$ et al.
\item[Issue 1.43  (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\end{description}
%\subsection{Changes Forecast}
\newpage
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the constructor, discriminator and destructor functions corresponding to the primitive constructors of Z.
The detailed design of these is found in \cite{DS/FMU/IED/DTD047}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives the implementation of the functions mentioned above.
Additional functions, which are used in other parts of the Z system, may also be included here for convenience.
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
(The constructors might be bypassed entirely and the HOL constructors
used to generate terms with the names of Z~constants.) Such terms must
be handled by the pretty printer~\cite{DS/FMU/IED/DTD031} in a way that allows them to
be read back by the HOL and Z parsers and generate a term with the same
meaning.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intecepted and reported as helpfully as possible.
\section{STRUCTURE PREAMBLE}
=SML
structure ÛZTypesAndTermsİ : ZTypesAndTerms = struct
=TEX
We open the structure containing the support package (see \cite{DS/FMU/IED/IMP048}).
=SML
open ZTypesAndTermsSupport;
=TEX
\section{AUXILIARY FUNCTIONS}
\subsection{Name Destruction}
We need the inverse of the name construction functions (defined in
\cite{DS/FMU/IED/DTD048}).  Given a name formed as a simple identifier
followed by a sequence of name lists with each name list in square
brackets function $dest\_z\_name$ returns the identifier name plus a
list of lists.  Thus a name like

=GFT
	"abc[de,fg,hi][jk,lm][no][p,r,s]"
=TEX

is split into the following pieces

=GFT
	("abc",
	[	["de", "fg", "hi"],
		["jk", "lm"],
		["no"],
		["p", "r", "s"]
	], Nil)
=TEX

Projections are of the form
=GFT
	"abc[de,fg,hi]jk"
=TEX

which is split into the following:

=GFT
	("abc",
	[	["de", "fg", "hi"]
	], Value "jk")
=TEX


Function $dest\_z\_name$ splits up well formed names by interpreting the
square brackets and commas, it complains about mal-formed names.

The implementation of function $dest\_z\_name$ merits some discussion.
Their intention is to split a Z~identifier into its component pieces
whilst detecting malformed Z~identifiers.  The first stage, in function
$hide\_subscripts$, is to split the identifier into its component
augmented characters, where an augmented character includes any
subscripting.  Function $get\_id$ extracts any leading name then
function $aux$ does the main work of splitting at square brackets and
commas.  It has three arguments: (1)~the unprocessed characters of the
identifier; (2)~details of the `current' pair of square brackets; and
(3)~information from previous pairs of square brackets.  Argument
(2)~is $Nil$ before opening and after square brackets between them it
is a pair of values comprising: (2.1)~the characters of the current
name; and (2.2)~a list of the previous comma separated names.

=SML
local
	exception bad_name;

	fun	addnam (nil:string list) (cl:string list)
			: string list = cl
	|	addnam n cl = (implode(rev n)) :: cl
	;

	fun	get_id(nil, prev) = (nil, prev)
	|	get_id(l as ("["::_ (*=]=*)), prev) = (l, prev)
	|	get_id(","::t, _) = raise bad_name
	|	get_id((*=[=*) "]"::t, _) = raise bad_name
	|	get_id(ch::t, prev) = get_id(t, ch :: prev)
	;

	fun	aux(nil, Value _, _) = raise bad_name
	|	aux(nil, Nil, pl) = (rev pl, Nil)

	|	aux("["::t (*=]=*), Value _, _) = raise bad_name
	|	aux("["::t (*=]=*), Nil, pl) = aux(t, Value(nil, nil), pl)

	|	aux(","::t, Nil, _) = raise bad_name
	|	aux(","::t, Value(cn, cl), pl) = aux(t, Value(nil, addnam cn cl), pl)

	|	aux((*=[=*) "]"::t, Nil, _) = raise bad_name
	|	aux((*=[=*) "]"::t, Value(cn, cl), pl) = aux(t, Nil, (rev(addnam cn cl)) :: pl)

	|	aux(l as(ch::t), Nil, pl) = (
			case get_id(l, nil)
			of (nil, nam) => (rev pl, Value(implode(rev nam)))
			| _ => raise bad_name
		)
	|	aux(ch::t, Value(cn, cl), pl) = aux(t, Value(ch::cn, cl), pl);
=SMLLITERAL	
	fun	hide_subscripts(nil, prev) = rev prev
	|	hide_subscripts(_::"‰"::"‰" :: _, _) = raise bad_name
	|	hide_subscripts(_::"‰"::nil, _) = raise bad_name
	|	hide_subscripts(c1::"‰"::c2::t, prev) = hide_subscripts((c1^"‰"^c2)::t, prev)
	|	hide_subscripts(c::t, prev) = hide_subscripts(t, c::prev)
	;
=SML
in
fun	Ûdest_z_nameİ (s:string) :string * string list list * string OPT = (
let		val (tail, front) = get_id(hide_subscripts(explode s, nil),nil);
		val (boxed_lists, projector) = aux(tail, Nil, nil);
in
		(implode(rev front), boxed_lists, projector)
end
handle Fail _ => fail "dest_z_name" 47000 [fn () => s]
| bad_name => fail "dest_z_name" 47000 [fn () => s]
);
end;
=TEX
The following function tests for multiple occurrences of a string in a list
of same.
=SML
fun moccurs (area : string) (msg : int) (a :: x : string list) : unit = (
	if	a mem x
	then	fail area msg [fn () => a]
	else	moccurs area msg x
) | moccurs _ _ [] = ();

=TEX
\section{Z TYPES}
The following sections describe the constructor, discriminator and destructor functions for each of the five Z type constructors.
\subsection{The Datatype $Z\_TYPE$}

The general mapping functions $mk\_z\_type$, $is\_z\_type$ and
$dest\_z\_type$, which are declared later in this document, use this
datatype.

=SML
datatype	ÛZ_TYPEİ = 	ÛZGivenTypeİ of string
		|		ÛZVarTypeİ of string
		|		ÛZPowerTypeİ of TYPE
		|		ÛZTupleTypeİ of TYPE list
		|		ÛZSchemaTypeİ of (string * TYPE) list;
=TEX
\subsection{The General Destructor Function}
This function converts a HOL type to the appropriate form of the above datatype (providing, of course, that it represents a valid Z type).
=SML
fun	Ûdest_z_typeİ (ty:TYPE) :Z_TYPE =
	case dest_simple_type ty of
		Vartype s => (
			case explode s of
				("'"::t) => ZVarType(implode t)
			|	_ => fail "" 0 []
		)
	|	Ctype("SET",[ty1]) => ZPowerType ty1
	|	Ctype(s,tyl) => (
			case (dest_z_name s,tyl) of
				(("Z'T",[[n]], Nil),tyl) => 
					if string_of_int(length tyl) = n
					then ZTupleType tyl
					else fail "" 0 []
			|	(("Z'S",[cl], Nil),tyl) => 
					ZSchemaType(combine cl tyl)
			|	(_,[]) => ZGivenType s
			|	_ => fail "" 0 []
		)
	handle Fail _ => type_fail "dest_z_type" 47800 [ty];
=TEX
\subsection{The General Discriminator Function}
=SML
fun	Ûis_z_typeİ (t:TYPE) :bool =
	let	val x = dest_z_type t
	in
		true
	end
	handle Fail _ => false;
=TEX
\subsection{Given Sets}
=SML
fun	Ûmk_z_given_typeİ (s:string) :TYPE = mk_ctype(s,[]);

fun	Ûis_z_given_typeİ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		ZGivenType _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_given_typeİ (ty :TYPE) :string = (
	case dest_z_type ty of
		ZGivenType s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_given_type" 47010 [ty];
=TEX
\subsection{Generic Variables}
=SML
fun	Ûmk_z_var_typeİ (s:string) :TYPE = mk_vartype("'" ^ s);

fun	Ûis_z_var_typeİ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		ZVarType _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_var_typeİ (ty :TYPE) :string = (
	case dest_z_type ty of
		ZVarType s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_var_type" 47020 [ty];
=TEX
\subsection{Set Types}
=SML
fun	Ûmk_z_power_typeİ (ty:TYPE) :TYPE = mk_ctype("SET",[ty]);

fun	Ûis_z_power_typeİ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		ZPowerType _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_power_typeİ (ty :TYPE) :TYPE = (
	case dest_z_type ty of
		ZPowerType t => t
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_power_type" 47030 [ty];
=TEX
\subsection{Cartesian Product Types}
=SML
fun	Ûmk_z_tuple_typeİ (tyl:TYPE list) :TYPE = 
		tuple_type tyl;

fun	Ûis_z_tuple_typeİ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		ZTupleType _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_tuple_typeİ (ty :TYPE) :TYPE list = (
	case dest_z_type ty of
		ZTupleType tyl => tyl
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_tuple_type" 47040 [ty];
=TEX
\subsection{Binding Types}
=SML
fun	Ûmk_z_schema_typeİ (itym:(string * TYPE) list) :TYPE =
		bind_type itym;

fun	Ûis_z_schema_typeİ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		ZSchemaType _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_schema_typeİ (ty :TYPE) :(string * TYPE) list = (
	case dest_z_type ty of
		ZSchemaType itym => itym
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_schema_type" 47050 [ty];
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $Z\_TERM$ to the corresponding $TERM$.
=SML
fun	Ûmk_z_typeİ	(ZGivenType(s:string) :Z_TYPE) :TYPE = mk_z_given_type s
|	mk_z_type	(ZVarType(s:string)) = mk_z_var_type s
|	mk_z_type	(ZPowerType(ty:TYPE)) = mk_z_power_type ty
|	mk_z_type	(ZTupleType(tyl:TYPE list)) = mk_z_tuple_type tyl
|	mk_z_type	(ZSchemaType(itym:(string * TYPE)list)) = mk_z_schema_type itym;
=TEX
\section{Z TERMS}
The following describes the constructor, discriminator and destructor functions for Z terms.
\subsection{The Datatype Z\_TERM}

The general mapping functions $mk\_z\_term$, $is\_z\_term$ and
$dest\_z\_term$, which are declared later in this document, use this
datatype.

=SML
datatype	ÛZ_TERMİ
		=	 	ÛZDecİ of TERM list * TERM
		|		ÛZSchemaDecİ of TERM * string
		|		ÛZDeclİ of TERM list
		|		ÛZEqİ of TERM * TERM
		|		ÛZİ of TERM * TERM
		|		ÛZTrueİ
		|		ÛZFalseİ
		|		ÛZ³İ of TERM
		|		ÛZ±İ of TERM * TERM
		|		ÛZ²İ of TERM * TERM
		|		ÛZ´İ of TERM * TERM
		|		ÛZ¤İ of TERM * TERM
		|		ÛZ¶İ of TERM * TERM * TERM
		|		ÛZ¶‰1İ of TERM * TERM * TERM
		|		ÛZµİ of TERM * TERM * TERM
		|		ÛZSchemaPredİ of TERM * string
		|		ÛZLVarİ of string * TYPE * TERM list
		|		ÛZGVarİ of string * TYPE * TERM list
		|		ÛZIntİ of string
		|		ÛZStringİ of string
		|		ÛZ§¢İ of TYPE * TERM list
		|		ÛZSetdİ of TYPE * TERM list
		|		ÛZSetaİ of TERM * TERM * TERM
		|		ÛZğİ of TERM
		|		ÛZTupleİ of TERM list
		|		ÛZBindingİ of (string * TERM) list
		|		ÛZ¸İ of TERM list
		|		ÛZÊİ of TERM * string
		|		ÛZSel‰sİ of TERM * string
		|		ÛZSel‰tİ of TERM * int
		|		ÛZAppİ of TERM * TERM
		|		ÛZÌİ of TERM * TERM * TERM
		|		ÛZÍİ of TERM * TERM * TERM
		|		ÛZHSchemaİ of TERM * TERM
		|		ÛZDecor‰sİ of TERM * string
		|		ÛZPre‰sİ of TERM
		|		ÛZ³‰sİ of TERM
		|		ÛZ±‰sİ of TERM * TERM
		|		ÛZ²‰sİ of TERM * TERM
		|		ÛZ´‰sİ of TERM * TERM
		|		ÛZ¤‰sİ of TERM * TERM
		|		ÛZù‰sİ of TERM * TERM
		|		ÛZHide‰sİ of TERM * string list
		|		ÛZ¶‰sİ of TERM * TERM * TERM
		|		ÛZ¶‰1‰sİ of TERM * TERM * TERM
		|		ÛZµ‰sİ of TERM * TERM * TERM
		|		ÛZ„‰sİ of TERM
		|		ÛZ˜‰sİ of TERM
		|		ÛZ»‰sİ of TERM * TERM
		| 		ÛZRename‰sİ of TERM * (string * string) list
		;
=TEX

\subsection{Result of Basic Destructor Function}

This function converts a HOL term to the appropriate form of the
datatype $Z\_TERM$, or to an encoding of why it could not be converted.
The encoded failure value is intended for use by the pretty
printer~\cite{DS/FMU/IED/DTD031,DS/FMU/IED/DTD064}, it contains values
showing how (in some cases) the term might be HOL if it were modified
slightly.  The return value from the basic destructor function is
in type $BDZ$ (named for `Basic Destroy Z').

=SML
datatype ÛBDZİ
	=	ÛBdzOkİ	of Z_TERM
	|	ÛBdzNotZİ	of int
	|	ÛBdzFailİ	of {
			ÛBdzFCodeİ	: int,
			ÛBdzFCompcİ	: int,
			ÛBdzFArgcİ	: int
		}
	;
=TEX

Successful destruction returns $BdzOk$ with the Z term.  Value
$BdzFail$ is returned when the term is similar to a Z~term (i.e., it
has a known constructor but the wrong number of arguments).  In this
case the $BdzFCompc$ and $BdzFArgc$ fields tell how many component
lists and arguments (respectively) are allowed in a well formed
Z~term.  Value $BdzNotZ$ is returned when the term is not
recognisable as a Z~term.  In cases where insufficient component lists
or arguments are given to a known constructor either $BdzFail$ or
$BdzNotZ$ may be returned.

\subsection{Destructor Utilities}

=SML
fun Ûzdest_0_0İ(nil, nil, _, v) = BdzOk v
| zdest_0_0(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_1_gt0İ(_, nil, e, _) = BdzNotZ 47900
| zdest_1_gt0(_::_, a, _, v) = BdzOk(v a)
| zdest_1_gt0(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_0_1İ(nil, [x], _, v) = BdzOk(v x)
| zdest_0_1 (_, _::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=0, BdzFArgc=1}
| zdest_0_1(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_0_2İ(nil, [x, y], _, v) = BdzOk(v(x,y))
| zdest_0_2 (_, _::_::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=0, BdzFArgc=2}
| zdest_0_2(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_1_1İ([_], [x], _, v) = BdzOk(v x)
| zdest_1_1 (_, _::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=1, BdzFArgc=1}
| zdest_1_1(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_2_2İ([_, _], [x, y], _, v) = BdzOk(v(x, y))
| zdest_2_2 (_, _::_::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=2, BdzFArgc=2}
| zdest_2_2(_, _, e, _) = BdzNotZ 47900
;
=IGN
fun Ûzdest_gt0_0İ(nil, nil, e, _) = BdzNotZ 47900
| zdest_gt0_0(_, nil, _, v) = BdzOk v
| zdest_gt0_0(_, _, e, _) = BdzNotZ 47900
;
=TEX

=SML
fun Ûdest_val_tupleİ(name:string, ty: TYPE, constr:string * TYPE * TERM list -> Z_TERM,
		arg_tm:TERM, e:int) : BDZ = (
	let
		val (arg_fn, args) = strip_app arg_tm;
		val (arg_name, arg_ty) = dest_const arg_fn;
	in
		case dest_z_name arg_name
		of ("Z'Mk_T", [_], Nil) =>
			BdzOk(constr(name, snd(dest_­_type ty), args))
		| _ =>
			BdzFail{BdzFCode=e,
				BdzFCompc=0, BdzFArgc=0}
	end
	handle Fail _ =>
		BdzFail{BdzFCode=e, BdzFCompc=0, BdzFArgc=0}
);
=TEX

=SML
fun	Ûdest_abstractionİ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_Ì t)))
	handle Fail _ => term_fail "dest_z_term" 47901 [t];
=TEX

=SML
fun	Ûdest_¶bodyİ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_¶ t)))
	handle Fail _ => term_fail "dest_z_term" 47901 [t];
=TEX

=SML
fun	Ûdest_µbodyİ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_µ t)))
	handle Fail _ => term_fail "dest_z_term" 47901 [t];
=TEX
$split\_on\_bar$ undoes the encoding of two identifers as one
string, and is found in \cite{DS/FMU/IED/DTD048}.
=SML
fun Ûzdest_renameİ(comp_list, args, n, v) = (
	if length comp_list = 2 
	then if length args = 1
		then (let val a2 = map split_on_bar (hd(tl comp_list))
		in
		BdzOk (v(hd args, a2))
		end
		handle (Fail _) =>
		BdzFail{BdzFCode=n, BdzFCompc=2, BdzFArgc=1})
		else BdzFail{BdzFCode=n, BdzFCompc=2, BdzFArgc=1}
	else BdzNotZ 47900
);
=TEX	
\subsection{The Basic Destructor Function}

Function $basic\_dest\_z\_term$ does the work of destroying a term to
yield its Z~structure.  The arguments are in the result of applying
$strip\_app$ to a term.  (This parameterisation is of benefit to the
pretty printer~\cite{DS/FMU/IED/DTD031}.)

The main part of this function is a large case clause which switches
depending on the name of the constant at the head of the stripped
application, the other cases are simple and dealt with in the
immedaitely following block of code.

=SML
fun Ûbasic_dest_z_termİ (hdterm:TERM, args:TERM list) : BDZ = (
	case dest_simple_term hdterm
	of App _ => BdzNotZ 47900
	| SimpleÌ _ => BdzNotZ 47900
	| Var (name, ty) => (
		case args
		of nil => BdzOk(ZLVar(name, ty,[]))
		| [tm] => dest_val_tuple(name, ty, ZLVar, tm, 47090)
		| _ => BdzFail{BdzFCode=47090,
				BdzFCompc=0, BdzFArgc=1}
	)
	| Const (name, ty) => (
		let
			val (identifier, comp_list, projector) = dest_z_name name;
		in
			case (identifier, projector) of
			("Z'S", Value s) => (
				case args of
				[x] => BdzOk(ZSel‰s(x,s))
				| _ => BdzFail{BdzFCode=47180, BdzFCompc=2,
								BdzFArgc=1}
				)
			|("Z'T", Value s) => (
				case args of
				[x] => BdzOk(ZSel‰t(x,nat_of_string s))
				| _ => BdzFail{BdzFCode=47185, BdzFCompc=2,
								BdzFArgc=1}
				)
			| (x, Nil) => (
				case identifier
=TEX


The $case$ clause started on the line above opens up the Z~term based
on the names of the constant.  The various options are catered for in
the following sections, the end of the function is in
section~\ref{EndOfFunctionBDZ}.

=TEX

\subsubsection{Declarations}
First we look for declarations, beginning with variables.
=SML
of "Z'Dec" => (
	case (comp_list, args)
	of ([],[x]) => (
		BdzOk(ZDec((dest_list ** Combinators.I)(dest_pair x)))
		handle Fail _ => BdzNotZ 47900
	)
	| _ => BdzFail{BdzFCode=47910, BdzFCompc=0, BdzFArgc=1}
)
=TEX
Then schema declarations.
=SML
| "Z'SchemaDec" => (
	case (comp_list, args)
	of ([],[bind, sch]) => (
		let	val btym = map dest_var (snd(strip_app bind));
			val stym = dest_z_schema_type(dest_z_power_type(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			BdzOk(ZSchemaDec(sch,d))
		end
		handle Fail _ => BdzNotZ 47911
		)
	| _ => BdzFail{BdzFCode=47911, BdzFCompc=0, BdzFArgc=1}
)
=TEX
And composite declarations.
Note that all declarations used in other constructs must be of this
form, even if only one of the above forms is used (it is even possible
to have an empty declaration under certain circumstances).
=SML
| "Z'Decl" => (
	case (comp_list, args)
	of ([],[x]) => (
		BdzOk(ZDecl(dest_list x))
		handle Fail _ => BdzNotZ 47912
	)
	| _ => BdzFail{BdzFCode=47912, BdzFCompc=0, BdzFArgc=1}
)
=TEX
\subsubsection{Predicates}

The logical connectives, `true' and `false', map directly on to the
equivalent HOL constants.

=SML
| "T"	=> zdest_0_0(comp_list, args, 47900, ZTrue)
| "F"	=> zdest_0_0(comp_list, args, 47900, ZFalse)
=TEX

Equality and equivalence both use the HOL `$=$' constant, they are distinguished by the
types of their operands.  Equivalence has both arguments of type $BOOL$.

=IGN
| "="	=> zdest_0_2(comp_list, args, 47220, ZEq)
| "¤"	=> zdest_0_2(comp_list, args, 47280, Z¤)
=SML
| "="	=> (
	case (comp_list, args)
	of (nil,[x, y]) => (
		BdzOk(	(if type_of x =: BOOL andalso type_of y =: BOOL
			then Z¤
			else ZEq
			)(x,y)
		)
	)
	| (_, _::_::_::_) =>
		BdzFail{BdzFCode=47220, BdzFCompc=0, BdzFArgc=2}
	| _ => BdzNotZ 47900
)
=TEX

=SML
| ""	=> zdest_0_2(comp_list, args, 47230, Z)
| "³"	=> zdest_0_1(comp_list, args, 47240, Z³)
| "±"	=> zdest_0_2(comp_list, args, 47250, Z±)
| "²"	=> zdest_0_2(comp_list, args, 47260, Z²)
| "´"	=> zdest_0_2(comp_list, args, 47270, Z´)
=TEX
=SML
| "Z'¶" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_¶body x
		of	[d,p,v] => BdzOk(Z¶(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47920
	)
	| _ => BdzFail{BdzFCode=47920, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'¶‰1" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,v] => BdzOk(Z¶‰1(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47921
	)
	| _ => BdzFail{BdzFCode=47921, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'µ" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_µbody x of
			[d,p,v] => BdzOk(Zµ(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47922
	)
	| _ => BdzFail{BdzFCode=47922, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'SchemaPred" => (
	case (comp_list, args)
	of ([],[bind, sch]) => (
		let	val btym = map dest_var (snd(strip_app bind));
			val stym = dest_z_schema_type(dest_z_power_type(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			BdzOk(ZSchemaPred(sch,d))
		end
		handle Fail _ => BdzNotZ 47923
	)
	| _ => BdzFail{BdzFCode=47923, BdzFCompc=0, BdzFArgc=1}
)
=TEX
\subsubsection{Terms}

We must postpone the handling of local and global variables until the
end of the case clause because they do not have an easily identifiable
constant part.

=SML
| "Z'Int" => (
	case (comp_list, args)
	of ([],[tm]) => (
		BdzOk(ZInt(fst(dest_const tm)))
		handle Fail _ => BdzNotZ 47105
	)
	| _ => BdzFail{BdzFCode=47105, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'String" => (
	case (comp_list, args)
	of ([],[tm]) => (
		BdzOk(ZString(dest_string tm))
		handle Fail _ => BdzNotZ 47105
	)
	| _ => BdzFail{BdzFCode=47105, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'§¢" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_ctype(type_of x) of
			("LIST",[t]) => BdzOk(Z§¢(t,dest_list x))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47110
	)
	| _ => BdzFail{BdzFCode=47110, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Setd" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_ctype(type_of x) of
			("LIST",[t]) => BdzOk(ZSetd(t,dest_list x))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47120
	)
	| _ => BdzFail{BdzFCode=47120, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Seta" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,v] => BdzOk(ZSeta(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47130
	)
	| _ => BdzFail{BdzFCode=47130, BdzFCompc=1, BdzFArgc=1}
)
=TEX
=SML
| "Z'ğ"	=> zdest_0_1	(comp_list, args, 47140, Zğ)
| "Z'Mk_T"	=> zdest_1_gt0	(comp_list, args, 47150, ZTuple)
| "Z'Mk_S"	=> (
	case comp_list
	of [comps] => (
		(BdzOk(ZBinding(combine comps args)))
		handle Fail _ =>
		BdzFail{BdzFCode=47130, BdzFCompc=1, BdzFArgc=length comps}
	)
	| _ => BdzNotZ 47900
)
| "Z'¸"	=> zdest_1_gt0	(comp_list, args, 47160, Z¸)
=TEX
=SML
| "Z'Ê" => (
	case (comp_list, args)
	of ([],[bind,sch]) => (
		let	val btym = map dest_var (snd(strip_app bind));
			val stym = dest_z_schema_type(dest_z_power_type(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			BdzOk(ZÊ(sch,d))
		end
		handle Fail _ => BdzNotZ 47170
	)
	| _ => BdzFail{BdzFCode=47170, BdzFCompc=0, BdzFArgc=1}
)

=SML
| "Z'App"	=> zdest_0_2(comp_list, args, 47190, ZApp)
=TEX
=SML
| "Z'Ì" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,t,v] => BdzOk(ZÌ(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47200
	)
	| _ => BdzFail{BdzFCode=47200, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Í" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,v] => BdzOk(ZÍ(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47936
	)
	| _ => BdzFail{BdzFCode=47936, BdzFCompc=0, BdzFArgc=1}
)
=TEX
\subsubsection{Schemas}
=SML
| "Z'‰s" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(ZHSchema(d,p))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47940
	)
	| _ => BdzFail{BdzFCode=47940, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Dec‰s" => (
	case (comp_list, args)
	of ([_,[]],[x]) => BdzOk(ZDecor‰s(x,""))
	| ([_,[s]],[x]) => BdzOk(ZDecor‰s(x,s))
	| _ => BdzFail{BdzFCode=47340, BdzFCompc=1, BdzFArgc=1}
)
=TEX
=SML
| "Z'Pre‰s"	=> zdest_1_1(comp_list, args, 47350, ZPre‰s)
| "Z'³‰s"	=> zdest_0_1(comp_list, args, 47360, Z³‰s)
| "Z'±‰s"	=> zdest_2_2(comp_list, args, 47370, Z±‰s)
| "Z'²‰s"	=> zdest_2_2(comp_list, args, 47380, Z²‰s)
| "Z'´‰s"	=> zdest_2_2(comp_list, args, 47390, Z´‰s)
| "Z'¤‰s"	=> zdest_2_2(comp_list, args, 47400, Z¤‰s)
| "Z'ù‰s"	=> zdest_2_2(comp_list, args, 47410, Zù‰s)
=TEX
=SML
| "Z'Hide‰s" => (
	case (comp_list, args)
	of ([_,sl],[x]) => BdzOk(ZHide‰s(x,sl))
	| _ => BdzFail{BdzFCode=47420, BdzFCompc=2, BdzFArgc=1}
)
=TEX
=SML
| "Z'¶‰s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(Z¶‰s(d,p,y))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47941
	)
	| _ => BdzFail{BdzFCode=47941, BdzFCompc=2, BdzFArgc=2}
)
=TEX
=SML
| "Z'¶‰1‰s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(Z¶‰1‰s(d,p,y))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47942
	)
	| _ => BdzFail{BdzFCode=47942, BdzFCompc=2, BdzFArgc=2}
)
=TEX
=SML
| "Z'µ‰s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(Zµ‰s(d,p,y))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47943
	)
	| _ => BdzFail{BdzFCode=47943, BdzFCompc=2, BdzFArgc=2}
)
=TEX
=SML
| "Z'„‰s"	=> zdest_1_1(comp_list, args, 47460, Z„‰s)
| "Z'˜‰s"	=> zdest_1_1(comp_list, args, 47470, Z˜‰s)
| "Z'»‰s"	=> zdest_2_2(comp_list, args, 47480, Z»‰s)
| "Z'Rename‰s"	=> zdest_rename(comp_list, args, 47461, ZRename‰s)
	
=TEX
\subsubsection{Local and Global Variables}
=SML
| _ => (
	case (comp_list, args)
	of (nil, nil) => (
		(	case unbind_gvar_name name
			of n => BdzOk(ZGVar(n, ty,[]))
		) handle Fail _ => BdzNotZ 47100
		)
	| (nil, [tm]) => (
		(	case unbind_gvar_name name
			of n => dest_val_tuple(n, ty, ZGVar, tm, 47100)
		) handle Fail _ => BdzNotZ 47100
		)
	| _ => BdzFail{BdzFCode=47100, BdzFCompc=0, BdzFArgc=1}
)
=TEX

\subsubsection{End of the Basic Destructor Function}
\label{EndOfFunctionBDZ}

=SML
		)
		| (_, Value _) => BdzNotZ 47100
		end (* of let in case Const *)
	) (* end of case Const (name, ty) => ... *)
	(* end of case dest_simple_term hdterm ... *)
	handle (Fail _) => BdzNotZ 47100 
) (* end of function basic_dest_z_term *);
=TEX

\subsection{The General Z Destructor Function}

Function $dest\_z\_term$ provides the normal interface for
destroying arbitrary Z~terms.  

=SML
fun	Ûdest_z_termİ (t:TERM) :Z_TERM = (
let
	val bdz_ans = basic_dest_z_term (strip_app t);
(*	fun sh(s, v) = diag_string("dest_z_term: ans is " ^ s ^ " " ^ (string_of_int v)); *)
in
	case bdz_ans
	of BdzOk zt => zt
	| BdzNotZ e => term_fail "dest_z_term" e [t]
	| BdzFail{BdzFCode=e, ...} => term_fail "dest_z_term" e [t]
end
);
=TEX

\subsection{The General Z Discriminator Function}
=SML
fun	Ûis_z_termİ (t:TERM) :bool =
	let	val x = dest_z_term t
	in
		true
	end
	handle Fail _ => false;
=TEX
\section{Constructor, Destructor and Discriminator Functions}

\subsection{Declaration Destructors}
=SML
fun	Ûdest_z_decİ (t:TERM) :(TERM list * TERM) =
	(case dest_z_term t of
		ZDec(tml,tm) => (tml,tm)
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_dec" 47061 [t];

fun	Ûdest_z_schema_decİ (t:TERM) :TERM * string =
	(case dest_z_term t of
		ZSchemaDec(tm,s) => (tm,s)
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_schema_dec" 47071 [t];

fun	Ûdest_z_declİ (t:TERM) :TERM list =
	(case dest_z_term t of
		ZDecl tml => tml
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_decl" 47912 [t];
=TEX
The following function, which produces a type map from a declaration, will frequently be required below.
=SML
local
fun	f ([] :TERM list) :(string * TYPE)list = []
|	f (h::t) = (
		map dest_var (fst(dest_z_dec h))
		handle Fail _ =>
		let val (sch,d) = dest_z_schema_dec h
		in
			map 	(fn(s,ty)=>(pack_ident(s,d),ty)) 
				(dest_z_schema_type(dest_z_power_type(type_of sch)))
		end) @ (f t);
in
fun	Ûdest_declİ (t:TERM) :(string * TYPE)list =
		f (dest_z_decl t)
	handle Fail _ => term_fail "dest_decl" 47912 [t]
end;
=TEX
\subsection{Declaration Discriminators}
=SML
fun	Ûis_z_decİ (t:TERM) :bool =
	(case dest_z_term t of
		ZDec(tml,tm) => true
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_schema_decİ (t:TERM) :bool =
	(case dest_z_term t of
		ZSchemaDec(tm,s) => true
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_declİ (t:TERM) :bool =
	(case dest_z_term t of
		ZDecl tml => true
	|	_ => false)
	handle Fail _ => false;
=TEX
\subsection{Predicate Destructors}
=SML
fun	Ûdest_z_eqİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		ZEq(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_eq" 47220 [t];

fun	Ûdest_z_İ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_" 47230 [t];

fun	Ûdest_z_³İ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z³(tm1) => (tm1) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_³" 47240 [t];

fun	Ûdest_z_±İ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z±(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_±" 47250 [t];

fun	Ûdest_z_²İ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z²(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_²" 47260 [t];

fun	Ûdest_z_´İ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z´(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_´" 47270 [t];

fun	Ûdest_z_¤İ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z¤(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¤" 47280 [t];

fun	Ûdest_z_¶İ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶" 47290 [t];

fun	Ûdest_z_¶‰1İ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶‰1(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶‰1" 47300 [t];

fun	Ûdest_z_µİ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Zµ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_µ" 47310 [t];

fun	Ûdest_z_schema_predİ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZSchemaPred(tm1,s) => (tm1,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_schema_pred" 47320 [t];
=TEX
\subsection{Predicate Discriminators}
=SML
fun	Ûis_z_eqİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZEq(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_trueİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZTrue => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_falseİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZFalse => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_³İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z³(tm1) => true 
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_±İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z±(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_²İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z²(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_´İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z´(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¤İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¤(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶‰1İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶‰1(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_µİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zµ(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_schema_predİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSchemaPred(tm1,s) => true 
	|	_ => false) 
	handle Fail _ => false;
=TEX
\subsection{Term Destructors}
=SML
fun	Ûdest_z_lvarİ (t:TERM) :string * TYPE * TERM list = 
	(case dest_z_term t of 
		ZLVar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_lvar" 47090 [t];

fun	Ûdest_z_gvarİ (t:TERM) :string * TYPE * TERM list = 
	(case dest_z_term t of 
		ZGVar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_gvar" 47100 [t];

fun	Ûdest_z_intİ (t:TERM) :string = 
	(case dest_z_term t of 
		ZInt(s) => (s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_int" 47105 [t];

fun	Ûdest_z_stringİ (t:TERM) :string = 
	(case dest_z_term t of 
		ZString(s) => (s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_int" 47106 [t];

fun	Ûdest_z_§¢İ (t:TERM) :TYPE * TERM list = 
	(case dest_z_term t of 
		Z§¢(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_§¢" 47110 [t];

fun	Ûdest_z_setdİ (t:TERM) :TYPE * TERM list = 
	(case dest_z_term t of 
		ZSetd(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_setd" 47120 [t];

fun	Ûdest_z_setaİ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		ZSeta(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_seta" 47130 [t];

fun	Ûdest_z_ğİ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Zğ(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_ğ" 47140 [t];

fun	Ûdest_z_tupleİ (t:TERM) :TERM list = 
	(case dest_z_term t of 
		ZTuple(tml) => (tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_tuple" 47150 [t];

fun	Ûdest_z_bindingİ (t:TERM) :(string * TERM) list = 
	(case dest_z_term t of 
		ZBinding stl => stl 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_binding" 47151 [t];

fun	Ûdest_z_¸İ (t:TERM) :TERM list = 
	(case dest_z_term t of 
		Z¸(tml) => (tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¸" 47160 [t];

fun	Ûdest_z_Êİ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZÊ(tm,s) => (tm,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_Ê" 47170 [t];

fun	Ûdest_z_sel‰sİ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZSel‰s(tm,s) => (tm,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_sel‰s" 47180 [t];

fun	Ûdest_z_sel‰tİ (t:TERM) :TERM * int = 
	(case dest_z_term t of 
		ZSel‰t(tm,i) => (tm,i) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_sel‰t" 47185 [t];

fun	Ûdest_z_appİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		ZApp(f,a) => (f,a) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_app" 47190 [t];

fun	Ûdest_z_Ìİ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		ZÌ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_Ì" 47200 [t];

fun	Ûdest_z_Íİ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		ZÍ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_Í" 47210 [t];
=TEX
\subsection{Term Discriminators}
=SML
fun	Ûis_z_lvarİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZLVar(s,ty,tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_gvarİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZGVar(s,ty,tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_intİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZInt(s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_stringİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZString(s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_§¢İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z§¢(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_setdİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSetd(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_setaİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSeta(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_ğİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zğ(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_tupleİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZTuple(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_bindingİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZBinding(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¸İ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¸(tml) => true 
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_Êİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZÊ(tm,s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_sel‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSel‰s(tm,s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_sel‰tİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSel‰t(tm,i) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_appİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZApp(f,a) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_Ìİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZÌ(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_Íİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZÍ(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;
=TEX
\subsection{Destructors for the Schema Calculus}
=SML
fun	Ûdest_z_h_schemaİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		ZHSchema(d,p) => (d,p) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_h_schema" 47940 [t];

fun	Ûdest_z_dec‰sİ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZDecor‰s(tm,s) => (tm,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_dec‰s" 47340 [t];

fun	Ûdest_z_pre‰sİ (t:TERM) :TERM = 
	(case dest_z_term t of 
		ZPre‰s(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_pre‰s" 47350 [t];

fun	Ûdest_z_³‰sİ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z³‰s(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_³‰s" 47360 [t];

fun	Ûdest_z_±‰sİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z±‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_±‰s" 47370 [t];

fun	Ûdest_z_²‰sİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z²‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_²‰s" 47380 [t];

fun	Ûdest_z_´‰sİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z´‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_´‰s" 47390 [t];

fun	Ûdest_z_¤‰sİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z¤‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¤‰s" 47400 [t];

fun	Ûdest_z_ù‰sİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Zù‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_ù‰s" 47410 [t];

fun	Ûdest_z_hide‰sİ (t:TERM) :TERM * string list = 
	(case dest_z_term t of 
		ZHide‰s(tm,sl) => (tm,sl) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_hide‰s" 47420 [t];

fun	Ûdest_z_¶‰sİ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶‰s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶‰s" 47430 [t];

fun	Ûdest_z_¶‰1‰sİ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶‰1‰s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶‰1‰s" 47440 [t];

fun	Ûdest_z_µ‰sİ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Zµ‰s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_µ‰s" 47450 [t];

fun	Ûdest_z_„‰sİ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z„‰s(tm) => (tm) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_„‰s" 47460 [t];

fun	Ûdest_z_˜‰sİ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z˜‰s(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_˜‰s" 47470 [t];

fun	Ûdest_z_»‰sİ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z»‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_»‰s" 47480 [t];
fun	Ûdest_z_rename‰sİ (t:TERM) :TERM * (string * string)list = 
	(case dest_z_term t of 
		ZRename‰s(args) => (args) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_rename‰s" 47461 [t];

=TEX
\subsection{Discriminators for the Schema Calculus}
=SML
fun	Ûis_z_h_schemaİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZHSchema(d,p) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_dec‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZDecor‰s(tm,s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_pre‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZPre‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_³‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z³‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_±‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z±‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_²‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z²‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_´‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z´‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¤‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¤‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_ù‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zù‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_hide‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZHide‰s(tm,sl) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶‰s(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶‰1‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶‰1‰s(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_µ‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zµ‰s(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_„‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z„‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_˜‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z˜‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_»‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z»‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_rename‰sİ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZRename‰s _ => true 
	|	_ => false) 
	handle Fail _ => false;
=TEX
\subsection{Binding Construction}
There are three constructors below which generate systematically decorated bindings from schemas: schema references as declarations, schema references as predicates and theta terms.
We therefore provide the following general function for doing this.
=SML
local open ZTypesAndTermsSupport in
fun	Ûmk_bindingİ ((sch,d):TERM * string) :TERM =
	let	val itym = dest_z_schema_type(dest_z_power_type(type_of sch));
		val itym' = map (fn(s,t) => (pack_ident(s,d),t)) itym;
		val bcons = bind_cterm itym;
		val argl = map mk_var (dest_z_schema_type(mk_z_schema_type itym'));
	in
		list_mk_app(bcons,argl)
	end
	handle Fail _ => term_fail "mk_binding" 47940 [sch];
end;
=TEX
\subsection{Declaration Constructors}
=SML
fun 	Ûmk_z_decİ ((varl,set):TERM list * TERM) :TERM =
	let	val sty = type_of set;
		val ety = dest_z_power_type sty;
		val vl = mk_list varl
			handle X => reraise X "mk_z_dec";
		val decty = mk_­_type(mk_¸_type(type_of vl,sty),¬:BOOL®);
		val dec = mk_const("Z'Dec",decty);
	in
		mk_app(dec,mk_pair(vl,set))
	end
	handle X => (divert X "mk_z_dec"
			"dest_z_power_type" 47060 [fn() => string_of_term set]

	);
=TEX
=SML
fun	Ûmk_z_schema_decİ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = list_mk_­_type[bty,sty,BOOL];
		val con = mk_const("Z'SchemaDec",cty);
	in
		list_mk_app(con,[bind,sch])
	end;
=TEX
=SML
fun	Ûmk_z_declİ (tml:TERM list) :TERM =
	let	val lis = mk_list tml;
		val decl = mk_const("Z'Decl",mk_­_type(type_of lis,BOOL));
	in
		mk_app(decl,lis)
	end
	handle X => pass_on X "mk_list" "mk_z_decl";
=TEX
\subsection{Predicate Constructors}
=SML
val	Ûmk_z_eqİ :(TERM * TERM) -> TERM = mk_eq
	handle X => pass_on X "mk_eq" "mk_z_eq";
=TEX
=SML
fun	Ûmk_z_İ ((tm1,tm2):TERM * TERM) :TERM = 
	let	val ty = list_mk_­_type[type_of tm1, mk_z_power_type (type_of tm1),BOOL];
	in
		list_mk_app(mk_const("",ty),[tm1,tm2])
	end
	handle X => pass_on X "mk_app" "mk_z_";
=TEX
True and False and the logical connectives in Z map directly into the corresponding HOL constants.
=SML
val	Ûmk_z_trueİ :TERM = mk_const("T",BOOL);

val	Ûmk_z_falseİ :TERM = mk_const("F",BOOL);

val	Ûmk_z_³İ :TERM -> TERM = mk_³
	handle X => pass_on X "mk_³" "mk_z_³";

val	Ûmk_z_±İ :(TERM * TERM) -> TERM = mk_±
	handle X => pass_on X "mk_±" "mk_z_±";

val	Ûmk_z_²İ :(TERM * TERM) -> TERM = mk_²
	handle X => pass_on X "mk_²" "mk_z_²";

val	Ûmk_z_´İ :(TERM * TERM) -> TERM = mk_´
	handle X => pass_on X "mk_´" "mk_z_´";

val	Ûmk_z_¤İ :(TERM * TERM) -> TERM = mk_¤
	handle X => pass_on X "mk_¤" "mk_z_¤";

fun	Ûmk_z_¶İ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_¶ (d,p,v,itym)
	end
	handle X => reraise X "mk_z_¶";

fun	Ûmk_z_¶‰1İ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		mk_app(¶‰1_bterm itym,g2_abs(d,p,v,itym))
	end
	handle X => reraise X "mk_z_¶‰1";

fun	Ûmk_z_µİ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_µ (d,p,v,itym)
	end
	handle X => reraise X "mk_z_µ";

fun	Ûmk_z_schema_predİ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = list_mk_­_type[bty,sty,BOOL];
		val con = mk_const("Z'SchemaPred",cty);
	in
		list_mk_app(con,[bind,sch])
	end;
=TEX
\subsection{Term Constructors}
=SML
fun	Ûmk_z_§¢İ ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val seqty = mk_z_power_type(mk_z_tuple_type[mk_z_given_type "ú",ty]);
		val zseqty = mk_­_type(listy,seqty);
		val zseq = mk_const("Z'§¢",zseqty);
	in
		case tml of 
			[] => mk_app(zseq,mk_empty_list ty)
		|	_ => mk_app(zseq,mk_list tml)
	end;

fun	Ûmk_z_setdİ ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val setty = mk_z_power_type ty;
		val zsetty = mk_­_type(listy,setty);
		val zset = mk_const("Z'Setd",zsetty);
	in
		case tml of 
			[] => mk_app(zset,mk_empty_list ty)
		|	_ => mk_app(zset,mk_list tml)
	end;

fun	Ûmk_z_setaİ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
		val vty = type_of v;
	in
		mk_app (seta_bterm itym vty, g2_abs(d,p,v,itym))
	end;
=TEX
$mk\_z\_ğ$ only makes sense if its argument is a set, but we do not bother to check that here, since the type checker should catch this kind of thing and the definition of the constant $Zğ$ will prevent us from doing any damage.
=SML
fun	Ûmk_z_ğİ (tm:TERM) :TERM = 
	let	val ty = type_of tm;
		val psetty = mk_z_power_type ty;
		val zpsetty = mk_­_type(ty,psetty);
		val zpset = mk_const("Z'ğ",zpsetty);
	in
		mk_app(zpset,tm)
	end;

fun	Ûmk_z_tupleİ (tml:TERM list) :TERM = 
	let	val tyl = map type_of tml;
	in
		list_mk_app(tuple_cterm tyl,tml)
	end;

fun	Ûmk_z_bindingİ (stl:(string * TERM) list) :TERM = (
	let	val (nl, tl) = split stl;
		val side =  moccurs "mk_z_binding" 47152 nl;
		val sortnl = idsetseq nl;
	in	case stl of
			[] => fail "mk_z_binding" 47153 []
		|	_ => list_mk_app(bind_cterm (combine nl (map type_of tl)), 
				map (lassoc3 stl) sortnl)
	end
);

fun	Ûmk_z_¸İ (tml:TERM list) :TERM = 
	let	val tyl = map (dest_z_power_type o type_of) tml;
	in
		list_mk_app(prod_cterm tyl,tml)
	end;

fun	Ûmk_z_Êİ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = list_mk_­_type[bty,sty,bty];
		val con = mk_const("Z'Ê",cty);
	in
		list_mk_app(con,[bind,sch])
	end;

fun	Ûmk_z_sel‰sİ ((tm,s):TERM * string) :TERM = 
	let	val tym = dest_z_schema_type(type_of tm);
	in
		mk_app(bind_pterm tym s,tm)
	end;

fun	Ûmk_z_sel‰tİ ((tm,i):TERM * int) :TERM = 
	let	val tyl = dest_z_tuple_type(type_of tm);
	in
		mk_app(tuple_pterm tyl i, tm)
	end;

fun	Ûmk_z_appİ ((tm1,tm2):TERM * TERM) :TERM = 
	let	val fty = type_of tm1;
		val aty = type_of tm2;
		val rty = 
			case dest_z_tuple_type(dest_z_power_type fty) of
				[_,r] => r
			|	_ => term_fail "mk_z_app" 0 [];
		val zappty = list_mk_­_type[fty,aty,rty];
		val zapp = mk_const("Z'App",zappty);
	in
		list_mk_app (zapp, [tm1, tm2])
	end;
=TEX
=SML
local
fun	f ([]:Z_TERM list) :TERM list = []
|	f (ZDec(tml,_)::z_tml) = tml @ (f z_tml)
|	f (ZSchemaDec(sch,d)::z_tml) = (mk_z_Ê(sch,d)) :: (f z_tml)
|	f _ = term_fail "mk_z_Ì" 0 [];

fun	chartuple ((ZDecl tml):Z_TERM) :TERM = (
		case (f (map dest_z_term tml)) of
			[] => fail "mk_z_Ì" 0 []
		|	[tm] => tm
		|	tml' => mk_z_tuple tml'
		)
|	chartuple _ = fail "mk_z_Ì" 0 [];
in
fun	Ûmk_z_Ìİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val t = chartuple(dest_z_term d);
		val tym = dest_decl d;
		val tty = type_of t;
		val vty = type_of v;
	in
		mk_app(Ì_bterm tym tty vty,g3_abs(t,d,p,v,tym))
	end
	handle	Fail _ => term_fail "mk_z_Ì" 47201 [d,p,v]
end;
=TEX
=SML
fun	Ûmk_z_Íİ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val tym = dest_decl d;
		val vty = type_of v;
	in
		mk_app(Í_bterm tym vty,g2_abs(d,p,v,tym))
	end;

fun	Ûmk_z_lvarİ ((s,ty,tml):string * TYPE * TERM list) :TERM = 
		case tml of [] 	=> mk_var(s,ty)
		| _		=> 
			let	val cty = mk_­_type(mk_z_tuple_type(map type_of tml),ty);
			in
				mk_app(mk_var(s,cty),mk_z_tuple tml)
			end;

fun	Ûmk_z_gvarİ ((s,ty,tml):string * TYPE * TERM list) :TERM =
		case tml of [] 	=> bind_gvar_term (s,ty)
		| _		=> 
			let	val cty = mk_­_type(mk_z_tuple_type(map type_of tml),ty);
			in
				mk_app(bind_gvar_term (s,cty),mk_z_tuple tml)
			end;

fun	Ûmk_z_intİ (s:string) :TERM = 
	let	val nty = mk_ctype("î",[]);
		val zty = mk_ctype("ú",[]);
		val zint = mk_const("Z'Int",mk_­_type(nty,zty));
	in
		mk_app(zint,mk_const(s,nty))
	end;

fun	Ûmk_z_stringİ (s:string) :TERM = 
	let	val aty = mk_ctype("LIST",[mk_ctype ("CHAR", [])]);
		val rty = mk_z_power_type (mk_z_tuple_type[
				mk_ctype("ú",[]),mk_ctype("CHAR",[])]);
		val zs = mk_const("Z'String",mk_­_type(aty,rty));
	in
		mk_app(zs,mk_string s)
	end;
=TEX
\subsection{Constructors for the Schema Calculus}
=SML
fun	Ûmk_z_h_schemaİ ((d,p):TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
	in
		mk_app (schema_bterm itym, g1_abs(d,p,itym))
	end;

fun	Ûmk_z_dec‰sİ ((tm,s):TERM * string) :TERM =
	let	val tym = dest_z_schema_type(dest_z_power_type(type_of tm));
	in
		mk_app(bind_decor_term tym s,tm)
	end;

fun	Ûmk_z_pre‰sİ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_type(dest_z_power_type(type_of tm));
	in
		mk_app(bind_pre_term tym,tm)
	end;

fun	Ûmk_z_³‰sİ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_type(dest_z_power_type(type_of tm));
	in
		mk_app(bind_³_term tym,tm)
	end;

fun	Ûmk_z_±‰sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_type(dest_z_power_type(type_of tm1));
		val tym2 = dest_z_schema_type(dest_z_power_type(type_of tm2));
	in
		list_mk_app(bind_±_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_²‰sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_type(dest_z_power_type(type_of tm1));
		val tym2 = dest_z_schema_type(dest_z_power_type(type_of tm2));
	in
		list_mk_app(bind_²_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_´‰sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_type(dest_z_power_type(type_of tm1));
		val tym2 = dest_z_schema_type(dest_z_power_type(type_of tm2));
	in
		list_mk_app(bind_´_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_¤‰sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_type(dest_z_power_type(type_of tm1));
		val tym2 = dest_z_schema_type(dest_z_power_type(type_of tm2));
	in
		list_mk_app(bind_¤_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_ù‰sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_type(dest_z_power_type(type_of tm1));
		val tym2 = dest_z_schema_type(dest_z_power_type(type_of tm2));
	in
		list_mk_app(bind_ù_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_hide‰sİ ((tm,sl):TERM * string list) :TERM =
	let	val tym = dest_z_schema_type(dest_z_power_type(type_of tm));
	in
		mk_app(bind_hide_term tym sl,tm)
	end;

fun	Ûmk_z_¶‰sİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_z_schema_type(dest_z_power_type(type_of v));
	in
		list_mk_app(¶‰s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_z_¶‰1‰sİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_z_schema_type(dest_z_power_type(type_of v));
	in
		list_mk_app(¶‰1‰s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_z_µ‰sİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_z_schema_type(dest_z_power_type(type_of v));
	in
		list_mk_app(µ‰s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_z_„‰sİ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_type(dest_z_power_type(type_of tm));
	in
		mk_app(bind_„_term tym,tm)
	end;

fun	Ûmk_z_˜‰sİ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_type(dest_z_power_type(type_of tm));
	in
		mk_app(bind_˜_term tym,tm)
	end;

fun	Ûmk_z_»‰sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_type(dest_z_power_type(type_of tm1));
		val tym2 = dest_z_schema_type(dest_z_power_type(type_of tm2));
	in
		list_mk_app(bind_»_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_rename‰sİ (tm:TERM, ididl : (string * string) list) :TERM = (
	let	val tym = dest_z_schema_type(dest_z_power_type(type_of tm));
		val (xs,ys) = split ididl;
		val dummy = (moccurs "mk_z_rename‰s" 47463 xs;
				moccurs "mk_z_rename‰s" 47462 ys);
	in
		mk_app(bind_rename_term tym ididl, tm)
	end);
=TEX
Can renaming collapse two distinct components onto one,
by renaming one component to be the same as another?
=TEX
\subsection{$U$}
We create the $U$-terms by instantiation rather than with the constructor
functions (which is intended to optimise for space rather than speed).
=SML
local
	val ZT1 = mk_ctype("Z'T[1]",[”'a SET®]);
	val u = ¬‘mk_const("z'U", mk_­_type(ZT1,”'a SET®))®
  (‘mk_const("Z'Mk_T[1]", mk_­_type(”'a SET®,ZT1))®
      ‘mk_const("Totality", ”'a SET®)®)®;
	val ty = type_of u;
in	fun Ûmk_uİ (tyi : TYPE) : TERM = (
		let	val tym = (type_match tyi ty)
			handle Fail _ => type_fail "mk_u" 47951 [tyi];
		in	inst [] tym u
		end
	);
	fun Ûdest_uİ (tm : TERM) : TYPE = (
		(term_match tm u; type_of tm)
		handle Fail _ => term_fail "dest_u" 47950 [tm]
	);
	fun Ûis_uİ (tm : TERM) : bool = (
		(term_match tm u; true)
		handle Fail _ => false
	);
end;
=TEX
\subsection{Binding of Global Variables}
=SML
fun Ûgvar_substİ (tm : TERM) : (TERM * TERM) list = (
	let	fun do_gvar v tyi n ty = (
			case dest_simple_type ty of
				Ctype("­", [aty, rty]) => (
				let	val tym = type_match tyi rty
					val aty' = inst_type tym aty;
					val us = map mk_u (dest_z_tuple_type aty');
				in	(mk_z_gvar(n, tyi, us), v)
				end 
			) |	_ => (
				let	val chk = type_match tyi ty;
				in	(mk_z_gvar(n, tyi, []), v)
				end 
			)
		);
		fun do_gvars [] = []
		|   do_gvars (v :: vs) = (
			(let	val (n, tyi) = dest_var v;
				val zn = bind_gvar_name n
			in case get_const_type zn of
				Nil => do_gvars vs
			|	Value ty => do_gvar v tyi n ty:: do_gvars vs
			end)
			handle Fail _ => do_gvars vs
		);
	in	do_gvars (frees tm)
	end
);
=TEX

\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $Z\_TERM$ to the corresponding $TERM$.
=SML
fun	Ûmk_z_termİ	(ZDec(tml:TERM list,tm:TERM) :Z_TERM) :TERM = mk_z_dec(tml,tm)
|	mk_z_term	(ZSchemaDec(tm:TERM,s:string)) = mk_z_schema_dec(tm,s)
|	mk_z_term	(ZDecl(tml:TERM list)) = mk_z_decl tml
|	mk_z_term	(ZEq(tm1:TERM,tm2:TERM)) = mk_z_eq(tm1,tm2)
|	mk_z_term	(Z(tm1:TERM,tm2:TERM)) = mk_z_(tm1,tm2)
|	mk_z_term	(ZTrue) = mk_z_true
|	mk_z_term	(ZFalse) = mk_z_false
|	mk_z_term	(Z³(tm:TERM)) = mk_z_³ tm
|	mk_z_term	(Z±(tm1:TERM,tm2:TERM)) = mk_z_±(tm1,tm2)
|	mk_z_term	(Z²(tm1:TERM,tm2:TERM)) = mk_z_²(tm1,tm2)
|	mk_z_term	(Z´(tm1:TERM,tm2:TERM)) = mk_z_´(tm1,tm2)
|	mk_z_term	(Z¤(tm1:TERM,tm2:TERM)) = mk_z_¤(tm1,tm2)
|	mk_z_term	(Z¶(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶(tm1,tm2,tm3)
|	mk_z_term	(Z¶‰1(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶‰1(tm1,tm2,tm3)
|	mk_z_term	(Zµ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_µ(tm1,tm2,tm3)
|	mk_z_term	(ZSchemaPred(tm:TERM,s:string)) = mk_z_schema_pred(tm,s)
|	mk_z_term	(ZLVar(s:string,ty:TYPE,tml:TERM list)) = mk_z_lvar(s,ty,tml)
|	mk_z_term	(ZGVar(s:string,ty:TYPE,tml:TERM list)) = mk_z_gvar(s,ty,tml)
|	mk_z_term	(ZInt(s:string)) = mk_z_int(s)
|	mk_z_term	(ZString(s:string)) = mk_z_string(s)
|	mk_z_term	(Z§¢(ty:TYPE,tml:TERM list)) = mk_z_§¢(ty,tml)
|	mk_z_term	(ZSetd(ty:TYPE,tml:TERM list)) = mk_z_setd(ty,tml)
|	mk_z_term	(ZSeta(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_seta(tm1,tm2,tm3)
|	mk_z_term	(Zğ(tm:TERM)) = mk_z_ğ tm
|	mk_z_term	(ZTuple(tml:TERM list)) = mk_z_tuple tml
|	mk_z_term	(ZBinding(stl:(string * TERM) list)) = mk_z_binding stl
|	mk_z_term	(Z¸(tml:TERM list)) = mk_z_¸ tml
|	mk_z_term	(ZÊ(tm:TERM,s:string)) = mk_z_Ê(tm,s)
|	mk_z_term	(ZSel‰s(tm:TERM,s:string)) = mk_z_sel‰s(tm,s)
|	mk_z_term	(ZSel‰t(tm:TERM,i:int)) = mk_z_sel‰t(tm,i)
|	mk_z_term	(ZApp(tm1:TERM,tm2:TERM)) = mk_z_app(tm1,tm2)
|	mk_z_term	(ZÌ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_Ì(tm1,tm2,tm3)
|	mk_z_term	(ZÍ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_Í(tm1,tm2,tm3)
|	mk_z_term	(ZHSchema(tm1:TERM,tm2:TERM)) = mk_z_h_schema(tm1,tm2)
|	mk_z_term	(ZDecor‰s(tm:TERM,s:string)) = mk_z_dec‰s(tm,s)
|	mk_z_term	(ZPre‰s(tm:TERM)) = mk_z_pre‰s tm
|	mk_z_term	(Z³‰s(tm:TERM)) = mk_z_³‰s tm
|	mk_z_term	(Z±‰s(tm1:TERM,tm2:TERM)) = mk_z_±‰s(tm1,tm2)
|	mk_z_term	(Z²‰s(tm1:TERM,tm2:TERM)) = mk_z_²‰s(tm1,tm2)
|	mk_z_term	(Z´‰s(tm1:TERM,tm2:TERM)) = mk_z_´‰s(tm1,tm2)
|	mk_z_term	(Z¤‰s(tm1:TERM,tm2:TERM)) = mk_z_¤‰s(tm1,tm2)
|	mk_z_term	(Zù‰s(tm1:TERM,tm2:TERM)) = mk_z_ù‰s(tm1,tm2)
|	mk_z_term	(ZHide‰s(tm:TERM,sl:string list)) = mk_z_hide‰s(tm,sl)
|	mk_z_term	(Z¶‰s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶‰s(tm1,tm2,tm3)
|	mk_z_term	(Z¶‰1‰s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶‰1‰s(tm1,tm2,tm3)
|	mk_z_term	(Zµ‰s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_µ‰s(tm1,tm2,tm3)
|	mk_z_term	(Z„‰s(tm:TERM)) = mk_z_„‰s tm
|	mk_z_term	(Z˜‰s(tm:TERM)) = mk_z_˜‰s tm
|	mk_z_term	(Z»‰s(tm1:TERM,tm2:TERM)) = mk_z_»‰s(tm1,tm2)
|	mk_z_term	(ZRename‰s(tm:TERM,ididl:(string * string)list)) = mk_z_rename‰s(tm,ididl)

;
=TEX
Finally, we leave the structure open.
=SML
end (* of structure ZTypesAndTerms *);
open ZTypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

val d1 = mk_z_decl[mk_z_dec([mk_var("a",mk_z_given_type"A"),mk_var("x",mk_z_given_type"A")],mk_var("A",mk_z_power_type(mk_z_given_type"A")))];
val p1 = mk_z_true;
val sch1 = mk_z_h_schema(d1,p1);
val d2 = mk_z_decl[mk_z_dec([mk_var("y",mk_z_given_type"B"),mk_var("b",mk_z_given_type"B")],mk_var("B",mk_z_power_type(mk_z_given_type"B")))];
val p2 = mk_z_true;
val sch2 = mk_z_h_schema(d2,p2);
val d3 = mk_z_decl[mk_z_schema_dec(sch1,"'"),mk_z_schema_dec(sch2,"")];
val p3 = mk_z_true;
val sch3 = mk_z_h_schema(d3,p3);



val x = mk_z_lvar("x",mk_z_given_type "A",[]);
val y = mk_z_lvar("y",mk_z_given_type "A",[]);
val X = mk_z_lvar("X",mk_z_power_type(mk_z_given_type "A"),[]);
val Y = mk_z_lvar("Y",mk_z_power_type(mk_z_given_type "B"),[]);
val eq = mk_z_eq(x,y);
val mm = mk_z_(x,X);

val f = mk_z_¸[X,Y];

val zd = mk_const("Z'Ì",mk_­_type(BOOL,BOOL));
val tm = mk_app(zd,p1);



