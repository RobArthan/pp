% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$

doctex imp047 ; texdvi imp047
bibtex imp047

=TEX
% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP047}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.19 (\TPPdate{\FormatDate{92/03/03}})]
First draft version.

\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
	Restructure function $dest\_ZTERM$ to meet the needs of the
	pretty printer.  This is done by adding function
	$basic\_dest\_ZTERM$ to do the actual destruction or production
	of error message arguments, this function is used by
	$dest\_ZTERM$ and by the pretty printer. Changed handling for naming of
	projection functions (including a change to the interface of
	dest\_Z\_name).

\end{description}
%\subsection{Changes Forecast}
\newpage
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the constructor, discriminator and destructor functions corresponding to the primitive constructors of Z.
The detailed design of these is found in \cite{DS/FMU/IED/DTD047}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives the implementation of the functions mentioned above.
Additional functions, which are used in other parts of the Z system, may also be included here for convenience.
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
(The constructors might be bypassed entirely and the HOL constructors
used to generate terms with the names of Z~constants.) Such terms must
be handled by the pretty printer~\cite{DS/FMU/IED/DTD031} in a way that allows them to
be read back by the HOL and Z parsers and generate a term with the same
meaning.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intecepted and reported as helpfully as possible.
\section{STRUCTURE PREAMBLE}
=SML
structure ÛZTypesAndTermsİ : ZTypesAndTerms = struct
=TEX
We open the structure containing the support package (see \cite{DS/FMU/IED/IMP048}).
=SML
open ZTypesAndTermsSupport;
=TEX
\section{DERIVED HOL CONSTRUCTORS}
The functions defined here are an ad-hoc collection of constructors, destructors and discriminators which, at the time of writing, were not provided by the ICL HOL system.
If they are added in future, they will be removed from here.
=SML
fun	Ûlist_mk_­_typeİ ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_­_type tyl ty;
=TEX
\section{AUXILIARY FUNCTIONS}
\subsection{Name Destruction}
We need the inverse of the name construction functions (defined in
\cite{DS/FMU/IED/DTD048}).  Given a name formed as a simple identifier
followed by a sequence of name lists with each name list in square
brackets function $dest\_Z\_name$ returns the identifier name plus a
list of lists.  Thus a name like

=GFT
	"abc[de,fg,hi][jk,lm][no][p,r,s]"
=TEX

is split into the following pieces

=GFT
	("abc",
	[	["de", "fg", "hi"],
		["jk", "lm"],
		["no"],
		["p", "r", "s"]
	], Nil)
=TEX

Projections are of the form
=GFT
	"abc[de,fg,hi]jk"
=TEX

which is split into the following:

=GFT
	("abc",
	[	["de", "fg", "hi"]
	], Value "jk")
=TEX


Function $dest\_Z\_name$ splits up well formed names by interpreting the
square brackets and commas, it complains about mal-formed names.

=SML
fun	Ûdest_Z_nameİ (s:string) :string * string list list * string OPT = (
let
	exception bad_name;

	fun	addnam (nil:string list) (cl:string list)
			: string list = cl
	|	addnam n cl = (implode(rev n)) :: cl
	;

	fun	aux(nil, Value _, _) = raise bad_name
	|	aux(nil, Nil, pl) = (rev pl, Nil)

	|	aux("["::t (*=]=*), Value _, _) = raise bad_name
	|	aux("["::t (*=]=*), Nil, pl) = aux(t, Value(nil, nil), pl)

	|	aux(","::t, Nil, _) = raise bad_name
	|	aux(","::t, Value(cn, cl), pl) = aux(t, Value(nil, addnam cn cl), pl)

	|	aux((*=[=*) "]"::t, Nil, _) = raise bad_name
	|	aux((*=[=*) "]"::t, Value(cn, cl), pl) = aux(t, Nil, (rev(addnam cn cl)) :: pl)

	|	aux(l as(ch::t), Nil, pl) = (
			case get_id(l, nil)
			of (nil, nam) => (rev pl, Value(implode(rev nam)))
			| _ => raise bad_name
		)
	|	aux(ch::t, Value(cn, cl), pl) = aux(t, Value(ch::cn, cl), pl)
	

	and	get_id(nil, prev) = (nil, prev)
	|	get_id(l as ("["::_ (*=]=*)), prev) = (l, prev)
	|	get_id(","::t, _) = raise bad_name
	|	get_id((*=[=*) "]"::t, _) = raise bad_name
	|	get_id(ch::t, prev) = get_id(t, ch :: prev)
	;
in
	let
		val (tail, front) = get_id(explode s, nil);
		val (boxed_lists, projector) = aux(tail, Nil, nil);
	in
		(implode(rev front), boxed_lists, projector)
	end
	handle Fail _ => fail "dest_Z_name" 47000 [fn () => s]
	| bad_name => fail "dest_Z_name" 47000 [fn () => s]
end
);
=TEX

=IGN
fun	Ûdest_Z_nameİ (s:string) :string * string list list = (
let
	exception bad_name;

	fun	addnam (nil:string list) (cl:string list)
			: string list = cl
	|	addnam n cl = (implode(rev n)) :: cl
	;

	fun	aux(nil, Value _, _) = raise bad_name
	|	aux(nil, Nil, pl) = rev pl

	|	aux("["::t (*=]=*), Value _, _) = raise bad_name
	|	aux("["::t (*=]=*), Nil, pl) = aux(t, Value(nil, nil), pl)

	|	aux(","::t, Nil, _) = raise bad_name
	|	aux(","::t, Value(cn, cl), pl) = aux(t, Value(nil, addnam cn cl), pl)

	|	aux((*=[=*) "]"::t, Nil, _) = raise bad_name
	|	aux((*=[=*) "]"::t, Value(cn, cl), pl) = aux(t, Nil, (rev(addnam cn cl)) :: pl)

	|	aux(ch::t, Nil, _) = raise bad_name
	|	aux(ch::t, Value(cn, cl), pl) = aux(t, Value(ch::cn, cl), pl)
	;

	fun	get_id(nil, prev) = (nil, prev)
	|	get_id(l as ("["::_ (*=]=*)), prev) = (l, prev)
	|	get_id(","::t, _) = raise bad_name
	|	get_id((*=[=*) "]"::t, _) = raise bad_name
	|	get_id(ch::t, prev) = get_id(t, ch :: prev)
	;
in
	let
		val (tail, front) = get_id(explode s, nil)
	in
		(implode(rev front), aux(tail, Nil, nil))
	end
	handle Fail _ => fail "dest_Z_name" 47000 [fn () => s]
	| bad_name => fail "dest_Z_name" 47000 [fn () => s]
end
);
=TEX
\section{Z TYPES}
The following sections describe the constructor, discriminator and destructor functions for each of the five Z type constructors.
\subsection{The Datatype ZTYPE}

The general mapping functions $mk\-\_ZTYPE$, $is\-\_ZTYPE$ and
$dest\-\_ZTYPE$, which are declared later in this document, use this
datatype.

=SML
datatype	ÛZTYPEİ = 	ÛZgivenTİ of string
		|		ÛZvarTİ of string
		|		ÛZpowerTİ of TYPE
		|		ÛZtupleTİ of TYPE list
		|		ÛZschemaTİ of (string * TYPE) list;
=TEX
\subsection{The General Destructor Function}
This function converts a HOL type to the appropriate form of the above datatype (providing, of course, that it represents a valid Z type).
=SML
fun	Ûdest_ZTYPEİ (ty:TYPE) :ZTYPE =
	case dest_simple_type ty of
		Vartype s => (
			case explode s of
				("'"::t) => ZvarT(implode t)
			|	_ => fail "" 0 []
		)
	|	Ctype("SET",[ty1]) => ZpowerT ty1
	|	Ctype(s,tyl) => (
			case (dest_Z_name s,tyl) of
				(("Z'T",[[n]], Nil),tyl) => 
					if string_of_int(length tyl) = n
					then ZtupleT tyl
					else fail "" 0 []
			|	(("Z'S",[cl], Nil),tyl) => 
					ZschemaT(combine cl tyl)
			|	(_,[]) => ZgivenT s
			|	_ => fail "" 0 []
		)
	handle Fail _ => type_fail "dest_ZTYPE" 47800 [ty];
=TEX
\subsection{The General Discriminator Function}
=SML
fun	Ûis_ZTYPEİ (t:TYPE) :bool =
	let	val x = dest_ZTYPE t
	in
		true
	end
	handle Fail _ => false;
=TEX
\subsection{Given Sets}
=SML
fun	Ûmk_ZgivenTİ (s:string) :TYPE = mk_ctype(s,[]);

fun	Ûis_ZgivenTİ (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZgivenT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_ZgivenTİ (ty :TYPE) :string = (
	case dest_ZTYPE ty of
		ZgivenT s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZgivenT" 47010 [ty];
=TEX
\subsection{Generic Variables}
=SML
fun	Ûmk_ZvarTİ (s:string) :TYPE = mk_vartype("'" ^ s);

fun	Ûis_ZvarTİ (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZvarT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_ZvarTİ (ty :TYPE) :string = (
	case dest_ZTYPE ty of
		ZvarT s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZvarT" 47020 [ty];
=TEX
\subsection{Set Types}
=SML
fun	Ûmk_ZpowerTİ (ty:TYPE) :TYPE = mk_ctype("SET",[ty]);

fun	Ûis_ZpowerTİ (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZpowerT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_ZpowerTİ (ty :TYPE) :TYPE = (
	case dest_ZTYPE ty of
		ZpowerT t => t
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZpowerT" 47030 [ty];
=TEX
\subsection{Cartesian Product Types}
=SML
fun	Ûmk_ZtupleTİ (tyl:TYPE list) :TYPE = 
		tuple_type tyl;

fun	Ûis_ZtupleTİ (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZtupleT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_ZtupleTİ (ty :TYPE) :TYPE list = (
	case dest_ZTYPE ty of
		ZtupleT tyl => tyl
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZtupleT" 47040 [ty];
=TEX
\subsection{Binding Types}
=SML
fun	Ûmk_ZschemaTİ (itym:(string * TYPE) list) :TYPE =
		bind_type itym;

fun	Ûis_ZschemaTİ (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZschemaT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_ZschemaTİ (ty :TYPE) :(string * TYPE) list = (
	case dest_ZTYPE ty of
		ZschemaT itym => itym
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZschemaT" 47050 [ty];
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $ZTERM$ to the corresponding $TERM$.
=SML
fun	Ûmk_ZTYPEİ	(ZgivenT(s:string) :ZTYPE) :TYPE = mk_ZgivenT s
|	mk_ZTYPE	(ZvarT(s:string)) = mk_ZvarT s
|	mk_ZTYPE	(ZpowerT(ty:TYPE)) = mk_ZpowerT ty
|	mk_ZTYPE	(ZtupleT(tyl:TYPE list)) = mk_ZtupleT tyl
|	mk_ZTYPE	(ZschemaT(itym:(string * TYPE)list)) = mk_ZschemaT itym;
=TEX
\section{Z TERMS}
The following describes the constructor, discriminator and destructor functions for Z terms.
\subsection{The Datatype ZTERM}

The general mapping functions $mk\-\_ZTERM$, $is\-\_ZTERM$ and
$dest\-\_ZTERM$, which are declared later in this document, use this
datatype.

=SML
datatype	ÛZTERMİ
		=	 	ÛZdecİ of TERM list * TERM
		|		ÛZdecsexpİ of TERM * string
		|		ÛZdeclİ of TERM list
		|		ÛZeqİ of TERM * TERM
		|		ÛZİ of TERM * TERM
		|		ÛZtrueİ
		|		ÛZfalseİ
		|		ÛZ³İ of TERM
		|		ÛZ±İ of TERM * TERM
		|		ÛZ²İ of TERM * TERM
		|		ÛZ´İ of TERM * TERM
		|		ÛZ¤İ of TERM * TERM
		|		ÛZ¶İ of TERM * TERM * TERM
		|		ÛZ¶1İ of TERM * TERM * TERM
		|		ÛZµİ of TERM * TERM * TERM
		|		ÛZpredsexpİ of TERM * string
		|		ÛZlvarİ of string * TYPE * TERM list
		|		ÛZgvarİ of string * TYPE * TERM list
		|		ÛZintİ of string
		|		ÛZ§¢İ of TYPE * TERM list
		|		ÛZsetdİ of TYPE * TERM list
		|		ÛZsetaİ of TERM * TERM * TERM
		|		ÛZğİ of TERM
		|		ÛZtupleİ of TERM list
		|		ÛZ¸İ of TERM list
		|		ÛZÊİ of TERM * string
		|		ÛZselİ of TERM * string
		|		ÛZappİ of TERM * TERM
		|		ÛZÌİ of TERM * TERM * TERM
		|		ÛZÍİ of TERM * TERM * TERM
		|		ÛZsİ of TERM * TERM
		|		ÛZdecsİ of TERM * string
		|		ÛZpresİ of TERM
		|		ÛZ³sİ of TERM
		|		ÛZ±sİ of TERM * TERM
		|		ÛZ²sİ of TERM * TERM
		|		ÛZ´sİ of TERM * TERM
		|		ÛZ¤sİ of TERM * TERM
		|		ÛZùsİ of TERM * TERM
		|		ÛZhidesİ of TERM * string list
		|		ÛZ¶sİ of TERM * TERM * TERM
		|		ÛZ¶1sİ of TERM * TERM * TERM
		|		ÛZµsİ of TERM * TERM * TERM
		|		ÛZsİ of TERM
		|		ÛZsİ of TERM
		|		ÛZ»sİ of TERM * TERM
		;
=TEX

\subsection{Result of Basic Destructor Function}

This function converts a HOL term to the appropriate form of the
datatype $ZTERM$, or to an encoding of why it could not be converted.
The encoded failure value is intended for use by the pretty
printer~\cite{DS/FMU/IED/DTD031,DS/FMU/IED/DTD064}, it contains values
showing how (in some cases) the term might be HOL if it were modified
slightly.  The return value from the basic destructor function is
in type $BDZ$ (named for `Basic Destroy Z').

=SML
datatype ÛBDZİ
	=	Ûbdz_okİ	of ZTERM
	|	Ûbdz_not_Zİ	of int
	|	Ûbdz_failİ	of {
			Ûbdz_f_codeİ	: int,
			Ûbdz_f_compcİ	: int,
			Ûbdz_f_argcİ	: int
		}
	;
=TEX

Successful destruction returns $bdz\_ok$ with the Z term.  Value
$bdz\_fail$ is returned when the term is similar to a Z~term (i.e., it
has a known constructor but the wrong number of arguments).  In this
case the $bdz\_f\_compc$ and $bdz\_f\_argc$ fields tell how many component
lists and arguments (respectively) are allowed in a well formed
Z~term.  Value $bdz\_not\_Z$ is returned when the term is not
recognisable as a Z~term.  In cases where insufficient component lists
or arguments are given to a known constructor either $bdz\_fail$ or
$bdz\_not\_Z$ may be returned.

\subsection{Destructor Utilities}

=SML
fun Ûzdest_0_0İ(nil, nil, _, v) = bdz_ok v
| zdest_0_0(_, _, e, _) = bdz_not_Z 47900
;

fun Ûzdest_1_gt0İ(_, nil, e, _) = bdz_not_Z 47900
| zdest_1_gt0(_::_, a, _, v) = bdz_ok(v a)
| zdest_1_gt0(_, _, e, _) = bdz_not_Z 47900
;

fun Ûzdest_0_1İ(nil, [x], _, v) = bdz_ok(v x)
| zdest_0_1 (_, _::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=0, bdz_f_argc=1}
| zdest_0_1(_, _, e, _) = bdz_not_Z 47900
;

fun Ûzdest_0_2İ(nil, [x, y], _, v) = bdz_ok(v(x,y))
| zdest_0_2 (_, _::_::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=0, bdz_f_argc=2}
| zdest_0_2(_, _, e, _) = bdz_not_Z 47900
;

fun Ûzdest_1_1İ([_], [x], _, v) = bdz_ok(v x)
| zdest_1_1 (_, _::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=1, bdz_f_argc=1}
| zdest_1_1(_, _, e, _) = bdz_not_Z 47900
;

fun Ûzdest_2_2İ([_, _], [x, y], _, v) = bdz_ok(v(x, y))
| zdest_2_2 (_, _::_::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=2, bdz_f_argc=2}
| zdest_2_2(_, _, e, _) = bdz_not_Z 47900
;
=IGN
fun Ûzdest_gt0_0İ(nil, nil, e, _) = bdz_not_Z 47900
| zdest_gt0_0(_, nil, _, v) = bdz_ok v
| zdest_gt0_0(_, _, e, _) = bdz_not_Z 47900
;
=TEX

=SML
fun Ûdest_val_tupleİ(name:string, ty: TYPE, constr:string * TYPE * TERM list -> ZTERM,
		arg_tm:TERM, e:int) : BDZ = (
	let
		val (arg_fn, args) = strip_app arg_tm;
		val (arg_name, arg_ty) = dest_const arg_fn;
	in
		case dest_Z_name arg_name
		of ("Z'Mk_T", [_], Nil) =>
			bdz_ok(constr(name, snd(dest_­_type ty), args))
		| _ =>
			bdz_fail{bdz_f_code=e,
				bdz_f_compc=0, bdz_f_argc=0}
	end
	handle Fail _ =>
		bdz_fail{bdz_f_code=e, bdz_f_compc=0, bdz_f_argc=0}
);
=TEX

=SML
fun	Ûdest_abstractionİ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_Ì t)))
	handle Fail _ => term_fail "dest_ZTERM" 47901 [t];
=TEX

=SML
fun	Ûdest_¶bodyİ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_¶ t)))
	handle Fail _ => term_fail "dest_ZTERM" 47901 [t];
=TEX

=SML
fun	Ûdest_µbodyİ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_µ t)))
	handle Fail _ => term_fail "dest_ZTERM" 47901 [t];
=TEX

\subsection{The Basic Destructor Function}

Function $basic\_dest\_ZTERM$ does the work of destroying a term to
yield its Z~structure.  The arguments are in the result of applying
$strip\_app$ to a term.  (This parameterisation is of benefit to the
pretty printer~\cite{DS/FMU/IED/DTD031}.)

The main part of this function is a large case clause which switches
depending on the name of the constant at the head of the stripped
application, the other cases are simple and dealt with in the
immedaitely following block of code.

=SML
fun Ûbasic_dest_ZTERMİ (hdterm:TERM, args:TERM list) : BDZ = (
	case dest_simple_term hdterm
	of App _ => bdz_not_Z 47900
	| SimpleÌ _ => bdz_not_Z 47900
	| Var (name, ty) => (
		case args
		of nil => bdz_ok(Zlvar(name, ty,[]))
		| [tm] => dest_val_tuple(name, ty, Zlvar, tm, 47090)
		| _ => bdz_fail{bdz_f_code=47090,
				bdz_f_compc=0, bdz_f_argc=1}
	)
	| Const (name, ty) => (
		let
			val (identifier, comp_list, projector) = dest_Z_name name;
		in
			case (identifier, projector) of
			("Z'S", Value s) => (
				case args of
				[x] => bdz_ok(Zsel(x,s))
				| _ => bdz_fail{bdz_f_code=47180, bdz_f_compc=2,
								bdz_f_argc=1}
				)
			| (x, Nil) => (
				case identifier
=TEX


The $case$ clause started on the line above opens up the Z~term based
on the names of the constant.  The various options are catered for in
the following sections, the end of the function is in
section~\ref{EndOfFunctionBDZ}.

=TEX

\subsubsection{Declarations}
First we look for declarations, beginning with variables.
=SML
of "Z'dec" => (
	case (comp_list, args)
	of ([],[x]) => (
		bdz_ok(Zdec((dest_list ** Combinators.I)(dest_pair x)))
		handle Fail _ => bdz_not_Z 47900
	)
	| _ => bdz_fail{bdz_f_code=47910, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
Then schema declarations.
=SML
| "Z'decsexp" => (
	case (comp_list, args)
	of ([],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			bdz_ok(Zdecsexp(sch,d))
		end
		handle Fail _ => bdz_not_Z 47911
		)
	| _ => bdz_fail{bdz_f_code=47911, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
And composite declarations.
Note that all declarations used in other constructs must be of this
form, even if only one of the above forms is used (it is even possible
to have an empty declaration under certain circumstances).
=SML
| "Z'decl" => (
	case (comp_list, args)
	of ([],[x]) => (
		bdz_ok(Zdecl(dest_list x))
		handle Fail _ => bdz_not_Z 47912
	)
	| _ => bdz_fail{bdz_f_code=47912, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
\subsubsection{Predicates}

The logical connectives, `true' and `false', map directly on to the
equivalent HOL constants.

=SML
| "T"	=> zdest_0_0(comp_list, args, 47900, Ztrue)
| "F"	=> zdest_0_0(comp_list, args, 47900, Zfalse)
=TEX

Equality and equivalence both use the HOL `$=$' constant, they are distinguished by the
types of their operands.  Equivalence has both arguments of type $BOOL$.

=IGN
| "="	=> zdest_0_2(comp_list, args, 47220, Zeq)
| "¤"	=> zdest_0_2(comp_list, args, 47280, Z¤)
=SML
| "="	=> (
	case (comp_list, args)
	of (nil,[x, y]) => (
		bdz_ok(	(if type_of x =: BOOL andalso type_of y =: BOOL
			then Z¤
			else Zeq
			)(x,y)
		)
	)
	| (_, _::_::_::_) =>
		bdz_fail{bdz_f_code=47220, bdz_f_compc=0, bdz_f_argc=2}
	| _ => bdz_not_Z 47900
)
=TEX

=SML
| ""	=> zdest_0_2(comp_list, args, 47230, Z)
| "³"	=> zdest_0_1(comp_list, args, 47240, Z³)
| "±"	=> zdest_0_2(comp_list, args, 47250, Z±)
| "²"	=> zdest_0_2(comp_list, args, 47260, Z²)
| "´"	=> zdest_0_2(comp_list, args, 47270, Z´)
=TEX
=SML
| "Z'¶" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_¶body x
		of	[d,p,v] => bdz_ok(Z¶(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47920
	)
	| _ => bdz_fail{bdz_f_code=47920, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'¶1" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => bdz_ok(Z¶1(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47921
	)
	| _ => bdz_fail{bdz_f_code=47921, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'µ" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_µbody x of
			[d,p,v] => bdz_ok(Zµ(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47922
	)
	| _ => bdz_fail{bdz_f_code=47922, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'predsexp" => (
	case (comp_list, args)
	of ([],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			bdz_ok(Zpredsexp(sch,d))
		end
		handle Fail _ => bdz_not_Z 47923
	)
	| _ => bdz_fail{bdz_f_code=47923, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
\subsubsection{Terms}

We must postpone the handling of local and global variables until the
end of the case clause because they do not have an easily identifiable
constant part.

=SML
| "Z'int" => (
	case (comp_list, args)
	of ([],[tm]) => (
		bdz_ok(Zint(fst(dest_const tm)))
		handle Fail _ => bdz_not_Z 47105
	)
	| _ => bdz_fail{bdz_f_code=47105, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'§¢" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_ctype(type_of x) of
			("LIST",[t]) => bdz_ok(Z§¢(t,dest_list x))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47110
	)
	| _ => bdz_fail{bdz_f_code=47110, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'setd" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_ctype(type_of x) of
			("LIST",[t]) => bdz_ok(Zsetd(t,dest_list x))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47120
	)
	| _ => bdz_fail{bdz_f_code=47120, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'seta" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => bdz_ok(Zseta(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47130
	)
	| _ => bdz_fail{bdz_f_code=47130, bdz_f_compc=1, bdz_f_argc=1}
)
=TEX
=SML
| "Z'ğ"	=> zdest_0_1	(comp_list, args, 47140, Zğ)
| "Z'Mk_T"	=> zdest_1_gt0	(comp_list, args, 47150, Ztuple)
| "Z'¸"	=> zdest_1_gt0	(comp_list, args, 47160, Z¸)
=TEX
=SML
| "Z'Ê" => (
	case (comp_list, args)
	of ([],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			bdz_ok(ZÊ(sch,d))
		end
		handle Fail _ => bdz_not_Z 47170
	)
	| _ => bdz_fail{bdz_f_code=47170, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'Mk_S" => (
	bdz_fail{bdz_f_code=47180, bdz_f_compc=2, bdz_f_argc=1}
)

=TEX
=SML
| "Z'app" => (
	case (comp_list, args)
	of ([],[x]) => (
		bdz_ok(Zapp(dest_pair x))
		handle Fail _ => bdz_not_Z 47190
	)
	| _ => bdz_fail{bdz_f_code=47190, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'Ì" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,t,v] => bdz_ok(ZÌ(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47200
	)
	| _ => bdz_fail{bdz_f_code=47200, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'Í" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => bdz_ok(ZÍ(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47936
	)
	| _ => bdz_fail{bdz_f_code=47936, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
\subsubsection{Schemas}
=SML
| "Z's" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Zs(d,p))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47940
	)
	| _ => bdz_fail{bdz_f_code=47940, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'decs" => (
	case (comp_list, args)
	of ([_,[]],[x]) => bdz_ok(Zdecs(x,""))
	| ([_,[s]],[x]) => bdz_ok(Zdecs(x,s))
	| _ => bdz_fail{bdz_f_code=47340, bdz_f_compc=1, bdz_f_argc=1}
)
=TEX
=SML
| "Z'pres"	=> zdest_1_1(comp_list, args, 47350, Zpres)
| "Z'³s"	=> zdest_0_1(comp_list, args, 47360, Z³s)
| "Z'±s"	=> zdest_2_2(comp_list, args, 47370, Z±s)
| "Z'²s"	=> zdest_2_2(comp_list, args, 47380, Z²s)
| "Z'´s"	=> zdest_2_2(comp_list, args, 47390, Z´s)
| "Z'¤s"	=> zdest_2_2(comp_list, args, 47400, Z¤s)
| "Z'ùs"	=> zdest_2_2(comp_list, args, 47410, Zùs)
=TEX
=SML
| "Z'hides" => (
	case (comp_list, args)
	of ([_,sl],[x]) => bdz_ok(Zhides(x,sl))
	| _ => bdz_fail{bdz_f_code=47420, bdz_f_compc=2, bdz_f_argc=1}
)
=TEX
=SML
| "Z'¶s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Z¶s(d,p,y))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47941
	)
	| _ => bdz_fail{bdz_f_code=47941, bdz_f_compc=2, bdz_f_argc=2}
)
=TEX
=SML
| "Z'¶1s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Z¶1s(d,p,y))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47942
	)
	| _ => bdz_fail{bdz_f_code=47942, bdz_f_compc=2, bdz_f_argc=2}
)
=TEX
=SML
| "Z'µs" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Zµs(d,p,y))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47943
	)
	| _ => bdz_fail{bdz_f_code=47943, bdz_f_compc=2, bdz_f_argc=2}
)
=TEX
=SML
| "Z's"	=> zdest_1_1(comp_list, args, 47460, Zs)
| "Z's"	=> zdest_1_1(comp_list, args, 47470, Zs)
| "Z'»s"	=> zdest_2_2(comp_list, args, 47480, Z»s)
=TEX
\subsubsection{Local and Global Variables}
=SML
| _ => (
	case (comp_list, args)
	of (nil, nil) => (
		(	case unbind_gvar_name name
			of n => bdz_ok(Zgvar(n, ty,[]))
		) handle Fail _ => bdz_not_Z 47100
		)
	| (nil, [tm]) => (
		(	case unbind_gvar_name name
			of n => dest_val_tuple(n, ty, Zgvar, tm, 47100)
		) handle Fail _ => bdz_not_Z 47100
		)
	| _ => bdz_fail{bdz_f_code=47100, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX

\subsubsection{End of the Basic Destructor Function}
\label{EndOfFunctionBDZ}

=SML
		)
		| (_, Value _) => bdz_not_Z 47100
		end (* of let in case Const *)
	) (* end of case Const (name, ty) => ... *)
	(* end of case dest_simple_term hdterm ... *)
	handle _ => bdz_not_Z 47100 
) (* end of function basic_dest_ZTERM *);
=TEX

\subsection{The General Z Destructor Function}

Function $dest\_ZTERM$ provides the normal interface for
destroying arbitrary Z~terms.  

=SML
fun	Ûdest_ZTERMİ (t:TERM) :ZTERM = (
let
	val bdz_ans = basic_dest_ZTERM (strip_app t);
	fun sh(s, v) = diag_string("dest_ZTERM: ans is " ^ s ^ " " ^ (string_of_int v));
in
	case bdz_ans
	of bdz_ok zt => zt
	| bdz_not_Z e => term_fail "dest_ZTERM" e [t]
	| bdz_fail{bdz_f_code=e, ...} => term_fail "dest_ZTERM" e [t]
end
);
=TEX

\subsection{The General Z Discriminator Function}
=SML
fun	Ûis_ZTERMİ (t:TERM) :bool =
	let	val x = dest_ZTERM t
	in
		true
	end
	handle Fail _ => false;
=TEX
\section{Constructor, Destructor and Discriminator Functions}

\subsection{Declaration Destructors}
=SML
fun	Ûdest_Zdecİ (t:TERM) :(TERM list * TERM) =
	case dest_ZTERM t of
		Zdec(tml,tm) => (tml,tm)
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdec" 47061 [t];

fun	Ûdest_Zdecsexpİ (t:TERM) :TERM * string =
	case dest_ZTERM t of
		Zdecsexp(tm,s) => (tm,s)
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdecsexp" 47071 [t];

fun	Ûdest_Zdeclİ (t:TERM) :TERM list =
	case dest_ZTERM t of
		Zdecl tml => tml
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdecl" 47912 [t];
=TEX
The following function, which produces a type map from a declaration, will frequently be required below.
=SML
local
fun	f ([] :TERM list) :(string * TYPE)list = []
|	f (h::t) = (
		map dest_var (fst(dest_Zdec h))
		handle Fail _ =>
		let val (sch,d) = dest_Zdecsexp h
		in
			map 	(fn(s,ty)=>(pack_IDENT(s,d),ty)) 
				(dest_ZschemaT(dest_ZpowerT(type_of sch)))
		end) @ (f t);
in
fun	Ûdest_declİ (t:TERM) :(string * TYPE)list =
		f (dest_Zdecl t)
	handle Fail _ => term_fail "dest_decl" 47912 [t]
end;
=TEX
\subsection{Declaration Discriminators}
=SML
fun	Ûis_Zdecİ (t:TERM) :bool =
	case dest_ZTERM t of
		Zdec(tml,tm) => true
	|	_ => false
	handle Fail _ => false;

fun	Ûis_Zdecsexpİ (t:TERM) :bool =
	case dest_ZTERM t of
		Zdecsexp(tm,s) => true
	|	_ => false
	handle Fail _ => false;

fun	Ûis_Zdeclİ (t:TERM) :bool =
	case dest_ZTERM t of
		Zdecl tml => true
	|	_ => false
	handle Fail _ => false;
=TEX
\subsection{Predicate Destructors}
=SML
fun	Ûdest_Zeqİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zeq(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zeq" 47220 [t];

fun	Ûdest_Zİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z" 47230 [t];

fun	Ûdest_Z³İ (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z³(tm1) => (tm1) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z³" 47240 [t];

fun	Ûdest_Z±İ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z±(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z±" 47250 [t];

fun	Ûdest_Z²İ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z²(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z²" 47260 [t];

fun	Ûdest_Z´İ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z´(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z´" 47270 [t];

fun	Ûdest_Z¤İ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z¤(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¤" 47280 [t];

fun	Ûdest_Z¶İ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z¶(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¶" 47290 [t];

fun	Ûdest_Z¶1İ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z¶1(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¶1" 47300 [t];

fun	Ûdest_Zµİ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zµ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zµ" 47310 [t];

fun	Ûdest_Zpredsexpİ (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zpredsexp(tm1,s) => (tm1,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zpredsexp" 47320 [t];
=TEX
\subsection{Predicate Discriminators}
=SML
fun	Ûis_Zeqİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zeq(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Ztrueİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Ztrue => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zfalseİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zfalse => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z³İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z³(tm1) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z±İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z±(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z²İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z²(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z´İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z´(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z¤İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¤(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z¶İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¶(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z¶1İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¶1(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zµİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zµ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zpredsexpİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zpredsexp(tm1,s) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Term Destructors}
=SML
fun	Ûdest_Zlvarİ (t:TERM) :string * TYPE * TERM list = 
	case dest_ZTERM t of 
		Zlvar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zlvar" 47090 [t];

fun	Ûdest_Zgvarİ (t:TERM) :string * TYPE * TERM list = 
	case dest_ZTERM t of 
		Zgvar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zgvar" 47100 [t];

fun	Ûdest_Zintİ (t:TERM) :string = 
	case dest_ZTERM t of 
		Zint(s) => (s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zint" 47105 [t];

fun	Ûdest_Z§¢İ (t:TERM) :TYPE * TERM list = 
	case dest_ZTERM t of 
		Z§¢(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z§¢" 47110 [t];

fun	Ûdest_Zsetdİ (t:TERM) :TYPE * TERM list = 
	case dest_ZTERM t of 
		Zsetd(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zsetd" 47120 [t];

fun	Ûdest_Zsetaİ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zseta(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zseta" 47130 [t];

fun	Ûdest_Zğİ (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zğ(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zğ" 47140 [t];

fun	Ûdest_Ztupleİ (t:TERM) :TERM list = 
	case dest_ZTERM t of 
		Ztuple(tml) => (tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Ztuple" 47150 [t];

fun	Ûdest_Z¸İ (t:TERM) :TERM list = 
	case dest_ZTERM t of 
		Z¸(tml) => (tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¸" 47160 [t];

fun	Ûdest_ZÊİ (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		ZÊ(tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÊ" 47170 [t];

fun	Ûdest_Zselİ (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zsel(tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zsel" 47180 [t];

fun	Ûdest_Zappİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zapp(f,a) => (f,a) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zapp" 47190 [t];

fun	Ûdest_ZÌİ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		ZÌ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÌ" 47200 [t];

fun	Ûdest_ZÍİ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		ZÍ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÍ" 47210 [t];
=TEX
\subsection{Term Discriminators}
=SML
fun	Ûis_Zlvarİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zlvar(s,ty,tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zgvarİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zgvar(s,ty,tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zintİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zint(s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z§¢İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z§¢(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zsetdİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zsetd(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zsetaİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zseta(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zğİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zğ(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Ztupleİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Ztuple(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z¸İ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¸(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_ZÊİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÊ(tm,s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zselİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zsel(tm,s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zappİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zapp(f,a) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_ZÌİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÌ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_ZÍİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÍ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Destructors for the Schema Calculus}
=SML
fun	Ûdest_Zsİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zs(d,p) => (d,p) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zs" 47940 [t];

fun	Ûdest_Zdecsİ (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zdecs(tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zdecs" 47340 [t];

fun	Ûdest_Zpresİ (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zpres(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zpres" 47350 [t];

fun	Ûdest_Z³sİ (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z³s(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z³s" 47360 [t];

fun	Ûdest_Z±sİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z±s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z±s" 47370 [t];

fun	Ûdest_Z²sİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z²s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z²s" 47380 [t];

fun	Ûdest_Z´sİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z´s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z´s" 47390 [t];

fun	Ûdest_Z¤sİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z¤s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¤s" 47400 [t];

fun	Ûdest_Zùsİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zùs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zùs" 47410 [t];

fun	Ûdest_Zhidesİ (t:TERM) :TERM * string list = 
	case dest_ZTERM t of 
		Zhides(tm,sl) => (tm,sl) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zhides" 47420 [t];

fun	Ûdest_Z¶sİ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z¶s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¶s" 47430 [t];

fun	Ûdest_Z¶1sİ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z¶1s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¶1s" 47440 [t];

fun	Ûdest_Zµsİ (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zµs(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zµs" 47450 [t];

fun	Ûdest_Zsİ (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zs" 47460 [t];

fun	Ûdest_Zsİ (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zs" 47470 [t];

fun	Ûdest_Z»sİ (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z»s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z»s" 47480 [t];
=TEX
\subsection{Discriminators for the Schema Calculus}
=SML
fun	Ûis_Zsİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zs(d,p) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zdecsİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zdecs(tm,s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zpresİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zpres(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z³sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z³s(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z±sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z±s(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z²sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z²s(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z´sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z´s(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z¤sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¤s(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zùsİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zùs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zhidesİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zhides(tm,sl) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z¶sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¶s(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z¶1sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¶1s(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zµsİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zµs(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zsİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zs(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Zsİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zs(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	Ûis_Z»sİ (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z»s(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Binding Construction}
There are three constructors below which generate systematically decorated bindings from schemas: schema references as declarations, schema references as predicates and theta terms.
We therefore provide the following general function for doing this.
=SML
local open ZTypesAndTermsSupport in
fun	Ûmk_bindingİ ((sch,d):TERM * string) :TERM =
	let	val itym = dest_ZschemaT(dest_ZpowerT(type_of sch));
		val itym' = map (fn(s,t) => (pack_IDENT(s,d),t)) itym;
		val bcons = bind_cterm itym;
		val argl = map mk_var (dest_ZschemaT(mk_ZschemaT itym'));
	in
		list_mk_app(bcons,argl)
	end
	handle Fail _ => term_fail "mk_binding" 47940 [sch];
end;
=TEX
\subsection{Declaration Constructors}
=SML
fun 	Ûmk_Zdecİ ((varl,set):TERM list * TERM) :TERM =
	let	val sty = type_of set;
		val ety = dest_ZpowerT sty;
		val vl = mk_list varl
			handle X => reraise X "mk_Zdec";
		val decty = mk_­_type(mk_¸_type(type_of vl,sty),¬:BOOL®);
		val dec = mk_const("Z'dec",decty);
	in
		mk_app(dec,mk_pair(vl,set))
	end
	handle X => (divert X "mk_Zdec"
			"dest_ZpowerT" 47060 [fn() => string_of_term set]

	);
=TEX
=SML
fun	Ûmk_Zdecsexpİ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_­_type(mk_¸_type(bty,sty),BOOL);
		val con = mk_const("Z'decsexp",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;
=TEX
=SML
fun	Ûmk_Zdeclİ (tml:TERM list) :TERM =
	let	val lis = mk_list tml;
		val decl = mk_const("Z'decl",mk_­_type(type_of lis,BOOL));
	in
		mk_app(decl,lis)
	end
	handle X => pass_on X "mk_list" "mk_Zdecl";
=TEX
\subsection{Predicate Constructors}
=SML
val	Ûmk_Zeqİ :(TERM * TERM) -> TERM = mk_eq
	handle X => pass_on X "mk_eq" "mk_Zeq";
=TEX
=SML
fun	Ûmk_Zİ ((tm1,tm2):TERM * TERM) :TERM = 
	let	val ty = list_mk_­_type([type_of tm1, mk_ZpowerT (type_of tm1)],BOOL);
	in
		list_mk_app(mk_const("",ty),[tm1,tm2])
	end
	handle X => pass_on X "mk_app" "mk_Z";
=TEX
True and False and the logical connectives in Z map directly into the corresponding HOL constants.
=SML
val	Ûmk_Ztrueİ :TERM = mk_const("T",BOOL);

val	Ûmk_Zfalseİ :TERM = mk_const("F",BOOL);

val	Ûmk_Z³İ :TERM -> TERM = mk_³
	handle X => pass_on X "mk_³" "mk_Z³";

val	Ûmk_Z±İ :(TERM * TERM) -> TERM = mk_±
	handle X => pass_on X "mk_±" "mk_Z±";

val	Ûmk_Z²İ :(TERM * TERM) -> TERM = mk_²
	handle X => pass_on X "mk_²" "mk_Z²";

val	Ûmk_Z´İ :(TERM * TERM) -> TERM = mk_´
	handle X => pass_on X "mk_´" "mk_Z´";

val	Ûmk_Z¤İ :(TERM * TERM) -> TERM = mk_¤
	handle X => pass_on X "mk_¤" "mk_Z¤";

fun	Ûmk_Z¶İ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_¶ (d,p,v,itym)
	end
	handle X => reraise X "mk_Z¶";

fun	Ûmk_Z¶1İ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		mk_app(¶1_bterm itym,g2_abs(d,p,v,itym))
	end
	handle X => reraise X "mk_Z¶1";

fun	Ûmk_Zµİ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_µ (d,p,v,itym)
	end
	handle X => reraise X "mk_Zµ";

fun	Ûmk_Zpredsexpİ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_­_type(mk_¸_type(bty,sty),BOOL);
		val con = mk_const("Z'predsexp",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;
=TEX
\subsection{Term Constructors}
=SML
fun	Ûmk_Z§¢İ ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val seqty = mk_ZpowerT(mk_ZtupleT[mk_ZgivenT "ú",ty]);
		val zseqty = mk_­_type(listy,seqty);
		val zseq = mk_const("Z'§¢",zseqty);
	in
		case tml of 
			[] => mk_app(zseq,mk_empty_list ty)
		|	_ => mk_app(zseq,mk_list tml)
	end;

fun	Ûmk_Zsetdİ ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val setty = mk_ZpowerT ty;
		val zsetty = mk_­_type(listy,setty);
		val zset = mk_const("Z'setd",zsetty);
	in
		case tml of 
			[] => mk_app(zset,mk_empty_list ty)
		|	_ => mk_app(zset,mk_list tml)
	end;

fun	Ûmk_Zsetaİ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
		val vty = type_of v;
	in
		mk_app (seta_bterm itym vty, g2_abs(d,p,v,itym))
	end;
=TEX
$mk\_Zğ$ only makes sense if its argument is a set, but we do not bother to check that here, since the type checker should catch this kind of thing and the definition of the constant $Zğ$ will prevent us from doing any damage.
=SML
fun	Ûmk_Zğİ (tm:TERM) :TERM = 
	let	val ty = type_of tm;
		val psetty = mk_ZpowerT ty;
		val zpsetty = mk_­_type(ty,psetty);
		val zpset = mk_const("Z'ğ",zpsetty);
	in
		mk_app(zpset,tm)
	end;

fun	Ûmk_Ztupleİ (tml:TERM list) :TERM = 
	let	val tyl = map type_of tml;
	in
		list_mk_app(tuple_cterm tyl,tml)
	end;

fun	Ûmk_Z¸İ (tml:TERM list) :TERM = 
	let	val tyl = map (dest_ZpowerT o type_of) tml;
	in
		list_mk_app(prod_cterm tyl,tml)
	end;

fun	Ûmk_ZÊİ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_­_type(mk_¸_type(bty,sty),bty);
		val con = mk_const("Z'Ê",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;

fun	Ûmk_Zselİ ((tm,s):TERM * string) :TERM = 
	let	val tym = dest_ZschemaT(type_of tm);
	in
		mk_app(bind_pterm tym s,tm)
	end;

fun	Ûmk_Zappİ ((tm1,tm2):TERM * TERM) :TERM = 
	let	val fty = type_of tm1;
		val aty = type_of tm2;
		val rty = 
			case dest_ZtupleT(dest_ZpowerT fty) of
				[_,r] => r
			|	_ => term_fail "mk_Zapp" 0 [];
		val zappty = mk_­_type(mk_¸_type(fty,aty),rty);
		val zapp = mk_const("Z'app",zappty);
	in
		mk_app(zapp,mk_pair(tm1,tm2))
	end;
=TEX
=SML
local
fun	f ([]:ZTERM list) :TERM list = []
|	f (Zdec(tml,_)::ztml) = tml @ (f ztml)
|	f (Zdecsexp(sch,d)::ztml) = (mk_ZÊ(sch,d)) :: (f ztml)
|	f _ = term_fail "mk_ZÌ" 0 [];

fun	chartuple ((Zdecl tml):ZTERM) :TERM = (
		case (f (map dest_ZTERM tml)) of
			[] => fail "mk_ZÌ" 0 []
		|	[tm] => tm
		|	tml' => mk_Ztuple tml'
		)
|	chartuple _ = fail "mk_ZÌ" 0 [];
in
fun	Ûmk_ZÌİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val t = chartuple(dest_ZTERM d);
		val tym = dest_decl d;
		val tty = type_of t;
		val vty = type_of v;
	in
		mk_app(Ì_bterm tym tty vty,g3_abs(t,d,p,v,tym))
	end
	handle	Fail _ => term_fail "mk_ZÌ" 47201 [d,p,v]
end;
=TEX
=SML
fun	Ûmk_ZÍİ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val tym = dest_decl d;
		val vty = type_of v;
	in
		mk_app(Í_bterm tym vty,g2_abs(d,p,v,tym))
	end;

fun	Ûmk_Zlvarİ ((s,ty,tml):string * TYPE * TERM list) :TERM = 
		case tml of [] 	=> mk_var(s,ty)
		| _		=> 
			let	val cty = mk_­_type(mk_ZtupleT(map type_of tml),ty);
			in
				mk_app(mk_var(s,cty),mk_Ztuple tml)
			end;

fun	Ûmk_Zgvarİ ((s,ty,tml):string * TYPE * TERM list) :TERM =
		case tml of [] 	=> bind_gvar_term (s,ty)
		| _		=> 
			let	val cty = mk_­_type(mk_ZtupleT(map type_of tml),ty);
			in
				mk_app(bind_gvar_term (s,cty),mk_Ztuple tml)
			end;

fun	Ûmk_Zintİ (s:string) :TERM = 
	let	val nty = mk_ctype("î",[]);
		val zty = mk_ctype("ú",[]);
		val zint = mk_const("Z'int",mk_­_type(nty,zty));
	in
		mk_app(zint,mk_const(s,nty))
	end;
=TEX
\subsection{Constructors for the Schema Calculus}
=SML
fun	Ûmk_Zsİ ((d,p):TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
	in
		mk_app (schema_bterm itym, g1_abs(d,p,itym))
	end;

fun	Ûmk_Zdecsİ ((tm,s):TERM * string) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_decor_term tym s,tm)
	end;

fun	Ûmk_Zpresİ (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_pre_term tym,tm)
	end;

fun	Ûmk_Z³sİ (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_³_term tym,tm)
	end;

fun	Ûmk_Z±sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_±_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_Z²sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_²_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_Z´sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_´_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_Z¤sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_¤_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_Zùsİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_ù_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_Zhidesİ ((tm,sl):TERM * string list) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_hide_term tym sl,tm)
	end;

fun	Ûmk_Z¶sİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(¶s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_Z¶1sİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(¶1s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_Zµsİ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(µs_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_Zsİ (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind__term tym,tm)
	end;

fun	Ûmk_Zsİ (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind__term tym,tm)
	end;

fun	Ûmk_Z»sİ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_»_term tym1 tym2,[tm1,tm2])
	end;
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $ZTERM$ to the corresponding $TERM$.
=SML
fun	Ûmk_ZTERMİ	(Zdec(tml:TERM list,tm:TERM) :ZTERM) :TERM = mk_Zdec(tml,tm)
|	mk_ZTERM	(Zdecsexp(tm:TERM,s:string)) = mk_Zdecsexp(tm,s)
|	mk_ZTERM	(Zdecl(tml:TERM list)) = mk_Zdecl tml
|	mk_ZTERM	(Zeq(tm1:TERM,tm2:TERM)) = mk_Zeq(tm1,tm2)
|	mk_ZTERM	(Z(tm1:TERM,tm2:TERM)) = mk_Z(tm1,tm2)
|	mk_ZTERM	(Ztrue) = mk_Ztrue
|	mk_ZTERM	(Zfalse) = mk_Zfalse
|	mk_ZTERM	(Z³(tm:TERM)) = mk_Z³ tm
|	mk_ZTERM	(Z±(tm1:TERM,tm2:TERM)) = mk_Z±(tm1,tm2)
|	mk_ZTERM	(Z²(tm1:TERM,tm2:TERM)) = mk_Z²(tm1,tm2)
|	mk_ZTERM	(Z´(tm1:TERM,tm2:TERM)) = mk_Z´(tm1,tm2)
|	mk_ZTERM	(Z¤(tm1:TERM,tm2:TERM)) = mk_Z¤(tm1,tm2)
|	mk_ZTERM	(Z¶(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z¶(tm1,tm2,tm3)
|	mk_ZTERM	(Z¶1(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z¶1(tm1,tm2,tm3)
|	mk_ZTERM	(Zµ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zµ(tm1,tm2,tm3)
|	mk_ZTERM	(Zpredsexp(tm:TERM,s:string)) = mk_Zpredsexp(tm,s)
|	mk_ZTERM	(Zlvar(s:string,ty:TYPE,tml:TERM list)) = mk_Zlvar(s,ty,tml)
|	mk_ZTERM	(Zgvar(s:string,ty:TYPE,tml:TERM list)) = mk_Zgvar(s,ty,tml)
|	mk_ZTERM	(Zint(s:string)) = mk_Zint(s)
|	mk_ZTERM	(Z§¢(ty:TYPE,tml:TERM list)) = mk_Z§¢(ty,tml)
|	mk_ZTERM	(Zsetd(ty:TYPE,tml:TERM list)) = mk_Zsetd(ty,tml)
|	mk_ZTERM	(Zseta(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zseta(tm1,tm2,tm3)
|	mk_ZTERM	(Zğ(tm:TERM)) = mk_Zğ tm
|	mk_ZTERM	(Ztuple(tml:TERM list)) = mk_Ztuple tml
|	mk_ZTERM	(Z¸(tml:TERM list)) = mk_Z¸ tml
|	mk_ZTERM	(ZÊ(tm:TERM,s:string)) = mk_ZÊ(tm,s)
|	mk_ZTERM	(Zsel(tm:TERM,s:string)) = mk_Zsel(tm,s)
|	mk_ZTERM	(Zapp(tm1:TERM,tm2:TERM)) = mk_Zapp(tm1,tm2)
|	mk_ZTERM	(ZÌ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_ZÌ(tm1,tm2,tm3)
|	mk_ZTERM	(ZÍ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_ZÍ(tm1,tm2,tm3)
|	mk_ZTERM	(Zs(tm1:TERM,tm2:TERM)) = mk_Zs(tm1,tm2)
|	mk_ZTERM	(Zdecs(tm:TERM,s:string)) = mk_Zdecs(tm,s)
|	mk_ZTERM	(Zpres(tm:TERM)) = mk_Zpres tm
|	mk_ZTERM	(Z³s(tm:TERM)) = mk_Z³s tm
|	mk_ZTERM	(Z±s(tm1:TERM,tm2:TERM)) = mk_Z±s(tm1,tm2)
|	mk_ZTERM	(Z²s(tm1:TERM,tm2:TERM)) = mk_Z²s(tm1,tm2)
|	mk_ZTERM	(Z´s(tm1:TERM,tm2:TERM)) = mk_Z´s(tm1,tm2)
|	mk_ZTERM	(Z¤s(tm1:TERM,tm2:TERM)) = mk_Z¤s(tm1,tm2)
|	mk_ZTERM	(Zùs(tm1:TERM,tm2:TERM)) = mk_Zùs(tm1,tm2)
|	mk_ZTERM	(Zhides(tm:TERM,sl:string list)) = mk_Zhides(tm,sl)
|	mk_ZTERM	(Z¶s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z¶s(tm1,tm2,tm3)
|	mk_ZTERM	(Z¶1s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z¶1s(tm1,tm2,tm3)
|	mk_ZTERM	(Zµs(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zµs(tm1,tm2,tm3)
|	mk_ZTERM	(Zs(tm:TERM)) = mk_Zs tm
|	mk_ZTERM	(Zs(tm:TERM)) = mk_Zs tm
|	mk_ZTERM	(Z»s(tm1:TERM,tm2:TERM)) = mk_Z»s(tm1,tm2);
=TEX
Finally, we leave the structure open.
=SML
end (* of structure ZTypesAndTerms *);
open ZTypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

val d1 = mk_Zdecl[mk_Zdec([mk_var("a",mk_ZgivenT"A"),mk_var("x",mk_ZgivenT"A")],mk_var("A",mk_ZpowerT(mk_ZgivenT"A")))];
val p1 = mk_Ztrue;
val sch1 = mk_Zs(d1,p1);
val d2 = mk_Zdecl[mk_Zdec([mk_var("y",mk_ZgivenT"B"),mk_var("b",mk_ZgivenT"B")],mk_var("B",mk_ZpowerT(mk_ZgivenT"B")))];
val p2 = mk_Ztrue;
val sch2 = mk_Zs(d2,p2);
val d3 = mk_Zdecl[mk_Zdecsexp(sch1,"'"),mk_Zdecsexp(sch2,"")];
val p3 = mk_Ztrue;
val sch3 = mk_Zs(d3,p3);



val x = mk_Zlvar("x",mk_ZgivenT "A",[]);
val y = mk_Zlvar("y",mk_ZgivenT "A",[]);
val X = mk_Zlvar("X",mk_ZpowerT(mk_ZgivenT "A"),[]);
val Y = mk_Zlvar("Y",mk_ZpowerT(mk_ZgivenT "B"),[]);
val eq = mk_Zeq(x,y);
val mm = mk_Z(x,X);

val f = mk_Z¸[X,Y];

val zd = mk_const("Z'Ì",mk_­_type(BOOL,BOOL));
val tm = mk_app(zd,p1);



