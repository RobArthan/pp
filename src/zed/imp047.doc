% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$

doctex imp047 ; texdvi imp047
bibtex imp047

=TEX
% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP047}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.19 (\TPPdate{\FormatDate{92/03/03}})]
First draft version.

\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
	Restructure function $dest\_ZTERM$ to meet the needs of the
	pretty printer.  This is done by adding function
	$basic\_dest\_ZTERM$ to do the actual destruction or production
	of error message arguments, this function is used by
	$dest\_ZTERM$ and by the pretty printer. Changed handling for naming of
	projection functions (including a change to the interface of
	dest\_Z\_name).

\end{description}
%\subsection{Changes Forecast}
\newpage
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the constructor, discriminator and destructor functions corresponding to the primitive constructors of Z.
The detailed design of these is found in \cite{DS/FMU/IED/DTD047}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives the implementation of the functions mentioned above.
Additional functions, which are used in other parts of the Z system, may also be included here for convenience.
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
(The constructors might be bypassed entirely and the HOL constructors
used to generate terms with the names of Z~constants.) Such terms must
be handled by the pretty printer~\cite{DS/FMU/IED/DTD031} in a way that allows them to
be read back by the HOL and Z parsers and generate a term with the same
meaning.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intecepted and reported as helpfully as possible.
\section{STRUCTURE PREAMBLE}
=SML
structure €ZTypesAndTerms› : ZTypesAndTerms = struct
=TEX
We open the structure containing the support package (see \cite{DS/FMU/IED/IMP048}).
=SML
open ZTypesAndTermsSupport;
=TEX
\section{DERIVED HOL CONSTRUCTORS}
The functions defined here are an ad-hoc collection of constructors, destructors and discriminators which, at the time of writing, were not provided by the ICL HOL system.
If they are added in future, they will be removed from here.
=SML
fun	€list_mk_≠_type› ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_≠_type tyl ty;
=TEX
\section{AUXILIARY FUNCTIONS}
\subsection{Name Destruction}
We need the inverse of the name construction functions (defined in
\cite{DS/FMU/IED/DTD048}).  Given a name formed as a simple identifier
followed by a sequence of name lists with each name list in square
brackets function $dest\_Z\_name$ returns the identifier name plus a
list of lists.  Thus a name like

=GFT
	"abc[de,fg,hi][jk,lm][no][p,r,s]"
=TEX

is split into the following pieces

=GFT
	("abc",
	[	["de", "fg", "hi"],
		["jk", "lm"],
		["no"],
		["p", "r", "s"]
	], Nil)
=TEX

Projections are of the form
=GFT
	"abc[de,fg,hi]jk"
=TEX

which is split into the following:

=GFT
	("abc",
	[	["de", "fg", "hi"]
	], Value "jk")
=TEX


Function $dest\_Z\_name$ splits up well formed names by interpreting the
square brackets and commas, it complains about mal-formed names.

=SML
fun	€dest_Z_name› (s:string) :string * string list list * string OPT = (
let
	exception bad_name;

	fun	addnam (nil:string list) (cl:string list)
			: string list = cl
	|	addnam n cl = (implode(rev n)) :: cl
	;

	fun	aux(nil, Value _, _) = raise bad_name
	|	aux(nil, Nil, pl) = (rev pl, Nil)

	|	aux("["::t (*=]=*), Value _, _) = raise bad_name
	|	aux("["::t (*=]=*), Nil, pl) = aux(t, Value(nil, nil), pl)

	|	aux(","::t, Nil, _) = raise bad_name
	|	aux(","::t, Value(cn, cl), pl) = aux(t, Value(nil, addnam cn cl), pl)

	|	aux((*=[=*) "]"::t, Nil, _) = raise bad_name
	|	aux((*=[=*) "]"::t, Value(cn, cl), pl) = aux(t, Nil, (rev(addnam cn cl)) :: pl)

	|	aux(l as(ch::t), Nil, pl) = (
			case get_id(l, nil)
			of (nil, nam) => (rev pl, Value(implode(rev nam)))
			| _ => raise bad_name
		)
	|	aux(ch::t, Value(cn, cl), pl) = aux(t, Value(ch::cn, cl), pl)
	

	and	get_id(nil, prev) = (nil, prev)
	|	get_id(l as ("["::_ (*=]=*)), prev) = (l, prev)
	|	get_id(","::t, _) = raise bad_name
	|	get_id((*=[=*) "]"::t, _) = raise bad_name
	|	get_id(ch::t, prev) = get_id(t, ch :: prev)
	;
in
	let
		val (tail, front) = get_id(explode s, nil);
		val (boxed_lists, projector) = aux(tail, Nil, nil);
	in
		(implode(rev front), boxed_lists, projector)
	end
	handle Fail _ => fail "dest_Z_name" 47000 [fn () => s]
	| bad_name => fail "dest_Z_name" 47000 [fn () => s]
end
);
=TEX

=IGN
fun	€dest_Z_name› (s:string) :string * string list list = (
let
	exception bad_name;

	fun	addnam (nil:string list) (cl:string list)
			: string list = cl
	|	addnam n cl = (implode(rev n)) :: cl
	;

	fun	aux(nil, Value _, _) = raise bad_name
	|	aux(nil, Nil, pl) = rev pl

	|	aux("["::t (*=]=*), Value _, _) = raise bad_name
	|	aux("["::t (*=]=*), Nil, pl) = aux(t, Value(nil, nil), pl)

	|	aux(","::t, Nil, _) = raise bad_name
	|	aux(","::t, Value(cn, cl), pl) = aux(t, Value(nil, addnam cn cl), pl)

	|	aux((*=[=*) "]"::t, Nil, _) = raise bad_name
	|	aux((*=[=*) "]"::t, Value(cn, cl), pl) = aux(t, Nil, (rev(addnam cn cl)) :: pl)

	|	aux(ch::t, Nil, _) = raise bad_name
	|	aux(ch::t, Value(cn, cl), pl) = aux(t, Value(ch::cn, cl), pl)
	;

	fun	get_id(nil, prev) = (nil, prev)
	|	get_id(l as ("["::_ (*=]=*)), prev) = (l, prev)
	|	get_id(","::t, _) = raise bad_name
	|	get_id((*=[=*) "]"::t, _) = raise bad_name
	|	get_id(ch::t, prev) = get_id(t, ch :: prev)
	;
in
	let
		val (tail, front) = get_id(explode s, nil)
	in
		(implode(rev front), aux(tail, Nil, nil))
	end
	handle Fail _ => fail "dest_Z_name" 47000 [fn () => s]
	| bad_name => fail "dest_Z_name" 47000 [fn () => s]
end
);
=TEX
\section{Z TYPES}
The following sections describe the constructor, discriminator and destructor functions for each of the five Z type constructors.
\subsection{The Datatype ZTYPE}

The general mapping functions $mk\-\_ZTYPE$, $is\-\_ZTYPE$ and
$dest\-\_ZTYPE$, which are declared later in this document, use this
datatype.

=SML
datatype	€ZTYPE› = 	€ZgivenT› of string
		|		€ZvarT› of string
		|		€ZpowerT› of TYPE
		|		€ZtupleT› of TYPE list
		|		€ZschemaT› of (string * TYPE) list;
=TEX
\subsection{The General Destructor Function}
This function converts a HOL type to the appropriate form of the above datatype (providing, of course, that it represents a valid Z type).
=SML
fun	€dest_ZTYPE› (ty:TYPE) :ZTYPE =
	case dest_simple_type ty of
		Vartype s => (
			case explode s of
				("'"::t) => ZvarT(implode t)
			|	_ => fail "" 0 []
		)
	|	Ctype("SET",[ty1]) => ZpowerT ty1
	|	Ctype(s,tyl) => (
			case (dest_Z_name s,tyl) of
				(("Z'T",[[n]], Nil),tyl) => 
					if string_of_int(length tyl) = n
					then ZtupleT tyl
					else fail "" 0 []
			|	(("Z'S",[cl], Nil),tyl) => 
					ZschemaT(combine cl tyl)
			|	(_,[]) => ZgivenT s
			|	_ => fail "" 0 []
		)
	handle Fail _ => type_fail "dest_ZTYPE" 47800 [ty];
=TEX
\subsection{The General Discriminator Function}
=SML
fun	€is_ZTYPE› (t:TYPE) :bool =
	let	val x = dest_ZTYPE t
	in
		true
	end
	handle Fail _ => false;
=TEX
\subsection{Given Sets}
=SML
fun	€mk_ZgivenT› (s:string) :TYPE = mk_ctype(s,[]);

fun	€is_ZgivenT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZgivenT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	€dest_ZgivenT› (ty :TYPE) :string = (
	case dest_ZTYPE ty of
		ZgivenT s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZgivenT" 47010 [ty];
=TEX
\subsection{Generic Variables}
=SML
fun	€mk_ZvarT› (s:string) :TYPE = mk_vartype("'" ^ s);

fun	€is_ZvarT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZvarT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	€dest_ZvarT› (ty :TYPE) :string = (
	case dest_ZTYPE ty of
		ZvarT s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZvarT" 47020 [ty];
=TEX
\subsection{Set Types}
=SML
fun	€mk_ZpowerT› (ty:TYPE) :TYPE = mk_ctype("SET",[ty]);

fun	€is_ZpowerT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZpowerT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	€dest_ZpowerT› (ty :TYPE) :TYPE = (
	case dest_ZTYPE ty of
		ZpowerT t => t
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZpowerT" 47030 [ty];
=TEX
\subsection{Cartesian Product Types}
=SML
fun	€mk_ZtupleT› (tyl:TYPE list) :TYPE = 
		tuple_type tyl;

fun	€is_ZtupleT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZtupleT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	€dest_ZtupleT› (ty :TYPE) :TYPE list = (
	case dest_ZTYPE ty of
		ZtupleT tyl => tyl
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZtupleT" 47040 [ty];
=TEX
\subsection{Binding Types}
=SML
fun	€mk_ZschemaT› (itym:(string * TYPE) list) :TYPE =
		bind_type itym;

fun	€is_ZschemaT› (ty :TYPE) :bool = (
	case dest_ZTYPE ty of	
		ZschemaT _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	€dest_ZschemaT› (ty :TYPE) :(string * TYPE) list = (
	case dest_ZTYPE ty of
		ZschemaT itym => itym
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_ZschemaT" 47050 [ty];
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $ZTERM$ to the corresponding $TERM$.
=SML
fun	€mk_ZTYPE›	(ZgivenT(s:string) :ZTYPE) :TYPE = mk_ZgivenT s
|	mk_ZTYPE	(ZvarT(s:string)) = mk_ZvarT s
|	mk_ZTYPE	(ZpowerT(ty:TYPE)) = mk_ZpowerT ty
|	mk_ZTYPE	(ZtupleT(tyl:TYPE list)) = mk_ZtupleT tyl
|	mk_ZTYPE	(ZschemaT(itym:(string * TYPE)list)) = mk_ZschemaT itym;
=TEX
\section{Z TERMS}
The following describes the constructor, discriminator and destructor functions for Z terms.
\subsection{The Datatype ZTERM}

The general mapping functions $mk\-\_ZTERM$, $is\-\_ZTERM$ and
$dest\-\_ZTERM$, which are declared later in this document, use this
datatype.

=SML
datatype	€ZTERM›
		=	 	€Zdec› of TERM list * TERM
		|		€Zdecsexp› of TERM * string
		|		€Zdecl› of TERM list
		|		€Zeq› of TERM * TERM
		|		€Zç› of TERM * TERM
		|		€Ztrue›
		|		€Zfalse›
		|		€Z≥› of TERM
		|		€Z±› of TERM * TERM
		|		€Z≤› of TERM * TERM
		|		€Z¥› of TERM * TERM
		|		€Z§› of TERM * TERM
		|		€Z∂› of TERM * TERM * TERM
		|		€Z∂â1› of TERM * TERM * TERM
		|		€Zµ› of TERM * TERM * TERM
		|		€Zpredsexp› of TERM * string
		|		€Zlvar› of string * TYPE * TERM list
		|		€Zgvar› of string * TYPE * TERM list
		|		€Zint› of string
		|		€Zß¢› of TYPE * TERM list
		|		€Zsetd› of TYPE * TERM list
		|		€Zseta› of TERM * TERM * TERM
		|		€Z› of TERM
		|		€Ztuple› of TERM list
		|		€Z∏› of TERM list
		|		€Z › of TERM * string
		|		€Zsel› of TERM * string
		|		€Zapp› of TERM * TERM
		|		€ZÃ› of TERM * TERM * TERM
		|		€ZÕ› of TERM * TERM * TERM
		|		€Zâs› of TERM * TERM
		|		€Zdecâs› of TERM * string
		|		€Zpreâs› of TERM
		|		€Z≥âs› of TERM
		|		€Z±âs› of TERM * TERM
		|		€Z≤âs› of TERM * TERM
		|		€Z¥âs› of TERM * TERM
		|		€Z§âs› of TERM * TERM
		|		€Z˘âs› of TERM * TERM
		|		€Zhideâs› of TERM * string list
		|		€Z∂âs› of TERM * TERM * TERM
		|		€Z∂â1âs› of TERM * TERM * TERM
		|		€Zµâs› of TERM * TERM * TERM
		|		€ZÑâs› of TERM
		|		€Zòâs› of TERM
		|		€Zªâs› of TERM * TERM
		;
=TEX

\subsection{Result of Basic Destructor Function}

This function converts a HOL term to the appropriate form of the
datatype $ZTERM$, or to an encoding of why it could not be converted.
The encoded failure value is intended for use by the pretty
printer~\cite{DS/FMU/IED/DTD031,DS/FMU/IED/DTD064}, it contains values
showing how (in some cases) the term might be HOL if it were modified
slightly.  The return value from the basic destructor function is
in type $BDZ$ (named for `Basic Destroy Z').

=SML
datatype €BDZ›
	=	€bdz_ok›	of ZTERM
	|	€bdz_not_Z›	of int
	|	€bdz_fail›	of {
			€bdz_f_code›	: int,
			€bdz_f_compc›	: int,
			€bdz_f_argc›	: int
		}
	;
=TEX

Successful destruction returns $bdz\_ok$ with the Z term.  Value
$bdz\_fail$ is returned when the term is similar to a Z~term (i.e., it
has a known constructor but the wrong number of arguments).  In this
case the $bdz\_f\_compc$ and $bdz\_f\_argc$ fields tell how many component
lists and arguments (respectively) are allowed in a well formed
Z~term.  Value $bdz\_not\_Z$ is returned when the term is not
recognisable as a Z~term.  In cases where insufficient component lists
or arguments are given to a known constructor either $bdz\_fail$ or
$bdz\_not\_Z$ may be returned.

\subsection{Destructor Utilities}

=SML
fun €zdest_0_0›(nil, nil, _, v) = bdz_ok v
| zdest_0_0(_, _, e, _) = bdz_not_Z 47900
;

fun €zdest_1_gt0›(_, nil, e, _) = bdz_not_Z 47900
| zdest_1_gt0(_::_, a, _, v) = bdz_ok(v a)
| zdest_1_gt0(_, _, e, _) = bdz_not_Z 47900
;

fun €zdest_0_1›(nil, [x], _, v) = bdz_ok(v x)
| zdest_0_1 (_, _::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=0, bdz_f_argc=1}
| zdest_0_1(_, _, e, _) = bdz_not_Z 47900
;

fun €zdest_0_2›(nil, [x, y], _, v) = bdz_ok(v(x,y))
| zdest_0_2 (_, _::_::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=0, bdz_f_argc=2}
| zdest_0_2(_, _, e, _) = bdz_not_Z 47900
;

fun €zdest_1_1›([_], [x], _, v) = bdz_ok(v x)
| zdest_1_1 (_, _::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=1, bdz_f_argc=1}
| zdest_1_1(_, _, e, _) = bdz_not_Z 47900
;

fun €zdest_2_2›([_, _], [x, y], _, v) = bdz_ok(v(x, y))
| zdest_2_2 (_, _::_::_::_, e, _) =
	bdz_fail{bdz_f_code=e, bdz_f_compc=2, bdz_f_argc=2}
| zdest_2_2(_, _, e, _) = bdz_not_Z 47900
;
=IGN
fun €zdest_gt0_0›(nil, nil, e, _) = bdz_not_Z 47900
| zdest_gt0_0(_, nil, _, v) = bdz_ok v
| zdest_gt0_0(_, _, e, _) = bdz_not_Z 47900
;
=TEX

=SML
fun €dest_val_tuple›(name:string, ty: TYPE, constr:string * TYPE * TERM list -> ZTERM,
		arg_tm:TERM, e:int) : BDZ = (
	let
		val (arg_fn, args) = strip_app arg_tm;
		val (arg_name, arg_ty) = dest_const arg_fn;
	in
		case dest_Z_name arg_name
		of ("Z'Mk_T", [_], Nil) =>
			bdz_ok(constr(name, snd(dest_≠_type ty), args))
		| _ =>
			bdz_fail{bdz_f_code=e,
				bdz_f_compc=0, bdz_f_argc=0}
	end
	handle Fail _ =>
		bdz_fail{bdz_f_code=e, bdz_f_compc=0, bdz_f_argc=0}
);
=TEX

=SML
fun	€dest_abstraction› (t:TERM) :TERM list =
		snd(strip_app(snd(strip_Ã t)))
	handle Fail _ => term_fail "dest_ZTERM" 47901 [t];
=TEX

=SML
fun	€dest_∂body› (t:TERM) :TERM list =
		snd(strip_app(snd(strip_∂ t)))
	handle Fail _ => term_fail "dest_ZTERM" 47901 [t];
=TEX

=SML
fun	€dest_µbody› (t:TERM) :TERM list =
		snd(strip_app(snd(strip_µ t)))
	handle Fail _ => term_fail "dest_ZTERM" 47901 [t];
=TEX

\subsection{The Basic Destructor Function}

Function $basic\_dest\_ZTERM$ does the work of destroying a term to
yield its Z~structure.  The arguments are in the result of applying
$strip\_app$ to a term.  (This parameterisation is of benefit to the
pretty printer~\cite{DS/FMU/IED/DTD031}.)

The main part of this function is a large case clause which switches
depending on the name of the constant at the head of the stripped
application, the other cases are simple and dealt with in the
immedaitely following block of code.

=SML
fun €basic_dest_ZTERM› (hdterm:TERM, args:TERM list) : BDZ = (
	case dest_simple_term hdterm
	of App _ => bdz_not_Z 47900
	| SimpleÃ _ => bdz_not_Z 47900
	| Var (name, ty) => (
		case args
		of nil => bdz_ok(Zlvar(name, ty,[]))
		| [tm] => dest_val_tuple(name, ty, Zlvar, tm, 47090)
		| _ => bdz_fail{bdz_f_code=47090,
				bdz_f_compc=0, bdz_f_argc=1}
	)
	| Const (name, ty) => (
		let
			val (identifier, comp_list, projector) = dest_Z_name name;
		in
			case (identifier, projector) of
			("Z'S", Value s) => (
				case args of
				[x] => bdz_ok(Zsel(x,s))
				| _ => bdz_fail{bdz_f_code=47180, bdz_f_compc=2,
								bdz_f_argc=1}
				)
			| (x, Nil) => (
				case identifier
=TEX


The $case$ clause started on the line above opens up the Z~term based
on the names of the constant.  The various options are catered for in
the following sections, the end of the function is in
section~\ref{EndOfFunctionBDZ}.

=TEX

\subsubsection{Declarations}
First we look for declarations, beginning with variables.
=SML
of "Z'dec" => (
	case (comp_list, args)
	of ([],[x]) => (
		bdz_ok(Zdec((dest_list ** Combinators.I)(dest_pair x)))
		handle Fail _ => bdz_not_Z 47900
	)
	| _ => bdz_fail{bdz_f_code=47910, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
Then schema declarations.
=SML
| "Z'decsexp" => (
	case (comp_list, args)
	of ([],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			bdz_ok(Zdecsexp(sch,d))
		end
		handle Fail _ => bdz_not_Z 47911
		)
	| _ => bdz_fail{bdz_f_code=47911, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
And composite declarations.
Note that all declarations used in other constructs must be of this
form, even if only one of the above forms is used (it is even possible
to have an empty declaration under certain circumstances).
=SML
| "Z'decl" => (
	case (comp_list, args)
	of ([],[x]) => (
		bdz_ok(Zdecl(dest_list x))
		handle Fail _ => bdz_not_Z 47912
	)
	| _ => bdz_fail{bdz_f_code=47912, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
\subsubsection{Predicates}

The logical connectives, `true' and `false', map directly on to the
equivalent HOL constants.

=SML
| "T"	=> zdest_0_0(comp_list, args, 47900, Ztrue)
| "F"	=> zdest_0_0(comp_list, args, 47900, Zfalse)
=TEX

Equality and equivalence both use the HOL `$=$' constant, they are distinguished by the
types of their operands.  Equivalence has both arguments of type $BOOL$.

=IGN
| "="	=> zdest_0_2(comp_list, args, 47220, Zeq)
| "§"	=> zdest_0_2(comp_list, args, 47280, Z§)
=SML
| "="	=> (
	case (comp_list, args)
	of (nil,[x, y]) => (
		bdz_ok(	(if type_of x =: BOOL andalso type_of y =: BOOL
			then Z§
			else Zeq
			)(x,y)
		)
	)
	| (_, _::_::_::_) =>
		bdz_fail{bdz_f_code=47220, bdz_f_compc=0, bdz_f_argc=2}
	| _ => bdz_not_Z 47900
)
=TEX

=SML
| "ç"	=> zdest_0_2(comp_list, args, 47230, Zç)
| "≥"	=> zdest_0_1(comp_list, args, 47240, Z≥)
| "±"	=> zdest_0_2(comp_list, args, 47250, Z±)
| "≤"	=> zdest_0_2(comp_list, args, 47260, Z≤)
| "¥"	=> zdest_0_2(comp_list, args, 47270, Z¥)
=TEX
=SML
| "Z'∂" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_∂body x
		of	[d,p,v] => bdz_ok(Z∂(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47920
	)
	| _ => bdz_fail{bdz_f_code=47920, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'∂â1" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => bdz_ok(Z∂â1(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47921
	)
	| _ => bdz_fail{bdz_f_code=47921, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'µ" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_µbody x of
			[d,p,v] => bdz_ok(Zµ(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47922
	)
	| _ => bdz_fail{bdz_f_code=47922, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'predsexp" => (
	case (comp_list, args)
	of ([],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			bdz_ok(Zpredsexp(sch,d))
		end
		handle Fail _ => bdz_not_Z 47923
	)
	| _ => bdz_fail{bdz_f_code=47923, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
\subsubsection{Terms}

We must postpone the handling of local and global variables until the
end of the case clause because they do not have an easily identifiable
constant part.

=SML
| "Z'int" => (
	case (comp_list, args)
	of ([],[tm]) => (
		bdz_ok(Zint(fst(dest_const tm)))
		handle Fail _ => bdz_not_Z 47105
	)
	| _ => bdz_fail{bdz_f_code=47105, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'ß¢" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_ctype(type_of x) of
			("LIST",[t]) => bdz_ok(Zß¢(t,dest_list x))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47110
	)
	| _ => bdz_fail{bdz_f_code=47110, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'setd" => (
	case (comp_list, args)
	of ([],[x]) => (
		case dest_ctype(type_of x) of
			("LIST",[t]) => bdz_ok(Zsetd(t,dest_list x))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47120
	)
	| _ => bdz_fail{bdz_f_code=47120, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'seta" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => bdz_ok(Zseta(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47130
	)
	| _ => bdz_fail{bdz_f_code=47130, bdz_f_compc=1, bdz_f_argc=1}
)
=TEX
=SML
| "Z'"	=> zdest_0_1	(comp_list, args, 47140, Z)
| "Z'Mk_T"	=> zdest_1_gt0	(comp_list, args, 47150, Ztuple)
| "Z'∏"	=> zdest_1_gt0	(comp_list, args, 47160, Z∏)
=TEX
=SML
| "Z' " => (
	case (comp_list, args)
	of ([],[x]) => (
		let	val (bind,sch) = dest_pair x;
			val btym = map dest_var (snd(strip_app bind));
			val stym = dest_ZschemaT(dest_ZpowerT(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			bdz_ok(Z (sch,d))
		end
		handle Fail _ => bdz_not_Z 47170
	)
	| _ => bdz_fail{bdz_f_code=47170, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'Mk_S" => (
	bdz_fail{bdz_f_code=47180, bdz_f_compc=2, bdz_f_argc=1}
)

=TEX
=SML
| "Z'app" => (
	case (comp_list, args)
	of ([],[x]) => (
		bdz_ok(Zapp(dest_pair x))
		handle Fail _ => bdz_not_Z 47190
	)
	| _ => bdz_fail{bdz_f_code=47190, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'Ã" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,t,v] => bdz_ok(ZÃ(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47200
	)
	| _ => bdz_fail{bdz_f_code=47200, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'Õ" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p,v] => bdz_ok(ZÕ(d,p,v))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47936
	)
	| _ => bdz_fail{bdz_f_code=47936, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
\subsubsection{Schemas}
=SML
| "Z'âs" => (
	case (comp_list, args)
	of ([_],[x]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Zâs(d,p))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47940
	)
	| _ => bdz_fail{bdz_f_code=47940, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX
=SML
| "Z'decâs" => (
	case (comp_list, args)
	of ([_,[]],[x]) => bdz_ok(Zdecâs(x,""))
	| ([_,[s]],[x]) => bdz_ok(Zdecâs(x,s))
	| _ => bdz_fail{bdz_f_code=47340, bdz_f_compc=1, bdz_f_argc=1}
)
=TEX
=SML
| "Z'preâs"	=> zdest_1_1(comp_list, args, 47350, Zpreâs)
| "Z'≥âs"	=> zdest_0_1(comp_list, args, 47360, Z≥âs)
| "Z'±âs"	=> zdest_2_2(comp_list, args, 47370, Z±âs)
| "Z'≤âs"	=> zdest_2_2(comp_list, args, 47380, Z≤âs)
| "Z'¥âs"	=> zdest_2_2(comp_list, args, 47390, Z¥âs)
| "Z'§âs"	=> zdest_2_2(comp_list, args, 47400, Z§âs)
| "Z'˘âs"	=> zdest_2_2(comp_list, args, 47410, Z˘âs)
=TEX
=SML
| "Z'hideâs" => (
	case (comp_list, args)
	of ([_,sl],[x]) => bdz_ok(Zhideâs(x,sl))
	| _ => bdz_fail{bdz_f_code=47420, bdz_f_compc=2, bdz_f_argc=1}
)
=TEX
=SML
| "Z'∂âs" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Z∂âs(d,p,y))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47941
	)
	| _ => bdz_fail{bdz_f_code=47941, bdz_f_compc=2, bdz_f_argc=2}
)
=TEX
=SML
| "Z'∂â1âs" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Z∂â1âs(d,p,y))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47942
	)
	| _ => bdz_fail{bdz_f_code=47942, bdz_f_compc=2, bdz_f_argc=2}
)
=TEX
=SML
| "Z'µâs" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		case dest_abstraction x of
			[d,p] => bdz_ok(Zµâs(d,p,y))
		|	_ => fail "" 0 []
		handle Fail _ => bdz_not_Z 47943
	)
	| _ => bdz_fail{bdz_f_code=47943, bdz_f_compc=2, bdz_f_argc=2}
)
=TEX
=SML
| "Z'Ñâs"	=> zdest_1_1(comp_list, args, 47460, ZÑâs)
| "Z'òâs"	=> zdest_1_1(comp_list, args, 47470, Zòâs)
| "Z'ªâs"	=> zdest_2_2(comp_list, args, 47480, Zªâs)
=TEX
\subsubsection{Local and Global Variables}
=SML
| _ => (
	case (comp_list, args)
	of (nil, nil) => (
		(	case unbind_gvar_name name
			of n => bdz_ok(Zgvar(n, ty,[]))
		) handle Fail _ => bdz_not_Z 47100
		)
	| (nil, [tm]) => (
		(	case unbind_gvar_name name
			of n => dest_val_tuple(n, ty, Zgvar, tm, 47100)
		) handle Fail _ => bdz_not_Z 47100
		)
	| _ => bdz_fail{bdz_f_code=47100, bdz_f_compc=0, bdz_f_argc=1}
)
=TEX

\subsubsection{End of the Basic Destructor Function}
\label{EndOfFunctionBDZ}

=SML
		)
		| (_, Value _) => bdz_not_Z 47100
		end (* of let in case Const *)
	) (* end of case Const (name, ty) => ... *)
	(* end of case dest_simple_term hdterm ... *)
	handle _ => bdz_not_Z 47100 
) (* end of function basic_dest_ZTERM *);
=TEX

\subsection{The General Z Destructor Function}

Function $dest\_ZTERM$ provides the normal interface for
destroying arbitrary Z~terms.  

=SML
fun	€dest_ZTERM› (t:TERM) :ZTERM = (
let
	val bdz_ans = basic_dest_ZTERM (strip_app t);
	fun sh(s, v) = diag_string("dest_ZTERM: ans is " ^ s ^ " " ^ (string_of_int v));
in
	case bdz_ans
	of bdz_ok zt => zt
	| bdz_not_Z e => term_fail "dest_ZTERM" e [t]
	| bdz_fail{bdz_f_code=e, ...} => term_fail "dest_ZTERM" e [t]
end
);
=TEX

\subsection{The General Z Discriminator Function}
=SML
fun	€is_ZTERM› (t:TERM) :bool =
	let	val x = dest_ZTERM t
	in
		true
	end
	handle Fail _ => false;
=TEX
\section{Constructor, Destructor and Discriminator Functions}

\subsection{Declaration Destructors}
=SML
fun	€dest_Zdec› (t:TERM) :(TERM list * TERM) =
	case dest_ZTERM t of
		Zdec(tml,tm) => (tml,tm)
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdec" 47061 [t];

fun	€dest_Zdecsexp› (t:TERM) :TERM * string =
	case dest_ZTERM t of
		Zdecsexp(tm,s) => (tm,s)
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdecsexp" 47071 [t];

fun	€dest_Zdecl› (t:TERM) :TERM list =
	case dest_ZTERM t of
		Zdecl tml => tml
	|	_ => fail "" 0 []
	handle Fail _ => term_fail "dest_Zdecl" 47912 [t];
=TEX
The following function, which produces a type map from a declaration, will frequently be required below.
=SML
local
fun	f ([] :TERM list) :(string * TYPE)list = []
|	f (h::t) = (
		map dest_var (fst(dest_Zdec h))
		handle Fail _ =>
		let val (sch,d) = dest_Zdecsexp h
		in
			map 	(fn(s,ty)=>(pack_IDENT(s,d),ty)) 
				(dest_ZschemaT(dest_ZpowerT(type_of sch)))
		end) @ (f t);
in
fun	€dest_decl› (t:TERM) :(string * TYPE)list =
		f (dest_Zdecl t)
	handle Fail _ => term_fail "dest_decl" 47912 [t]
end;
=TEX
\subsection{Declaration Discriminators}
=SML
fun	€is_Zdec› (t:TERM) :bool =
	case dest_ZTERM t of
		Zdec(tml,tm) => true
	|	_ => false
	handle Fail _ => false;

fun	€is_Zdecsexp› (t:TERM) :bool =
	case dest_ZTERM t of
		Zdecsexp(tm,s) => true
	|	_ => false
	handle Fail _ => false;

fun	€is_Zdecl› (t:TERM) :bool =
	case dest_ZTERM t of
		Zdecl tml => true
	|	_ => false
	handle Fail _ => false;
=TEX
\subsection{Predicate Destructors}
=SML
fun	€dest_Zeq› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zeq(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zeq" 47220 [t];

fun	€dest_Zç› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zç(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zç" 47230 [t];

fun	€dest_Z≥› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z≥(tm1) => (tm1) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≥" 47240 [t];

fun	€dest_Z±› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z±(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z±" 47250 [t];

fun	€dest_Z≤› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z≤(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≤" 47260 [t];

fun	€dest_Z¥› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z¥(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¥" 47270 [t];

fun	€dest_Z§› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z§(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z§" 47280 [t];

fun	€dest_Z∂› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂" 47290 [t];

fun	€dest_Z∂â1› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂â1(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂â1" 47300 [t];

fun	€dest_Zµ› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zµ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zµ" 47310 [t];

fun	€dest_Zpredsexp› (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zpredsexp(tm1,s) => (tm1,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zpredsexp" 47320 [t];
=TEX
\subsection{Predicate Discriminators}
=SML
fun	€is_Zeq› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zeq(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zç› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zç(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Ztrue› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Ztrue => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zfalse› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zfalse => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z≥› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≥(tm1) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z±› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z±(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z≤› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≤(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z¥› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¥(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z§› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z§(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z∂› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z∂â1› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂â1(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zµ› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zµ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zpredsexp› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zpredsexp(tm1,s) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Term Destructors}
=SML
fun	€dest_Zlvar› (t:TERM) :string * TYPE * TERM list = 
	case dest_ZTERM t of 
		Zlvar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zlvar" 47090 [t];

fun	€dest_Zgvar› (t:TERM) :string * TYPE * TERM list = 
	case dest_ZTERM t of 
		Zgvar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zgvar" 47100 [t];

fun	€dest_Zint› (t:TERM) :string = 
	case dest_ZTERM t of 
		Zint(s) => (s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zint" 47105 [t];

fun	€dest_Zß¢› (t:TERM) :TYPE * TERM list = 
	case dest_ZTERM t of 
		Zß¢(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zß¢" 47110 [t];

fun	€dest_Zsetd› (t:TERM) :TYPE * TERM list = 
	case dest_ZTERM t of 
		Zsetd(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zsetd" 47120 [t];

fun	€dest_Zseta› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zseta(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zseta" 47130 [t];

fun	€dest_Z› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z" 47140 [t];

fun	€dest_Ztuple› (t:TERM) :TERM list = 
	case dest_ZTERM t of 
		Ztuple(tml) => (tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Ztuple" 47150 [t];

fun	€dest_Z∏› (t:TERM) :TERM list = 
	case dest_ZTERM t of 
		Z∏(tml) => (tml) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∏" 47160 [t];

fun	€dest_Z › (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Z (tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z " 47170 [t];

fun	€dest_Zsel› (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zsel(tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zsel" 47180 [t];

fun	€dest_Zapp› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zapp(f,a) => (f,a) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zapp" 47190 [t];

fun	€dest_ZÃ› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		ZÃ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÃ" 47200 [t];

fun	€dest_ZÕ› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		ZÕ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÕ" 47210 [t];
=TEX
\subsection{Term Discriminators}
=SML
fun	€is_Zlvar› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zlvar(s,ty,tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zgvar› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zgvar(s,ty,tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zint› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zint(s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zß¢› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zß¢(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zsetd› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zsetd(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zseta› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zseta(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Ztuple› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Ztuple(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z∏› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∏(tml) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z › (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z (tm,s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zsel› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zsel(tm,s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zapp› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zapp(f,a) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_ZÃ› (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÃ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_ZÕ› (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÕ(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Destructors for the Schema Calculus}
=SML
fun	€dest_Zâs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zâs(d,p) => (d,p) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zâs" 47940 [t];

fun	€dest_Zdecâs› (t:TERM) :TERM * string = 
	case dest_ZTERM t of 
		Zdecâs(tm,s) => (tm,s) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zdecâs" 47340 [t];

fun	€dest_Zpreâs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zpreâs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zpreâs" 47350 [t];

fun	€dest_Z≥âs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Z≥âs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≥âs" 47360 [t];

fun	€dest_Z±âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z±âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z±âs" 47370 [t];

fun	€dest_Z≤âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z≤âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z≤âs" 47380 [t];

fun	€dest_Z¥âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z¥âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z¥âs" 47390 [t];

fun	€dest_Z§âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z§âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z§âs" 47400 [t];

fun	€dest_Z˘âs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Z˘âs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z˘âs" 47410 [t];

fun	€dest_Zhideâs› (t:TERM) :TERM * string list = 
	case dest_ZTERM t of 
		Zhideâs(tm,sl) => (tm,sl) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zhideâs" 47420 [t];

fun	€dest_Z∂âs› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂âs(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂âs" 47430 [t];

fun	€dest_Z∂â1âs› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Z∂â1âs(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Z∂â1âs" 47440 [t];

fun	€dest_Zµâs› (t:TERM) :TERM * TERM * TERM = 
	case dest_ZTERM t of 
		Zµâs(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zµâs" 47450 [t];

fun	€dest_ZÑâs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		ZÑâs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_ZÑâs" 47460 [t];

fun	€dest_Zòâs› (t:TERM) :TERM = 
	case dest_ZTERM t of 
		Zòâs(tm) => (tm) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zòâs" 47470 [t];

fun	€dest_Zªâs› (t:TERM) :TERM * TERM = 
	case dest_ZTERM t of 
		Zªâs(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [] 
	handle Fail _ => term_fail "dest_Zªâs" 47480 [t];
=TEX
\subsection{Discriminators for the Schema Calculus}
=SML
fun	€is_Zâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zâs(d,p) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zdecâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zdecâs(tm,s) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zpreâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zpreâs(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z≥âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≥âs(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z±âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z±âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z≤âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z≤âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z¥âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z¥âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z§âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z§âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z˘âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z˘âs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zhideâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zhideâs(tm,sl) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z∂âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂âs(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Z∂â1âs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Z∂â1âs(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zµâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zµâs(d,p,v) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_ZÑâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		ZÑâs(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zòâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zòâs(tm) => true 
	|	_ => false 
	handle Fail _ => false;

fun	€is_Zªâs› (t:TERM) :bool = 
	case dest_ZTERM t of 
		Zªâs(tm1,tm2) => true 
	|	_ => false 
	handle Fail _ => false;
=TEX
\subsection{Binding Construction}
There are three constructors below which generate systematically decorated bindings from schemas: schema references as declarations, schema references as predicates and theta terms.
We therefore provide the following general function for doing this.
=SML
local open ZTypesAndTermsSupport in
fun	€mk_binding› ((sch,d):TERM * string) :TERM =
	let	val itym = dest_ZschemaT(dest_ZpowerT(type_of sch));
		val itym' = map (fn(s,t) => (pack_IDENT(s,d),t)) itym;
		val bcons = bind_cterm itym;
		val argl = map mk_var (dest_ZschemaT(mk_ZschemaT itym'));
	in
		list_mk_app(bcons,argl)
	end
	handle Fail _ => term_fail "mk_binding" 47940 [sch];
end;
=TEX
\subsection{Declaration Constructors}
=SML
fun 	€mk_Zdec› ((varl,set):TERM list * TERM) :TERM =
	let	val sty = type_of set;
		val ety = dest_ZpowerT sty;
		val vl = mk_list varl
			handle X => reraise X "mk_Zdec";
		val decty = mk_≠_type(mk_∏_type(type_of vl,sty),¨:BOOLÆ);
		val dec = mk_const("Z'dec",decty);
	in
		mk_app(dec,mk_pair(vl,set))
	end
	handle X => (divert X "mk_Zdec"
			"dest_ZpowerT" 47060 [fn() => string_of_term set]

	);
=TEX
=SML
fun	€mk_Zdecsexp› ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_≠_type(mk_∏_type(bty,sty),BOOL);
		val con = mk_const("Z'decsexp",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;
=TEX
=SML
fun	€mk_Zdecl› (tml:TERM list) :TERM =
	let	val lis = mk_list tml;
		val decl = mk_const("Z'decl",mk_≠_type(type_of lis,BOOL));
	in
		mk_app(decl,lis)
	end
	handle X => pass_on X "mk_list" "mk_Zdecl";
=TEX
\subsection{Predicate Constructors}
=SML
val	€mk_Zeq› :(TERM * TERM) -> TERM = mk_eq
	handle X => pass_on X "mk_eq" "mk_Zeq";
=TEX
=SML
fun	€mk_Zç› ((tm1,tm2):TERM * TERM) :TERM = 
	let	val ty = list_mk_≠_type([type_of tm1, mk_ZpowerT (type_of tm1)],BOOL);
	in
		list_mk_app(mk_const("ç",ty),[tm1,tm2])
	end
	handle X => pass_on X "mk_app" "mk_Zç";
=TEX
True and False and the logical connectives in Z map directly into the corresponding HOL constants.
=SML
val	€mk_Ztrue› :TERM = mk_const("T",BOOL);

val	€mk_Zfalse› :TERM = mk_const("F",BOOL);

val	€mk_Z≥› :TERM -> TERM = mk_≥
	handle X => pass_on X "mk_≥" "mk_Z≥";

val	€mk_Z±› :(TERM * TERM) -> TERM = mk_±
	handle X => pass_on X "mk_±" "mk_Z±";

val	€mk_Z≤› :(TERM * TERM) -> TERM = mk_≤
	handle X => pass_on X "mk_≤" "mk_Z≤";

val	€mk_Z¥› :(TERM * TERM) -> TERM = mk_¥
	handle X => pass_on X "mk_¥" "mk_Z¥";

val	€mk_Z§› :(TERM * TERM) -> TERM = mk_§
	handle X => pass_on X "mk_§" "mk_Z§";

fun	€mk_Z∂› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_∂ (d,p,v,itym)
	end
	handle X => reraise X "mk_Z∂";

fun	€mk_Z∂â1› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		mk_app(∂â1_bterm itym,g2_abs(d,p,v,itym))
	end
	handle X => reraise X "mk_Z∂â1";

fun	€mk_Zµ› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_µ (d,p,v,itym)
	end
	handle X => reraise X "mk_Zµ";

fun	€mk_Zpredsexp› ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_≠_type(mk_∏_type(bty,sty),BOOL);
		val con = mk_const("Z'predsexp",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;
=TEX
\subsection{Term Constructors}
=SML
fun	€mk_Zß¢› ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val seqty = mk_ZpowerT(mk_ZtupleT[mk_ZgivenT "˙",ty]);
		val zseqty = mk_≠_type(listy,seqty);
		val zseq = mk_const("Z'ß¢",zseqty);
	in
		case tml of 
			[] => mk_app(zseq,mk_empty_list ty)
		|	_ => mk_app(zseq,mk_list tml)
	end;

fun	€mk_Zsetd› ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val setty = mk_ZpowerT ty;
		val zsetty = mk_≠_type(listy,setty);
		val zset = mk_const("Z'setd",zsetty);
	in
		case tml of 
			[] => mk_app(zset,mk_empty_list ty)
		|	_ => mk_app(zset,mk_list tml)
	end;

fun	€mk_Zseta› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
		val vty = type_of v;
	in
		mk_app (seta_bterm itym vty, g2_abs(d,p,v,itym))
	end;
=TEX
$mk\_Z$ only makes sense if its argument is a set, but we do not bother to check that here, since the type checker should catch this kind of thing and the definition of the constant $Z$ will prevent us from doing any damage.
=SML
fun	€mk_Z› (tm:TERM) :TERM = 
	let	val ty = type_of tm;
		val psetty = mk_ZpowerT ty;
		val zpsetty = mk_≠_type(ty,psetty);
		val zpset = mk_const("Z'",zpsetty);
	in
		mk_app(zpset,tm)
	end;

fun	€mk_Ztuple› (tml:TERM list) :TERM = 
	let	val tyl = map type_of tml;
	in
		list_mk_app(tuple_cterm tyl,tml)
	end;

fun	€mk_Z∏› (tml:TERM list) :TERM = 
	let	val tyl = map (dest_ZpowerT o type_of) tml;
	in
		list_mk_app(prod_cterm tyl,tml)
	end;

fun	€mk_Z › ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = mk_≠_type(mk_∏_type(bty,sty),bty);
		val con = mk_const("Z' ",cty);
	in
		mk_app(con,mk_pair(bind,sch))
	end;

fun	€mk_Zsel› ((tm,s):TERM * string) :TERM = 
	let	val tym = dest_ZschemaT(type_of tm);
	in
		mk_app(bind_pterm tym s,tm)
	end;

fun	€mk_Zapp› ((tm1,tm2):TERM * TERM) :TERM = 
	let	val fty = type_of tm1;
		val aty = type_of tm2;
		val rty = 
			case dest_ZtupleT(dest_ZpowerT fty) of
				[_,r] => r
			|	_ => term_fail "mk_Zapp" 0 [];
		val zappty = mk_≠_type(mk_∏_type(fty,aty),rty);
		val zapp = mk_const("Z'app",zappty);
	in
		mk_app(zapp,mk_pair(tm1,tm2))
	end;
=TEX
=SML
local
fun	f ([]:ZTERM list) :TERM list = []
|	f (Zdec(tml,_)::ztml) = tml @ (f ztml)
|	f (Zdecsexp(sch,d)::ztml) = (mk_Z (sch,d)) :: (f ztml)
|	f _ = term_fail "mk_ZÃ" 0 [];

fun	chartuple ((Zdecl tml):ZTERM) :TERM = (
		case (f (map dest_ZTERM tml)) of
			[] => fail "mk_ZÃ" 0 []
		|	[tm] => tm
		|	tml' => mk_Ztuple tml'
		)
|	chartuple _ = fail "mk_ZÃ" 0 [];
in
fun	€mk_ZÃ› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val t = chartuple(dest_ZTERM d);
		val tym = dest_decl d;
		val tty = type_of t;
		val vty = type_of v;
	in
		mk_app(Ã_bterm tym tty vty,g3_abs(t,d,p,v,tym))
	end
	handle	Fail _ => term_fail "mk_ZÃ" 47201 [d,p,v]
end;
=TEX
=SML
fun	€mk_ZÕ› ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val tym = dest_decl d;
		val vty = type_of v;
	in
		mk_app(Õ_bterm tym vty,g2_abs(d,p,v,tym))
	end;

fun	€mk_Zlvar› ((s,ty,tml):string * TYPE * TERM list) :TERM = 
		case tml of [] 	=> mk_var(s,ty)
		| _		=> 
			let	val cty = mk_≠_type(mk_ZtupleT(map type_of tml),ty);
			in
				mk_app(mk_var(s,cty),mk_Ztuple tml)
			end;

fun	€mk_Zgvar› ((s,ty,tml):string * TYPE * TERM list) :TERM =
		case tml of [] 	=> bind_gvar_term (s,ty)
		| _		=> 
			let	val cty = mk_≠_type(mk_ZtupleT(map type_of tml),ty);
			in
				mk_app(bind_gvar_term (s,cty),mk_Ztuple tml)
			end;

fun	€mk_Zint› (s:string) :TERM = 
	let	val nty = mk_ctype("Ó",[]);
		val zty = mk_ctype("˙",[]);
		val zint = mk_const("Z'int",mk_≠_type(nty,zty));
	in
		mk_app(zint,mk_const(s,nty))
	end;
=TEX
\subsection{Constructors for the Schema Calculus}
=SML
fun	€mk_Zâs› ((d,p):TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
	in
		mk_app (schema_bterm itym, g1_abs(d,p,itym))
	end;

fun	€mk_Zdecâs› ((tm,s):TERM * string) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_decor_term tym s,tm)
	end;

fun	€mk_Zpreâs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_pre_term tym,tm)
	end;

fun	€mk_Z≥âs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_≥_term tym,tm)
	end;

fun	€mk_Z±âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_±_term tym1 tym2,[tm1,tm2])
	end;

fun	€mk_Z≤âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_≤_term tym1 tym2,[tm1,tm2])
	end;

fun	€mk_Z¥âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_¥_term tym1 tym2,[tm1,tm2])
	end;

fun	€mk_Z§âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_§_term tym1 tym2,[tm1,tm2])
	end;

fun	€mk_Z˘âs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_˘_term tym1 tym2,[tm1,tm2])
	end;

fun	€mk_Zhideâs› ((tm,sl):TERM * string list) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_hide_term tym sl,tm)
	end;

fun	€mk_Z∂âs› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(∂âs_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	€mk_Z∂â1âs› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(∂â1âs_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	€mk_Zµâs› ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_ZschemaT(dest_ZpowerT(type_of v));
	in
		list_mk_app(µâs_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	€mk_ZÑâs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_Ñ_term tym,tm)
	end;

fun	€mk_Zòâs› (tm:TERM) :TERM =
	let	val tym = dest_ZschemaT(dest_ZpowerT(type_of tm));
	in
		mk_app(bind_ò_term tym,tm)
	end;

fun	€mk_Zªâs› ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_ZschemaT(dest_ZpowerT(type_of tm1));
		val tym2 = dest_ZschemaT(dest_ZpowerT(type_of tm2));
	in
		list_mk_app(bind_ª_term tym1 tym2,[tm1,tm2])
	end;
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $ZTERM$ to the corresponding $TERM$.
=SML
fun	€mk_ZTERM›	(Zdec(tml:TERM list,tm:TERM) :ZTERM) :TERM = mk_Zdec(tml,tm)
|	mk_ZTERM	(Zdecsexp(tm:TERM,s:string)) = mk_Zdecsexp(tm,s)
|	mk_ZTERM	(Zdecl(tml:TERM list)) = mk_Zdecl tml
|	mk_ZTERM	(Zeq(tm1:TERM,tm2:TERM)) = mk_Zeq(tm1,tm2)
|	mk_ZTERM	(Zç(tm1:TERM,tm2:TERM)) = mk_Zç(tm1,tm2)
|	mk_ZTERM	(Ztrue) = mk_Ztrue
|	mk_ZTERM	(Zfalse) = mk_Zfalse
|	mk_ZTERM	(Z≥(tm:TERM)) = mk_Z≥ tm
|	mk_ZTERM	(Z±(tm1:TERM,tm2:TERM)) = mk_Z±(tm1,tm2)
|	mk_ZTERM	(Z≤(tm1:TERM,tm2:TERM)) = mk_Z≤(tm1,tm2)
|	mk_ZTERM	(Z¥(tm1:TERM,tm2:TERM)) = mk_Z¥(tm1,tm2)
|	mk_ZTERM	(Z§(tm1:TERM,tm2:TERM)) = mk_Z§(tm1,tm2)
|	mk_ZTERM	(Z∂(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂(tm1,tm2,tm3)
|	mk_ZTERM	(Z∂â1(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂â1(tm1,tm2,tm3)
|	mk_ZTERM	(Zµ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zµ(tm1,tm2,tm3)
|	mk_ZTERM	(Zpredsexp(tm:TERM,s:string)) = mk_Zpredsexp(tm,s)
|	mk_ZTERM	(Zlvar(s:string,ty:TYPE,tml:TERM list)) = mk_Zlvar(s,ty,tml)
|	mk_ZTERM	(Zgvar(s:string,ty:TYPE,tml:TERM list)) = mk_Zgvar(s,ty,tml)
|	mk_ZTERM	(Zint(s:string)) = mk_Zint(s)
|	mk_ZTERM	(Zß¢(ty:TYPE,tml:TERM list)) = mk_Zß¢(ty,tml)
|	mk_ZTERM	(Zsetd(ty:TYPE,tml:TERM list)) = mk_Zsetd(ty,tml)
|	mk_ZTERM	(Zseta(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zseta(tm1,tm2,tm3)
|	mk_ZTERM	(Z(tm:TERM)) = mk_Z tm
|	mk_ZTERM	(Ztuple(tml:TERM list)) = mk_Ztuple tml
|	mk_ZTERM	(Z∏(tml:TERM list)) = mk_Z∏ tml
|	mk_ZTERM	(Z (tm:TERM,s:string)) = mk_Z (tm,s)
|	mk_ZTERM	(Zsel(tm:TERM,s:string)) = mk_Zsel(tm,s)
|	mk_ZTERM	(Zapp(tm1:TERM,tm2:TERM)) = mk_Zapp(tm1,tm2)
|	mk_ZTERM	(ZÃ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_ZÃ(tm1,tm2,tm3)
|	mk_ZTERM	(ZÕ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_ZÕ(tm1,tm2,tm3)
|	mk_ZTERM	(Zâs(tm1:TERM,tm2:TERM)) = mk_Zâs(tm1,tm2)
|	mk_ZTERM	(Zdecâs(tm:TERM,s:string)) = mk_Zdecâs(tm,s)
|	mk_ZTERM	(Zpreâs(tm:TERM)) = mk_Zpreâs tm
|	mk_ZTERM	(Z≥âs(tm:TERM)) = mk_Z≥âs tm
|	mk_ZTERM	(Z±âs(tm1:TERM,tm2:TERM)) = mk_Z±âs(tm1,tm2)
|	mk_ZTERM	(Z≤âs(tm1:TERM,tm2:TERM)) = mk_Z≤âs(tm1,tm2)
|	mk_ZTERM	(Z¥âs(tm1:TERM,tm2:TERM)) = mk_Z¥âs(tm1,tm2)
|	mk_ZTERM	(Z§âs(tm1:TERM,tm2:TERM)) = mk_Z§âs(tm1,tm2)
|	mk_ZTERM	(Z˘âs(tm1:TERM,tm2:TERM)) = mk_Z˘âs(tm1,tm2)
|	mk_ZTERM	(Zhideâs(tm:TERM,sl:string list)) = mk_Zhideâs(tm,sl)
|	mk_ZTERM	(Z∂âs(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂âs(tm1,tm2,tm3)
|	mk_ZTERM	(Z∂â1âs(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Z∂â1âs(tm1,tm2,tm3)
|	mk_ZTERM	(Zµâs(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_Zµâs(tm1,tm2,tm3)
|	mk_ZTERM	(ZÑâs(tm:TERM)) = mk_ZÑâs tm
|	mk_ZTERM	(Zòâs(tm:TERM)) = mk_Zòâs tm
|	mk_ZTERM	(Zªâs(tm1:TERM,tm2:TERM)) = mk_Zªâs(tm1,tm2);
=TEX
Finally, we leave the structure open.
=SML
end (* of structure ZTypesAndTerms *);
open ZTypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

val d1 = mk_Zdecl[mk_Zdec([mk_var("a",mk_ZgivenT"A"),mk_var("x",mk_ZgivenT"A")],mk_var("A",mk_ZpowerT(mk_ZgivenT"A")))];
val p1 = mk_Ztrue;
val sch1 = mk_Zâs(d1,p1);
val d2 = mk_Zdecl[mk_Zdec([mk_var("y",mk_ZgivenT"B"),mk_var("b",mk_ZgivenT"B")],mk_var("B",mk_ZpowerT(mk_ZgivenT"B")))];
val p2 = mk_Ztrue;
val sch2 = mk_Zâs(d2,p2);
val d3 = mk_Zdecl[mk_Zdecsexp(sch1,"'"),mk_Zdecsexp(sch2,"")];
val p3 = mk_Ztrue;
val sch3 = mk_Zâs(d3,p3);



val x = mk_Zlvar("x",mk_ZgivenT "A",[]);
val y = mk_Zlvar("y",mk_ZgivenT "A",[]);
val X = mk_Zlvar("X",mk_ZpowerT(mk_ZgivenT "A"),[]);
val Y = mk_Zlvar("Y",mk_ZpowerT(mk_ZgivenT "B"),[]);
val eq = mk_Zeq(x,y);
val mm = mk_Zç(x,X);

val f = mk_Z∏[X,Y];

val zd = mk_const("Z'Ã",mk_≠_type(BOOL,BOOL));
val tm = mk_app(zd,p1);



