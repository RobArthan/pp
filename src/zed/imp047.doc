% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$

doctex imp047 ; texdvi imp047
bibtex imp047

=TEX
% imp047.doc  %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP047}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.19 (\TPPdate{\FormatDate{92/03/03}})]
First draft version.

\item [Issue 1.20 to 1.31]
	Restructure function $dest\_z\_term$ to meet the needs of the
	pretty printer.  This is done by adding function
	$basic\_dest\_z\_term$ to do the actual destruction or production
	of error message arguments, this function is used by
	$dest\_z\_term$ and by the pretty printer. Changed handling for naming of
	projection functions (including a change to the interface of
	dest\_z\_name).
\item [Issue 1.32 (July 16th 1992)]
Added support for schema renaming.
$dest\_z\_name$ given protection from subscripted punctuation. 
\item [Issue 1.33] Added binding display.
\item [Issue 1.34 (July 28th 1992)]
Corrected $Ê$ stuff.
Removed local definition of $list\_mk\_­\_type$
\item[Issue 1.37 (30th July 1992)]
Corrected a bug in $mk\_z\_binding$.
\item[Issue 1.38 (31st July 1992)]
Removed redundant code of $split\_on\_bar$.
\item [Issue 1.39 (13th August 1992)]
Corrected error handling for interrupts.
\item [Issue 1.40 (9th September 1992)]
Added some necessary brackets for error handlers.
\end{description}
%\subsection{Changes Forecast}
\newpage
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the constructor, discriminator and destructor functions corresponding to the primitive constructors of Z.
The detailed design of these is found in \cite{DS/FMU/IED/DTD047}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives the implementation of the functions mentioned above.
Additional functions, which are used in other parts of the Z system, may also be included here for convenience.
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
(The constructors might be bypassed entirely and the HOL constructors
used to generate terms with the names of Z~constants.) Such terms must
be handled by the pretty printer~\cite{DS/FMU/IED/DTD031} in a way that allows them to
be read back by the HOL and Z parsers and generate a term with the same
meaning.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intecepted and reported as helpfully as possible.
\section{STRUCTURE PREAMBLE}
=SML
structure ÛZTypesAndTermsÝ : ZTypesAndTerms = struct
=TEX
We open the structure containing the support package (see \cite{DS/FMU/IED/IMP048}).
=SML
open ZTypesAndTermsSupport;
=TEX
\section{AUXILIARY FUNCTIONS}
\subsection{Name Destruction}
We need the inverse of the name construction functions (defined in
\cite{DS/FMU/IED/DTD048}).  Given a name formed as a simple identifier
followed by a sequence of name lists with each name list in square
brackets function $dest\_z\_name$ returns the identifier name plus a
list of lists.  Thus a name like

=GFT
	"abc[de,fg,hi][jk,lm][no][p,r,s]"
=TEX

is split into the following pieces

=GFT
	("abc",
	[	["de", "fg", "hi"],
		["jk", "lm"],
		["no"],
		["p", "r", "s"]
	], Nil)
=TEX

Projections are of the form
=GFT
	"abc[de,fg,hi]jk"
=TEX

which is split into the following:

=GFT
	("abc",
	[	["de", "fg", "hi"]
	], Value "jk")
=TEX


Function $dest\_z\_name$ splits up well formed names by interpreting the
square brackets and commas, it complains about mal-formed names.

The implementation of function $dest\_z\_name$ merits some discussion.
Their intention is to split a Z~identifier into its component pieces
whilst detecting malformed Z~identifiers.  The first stage, in function
$hide\_subscripts$, is to split the identifier into its component
augmented characters, where an augmented character includes any
subscripting.  Function $get\_id$ extracts any leading name then
function $aux$ does the main work of splitting at square brackets and
commas.  It has three arguments: (1)~the unprocessed characters of the
identifier; (2)~details of the `current' pair of square brackets; and
(3)~information from previous pairs of square brackets.  Argument
(2)~is $Nil$ before opening and after square brackets between them it
is a pair of values comprising: (2.1)~the characters of the current
name; and (2.2)~a list of the previous comma separated names.

=SML
local
	exception bad_name;

	fun	addnam (nil:string list) (cl:string list)
			: string list = cl
	|	addnam n cl = (implode(rev n)) :: cl
	;

	fun	get_id(nil, prev) = (nil, prev)
	|	get_id(l as ("["::_ (*=]=*)), prev) = (l, prev)
	|	get_id(","::t, _) = raise bad_name
	|	get_id((*=[=*) "]"::t, _) = raise bad_name
	|	get_id(ch::t, prev) = get_id(t, ch :: prev)
	;

	fun	aux(nil, Value _, _) = raise bad_name
	|	aux(nil, Nil, pl) = (rev pl, Nil)

	|	aux("["::t (*=]=*), Value _, _) = raise bad_name
	|	aux("["::t (*=]=*), Nil, pl) = aux(t, Value(nil, nil), pl)

	|	aux(","::t, Nil, _) = raise bad_name
	|	aux(","::t, Value(cn, cl), pl) = aux(t, Value(nil, addnam cn cl), pl)

	|	aux((*=[=*) "]"::t, Nil, _) = raise bad_name
	|	aux((*=[=*) "]"::t, Value(cn, cl), pl) = aux(t, Nil, (rev(addnam cn cl)) :: pl)

	|	aux(l as(ch::t), Nil, pl) = (
			case get_id(l, nil)
			of (nil, nam) => (rev pl, Value(implode(rev nam)))
			| _ => raise bad_name
		)
	|	aux(ch::t, Value(cn, cl), pl) = aux(t, Value(ch::cn, cl), pl);
	
	fun	hide_subscripts(nil, prev) = rev prev
	|	hide_subscripts(_::"‰"::"‰" :: _, _) = raise bad_name
	|	hide_subscripts(_::"‰"::nil, _) = raise bad_name
	|	hide_subscripts(c1::"‰"::c2::t, prev) = hide_subscripts((c1^"‰"^c2)::t, prev)
	|	hide_subscripts(c::t, prev) = hide_subscripts(t, c::prev)
	;

in
fun	Ûdest_z_nameÝ (s:string) :string * string list list * string OPT = (
let		val (tail, front) = get_id(hide_subscripts(explode s, nil),nil);
		val (boxed_lists, projector) = aux(tail, Nil, nil);
in
		(implode(rev front), boxed_lists, projector)
end
handle Fail _ => fail "dest_z_name" 47000 [fn () => s]
| bad_name => fail "dest_z_name" 47000 [fn () => s]
);
end;
=TEX
The following function tests for multiple occurrences of a string in a list
of same.
=SML
fun moccurs (area : string) (msg : int) (a :: x : string list) : unit = (
	if	a mem x
	then	fail area msg [fn () => a]
	else	moccurs area msg x
) | moccurs _ _ [] = ();

=TEX
\section{Z TYPES}
The following sections describe the constructor, discriminator and destructor functions for each of the five Z type constructors.
\subsection{The Datatype $Z\_TYPE$}

The general mapping functions $mk\_z\_type$, $is\_z\_type$ and
$dest\_z\_type$, which are declared later in this document, use this
datatype.

=SML
datatype	ÛZ_TYPEÝ = 	ÛZgiven_tÝ of string
		|		ÛZvar_tÝ of string
		|		ÛZpower_tÝ of TYPE
		|		ÛZTuple_tÝ of TYPE list
		|		ÛZschema_tÝ of (string * TYPE) list;
=TEX
\subsection{The General Destructor Function}
This function converts a HOL type to the appropriate form of the above datatype (providing, of course, that it represents a valid Z type).
=SML
fun	Ûdest_z_typeÝ (ty:TYPE) :Z_TYPE =
	case dest_simple_type ty of
		Vartype s => (
			case explode s of
				("'"::t) => Zvar_t(implode t)
			|	_ => fail "" 0 []
		)
	|	Ctype("SET",[ty1]) => Zpower_t ty1
	|	Ctype(s,tyl) => (
			case (dest_z_name s,tyl) of
				(("Z'T",[[n]], Nil),tyl) => 
					if string_of_int(length tyl) = n
					then ZTuple_t tyl
					else fail "" 0 []
			|	(("Z'S",[cl], Nil),tyl) => 
					Zschema_t(combine cl tyl)
			|	(_,[]) => Zgiven_t s
			|	_ => fail "" 0 []
		)
	handle Fail _ => type_fail "dest_z_type" 47800 [ty];
=TEX
\subsection{The General Discriminator Function}
=SML
fun	Ûis_z_typeÝ (t:TYPE) :bool =
	let	val x = dest_z_type t
	in
		true
	end
	handle Fail _ => false;
=TEX
\subsection{Given Sets}
=SML
fun	Ûmk_z_given_tÝ (s:string) :TYPE = mk_ctype(s,[]);

fun	Ûis_z_given_tÝ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		Zgiven_t _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_given_tÝ (ty :TYPE) :string = (
	case dest_z_type ty of
		Zgiven_t s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_given_t" 47010 [ty];
=TEX
\subsection{Generic Variables}
=SML
fun	Ûmk_z_var_tÝ (s:string) :TYPE = mk_vartype("'" ^ s);

fun	Ûis_z_var_tÝ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		Zvar_t _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_var_tÝ (ty :TYPE) :string = (
	case dest_z_type ty of
		Zvar_t s => s
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_var_t" 47020 [ty];
=TEX
\subsection{Set Types}
=SML
fun	Ûmk_z_power_tÝ (ty:TYPE) :TYPE = mk_ctype("SET",[ty]);

fun	Ûis_z_power_tÝ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		Zpower_t _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_power_tÝ (ty :TYPE) :TYPE = (
	case dest_z_type ty of
		Zpower_t t => t
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_power_t" 47030 [ty];
=TEX
\subsection{Cartesian Product Types}
=SML
fun	Ûmk_z_tuple_tÝ (tyl:TYPE list) :TYPE = 
		tuple_type tyl;

fun	Ûis_z_tuple_tÝ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		ZTuple_t _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_tuple_tÝ (ty :TYPE) :TYPE list = (
	case dest_z_type ty of
		ZTuple_t tyl => tyl
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_tuple_t" 47040 [ty];
=TEX
\subsection{Binding Types}
=SML
fun	Ûmk_z_schema_tÝ (itym:(string * TYPE) list) :TYPE =
		bind_type itym;

fun	Ûis_z_schema_tÝ (ty :TYPE) :bool = (
	case dest_z_type ty of	
		Zschema_t _ => true
	|	_ => false
	)
	handle Fail _ => false;

fun	Ûdest_z_schema_tÝ (ty :TYPE) :(string * TYPE) list = (
	case dest_z_type ty of
		Zschema_t itym => itym
	|	_ => fail "" 0 []
	)
	handle Fail _ => type_fail "dest_z_schema_t" 47050 [ty];
=TEX
\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $Z\_TERM$ to the corresponding $TERM$.
=SML
fun	Ûmk_z_typeÝ	(Zgiven_t(s:string) :Z_TYPE) :TYPE = mk_z_given_t s
|	mk_z_type	(Zvar_t(s:string)) = mk_z_var_t s
|	mk_z_type	(Zpower_t(ty:TYPE)) = mk_z_power_t ty
|	mk_z_type	(ZTuple_t(tyl:TYPE list)) = mk_z_tuple_t tyl
|	mk_z_type	(Zschema_t(itym:(string * TYPE)list)) = mk_z_schema_t itym;
=TEX
\section{Z TERMS}
The following describes the constructor, discriminator and destructor functions for Z terms.
\subsection{The Datatype Z\_TERM}

The general mapping functions $mk\_z\_term$, $is\_z\_term$ and
$dest\_z\_term$, which are declared later in this document, use this
datatype.

=SML
datatype	ÛZ_TERMÝ
		=	 	ÛZDecÝ of TERM list * TERM
		|		ÛZSchemaDecÝ of TERM * string
		|		ÛZDeclÝ of TERM list
		|		ÛZEqÝ of TERM * TERM
		|		ÛZÝ of TERM * TERM
		|		ÛZTrueÝ
		|		ÛZFalseÝ
		|		ÛZ³Ý of TERM
		|		ÛZ±Ý of TERM * TERM
		|		ÛZ²Ý of TERM * TERM
		|		ÛZ´Ý of TERM * TERM
		|		ÛZ¤Ý of TERM * TERM
		|		ÛZ¶Ý of TERM * TERM * TERM
		|		ÛZ¶‰1Ý of TERM * TERM * TERM
		|		ÛZµÝ of TERM * TERM * TERM
		|		ÛZSchemaPredÝ of TERM * string
		|		ÛZLVarÝ of string * TYPE * TERM list
		|		ÛZGVarÝ of string * TYPE * TERM list
		|		ÛZIntÝ of string
		|		ÛZStringÝ of string
		|		ÛZ§¢Ý of TYPE * TERM list
		|		ÛZSetdÝ of TYPE * TERM list
		|		ÛZSetaÝ of TERM * TERM * TERM
		|		ÛZðÝ of TERM
		|		ÛZTupleÝ of TERM list
		|		ÛZBindingÝ of (string * TERM) list
		|		ÛZ¸Ý of TERM list
		|		ÛZÊÝ of TERM * string
		|		ÛZSel‰sÝ of TERM * string
		|		ÛZSel‰tÝ of TERM * int
		|		ÛZAppÝ of TERM * TERM
		|		ÛZÌÝ of TERM * TERM * TERM
		|		ÛZÍÝ of TERM * TERM * TERM
		|		ÛZ‰sÝ of TERM * TERM
		|		ÛZDecor‰sÝ of TERM * string
		|		ÛZPre‰sÝ of TERM
		|		ÛZ³‰sÝ of TERM
		|		ÛZ±‰sÝ of TERM * TERM
		|		ÛZ²‰sÝ of TERM * TERM
		|		ÛZ´‰sÝ of TERM * TERM
		|		ÛZ¤‰sÝ of TERM * TERM
		|		ÛZù‰sÝ of TERM * TERM
		|		ÛZHide‰sÝ of TERM * string list
		|		ÛZ¶‰sÝ of TERM * TERM * TERM
		|		ÛZ¶‰1‰sÝ of TERM * TERM * TERM
		|		ÛZµ‰sÝ of TERM * TERM * TERM
		|		ÛZ„‰sÝ of TERM
		|		ÛZ˜‰sÝ of TERM
		|		ÛZ»‰sÝ of TERM * TERM
		| 		ÛZRename‰sÝ of TERM * (string * string) list
		;
=TEX

\subsection{Result of Basic Destructor Function}

This function converts a HOL term to the appropriate form of the
datatype $Z\_TERM$, or to an encoding of why it could not be converted.
The encoded failure value is intended for use by the pretty
printer~\cite{DS/FMU/IED/DTD031,DS/FMU/IED/DTD064}, it contains values
showing how (in some cases) the term might be HOL if it were modified
slightly.  The return value from the basic destructor function is
in type $BDZ$ (named for `Basic Destroy Z').

=SML
datatype ÛBDZÝ
	=	ÛBdzOkÝ	of Z_TERM
	|	ÛBdzNotZÝ	of int
	|	ÛBdzFailÝ	of {
			ÛBdzFCodeÝ	: int,
			ÛBdzFCompcÝ	: int,
			ÛBdzFArgcÝ	: int
		}
	;
=TEX

Successful destruction returns $BdzOk$ with the Z term.  Value
$BdzFail$ is returned when the term is similar to a Z~term (i.e., it
has a known constructor but the wrong number of arguments).  In this
case the $BdzFCompc$ and $BdzFArgc$ fields tell how many component
lists and arguments (respectively) are allowed in a well formed
Z~term.  Value $BdzNotZ$ is returned when the term is not
recognisable as a Z~term.  In cases where insufficient component lists
or arguments are given to a known constructor either $BdzFail$ or
$BdzNotZ$ may be returned.

\subsection{Destructor Utilities}

=SML
fun Ûzdest_0_0Ý(nil, nil, _, v) = BdzOk v
| zdest_0_0(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_1_gt0Ý(_, nil, e, _) = BdzNotZ 47900
| zdest_1_gt0(_::_, a, _, v) = BdzOk(v a)
| zdest_1_gt0(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_0_1Ý(nil, [x], _, v) = BdzOk(v x)
| zdest_0_1 (_, _::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=0, BdzFArgc=1}
| zdest_0_1(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_0_2Ý(nil, [x, y], _, v) = BdzOk(v(x,y))
| zdest_0_2 (_, _::_::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=0, BdzFArgc=2}
| zdest_0_2(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_1_1Ý([_], [x], _, v) = BdzOk(v x)
| zdest_1_1 (_, _::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=1, BdzFArgc=1}
| zdest_1_1(_, _, e, _) = BdzNotZ 47900
;

fun Ûzdest_2_2Ý([_, _], [x, y], _, v) = BdzOk(v(x, y))
| zdest_2_2 (_, _::_::_::_, e, _) =
	BdzFail{BdzFCode=e, BdzFCompc=2, BdzFArgc=2}
| zdest_2_2(_, _, e, _) = BdzNotZ 47900
;
=IGN
fun Ûzdest_gt0_0Ý(nil, nil, e, _) = BdzNotZ 47900
| zdest_gt0_0(_, nil, _, v) = BdzOk v
| zdest_gt0_0(_, _, e, _) = BdzNotZ 47900
;
=TEX

=SML
fun Ûdest_val_tupleÝ(name:string, ty: TYPE, constr:string * TYPE * TERM list -> Z_TERM,
		arg_tm:TERM, e:int) : BDZ = (
	let
		val (arg_fn, args) = strip_app arg_tm;
		val (arg_name, arg_ty) = dest_const arg_fn;
	in
		case dest_z_name arg_name
		of ("Z'Mk_T", [_], Nil) =>
			BdzOk(constr(name, snd(dest_­_type ty), args))
		| _ =>
			BdzFail{BdzFCode=e,
				BdzFCompc=0, BdzFArgc=0}
	end
	handle Fail _ =>
		BdzFail{BdzFCode=e, BdzFCompc=0, BdzFArgc=0}
);
=TEX

=SML
fun	Ûdest_abstractionÝ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_Ì t)))
	handle Fail _ => term_fail "dest_z_term" 47901 [t];
=TEX

=SML
fun	Ûdest_¶bodyÝ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_¶ t)))
	handle Fail _ => term_fail "dest_z_term" 47901 [t];
=TEX

=SML
fun	Ûdest_µbodyÝ (t:TERM) :TERM list =
		snd(strip_app(snd(strip_µ t)))
	handle Fail _ => term_fail "dest_z_term" 47901 [t];
=TEX
$split\_on\_bar$ undoes the encoding of two identifers as one
string, and is found in \cite{DS/FMU/IED/DTD048}.
=SML
fun Ûzdest_renameÝ(comp_list, args, n, v)Ý = (
	if length comp_list = 2 
	then if length args = 1
		then (let val a2 = map split_on_bar (hd(tl comp_list))
		in
		BdzOk (v(hd args, a2))
		end
		handle (Fail _) =>
		BdzFail{BdzFCode=n, BdzFCompc=2, BdzFArgc=1})
		else BdzFail{BdzFCode=n, BdzFCompc=2, BdzFArgc=1}
	else BdzNotZ 47900
);
=TEX	
\subsection{The Basic Destructor Function}

Function $basic\_dest\_z\_term$ does the work of destroying a term to
yield its Z~structure.  The arguments are in the result of applying
$strip\_app$ to a term.  (This parameterisation is of benefit to the
pretty printer~\cite{DS/FMU/IED/DTD031}.)

The main part of this function is a large case clause which switches
depending on the name of the constant at the head of the stripped
application, the other cases are simple and dealt with in the
immedaitely following block of code.

=SML
fun Ûbasic_dest_z_termÝ (hdterm:TERM, args:TERM list) : BDZ = (
	case dest_simple_term hdterm
	of App _ => BdzNotZ 47900
	| SimpleÌ _ => BdzNotZ 47900
	| Var (name, ty) => (
		case args
		of nil => BdzOk(ZLVar(name, ty,[]))
		| [tm] => dest_val_tuple(name, ty, ZLVar, tm, 47090)
		| _ => BdzFail{BdzFCode=47090,
				BdzFCompc=0, BdzFArgc=1}
	)
	| Const (name, ty) => (
		let
			val (identifier, comp_list, projector) = dest_z_name name;
		in
			case (identifier, projector) of
			("Z'S", Value s) => (
				case args of
				[x] => BdzOk(ZSel‰s(x,s))
				| _ => BdzFail{BdzFCode=47180, BdzFCompc=2,
								BdzFArgc=1}
				)
			|("Z'T", Value s) => (
				case args of
				[x] => BdzOk(ZSel‰t(x,nat_of_string s))
				| _ => BdzFail{BdzFCode=47185, BdzFCompc=2,
								BdzFArgc=1}
				)
			| (x, Nil) => (
				case identifier
=TEX


The $case$ clause started on the line above opens up the Z~term based
on the names of the constant.  The various options are catered for in
the following sections, the end of the function is in
section~\ref{EndOfFunctionBDZ}.

=TEX

\subsubsection{Declarations}
First we look for declarations, beginning with variables.
=SML
of "Z'Dec" => (
	case (comp_list, args)
	of ([],[x]) => (
		BdzOk(ZDec((dest_list ** Combinators.I)(dest_pair x)))
		handle Fail _ => BdzNotZ 47900
	)
	| _ => BdzFail{BdzFCode=47910, BdzFCompc=0, BdzFArgc=1}
)
=TEX
Then schema declarations.
=SML
| "Z'SchemaDec" => (
	case (comp_list, args)
	of ([],[bind, sch]) => (
		let	val btym = map dest_var (snd(strip_app bind));
			val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			BdzOk(ZSchemaDec(sch,d))
		end
		handle Fail _ => BdzNotZ 47911
		)
	| _ => BdzFail{BdzFCode=47911, BdzFCompc=0, BdzFArgc=1}
)
=TEX
And composite declarations.
Note that all declarations used in other constructs must be of this
form, even if only one of the above forms is used (it is even possible
to have an empty declaration under certain circumstances).
=SML
| "Z'Decl" => (
	case (comp_list, args)
	of ([],[x]) => (
		BdzOk(ZDecl(dest_list x))
		handle Fail _ => BdzNotZ 47912
	)
	| _ => BdzFail{BdzFCode=47912, BdzFCompc=0, BdzFArgc=1}
)
=TEX
\subsubsection{Predicates}

The logical connectives, `true' and `false', map directly on to the
equivalent HOL constants.

=SML
| "T"	=> zdest_0_0(comp_list, args, 47900, ZTrue)
| "F"	=> zdest_0_0(comp_list, args, 47900, ZFalse)
=TEX

Equality and equivalence both use the HOL `$=$' constant, they are distinguished by the
types of their operands.  Equivalence has both arguments of type $BOOL$.

=IGN
| "="	=> zdest_0_2(comp_list, args, 47220, ZEq)
| "¤"	=> zdest_0_2(comp_list, args, 47280, Z¤)
=SML
| "="	=> (
	case (comp_list, args)
	of (nil,[x, y]) => (
		BdzOk(	(if type_of x =: BOOL andalso type_of y =: BOOL
			then Z¤
			else ZEq
			)(x,y)
		)
	)
	| (_, _::_::_::_) =>
		BdzFail{BdzFCode=47220, BdzFCompc=0, BdzFArgc=2}
	| _ => BdzNotZ 47900
)
=TEX

=SML
| ""	=> zdest_0_2(comp_list, args, 47230, Z)
| "³"	=> zdest_0_1(comp_list, args, 47240, Z³)
| "±"	=> zdest_0_2(comp_list, args, 47250, Z±)
| "²"	=> zdest_0_2(comp_list, args, 47260, Z²)
| "´"	=> zdest_0_2(comp_list, args, 47270, Z´)
=TEX
=SML
| "Z'¶" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_¶body x
		of	[d,p,v] => BdzOk(Z¶(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47920
	)
	| _ => BdzFail{BdzFCode=47920, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'¶‰1" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,v] => BdzOk(Z¶‰1(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47921
	)
	| _ => BdzFail{BdzFCode=47921, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'µ" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_µbody x of
			[d,p,v] => BdzOk(Zµ(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47922
	)
	| _ => BdzFail{BdzFCode=47922, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'SchemaPred" => (
	case (comp_list, args)
	of ([],[bind, sch]) => (
		let	val btym = map dest_var (snd(strip_app bind));
			val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			BdzOk(ZSchemaPred(sch,d))
		end
		handle Fail _ => BdzNotZ 47923
	)
	| _ => BdzFail{BdzFCode=47923, BdzFCompc=0, BdzFArgc=1}
)
=TEX
\subsubsection{Terms}

We must postpone the handling of local and global variables until the
end of the case clause because they do not have an easily identifiable
constant part.

=SML
| "Z'Int" => (
	case (comp_list, args)
	of ([],[tm]) => (
		BdzOk(ZInt(fst(dest_const tm)))
		handle Fail _ => BdzNotZ 47105
	)
	| _ => BdzFail{BdzFCode=47105, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'String" => (
	case (comp_list, args)
	of ([],[tm]) => (
		BdzOk(ZString(dest_string tm))
		handle Fail _ => BdzNotZ 47105
	)
	| _ => BdzFail{BdzFCode=47105, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'§¢" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_ctype(type_of x) of
			("LIST",[t]) => BdzOk(Z§¢(t,dest_list x))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47110
	)
	| _ => BdzFail{BdzFCode=47110, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Setd" => (
	case (comp_list, args)
	of ([],[x]) => (
		(case dest_ctype(type_of x) of
			("LIST",[t]) => BdzOk(ZSetd(t,dest_list x))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47120
	)
	| _ => BdzFail{BdzFCode=47120, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Seta" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,v] => BdzOk(ZSeta(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47130
	)
	| _ => BdzFail{BdzFCode=47130, BdzFCompc=1, BdzFArgc=1}
)
=TEX
=SML
| "Z'ð"	=> zdest_0_1	(comp_list, args, 47140, Zð)
| "Z'Mk_T"	=> zdest_1_gt0	(comp_list, args, 47150, ZTuple)
| "Z'Mk_S"	=> (
	case comp_list
	of [comps] => (
		(BdzOk(ZBinding(combine comps args)))
		handle Fail _ =>
		BdzFail{BdzFCode=47130, BdzFCompc=1, BdzFArgc=length comps}
	)
	| _ => BdzNotZ 47900
)
| "Z'¸"	=> zdest_1_gt0	(comp_list, args, 47160, Z¸)
=TEX
=SML
| "Z'Ê" => (
	case (comp_list, args)
	of ([],[bind,sch]) => (
		let	val btym = map dest_var (snd(strip_app bind));
			val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
			val d = implode(
					(explode(fst(hd btym))) from 
					(length(explode(fst(hd stym)))));
		in
			BdzOk(ZÊ(sch,d))
		end
		handle Fail _ => BdzNotZ 47170
	)
	| _ => BdzFail{BdzFCode=47170, BdzFCompc=0, BdzFArgc=1}
)

=SML
| "Z'App"	=> zdest_0_2(comp_list, args, 47190, ZApp)
=TEX
=SML
| "Z'Ì" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,t,v] => BdzOk(ZÌ(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47200
	)
	| _ => BdzFail{BdzFCode=47200, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Í" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p,v] => BdzOk(ZÍ(d,p,v))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47936
	)
	| _ => BdzFail{BdzFCode=47936, BdzFCompc=0, BdzFArgc=1}
)
=TEX
\subsubsection{Schemas}
=SML
| "Z'‰s" => (
	case (comp_list, args)
	of ([_],[x]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(Z‰s(d,p))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47940
	)
	| _ => BdzFail{BdzFCode=47940, BdzFCompc=0, BdzFArgc=1}
)
=TEX
=SML
| "Z'Dec‰s" => (
	case (comp_list, args)
	of ([_,[]],[x]) => BdzOk(ZDecor‰s(x,""))
	| ([_,[s]],[x]) => BdzOk(ZDecor‰s(x,s))
	| _ => BdzFail{BdzFCode=47340, BdzFCompc=1, BdzFArgc=1}
)
=TEX
=SML
| "Z'Pre‰s"	=> zdest_1_1(comp_list, args, 47350, ZPre‰s)
| "Z'³‰s"	=> zdest_0_1(comp_list, args, 47360, Z³‰s)
| "Z'±‰s"	=> zdest_2_2(comp_list, args, 47370, Z±‰s)
| "Z'²‰s"	=> zdest_2_2(comp_list, args, 47380, Z²‰s)
| "Z'´‰s"	=> zdest_2_2(comp_list, args, 47390, Z´‰s)
| "Z'¤‰s"	=> zdest_2_2(comp_list, args, 47400, Z¤‰s)
| "Z'ù‰s"	=> zdest_2_2(comp_list, args, 47410, Zù‰s)
=TEX
=SML
| "Z'Hide‰s" => (
	case (comp_list, args)
	of ([_,sl],[x]) => BdzOk(ZHide‰s(x,sl))
	| _ => BdzFail{BdzFCode=47420, BdzFCompc=2, BdzFArgc=1}
)
=TEX
=SML
| "Z'¶‰s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(Z¶‰s(d,p,y))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47941
	)
	| _ => BdzFail{BdzFCode=47941, BdzFCompc=2, BdzFArgc=2}
)
=TEX
=SML
| "Z'¶‰1‰s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(Z¶‰1‰s(d,p,y))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47942
	)
	| _ => BdzFail{BdzFCode=47942, BdzFCompc=2, BdzFArgc=2}
)
=TEX
=SML
| "Z'µ‰s" => (
	case (comp_list, args)
	of ([_,_],[x,y]) => (
		(case dest_abstraction x of
			[d,p] => BdzOk(Zµ‰s(d,p,y))
		|	_ => fail "" 0 [])
		handle Fail _ => BdzNotZ 47943
	)
	| _ => BdzFail{BdzFCode=47943, BdzFCompc=2, BdzFArgc=2}
)
=TEX
=SML
| "Z'„‰s"	=> zdest_1_1(comp_list, args, 47460, Z„‰s)
| "Z'˜‰s"	=> zdest_1_1(comp_list, args, 47470, Z˜‰s)
| "Z'»‰s"	=> zdest_2_2(comp_list, args, 47480, Z»‰s)
| "Z'Rename‰s"	=> zdest_rename(comp_list, args, 47461, ZRename‰s)
	
=TEX
\subsubsection{Local and Global Variables}
=SML
| _ => (
	case (comp_list, args)
	of (nil, nil) => (
		(	case unbind_gvar_name name
			of n => BdzOk(ZGVar(n, ty,[]))
		) handle Fail _ => BdzNotZ 47100
		)
	| (nil, [tm]) => (
		(	case unbind_gvar_name name
			of n => dest_val_tuple(n, ty, ZGVar, tm, 47100)
		) handle Fail _ => BdzNotZ 47100
		)
	| _ => BdzFail{BdzFCode=47100, BdzFCompc=0, BdzFArgc=1}
)
=TEX

\subsubsection{End of the Basic Destructor Function}
\label{EndOfFunctionBDZ}

=SML
		)
		| (_, Value _) => BdzNotZ 47100
		end (* of let in case Const *)
	) (* end of case Const (name, ty) => ... *)
	(* end of case dest_simple_term hdterm ... *)
	handle (Fail _) => BdzNotZ 47100 
) (* end of function basic_dest_z_term *);
=TEX

\subsection{The General Z Destructor Function}

Function $dest\_z\_term$ provides the normal interface for
destroying arbitrary Z~terms.  

=SML
fun	Ûdest_z_termÝ (t:TERM) :Z_TERM = (
let
	val bdz_ans = basic_dest_z_term (strip_app t);
(*	fun sh(s, v) = diag_string("dest_z_term: ans is " ^ s ^ " " ^ (string_of_int v)); *)
in
	case bdz_ans
	of BdzOk zt => zt
	| BdzNotZ e => term_fail "dest_z_term" e [t]
	| BdzFail{BdzFCode=e, ...} => term_fail "dest_z_term" e [t]
end
);
=TEX

\subsection{The General Z Discriminator Function}
=SML
fun	Ûis_z_termÝ (t:TERM) :bool =
	let	val x = dest_z_term t
	in
		true
	end
	handle Fail _ => false;
=TEX
\section{Constructor, Destructor and Discriminator Functions}

\subsection{Declaration Destructors}
=SML
fun	Ûdest_z_decÝ (t:TERM) :(TERM list * TERM) =
	(case dest_z_term t of
		ZDec(tml,tm) => (tml,tm)
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_dec" 47061 [t];

fun	Ûdest_z_decsexpÝ (t:TERM) :TERM * string =
	(case dest_z_term t of
		ZSchemaDec(tm,s) => (tm,s)
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_decsexp" 47071 [t];

fun	Ûdest_z_declÝ (t:TERM) :TERM list =
	(case dest_z_term t of
		ZDecl tml => tml
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_decl" 47912 [t];
=TEX
The following function, which produces a type map from a declaration, will frequently be required below.
=SML
local
fun	f ([] :TERM list) :(string * TYPE)list = []
|	f (h::t) = (
		map dest_var (fst(dest_z_dec h))
		handle Fail _ =>
		let val (sch,d) = dest_z_decsexp h
		in
			map 	(fn(s,ty)=>(pack_ident(s,d),ty)) 
				(dest_z_schema_t(dest_z_power_t(type_of sch)))
		end) @ (f t);
in
fun	Ûdest_declÝ (t:TERM) :(string * TYPE)list =
		f (dest_z_decl t)
	handle Fail _ => term_fail "dest_decl" 47912 [t]
end;
=TEX
\subsection{Declaration Discriminators}
=SML
fun	Ûis_z_decÝ (t:TERM) :bool =
	(case dest_z_term t of
		ZDec(tml,tm) => true
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_decsexpÝ (t:TERM) :bool =
	(case dest_z_term t of
		ZSchemaDec(tm,s) => true
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_declÝ (t:TERM) :bool =
	(case dest_z_term t of
		ZDecl tml => true
	|	_ => false)
	handle Fail _ => false;
=TEX
\subsection{Predicate Destructors}
=SML
fun	Ûdest_z_eqÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		ZEq(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_eq" 47220 [t];

fun	Ûdest_z_Ý (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_" 47230 [t];

fun	Ûdest_z_³Ý (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z³(tm1) => (tm1) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_³" 47240 [t];

fun	Ûdest_z_±Ý (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z±(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_±" 47250 [t];

fun	Ûdest_z_²Ý (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z²(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_²" 47260 [t];

fun	Ûdest_z_´Ý (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z´(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_´" 47270 [t];

fun	Ûdest_z_¤Ý (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z¤(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¤" 47280 [t];

fun	Ûdest_z_¶Ý (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶" 47290 [t];

fun	Ûdest_z_¶‰1Ý (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶‰1(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶‰1" 47300 [t];

fun	Ûdest_z_µÝ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Zµ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_µ" 47310 [t];

fun	Ûdest_z_predsexpÝ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZSchemaPred(tm1,s) => (tm1,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_predsexp" 47320 [t];
=TEX
\subsection{Predicate Discriminators}
=SML
fun	Ûis_z_eqÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZEq(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_trueÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZTrue => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_falseÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZFalse => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_³Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z³(tm1) => true 
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_±Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z±(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_²Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z²(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_´Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z´(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¤Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¤(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶‰1Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶‰1(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_µÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zµ(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_predsexpÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSchemaPred(tm1,s) => true 
	|	_ => false) 
	handle Fail _ => false;
=TEX
\subsection{Term Destructors}
=SML
fun	Ûdest_z_lvarÝ (t:TERM) :string * TYPE * TERM list = 
	(case dest_z_term t of 
		ZLVar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_lvar" 47090 [t];

fun	Ûdest_z_gvarÝ (t:TERM) :string * TYPE * TERM list = 
	(case dest_z_term t of 
		ZGVar(s,ty,tml) => (s,ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_gvar" 47100 [t];

fun	Ûdest_z_intÝ (t:TERM) :string = 
	(case dest_z_term t of 
		ZInt(s) => (s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_int" 47105 [t];

fun	Ûdest_z_stringÝ (t:TERM) :string = 
	(case dest_z_term t of 
		ZString(s) => (s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_int" 47106 [t];

fun	Ûdest_z_§¢Ý (t:TERM) :TYPE * TERM list = 
	(case dest_z_term t of 
		Z§¢(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_§¢" 47110 [t];

fun	Ûdest_z_setdÝ (t:TERM) :TYPE * TERM list = 
	(case dest_z_term t of 
		ZSetd(ty,tml) => (ty,tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_setd" 47120 [t];

fun	Ûdest_z_setaÝ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		ZSeta(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_seta" 47130 [t];

fun	Ûdest_z_ðÝ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Zð(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_ð" 47140 [t];

fun	Ûdest_z_tupleÝ (t:TERM) :TERM list = 
	(case dest_z_term t of 
		ZTuple(tml) => (tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_tuple" 47150 [t];

fun	Ûdest_z_bindingÝ (t:TERM) :(string * TERM) list = 
	(case dest_z_term t of 
		ZBinding stl => stl 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_binding" 47151 [t];

fun	Ûdest_z_¸Ý (t:TERM) :TERM list = 
	(case dest_z_term t of 
		Z¸(tml) => (tml) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¸" 47160 [t];

fun	Ûdest_z_ÊÝ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZÊ(tm,s) => (tm,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_Ê" 47170 [t];

fun	Ûdest_z_sel‰sÝ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZSel‰s(tm,s) => (tm,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_sel‰s" 47180 [t];

fun	Ûdest_z_sel‰tÝ (t:TERM) :TERM * int = 
	(case dest_z_term t of 
		ZSel‰t(tm,i) => (tm,i) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_sel‰t" 47185 [t];

fun	Ûdest_z_appÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		ZApp(f,a) => (f,a) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_app" 47190 [t];

fun	Ûdest_z_ÌÝ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		ZÌ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_Ì" 47200 [t];

fun	Ûdest_z_ÍÝ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		ZÍ(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_Í" 47210 [t];
=TEX
\subsection{Term Discriminators}
=SML
fun	Ûis_z_lvarÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZLVar(s,ty,tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_gvarÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZGVar(s,ty,tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_intÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZInt(s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_stringÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZString(s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_§¢Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z§¢(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_setdÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSetd(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_setaÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSeta(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_ðÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zð(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_tupleÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZTuple(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_bindingÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZBinding(tml) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¸Ý (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¸(tml) => true 
	|	_ => false)
	handle Fail _ => false;

fun	Ûis_z_ÊÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZÊ(tm,s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_sel‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSel‰s(tm,s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_sel‰tÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZSel‰t(tm,i) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_appÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZApp(f,a) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_ÌÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZÌ(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_ÍÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZÍ(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;
=TEX
\subsection{Destructors for the Schema Calculus}
=SML
fun	Ûdest_z_‰sÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z‰s(d,p) => (d,p) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_‰s" 47940 [t];

fun	Ûdest_z_dec‰sÝ (t:TERM) :TERM * string = 
	(case dest_z_term t of 
		ZDecor‰s(tm,s) => (tm,s) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_dec‰s" 47340 [t];

fun	Ûdest_z_pre‰sÝ (t:TERM) :TERM = 
	(case dest_z_term t of 
		ZPre‰s(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_pre‰s" 47350 [t];

fun	Ûdest_z_³‰sÝ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z³‰s(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_³‰s" 47360 [t];

fun	Ûdest_z_±‰sÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z±‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_±‰s" 47370 [t];

fun	Ûdest_z_²‰sÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z²‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_²‰s" 47380 [t];

fun	Ûdest_z_´‰sÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z´‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_´‰s" 47390 [t];

fun	Ûdest_z_¤‰sÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z¤‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¤‰s" 47400 [t];

fun	Ûdest_z_ù‰sÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Zù‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_ù‰s" 47410 [t];

fun	Ûdest_z_hide‰sÝ (t:TERM) :TERM * string list = 
	(case dest_z_term t of 
		ZHide‰s(tm,sl) => (tm,sl) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_hide‰s" 47420 [t];

fun	Ûdest_z_¶‰sÝ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶‰s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶‰s" 47430 [t];

fun	Ûdest_z_¶‰1‰sÝ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Z¶‰1‰s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_¶‰1‰s" 47440 [t];

fun	Ûdest_z_µ‰sÝ (t:TERM) :TERM * TERM * TERM = 
	(case dest_z_term t of 
		Zµ‰s(d,p,v) => (d,p,v) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_µ‰s" 47450 [t];

fun	Ûdest_z_„‰sÝ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z„‰s(tm) => (tm) 
	|	_ => fail "" 0 [])
	handle Fail _ => term_fail "dest_z_„‰s" 47460 [t];

fun	Ûdest_z_˜‰sÝ (t:TERM) :TERM = 
	(case dest_z_term t of 
		Z˜‰s(tm) => (tm) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_˜‰s" 47470 [t];

fun	Ûdest_z_»‰sÝ (t:TERM) :TERM * TERM = 
	(case dest_z_term t of 
		Z»‰s(tm1,tm2) => (tm1,tm2) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_»‰s" 47480 [t];
fun	Ûdest_z_rename‰sÝ (t:TERM) :TERM * (string * string)list = 
	(case dest_z_term t of 
		ZRename‰s(args) => (args) 
	|	_ => fail "" 0 []) 
	handle Fail _ => term_fail "dest_z_rename‰s" 47461 [t];

=TEX
\subsection{Discriminators for the Schema Calculus}
=SML
fun	Ûis_z_‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z‰s(d,p) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_dec‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZDecor‰s(tm,s) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_pre‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZPre‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_³‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z³‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_±‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z±‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_²‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z²‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_´‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z´‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¤‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¤‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_ù‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zù‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_hide‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZHide‰s(tm,sl) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶‰s(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_¶‰1‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z¶‰1‰s(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_µ‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Zµ‰s(d,p,v) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_„‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z„‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_˜‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z˜‰s(tm) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_»‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		Z»‰s(tm1,tm2) => true 
	|	_ => false) 
	handle Fail _ => false;

fun	Ûis_z_rename‰sÝ (t:TERM) :bool = 
	(case dest_z_term t of 
		ZRename‰s _ => true 
	|	_ => false) 
	handle Fail _ => false;
=TEX
\subsection{Binding Construction}
There are three constructors below which generate systematically decorated bindings from schemas: schema references as declarations, schema references as predicates and theta terms.
We therefore provide the following general function for doing this.
=SML
local open ZTypesAndTermsSupport in
fun	Ûmk_bindingÝ ((sch,d):TERM * string) :TERM =
	let	val itym = dest_z_schema_t(dest_z_power_t(type_of sch));
		val itym' = map (fn(s,t) => (pack_ident(s,d),t)) itym;
		val bcons = bind_cterm itym;
		val argl = map mk_var (dest_z_schema_t(mk_z_schema_t itym'));
	in
		list_mk_app(bcons,argl)
	end
	handle Fail _ => term_fail "mk_binding" 47940 [sch];
end;
=TEX
\subsection{Declaration Constructors}
=SML
fun 	Ûmk_z_decÝ ((varl,set):TERM list * TERM) :TERM =
	let	val sty = type_of set;
		val ety = dest_z_power_t sty;
		val vl = mk_list varl
			handle X => reraise X "mk_z_dec";
		val decty = mk_­_type(mk_¸_type(type_of vl,sty),¬:BOOL®);
		val dec = mk_const("Z'Dec",decty);
	in
		mk_app(dec,mk_pair(vl,set))
	end
	handle X => (divert X "mk_z_dec"
			"dest_z_power_t" 47060 [fn() => string_of_term set]

	);
=TEX
=SML
fun	Ûmk_z_decsexpÝ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = list_mk_­_type[bty,sty,BOOL];
		val con = mk_const("Z'SchemaDec",cty);
	in
		list_mk_app(con,[bind,sch])
	end;
=TEX
=SML
fun	Ûmk_z_declÝ (tml:TERM list) :TERM =
	let	val lis = mk_list tml;
		val decl = mk_const("Z'Decl",mk_­_type(type_of lis,BOOL));
	in
		mk_app(decl,lis)
	end
	handle X => pass_on X "mk_list" "mk_z_decl";
=TEX
\subsection{Predicate Constructors}
=SML
val	Ûmk_z_eqÝ :(TERM * TERM) -> TERM = mk_eq
	handle X => pass_on X "mk_eq" "mk_z_eq";
=TEX
=SML
fun	Ûmk_z_Ý ((tm1,tm2):TERM * TERM) :TERM = 
	let	val ty = list_mk_­_type[type_of tm1, mk_z_power_t (type_of tm1),BOOL];
	in
		list_mk_app(mk_const("",ty),[tm1,tm2])
	end
	handle X => pass_on X "mk_app" "mk_z_";
=TEX
True and False and the logical connectives in Z map directly into the corresponding HOL constants.
=SML
val	Ûmk_z_trueÝ :TERM = mk_const("T",BOOL);

val	Ûmk_z_falseÝ :TERM = mk_const("F",BOOL);

val	Ûmk_z_³Ý :TERM -> TERM = mk_³
	handle X => pass_on X "mk_³" "mk_z_³";

val	Ûmk_z_±Ý :(TERM * TERM) -> TERM = mk_±
	handle X => pass_on X "mk_±" "mk_z_±";

val	Ûmk_z_²Ý :(TERM * TERM) -> TERM = mk_²
	handle X => pass_on X "mk_²" "mk_z_²";

val	Ûmk_z_´Ý :(TERM * TERM) -> TERM = mk_´
	handle X => pass_on X "mk_´" "mk_z_´";

val	Ûmk_z_¤Ý :(TERM * TERM) -> TERM = mk_¤
	handle X => pass_on X "mk_¤" "mk_z_¤";

fun	Ûmk_z_¶Ý ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_¶ (d,p,v,itym)
	end
	handle X => reraise X "mk_z_¶";

fun	Ûmk_z_¶‰1Ý ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		mk_app(¶‰1_bterm itym,g2_abs(d,p,v,itym))
	end
	handle X => reraise X "mk_z_¶‰1";

fun	Ûmk_z_µÝ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d
	in
		g2_µ (d,p,v,itym)
	end
	handle X => reraise X "mk_z_µ";

fun	Ûmk_z_predsexpÝ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = list_mk_­_type[bty,sty,BOOL];
		val con = mk_const("Z'SchemaPred",cty);
	in
		list_mk_app(con,[bind,sch])
	end;
=TEX
\subsection{Term Constructors}
=SML
fun	Ûmk_z_§¢Ý ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val seqty = mk_z_power_t(mk_z_tuple_t[mk_z_given_t "ú",ty]);
		val zseqty = mk_­_type(listy,seqty);
		val zseq = mk_const("Z'§¢",zseqty);
	in
		case tml of 
			[] => mk_app(zseq,mk_empty_list ty)
		|	_ => mk_app(zseq,mk_list tml)
	end;

fun	Ûmk_z_setdÝ ((ty,tml):TYPE * TERM list) :TERM = 
	let	val listy = mk_ctype("LIST",[ty]);
		val setty = mk_z_power_t ty;
		val zsetty = mk_­_type(listy,setty);
		val zset = mk_const("Z'Setd",zsetty);
	in
		case tml of 
			[] => mk_app(zset,mk_empty_list ty)
		|	_ => mk_app(zset,mk_list tml)
	end;

fun	Ûmk_z_setaÝ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
		val vty = type_of v;
	in
		mk_app (seta_bterm itym vty, g2_abs(d,p,v,itym))
	end;
=TEX
$mk\_z\_ð$ only makes sense if its argument is a set, but we do not bother to check that here, since the type checker should catch this kind of thing and the definition of the constant $Zð$ will prevent us from doing any damage.
=SML
fun	Ûmk_z_ðÝ (tm:TERM) :TERM = 
	let	val ty = type_of tm;
		val psetty = mk_z_power_t ty;
		val zpsetty = mk_­_type(ty,psetty);
		val zpset = mk_const("Z'ð",zpsetty);
	in
		mk_app(zpset,tm)
	end;

fun	Ûmk_z_tupleÝ (tml:TERM list) :TERM = 
	let	val tyl = map type_of tml;
	in
		list_mk_app(tuple_cterm tyl,tml)
	end;

fun	Ûmk_z_bindingÝ (stl:(string * TERM) list) :TERM = (
	let	val (nl, tl) = split stl;
		val side =  moccurs "mk_z_binding" 47152 nl;
		val sortnl = idsetseq nl;
	in	case stl of
			[] => fail "mk_z_binding" 47153 []
		|	_ => list_mk_app(bind_cterm (combine nl (map type_of tl)), map (lassoc3 stl) sortnl)
	end
);

fun	Ûmk_z_¸Ý (tml:TERM list) :TERM = 
	let	val tyl = map (dest_z_power_t o type_of) tml;
	in
		list_mk_app(prod_cterm tyl,tml)
	end;

fun	Ûmk_z_ÊÝ ((sch,d):TERM * string) :TERM = 
	let	val bind = mk_binding(sch,d);
		val bty = type_of bind;
		val sty = type_of sch;
		val cty = list_mk_­_type[bty,sty,bty];
		val con = mk_const("Z'Ê",cty);
	in
		list_mk_app(con,[bind,sch])
	end;

fun	Ûmk_z_sel‰sÝ ((tm,s):TERM * string) :TERM = 
	let	val tym = dest_z_schema_t(type_of tm);
	in
		mk_app(bind_pterm tym s,tm)
	end;

fun	Ûmk_z_sel‰tÝ ((tm,i):TERM * int) :TERM = 
	let	val tyl = dest_z_tuple_t(type_of tm);
	in
		mk_app(bind_ptterm tyl i, tm)
	end;

fun	Ûmk_z_appÝ ((tm1,tm2):TERM * TERM) :TERM = 
	let	val fty = type_of tm1;
		val aty = type_of tm2;
		val rty = 
			case dest_z_tuple_t(dest_z_power_t fty) of
				[_,r] => r
			|	_ => term_fail "mk_z_app" 0 [];
		val zappty = list_mk_­_type[fty,aty,rty];
		val zapp = mk_const("Z'App",zappty);
	in
		list_mk_app (zapp, [tm1, tm2])
	end;
=TEX
=SML
local
fun	f ([]:Z_TERM list) :TERM list = []
|	f (ZDec(tml,_)::z_tml) = tml @ (f z_tml)
|	f (ZSchemaDec(sch,d)::z_tml) = (mk_z_Ê(sch,d)) :: (f z_tml)
|	f _ = term_fail "mk_z_Ì" 0 [];

fun	chartuple ((ZDecl tml):Z_TERM) :TERM = (
		case (f (map dest_z_term tml)) of
			[] => fail "mk_z_Ì" 0 []
		|	[tm] => tm
		|	tml' => mk_z_tuple tml'
		)
|	chartuple _ = fail "mk_z_Ì" 0 [];
in
fun	Ûmk_z_ÌÝ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val t = chartuple(dest_z_term d);
		val tym = dest_decl d;
		val tty = type_of t;
		val vty = type_of v;
	in
		mk_app(Ì_bterm tym tty vty,g3_abs(t,d,p,v,tym))
	end
	handle	Fail _ => term_fail "mk_z_Ì" 47201 [d,p,v]
end;
=TEX
=SML
fun	Ûmk_z_ÍÝ ((d,p,v):TERM * TERM * TERM) :TERM = 
	let	val tym = dest_decl d;
		val vty = type_of v;
	in
		mk_app(Í_bterm tym vty,g2_abs(d,p,v,tym))
	end;

fun	Ûmk_z_lvarÝ ((s,ty,tml):string * TYPE * TERM list) :TERM = 
		case tml of [] 	=> mk_var(s,ty)
		| _		=> 
			let	val cty = mk_­_type(mk_z_tuple_t(map type_of tml),ty);
			in
				mk_app(mk_var(s,cty),mk_z_tuple tml)
			end;

fun	Ûmk_z_gvarÝ ((s,ty,tml):string * TYPE * TERM list) :TERM =
		case tml of [] 	=> bind_gvar_term (s,ty)
		| _		=> 
			let	val cty = mk_­_type(mk_z_tuple_t(map type_of tml),ty);
			in
				mk_app(bind_gvar_term (s,cty),mk_z_tuple tml)
			end;

fun	Ûmk_z_intÝ (s:string) :TERM = 
	let	val nty = mk_ctype("î",[]);
		val zty = mk_ctype("ú",[]);
		val zint = mk_const("Z'Int",mk_­_type(nty,zty));
	in
		mk_app(zint,mk_const(s,nty))
	end;

fun	Ûmk_z_stringÝ (s:string) :TERM = 
	let	val aty = mk_ctype("LIST",[mk_ctype ("CHAR", [])]);
		val rty = mk_z_power_t (mk_z_tuple_t[
				mk_ctype("ú",[]),mk_ctype("CHAR",[])]);
		val zs = mk_const("Z'String",mk_­_type(aty,rty));
	in
		mk_app(zs,mk_string s)
	end;
=TEX
\subsection{Constructors for the Schema Calculus}
=SML
fun	Ûmk_z_‰sÝ ((d,p):TERM * TERM) :TERM = 
	let	val itym = dest_decl d;
	in
		mk_app (schema_bterm itym, g1_abs(d,p,itym))
	end;

fun	Ûmk_z_dec‰sÝ ((tm,s):TERM * string) :TERM =
	let	val tym = dest_z_schema_t(dest_z_power_t(type_of tm));
	in
		mk_app(bind_decor_term tym s,tm)
	end;

fun	Ûmk_z_pre‰sÝ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_t(dest_z_power_t(type_of tm));
	in
		mk_app(bind_pre_term tym,tm)
	end;

fun	Ûmk_z_³‰sÝ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_t(dest_z_power_t(type_of tm));
	in
		mk_app(bind_³_term tym,tm)
	end;

fun	Ûmk_z_±‰sÝ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_t(dest_z_power_t(type_of tm1));
		val tym2 = dest_z_schema_t(dest_z_power_t(type_of tm2));
	in
		list_mk_app(bind_±_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_²‰sÝ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_t(dest_z_power_t(type_of tm1));
		val tym2 = dest_z_schema_t(dest_z_power_t(type_of tm2));
	in
		list_mk_app(bind_²_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_´‰sÝ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_t(dest_z_power_t(type_of tm1));
		val tym2 = dest_z_schema_t(dest_z_power_t(type_of tm2));
	in
		list_mk_app(bind_´_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_¤‰sÝ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_t(dest_z_power_t(type_of tm1));
		val tym2 = dest_z_schema_t(dest_z_power_t(type_of tm2));
	in
		list_mk_app(bind_¤_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_ù‰sÝ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_t(dest_z_power_t(type_of tm1));
		val tym2 = dest_z_schema_t(dest_z_power_t(type_of tm2));
	in
		list_mk_app(bind_ù_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_hide‰sÝ ((tm,sl):TERM * string list) :TERM =
	let	val tym = dest_z_schema_t(dest_z_power_t(type_of tm));
	in
		mk_app(bind_hide_term tym sl,tm)
	end;

fun	Ûmk_z_¶‰sÝ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_z_schema_t(dest_z_power_t(type_of v));
	in
		list_mk_app(¶‰s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_z_¶‰1‰sÝ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_z_schema_t(dest_z_power_t(type_of v));
	in
		list_mk_app(¶‰1‰s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_z_µ‰sÝ ((d,p,v):TERM * TERM * TERM) :TERM =
	let	val dtym = dest_decl d;
		val vtym = dest_z_schema_t(dest_z_power_t(type_of v));
	in
		list_mk_app(µ‰s_bterm dtym vtym,[g1_abs(d,p,dtym),v])
	end;

fun	Ûmk_z_„‰sÝ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_t(dest_z_power_t(type_of tm));
	in
		mk_app(bind_„_term tym,tm)
	end;

fun	Ûmk_z_˜‰sÝ (tm:TERM) :TERM =
	let	val tym = dest_z_schema_t(dest_z_power_t(type_of tm));
	in
		mk_app(bind_˜_term tym,tm)
	end;

fun	Ûmk_z_»‰sÝ ((tm1,tm2):TERM * TERM) :TERM =
	let	val tym1 = dest_z_schema_t(dest_z_power_t(type_of tm1));
		val tym2 = dest_z_schema_t(dest_z_power_t(type_of tm2));
	in
		list_mk_app(bind_»_term tym1 tym2,[tm1,tm2])
	end;

fun	Ûmk_z_rename‰sÝ (tm:TERM, ididl : (string * string) list) :TERM = (
	let	val tym = dest_z_schema_t(dest_z_power_t(type_of tm));
		val (xs,ys) = split ididl;
		val dummy = (moccurs "mk_z_rename‰s" 47463 xs;
				moccurs "mk_z_rename‰s" 47462 ys);
	in
		mk_app(bind_rename_term tym ididl, tm)
	end);
=TEX
Can renaming collapse two distinct components onto one,
by renaming one component to be the same as another?

\subsection{The General Constructor Function}
This function uses the constructors defined above to convert a $Z\_TERM$ to the corresponding $TERM$.
=SML
fun	Ûmk_z_termÝ	(ZDec(tml:TERM list,tm:TERM) :Z_TERM) :TERM = mk_z_dec(tml,tm)
|	mk_z_term	(ZSchemaDec(tm:TERM,s:string)) = mk_z_decsexp(tm,s)
|	mk_z_term	(ZDecl(tml:TERM list)) = mk_z_decl tml
|	mk_z_term	(ZEq(tm1:TERM,tm2:TERM)) = mk_z_eq(tm1,tm2)
|	mk_z_term	(Z(tm1:TERM,tm2:TERM)) = mk_z_(tm1,tm2)
|	mk_z_term	(ZTrue) = mk_z_true
|	mk_z_term	(ZFalse) = mk_z_false
|	mk_z_term	(Z³(tm:TERM)) = mk_z_³ tm
|	mk_z_term	(Z±(tm1:TERM,tm2:TERM)) = mk_z_±(tm1,tm2)
|	mk_z_term	(Z²(tm1:TERM,tm2:TERM)) = mk_z_²(tm1,tm2)
|	mk_z_term	(Z´(tm1:TERM,tm2:TERM)) = mk_z_´(tm1,tm2)
|	mk_z_term	(Z¤(tm1:TERM,tm2:TERM)) = mk_z_¤(tm1,tm2)
|	mk_z_term	(Z¶(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶(tm1,tm2,tm3)
|	mk_z_term	(Z¶‰1(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶‰1(tm1,tm2,tm3)
|	mk_z_term	(Zµ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_µ(tm1,tm2,tm3)
|	mk_z_term	(ZSchemaPred(tm:TERM,s:string)) = mk_z_predsexp(tm,s)
|	mk_z_term	(ZLVar(s:string,ty:TYPE,tml:TERM list)) = mk_z_lvar(s,ty,tml)
|	mk_z_term	(ZGVar(s:string,ty:TYPE,tml:TERM list)) = mk_z_gvar(s,ty,tml)
|	mk_z_term	(ZInt(s:string)) = mk_z_int(s)
|	mk_z_term	(ZString(s:string)) = mk_z_string(s)
|	mk_z_term	(Z§¢(ty:TYPE,tml:TERM list)) = mk_z_§¢(ty,tml)
|	mk_z_term	(ZSetd(ty:TYPE,tml:TERM list)) = mk_z_setd(ty,tml)
|	mk_z_term	(ZSeta(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_seta(tm1,tm2,tm3)
|	mk_z_term	(Zð(tm:TERM)) = mk_z_ð tm
|	mk_z_term	(ZTuple(tml:TERM list)) = mk_z_tuple tml
|	mk_z_term	(ZBinding(stl:(string * TERM) list)) = mk_z_binding stl
|	mk_z_term	(Z¸(tml:TERM list)) = mk_z_¸ tml
|	mk_z_term	(ZÊ(tm:TERM,s:string)) = mk_z_Ê(tm,s)
|	mk_z_term	(ZSel‰s(tm:TERM,s:string)) = mk_z_sel‰s(tm,s)
|	mk_z_term	(ZSel‰t(tm:TERM,i:int)) = mk_z_sel‰t(tm,i)
|	mk_z_term	(ZApp(tm1:TERM,tm2:TERM)) = mk_z_app(tm1,tm2)
|	mk_z_term	(ZÌ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_Ì(tm1,tm2,tm3)
|	mk_z_term	(ZÍ(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_Í(tm1,tm2,tm3)
|	mk_z_term	(Z‰s(tm1:TERM,tm2:TERM)) = mk_z_‰s(tm1,tm2)
|	mk_z_term	(ZDecor‰s(tm:TERM,s:string)) = mk_z_dec‰s(tm,s)
|	mk_z_term	(ZPre‰s(tm:TERM)) = mk_z_pre‰s tm
|	mk_z_term	(Z³‰s(tm:TERM)) = mk_z_³‰s tm
|	mk_z_term	(Z±‰s(tm1:TERM,tm2:TERM)) = mk_z_±‰s(tm1,tm2)
|	mk_z_term	(Z²‰s(tm1:TERM,tm2:TERM)) = mk_z_²‰s(tm1,tm2)
|	mk_z_term	(Z´‰s(tm1:TERM,tm2:TERM)) = mk_z_´‰s(tm1,tm2)
|	mk_z_term	(Z¤‰s(tm1:TERM,tm2:TERM)) = mk_z_¤‰s(tm1,tm2)
|	mk_z_term	(Zù‰s(tm1:TERM,tm2:TERM)) = mk_z_ù‰s(tm1,tm2)
|	mk_z_term	(ZHide‰s(tm:TERM,sl:string list)) = mk_z_hide‰s(tm,sl)
|	mk_z_term	(Z¶‰s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶‰s(tm1,tm2,tm3)
|	mk_z_term	(Z¶‰1‰s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_¶‰1‰s(tm1,tm2,tm3)
|	mk_z_term	(Zµ‰s(tm1:TERM,tm2:TERM,tm3:TERM)) = mk_z_µ‰s(tm1,tm2,tm3)
|	mk_z_term	(Z„‰s(tm:TERM)) = mk_z_„‰s tm
|	mk_z_term	(Z˜‰s(tm:TERM)) = mk_z_˜‰s tm
|	mk_z_term	(Z»‰s(tm1:TERM,tm2:TERM)) = mk_z_»‰s(tm1,tm2)
|	mk_z_term	(ZRename‰s(tm:TERM,ididl:(string * string)list)) = mk_z_rename‰s(tm,ididl)

;
=TEX
Finally, we leave the structure open.
=SML
end (* of structure ZTypesAndTerms *);
open ZTypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

val d1 = mk_z_decl[mk_z_dec([mk_var("a",mk_z_given_t"A"),mk_var("x",mk_z_given_t"A")],mk_var("A",mk_z_power_t(mk_z_given_t"A")))];
val p1 = mk_z_true;
val sch1 = mk_z_‰s(d1,p1);
val d2 = mk_z_decl[mk_z_dec([mk_var("y",mk_z_given_t"B"),mk_var("b",mk_z_given_t"B")],mk_var("B",mk_z_power_t(mk_z_given_t"B")))];
val p2 = mk_z_true;
val sch2 = mk_z_‰s(d2,p2);
val d3 = mk_z_decl[mk_z_decsexp(sch1,"'"),mk_z_decsexp(sch2,"")];
val p3 = mk_z_true;
val sch3 = mk_z_‰s(d3,p3);



val x = mk_z_lvar("x",mk_z_given_t "A",[]);
val y = mk_z_lvar("y",mk_z_given_t "A",[]);
val X = mk_z_lvar("X",mk_z_power_t(mk_z_given_t "A"),[]);
val Y = mk_z_lvar("Y",mk_z_power_t(mk_z_given_t "B"),[]);
val eq = mk_z_eq(x,y);
val mm = mk_z_(x,X);

val f = mk_z_¸[X,Y];

val zd = mk_const("Z'Ì",mk_­_type(BOOL,BOOL));
val tm = mk_app(zd,p1);



