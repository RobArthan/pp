=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Relations}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP083}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.Blackburn & WIN01}
\TPPauthors{D.J.~King & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1] 
First version, derived from \cite{DS/FMU/IED/IMP042}.
\item [Issues 1.2 (21st October 1992)] 
Corrected pre-processing in proof contexts,
added in $z\-\_rel\-\_inv\-\_thm$.
\item [Issues 1.3 (21st October 1992)] 
Removed consistency function.
\item [Issues 1.4 (22nd October 1992)] 
ML typo.
\item [Issues 1.5 (22nd October 1992)] 
Improved use of $z\_rel\_inv\_thm$, changed $z\_id\_thm$.
\item [Issue 1.6 (22nd October 1992)]
Change of name and nature to Z Library Relations.
\item [Issue 1.7,1.8 (30th October 1992)]
Reorganising Z theory material.
\item [Issue 1.9, 12th November 1992] 
Changes as a consequence of changes in dependences.
\item [Issue 1.9, 4th December 1992] 
Bug fix after parser change.
\item[Issue 1.12 (8th December 1992)]
Removed mention of ``$'$z$\_$schemas$\_$ext''.
\item[Issue 1.13 (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) set theory, tuples and cartesian products.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD083}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the set theory, tuples and cartesian products of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD083}.
\subsubsection{Deficiencies}
$z\_∏\_conv$ is comparatively slow compared to like functions.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
Structure done in two parts.
=SML
structure €ZRelations› : ZRelations = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_relations"›;
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples_lang"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:
=SML
	val z_™_def = get_spec Ò(_ ™ _)Æ;
	val z_Ì_def = get_spec Ò(_ Ì _)Æ;
	val z_dom_def = get_spec Ò(dom)Æ;
	val z_ran_def = get_spec Ò(ran)Æ;
	val z_id_def = get_spec Ò(id _)Æ;
	val z_ª_def = get_spec Ò(_ ª _)Æ;
	val z_o_def = get_spec Ò(_ o _)Æ;
	val z_Ú_def = get_spec Ò(_ Ú _)Æ;
	val z_í_def = get_spec Ò(_ í _)Æ;
	val z_·_def = get_spec Ò(_ · _)Æ;
	val z_Å_def = get_spec Ò(_ Å _)Æ;
	val z_rel_inv_def = get_spec Ò(_ Á~Í)Æ;
	val z_rel_image_def = get_spec Ò(_ ® _ ©)Æ;
	val z_tc_def = get_spec Ò(_ Á+Í)Æ;
	val z_rtc_def = get_spec Ò(_ Á*Í)Æ;
	val z_´_def = get_spec Ò(_ ´ _)Æ;
=TEX

\section{THE CODE}
\subsection{Utilities}
A precaution, lost outside of structure:
=SML
fun €save_thm›(a,b) = KernelInterface.save_thm(a, check_is_z_thm "save_thm" b);
fun €list_save_thm›(a,b) = KernelInterface.list_save_thm(a, check_is_z_thm "list_save_thm" b);
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
val €Ub› = inst [] [(î'bÆ,î'aÆ)] Ua;
val €Uc› = inst [] [(î'cÆ,î'aÆ)] Ua;
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_¡_conv1 nm :CONV= (fn tm =>
		(simple_¡_conv nm
		ORELSE_C
		simple_¡_conv1 (nm ^ get_variant_suffix())) tm);
in
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_¡_conv1 nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_¡_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
end;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX
Change a free variable name:
=SML
fun €change_name_rule› from_nm to_nm thm = (
let	val fvs = map dest_var (frees(concl thm));
	val ty = lassoc3 fvs from_nm;
in
	simple_µ_elim (mk_var(to_nm, ty))
	(simple_µ_intro (mk_var(from_nm, ty)) thm)
end);
=TEX

\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
=SML
fun use_ext_pc () = push_merge_pcs ["z_sets_ext", "'z_tuples_lang"];
=TEX
\section{THE IMPLEMENTATION}
=SML
local
	val spec = (rewrite_rule[]z_™_def);
in
val €z_™_thm› = save_thm("z_™_thm",
	all_z_µ_intro(all_µ_elim 
	(inst_type_rule[(î'bÆ,î'YÆ),(î'aÆ,î'XÆ)]spec)));
end;
=TEX


\section{TUPLES}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_Ì_def));
in
val €z_Ì_thm› = save_thm("z_Ì_thm",
	(nth 1 (strip_±_rule spec)));
end;
=TEX
=SML
val €z_Ì_conv› : CONV = simple_eq_match_conv1 (conv_rule
		z_µ_elim_conv1 z_Ì_thm);
=TEX
=SML
local
	fun aux thm [] [] = thm
	| aux thm (a::x)(b::y) = aux (mk_app_rule thm (asm_rule (mk_z_eq (a, b)))) x y
	| aux _ _ _ = error "z_tuple_eq_conv" 0 [];
	
	fun aux1 tm [] [] = tm
	| aux1 tm (a::x)(b::y) = aux1 (mk_z_±(mk_z_eq (a,b), tm)) x y
	|aux1 _ _ _ = error "z_tuple_eq_conv" 0 [];
in
val €z_tuple_eq_conv› : CONV = (fn tm =>
let	val (lhs,rhs) = dest_z_eq tm
		handle (Fail _) =>
		term_fail "z_tuple_eq_conv" 42003 [tm];
	val s0 = (if is_z_tuple lhs andalso is_z_tuple rhs
		then refl_conv tm
		else 
		((LEFT_C z_Ì_conv AND_OR_C RIGHT_C z_Ì_conv)
		tm))
		handle (Fail _) =>
		term_fail "z_tuple_eq_conv" 42003 [tm];
	val tm' = snd(dest_eq(concl s0));
	val (lhs,rhs) = dest_z_eq tm';
	val dummy = if is_z_tuple lhs andalso is_z_tuple rhs
		then ()
		else term_fail "z_tuple_eq_conv" 42003 [tm];
	val spec = get_spec lhs;
	val proj_thms = map all_µ_intro
		(rev(tl(rev(strip_±_rule(all_µ_elim spec)))));
	val (tcons,tproj) = get_tuple_info (type_of lhs);
	val lhs_bits = dest_z_tuple lhs;
	val rhs_bits = dest_z_tuple rhs;
	val tcons' = fst(strip_app lhs);
	val ty_insts = fst(term_match tcons' tcons);
	val s1 = aux (refl_conv tcons') lhs_bits rhs_bits;
	val rlhs_bits = rev lhs_bits;
	val rrhs_bits = rev rhs_bits;
	val res = aux1 (mk_z_eq(hd rlhs_bits, hd rrhs_bits))
		(tl rlhs_bits) (tl rrhs_bits);
	val s2 = strip_±_rule (asm_rule res);
	val s3 = fold (uncurry prove_asm_rule) s2 s1;
	val s4 = asm_rule tm';
	val s5 = map (fn (x,xthm) => 
		conv_rule(APP_C(RAND_C(simple_eq_match_conv1 xthm),
			simple_eq_match_conv1 xthm))
		(app_fun_rule (inst [] ty_insts x) s4)) 
		(combine tproj proj_thms);
	val s6 = list_±_intro s5;
	val s7 = §_intro(all_¥_intro s6) (all_¥_intro s3);
in
	check_is_z_conv_result "z_tuple_eq_conv" 
	(eq_trans_rule s0 s7)
end);
end;
=TEX
=IGN
z_tuple_eq_conv Ò(1,2,3) = (p,q,r)Æ;
z_tuple_eq_conv Ò(1 Ì 2) = (p,q)Æ;
=SML
val €z_selât_conv› : CONV = (fn tm =>
let	val (bdy,n) = dest_z_selât tm
		handle complaint =>
		pass_on complaint "dest_z_selât" "z_selât_conv";
	val spec = get_spec tm;
	val s0 = (if is_z_tuple bdy
		then refl_conv tm
		else (RAND_C z_Ì_conv) tm)
		handle (Fail _) =>
		term_fail "z_selât_conv" 42006 [tm];
	val tm' = snd(dest_eq(concl s0));
	val (bdy,n) = dest_z_selât tm'; 
	val xi = dest_z_tuple bdy;
	val proj_thm = nth (n-1) 
		(strip_±_rule(list_µ_elim (bdy :: xi) spec));
in
	check_is_z_conv_result "z_selât_conv"
	(eq_trans_rule s0 proj_thm)
end);
=TEX
=IGN
z_selât_conv Ò(1,2,3,4).2Æ;
z_selât_conv Ò(1 Ì 2).2Æ;
=SML
val €z_tuple_intro_conv› : CONV = (fn tm =>
let	val s0 = if is_z_tuple tm
		then refl_conv tm
		else (z_Ì_conv ORELSE_C
		(fn _ => term_fail "z_tuple_intro_conv" 42005 [tm])) tm;
	val tm' = snd(dest_eq(concl s0));
	val xi = dest_z_tuple tm'
		handle (Fail _) =>
		term_fail "z_tuple_intro_conv" 42005 [tm];
	val tuple= fst(dest_z_selât(hd xi))
		handle (Fail _) =>
		term_fail "z_tuple_intro_conv" 42005 [tm];
	val spec = all_µ_elim (µ_elim tuple (get_spec tm'))		handle (Fail _) =>
		term_fail "z_tuple_intro_conv" 42005 [tm];
	val cthm = hd(rev(strip_±_rule spec));
in
		check_is_z_conv_result "z_tuple_intro_conv"
		(eq_trans_rule s0 cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_intro_conv" 42005
			[fn () => string_of_term tm])
end);
=TEX
=IGN
z_tuple_intro_conv Ò((1,2,3).1,(1,2,3).2,(1,2,3).3)Æ;
z_tuple_intro_conv Ò((1 Ì 2).1,(1 Ì 2).2)Æ;
=TEX
\section{RELATIONS}
=SML
val €u_™_u_thm› = prove_rule [z_™_def]  ÒU ™ U = UÆ;
=TEX
=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_dom_def));
	val s1 = conv_rule z_µ_elim_conv1(±_right_elim spec);
	val s2 = rewrite_rule [z_sets_ext_thm] s1;
	val s3 = conv_rule (ONCE_MAP_C (z_∂_elim_conv1 THEN_C
			prove_∂_conv THEN_C
			z_∂_intro_conv)) s2;
	val s4 = all_µ_elim s3;
in
val €z_dom_thm› = save_thm("z_dom_thm",
	pure_rewrite_rule[z_Ì_thm]
	(all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1(±_left_elim s4)))));
val €z_ran_thm› = save_thm("z_ran_thm",
	pure_rewrite_rule[z_Ì_thm]
	(inst_type_rule [(î'bÆ,î'aÆ),(î'aÆ,î'bÆ)]
	(all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1(±_right_elim s4))))));
end;
=TEX
=SML
val _ = use_ext_pc();
local
	val spec = all_z_µ_intro(all_µ_elim(rewrite_rule[]
		z_id_def));
in
val €z_id_thm› = save_thm("z_id_thm",(
push_goal([],Òµ X: U∑ id X = {x : U | x ç X ∑ (x, x)}Æ);
a(rewrite_tac[spec, z_Ì_thm]);
a(REPEAT strip_tac THEN prop_eq_prove_tac[]);
a(z_spec_nth_asm_tac 3 Òx1Æ);
pop_thm()));
end;
val _ = pop_pc();
=TEX
=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua,Ub,Uc]
		(rewrite_rule[]z_ª_def));
	val s1 = conv_rule z_µ_elim_conv1(±_right_elim spec);
	val s2 = rewrite_rule [z_sets_ext_thm]
		(±_right_elim(all_µ_elim s1));
	val s3 = all_µ_elim(conv_rule z_µ_elim_conv1 s2);
	val s4 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (RIGHT_C z_selât_intro_conv THEN_C
			z_tuple_eq_conv))
		THEN_C prove_∂_conv
		THEN_C z_∂_intro_conv)) s3;
in
val €z_ª_thm› = save_thm("z_ª_thm",
	all_z_µ_intro(±_left_elim(all_µ_elim s1)));
val €z_o_thm› = save_thm("z_o_thm",
	pure_rewrite_rule[z_Ì_thm]
	(inst_type_rule[(î'bÆ,î'cÆ),(î'cÆ,î'bÆ)]
	(all_z_µ_intro (change_name_rule "z" "x" s4))));
end;
=TEX
=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_Ú_def));
	val s1 = conv_rule(MAP_C z_µ_elim_conv1)
		(rewrite_rule[z_sets_ext_thm]
		(±_right_elim spec));
	val s2 = all_µ_elim(±_left_elim s1);
	val s3 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (RIGHT_C z_selât_intro_conv
			THEN_C z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s2;
	val s4 = conv_rule(RIGHT_C(RIGHT_C(LEFT_C z_tuple_intro_conv))) s3;
	val s5 = ±_right_elim s1;
	val s6 = all_µ_elim (conv_rule (BINDER_C(RAND_C(simple_¡_conv "S"))) s5);
	val s7 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (RIGHT_C z_selât_intro_conv
			THEN_C z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s6;
	val s8 = conv_rule(RIGHT_C(LEFT_C(LEFT_C z_tuple_intro_conv))) s7;

in
val €z_Ú_thm› = save_thm("z_Ú_thm",
	all_z_µ_intro (change_name_rule "z" "x" s4));
val €z_í_thm› = save_thm("z_í_thm",
	all_z_µ_intro (change_name_rule "z" "x" s8));
end;
=TEX
=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[] z_·_def));
	val s1 = conv_rule(MAP_C z_µ_elim_conv1)
		(rewrite_rule[z_sets_ext_thm]
		(conv_rule(ONCE_MAP_C z_µ_elim_conv1)
		(±_right_elim spec)));
	val s2 = all_µ_elim(±_left_elim s1);
	val s3 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (RIGHT_C z_selât_intro_conv THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s2;
	val s4 = conv_rule(RIGHT_C(RIGHT_C(LEFT_C z_tuple_intro_conv))) s3;
	val s5 = ±_right_elim s1;
	val s6 = all_µ_elim (conv_rule (BINDER_C(RAND_C(simple_¡_conv "S"))) s5);
	val s7 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (RIGHT_C z_selât_intro_conv THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s6;
	val s8 = conv_rule(RIGHT_C(LEFT_C(LEFT_C z_tuple_intro_conv))) s7;

in
val €z_·_thm› = save_thm("z_·_thm",
	all_z_µ_intro (change_name_rule "z" "x" s4));
val €z_Å_thm› = save_thm("z_Å_thm",
	all_z_µ_intro (change_name_rule "z" "x" s8));
end;
=TEX

=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_rel_inv_def));
	val s1 = conv_rule z_µ_elim_conv1 
		(±_right_elim spec);
	val p = mk_var("p",type_of Ò(p,q)Æ);
	val s2 = (pure_rewrite_conv [s1]  THEN_C z_ç_seta_conv)
		(snd(strip_µ Ò[a,b] ((x ∫ (a ∏ b)).1,x.2) ç R Á~ÍÆ));
	val s3 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (LEFT_C (rewrite_conv [z_Ì_thm]) THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s2;
	val s4 = conv_rule(MAP_C z_tuple_intro_conv) s3;
in
val €z_rel_inv_thm› = save_thm("z_rel_inv_thm",
	pure_rewrite_rule[z_Ì_thm]
	(all_z_µ_intro s4));
end;
=TEX
=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_rel_image_def));
	val s1 = all_µ_elim(conv_rule z_µ_elim_conv1 
		(±_right_elim spec));
	val s2 = (µ_elim ¨y:'bÆ
		(conv_rule z_µ_elim_conv1
		(rewrite_rule[z_sets_ext_thm] s1)));
	val s3 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		prove_∂_conv)) s2;
	val ±_t_±_thm = taut_rule¨µ x y∑ x ± y § x ± T ± yÆ;
	val s4 = conv_rule (RIGHT_C (BINDER_C(LEFT_C
		(Z_DECL_INTRO_C z_pred_dec_conv) THEN_C 
		simple_eq_match_conv1 ±_t_±_thm)
		THEN_C z_∂_intro_conv1)) s3;
in
val €z_rel_image_thm› = save_thm("z_rel_image_thm",
	conv_rule ((ONCE_MAP_C 
		(z_∂_elim_conv THEN_C z_∂_intro_conv THEN_C rewrite_conv[]))) 
	(inst_type_rule [(î'bÆ,î'aÆ),(î'aÆ,î'bÆ)]
	(pure_rewrite_rule[z_Ì_thm]
	(all_z_µ_intro s4))));
end;
=TEX
=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua]
		(rewrite_rule[]z_tc_def));
	val s1 = all_µ_elim(conv_rule z_µ_elim_conv1 
		(±_right_elim spec));
in
val €z_trans_closure_thm› = save_thm("z_trans_closure_thm",
	all_z_µ_intro(±_left_elim s1));
val €z_reflex_trans_closure_thm› = 
	save_thm("z_reflex_trans_closure_thm",
		all_z_µ_intro(±_right_elim s1));
end;
=TEX
=SML
local
	val spec = rewrite_rule[u_™_u_thm]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_´_def));
in
val €z_´_thm› = save_thm("z_´_thm",
	all_z_µ_intro(all_µ_elim(
	conv_rule z_µ_elim_conv1
	(nth 1 (strip_±_rule spec)))));
end;
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun €make_ç_rule› thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun €make_pair_trio_rule› thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_selât_conv)
		(µ_elim Ò(p1,p2)Æ 
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_selât_conv)
		(µ_elim Ò(p1 Ì p2)Æ (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val €ç_operator_clauses1› = [
	make_ç_rule z_´_thm, 
	make_ç_rule z_trans_closure_thm,
	make_ç_rule z_reflex_trans_closure_thm,
	z_rel_image_thm, 
	make_pair_trio_rule z_rel_inv_thm,
	make_pair_trio_rule z_·_thm, 
	make_pair_trio_rule z_Å_thm, 
	make_pair_trio_rule z_Ú_thm,
	make_pair_trio_rule z_í_thm, 
	make_pair_trio_rule z_o_thm, 
	make_ç_rule z_ª_thm, 
	make_ç_rule z_id_thm, z_ran_thm, z_dom_thm,
	make_ç_rule z_™_thm];
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	
\subsection{Treatment of Membership of Relations}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_rel" handle Fail _ => ();
val _ = new_pc "'z_ç_rel";
val _ = set_rw_eqn_cxt []"'z_ç_rel";
val _ = add_rw_thms 
	([]
	@ ç_operator_clauses1) "'z_ç_rel";

val pos = (thms_to_eqn_cxt ç_operator_clauses1)
	@ [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_ç_rel";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_ç_rel";
val _ = set_rw_canons [] "'z_ç_rel";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_rel";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_rel";
val _ = set_cs_∂_convs [] "'z_ç_rel";
val _ = set_∂_vs_thms [] "'z_ç_rel";
=TEX
\subsection{Treatment of Tuples and Cartesian Products}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_tuples" handle Fail _ => ();
val _ = new_pc "'z_tuples";
val _ = set_rw_eqn_cxt [(Òx ç ¨y (z:'c):'b SETÆÆ,z_ç_∏_conv),
	(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_eq_conv),
	(¨f(a1 a2 a3)Æ,z_selât_conv),
	(¨f (a1 a2) (b1 b2)Æ,z_tuple_intro_conv)
	]"'z_tuples";
val _ = add_rw_thms 
	([z_second_thm, z_first_thm]) "'z_tuples";

val pos = [(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_eq_conv),
	  (Òx ç ¨y (z:'c):'b SETÆÆ,z_ç_∏_conv)];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_tuples";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_tuples";
val _ = set_rw_canons [] "'z_tuples";
val _ = set_pr_tac z_basic_prove_tac "'z_tuples";
val _ = set_pr_conv z_basic_prove_conv "'z_tuples";
val _ = set_cs_∂_convs [] "'z_tuples";
val _ = set_∂_vs_thms [] "'z_tuples";
val _ = commit_pc "'z_tuples";
=TEX
\subsection{Treatment of Z Language}
=SML
val _ = delete_pc "z_language" handle (Fail _) => ();
val _ = new_pc "z_language";
val _ = merge_pcs ["z_predicates",
	"'z_ç_set_lang",
	"'z_bindings",
	"'z_schemas",
	"'z_tuples"] "z_language";
=TEX
=SML
val _ = delete_pc "z_language_ext" handle (Fail _ ) => ();
val _ = new_pc "z_language_ext";
val _ = merge_pcs ["z_predicates",
	"'z_ç_set_lang",
	"'z_sets_ext_lang",
	"'z_bindings",
	"'z_schemas",
	"'z_tuples"] "z_language_ext";
=TEX
\section{EPILOGUE}
=SML
end; (* of structure ZRelations *)
open ZRelations;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
