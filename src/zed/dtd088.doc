%  dtd088.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of the Z Library Bags}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD088}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
%\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthors{D.J.~King & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design of
the Z Library Bags and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (22nd October 1992)]
First version, derived from 078 and 083.
\item [Issue 1.2 (30th October 1992)]
Tidying.
\item [Issue 1.3, 12th November 1992] 
Changes as a consequence of changes in dependences.
\item [Issue 1.4, 15th November 1992] 
Added definition of the bag brackets.
\item[Issue 1.5 (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.6 (11th December 1992)]
Removed spurious ML bindings.
\item[Issue 1.7 (10th February 1993)]
Rearranging proof contexts.
\end{description}
\subsection{Changes Forecast}
Proof contexts ``z$\_$library'' and ``z$\_$library$\_$ext'' are 
likely to change or be superceded.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design
of the Bags Material of the Z Library.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD017}.
\subsection{Dependencies}

\subsection{Possible Enhancements}
2nd Edition Spivey changes the name of bag membership, and
gives new operators for bag scaling, bag subsets, and bag difference.
This may need to be tracked as the Z Standard, to date, does not have these changes.
\subsection{Deficiencies}
None known.
\section{PROLOG}

=SML
open_theory"z_sequences";
push_pc "z_sets_alg";
delete_theory"z_bags" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
new_theory"z_bags";
=TEX
\section {DEFINITION OF FIXITY}

The following fixity information has been taken from \cite{Spivey89}.
¹Z
fun 3 _ ‚ _
°
¹Z
rel _ in _
°
¹Z
gen 7 bag _
°
In the language of Spivey, bag display is a language construct; the \ProductZ{} language allows (and requires) us to define the bag display here:

¹Z
	fun	û ... ı
°

\section{BAGS}

\subsection{Bags, Multiplicity and Membership}

¹Z
Ûbagİ X ¦ X ß î‰1
°

[X]œœœœœœœœœœœœœœœœ
Ü Ûcountİ : bag X  (X ­ î)
÷üüüüüüüüüüüüüüüüüü
Üµ x : X; B : bag X ·
Ü	count B = (Ìx:X · 0) « B
ˆüüüüüüüüüüüüüüüüüüüü

[X]œœœœœœœœœœœœœœœœ
Ü _ Ûinİ _ : X ª bag X
÷üüüüüüüüüüüüüüüüüü
Ü µ x : X;B : bag X ·
Ü	x in B ¤ x  dom B
ˆüüüüüüüüüüüüüüüüüüüü
N.B. this is as in the 1st edition of Spivey, and in the standard version 0.5,
but its name changes to a ``squared'' $$ in 2nd edition Spivey.

\subsection{Bag Union}
[X]œœœœœœœœœœœœœœœœ
Ü _ Û‚İ _ : (bag X) ¸ bag X ­ bag X
÷üüüüüüüüüüüüüüüüüü
Ü µ B, C : bag X; x : X ·
Ü	count (B ‚ C) x = count B x + count C x
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Bag of Elements of a Sequence}

[X]œœœœœœœœœœœœœœœœ
Ü Ûitemsİ : seq X ­ bag X
÷üüüüüüüüüüüüüüüüüü
Ü µ s : seq X; x : X ·
Ü	count (items s) x = # {i : dom s | s (i) = x}
ˆüüüüüüüüüüüüüüüüüüüü
\subsection{Bag Display}
[X]œœœœœœœœœœœœœœœœ
	û ... ı : seq X ­ bag X
÷üüüüüüüüü
	û ı = {};
	µx : X; s : seq X· (û ... ı) (§x¢ ë s) = (û ... ı) s « {x í (û ... ı) s x + 1}
ˆüüüüüüüüüüüüüüüüüüü
\section{START OF STRUCTURE}
=DOC
signature ÛZBagsİ = sig
=DESCRIBE
This provides the basic proof support for the Z library bags.
It creates the theory $z\_bags$.
=ENDDOC
=THDOC
req_name Û"z_bags"İ (Value "z_sequences");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_bags$ contains various definitions of relation operators, and ``defining theorems'' of Z library constants derived from these definitions.
It is created in structure $ZBags$.
=ENDDOC

=DOC
val Ûz_bag_defİ : THM;	val Ûz_count_defİ : THM;
val Ûz_in_defİ : THM;	val Ûz_‚_defİ : THM;
val Ûz_items_defİ : THM;
=DESCRIBE
These are the definitions of the Z bag theory.
=ENDDOC
\section{PROOF CONTEXTS}
\subsection{Bags}
No appropriate material to use.
\subsection{The Z Library}
=DOC
(* Proof Context: Ûz_libraryİ *)
=DESCRIBE
A mild complete proof context for handling the manipulation of Z language and library expressions and predicates.
Its contents are chosen to be ``uncontroversial''.
That is, any effect is considered to be ``almost always the correct thing''.

It consists of the merge of the proof contexts:
=GFT
"z_sets_alg", - simplification of set contructs, and Z language
"'z_rel_alg", - simplification of relational contructs
"'z_fun_alg", - simplification of function contructs
"'z_numbers" - simplification of numeric contructs
=TEX
\paragraph{Usage Notes}
It requires theory $z\-\_bags$.

It is not intended to be mixed with HOL proof contexts
or ``z$\_$library$\_$ext'', which offers an aggressive
approach.
=ENDDOC
=DOC
(* Proof Context: Ûz_library_extİ *)
=DESCRIBE
A agressive complete proof context for handling the manipulation of Z language and library expressions and predicates.
Its purpose is to strip or rewrite its input into the
Z predicate calculus.

It consists of the merge of the proof contexts:
=GFT
"z_fun_ext", - extensional reasoning about functions (and
	realtions and sets)
"'z_numbers" - simplification of numeric contructs
=TEX
\paragraph{Usage Notes}
It requires theory $z\-\_bags$.

It is not intended to be mixed with HOL proof contexts
or ``z$\_$library$\_$ext'', which offers an aggressive
approach.
=ENDDOC
Including the algebraic material in the above may not be
particularly helpful, though it seems unlikely to cause any harm.

What do the above proof contexts do?

The following function can be executed a Z system, to
derived the text that follows. It is intended as a summary of effects.
=DUMP z_library_summary.sml
local 
	val cnv1 = pc_rule1 "z_library" rewrite_conv [];
	val cnv2 = pc_rule1 "z_library_ext" rewrite_conv [];
	val cnv3 = pc_rule "z_library" strip_asm_conv;
	val cnv4 = pc_rule "z_library_ext" strip_asm_conv;
	fun cnv_result label isbool cnv tm = (
		if isbool andalso (not (type_of tm =: BOOL))
		then ("    " ^ label ^ ":   N/A")
		else  let val res = (snd(dest_eq(concl(cnv tm))))
			handle (Fail _) => tm;
		in
		if res =$ tm
		then ("   " ^ label ^ ":   N/C")
		else
		("    " ^ label ^ ": " ^ string_of_term res)
		end
	);
	
in
fun Ûlibrary_pc_summaryİ ((title, term) :: rest) = (
	diag_line (title ^ ": " ^ string_of_term term);
	diag_line (cnv_result "z_library rewrite" false cnv1 term);
	diag_line (cnv_result "z_library_ext rewrite" false cnv2 term);
	diag_line (cnv_result "z_library strip" true cnv3 term);
	diag_line (cnv_result "z_library_ext strip" true cnv4 term);
 	library_pc_summary rest
) | library_pc_summary [] = (
	diag_line ("*** Z System Version " ^ z_system_version ^ " *** ")
);
end;
=TEX
The input data is:
=DUMPMORE z_library_summary.sml
val library_pc_summary_data1 = fn () => [
("Tuple Display Eqn", ñ(1,2,3) = (a,b,c)®),
("Tuple Display Eqn 2", ñ(1,2,3) = tuple®),
("Tuple Eqn", ñ(tuple1º (X ¸ Y)) = tuple2®),
("Tuple Maplet Eqn 1", ñ(x í y) = tuple2®),
("Tuple Maplet Eqn 2", ñ(x í y) = (1,2)®),
("Tuple of Selections",ñ((tuple1º ( X ¸ Y)).1, tuple1.2)®),
("Binding Display Eqn", ñ(x ¦ 1, y ¦ 2) = (x ¦ a, y ¦ b)®),
("Binding Display Eqn 2", ñbinding = (x ¦ 2, y ¦ 3)®),
("Binding Eqn", ñ(binding1 º [x,y:X]) = binding2®),
("Binding Ê Eqn 1", ñ(Ê [x,y:X]) = binding2®),
("Binding Ê Eqn 2", ñ(Ê [x,y:X]) = Ê ([x,y:X])'®),
("Binding of Selections",ñ(x ¦ (binding1 º [x,y:X]).x, y ¦ binding1.y)®),
("Set Display Eqn",ñ{1,2} = {a,b}®),
("Set Abstraction Eqn",ñ{x:X | x = 1} = {y:X | y > 0}®),
("Set Eqn",ñ(aº ğ X) = b®),
("Set Display",ñ{1,2,3}®),
(" Set Display",ñ p  {1,2,3}®),
("Set Abstraction",ñ{x :X | p x · (x,x)}®),
("Simp Set Abstraction",ñ{x:X | false · x = 1}®),
(" Set Abstraction",ñf x  {x:X | p x · x = 1}®),
("Empty Set",ñ{}®),
(" Empty Set",ñr  {}®),
("U",ñU®),
(" U",ñx  U®),
("U set",ñ{x:U; y,z:U | true}®),
("¬ U set",ñx  {x:U; y,z:U | true}®),
("U schema",ñ[x:U; y,z:U | true]®),
(" U schema",ñx  [x:U; y,z:U | true]®),
("Paragraph marker",¬Z'AbbDef (µ X · ñsomething = false®)®),
(" ğ ",ñx  ğ y®),
("Set Display  ğ ",ñ{1,2}  ğ y®),
("Set Display of variables  ğ ",ñ{a,b}  ğ y®),
("ğ U",ñğ U®),
(" ğ U",ñx  ğ U®)
];
=TEX
=DUMPMORE z_library_summary.sml
val library_pc_summary_data2 =fn () =>  [
("Tuple Display  Product",ñ(1,2)  X ¸ Y®),
("Tuple  Product",ñx  X ¸ Y®),
("U ¸ U",ñU ¸ U ¸ U®),
(" U ¸ U",ñx  U ¸ U ¸ U®),
("Â reduction - no asms 1",ñ(Ì x :U· f x) y®),
("Â reduction - no asms 2",ñ(Ì x:U · (x = y)) y®),
("Â reduction 1",ñ(Ì x :X· f x) y®),
("Â reduction 2",ñ(Ì x :X · (y = x)) y®),
(" Ì",ñx  (Ì x :X· f x)®),
("Í", ñ(Í x:X | p x · q x)®),
(" Í", ñv  (Í x:X | p x · q x)®),
("Application",ñf x®),
(" Application",ñp  f x®),
("Selection from Tuple Display 1",ñ(1,2,3).2®),
("Selection from Tuple Display 2",ñ(1,true,3).2®),
("Selection from Tuple Display 3",ñx  (1,f 2,3).2®),
("Selection from Binding Display 1",ñ(x ¦ 1, y ¦ 2).y®),
("Selection from Tuple Display 2",ñ(x ¦ 1, y ¦ true).y®),
("Selection from Tuple Display 3",ñx  (x ¦ 1, y ¦ f y).y®),
("Selection from Ê 1",ñ(Ê [a,b:X]).a®),
("Selection from Ê 2",ñ(Ê [a,b:X| ³ a]).a®),
("Selection from Ê 3",ñx  (Ê [a,b:X]).a®),
("Ill-formed Schema as predicate",¬$"Z'SchemaPred" ñ(x¦x',y¦y) ®ñ[x:X;y:Y]®®),
("Ill-formed Ê",¬$"Z'Ê" ñ(x¦x',y¦y) ®ñ[x:X;y:Y]®®),
("",ñx  f®),
("Variable",ñf®),
("Sequence Display",ñ§1,2¢®),
(" Sequence Display",ñx  §1,2¢®),
("Bag Display",ñû 1,2,1 ı®),
(" Bag Display",ñx  û 1,2,1 ı®),
("Function Eqn",ñ(Ì x:X · x +1) = y®),
("Variable Eqn",ñx = y®)
];
=TEX
=DUMPMORE z_library_summary.sml
val library_pc_summary_data3 = fn () => [
("³",ñ³ f x®),
("Simp ³",ñ³ false®),
("±",ña ± b®),
("Simp ±",ñtrue ± b®),
("²",ña ² b®),
("Simp ²",ñtrue ² b®),
("´",ña ´ b®),
("Simp ´",ñtrue ´ b®),
("¤",ña ¤ b®),
("Simp ¤",ñtrue ¤ b®),
("µ",ñµ x:X | p x · q x®),
("Simp µ",ñµ x:X | false · q x®),
("¶",ñ¶ x:X | p x · q x®),
("Simp ¶",ñ¶ x:X | false · q x®),
("¶‰1",ñ¶‰1 x:X | p x · q x®),
("Simp ¶‰1",ñ¶‰1 x:X | false · q x®),
("Binding  Schema 1",ñ(x ¦ x,y ¦ y)  (S º ğ [x:X;y:Y| f x y])®),
("Binding  Schema 2",ñ(x ¦ x',y ¦ y)  (S º ğ [x:X;y:Y| f x y])®),
("Schema",ñ([x:X;y:Y| f x y] º U)®),
("Schema as predicate",ñ [x:X;y:Y| f x y]®),
("³‰s", ñ((³ [x:X;y:Y| f x y]) º U)®),
(" ³‰s", ñp  (³ [x:X;y:Y| f x y])®),
("³‰s as predicate", ñ(³ [x:X;y:Y| f x y])®),
("±‰s", ñ(([y:Y; z:Z| g y z] ± [x:X;y:Y| f x y]) º U)®),
(" ±‰s", ñp  (([y:Y; z:Z| g y z] ± [x:X;y:Y| f x y]) º U)®),
("±‰s as predicate", ñ (([y:Y; z:Z| g y z] ± [x:X;y:Y| f x y]) º U)®),
("²‰s", ñ(([y:Y; z:Z| g y z] ² [x:X;y:Y| f x y]) º U)®),
(" ²‰s", ñp  (([y:Y; z:Z| g y z] ² [x:X;y:Y| f x y]) º U)®),
("²‰s as predicate", ñ (([y:Y; z:Z| g y z] ² [x:X;y:Y| f x y]) º U)®)
];
=TEX
=DUMPMORE z_library_summary.sml
val library_pc_summary_data4 = fn () => [
("´‰s", ñ(([y:Y; z:Z| g y z] ´ [x:X;y:Y| f x y]) º U)®),
(" ´‰s", ñp  (([y:Y; z:Z| g y z] ´ [x:X;y:Y| f x y]) º U)®),
("´‰s as predicate", ñ (([y:Y; z:Z| g y z] ´ [x:X;y:Y| f x y]) º U)®),
("¤‰s", ñ(([y:Y; z:Z| g y z] ¤ [x:X;y:Y| f x y]) º U)®),
(" ¤‰s", ñp  (([y:Y; z:Z| g y z] ¤ [x:X;y:Y| f x y]) º U)®),
("¤‰s as predicate", ñ (([y:Y; z:Z| g y z] ¤ [x:X;y:Y| f x y]) º U)®),
("ù‰s", ñ([y:Y; z:Z| g y z] ù‰s [x:X;y:Y| f x y] º U)®),
(" ù‰s", ñp  ([y:Y; z:Z| g y z] ù‰s [x:X;y:Y| f x y] º U)®),
("ù‰s as predicate", ñ ([y:Y; z:Z| g y z] ù‰s [x:X;y:Y| f x y] º U)®),
("µ‰s",ñ((µ x:X | p x · [x,y,z:X | f x y z])ºU)®),
(" µ‰s",ñq  ((µ x:X | p x · [x,y,z:X | f x y z])ºU)®),
("µ‰s as predicate",ñ ((µ x:X | p x · [x,y,z:X | f x y z])ºU)®),
("¶‰s",ñ((¶ x:X | p x · [x,y,z:X | f x y z])ºU)®),
(" ¶‰s",ñq  ((¶ x:X | p x · [x,y,z:X | f x y z])ºU)®),
("¶‰s as predicate",ñ ((¶ x:X | p x · [x,y,z:X | f x y z])ºU)®),
("¶‰1‰s",ñ((¶‰1 x:X | p x · [x,y,z:X | f x y z])ºU)®),
(" ¶‰1‰s",ñq  ((¶‰1 x:X | p x · [x,y,z:X | f x y z])ºU)®),
("¶‰1‰s as predicate",ñ ((¶‰1 x:X | p x · [x,y,z:X | f x y z])ºU)®),
("pre‰s",ñpre [x,x',y,z:X | f x y z]®),
(" pre‰s",ñp  (pre [x,x',y,z:X | f x y z])®),
("pre‰s as predicate",ñ( pre [x,x',y,z:X | f x y z])®),
("„‰s",ñ„ [x,y,z:X | f x y z]®),
(" „‰s",ñp  („ [x,y,z:X | f x y z])®),
("„‰s as predicate",ñ( „ [x,y,z:X | f x y z])®),
("˜‰s",ñ˜ [x,y,z:X | f x y z]®),
(" ˜‰s",ñp  (˜ [x,y,z:X | f x y z])®),
("˜‰s as predicate",ñ( ˜ [x,y,z:X | f x y z])®)
];
=TEX
=DUMPMORE z_library_summary.sml
val library_pc_summary_data5 = fn () => [
("\\‰s",ñ[x,y,z :X | f x y z] \‰s (y)®),
(" \\‰s",ñp  ([x,y,z :X| f x y z] \‰s (y))®),
("\\‰s as predicate",ñ ([x,y,z :X | f x y z] \‰s (y))®),
("»‰s",ñ[x,x',y:X | f x x' y] »‰s [x,y,z:X | g x y z]®),
(" »‰s",ñp  ([x,x',y:X | f x x' y] »‰s [x,y,z:X | g x y z])®),
("»‰s as predicate",ñ( [x,x',y:X | f x x' y] »‰s [x,y,z:X | g x y z])®),
("½",ñs ½ t®),
("",ñx  y®),
("š",ñš®),
(" š",ñp  š®),
("€", ñs € t®),
("Simp €", ñ{} € t®),
("Set Display €", ñ{1,2} € t®),
(" ", ñs   t®),
("Simp  ", ñt   {}®),
("Set Display  ", ñ{1,2}   t®),
("ğ‰1",ñğ‰1 s®),
("Simp ğ‰1",ñğ‰1 {}®),
(" ğ‰1",ñt  ğ‰1 s®),
("¡", ñs ¡ t®),
("Simp ¡", ñ{} ¡ t®),
(" ¡", ñx  s ¡ t®),
("À", ñs À t®),
("Simp À", ñ{} À t®),
(" À", ñx  s À t®),
("\\", ñs \ t®),
("Simp \\", ñ{} \ t®),
(" \\", ñx  s \ t®),
("¥",ñ¥ s®),
("Simp ¥",ñ¥ {}®),
(" ¥",ñx  ¥ s®),
("Ş",ñŞ s®),
("Simp Ş",ñŞ {}®),
(" Ş",ñx  Ş s®)
];
=TEX
=DUMPMORE z_library_summary.sml
val library_pc_summary_data6 = fn () => [
("first",ñfirst x®),
(" first",ñp  first x®),
("second",ñsecond x®),
(" second",ñp  second x®),
("í",ñ(a í b).1®),
("ª", ñX ª Y®),
("Simp ª", ñ{} ª Y®),
(" ª", ñx  X ª Y®),
("Simp  ª", ñx  {} ª Y®),
("Domain", ñdom x®),
("Simp Domain", ñdom {}®),
(" Domain", ñp  dom x®),
("Simp  Domain", ñp  dom {}®),
("Range", ñran x®),
("Simp Range", ñran {}®),
(" Range", ñp  ran x®),
("Simp  Range", ñp  ran {}®),
("Identity",ñid x®),
("Simp Identity",ñid {}®),
(" Identity",ñp  id x®),
("Simp  Identity",ñp  id {}®),
("Sequential Composition",ñf » g®),
(" Sequential Composition",ñ x  (f » g)®),
("Sequential Composition 1",ñf o g®),
(" Sequential Composition 1 ",ñ x  (f o g)®),
("Domain restriction",ñx ò y®),
("Simp Domain restriction",ñ{} ò y®),
(" Domain restriction",ñp  x ò y®),
("Simp  Domain restriction",ñp  {} ò y®),
("Range restriction",ñx ’ y®),
("Simp Range restriction",ñ{} ’ y®),
(" Range restriction",ñp  x ’ y®),
("Simp  Range restriction",ñp  {} ’ y®),
("Domain antirestriction",ñx á y®),
("Simp Domain antirestriction",ñ{} á y®),
(" Domain antirestriction",ñp  x á y®),
("Simp  Domain antirestriction",ñp  {} á y®),
("Range antirestriction",ñx  y®),
("Simp Range antirestriction",ñ{}  y®),
(" Range antirestriction",ñp  x  y®),
("Simp  Range antirestriction",ñp  {}  y®)
];
=TEX
=DUMPMORE z_library_summary.sml
val library_pc_summary_data7 = fn () => [
("Relational Image", ñs ¨t©®),
("Simp Relational Image", ñ{} ¨t©®),
(" Relational Image", ñx  s ¨t©®),
("Simp  Relational Image", ñx  {} ¨t©®),
("Transitive Closure",ñx ç+ê®),
("Simp Transitive Closure",ñ{} ç+ê®),
(" Transitive Closure",ñp  x ç+ê®),
("Simp  Transitive Closure",ñp  {} ç+ê®),
("Transitive-Reflexive Closure",ñx ç*ê®),
("Simp Transitive-Reflexive Closure",ñ{} ç*ê®),
(" Transitive-Reflexive Closure",ñp  x ç*ê®),
("Simp  Transitive-Reflexive Closure",ñp  {} ç*ê®),
("Override",ñf « g®),
(" Override",ñx  f « g®),
("Partial Functions",ñx ß y®),
("Simp Partial Functions",ñ{} ß y®),
(" Partial Functions",ñp  x ß y®),
(" Simp Partial Functions",ñp  {} ß y®),
("Injections",ñx ş y®),
("Simp Injections",ñ{} ş y®),
(" Injections",ñp  x ş y®),
(" Simp Injections",ñp  {} ş y®),
("Surjections",ñx Ï y®),
("Simp Surjections",ñ{} Ï y®),
(" Surjections",ñp  x Ï y®),
(" Simp Surjections",ñp  {} Ï y®),
("Total Injections",ñx à y®),
("Simp Total Injections",ñ{} à y®),
(" Total Injections",ñp  x à y®),
(" Simp Total Injections",ñp  {} à y®),
("Total Surjections",ñx ï y®),
("Simp Total Surjections",ñ{} ï y®),
(" Total Surjections",ñp  x ï y®),
(" Total Simp Surjections",ñp  {} ï y®),
("Bijections",ñx  y®),
("Simp Bijections",ñ{}  y®),
(" Bijections",ñp  x  y®),
(" Simp Bijections",ñp  {}  y®),
("Total Functions",ñx ­ y®),
("Simp Total Functions",ñ{} ­ y®),
(" Total Functions",ñp  x ­ y®),
(" Simp Total Functions",ñp  {} ­ y®)
];
=TEX
=DUMPMORE z_library_summary.sml
val library_pc_summary_data8 = fn () => [
("î",ñî®),
(" î",ñp  î®),
(" î 1",ñ1  î®),
("ú",ñú®),
("ú struct",ñú ¸ ú®),
(" ú",ñp  ú®),
(" ú 1",ñ1  ú®),
("Addition",ñ a + b®),
("Simp Addition",ñ a + 0®),
("Literal Addition",ñ 2 + 3®),
("Negation",ñ a - b®),
("Simp Negation",ñ a - 0®),
("Literal Negation",ñ 2 - 3®),
("Multiplication",ñ a * b®),
("Simp Multiplication",ñ a * 0®),
("Literal Multiplication",ñ 2 * 3®),
("Integer divide",ñ a div b®),
("Simp Integer divide",ñ a div 1®),
("Literal Integer divide",ñ 5 div 3®),
("Modulus",ñ a mod b®),
("Simp Modulus",ñ a mod 1®),
("Literal Modulus",ñ 2 mod 3®),
("Unit negation",ñ~ a®),
("Simp Unit negation",ñ~ 0®),
("Literal Unit negation",ñ~ 3®),
("Less",ñ a < b®),
("Simp Less",ñ a < a®),
("Literal Less",ñ 2 < 3®),
("Less or equal",ñ a ¼ b®),
("Simp Less or equal",ñ a ¼ a®),
("Literal Less or equal",ñ 2 ¼ 3®),
("Greater",ñ a > b®),
("Simp Greater",ñ a > a®),
("Literal Greater",ñ 2 > 3®),
("Greater or equal",ñ a ¾ b®),
("Simp Greater or equal",ñ a ¾ a®),
("Literal Greater or equal",ñ 2 ¾ 3®),
("Non-empty î",ñî‰1®),
(" Non-empty î",ñx  î‰1®),
("succ",ñsucc 3®),
("Iterate",ñx ç 2 ê®),
("Interval",ña .. b®),
("Simp Interval",ñ1 .. 1®),
(" Interval",ñx  a .. b®),
(" Simp Interval",ñx  1 .. 1®)
];
=TEX
Note that we do nothing for finiteness, sequence operators or bag operators.
=DUMPMORE z_library_summary.sml
library_pc_summary (library_pc_summary_data1 () @ 
	library_pc_summary_data2 () @
	library_pc_summary_data3 () @
	library_pc_summary_data4 () @
	library_pc_summary_data5 () @
	library_pc_summary_data6 () @
	library_pc_summary_data7 () @
	library_pc_summary_data8 ());
=TEX
The results of this are:
=GFT

=TEX

\section{EPILOGUE}
=SML
end (* end of Signature ZBags *);
=TEX
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX
\section{TEST POLICY}
The module tests for this module are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


=IGN
delete_const ¬$"z'_ À _"®;

 [X]œœœœœœœœœœœœœœœœ
 Ü _ ÛÀİ _ : ğ X ¸ ğ X ­ ğ X
 ÷üüüüüüüüüüüüüüüüüü
 Üµ x  : ğ X · x À x = X
 ˆüüüüüüüüüüüüüüüüüüüü

dest_Zapp ñ x À x ®;
dest_app ñ x À x ®;

