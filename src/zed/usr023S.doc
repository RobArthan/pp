# $Id: usr023S.doc,v 1.7 1994/09/06 15:35:28 rda Rel rda $
# The following ex script is intended to generate the work file
# in which students can do the exercises and the solutions file
# Lines for the solutions only begin with a comment: `(* ?X *)'
# Lines for the work file only begin with a comment: `(* ?A *)'
# `(* ?: *) stuff (* :? *)' ==> `(* ??? *)' in the work file
# `(* ?: *) stuff (* :? *)' ==> `stuff' in the work file
=SH
if	test -f usr023S.doc
then
ex usr023S.doc <<!DONE
1,/^=TEX/-1d
g/%X/d
g/?X/d
g/?:/s/?:.*:?/???/
g/?A/s/(\* *?A *\*) *//
w! zed_course_work.doc
e! usr023S.doc
1,/^=TEX/-1d
g/%X/d
g/?A/d
g/?X/s/(\* *?X *\*) *//
g/?A/s/(\* *?A *\*) *//
g/(\* *?: *\*)/s///
g/(\* *:? *\*)/s///
g/?:.*:?:/s///
w! zed_course_solutions.doc
q!
!DONE
fi >/dev/null 2>&1
=TEX
\documentstyle[TQa4,hol1,twoside]{article}
\underscoreoff\ftlinepenalty=1000
(* ?A *) \title{PROOFPOWER-Z COURSE \\ COURSEWORK FILE}
(* ?X *) \title{PROOFPOWER-Z COURSE \\ ANSWERS TO EXERCISES}
\author{ICL}
\begin{document}
\maketitle

(* ?A *) The course exercises with skeletal solutions for you to fill in are
(* ?A *) given below. Record your answers to the exercises in this file.

(* ?A *) Worked answers may be found in the file `zed_course_solutions.doc'

(* ?X *) Worked answers to the exercise in the file `zed_course_work.doc'
(* ?X *) are given below.

Use the Search and Replace Tool (from the Tools Menu) to look for the
string ``Exercises'' to find the beginning of each exercise set.

Execute the following commands before embarking on the exercises:
=SML
repeat drop_main_goal;
open_theory "z_library";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
open_theory"z_exercises_1";
=TEX

% =====================================================================

\section*{Exercises 1: The Two Tactic Method in Z}
Use the two tactic method to prove the following goals (taken
from sections 7.1.4 of usr011X.doc).
=SML
set_goal([], (* *9.01 *)
	Ò[X](≥ (µx:X∑ ∆x)) § (∂x: X∑ ≥ ∆x)Æ);
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) val thm_1_1 = pop_thm();
=SML
set_goal([], (* *10.01 *)
	Ò[X](∂x:X∑ ∆x) § ≥ (µy:X∑ ≥ ∆y)Æ);
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" (which is the same as Goal "2") *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) val thm_1_2 = save_pop_thm"thm_1_2";
=SML
set_goal([], (* *10.271 *)
	Ò[X](µx:X∑ ∆x § Ÿx) ¥ ((µy:X∑ ∆y) § (µz:X∑ Ÿz))Æ);
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒzÆ);
(* ?X *) a(z_spec_nth_asm_tac 4 ÒzÆ);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒyÆ);
(* ?X *) a(z_spec_nth_asm_tac 4 ÒyÆ);
(* ?X *) val thm_1_3 = save_pop_thm"thm_1_3";
=TEX
Many more exercises of this kind can be found in usr011X.doc
The function setlg can be used to select one of them, e.g.
=SML
setlg"*9.05" PM9;
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 2 Òx'Æ);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 Òx'Æ);
(* ?X *) (* *** Goal "3" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) val thm_1_4 = save_pop_thm"thm_1_4";
=TEX
% =====================================================================

\section*{Exercises 2: Predicate Calculus Proofs}
1. Use ¥_elim, asm_rule, and ¥_intro to give forward proofs of the
following theorems:
=SML
(* (a):	 b ¥ c, a ¥ b, a Ù c *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_1_a_1 = asm_rule Òa ¥ bÆ;
(* ?X *) val thm_2_1_a_2 = asm_rule Òê(a)Æ;
(* ?X *) val thm_2_1_a_3 = asm_rule Òb ¥ cÆ;
(* ?X *) val thm_2_1_a_4 = ¥_elim thm_2_1_a_1 thm_2_1_a_2;
(* ?X *) val thm_2_1_a = ¥_elim thm_2_1_a_3 thm_2_1_a_4;
(* ?X *) save_thm("thm_2_1_a", thm_2_1_a);
=SML
(* (b): a ¥ b ¥ c, a, b Ù c *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_1_b_1 = asm_ruleÒê(a)Æ;
(* ?X *) val thm_2_1_b_2 = asm_ruleÒê(b)Æ;
(* ?X *) val thm_2_1_b_3 = asm_ruleÒa ¥ b ¥ cÆ;
(* ?X *) val thm_2_1_b_4 = ¥_elim thm_2_1_b_3 thm_2_1_b_1;
(* ?X *) val thm_2_1_b = ¥_elim thm_2_1_b_4 thm_2_1_b_2;
(* ?X *) save_thm("thm_2_1_b", thm_2_1_b);
=SML
(* (c): a ¥ b ¥ c, b Ù a ¥ c *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_1_c_1 = asm_ruleÒê(a)Æ;
(* ?X *) val thm_2_1_c_2 = asm_ruleÒê(b)Æ;
(* ?X *) val thm_2_1_c_3 = asm_ruleÒa ¥ b ¥ cÆ;
(* ?X *) val thm_2_1_c_4 = ¥_elim thm_2_1_c_3 thm_2_1_c_1;
(* ?X *) val thm_2_1_c_5 = ¥_elim thm_2_1_c_4 thm_2_1_c_2;
(* ?X *) val thm_2_1_c = ¥_intro Òê(a)Æ thm_2_1_c_5;
(* ?X *) save_thm("thm_2_1_c", thm_2_1_c);
=TEX
2. Use strip_tac to prove:
=SML
set_goal([],(* *3.01 *) Òp ± q § ≥(≥ p ≤ ≥ q)Æ);
(* ?: *) (* :? *)
(* ?X *) a (REPEAT strip_tac);
(* ?X *) val thm_2_2_1 = save_pop_thm"thm_2_2_1";
=SML
set_goal([], (* *3.3 *) Ò(p ± q ¥ r) ¥ (p ¥ q ¥ r)Æ);
(* ?: *) (* :? *)
(* ?X *) a (REPEAT strip_tac);
(* ?X *) val thm_2_2_2 = save_pop_thm"thm_2_2_2";
=SML
set_goal([], (* *4.11 *) Ò(p § q) § (≥ p § ≥ q)Æ);
(* ?: *) (* :? *)
(* ?X *) a (REPEAT strip_tac);
(* ?X *) val thm_2_2_3 = save_pop_thm"thm_2_2_3";
=TEX
3. Use the indicated rules and theorems to give forward proofs of
=SML
(* (a): 0 ç Ó ± true ¥ ≥ 0 + 1 = 0 
			(use z_µ_elim, z_Ó_≥_plus1_thm *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_3_a = z_µ_elim Ò0Æ z_Ó_≥_plus1_thm;
(* ?X *) save_thm("thm_2_3_a", thm_2_3_a);
=SML
(* (b): x * x ç Ó ± true ¥ ≥ x * x + 1 = 0 
			(use z_µ_elim, z_Ó_≥_plus1_thm *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_3_b = z_µ_elim Òx * xÆ z_Ó_≥_plus1_thm;
(* ?X *) save_thm("thm_2_3_b", thm_2_3_b);
=SML
(* (c): i º j ± j º k ¥ i º k 
			(use prove_rule, z_º_trans_thm *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_3_c = prove_rule[z_º_trans_thm]
(* ?X *)		Òi º j ± j º k ¥ i º kÆ;
(* ?X *) save_thm("thm_2_3_c", thm_2_3_c);
=SML
(* (d): ≥ 0 + 1 = 0
			(use prove_rule, z_Ó_≥_plus1_thm, z_0_Ó_thm *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_3_d = prove_rule[z_0_Ó_thm, z_Ó_≥_plus1_thm]
(* ?X *)		Ò≥0 + 1 = 0Æ;
(* ?X *) save_thm("thm_2_3_d", thm_2_3_d);
=TEX
4. If you want some more drill in the two tactic method, prove
further examples from section 7.1.4 of the Z Tutorial Manual.
Use the function setlg to select an example.
E.g.,
=SML
setlg "*10.281" PM10b;
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒyÆ);
(* ?X *) a(z_spec_nth_asm_tac 2 ÒyÆ);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒzÆ);
(* ?X *) a(z_spec_nth_asm_tac 2 ÒzÆ);
(* ?X *) val thm_2_4 = save_pop_thm"thm_2_4";
=TEX
5. Observe the behaviour of the proof context z_library_ext by
executing the following commands, then complete the proof:
=SML
set_pc "z_library_ext";
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
a (rewrite_tac[]);
undo 1;
(* ?X *) (*
a (pure_rewrite_tac[]);
(* ?X *) *)
a (pure_rewrite_tac[z_sets_ext_clauses]);
a (pure_rewrite_tac[z_set_dif_thm]);
a (pure_rewrite_tac[z_°_thm, z_¿_thm]);
a (pure_rewrite_tac[z_set_dif_thm]);
undo 4;
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) val thm_2_5 = save_pop_thm"thm_2_5";
=TEX
When you're done restore the proof context using the following command:
=SML
set_pc "z_library";
=TEX
6. Prove the following:
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
(* hint : try using z_plus_assoc_thm *)
(* ?: *) (* :? *)
(* ?X *) a(rewrite_tac[z_plus_assoc_thm]);
(* ?X *) val thm_2_6_a = save_pop_thm"thm_2_6_a";
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
(* hint : try using z_plus_assoc_thm1 *)
(* ?: *) (* :? *)
(* ?X *) a(rewrite_tac[z_plus_assoc_thm1]);
(* ?X *) val thm_2_6_b = save_pop_thm"thm_2_6_b";
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
(* hint : try using z_µ_elim with z_plus_assoc_thm1 *)
(* ?: *) (* :? *)
(* ?X *) a(rewrite_tac[z_µ_elimÒ(i¶y, j¶z, k¶x)Æ z_plus_assoc_thm1]);
(* ?X *) val thm_2_6_c = save_pop_thm"thm_2_6_c";
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
(* hint : try using z_µ_elim with z_plus_order_thm *)
(* ?: *) (* :? *)
(* ?X *) a(rewrite_tac[z_µ_elimÒxÆ z_plus_order_thm]);
(* ?X *) val thm_2_6_d = save_pop_thm"thm_2_6_d";
=TEX

% =====================================================================

\section*{Exercises 3: Expressions}
Before doing these exercises execute the following commands:
=SML
repeat drop_main_goal;
open_theory"z_exercises_2";
set_pc"z_library";
=TEX
1. Prove the following (hint: they can all be done automatically):
=SML
set_goal([], (* ZE1.1 *) Ò(2,4) ç (Ãx:Ó ∑ 2*x)Æ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_3_1_a = save_pop_thm"thm_3_1_a";
=SML
set_goal([], (* ZE1.2 *) Ò{1,2,3} ç  {1,2,3,4}Æ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_3_1_b = save_pop_thm"thm_3_1_b";
=SML
set_goal([], (* ZE1.3 *) ÒÓ ç  ˙Æ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_3_1_c = save_pop_thm"thm_3_1_c";
=SML
set_goal([], (* ZE1.4 *) Ò"a" ç {"a", "b"}Æ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_3_1_d = save_pop_thm"thm_3_1_d";
=SML
set_goal([], (* ZE1.11 *) ÒµFile∑ ( File').age = age'Æ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_3_1_e = save_pop_thm"thm_3_1_e";
=TEX
2. Using the proof context z_language_ext, prove the following:
=SML
set_goal([], (* ZE2.3 *) Ò[x:˙ | x > 0] = {x:˙ | x > 0 ∑ (x ¶ x)}Æ);
(* ?: *) (* :? *)
(* ?X *) a(PC_T1 "z_language_ext" prove_tac[]);
(* ?X *) val thm_3_2 = save_pop_thm"thm_3_2";
=TEX
3. Prove the following (see section 7.2.1 of the Z Tutorial Manual for hints)
=SML
set_goal([], (* ZE3.1 *) Ò(Ãx:˙∑ x + 1) 3 = 4Æ);
(* ?: *) (* :? *)
(* ?X *) a(conv_tac(MAP_C z_¬_conv));
(* ?X *) a(rewrite_tac[]);
(* ?X *) val thm_3_3_1 = save_pop_thm"thm_3_3_1";
=SML
set_goal([], (* ZE3.2 *) Ò{(1, 2), (3, 4)} 3 = 4Æ);
(* ?: *) (* :? *)
(* ?X *) a(z_app_eq_tac);
(* ?X *) a(REPEAT z_strip_tac);
(* ?X *) val thm_3_3_2 = save_pop_thm"thm_3_3_2";
=TEX
4. If you have time, do more of the exercises from section 7.2.1 of
the Z Tutorial Manual.
Use the function setlg to select a problem.
E.g.,
=SML
setlg "ZE3.3" ZE3;
(* ?: *) (* :? *)
(* ?X *) a(REPEAT z_strip_tac);
(* ?X *) a(strip_asm_tac(z_get_specÒ(abs_)Æ));
(* ?X *) a(asm_tac(prove_rule[] Ò1 ç ˙Æ));
(* ?X *) a(all_fc_tac[z_≠_ç_rel_§_app_eq_thm]);
(* ?X *) val thm_3_3_3 = save_pop_thm"thm_3_3_3";
(* ?X *)
(* ?X *) setlg "ZE3.4" ZE3;
(* ?X *) a(REPEAT z_strip_tac);
(* ?X *) a(strip_asm_tac(z_get_specÒ(abs_)Æ));
(* ?X *) a(asm_tac(prove_rule[] Òi ç ˙Æ));
(* ?X *) a(all_fc_tac[z_≠_ç_rel_§_app_eq_thm]);
(* ?X *) val thm_3_3_4 = save_pop_thm"thm_3_3_4";
(* ?X *)
(* ?X *) setlg "ZE3.5" ZE3;
(* ?X *) a(REPEAT z_strip_tac);
(* ?X *) a(strip_asm_tac(z_get_specÒ(abs_)Æ));
(* ?X *) a(asm_tac(prove_rule[] Òi ç ˙Æ));
(* ?X *) a(all_fc_tac[z_fun_ç_clauses]);
(* ?X *) val thm_3_3_5 = save_pop_thm"thm_3_3_5";
(* ?X *)
(* ?X *) setlg "ZE3.6" ZE3;
(* ?X *) a(strip_asm_tac(z_µ_elimÒ9Æ(z_Õ_ruleÒ(Õ x : ˙ | x = 3 ∑ x * x)Æ)));
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(swap_nth_asm_concl_tac 1);
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 Ò3Æ);
(* ?X *) a(swap_nth_asm_concl_tac 1);
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) val thm_3_3_6 = save_pop_thm"thm_3_3_6";
(* ?X *)
(* ?X *) setlg "ZE3.7" ZE3;
(* ?X *) a(REPEAT z_strip_tac);
(* ?X *) a(z_∂_tacÒ5Æ);
(* ?X *) a(rewrite_tac[]);
(* ?X *) val thm_3_3_7 = save_pop_thm"thm_3_3_7";
(* ?X *)
(* ?X *) setlg "ZE3.8" ZE3;
(* ?X *) a(PC_T "z_library_ext" contr_tac);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* ?X *) (* *** Goal "3" *** *)
(* ?X *) a(swap_nth_asm_concl_tac 6);
(* ?X *) a(conv_tac(ONCE_MAP_C eq_sym_conv));
(* ?X *) a(contr_tac);
(* ?X *) a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* ?X *) (* *** Goal "4" *** *)
(* ?X *) a(swap_nth_asm_concl_tac 6);
(* ?X *) a(conv_tac(ONCE_MAP_C eq_sym_conv));
(* ?X *) a(contr_tac);
(* ?X *) a(PC_T1 "z_library_ext" all_asm_fc_tac[]);
(* ?X *) val thm_3_3_8 = save_pop_thm"thm_3_3_8";
(* ?X *)
(* ?X *) setlg "ZE3.9" ZE3;
(* ?X *) a(PC_T "z_library_ext" contr_tac);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) a(swap_nth_asm_concl_tac 1);
(* ?X *) a(lemma_tacÒ(z.1, z.2) = zÆ);
(* ?X *) (* *** Goal "1.1" *** *)
(* ?X *) a(PC_T "z_library_ext" contr_tac);
(* ?X *) (* *** Goal "1.2" *** *)
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 Ò(x, y)Æ);
(* ?X *) val thm_3_3_9 = save_pop_thm"thm_3_3_9";
(* ?X *)
(* ?X *) setlg "ZE3.10" ZE3;
(* ?X *) a(PC_T "z_library_ext" strip_tac);
(* ?X *) a(PC_T1 "z_library" prove_tac[]);
(* ?X *) a(z_∂_tacÒ(age ¶ x1, people ¶ x2)Æ);
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) val thm_3_3_10 = save_pop_thm"thm_3_3_10";
(* ?X *)
(* ?X *) setlg "ZE3.11" ZE3;
(* ?X *) a(PC_T "z_library_ext" contr_tac);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(PC_T1 "z_library_ext" (z_spec_nth_asm_tac 2) Ò(x1¶1, x2¶a)Æ);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(PC_T1 "z_library_ext" (z_spec_nth_asm_tac 2) Ò(x1¶2, x2¶b)Æ);
(* ?X *) val thm_3_3_11 = save_pop_thm"thm_3_3_11";
(* ?X *)
(* ?X *) setlg "ZE3.12" ZE3;
(* ?X *) a(PC_T "z_library_ext" strip_tac);
(* ?X *) a(PC_T1 "z_library_ext" (z_spec_nth_asm_tac 1) Ò(x1¶1, x2¶a)Æ);
(* ?X *) a(PC_T1 "z_library_ext" (z_spec_nth_asm_tac 2) Ò(x1¶2, x2¶b)Æ);
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) val thm_3_3_12 = save_pop_thm"thm_3_3_12";
=TEX

% =====================================================================

\section*{Exercises 4: Schema Calculus}

Before doing these exercises execute the following commands:

=SML
repeat drop_main_goal;
open_theory"z_exercises_2";
set_pc"z_language";
=TEX
1. Use strip_tac to prove:
=SML
set_goal([], (* *2.02 *) Ò ê((Qac ¥ (Pab ¥ Qac))∫U)Æ);
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) val thm_4_1_1 = save_pop_thm"thm_4_1_1";
=SML
set_goal([], (* *3.01 *) Ò ê((Pab ± Qac § ≥(≥ Pab ≤ ≥ Qac))∫U)Æ);
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) val thm_4_1_2 = save_pop_thm"thm_4_1_2";
=TEX
2. Set the proof context to z_library and use contradiction
and forward chaining from the assumptions to prove:
=SML
set_pc"z_library";
set_goal([], (* *9.01 *) Òê(((≥ (µQac∑ Sabc)) § (∂Qac∑ ≥ Sabc))∫U)Æ);
(* ?X *) a(contr_tac);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) val thm_4_2_1 = save_pop_thm"thm_4_2_1";
=TEX
Is you have time, try further examples from sections 7.2.2 or 7.2.3
using setlg.
E.g.,
=SML
setlg "*10.01" SCPM10;
(* ?: *) (* :? *)
(* ?X *) a(contr_tac);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) val thm_4_2_2 = save_pop_thm"thm_4_2_2";
=TEX

% =====================================================================

\section*{Exercises 5: Paragraphs}

Before doing these exercises execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
1.1 Use a fun fixity paragraph and a generic axiomatic description to
define a conditional construct, if a then b else c.
πZ
‹ fun (* ?: *) if _ then _ else _ (* :? *)
∞
ù[X]úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
‹	(* ?: *) if _ then _ else _ : BOOL ∏ X ∏ X ≠ X (* :? *)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(* ?: *)µx, y: X∑ (* :? *)
‹(* ?X *)		if true then x else y = x
‹(* ?X *)	±	if false then x else y = y
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
1.2 Use z_get_spec to examine the defining property for your
conditional construct. Prove:
=SML
z_get_specÒ(if _ then _ else _)Æ;
set_goal([], Òif 2 > 1 then 1 else 0 = 1Æ);
(* ?: *) (* :? *)
(* ?X *) a(rewrite_tac[]);
(* ?X *) a(rewrite_tac[z_gen_pred_elim[ÒUÆ] (z_get_specÒ(if _ then _ else _)Æ)]);
(* ?X *) val thm_5_1 = save_pop_thm"thm_5_1";
=TEX
2.1 First of all set the system up to work conservatively:
=SML
set_flags [("z_use_axioms", false)];
=TEX
Now use an axiomatic description to define a global variable, num,
whose value is a natural number loosely specified to lie between 4 and 50:
πZAX
‹	(* ?: *) num : Ó (* :? *)
˜¸¸¸¸¸¸
‹	(* ?: *) 4 º num º 50 (* :? *)
∞
2.2 Prove the consistency result for num and save it:
=SML
z_push_consistency_goal ÒnumÆ;
(* ?: *) (* :? *)
(* ?X *) a(z_∂_tacÒ10Æ);
(* ?X *) a(rewrite_tac[]);
save_consistency_thm ÒnumÆ (pop_thm());
=TEX
2.3 Examine the specification of num and use it to prove that
num is non-negative:
=SML
z_get_specÒnumÆ;
set_goal([], Ònum æ 0Æ);
(* ?: *) (* :? *)
(* ?X *) a(strip_tac);
(* ?X *) a(strip_asm_tac(z_get_specÒnumÆ));
(* ?X *) val thm_5_2 = save_pop_thm"thm_5_2";
=TEX
3. Prove the following conjectures about the opperation schemas OP and OP2
defined in section 7.3.3 of the Z Tutorial Manual:
=SML
set_goal([], Òpre OP § i? æ 0Æ);
(* ?: *) (* :? *)
(* ?X *) a(rewrite_tac(map z_get_spec[ÒOPÆ, ÒSTATEÆ]));
(* ?X *) a(REPEAT strip_tac);
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_5_3_1 = save_pop_thm"thm_5_3_1";
set_goal([], Ò(pre OP ¥ pre OP2) ± (pre OP ± OP2 ¥ OP)Æ);
(* ?: *) (* :? *)
(* ?: *) a(rewrite_tac(map z_get_spec[ÒOPÆ, ÒOP2Æ, ÒSTATEÆ]));
(* ?: *) a(REPEAT strip_tac);
(* ?: *) a(asm_prove_tac[]);
(* ?X *) val thm_5_3_2 = save_pop_thm"thm_5_3_2";
=TEX

% =====================================================================

\section*{Exercises 6: The Z Toolkit}

1. Sets: before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_sets_ext";
=TEX
Prove the following samples from section 7.4.1 of the Z Tutorial Manual:
=SML
set_goal([], (* Z1.9 *) Ò (a ° b) ¿ (a \ b) = aÆ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_6_1_1 = save_pop_thm"thm_6_1_1";
=SML
set_goal([], (* Z3.1 *) Ò a Ä b § a ç  bÆ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_6_1_2 = save_pop_thm"thm_6_1_2";
=TEX
Try further examples ad lib using setlg:
=SML
setlg "Z3b.1" Z3b;
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_6_1_3 = save_pop_thm"thm_6_1_3";
=TEX

2. Relations: before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_rel_ext";
=TEX
Prove the following samples from section 7.4.2 of the Z Tutorial Manual:
=SML
set_goal([], (* Z4.9 *) Òdom {} = {}Æ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_6_2_1 = save_pop_thm"thm_6_2_1";
=SML
set_goal([], (* Z5.2 *) ÒP ª (Q ª R) = (P ª Q) ª RÆ);
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_6_2_2 = save_pop_thm"thm_6_2_2";
=TEX
Try further examples ad lib using setlg:
=SML
setlg "Z7.1" Z7;
(* ?: *) (* :? *)
(* ?X *) a(prove_tac[]);
(* ?X *) val thm_6_2_3 = save_pop_thm"thm_6_2_3";
=TEX


3. Functions: before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_fun_ext";
=TEX
Prove the following samples from section 7.4.3 of the Z Tutorial Manual:
=SML
set_goal([], (* Z12.1 *) Ò f ç X ﬂ Y ± (x, y) ç f ¥ f x = y Æ);
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) a(z_app_eq_tac);
(* ?X *) a(REPEAT strip_tac);
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) val thm_6_3_1 = save_pop_thm"thm_6_3_1";
=SML
set_goal([], (* Z12.2 *) Ò f ç X ˛ Y ± (x, y) ç f ¥ f x = y Æ);
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) a(z_app_eq_tac);
(* ?X *) a(REPEAT strip_tac);
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) val thm_6_3_2 = save_pop_thm"thm_6_3_2";
=TEX
The other Z12 proofs are very similar.
The Z12b proofs are rather long; you are not recommended to try them
during the course.

4. Numbers and Finiteness: before doing this exercise execute the
following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_library";
set_flags[("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
4.1 Give an inductive definition of the function ì which maps a natural
number n to the sum of the first n natural numbers:
πZAX
‹	ì : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(* ?: *) ì 0 = 0; (* :? *)
‹(* ?X *)	µn: Ó∑ì (n + 1) = ì n + n + 1
∞
4.2 Prove the following:
=SML
set_goal([], Òµn:Ó∑ ì n * 2 = n * (n + 1)Æ);
(* ?: *) (* :? *)
(* ?X *) a(z_strip_tac);
(* ?X *) a(PC_T1 "z_language" rewrite_tac[]);
(* ?X *) a(z_Ó_induction_tac);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(rewrite_tac[z_get_specÒìÆ]);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(strip_asm_tac (z_get_specÒìÆ));
(* ?X *) a(all_asm_fc_tac[]);
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) a(rewrite_tac[z_times_plus_distrib_thm]);
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) a(rewrite_tac[z_times_plus_distrib_thm, z_plus_assoc_thm]);
(* ?X *) a(pure_once_rewrite_tac[prove_rule[]Ò2 = 1 + 1Æ]);
(* ?X *) a(rewrite_tac[z_times_plus_distrib_thm, z_plus_assoc_thm]);
(* ?X *) a(rewrite_tac[z_µ_elimÒiÆ z_plus_order_thm]);
(* ?X *) val thm_6_4_1 = save_pop_thm"thm_6_4_1";
=TEX
You may also like to try the other two proofs in section 7.4.4 of
the Z Tutorial Manual.
It is best to user the proof context z_library_ext for these
(this has rewriting with the definition of (_.._) built into it).
=SML
set_pc"z_library_ext";
setlg "ZNum.2" ZNum;
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) a(all_fc_tac[z_º_trans_thm]);
(* ?X *) val thm_6_4_2 = save_pop_thm"thm_6_4_2";
=SML
setlg "ZNum.3" ZNum;
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) a(all_fc_tac[z_º_less_trans_thm]);
(* ?X *) a(swap_asm_concl_tac Òx1 < xÆ);
(* ?X *) a(pure_once_rewrite_tac[z_get_specÒ(_<_)Æ]);
(* ?X *) a(swap_asm_concl_tac Òx - 1 < x1Æ);
(* ?X *) a(pure_once_rewrite_tac[z_get_specÒ(_<_)Æ]);
(* ?X *) a(rewrite_tac[]);
(* ?X *) a(rewrite_tac[z_plus_assoc_thm]);
(* ?X *) a(contr_tac);
(* ?X *) a(all_fc_tac[z_º_trans_thm]);
(* ?X *) val thm_6_4_3 = save_pop_thm"thm_6_4_3";
=TEX

% =====================================================================

\section*{Exercises 7: Case Study 1}
Consult the course overheads for hints for these exercises.

Execute the following commands to open the theory containing
the specifications etc. before embarking on these exercises.
=SML
open_theory"usr023V";
set_pc "z_library_ext";
val [	price, VMSTATE, VM_operation,
	exact_cash, insufficient_cash, some_stock,
	VM_sale, VM_nosale, VM1, VM2, VM3 ]
    = map z_get_spec [ ÒpriceÆ, ÒVMSTATEÆ, ÒVM_operationÆ,
	Òexact_cashÆ, Òinsufficient_cashÆ, Òsome_stockÆ,
	ÒVM_saleÆ, ÒVM_nosaleÆ, ÒVM1Æ, ÒVM2Æ, ÒVM3Æ ];
=TEX
1. Prove that the schema VM3 is non-empty, i.e., prove:
=SML
set_goal([], Ò∂ VM3 ∑ trueÆ);
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) a(z_spec_asm_tac Òµ VM3 ∑ falseÆ
(* ?X *) 	Ò(	cash_tendered? ¶ price,
(* ?X *) 		stock ¶ 1, stock' ¶ 0,
(* ?X *) 		takings ¶ 0, takings' ¶ price,
(* ?X *) 		cash_refunded! ¶ 0,
(* ?X *) 		bars_delivered! ¶ 1)Æ);
(* ?X *) a(swap_asm_concl_tac
(* ?X *)  Ò≥ (bars_delivered! ¶ 1, cash_refunded! ¶ 0, cash_tendered? ¶ price,
(* ?X *)          stock ¶ 1, stock' ¶ 0, takings ¶ 0, takings' ¶ price)
(* ?X *)           ç VM3Æ);
(* ?X *) a(rewrite_tac[VM1, VM3,
(* ?X *) 	exact_cash, 
(* ?X *) 	some_stock, VM_sale, VM_operation, VMSTATE]);
(* ?X *) a(strip_asm_tac price);
(* ?X *) a(asm_rewrite_tac[]);
(* ?X *) val VM3_non_empty = save_pop_thm "VM3_non_empty";
=TEX
2. Prove the following lemma for use in the refinement proof.
=SML
set_goal([], Ò≥ (insufficient_cash ± exact_cash)Æ);
(* ?: *) (* :? *)
(* ?X *) a (rewrite_tac [insufficient_cash, exact_cash]);
(* ?X *) a (pure_rewrite_tac [z_get_spec Ò(_<_)Æ]);
(* ?X *) a (rewrite_tac [z_plus_assoc_thm1]);
(* ?X *) a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
(* ?X *) a (REPEAT_N 3 z_strip_tac);
(* ?X *) a (asm_rewrite_tac[]);
(* ?X *) val cash_lemma = save_pop_thm "cash_lemma";
=TEX
3. Prove that VM3 is a refinement of VM1, i.e. prove:
=SML
set_goal([], Ò (pre VM1 ¥ pre VM3) ± (pre VM1 ± VM3 ¥ VM1)Æ);
(* ?: *) (* :? *)
(* ?X *) a (rewrite_tac [VM1, VM2, VM3]);
(* ?X *) a (strip_asm_tac cash_lemma THEN asm_rewrite_tac[]);
(* ?X *) a (REPEAT z_strip_tac);
(* ?X *) val VM3_refines_VM1 = save_pop_thm "VM3_refines_VM1";
=TEX

% =====================================================================

\section*{Exercises 8: Case Study 2}
Consult the course overheads for hints for these exercises.

If you have not already done so for exercises 7,
execute the following commands to open the theory containing
the specifications etc. before embarking on these exercises.
=SML
open_theory"usr023V";
set_pc "z_library_ext";
val [	price, VMSTATE, VM_operation,
	exact_cash, insufficient_cash, some_stock,
	VM_sale, VM_nosale, VM1, VM2, VM3 ]
    = map z_get_spec [ ÒpriceÆ, ÒVMSTATEÆ, ÒVM_operationÆ,
	Òexact_cashÆ, Òinsufficient_cashÆ, Òsome_stockÆ,
	ÒVM_saleÆ, ÒVM_nosaleÆ, ÒVM1Æ, ÒVM2Æ, ÒVM3Æ ];
=TEX
Use z_defn_simp_rule to convert the definition of VM_ok into
an unconditional rewrite_rule:
=SML
(* ?: *) val VM_ok = z_defn_simp_rule (z_get_spec ÒVM_okÆ); (* :? *)
=TEX
Using the converted definition, prove that vending machine VM3 is
a member of VM_ok:
=SML
set_goal([], ÒVM3 ç VM_okÆ);
(* ?: *) (* :? *)
(* ?X *) a (rewrite_tac [VM1,VM2,VM3,VM_ok,VM_sale,VM_nosale,
		VM_operation,VMSTATE]);
(* ?X *) a(REPEAT z_strip_tac THEN asm_rewrite_tac[]);
(* ?X *) a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
(* ?X *) a (rewrite_tac [z_µ_elim Ò~ takingsÆ z_plus_order_thm]);
(* ?X *) a (rewrite_tac [z_plus_assoc_thm1]);
(* ?X *) val VM3_ok_thm = save_pop_thm "VM3_ok_thm";

=TEX
\end{document}
