=IGN
# The following ex script is intended to generate the work file
# in which students can do the exercises and the solutions file
# Lines for the solutions only begin with a comment: `(* ?X *)'
# Lines for the work file only begin with a comment: `(* ?A *)'
# `(* ?: *) stuff (* :? *)' ==> `(* ??? *)' in the work file
# `(* ?: *) stuff (* :? *)' ==> `stuff' in the work file
ex usr023S.doc
1,/^q!/d
g/%X/d
g/?X/d
g/?:/s/?:.*:?/???/
g/?A/s/(\* *?A *\*) *//
w! zed_course_answers.doc
e! usr023S.doc
1,/^q!/d
g/%X/d
g/?A/d
g/?X/s/(\* *?X *\*) *//
g/(\* *?: *\*)/s///
g/(\* *:? *\*)/s///
g/?:.*:?:/s///
w! zed_course_solutions.doc
q!
=TEX
\documentstyle[TQa4,hol1]{article}
\underscoreoff
\title{PROOFPOWER-Z COURSE EXERCISE FILE}
\author{ICL}
\begin{document}
\maketitle

The course exercises with skeletal solutions for you to fill in are
given below. Record your answers to the exercises in this file.

Hints and worked answers may be found in the file `usr023_slides.doc'

Use the Search and Replace Tool (from the Tools Menu) to look for the
string ``Exercises'' to find the beginning of each exercise set in this
file or in `usr023_slides.doc'.

Execute the following commands before embarking on the exercises:
=SML
repeat drop_main_goal;
open_theory "z_library";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
open_theory"z_exercises_1";
=TEX

% =====================================================================

\section*{Exercises 1: The Two Tactic Method in Z}
Use the two tactic method to prove the following goals (taken
from sections 7.1.4 of usr011X.doc).
=SML
set_goal([], (* *9.01 *)
	Ò[X](≥ (µx:X∑ ∆x)) § (∂x: X∑ ≥ ∆x)Æ);
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) val thm_1_1 = pop_thm();
=SML
set_goal([], (* *10.01 *)
	Ò[X](∂x:X∑ ∆x) § ≥ (µy:X∑ ≥ ∆y)Æ);
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" (which is the same as Goal "2") *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) val thm_1_2 = save_pop_thm"thm_1_2";
=SML
set_goal([], (* *10.271 *)
	Ò[X](µx:X∑ ∆x § Ÿx) ¥ ((µy:X∑ ∆y) § (µz:X∑ Ÿz))Æ);
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒzÆ);
(* ?X *) a(z_spec_nth_asm_tac 4 ÒzÆ);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒyÆ);
(* ?X *) a(z_spec_nth_asm_tac 4 ÒyÆ);
(* ?X *) val thm_1_3 = save_pop_thm"thm_1_3";
=TEX
Many more exercises of this kind can be found in usr011X.doc
The function setlg can be used to select one of them, e.g.
=SML
setlg"*9.05" PM9;
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 2 Òx'Æ);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 Òx'Æ);
(* ?X *) (* *** Goal "3" *** *)
(* ?X *) a(z_spec_nth_asm_tac 1 ÒxÆ);
(* ?X *) val thm_1_4 = save_pop_thm"thm_1_4";
=TEX
% =====================================================================

\section*{Exercises 2: Predicate Calculus Proofs}
1. Use ¥_elim, asm_rule, and ¥_intro to give forward proofs of the
following theorems:
=SML
(* (a):	 b ¥ c, a ¥ b, a Ù c *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_1_a_1 = asm_rule Òa ¥ bÆ;
(* ?X *) val thm_2_1_a_2 = asm_rule Òê(a)Æ;
(* ?X *) val thm_2_1_a_3 = asm_rule Òb ¥ cÆ;
(* ?X *) val thm_2_1_a_4 = ¥_elim thm_2_1_a_1 thm_2_1_a_2;
(* ?X *) val thm_2_1_a = ¥_elim thm_2_1_a_3 thm_2_1_a_4;
(* ?X *) save_thm("thm_2_1_a", thm_2_1_a);
=SML
(* (b): a ¥ b ¥ c, a, b Ù c *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_1_b_1 = asm_ruleÒê(a)Æ;
(* ?X *) val thm_2_1_b_2 = asm_ruleÒê(b)Æ;
(* ?X *) val thm_2_1_b_3 = asm_ruleÒa ¥ b ¥ cÆ;
(* ?X *) val thm_2_1_b_4 = ¥_elim thm_2_1_b_3 thm_2_1_b_1;
(* ?X *) val thm_2_1_b = ¥_elim thm_2_1_b_4 thm_2_1_b_2;
(* ?X *) save_thm("thm_2_1_b", thm_2_1_b);
=SML
(* (c): a ¥ b ¥ c, b Ù a ¥ c *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_1_c_1 = asm_ruleÒê(a)Æ;
(* ?X *) val thm_2_1_c_2 = asm_ruleÒê(b)Æ;
(* ?X *) val thm_2_1_c_3 = asm_ruleÒa ¥ b ¥ cÆ;
(* ?X *) val thm_2_1_c_4 = ¥_elim thm_2_1_c_3 thm_2_1_c_1;
(* ?X *) val thm_2_1_c_5 = ¥_elim thm_2_1_c_4 thm_2_1_c_2;
(* ?X *) val thm_2_1_c = ¥_intro Òê(a)Æ thm_2_1_c_5;
(* ?X *) save_thm("thm_2_1_c", thm_2_1_c);
=TEX
2. Use strip_tac to prove:
=SML
set_goal([],(* *3.01 *) Òp ± q § ≥(≥ p ≤ ≥ q)Æ);
(* ?: *) (* :? *)
(* ?X *) a (REPEAT strip_tac);
(* ?X *) val thm_2_2_1 = save_pop_thm"thm_2_2_1";
=SML
set_goal([], (* *3.3 *) Ò(p ± q ¥ r) ¥ (p ¥ q ¥ r)Æ);
(* ?: *) (* :? *)
(* ?X *) a (REPEAT strip_tac);
(* ?X *) val thm_2_2_2 = save_pop_thm"thm_2_2_2";
=SML
set_goal([], (* *4.11 *) Ò(p § q) § (≥ p § ≥ q)Æ);
(* ?: *) (* :? *)
(* ?X *) a (REPEAT strip_tac);
(* ?X *) val thm_2_2_3 = save_pop_thm"thm_2_2_3";
=TEX
3. Use the indicated rules and theorems to give forward proofs of
=SML
(* (a): 0 ç Ó ± true ¥ ≥ 0 + 1 = 0 
			(use z_µ_elim, z_Ó_≥_plus1_thm *)
(* ?: *) (* :? *)
(* ?X *) val thm_2_3_a = z_µ_elim Ò0Æ z_Ó_≥_plus1_thm;
(* ?X *) save_thm("thm_2_3_a", thm_2_3_a);
=SML
(* (b): x * x ç Ó ± true ¥ ≥ x * x + 1 = 0 
			(use z_µ_elim, z_Ó_≥_plus1_thm *)
(* ?X *) val thm_2_3_b = z_µ_elim Òx * xÆ z_Ó_≥_plus1_thm;
(* ?X *) save_thm("thm_2_3_b", thm_2_3_b);
=SML
(* (c): i º j ± j º k ¥ i º k 
			(use prove_rule, z_º_trans_thm *)
(* ?X *) val thm_2_3_c = prove_rule[z_º_trans_thm]
(* ?X *)		Òi º j ± j º k ¥ i º kÆ;
(* ?X *) save_thm("thm_2_3_c", thm_2_3_c);
=SML
(* (d): ≥ 0 + 1 = 0
			(use prove_rule, z_Ó_≥_plus1_thm, z_0_Ó_thm *)
(* ?X *) val thm_2_3_d = prove_rule[z_0_Ó_thm, z_Ó_≥_plus1_thm]
(* ?X *)		Ò≥0 + 1 = 0Æ;
(* ?X *) save_thm("thm_2_3_d", thm_2_3_d);
=TEX
4. If you want some more drill in the two tactic method, prove
further examples from section 7.1.4 of the Z Tutorial Manual.
Use the function setlg to select an example.
E.g.,
=SML
setlg "*10.281" PM10b;
(* ?: *) (* :? *)
(* ?X *) a contr_tac;
(* ?X *) (* *** Goal "1" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒyÆ);
(* ?X *) a(z_spec_nth_asm_tac 2 ÒyÆ);
(* ?X *) (* *** Goal "2" *** *)
(* ?X *) a(z_spec_nth_asm_tac 4 ÒzÆ);
(* ?X *) a(z_spec_nth_asm_tac 2 ÒzÆ);
(* ?X *) val thm_2_4 = save_pop_thm"thm_2_4";
=TEX
5. Observe the behaviour of the proof context z_library_ext by
executing the following commands, then complete the proof:
=SML
set_pc "z_library_ext";
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
a (rewrite_tac[]);
undo 1;
(* ?X *) (*
a (pure_rewrite_tac[]);
(* ?X *) *)
a (pure_rewrite_tac[z_sets_ext_clauses]);
a (pure_rewrite_tac[z_set_dif_thm]);
a (pure_rewrite_tac[z_°_thm, z_¿_thm]);
a (pure_rewrite_tac[z_set_dif_thm]);
undo 4;
(* ?: *) (* :? *)
(* ?X *) a(REPEAT strip_tac);
(* ?X *) val thm_2_5 = save_pop_thm"thm_2_5";
=TEX
When you're done restore the proof context using the following command:
=SML
set_pc "z_library";
=TEX
6. Prove the following:
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
(* hint : try using z_plus_assoc_thm *)
(* ?: *) (* :? *)
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
(* hint : try using z_plus_assoc_thm1 *)
(* ?: *) (* :? *)
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
(* hint : try using z_µ_elim with z_plus_assoc_thm1 *)
(* ?: *) (* :? *)
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
(* hint : try using z_µ_elim with z_plus_order_thm *)
=TEX

% =====================================================================

\section*{Exercises 3: Expressions}
Before doing these exercises execute the following commands:
=SML
repeat drop_main_goal;
open_theory"z_exercises_2";
set_pc"z_library";
=TEX
1. Prove the following (hint: they can all be done automatically):
=SML
set_goal([], (* ZE1.1 *) Ò(2,4) ç (Ãx:Ó ∑ 2*x)Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* ZE1.2 *) Ò{1,2,3} ç  {1,2,3,4}Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* ZE1.3 *) ÒÓ ç  ˙Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* ZE1.4 *) Ò"a" ç {"a", "b"}Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* ZE1.11 *) ÒµFile∑ ( File').age = age'Æ);
=TEX
2. Using the proof context z_language_ext, prove the following:
=SML
set_goal([], (* ZE2.3 *) Ò[x:˙ | x > 0] = {x:˙ | x > 0 ∑ (x ¶ x)}Æ);
=TEX
3. Prove the following (see section 7.2.1 of the Z Tutorial Manual for hints)
=SML
set_goal([], (* ZE3.1 *) Ò(Ãx:˙∑ x + 1) 3 = 4Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* ZE3.2 *) Ò{(1, 2), (3, 4)} 3 = 4Æ);
(* ?: *) (* :? *)
=TEX
4. If you have time, do more of the exercises from section 7.2.1 of
the Z Tutorial Manual.
Use the function setlg to select a problem.
E.g.,
=SML
setlg "ZE3.7" ZE3;
=TEX

% =====================================================================

\section*{Exercises 4: Schema Calculus}

Before doing these exercises execute the following commands:

=SML
repeat drop_main_goal;
open_theory"z_exercises_2";
set_pc"z_language";
=TEX
1. Use strip_tac to prove:
=SML
set_goal([], (* *2.02 *) Ò ê((Qac ¥ (Pab ¥ Qac))∫U)Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* *3.01 *) Ò ê((Pab ± Qac § ≥(≥ Pab ≤ ≥ Qac))∫U)Æ);
(* ?: *) (* :? *)
=TEX
2. Set the proof context to z_library and use contradiction
and forward chaining from the assumptions to prove:
=SML
set_pc"z_library";
set_goal([], (* *9.01 *) Òê(((≥ (µQac∑ Sabc)) § (∂Qac∑ ≥ Sabc))∫U)Æ);
=TEX
Is you have time, try further examples from sections 7.2.2 or 7.2.3
using setlg.
E.g.,
=SML
setlg "*10.01" SCPM10;
(* ?: *) (* :? *)
=TEX

% =====================================================================

\section*{Exercises 5: Paragraphs}

Before doing these exercises execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
1.1 Use a fun fixity paragraph and an axiomatic description to
define a conditional construct, if a then b else c.
πZ
‹ fun ???
∞
πZAX
‹ ???
˜¸¸¸¸¸¸
‹ ???
∞
1.2 Use z_get_spec to examine the defining property for your
conditional construct. Prove:
=SML
z_get_specÒ(if _ then _ else _)Æ;
set_goal([], Òif 2 > 1 then 1 else 0 = 1Æ);
=TEX
2.1 Use an axiomatic description to define a global variable, num,
whose value is loosely specified to lie between 4 and 50:
πZAX
‹ ???
˜¸¸¸¸¸¸
‹ ???
∞
2.2 Prove the consistency result for num and save it:
=SML
z_push_consistency_goal ÒnumÆ;
(* ?: *) (* :? *)
save_consistency_thm ÒnumÆ (pop_thm());
=TEX
2.3 Examine the specification of num and use it to prove that
num is non-negative:
=SML
z_get_specÒnumÆ;
set_goal([], Ònum æ 0Æ);
(* ?: *) (* :? *)
=TEX
3. Prove the following conjectures about the opperation schemas OP and OP2
defined in section 7.3.3 of the Z Tutorial Manual:
=SML
set_goal([], Òpre OP § i? æ 0Æ);
(* ?: *) (* :? *)
set_goal([], Ò(pre OP ¥ pre OP2) ± (pre OP ± OP2 ¥ OP)Æ);
(* ?: *) (* :? *)
=TEX

% =====================================================================

\section*{Exercises 6: The Z Toolkit}

1. Before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_sets_ext";
=TEX
Prove the following samples from section 7.4.1 of the Z Tutorial Manual:
=SML
set_goal([], (* Z1.9 *) Ò (a ° b) ¿ (a \ b) = aÆ);
(* ?: *) (* :? *)
=SML
set_goal([], (* Z3.1 *) Ò a Ä b § a ç  bÆ);
(* ?: *) (* :? *)
=TEX
Try further examples ad lib using setlg:
=SML
setlg "Z3b.1" Z3b;
(* ?: *) (* :? *)
=TEX

2. Before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_rel_ext";
=TEX
Prove the following samples from section 7.4.2 of the Z Tutorial Manual:
=SML
set_goal([], (* Z4.9 *) Òdom {} = {}Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* Z5.2 *) ÒP ª (Q ª R) = (P ª Q) ª RÆ);
(* ?: *) (* :? *)
=SML
set_goal([], (* Z9b.1 *) Òdom R = first ® R ©Æ);
(* ?: *) (* :? *)
=TEX
Try further examples ad lib using setlg:
=SML
setlg "Z8.1" Z8;
(* ?: *) (* :? *)
=TEX

% =====================================================================

\section*{Exercises 6: The Z Toolkit}

1. Sets: before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_sets_ext";
=TEX
Prove the following samples from section 7.4.1 of the Z Tutorial Manual:
=SML
set_goal([], (* Z1.9 *) Ò (a ° b) ¿ (a \ b) = aÆ);
(* ?: *) (* :? *)
=SML
set_goal([], (* Z3.1 *) Ò a Ä b § a ç  bÆ);
(* ?: *) (* :? *)
=TEX
Try further examples ad lib using setlg:
=SML
setlg "Z3b.1" Z3b;
(* ?: *) (* :? *)
=TEX

2. Relations: before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_rel_ext";
=TEX
Prove the following samples from section 7.4.2 of the Z Tutorial Manual:
=SML
set_goal([], (* Z4.9 *) Òdom {} = {}Æ);
(* ?: *) (* :? *)
=SML
set_goal([], (* Z5.2 *) ÒP ª (Q ª R) = (P ª Q) ª RÆ);
(* ?: *) (* :? *)
=SML
set_goal([], (* Z9b.1 *) Òdom R = first ® R ©Æ);
(* ?: *) (* :? *)
=TEX
Try further examples ad lib using setlg:
=SML
setlg "Z8.1" Z8;
(* ?: *) (* :? *)
=TEX

3. Functions: before doing this exercise execute the following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_fun_ext";
=TEX
Prove the following sample from section 7.4.3 of the Z Tutorial Manual:
=SML
set_goal([], (* Z12.1 *) Ò f ç X ﬂ Y ± (x, y) ç f ¥ f x = y Æ);
(* ?: *) (* :? *)
set_goal([], (* Z12.2 *) Ò f ç X ˛ Y ± (x, y) ç f ¥ f x = y Æ);
=SML
(* ?: *) (* :? *)
=TEX
The other Z12 proofs are very similar.
The Z12b proofs are rather long; you are not recommended to try them
during the course.

4. Numbers and Finiteness: before doing this exercise execute the
following commands:
=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_library";
set_flags[("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
4.1 Give an inductive definition of the function ì which maps a natural
number n to the sum of the first n natural numbers:
πZAX
‹	ì : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	???
∞
4.2 Prove the following:
=SML
set_goal([], Òµn:Ó∑ ì n * 2 = n * (n + 1)Æ);
(* ?: *) (* :? *)
=TEX
You may also like to try the other two proofs in section 7.4.4 of
the Z Tutorial Manual
=SML
setlg "ZNum.2" ZNum;
(* ?: *) (* :? *)
=SML
setlg "ZNum.3" ZNum;
(* ?: *) (* :? *)
=TEX
\end{document}
