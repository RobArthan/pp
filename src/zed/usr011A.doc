% usr011A.doc   %Z% $Date$ $Revision$ $RCSfile$
% this should form a chapter of the document
=TEX

\section{Introduction}

\subsection{The Structure of This Chapter}

In this chapter the \Product-Z{} language and its proof support is described systematically but informally.

The description is organised around the abstract syntax for \Product-Z{}.

One section of the chapter is devoted to each of:

\begin{itemize}
\item
Propositional Connectives
\item
Declarations
\item
Quantifiers and Predicates
\item
Expressions
\item
Schema Expressions
\item
Paragraphs
\end{itemize}

Within each of these sections one subsection is devoted to each way of constructing phrases of the appropriate kind.

Each of these subsections covers:

\begin{itemize}
\item
concrete syntax
\item
abstract/computational syntax
\item
proof support
\end{itemize}

The emphasis is on illustration and example rather than on formal description.

This introductory section also addresses some topics orthogonal to the following sections.

\subsection{Paragraphs, Terms and Quotations}

The \Product{} system provides support for Z via a semantic embedding into HOL.
Z and HOL originate in distinct academic subcultures of the formal methods community, and the terminology used by these subcultures is diverse.

In the \Product{} documentation we therefore find it necessary to mix terminology in ways which might be confusing.

\subsubsection{Paragraphs}

Usage of the term ``Paragraph'' follows the literature on Z.
Paragraphs form the top level constituents of Z specifications, and correspond to declarations, definitions, or constant specifications in HOL.
These effects in HOL are often not available as object language syntactic contructs, but are effected by the use of procedure calls in the metalanguage \Product-ML{}.

The effect of processing a paragraph in Z therefore corresponds most closely to that of executing a metalanguage procedure in HOL.
Paragraphs do not have values, but are evaluated for their side effects, which are recorded in the \Product{} theory hierarchy.

Paragraphs in Z are formed using various other syntactic categories, including {\it predicates}, {\it expressions}, {\it schema-expression}, and {\it declarations}.
In HOL the syntactic categories having similar roles are {\it types} and {\it terms}.

\subsubsection{Z Terms}

In mapping Z into HOL all of the syntactic categories for Z except paragraphs are mapped into HOL terms.
It is therefore convenient at times to talk of ``Z Terms'', even though the `term' is not used in the literature on Z, meaning a term in the image of the Z to HOL mapping.

Furthermore, when dealing with Z in \Product{} at an abstract or computational level, it is convenient to regard the syntactic categories ``predicate'', ``expression'', and ``schema expression'' as being combined into the single category ``term''.
This is reflected by the provision of a \ProductML{} datatype called $Z\_TERM$ which reveals the abstract structure of the Z language in these terms.

Two functions are supplied with \Product{} which enable $TERM$s to be contructed from their components or broken up into their components via the datatype $Z\_TERM$:

=SML
mk_z_term : Z_TERM -> TERM;
dest_z_term : TERM -> Z_TERM;
=TEX

e.g., to contruct the Z predicate
=INLINEFT
ñtrue®
=TEX
:
=SML
val term_true = mk_z_term ZTrue;
=TEX
=GFT ProofPower output
val term_true = ñtrue® : TERM   
=TEX

To construct an implication:

=SML
val term_imp = mk_z_term (Z´ (term_true, term_true));
=TEX
=GFT ProofPower output
val term_imp = ñtrue ´ true® : TERM   
=TEX

To display the kind of Z contruct and its constituents:

=SML
dest_z_term term_imp;
=TEX
=GFT ProofPower output
val it = Z´ (ñtrue®, ñtrue®) : Z_TERM   
=TEX

=SML
dest_z_term term_true;
=TEX
=GFT ProofPower output
val it = ZTrue : Z_TERM   
=TEX

To bind the values of the constituents of a Z TERM to ML names use a pattern matching ML binding with $dest\_z\_term$:

=SML
val (Z´ (ante, concl)) = dest_z_term term_imp;
=TEX
=GFT ProofPower output
val ante = ñtrue® : TERM   val concl = ñtrue® : TERM   
=TEX

The datatype $Z\_TERM$ is described in detail below, and the its structure is used as the basis for the explanation of the Z language support in \Product{}.

\subsubsection{Z Types}

Z is a typed language, and in \Product{}, the types of Z are mapped into types in HOL.
Types in Z are not provided with a concrete syntax, but a Z type may be described using a Z expression which denotes a set co-extensive with the type. 
The function:
=SML
z_type_of : TERM -> TERM
=TEX
when given the HOL term representing a Z expression, returns a HOL term representing a Z expression which denotes the set of all elements of the type of the Z expression.

e.g.:
=SML
z_type_of ñ{x,y:î | x > y}®;
=TEX
=GFT ProofPower output
val it = ñú ª ú® : TERM   
=TEX

$z\_type\_of$ also works on Z schema expressions and predicates:

=SML
z_type_of ñ[x,y:î | x > y]®;
=TEX
=GFT ProofPower output
val it = ñğ [x, y : ú]® : TERM   
=TEX

=SML
z_type_of ñx > y®;
=TEX
=GFT ProofPower output
val it = ñBOOL® : TERM   
=TEX

\subsubsection{Quotation}

As illustrated above, for many of the syntactic categories in Z, and for terms in HOL, quotation facilities are provided in \Product-ML{} which permit phrases to be written in the concrete syntax of Z of HOL.
Such quotations, whether in HOL or in Z, evaluate (after syntax checking and type inference) to yield HOL terms which form the internal representation of the construct.
When such terms are displayed a pretty printer is automatically invoked, which will use an appropriate concrete syntax for displaying the term.
The pretty printer is able to determine which concrete syntax is more appropriate for displaying a term, that of Z or that of HOL.

Both in quotations and in the formatting of terms for display, mixed languages are permitted.
A term may have subterms in distinct languages.

The three languages of concern for this tutorial are \Product-ML{}, \Product-HOL{}, and\\
 \Product-Z{}.
They are quoted using the quotation characters `
=INLINEFT
‘
=TEX
', `
=INLINEFT
¬
=TEX
' and `
=INLINEFT
ñ
=TEX
' respectively.
Quotations are terminated by the character `
=INLINEFT
®
=TEX
', irrespective of language, and may be nested.
Quotations in ML are sometimes known as ``anti-quotations''.
ML quotations are compiled and executed to yield a value of type TERM.
In addition HOL TYPEs may be quoted using `
=INLINEFT
”
=TEX
'.

\subsubsection{Type Inference and Casts}

For the purposes of conducting proofs in Z using \Product{} it is often necessary to enter into the system fragments of Z in which free variables occur.
These are sometimes necessary, for example, when providing a witness for an existence proof.

When type inference takes place on a term entered with free variables the following rules apply.

{\ftlmargin=0.5in

\begin{itemize}

\item
variables with names corresponding to the names of previously declared global variables are treated as occurrences of those global variables.
They are required to have types which are instances of the type of the global variable.
Z global variables are represented in HOL as constants.

\item
The goal package used for goal oriented or backward proof maintains a type context in which the types of all the free variables in the currentsubgoal are held (unless flag "subgoal\_package\_ti\_context" is set false).
Free variables in terms entered by Z quotation will be assigned the type given in the type inference context if there is one, forcing them to match free variable in the current goal.

\item
If a free variable is not a global variable and does not appear in the type inference context, then its type will be inferred from its context in the quotation if possible.
Otherwise a new type variable will be introduced and used for the type of the variable.

\item
Type variables introduced during type inference cannot be constrained to range over tuple types or binding types in the present implementation, and therefore in places where a value of binding or tuple type is required (e.g., before `.') type type inferrer will report an error unless the type of the tuple or binding is apparent.

In the following `x' and `y' are assigned type variables without demur.

=SML
ñ(x,y).2®;
=TEX
=GFT ProofPower output
val it = ñ(x, y).2® : TERM   
=TEX

Whereas in this example, `t' must be assigned a tuple type, a type variable will not suffice:

=SML
ñt.2®;
=TEX
=GFT ProofPower output
Type error in ñt . 2®
In a term of the form ñT.number®, T must be a tuple
The following sub-term is not a tuple
   ñt:'a®
Exception- Fail * Type error [Z-Parser.62000] * raised
=TEX

\item

To overcome the above problem the user may supply, when necessary, additional information in the form of type casts.

For the purpose of applying type casts the infix operator `%
=INLINEFT
_º_
=TEX
' may be used to give guidance to the type inferrer on the type of a construct.

For the purposes of type inference `%
=INLINEFT
_º_
=TEX
' behaves as if it were defined as follows:
[X]œœœœœœœœœœœœœœœœœœœ
Ü	Û_º_İ : (X ¸ ğ X) ­ X
÷üüüüüüüüüüü
Ü	µ x:X; y: ğ X· x º y = x
ˆüüüüüüüüüüüüüüüüüüüüüü

The left hand operand of `%
=INLINEFT
_º_
=TEX
' is required to be an expression, whose type is that of the elements of the expression which is the right hand operand.

\end{itemize}
}%\ftlmargin

\subsubsection{Elided Actual Generic Parameters}

Z generic global variables on set-generic rather than polymorphic.
This means that when instantiated for use, they are instantiated with values which are sets rather than types.

When actual generic parameters are elided, the type of the parameter can usually be established by type inference, but this leaves open the choice of a particular set of that type for the actual parameter.

The choice made by the system depends upon whether the occurrence of the use is a paragraph defining the constant or in a later paragraph or term.
In the defining paragraph, generic parameters must be omitted, and are supplied as identical with the formal parameters.

This may bee seen by viewing the generic predicate subsequently extracted from such a paragraph:

=SML
z_get_specñ¥®;
=GFT ProofPower output
val it = ô [X]({Ş[X], ¥[X]} € ğ ğ X ­ ğ X
    ± (µ A : ğ ğ X
      · Ş[X] A = {x : X | ¶ S : A · x  S}
        ± ¥[X] A = {x : X | µ S : A · x  S})) : THM
=TEX
In this generic predicate all occurrences of `$¥$' are explicitly supplied with the formal parameter which were taken as implicit in the original declaration.

When actual generic parameters to global generic variables are omitted in contexts other than the defining paragraph the set supplied is the largest set of the inferred type, i.e. the set co-extensive with that type.

\subsubsection{U}

Because of the above behaviour of the system in inferring types and actual generic parameters a special constant, which we have called `U' turns out to be very useful.

`U' may be though of as if defined by the abbreviation definition:

=SML
U[X] ¦ X
=TEX

If `U' is used in some specification or expression without supplying an actual generic parameter, the type inferrer will infer an appropriate type, and will then use for the actual parameter the set of all elements of that type.

This is used for two main purposes.
It is frequently used by the proof facilities where quantifiers are introduced automatically.
The main merit here is brevity and efficiency.
The second purpose is for expressing theorems which may be used for unconditional rewriting, since formulae universally quantified over `U' can readily be instantiated for any type-correct rewrite, whereas quantification over other expressions gives rise to proof obligations which may be more difficult to discharge before instantiation can take place.

\subsection{Syntactic Categories}

There is only one form of quotation available for all syntactic categories in Z, encompassing predicates, expressions, and schema expressions.

Ambiguities therefore arise.
Two mechanisms are available to force interpretations other than the default interpretation taken by the parser.

The first is the use of casts, described above.
The left hand operand of a cast must be an expression or schema expression rather than a predicate, and use of a cast (even if the right hand operand is simply `U', will therefore force interpretation of the left hand operand as an expression or schema expression (if this is possible).

The second feature is the operator $$.

$$ will accept as an operand only a predicate, and acts as an identity function on predicates.
It may therefore be used to force interpretation of an expression as a predicate.

While:
=SML
val schexp = ñ[x:X]®;
=TEX
is interpreted as a schema expression:
=SML
z_type_of schexp;
=GFT ProofPower output
val it = ñğ [x : U]® : TERM   
=TEX

=SML
val predicate = ñ[x:X]®;
=TEX
is interpreted as a schema-as-predicate:
=SML
z_type_of predicate;
=GFT ProofPower output
val it = ñBOOL® : TERM   
=TEX

When occurring at the outer level in a quotation, logical connectives are treated as propositional connectives rather than schema calculus operators.

\section{Propositional Connectives}

=GFT
	(* ñ true® *)
	
	ÛZTrueİ
	
	(* ñ false® *)
	
 |	ÛZFalseİ
 
	(* negation, e.g. ñ ³ p® *)
	
 |	ÛZ³İ		of TERM		(* predicate *)
 			
	(* conjunction, e.g. ñ p ± q® *)
	
 |	ÛZ±İ		of TERM * TERM	(* predicates *)
 			
	(* disjunction, e.g. ñ p ² q® *)
	
 |	ÛZ²İ		of TERM * TERM	(* predicates *)
 			
	(* implication, e.g. ñ p ´ q® *)
	
 |	ÛZ´İ		of TERM * TERM 	(* predicates *)
 			
	(* bi-implication, e.g. ñ p ¤ q® *)
	
 |	ÛZ¤İ		of TERM * TERM 	(* predicates *)
=TEX

\subsection{Propositional Reasoning in Z}

The Z propositional connectives are mapped directly to the corresponding connective in HOL, and propositional reasoning in \ProductZ{} behaves therefore in a manner identical to propositional reasoning in \ProductHOL{}.

The behaviour is sensitive to the current ``proof context'', but almost all the proof contexts behave in the same way for propositional reasoning.

A suitable context for propositional reasoning in Z is ``$z\_language$'', and all other Z proof contexts contain the same material for propositional reasoning.

The main methods of proof are:

\begin{enumerate}
\item
Forward proof using elementary rules.
\item
Goal oriented proof by stripping.
\item
Goal oriented automatic proof.
\end{enumerate}

These methods are described and illustrated in each of the following subsections.

\subsubsection{Forward proof using elementary rules}

Forward propositional reasoning is rarely required in \ProductZ{} proofs.
The methods of forward proof are illustrated below showing the use of the following rules.

These are all rules which behave identically \ProductHOL{} and \ProductZ{}.
In the case of Z however, it should be noted that they concern only propositional connectives, and do not operate on the corresponding schema calculus operators.

{\ftlmargin=0.5in

\begin{description}
\item
$asm\_rule$ - make or use an assumption

Given an arbitrary boolean term `$t$', infer `%
=INLINEFT
t ô t
=TEX
', e.g.:
=SML
val x_eq_y = asm_rule ñx=y®;
=GFT ProofPower output
val x_eq_y = x = y ô x = y : THM   
=TEX
=SML
val eq_sym_thm = asm_rule ñx=y ´ y=x®;
=GFT ProofPower output
val eq_sym_thm = x = y ´ y = x ô x = y ´ y = x : THM   
=TEX

\item
$´\_elim$ - use an implication (modus ponens)

Given a theorem of the form `%
=INLINEFT
™ ô a ´ b 
=TEX
' and one of the form `%
=INLINEFT
• ô a
=TEX
' infer `%
=INLINEFT
™, • ô b
=TEX
', e.g:
=SML
val y_eq_x = ´_elim eq_sym_thm x_eq_y;
=GFT ProofPower output
val y_eq_x = x = y ´ y = x, x = y ô y = x : THM   
=TEX

\item
$´\_intro$ - prove an implication

=SML
val imp_thm = ´_intro ñx = y ´ y = x® y_eq_x;
=GFT ProofPower output
val imp_thm = x = y ô (x = y ´ y = x) ´ y = x : THM   
=TEX
=SML
val imp_thm2 = ´_intro ñx = y® imp_thm;
=GFT ProofPower output
val imp_thm2 = ô x = y ´ (x = y ´ y = x) ´ y = x : THM   
=TEX

\item
$strip\_±\_rule$ - split up a conjunction

=SML
val [thm1,thm2,thm3] = strip_±_rule (asm_rule ña ± b ± c®);
=TEX
=GFT ProofPower output
val thm1 = a ± b ± c ô a : THM
val thm2 = a ± b ± c ô b : THM
val thm3 = a ± b ± c ô c : THM
=TEX

\item
$±\_intro$ - create a conjunction

=SML
val newconj = ±_intro x_eq_y thm3;
=GFT ProofPower output
val newconj = x = y, a ± b ± c ô x = y ± c : THM   
=TEX

\end{description}

}

\subsubsection{Proof by stripping}

In suitable proof contexts (which is almost all of them) proofs of propositional results can be completed using only ``stripping'' facilities.

In such cases a proof of the form:

=GFT SML
set_goal([],ñ conjecture ®);
a contr_tac;
=TEX

will suffice.

e.g., first set the goal:

=SML
set_goal([],ñ a ± b ´ b ± a®);
=GFT ProofPower output
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ña ± b ´ b ± a®

val it = () : unit   
=TEX

Then initiate proof by contradiction by applying $contr\_tac$.

=SML
a contr_tac;
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=TEX

In this proof method the conjecture is negated and ``stripped'' into the assumptions, which process is sometimes sufficient to discharge the result without further intervention by the user.
In the case of pure propositional results this is always sufficient.

It is however instructive to undertake such proofs in a more piecemeal way, so as to get an understanding of how these stripping facilities work.

To achieve this a proof of the form:

=GFT SML
set_goal([],ñ conjecture ®);
a z_strip_tac;  (* repeat as often as necessary *)
=TEX
may be used.


e.g.:
=SML
set_goal([],ñ a ± b ´ b ± a®);
=GFT ProofPower output
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ña ± b ´ b ± a®

val it = () : unit   
=TEX
=SML
a z_strip_tac;
=GFT ProofPower output
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ñb ± a®

val it = () : unit   
=TEX
=SML
a z_strip_tac;
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ña®


(* *** Goal "1" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ñb®

val it = () : unit   
=SML
a z_strip_tac;
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ña®

val it = () : unit
=SML
a z_strip_tac;
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=TEX

In such a proof, the conclusion of the current goal is stripped a step at a time.
Whenever an assumption is added to the list of assumptions in the current goal, this assumption is completely stripped.
If the original goal was completely well formed Z, (and the proof context is appropriate for reasoning in Z) then this stripping process should result only in subgoals which are also well formed Z.
If the original subgoal was true, so will be any subgoals obtained by this stripping process, so if an evidently false subgoal appears the original conjecture must have been false.

To get an idea of how the assumptions are being stripped a tactic are available which performs step-by-step stripping on new assumptions before they are taken out of the conclusion.

=GFT SML
set_goal([],ñ conjecture ®);
a step_strip_tac;  (* repeat as often as necessary *)
=TEX

e.g.:
=SML
set_goal([], ñ (a ± b ± (³a ² ³b)) ´ false®);
=GFT ProofPower output
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ña ± b ± (³ a ² ³ b) ´ false®

val it = () : unit 
=TEX
If $strip\_tac$ were used at this point the antecendent of the implication in the conclusion of the goal would be completely stripped into the assumptions, which would in fact solve the goal.

$step\_strip\_tac$, however, performs as much stripping as possible while the antecedent is still in place in the conclusion, creating new asumptions only when no further stripping is possible.

In this case the leftmost conjunct of the antecendent is considered completely stripped and is added to the assumptions, while the remaining conjuncts are left for further attention.

=SML
a step_strip_tac;
=GFT ProofPower output
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  1 *)  ña®

(* ?ô *)  ñb ± (³ a ² ³ b) ´ false®

val it = () : unit   
=SML
a step_strip_tac;
=TEX
The leftmost conjunct of the antecedent is again transferred to the assumptions.
=GFT ProofPower output
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ñ³ a ² ³ b ´ false®

val it = () : unit   
=TEX
The antecedent is now a disjunction.
Stripping a disjunction into the assumptions gives rise to a case split.
=SML
a step_strip_tac;
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ñ³ b ´ false®


(* *** Goal "1" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ñ³ a ´ false®

val it = () : unit
=TEX
The next step would attempt to strip
=INLINEFT
ñ³ a®
=TEX
\ into the assumptions.
However, $ña®$ is already in the assumptions and this results in the discharge of the subgoal. 
=TEX
=SML
a step_strip_tac;
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  2 *)  ña®
(*  1 *)  ñb®

(* ?ô *)  ñ³ b ´ false®

val it = () : unit   
=SML
a step_strip_tac;
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=TEX

\subsubsection{Automatic Proof}

An automatic proof procedure is provided for each proof context which is often capable of solving results reducible to the pure propositional calculus.
Even when it fails it may have resulted in more simplification than would be obtained by other methods.

=GFT SML
set_goal([],ñ conjecture®);
a (prove_tac[]); (* once only *)
=TEX

e.g.:

=SML
set_goal([],ñ (a ± b ± (³a ² ³b)) ´ false®);
=GFT ProofPower output
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ña ± b ± (³ a ² ³ b) ´ false®

val it = () : unit   
=SML
a (prove_tac[]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=TEX

If subgoals are left by $prove\_tac$ then they will not normally be further progressed by repeated application of the tactic.

$prove\_tac$ should be used only when the current goal has no assumptions, or where it is expected that $prove\_tac$ can completely discharge the current goal without making use of the assumptions.

If the assumptions must be used to obtain the proof, or if there are assumptions and $prove\_tac$ is likely to leave some outstanding subgoals, then instead of $prove\_tac$, $asm\_prove\_tac$ should be used:

=GFT SML
a (asm_prove_tac[]); (* once only *)
=TEX

e.g.:
=SML
set_goal([ñ³a®,ñ³b®], ñ ³(a ² b)®);
=GFT ProofPower output
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(*  2 *)  ñ³ b®
(*  1 *)  ñ³ a®

(* ?ô *)  ñ³ (a ² b)®

val it = () : unit   
=SML
a (asm_prove_tac[]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
=TEX

If $prove\_tac$ is used in these circumstances then it may fail.

If the conjecture to be proven can be completely proved by one application of $prove\_tac$ then invocation of the subgoal package is unnecessary.
$prove\_rule$ may be used to obtain the result as follows:

=SML
prove_rule [] ñ (a ± b ± (³a ² ³b)) ´ false®;
=GFT ProofPower output
val it = ô a ± b ± (³ a ² ³ b) ´ false : THM   
=TEX

Further illustrations of these proof methods for the propositional calculus in Z may be found in the exercises in \ref{PropEx}

\section{Declarations}

=GFT
	(* declaration, e.g. ‘dec_of ñ[x,y:ú]®® *)
	
 |	ÛZDecİ		of TERM list		(* variables *)
  			* TERM		(* expression *)
  		
  			
 	(* schema reference, e.g. ‘dec_of ñ[File!]®® *)
 	
 |	ÛZSchemaDecİ	of TERM		(*schema expression*)
			* string		(* decoration *)
		
			
 	(* declaration list, e.g. ‘decl_of ñ[x,y:ú; File!]®® *)
 	
 |	ÛZDeclİ		of TERM list	(* declarations *)
=TEX

\section{Predicates}

=GFT
	(* existential quantification, ñ ¶ File | p · q® *)
	
 |	ÛZ¶İ 		of TERM		(* declaration *)
 			* TERM * TERM	(* predicates *)
 		
 			
	(* unique existential quantification, ñ ¶‰1 File | p · q® *)
	
 |	ÛZ¶‰1İ		of TERM		(* declaration *)
 			* TERM * TERM	(* predicates *)

 		
	(* universal quantification, ñ µ File | p · q® *)
	
 |	ÛZµİ		of TERM		(* declaration *)
			* TERM * TERM	(* predicates *)
		

	(* equation, e.g. ñ a = b® *)
	
 |	ÛZEqİ		of TERM * TERM	(* expressions *)
 		
 			
	(* membership, e.g. ñ a  b® *)
	
 |	ÛZİ		of TERM * TERM	(* expressions *)


	(* schema predicate, e.g. ñ  (File ')® *)
	
 |	ÛZSchemaPredİ	of TERM	(* schema expression *)
 				* string	(* decoration *)
=TEX

\subsection{Schemas as Predicates}

\subsubsection{Concrete Syntax}

An arbitrary expression denoting a set of bindings, together with an optional decoration, may be used as a predicate.


=GFT
	(* schema predicate, e.g. ñ  (File ')® *)
	
 |	ÛZSchemaPredİ		of TERM		(* schema expression *)
 				* string		(* decoration *)
=TEX

\subsubsection{Proof Support}

Schemas as predicates may be eliminated in favour of membership statements by rewriting with $z'schemapred\_def$:

=SML
pure_rewrite_conv[z'schemapred_def]ñ [x:X]±true®;
=TEX
=GFT ProofPower output
val it = ô [x : X] ± true ¤ (x ¦ x)  [x : X] ± true : THM   
=TEX

=SML
rewrite_conv[z'schemapred_def]ñ [x:X]±true®;
=TEX
=GFT ProofPower output
val it = ô [x : X] ± true ¤ x  X : THM   
=TEX

\section{Expressions}

=GFT
		(* local variable ñ x® *)
 |	ÛZLVarİ 	of string	(* variable name *)
 			* TYPE	(* HOL type of variable *)
 			* TERM list	(* generic parameters *)
 		
		(* global variable ñ U[DATE]® *)
 |	ÛZGVarİ 	of string	(* variable name *)
 			* TYPE	(* HOL type of variable *)
 			* TERM list	(* generic parameters *)

 		(* positive integer literal ñ 34® *)
 |	ÛZIntİ 		of string
 		
		(* string literal ñ "characters"® *)
 |	ÛZStringİ	of string
 		
		(* function application  ñ f x®  *)
 |	ÛZAppİ 		of TERM * TERM	(* expressions *)
 		
		(* lambda expression ñ Ì x:î | x > 3 · x * x ® *)
 |	ÛZÌİ		of TERM	(* declaration *)
 			* TERM	(* predicate *)
 			* TERM	(* expression *)
 		
		(* definite description ñ Í x:î | x * x = 4 · x® *)
 |	ÛZÍİ		of TERM	(* declaration *)
 			* TERM	(* predicate *)
			* TERM	(* expression *)
 		
		(* power set construction, ñ ğ ú® *)
 |	ÛZğİ		of TERM		(* expression *)

		(* set display, ñ {1,2,3,4} ® *)
 |	ÛZSetdİ		of TYPE	(* HOL type of elements *)
 			* TERM list	(* expressions *)
 		
		(* set abstraction, ñ {x:ú | 1¼x¼4 · x*x} ®*)
 |	ÛZSetaİ 		of TERM	(* declaration *)
 			* TERM	(* predicate *)
 			* TERM	(* expression *)
 		
		(* tuple, ñ (1,2,3,4) ® *)
 |	ÛZTupleİ 	of TERM list	(* expressions *)
 		
		(* tuple element selection, ñ (x,y).2® *)
 |	ÛZSel‰tİ 		of TERM	(* expression *)
 			* int		(* element number *)

 		(* cartesian product, ñ (ú ¸ î) ® *)
 |	ÛZ¸İ		of TERM list	(* expressions *)
 		
		(* binding ñ (people ¦ {}, age ¦ {}) ® *)
 |	ÛZBindingİ	of (	string	(* component name *)
 			* TERM	(* component value *)
 			) list
 		
		(* binding component selection ñ (a ¦ 1, b ¦ "4").b ® *)
 |	ÛZSel‰sİ		of TERM	(* expression *)
 			* string	(* component name *)
 		
		(* theta term ñ ÊFile' ® *)
 |	ÛZÊİ		of TERM	(* schema expression *)
			* string	(* decoration *)
 		
		(* sequence display ñ §1,2,3¢® *)
 |	ÛZ§¢İ		of TYPE	(* type of elements *)
			* TERM list	(* values of elements *)
=TEX

\subsection{Function Application}\label{FunctionApplication}

\subsubsection{Syntax}

=GFT
	(* function application  ñ f x®  *)
	
 |	ÛZAppİ 		of TERM * TERM	(* expressions *)
=TEX

\subsubsection{Proof Support}

Applications of lambda abstractions can be eliminated by (conditional) Â-conversion.

=SML
z_Â_conv ñ (Ì x:X | P x · f x) a®;
=GFT ProofPower output
val it = P a, a  X ô (Ì x : X | P x · f x) a = f a : THM   
=TEX
Other applications may be eliminated in favour of definite descriptions.

=SML
z_app_conv ñ f a®;
=GFT ProofPower output
val it = ô f a = Í f_a : U | (a, f_a)  f · f_a : THM   
=TEX

More commonly function applications will be eliminated by rewriting with the definition of the relevant function.


\subsection{Lambda Abstraction}

$Ì$-abstractions when applied to arguments may be eliminated by $z\_Â\_conv$ (see \ref{FunctionApplication}).

Assertions about membership of $Ì$-abstractions may be directly eliminated.
=SML
rewrite_conv [] ñz  (Ì x:X | P x · f x)®;
=GFT ProofPower output
val it = ô z  Ì x : X | P x · f x ¤ z.1  X ± P z.1 ± f z.1 = z.2 : THM  
=TEX

Since they denote sets they may also be eliminated in favour of set comprehensions using $z\_Ì\_conv$. 

=SML
z_Ì_conv ñÌ x:X | P x · f x®;
=GFT ProofPower output
val it = ô (Ì x : X | P x · f x) = {x : X | P x · (x, f x)} : THM   
=TEX

\subsection{Definite Description}

Definite descriptions may be eliminated using $z\_Í\_rule$.

=SML
z_Í_rule ñ Í x:X | P · y®;
=GFT ProofPower output
val it = ô µ x' · ñ µ x : X | P · y = x'® ± ñ ¶ x : X | P · y = x'®
  ´ ñ Í x : X | P · y® = x' : THM
=TEX

\subsection{The Power Set}

Membership statements concerning power sets may be eliminated using $z\_\_ğ\_conv$, or by rewriting in proof context ``$z\_language\_ext$''.

=SML
rewrite_conv[] ñ z  ğ y®;
=GFT ProofPower output
val it = ô z  ğ y ¤ (µ x1 : U · x1  z ´ x1  y) : THM   
=TEX

\subsection{Set Displays}

Membership statements sets displays may be eliminated using $z\_\_setd\_conv$, or by rewriting in proof context ``$z\_language\_ext$''.

=SML
rewrite_conv[] ñ z  {1,2,3,4,5}®;
=GFT ProofPower output
val it = ô z  {1, 2, 3, 4, 5} ¤ z = 1 ² z = 2 ² z = 3 ² z = 4 ² z = 5 : THM
=TEX

\subsection{Set Abstractions}

Statements about membership of set abstractions may be eliminated using $z\_\_seta\_conv$, or by rewriting in proof context ``$z\_language\_ext$''.

A simple abstraction results in straightforward substitution into the body of the abstraction:

=SML
rewrite_conv[] ñ 9  {x:î | x < 12}®;
=GFT ProofPower output
val it = ô 9  {x : î | x < 12} ¤ 9  î ± 9 < 12 : THM   
=TEX

Where the signature is more complex tuple projections are introduced:

=SML
rewrite_conv[]ñ z  {x, y:î | x < y}®;
=GFT ProofPower output
val it = ô z  {x, y : î | x < y} ¤ (z.1  î ± z.2  î) ± z  (_ < _) : THM
=TEX

Where membership is asserted of a tuple the projections are undertaken automatically.

=SML
rewrite_conv[]ñ (v,w)  {x, y:î | x < y}®;
=GFT ProofPower output
val it = ô (v, w)  {x, y : î | x < y} ¤ (v  î ± w  î) ± v < w : THM   
=TEX

In the general case introduction of an existential is necessary, though this is avoided whenever possible.

=SML
rewrite_conv[]ñ z  {x, y:î | x < y · x * y - x}®;
=GFT ProofPower Output
val it = ô z  {x, y : î | x < y · x * y - x} ¤ (¶ x, y : î | x < y · x * y - x = z) :THM
=TEX

\subsection{Tuple Displays}

Two tuple displays are equal iff each of their respective components are equal.

=SML
rewrite_conv[] ñ(x,y) = (a,b)®;
=GFT ProofPower output
val it = ô (x, y) = (a, b) ¤ x = a ± y = b : THM   
=TEX

Conversions to effect projection from tuple displays are also built into proof context ``$z\_language$''.
=SML
rewrite_conv[] ñ (x,y).1®;
=GFT ProofPower output
val it = ô (x, y).1 = x : THM   
=TEX

\subsection{Binding Displays}

Two binding displays are equal iff each of their respective components are equal.

=SML
rewrite_conv[] ñ (x ¦ a, y ¦ b) = (y ¦ d, x ¦ c)®;
=GFT ProofPower output
val it = ô (x ¦ a, y ¦ b) = (x ¦ c, y ¦ d) ¤ a = c ± b = d : THM   
=TEX

Projection from binding displays is also built in to proof context ``$z\_language$''.

=SML
rewrite_conv[] ñ (x ¦ a, y ¦ b).y®;
=GFT ProofPower output
val it = ô (x ¦ a, y ¦ b).y = b : THM   
=TEX

\subsection{Cartesian Products}

=SML
rewrite_conv[] ñ (a, b)  (x ¸ y)®;
=GFT ProofPower output
val it = ô (a, b)  x ¸ y ¤ a  x ± b  y : THM   
=TEX

=SML
rewrite_conv[z_sets_ext_thm]	ñ (x ¸ y) = (a ¸ b)®;
=GFT ProofPower output
val it = ô x ¸ y = a ¸ b ¤ (µ z : U · z.1  x ± z.2  y ¤ z.1  a ± z.2  b) : THM
=TEX

\subsection{Theta Terms}

Theta terms may be though of as abbreviations for explicit binding constructions.
Rewriting with $z'Ê\_def$ will reveal the underlying binding construction:

=SML
rewrite_conv[z'Ê_def] ñ Ê([x:X; y:Y])'®;
=GFT ProofPower output
val it = ô Ê([x : X; y : Y])' = (x ¦ x', y ¦ y') : THM
=TEX

Alternatively $z\_Ê\_conv$ may be used to secure the same effect:
 
=SML
z_Ê_conv ñ Ê([x:X; y:Y])'®;
=GFT ProofPower output
val it = ô Ê([x : X; y : Y])' = (x ¦ x', y ¦ y') : THM   
=TEX

\section{Schema Expressions}

=GFT
		(* schema negation: ñ(³ File)ºU® *)
 |	ÛZ³‰sİ		of TERM	(* schema expression *)
			
		(* schema conjunction: ñ(File ± File2)ºU® *)
 |	ÛZ±‰sİ		of TERM * TERM	(* schema expressions *)
			
		(* schema disjunction: ñ(File ² File2)ºU® *)
 |	ÛZ²‰sİ		of TERM * TERM	(* schema expressions *)
			
		(* schema implication ñ(File ´ File2)ºU® *)
 |	ÛZ´‰sİ		of TERM * TERM	(* schema expressions *)
			
		(* schema equivalence: ñ(File ¤ File2)ºU® *)
 |	ÛZ¤‰sİ		of TERM * TERM	(* schema expressions *)
			
		(* schema existential: ñ(¶ File3 | people = {} · File2)ºU® *)
 |	ÛZ¶‰sİ		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
		(* schema unique existential: ñ(¶‰1 File3 | people = {} · File2)ºU® *)
 |	ÛZ¶‰1‰sİ		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)
			
		(* schema universal: ñ(µ File3 | people = {} · File2)ºU® *)
 |	ÛZµ‰sİ		of TERM		(* declaration *)
			* TERM		(* predicate *)
			* TERM		(* schema expression *)

		(* horizontal schema expression: ñ [x:ú | x>0] ® *)
 |	ÛZ‰sİ		of TERM		(* declaration *)
			* TERM		(* predicate *)
		
		(* decoration: ñ File ''® *)
 |	ÛZDecor‰sİ	of TERM		(* schema expression *)
 			* string		(* decoration *)
 		
		(* pre-condition: ñ pre FileOp® *)
 |	ÛZPre‰sİ		of TERM		(* schema expression *)

 		(* schema hiding: ñ FileOp \‰s (age, i?)®  *)
 |	ÛZHide‰sİ	of TERM		(* schema expression *)
 			* string list		(* component names *)
 		
		(* schema renaming: ñFile [aged/age, input/i?]® *)
 |	ÛZRename‰sİ	of TERM		(* schema expression *)
 			* (string * string) list	(* rename list *)
 		
		(* schema projection: ñFileOp ù‰s File®*)
 |	ÛZù‰sİ		of TERM * TERM	(* schema expressions *)

		(* schema composition: ñ„File »‰s „File® *)
 |	Z»‰s		of TERM * TERM	(* schema expressions *)
 		
		(* delta operation: ñ„File® *)
 |	ÛZ„‰sİ		of TERM		(* schema expression *)
 		
		(* ˜ operation: ñ˜File® *)
 |	ÛZ˜‰sİ		of TERM		(* schema expression *)
;
=TEX
\subsection{Schema Negation}

\subsubsection{Syntax}

=GFT
	(* schema negation ñ(³ File)ºU® *)
	
 | 	ÛZ³‰sİ			of TERM	(* schema expression *)
=TEX

A negation occurring at the outermost level in a term quotation will be interpreted as a logical negation rather than a schema negation, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema negation of a schema iff it is not an element of the schema.

This rule is captured by the conversion $z\_\_³‰s\_conv$, which is built into the standard rewrites for proof context ``z\_language''.

=SML
rewrite_conv[]ñz  (³ File)®;
=TEX

=GFT ProofPower output
val it = ô z  (³ File) ¤ ³ z  File : THM   
=TEX

\subsection{Schema Conjunction}

\subsubsection{Syntax}

=GFT
 | 	ÛZ±‰sİ	(* schema conjunction ñ(File ± File2)ºU® *)
			of TERM * TERM (* schema expressions *)
=TEX

The two operands must be schema expressions with compatible types.

A conjunction occurring at the outermost level in a term quotation will be interpreted as a logical conjunction rather than a schema conjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding is an element of the schema conjunction of two schemas iff both the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z\_\_±‰s\_conv$, which is built into the standard rewrites for proof context ``z\_language''.

=IGN
z__±‰s_conv ñz  (File ± File2)®;
=SML
rewrite_conv[] ñz  (File ± File2)®;
=TEX

=GFT ProofPower output
val it = ô z  (File ± File2)
    ¤ (age ¦ z.age, people ¦ z.people)  File
      ± (height ¦ z.height, people ¦ z.people)  File2 : THM
=TEX

\subsection{Schema Disjunction}

\subsubsection{Syntax}

=GFT
 | 	ÛZ²‰sİ	(* schema disjunction ñ(File ² File2)ºU® *)
			of TERM * TERM (* schema expressions *)
=TEX

The two operands must be schema expressions with compatible types.

A disjunction occurring at the outermost level in a term quotation will be interpreted as a logical disjunction rather than a schema disjunction, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema disjunction of two schemas iff either of the projections of the binding to the signatures of the operands are elements of the corresponding operand schemas.

This rule is captured by the conversion $z\_\_²‰s\_conv$, which is built into the standard rewrites for proof context ``z\_language''.

=IGN
z__²‰s_conv ñz  (File ² File2)®;
=SML
rewrite_conv[] ñz  (File ² File2)®;
=TEX

=GFT ProofPower output
val it = ô z  (File ² File2)
    ¤ (age ¦ z.age, people ¦ z.people)  File
      ² (height ¦ z.height, people ¦ z.people)  File2 : THM
=TEX

\subsection{Schema Implication}
\subsubsection{Syntax}

=GFT
 | 	ÛZ´‰sİ	(* schema implication ñ(File ´ File2)ºU® *)
			of TERM * TERM (* schema expressions *)
=TEX

The two operands must be schema expressions with compatible types.

An implication occurring at the outermost level in a term quotation will be interpreted as a logical implication rather than a schema implication, unless a cast is applied.

\subsubsection{Proof Support}

A binding (of appropriate type) is an element of the schema implication of two schemas iff whenever the projection of the binding to the signature of the first operand is an element of the corresponding operand schemas, the projections of the binding to the signature of the second operand is also an element of the second operand schema.

This rule is captured by the conversion $z\_\_´‰s\_conv$, which is built into the standard rewrites for proof context "z\_language".

=IGN
z__´‰s_conv ñz  (File ´ File2)®;
=SML
rewrite_conv[] ñz  (File ´ File2)®;
=TEX

=GFT ProofPower output
val it = ô z  (File ´ File2)
    ¤ (age ¦ z.age, people ¦ z.people)  File
      ´ (height ¦ z.height, people ¦ z.people)  File2 : THM
=TEX

\section{Paragraphs}

\subsection{Introduction}

\begin{itemize}
\item
Fixity declarations
\item
Given sets
\item
Abbreviation definitions
\item
Schema boxes
\item
Axiomatic descriptions
\item
Generics
\item
Free types
\item
Constraints
\end{itemize}

\subsection{Paragraph Processing Modes and Flags}

There are several different modes of processing Z paragraphs which are controlled by flags.

\begin{itemize}
\item
{\bf Type-checking Mode}

If the flag $z\_type\_check\_only$ is set to $true$ then only type checking of Z paragrpahs is performed.

This makes the response faster, and permits greater flexibility in amending paragraphs.
This mode is suitable for use while developing specifications prior to undertaking any proof work.

\item
{\bf Axiomatic Mode}
 
If the flag $z\_use\_axioms$ is set to true (and\\
$z\_type\_check\_only$ is set to $false$) then axiomatic descriptions and free-type descriptions are introduced using axioms.


\item
{\bf Conservative Mode}

If both the above flags is set $false$ then all Z axiomatic descriptions are introduced using the \Product{} $new\_specification$ facility, i.e. by conservative extension.

Consistency proof obligations, unless discharged automatically, will have to be discharged by the user.

In a future release it is hoped that free-types will also be supported by conservative extension.

\end{itemize}


\subsection{Fixity Declarations}


Fixity declarations may be provided for:

{\ftlmargin 0.5in
\begin{itemize}
\item
functions
¹Z
fun 10 twice _
°
¹Z
fun  slice ... from _ to _ 
°
\item
generics
¹Z
gen _ swap _
°
\item
relations
¹Z
rel  _ is_even 
°
\end{itemize}
}%\ftlmargin

The optional numeric value is a priority.

`\_' is a space for a parameter\\
`...' is a space for a sequence of parameters (with sequence brackets elided)

Fixity clauses can only be deleted by deleting the theory they are contained in.

\subsection{Given Sets}

\subsubsection{Syntax}

Given sets are introduced in the normal way a list of names enclosed in square brackets.
The paragraph is introduced in the \LaTeX source by `$¹Z$' and terminated by `$°$', each on a new line.

The displayed form is:

¹Z
[G1, G2]
°

\subsubsection{Proof Support}

Each given set causes the introduction of a new type and a new global variable known to be the set of all elements of that type.

The specification of the given set may be retrieved as follows: 

=SML
val G1_def = z_get_spec ñG1®;
=GFT ProofPower output
val G1_def = ô G1 = U : THM   
=TEX

`U' is the generic identity function, and when its actual generic parameter is not printed it may be assumed to be the set of all elements of the relevant type.
The normal proof contexts have knowledge of `U' so that rewriting with the specification of a given set will enable assertions about membership of the given set to be proven.

=SML
rewrite_conv [G1_def] ñx  G1®;
=GFT ProofPower output
val it = ô x  G1 ¤ true : THM   
=TEX

\subsection{Abbreviation Definitions}

\subsubsection{Syntax}

¹Z
X swap Y ¦ Y ¸ X 
°

\subsubsection{Proof Support}

=SML
val swap_def = z_get_spec ñ(_swap_)®;
=GFT ProofPower Output
val swap_def =
ô [X, Y](X swap Y = Y ¸ X) : THM   
=TEX

=SML
rewrite_conv [swap_def] ñú swap î®;
=TEX
=GFT ProofPower Output
val it = ô ú swap î = î ¸ ú : THM   
=TEX

\subsection{Schema Boxes}

\subsubsection{Syntax}

ÿSchüüüüüüüüüüüü
Ü	x, y : ú;
Ü	z : î
÷üüüüüüüüü
Ü	x = y ² y = z
ˆüüüüüüüüüüüüüü
\subsubsection{Proof Support}
=SML
val sch_def = z_get_spec ñSch®;
=GFT ProofPower Output
val sch_def = ô Sch =
  [x, y : ú; z : î | x = y ² y = z] : THM   
=TEX
=SML
rewrite_conv [sch_def (*, z'schemapred_def*)]
 ñµ x,y:ú; z:î · Sch ² disjoint §{x},{y},{z}¢®;
=TEX
=GFT ProofPower Output
val it = ô (µ x, y : ú; z : î · Sch
		² disjoint §{x}, {y}, {z}¢)
    ¤ (µ x, y : ú; z : î
      · [x, y : ú; z : î | x = y ² y = z]
      	² disjoint §{x}, {y}, {z}¢) : THM
=TEX

\subsection{Generic Schema Boxes}

\subsubsection{Syntax}

ÿDSUBS[X]üüüüüüüüüüü
Ü	set1, set2: ğ X
÷üüüüüüüüüüüüü
Ü	set1 ¡ set2 = {}
ˆüüüüüüüüüüüüüüüü

\subsubsection{Proof Support}

=SML
val dsubs_def = z_get_spec ñDSUBS®;
=GFT ProofPower Output
val dsubs_def = ô [X](DSUBS[X] =
  [set1, set2 : ğ X | set1 ¡ set2 = {}]) : THM
=TEX
\vfill
=SML
rewrite_conv [dsubs_def (*, z'schemapred_def*)]
 ñµ DSUBS[î] · set1 € î ± set2 € î®;
=GFT ProofPower Output
val it = ô (µ (DSUBS[î]) · set1 € î ± set2 € î)
	¤ (µ [set1, set2 : ğ î | set1 ¡ set2 = {}] ·
		set1 € î ± set2 € î) : THM
=TEX
\ignore{
set_goal([],ñµ DSUBS[î] · set1 € î ± set2 € î®);
a (z_strip_tac THEN rewrite_tac [dsubs_def,z'schemapred_def]);
a (conv_tac (MAP_C z__horiz_schema_conv));
 THEN REPEAT strip_tac);

=TEX
=GFT ProofPower Output
val it = ô (µ (DSUBS[î]) · set1 € î ± set2 € î)
    ¤ (µ [set1, set2 : ğ î | set1 ¡ set2 = {}] ·
    		set1 € î ± set2 € î) : THM
=TEX
}

\subsection{Axiomatic Descriptions}

\subsubsection{Syntax}

¹ZAX
Ü	twice _ : ú ­ ú
÷üüüüüüüüüüü
Ü	µi : ú · twice i = 2*i
°
\subsubsection{Proof Support}
=SML
val twice_def = z_get_spec ñ(twice_)®;
=GFT ProofPower Output
val twice_def = ô (twice _)  ú ­ ú
	± (µ i : ú · twice i = 2 * i) : THM   
=TEX
=SML
rewrite_conv[twice_def] ñtwice 4®;
=GFT ProofPower Output
Exception- Fail * no rewriting occurred
  [rewrite_conv.26001] * raised
=TEX
=SML
set_goal([],ñµ n:ú · twice n = 2*n®);
a (REPEAT z_strip_tac);
=GFT ProofPower Output
(* *** Goal "" *** *)

(*  1 *)  ñn  ú®

(* ?ô *)  ñtwice n = 2 * n®
=TEX
=SML
a (fc_tac [twice_def]);
=GFT ProofPower Output
Current and main goal achieved
=TEX

\subsection{Generic Axiomatics}


\subsubsection{Syntax}

[X]œœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü slice ... from _ to _ : ((seq X) ¸ î ¸ î) ­ seq X
÷üüüüüüüüüüüüüüüü
Ü	µ l,r:î; s: seq X ·
Ü	(slice ... from _ to _) (s,l,r) = (l .. r) ò s
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
[A, B, C]œœœœœœœœœœœœœœœœœœœœœœœœ
Ü	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷üüüüüüüüüüüüüüüüüü
Ü	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
[X]üüüüüüüüüüüüüüüüüüüü
Ü length : seq X ­ î
÷üüüüüüüüüüüüüüüü
Ü	length §¢ = 0;
Ü	µ h:X; t: seq X·
Ü	length (§h¢ ë t) = length t + 1
ˆüüüüüüüüüüüüüüüüüüüüüü

\subsubsection{Proof Support}

=SML
val slice_from_to_def =
  z_get_spec ñ(slice ... from _ to _)®;
=GFT ProofPower Output
val slice_from_to_def = ô
 [X]((slice ... from _ to _)[X]
 		 (seq X) ¸ î ¸ î ­ seq X
 ± (µ l, r : î; s : seq X ·
 	(slice ... from _ to _)[X] (s, l, r)
 	= (l .. r) ò s)) : THM
=TEX


\subsection{Free Types}


\subsubsection{Syntax}

¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°

\subsubsection{Proof Support}

=SML
val tree_def = z_get_spec ñTREE®;
=GFT ProofPower Output
val tree_def = ô TREE = U : THM   
=TEX

=SML
val tip_def = z_get_spec ñtip®;
=GFT ProofPower Output
val tip_def = ô (tip  TREE
 ± fork  î ¸ TREE ¸ TREE à TREE)
 ± disjoint §{tip}, ran fork¢
 ± (µ W : ğ TREE | {tip} À fork ¨ î ¸ W ¸ W © € W·
	TREE € W) : THM
=TEX

\subsection{Mutually Recursive Free Types}

\subsubsection{Syntax}

¹Z
TYPE ::= Tvar G1 | Tcon (G1 ¸ seq TERM)
&
TERM ::= Con (G1 ¸ TYPE) | App (TERM ¸ TERM)
°

\subsubsection{Proof Support}

=SML
val tvar_def = z_get_spec ñTvar®;
=GFT ProofPower Output
val tvar_def = ô (Tvar  G1 à TYPE
    ± Tcon  G1 ¸ (seq TERM) à TYPE
    ± Con  G1 ¸ TYPE à TERM
    ± App  TERM ¸ TERM à TERM)
    ± (disjoint §ran Tvar, ran Tcon¢
    ± (µ W : ğ TYPE
      | Tvar ¨ G1 © À Tcon ¨ G1 ¸ (seq TERM) © € W
      · TYPE € W))
    ± disjoint §ran Con, ran App¢
    ± (µ W : ğ TERM
      | Con ¨ G1 ¸ TYPE © À App ¨ W ¸ W © € W
      · TERM € W) : THM
=TEX

\subsection{Constraints}

\subsubsection{Syntax}

¹Z
[X] ((¶f : X à G1 · true)
	¤ (¶f : X à G2 · true))
°
¹Z
 {1} swap {§1¢} = {§1¢} ¸ {1}
 	± Sch ½ [x, y, z : ú] 
°
¹Z
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))
 	 (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú)
°
\subsubsection{Proof Support}

=SML
val c1 = get_axiom "-" "Constraint 1";
=GFT ProofPower output
val c1 = ô [X]((¶ f : X à G1 · true) ¤
		(¶ f : X à G2 · true)) : THM   
=TEX

