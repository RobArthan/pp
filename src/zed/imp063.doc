% imp063.doc	%Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Term Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP063}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the term generator for HOL/Z.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{92/03/19} ] Initial Draft.

\item [Issue 1.9 (17th July 1992)]
Now uses real $mk\_z\_rename‰s$.
\item [Issue 1.10 (20th July 1992)] Added binding display. 
\item [Issue 1.11 (21st July 1992)]
Activated $rename‰s\_const\_spec$.
\item [Issue 1.12-15 (31st July 1992)]
Added calls to a few more semantic constant generation functions. Tidied up the documentation side.
\end{description}
\subsection{Changes Forecast}
The function $do\_in\_theory$ will be moved into the
underlying HOL system in due course.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the term generator for HOL/Z meeting the detailed design
given in \cite{DS/FMU/IED/DTD063}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD063}.
\subsection{Dependencies}
The structure $ZTermGenerator$ depends on the structure
$ZUserInterfaceSupport$ for the types of the Z abstract syntax
tree, $ZTypeInference$ for the function $type\_of\_z_extype$
amd $ZGeneratedConstants$ for the functions which introduce
generated semantic constants.
\subsection{Interface}
The structure $ZTermGenerator$ is constrained by the signature
$ZTermGenerator$ defined in \cite{DS/FMU/IED/DTD063}.
\subsection{Possible Enhancements}
None.
\subsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
structure ÛZTermGeneratorÝ : ZTermGenerator = struct
local
	open ZUserInterfaceSupport ZTypeInference ZGeneratedConstants;
in
=TEX

\section{CALLING THE GENERATED SEMANTIC CONSTANT INTERFACES}

=SML
fun Ûnew_seta_defnÝ ((dec, pred, t) : (TERM * TERM * TERM)) : TERM = (
let	val res = mk_z_seta (dec, pred, t);
	val thm = seta_gen_semantic_const res;
in
	res
end);
=TEX
=SML
fun Ûnew_tuple_defnÝ (tms : (TERM list)) : TERM = (
let	val tm = mk_z_tuple tms;
	val side = general_gen_const tm;
in
	tm
end);
=TEX
=SML
fun Ûnew_¸_defnÝ (tms : (TERM list)) : TERM = (
let	val tm = mk_z_¸ tms;
	val side = ¸_gen_semantic_const tm;
in
	tm
end);
=TEX
=SML
fun Ûnew_Ì_defnÝ ((dec, pred, t) : (TERM * TERM * TERM)) : TERM = (
let	val tm = mk_z_Ì (dec, pred, t);
	val thm = Ì_gen_semantic_const tm;
in
	tm
end);
=TEX
=SML
fun Ûnew_renaming_defnÝ ((tm, ididl) : TERM * (string * string) list) : TERM = (
let	val tm' = mk_z_rename‰s (tm, ididl);
	val thm = rename‰s_gen_semantic_const tm';
in
	tm'
end);
=TEX
=SML
fun Ûnew_binding_defnÝ (stl : (string * TERM) list) : TERM = (
let	val tm' = mk_z_binding stl;
	val thm = binding_gen_semantic_const tm';
in
	tm'
end);
=TEX
=SML
fun Ûnew_‰s_defnÝ ((tm1, tm2) : (TERM * TERM)) : TERM = (
let	val tm' = mk_z_‰s (tm1, tm2);
	val thm = schema_gen_semantic_const tm';
in
	tm'
end);
=TEX
=SML
fun Ûnew_z_defnÝ (f : 'a -> TERM) (args : 'a) : TERM = (
let	val tm' = f args;
	val thm = general_gen_const tm';
in
	tm'
end);
=TEX

\section{GENERATING HOL TERMS}

\subsection{Z Declarations}

=SML
fun Ûterm_of_z_decÝ (dec : Z_DEC) : TERM = (
	case dec of
	ZDDec (idl, tm, Value ty) =>
		let	val set = term_of_z_tm tm;
			val vars = map (fn id =>
				mk_z_lvar (string_of_ident id, type_of_z_extype ty, [])) idl;
		in
			mk_z_dec (vars, set)
		end
	|ZDDec (_, _, Nil) =>
		fail "term_of_z_dec" 63001 []
	|ZDSchemaDec (tm, _) =>
		mk_z_decsexp (term_of_z_tm tm, "")
)
=TEX
=SML
and Ûlist_term_of_z_decÝ (decl : Z_DEC list) : TERM = (
	mk_z_decl (map (fn zd => term_of_z_dec zd) decl)
)
=TEX

\subsection{Z Schema Texts}

=SML
and Ûterm_of_z_schtextÝ (sch as (dec, Value pred, Value ty)
	: Z_SCH_TEXT) : (TERM * TERM OPT) = (
	(list_term_of_z_dec dec, Value (term_of_z_tm pred))
) | term_of_z_schtext (dec, _, _) = (
	(list_term_of_z_dec dec, Nil)
) 
=TEX

\subsection{Z Terms}

=SML
and Ûterm_of_z_tmÝ ((term as ZTm§¢ (Value ty, tml)) : Z_TM) : TERM = (
let	val elty = hd (tl (dest_z_tuple_t (type_of_z_extype ty)));
in
	mk_z_§¢ (elty, list_term_of_z_tm tml)
end
) | term_of_z_tm (ZTm§¢ (Nil, _)) = (
		fail "term_of_z_tm" 63001 []
) | term_of_z_tm (term as ZTmSetd (Value ty, tml)) = (
let	val elty = type_of_z_extype ty;
in
	mk_z_setd (elty, list_term_of_z_tm tml)
end
) | term_of_z_tm (ZTmSetd (Nil, _)) = (
		fail "term_of_z_tm" 63001 []
) | term_of_z_tm (term as ZTmSeta1 sch) = (
	let	val (tm', ty') = make_chartuple sch;
		val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp => zp;
		val t = term_of_z_tm tm';
	in
		new_seta_defn (dec, pred, t)
	end
) | term_of_z_tm (term as ZTmSeta2 (sch, tm)) = (
	let	val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp => zp;
		val t = term_of_z_tm tm;
	in
		new_seta_defn (dec, pred, t)
	end
) | term_of_z_tm (term as ZTmð tm) = (
	mk_z_ð (term_of_z_tm tm)
) | term_of_z_tm (term as ZTmTuple tml) = (
	new_tuple_defn (list_term_of_z_tm tml)
) | term_of_z_tm (term as ZTmBinding stl) = (
	let	val (ns, ts) = split stl;
	in	new_binding_defn
		(combine (map string_of_ident ns) (list_term_of_z_tm ts))
	end
) | term_of_z_tm (term as ZTm¸ tml) = (
	new_¸_defn (list_term_of_z_tm tml)
) | term_of_z_tm (term as ZTmÊ (tm, d)) = (
	mk_z_Ê (term_of_z_tm tm, d)
) | term_of_z_tm (term as ZTmSel‰T (tm, i)) = (
	new_z_defn mk_z_sel‰t (term_of_z_tm tm, i)
) | term_of_z_tm (term as ZTmSel‰B (tm, id)) = (
	new_z_defn mk_z_sel‰s (term_of_z_tm tm, string_of_ident id)
) | term_of_z_tm (term as ZTmApp (tm1, tm2)) = (
	mk_z_app (term_of_z_tm tm1, term_of_z_tm tm2)
) | term_of_z_tm (term as ZTmFancyApp (id, tm)) = (
	fail "term_of_z_tm" 63003 []
=TEX
=SML
) | term_of_z_tm (term as ZTmÌ (sch, tm)) = (
	let	val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp =>  zp;
		val t = term_of_z_tm tm;
	in
		new_Ì_defn (dec, pred, t)
	end
) | term_of_z_tm (term as ZTmÍ1 sch) = (
	let	val (tm', ty') = make_chartuple sch;
		val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp => zp;
		val t = term_of_z_tm tm';
	in
		new_z_defn mk_z_Í (dec, pred, t)
	end
) | term_of_z_tm (term as ZTmÍ2 (sch, tm)) = (
	let	val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp => zp;
		val t = term_of_z_tm tm;
	in
		new_z_defn mk_z_Í (dec, pred, t)
	end
) | term_of_z_tm (term as ZTmTruth true) = (
	mk_z_true
) | term_of_z_tm (term as ZTmTruth false) = (
	mk_z_false
) | term_of_z_tm (term as ZTm³‰F tm) = (
	mk_z_³ (term_of_z_tm tm)
) | term_of_z_tm (term as ZTmLogInOp‰F (inop, tm1, tm2)) = (
	let	val htm1 = term_of_z_tm tm1;
		val htm2 = term_of_z_tm tm2;
	in
		case inop of
		ZLogInOp± => mk_z_± (htm1, htm2)
		|ZLogInOp² => mk_z_² (htm1, htm2)
		|ZLogInOp´ => mk_z_´ (htm1, htm2)
		|ZLogInOp¤ => mk_z_¤ (htm1, htm2)
		|ZLogInOpSemi => mk_z_± (htm1, htm2)
	end
) | term_of_z_tm (term as ZTmQuant‰F (quant, sch, tm)) = (
	let	val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp => zp;
		val t = term_of_z_tm tm;
	in
		case quant of
		ZQuantµ => mk_z_µ (dec, pred, t)
		|ZQuant¶ => mk_z_¶ (dec, pred, t)
		|ZQuant¶‰1 => new_z_defn mk_z_¶‰1 (dec, pred, t)
	end
=TEX
=SML
) | term_of_z_tm (term as ZTmSchemaPred tm) = (
	mk_z_predsexp (term_of_z_tm tm, "")
) | term_of_z_tm (term as ZTmHorizSchema sch) = (
	let	val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp => zp;
	in
		new_‰s_defn (dec, pred)
	end
) | term_of_z_tm (term as ZTmDecor (tm, d)) = (
	new_z_defn mk_z_dec‰s (term_of_z_tm tm, d)
) | term_of_z_tm (term as ZTmPre tm) = (
	new_z_defn mk_z_pre‰s (term_of_z_tm tm)
) | term_of_z_tm (term as ZTm³‰S tm) = (
	new_z_defn mk_z_³‰s (term_of_z_tm tm)
) | term_of_z_tm (term as ZTmLogInOp‰S (inop, tm1, tm2)) = (
	let	val htm1 = term_of_z_tm tm1;
		val htm2 = term_of_z_tm tm2;
	in
		case inop of
		ZLogInOp± => new_z_defn mk_z_±‰s (htm1, htm2)
		|ZLogInOp² => new_z_defn mk_z_²‰s (htm1, htm2)
		|ZLogInOp´ => new_z_defn mk_z_´‰s (htm1, htm2)
		|ZLogInOp¤ => new_z_defn mk_z_¤‰s (htm1, htm2)
		|ZLogInOpSemi => new_z_defn mk_z_±‰s (htm1, htm2)
	end
) | term_of_z_tm (term as ZTmù (tm1, tm2)) = (
	new_z_defn mk_z_ù‰s (term_of_z_tm tm1, term_of_z_tm tm2)
) | term_of_z_tm (term as ZTmHide (tm, idl)) = (
	new_z_defn mk_z_hide‰s (term_of_z_tm tm, map string_of_ident idl)
) | term_of_z_tm (term as ZTmQuant‰S (quant, sch, tm)) = (
	let	val (dec, opred) = term_of_z_schtext sch;
		val pred = case opred of
			Nil => mk_z_true
			|Value zp => zp;
		val t = term_of_z_tm tm;
	in
		case quant of
		ZQuantµ => new_z_defn mk_z_µ‰s (dec, pred, t)
		|ZQuant¶ => new_z_defn mk_z_¶‰s (dec, pred, t)
		|ZQuant¶‰1 => new_z_defn mk_z_¶‰1‰s (dec, pred, t)
	end
=TEX
=SML
) | term_of_z_tm (term as ZTm„ tm) = (
	new_z_defn mk_z_„‰s (term_of_z_tm tm)
) | term_of_z_tm (term as ZTm˜ tm) = (
	new_z_defn mk_z_˜‰s (term_of_z_tm tm)
) | term_of_z_tm (term as ZTmEq (tm1, tm2)) = (
	mk_z_eq (term_of_z_tm tm1, term_of_z_tm tm2)
) | term_of_z_tm (term as ZTm (tm1, tm2)) = (
	mk_z_ (term_of_z_tm tm1, term_of_z_tm tm2)
) | term_of_z_tm (term as ZTm» (tm1, tm2)) = (
	new_z_defn mk_z_»‰s (term_of_z_tm tm1, term_of_z_tm tm2)
) | term_of_z_tm (term as ZTmPipe (tm1, tm2)) = (
	fail "term_of_z_tm" 63002 [fn()=>"schema piping"]
) | term_of_z_tm (term as ZTmú i) = (
	mk_z_int (string_of_int i)
) | term_of_z_tm (term as ZTmString s) = (
	mk_z_string s
) | term_of_z_tm (term as ZTmLVar (id, Value ty, tml)) = (
	mk_z_lvar (string_of_ident id, type_of_z_extype ty, list_term_of_z_tm tml)
) | term_of_z_tm (ZTmLVar (_, Nil, _)) = (
		fail "term_of_z_tm" 63001 []
) | term_of_z_tm (term as ZTmGVar (id, Value ty, tml)) = (
	mk_z_gvar (string_of_ident id, type_of_z_extype ty, list_term_of_z_tm tml)
) | term_of_z_tm (ZTmGVar (_, Nil, _)) = (
	fail "term_of_z_tm" 63001 []
) | term_of_z_tm (term as ZTmLet _) = (
	fail "term_of_z_tm" 63002 [fn()=>"let-expressions"]
) | term_of_z_tm (term as ZTmRename (tm, ididl)) = (
let	val term = term_of_z_tm tm;	
	val s = map (fn (id1, id2) =>
			(string_of_ident id1, string_of_ident id2)) ididl
in
	new_renaming_defn (term, s)
end
) | term_of_z_tm (term as ZTmBracketed tm) = (
	term_of_z_tm tm
) | term_of_z_tm (term as ZTmQuotation htm) = (
	htm
)
=TEX
=SML
and Ûlist_term_of_z_tmÝ ((tm::tml) : Z_TM list) : TERM list = (
	(term_of_z_tm tm)::(list_term_of_z_tm tml)
)
  | list_term_of_z_tm [] = [];
=TEX

\section{THE FUNCTION $do\_in\_theory$}

=SML
local
	open icl'Kernel;
	(****
	 ****	next line is a temporary get-around for a
	 ****	bug in labelled_product_spec. Will be
	 ****	removed when that bug has been fixed.
	 ****)
	val icl'open_theory = open_theory;
in
fun Ûdo_in_theoryÝ (caller:string) (f : 'a -> 'b) (arg : 'a) : 'b = (
let	val curr_theory = get_current_theory_name();
in
	let	val side = icl'open_theory (current_cache_theory());
		val result = f arg;
		val side = icl'open_theory curr_theory;
	in
		result
	end
	handle ex => (icl'open_theory curr_theory; reraise ex caller)
end);
end;
=TEX

\section{EPILOGUE}

=SML
end (* local ... in *);
end (* of structure ZTermGenerator *);
=TEX

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

