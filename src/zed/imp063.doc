% imp063.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Term Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP063}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the term generator for HOL/Z.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{92/03/19} ] Initial Draft.


\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the term generator for HOL/Z meeting the detailed design
given in \cite{DS/FMU/IED/DTD063}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD063}.
\subsection{Dependencies}
\subsection{Interface}
The structure $ZTermGenerator$ is constrained by the signature
$ZTermGenerator$ defined in \cite{DS/FMU/IED/DTD063}.
\subsection{Algorithms}
\subsection{Possible Enhancements}
None.
\subsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
structure €ZTermGenerator› : ZTermGenerator = struct
local
	open Unification ZUserInterfaceSupport ZTypeInference;
in
=TEX
=SML
fun €string_of_ident› ((t, d) : IDENT) : string = (
	string_of_template t ^ d
);
=TEX

\section{Updating the Database with Definitions}

=SML
fun €seta_sem_const› ((dec, pred, t) : (TERM * TERM * TERM)) : TERM = (
let	val res = mk_Zseta (dec, pred, t);
	val thm = seta_const_spec res;
in
	res
end);

fun €Ã_sem_const› ((dec, pred, t) : (TERM * TERM * TERM)) : TERM = (
let	val res = mk_ZÃ (dec, pred, t);
	val thm = Ã_const_spec res;
in
	res
end);
=TEX

\section{Generation of HOL Terms for Z Semantic Tree}

=SML
fun €term_of_zdec› (dec : Z_DEC) : TERM = (
	case dec of
	ZDec (idl, tm, Value ty) =>
		let	val set = term_of_ztm tm;
			val vars = map (fn id =>
				mk_Zlvar (string_of_ident id, type_of_zextype ty, [])) idl;
		in
			mk_Zdec (vars, set)
		end
	|ZDec (_, _, Nil) =>
		fail "term_of_zdec" 63000 []
	|ZSchemaDec (tm, _) =>
		mk_Zdecsexp (term_of_ztm tm, "")
)
=TEX
=SML
and €list_term_of_zdec› (decl : Z_DEC list) : TERM = (
	mk_Zdecl (map (fn zd => term_of_zdec zd) decl)
)
=TEX
=SML
and €term_of_zschtext› (sch as (dec, Value pred, Value ty) : Z_SCH_TEXT) : (TERM * TERM OPT) = (
	(list_term_of_zdec dec, Value (term_of_ztm pred))
) | term_of_zschtext (dec, _, _) = (
	(list_term_of_zdec dec, Nil)
) 
=TEX
=SML
and €term_of_ztm› (term : Z_TM) : TERM = (
let	fun aux (term as ZTmß¢ (Value ty, tml)) = (
	let	val elty = hd (tl (dest_ZtupleT (type_of_zextype ty)));
	in
		mk_Zß¢ (elty, list_term_of_ztm tml)
	end
	) | aux (ZTmß¢ (Nil, _)) = (
			fail "term_of_ztm" 63024 []
	) | aux (term as ZTmSetd (Value ty, tml)) = (
	let	val elty = type_of_zextype ty;
	in
		mk_Zsetd (elty, list_term_of_ztm tml)
	end
	) | aux (ZTmSetd (Nil, _)) = (
			fail "term_of_ztm" 63023 []
	) | aux (term as ZTmSeta1 sch) = (
		let	val (tm', ty') = make_chartuple sch;
			val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp => zp;
			val t = aux tm';
		in
			seta_sem_const (dec, pred, t)
		end
	) | aux (term as ZTmSeta2 (sch, tm)) = (
		let	val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp => zp;
			val t = aux tm;
		in
			seta_sem_const (dec, pred, t)
		end
	) | aux (term as ZTm tm) = (
		mk_Z (aux tm)
	) | aux (term as ZTmTuple tml) = (
		mk_Ztuple (list_term_of_ztm tml)
	) | aux (term as ZTm∏ tml) = (
		mk_Z∏ (list_term_of_ztm tml)
	) | aux (term as ZTm  (tm, d)) = (
		mk_Z  (aux tm, d)
	) | aux (term as ZTmSelâT (tm, i)) = (
		fail "term_of_ztm" 63901 [fn()=>"mk_ZselâT not yet implemented"]
	) | aux (term as ZTmSelâB (tm, id)) = (
		mk_Zsel (aux tm, string_of_ident id)
	) | aux (term as ZTmApp (tm1, tm2)) = (
		mk_Zapp (aux tm1, aux tm2)
	) | aux (term as ZTmFancyApp (id, tm)) = (
		fail "term_of_ztm" 63998 [fn()=>"ZTmFancyApp should not appear in type-inferred terms"]
=TEX
=SML
	) | aux (term as ZTmÃ (sch, tm)) = (
		let	val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp =>  zp;
			val t = aux tm;
		in
			Ã_sem_const (dec, pred, t)
		end
	) | aux (term as ZTmÕ1 sch) = (
		let	val (tm', ty') = make_chartuple sch;
			val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp => zp;
			val t = aux tm';
		in
			mk_ZÕ (dec, pred, t)
		end
	) | aux (term as ZTmÕ2 (sch, tm)) = (
		let	val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp => zp;
			val t = aux tm;
		in
			mk_ZÕ (dec, pred, t)
		end
	) | aux (term as ZTmTruth true) = (
		mk_Ztrue
	) | aux (term as ZTmTruth false) = (
		mk_Zfalse
	) | aux (term as ZTm≥âF tm) = (
		mk_Z≥ (aux tm)
	) | aux (term as ZTmLogInOpâF (inop, tm1, tm2)) = (
		let	val htm1 = aux tm1;
			val htm2 = aux tm2;
		in
			case inop of
			ZLogInOp± => mk_Z± (htm1, htm2)
			|ZLogInOp≤ => mk_Z≤ (htm1, htm2)
			|ZLogInOp¥ => mk_Z¥ (htm1, htm2)
			|ZLogInOp§ => mk_Z§ (htm1, htm2)
			|ZLogInOpSemi =>
				fail "term_of_ztm" 62901 [fn()=>"mk_Zsemi not yet implemented"]
		end
	) | aux (term as ZTmQuantâF (quant, sch, tm)) = (
		let	val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp => zp;
			val t = aux tm;
		in
			case quant of
			ZQuantµ => mk_Zµ (dec, pred, t)
			|ZQuant∂ => mk_Z∂ (dec, pred, t)
			|ZQuant∂â1 => mk_Z∂â1 (dec, pred, t)
		end
=TEX
=SML
	) | aux (term as ZTmSchemaPred tm) = (
		mk_Zpredsexp (aux tm, "")
	) | aux (term as ZTmHorizSchema sch) = (
		let	val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp => zp;
		in
			mk_Zâs (dec, pred)
		end
	) | aux (term as ZTmDecor (tm, d)) = (
		mk_Zdecâs (aux tm, d)
	) | aux (term as ZTmPre tm) = (
		mk_Zpreâs (aux tm)
	) | aux (term as ZTm≥âS tm) = (
		mk_Z≥âs (aux tm)
	) | aux (term as ZTmLogInOpâS (inop, tm1, tm2)) = (
		let	val htm1 = aux tm1;
			val htm2 = aux tm2;
		in
			case inop of
			ZLogInOp± => mk_Z±âs (htm1, htm2)
			|ZLogInOp≤ => mk_Z≤âs (htm1, htm2)
			|ZLogInOp¥ => mk_Z¥âs (htm1, htm2)
			|ZLogInOp§ => mk_Z§âs (htm1, htm2)
			|ZLogInOpSemi =>
				fail "term_of_ztm" 62901 [fn()=>"mk_Zsemi not yet implemented"]
		end
	) | aux (term as ZTm˘ (tm1, tm2)) = (
		mk_Z˘âs (aux tm1, aux tm2)
	) | aux (term as ZTmHide (tm, idl)) = (
		mk_Zhideâs (aux tm, map string_of_ident idl)
	) | aux (term as ZTmQuantâS (quant, sch, tm)) = (
		let	val (dec, opred) = term_of_zschtext sch;
			val pred = case opred of
				Nil => mk_Ztrue
				|Value zp => zp;
			val t = aux tm;
		in
			case quant of
			ZQuantµ => mk_Zµâs (dec, pred, t)
			|ZQuant∂ => mk_Z∂âs (dec, pred, t)
			|ZQuant∂â1 => mk_Z∂â1âs (dec, pred, t)
		end
=TEX
=SML
	) | aux (term as ZTmÑ tm) = (
		mk_ZÑâs (aux tm)
	) | aux (term as ZTmò tm) = (
		mk_Zòâs (aux tm)
	) | aux (term as ZTmEq (tm1, tm2)) = (
		mk_Zeq (aux tm1, aux tm2)
	) | aux (term as ZTmç (tm1, tm2)) = (
		mk_Zç (aux tm1, aux tm2)
	) | aux (term as ZTmª (tm1, tm2)) = (
		mk_Zªâs (aux tm1, aux tm2)
	) | aux (term as ZTmPipe (tm1, tm2)) = (
		fail "term_of_ztm" 63901 [fn()=>"mk_Zpipe not yet implemented"]
	) | aux (term as ZTm˙ i) = (
		mk_Zint (string_of_int i)
	) | aux (term as ZTmString s) = (
		fail "term_of_ztm" 63901 [fn()=>"mk_Zstring not yet implemented"]
	) | aux (term as ZTmConstrained (tm1, tm2)) = (
		aux tm1
	) | aux (term as ZTmLVar (id, Value ty, tml)) = (
		mk_Zlvar (string_of_ident id, type_of_zextype ty, list_term_of_ztm tml)
	) | aux (ZTmLVar (_, Nil, _)) = (
			fail "term_of_ztm" 63022 []
	) | aux (term as ZTmGVar (id, Value ty, tml)) = (
		mk_Zgvar (string_of_ident id, type_of_zextype ty, list_term_of_ztm tml)
	) | aux (ZTmGVar (_, Nil, _)) = (
		fail "term_of_ztm" 63021 []
	) | aux (term as ZTmLet _) = (
		fail "term_of_ztm" 63901 [fn()=>"mk_Zlet not yet implemented"]
	) | aux (term as ZTmRename _) = (
		fail "term_of_ztm" 63901 [fn()=>"mk_Zrename not yet implemented"]
	) | aux (term as ZTmBracketed tm) = (
		aux tm
	) | aux (term as ZTmQuotation htm) = (
		htm
	);
in
	aux term
end)
=TEX
=SML
and €list_term_of_ztm› ((tm::tml) : Z_TM list) : TERM list = (
	(term_of_ztm tm)::(list_term_of_ztm tml)
)
  | list_term_of_ztm [] = [];
=TEX

=SML
end (* local ... in *);
end (* of structure ZTermGenerator *);
=TEX

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

