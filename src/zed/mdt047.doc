=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Types and Terms}
\TPPref{DS/FMU/IED/MDT047}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{A set of module tests are given for the 
the constructors, destructors and discriminators of Z terms and types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First drafts.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the type and term constructors, destructors and discriminators for Z in ICL HOL.
The design is in \cite{DS/FMU/IED/DTD047}
and it is
implemented in \cite{DS/FMU/IED/IMP047
}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD047},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD047},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP047}.
It relies on a term pretty-printer being present to format
the results of error messages.
\subsubsection{Deficiencies}
None known.
\section{TEST CASES}
We test each function of the signature of \cite{DS/FMU/IED/DTD047}
in turn, where possible in the same order as in the design document,
except for those exceptions noted in section \ref{untested}.
\section{TEST HARNESS MATERIAL}
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
=TEX
\section{TEST DATA}
This section contains data used in the test, that
in themselves are not part of the tests.
However, they may fail if the functions tested are ill-formed.
=SML
=TEX
\section{THE TESTS}
\subsection{Name Destruction}
We check that the names of our internally generated constants, types etc. can be correctly analysed into basic name and component names.
=SML
store_mt_results mt_run [(
	"dest_Z_name 1",
	dest_Z_name,
	"Abcd",
	("Abcd",[])
	),(
	"dest_Z_name 2",
	dest_Z_name,
	"Abcd[]",
	("Abcd",[[]])
	),(
	"dest_Z_name 3",
	dest_Z_name,
	"Abcd[w]",
	("Abcd",[["w"]])
	),(
	"dest_Z_name 4",
	dest_Z_name,
	"Abcd[w,x,y,z]",
	("Abcd",[["w","x","y","z"]])
	),(
	"dest_Z_name 5",
	dest_Z_name,
	"Abcd[w,x,y,z][p,q,r]",
	("Abcd",[["w","x","y","z"],["p","q","r"]])
	),(
	"dest_Z_name 6",
	dest_Z_name,
	"Abcd[w,x,y,z][]",
	("Abcd",[["w","x","y","z"],[]])
	),(
	"dest_Z_name 7",
	dest_Z_name,
	"Abcd[][p,q,r]",
	("Abcd",[[],["p","q","r"]])
	)
];
=TEX
\subsection{Tests on Types}
We do not concern ourselves here with the internal representations of the Z types; we simply verify their expected properties.
\subsubsection{Given Types}
We first show that the function $is\_ZgivenT$ correctly discriminates.
=SML
store_mt_results mt_run [(
	"is_ZgivenT 1",
	is_ZgivenT,
	mk_ZgivenT "a",
	true
	),(
	"is_ZgivenT 2",
	is_ZgivenT,
	mk_ZvarT "a",
	false
	),(
	"is_ZgivenT 3",
	is_ZgivenT,
	mk_ZpowerT(mk_ZgivenT "a"),
	false
	),(
	"is_ZgivenT 4",
	is_ZgivenT,
	mk_ZtupleT[mk_ZgivenT "a"],
	false
	),(
	"is_ZgivenT 5",
	is_ZgivenT,
	mk_ZschemaT[("a",mk_ZgivenT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZgivenT$ is the inverse of $mk\_ZgivenT$.
=SML
store_mt_results mt_run [(
	"dest_ZgivenT 1",
	dest_ZgivenT,
	mk_ZgivenT "a",
	"a"
	)
];
=TEX
And that $dest\_ZgivenT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZgivenT f1",
	dest_ZgivenT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZgivenT" 47010 ["»:'a¼"]
	),(
	"dest_ZgivenT f2",
	dest_ZgivenT,
	mk_ZpowerT(mk_ZgivenT "a"),
	gen_fail_msg "dest_ZgivenT" 47010 ["»:a ‘¼"]
	),(
	"dest_ZgivenT f3",
	dest_ZgivenT,
	mk_ZtupleT[mk_ZgivenT "a"],
	gen_fail_msg "dest_ZgivenT" 47010 ["»:a Z'T[1]¼"]
	),(
	"dest_ZgivenT f4",
	dest_ZgivenT,
	mk_ZschemaT[("a",mk_ZgivenT "a")],
	gen_fail_msg "dest_ZgivenT" 47010 ["»:a Z'S[a]¼"]
	)
];
=TEX
\subsubsection{Type Variables}
This is similar to given types.
We first show that the function $is\_ZvarT$ correctly discriminates.
=SML
store_mt_results mt_run [(
	"is_ZvarT 1",
	is_ZvarT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZvarT 2",
	is_ZvarT,
	mk_ZvarT "a",
	true
	),(
	"is_ZvarT 3",
	is_ZvarT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
	"is_ZvarT 4",
	is_ZvarT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
	"is_ZvarT 5",
	is_ZvarT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZvarT$ is the inverse of $mk\_ZvarT$.
=SML
store_mt_results mt_run [(
	"dest_ZvarT 1",
	dest_ZvarT,
	mk_ZvarT "a",
	"a"
	)
];
=TEX
And that $dest\_ZvarT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZvarT f1",
	dest_ZvarT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZvarT" 47020 ["»:a¼"]
	),(
	"dest_ZvarT f2",
	dest_ZvarT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZvarT" 47020 ["»:'a ‘¼"]
	),(
	"dest_ZvarT f3",
	dest_ZvarT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZvarT" 47020 ["»:'a Z'T[1]¼"]
	),(
	"dest_ZvarT f4",
	dest_ZvarT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZvarT" 47020 ["»:'a Z'S[a]¼"]
	)
];
=TEX
\subsubsection{Set Types}
As before.
=SML
store_mt_results mt_run [(
	"is_ZpowerT 1",
	is_ZpowerT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZpowerT 2",
	is_ZpowerT,
	mk_ZvarT "a",
	false
	),(
	"is_ZpowerT 3",
	is_ZpowerT,
	mk_ZpowerT(mk_ZvarT "a"),
	true
	),(
	"is_ZpowerT 4",
	is_ZpowerT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
	"is_ZpowerT 5",
	is_ZpowerT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZpowerT$ is the inverse of $mk\_ZpowerT$.
=SML
store_mt_results mt_run [(
	"dest_ZpowerT 1",
	dest_ZpowerT,
	mk_ZpowerT(mk_ZvarT "a"),
	mk_ZvarT "a"
	)
];
=TEX
And that $dest\_ZpowerT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZpowerT f1",
	dest_ZpowerT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZpowerT" 47030 ["»:a¼"]
	),(
	"dest_ZpowerT f2",
	dest_ZpowerT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZpowerT" 47030 ["»:'a¼"]
	),(
	"dest_ZpowerT f3",
	dest_ZpowerT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZpowerT" 47030 ["»:'a Z'T[1]¼"]
	),(
	"dest_ZpowerT f4",
	dest_ZpowerT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZpowerT" 47030 ["»:'a Z'S[a]¼"]
	)
];
=TEX
\subsubsection{Tuple Types}
=SML
store_mt_results mt_run [(
	"is_ZtupleT 1",
	is_ZtupleT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZtupleT 2",
	is_ZtupleT,
	mk_ZvarT "a",
	false
	),(
	"is_ZtupleT 3",
	is_ZtupleT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
	"is_ZtupleT 4",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a"],
	true
	),(
	"is_ZtupleT 5",
	is_ZtupleT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	),(
	"is_ZtupleT 6",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZgivenT "b"],
	true
	),(
	"is_ZtupleT 7",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZgivenT "b",mk_ZpowerT(mk_ZvarT "c")],
	true
	)
];
=TEX
We now show that $dest\_ZtupleT$ is the inverse of $mk\_ZtupleT$.
=SML
store_mt_results mt_run [(
	"dest_ZtupleT 1",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a"],
	[mk_ZvarT "a"]
	),(
	"dest_ZtupleT 2",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZvarT "b"],
	[mk_ZvarT "a",mk_ZvarT "b"]
	),(
	"dest_ZtupleT 3",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "b",mk_ZvarT "a"],
	[mk_ZvarT "b",mk_ZvarT "a"]
	)
];
=TEX
And that $dest\_ZtupleT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZtupleT f1",
	dest_ZtupleT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZtupleT" 47040 ["»:a¼"]
	),(
	"dest_ZtupleT f2",
	dest_ZtupleT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZtupleT" 47040 ["»:'a¼"]
	),(
	"dest_ZtupleT f3",
	dest_ZtupleT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZtupleT" 47040 ["»:'a ‘¼"]
	),(
	"dest_ZtupleT f4",
	dest_ZtupleT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZtupleT" 47040 ["»:'a Z'S[a]¼"]
	)
];
=TEX
\subsubsection{Schema Types}
=SML
store_mt_results mt_run [(
	"is_ZschemaT 1",
	is_ZschemaT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZschemaT 2",
	is_ZschemaT,
	mk_ZvarT "a",
	false
	),(
	"is_ZschemaT 3",
	is_ZschemaT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
	"is_ZschemaT 4",
	is_ZschemaT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
	"is_ZschemaT 5",
	is_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	true
	),(
	"is_ZschemaT 6",
	is_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZgivenT "b")],
	true
	),(
	"is_ZschemaT 7",
	is_ZschemaT,
	mk_ZschemaT[	("a",mk_ZvarT "a"),
			("b",mk_ZgivenT "b"),
			("c",mk_ZpowerT(mk_ZvarT "c"))],
	true
	),(
	"is_ZschemaT 8",
	is_ZschemaT,
	mk_ZschemaT[],
	true
	)
];
=TEX
We now show that $dest\_ZschemaT$ is the inverse of $mk\_ZschemaT$.
Note that the order of the argument list for $mk\_ZschemaT$ is not significant and so we must be a little careful in generating expected values.
=SML
store_mt_results (mt_runf (op ListUtilities.set_eq)) [(
	"dest_ZschemaT 1",
	dest_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	[("a",mk_ZvarT "a")]
	),(
	"dest_ZschemaT 2",
	dest_ZschemaT,
	mk_ZschemaT[],
	[]
	),(
	"dest_ZschemaT 3",
	dest_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")],
	[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	),(
	"dest_ZschemaT 4",
	dest_ZschemaT,
	mk_ZschemaT[("b",mk_ZvarT "b"),("a",mk_ZvarT "a")],
	[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	)
];
=TEX
And that $dest\_ZschemaT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZschemaT f1",
	dest_ZschemaT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZschemaT" 47050 ["»:a¼"]
	),(
	"dest_ZschemaT f2",
	dest_ZschemaT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZschemaT" 47050 ["»:'a¼"]
	),(
	"dest_ZschemaT f3",
	dest_ZschemaT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZschemaT" 47050 ["»:'a ‘¼"]
	),(
	"dest_ZschemaT f4",
	dest_ZschemaT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZschemaT" 47050 ["»:'a Z'T[1]¼"]
	)
];
=TEX
Finally, we need to demonstrate the non-significance of ordering and the effect of duplicates in $mk\_ZschemaT$.
=SML
store_mt_results mt_run [(
	"mk_ZschemaT 1",
	mk_ZschemaT,
	[("b",mk_ZvarT "b"),("a",mk_ZvarT "a")],
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	),(
	"mk_ZschemaT 2",
	mk_ZschemaT,
	[("b",mk_ZvarT "b"),("a",mk_ZvarT "a"),("b",mk_ZvarT "b")],
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	)
];
=TEX
\subsubsection{The General Functions}
\subsection{Tests on Declarations}
\subsubsection{Simple Declarations}
=SML
local
val aty = mk_ZvarT "a";
val Aty = mk_ZpowerT aty;
val a = mk_Zlvar("a",aty,[]);
in
=TEX
=SML
store_mt_results mt_run [(
	"is_Zdec 1",
	is_

=TEX
=SML	
end (* of simple declaration tests *);
=TEX
\subsubsection{Schema Declarations}
\subsubsection{Declarations}
\subsection{Tests on Predicates}
\subsection{Tests on Terms}
\subsection{Tests on Schema Calculus}
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results ());
=TEX
\section{UNTESTED ERROR MESSAGES}
\label{untested}
\end{document}
