%  mdt047.doc  %Z% $Date$ $Revision$ $RCSfile$

doctex mdt047 ; texdvi mdt047
bibtex mdt047

=TEX
%  mdt047.doc  %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Types and Terms}
\TPPref{DS/FMU/IED/MDT047}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{A set of module tests are given for the 
the constructors, destructors and discriminators of Z terms and types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First drafts. Changed to accomodate change in the interface to dest\_z\_name.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the type and term constructors, destructors and discriminators for Z in ICL HOL.
The design is in \cite{DS/FMU/IED/DTD047}
and it is
implemented in \cite{DS/FMU/IED/IMP047}.

\subsection{Introduction}

\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD047},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

We test each function of the signature of \cite{DS/FMU/IED/DTD047}
in turn, where possible in the same order as in the design document,
except for those exceptions noted in section \ref{untested}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD047},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP047}.
It relies on a term pretty-printer being present to format
the results of error messages.

\subsubsection{Deficiencies}
None known.

\section{TEST HARNESS MATERIAL}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
=TEX
\section{UTILITIES}

We need to test various strange Standard~ML types for equality.

=SML
fun all_types_eq(l1:TYPE list, l2:TYPE list) : bool = (
	all	(map (op =:) (combine l1 l2))
		Combinators.I
);
=TEX

=SML
fun string_types_eq((s1, t1):string * TYPE, (s2, t2):string * TYPE) : bool = (
	s1 = s2 andalso t1 =: t2
);
=TEX

=SML
fun all_string_types_eq(l1:(string * TYPE) list, l2:(string * TYPE) list) : bool = (
	all	(map string_types_eq (combine l1 l2))
		Combinators.I
);
=TEX

\section{NAME DESTRUCTION TESTS}
We check that the names of our internally generated constants, types etc. can be correctly analysed into basic name and component names.
=SML
store_mt_results_show mt_run [(
"dest_z_name_1",
	dest_z_name,
	"Abcd",
	("Abcd",[], Nil)
	),(
"dest_z_name_2",
	dest_z_name,
	"Abcd[]",
	("Abcd",[[]], Nil)
	),(
"dest_z_name_3",
	dest_z_name,
	"Abcd[w]",
	("Abcd",[["w"]], Nil)
	),(
"dest_z_name_4",
	dest_z_name,
	"Abcd[w,x,y,z]",
	("Abcd",[["w","x","y","z"]], Nil)
	),(
"dest_z_name_5",
	dest_z_name,
	"Abcd[w,x,y,z][p,q,r]",
	("Abcd",[["w","x","y","z"],["p","q","r"]], Nil)
	),(
"dest_z_name_6",
	dest_z_name,
	"Abcd[w,x,y,z][]",
	("Abcd",[["w","x","y","z"],[]], Nil)
	),(
"dest_z_name_7",
	dest_z_name,
	"Abcd[][p,q,r]",
	("Abcd",[[],["p","q","r"]], Nil)
	),(
"dest_z_name_8",
	dest_z_name,
	"Abcd[efg]hij",
	("Abcd",[["efg"]], Value "hij")
	),(
"dest_z_name_9",
	dest_z_name,
	"Abcd[efg][hij]klm",
	("Abcd",[["efg"],["hij"]], Value "klm")
	)
];
=TEX

=SML
let
	fun fail_msg s = gen_fail_msg "dest_z_name" 47000 [s];
	fun test lab name = (lab, dest_z_name, name, fail_msg name);
in
store_mt_results_show mt_run_fail [
test "dest_z_name_f1" "Abcd][p,q,r]",
test "dest_z_name_f2" "Ab,cd[][p,q,r]",
test "dest_z_name_f3" "Abcd[[p,q,r]",
test "dest_z_name_f4" "Abcd[]p,q,r]",
test "dest_z_name_f5" "Abcd[],q,r]",
test "dest_z_name_f6" "Abcd[][p,q,r]x[",
test "dest_z_name_f7" "Abcd[]]p,q,r]",
test "dest_z_name_f8" "Abcd[][p,q,r]]"
]
end;
=TEX

\section{TESTS ON TYPES}
We do not concern ourselves here with the internal representations of the Z types; we simply verify their expected properties.
\subsection{Given Types}
We first show that the function $is\_z\_given\_t$ correctly discriminates.
=SML
store_mt_results_show mt_run [(
"is_z_given_t_1",
	is_z_given_t,
	mk_z_given_t "a",
	true
	),(
"is_z_given_t_2",
	is_z_given_t,
	mk_z_var_t "a",
	false
	),(
"is_z_given_t_3",
	is_z_given_t,
	mk_z_power_t(mk_z_given_t "a"),
	false
	),(
"is_z_given_t_4",
	is_z_given_t,
	mk_z_tuple_t[mk_z_given_t "a"],
	false
	),(
"is_z_given_t_5",
	is_z_given_t,
	mk_z_schema_t[("a",mk_z_given_t "a")],
	false
	)
];
=TEX
We now show that $dest\_z\_given\_t$ is the inverse of $mk\_z\_given\_t$.
=SML
store_mt_results_show mt_run [(
"dest_z_given_t_1",
	dest_z_given_t,
	mk_z_given_t "a",
	"a"
	)
];
=TEX
And that $dest\_z\_given\_t$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_z_given_t_f1",
	dest_z_given_t,
	mk_z_var_t "a",
	gen_fail_msg "dest_z_given_t" 47010 ["î'aÆ"]
	),(
"dest_z_given_t_f2",
	dest_z_given_t,
	mk_z_power_t(mk_z_given_t "a"),
	gen_fail_msg "dest_z_given_t" 47010 ["îa SETÆ"]
	),(
"dest_z_given_t_f3",
	dest_z_given_t,
	mk_z_tuple_t[mk_z_given_t "a"],
	gen_fail_msg "dest_z_given_t" 47010 ["îa $\"Z'T[1]\"Æ"]
	),(
"dest_z_given_t_f4",
	dest_z_given_t,
	mk_z_schema_t[("a",mk_z_given_t "a")],
	gen_fail_msg "dest_z_given_t" 47010 ["îa $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Type Variables}
This is similar to given types.
We first show that the function $is\_z\_var\_t$ correctly discriminates.
=SML
store_mt_results_show mt_run [(
"is_z_var_t_1",
	is_z_var_t,
	mk_z_given_t "a",
	false
	),(
"is_z_var_t_2",
	is_z_var_t,
	mk_z_var_t "a",
	true
	),(
"is_z_var_t_3",
	is_z_var_t,
	mk_z_power_t(mk_z_var_t "a"),
	false
	),(
"is_z_var_t_4",
	is_z_var_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	false
	),(
"is_z_var_t_5",
	is_z_var_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	false
	)
];
=TEX
We now show that $dest\_z\_var\_t$ is the inverse of $mk\_z\_var\_t$.
=SML
store_mt_results_show mt_run [(
"dest_z_var_t_1",
	dest_z_var_t,
	mk_z_var_t "a",
	"a"
	)
];
=TEX
And that $dest\_z\_var\_t$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_z_var_t_f1",
	dest_z_var_t,
	mk_z_given_t "a",
	gen_fail_msg "dest_z_var_t" 47020 ["îaÆ"]
	),(
"dest_z_var_t_f2",
	dest_z_var_t,
	mk_z_power_t(mk_z_var_t "a"),
	gen_fail_msg "dest_z_var_t" 47020 ["î'a SETÆ"]
	),(
"dest_z_var_t_f3",
	dest_z_var_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	gen_fail_msg "dest_z_var_t" 47020 ["î'a $\"Z'T[1]\"Æ"]
	),(
"dest_z_var_t_f4",
	dest_z_var_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	gen_fail_msg "dest_z_var_t" 47020 ["î'a $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Set Types}
As before.
=SML
store_mt_results_show mt_run [(
"is_z_power_t_1",
	is_z_power_t,
	mk_z_given_t "a",
	false
	),(
"is_z_power_t_2",
	is_z_power_t,
	mk_z_var_t "a",
	false
	),(
"is_z_power_t_3",
	is_z_power_t,
	mk_z_power_t(mk_z_var_t "a"),
	true
	),(
"is_z_power_t_4",
	is_z_power_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	false
	),(
"is_z_power_t_5",
	is_z_power_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	false
	)
];
=TEX
We now show that $dest\_z\_power\_t$ is the inverse of $mk\_z\_power\_t$.
=SML
store_mt_results_show (mt_runf (op =:)) [(
"dest_z_power_t_1",
	dest_z_power_t,
	mk_z_power_t(mk_z_var_t "a"),
	mk_z_var_t "a"
	)
];
=TEX
And that $dest\_z\_power\_t$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_z_power_t_f1",
	dest_z_power_t,
	mk_z_given_t "a",
	gen_fail_msg "dest_z_power_t" 47030 ["îaÆ"]
	),(
"dest_z_power_t_f2",
	dest_z_power_t,
	mk_z_var_t "a",
	gen_fail_msg "dest_z_power_t" 47030 ["î'aÆ"]
	),(
"dest_z_power_t_f3",
	dest_z_power_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	gen_fail_msg "dest_z_power_t" 47030 ["î'a $\"Z'T[1]\"Æ"]
	),(
"dest_z_power_t_f4",
	dest_z_power_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	gen_fail_msg "dest_z_power_t" 47030 ["î'a $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Tuple Types}
=SML
store_mt_results_show mt_run [(
"is_z_tuple_t_1",
	is_z_tuple_t,
	mk_z_given_t "a",
	false
	),(
"is_z_tuple_t_2",
	is_z_tuple_t,
	mk_z_var_t "a",
	false
	),(
"is_z_tuple_t_3",
	is_z_tuple_t,
	mk_z_power_t(mk_z_var_t "a"),
	false
	),(
"is_z_tuple_t_4",
	is_z_tuple_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	true
	),(
"is_z_tuple_t_5",
	is_z_tuple_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	false
	),(
"is_z_tuple_t_6",
	is_z_tuple_t,
	mk_z_tuple_t[mk_z_var_t "a",mk_z_given_t "b"],
	true
	),(
"is_z_tuple_t_7",
	is_z_tuple_t,
	mk_z_tuple_t[mk_z_var_t "a",mk_z_given_t "b",mk_z_power_t(mk_z_var_t "c")],
	true
	)
];
=TEX
We now show that $dest\_z\_tuple\_t$ is the inverse of $mk\_z\_tuple\_t$.
=SML
store_mt_results_show (mt_runf all_types_eq) [(
"dest_z_tuple_t_1",
	dest_z_tuple_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	[mk_z_var_t "a"]
	)];
=TEX
=SML
store_mt_results_show (mt_runf all_types_eq) [(
"dest_z_tuple_t_2",
	dest_z_tuple_t,
	mk_z_tuple_t[mk_z_var_t "a",mk_z_var_t "b"],
	[mk_z_var_t "a",mk_z_var_t "b"]
	)];
=TEX
=SML
store_mt_results_show (mt_runf all_types_eq) [(
"dest_z_tuple_t_3",
	dest_z_tuple_t,
	mk_z_tuple_t[mk_z_var_t "b",mk_z_var_t "a"],
	[mk_z_var_t "b",mk_z_var_t "a"]
	)
];
=TEX
And that $dest\_z\_tuple\_t$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_z_tuple_t_f1",
	dest_z_tuple_t,
	mk_z_given_t "a",
	gen_fail_msg "dest_z_tuple_t" 47040 ["îaÆ"]
	),(
"dest_z_tuple_t_f2",
	dest_z_tuple_t,
	mk_z_var_t "a",
	gen_fail_msg "dest_z_tuple_t" 47040 ["î'aÆ"]
	),(
"dest_z_tuple_t_f3",
	dest_z_tuple_t,
	mk_z_power_t(mk_z_var_t "a"),
	gen_fail_msg "dest_z_tuple_t" 47040 ["î'a SETÆ"]
	),(
"dest_z_tuple_t_f4",
	dest_z_tuple_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	gen_fail_msg "dest_z_tuple_t" 47040 ["î'a $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Schema Types}
=SML
store_mt_results_show mt_run [(
"is_z_schema_t_1",
	is_z_schema_t,
	mk_z_given_t "a",
	false
	),(
"is_z_schema_t_2",
	is_z_schema_t,
	mk_z_var_t "a",
	false
	),(
"is_z_schema_t_3",
	is_z_schema_t,
	mk_z_power_t(mk_z_var_t "a"),
	false
	),(
"is_z_schema_t_4",
	is_z_schema_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	false
	),(
"is_z_schema_t_5",
	is_z_schema_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	true
	),(
"is_z_schema_t_6",
	is_z_schema_t,
	mk_z_schema_t[("a",mk_z_var_t "a"),("b",mk_z_given_t "b")],
	true
	),(
"is_z_schema_t_7",
	is_z_schema_t,
	mk_z_schema_t[	("a",mk_z_var_t "a"),
			("b",mk_z_given_t "b"),
			("c",mk_z_power_t(mk_z_var_t "c"))],
	true
	),(
"is_z_schema_t_8",
	is_z_schema_t,
	mk_z_schema_t[],
	true
	)
];
=TEX
We now show that $dest\_z\_schema\_t$ is the inverse of $mk\_z\_schema\_t$.
Note that the order of the argument list for $mk\_z\_schema\_t$ is not significant and so we must be a little careful in generating expected values.
=SML
store_mt_results_show (mt_runf all_string_types_eq) [(
"dest_z_schema_t_1",
	dest_z_schema_t,
	mk_z_schema_t[("a",mk_z_var_t "a")],
	[("a",mk_z_var_t "a")]
	),(
"dest_z_schema_t_2",
	dest_z_schema_t,
	mk_z_schema_t[],
	[]
	),(
"dest_z_schema_t_3",
	dest_z_schema_t,
	mk_z_schema_t[("a",mk_z_var_t "a"),("b",mk_z_var_t "b")],
	[("a",mk_z_var_t "a"),("b",mk_z_var_t "b")]
	),(
"dest_z_schema_t_4",
	dest_z_schema_t,
	mk_z_schema_t[("b",mk_z_var_t "b"),("a",mk_z_var_t "a")],
	[("a",mk_z_var_t "a"),("b",mk_z_var_t "b")]
	)
];
=TEX
And that $dest\_z\_schema\_t$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_z_schema_t_f1",
	dest_z_schema_t,
	mk_z_given_t "a",
	gen_fail_msg "dest_z_schema_t" 47050 ["îaÆ"]
	),(
"dest_z_schema_t_f2",
	dest_z_schema_t,
	mk_z_var_t "a",
	gen_fail_msg "dest_z_schema_t" 47050 ["î'aÆ"]
	),(
"dest_z_schema_t_f3",
	dest_z_schema_t,
	mk_z_power_t(mk_z_var_t "a"),
	gen_fail_msg "dest_z_schema_t" 47050 ["î'a SETÆ"]
	),(
"dest_z_schema_t_f4",
	dest_z_schema_t,
	mk_z_tuple_t[mk_z_var_t "a"],
	gen_fail_msg "dest_z_schema_t" 47050 ["î'a $\"Z'T[1]\"Æ"]
	)
];
=TEX
Finally, we need to demonstrate the non-significance of ordering and the effect of duplicates in $mk\_z\_schema\_t$.
=SML
store_mt_results_show (mt_runf (op =:)) [(
"mk_z_schema_t_1",
	mk_z_schema_t,
	[("b",mk_z_var_t "b"),("a",mk_z_var_t "a")],
	mk_z_schema_t[("a",mk_z_var_t "a"),("b",mk_z_var_t "b")]
	),(
"mk_z_schema_t_2",
	mk_z_schema_t,
	[("b",mk_z_var_t "b"),("a",mk_z_var_t "a"),("b",mk_z_var_t "b")],
	mk_z_schema_t[("a",mk_z_var_t "a"),("b",mk_z_var_t "b")]
	)
];
=TEX
\subsection{The General Functions}
\section{TESTS ON TERMS}
A list of test cases is created in $terms$ which is built up
during much of the rest of this document.
We begin by initialising the test case list and defining the functions $add\_term$ (for adding test cases) and $t$ (which allows us to build terms using previously defined terms in the list).
Elements are pushed onto the list, function~$t$ retrieves entries counting
from the head, where the head element is number~1.
=SML
val terms :(string * int * TERM) list ref = ref [];

fun add_term (nam, z_tm) = (
	let
		val zt = mk_z_TERM z_tm;
	in
		terms := (nam,length(!terms), zt) :: (!terms);
		("add_term: " ^ nam)
	end
);

fun t n = (
	let 	fun aux m nil = mk_var("no_term", BOOL)
		| aux m ((_, _, tm) :: more) =
			if m <= 1
			then tm
			else aux (m-1) more
	in
		aux n (!terms)
	end
);
=TEX
The following function tests that all the terms in the test case list are correctly discriminated by all the discriminator functions.
=SML
local
	fun build_test(nam1,func) (nam2,n,tm) = (
		"disc__" ^ nam1 ^ "__" ^ nam2 ^ "__" ^ (string_of_int n),
		func,
		tm,
		(nam1 = nam2)
	);

	fun aux tml ff = (
		store_mt_results mt_run (map (build_test ff) tml)
	);

	fun auxM tml ff = (
		map (build_test ff) tml
	);
in
	fun make_discriminator_tests (ffl:(string * (TERM -> bool)) list) tml = (
		flat(map (auxM tml) ffl)
	);

	fun run_discriminator_tests (ffl:(string * (TERM -> bool)) list) tml = (
		map (aux tml) ffl;
		()
	);
end;
=TEX
The discriminator functions follow:
=SML
val	discriminator_functions = [
		("Zdec",is_z_dec),
		("Zdecsexp",is_z_decsexp),
		("Zdecl",is_z_decl),
                ("Zeq",is_z_eq),
                ("Zç",is_z_ç),
                ("Ztrue",is_z_true),
                ("Zfalse",is_z_false),
                ("Z≥",is_z_≥),
                ("Z±",is_z_±),
                ("Z≤",is_z_≤),
                ("Z¥",is_z_¥),
                ("Z§",is_z_§),
                ("Z∂",is_z_∂),
                ("Z∂â1",is_z_∂â1),
                ("Zµ",is_z_µ),
                ("Zpredsexp",is_z_predsexp),
                ("Zlvar",is_z_lvar),
                ("Zgvar",is_z_gvar),
                ("Zint",is_z_int),
                ("Zß¢",is_z_ß¢),
                ("Zsetd",is_z_setd),
                ("Zseta",is_z_seta),
                ("Z",is_z_),
                ("ZT",is_z_tuple),
                ("Z∏",is_z_∏),
                ("Z ",is_z_ ),
                ("Zsel",is_z_sel),
                ("Zapp",is_z_app),
                ("ZÃ",is_z_Ã),
                ("ZÕ",is_z_Õ),
                ("Zâs",is_z_âs),
                ("Zdecâs",is_z_decâs),
                ("Zpreâs",is_z_preâs),
                ("Z≥âs",is_z_≥âs),
                ("Z±âs",is_z_±âs),
                ("Z≤âs",is_z_≤âs),
                ("Z¥âs",is_z_¥âs),
                ("Z§âs",is_z_§âs),
                ("Z˘âs",is_z_˘âs),
                ("Zhideâs",is_z_hideâs),
                ("Z∂âs",is_z_∂âs),
                ("Z∂â1âs",is_z_∂â1âs),
                ("Zµâs",is_z_µâs),
                ("ZÑâs",is_z_Ñâs),
                ("Zòâs",is_z_òâs),
                ("Zªâs",is_z_ªâs)
	];
=TEX
Next we define a function to show that all test cases behave correctly with the function $dest\_z\_term$.
=SML
local
	fun build_test(nam,n,tm) = (
		"dest__" ^ nam ^ "__" ^ (string_of_int n),
		mk_z_TERM o dest_z_term,
		tm,
		tm
	);
in
	fun run_destructor_tests (tml:(string * int * TERM) list) = (
		store_mt_results (mt_runf (op =$)) (map build_test tml)
	);
end;
=TEX
\subsection{Tests on Declarations}
We begin by defining a few variables and given sets, which will be frequently used throughout the tests.
=SML
val vara = mk_z_lvar("a",mk_z_given_t "R",[]);
val varb = mk_z_lvar("b",mk_z_given_t "R",[]);
val varc = mk_z_lvar("c",mk_z_given_t "R",[]);
val vard = mk_z_lvar("d",mk_z_given_t "S",[]);
val vare = mk_z_lvar("e",mk_z_given_t "S",[]);
val varf = mk_z_lvar("f",mk_z_given_t "S",[]);
val conR = mk_z_gvar("R",mk_z_power_t(mk_z_given_t "R"),[]);
val conS = mk_z_gvar("S",mk_z_power_t(mk_z_given_t "S"),[]);
=TEX
=SML
add_term("Zdec",Zdec([varb,varc],conR));
add_term("Zdec",Zdec([varf],conS));
=TEX
We save these declarations for use later.
=SML
val decbc = t 2;
val decf = t 1;
val deca = mk_z_dec([vara],conR);
val decde = mk_z_dec([vare,vard],conS);
val decab = mk_z_dec([vara,varb],conR);
val decabc = mk_z_dec([varc,varb,vara],conR);
val decdef = mk_z_dec([vare,vard,varf],conS);
=TEX
Now we use the above to make a compound declaration and use this to make a schema, which can then be used to test schema declaration.
=SML
add_term("Zdecl",Zdecl[decf,decbc]);
add_term("Zâs",Zâs(t 1, mk_z_true));
add_term("Zdecsexp",Zdecsexp(t 1,""));
add_term("Zdecsexp",Zdecsexp(t 2,"'"));
add_term("Zdecsexp",Zdecsexp(t 3,"!"));
add_term("Zdecsexp",Zdecsexp(t 4,"?"));
=TEX
Again, a schema and schema declaration will be useful.
=SML
val schbcf = t 5;
val decsexpbcf = t 4;
=TEX
Finally we can make a compound declaration from both types.
=SML
add_term("Zdecl",Zdecl[decde,decsexpbcf,deca]);
=TEX
\subsection{Tests on Terms}
\subsubsection{Global and Local Variables}
We begin this section by making some variables (global and local, generic and non-generic).
=SML
add_term("Zgvar",Zgvar("a",mk_z_var_t "A",[]));
add_term("Zgvar",Zgvar("ag",mk_z_given_t "AG",[t 1]));
add_term("Zlvar",Zlvar("ag",mk_z_given_t "AG",[t 2]));
add_term("Zlvar",Zlvar("a",mk_z_given_t "A",[]));
add_term("Zlvar",Zlvar("b",mk_z_given_t "A",[]));
add_term("Zlvar",Zlvar("c",mk_z_given_t "A",[]));
=TEX
\subsubsection{Integers}
=SML
add_term("Zint",Zint "0");
add_term("Zint",Zint "20");
=TEX
\subsubsection{Finite Sequence Display}
=SML
add_term("Zß¢",Zß¢(mk_z_given_t "R",[]));
add_term("Zß¢",Zß¢(mk_z_given_t "R",[vara]));
add_term("Zß¢",Zß¢(mk_z_given_t "R",[varc,vara,varb]));
=TEX
\subsubsection{Finite Set Display}
In the following tests, we use set membership to check that constructed terms are correctly typed.
Sets will be needed again, so we save the following cases:
=SML
add_term("Zsetd",Zsetd(mk_z_given_t "R",[]));
add_term("Zç",Zç(vara,t 1));
val setd = t 2;
add_term("Zsetd",Zsetd(mk_z_given_t "S",[vard]));
add_term("Zç",Zç(vard,t 1));
val setdd = t 2;
add_term("Zsetd",Zsetd(mk_z_given_t "R",[varc,vara,varb]));
add_term("Zç",Zç(vara,t 1));
val setdabc = t 2;
=TEX
\subsubsection{Set Abstraction}
Again we save the set abstraction for later.
=SML
add_term("Zdecl",Zdecl[decde,decsexpbcf]);
add_term("Zseta",Zseta(t 1,mk_z_true,varc));
add_term("Zç",Zç(vara,t 1));
val seta = t 2;
=TEX
\subsubsection{Power Set}
The first test uses the set abstraction generated in the previous section.
=SML
add_term("Z",Z(seta));
add_term("Zç",Zç(seta,t 1));
add_term("Z",Z(setdabc));
add_term("Zç",Zç(seta,t 1));
=TEX
\subsubsection{Tuple}
The first test uses the three terms generated in the previous sections to form a 3-tuple.
We also check that unit tuples work (since they are used internally by the mapping; they are not allowed in Z).
=SML
add_term("ZT",Ztuple[t 1,t 2,t 3]);
add_term("ZT",Ztuple[vara]);
=TEX
\subsubsection{Cartesian Product}
=SML
add_term("Z∏",Z∏[setd,setdd,setdabc,seta]);
add_term("Zç",Zç(mk_z_tuple[vara,vard,vara,vara],t 1));
=TEX
\subsubsection{Theta}
=SML
add_term("Z ",Z (schbcf,""));
add_term("Zç",Zç(t 1,schbcf));
add_term("Z ",Z (schbcf,"'"));
add_term("Zç",Zç(t 1,schbcf));
add_term("Z ",Z (schbcf,"!"));
add_term("Zç",Zç(t 1,schbcf));
add_term("Z ",Z (schbcf,"?"));
add_term("Zç",Zç(t 1,schbcf));
=TEX
\subsubsection{Selection}
We use the binding generated in the previous section to test selection.
=SML
add_term("Zsel",Zsel(t 2,"c"));
add_term("Zeq",Zeq(t 1,vara));
=TEX
\subsubsection{Function Application}
=SML
add_term("Zapp",Zapp(mk_z_∏[seta,setdd],vara));
add_term("Zeq",Zeq(t 1,vard));
=TEX
\subsubsection{Lambda Abstraction}
=SML
add_term("ZÃ",ZÃ(mk_z_decl[deca],mk_z_true,vara));
add_term("Zç",Zç(mk_z_tuple[vara,vara],t 1));
add_term("ZÃ",ZÃ(mk_z_decl[decbc],mk_z_true,varb));
add_term("Zç",Zç(mk_z_tuple[mk_z_tuple[varb,varc],varb],t 1));
add_term("ZÃ",ZÃ(mk_z_decl[decsexpbcf],mk_z_true,varf));
add_term("Zç",Zç(mk_z_tuple[mk_z_ (schbcf,""),varf],t 1));
add_term("ZÃ",ZÃ(mk_z_decl[decde,decsexpbcf,deca],mk_z_true,varf));
add_term("Zç",Zç(mk_z_tuple[mk_z_tuple[vard,vare,mk_z_ (schbcf,""),vara],varf],t 1));
=TEX
\subsubsection{Definite Description}
=SML
add_term("ZÕ",ZÕ(mk_z_decl[deca],mk_z_true,vara));
add_term("Zeq",Zeq(vara,t 1));
add_term("ZÕ",ZÕ(mk_z_decl[decbc],mk_z_true,varb));
add_term("Zeq",Zeq(varb,t 1));
add_term("ZÕ",ZÕ(mk_z_decl[decsexpbcf],mk_z_true,varf));
add_term("Zeq",Zeq(varf,t 1));
add_term("ZÕ",ZÕ(mk_z_decl[decde,decsexpbcf,deca],mk_z_true,varf));
add_term("Zeq",Zeq(varf,t 1));
=TEX
\subsection{Tests on Predicates}
\subsubsection{Equality}
There are lots of tests of equality elsewhere.
\subsubsection{Set Membership}
There are lots of tests of set membership elsewhere.
\subsubsection{True and False}
=SML
add_term("Ztrue",Ztrue);
add_term("Zfalse",Zfalse);
=TEX
\subsubsection{Logical Connectives}
=SML
add_term("Z≥",Z≥ mk_z_true);
add_term("Z±",Z±(mk_z_true,mk_z_true));
add_term("Z≤",Z≤(mk_z_true,mk_z_true));
add_term("Z¥",Z¥(mk_z_true,mk_z_true));
add_term("Z§",Z§(mk_z_true,mk_z_true));
=TEX
\subsubsection{Quantification}
=SML
add_term("Z∂",Z∂(mk_z_decl[deca],mk_z_true,mk_z_true));
add_term("Z∂",Z∂(mk_z_decl[decsexpbcf,deca],mk_z_eq(vara,varb),mk_z_eq(varc,varb)));
add_term("Z∂â1",Z∂â1(mk_z_decl[deca],mk_z_true,mk_z_true));
add_term("Z∂â1",Z∂â1(mk_z_decl[decsexpbcf,deca],mk_z_eq(vara,varb),mk_z_eq(varc,varb)));
add_term("Zµ",Zµ(mk_z_decl[deca],mk_z_true,mk_z_true));
add_term("Zµ",Zµ(mk_z_decl[decsexpbcf,deca],mk_z_eq(vara,varb),mk_z_eq(varc,varb)));
=TEX
\subsubsection{Schema as Predicate}
=SML
add_term("Zpredsexp",Zpredsexp(schbcf,""));
add_term("Zpredsexp",Zpredsexp(schbcf,"'"));
add_term("Z±",Z±(t 1,t 2));
add_term("Zpredsexp",Zpredsexp(schbcf,"?"));
add_term("Zpredsexp",Zpredsexp(schbcf,"!"));
add_term("Z±",Z±(t 1,t 2));
=TEX
\subsection{Tests on Schema Operations}
\subsubsection{Schema Construction}
In the schema constructor tests, we make two schemas of the same type in different ways and use the equality constructor to show that they are indeed of the same type.
A few other schemas are constructed and saved for later.
=SML
add_term("Zâs",Zâs(mk_z_decl[decde,decsexpbcf,deca],mk_z_true));
add_term("Zâs",Zâs(mk_z_decl[decabc,decdef],mk_z_eq(vara,varc)));
add_term("Zeq",Zeq(t 1,t 2));
val schabcdef1 = t 3;
val schabcdef2 = t 2;
add_term("Zâs",Zâs(mk_z_decl[deca],mk_z_true));
val scha = t 1;
add_term("Zâs",Zâs(mk_z_decl[decab],mk_z_true));
val schab = t 1;
add_term("Zâs",Zâs(mk_z_decl[decabc],mk_z_true));
val schabc = t 1;
add_term("Zâs",Zâs(mk_z_decl[decbc],mk_z_eq(varb,varc)));
val schbc = t 1;
add_term("Zâs",Zâs(mk_z_decl[decf],mk_z_true));
val schf = t 1;
add_term("Zâs",Zâs(mk_z_decl[decde],mk_z_eq(vare,vard)));
val schde = t 1;
=TEX
\subsubsection{Decoration}
In the tests for schema decoration, we show that component types are preserved.
=SML
add_term("Zdecâs",Zdecâs(scha,""));
add_term("Zdecâs",Zdecâs(scha,"!"));
add_term("Zdecâs",Zdecâs(scha,"?"));
add_term("Zdecâs",Zdecâs(scha,"'"));
add_term("Zeq",Zeq(mk_z_sel(mk_z_ (scha,""),"a"),mk_z_sel(mk_z_ (t 1,""),"a'")));
add_term("Zdecâs",Zdecâs(schabcdef1,"?"));
add_term("Zeq",Zeq(mk_z_sel(mk_z_ (schabcdef1,""),"a"),mk_z_sel(mk_z_ (t 1,""),"a?")));
add_term("Zeq",Zeq(mk_z_sel(mk_z_ (schabcdef1,""),"a"),mk_z_sel(mk_z_ (t 2,""),"b?")));
add_term("Zeq",Zeq(mk_z_sel(mk_z_ (schabcdef1,""),"f"),mk_z_sel(mk_z_ (t 3,""),"d?")));
=TEX
\subsubsection{Precondition}
=SML
add_term("Zdecsexp",Zdecsexp(scha,""));
add_term("Zdecsexp",Zdecsexp(schbc,"'"));
add_term("Zdecsexp",Zdecsexp(schf,"!"));
add_term("Zdecsexp",Zdecsexp(schde,"?"));
add_term("Zâs",Zâs(mk_z_decl[t 1,t 2,t 3,t 4],mk_z_true));
add_term("Zpreâs",Zpreâs(t 1));
add_term("Zeq",Zeq(t 1,mk_z_âs(mk_z_decl[t 3,t 6],mk_z_true)));
add_term("Zâs",Zâs(mk_z_decl[t 7,t 4],mk_z_true));
add_term("Zpreâs",Zpreâs(t 1));
add_term("Zeq",Zeq(t 1,t 2));
add_term("Zâs",Zâs(mk_z_decl[t 8,t 9],mk_z_true));
add_term("Zpreâs",Zpreâs(t 1));
add_term("Zeq",Zeq(t 1,mk_z_lvar("x",mk_z_power_t(mk_z_schema_t []),[])));
=TEX
\subsubsection{Negation}
=SML
add_term("Z≥âs",Z≥âs scha);
add_term("Zeq",Zeq(scha,t 1));
add_term("Z≥âs",Z≥âs schbc);
add_term("Zeq",Zeq(schbc,t 1));
=TEX
\subsubsection{Conjunction}
=SML
add_term("Z±âs",Z±âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z±âs",Z±âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Disjunction}
=SML
add_term("Z≤âs",Z≤âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z≤âs",Z≤âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Implication}
=SML
add_term("Z¥âs",Z¥âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z¥âs",Z¥âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Equivalence}
=SML
add_term("Z§âs",Z§âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z§âs",Z§âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Projection}
=SML
add_term("Z˘âs",Z˘âs(schab,schbc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z˘âs",Z˘âs(schabc,schbc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z˘âs",Z˘âs(schabc,scha));
add_term("Zeq",Zeq(scha,t 1));
=TEX
\subsubsection{Hiding}
=SML
add_term("Zhideâs",Zhideâs(schabc,["a"]));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zhideâs",Zhideâs(schabc,["b","c"]));
add_term("Zeq",Zeq(scha,t 1));
add_term("Zhideâs",Zhideâs(schabc,["a","b","c"]));
add_term("Zeq",Zeq(mk_z_lvar("x",mk_z_power_t(mk_z_schema_t []),[]),t 1));
add_term("Zhideâs",Zhideâs(schabc,["a","b","c","d"]));
add_term("Zç",Zç(mk_z_lvar("x",mk_z_schema_t [],[]),t 1));
=TEX
\subsubsection{Existential Quantification}
=SML
add_term("Z∂âs",Z∂âs(mk_z_decl[deca],mk_z_true,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z∂âs",Z∂âs(mk_z_decl[decbc],mk_z_true,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Z∂âs",Z∂âs(mk_z_decl[decbc,deca],mk_z_true,schabc));
add_term("Zç",Zç(mk_z_lvar("x",mk_z_schema_t [],[]),t 1));
=TEX
\subsubsection{Unique Existential Quantification}
=SML
add_term("Z∂â1âs",Z∂â1âs(mk_z_decl[deca],mk_z_true,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z∂â1âs",Z∂â1âs(mk_z_decl[decbc],mk_z_true,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Z∂â1âs",Z∂â1âs(mk_z_decl[decbc,deca],mk_z_true,schabc));
add_term("Zç",Zç(mk_z_lvar("x",mk_z_schema_t [],[]),t 1));
=TEX
\subsubsection{Universal Quantification}
=SML
add_term("Zµâs",Zµâs(mk_z_decl[deca],mk_z_true,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zµâs",Zµâs(mk_z_decl[decbc],mk_z_true,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Zµâs",Zµâs(mk_z_decl[decbc,deca],mk_z_true,schabc));
add_term("Zç",Zç(mk_z_lvar("x",mk_z_schema_t [],[]),t 1));
=TEX
\subsubsection{Sequential Composition}
=SML
add_term("Zdecsexp",Zdecsexp(scha,""));
add_term("Zdecsexp",Zdecsexp(schde,"'"));
add_term("Zdecsexp",Zdecsexp(schde,""));
add_term("Zdecsexp",Zdecsexp(schbc,"'"));
add_term("Zâs",Zâs(mk_z_decl[t 3,t 4],mk_z_true));
add_term("Zâs",Zâs(mk_z_decl[t 2,t 3],mk_z_true));
add_term("Zªâs",Zªâs(t 2,t 1));
add_term("Zeq",Zeq(mk_z_âs(mk_z_decl[t 4,t 7],mk_z_true),t 1));
=TEX
\subsection{Run Tests}
=SML
(* Some statistics *)
("Number of discriminator functions",	length discriminator_functions);
("Number of terms",			length(!terms));
("Number of discriminator tests",	(length discriminator_functions)
					* (length(!terms)));
("Number of destructor tests",		length(!terms));

run_discriminator_tests discriminator_functions (!terms);
run_destructor_tests (!terms);
=TEX
\section{END OF TESTS}
=SML
"End of tests";
diag_string(summarize_mt_results ());
=TEX
\section{UNTESTED ERROR MESSAGES}
\label{untested}
\end{document}


