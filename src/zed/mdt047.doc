%  mdt047.doc  %Z% $Date$ $Revision$ $RCSfile$

doctex mdt047 ; texdvi mdt047
bibtex mdt047

=TEX
%  mdt047.doc  %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Types and Terms}
\TPPref{DS/FMU/IED/MDT047}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{A set of module tests are given for the 
the constructors, destructors and discriminators of Z terms and types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First drafts.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the type and term constructors, destructors and discriminators for Z in ICL HOL.
The design is in \cite{DS/FMU/IED/DTD047}
and it is
implemented in \cite{DS/FMU/IED/IMP047}.

\subsection{Introduction}

\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD047},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

We test each function of the signature of \cite{DS/FMU/IED/DTD047}
in turn, where possible in the same order as in the design document,
except for those exceptions noted in section \ref{untested}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD047},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP047}.
It relies on a term pretty-printer being present to format
the results of error messages.

\subsubsection{Deficiencies}
None known.

\section{TEST HARNESS MATERIAL}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
=TEX
\section{UTILITIES}

We need to test various strange Standard~ML types for equality.

=SML
fun all_types_eq(l1:TYPE list, l2:TYPE list) : bool = (
	all	(map (op =:) (combine l1 l2))
		Combinators.I
);
=TEX

=SML
fun string_types_eq((s1, t1):string * TYPE, (s2, t2):string * TYPE) : bool = (
	s1 = s2 andalso t1 =: t2
);
=TEX

=SML
fun all_string_types_eq(l1:(string * TYPE) list, l2:(string * TYPE) list) : bool = (
	all	(map string_types_eq (combine l1 l2))
		Combinators.I
);
=TEX

\section{NAME DESTRUCTION TESTS}
We check that the names of our internally generated constants, types etc. can be correctly analysed into basic name and component names.
=SML
store_mt_results_show mt_run [(
"dest_Z_name_1",
	dest_Z_name,
	"Abcd",
	("Abcd",[])
	),(
"dest_Z_name_2",
	dest_Z_name,
	"Abcd[]",
	("Abcd",[[]])
	),(
"dest_Z_name_3",
	dest_Z_name,
	"Abcd[w]",
	("Abcd",[["w"]])
	),(
"dest_Z_name_4",
	dest_Z_name,
	"Abcd[w,x,y,z]",
	("Abcd",[["w","x","y","z"]])
	),(
"dest_Z_name_5",
	dest_Z_name,
	"Abcd[w,x,y,z][p,q,r]",
	("Abcd",[["w","x","y","z"],["p","q","r"]])
	),(
"dest_Z_name_6",
	dest_Z_name,
	"Abcd[w,x,y,z][]",
	("Abcd",[["w","x","y","z"],[]])
	),(
"dest_Z_name_7",
	dest_Z_name,
	"Abcd[][p,q,r]",
	("Abcd",[[],["p","q","r"]])
	)
];
=TEX

=SML
let
	fun fail_msg s = gen_fail_msg "dest_Z_name" 47000 [s];
	fun test lab name = (lab, dest_Z_name, name, fail_msg name);
in
store_mt_results_show mt_run_fail [
test "dest_Z_name_f1" "Abcd][p,q,r]",
test "dest_Z_name_f2" "Ab,cd[][p,q,r]",
test "dest_Z_name_f3" "Abcd[[p,q,r]",
test "dest_Z_name_f4" "Abcd[]p,q,r]",
test "dest_Z_name_f5" "Abcd[],q,r]",
test "dest_Z_name_f6" "Abcd[][p,q,r]x",
test "dest_Z_name_f7" "Abcd[]]p,q,r]",
test "dest_Z_name_f8" "Abcd[][p,q,r]]"
]
end;
=TEX

\section{TESTS ON TYPES}
We do not concern ourselves here with the internal representations of the Z types; we simply verify their expected properties.
\subsection{Given Types}
We first show that the function $is\_ZgivenT$ correctly discriminates.
=SML
store_mt_results_show mt_run [(
"is_ZgivenT_1",
	is_ZgivenT,
	mk_ZgivenT "a",
	true
	),(
"is_ZgivenT_2",
	is_ZgivenT,
	mk_ZvarT "a",
	false
	),(
"is_ZgivenT_3",
	is_ZgivenT,
	mk_ZpowerT(mk_ZgivenT "a"),
	false
	),(
"is_ZgivenT_4",
	is_ZgivenT,
	mk_ZtupleT[mk_ZgivenT "a"],
	false
	),(
"is_ZgivenT_5",
	is_ZgivenT,
	mk_ZschemaT[("a",mk_ZgivenT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZgivenT$ is the inverse of $mk\_ZgivenT$.
=SML
store_mt_results_show mt_run [(
"dest_ZgivenT_1",
	dest_ZgivenT,
	mk_ZgivenT "a",
	"a"
	)
];
=TEX
And that $dest\_ZgivenT$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_ZgivenT_f1",
	dest_ZgivenT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZgivenT" 47010 ["î'aÆ"]
	),(
"dest_ZgivenT_f2",
	dest_ZgivenT,
	mk_ZpowerT(mk_ZgivenT "a"),
	gen_fail_msg "dest_ZgivenT" 47010 ["îa SETÆ"]
	),(
"dest_ZgivenT_f3",
	dest_ZgivenT,
	mk_ZtupleT[mk_ZgivenT "a"],
	gen_fail_msg "dest_ZgivenT" 47010 ["îa $\"Z'T[1]\"Æ"]
	),(
"dest_ZgivenT_f4",
	dest_ZgivenT,
	mk_ZschemaT[("a",mk_ZgivenT "a")],
	gen_fail_msg "dest_ZgivenT" 47010 ["îa $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Type Variables}
This is similar to given types.
We first show that the function $is\_ZvarT$ correctly discriminates.
=SML
store_mt_results_show mt_run [(
"is_ZvarT_1",
	is_ZvarT,
	mk_ZgivenT "a",
	false
	),(
"is_ZvarT_2",
	is_ZvarT,
	mk_ZvarT "a",
	true
	),(
"is_ZvarT_3",
	is_ZvarT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
"is_ZvarT_4",
	is_ZvarT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
"is_ZvarT_5",
	is_ZvarT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZvarT$ is the inverse of $mk\_ZvarT$.
=SML
store_mt_results_show mt_run [(
"dest_ZvarT_1",
	dest_ZvarT,
	mk_ZvarT "a",
	"a"
	)
];
=TEX
And that $dest\_ZvarT$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_ZvarT_f1",
	dest_ZvarT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZvarT" 47020 ["îaÆ"]
	),(
"dest_ZvarT_f2",
	dest_ZvarT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZvarT" 47020 ["î'a SETÆ"]
	),(
"dest_ZvarT_f3",
	dest_ZvarT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZvarT" 47020 ["î'a $\"Z'T[1]\"Æ"]
	),(
"dest_ZvarT_f4",
	dest_ZvarT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZvarT" 47020 ["î'a $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Set Types}
As before.
=SML
store_mt_results_show mt_run [(
"is_ZpowerT_1",
	is_ZpowerT,
	mk_ZgivenT "a",
	false
	),(
"is_ZpowerT_2",
	is_ZpowerT,
	mk_ZvarT "a",
	false
	),(
"is_ZpowerT_3",
	is_ZpowerT,
	mk_ZpowerT(mk_ZvarT "a"),
	true
	),(
"is_ZpowerT_4",
	is_ZpowerT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
"is_ZpowerT_5",
	is_ZpowerT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZpowerT$ is the inverse of $mk\_ZpowerT$.
=SML
store_mt_results_show (mt_runf (op =:)) [(
"dest_ZpowerT_1",
	dest_ZpowerT,
	mk_ZpowerT(mk_ZvarT "a"),
	mk_ZvarT "a"
	)
];
=TEX
And that $dest\_ZpowerT$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_ZpowerT_f1",
	dest_ZpowerT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZpowerT" 47030 ["îaÆ"]
	),(
"dest_ZpowerT_f2",
	dest_ZpowerT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZpowerT" 47030 ["î'aÆ"]
	),(
"dest_ZpowerT_f3",
	dest_ZpowerT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZpowerT" 47030 ["î'a $\"Z'T[1]\"Æ"]
	),(
"dest_ZpowerT_f4",
	dest_ZpowerT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZpowerT" 47030 ["î'a $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Tuple Types}
=SML
store_mt_results_show mt_run [(
"is_ZtupleT_1",
	is_ZtupleT,
	mk_ZgivenT "a",
	false
	),(
"is_ZtupleT_2",
	is_ZtupleT,
	mk_ZvarT "a",
	false
	),(
"is_ZtupleT_3",
	is_ZtupleT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
"is_ZtupleT_4",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a"],
	true
	),(
"is_ZtupleT_5",
	is_ZtupleT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	),(
"is_ZtupleT_6",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZgivenT "b"],
	true
	),(
"is_ZtupleT_7",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZgivenT "b",mk_ZpowerT(mk_ZvarT "c")],
	true
	)
];
=TEX
We now show that $dest\_ZtupleT$ is the inverse of $mk\_ZtupleT$.
=SML
store_mt_results_show (mt_runf all_types_eq) [(
"dest_ZtupleT_1",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a"],
	[mk_ZvarT "a"]
	)];
=TEX
=SML
store_mt_results_show (mt_runf all_types_eq) [(
"dest_ZtupleT_2",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZvarT "b"],
	[mk_ZvarT "a",mk_ZvarT "b"]
	)];
=TEX
=SML
store_mt_results_show (mt_runf all_types_eq) [(
"dest_ZtupleT_3",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "b",mk_ZvarT "a"],
	[mk_ZvarT "b",mk_ZvarT "a"]
	)
];
=TEX
And that $dest\_ZtupleT$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_ZtupleT_f1",
	dest_ZtupleT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZtupleT" 47040 ["îaÆ"]
	),(
"dest_ZtupleT_f2",
	dest_ZtupleT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZtupleT" 47040 ["î'aÆ"]
	),(
"dest_ZtupleT_f3",
	dest_ZtupleT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZtupleT" 47040 ["î'a SETÆ"]
	),(
"dest_ZtupleT_f4",
	dest_ZtupleT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZtupleT" 47040 ["î'a $\"Z'S[a]\"Æ"]
	)
];
=TEX
\subsection{Schema Types}
=SML
store_mt_results_show mt_run [(
"is_ZschemaT_1",
	is_ZschemaT,
	mk_ZgivenT "a",
	false
	),(
"is_ZschemaT_2",
	is_ZschemaT,
	mk_ZvarT "a",
	false
	),(
"is_ZschemaT_3",
	is_ZschemaT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
"is_ZschemaT_4",
	is_ZschemaT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
"is_ZschemaT_5",
	is_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	true
	),(
"is_ZschemaT_6",
	is_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZgivenT "b")],
	true
	),(
"is_ZschemaT_7",
	is_ZschemaT,
	mk_ZschemaT[	("a",mk_ZvarT "a"),
			("b",mk_ZgivenT "b"),
			("c",mk_ZpowerT(mk_ZvarT "c"))],
	true
	),(
"is_ZschemaT_8",
	is_ZschemaT,
	mk_ZschemaT[],
	true
	)
];
=TEX
We now show that $dest\_ZschemaT$ is the inverse of $mk\_ZschemaT$.
Note that the order of the argument list for $mk\_ZschemaT$ is not significant and so we must be a little careful in generating expected values.
=SML
store_mt_results_show (mt_runf all_string_types_eq) [(
"dest_ZschemaT_1",
	dest_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	[("a",mk_ZvarT "a")]
	),(
"dest_ZschemaT_2",
	dest_ZschemaT,
	mk_ZschemaT[],
	[]
	),(
"dest_ZschemaT_3",
	dest_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")],
	[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	),(
"dest_ZschemaT_4",
	dest_ZschemaT,
	mk_ZschemaT[("b",mk_ZvarT "b"),("a",mk_ZvarT "a")],
	[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	)
];
=TEX
And that $dest\_ZschemaT$ fails when used with other Z types.
=SML
store_mt_results_show mt_run_fail [(
"dest_ZschemaT_f1",
	dest_ZschemaT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZschemaT" 47050 ["îaÆ"]
	),(
"dest_ZschemaT_f2",
	dest_ZschemaT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZschemaT" 47050 ["î'aÆ"]
	),(
"dest_ZschemaT_f3",
	dest_ZschemaT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZschemaT" 47050 ["î'a SETÆ"]
	),(
"dest_ZschemaT_f4",
	dest_ZschemaT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZschemaT" 47050 ["î'a $\"Z'T[1]\"Æ"]
	)
];
=TEX
Finally, we need to demonstrate the non-significance of ordering and the effect of duplicates in $mk\_ZschemaT$.
=SML
store_mt_results_show (mt_runf (op =:)) [(
"mk_ZschemaT_1",
	mk_ZschemaT,
	[("b",mk_ZvarT "b"),("a",mk_ZvarT "a")],
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	),(
"mk_ZschemaT_2",
	mk_ZschemaT,
	[("b",mk_ZvarT "b"),("a",mk_ZvarT "a"),("b",mk_ZvarT "b")],
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	)
];
=TEX
\subsection{The General Functions}
\section{TESTS ON TERMS}
A list of test cases is created in $terms$ which is built up
during much of the rest of this document.
We begin by initialising the test case list and defining the functions $add\_term$ (for adding test cases) and $t$ (which allows us to build terms using previously defined terms in the list).
Elements are pushed onto the list, function~$t$ retrieves entries counting
from the head, where the head element is number~1.
=SML
val terms :(string * int * TERM) list ref = ref [];

fun add_term (nam, ztm) = (
	let
		val zt = mk_ZTERM ztm;
	in
		terms := (nam,length(!terms), zt) :: (!terms);
		("add_term: " ^ nam)
	end
);

fun t n = (
	let 	fun aux m nil = mk_var("no_term", BOOL)
		| aux m ((_, _, tm) :: more) =
			if m <= 1
			then tm
			else aux (m-1) more
	in
		aux n (!terms)
	end
);
=TEX
The following function tests that all the terms in the test case list are correctly discriminated by all the discriminator functions.
=SML
local
	fun build_test(nam1,func) (nam2,n,tm) = (
		"disc__" ^ nam1 ^ "__" ^ nam2 ^ "__" ^ (string_of_int n),
		func,
		tm,
		(nam1 = nam2)
	);

	fun aux tml ff = (
		store_mt_results mt_run (map (build_test ff) tml)
	);

	fun auxM tml ff = (
		map (build_test ff) tml
	);
in
	fun make_discriminator_tests (ffl:(string * (TERM -> bool)) list) tml = (
		flat(map (auxM tml) ffl)
	);

	fun run_discriminator_tests (ffl:(string * (TERM -> bool)) list) tml = (
		map (aux tml) ffl;
		()
	);
end;
=TEX
The discriminator functions follow:
=SML
val	discriminator_functions = [
		("Zdec",is_Zdec),
		("Zdecsexp",is_Zdecsexp),
		("Zdecl",is_Zdecl),
                ("Zeq",is_Zeq),
                ("Zç",is_Zç),
                ("Ztrue",is_Ztrue),
                ("Zfalse",is_Zfalse),
                ("Z≥",is_Z≥),
                ("Z±",is_Z±),
                ("Z≤",is_Z≤),
                ("Z¥",is_Z¥),
                ("Z§",is_Z§),
                ("Z∂",is_Z∂),
                ("Z∂â1",is_Z∂â1),
                ("Zµ",is_Zµ),
                ("Zpredsexp",is_Zpredsexp),
                ("Zlvar",is_Zlvar),
                ("Zgvar",is_Zgvar),
                ("Zint",is_Zint),
                ("Zß¢",is_Zß¢),
                ("Zsetd",is_Zsetd),
                ("Zseta",is_Zseta),
                ("Z",is_Z),
                ("ZT",is_Ztuple),
                ("Z∏",is_Z∏),
                ("Z ",is_Z ),
                ("Zsel",is_Zsel),
                ("Zapp",is_Zapp),
                ("ZÃ",is_ZÃ),
                ("ZÕ",is_ZÕ),
                ("Zâs",is_Zâs),
                ("Zdecâs",is_Zdecâs),
                ("Zpreâs",is_Zpreâs),
                ("Z≥âs",is_Z≥âs),
                ("Z±âs",is_Z±âs),
                ("Z≤âs",is_Z≤âs),
                ("Z¥âs",is_Z¥âs),
                ("Z§âs",is_Z§âs),
                ("Z˘âs",is_Z˘âs),
                ("Zhideâs",is_Zhideâs),
                ("Z∂âs",is_Z∂âs),
                ("Z∂â1âs",is_Z∂â1âs),
                ("Zµâs",is_Zµâs),
                ("ZÑâs",is_ZÑâs),
                ("Zòâs",is_Zòâs),
                ("Zªâs",is_Zªâs)
	];
=TEX
Next we define a function to show that all test cases behave correctly with the function $dest\_ZTERM$.
=SML
local
	fun build_test(nam,n,tm) = (
		"dest__" ^ nam ^ "__" ^ (string_of_int n),
		mk_ZTERM o dest_ZTERM,
		tm,
		tm
	);
in
	fun run_destructor_tests (tml:(string * int * TERM) list) = (
		store_mt_results (mt_runf (op =$)) (map build_test tml)
	);
end;
=TEX
\subsection{Tests on Declarations}
We begin by defining a few variables and given sets, which will be frequently used throughout the tests.
=SML
val vara = mk_Zlvar("a",mk_ZgivenT "R",[]);
val varb = mk_Zlvar("b",mk_ZgivenT "R",[]);
val varc = mk_Zlvar("c",mk_ZgivenT "R",[]);
val vard = mk_Zlvar("d",mk_ZgivenT "S",[]);
val vare = mk_Zlvar("e",mk_ZgivenT "S",[]);
val varf = mk_Zlvar("f",mk_ZgivenT "S",[]);
val conR = mk_Zgvar("R",mk_ZpowerT(mk_ZgivenT "R"),[]);
val conS = mk_Zgvar("S",mk_ZpowerT(mk_ZgivenT "S"),[]);
=TEX
=SML
add_term("Zdec",Zdec([varb,varc],conR));
add_term("Zdec",Zdec([varf],conS));
=TEX
We save these declarations for use later.
=SML
val decbc = t 2;
val decf = t 1;
val deca = mk_Zdec([vara],conR);
val decde = mk_Zdec([vare,vard],conS);
val decab = mk_Zdec([vara,varb],conR);
val decabc = mk_Zdec([varc,varb,vara],conR);
val decdef = mk_Zdec([vare,vard,varf],conS);
=TEX
Now we use the above to make a compound declaration and use this to make a schema, which can then be used to test schema declaration.
=SML
add_term("Zdecl",Zdecl[decf,decbc]);
add_term("Zâs",Zâs(t 1, mk_Ztrue));
add_term("Zdecsexp",Zdecsexp(t 1,""));
add_term("Zdecsexp",Zdecsexp(t 2,"'"));
add_term("Zdecsexp",Zdecsexp(t 3,"!"));
add_term("Zdecsexp",Zdecsexp(t 4,"?"));
=TEX
Again, a schema and schema declaration will be useful.
=SML
val schbcf = t 5;
val decsexpbcf = t 4;
=TEX
Finally we can make a compound declaration from both types.
=SML
add_term("Zdecl",Zdecl[decde,decsexpbcf,deca]);
=TEX
\subsection{Tests on Terms}
\subsubsection{Global and Local Variables}
We begin this section by making some variables (global and local, generic and non-generic).
=SML
add_term("Zgvar",Zgvar("a",mk_ZvarT "A",[]));
add_term("Zgvar",Zgvar("ag",mk_ZgivenT "AG",[t 1]));
add_term("Zlvar",Zlvar("ag",mk_ZgivenT "AG",[t 2]));
add_term("Zlvar",Zlvar("a",mk_ZgivenT "A",[]));
add_term("Zlvar",Zlvar("b",mk_ZgivenT "A",[]));
add_term("Zlvar",Zlvar("c",mk_ZgivenT "A",[]));
=TEX
\subsubsection{Integers}
=SML
add_term("Zint",Zint "0");
add_term("Zint",Zint "20");
=TEX
\subsubsection{Finite Sequence Display}
=SML
add_term("Zß¢",Zß¢(mk_ZgivenT "R",[]));
add_term("Zß¢",Zß¢(mk_ZgivenT "R",[vara]));
add_term("Zß¢",Zß¢(mk_ZgivenT "R",[varc,vara,varb]));
=TEX
\subsubsection{Finite Set Display}
In the following tests, we use set membership to check that constructed terms are correctly typed.
Sets will be needed again, so we save the following cases:
=SML
add_term("Zsetd",Zsetd(mk_ZgivenT "R",[]));
add_term("Zç",Zç(vara,t 1));
val setd = t 2;
add_term("Zsetd",Zsetd(mk_ZgivenT "S",[vard]));
add_term("Zç",Zç(vard,t 1));
val setdd = t 2;
add_term("Zsetd",Zsetd(mk_ZgivenT "R",[varc,vara,varb]));
add_term("Zç",Zç(vara,t 1));
val setdabc = t 2;
=TEX
\subsubsection{Set Abstraction}
Again we save the set abstraction for later.
=SML
add_term("Zdecl",Zdecl[decde,decsexpbcf]);
add_term("Zseta",Zseta(t 1,mk_Ztrue,varc));
add_term("Zç",Zç(vara,t 1));
val seta = t 2;
=TEX
\subsubsection{Power Set}
The first test uses the set abstraction generated in the previous section.
=SML
add_term("Z",Z(seta));
add_term("Zç",Zç(seta,t 1));
add_term("Z",Z(setdabc));
add_term("Zç",Zç(seta,t 1));
=TEX
\subsubsection{Tuple}
The first test uses the three terms generated in the previous sections to form a 3-tuple.
We also check that unit tuples work (since they are used internally by the mapping; they are not allowed in Z).
=SML
add_term("ZT",Ztuple[t 1,t 2,t 3]);
add_term("ZT",Ztuple[vara]);
=TEX
\subsubsection{Cartesian Product}
=SML
add_term("Z∏",Z∏[setd,setdd,setdabc,seta]);
add_term("Zç",Zç(mk_Ztuple[vara,vard,vara,vara],t 1));
=TEX
\subsubsection{Theta}
=SML
add_term("Z ",Z (schbcf,""));
add_term("Zç",Zç(t 1,schbcf));
add_term("Z ",Z (schbcf,"'"));
add_term("Zç",Zç(t 1,schbcf));
add_term("Z ",Z (schbcf,"!"));
add_term("Zç",Zç(t 1,schbcf));
add_term("Z ",Z (schbcf,"?"));
add_term("Zç",Zç(t 1,schbcf));
=TEX
\subsubsection{Selection}
We use the binding generated in the previous section to test selection.
=SML
add_term("Zsel",Zsel(t 2,"c"));
add_term("Zeq",Zeq(t 1,vara));
=TEX
\subsubsection{Function Application}
=SML
add_term("Zapp",Zapp(mk_Z∏[seta,setdd],vara));
add_term("Zeq",Zeq(t 1,vard));
=TEX
\subsubsection{Lambda Abstraction}
=SML
add_term("ZÃ",ZÃ(mk_Zdecl[deca],mk_Ztrue,vara));
add_term("Zç",Zç(mk_Ztuple[vara,vara],t 1));
add_term("ZÃ",ZÃ(mk_Zdecl[decbc],mk_Ztrue,varb));
add_term("Zç",Zç(mk_Ztuple[mk_Ztuple[varb,varc],varb],t 1));
add_term("ZÃ",ZÃ(mk_Zdecl[decsexpbcf],mk_Ztrue,varf));
add_term("Zç",Zç(mk_Ztuple[mk_Z (schbcf,""),varf],t 1));
add_term("ZÃ",ZÃ(mk_Zdecl[decde,decsexpbcf,deca],mk_Ztrue,varf));
add_term("Zç",Zç(mk_Ztuple[mk_Ztuple[vard,vare,mk_Z (schbcf,""),vara],varf],t 1));
=TEX
\subsubsection{Definite Description}
=SML
add_term("ZÕ",ZÕ(mk_Zdecl[deca],mk_Ztrue,vara));
add_term("Zeq",Zeq(vara,t 1));
add_term("ZÕ",ZÕ(mk_Zdecl[decbc],mk_Ztrue,varb));
add_term("Zeq",Zeq(varb,t 1));
add_term("ZÕ",ZÕ(mk_Zdecl[decsexpbcf],mk_Ztrue,varf));
add_term("Zeq",Zeq(varf,t 1));
add_term("ZÕ",ZÕ(mk_Zdecl[decde,decsexpbcf,deca],mk_Ztrue,varf));
add_term("Zeq",Zeq(varf,t 1));
=TEX
\subsection{Tests on Predicates}
\subsubsection{Equality}
There are lots of tests of equality elsewhere.
\subsubsection{Set Membership}
There are lots of tests of set membership elsewhere.
\subsubsection{True and False}
=SML
add_term("Ztrue",Ztrue);
add_term("Zfalse",Zfalse);
=TEX
\subsubsection{Logical Connectives}
=SML
add_term("Z≥",Z≥ mk_Ztrue);
add_term("Z±",Z±(mk_Ztrue,mk_Ztrue));
add_term("Z≤",Z≤(mk_Ztrue,mk_Ztrue));
add_term("Z¥",Z¥(mk_Ztrue,mk_Ztrue));
add_term("Z§",Z§(mk_Ztrue,mk_Ztrue));
=TEX
\subsubsection{Quantification}
=SML
add_term("Z∂",Z∂(mk_Zdecl[deca],mk_Ztrue,mk_Ztrue));
add_term("Z∂",Z∂(mk_Zdecl[decsexpbcf,deca],mk_Zeq(vara,varb),mk_Zeq(varc,varb)));
add_term("Z∂â1",Z∂â1(mk_Zdecl[deca],mk_Ztrue,mk_Ztrue));
add_term("Z∂â1",Z∂â1(mk_Zdecl[decsexpbcf,deca],mk_Zeq(vara,varb),mk_Zeq(varc,varb)));
add_term("Zµ",Zµ(mk_Zdecl[deca],mk_Ztrue,mk_Ztrue));
add_term("Zµ",Zµ(mk_Zdecl[decsexpbcf,deca],mk_Zeq(vara,varb),mk_Zeq(varc,varb)));
=TEX
\subsubsection{Schema as Predicate}
=SML
add_term("Zpredsexp",Zpredsexp(schbcf,""));
add_term("Zpredsexp",Zpredsexp(schbcf,"'"));
add_term("Z±",Z±(t 1,t 2));
add_term("Zpredsexp",Zpredsexp(schbcf,"?"));
add_term("Zpredsexp",Zpredsexp(schbcf,"!"));
add_term("Z±",Z±(t 1,t 2));
=TEX
\subsection{Tests on Schema Operations}
\subsubsection{Schema Construction}
In the schema constructor tests, we make two schemas of the same type in different ways and use the equality constructor to show that they are indeed of the same type.
A few other schemas are constructed and saved for later.
=SML
add_term("Zâs",Zâs(mk_Zdecl[decde,decsexpbcf,deca],mk_Ztrue));
add_term("Zâs",Zâs(mk_Zdecl[decabc,decdef],mk_Zeq(vara,varc)));
add_term("Zeq",Zeq(t 1,t 2));
val schabcdef1 = t 3;
val schabcdef2 = t 2;
add_term("Zâs",Zâs(mk_Zdecl[deca],mk_Ztrue));
val scha = t 1;
add_term("Zâs",Zâs(mk_Zdecl[decab],mk_Ztrue));
val schab = t 1;
add_term("Zâs",Zâs(mk_Zdecl[decabc],mk_Ztrue));
val schabc = t 1;
add_term("Zâs",Zâs(mk_Zdecl[decbc],mk_Zeq(varb,varc)));
val schbc = t 1;
add_term("Zâs",Zâs(mk_Zdecl[decf],mk_Ztrue));
val schf = t 1;
add_term("Zâs",Zâs(mk_Zdecl[decde],mk_Zeq(vare,vard)));
val schde = t 1;
=TEX
\subsubsection{Decoration}
In the tests for schema decoration, we show that component types are preserved.
=SML
add_term("Zdecâs",Zdecâs(scha,""));
add_term("Zdecâs",Zdecâs(scha,"!"));
add_term("Zdecâs",Zdecâs(scha,"?"));
add_term("Zdecâs",Zdecâs(scha,"'"));
add_term("Zeq",Zeq(mk_Zsel(mk_Z (scha,""),"a"),mk_Zsel(mk_Z (t 1,""),"a'")));
add_term("Zdecâs",Zdecâs(schabcdef1,"?"));
add_term("Zeq",Zeq(mk_Zsel(mk_Z (schabcdef1,""),"a"),mk_Zsel(mk_Z (t 1,""),"a?")));
add_term("Zeq",Zeq(mk_Zsel(mk_Z (schabcdef1,""),"a"),mk_Zsel(mk_Z (t 2,""),"b?")));
add_term("Zeq",Zeq(mk_Zsel(mk_Z (schabcdef1,""),"f"),mk_Zsel(mk_Z (t 3,""),"d?")));
=TEX
\subsubsection{Precondition}
=SML
add_term("Zdecsexp",Zdecsexp(scha,""));
add_term("Zdecsexp",Zdecsexp(schbc,"'"));
add_term("Zdecsexp",Zdecsexp(schf,"!"));
add_term("Zdecsexp",Zdecsexp(schde,"?"));
add_term("Zâs",Zâs(mk_Zdecl[t 1,t 2,t 3,t 4],mk_Ztrue));
add_term("Zpreâs",Zpreâs(t 1));
add_term("Zeq",Zeq(t 1,mk_Zâs(mk_Zdecl[t 3,t 6],mk_Ztrue)));
add_term("Zâs",Zâs(mk_Zdecl[t 7,t 4],mk_Ztrue));
add_term("Zpreâs",Zpreâs(t 1));
add_term("Zeq",Zeq(t 1,t 2));
add_term("Zâs",Zâs(mk_Zdecl[t 8,t 9],mk_Ztrue));
add_term("Zpreâs",Zpreâs(t 1));
add_term("Zeq",Zeq(t 1,mk_Zlvar("x",mk_ZpowerT(mk_ZschemaT []),[])));
=TEX
\subsubsection{Negation}
=SML
add_term("Z≥âs",Z≥âs scha);
add_term("Zeq",Zeq(scha,t 1));
add_term("Z≥âs",Z≥âs schbc);
add_term("Zeq",Zeq(schbc,t 1));
=TEX
\subsubsection{Conjunction}
=SML
add_term("Z±âs",Z±âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z±âs",Z±âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Disjunction}
=SML
add_term("Z≤âs",Z≤âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z≤âs",Z≤âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Implication}
=SML
add_term("Z¥âs",Z¥âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z¥âs",Z¥âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Equivalence}
=SML
add_term("Z§âs",Z§âs(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z§âs",Z§âs(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Projection}
=SML
add_term("Z˘âs",Z˘âs(schab,schbc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z˘âs",Z˘âs(schabc,schbc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z˘âs",Z˘âs(schabc,scha));
add_term("Zeq",Zeq(scha,t 1));
=TEX
\subsubsection{Hiding}
=SML
add_term("Zhideâs",Zhideâs(schabc,["a"]));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zhideâs",Zhideâs(schabc,["b","c"]));
add_term("Zeq",Zeq(scha,t 1));
add_term("Zhideâs",Zhideâs(schabc,["a","b","c"]));
add_term("Zeq",Zeq(mk_Zlvar("x",mk_ZpowerT(mk_ZschemaT []),[]),t 1));
add_term("Zhideâs",Zhideâs(schabc,["a","b","c","d"]));
add_term("Zç",Zç(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Existential Quantification}
=SML
add_term("Z∂âs",Z∂âs(mk_Zdecl[deca],mk_Ztrue,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z∂âs",Z∂âs(mk_Zdecl[decbc],mk_Ztrue,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Z∂âs",Z∂âs(mk_Zdecl[decbc,deca],mk_Ztrue,schabc));
add_term("Zç",Zç(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Unique Existential Quantification}
=SML
add_term("Z∂â1âs",Z∂â1âs(mk_Zdecl[deca],mk_Ztrue,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z∂â1âs",Z∂â1âs(mk_Zdecl[decbc],mk_Ztrue,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Z∂â1âs",Z∂â1âs(mk_Zdecl[decbc,deca],mk_Ztrue,schabc));
add_term("Zç",Zç(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Universal Quantification}
=SML
add_term("Zµâs",Zµâs(mk_Zdecl[deca],mk_Ztrue,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zµâs",Zµâs(mk_Zdecl[decbc],mk_Ztrue,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Zµâs",Zµâs(mk_Zdecl[decbc,deca],mk_Ztrue,schabc));
add_term("Zç",Zç(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Sequential Composition}
=SML
add_term("Zdecsexp",Zdecsexp(scha,""));
add_term("Zdecsexp",Zdecsexp(schde,"'"));
add_term("Zdecsexp",Zdecsexp(schde,""));
add_term("Zdecsexp",Zdecsexp(schbc,"'"));
add_term("Zâs",Zâs(mk_Zdecl[t 3,t 4],mk_Ztrue));
add_term("Zâs",Zâs(mk_Zdecl[t 2,t 3],mk_Ztrue));
add_term("Zªâs",Zªâs(t 2,t 1));
add_term("Zeq",Zeq(mk_Zâs(mk_Zdecl[t 4,t 7],mk_Ztrue),t 1));
=TEX
\subsection{Run Tests}
=SML
(* Some statistics *)
("Number of discriminator functions",	length discriminator_functions);
("Number of terms",			length(!terms));
("Number of discriminator tests",	(length discriminator_functions)
					* (length(!terms)));
("Number of destructor tests",		length(!terms));

run_discriminator_tests discriminator_functions (!terms);
run_destructor_tests (!terms);
=TEX
\section{END OF TESTS}
=SML
"End of tests";
diag_string(summarize_mt_results ());
=TEX
\section{UNTESTED ERROR MESSAGES}
\label{untested}
\end{document}


