=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Types and Terms}
\TPPref{DS/FMU/IED/MDT047}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{A set of module tests are given for the 
the constructors, destructors and discriminators of Z terms and types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First drafts.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the type and term constructors, destructors and discriminators for Z in ICL HOL.
The design is in \cite{DS/FMU/IED/DTD047}
and it is
implemented in \cite{DS/FMU/IED/IMP047}.

\subsection{Introduction}

\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD047},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

We test each function of the signature of \cite{DS/FMU/IED/DTD047}
in turn, where possible in the same order as in the design document,
except for those exceptions noted in section \ref{untested}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD047},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP047}.
It relies on a term pretty-printer being present to format
the results of error messages.

\subsubsection{Deficiencies}
None known.

\section{TEST HARNESS MATERIAL}
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
=TEX
\section{NAME DESTRUCTION TESTS}
We check that the names of our internally generated constants, types etc. can be correctly analysed into basic name and component names.
=SML
store_mt_results mt_run [(
	"dest_Z_name 1",
	dest_Z_name,
	"Abcd",
	("Abcd",[])
	),(
	"dest_Z_name 2",
	dest_Z_name,
	"Abcd[]",
	("Abcd",[[]])
	),(
	"dest_Z_name 3",
	dest_Z_name,
	"Abcd[w]",
	("Abcd",[["w"]])
	),(
	"dest_Z_name 4",
	dest_Z_name,
	"Abcd[w,x,y,z]",
	("Abcd",[["w","x","y","z"]])
	),(
	"dest_Z_name 5",
	dest_Z_name,
	"Abcd[w,x,y,z][p,q,r]",
	("Abcd",[["w","x","y","z"],["p","q","r"]])
	),(
	"dest_Z_name 6",
	dest_Z_name,
	"Abcd[w,x,y,z][]",
	("Abcd",[["w","x","y","z"],[]])
	),(
	"dest_Z_name 7",
	dest_Z_name,
	"Abcd[][p,q,r]",
	("Abcd",[[],["p","q","r"]])
	)
];
=TEX
\section{TESTS ON TYPES}
We do not concern ourselves here with the internal representations of the Z types; we simply verify their expected properties.
\subsection{Given Types}
We first show that the function $is\_ZgivenT$ correctly discriminates.
=SML
store_mt_results mt_run [(
	"is_ZgivenT 1",
	is_ZgivenT,
	mk_ZgivenT "a",
	true
	),(
	"is_ZgivenT 2",
	is_ZgivenT,
	mk_ZvarT "a",
	false
	),(
	"is_ZgivenT 3",
	is_ZgivenT,
	mk_ZpowerT(mk_ZgivenT "a"),
	false
	),(
	"is_ZgivenT 4",
	is_ZgivenT,
	mk_ZtupleT[mk_ZgivenT "a"],
	false
	),(
	"is_ZgivenT 5",
	is_ZgivenT,
	mk_ZschemaT[("a",mk_ZgivenT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZgivenT$ is the inverse of $mk\_ZgivenT$.
=SML
store_mt_results mt_run [(
	"dest_ZgivenT 1",
	dest_ZgivenT,
	mk_ZgivenT "a",
	"a"
	)
];
=TEX
And that $dest\_ZgivenT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZgivenT f1",
	dest_ZgivenT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZgivenT" 47010 ["¬:'a®"]
	),(
	"dest_ZgivenT f2",
	dest_ZgivenT,
	mk_ZpowerT(mk_ZgivenT "a"),
	gen_fail_msg "dest_ZgivenT" 47010 ["¬:a ð®"]
	),(
	"dest_ZgivenT f3",
	dest_ZgivenT,
	mk_ZtupleT[mk_ZgivenT "a"],
	gen_fail_msg "dest_ZgivenT" 47010 ["¬:a Z'T[1]®"]
	),(
	"dest_ZgivenT f4",
	dest_ZgivenT,
	mk_ZschemaT[("a",mk_ZgivenT "a")],
	gen_fail_msg "dest_ZgivenT" 47010 ["¬:a Z'S[a]®"]
	)
];
=TEX
\subsection{Type Variables}
This is similar to given types.
We first show that the function $is\_ZvarT$ correctly discriminates.
=SML
store_mt_results mt_run [(
	"is_ZvarT 1",
	is_ZvarT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZvarT 2",
	is_ZvarT,
	mk_ZvarT "a",
	true
	),(
	"is_ZvarT 3",
	is_ZvarT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
	"is_ZvarT 4",
	is_ZvarT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
	"is_ZvarT 5",
	is_ZvarT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZvarT$ is the inverse of $mk\_ZvarT$.
=SML
store_mt_results mt_run [(
	"dest_ZvarT 1",
	dest_ZvarT,
	mk_ZvarT "a",
	"a"
	)
];
=TEX
And that $dest\_ZvarT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZvarT f1",
	dest_ZvarT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZvarT" 47020 ["¬:a®"]
	),(
	"dest_ZvarT f2",
	dest_ZvarT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZvarT" 47020 ["¬:'a ð®"]
	),(
	"dest_ZvarT f3",
	dest_ZvarT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZvarT" 47020 ["¬:'a Z'T[1]®"]
	),(
	"dest_ZvarT f4",
	dest_ZvarT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZvarT" 47020 ["¬:'a Z'S[a]®"]
	)
];
=TEX
\subsection{Set Types}
As before.
=SML
store_mt_results mt_run [(
	"is_ZpowerT 1",
	is_ZpowerT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZpowerT 2",
	is_ZpowerT,
	mk_ZvarT "a",
	false
	),(
	"is_ZpowerT 3",
	is_ZpowerT,
	mk_ZpowerT(mk_ZvarT "a"),
	true
	),(
	"is_ZpowerT 4",
	is_ZpowerT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
	"is_ZpowerT 5",
	is_ZpowerT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	)
];
=TEX
We now show that $dest\_ZpowerT$ is the inverse of $mk\_ZpowerT$.
=SML
store_mt_results mt_run [(
	"dest_ZpowerT 1",
	dest_ZpowerT,
	mk_ZpowerT(mk_ZvarT "a"),
	mk_ZvarT "a"
	)
];
=TEX
And that $dest\_ZpowerT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZpowerT f1",
	dest_ZpowerT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZpowerT" 47030 ["¬:a®"]
	),(
	"dest_ZpowerT f2",
	dest_ZpowerT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZpowerT" 47030 ["¬:'a®"]
	),(
	"dest_ZpowerT f3",
	dest_ZpowerT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZpowerT" 47030 ["¬:'a Z'T[1]®"]
	),(
	"dest_ZpowerT f4",
	dest_ZpowerT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZpowerT" 47030 ["¬:'a Z'S[a]®"]
	)
];
=TEX
\subsection{Tuple Types}
=SML
store_mt_results mt_run [(
	"is_ZtupleT 1",
	is_ZtupleT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZtupleT 2",
	is_ZtupleT,
	mk_ZvarT "a",
	false
	),(
	"is_ZtupleT 3",
	is_ZtupleT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
	"is_ZtupleT 4",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a"],
	true
	),(
	"is_ZtupleT 5",
	is_ZtupleT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	false
	),(
	"is_ZtupleT 6",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZgivenT "b"],
	true
	),(
	"is_ZtupleT 7",
	is_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZgivenT "b",mk_ZpowerT(mk_ZvarT "c")],
	true
	)
];
=TEX
We now show that $dest\_ZtupleT$ is the inverse of $mk\_ZtupleT$.
=SML
store_mt_results mt_run [(
	"dest_ZtupleT 1",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a"],
	[mk_ZvarT "a"]
	),(
	"dest_ZtupleT 2",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "a",mk_ZvarT "b"],
	[mk_ZvarT "a",mk_ZvarT "b"]
	),(
	"dest_ZtupleT 3",
	dest_ZtupleT,
	mk_ZtupleT[mk_ZvarT "b",mk_ZvarT "a"],
	[mk_ZvarT "b",mk_ZvarT "a"]
	)
];
=TEX
And that $dest\_ZtupleT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZtupleT f1",
	dest_ZtupleT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZtupleT" 47040 ["¬:a®"]
	),(
	"dest_ZtupleT f2",
	dest_ZtupleT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZtupleT" 47040 ["¬:'a®"]
	),(
	"dest_ZtupleT f3",
	dest_ZtupleT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZtupleT" 47040 ["¬:'a ð®"]
	),(
	"dest_ZtupleT f4",
	dest_ZtupleT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	gen_fail_msg "dest_ZtupleT" 47040 ["¬:'a Z'S[a]®"]
	)
];
=TEX
\subsection{Schema Types}
=SML
store_mt_results mt_run [(
	"is_ZschemaT 1",
	is_ZschemaT,
	mk_ZgivenT "a",
	false
	),(
	"is_ZschemaT 2",
	is_ZschemaT,
	mk_ZvarT "a",
	false
	),(
	"is_ZschemaT 3",
	is_ZschemaT,
	mk_ZpowerT(mk_ZvarT "a"),
	false
	),(
	"is_ZschemaT 4",
	is_ZschemaT,
	mk_ZtupleT[mk_ZvarT "a"],
	false
	),(
	"is_ZschemaT 5",
	is_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	true
	),(
	"is_ZschemaT 6",
	is_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZgivenT "b")],
	true
	),(
	"is_ZschemaT 7",
	is_ZschemaT,
	mk_ZschemaT[	("a",mk_ZvarT "a"),
			("b",mk_ZgivenT "b"),
			("c",mk_ZpowerT(mk_ZvarT "c"))],
	true
	),(
	"is_ZschemaT 8",
	is_ZschemaT,
	mk_ZschemaT[],
	true
	)
];
=TEX
We now show that $dest\_ZschemaT$ is the inverse of $mk\_ZschemaT$.
Note that the order of the argument list for $mk\_ZschemaT$ is not significant and so we must be a little careful in generating expected values.
=SML
store_mt_results (mt_runf (op ListUtilities.set_eq)) [(
	"dest_ZschemaT 1",
	dest_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a")],
	[("a",mk_ZvarT "a")]
	),(
	"dest_ZschemaT 2",
	dest_ZschemaT,
	mk_ZschemaT[],
	[]
	),(
	"dest_ZschemaT 3",
	dest_ZschemaT,
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")],
	[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	),(
	"dest_ZschemaT 4",
	dest_ZschemaT,
	mk_ZschemaT[("b",mk_ZvarT "b"),("a",mk_ZvarT "a")],
	[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	)
];
=TEX
And that $dest\_ZschemaT$ fails when used with other Z types.
=SML
store_mt_results mt_run_fail [(
	"dest_ZschemaT f1",
	dest_ZschemaT,
	mk_ZgivenT "a",
	gen_fail_msg "dest_ZschemaT" 47050 ["¬:a®"]
	),(
	"dest_ZschemaT f2",
	dest_ZschemaT,
	mk_ZvarT "a",
	gen_fail_msg "dest_ZschemaT" 47050 ["¬:'a®"]
	),(
	"dest_ZschemaT f3",
	dest_ZschemaT,
	mk_ZpowerT(mk_ZvarT "a"),
	gen_fail_msg "dest_ZschemaT" 47050 ["¬:'a ð®"]
	),(
	"dest_ZschemaT f4",
	dest_ZschemaT,
	mk_ZtupleT[mk_ZvarT "a"],
	gen_fail_msg "dest_ZschemaT" 47050 ["¬:'a Z'T[1]®"]
	)
];
=TEX
Finally, we need to demonstrate the non-significance of ordering and the effect of duplicates in $mk\_ZschemaT$.
=SML
store_mt_results mt_run [(
	"mk_ZschemaT 1",
	mk_ZschemaT,
	[("b",mk_ZvarT "b"),("a",mk_ZvarT "a")],
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	),(
	"mk_ZschemaT 2",
	mk_ZschemaT,
	[("b",mk_ZvarT "b"),("a",mk_ZvarT "a"),("b",mk_ZvarT "b")],
	mk_ZschemaT[("a",mk_ZvarT "a"),("b",mk_ZvarT "b")]
	)
];
=TEX
\subsection{The General Functions}
\section{TESTS ON TERMS}
We begin by initialising the test case list and defining the functions $add\_term$ (for adding test cases) and $t$ (which allows us to build terms using previously defined terms in the list).
=SML
val terms :(string * int * TERM) list ref = ref [];
fun add_term (nam,ztm) = (terms := !terms @ [(nam,length(!terms),mk_ZTERM ztm)]);
fun t n = case nth (n - 1) (rev (!terms)) of (_,_,tm) => tm;
=TEX
The following function tests that all the terms in the test case list are correctly discriminated by all the discriminator functions.
=SML
local
fun	run_test (nam1,func) (nam2,n,tm) =
		store_mt_results mt_run [(
			nam1 ^ " discriminator test, using term " ^ (string_of_int n),
			func,
			tm,
			(nam1 = nam2)
		)];
in
fun	run_discriminator_tests 
		([]:(string * (TERM -> bool)) list)
		(tml:(string * int * TERM) list) = ()
|	run_discriminator_tests (h::rest) tml = (
		map (run_test h) tml;
		run_discriminator_tests rest tml
		);
end;
=TEX
The discriminator functions follow:
=SML
val	discriminator_functions = [
		("Zdec",is_Zdec),
		("Zdecsexp",is_Zdecsexp),
		("Zdecl",is_Zdecl),
                ("Zeq",is_Zeq),
                ("Z",is_Z),
                ("Ztrue",is_Ztrue),
                ("Zfalse",is_Zfalse),
                ("Z³",is_Z³),
                ("Z±",is_Z±),
                ("Z²",is_Z²),
                ("Z´",is_Z´),
                ("Z¤",is_Z¤),
                ("Z¶",is_Z¶),
                ("Z¶%down%1",is_Z¶%down%1),
                ("Zµ",is_Zµ),
                ("Zpredsexp",is_Zpredsexp),
                ("Zlvar",is_Zlvar),
                ("Zgvar",is_Zgvar),
                ("Zint",is_Zint),
                ("Z§¢",is_Z§¢),
                ("Zsetd",is_Zsetd),
                ("Zseta",is_Zseta),
                ("Zð",is_Zð),
                ("ZT",is_Ztuple),
                ("Z¸",is_Z¸),
                ("ZÊ",is_ZÊ),
                ("Zsel",is_Zsel),
                ("Zapp",is_Zapp),
                ("ZÌ",is_ZÌ),
                ("ZÍ",is_ZÍ),
                ("Z%down%s",is_Z%down%s),
                ("Zdec%down%s",is_Zdec%down%s),
                ("Zpre%down%s",is_Zpre%down%s),
                ("Z³%down%s",is_Z³%down%s),
                ("Z±%down%s",is_Z±%down%s),
                ("Z²%down%s",is_Z²%down%s),
                ("Z´%down%s",is_Z´%down%s),
                ("Z¤%down%s",is_Z¤%down%s),
                ("Zù%down%s",is_Zù%down%s),
                ("Zhide%down%s",is_Zhide%down%s),
                ("Z¶%down%s",is_Z¶%down%s),
                ("Z¶%down%1%down%s",is_Z¶%down%1%down%s),
                ("Zµ%down%s",is_Zµ%down%s),
                ("Z%down%s",is_Z%down%s),
                ("Z%down%s",is_Z%down%s),
                ("Z»%down%s",is_Z»%down%s)
	];
=TEX
Next we define a function to show that all test cases behave correctly with the function $dest\_ZTERM$.
=SML
local
fun	run_test (nam,n,tm) =
		store_mt_results mt_run [(
			nam ^ " destructor test, using term " ^ (string_of_int n),
			mk_ZTERM o dest_ZTERM,
			tm,
			tm
		)];
in
fun	run_destructor_tests (tml:(string * int * TERM) list) = 
		map run_test tml;
end;
=TEX
\subsection{Tests on Declarations}
We begin by defining a few variables and given sets, which will be frequently used throughout the tests.
=SML
val vara = mk_Zlvar("a",mk_ZgivenT "R",[]);
val varb = mk_Zlvar("b",mk_ZgivenT "R",[]);
val varc = mk_Zlvar("c",mk_ZgivenT "R",[]);
val vard = mk_Zlvar("d",mk_ZgivenT "S",[]);
val vare = mk_Zlvar("e",mk_ZgivenT "S",[]);
val varf = mk_Zlvar("f",mk_ZgivenT "S",[]);
val conR = mk_Zgvar("R",mk_ZpowerT(mk_ZgivenT "R"),[]);
val conS = mk_Zgvar("S",mk_ZpowerT(mk_ZgivenT "S"),[]);
=TEX
=SML
add_term("Zdec",Zdec([varb,varc],conR));
add_term("Zdec",Zdec([varf],conS));
=TEX
We save these declarations for use later.
=SML
val decbc = t 2;
val decf = t 1;
val deca = mk_Zdec([vara],conR);
val decde = mk_Zdec([vare,vard],conS);
val decab = mk_Zdec([vara,varb],conR);
val decabc = mk_Zdec([varc,varb,vara],conR);
val decdef = mk_Zdec([vare,vard,varf],conS);
=TEX
Now we use the above to make a compound declaration and use this to make a schema, which can then be used to test schema declaration.
=SML
add_term("Zdecl",Zdecl[decf,decbc]);
add_term("Z%down%s",Z%down%s(t 1,mk_Ztrue));
add_term("Zdecsexp",Zdecsexp(t 1,""));
add_term("Zdecsexp",Zdecsexp(t 2,"'"));
add_term("Zdecsexp",Zdecsexp(t 3,"!"));
add_term("Zdecsexp",Zdecsexp(t 4,"?"));
=TEX
Again, a schema and schema declaration will be useful.
=SML
val schbcf = t 5;
val decsexpbcf = t 4;
=TEX
Finally we can make a compound declaration from both types.
=SML
add_term("Zdecl",Zdecl[decde,decsexpbcf,deca]);
=TEX
\subsection{Tests on Terms}
\subsubsection{Global and Local Variables}
We begin this section by making some variables (global and local, generic and non-generic).
=SML
add_term("Zgvar",Zgvar("a",mk_ZvarT "A",[]));
add_term("Zgvar",Zgvar("ag",mk_ZgivenT "AG",[t 1]));
add_term("Zlvar",Zlvar("ag",mk_ZgivenT "AG",[t 2]));
add_term("Zlvar",Zlvar("a",mk_ZgivenT "A",[]));
add_term("Zlvar",Zlvar("b",mk_ZgivenT "A",[]));
add_term("Zlvar",Zlvar("c",mk_ZgivenT "A",[]));
=TEX
\subsubsection{Integers}
=SML
add_term("Zint",Zint "0");
add_term("Zint",Zint "20");
=TEX
\subsubsection{Finite Sequence Display}
=SML
add_term("Z§¢",Z§¢(mk_ZgivenT "R",[]));
add_term("Z§¢",Z§¢(mk_ZgivenT "R",[vara]));
add_term("Z§¢",Z§¢(mk_ZgivenT "R",[varc,vara,varb]));
=TEX
\subsubsection{Finite Set Display}
In the following tests, we use set membership to check that constructed terms are correctly typed.
Sets will be needed again, so we save the following cases:
=SML
add_term("Zsetd",Zsetd(mk_ZgivenT "R",[]));
add_term("Z",Z(vara,t 1));
val setd = t 2;
add_term("Zsetd",Zsetd(mk_ZgivenT "S",[vard]));
add_term("Z",Z(vard,t 1));
val setdd = t 2;
add_term("Zsetd",Zsetd(mk_ZgivenT "R",[varc,vara,varb]));
add_term("Z",Z(vara,t 1));
val setdabc = t 2;
=TEX
\subsubsection{Set Abstraction}
Again we save the set abstraction for later.
=SML
add_term("Zdecl",Zdecl[decde,decsexpbcf]);
add_term("Zseta",Zseta(t 1,mk_Ztrue,varc));
add_term("Z",Z(vara,t 1));
val seta = t 2;
=TEX
\subsubsection{Power Set}
The first test uses the set abstraction generated in the previous section.
=SML
add_term("Zð",Zð(seta));
add_term("Z",Z(seta,t 1));
add_term("Zð",Zð(setdabc));
add_term("Z",Z(seta,t 1));
=TEX
\subsubsection{Tuple}
The first test uses the three terms generated in the previous sections to form a 3-tuple.
We also check that unit tuples work (since they are used internally by the mapping; they are not allowed in Z).
=SML
add_term("ZT",ZT[t 1,t 2,t 3]);
add_term("ZT",ZT[vara]);
=TEX
\subsubsection{Cartesian Product}
=SML
add_term("Z¸",Z¸[setd,setdd,setdabc,seta]);
add_term("Z",Z(mk_Ztuple[vara,vard,vara,vara],t 1));
=TEX
\subsubsection{Theta}
=SML
add_term("ZÊ",ZÊ(schbcf,""));
add_term("Z",Z(t 1,schbcf));
add_term("ZÊ",ZÊ(schbcf,"'"));
add_term("Z",Z(t 1,schbcf));
add_term("ZÊ",ZÊ(schbcf,"!"));
add_term("Z",Z(t 1,schbcf));
add_term("ZÊ",ZÊ(schbcf,"?"));
add_term("Z",Z(t 1,schbcf));
=TEX
\subsubsection{Selection}
We use the binding generated in the previous section to test selection.
=SML
add_term("Zsel",Zsel(t 2,"c"));
add_term("Zeq",Zeq(t 1,vara));
=TEX
\subsubsection{Function Application}
=SML
add_term("Zapp",Zapp(mk_Z¸[seta,setdd],vara));
add_term("Zeq",Zeq(t 1,vard));
=TEX
\subsubsection{Lambda Abstraction}
=SML
add_term("ZÌ",ZÌ(mk_Zdecl[deca],mk_Ztrue,vara));
add_term("Z",Z(mk_Ztuple[vara,vara],t 1));
add_term("ZÌ",ZÌ(mk_Zdecl[decbc],mk_Ztrue,varb));
add_term("Z",Z(mk_Ztuple[mk_Ztuple[varb,varc],varb],t 1));
add_term("ZÌ",ZÌ(mk_Zdecl[decsexpbcf],mk_Ztrue,varf));
add_term("Z",Z(mk_Ztuple[mk_ZÊ(schbcf,""),varf],t 1));
add_term("ZÌ",ZÌ(mk_Zdecl[decde,decsexpbcf,deca],mk_Ztrue,varf));
add_term("Z",Z(mk_Ztuple[mk_Ztuple[vard,vare,mk_ZÊ(schbcf,""),vara],varf],t 1));
=TEX
\subsubsection{Definite Description}
=SML
add_term("ZÍ",ZÍ(mk_Zdecl[deca],mk_Ztrue,vara));
add_term("Zeq",Zeq(vara,t 1));
add_term("ZÍ",ZÍ(mk_Zdecl[decbc],mk_Ztrue,varb));
add_term("Zeq",Zeq(varb,t 1));
add_term("ZÍ",ZÍ(mk_Zdecl[decsexpbcf],mk_Ztrue,varf));
add_term("Zeq",Zeq(varf,t 1));
add_term("ZÍ",ZÍ(mk_Zdecl[decde,decsexpbcf,deca],mk_Ztrue,varf));
add_term("Zeq",Zeq(varf,t 1));
=TEX
\subsection{Tests on Predicates}
\subsubsection{Equality}
There are lots of tests of equality elsewhere.
\subsubsection{Set Membership}
There are lots of tests of set membership elsewhere.
\subsubsection{True and False}
=SML
add_term("Ztrue",Ztrue);
add_term("Zfalse",Zfalse);
=TEX
\subsubsection{Logical Connectives}
=SML
add_term("Z³",Z³ mk_Ztrue);
add_term("Z±",Z±(mk_Ztrue,mk_Ztrue));
add_term("Z²",Z²(mk_Ztrue,mk_Ztrue));
add_term("Z´",Z´(mk_Ztrue,mk_Ztrue));
add_term("Z¤",Z¤(mk_Ztrue,mk_Ztrue));
=TEX
\subsubsection{Quantification}
=SML
add_term("Z¶",Z¶(mk_Zdecl[deca],mk_Ztrue,mk_Ztrue));
add_term("Z¶",Z¶(mk_Zdecl[decsexpbcf,deca],mk_Zeq(vara,varb),mk_Zeq(varc,varb)));
add_term("Z¶%down%1",Z¶%down%1(mk_Zdecl[deca],mk_Ztrue,mk_Ztrue));
add_term("Z¶%down%1",Z¶%down%1(mk_Zdecl[decsexpbcf,deca],mk_Zeq(vara,varb),mk_Zeq(varc,varb)));
add_term("Zµ",Zµ(mk_Zdecl[deca],mk_Ztrue,mk_Ztrue));
add_term("Zµ",Zµ(mk_Zdecl[decsexpbcf,deca],mk_Zeq(vara,varb),mk_Zeq(varc,varb)));
=TEX
\subsubsection{Schema as Predicate}
=SML
add_term("Zpredsexp",Zpredsexp(schbcf,""));
add_term("Zpredsexp",Zpredsexp(schbcf,"'"));
add_term("Z±",Z±(t 1,t 2));
add_term("Zpredsexp",Zpredsexp(schbcf,"?"));
add_term("Zpredsexp",Zpredsexp(schbcf,"!"));
add_term("Z±",Z±(t 1,t 2));
=TEX
\subsection{Tests on Schema Operations}
\subsubsection{Schema Construction}
In the schema constructor tests, we make two schemas of the same type in different ways and use the equality constructor to show that they are indeed of the same type.
A few other schemas are constructed and saved for later.
=SML
add_term("Z%down%s",Z%down%s(mk_Zdecl[decde,decsexpbcf,deca],mk_Ztrue));
add_term("Z%down%s",Z%down%s(mk_Zdecl[decabc,decdef],mk_Zeq(vara,varc)));
add_term("Zeq",Zeq(t 1,t 2));
val schabcdef1 = t 3;
val schabcdef2 = t 2;
add_term("Z%down%s",Z%down%s(mk_Zdecl[deca],mk_Ztrue));
val scha = t 1;
add_term("Z%down%s",Z%down%s(mk_Zdecl[decab],mk_Ztrue));
val schab = t 1;
add_term("Z%down%s",Z%down%s(mk_Zdecl[decabc],mk_Ztrue));
val schabc = t 1;
add_term("Z%down%s",Z%down%s(mk_Zdecl[decbc],mk_Zeq(varb,varc)));
val schbc = t 1;
add_term("Z%down%s",Z%down%s(mk_Zdecl[decf],mk_Ztrue));
val schf = t 1;
add_term("Z%down%s",Z%down%s(mk_Zdecl[decde],mk_Zeq(vare,vard)));
val schde = t 1;
=TEX
\subsubsection{Decoration}
In the tests for schema decoration, we show that component types are preserved.
=SML
add_term("Zdec%down%s",Zdec%down%s(scha,""));
add_term("Zdec%down%s",Zdec%down%s(scha,"!"));
add_term("Zdec%down%s",Zdec%down%s(scha,"?"));
add_term("Zdec%down%s",Zdec%down%s(scha,"'"));
add_term("Zeq",Zeq(mk_Zsel(mk_ZÊ(scha,""),"a"),mk_Zsel(mk_ZÊ(t 1,""),"a'")));
add_term("Zdec%down%s",Zdec%down%s(schabcdef1,"?"));
add_term("Zeq",Zeq(mk_Zsel(mk_ZÊ(schabcdef1,""),"a"),mk_Zsel(mk_ZÊ(t 1,""),"a?")));
add_term("Zeq",Zeq(mk_Zsel(mk_ZÊ(schabcdef1,""),"a"),mk_Zsel(mk_ZÊ(t 2,""),"b?")));
add_term("Zeq",Zeq(mk_Zsel(mk_ZÊ(schabcdef1,""),"f"),mk_Zsel(mk_ZÊ(t 3,""),"d?")));
=TEX
\subsubsection{Precondition}
=SML
add_term("Zdecsexp",Zdecsexp(scha,""));
add_term("Zdecsexp",Zdecsexp(schbc,"'"));
add_term("Zdecsexp",Zdecsexp(schf,"!"));
add_term("Zdecsexp",Zdecsexp(schde,"?"));
add_term("Z%down%s",Z%down%s(mk_Zdecl[t 1,t 2,t 3,t 4],mk_Ztrue));
add_term("Zpre%down%s",Zpre%down%s(t 1));
add_term("Zeq",Zeq(t 1,mk_Z%down%s(mk_Zdecl[t 3,t 6],mk_Ztrue)));
add_term("Z%down%s",Z%down%s(mk_Zdecl[t 7,t 4],mk_Ztrue));
add_term("Zpre%down%s",Zpre%down%s(t 1));
add_term("Zeq",Zeq(t 1,t 2));
add_term("Z%down%s",Z%down%s(mk_Zdecl[t 8,t 9],mk_Ztrue));
add_term("Zpre%down%s",Zpre%down%s(t 1));
add_term("Zeq",Zeq(t 1,mk_Zlvar("x",mk_ZpowerT(mk_ZschemaT []),[])));
=TEX
\subsubsection{Negation}
=SML
add_term("Z³%down%s",Z³%down%s scha);
add_term("Zeq",Zeq(scha,t 1));
add_term("Z³%down%s",Z³%down%s schbc);
add_term("Zeq",Zeq(schbc,t 1));
=TEX
\subsubsection{Conjunction}
=SML
add_term("Z±%down%s",Z±%down%s(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z±%down%s",Z±%down%s(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Disjunction}
=SML
add_term("Z²%down%s",Z²%down%s(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z²%down%s",Z²%down%s(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Implication}
=SML
add_term("Z´%down%s",Z´%down%s(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z´%down%s",Z´%down%s(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Equivalence}
=SML
add_term("Z¤%down%s",Z¤%down%s(schab,schbc));
add_term("Zeq",Zeq(schabc,t 1));
add_term("Z¤%down%s",Z¤%down%s(schbc,schab));
add_term("Zeq",Zeq(schabc,t 1));
=TEX
\subsubsection{Projection}
=SML
add_term("Zù%down%s",Zù%down%s(schab,schbc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zù%down%s",Zù%down%s(schabc,schbc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zù%down%s",Zù%down%s(schabc,scha));
add_term("Zeq",Zeq(scha,t 1));
=TEX
\subsubsection{Hiding}
=SML
add_term("Zhide%down%s",Zhide%down%s(schabc,["a"]));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zhide%down%s",Zhide%down%s(schabc,["b","c"]));
add_term("Zeq",Zeq(scha,t 1));
add_term("Zhide%down%s",Zhide%down%s(schabc,["a","b","c"]));
add_term("Zeq",Zeq(mk_Zlvar("x",mk_ZpowerT(mk_ZschemaT []),[]),t 1));
add_term("Zhide%down%s",Zhide%down%s(schabc,["a","b","c","d"]));
add_term("Z",Z(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Existential Quantification}
=SML
add_term("Z¶%down%s",Z¶%down%s(mk_Zdecl[deca],mk_Ztrue,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z¶%down%s",Z¶%down%s(mk_Zdecl[decbc],mk_Ztrue,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Z¶%down%s",Z¶%down%s(mk_Zdecl[decbc,deca],mk_Ztrue,schabc));
add_term("Z",Z(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Unique Existential Quantification}
=SML
add_term("Z¶%down%1%down%s",Z¶%down%1%down%s(mk_Zdecl[deca],mk_Ztrue,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Z¶%down%1%down%s",Z¶%down%1%down%s(mk_Zdecl[decbc],mk_Ztrue,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Z¶%down%1%down%s",Z¶%down%1%down%s(mk_Zdecl[decbc,deca],mk_Ztrue,schabc));
add_term("Z",Z(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Universal Quantification}
=SML
add_term("Zµ%down%s",Zµ%down%s(mk_Zdecl[deca],mk_Ztrue,schabc));
add_term("Zeq",Zeq(schbc,t 1));
add_term("Zµ%down%s",Zµ%down%s(mk_Zdecl[decbc],mk_Ztrue,schabc));
add_term("Zeq",Zeq(scha,t 1));
add_term("Zµ%down%s",Zµ%down%s(mk_Zdecl[decbc,deca],mk_Ztrue,schabc));
add_term("Z",Z(mk_Zlvar("x",mk_ZschemaT [],[]),t 1));
=TEX
\subsubsection{Sequential Composition}
=SML
add_term("Zdecsexp",Zdecsexp(scha,""));
add_term("Zdecsexp",Zdecsexp(schde,"'"));
add_term("Zdecsexp",Zdecsexp(schde,""));
add_term("Zdecsexp",Zdecsexp(schbc,"'"));
add_term("Z%down%s",Z%down%s(mk_Zdecl[t 3,t 4],mk_Ztrue));
add_term("Z%down%s",Z%down%s(mk_Zdecl[t 2,t 3],mk_Ztrue));
add_term("Z»%down%s",Z»%down%s(t 2,t 1));
add_term("Zeq",Zeq(mk_Z%down%s(mk_Zdecl[t 4,t 7],mk_Ztrue),t 1));
=TEX
\subsection{Run Tests}
=SML
run_discriminator_tests discriminator_functions (!terms);
run_destructor_tests (!terms);
=TEX
\section{END OF TESTS}
=SML
diag_string(summarize_mt_results ());
=TEX
\section{UNTESTED ERROR MESSAGES}
\label{untested}
\end{document}


