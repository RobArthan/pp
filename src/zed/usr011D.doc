% usr011D.doc   %Z% $Date$ $Revision$ $RCSfile$
% this should form a Chapter of the document
% Z Paragraphs
=TEX
\section{Paragraphs}

\subsection{Introduction}

\begin{itemize}
\item
Fixity declarations
\item
Given sets
\item
Abbreviation definitions
\item
Schema boxes
\item
Axiomatic descriptions
\item
Generics
\item
Free types
\item
Constraints
\end{itemize}

\subsection{Paragraph Processing Modes and Flags}

There are several different modes of processing Z paragraphs which are controlled by flags.

\begin{itemize}
\item
{\bf Type-checking Mode}

If the flag $z\_type\_check\_only$ is set to $true$ then only type checking of Z paragrpahs is performed.

This makes the response faster, and permits greater flexibility in amending paragraphs.
This mode is suitable for use while developing specifications prior to undertaking any proof work.

\item
{\bf Axiomatic Mode}
 
If the flag $z\_use\_axioms$ is set to true (and\\
$z\_type\_check\_only$ is set to $false$) then axiomatic descriptions and free-type descriptions are introduced using axioms.


\item
{\bf Conservative Mode}

If both the above flags is set $false$ then all Z axiomatic descriptions are introduced using the \Product{} $new\_specification$ facility, i.e. by conservative extension.

Consistency proof obligations, unless discharged automatically, will have to be discharged by the user.

In a future release it is hoped that free-types will also be supported by conservative extension.

\end{itemize}


\subsection{Fixity Declarations}


Fixity declarations may be provided for:

{\ftlmargin 0.5in
\begin{itemize}
\item
functions
¹Z
fun 10 twice _
°
¹Z
fun  slice ... from _ to _ 
°
\item
generics
¹Z
gen _ swap _
°
\item
relations
¹Z
rel  _ is_even 
°
\end{itemize}
}%\ftlmargin

The optional numeric value is a priority.

`\_' is a space for a parameter\\
`...' is a space for a sequence of parameters (with sequence brackets elided)

Fixity clauses can only be deleted by deleting the theory they are contained in.

\subsection{Given Sets}

\subsubsection{Syntax}

Given sets are introduced in the normal way a list of names enclosed in square brackets.
The paragraph is introduced in the \LaTeX source by `$¹Z$' and terminated by `$°$', each on a new line.

The displayed form is:

¹Z
[G1, G2]
°

\subsubsection{Proof Support}

Each given set causes the introduction of a new type and a new global variable known to be the set of all elements of that type.

The specification of the given set may be retrieved as follows: 

=SML
val G1_def = z_get_spec ñG1®;
=GFT ProofPower output
val G1_def = ô G1 = U : THM   
=TEX

`U' is the generic identity function, and when its actual generic parameter is not printed it may be assumed to be the set of all elements of the relevant type.
The normal proof contexts have knowledge of `U' so that rewriting with the specification of a given set will enable assertions about membership of the given set to be proven.

=SML
rewrite_conv [G1_def] ñx  G1®;
=GFT ProofPower output
val it = ô x  G1 ¤ true : THM   
=TEX

\subsection{Abbreviation Definitions}

\subsubsection{Syntax}

¹Z
X swap Y ¦ Y ¸ X 
°

\subsubsection{Proof Support}

=SML
val swap_def = z_get_spec ñ(_swap_)®;
=GFT ProofPower Output
val swap_def =
ô [X, Y](X swap Y = Y ¸ X) : THM   
=TEX

=SML
rewrite_conv [swap_def] ñú swap î®;
=TEX
=GFT ProofPower Output
val it = ô ú swap î = î ¸ ú : THM   
=TEX

\subsection{Schema Boxes}

\subsubsection{Syntax}

ÿSchüüüüüüüüüüüü
Ü	x, y : ú;
Ü	z : î
÷üüüüüüüüü
Ü	x = y ² y = z
ˆüüüüüüüüüüüüüü
\subsubsection{Proof Support}
=SML
val sch_def = z_get_spec ñSch®;
=GFT ProofPower Output
val sch_def = ô Sch =
  [x, y : ú; z : î | x = y ² y = z] : THM   
=TEX
=SML
rewrite_conv [sch_def (*, z'schemapred_def*)]
 ñµ x,y:ú; z:î · Sch ² disjoint §{x},{y},{z}¢®;
=TEX
=GFT ProofPower Output
val it = ô (µ x, y : ú; z : î · Sch
		² disjoint §{x}, {y}, {z}¢)
    ¤ (µ x, y : ú; z : î
      · [x, y : ú; z : î | x = y ² y = z]
      	² disjoint §{x}, {y}, {z}¢) : THM
=TEX

\subsection{Generic Schema Boxes}

\subsubsection{Syntax}

ÿDSUBS[X]üüüüüüüüüüü
Ü	set1, set2: ğ X
÷üüüüüüüüüüüüü
Ü	set1 ¡ set2 = {}
ˆüüüüüüüüüüüüüüüü

\subsubsection{Proof Support}

=SML
val dsubs_def = z_get_spec ñDSUBS®;
=GFT ProofPower Output
val dsubs_def = ô [X](DSUBS[X] =
  [set1, set2 : ğ X | set1 ¡ set2 = {}]) : THM
=TEX
=SML
rewrite_conv [dsubs_def (*, z'schemapred_def*)]
 ñµ DSUBS[î] · set1 € î ± set2 € î®;
=GFT ProofPower Output
val it = ô (µ (DSUBS[î]) · set1 € î ± set2 € î)
	¤ (µ [set1, set2 : ğ î | set1 ¡ set2 = {}] ·
		set1 € î ± set2 € î) : THM
=TEX
\ignore{
set_goal([],ñµ DSUBS[î] · set1 € î ± set2 € î®);
a (z_strip_tac THEN rewrite_tac [dsubs_def,z'schemapred_def]);
a (conv_tac (MAP_C z__horiz_schema_conv));
 THEN REPEAT strip_tac);

=TEX
=GFT ProofPower Output
val it = ô (µ (DSUBS[î]) · set1 € î ± set2 € î)
    ¤ (µ [set1, set2 : ğ î | set1 ¡ set2 = {}] ·
    		set1 € î ± set2 € î) : THM
=TEX
}

\subsection{Axiomatic Descriptions}

\subsubsection{Syntax}

¹ZAX
Ü	twice _ : ú ­ ú
÷üüüüüüüüüüü
Ü	µi : ú · twice i = 2*i
°
\subsubsection{Proof Support}
=SML
val twice_def = z_get_spec ñ(twice_)®;
=GFT ProofPower Output
val twice_def = ô (twice _)  ú ­ ú
	± (µ i : ú · twice i = 2 * i) : THM   
=TEX
=SML
rewrite_conv[twice_def] ñtwice 4®;
=GFT ProofPower Output
Exception- Fail * no rewriting occurred
  [rewrite_conv.26001] * raised
=TEX
=SML
set_goal([],ñµ n:ú · twice n = 2*n®);
a (REPEAT z_strip_tac);
=GFT ProofPower Output
(* *** Goal "" *** *)

(*  1 *)  ñn  ú®

(* ?ô *)  ñtwice n = 2 * n®
=TEX
=SML
a (fc_tac [twice_def]);
=GFT ProofPower Output
Current and main goal achieved
=TEX

\subsection{Generic Axiomatics}


\subsubsection{Syntax}

[X]œœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü slice ... from _ to _ : ((seq X) ¸ î ¸ î) ­ seq X
÷üüüüüüüüüüüüüüüü
Ü	µ l,r:î; s: seq X ·
Ü	(slice ... from _ to _) (s,l,r) = (l .. r) ò s
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
[A, B, C]œœœœœœœœœœœœœœœœœœœœœœœœ
Ü	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷üüüüüüüüüüüüüüüüüü
Ü	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüüüüüü
[X]üüüüüüüüüüüüüüüüüüüü
Ü length : seq X ­ î
÷üüüüüüüüüüüüüüüü
Ü	length §¢ = 0;
Ü	µ h:X; t: seq X·
Ü	length (§h¢ ë t) = length t + 1
ˆüüüüüüüüüüüüüüüüüüüüüü

\subsubsection{Proof Support}

=SML
val slice_from_to_def =
  z_get_spec ñ(slice ... from _ to _)®;
=GFT ProofPower Output
val slice_from_to_def = ô
 [X]((slice ... from _ to _)[X]
 		 (seq X) ¸ î ¸ î ­ seq X
 ± (µ l, r : î; s : seq X ·
 	(slice ... from _ to _)[X] (s, l, r)
 	= (l .. r) ò s)) : THM
=TEX


\subsection{Free Types}


\subsubsection{Syntax}

¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°

\subsubsection{Proof Support}

=SML
val tree_def = z_get_spec ñTREE®;
=GFT ProofPower Output
val tree_def = ô TREE = U : THM   
=TEX

=SML
val tip_def = z_get_spec ñtip®;
=GFT ProofPower Output
val tip_def = ô (tip  TREE
 ± fork  î ¸ TREE ¸ TREE à TREE)
 ± disjoint §{tip}, ran fork¢
 ± (µ W : ğ TREE | {tip} À fork ¨ î ¸ W ¸ W © € W·
	TREE € W) : THM
=TEX

\subsection{Mutually Recursive Free Types}

\subsubsection{Syntax}

¹Z
TYPE ::= Tvar G1 | Tcon (G1 ¸ seq TERM)
&
TERM ::= Con (G1 ¸ TYPE) | App (TERM ¸ TERM)
°

\subsubsection{Proof Support}

=SML
val tvar_def = z_get_spec ñTvar®;
=GFT ProofPower Output
val tvar_def = ô (Tvar  G1 à TYPE
    ± Tcon  G1 ¸ (seq TERM) à TYPE
    ± Con  G1 ¸ TYPE à TERM
    ± App  TERM ¸ TERM à TERM)
    ± (disjoint §ran Tvar, ran Tcon¢
    ± (µ W : ğ TYPE
      | Tvar ¨ G1 © À Tcon ¨ G1 ¸ (seq TERM) © € W
      · TYPE € W))
    ± disjoint §ran Con, ran App¢
    ± (µ W : ğ TERM
      | Con ¨ G1 ¸ TYPE © À App ¨ W ¸ W © € W
      · TERM € W) : THM
=TEX

\subsection{Constraints}

\subsubsection{Syntax}

¹Z
[X] ((¶f : X à G1 · true)
	¤ (¶f : X à G2 · true))
°
¹Z
 {1} swap {§1¢} = {§1¢} ¸ {1}
 	± Sch ½ [x, y, z : ú] 
°
¹Z
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))
 	 (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú)
°
\subsubsection{Proof Support}

=SML
val c1 = get_axiom "-" "Constraint 1";
=GFT ProofPower output
val c1 = ô [X]((¶ f : X à G1 · true) ¤
		(¶ f : X à G2 · true)) : THM   
=TEX

