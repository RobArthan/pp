% imp062.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplatetex
\documentstyle[hol1,11pt,TQ]{article}
\makeindex
% The following macro is used to insert temporary notes
% in the document.
\def\TempNote#1{{\tiny#1}}
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Type Inferrer}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP062}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}                    %% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{Z, HOL}
\TPPauthor{D.J.~King&WIN01}
%\TPPauthors{R.D.~Arthan&WIN01\\D.J.~King&WIN01\\G.T.~Scullard&MAN05}
\TPPauthorisation{R.D.~Arthan & FMU Manager}
\TPPabstract{This document contains the Standard ML code for the type
inferrer for HOL/Z.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	  R.D.~Arthan \\ R.B.~Jones \\ G.T. Scullard
}}
 
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List} \tableofcontents
\subsection{Document Cross References}\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}
\item[\SCCSversion (9 June 1992)] Initial version.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the Z type inferrer described in
\cite{DS/FMU/IED/DTD062}, and responds to that document. The type inferrer
comprises part of the Z user interface which is overviewed in \cite{DS/FMU/IED/HLD018}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
The purpose of the Z type inferrer is check Z paragraphs as produced by the
Z parser \cite{DS/FMU/IED/DTD061}, according to the typing rules written down in
the detailed design for the type inferrer \cite{DS/FMU/IED/DTD062}. The type inferrer
yields a correctly typed term, and a substitution function containing all the necessary
typing information for the paragraph. If the paragraph is ill-typed, then error
information is returned, for subsequent printing out by a function provided in the
type inferrer structure.

\subsubsection{Dependencies}

The type inferrer is contained within the structure $ZTypeInference$, which is
constrained by the signature of the same name, specified in \cite{DS/FMU/IED/DTD062}.

\subsubsection{Interface}

The following interfaces to the type inferrer module are made public:

\begin{itemize}

\item[1.]
Functions which permit formatting of the abstract syntax tree for Z paragraphs and
their components.

\item[2.]
A function for formatting error information returned by the type inferrer.

\item[3.]
The function which type infers Z paragraphs $type\_check\_zpara$.

\end{itemize}

\subsubsection{Algorithms}
\subsubsection{Possible Enhancements}

The coding of the variable environment as a combination of pure functional overriding,
and imperative programming could be made more elegant by implementating environment
frame stack as a list of frames.

\subsubsection{Deficiencies}

There is no decent error handling for a case of generic actuals being incompatible
with the type of the defined constant.


\section{PREAMBLE}
First we introduce the structure for Z type inference.

=SML
structure €ZTypeInference› : ZTypeInference = struct
=TEX
=SML
	open Unification ZLex ZUserInterfaceSupport;
	open ZTypesAndTermsSupport;

=TEX

\subsection{Flags and Switches}

The flag $zti\_standard\_z$ denotes that type inference is to be carried
out according to the rules which denote standard (rather than extended) Z.

=SML
val €zti_standard_z› = ref true;
=TEX

The following declarations define space for the substitution function.
=SML
val €zarray_size› = 100;
val €zti_subs› = new_subs zarray_size;
=TEX

\section{CONVERTING STRINGS TO IDENTIFIERS ETC.}
=TEX
=SML
fun €string_of_ident› ((t, d) : IDENT) : string = (
	string_of_template t ^ d
);
=TEX
=SML
fun €ident_of_string› (s : string) : IDENT = (
let	fun strip_decor (d::rest) decors = (
		if (d mem ["?", "!", "'"])
		then	strip_decor rest (d::decors)
		else	(d::rest, decors)
	)
	  | strip_decor [] decors = ([], decors);
	val (xrs, d) = strip_decor ((rev o explode) s) [];
	val xs = implode (rev xrs);
in	(template_of_string xs, implode d)
end
);
=TEX


\section{FORMATTING Z SCHEMA TEXT AND TERMS}

The functions introduced in this section permit the formatting of Z paragraphs
represented as an abstract syntax tree, and the parts which comprise
Z paragraphs. These interfaces are intended to be public as they will no
doubt prove useful to applications programmers and testers.

First a few of auxiliary functions which will be useful.

=SML
fun €type_of_extype› (phi : SUBS) (f : int -> string) ty = (
let	fun aux (ExVartype(Known x)) = (
		mk_vartype x
	) | aux (ExVartype(Unknown x)) = (
		case SparseArray.sub_opt (phi, x) of
			Nil => (mk_vartype (f x))
			| Value y => aux y
	) | aux (ExType(s, l)) = (
		mk_ctype(s, map aux l)
	);
in
	aux ty
end);
=TEX
The following code does not yet check that there are no free types in the
term whose names might clash with those generated by $mk\_freetype\_name$. This
will need to be amended some time in the future.

=SML

fun €mk_freetype_name› (i : int) : string =
	if i >= 0 andalso i < 26
	then "'"^(chr (i+ord "a"))
	else "'"^(string_of_int i);

fun €type_of_zextype› (ty : EXTYPE) : TYPE = (
	type_of_extype zti_subs mk_freetype_name ty
);
=TEX
=SML
local

fun	f_ztype (ty : TYPE) : string =
	if is_ZgivenT ty
	then
		dest_ZgivenT ty
	else
	if is_ZvarT ty
	then
		"'" ^ (dest_ZvarT ty)
	else
	if is_ZpowerT ty
	then
	let	val tyt = dest_ZpowerT ty;
		fun	f [ty1, ty2] = (f_ztype ty1) ^ " ™ " ^ (f_ztype ty2)
		|	f _ = " " ^ (f_ztype tyt);
	in
		f (dest_ZtupleT tyt)
			handle _ => f []	
	end
	else
	if is_ZtupleT ty
	then
	let	val tyl = dest_ZtupleT ty
		fun 	f [] = ""
		|	f [ty] = f_ztype ty
		|	f (h::t) = "(" ^ (f_ztype h) ^ " ∏ " ^ (f t) ^ ")"
	in
		f tyl
	end
	else
	if is_ZschemaT ty
	then
	let	val tym = dest_ZschemaT ty
		fun 	f [] = ""
		|	f [(s,ty)] = s ^ ":" ^ (f_ztype ty)
		|	f ((s,ty)::t) = s ^ ":" ^ (f_ztype ty) ^ ";" ^ (f t)
	in
		"[" ^ (f tym) ^ "]"
	end
	else
		fail "f_ztype" 62999 [];
fun	f_gens (ty : TYPE) : string = 
	let	val tyl = map (dest_ZvarT o dest_ZpowerT) (dest_ZtupleT ty);
		fun	f [] = ""
		|	f [s] = s
		|	f (h::t) = h ^ "," ^ (f t);
	in
		"[" ^ (f tyl) ^ "]"
	end;
fun	strip_≠_type1 (ty : TYPE): TYPE list * TYPE = (
	let fun aux typ l= (
		if is_≠_type typ
		then 	let 	val (ty1,ty2) = dest_≠_type typ
			in aux  ty2 (l @ [ty1]) 
			end
		else (l,typ)
		);
	in	aux ty [] 
	end
);
in
fun	€format_ztype› (ty : TYPE) : string = (
let	val (gens,zty) = strip_≠_type1 ty;
in
	f_ztype zty
end
handle Fail _ => (PolyML.makestring ty)
)
end (* of local ... in *);
=TEX
=SML
fun €format_zextype› (ty : EXTYPE) : string = format_ztype (type_of_zextype ty);
=TEX
\section{SUPPORTING FUNCTIONS}


\subsection{Auxiliary Functions}
=SML
fun €ex_set› t = ExType ("SET", [t]);
val €ex_˙› = ExType ("˙", []);
val €ex_string› = ExType ("LIST", [ExType ("CHAR",[])]);
fun €ex_≠› (f, a) = ExType ("≠", [f, a]);
val €ex_bool› = ExType ("BOOL", []);
=TEX

\section{ERROR HANDLING AND REPORTING}

=SML
datatype Z_VAR_TYPE =
		GlobalVar of EXTYPE
	|	BoundVar of EXTYPE
	|	FreeVar of EXTYPE OPT;
=TEX

=SML
type €Z_ENV› = IDENT -> Z_VAR_TYPE;
=TEX

=SML
datatype €Z_DETAILS›	=
		Failedß¢ of Z_TM list * EXTYPE list
	|	FailedSetd of Z_TM list * EXTYPE list
	|	FailedSeta of Z_TM * EXTYPE * int
	|	Failedset of Z_TM * EXTYPE
	|	Failed∏ of Z_TM list * EXTYPE list
	|	Failed  of Z_TM * EXTYPE
	|	FailedSelâT1 of int * int
	|	FailedSelâT2 of Z_TM * EXTYPE
	|	FailedSelâB1 of Z_TM * IDENT
	|	FailedSelâB2 of Z_TM * EXTYPE
	|	FailedApp of Z_TM * Z_TM * EXTYPE * EXTYPE
	|	FailedFancyApp of IDENT * Z_TM * EXTYPE * EXTYPE
	|	Failed≥âF of Z_TM * EXTYPE
	|	FailedLogInOpâF of Z_LOG_IN_OP * Z_TM * EXTYPE
	|	FailedQuantâF of Z_QUANT * Z_TM * EXTYPE
	|	FailedDecor of Z_TM * EXTYPE
	|	FailedPre of Z_TM * EXTYPE
	|	Failed≥âS of Z_TM * EXTYPE
	|	FailedLogInOpâS1 of Z_LOG_IN_OP * Z_TM * Z_TM * (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	FailedLogInOpâS2 of Z_LOG_IN_OP * Z_TM * EXTYPE
	|	Failed˘1 of Z_TM * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	Failed˘2 of Z_TM * EXTYPE
	|	FailedHide of Z_TM * EXTYPE
	|	FailedQuantâS1 of Z_QUANT * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	FailedQuantâS2 of Z_QUANT * Z_TM * EXTYPE
	|	FailedQuantâS3 of Z_QUANT * Z_TM * IDENT list
	|	FailedÑ of Z_TM * EXTYPE
	|	Failedò of Z_TM * EXTYPE
	|	FailedEq of Z_TM * Z_TM * EXTYPE * EXTYPE
	|	Failedç1 of Z_TM * EXTYPE
	|	Failedç2 of Z_TM * EXTYPE
	|	Failedª1 of Z_TM * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	Failedª2 of Z_TM * EXTYPE
	|	FailedPipe1 of Z_TM * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	FailedPipe2 of Z_TM * EXTYPE
	|	FailedConstrained of Z_TM * EXTYPE * Z_TM
	|	FailedRename1 of Z_TM * EXTYPE
	|	FailedRename2 of IDENT list
	|	FailedRename3 of IDENT list
	|	FailedFreeVar of IDENT
	|	FailedEnv of Z_TM * IDENT * EXTYPE * EXTYPE;

=TEX
=SML
datatype €Z_PARA_DETAILS› =
		FailedZPGiven
	|	FailedZPConstraint
	|	FailedZPConjecture;
=TEX
The following type definition is visible via the signature
$ZTypeInference$.
=SML
datatype €LOCAL_ERROR_INFO› =
		FailedZTm of Z_TM * Z_ENV * Z_DETAILS
	|	FailedZSchText of Z_SCH_TEXT * Z_ENV * Z_TM * EXTYPE
	|	FailedZDec1 of Z_DEC * Z_ENV * Z_TM * EXTYPE
	|	FailedZDec2 of Z_DEC * Z_ENV * Z_TM * EXTYPE
	|	FailedZDec3 of Z_DEC * Z_ENV * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list	|	FailedZCompat of (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	FailedZIncludes of IDENT list
	|	FailedZPara of Z_TM * EXTYPE * Z_PARA_DETAILS
	|	FailedZFreeVar of IDENT;

type €Z_ERROR_INFO›	=	LOCAL_ERROR_INFO;
=TEX
=SML
exception €ZExn› of LOCAL_ERROR_INFO;
=TEX

=SML
fun €report› (msg : int) (inserts : string list) : unit = (
	diag_string (get_error_message msg inserts)
);
=TEX

=SML
fun €not_a_set› (tm : Z_TM) (ty : EXTYPE) = (
	report 62910 [];
	report 62900 [format_ztm tm, format_zextype ty]
);
=TEX

=SML
fun €not_a_sequence› (tm : Z_TM) (ty : EXTYPE) = (
	report 62911 [];
	report 62900 [format_ztm tm, format_zextype ty]
);
=TEX

=SML
fun €not_a_predicate› (tm : Z_TM) (ty : EXTYPE) = (
	report 62912 [];
	report 62900 [format_ztm tm, format_zextype ty]
);
=TEX

=SML
fun €not_a_schema› (tm : Z_TM) (ty : EXTYPE) = (
	report 62913 [];
	report 62900 [format_ztm tm, format_zextype ty]
);
=TEX

=SML
fun €not_a_binding› (tm : Z_TM) (ty : EXTYPE) = (
	report 62914 [];
	report 62900 [format_ztm tm, format_zextype ty]
);
=TEX

=SML
fun €not_a_tuple› (tm : Z_TM) (ty : EXTYPE) = (
	report 62915 [];
	report 62900 [format_ztm tm, format_zextype ty]
);
=TEX

=SML
fun €print_zerrlistinfo› (tml : Z_TM list) (tyl : EXTYPE list) : unit = (
let	
	fun plu (x1::x2::rest) = "s"
	  | plu [x1] = ""
	  | plu nil = error "print_zerrlistinfo" 62998 [
		fn()=>"plu"];
	fun sort1 (i1 : int, (tm1:string, ty1:string)) (i2, (tm2, ty2)) =
		if ty1 = ty2 then
			if tm1 = tm2 then 0
			else i1 - i2
		else	Sort.string_order ty1 ty2;
	fun grpaux ((ty1, tmlist1)::rest1) ((tm2, ty2)::rest2) =
		if ty1 = ty2
		then grpaux ((ty1, tmlist1@[[tm2]])::rest1) rest2
		else grpaux ((ty2, [[tm2]])::(ty1,tmlist1)::rest1) rest2
	  | grpaux res _ = res;	

	fun grp ((tm, ty)::rest) = grpaux [(ty, [[tm]])] rest
	  | grp _ = error "print_zerrlistinfo" 62999 [];
	fun do_errmsgs ((ty, tmlist)::rest) = (
		report 62902 [ty, plu tmlist];
		map (report 62901) tmlist;
		do_errmsgs rest
	) | do_errmsgs nil = nil;
	val stml = map format_ztm tml;
	val styl = map format_zextype tyl;
	val tmty = (combine stml styl);
	val itmty = combine (interval 1 (length styl)) tmty;
	val stmty = (map snd) (Sort.sort sort1 (rev itmty));
in
	(do_errmsgs (grp stmty);()
	)
end);
=TEX

=SML
fun €incompatible_schemas› (tm1 : Z_TM) (tm2 : Z_TM) (idtyl1 : (IDENT * EXTYPE) list)
	(idtyl2 : (IDENT * EXTYPE) list) = (
	report 62921 [];
	report 62922 [format_ztm tm1];
	map (fn (id, ty) => report 62900 [format_ident id, format_zextype ty]) idtyl1;
	report 62922 [format_ztm tm2];
	map (fn (id, ty) => report 62900 [format_ident id, format_zextype ty]) idtyl2;
	()
);
=TEX
=SML
fun €incompatible_quant› (tm : Z_TM) (idtyl1 : (IDENT * EXTYPE) list) (idtyl2 : (IDENT * EXTYPE) list) = (
	report 62921 [];
	report 62924 [];
	map (fn (id, ty) => report 62900 [format_ident id, format_zextype ty]) idtyl1;
	report 62922 [format_ztm tm];
	map (fn (id, ty) => report 62900 [format_ident id, format_zextype ty]) idtyl2;
	()
);
=TEX
=SML
fun €incompatible_comps› (idtyl1 : (IDENT * EXTYPE) list) (idtyl2 : (IDENT * EXTYPE) list) = (
	report 62921 [];
	map (fn (id, ty) => report 62900 [format_ident id, format_zextype ty]) idtyl1;
	map (fn (id, ty) => report 62900 [format_ident id, format_zextype ty]) idtyl2
);
=TEX
=SML
fun €print_zerror› ((FailedZTm (term, env, details)) : Z_ERROR_INFO) = (
	report 62001 [format_ztm term];
	(case details of

	Failedß¢ (tml, tyl) => (
		report 62011 []; print_zerrlistinfo tml tyl
	) | FailedSetd (tml, tyl) => (
		report 62021 []; print_zerrlistinfo tml tyl
	) | FailedSeta (tm, ty, ierr) => (
		report ierr []; not_a_predicate tm ty
	) | Failedset (tm, ty) => (
		report 62041 []; not_a_set tm ty
	) | Failed∏ (tml, tyl) => (
		report 62061 []; print_zerrlistinfo tml tyl
	) | Failed  (tm, ty) => (
		report 62071 []; not_a_schema tm ty
	) | FailedSelâT1 (i, j) => (
		report 62086 []; report 62087 [string_of_int i, string_of_int j]
	) | FailedSelâT2 (tm, ty) => (
		report 62088 []; not_a_tuple tm ty
	) | FailedSelâB1 (tm, id) => (
		report 62081 []; report 62082 [format_ident id];
		report 62083 [format_ztm tm]
	) | FailedSelâB2 (tm, ty) => (
		report 62084 []; not_a_binding tm ty
	) | FailedApp (tm1, tm2, ty1, ty2) => (
		report 62091 [];
		report 62092 [format_ztm tm1, format_zextype ty1];
		report 62093 [format_ztm tm2, format_zextype ty2]
	) | FailedFancyApp (id, tm, ty1, ty2) => (
		report 62091 [];
		report 62092 [format_ident id, format_zextype ty1];
		report 62093 [format_ztm tm, format_zextype ty2]
	) | Failed≥âF (tm, ty) => (
		report 62151 []; not_a_predicate tm ty
	) | FailedLogInOpâF (inop, tm, ty) => (
		report 62161 [format_z_in_op inop];
		not_a_predicate tm ty
	) | FailedQuantâF (quant, tm, ty) => (
		report 62162 [format_quant quant]; not_a_predicate tm ty
	) | FailedDecor (tm, ty) => (
		report 62131 []; not_a_schema tm ty
	) | FailedPre (tm, ty) => (
		report 62141 []; not_a_schema tm ty
	) | Failed≥âS (tm, ty) => (
		report 62142 []; not_a_schema tm ty
	) | FailedLogInOpâS1 (inop, tm1, tm2, idtyl1, idtyl2) => (
		report 62168 [format_z_in_op inop];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | FailedLogInOpâS2 (inop, tm, ty) => (
		report 62167 [format_z_in_op inop];not_a_schema tm ty
	) | Failed˘1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62172 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | Failed˘2 (tm, ty) => (
		report 62171 []; not_a_schema tm ty
	) | FailedHide (tm, ty) => (
		report 62181 []; not_a_schema tm ty
	) | FailedQuantâS1 (quant, tm, idtyl1, idtyl2) => (
		report 62192 [format_quant quant];
		report 62193 [];
		incompatible_quant tm idtyl1 idtyl2
	) | FailedQuantâS2 (quant, tm, ty) => (
		report 62191 [format_quant quant];
		not_a_schema tm ty
	) | FailedQuantâS3 (quant, tm, idl) => (
		report 62192 [format_quant quant];
		report 62195 [];
		report 62196 [format_ztm tm];
		map (fn id => report 62901 [format_ident id]) idl;
		()
	) | FailedÑ (tm, ty) => (
		report 62200 []; not_a_schema tm ty
	) | Failedò (tm, ty) => (
		report 62201 []; not_a_schema tm ty
	) | FailedEq (tm1, tm2, ty1, ty2) => (
		report 62251 [];
		report 62904 [];
		report 62900 [format_ztm tm1, format_zextype ty1];
		report 62900 [format_ztm tm2, format_zextype ty2]
	) | Failedª1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62281 [];
		report 62282 [];
		report 62283 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | Failedª2 (tm, ty) => (
		report 62280 [];
		not_a_schema tm ty
	) | FailedPipe1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62291 [];
		report 62292 [];
		report 62293 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | FailedPipe2 (tm, ty) => (
		report 62290 [];
		not_a_schema tm ty
	) | Failedç1 (tm, ty) => (
		report 62252 []; not_a_set tm ty
	) | Failedç2 (tm, ty) => (
		report 62253 [];
		report 62903 [];
		report 62900 [format_ztm tm, format_zextype ty]
	) | FailedConstrained (tm1, ty, tm2) => (
		report 62261 [];
		report 62262 [format_ztm tm1, format_zextype ty];
		report 62263 [format_ztm tm2]
	) | FailedRename1 (tm, ty) => (
		report 62271 []; not_a_schema tm ty
	) | FailedRename2 idl => (
		report 62272 []; report 62273 [];
		(case idl of
		[_] => report 62916 []
		|_ => report 62917 []);
		map (fn id => report 62901 [format_ident id]) idl;
		()
	) | FailedRename3 idl => (
		report 62272 []; report 62274 [];
		(case idl of
		[_] => report 62916 []
		|_ => report 62917 []);
		map (fn id => report 62901 [format_ident id]) idl;
		()
	) | FailedFreeVar id => (
		report 62980 []; report 62981 [];
		report 62901 [format_ident id]
	) | FailedEnv (tm, id, ty1, ty2) => (
		report 62504 []; report 62505 [];
		report 62922 [format_ztm tm];
		report 62900 [format_ident id, format_zextype ty1];
		report 62925 [];
		report 62900 [format_ident id, format_zextype ty2]
	) (* end case *)
	);
	fail "Z-Parser" 62000 []
=TEX
=SML
) | print_zerror (FailedZSchText (schtext, env, tm, ty)) = (
	report 62001 [format_zschtext schtext];
	report 62502 [];
	not_a_predicate tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZDec1 (dec, env, tm, ty)) = (
	report 62001 [format_zdec dec];
	report 62501 [];
	not_a_set tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZDec2 (dec, env, tm, ty)) = (
	report 62001 [format_zdec dec];
	report 62503 [];
	not_a_schema tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZDec3 (dec, env, idtyl1, idtyl2)) = (
	report 62001 [format_zdec dec];
	report 62506 [];
	report 62507 [];
	incompatible_comps idtyl1 idtyl2;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZCompat (idtyl1,idtyl2)) = (
	report 62920 [];
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZIncludes idl) = (
	report 62923 [];
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZPara (tm, ty, det)) = (
	report 62002 []; (
		case det of
		FailedZPGiven => (report 62801 []; report 62802 [];())
		|FailedZPConstraint => (report 62803 [])
		|FailedZPConjecture => (report 62804 [])
		);
	not_a_predicate tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZFreeVar id) = (
	report 62980 []; report 62981 [];
	report 62901 [format_ident id];
	fail "Z-Parser" 62000 []
);
=TEX

\subsection{The Environment}

=SML
val table:(IDENT * Z_VAR_TYPE) list ref = ref [];
=TEX
=SML
fun €sub_ty› (env:Z_ENV) : Z_ENV = (
	fn id =>
		case env id of
		GlobalVar ty => GlobalVar (sub_type zti_subs ty)
		|BoundVar ty => BoundVar (sub_type zti_subs ty)
		|FreeVar (Value ty) => FreeVar  (Value (sub_type zti_subs ty))
		|FreeVar Nil => FreeVar Nil
);
=TEX
=SML
fun €get_zconst_type› (s : string) : TYPE OPT = get_const_type (bind_gvar_name s);
=TEX
=SML
local
	fun freety id = (id, BoundVar (ex_set (ExType (string_of_ident id, []))));
	fun formal id = (id, BoundVar (ex_set (ExVartype(Known("'"^(string_of_ident id))))));
in
fun €init_zenv› (ftdef : bool) (genformals : IDENT list) : Z_ENV = (
let	val dummy = start_again();
	val side = if ftdef
		then
			table := (map freety genformals)
		else
			table := (map formal genformals);
in
	fn id => (
		case lassoc5 (!table) id of
		Value vty => vty
		|Nil => (
			case get_zconst_type (string_of_ident id) of
			Value ty =>
				GlobalVar (replaced ty)
			|Nil =>
				FreeVar Nil
		)
	)
end
);
end (* of local ... in *);
=TEX
=SML
fun €update_zenv› (env : Z_ENV) (id : IDENT) : Z_ENV = (
	case env id of
	FreeVar Nil =>
		if (!zti_standard_z)
		then
			raise ZExn (FailedZFreeVar id)
		else
			let	val side = table := (id, FreeVar (Value (ExVartype
				(Unknown (next_name()))))):: !table;
			in
				env
			end
	|_ => env
);
=TEX
=SML
fun €bind_zenv› (env : Z_ENV) (term : Z_TM) (tm : Z_TM) (idtyl : (IDENT * EXTYPE) list) : Z_ENV = (
let	fun bz_unify id (ty1, ty2) = (
		unify zti_subs (ty1, ty2)
			handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEnv (tm, id, ty1, ty2)))
		);
	fun aux (id, ty) = (
		case env id of
		FreeVar Nil => (
			table := (id, FreeVar (Value ty)):: !table
			)
		|FreeVar (Value ty') => bz_unify id (ty, ty')
		|BoundVar ty' => bz_unify id (ty, ty')
		|GlobalVar ty' => bz_unify id (ty, ty')
	);
in
	map aux idtyl; env
end
);
=TEX
=SML
fun €dec_boundvars› (env : Z_ENV) (idtyl : (IDENT * EXTYPE) list) : Z_ENV = (
	fn id => (
		case lassoc5 idtyl id of
		Nil => env id
		|Value ty => BoundVar ty
		)
);
=TEX
=SML
fun €show_env› () : (IDENT * Z_VAR_TYPE) list = (
	!table
);
=TEX


\section{SUPPORT FOR SCHEMAS}
=SML
datatype €MANIFEST_EXTYPE› =
		NotManifest
	|	TupleType of EXTYPE list
	|	BindingType of (IDENT * EXTYPE) list
	|	SchemaType of (IDENT * EXTYPE) list;
=TEX

=SML
fun	€idsetseq› (sl:string list) : string list = Sort.sort Sort.string_order sl;
=TEX
=SML
fun	€flatpack› ([]:string list) : string 	= ""
|	flatpack (s::[])			= s
|	flatpack (s::ss) 			= s ^ "," ^ (flatpack ss);
=TEX


=SML

fun 	€val_setIDENT› (sl:string list) :string =
	"[" ^ flatpack(idsetseq sl) ^ "]";

fun	 €iextymfunseq› (itym:(string * EXTYPE)list) :EXTYPE list =
	map (lassoc3 itym) (idsetseq(fst(split itym)));
=TEX

=SML
fun	€bind_exname› (fid :IDENT list) :string = (
let	val sl = map string_of_ident fid;
in	
	"Z'S" ^ (val_setIDENT sl)
end);

fun 	€bind_extype› (itym :(IDENT * EXTYPE) list) :EXTYPE = (
let	val itym' = map (fn (id, ty) => (string_of_ident id, ty)) itym;
in
		ExType (bind_exname(fst(split itym)), iextymfunseq itym')
end);

=TEX
=SML
fun €unbind_extype› (ty : EXTYPE) : (IDENT * EXTYPE) list = (
	case ty of
	ExType (s, tyl) => (
		let	val (mani, sll) = dest_Z_name s;
		in
			case mani of
			"Z'S" => (
				case sll of
				[sl] => combine (map ident_of_string sl) tyl
				|_ => fail "unbind_extype" 62953 []
				)
			| _ => fail "unbind_extype" 62954 []
			
		end)
	|_ => fail "unbind_extype" 62954 []
);
=TEX

The following makes use of the Z mapping \cite{DS/FMU/IED/ZED003}
and \cite{DS/FMU/IED/ZED002}.
=SML
fun	€tuple_exname› (tyl: EXTYPE list) :string = "Z'T[" ^ string_of_int(length tyl) ^ "]";
fun	€tuple_extype› (tyl: EXTYPE list) :EXTYPE = ExType(tuple_exname tyl,tyl);
=TEX

=SML
fun €untuple_extype› (ty : EXTYPE) : EXTYPE list = (
	case ty of
	ExType (s, tyl) => (
		let	val (mani, sll) = dest_Z_name s;
		in
			case mani of
			"Z'T" => tyl
			| _ => fail "untuple_extype" 62955 []
			
		end)
	|_ => fail "untuple_extype" 62955 []
);
=TEX


=SML
fun  €manifest› (ty:EXTYPE) : MANIFEST_EXTYPE = (
	case ty of

	ExType("SET",[ty']) => (
	   	SchemaType (unbind_extype ty')
		handle Fail _ => NotManifest

	)|ExType(_,_) => (
		TupleType (untuple_extype ty)
		handle Fail _ =>
			BindingType (unbind_extype ty)
			handle Fail _ => NotManifest
	)|_ => NotManifest
);
=TEX
=SML
fun €chartuple› ((decls, tm, _) : Z_SCH_TEXT) : Z_TM = (
let	fun f (ZDec(ids, tm, _)) = (
		map (fn id => ZTmLVar(id, Nil, [])) ids
	) | f (ZSchemaDec (ZTmDecor (tm1, d), _)) = (
		[ZTm (tm1, d)]
	) | f (ZSchemaDec (tm1, _)) = (
		[ZTm (tm1, "")]
	);
in
	case decls of
	[] => error "chartuple" 62998 [fn()=>"empty declaration"]
	|[decl] => (case f decl of
			[tm] => tm
			|tms => ZTmTuple tms)
	|decls => ZTmTuple(flat (map f decls)
	)
end);
=TEX
The following function is used by the term generator.

=SML
fun €make_chartuple› ((decls, _, _) : Z_SCH_TEXT) : Z_TM * EXTYPE = (
let	fun f (ZDec(ids, tm, Value ty)) = (
		(map (fn id => (ZTmLVar(id, Value ty, []), ty)) ids)
	) | f (ZSchemaDec (ZTmDecor (tm, d), Value ty)) = (
	let	val ty' = case sub_type zti_subs ty of
				ExType ("SET", [ty'']) => ty''
				| _ => error "make_chartuple" 62999 [];
	in
		[(ZTm (tm, d), ty')]
	end
	) | f (ZSchemaDec (tm, Value ty)) = (
	let	val ty' = case sub_type zti_subs ty of
				ExType ("SET", [ty'']) => ty''
				| _ => error "make_chartuple" 62999 [];
	in
		[(ZTm (tm, ""), ty')]
	end
	) | f _ = error "make_chartuple" 63999 [];
in
	case decls of
	[] => error "make_chartuple" 62998 [fn()=>"empty declaration"]
	|decls => 
		let	val (tml, tyl) = split (flat (map f decls));
		in
			case (tml, tyl) of
			([tm], [ty]) => (tm, ty)
			|_ => (ZTmTuple tml, tuple_extype tyl)
		end
end);
=TEX


=SML
fun €aux_compatibility› [] tym1 tym2 = ([], [], [])
  | aux_compatibility (c::cl) tym1 tym2 = (
let	val 	(tym, idtyl1, idtyl2) = aux_compatibility cl tym1 tym2;
in 
	case (lassoc5 tym1 c,lassoc5 tym2 c) of
	(Nil,Value ty) => ((c,ty)::tym, idtyl1, idtyl2)
	|(Value ty,Nil) => ((c,ty)::tym, idtyl1, idtyl2)
	|(Value ty1, Value ty2) => (
			(unify zti_subs (ty1, ty2);
				((c,sub_type zti_subs ty1)::tym, idtyl1, idtyl2))
			handle Fail msg =>
				(tym, (c,sub_type zti_subs ty1)::idtyl1,
					(c,sub_type zti_subs ty2)::idtyl2)

		)
	|_ => (tym, idtyl1, idtyl2)
end);

=TEX
=SML
fun €compatible› ((idtyl1, idtyl2):((IDENT * EXTYPE) list) * ((IDENT * EXTYPE) list)) : (IDENT * EXTYPE) list = (
let	val cl = (list_cup o (map(map fst))) [idtyl1,idtyl2];
in
	case aux_compatibility cl idtyl1 idtyl2 of
	(tym, [], []) => (
		 tym
	) | (_, idtyl1, idtyl2) => (
		raise ZExn (FailedZCompat (idtyl1, idtyl2))
	)
end);
=TEX
=SML
fun €includes› ((idtyl1, idtyl2):((IDENT * EXTYPE) list) * ((IDENT * EXTYPE) list)) : (IDENT * EXTYPE) list = (
let	val (cl1, tyl1) = split idtyl1;
	val (cl2, tyl2) = split idtyl2;
in
	if cl2 diff cl1 = []
	then
		case aux_compatibility cl1 idtyl1 idtyl2 of
		(tym, [], []) => (
			 (tym drop (fn (s,_) => s mem cl2))
		) | (_, idtyl1', idtyl2') => (
			raise ZExn (FailedZCompat (idtyl1', idtyl2'))
		)
	else
		raise (ZExn (FailedZIncludes (cl2 diff cl1)))
end);
=TEX

\section{INFERRING TYPES IN Z DECLARATIONS}

The first thing we need to do is to type infer schema as declarations which
appear in a group of declarations. Note that the
environment is not extended at this point.
The following function achieves this:

=SML
fun €ti_dec_pass_1› (env : Z_ENV) (zdec as ZSchemaDec (tm, _) : Z_DEC)
				: Z_DEC * Z_ENV * (IDENT * EXTYPE) list = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val env' = dec_boundvars env idtyl;
		in
			(ZSchemaDec (tm', Value ty'), env',  idtyl)
		end)
	|_ => raise ZExn (FailedZDec2 (zdec, env, tm', ty'))
end)
  | ti_dec_pass_1 env (zdec as ZDec (ids, tm, _)) = (
let	val unk = ExVartype (Unknown (next_name()));
	val idtyl = map (fn id => (id, unk)) ids;
	val env' = dec_boundvars env idtyl;
in
	(ZDec (ids, tm, Nil), env', idtyl)
end)
=TEX

=SML
and €ti_zdec_pass_2› (env : Z_ENV) ((zdec as ZSchemaDec (tm, _)) : Z_DEC, _, idtyl) = (
	(zdec, idtyl)
)
  | ti_zdec_pass_2 env (zdec as ZDec (ids, tm, _), _, idtyl) = (
let	val (tm', ty') = ti_ztm env tm;
	val ty'' = (
		case ty' of
		ExType ("SET", [ty'']) => ty''
		|_ =>raise ZExn (FailedZDec1 (zdec, env, tm', ty'))
		);
	val side = map (curry (unify zti_subs) ty'') (map snd idtyl)
		handle Fail _ => fail "ti_zdec_pass_2" 62901 [];
in
	(ZDec (ids, tm', Value (sub_type zti_subs ty'')), idtyl)
end)
=TEX

=SML
and €map_compat› ((dec, env, idtyl)::more) res = (
let	val idtyl = compatible (idtyl, res)
			handle ZExn (FailedZCompat (idtyl1, idtyl2)) =>
			raise ZExn (FailedZDec3 (dec, env, idtyl1, idtyl2))

in
	map_compat more (idtyl@res)
end)
  | map_compat [] res = res
=TEX

=SML
and €list_ti_zdec› (env : Z_ENV) (zdecl : Z_DEC list) : (Z_DEC list * Z_ENV * (IDENT * EXTYPE) list) = (
let	val pass1 = map (ti_dec_pass_1 env) zdecl;
	val idtyl =  map_compat pass1 [];
	val (_, envl, _) = split3 pass1;
	fun mk_env (env::rest) = (
		fn id => (
			case env id of
			FreeVar Nil => (mk_env rest) id
			|thing => thing)
	) | mk_env [] = fn id => FreeVar Nil;
	val env' = mk_env envl;
	val pass2 = map (ti_zdec_pass_2 env') pass1;
	val idtyl' = map (fn (id,ty) => (id, sub_type zti_subs ty)) idtyl;
in
	(map fst pass2, sub_ty env', idtyl')
end)
=TEX
\section{INFERRING TYPES IN Z SCHEMAS}

Note that if the predicate part of a schema text is
not boolean, then this constitutes a type checking error.
The caller of $ti\_zschtext$ should make this check, as
it is likely
to have more contextual information for reporting informative
error messages than $ti\_zschtext$. 

=SML
and €ti_zschtext› (env : Z_ENV) (schtext : Z_SCH_TEXT as (ds, otm, oty))
			: Z_SCH_TEXT * Z_ENV * (IDENT * EXTYPE) list = (
let	val (ds', env', idtyl) = list_ti_zdec env ds;
in
	case otm of
	Nil =>		((ds', Nil, Nil), env', idtyl)
	|Value tm => (
		let	val (tm', ty') = ti_ztm env' tm;
			val side = unify zti_subs (ty', ex_bool)
				handle Fail msg =>
				raise ZExn (FailedZSchText (schtext, env, tm', ty'));
		in
			((ds', Value tm', Value ty'), env', idtyl)
		end)
end)
=TEX

\section{INFERRING TYPES IN Z TERMS}

\subsection{Sequence Display}

=SML
and €ti_ztm› (env : Z_ENV) (term as ZTmß¢ (Nil, tl)) : Z_TM * EXTYPE = (
let	val tmlist = list_ti_ztm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise ZExn (FailedZTm (term, env, Failedß¢(tl, tyl)));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = (tuple_extype [ex_˙, sub_type zti_subs ty]);
in
	(ZTmß¢ (Value resty, tml), ex_set resty)
end)
  | ti_ztm env (ZTmß¢ (Value _, _)) = (
	fail "ti_ztm" 62998 [fn()=>
		"The expression passed to the type inferrer must not be typed"]
)
=TEX
\subsection{Set Display}
=SML
  | ti_ztm env (term as ZTmSetd (Nil, tl)) = (
let	val tmlist = list_ti_ztm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise ZExn (FailedZTm (term, env, FailedSetd(tl, tyl)));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = sub_type zti_subs ty;
in
	(ZTmSetd (Value resty, tml), ex_set resty)
end)
  | ti_ztm env (ZTmSetd (Value _, _)) = (
	fail "ti_ztm" 62998 [fn()=>
		"The expression passed to the type inferrer must not be typed"]
)
=TEX

\subsection{Set Abstraction}
=SML
  | ti_ztm env (term as ZTmSeta1 schtext) = (
let	val ctm = chartuple schtext;
	val (schtext', env', _) = ti_zschtext env schtext
		handle ZExn (FailedZSchText (_, env, tm', ty')) =>
		raise ZExn (FailedZTm (term, env, FailedSeta(tm',ty',62031)));
	val (_, ty') = ti_ztm (sub_ty env') ctm;
in
	(ZTmSeta1 schtext', ex_set ty')
end)
=TEX
=SML
  | ti_ztm env (term as ZTmSeta2 (schtext, tm)) = (
let	val (schtext', env', _) = ti_zschtext env schtext
		handle ZExn (FailedZSchText (_, env, tm', ty')) =>
		raise ZExn (FailedZTm (term, env, FailedSeta(tm',ty',62032)));
	val (tm', ty') = ti_ztm (sub_ty env') tm;
in
	(ZTmSeta2(schtext', tm'), ex_set ty')
end)
=TEX

\subsection{Powerset}
=SML
  | ti_ztm env (term as ZTm tm) = (
let	val (tm', ty') = ti_ztm env tm;
	val tya = ex_set (ExVartype (Unknown (next_name())));
	val side = unify zti_subs (ty', tya)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, Failedset (tm', ty')));
in
	(ZTm tm', ex_set (sub_type zti_subs tya))
end)
=TEX

\subsection{Tuple Display}
=SML
  | ti_ztm env (ZTmTuple []) = error "ti_ztm" 62998
		[fn()=>"ZTmTuple (Zero length tuple)"]
  | ti_ztm env (ZTmTuple tml) = (
let	val tmlist = list_ti_ztm env tml;
	val (tml', tyl') = split tmlist;
	val unkl = map (fn x => ExVartype (Unknown(next_name()))) tml';
	val side = map (unify zti_subs) (combine unkl tyl')
		handle Fail msg =>
		error "ti_ztm" 62998 [fn()=>"ZTmTuple (Unification error)"];
	val ty = tuple_extype (map (sub_type zti_subs) unkl);
in
	(ZTmTuple tml', ty)
end)
=TEX
\subsection{Product}
=SML
  | ti_ztm env (ZTm∏ []) = fail "ti_ztm" 62998 [fn()=>"ZTm∏ (Zero length product type)"]
  | ti_ztm env (term as ZTm∏ tml) = (
let	fun get_unify_failures ((tm, (ty1, ty2))::rest) = (
	let	val res = (unify zti_subs (ty1, ty2);true)
			handle Fail msg => false;
	in
		if res then get_unify_failures rest
		else (tm,ty2)::get_unify_failures rest
	end
	) | get_unify_failures [] = [];
	val tmlist = list_ti_ztm env tml;
	val (tml', tyl') = split tmlist;
	val unkl = map (fn x => (ExVartype (Unknown(next_name())))) tml';
	val punkl = map (fn x => ex_set x) unkl;
	val typairs = combine punkl tyl';
	val side = case get_unify_failures (combine tml' typairs) of
		[] => ()
		|failures =>
		   (let	val(ftml, ftyl) = split failures;
		   in
			raise ZExn (FailedZTm (term, env, Failed∏ (ftml, ftyl)))
		   end);
	val ty =  ex_set (tuple_extype (map (sub_type zti_subs) unkl));

in
	(ZTm∏ tml', ty)
end)
=TEX
\subsection{Theta}
=SML
  | ti_ztm env (term as ZTm  (tm, decor)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ =>
		let	val bty = (
				case ty' of
				ExType ("SET", [x]) => x
				|_ => error "ti_ztm" 62998 [fn()=> "ZTm "]
			);
		in
			(ZTm (tm', decor), bty)
		end
	|_ => raise ZExn (FailedZTm (term, env, Failed  (tm', ty')))
end)
=TEX

\subsection{Tuple Selection}

=SML
  | ti_ztm env (term as ZTmSelâT (tm, i)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	TupleType tyl => (
		let	val sz = length tyl;
			val ty'' = nth (i-1) tyl
				handle Fail _ =>
				raise ZExn (FailedZTm  (term, env, FailedSelâT1 (i, sz)));
		in
			(ZTmSelâT(tm', i), sub_type zti_subs ty'')
		end)
	|_ => raise ZExn (FailedZTm (term, env, FailedSelâT2 (tm', ty')))
end)
=TEX

\subsection{Binding Selection}

=SML
  | ti_ztm env (term as ZTmSelâB (tm, id)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	BindingType idtyl => (
		case lassoc5 idtyl id of
		Nil => raise ZExn (FailedZTm  (term, env, FailedSelâB1 (tm', id)))
		|Value ty'' =>
			(ZTmSelâB(tm', id), sub_type zti_subs ty'')
		)
	|_ => raise ZExn (FailedZTm (term, env, FailedSelâB2 (tm', ty')))
end)
=TEX

\subsection{Application}
=SML
  | ti_ztm env (term as ZTmApp (ZTmLVar ((TmplIn (StubUS, ("=", Nil), StubUS), ""), Nil, []), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val side = unify zti_subs (ty1', ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEq (tm1', tm2', ty1', ty2')));
in
	(ZTmEq (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmApp (ZTmLVar ((TmplIn (StubUS, ("ç", Nil), StubUS), ""), Nil, []), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val unk = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ex_set unk, ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failedç1(tm2', ty2')));
	val side = unify zti_subs (ty1', sub_type zti_subs unk)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failedç2(tm2', ty2')));
in
	(ZTmç (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmApp (tmf, tma)) = (
let	val (tmf', tyf) = ti_ztm env tmf;
	val (tma', tya) = ti_ztm (sub_ty env) tma;
	val tvn = next_name();
	val tyr = ExVartype(Unknown tvn);
	val side = unify zti_subs (tyf, ex_set (tuple_extype([tya,tyr])))
			handle Fail _ =>
			raise ZExn (FailedZTm (term, env,
				FailedApp (tmf', tma', tyf, tya)));

in
		(ZTmApp(tmf',tma'), sub_type zti_subs tyr)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmFancyApp ((TmplIn (StubUS, ("=", Nil), StubUS), ""), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val side = unify zti_subs (ty1', ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEq (tm1', tm2', ty1', ty2')));
in
	(ZTmEq (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmFancyApp ((TmplIn (StubUS, ("ç", Nil), StubUS), ""), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val unk = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ex_set unk, ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failedç1(tm2', ty2')));
	val side = unify zti_subs (ty1', sub_type zti_subs unk)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failedç2(tm2', ty2')));
in
	(ZTmç (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmFancyApp (id as (n, d), tma)) = (
	case get_zfixity_info (first_tmpl_id n) of
	Value((_, ZClGen _),_) => (
		case tma of
		ZTmTuple tml => ti_ztm env (ZTmLVar (id, Nil, tml))
		| _ => fail "ti_ztm" 62901 [fn()=>"(gen) Bad Generic argument"]
		)
	|Value((_, ZClRel),_) => (
		case tma of
		ZTmTuple [tma'] =>
			ti_ztm env (ZTmFancyApp ((TmplIn (StubUS, ("ç", Nil), StubUS), ""),
				ZTmTuple [tma', (ZTmLVar (id, Nil, []))]))
		|ZTmTuple _ =>
			ti_ztm env (ZTmFancyApp ((TmplIn (StubUS, ("ç", Nil), StubUS), ""),
				ZTmTuple [tma, (ZTmLVar (id, Nil, []))]))
		| _ => fail "ti_ztm" 62901 [fn()=>"(rel) Bad Generic argument"]
		)
	|Value((_, ZClFun _),_) =>
	let	val (tmf', tyf) = ti_ztm env (ZTmLVar (id, Nil, []));
		val (tma', tya) = ti_ztm (sub_ty env) tma;
		val tya' = case manifest tya of
			TupleType [ty] => ty
			|_ => tya;
		val tvn = next_name();
		val tyr = ExVartype(Unknown tvn);
		val side = unify zti_subs (tyf, ex_set (tuple_extype([tya',tyr])))
				handle Fail _ =>
				raise ZExn (FailedZTm (term, env,
					FailedFancyApp (id, tma', tyf, tya')));
	in
		(ZTmApp(tmf', tma'), sub_type zti_subs tyr)
	end
	| Nil => error "ti_ztm" 62998 [fn()=> "(ZTmFancyApp)"])
=TEX

\subsection{Ã-abstraction}
=SML
 | ti_ztm env (term as ZTmÃ (sch, tm)) = (
let	val ctm = chartuple sch;
	val (sch', env', _) = ti_zschtext env sch;
	val env2 = sub_ty env';
	val (tm', ty') = ti_ztm env2 tm;
	val env3 = sub_ty env2;
	val (tm2, ty2) = ti_ztm (sub_ty env3) ctm;
	val ty = ex_set (tuple_extype [ty2, ty']);
in
	(ZTmÃ (sch', tm'), ty)
end)
=TEX

\subsubsection{Definite Description}
=SML
 | ti_ztm env (ZTmÕ1 sch) = (
let	val ctm = chartuple sch;
	val (sch',env', _) = ti_zschtext env sch;
	val (_, ty') = ti_ztm (sub_ty env') ctm;
in
	(ZTmÕ1 sch', ty')
end)
=TEX
=SML
 | ti_ztm env (ZTmÕ2 (sch, tm)) = (
let	val (sch',env', _) = ti_zschtext env sch;
	val (tm', ty') = ti_ztm (sub_ty env') tm;
in
	(ZTmÕ2 (sch', tm'), ty')
end)
=TEX

\subsection{Truth}

=SML
  | ti_ztm env (ZTmTruth _) = (
	error "ti_ztm" 62998 [fn()=>"ZTmTruth (not expected from parser)"]
)
=TEX

\subsection{Predicate Negation}

=SML
 | ti_ztm env (term as ZTm≥âF tm) = (
let	val (tm', ty') = ti_ztm env tm;
	val (tm'', ty'') = (
		case manifest ty' of
		SchemaType idtyl => (
			bind_zenv env term tm' idtyl;
			(ZTmSchemaPred tm', ex_bool))
		|_ => (tm', ty')
		);
	val side = (unify zti_subs (ty'', ex_bool)
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, Failed≥âF (tm', ty')))
		);
in
	(ZTm≥âF tm'', ty'')
end)
=TEX

\subsection{Logical Infix Operators for Predicates}

=SML
 | ti_ztm env (term as ZTmLogInOpâF (inop, tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm1'', ty1'') = (
		case manifest ty1' of
		SchemaType idtyl => (
			bind_zenv env term tm1' idtyl;
			(ZTmSchemaPred tm1', ex_bool))
		|_ => (tm1', ty1')
		);
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val (tm2'', ty2'') = (
		case manifest ty2' of
		SchemaType idtyl => (
			bind_zenv env term tm2' idtyl;
			(ZTmSchemaPred tm2', ex_bool))
		|_ => (tm2', ty2')
		);
	val side = unify zti_subs (ty1'', ex_bool)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, FailedLogInOpâF (inop, tm1'', ty1'')));
	val side = unify zti_subs (ty2'', ex_bool)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, FailedLogInOpâF (inop, tm2'', ty2'')));
in
	(ZTmLogInOpâF(inop, tm1'' ,tm2''), ex_bool)
end
)
=TEX

\subsection{Predicate Quantification}
=SML
  | ti_ztm env (term as ZTmQuantâF (quant, sch, tm)) = (
let	val (sch', env', _) = ti_zschtext env sch;
	val (tm', ty') = ti_ztm (sub_ty env') tm;
	val (tm'', ty'') = (
		case manifest ty' of
		SchemaType idtyl =>	(
			bind_zenv env term tm' idtyl;
			(ZTmSchemaPred tm', ex_bool))
		|_ => (tm', ty')
		);
	val side = (unify zti_subs (ty'', ex_bool)
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, FailedQuantâF (quant, tm'', ty'')))
		);
in
	(ZTmQuantâF (quant, sch', tm''), sub_type zti_subs ty'')
end
)
=TEX


\subsection{Schemas as Predicates}
=SML
  | ti_ztm env (term as ZTmSchemaPred tm) = (
	error "ti_ztm" 62998 [fn()=>"ZTmSchemaPred (not expected from parser)"]
)
=TEX

\subsection{Horizontal Schemas}

=SML
  | ti_ztm env (term as ZTmHorizSchema sch) = (
let	val (sch', env', idtyl) = ti_zschtext env sch;
	val ty = ex_set (bind_extype idtyl);
in
	(ZTmHorizSchema sch', ty)
end)
=TEX

\subsubsection{Decoration}
=SML
 | ti_ztm env (term as ZTmDecor (tm, d)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ => (ZTmDecor(tm',d), ty')
	| _ => raise ZExn (FailedZTm (term, env, FailedDecor (tm', ty')))
end)
=TEX
\subsubsection{Precondition}
=SML
  | ti_ztm env (term as ZTmPre tm) = (
let	val (tm', ty') = ti_ztm env tm;
	fun is_post (n, d) =
		case (rev o explode) d of
		("!"::rest) => true
		|("'"::rest) => true
		|_ => false;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idtyl' = idtyl drop (fn(id, ty) => is_post id);
			val ty'' = ex_set (bind_extype idtyl');
		in
			(ZTmPre tm', ty'')
		end)
	| _ => raise ZExn (FailedZTm (term, env, FailedPre (tm', ty')))
end)
=TEX
\subsubsection{Schema Negation}
=SML
 | ti_ztm env (term as ZTm≥âS tm) = (
let	val (tm', ty') = ti_ztm env tm
	val side = (
		case manifest ty' of
		SchemaType _ 	=> ()
		|_ => 	raise ZExn (FailedZTm (term, env, Failed≥âF (tm', ty')))
		)
in
	(ZTm≥âS tm', ty')
end)
=TEX

\subsection{Logical Infix Operators for Schemas}

=SML
 | ti_ztm env (term as ZTmLogInOpâS (inop, tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1, SchemaType idtyl2) => (
		let	
			val idtyl' = compatible (idtyl1, idtyl2)
				handle ZExn (FailedZCompat (idtyl1, idtyl2)) =>
				raise ZExn (FailedZTm (term, env,
					FailedLogInOpâS1 (inop, tm1', tm2', idtyl1, idtyl2)))
		in
			(ZTmLogInOpâS(inop, tm1',tm2'), ex_set (bind_extype idtyl'))
		end
	) | (SchemaType _, _) => (
		raise ZExn (FailedZTm (term, env, FailedLogInOpâS2 (inop, tm2', ty2')))
	) | (_, _) => (
		raise ZExn (FailedZTm (term, env, FailedLogInOpâS2 (inop, tm1', ty1')))
	)
end
)
=TEX

\subsubsection{Schema Projection}

=SML
  | ti_ztm env (term as ZTm˘ (tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1, SchemaType idtyl2) => (
		let	val idtyl1' = map (fn ((n,d),t) => ((n,""),t)) idtyl1;
			val idtyl2' = map (fn ((n,d),t) => ((n,""),t)) idtyl2;
			val idtyl' = compatible (idtyl1', idtyl2')
				handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
				raise ZExn (FailedZTm (term, env,
					Failed˘1 (tm1', tm2', idtyl1'', idtyl2'')))
		in
			(ZTm˘(tm1',tm2'), ty2')
		end
	) | (SchemaType _, _) => (
		raise ZExn(FailedZTm(term, env, Failed˘2 (tm2', ty2')))
	) | (_, _) => (
		raise ZExn(FailedZTm(term, env, Failed˘2 (tm1', ty1')))
	)
end
)
=TEX
\subsubsection{Schema Hiding}

=SML
  | ti_ztm env (term as ZTmHide (tm, idl)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idm = idtyl drop (fn(id,ty) => (id mem idl));
			val ty'' = ex_set (bind_extype idm);
		in
			(ZTmHide(tm',idl), ty'')
		end)
	| _ => raise ZExn(FailedZTm(term, env, FailedHide (tm', ty')))
end
)
=TEX

\subsubsection{Schema Quantification}

=SML
  | ti_ztm env (term as ZTmQuantâS (quant, sch, tm)) = (
let	val (sch', _, idtyl1) = ti_zschtext env sch;
	val (tm2', ty2') = ti_ztm env tm;
in
	case manifest ty2' of
	SchemaType idtyl2 => (
		let	val idtyl' = includes (idtyl2, idtyl1)
				handle
				ZExn (FailedZCompat (idtyl2'', idtyl1'')) => (
					raise ZExn (FailedZTm (term, env,
					FailedQuantâS1 (quant, tm2', idtyl1'', idtyl2''))))
				|ZExn (FailedZIncludes idl) => (
					raise ZExn (FailedZTm (term, env, 
					FailedQuantâS3 (quant, tm2', idl))));
		in
			(ZTmQuantâS(quant, sch', tm2'), ex_set (bind_extype idtyl'))
		end
	) |_ => raise ZExn(FailedZTm(term, env, FailedQuantâS2 (quant, tm2', ty2')))
end)
=TEX

\subsubsection{Ñ and ò}
=SML
  | ti_ztm env (term as ZTmÑ tm) = (
let	val(tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ => (ZTmÑ tm', ty')
	|_ => raise ZExn (FailedZTm (term, env, FailedÑ (tm', ty')))
end)
=TEX

=SML
  | ti_ztm env (term as ZTmò tm) = (
let	val(tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ => (ZTmò tm', ty')
	|_ => raise ZExn (FailedZTm (term, env, Failedò (tm', ty')))
end)
=TEX

\subsection{Set Membership and Equality}

=SML
  | ti_ztm env (ZTmEq (_, _)) = (
	error "ti_ztm" 62998 [fn()=>"ZTmEq (not expected from parser)"]
)
=TEX
=SML
  | ti_ztm env (term as ZTmç (_, _)) = (
	error "ti_ztm" 62998 [fn()=>"ZTmç (not expected from parser)"]
)
=TEX

\subsection{Schema Composition}

=SML
 | ti_ztm env (term as ZTmª (tm1, tm2)) = (
let	fun add_prime (id as (n, d)) =
		(n, d^"'");
	fun f tym1 [] = ([], [], [])
	  | f tym1 ((id2, ty2)::t) = (
		let	val id2' = add_prime id2;
		in
			case lassoc5 tym1 id2' of
			Value ty1 => (
				let	val (dl, idtyl1, idtyl2) = f tym1 t;
				in
					(unify zti_subs (ty1, ty2); (id2::dl, idtyl1, idtyl2))
					handle Fail _ => (dl, (id2',ty1)::idtyl1, (id2,ty2)::idtyl2)
				end)
			| Nil => f tym1 t
		end);
	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1,SchemaType idtyl2) => 
		let	val (dropl, fidtyl1, fidtyl2) = f idtyl1 idtyl2;
			val pdropl = map add_prime dropl;
		in
			case (fidtyl1, fidtyl2) of
			([], []) => (
				let	val idtyl1' = idtyl1 drop
						 (fn (id,ty) => id mem pdropl);
					val idtyl2' = idtyl2 drop
						(fn (id,ty) => id mem dropl);
					val idtyl' = compatible (idtyl1', idtyl2')

						handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
						raise ZExn (FailedZTm (term, env,
						Failedª1 (tm1', tm2', idtyl1'', idtyl2'')))
				in
					(ZTmª(tm1',tm2'), ex_set (bind_extype idtyl'))
				end)
			|_ => raise ZExn (FailedZTm (term, env, Failedª1 (tm1', tm2', fidtyl1, fidtyl2)))
		end
	| (SchemaType _, _) => raise ZExn (FailedZTm (term, env, Failedª2 (tm2', ty2')))
	| _ => raise ZExn (FailedZTm (term, env, Failedª2 (tm1', ty1')))
end)
=TEX

\subsection{Schema Piping}
=SML
 | ti_ztm env (term as ZTmPipe (tm1, tm2)) = (
let	fun change_q (id as (n, d)) = (
		case (rev o explode) d of
		"?"::rest => (n, (implode o rev) ("!"::rest))
		|_ => id);
	fun f tym1 [] = ([], [], [])
	  | f tym1 ((id2, ty2)::t) = (
		let	val id2' = change_q id2;
		in
			case lassoc5 tym1 id2' of
			Value ty1 => (
				let	val (dl, idtyl1, idtyl2) = f tym1 t;
				in
					(unify zti_subs (ty1, ty2); (id2::dl, idtyl1, idtyl2))
					handle Fail _ => (dl, (id2',ty1)::idtyl1, (id2,ty2)::idtyl2)
				end)
			| Nil => f tym1 t
		end);
	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1,SchemaType idtyl2) => 
		let	val (dropl, fidtyl1, fidtyl2) = f idtyl1 idtyl2;
			val bang_dropl = map change_q dropl;
		in
			case (fidtyl1, fidtyl2) of
			([], []) => (
				let	val idtyl1' = idtyl1 drop
						 (fn (id,ty) => id mem bang_dropl);
					val idtyl2' = idtyl2 drop
						(fn (id,ty) => id mem dropl);
					val idtyl' = compatible (idtyl1', idtyl2')

						handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
						raise ZExn (FailedZTm (term, env,
						FailedPipe1 (tm1', tm2', idtyl1'', idtyl2'')))
				in
					(ZTmPipe(tm1',tm2'), ex_set (bind_extype idtyl'))
				end)
			|_ => raise ZExn (FailedZTm (term, env, FailedPipe1 (tm1', tm2', fidtyl1, fidtyl2)))
		end
	| (SchemaType _, _) => raise ZExn (FailedZTm (term, env, FailedPipe2 (tm2', ty2')))
	| _ => raise ZExn (FailedZTm (term, env, FailedPipe2 (tm1', ty1')))
end)
=TEX



\subsection{Integer and String Quotation}
=SML
  | ti_ztm env (ZTm˙ i) = (ZTm˙ i, ex_˙)
  | ti_ztm env (ZTmString s ) = (ZTmString s, ex_string)
=TEX

\subsection{Type Constraints}
=SML
  | ti_ztm env (term as ZTmConstrained (tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', ty2') of
	(SchemaType _,ExType("SET",[ExType("BOOL",[])])) => (
		(ZTmSchemaPred (tm1'), ex_bool)
		)
	|_ => (
		let	val side = unify zti_subs (ex_set ty1', ty2')
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, FailedConstrained
						(tm1', ty1', tm2')));
		in
			(ZTmConstrained(tm1',tm2'), sub_type  zti_subs ty1')
		end)
	end)
=TEX

\subsection{Local Variables}
=SML
 | ti_ztm env (ZTmLVar ((TmplNon ("true", Nil), ""), Nil, tml)) = (
	(ZTmTruth true, ex_bool)
)| ti_ztm env (ZTmLVar ((TmplNon ("false", Nil), ""), Nil, tml)) = (
	(ZTmTruth false, ex_bool)
)| ti_ztm env (term as ZTmLVar (id as (n, d), _, tml)) = (
let	fun find_in_scope (ident as (n, d)) = (
	let
		val exd = (rev o explode) d;
		fun aux (decor as d0::rest) res =
		let	val sd = (implode o rev) decor;
		in
			case env (n, sd) of
			GlobalVar ty => ((n, sd), GlobalVar ty, res)
			|BoundVar ty => ((n, sd), BoundVar ty, res)
			|_ => aux rest (d0::res)
		end
		  | aux [] res = (
			case env (n, "") of
			GlobalVar ty => ((n, ""), GlobalVar ty, res)
			|BoundVar ty => ((n, ""), BoundVar ty, res)
			|other => ((n, ""), other, res)
			);
	in
		case aux exd [] of
		(id, GlobalVar ty, res) => (id, GlobalVar ty, implode res)
		|(id, BoundVar ty, res) => (id, BoundVar ty, implode res)
		|(_, other, _) => (ident, other, "")
	end);
	fun gen_actuals id tml ty = (
		case tml of
		[] => (
			(ZTmLVar(id, Value (sub_type zti_subs ty), []), ty)
		)|_ => (
			let	val ttmlist = list_ti_ztm env tml;
				val (ttml,tyl) = split ttmlist
				val argty = tuple_extype tyl;
				val tvn = next_name();
				val resty = ExVartype(Unknown tvn);
				val side = unify zti_subs (ty, ex_set (tuple_extype [argty, resty]))
					handle Fail msg =>
					fail "ti_ztm" 62998 [fn ()=>
					"ZTmLVar (message to be supplied later)"];
				val vty = sub_type zti_subs resty;
			in
				(ZTmLVar(id, Value vty, ttml), vty)
			end)
	);
	fun setup_new_var id = (
	let	val newenv = update_zenv env id
			handle ZExn (FailedZFreeVar id) =>
			raise ZExn (FailedZTm (term, env, FailedFreeVar id));
	in
		case newenv id of
		FreeVar (Value ty) => ty
		|_ =>  error "ti_ztm" 62998
			[fn ()=> "ZTmLVar (bound or global var. went undetected)"]
	end);

in
	case find_in_scope id of
	(id', GlobalVar ty', "") => (
		ti_ztm env (ZTmGVar (id', Nil, tml))
	)|(id', BoundVar ty', "") => (
		gen_actuals id tml ty'
	)|(id', GlobalVar ty', d') => (
		case manifest ty' of
		SchemaType _ => (
			ti_ztm env (ZTmDecor (ZTmGVar (id', Nil, tml), d'))
		) |_ =>
			let	val ty'' = setup_new_var id;
			in
				gen_actuals id tml ty''
			end
	)|(id', BoundVar ty', d') => (
		case manifest ty' of
		SchemaType _ => (
			ti_ztm env (ZTmDecor (ZTmLVar (id', Nil, tml), d'))
		) |_ =>
			let	val ty'' = setup_new_var id;
			in
				gen_actuals id tml ty''
			end


	)|(id', FreeVar Nil, "") => (
		let	val ty' = setup_new_var id;
		in
			gen_actuals id tml ty'
		end
	)|(id', FreeVar (Value ty'), "") => (
		gen_actuals id tml ty'
	)|_ => error "ti_ztm" 62998 [fn ()=> "ZTmLVar (cannot have a decorated free var.)"]
end
)
=TEX

\subsection{Global Variables}

=SML
 | ti_ztm env (term as ZTmGVar (id as (n, d), _, tml)) = (
	case (env id, tml, id) of 
	(GlobalVar (ExType ("≠",[domty, _])), [], (TmplNon ("U", Nil),"")) => 
		let	val gentyl = untuple_extype domty
				handle Fail _ => [domty];
			val ztml' = map (fn x => ZTmGVar((TmplNon ("Totality",Nil),""), Nil, [])) gentyl;
		in
			ti_ztm env (ZTmGVar(id, Nil, ztml'))
		end
	| (GlobalVar (ExType ("≠",[domty, _])),[],_) => 
		let	val gentyl = untuple_extype domty
				handle Fail _ => [domty];
			val ztml' = map (fn x => ZTmGVar((TmplNon("U",Nil), ""),Nil, []))
									 gentyl;
		in
			ti_ztm env (ZTmGVar(id, Nil, ztml'))
		end
	| (GlobalVar (ty as ExType("≠",[domty,ranty])), _, _) =>
		let	val (tml', tyl') = split (list_ti_ztm env tml);
			val argty = tuple_extype tyl';
			val resty = ExVartype(Unknown (next_name()));
			val side = unify zti_subs (ExType ("≠",[domty, ranty]),
				ExType ("≠", [argty, resty]));
			val vty = sub_type zti_subs resty;
			in
				(ZTmGVar(id, Value vty, tml'), vty)
			end
	| (GlobalVar ty, [], _) =>	(ZTmGVar(id, Value ty, []), ty)
	|_ => error "ti_ztm" 62998 [fn()=>"ZTmGVar (The environment has no knowledge of this constant: "^
		PolyML.makestring (env id)]
)
=TEX

\subsection{Let Expressions}

=SML
 | ti_ztm env (term as ZTmLet (eqdefl, tm)) = (
let	val (abbl, defl) = split eqdefl;
	val (defl', tyl') = split (list_ti_ztm env defl);
	val abbtyl' = combine abbl tyl';
	val eqdefl' = combine abbl defl';
	val env' = (fn id =>
		case lassoc5 abbtyl' id of
		Nil => (update_zenv env id
			handle ZExn (FailedZFreeVar id) =>
			raise ZExn (FailedZTm (term, env, FailedFreeVar id)); env id)
		|Value ty => BoundVar ty
		);
	val (tm', ty') = ti_ztm env' tm;
in
	(ZTmLet (eqdefl', tm'), ty')
end
)
=TEX

\subsection{Renaming}
=SML
 | ti_ztm env (term as ZTmRename (tm, ididl)) = (
let	val (tm', ty') = ti_ztm env tm;
	fun get_repeats idl = (
	let	fun aux (id::rest) = (
			if id mem rest
			then [id]::(aux rest)
			else aux rest
		) | aux [] = [];
	in
		list_cup (aux idl)
	end);
	val (idnewl, idoldl) = split ididl;
	val rep1 = get_repeats idnewl;
	val rep2 = get_repeats idoldl;

	val side = case rep1 of
		[] => ()
		|_ =>	raise ZExn (FailedZTm (term, env, FailedRename2 rep1));
	val side = case rep2 of
		[] => ()
		|_ =>	raise ZExn (FailedZTm (term, env, FailedRename3 rep2));
in
	case manifest ty' of
	SchemaType idtyl =>
		(ZTmRename(tm, ididl), bind_extype (map (fn (id, ty) =>
			(rassoc4 ididl id id, ty)) idtyl))
	|_ => raise ZExn (FailedZTm (term, env, FailedRename1 (tm', ty')))
end
)
=TEX

\subsection{Bracketed Terms}
=SML
 | ti_ztm env (term as ZTmBracketed tm) = (
let	val (tm', ty') = ti_ztm env tm
in
	(ZTmBracketed tm', ty')
end
)
=TEX

\subsection{Term Quotation}
=SML
  | ti_ztm env (ZTmQuotation holtm) = (
	(ZTmQuotation holtm, (type_to_extype o type_of) holtm)
)
=TEX


\subsection{Type Inferring Lists of Z Terms}
=SML
and
€list_ti_ztm› (env : Z_ENV) (tml : Z_TM list) : (Z_TM * EXTYPE) list = (
	let	fun list_ti_aux env nil = nil
		  | list_ti_aux env (tm::rest) = (
		let	val (titerm as (tm, ty)) = ti_ztm env tm;
			val newenv = sub_ty env;
			val next = list_ti_aux newenv rest;
		in
			(titerm::next)
		end);
	in
		list_ti_aux env tml
	end
);
=TEX

\section{INFERRING TYPES IN Z PARAGRAPHS}

The paragraph datatype includes a constructor for
Z terms. This is a convenient place to include Z terms,
and avoids having another data type which comprises
paragraphs or Z terms.
=SML
datatype €Z_INFERRED› =	ZInferred of Z_PARA 
		|	ZTypeError of Z_ERROR_INFO;
=TEX
=SML
fun €format_zinferred› inf = (
	case inf of
	ZInferred p => format_zpara p
	|ZTypeError errinfo => print_zerror errinfo
);
=TEX
=SML
fun €ti_zpara› (p as ZParaAbbDef (id, formals, tm, Nil): Z_PARA) : Z_INFERRED = (
let	val env = init_zenv false formals;
	val (tm', ty') = ti_ztm env tm;
in
	ZInferred (ZParaAbbDef (id, formals, tm', Value ty'))

end
) | ti_zpara (ZParaAbbDef (_, _, _, Value _)) = (
	fail "ti_zpara" 62998 [fn()=>"ZParaAbbDef (Unexpected type)"]
=TEX
=SML
) | ti_zpara (p as ZParaSchBox (id, formals, sch, Nil)) = (
let	val env = init_zenv false formals;
	val (sch', env', idtyl) = ti_zschtext env sch;
	val ty = ex_set (bind_extype idtyl);
in
	ZInferred (ZParaSchBox (id, formals, sch', Value ty))

end
=TEX
=SML
) | ti_zpara (p as ZParaSchBox (_, _, _, Value _)) = (
	error "ti_zpara" 62998 [fn()=>"ZParaSchBox (Unexpected type)"]
=TEX
=SML
) | ti_zpara  (ZParaAxDes (formals, sch, Nil)) = (
let	val env = init_zenv false formals;
	val (sch', env', idtyl) = ti_zschtext env sch;
in
	ZInferred (ZParaAxDes (formals, sch', Value idtyl))
end
) | ti_zpara (ZParaAxDes (_, _, Value _)) = (
	error "ti_zpara" 62998 [fn()=>"ZParaAxDes (Unexpected term-type list)"]
=TEX

=SML
) | ti_zpara (p as ZParaFreeType ftdef) = (
let	val env = init_zenv true (map fst ftdef);
	fun ftbranch ftid (id, Nil, Nil) = (id, Nil, Nil)
	  | ftbranch ftid (id, Nil, Value tm) = (
	let	val (tm', ty') = ti_ztm env tm;
	in
		(id, Value ty', Value tm')
	end)
	  | ftbranch _ _ = fail "zpft.3" 62998 [];
	fun ftprod (id, idotytml) =
		(id, map (ftbranch id) idotytml);
in
	ZInferred (ZParaFreeType (map ftprod ftdef))
end
=TEX

=SML
) | ti_zpara (p as ZParaGivenSet (idl, Nil)) = (
	ZInferred p
) | ti_zpara (p as ZParaGivenSet (idl, Value (formals, tm))) = (
let	val env = init_zenv false (idl@formals);
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPGiven));
in
	ZInferred p
end
=TEX
=SML
) | ti_zpara (p as ZParaConstraint (idl, tm)) = (
let	val env = init_zenv false idl;
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPConstraint));
in
	ZInferred (ZParaConstraint (idl, tm'))
end
=TEX
=SML
) | ti_zpara (p as ZParaConjecture (id, formals, tm)) = (
let	val env = init_zenv false formals;
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPConjecture));
in
	ZInferred (ZParaConjecture (id, formals, tm'))
end
=TEX
=SML
) | ti_zpara (p as ZParaTerm (formals, tm, Nil)) = (
let	val env = init_zenv false formals;
	val (tm', ty') = ti_ztm env tm;
in
	ZInferred (ZParaTerm (formals, tm', Value ty'))
end
=TEX
=SML
) | ti_zpara (p as ZParaTerm (_, _, Value _)) = (
	error "ti_zpara" 62998 [fn()=>"The term passed to the type inferrer must not be typed"]
=TEX
=SML
) | ti_zpara (p as ZParaFixity _) = (
	ZInferred p
);
=TEX
=SML
fun €type_check_zpara› {standard : bool} (p:Z_PARA) : Z_INFERRED = (
let	val side = init_subs zti_subs;
	val side = (zti_standard_z := standard);
in
	ti_zpara p
		handle ZExn info => ZTypeError(info)
end);
=TEX

\section{EPILOGUE}
=SML
end (* of structure ZTypeInference *);
=TEX

\end{document}


=IGN

fun tc p = type_check_zpara {standard = true} p;
fun tf p = diag_line (format_zinferred (tc p));


 πZ
ZLIST ::= ZNil | ZCons (ZITEM ∏ ZLIST)
&
ZITEM ::= ZNumber ˙ | ZSet (set Ó)
 ∞



val para = Ò1 Ω 0Æ;
val env = init_zenv false [];
val (ZParaTerm (_, term, _)) = para;
ti_ztm env term;

val (ZTmFancyApp (id, tma)) = term;
ti_ztm env (ZTmFancyApp ((TmplIn (StubUS, ("ç", Nil), StubUS), ""),
				ZTmTuple [tma, (ZTmLVar (id, Nil, []))]));

ti_ztm env (ZTmTuple [tma,  (ZTmLVar (id, Nil, []))]);
ti_ztm env (ZTmLVar (id, Nil, []));
val term = (ZTmGVar (id, Nil, []));



∞
