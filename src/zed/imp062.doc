% imp062.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplatetex
\documentstyle[hol1,11pt,TQ]{article}
\makeindex
% The following macro is used to insert temporary notes
% in the document.
\def\TempNote#1{{\tiny#1}}
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Type Inferrer}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP062}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}                    %% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{Z, HOL}
\TPPauthor{D.J.~King&WIN01}
%\TPPauthors{R.D.~Arthan&WIN01\\D.J.~King&WIN01\\G.T.~Scullard&MAN05}
\TPPauthorisation{R.D.~Arthan & FMU Manager}
\TPPabstract{This document contains the Standard ML code for the type
inferrer for HOL/Z.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	  R.D.~Arthan \\ R.B.~Jones \\ G.T. Scullard
}}
 
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List} \tableofcontents
\subsection{Document Cross References}\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion (9 June 1992)] Initial version.

\item[Issue 1.22 (10 July 1992)]
	Fixed bug in decoration of components of schemas which appear
	as declarations (and „ and ˜ expressions).
\item[Issue 1.28 (20 July 1992)]
	Version which passes the module tests. (Fixed type of theta expressions
	and added checking for uniqueness of free type variables with respect
	to free type variables in term quotations).

\item[Issue 1.29 (27 July 1992)]
	Fixed a bug in the handling of unary-tupled arguments to functions. Fixed
	an error message in ti\_z\_tm (ZTmFancyApp).

\item[Issue 1.31 (31st July 1992)]
	Removed function $val\_setIDENT$ and the caller now
	calls $val\_set\_ident$ in $ZTypesAndTermsSupport$.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the Z type inferrer described in
\cite{DS/FMU/IED/DTD062}, and responds to that document. The type inferrer
comprises part of the Z user interface which is overviewed in \cite{DS/FMU/IED/HLD018}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
The purpose of the Z type inferrer is check Z paragraphs as produced by the
Z parser \cite{DS/FMU/IED/DTD061}, according to the typing rules written down in
the detailed design for the type inferrer \cite{DS/FMU/IED/DTD062}. The type inferrer
yields a correctly typed term, and a substitution function containing all the necessary
typing information for the paragraph. If the paragraph is ill-typed, then error
information is returned, for subsequent printing out by a function provided in the
type inferrer structure.

\subsubsection{Dependencies}

The type inferrer is contained within the structure $ZTypeInference$, which is
constrained by the signature of the same name, specified in \cite{DS/FMU/IED/DTD062}.

\subsubsection{Interface}

The following interfaces to the type inferrer module are made public:

\begin{itemize}

\item[1.]
Functions which permit formatting of the abstract syntax tree for Z paragraphs and
their components.

\item[2.]
A function for formatting error information returned by the type inferrer.

\item[3.]
The function which type infers Z paragraphs $type\_check\_z\_para$.

\end{itemize}

\subsubsection{Algorithms}
\subsubsection{Possible Enhancements}

The coding of the variable environment as a combination of pure functional overriding,
and imperative programming could be made more elegant by implementating environment
frame stack as a list of frames.

\subsubsection{Deficiencies}

There is no decent error handling for a case of generic actuals being incompatible
with the type of the defined constant.


\section{PREAMBLE}
First we introduce the structure for Z type inference.

=SML
structure ÛZTypeInferenceÝ : ZTypeInference = struct
=TEX
=SML
	open Unification ZLex ZUserInterfaceSupport;
	open ZTypesAndTermsSupport;

=TEX

\section{SUPPORTING FUNCTIONS}

=SML
fun ÛscreamÝ (s : string) : 'a = (
	fail "Z-Parser" 62901 [fn()=>s]
);
=TEX

=SML
fun Ûex_setÝ t = ExType ("SET", [t]);
val Ûex_úÝ = ExType ("ú", []);
val Ûex_charÝ = ExType ("CHAR",[]);
fun Ûex_­Ý (f, a) = ExType ("­", [f, a]);
val Ûex_boolÝ = ExType ("BOOL", []);
=TEX
=SML
fun Ûget_repeatsÝ (idl : ''a list) : ''a list = (
let	fun aux (id::rest) = (
		if id mem rest
		then [id]::(aux rest)
		else aux rest
	) | aux [] = [];
in
	list_cup (aux idl)
end);
=TEX
=SML
fun Ûident_of_stringÝ (s : string) : IDENT = (
let	fun strip_decor (d::rest) decors = (
		if (d mem ["?", "!", "'"])
		then	strip_decor rest (d::decors)
		else	(d::rest, decors)
	)
	  | strip_decor [] decors = ([], decors);
	val (xrs, d) = strip_decor ((rev o explode) s) [];
	val xs = implode (rev xrs);
in	(template_of_string xs, implode d)
end
);
=TEX


\subsection{Flags and Switches}

The flag $zti\_standard\_z$ denotes that type inference is to be carried
out according to the rules which denote standard (rather than extended) Z.

=SML
val Ûzti_standard_zÝ = ref true;
=TEX

The following declarations define space for the substitution function.
=SML
val Ûzarray_sizeÝ = 100;
val Ûzti_subsÝ = new_subs zarray_size;
=TEX


\section{FORMATTING Z SCHEMA TEXT AND TERMS}

The functions introduced in this section permit the formatting of Z paragraphs
represented as an abstract syntax tree, and the parts which comprise
Z paragraphs. These interfaces are intended to be public as they will no
doubt prove useful to applications programmers and testers.

First a few of auxiliary functions which will be useful.

=SML
fun Ûtype_of_extypeÝ (phi : SUBS) (f : int -> string) ty = (
let	fun aux (ExVartype(Known x)) = (
		mk_vartype x
	) | aux (ExVartype(Unknown x)) = (
		case SparseArray.sub_opt (phi, x) of
			Nil => (mk_vartype (f x))
			| Value y => aux y
	) | aux (ExType(s, l)) = (
		mk_ctype(s, map aux l)
	);
in
	aux ty
end);
=TEX
The following variable keeps a note of free type variables encountered
in HOL quotations, so that the type variable names generated by $type\_of\_z\_extype$
are unique with respect to those occurring in quotations.
Type variable names start with "'a", "'b" ... and so on.

=SML
val Ûknown_term_tyvarsÝ : string list ref = ref [];
=TEX

The following code and the reference variables ensure that names are generated
only when they need to be printed, thus ensuring no gaps
in the sequence of names. 

=SML
local
	val Ûtyvar_mapÝ : (int * string) list ref = ref [];
	val Ûnext_tyvarÝ : int ref = ref 1;
in
=TEX
=SML
fun Ûreset_freetype_namesÝ (() : unit) : unit = (
	known_term_tyvars := [];
	tyvar_map := [];
	next_tyvar := 1
);
=TEX
=SML
fun Ûmk_freetype_nameÝ (tvar : int) : string = (
let	fun mk_tyvar_name i = 
		if i > 0 andalso i <= 26
		then
			"'"^(chr (i+96))
		else
			"'"^(string_of_int i);
	fun next_unique () = (
	let	val name = mk_tyvar_name (!next_tyvar);
		val side = (next_tyvar := (!next_tyvar) + 1);
	in
		if name mem (!known_term_tyvars)
		then
			next_unique ()
		else
			name
	end);
in
	lassoc3 (!tyvar_map) tvar
		handle Fail _ => (
			let	val name = next_unique();
				val side = (tyvar_map := (tvar, name)::(!tyvar_map));
			in
				name
			end)
end);
end (* local ... in ... *);
=TEX

=SML
fun Ûtype_of_z_extypeÝ (ty : EXTYPE) : TYPE = (
	type_of_extype zti_subs mk_freetype_name ty
);
=TEX
=SML
local

fun	f_ztype (ty : TYPE) : string =
	if is_z_given_t ty
	then
		dest_z_given_t ty
	else
	if is_z_var_t ty
	then
		"'" ^ (dest_z_var_t ty)
	else
	if is_z_power_t ty
	then
	let	val tyt = dest_z_power_t ty;
		fun	f [ty1, ty2] = (f_ztype ty1) ^ " ª " ^ (f_ztype ty2)
		|	f _ = "ð " ^ (f_ztype tyt);
	in
		f (dest_z_tuple_t tyt)
			handle Fail _ => f []	
	end
	else
	if is_z_tuple_t ty
	then
	let	val tyl = dest_z_tuple_t ty
		fun 	f [] = ""
		|	f [ty] = f_ztype ty
		|	f (h::t) = "(" ^ (f_ztype h) ^ " ¸ " ^ (f t) ^ ")"
	in
		f tyl
	end
	else
	if is_z_schema_t ty
	then
	let	val tym = dest_z_schema_t ty
		fun 	f [] = ""
		|	f [(s,ty)] = s ^ ":" ^ (f_ztype ty)
		|	f ((s,ty)::t) = s ^ ":" ^ (f_ztype ty) ^ ";" ^ (f t)
	in
		"[" ^ (f tym) ^ "]"
	end
	else
		scream "Unable to print a Z type - the type is corrupt";
=TEX
=SML
fun	f_gens (ty : TYPE) : string = 
	let	val tyl = map (dest_z_var_t o dest_z_power_t) (dest_z_tuple_t ty);
		fun	f [] = ""
		|	f [s] = s
		|	f (h::t) = h ^ "," ^ (f t);
	in
		"[" ^ (f tyl) ^ "]"
	end;

=TEX
=SML
fun	strip_­_type1 (ty : TYPE): TYPE list * TYPE = (
	let fun aux typ l= (
		if is_­_type typ
		then 	let 	val (ty1,ty2) = dest_­_type typ
			in aux  ty2 (l @ [ty1]) 
			end
		else (l,typ)
		);
	in	aux ty [] 
	end
);
=TEX
=SML
in
fun	Ûformat_ztypeÝ (ty : TYPE) : string = (
let	val (gens,zty) = strip_­_type1 ty;
in
	f_ztype zty
end
handle Fail _ => (PolyML.makestring ty)
)
end (* of local ... in *);
=TEX
=SML
fun Ûformat_z_extypeÝ (ty : EXTYPE) : string = format_ztype (type_of_z_extype ty);
=TEX
\section{ERROR HANDLING AND REPORTING}

=SML
datatype Z_VAR_TYPE =
		GlobalVar of EXTYPE
	|	BoundVar of EXTYPE
	|	FreeVar of EXTYPE OPT;
=TEX

=SML
type ÛZ_ENVÝ = IDENT -> Z_VAR_TYPE;
=TEX

=SML
datatype ÛZ_DETAILSÝ	=
		Failed§¢ of Z_TM list * EXTYPE list
	|	FailedSetd of Z_TM list * EXTYPE list
	|	FailedSeta of Z_TM * EXTYPE * int
	|	Failedset of Z_TM * EXTYPE
	|	Failed¸ of Z_TM list * EXTYPE list
	|	FailedÊ of Z_TM * EXTYPE
	|	FailedSel‰T1 of int * int
	|	FailedSel‰T2 of Z_TM * EXTYPE
	|	FailedSel‰B1 of Z_TM * IDENT
	|	FailedSel‰B2 of Z_TM * EXTYPE
	|	FailedApp of Z_TM * Z_TM * EXTYPE * EXTYPE
	|	FailedFancyApp of IDENT * Z_TM * EXTYPE * EXTYPE
	|	Failed³‰F of Z_TM * EXTYPE
	|	FailedLogInOp‰F of Z_LOG_IN_OP * Z_TM * EXTYPE
	|	FailedQuant‰F of Z_QUANT * Z_TM * EXTYPE
	|	FailedDecor of Z_TM * EXTYPE
	|	FailedPre of Z_TM * EXTYPE
	|	Failed³‰S of Z_TM * EXTYPE
	|	FailedLogInOp‰S1 of Z_LOG_IN_OP * Z_TM * Z_TM
			* (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	FailedLogInOp‰S2 of Z_LOG_IN_OP * Z_TM * EXTYPE
	|	Failedù1 of Z_TM * Z_TM * (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	Failedù2 of Z_TM * EXTYPE
	|	FailedHide of Z_TM * EXTYPE
	|	FailedQuant‰S1 of Z_QUANT * Z_TM * (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	FailedQuant‰S2 of Z_QUANT * Z_TM * EXTYPE
	|	FailedQuant‰S3 of Z_QUANT * Z_TM * IDENT list
	|	Failed„ of Z_TM * EXTYPE
	|	Failed˜ of Z_TM * EXTYPE
	|	FailedEq of Z_TM * Z_TM * EXTYPE * EXTYPE
	|	Failed1 of Z_TM * EXTYPE
	|	Failed2 of Z_TM * EXTYPE
	|	Failed»1 of Z_TM * Z_TM * (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	Failed»2 of Z_TM * EXTYPE
	|	FailedPipe1 of Z_TM * Z_TM * (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	FailedPipe2 of Z_TM * EXTYPE
=TEX
=SML
	|	FailedConstrained of Z_TM * EXTYPE * Z_TM
	|	FailedRename1 of Z_TM * EXTYPE
	|	FailedRename2 of IDENT list
	|	FailedRename3 of IDENT list
	|	FailedBinding of IDENT list
	|	FailedGlobalVar of IDENT
	|	FailedFreeVar of IDENT
	|	FailedActual of IDENT * int
	|	FailedEnv of Z_TM * IDENT * EXTYPE * EXTYPE;

=TEX
=SML
datatype ÛZ_PARA_DETAILSÝ =
		FailedZPGiven
	|	FailedZPConstraint
	|	FailedZPConjecture;
=TEX
The following type definition is visible via the signature
$ZTypeInference$.
=SML
datatype ÛLOCAL_ERROR_INFOÝ =
		FailedZTm of Z_TM * Z_ENV * Z_DETAILS
	|	FailedZSchText of Z_SCH_TEXT * Z_ENV * Z_TM * EXTYPE
	|	FailedZDDec1 of Z_DEC * Z_ENV * Z_TM * EXTYPE
	|	FailedZDDec2 of Z_DEC * Z_ENV * Z_TM * EXTYPE
	|	FailedZDDec3 of Z_DEC * Z_ENV * (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	FailedZCompat of (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	FailedZIncludes of IDENT list
	|	FailedZPara of Z_TM * EXTYPE * Z_PARA_DETAILS
	|	FailedZFreeVar of IDENT;

type ÛZ_ERROR_INFOÝ	=	LOCAL_ERROR_INFO;
=TEX
=SML
exception ÛZExnÝ of LOCAL_ERROR_INFO;
=TEX

=SML
fun ÛreportÝ (msg : int) (inserts : string list) : unit = (
	diag_string (get_error_message msg inserts)
);
=TEX

=SML
fun Ûnot_a_setÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62700 [];
	report 62003 [format_z_tm tm, format_z_extype ty]
);
=TEX

=SML
fun Ûnot_a_sequenceÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62701 [];
	report 62003 [format_z_tm tm, format_z_extype ty]
);
=TEX

=SML
fun Ûnot_a_predicateÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62702 [];
	report 62003 [format_z_tm tm, format_z_extype ty]
);
=TEX

=SML
fun Ûnot_a_schemaÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62703 [];
	report 62003 [format_z_tm tm, format_z_extype ty]
);
=TEX

=SML
fun Ûnot_a_bindingÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62704 [];
	report 62003 [format_z_tm tm, format_z_extype ty]
);
=TEX

=SML
fun Ûnot_a_tupleÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62705 [];
	report 62003 [format_z_tm tm, format_z_extype ty]
);
=TEX

=SML
fun Ûnot_a_globvarÝ (id : IDENT) = (
	report 62706 [];
	report 62004 [format_ident id]
);
=TEX

=SML
fun Ûprint_zerrlistinfoÝ (tml : Z_TM list) (tyl : EXTYPE list) : unit = (
let	
	fun plu (x1::x2::rest) = "s"
	  | plu _ = "";
	fun sort1 (i1 : int, (tm1:string, ty1:string)) (i2, (tm2, ty2)) =
		if ty1 = ty2 then
			if tm1 = tm2 then 0
			else i1 - i2
		else	Sort.string_order ty1 ty2;
	fun grpaux ((ty1, tmlist1)::rest1) ((tm2, ty2)::rest2) =
		if ty1 = ty2
		then grpaux ((ty1, tmlist1@[[tm2]])::rest1) rest2
		else grpaux ((ty2, [[tm2]])::(ty1,tmlist1)::rest1) rest2
	  | grpaux res _ = res;	

	fun grp ((tm, ty)::rest) = grpaux [(ty, [[tm]])] rest
	  | grp _ = scream "Problem in formatting a list of terms in an error report";
	fun do_errmsgs ((ty, tmlist)::rest) = (
		report 62005 [ty, plu tmlist];
		map (report 62004) tmlist;
		do_errmsgs rest
	) | do_errmsgs nil = nil;
	val stml = map format_z_tm tml;
	val styl = map format_z_extype tyl;
	val tmty = (combine stml styl);
	val itmty = combine (interval 1 (length styl)) tmty;
	val stmty = (map snd) (Sort.sort sort1 (rev itmty));
in
	(do_errmsgs (grp stmty);()
	)
end);
=TEX

=SML
fun Ûincompatible_schemasÝ (tm1 : Z_TM) (tm2 : Z_TM) (idtyl1 : (IDENT * EXTYPE) list)
		(idtyl2 : (IDENT * EXTYPE) list) : unit = (
	report 62622 [];
	report 62601 [format_z_tm tm1];
	map (fn (id, ty) => report 62003 [format_ident id, format_z_extype ty]) idtyl1;
	report 62601 [format_z_tm tm2];
	map (fn (id, ty) => report 62003 [format_ident id, format_z_extype ty]) idtyl2;
	()
);
=TEX
=SML
fun Ûincompatible_quantÝ (tm : Z_TM) (idtyl1 : (IDENT * EXTYPE) list)
		(idtyl2 : (IDENT * EXTYPE) list) : unit = (
	report 62622 [];
	report 62602 [];
	map (fn (id, ty) => report 62003 [format_ident id, format_z_extype ty]) idtyl1;
	report 62601 [format_z_tm tm];
	map (fn (id, ty) => report 62003 [format_ident id, format_z_extype ty]) idtyl2;
	()
);
=TEX
=SML
fun Ûincompatible_compsÝ (idtyl1 : (IDENT * EXTYPE) list)
		(idtyl2 : (IDENT * EXTYPE) list) : unit = (
	report 62622 [];
	map (fn (id, ty) => report 62003 [format_ident id, format_z_extype ty]) idtyl1;
	map (fn (id, ty) => report 62003 [format_ident id, format_z_extype ty]) idtyl2;
	()
);
=TEX
=SML
fun Ûprint_z_errorÝ ((FailedZTm (term, env, details)) : Z_ERROR_INFO) = (
	report 62001 [format_z_tm term];
	(case details of

	Failed§¢ (tml, tyl) => (
		report 62011 []; print_zerrlistinfo tml tyl
	) | FailedSetd (tml, tyl) => (
		report 62021 []; print_zerrlistinfo tml tyl
	) | FailedSeta (tm, ty, ierr) => (
		report ierr []; not_a_predicate tm ty
	) | Failedset (tm, ty) => (
		report 62041 []; not_a_set tm ty
	) | Failed¸ (tml, tyl) => (
		report 62071 []; print_zerrlistinfo tml tyl
	) | FailedÊ (tm, ty) => (
		report 62081 []; not_a_schema tm ty
	) | FailedSel‰T1 (i, j) => (
		report 62096 []; report 62097 [string_of_int i, string_of_int j]
	) | FailedSel‰T2 (tm, ty) => (
		report 62098 []; not_a_tuple tm ty
	) | FailedSel‰B1 (tm, id) => (
		report 62101 []; report 62102 [format_ident id];
		report 62103 [format_z_tm tm]
	) | FailedSel‰B2 (tm, ty) => (
		report 62104 []; not_a_binding tm ty
=TEX
=SML
	) | FailedApp (tm1, tm2, ty1, ty2) => (
		report 62111 [];
		report 62112 [format_z_tm tm1, format_z_extype ty1];
		report 62113 [format_z_tm tm2, format_z_extype ty2]
	) | FailedFancyApp (id, tm, ty1, ty2) => (
		report 62111 [];
		report 62112 [format_ident id, format_z_extype ty1];
		report 62113 [format_z_tm tm, format_z_extype ty2]
	) | Failed³‰F (tm, ty) => (
		report 62151 []; not_a_predicate tm ty
	) | FailedLogInOp‰F (inop, tm, ty) => (
		report 62161 [format_z_in_op inop];
		not_a_predicate tm ty
	) | FailedQuant‰F (quant, tm, ty) => (
		report 62171 [format_quant quant]; not_a_predicate tm ty
	) | FailedDecor (tm, ty) => (
		report 62201 []; not_a_schema tm ty
	) | FailedPre (tm, ty) => (
		report 62211 []; not_a_schema tm ty
	) | Failed³‰S (tm, ty) => (
		report 62221 []; not_a_schema tm ty
	) | FailedLogInOp‰S1 (inop, tm1, tm2, idtyl1, idtyl2) => (
		report 62232 [format_z_in_op inop];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | FailedLogInOp‰S2 (inop, tm, ty) => (
		report 62231 [format_z_in_op inop];not_a_schema tm ty
	) | Failedù1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62242 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
=TEX
=SML
	) | Failedù2 (tm, ty) => (
		report 62241 []; not_a_schema tm ty
	) | FailedHide (tm, ty) => (
		report 62251 []; not_a_schema tm ty
	) | FailedQuant‰S1 (quant, tm, idtyl1, idtyl2) => (
		report 62262 [format_quant quant];
		report 62263 [];
		incompatible_quant tm idtyl1 idtyl2
	) | FailedQuant‰S2 (quant, tm, ty) => (
		report 62261 [format_quant quant];
		not_a_schema tm ty
	) | FailedQuant‰S3 (quant, tm, idl) => (
		report 62262 [format_quant quant];
		report 62265 [];
		report 62266 [format_z_tm tm];
		map (fn id => report 62004 [format_ident id]) idl;
		()
	) | Failed„ (tm, ty) => (
		report 62270 []; not_a_schema tm ty
	) | Failed˜ (tm, ty) => (
		report 62271 []; not_a_schema tm ty
	) | FailedEq (tm1, tm2, ty1, ty2) => (
		report 62281 [];
		report 62007 [];
		report 62003 [format_z_tm tm1, format_z_extype ty1];
		report 62003 [format_z_tm tm2, format_z_extype ty2]
	) | Failed»1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62291 [];
		report 62292 [];
		report 62293 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | Failed»2 (tm, ty) => (
		report 62290 [];
		not_a_schema tm ty
	) | FailedPipe1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62301 [];
		report 62302 [];
		report 62303 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
=TEX
=SML
	) | FailedPipe2 (tm, ty) => (
		report 62300 [];
		not_a_schema tm ty
	) | Failed1 (tm, ty) => (
		report 62282 []; not_a_set tm ty
	) | Failed2 (tm, ty) => (
		report 62283 [];
		report 62006 [];
		report 62003 [format_z_tm tm, format_z_extype ty]
	) | FailedConstrained (tm1, ty, tm2) => (
		report 62261 [];
		report 62262 [format_z_tm tm1, format_z_extype ty];
		report 62263 [format_z_tm tm2]
	) | FailedRename1 (tm, ty) => (
		report 62361 []; not_a_schema tm ty
	) | FailedRename2 idl => (
		report 62362 []; report 62363 [];
		(case idl of
		[_] => report 62611 []
		|_ => report 62612 []);
		map (fn id => report 62004 [format_ident id]) idl;
		()
	) | FailedRename3 idl => (
		report 62362 []; report 62364 [];
		(case idl of
		[_] => report 62611 []
		|_ => report 62612 []);
		map (fn id => report 62004 [format_ident id]) idl;
		()
=TEX
=SML
	) | FailedBinding idl => (
		report 62051 []; report 62052 [];
		(case idl of
		[_] => report 62611 []
		|_ => report 62612 []);
		map (fn id => report 62004 [format_ident id]) idl;
		()
	) | FailedGlobalVar id => (
		report 62341 []; not_a_globvar id
	) | FailedFreeVar id => (
		report 62631 []; report 62632 [];
		report 62004 [format_ident id]
	) | FailedActual (id, len) => (
		report 62342 []; report 62343 [];
		report 62344 [format_ident id, string_of_int len,
				if len  >1 then "s" else ""]
	) | FailedEnv (tm, id, ty1, ty2) => (
		report 62503 []; report 62504 [];
		report 62601 [format_z_tm tm];
		report 62003 [format_ident id, format_z_extype ty1];
		report 62603 [];
		report 62003 [format_ident id, format_z_extype ty2]
	) (* end case *)
	);
	fail "Z-Parser" 62000 []
=TEX
=SML
) | print_z_error (FailedZSchText (schtext, env, tm, ty)) = (
	report 62001 [format_z_schtext schtext];
	report 62510 [];
	not_a_predicate tm ty;
	fail "Z-Parser" 62000 []
) | print_z_error (FailedZDDec1 (dec, env, tm, ty)) = (
	report 62001 [format_z_dec dec];
	report 62501 [];
	not_a_set tm ty;
	fail "Z-Parser" 62000 []
) | print_z_error (FailedZDDec2 (dec, env, tm, ty)) = (
	report 62001 [format_z_dec dec];
	report 62502 [];
	not_a_schema tm ty;
	fail "Z-Parser" 62000 []
) | print_z_error (FailedZDDec3 (dec, env, idtyl1, idtyl2)) = (
	report 62001 [format_z_dec dec];
	report 62505 [];
	report 62506 [];
	incompatible_comps idtyl1 idtyl2;
	fail "Z-Parser" 62000 []
=TEX
=SML
) | print_z_error (FailedZCompat (idtyl1,idtyl2)) = (
	report 62621 [];
	fail "Z-Parser" 62000 []
) | print_z_error (FailedZIncludes idl) = (
	report 62623 [];
	fail "Z-Parser" 62000 []
) | print_z_error (FailedZPara (tm, ty, det)) = (
	report 62002 []; (
		case det of
		FailedZPGiven => (report 62801 []; report 62802 [];())
		|FailedZPConstraint => (report 62803 [])
		|FailedZPConjecture => (report 62804 [])
		);
	not_a_predicate tm ty;
	fail "Z-Parser" 62000 []
) | print_z_error (FailedZFreeVar id) = (
	report 62631 []; report 62632 [];
	report 62004 [format_ident id];
	fail "Z-Parser" 62000 []
);
=TEX

\subsection{The Environment}

=SML
val table:(IDENT * Z_VAR_TYPE) list ref = ref [];
=TEX
=SML
fun Ûsub_tyÝ (env:Z_ENV) : Z_ENV = (
	fn id =>
		case env id of
		GlobalVar ty => GlobalVar (sub_type zti_subs ty)
		|BoundVar ty => BoundVar (sub_type zti_subs ty)
		|FreeVar (Value ty) => FreeVar  (Value (sub_type zti_subs ty))
		|FreeVar Nil => FreeVar Nil
);
=TEX
=SML
fun Ûget_zconst_typeÝ (s : string) : TYPE OPT = get_const_type (bind_gvar_name s);
=TEX
=SML
local
	fun freety id = (id, BoundVar (ex_set (ExType (string_of_ident id, []))));
	fun formal id = (id, BoundVar (ex_set (ExVartype(Known("'"^(string_of_ident id))))));
in
fun Ûinit_zenvÝ (ftdef : bool) (genformals : IDENT list) : Z_ENV = (
let	val dummy = start_again();
	val side = if ftdef
		then
			table := (map freety genformals)
		else
			table := (map formal genformals);
in
	fn id => (
		case lassoc5 (!table) id of
		Value vty => vty
		|Nil => (
			case get_zconst_type (string_of_ident id) of
			Value ty =>
				GlobalVar (replaced ty)
			|Nil =>
				FreeVar Nil
		)
	)
end
);
end (* of local ... in *);
=TEX
=SML
fun Ûupdate_zenvÝ (env : Z_ENV) (id : IDENT) : Z_ENV = (
	case env id of
	FreeVar Nil =>
		if (!zti_standard_z)
		then
			raise ZExn (FailedZFreeVar id)
		else
			let	val side = table := (id, FreeVar (Value (ExVartype
				(Unknown (next_name()))))):: !table;
			in
				env
			end
	|_ => env
);
=TEX
=SML
fun Ûbind_zenvÝ (env : Z_ENV) (term : Z_TM) (tm : Z_TM)
		(idtyl : (IDENT * EXTYPE) list) : Z_ENV = (
let	fun bz_unify id (ty1, ty2) = (
		unify zti_subs (ty1, ty2)
			handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEnv (tm, id, ty1, ty2)))
		);
	fun aux (id, ty) = (
		case env id of
		FreeVar Nil => (
			table := (id, FreeVar (Value ty)):: !table
			)
		|FreeVar (Value ty') => bz_unify id (ty, ty')
		|BoundVar ty' => bz_unify id (ty, ty')
		|GlobalVar ty' => bz_unify id (ty, ty')
	);
in
	map aux idtyl; env
end
);
=TEX
=SML
fun Ûdec_boundvarsÝ (env : Z_ENV) (idtyl : (IDENT * EXTYPE) list) : Z_ENV = (
	fn id => (
		case lassoc5 idtyl id of
		Nil => env id
		|Value ty => BoundVar ty
		)
);
=TEX
=SML
fun Ûshow_envÝ () : (IDENT * Z_VAR_TYPE) list = (
	!table
);
=TEX


\section{SUPPORT FOR SCHEMAS}
=SML
datatype ÛMANIFEST_EXTYPEÝ =
		NotManifest
	|	TupleType of EXTYPE list
	|	BindingType of (IDENT * EXTYPE) list
	|	SchemaType of (IDENT * EXTYPE) list;
=TEX

=SML
fun	ÛidsetseqÝ (sl:string list) : string list = Sort.sort Sort.string_order sl;
=TEX
=SML
fun	ÛflatpackÝ ([]:string list) : string 	= ""
|	flatpack (s::[])			= s
|	flatpack (s::ss) 			= s ^ "," ^ (flatpack ss);
=TEX


=SML
fun	 ÛiextymfunseqÝ (itym:(string * EXTYPE)list) :EXTYPE list =
	map (lassoc3 itym) (idsetseq(fst(split itym)));
=TEX

=SML
fun	Ûbind_exnameÝ (fid :IDENT list) :string = (
let	val sl = map string_of_ident fid;
in	
	"Z'S" ^ (val_set_ident sl)
end);

fun 	Ûbind_extypeÝ (itym :(IDENT * EXTYPE) list) :EXTYPE = (
let	val itym' = map (fn (id, ty) => (string_of_ident id, ty)) itym;
in
		ExType (bind_exname(fst(split itym)), iextymfunseq itym')
end);

=TEX
=SML
fun Ûunbind_extypeÝ (ty : EXTYPE) : (IDENT * EXTYPE) list = (
	case ty of
	ExType (s, tyl) => (
		let	val (mani, sll, _) = dest_z_name s;
		in
			case mani of
			"Z'S" => (
				case sll of
				[sl] => combine (map ident_of_string sl) tyl
				|_ => scream "Strange value returned from dest_z_name"
				)
			| _ => scream "Type is not a Binding type"
			
		end)
	|_ => scream "Type is not a binding type"
);
=TEX

The following makes use of the Z mapping \cite{DS/FMU/IED/ZED003}
and \cite{DS/FMU/IED/ZED002}.
=SML
fun	Ûtuple_exnameÝ (tyl: EXTYPE list) :string = "Z'T[" ^ string_of_int(length tyl) ^ "]";
fun	Ûtuple_extypeÝ (tyl: EXTYPE list) :EXTYPE = ExType(tuple_exname tyl,tyl);
=TEX

=SML
fun Ûuntuple_extypeÝ (ty : EXTYPE) : EXTYPE list = (
	case ty of
	ExType (s, tyl) => (
		let	val (mani, sll, _) = dest_z_name s;
		in
			case mani of
			"Z'T" => tyl
			| _ => scream "Type is not a Tuple"
			
		end)
	|_ => scream "Type is not a tuple"
);
=TEX


=SML
fun  ÛmanifestÝ (ty:EXTYPE) : MANIFEST_EXTYPE = (
	case ty of

	ExType("SET",[ty']) => (
	   	SchemaType (unbind_extype ty')
		handle Fail _ => NotManifest

	)|ExType(_,_) => (
		TupleType (untuple_extype ty)
		handle Fail _ =>
			BindingType (unbind_extype ty)
			handle Fail _ => NotManifest
	)|_ => NotManifest
);
=TEX
=SML
fun ÛchartupleÝ ((decls, tm, _) : Z_SCH_TEXT) : Z_TM = (
let	fun f (ZDDec(ids, tm, _)) = (
		map (fn id => ZTmLVar(id, Nil, [])) ids
	) | f (ZDSchemaDec (ZTmDecor (tm1, d), _)) = (
		[ZTmÊ(tm1, d)]
	) | f (ZDSchemaDec (tm1, _)) = (
		[ZTmÊ(tm1, "")]
	);
in
	case decls of
	[] => scream
		"Attempt to compute the characteristic tuple of an empty declaration"
	|[decl] => (case f decl of
			[tm] => tm
			|tms => ZTmTuple tms)
	|decls => ZTmTuple(flat (map f decls)
	)
end);
=TEX
The following function is used by the term generator.

=SML
fun Ûmake_chartupleÝ ((decls, _, _) : Z_SCH_TEXT) : Z_TM * EXTYPE = (
let	fun f (ZDDec(ids, tm, Value ty)) = (
		(map (fn id => (ZTmLVar(id, Value ty, []), ty)) ids)
	) | f (ZDSchemaDec (ZTmDecor (tm, d), Value ty)) = (
	let	val ty' = case sub_type zti_subs ty of
				ExType ("SET", [ty'']) => ty''
				| _ => fail "make_chartuple" 62903 [];
	in
		[(ZTmÊ(tm, d), ty')]
	end
	) | f (ZDSchemaDec (tm, Value ty)) = (
	let	val ty' = case sub_type zti_subs ty of
				ExType ("SET", [ty'']) => ty''
				| _ => fail "make_chartuple" 62903 [];
	in
		[(ZTmÊ(tm, ""), ty')]
	end
	) | f _ = fail "make_chartuple" 62904 [];
in
	case decls of
	[] => fail "make_chartuple" 62902 []
	|decls => 
		let	val (tml, tyl) = split (flat (map f decls));
		in
			case (tml, tyl) of
			([tm], [ty]) => (tm, ty)
			|_ => (ZTmTuple tml, tuple_extype tyl)
		end
end);
=TEX


=SML
fun Ûaux_compatibilityÝ [] tym1 tym2 = ([], [], [])
  | aux_compatibility (c::cl) tym1 tym2 = (
let	val 	(tym, idtyl1, idtyl2) = aux_compatibility cl tym1 tym2;
in 
	case (lassoc5 tym1 c,lassoc5 tym2 c) of
	(Nil,Value ty) => ((c,ty)::tym, idtyl1, idtyl2)
	|(Value ty,Nil) => ((c,ty)::tym, idtyl1, idtyl2)
	|(Value ty1, Value ty2) => (
			(unify zti_subs (ty1, ty2);
				((c,sub_type zti_subs ty1)::tym, idtyl1, idtyl2))
			handle Fail msg =>
				(tym, (c,sub_type zti_subs ty1)::idtyl1,
					(c,sub_type zti_subs ty2)::idtyl2)

		)
	|_ => (tym, idtyl1, idtyl2)
end);

=TEX
=SML
fun ÛcompatibleÝ ((idtyl1, idtyl2):((IDENT * EXTYPE) list) * ((IDENT * EXTYPE) list))
		: (IDENT * EXTYPE) list = (
let	val cl = (list_cup o (map(map fst))) [idtyl1,idtyl2];
in
	case aux_compatibility cl idtyl1 idtyl2 of
	(tym, [], []) => (
		 tym
	) | (_, idtyl1, idtyl2) => (
		raise ZExn (FailedZCompat
 (idtyl1, idtyl2))
	)
end);
=TEX
=SML
fun ÛincludesÝ ((idtyl1, idtyl2):((IDENT * EXTYPE) list) * ((IDENT * EXTYPE) list))
		: (IDENT * EXTYPE) list = (
let	val (cl1, tyl1) = split idtyl1;
	val (cl2, tyl2) = split idtyl2;
in
	if cl2 diff cl1 = []
	then
		case aux_compatibility cl1 idtyl1 idtyl2 of
		(tym, [], []) => (
			 (tym drop (fn (s,_) => s mem cl2))
		) | (_, idtyl1', idtyl2') => (
			raise ZExn (FailedZCompat (idtyl1', idtyl2'))
		)
	else
		raise (ZExn (FailedZIncludes (cl2 diff cl1)))
end);
=TEX

\section{INFERRING TYPES IN Z DECLARATIONS}

The first thing we need to do is to type infer schema as declarations which
appear in a group of declarations. Note that the
environment is not extended at this point.
The following function achieves this:

=SML
fun Ûti_dec_pass_1Ý (env : Z_ENV) (z_dec as ZDSchemaDec (tm, _) : Z_DEC)
				: Z_DEC * Z_ENV * (IDENT * EXTYPE) list = (
let	val (tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val env' = dec_boundvars env idtyl;
		in
			(ZDSchemaDec (tm', Value ty'), env',  idtyl)
		end)
	|_ => raise ZExn (FailedZDDec2 (z_dec, env, tm', ty'))
end)
  | ti_dec_pass_1 env (z_dec as ZDDec (ids, tm, _)) = (
let	val unk = ExVartype (Unknown (next_name()));
	val idtyl = map (fn id => (id, unk)) ids;
	val env' = dec_boundvars env idtyl;
in
	(ZDDec (ids, tm, Nil), env', idtyl)
end)
=TEX

=SML
and Ûti_z_dec_pass_2Ý (env : Z_ENV) ((z_dec as ZDSchemaDec (tm, _)) : Z_DEC, _, idtyl) = (
	(z_dec, idtyl)
)
  | ti_z_dec_pass_2 env (z_dec as ZDDec (ids, tm, _), _, idtyl) = (
let	val (tm', ty') = ti_z_tm env tm;
	val ty'' = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ExType ("SET", [ty'']), ty')
			handle Fail _ =>
			raise ZExn (FailedZDDec1 (z_dec, env, tm', ty'));
	val setidtyl = map (fn (id, ty) => (id, ty'')) idtyl;
	val side = compatible (setidtyl, idtyl)
			handle ZExn (FailedZCompat (idtyl1, idtyl2)) =>
			raise ZExn (FailedZDDec3 (z_dec, env, idtyl2, idtyl1));
in
	(ZDDec (ids, tm', Value (sub_type zti_subs ty'')), idtyl)
end)
=TEX

=SML
and Ûmap_compatÝ ((dec, env, idtyl)::more) res = (
let	val idtyl' = compatible (idtyl, res)
			handle ZExn (FailedZCompat (idtyl1, idtyl2)) =>
			raise ZExn (FailedZDDec3 (dec, env, idtyl1, idtyl2));

in
	map_compat more (idtyl' cup res)
end)
  | map_compat [] res = res
=TEX

=SML
and Ûlist_ti_z_decÝ (env : Z_ENV) (z_decl : Z_DEC list) : (Z_DEC list * Z_ENV
		* (IDENT * EXTYPE) list) = (
let	val pass1 = map (ti_dec_pass_1 env) z_decl;
	val idtyl =  map_compat pass1 [];
	val (_, envl, _) = split3 pass1;
	fun mk_env (env::rest) = (
		fn id => (
			case env id of
			FreeVar Nil => (mk_env rest) id
			|thing => thing)
	) | mk_env [] = fn id => FreeVar Nil;
	val env' = mk_env envl;
	val pass2 = map (ti_z_dec_pass_2 env') pass1;
	val idtyl' = map (fn (id,ty) => (id, sub_type zti_subs ty)) idtyl;
in
	(map fst pass2, sub_ty env', idtyl')
end)
=TEX
\section{INFERRING TYPES IN Z SCHEMAS}

Note that if the predicate part of a schema text is
not boolean, then this constitutes a type checking error.
The caller of $ti\_z_schtext$ should make this check, as
it is likely
to have more contextual information for reporting informative
error messages than $ti\_z_schtext$. 

=SML
and Ûti_z_schtextÝ (env : Z_ENV) (schtext : Z_SCH_TEXT as (ds, otm, oty))
			: Z_SCH_TEXT * Z_ENV * (IDENT * EXTYPE) list = (
let	val (ds', env', idtyl) = list_ti_z_dec env ds;
in
	case otm of
	Nil =>		((ds', Nil, Nil), env', idtyl)
	|Value tm => (
		let	val (tm', ty') = ti_z_tm env' tm;
			val side = unify zti_subs (ty', ex_bool)
				handle Fail msg =>
				raise ZExn (FailedZSchText (schtext, env, tm', ty'));
		in
			((ds', Value tm', Value ty'), env', idtyl)
		end)
end)
=TEX

\section{INFERRING TYPES IN Z TERMS}

\subsection{Sequence Display}

=SML
and Ûti_z_tmÝ (env : Z_ENV) (term as ZTm§¢ (_, tl)) : Z_TM * EXTYPE = (
let	val tmlist = list_ti_z_tm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise ZExn (FailedZTm (term, env, Failed§¢(tl, tyl)));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = (tuple_extype [ex_ú, sub_type zti_subs ty]);
in
	(ZTm§¢ (Value resty, tml), ex_set resty)
end)
=TEX
\subsection{Set Display}
=SML
  | ti_z_tm env (term as ZTmSetd (_, tl)) = (
let	val tmlist = list_ti_z_tm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise ZExn (FailedZTm (term, env, FailedSetd(tl, tyl)));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = sub_type zti_subs ty;
in
	(ZTmSetd (Value resty, tml), ex_set resty)
end)
=TEX

\subsection{Set Abstraction}
=SML
  | ti_z_tm env (term as ZTmSeta1 schtext) = (
let	val ctm = chartuple schtext;
	val (schtext', env', _) = ti_z_schtext env schtext
		handle ZExn (FailedZSchText (_, env, tm', ty')) =>
		raise ZExn (FailedZTm (term, env, FailedSeta(tm',ty',62031)));
	val (_, ty') = ti_z_tm (sub_ty env') ctm;
in
	(ZTmSeta1 schtext', ex_set ty')
end)
=TEX
=SML
  | ti_z_tm env (term as ZTmSeta2 (schtext, tm)) = (
let	val (schtext', env', _) = ti_z_schtext env schtext
		handle ZExn (FailedZSchText (_, env, tm', ty')) =>
		raise ZExn (FailedZTm (term, env, FailedSeta(tm',ty',62032)));
	val (tm', ty') = ti_z_tm (sub_ty env') tm;
in
	(ZTmSeta2(schtext', tm'), ex_set ty')
end)
=TEX

\subsection{Powerset}
=SML
  | ti_z_tm env (term as ZTmð tm) = (
let	val (tm', ty') = ti_z_tm env tm;
	val tya = ex_set (ExVartype (Unknown (next_name())));
	val side = unify zti_subs (ty', tya)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, Failedset (tm', ty')));
in
	(ZTmð tm', ex_set (sub_type zti_subs tya))
end)
=TEX

\subsection{Tuple Display}
=SML
  | ti_z_tm env (ZTmTuple []) =
	scream "The paragraph may not contain a zero length tuple"
  | ti_z_tm env (ZTmTuple tml) = (
let	val tmlist = list_ti_z_tm env tml;
	val (tml', tyl') = split tmlist;
	val ty = tuple_extype (map (sub_type zti_subs) tyl');
in
	(ZTmTuple tml', ty)
end)
=TEX
\subsection{Binding Display}
=SML
  | ti_z_tm env (ZTmBinding []) =
	scream "The paragraph may not contain a zero length binding"
  | ti_z_tm env (term as (ZTmBinding eds)) = (
let	val (idl, tml) = split eds;
	val rep = get_repeats idl;
	val side = case rep of
		[] => ()
		| _ =>	raise ZExn (FailedZTm (term, env, FailedBinding rep));
	val (tml', tyl') = split(list_ti_z_tm env tml);
	val ty = bind_extype (combine idl tyl');
	val eds' = combine idl tml';
in
	(ZTmBinding eds', ty)
end)
=TEX
\subsection{Product}
=SML
  | ti_z_tm env (ZTm¸ []) =
	scream "The paragraph may not contain a zero length product type"
  | ti_z_tm env (term as ZTm¸ tml) = (
let	fun get_unify_failures ((tm, (ty1, ty2))::rest) = (
	let	val res = (unify zti_subs (ty1, ty2);true)
			handle Fail msg => false;
	in
		if res then get_unify_failures rest
		else (tm,ty2)::get_unify_failures rest
	end
	) | get_unify_failures [] = [];
	val tmlist = list_ti_z_tm env tml;
	val (tml', tyl') = split tmlist;
	val unkl = map (fn x => (ExVartype (Unknown(next_name())))) tml';
	val punkl = map (fn x => ex_set x) unkl;
	val typairs = combine punkl tyl';
	val side = case get_unify_failures (combine tml' typairs) of
		[] => ()
		|failures =>
		   (let	val(ftml, ftyl) = split failures;
		   in
			raise ZExn (FailedZTm (term, env, Failed¸ (ftml, ftyl)))
		   end);
	val ty =  ex_set (tuple_extype (map (sub_type zti_subs) unkl));

in
	(ZTm¸ tml', ty)
end)
=TEX
\subsection{Theta}
=SML
  | ti_z_tm env (term as ZTmÊ (tm, decor)) = (
let	val (tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	SchemaType idtyl =>
			(ZTmÊ(tm', decor), bind_extype idtyl)
	|_ => raise ZExn (FailedZTm (term, env, FailedÊ (tm', ty')))
end)
=TEX

\subsection{Tuple Selection}

=SML
  | ti_z_tm env (term as ZTmSel‰T (tm, i)) = (
let	val (tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	TupleType tyl => (
		let	val sz = length tyl;
			val ty'' = nth (i-1) tyl
				handle Fail _ =>
				raise ZExn (FailedZTm  (term, env, FailedSel‰T1 (i, sz)));
		in
			(ZTmSel‰T(tm', i), sub_type zti_subs ty'')
		end)
	|_ => raise ZExn (FailedZTm (term, env, FailedSel‰T2 (tm', ty')))
end)
=TEX

\subsection{Binding Selection}

=SML
  | ti_z_tm env (term as ZTmSel‰B (tm, id)) = (
let	val (tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	BindingType idtyl => (
		case lassoc5 idtyl id of
		Nil => raise ZExn (FailedZTm  (term, env, FailedSel‰B1 (tm', id)))
		|Value ty'' =>
			(ZTmSel‰B(tm', id), sub_type zti_subs ty'')
		)
	|_ => raise ZExn (FailedZTm (term, env, FailedSel‰B2 (tm', ty')))
end)
=TEX

\subsection{Application}
=SML
  | ti_z_tm env (term as ZTmApp (ZTmLVar ((TmplIn (StubUS, ("=", Nil),
		StubUS), ""), Nil, []), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
	val side = unify zti_subs (ty1', ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEq (tm1', tm2', ty1', ty2')));
in
	(ZTmEq (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_z_tm env (term as ZTmApp (ZTmLVar ((TmplIn (StubUS, ("", Nil),
		StubUS), ""), Nil, []), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
	val unk = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ex_set unk, ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed1(tm2', ty2')));
	val side = unify zti_subs (ty1', sub_type zti_subs unk)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed2(tm2', ty2')));
in
	(ZTm (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_z_tm env (term as ZTmApp (tmf, tma)) = (
let	val (tmf', tyf) = ti_z_tm env tmf;
	val (tma', tya) = ti_z_tm (sub_ty env) tma;
	val tvn = next_name();
	val tyr = ExVartype(Unknown tvn);
	val side = unify zti_subs (tyf, ex_set (tuple_extype([tya,tyr])))
			handle Fail _ =>
			raise ZExn (FailedZTm (term, env,
				FailedApp (tmf', tma', tyf, tya)));

in
		(ZTmApp(tmf',tma'), sub_type zti_subs tyr)
end)
=TEX
=SML
  | ti_z_tm env (term as ZTmFancyApp ((TmplIn (StubUS, ("=", Nil),
		StubUS), ""), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
	val side = unify zti_subs (ty1', ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEq (tm1', tm2', ty1', ty2')));
in
	(ZTmEq (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_z_tm env (term as ZTmFancyApp ((TmplIn (StubUS, ("", Nil),
		StubUS), ""), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
	val unk = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ex_set unk, ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed1(tm2', ty2')));
	val side = unify zti_subs (ty1', sub_type zti_subs unk)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed2(tm2', ty2')));
in
	(ZTm (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_z_tm env (term as ZTmFancyApp (id as (n, d), tma)) = (
	case get_zfixity_info (first_tmpl_id n) of
	Value((_, ZClGen _),_) => (
		case tma of
		ZTmTuple tml => ti_z_tm env (ZTmLVar (id, Nil, tml))
		| _ => scream "Argument to a generic must be a tuple"
		)
	|Value((_, ZClRel),_) => (
		case tma of
		ZTmTuple [tma'] =>
			ti_z_tm env (ZTmFancyApp ((TmplIn (StubUS, ("", Nil), StubUS), ""),
				ZTmTuple [tma', (ZTmLVar (id, Nil, []))]))
		|ZTmTuple _ =>
			ti_z_tm env (ZTmFancyApp ((TmplIn (StubUS, ("", Nil), StubUS), ""),
				ZTmTuple [tma, (ZTmLVar (id, Nil, []))]))
		| _ => fail "ti_z_tm" 62004 [fn()=>"(rel) Bad Generic argument"]
		)
	|_ =>
	let	val (tmf', tyf) = ti_z_tm env (ZTmLVar (id, Nil, []));
		val tma' = case tma of
			ZTmTuple [tma'] => tma'
			| _ => tma;
		val (tma'', tya') = ti_z_tm (sub_ty env) tma';
		val tvn = next_name();
		val tyr = ExVartype(Unknown tvn);
		val side = unify zti_subs (tyf, ex_set (tuple_extype([tya',tyr])))
				handle Fail _ =>
				raise ZExn (FailedZTm (term, env,
					FailedFancyApp (id, tma'', tyf, tya')));
	in
		(ZTmApp(tmf', tma''), sub_type zti_subs tyr)
	end)
=TEX

\subsection{Ì-abstraction}
=SML
 | ti_z_tm env (term as ZTmÌ (sch, tm)) = (
let	val ctm = chartuple sch;
	val (sch', env', _) = ti_z_schtext env sch;
	val env2 = sub_ty env';
	val (tm', ty') = ti_z_tm env2 tm;
	val env3 = sub_ty env2;
	val (tm2, ty2) = ti_z_tm (sub_ty env3) ctm;
	val ty = ex_set (tuple_extype [ty2, ty']);
in
	(ZTmÌ (sch', tm'), ty)
end)
=TEX

\subsubsection{Definite Description}
=SML
 | ti_z_tm env (ZTmÍ1 sch) = (
let	val ctm = chartuple sch;
	val (sch',env', _) = ti_z_schtext env sch;
	val (_, ty') = ti_z_tm (sub_ty env') ctm;
in
	(ZTmÍ1 sch', ty')
end)
=TEX
=SML
 | ti_z_tm env (ZTmÍ2 (sch, tm)) = (
let	val (sch',env', _) = ti_z_schtext env sch;
	val (tm', ty') = ti_z_tm (sub_ty env') tm;
in
	(ZTmÍ2 (sch', tm'), ty')
end)
=TEX

\subsection{Truth}

ZTmTruth is not expected by the parser, but we pass it on anyway.
=SML
  | ti_z_tm env (ZTmTruth truth) = (
	(ZTmTruth truth, ex_bool)
)
=TEX

\subsection{Predicate Negation}

=SML
 | ti_z_tm env (term as ZTm³‰F tm) = (
let	val (tm', ty') = ti_z_tm env tm;
	val (tm'', ty'') = (
		case manifest ty' of
		SchemaType idtyl => (
			bind_zenv env term tm' idtyl;
			(ZTmSchemaPred tm', ex_bool))
		|_ => (tm', ty')
		);
	val side = (unify zti_subs (ty'', ex_bool)
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, Failed³‰F (tm', ty')))
		);
in
	(ZTm³‰F tm'', ty'')
end)
=TEX

\subsection{Logical Infix Operators for Predicates}

=SML
 | ti_z_tm env (term as ZTmLogInOp‰F (inop, tm1, tm2)) = (
let	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm1'', ty1'') = (
		case manifest ty1' of
		SchemaType idtyl => (
			bind_zenv env term tm1' idtyl;
			(ZTmSchemaPred tm1', ex_bool))
		|_ => (tm1', ty1')
		);
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
	val (tm2'', ty2'') = (
		case manifest ty2' of
		SchemaType idtyl => (
			bind_zenv env term tm2' idtyl;
			(ZTmSchemaPred tm2', ex_bool))
		|_ => (tm2', ty2')
		);
	val side = unify zti_subs (ty1'', ex_bool)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰F (inop, tm1'', ty1'')));
	val side = unify zti_subs (ty2'', ex_bool)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰F (inop, tm2'', ty2'')));
in
	(ZTmLogInOp‰F(inop, tm1'' ,tm2''), ex_bool)
end
)
=TEX

\subsection{Predicate Quantification}
=SML
  | ti_z_tm env (term as ZTmQuant‰F (quant, sch, tm)) = (
let	val (sch', env', _) = ti_z_schtext env sch;
	val (tm', ty') = ti_z_tm (sub_ty env') tm;
	val (tm'', ty'') = (
		case manifest ty' of
		SchemaType idtyl =>	(
			bind_zenv env term tm' idtyl;
			(ZTmSchemaPred tm', ex_bool))
		|_ => (tm', ty')
		);
	val side = (unify zti_subs (ty'', ex_bool)
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, FailedQuant‰F (quant, tm'', ty'')))
		);
in
	(ZTmQuant‰F (quant, sch', tm''), sub_type zti_subs ty'')
end
)
=TEX


\subsection{Schemas as Predicates}

ZTmSchemaPred is not expected from the parser, but we pass it on anyway.
=SML
  | ti_z_tm env (term as ZTmSchemaPred tm) = (
	(ZTmSchemaPred tm, ex_bool)
)
=TEX

\subsection{Horizontal Schemas}

=SML
  | ti_z_tm env (term as ZTmHorizSchema sch) = (
let	val (sch', env', idtyl) = ti_z_schtext env sch;
	val ty = ex_set (bind_extype idtyl);
in
	(ZTmHorizSchema sch', ty)
end)
=TEX

\subsubsection{Decoration}
=SML
 | ti_z_tm env (term as ZTmDecor (tm, d)) = (
let	val (tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idtyl' = map (fn ((t, dec), ty) => ((t, dec^d), ty)) idtyl;
			val ty'' = ex_set (bind_extype idtyl');
		in
			(ZTmDecor(tm', d), ty'')
		end
	) | _ => raise ZExn (FailedZTm (term, env, FailedDecor (tm', ty')))
end)
=TEX
\subsubsection{Precondition}
=SML
  | ti_z_tm env (term as ZTmPre tm) = (
let	val (tm', ty') = ti_z_tm env tm;
	fun is_post (n, d) =
		case (rev o explode) d of
		("!"::rest) => true
		|("'"::rest) => true
		|_ => false;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idtyl' = idtyl drop (fn(id, ty) => is_post id);
			val ty'' = ex_set (bind_extype idtyl');
		in
			(ZTmPre tm', ty'')
		end)
	| _ => raise ZExn (FailedZTm (term, env, FailedPre (tm', ty')))
end)
=TEX
\subsubsection{Schema Negation}
=SML
 | ti_z_tm env (term as ZTm³‰S tm) = (
let	val (tm', ty') = ti_z_tm env tm
	val side = (
		case manifest ty' of
		SchemaType _ 	=> ()
		|_ => 	raise ZExn (FailedZTm (term, env, Failed³‰S (tm', ty')))
		)
in
	(ZTm³‰S tm', ty')
end)
=TEX

\subsection{Logical Infix Operators for Schemas}

=SML
 | ti_z_tm env (term as ZTmLogInOp‰S (inop, tm1, tm2)) = (
let	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1, SchemaType idtyl2) => (
		let	
			val idtyl' = compatible (idtyl1, idtyl2)
				handle ZExn (FailedZCompat (idtyl1, idtyl2)) =>
				raise ZExn (FailedZTm (term, env,
					FailedLogInOp‰S1 (inop, tm1', tm2', idtyl1, idtyl2)))
		in
			(ZTmLogInOp‰S(inop, tm1',tm2'), ex_set (bind_extype idtyl'))
		end
	) | (SchemaType _, _) => (
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰S2 (inop, tm2', ty2')))
	) | (_, _) => (
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰S2 (inop, tm1', ty1')))
	)
end
)
=TEX

\subsubsection{Schema Projection}

=SML
  | ti_z_tm env (term as ZTmù (tm1, tm2)) = (
let	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1, SchemaType idtyl2) => (
		let	val idtyl1' = map (fn ((n,d),t) => ((n,""),t)) idtyl1;
			val idtyl2' = map (fn ((n,d),t) => ((n,""),t)) idtyl2;
			val idtyl' = compatible (idtyl1', idtyl2')
				handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
				raise ZExn (FailedZTm (term, env,
					Failedù1 (tm1', tm2', idtyl1'', idtyl2'')))
		in
			(ZTmù(tm1',tm2'), ty2')
		end
	) | (SchemaType _, _) => (
		raise ZExn(FailedZTm(term, env, Failedù2 (tm2', ty2')))
	) | (_, _) => (
		raise ZExn(FailedZTm(term, env, Failedù2 (tm1', ty1')))
	)
end
)
=TEX
\subsubsection{Schema Hiding}

=SML
  | ti_z_tm env (term as ZTmHide (tm, idl)) = (
let	val (tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idm = idtyl drop (fn(id,ty) => (id mem idl));
			val ty'' = ex_set (bind_extype idm);
		in
			(ZTmHide(tm',idl), ty'')
		end)
	| _ => raise ZExn(FailedZTm(term, env, FailedHide (tm', ty')))
end
)
=TEX

\subsubsection{Schema Quantification}

=SML
  | ti_z_tm env (term as ZTmQuant‰S (quant, sch, tm)) = (
let	val (sch', _, idtyl1) = ti_z_schtext env sch;
	val (tm2', ty2') = ti_z_tm env tm;
in
	case manifest ty2' of
	SchemaType idtyl2 => (
		let	val idtyl' = includes (idtyl2, idtyl1)
				handle
				ZExn (FailedZCompat (idtyl2'', idtyl1'')) => (
					raise ZExn (FailedZTm (term, env,
					FailedQuant‰S1 (quant, tm2', idtyl1'', idtyl2''))))
				|ZExn (FailedZIncludes idl) => (
					raise ZExn (FailedZTm (term, env, 
					FailedQuant‰S3 (quant, tm2', idl))));
		in
			(ZTmQuant‰S(quant, sch', tm2'), ex_set (bind_extype idtyl'))
		end
	) |_ => raise ZExn(FailedZTm(term, env, FailedQuant‰S2 (quant, tm2', ty2')))
end)
=TEX

\subsubsection{„ and ˜}

=SML
  | ti_z_tm env (term as ZTm„ tm) = (
let	val(tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idtyl' = map (fn ((t, d), ty) => ((t, d^"'"), ty)) idtyl;
			val ty'' = ex_set (bind_extype (idtyl@idtyl'));
		in
			(ZTm„ tm', ty'')
		end
	) | _ => raise ZExn (FailedZTm (term, env, Failed„ (tm', ty')))
end)
=TEX

=SML
  | ti_z_tm env (term as ZTm˜ tm) = (
let	val(tm', ty') = ti_z_tm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idtyl' = map (fn ((t, d), ty) => ((t, d^"'"), ty)) idtyl;
			val ty'' = ex_set (bind_extype (idtyl@idtyl'));
		in
			(ZTm˜ tm', ty'')
		end
	) | _ => raise ZExn (FailedZTm (term, env, Failed˜ (tm', ty')))
end)
=TEX

\subsection{Set Membership and Equality}

=SML
  | ti_z_tm env (term as ZTmEq (_, _)) = (
	(term, ex_bool)
)
=TEX
=SML
  | ti_z_tm env (term as ZTm (_, _)) = (
	(term, ex_bool)
)
=TEX

\subsection{Schema Composition}

=SML
 | ti_z_tm env (term as ZTm» (tm1, tm2)) = (
let	fun add_prime (id as (n, d)) =
		(n, d^"'");
	fun f tym1 [] = ([], [], [])
	  | f tym1 ((id2, ty2)::t) = (
		let	val id2' = add_prime id2;
		in
			case lassoc5 tym1 id2' of
			Value ty1 => (
				let	val (dl, idtyl1, idtyl2) = f tym1 t;
				in
					(unify zti_subs (ty1, ty2); (id2::dl, idtyl1, idtyl2))
					handle Fail _ => (dl, (id2',ty1)::idtyl1, (id2,ty2)::idtyl2)
				end)
			| Nil => f tym1 t
		end);
	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
=TEX
=SML
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1,SchemaType idtyl2) => 
		let	val (dropl, fidtyl1, fidtyl2) = f idtyl1 idtyl2;
			val pdropl = map add_prime dropl;
		in
			case (fidtyl1, fidtyl2) of
			([], []) => (
				let	val idtyl1' = idtyl1 drop
						 (fn (id,ty) => id mem pdropl);
					val idtyl2' = idtyl2 drop
						(fn (id,ty) => id mem dropl);
					val idtyl' = compatible (idtyl1', idtyl2')

						handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
						raise ZExn (FailedZTm (term, env,
						Failed»1 (tm1', tm2', idtyl1'', idtyl2'')))
				in
					(ZTm»(tm1',tm2'), ex_set (bind_extype idtyl'))
				end)
			|_ => raise ZExn (FailedZTm (term, env,
					Failed»1 (tm1', tm2', fidtyl1, fidtyl2)))
		end
	| (SchemaType _, _) => raise ZExn (FailedZTm (term, env, Failed»2 (tm2', ty2')))
	| _ => raise ZExn (FailedZTm (term, env, Failed»2 (tm1', ty1')))
end)
=TEX

\subsection{Schema Piping}
=SML
 | ti_z_tm env (term as ZTmPipe (tm1, tm2)) = (
let	fun change_q (id as (n, d)) = (
		case (rev o explode) d of
		"?"::rest => (n, (implode o rev) ("!"::rest))
		|_ => id);
	fun f tym1 [] = ([], [], [])
	  | f tym1 ((id2, ty2)::t) = (
		let	val id2' = change_q id2;
		in
			case lassoc5 tym1 id2' of
			Value ty1 => (
				let	val (dl, idtyl1, idtyl2) = f tym1 t;
				in
					(unify zti_subs (ty1, ty2); (id2::dl, idtyl1, idtyl2))
					handle Fail _ => (dl, (id2',ty1)::idtyl1, (id2,ty2)::idtyl2)
				end)
			| Nil => f tym1 t
		end);
	val (tm1', ty1') = ti_z_tm env tm1;
	val (tm2', ty2') = ti_z_tm (sub_ty env) tm2;
=TEX
=SML
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1,SchemaType idtyl2) => 
		let	val (dropl, fidtyl1, fidtyl2) = f idtyl1 idtyl2;
			val bang_dropl = map change_q dropl;
		in
			case (fidtyl1, fidtyl2) of
			([], []) => (
				let	val idtyl1' = idtyl1 drop
						 (fn (id,ty) => id mem bang_dropl);
					val idtyl2' = idtyl2 drop
						(fn (id,ty) => id mem dropl);
					val idtyl' = compatible (idtyl1', idtyl2')

						handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
						raise ZExn (FailedZTm (term, env,
						FailedPipe1 (tm1', tm2', idtyl1'', idtyl2'')))
				in
					(ZTmPipe(tm1',tm2'), ex_set (bind_extype idtyl'))
				end)
			|_ => raise ZExn (FailedZTm (term, env,
					FailedPipe1 (tm1', tm2', fidtyl1, fidtyl2)))
		end
	| (SchemaType _, _) => raise ZExn (FailedZTm (term, env, FailedPipe2 (tm2', ty2')))
	| _ => raise ZExn (FailedZTm (term, env, FailedPipe2 (tm1', ty1')))
end)
=TEX



\subsection{Integer and String Quotation}
=SML
  | ti_z_tm env (ZTmú i) = (ZTmú i, ex_ú)
  | ti_z_tm env (ZTmString s ) = (ZTmString s, ex_set (tuple_extype [ex_ú, ex_char]))
=TEX

\subsection{Type Constraints}

This section is obsolete.
\subsection{Local Variables}
=SML
 | ti_z_tm env (ZTmLVar ((TmplNon ("true", Nil), ""), Nil, tml)) = (
	(ZTmTruth true, ex_bool)
)| ti_z_tm env (ZTmLVar ((TmplNon ("false", Nil), ""), Nil, tml)) = (
	(ZTmTruth false, ex_bool)
)| ti_z_tm env (term as ZTmLVar (id as (n, d), _, tml)) = (
let	fun find_in_scope (ident as (n, d)) = (
	let
		val exd = (rev o explode) d;
		fun aux (decor as d0::rest) res =
		let	val sd = (implode o rev) decor;
		in
			case env (n, sd) of
			GlobalVar ty => ((n, sd), GlobalVar ty, res)
			|BoundVar ty => ((n, sd), BoundVar ty, res)
			|_ => aux rest (d0::res)
		end
		  | aux [] res = (
			case env (n, "") of
			GlobalVar ty => ((n, ""), GlobalVar ty, res)
			|BoundVar ty => ((n, ""), BoundVar ty, res)
			|other => ((n, ""), other, res)
			);
	in
		case aux exd [] of
		(id, GlobalVar ty, res) => (id, GlobalVar ty, implode res)
		|(id, BoundVar ty, res) => (id, BoundVar ty, implode res)
		|(_, other, _) => (ident, other, "")
	end);
=TEX
=SML
	fun local_variable id ty = (
		case tml of
		[] => (
			(ZTmLVar(id, Value ty, []), ty)
		)|_ => (
			raise ZExn (FailedZTm (term, env, FailedGlobalVar id))
		)
	);
	fun setup_new_var id = (
	let	val newenv = update_zenv env id
			handle ZExn (FailedZFreeVar id) =>
			raise ZExn (FailedZTm (term, env, FailedFreeVar id));
	in
		case newenv id of
		FreeVar (Value ty) => ty
		|_ =>  scream "Bound or global variable went undetected"
	end);
=TEX
=SML
in
	case find_in_scope id of
	(id', GlobalVar ty', "") => (
		ti_z_tm env (ZTmGVar (id', Nil, tml))
	)|(id', BoundVar ty', "") => (
		local_variable id ty'
	)|(id', GlobalVar ty', d') => (
		case manifest ((fn (ExType ("­", [_,t])) => t | t => t) ty') of
		SchemaType _ => (
			ti_z_tm env (ZTmDecor (ZTmGVar (id', Nil, tml), d'))
		) |_ =>
			let	val ty'' = setup_new_var id;
			in
				local_variable id ty''
			end
	)|(id', BoundVar ty', d') => (
		case manifest ((fn (ExType ("­", [_,t])) => t | t => t) ty') of
		SchemaType _ => (
			ti_z_tm env (ZTmDecor (ZTmLVar (id', Nil, tml), d'))
		) |_ =>
			let	val ty'' = setup_new_var id;
			in
				local_variable id ty''
			end


	)|(_, FreeVar Nil, _) => (
		let	val ty' = setup_new_var id;
		in
			local_variable id ty'
		end
	)|(_, FreeVar (Value ty'), _) => (
		local_variable id ty'
	)
end
)
=TEX

\subsection{Global Variables}

=SML
 | ti_z_tm env (term as ZTmGVar (id as (n, d), _, tml)) = (
	case (env id, tml, id) of 
	(GlobalVar (ExType ("­",[domty, _])), [], (TmplNon ("U", Nil),"")) => 
		let	val gentyl = untuple_extype domty
				handle Fail _ => [domty];
			val z_tml' = map (fn x => ZTmGVar((TmplNon
					("Totality",Nil),""), Nil, [])) gentyl;
		in
			ti_z_tm env (ZTmGVar(id, Nil, z_tml'))
		end
	| (GlobalVar (ExType ("­",[domty, _])),[],_) => 
		let	val gentyl = untuple_extype domty
				handle Fail _ => [domty];
			val z_tml' = map (fn x => ZTmGVar((TmplNon("U",Nil), ""),Nil, []))
									 gentyl;
		in
			ti_z_tm env (ZTmGVar(id, Nil, z_tml'))
		end
	| (GlobalVar (ty as ExType("­",[domty,ranty])), _, _) =>
		let	val (tml', tyl') = split (list_ti_z_tm env tml);
			val argty = tuple_extype tyl';
			val resty = ExVartype(Unknown (next_name()));
			val side = unify zti_subs (ExType ("­",[domty, ranty]),
					ExType ("­", [argty, resty]))
				handle Fail _ =>
				let	val len = case manifest domty of
						TupleType tyl => length tyl
						| _ => scream
						  "Generic actual parameter is badly formed";
				in
					raise ZExn (FailedZTm (term, env, FailedActual (id, len)))
				end;
			val vty = sub_type zti_subs resty;
			in
				(ZTmGVar(id, Value vty, tml'), vty)
			end
	| (GlobalVar ty, [], _) =>	(ZTmGVar(id, Value ty, []), ty)
	| (GlobalVar ty, _, _) => (
		raise ZExn (FailedZTm (term, env, FailedGlobalVar id))
	) |_ => scream "The environment has no knowledge of a constant in the theory"
)
=TEX

\subsection{Let Expressions}

=SML
 | ti_z_tm env (term as ZTmLet (eqdefl, tm)) = (
let	val (abbl, defl) = split eqdefl;
	val (defl', tyl') = split (list_ti_z_tm env defl);
	val abbtyl' = combine abbl tyl';
	val eqdefl' = combine abbl defl';
	val env' = (fn id =>
		case lassoc5 abbtyl' id of
		Nil => (update_zenv env id
			handle ZExn (FailedZFreeVar id) =>
			raise ZExn (FailedZTm (term, env, FailedFreeVar id)); env id)
		|Value ty => BoundVar ty
		);
	val (tm', ty') = ti_z_tm env' tm;
in
	(ZTmLet (eqdefl', tm'), ty')
end
)
=TEX

\subsection{Renaming}
=SML
 | ti_z_tm env (term as ZTmRename (tm, ididl)) = (
let	val (tm', ty') = ti_z_tm env tm;
	val (idnewl, idoldl) = split ididl;
	val rep1 = get_repeats idnewl;
	val rep2 = get_repeats idoldl;
	val side = case rep1 of
		[] => ()
		|_ =>	raise ZExn (FailedZTm (term, env, FailedRename2 rep1));
	val side = case rep2 of
		[] => ()
		|_ =>	raise ZExn (FailedZTm (term, env, FailedRename3 rep2));
in
	case manifest ty' of
	SchemaType idtyl =>
		(ZTmRename(tm', ididl), bind_extype (map (fn (id, ty) =>
			(rassoc4 ididl id id, ty)) idtyl))
	|_ => raise ZExn (FailedZTm (term, env, FailedRename1 (tm', ty')))
end
)
=TEX

\subsection{Bracketed Terms}
=SML
 | ti_z_tm env (term as ZTmBracketed tm) = (
let	val (tm', ty') = ti_z_tm env tm
in
	(ZTmBracketed tm', ty')
end
)
=TEX

\subsection{Term Quotation}
=SML
  | ti_z_tm env (ZTmQuotation holtm) = (
let val side = (known_term_tyvars := term_tyvars holtm cup (!known_term_tyvars));
in
	(ZTmQuotation holtm, (type_to_extype o type_of) holtm)
end)
=TEX


\subsection{Type Inferring Lists of Z Terms}
=SML
and
Ûlist_ti_z_tmÝ (env : Z_ENV) (tml : Z_TM list) : (Z_TM * EXTYPE) list = (
	let	fun list_ti_aux env nil = nil
		  | list_ti_aux env (tm::rest) = (
		let	val (titerm as (tm, ty)) = ti_z_tm env tm;
			val newenv = sub_ty env;
			val next = list_ti_aux newenv rest;
		in
			(titerm::next)
		end);
	in
		list_ti_aux env tml
	end
);
=TEX

\section{INFERRING TYPES IN Z PARAGRAPHS}

The paragraph datatype includes a constructor for
Z terms. This is a convenient place to include Z terms,
and avoids having another data type which comprises
paragraphs or Z terms.
=SML
datatype ÛZ_INFERREDÝ =	ZInferred of Z_PARA 
		|	ZTypeError of Z_ERROR_INFO;
=TEX
=SML
fun Ûformat_zinferredÝ inf = (
	case inf of
	ZInferred p => format_z_para p
	|ZTypeError errinfo => print_z_error errinfo
);
=TEX
=SML
fun Ûti_z_paraÝ (p as ZParaAbbDef (id, formals, tm, _): Z_PARA) : Z_INFERRED = (
let	val env = init_zenv false formals;
	val (tm', ty') = ti_z_tm env tm;
in
	ZInferred (ZParaAbbDef (id, formals, tm', Value ty'))

end
) | ti_z_para (p as ZParaSchBox (id, formals, sch, _)) = (
let	val env = init_zenv false formals;
	val (sch', env', idtyl) = ti_z_schtext env sch;
	val ty = ex_set (bind_extype idtyl);
in
	ZInferred (ZParaSchBox (id, formals, sch', Value ty))
end
) | ti_z_para  (ZParaAxDes (formals, sch, _)) = (
let	val env = init_zenv false formals;
	val (sch', env', idtyl) = ti_z_schtext env sch;
in
	ZInferred (ZParaAxDes (formals, sch', Value idtyl))
end
=TEX
=SML
) | ti_z_para (p as ZParaFreeType ftdef) = (
let	val env = init_zenv true (map fst ftdef);
	fun ftbranch ftid (id, _, Nil) = (id, Nil, Nil)
	  | ftbranch ftid (id, _, Value tm) = (
	let	val tm' = 
			case tm of
			ZTmTuple [tm] => tm
			|ZTmTuple tml => ZTm¸ tml
			|tm => tm;
		val (tm'', ty'') = ti_z_tm env tm';
		val ty''' = case ty'' of
			ExType ("SET",[ty]) => ty
			|ty => ty;
	in
		(id, Value ty''', Value tm'')
	end);
	fun ftprod (id, idotytml) =
		(id, map (ftbranch id) idotytml);
in
	ZInferred (ZParaFreeType (map ftprod ftdef))
end
=TEX

=SML
) | ti_z_para (p as ZParaGivenSet (idl, Nil)) = (
	ZInferred p
) | ti_z_para (p as ZParaGivenSet (idl, Value (formals, tm))) = (
let	val env = init_zenv false (idl@formals);
	val (tm', ty') = ti_z_tm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPGiven));
in
	ZInferred (ZParaGivenSet (idl, Value (formals, tm')))
end
=TEX
=SML
) | ti_z_para (p as ZParaConstraint (idl, tm)) = (
let	val env = init_zenv false idl;
	val (tm', ty') = ti_z_tm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPConstraint));
in
	ZInferred (ZParaConstraint (idl, tm'))
end
=TEX
=SML
) | ti_z_para (p as ZParaConjecture (id, formals, tm)) = (
let	val env = init_zenv false formals;
	val (tm', ty') = ti_z_tm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPConjecture));
in
	ZInferred (ZParaConjecture (id, formals, tm'))
end
=TEX
=SML
) | ti_z_para (p as ZParaTerm (formals, tm, _)) = (
let	val env = init_zenv false formals;
	val (tm', ty') = ti_z_tm env tm;
in
	ZInferred (ZParaTerm (formals, tm', Value ty'))
end
=TEX
=SML
) | ti_z_para (p as ZParaFixity _) = (
	ZInferred p
);
=TEX
=SML
fun Ûtype_check_z_paraÝ {standard : bool} (p:Z_PARA) : Z_INFERRED = (
let	val side = init_subs zti_subs;
	val side = (zti_standard_z := standard);
	val side = reset_freetype_names();
in
	ti_z_para p
		handle ZExn info => ZTypeError(info)
end);
=TEX

\section{EPILOGUE}
=SML
end (* of structure ZTypeInference *);
=TEX
\pagebreak

\twocolumn[\section{INDEX}]
{	\footnotesize
	\printindex
}
\onecolumn


\end{document}

