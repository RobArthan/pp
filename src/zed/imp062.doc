=TEX
% TQtemplatetex
\documentstyle[hol1,11pt,TQ]{article}
\makeindex
% The following macro is used to insert temporary notes
% in the document.
\def\TempNote#1{{\tiny#1}}
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Type Inferrer}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP062}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}                    %% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{Z, HOL}
\TPPauthor{D.J.~King&WIN01}
%\TPPauthors{R.D.~Arthan&WIN01\\D.J.~King&WIN01\\G.T.~Scullard&MAN05}
\TPPauthorisation{R.D.~Arthan & FMU Manager}
\TPPabstract{A type inference mechanism for Z}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	  R.D.~Arthan \\ R.B.~Jones \\ G.T. Scullard
}}
 
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List} \tableofcontents
\subsection{Document Cross References}\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}
\item[\SCCSversion (3 March 1992)] Initial version.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
\subsubsection{Interface}
\subsubsection{Algorithms}
\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
\section{PREAMBLE}
=SML
structure €ZTypeInference› : ZTypeInference = struct
	open Unification;
	open icl'ZTypesAndTerms;

=TEX
\subsection{Flags and Switches}
=SML
val €check_paras_with_extended_z› = ref false;
val €check_terms_with_extended_z› = ref true;
val €extended_z› = ref false;

val _ = if contains (map fst (get_flags()))
			"check_paras_with_extended_z"
	then	()
	else	new_flag {name = "check_paras_with_extended_z",
			control=check_paras_with_extended_z,
			check=fun_true,
			default = fun_false};

val _ = if contains (map fst (get_flags()))
			"check_terms_with_extended_z"
	then	()
	else	new_flag {name = "check_terms_with_extended_z",
			control=check_terms_with_extended_z,
			check=fun_true,
			default = fun_true};
=TEX
=SML
val €zarray_size› = 100;
val €zti_subs› = new_subs zarray_size;
=TEX

\section{DATA TYPES AND STRUCTURES}

=SML
type €DECOR›	=	string;
type €IDENT›	=	string*DECOR;
datatype €ZTM›	=	Ztß¢ of EXTYPE OPT * ZTM list
		|	Ztsetd of EXTYPE OPT * ZTM list
		|	Ztseta1 of ZSCHTEXT
		|	Ztseta2 of ZSCHTEXT * ZTM
		|	Zt of ZTM
		|	Zttuple of ZTM list
		|	Zt∏ of ZTM list
		|	Zt  of ZTM * DECOR
		|	Ztsel of ZTM * IDENT
		|	Ztapp of ZTM * ZTM
		|	ZtÃ of ZSCHTEXT * ZTM
		|	ZtÕ1 of ZSCHTEXT
		|	ZtÕ2 of ZSCHTEXT * ZTM
		|	Ztschema of ZSCHTEXT
		|	Ztdec of ZTM * DECOR
		|	Ztpre of ZTM
		|	Zt≥ of ZTM
		|	Zt± of ZTM * ZTM
		|	Zt≤ of ZTM * ZTM
		|	Zt¥ of ZTM * ZTM
		|	Zt§ of ZTM * ZTM
		|	Zt˘ of ZTM * ZTM
		|	Zthide of (ZTM * IDENT list)
		|	Ztµ of ZSCHTEXT * ZTM
		|	Zt∂ of ZSCHTEXT * ZTM
		|	Zt∂â1 of ZSCHTEXT * ZTM
		|	ZtÑ of ZTM
		|	Ztò of ZTM
		|	Zttrue
		|	Ztfalse
		|	Zteq of ZTM * ZTM
		|	Ztç of ZTM * ZTM
		|	Ztª of ZTM * ZTM
		|	Ztpipe of ZTM * ZTM
		|	Zt˙ of int
		|	Zt˚˝ of EXTYPE OPT * ZTM list
		|	Ztconstrained of (ZTM * ZTM)
		|	Ztlvar of IDENT*EXTYPE OPT*ZTM list
		|	Ztgvar of IDENT*EXTYPE OPT*ZTM list
		|	Ztbracketed of ZTM
=TEX
=SML
and €ZDEC›	=	ZdDec of IDENT list * ZTM
		|	ZdDecsexp of ZTM * DECOR
=TEX
=SML
withtype €ZSCHTEXT› =	ZDEC list * ZTM;
=TEX

\section{SUPPORTING FUNCTIONS}

\subsection{The Environment}

=SML
type €ZENV› = IDENT -> (bool * EXTYPE);
=TEX
=SML
local	val table:(IDENT * EXTYPE) list ref = ref [];
in
fun €init_zenv› (genformals : IDENT list) : ZENV = (
let	val dummy = start_again()
in	(
	table := (map (fn x => (x,ExType("",[ExVartype(Known("*"^(fst x)))]))) genformals);
	fn id as (s,d) => (
	case lassoc5 (!table) id of
		Nil => (case get_const_info s of
			Nil =>	(
				let val x = ExVartype(Unknown(next_name()))
				in
					((table := (id,x) :: !table);
					(false,x))
				end
							)
			| Value(ty,_) => (true,replaced ty))
		|Value tty => (false,tty))
		)
end
)
=TEX
=SML
and	€env_formals› () : IDENT list =
let	fun 	f [] = []
	|	f (h::t) = (
			case h of 	(x,ExType("",[ExVartype(Known(_))])) => (x::(f t))
			|		_ => (f t))
in
	f (!table)
end
=TEX
=SML
and €show_env› () : (IDENT * EXTYPE)list = !table
end;
=TEX

\subsection{Auxiliary Functions}
=SML
fun €ex_› t = ExType ("", [t]);
val €ex_˙› = ExType ("˙", []);
fun €ex_™› (f, a) = ExType ("™", [f, a]);
val €ex_bool› = ExType ("BOOL", []);
=TEX
=SML
fun €sub_ty› (env:ZENV) : ZENV = (
	fn id =>
		let	val (flag,tty) = env id
		in
			(flag, sub_type zti_subs tty)
		end
);
=TEX



\section{FORMATTING Z TERMS AND TYPES}

=SML
fun €format_ztm› (tm : ZTM) : string = (
	PolyML.makestring tm
);
=TEX

=SML
fun €format_extype› (ExVartype ty : EXTYPE) : string = (
	case ty of
	Known name => "'"^name
	|Unknown tvn => "'"^(string_of_int tvn)
) | format_extype (ExType ("", [ExType ("∏", [ty1, ty2])])) = (
	(format_extype ty1)^"™"^(format_extype ty2)
) | format_extype (ExType ("", [tyl])) = (
	"("^(format_extype tyl)^")"
) | format_extype (ExType ("∏", tyl)) = (
	let	fun aux (ty1::ty2::rest) = (
		(format_extype ty1)^"∏"^(format_extype ty2)
		^(aux rest)
		) | aux [ty] = format_extype ty
		  | aux [] = "";
	in
		aux tyl
	end
) | format_extype (ExType (name, tyl)) = (
	let	fun brkt (s : string) : string = (
		if size s = 0
		then s
		else "(" ^ s ^ ")");
	in
		brkt (format_list format_extype tyl ", ")^name
	end
);
=TEX
=SML
fun €format_schtext› (schtext : ZSCHTEXT) : string = (
	PolyML.makestring schtext
);
=TEX

=SML
fun €format_dec› (decl : ZDEC) : string = (
	PolyML.makestring decl
);
=TEX


\section{ERROR HANDLING AND REPORTING}

=SML
datatype €ZTM_DETAILS›	=
		ZErrß¢ of ZTM list * EXTYPE list
	|	ZErrsetd of ZTM list * EXTYPE list
	|	ZErrseta of ZTM * EXTYPE * int
	|	ZErr of ZTM * EXTYPE
	|	ZErr∏ of ZTM list * EXTYPE list
	|	ZErr  of ZTM * EXTYPE
	|	ZErrsel1 of ZTM * IDENT
	|	ZErrsel2 of ZTM * EXTYPE
	|	ZErrdec of ZTM * EXTYPE
	|	ZErr≥ of ZTM * EXTYPE
	|	ZErr˚˝ of ZTM list * EXTYPE list
	|	ZErreq of ZTM * ZTM * EXTYPE * EXTYPE
	|	ZErrç1 of ZTM * EXTYPE
	|	ZErrç2 of ZTM * EXTYPE
	|	ZErrconstrained of ZTM * EXTYPE * ZTM
	|	ZError;

type €ZTM_INFO› =	(ZTM * ZENV * ZTM_DETAILS);
type €SCHTEXT_INFO› =	(ZSCHTEXT * ZENV * ZTM * EXTYPE);
type €DEC_INFO› =	(ZDEC * ZENV * ZTM * EXTYPE);
=TEX
The following type definition is visible via the signature
$ZTypeInference$.
=SML
datatype €LOCAL_ERROR_INFO› =
		ZTMErrInfo of ZTM_INFO
	|	ZSchErrInfo of SCHTEXT_INFO
	|	ZDecErrInfo of DEC_INFO;

type €ERROR_INFO›	=	LOCAL_ERROR_INFO;
=TEX
=SML
exception €EZTM› of ZTM_INFO;
exception €ESchText› of SCHTEXT_INFO;
exception €EDec› of DEC_INFO;
=TEX

=SML
fun €report› (msg : int) (inserts : string list) : unit = (
	diag_string (get_error_message msg inserts)
);
=TEX

=SML
fun €print_zerrlistinfo› (tml : ZTM list) (tyl : EXTYPE list) : unit = (
let	
	fun plu (x1::x2::rest) = "s"
	  | plu [x1] = ""
	  | plu nil = error "print_zerrlistinfo" 62998 [
		fn()=>"plu"];
	fun sort1 (i1 : int, (tm1:string, ty1:string)) (i2, (tm2, ty2)) =
		if ty1 = ty2 then
			if tm1 = tm2 then 0
			else i1 - i2
		else	Sort.stringorder ty1 ty2;
	fun grpaux ((ty1, tmlist1)::rest1) ((tm2, ty2)::rest2) =
		if ty1 = ty2
		then grpaux ((ty1, tmlist1@[[tm2]])::rest1) rest2
		else grpaux ((ty2, [[tm2]])::(ty1,tmlist1)::rest1) rest2
	  | grpaux res _ = res;	

	fun grp ((tm, ty)::rest) = grpaux [(ty, [[tm]])] rest
	  | grp _ = error "print_zerrlistinfo" 62999 [];
	fun do_errmsgs ((ty, tmlist)::rest) = (
		report 62012 [ty, plu tmlist];
		map (report 62013) tmlist;
		do_errmsgs rest
	) | do_errmsgs nil = nil;
	val stml = map format_ztm tml;
	val styl = map format_extype tyl;
	val tmty = (combine stml styl);
	val itmty = combine (interval 1 (length styl)) tmty;
	val stmty = (map snd) (Sort.sort sort1 (rev itmty));
in
	(do_errmsgs (grp stmty);()
	)
end);
=TEX

=SML
fun €print_zerrß¢› (tml : ZTM list) (tyl : EXTYPE list) : unit = (
	report 62011 ["sequence"];
	print_zerrlistinfo tml tyl
);
=TEX

=SML
fun €print_zerrsetd› (tml : ZTM list) (tyl : EXTYPE list) : unit = (
	report 62011 ["set"];
	print_zerrlistinfo tml tyl
);
=TEX

=SML
fun €print_zerrseta› (tm : ZTM) (ty : EXTYPE) (ierr : int) : unit = (
	report ierr [];
	report 62032 ["predicate"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerr› (tm : ZTM) (ty : EXTYPE) : unit = (
	report 62041 [];
	report 62032 ["set"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerr∏› (tml : ZTM list) (tyl : EXTYPE list) : unit = (
	report 62061 [];
	print_zerrlistinfo tml tyl
);
=TEX

=SML
fun €print_zerr › (tm : ZTM) (ty : EXTYPE) : unit = (
	report 62071 [];
	report 62032 ["schema"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerrsel1› (tm : ZTM) (id as (n,d): IDENT) : unit = (
	report 62081 [];
	report 62082 [n^d];
	report 62083 [format_ztm tm]
);
=TEX

=SML
fun €print_zerrsel2› (tm : ZTM) (ty : EXTYPE) : unit = (
	report 62084 [];
	report 62032 ["binding"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerrdec› (tm : ZTM) (ty : EXTYPE) : unit = (
	report 62131 [];
	report 62032 ["schema"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerr≥› (tm : ZTM) (ty : EXTYPE) : unit = (
	report 62151 [];
	report 62032 ["predicate"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerr˚˝› (tml : ZTM list) (tyl : EXTYPE list) : unit = (
	report 62011 ["bag"];
	print_zerrlistinfo tml tyl
);
=TEX

=SML
fun €print_zerreq› (tm1 : ZTM) (tm2 : ZTM) (ty1 : EXTYPE) (ty2 : EXTYPE) : unit = (
	report 62251 [];
	report 62255 [];
	report 62033 [format_ztm tm1, format_extype ty1];
	report 62033 [format_ztm tm2, format_extype ty2]
);
=TEX

=SML
fun €print_zerrç1› (tm : ZTM) (ty : EXTYPE) : unit = (
	report 62252 [];
	report 62032 ["set"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerrç2› (tm : ZTM) (ty : EXTYPE) : unit = (
	report 62253 [];
	report 62254 [];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun €print_zerrconstrained› (tm1 : ZTM) (ty : EXTYPE) (tm2 : ZTM) : unit = (
	report 62261 [];
	report 62262 [format_ztm tm1, format_extype ty];
	report 62263 [format_ztm tm2]
);
=TEX

=SML
fun €print_ztmerror› ((term, env, details) : ZTM_INFO) = (
	report 62001 [format_ztm term];
	(case details of
	ZErrß¢ (tml, tyl) => (
		print_zerrß¢ tml tyl
	) | ZErrsetd (tml, tyl) => (
		print_zerrsetd tml tyl
	) | ZErrseta (tm, ty, ierr) => (
		print_zerrseta tm ty ierr
	) | ZErr (tm, ty) => (
		print_zerr tm ty
	) | ZErr∏ (tml, tyl) => (
		print_zerr∏ tml tyl
	) | ZErr  (tm, ty) => (
		print_zerr  tm ty
	) | ZErrsel1 (tm, id) => (
		print_zerrsel1 tm id
	) | ZErrsel2 (tm, ty) => (
		print_zerrsel2 tm ty
	) | ZErrdec (tm, ty) => (
		print_zerrdec tm ty
	) | ZErr≥ (tm, ty) => (
		print_zerr≥ tm ty
	) | ZErr˚˝ (tml, tyl) => (
		print_zerr˚˝ tml tyl
	) | ZErreq (tm1, tm2, ty1, ty2) => (
		print_zerreq tm1 tm2 ty1 ty2
	) | ZErrç1 (tm, ty) => (
		print_zerrç1 tm ty
	) | ZErrç2 (tm, ty) => (
		print_zerrç2 tm ty
	) | ZErrconstrained (tm1, ty, tm2) => (
		print_zerrconstrained tm1 ty tm2
	) | ZError => (
		error "print_ztmerror" 62999 []
	)
	) (* end case *)
);
=TEX
=SML
fun €print_scherror› ((schtext, env, tm, ty) : SCHTEXT_INFO) = (
	report 62001 [format_schtext schtext];
	report 62502 [];
	report 62254 [];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX
=SML
fun €print_decerror› ((dec, env, tm, ty) : DEC_INFO) = (
	report 62001 [format_dec dec];
	report 62501 [];
	report 62032 ["set"];
	report 62033 [format_ztm tm, format_extype ty]
);
=TEX
=SML
fun €print_zerror› ((error_info) : ERROR_INFO) : 'a  = (
	case error_info of
	ZTMErrInfo info => print_ztmerror info
	|ZSchErrInfo info => print_scherror info
	|ZDecErrInfo info => print_decerror info;
	fail "Z-Parser" 62000 []
);
=TEX
\section{SUPPORT FOR SCHEMAS}

=SML
datatype €MANIFEST_EXTYPE› =
		NotManifest
	|	BindingType of (IDENT * EXTYPE) list
	|	SchemaType of (IDENT * EXTYPE) list;
=TEX

=SML
fun €bind_extype› (itm : (IDENT * EXTYPE) list) : EXTYPE = (
let	fun aux ((name, d), ty) = (
	let	val holtype = extype_to_type zti_subs [] ty
			handle Fail msg =>
			error "bind_extype" 62998 [fn()=>
				"Type unknown is not allowed"];
	in
		(name^d, holtype)
	end);
in
	type_to_extype (mk_ZschemaT (map aux itm))
end);
=TEX

=SML
fun €unbind_extype› (ty : EXTYPE) : (IDENT * EXTYPE) list = (
let	val holtype = extype_to_type zti_subs [] ty
		handle Fail msg =>
		error "unbind_extype" 62998 [fn()=>
			"Type unknown is not allowed"];
	val itm = dest_ZschemaT holtype;
in
	map (fn (n, t) => ((unpack_IDENT n), type_to_extype t)) itm
end);
=TEX

=SML
fun €tuple_extype› (tyl : EXTYPE list) : EXTYPE = (
let	val holtypes = map (extype_to_type zti_subs []) tyl
		handle Fail msg =>
		error "tuple_extype" 62998 [fn()=>
			"Type unknown is not allowed"];
in
	type_to_extype (mk_ZtupleT (holtypes))
end);
=TEX

=SML
fun 	€manifest› (ty:EXTYPE) : MANIFEST_EXTYPE = (
	case ty of

	ExType("",[ty']) => (
	   	SchemaType (unbind_extype ty')
		handle Fail msg => NotManifest

	)|ExType(_,_) => (
		BindingType (unbind_extype ty)
		handle Fail msg => NotManifest
	)|_ => NotManifest
);
=TEX
=SML
fun €chartuple› ((decls, tm) : ZSCHTEXT) : ZTM = (
let	fun f (ZdDec(ids, tm)) = (
		map (fn id => Ztlvar(id, Nil,[])) ids
	) | f (ZdDecsexp(tm1, d)) = [Zt (tm1, d)];
in
	case decls of
	[] => error "chartuple" 62998 [fn()=>"empty declaration"]
	|[decl] => (case f decl of
			[tm] => tm
			|tms => Zttuple tms)
	|decls => Zttuple(flat (map f decls)
	)
end);
=TEX

=SML
local
fun f [] tym1 tym2 = Value []
  | f (c::cl) tym1 tym2 = (
	case f cl tym1 tym2 of 
	Nil => Nil
	|Value tym => (
		case (lassoc5 tym1 c,lassoc5 tym2 c) of
		(Nil,Value ty) => Value((c,ty)::tym)
		|(Value ty,Nil) => Value((c,ty)::tym)
		|(Value ty1,Value ty2) => (
			let	val side = unify zti_subs (ty1, ty2)
					handle Fail msg =>
					error "f" 62998 [fn()=>"unify error"];
			in
					Value((c,sub_type zti_subs ty1)::tym)
			end
			)
		|_ => Nil
		)
	)
in
=TEX
=SML
fun €compatible› ((tty1,tty2):EXTYPE * EXTYPE) : EXTYPE OPT = (
let	val idtyl1 = unbind_extype tty1;
	val idtyl2 = unbind_extype tty2;
	val cl = (list_cup o (map(map fst))) [idtyl1,idtyl2];
in
	case f cl idtyl1 idtyl2 of
	Nil => Nil
	|Value tym => (
			Value(bind_extype tym)
		)
end)
=TEX
=SML
and €includes› ((tty1,tty2):EXTYPE * EXTYPE) : EXTYPE OPT = (
let	val idtyl1 = unbind_extype tty1;
	val idtyl2 = unbind_extype tty2;
	val (cl1, tyl1) = split idtyl1;
	val (cl2, tyl2) = split idtyl2;
in
	if cl1 = (cl1 cup cl2)
	then
		case f cl1 idtyl1 idtyl2 of
		Nil => Nil
		|Value tym => (
			let	val tym' = tym drop (fn (s,_) => s mem cl2)
			in
				Value(bind_extype tym')
			end)
	else
		Nil
end);
end (* of local ... in ... *);
=TEX

\section{INFERRING TYPES IN Z DECLARATIONS}

=SML
fun €ti_zdec› (env : ZENV) (zdec as ZdDec (ids, tm): ZDEC) : ZDEC * ZENV * IDENT list = (
let	val (tm', ty') = ti_ztm env tm;
	val uty = ExVartype(Unknown (next_name()));
	val side = unify zti_subs (ty', ExType("",[uty]))
		handle Fail msg =>
		raise EDec (zdec, env, tm', ty');
	val idty = sub_type zti_subs uty;
	val env' = sub_ty env;
	fun env'' id' = (if id' mem ids then (false, idty) else env' id');
in
	(ZdDec(ids, tm'), env'', ids)
end)
=TEX
=SML
  | ti_zdec env (ZdDecsexp (tm, d)) = (
let	val (tm', ty') = ti_ztm env tm;
	val schty = sub_type zti_subs ty';
in
	case manifest schty of
	SchemaType idtyl => (
	   let	fun env' id = (
			case lassoc5 idtyl id of
			Nil => env id
			|Value x => (false,x)
		);
	   in
		(ZdDecsexp(tm', d), env', map fst idtyl)
	   end)
	|_ => error "ti_zdec" 62998 [fn()=>"ZdDecsexp (not a schema)"]
end)
=TEX
=SML
and €list_ti_zdec› env ([]:ZDEC list) : ZDEC list * ZENV * IDENT list = (
	([], env, [])
) | list_ti_zdec env (d::ds) = (
let	val (d', env', ids') = ti_zdec env d
	val (ds'', env'', ids'') = list_ti_zdec (sub_ty env') ds
in
	(d'::ds'', sub_ty env'', ids'@ids'')
end)
=TEX
\section{INFERRING TYPES IN Z SCHEMAS}

Note that if the predicate part of a schema text is
not boolean, then this constitutes a type checking error.
The caller of $ti\_zschtext$ should make this check, as
it is likely
to have more contextual information for reporting informative
error messages than $ti\_zschtext$. 

=SML
and €ti_zschtext› (env : ZENV) (schtext : ZSCHTEXT as (ds, tm)) : ZSCHTEXT * ZENV * IDENT list = (
let	val (ds', env', ids) = list_ti_zdec env ds;
	val env'' = sub_ty env';
	val (tm', ty') = ti_ztm env'' tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ESchText (schtext, env, tm', ty');
in
	((ds', tm'), env'', ids)
end)
=TEX

\section{INFERRING TYPES IN Z TERMS}

\subsection{Sequence Display}

=SML
and €ti_ztm› (env : ZENV) (term as Ztß¢ (oty, tl)) : ZTM * EXTYPE = (
let	val tmlist = list_ti_ztm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise EZTM (term, env, ZErrß¢(tl, tyl));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = ex_ (tuple_extype [ex_˙, sub_type zti_subs ty]);
	val side = case oty of
		Nil => ()
		|Value ty => (
			unify zti_subs (ty, resty)
			handle Fail msg =>
			error "ti_ztm" 62998 [fn()=>"Ztß¢ (cannot unify type constraint)"]);
in
	(Ztß¢ (Value resty, tml), resty)
end)
=TEX
\subsection{Set Display}
=SML
  | ti_ztm env(term as Ztsetd (oty, tl)) = (
let	val tmlist = list_ti_ztm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise EZTM (term, env, ZErrsetd(tl, tyl));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = ex_ (sub_type zti_subs ty);
	val side = case oty of
		Nil => ()
		|Value ty => (
			unify zti_subs (ty, resty)
			handle Fail msg =>
			error "ti_ztm" 62998 [fn()=>"Ztsetd (cannot unify type constraint)"]);
in
	(Ztsetd (Value resty, tml), resty)
end)
=TEX

\subsection{Set Abstraction}
=SML
  | ti_ztm env (term as Ztseta1 zschtext) = (
let	val ctm = chartuple zschtext;
	val (zschtext', env', _) = ti_zschtext env zschtext
		handle ESchText (_, env, tm', ty') =>
		raise EZTM (term, env, ZErrseta(tm',ty',62031));
	val (_, ty') = ti_ztm (sub_ty env') ctm;
in
	(Ztseta1 zschtext', ty')
end)
=TEX
=SML
  | ti_ztm env (term as Ztseta2 (zschtext, tm)) = (
let	val (zschtext', env', _) = ti_zschtext env zschtext
		handle ESchText (_, env, tm', ty') =>
		raise EZTM (term, env, ZErrseta(tm',ty',62034));
	val (tm', ty') = ti_ztm (sub_ty env') tm;
in
	(Ztseta2(zschtext', tm'), ty')
end)
=TEX

\subsection{Powerset}
=SML
  | ti_ztm env (term as Zt tm) = (
let	val (tm', ty') = ti_ztm env tm;
	val side = case ty' of
		ExType ("", _) => ()
		|_ => raise EZTM (term, env, ZErr (tm', ty'));
in
	(Zt tm, ex_ ty')
end)
=TEX

\subsubsection{Tuple Display}
=SML
  | ti_ztm env (Zttuple []) = error "ti_ztm" 62998
		[fn()=>"Zttuple (Zero length tuple)"]
  | ti_ztm env (Zttuple [ztm]) = error "ti_ztm" 62998
		[fn()=>"Zttuple (Unit length tuple)"]
  | ti_ztm env (Zttuple tml) = (
let	fun f [] n nl = nl
	  | f (h::t) n nl = f t (n+1) ((string_of_int n, "")::nl);
	val tmlist = list_ti_ztm env tml;
	val (tml', tyl') = split tmlist;
	val unkl = map (fn x => ExVartype (Unknown(next_name()))) tml';
	val side = map (unify zti_subs) (combine unkl tyl')
		handle Fail msg =>
		error "ti_ztm" 62998
			[fn()=>"Zttuple (Unification error)"];
	val ty = tuple_extype (map (sub_type zti_subs) unkl);
in
	(Zttuple tml', ty)
end)
=TEX
\subsubsection{Product}
=SML
  | ti_ztm env (Zt∏ []) = error "ti_ztm" 62998
		[fn()=>"Zt∏ (Zero length tuple)"]
  | ti_ztm env (Zt∏ [ztm]) = error "ti_ztm" 62998
		[fn()=>"Zt∏ (Unit length tuple)"]
  | ti_ztm env (term as Zt∏ tml) = (
let	fun f [] n nl = nl
	  | f (h::t) n nl = f t (n+1) ((string_of_int n, "")::nl);
	fun get_unify_failures ((tm, (ty1, ty2))::rest) = (
	let	val res = (unify zti_subs (ty1, ty2);true)
			handle Fail msg => false;
	in
		if res then get_unify_failures rest
		else (tm,ty2)::get_unify_failures rest
	end
	) | get_unify_failures [] = [];
	val tmlist = list_ti_ztm env tml;
	val (tml', tyl') = split tmlist;
	val unkl = map (fn x => ex_ (ExVartype
			(Unknown(next_name())))) tml';
	val typairs = combine unkl tyl';
	val side = case get_unify_failures (combine tml' typairs) of
		[] => ()
		|failures =>
		   (let	val(ftml, ftyl) = split failures;
		   in
			raise EZTM (term, env, ZErr∏ (ftml, ftyl))
		   end);
	val ty =  ex_ (tuple_extype (map (sub_type zti_subs) unkl));

in
	(Zt∏ tml', ty)
end)
=TEX
\subsubsection{Theta}
=SML
  | ti_ztm env (term as Zt  (tm, decor)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ =>
		let	val bty = (
				case ty' of
				ExType ("", [x]) => x
				|_ => error "ti_ztm" 62998 [fn()=>
					"Zt "]
			);
		in
			(Zt (tm', decor), bty)
		end
	|_ => raise EZTM (term, env, ZErr  (tm', ty'))
end)
=TEX

\subsubsection{Selection}
=SML
  | ti_ztm env (term as Ztsel (tm, id)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	BindingType idtyl => (
		case lassoc5 idtyl id of
		Nil => raise EZTM  (term, env, ZErrsel1 (tm', id))
		|Value ty'' =>
			(Ztsel(tm', id), sub_type zti_subs ty'')
		)
	|_ => raise EZTM (term, env, ZErrsel2 (tm', ty'))
end)
=TEX

\subsubsection{Application}
=SML
  | ti_ztm env (term as Ztapp (tmf,tma)) = (
let	val gen_args = ( 
		case tmf of Ztlvar(id as (s,d), _ ,_) =>(
			case get_fixity s of
			Lex.Infix ~3 => 2
			|Lex.Infix ~5 => 1
			|_ => 0)
		|_ => 0);
in
	case gen_args of 
	0 => (
		let	val (ttmf, tyf) = ti_ztm env tmf;
			val (ttma, tya) = ti_ztm (sub_ty env) tma;
			val tvn = next_name();
			val tyr = ExVartype(Unknown tvn);
			val side = unify zti_subs (tyf, ex_ (tuple_extype([tya,tyr])));
		in
			case ttmf of Ztgvar(id as (s,d), _, tml) => (
				case get_fixity s of 
				Lex.Infix ~2 => raise EZTM (term, env, ZError)
				|_ => (Ztapp(ttmf,ttma), sub_type zti_subs tyr)
			)
			|_ => (Ztapp(ttmf,ttma), sub_type zti_subs tyr)
		end
		handle EZTM _ => (
		let	val (ttmf, tyf) = ti_ztm env tmf;
			val (ttma, tya) = ti_ztm (sub_ty env) tma;
			val side = unify zti_subs (tyf, ex_ ex_bool);
		in
			(Ztapp(ttmf,ttma), ex_ ex_bool)
		end))
=TEX
=SML
	|1 => (
		let	val tmf' = (	case (tmf,tma) of (Ztlvar(s, oty, _),_) =>
						Ztlvar(s, oty, [tma])
					| _ => error "ti_ztm" 62998
						[fn()=>"ti_Ztapp (This should be impossible)"]);
			val (ttma, tya) = ti_ztm env tma;
			val (ttmf, tyf) = ti_ztm (sub_ty env) tmf';
		in
			(ttmf, tyf)
		end)
	|_ => (
		let	val tmf' = (case (tmf,tma) of
				(Ztlvar(s, oty, _), Zttuple tml) =>
					Ztlvar(s, oty, tml)
				|_ => error "ti_ztm" 62998
					[fn()=>"ti_Ztapp (This should be impossible)"]);
			val (ttma, tya) = ti_ztm env tma;
			val (ttmf, tyf) = ti_ztm (sub_ty env) tmf';
		in
			(ttmf, tyf)
		end)
end)
=TEX

\subsubsection{$\lambda$-abstraction}
=SML
 | ti_ztm env (term as ZtÃ (sch, tm)) = (
let	val ctm = chartuple sch;
	val (sch', env', _) = ti_zschtext env sch;
	val env2 = sub_ty env';
	val (tm', ty') = ti_ztm env2 tm;
	val env3 = sub_ty env2;
	val (tm2, ty2) = ti_ztm (sub_ty env3) ctm;
	val ty = ex_ (tuple_extype [ty2, ty']);
in
	(ZtÃ (sch', tm'), ty)
end)
=TEX

\subsubsection{Definite Description}
=SML
 | ti_ztm env (ZtÕ1 sch) = (
let	val ctm = chartuple sch;
	val (sch',env', _) = ti_zschtext env sch;
	val (_, ty') = ti_ztm (sub_ty env') ctm;
in
	(ZtÕ1 sch', ty')
end)
=TEX
=SML
 | ti_ztm env (ZtÕ2 (sch, tm)) = (
let	val (sch',env', _) = ti_zschtext env sch;
	val (tm', ty') = ti_ztm (sub_ty env') tm;
in
	(ZtÕ2 (sch', tm'), ty')
end)
=TEX

\subsection{Schema Text as a Term}

=SML
  | ti_ztm env (term as Ztschema sch) = (
let	val (sch', env', ids) = ti_zschtext env sch;
	val tyl = map snd (map env' ids);
	val ty = ex_ (bind_extype (combine ids tyl));
in
	(Ztschema sch', ty)
end)
=TEX

\subsubsection{Decoration}
=SML
 | ti_ztm env (term as Ztdec (tm, d)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ => (Ztdec(tm',d), ty')
	| _ => raise EZTM (term, env, ZErrdec (tm', ty'))
end)
=TEX
\subsubsection{Precondition}
=SML
  | ti_ztm env (term as Ztpre tm) = (
let	val (tm', ty') = ti_ztm env tm
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val cmap = idtyl drop (fn((n,d), ty) => (
			let	val c=hd(rev(explode d))
					handle Fail _ => "";
			in
				(c="'") orelse
				(c="!")
			end));
			val idm = map (fn((n,d),t)=> ((n,""), t)) cmap;
			val ty'' = ex_ (bind_extype idm);
		in
			(Ztpre tm', ty'')
		end)
	| _ => raise EZTM (term, env, ZErrdec (tm', ty'))
end)
=TEX
\subsubsection{Negation}
=SML
 | ti_ztm env (term as Zt≥ tm) = (
let	val (tm', ty') = ti_ztm env tm
	val side = (
		case manifest ty' of
		SchemaType _ 	=> ()
		|_ => unify  zti_subs(ty', ex_bool)
			handle Fail msg =>
			raise EZTM (term, env, ZErr≥ (tm', ty'))
		)
in
	(Zt≥ tm', ty')
end)
=TEX

\subsection{Integers}
=SML
  | ti_ztm env (Zt˙ i) = (
	(Zt˙ i, ex_˙)
)
=TEX
\subsection{Bag Display}
=SML
  | ti_ztm env (term as Zt˚˝ (oty, tl)) = (
let	val tmlist = list_ti_ztm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise EZTM (term, env, ZErr˚˝ (tl, tyl));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = ex_ (tuple_extype [sub_type zti_subs ty, ex_˙]);
	val side = case oty of
		Nil => ()
		|Value ty => (
			unify zti_subs (ty, resty)
			handle Fail msg =>
			error "ti_ztm" 62998 [fn()=>"Zt˚˝ (cannot unify type constraint)"]);
in
	(Zt˚˝ (Value resty, tml), resty)
end)
=TEX

\subsection{Predicates}
=SML
  | ti_ztm env Zttrue = (
	(Zttrue, ex_bool)
)
=TEX
=SML
  | ti_ztm env Ztfalse = (
	(Ztfalse, ex_bool)
)
=TEX
=SML
  | ti_ztm env (term as Zteq (t1, t2)) = (
let	val (tm1, ty1) = ti_ztm env t1;
	val (tm2, ty2) = ti_ztm (sub_ty env) t2;
	val ty1' = sub_type zti_subs ty1;
	val ty2' = sub_type zti_subs ty2;
	val side = unify zti_subs (ty1', ty2')
		handle Fail msg =>
		raise EZTM (term, env, ZErreq (tm1, tm2, ty1', ty2'));
in
	(Zteq(tm1, tm2), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as Ztç (t1, t2)) = (
let	val (tm1, ty1) = ti_ztm env t1;
	val (tm2, ty2) = ti_ztm (sub_ty env) t2;
	val ty1' = sub_type zti_subs ty1;
	val ty2' = sub_type zti_subs ty2;
	val unk = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ty2', ex_ unk)
		handle Fail msg =>
		raise EZTM (term, env, ZErrç1 (tm1, ty1'));
	val side = unify zti_subs (ty1', unk)
		handle Fail msg =>
		raise EZTM (term, env, ZErrç2 (tm1, ty1'));
in
	(Ztç(tm1,tm2), ex_bool)
end)
=TEX
\subsubsection{Type Constraints}
=SML
  | ti_ztm env (term as Ztconstrained (tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', ty2') of
	(SchemaType _,ExType("",[ExType("BOOL",[])])) => (
		(* This needs to be re-visited... *)
		let	val ty = ExType("BOOL",[])
		in
			(Ztconstrained(tm1',tm2'), ty)
		end)
	|_ => (
		let	val side = unify zti_subs (ex_ ty1', ty2')
			handle Fail msg =>
			raise EZTM (term, env, ZErrconstrained (tm1', ty1', tm2'));
		in
			(Ztconstrained(tm1',tm2'), sub_type  zti_subs ty1')
		end)
	end)
=TEX

\subsubsection{Local Variables}
=SML
 | ti_ztm env (term as Ztlvar (id as (n, d), _, tml)) = (
let	val (is_con, ty) = env id;
in
	if is_con andalso d <> "" andalso (case manifest ty of
				SchemaType _ => true
			|	_ => false)
	then ti_ztm env (Ztdec (Ztlvar((n, ""), Value ty, tml), d))
	else if is_con
	then  ti_ztm env (Ztgvar (id, Value ty, tml))
	else (
		case tml of	[] => (
		(Ztlvar(id, Value ty, []), ty)
		)|_ =>
			let	val ttmlist = list_ti_ztm env tml;
				val (ttml,tyl) = split ttmlist
				val argty = tuple_extype tyl;
				val tvn = next_name();
				val resty = ExVartype(Unknown tvn);
				val side = unify zti_subs (ty, ex_ (tuple_extype [argty, resty]))
					handle Fail msg =>
					error "ti_ztm" 62998 [fn ()=>
					"Ztlvar (message to be supplied later)"];
				val ty' = sub_type zti_subs ty;
			in
				(Ztlvar(id, Value ty', ttml), ty')
			end)
end
)
=TEX

\subsection{Type Inferring Lists of Z Terms}
=SML
  | ti_ztm env other = (
	error "ti_ztm" 62998 [fn()=>"Not yet implemented"]
)
and
€list_ti_ztm› (env : ZENV) (tml : ZTM list) : (ZTM * EXTYPE) list = (
	let	fun list_ti_aux env nil = nil
		  | list_ti_aux env (tm::rest) = (
		let	val (titerm as (tm, ty)) = ti_ztm env tm;
			val newenv = sub_ty env;
			val next = list_ti_aux newenv rest;
		in
			(titerm::next)
		end);
	in
		list_ti_aux env tml
	end
);
=TEX

=TEX
\section{INFERRING TYPES IN Z PARAGRAPHS}

The paragraph datatype includes a constructor for
Z terms. This is a convenient place to include Z terms,
and avoids having another data type which comprises
paragraphs or Z terms.
=SML
datatype €ZPARAGRAPH› =	AbbDef of IDENT * EXTYPE OPT * IDENT list * ZTM
|	AxDes of IDENT list * (IDENT * EXTYPE) list * ZSCHTEXT
|	FreeType of (IDENT * (IDENT * ZTM) list) list
|	GivenSet of IDENT list
|	Constraint of IDENT list * ZTM
|	Conjecture of ZTM
|	ZTerm of ZTM * EXTYPE OPT;
=TEX

=SML
datatype €ZINFERRED› =	Inferred of ZPARAGRAPH * SUBS 
		|	TypeError of ERROR_INFO;
=TEX
=SML
fun €ti_zpara› (p as AbbDef (id, Nil, formals, tm): ZPARAGRAPH) : ZINFERRED = (
let	val env = init_zenv formals;
	val (tm', ty') = ti_ztm env tm;
in
	Inferred (AbbDef (id, Value ty', formals, tm'), zti_subs)

end)
  | ti_zpara (AbbDef (_, Value _, _, _)) = error "ti_zpara" 62998
	[fn()=>"AbbDef (Unexpected type)"]
=TEX
=SML
  | ti_zpara  (AxDes (formals, [], sch)) = (
let	val env = init_zenv formals;
	val (sch', env', idl) = ti_zschtext env sch;
	val idtyl = combine idl (map snd (map env' idl));
in
	Inferred (AxDes (formals, idtyl, sch'), zti_subs)
end)
  | ti_zpara (AxDes (_, x::rest, _)) = error "ti_zpara" 62998
	[fn()=>"AxDes (Unexpected term-type list)"]
=TEX

=SML
  | ti_zpara  (p as FreeType _) = (
	Inferred (p, zti_subs)
)
=TEX

=SML
  | ti_zpara (p as GivenSet idl) = (
	Inferred (p, zti_subs)
)
=TEX
=SML
  | ti_zpara (p as Conjecture tm) = (
let	val env = init_zenv [];
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		error "ti_zpara" 62998 [fn()=>"Conjecture"];
in
	Inferred (Conjecture tm', zti_subs)
end)
=TEX
=SML
  | ti_zpara (p as Constraint (idl,tm)) = (
let	val env = init_zenv idl;
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		error "ti_zpara" 62998 [fn()=>"Constraint"];
in
	Inferred (Constraint (idl, tm'), zti_subs)
end)
=TEX
=SML
  | ti_zpara (p as ZTerm (tm, _)) = (
let	val env = init_zenv [];
	val (tm', ty') = ti_ztm env tm
in
	Inferred (ZTerm (tm', Value ty'), zti_subs)
end);
=TEX
=SML
fun €type_check_zparagraph› (p:ZPARAGRAPH) : ZINFERRED = (
let	val side = init_subs zti_subs;
	val side = (extended_z := get_flag(
		case p of
		ZTerm _ => "check_terms_with_extended_z"
		|_ => "check_paras_with_extended_z"));
in
	ti_zpara p
		handle
		EZTM info =>
			TypeError(ZTMErrInfo info)
		|ESchText info =>
			TypeError(ZSchErrInfo info)
		|EDec info =>
			TypeError(ZDecErrInfo info)
end);
=TEX
\section{EPILOGUE}
=SML
end (* of structure ZTypeInference *);
=TEX
\pagebreak
\section{BACKEND}
To be supplied.

\end{document}

----------------------------------------------------
\subsubsection{Constants}
SML
and	€ti_Ztgvar› (env:ZENV) (id:IDENT, ztml:ZTM list) : ZTM = (
	case (env id,ztml,id) of 
		((true,ExType("≠",[domty,ranty])),[],("U","")) => 
			let	val (bnam,gentyl) = (	case domty of ExType(b,l) => (b,l)
							| _ => scream "ti_Ztgvar" "Bad generic constant")
				val ztml' = map (fn x => Ztgvar(("totality",""),[])) gentyl
			in
				ti_Ztgvar env (id,ztml')
			end
	|	((true,ExType("≠",[domty,ranty])),[],_) => 
			let	val (bnam,gentyl) = (	case domty of ExType(b,l) => (b,l)
							| _ => scream "ti_Ztgvar" "Bad generic constant")
				val ztml' = map (fn x => Ztgvar(("U",""),[])) gentyl
			in
				ti_Ztgvar env (id,ztml')
			end
	|	((true,ExType("≠",[domty,ranty])),_,_) =>
			let	val ttml = list_ti_ztm env ztml
				val tyl = map ((sub_type zti_subs) o get_type) ttml
				val argty = tuple_extype tyl
				val tvn = next_name()
				val resty = ExVartype(Unknown tvn)
				val msg = [	ZUmsg ("generic constant "),
						ZUmsg (	"the previously defined type of " ^ 
							(pack_IDENT id) ^ 
							" is a mapping from"),
						ZUtyp (domty,zti_subs),
						ZUmsg ("to"),
						ZUtyp (ranty,zti_subs),
						ZUmsg ("which cannot be unified with"),
						ZUtyp (argty,zti_subs),
						ZUmsg ("to"),
						ZUtyp (resty,zti_subs)]
				val side = z_unify msg (Funt domty ranty,Funt argty resty)
			in
				Ztgvar(id,ttml)
			end
	|	((true,ty),[],_) =>
			Ztgvar(id,[])
	|	_ => raise Z_TYPE_INF [	ZUmsg ("constant" ^ (pack_IDENT id))]
)
TEX
\subsubsection{Propositional Calculus}
SML
and	€ti_Zt±› (env:ZENV) ((ztm1,ztm2):ZTM * ZTM) : ZTM = (
	let	val ttm1 = ti_ztm env ztm1
		val ttm2 = ti_ztm (sub_ty env) ztm2
		val tty1 = sub_type zti_subs (get_type ttm1)
		val tty2 = sub_type zti_subs (get_type ttm2)
	in
		case (manifest tty1,manifest tty2) of
			(SchemaType _, SchemaType _) => (
			let	val bty1 = (	case tty1 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt±" "Design error")
				val bty2 = (	case tty2 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt±" "Design error")
			in
				case compatible (bty1,bty2) of
					Nil => raise Z_TYPE_INF [	ZUmsg "±",
									ZUtrm(ttm1,zti_subs),
									ZUtrm(ttm2,zti_subs),
									ZUmsg "compatible"]
				|	Value tty => Zt±(ttm1,ttm2)
			end
			handle Z_TYPE_INF _ => (
				raise Z_TYPE_INF [	ZUmsg "±",
							ZUtrm(ttm1,zti_subs),
							ZUtrm(ttm2,zti_subs),
							ZUmsg "unify"]
			))
		|	(SchemaType _,_) => (
			let	val msg = [	ZUmsg "±",
						ZUtrm(ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt±(ttm1,ttm2)
			end)
=TEX
SML
		|	(_,SchemaType _) => (
			let	val msg = [	ZUmsg "±",
						ZUtrm(ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
			in
				Zt±(ttm1,ttm2)
			end)
		|	_ => (
			let	val msg = [	ZUmsg "±",
						ZUtrm(ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
				val msg = [	ZUmsg "±",
						ZUtrm(ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt±(ttm1,ttm2)
			end)
	end)
=TEX
SML
and	€ti_Zt≤› (env:ZENV) ((ztm1,ztm2):ZTM * ZTM) : ZTM = (
	let	val ttm1 = ti_ztm env ztm1
		val ttm2 = ti_ztm (sub_ty env) ztm2
		val tty1 = sub_type zti_subs (get_type ttm1)
		val tty2 = sub_type zti_subs (get_type ttm2)
	in
		case (manifest tty1,manifest tty2) of
			(SchemaType _, SchemaType _) => (
			let	val bty1 = (	case tty1 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt≤" "Design error")
				val bty2 = (	case tty2 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt≤" "Design error")
			in
				case compatible (bty1,bty2) of
					Nil => raise Z_TYPE_INF [	ZUmsg "≤",
									ZUtrm (ttm1,zti_subs),
									ZUtrm (ttm2,zti_subs),
									ZUmsg "compatible"]
				|	Value tty => Zt≤(ttm1,ttm2)
			end
=TEX
SML
			handle Z_TYPE_INF _ => (
				raise Z_TYPE_INF [	ZUmsg "≤",
							ZUtrm (ttm1,zti_subs),
							ZUtrm (ttm2,zti_subs),
							ZUmsg "unify"]
			))
		|	(SchemaType _,_) => (
			let	val msg = [	ZUmsg "≤",
						ZUtrm (ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt≤(ttm1,ttm2)
			end)
		|	(_,SchemaType _) => (
			let	val msg = [	ZUmsg "≤",
						ZUtrm (ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
			in
				Zt≤(ttm1,ttm2)
			end)
=TEX
SML
		|	_ => (
			let	val msg = [	ZUmsg "≤",
						ZUtrm (ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
				val msg = [	ZUmsg "≤",
						ZUtrm (ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt≤(ttm1,ttm2)
			end)
	end)
=TEX
SML
and	€ti_Zt¥› (env:ZENV) ((ztm1,ztm2):ZTM * ZTM) : ZTM = (
	let	val ttm1 = ti_ztm env ztm1
		val ttm2 = ti_ztm (sub_ty env) ztm2
		val tty1 = sub_type zti_subs (get_type ttm1)
		val tty2 = sub_type zti_subs (get_type ttm2)
	in
		case (manifest tty1,manifest tty2) of
			(SchemaType _, SchemaType _) => (
			let	val bty1 = (	case tty1 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt¥" "Design error")
				val bty2 = (	case tty2 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt¥" "Design error")
			in
				case compatible (bty1,bty2) of
					Nil => raise Z_TYPE_INF [	ZUmsg "¥",
									ZUtrm (ttm1,zti_subs),
									ZUtrm (ttm2,zti_subs),
									ZUmsg "compatible"]
				|	Value tty => Zt¥(ttm1,ttm2)
			end
=TEX
SML
			handle Z_TYPE_INF _ => (
				raise Z_TYPE_INF [	ZUmsg "¥",
							ZUtrm (ttm1,zti_subs),
							ZUtrm (ttm2,zti_subs),
							ZUmsg "unify"]
			))
		|	(SchemaType _,_) => (
			let	val msg = [	ZUmsg "¥",
						ZUtrm (ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt¥(ttm1,ttm2)
			end)
		|	(_,SchemaType _) => (
			let	val msg = [	ZUmsg "¥",
						ZUtrm (ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
			in
				Zt¥(ttm1,ttm2)
			end)
=TEX
SML
		|	_ => (
			let	val msg = [	ZUmsg "¥",
						ZUtrm (ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
				val msg = [	ZUmsg "¥",
						ZUtrm (ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt¥(ttm1,ttm2)
			end)
	end)
=TEX
SML
and	€ti_Zt§› (env:ZENV) ((ztm1,ztm2):ZTM * ZTM) : ZTM = (
	let	val ttm1 = ti_ztm env ztm1
		val ttm2 = ti_ztm (sub_ty env) ztm2
		val tty1 = sub_type zti_subs (get_type ttm1)
		val tty2 = sub_type zti_subs (get_type ttm2)
	in
		case (manifest tty1,manifest tty2) of
			(SchemaType _, SchemaType _) => (
			let	val bty1 = (	case tty1 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt§" "Design error")
				val bty2 = (	case tty2 of ExType("",[ty]) => ty
						| _ => scream "ti_Zt§" "Design error")
			in
				case compatible (bty1,bty2) of
					Nil => raise Z_TYPE_INF [	ZUmsg "§",
									ZUtrm (ttm1,zti_subs),
									ZUtrm (ttm2,zti_subs),
									ZUmsg "compatible"]
				|	Value tty => Zt§(ttm1,ttm2)
			end
=TEX
SML
			handle Z_TYPE_INF _ => (
				raise Z_TYPE_INF [	ZUmsg "§",
							ZUtrm (ttm1,zti_subs),
							ZUtrm (ttm2,zti_subs),
							ZUmsg "unify"]
			))
		|	(SchemaType _,_) => (
			let	val msg = [	ZUmsg "§",
						ZUtrm (ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt§(ttm1,ttm2)
			end)
		|	(_,SchemaType _) => (
			let	val msg = [	ZUmsg "§",
						ZUtrm (ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
			in
				Zt§(ttm1,ttm2)
			end)
=TEX
SML
		|	_ => (
			let	val msg = [	ZUmsg "§",
						ZUtrm (ttm1,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty1,ExType("bool",[]))
				val msg = [	ZUmsg "§",
						ZUtrm (ttm2,zti_subs),
						ZUmsg "bool",
						ZUmsg "unify"]
				val side = z_unify msg (tty2,ExType("bool",[]))
			in
				Zt§(ttm1,ttm2)
			end)
	end)
=TEX
\subsubsection{Projection}
SML
and	€ti_Zt˘› (env:ZENV) (ztm1:ZTM,ztm2:ZTM) : ZTM = (
	let	val ttm1 = ti_ztm env ztm1
		val ttm2 = ti_ztm (sub_ty env) ztm2
		val ty1 = sub_type zti_subs (get_type ttm1)
		val ty2 = sub_type zti_subs (get_type ttm2)
	in
	case (manifest ty1,manifest ty2) of
		(SchemaType(cl1,ttyl1),SchemaType(cl2,ttyl2)) => (
			let	val idl1 = map (fn s => (s,"")) cl1
				val idl2 = map (fn s => (s,"")) cl2
				val bty1 = bind_extype(combine idl1 ttyl1)
				val bty2 = bind_extype(combine idl2 ttyl2)
			in
				case compatible (bty1,bty2) of
					Value ty =>
						Zt˘(ttm1,ttm2)
				| _ => raise Z_TYPE_INF [	ZUmsg "˘",
								ZUtrm (ttm1,zti_subs),
								ZUtrm (ttm2,zti_subs),
								ZUmsg "compatible"]
			end
=TEX
SML
			handle Z_TYPE_INF _ => (
				raise Z_TYPE_INF [	ZUmsg "˘",
							ZUtrm (ttm1,zti_subs),
							ZUtrm (ttm2,zti_subs),
							ZUmsg "unify"]
			))
		| _ => raise Z_TYPE_INF [	ZUmsg "˘",
						ZUtrm (ttm1,zti_subs),
						ZUtrm (ttm2,zti_subs),
						ZUmsg "manifest"]
	end)
=TEX
\subsubsection{Hiding}
SML
and	€ti_Zthide› (env:ZENV) (ztm:ZTM,idl:IDENT list) : ZTM = (
	let	val ttm = ti_ztm env ztm
		val ty = sub_type zti_subs (get_type ttm)
	in
		case manifest ty of
			SchemaType(cl,ttyl) => (
			let	val cl' = map (fn s => (s,"")) cl
				val idm = (combine cl' ttyl) drop (fn(c,ty) => (c mem idl))
			in
				Zthide(ttm,idl)
			end)
		| _ => raise Z_TYPE_INF [	ZUmsg "",
						ZUtrm (ttm,zti_subs),
						ZUmsg "manifest"]
	end)
=TEX
\subsubsection{Quantification}
SML
and	€ti_Zt∂› (env:ZENV) ((zsch,ztm):ZSCHTEXT * ZTM) : ZTM = (
	let	val (tsch,env',_) = ti_zschtext env zsch
		val ttm = ti_ztm (sub_ty env') ztm
	in
		case sub_type zti_subs (get_type ttm) of
			ExType("bool",[]) => (
				Zt∂(tsch,ttm)			)
		|	_ => (
			let	val tschtm = ti_ztm (sub_ty env') (Ztschema tsch)
				val ty1 = (	case sub_type zti_subs (get_type ttm) of 
							ExType("",[ty]) => ty
						| _ => raise Z_TYPE_INF [	ZUmsg "∂",
										ZUtrm (tschtm,zti_subs),
										ZUmsg "not bool or schema"])
				val ty2 = (	case sub_type zti_subs (get_type tschtm) of 
							ExType("",[ty]) => ty
						| _ => raise Z_TYPE_INF [	ZUmsg "∂",
										ZUtrm (tschtm,zti_subs),
										ZUmsg "not schema text"])
			in
				case includes (ty1,ty2) of
					Nil => raise Z_TYPE_INF [	ZUmsg "∂",
									ZUtrm (tschtm,zti_subs),
									ZUtrm (ttm,zti_subs),
									ZUmsg "bound variable not in schema"]
				|	Value tty => 
						Zt∂(tsch,ttm)
			end)
	end)
=TEX
SML
and	€ti_Zt∂â1› (env:ZENV) ((zsch,ztm):ZSCHTEXT * ZTM) : ZTM = (
	let	val (tsch,env',_) = ti_zschtext env zsch
		val ttm = ti_ztm (sub_ty env') ztm
	in
		case sub_type zti_subs (get_type ttm) of
			ExType("bool",[]) => (
				Zt∂â1(tsch,ttm)			)
		|	_ => (
			let	val tschtm = ti_ztm (sub_ty env') (Ztschema tsch)
				val ty1 = (	case sub_type zti_subs (get_type ttm) of 
							ExType("",[ty]) => ty
						| _ => raise Z_TYPE_INF [	ZUmsg "∂â1",
										ZUtrm (tschtm,zti_subs),
										ZUmsg "not bool or schema"])
				val ty2 = (	case sub_type zti_subs (get_type tschtm) of 
							ExType("",[ty]) => ty
						| _ => raise Z_TYPE_INF [	ZUmsg "∂â1",
										ZUtrm (tschtm,zti_subs),
										ZUmsg "not schema text"])
			in
				case includes (ty1,ty2) of
					Nil => raise Z_TYPE_INF [	ZUmsg "∂â1",
									ZUtrm (tschtm,zti_subs),
									ZUtrm (ttm,zti_subs),
									ZUmsg "bound variable not in schema"]
				|	Value tty => 
						Zt∂â1(tsch,ttm)
			end)
	end)
=TEX
SML
and	€ti_Ztµ› (env:ZENV) ((zsch,ztm):ZSCHTEXT * ZTM) : ZTM = (
	let	val (tsch,env',_) = ti_zschtext env zsch
		val ttm = ti_ztm (sub_ty env') ztm
	in
		case sub_type zti_subs (get_type ttm) of
			ExType("bool",[]) => (
				Ztµ(tsch,ttm)			)
		|	_ => (
			let	val tschtm = ti_ztm (sub_ty env') (Ztschema tsch)
				val ty1 = (	case sub_type zti_subs (get_type ttm) of 
							ExType("",[ty]) => ty
						| _ => raise Z_TYPE_INF [	ZUmsg "µ",
										ZUtrm (tschtm,zti_subs),
										ZUmsg "not bool or schema"])
				val ty2 = (	case sub_type zti_subs (get_type tschtm) of 
							ExType("",[ty]) => ty
						| _ => raise Z_TYPE_INF [	ZUmsg "µ",
										ZUtrm (tschtm,zti_subs),
										ZUmsg "not schema text"])
			in
				case includes  (ty1,ty2) of
					Nil => raise Z_TYPE_INF [	ZUmsg "µ",
									ZUtrm (tschtm,zti_subs),
									ZUtrm (ttm,zti_subs),
									ZUmsg "bound variable not in schema"]
				|	Value tty => 
						Ztµ(tsch,ttm)
			end)
	end)
=TEX
\subsubsection{Ñ and ò}
SML
and	€ti_ZtÑ› (env:ZENV) (ztm:ZTM) : ZTM =
	let	val ttm = ti_ztm env ztm
		val tty = sub_type zti_subs (get_type ttm)
	in
		case manifest tty of
			SchemaType(compl,tyl) => ZtÑ ttm
		|	_ => raise Z_TYPE_INF [	ZUmsg "Ñ", ZUtrm (ttm,zti_subs), ZUmsg "manifest"]
	end
=TEX
SML
and	€ti_Ztò› (env:ZENV) (ztm:ZTM) : ZTM =
	let	val ttm = ti_ztm env ztm
		val tty = sub_type zti_subs (get_type ttm)
	in
		case manifest tty of
			SchemaType(compl,tyl) => Ztò ttm
		|	_ => raise Z_TYPE_INF [	ZUmsg "ò", ZUtrm (ttm,zti_subs), ZUmsg "manifest"]
	end
=TEX
\subsubsection{Schema Composition}
SML
and	€ti_Ztª› (env:ZENV) (ztm1:ZTM,ztm2:ZTM) : ZTM = (
	let	fun	f msg [] [] _ = []
		|	f msg [] (h::t) tym1 = (
				case h of ((s,""),ty2) => (
					case lassoc5 tym1 (s,"'") of
						Value ty1 => (
						let	val dl = f msg [] t tym1
							val side = z_unify msg (ty1,ty2)
						in
							dl
						end)
					|	Nil => raise Z_TYPE_INF msg)
				| _ => f msg [] t tym1)
		|	f msg (h::t) tym2 tym1 = (
				case h of ((s,"'"),ty1) => (
					case lassoc5 tym2 (s,"") of
						Value ty2 => (
						let	val dl = f msg t tym2 tym1
							val side = z_unify msg (ty1,ty2)
						in
							(s,"")::dl
						end)
					|	Nil => raise Z_TYPE_INF msg)
				| _ => f msg t tym2 tym1)
		val ttm1 = ti_ztm env ztm1
		val ttm2 = ti_ztm (sub_ty env) ztm2
		val tty1 = sub_type zti_subs (get_type ttm1)
		val tty2 = sub_type zti_subs (get_type ttm2)
=TEX
SML
	in
		case (manifest tty1,manifest tty2) of
			(SchemaType(cl1,tyl1),SchemaType(cl2,tyl2)) => (
			let	val idl1 = map unpack_IDENT cl1
				val idl2 = map unpack_IDENT cl2
				val idtym1 = combine idl1 tyl1
				val idtym2 = combine idl2 tyl2
				val msg = [	ZUmsg "ª",
						ZUtrm (ttm1,zti_subs), ZUtrm (ttm2,zti_subs),
						ZUmsg "compatible"]
				val dropl = f msg idtym1 idtym2 idtym1
				val idtym1' = idtym1 drop (fn ((s,d),ty) => (d = "'") andalso (s,"") mem dropl)
				val idtym2' = idtym2 drop (fn ((s,d),ty) => (d = "") andalso (s,"") mem dropl)
				val idtym = idtym1' cup idtym2'
			in
				Ztª(ttm1,ttm2)
			end)
		| _ => raise Z_TYPE_INF [	ZUmsg "ª",
						ZUtrm (ttm1,zti_subs), ZUtrm (ttm2,zti_subs),
						ZUmsg "manifest"]
	end)
=TEX
=IGN
open ZTypeInference;



exception OOPS;

fun d tm = (
	case type_check_zparagraph (ZTerm (tm, Nil)) of
		Inferred (ZTerm (tm',Value ty'), subs) => (tm', ty', subs)
		|TypeError info => print_zerror info
		|_ => raise OOPS);



val set_1 = Ztsetd (Nil, [Zttrue, Ztfalse]);
val set_2 = Ztsetd (Nil, [Zt˙ 0,Zt˙ 1,Zt˙ 2,Zt˙ 3]);

val decl_1 = [ZdDec ([("a","")], set_1)];
val decl_2 = [ZdDec ([("x",""),("y",""),("z","")], set_2)];
val decl_3 = [ZdDec ([("w",""),("x","?"),("y","'"),("z","!")], set_2)];
val decl_4 = decl_1@decl_2;

val decl_1f = [ZdDec ([("a","")],Zttrue)];

val schtext_1 = (decl_1, Zttrue);
val schtext_2 = (decl_2, Zteq (Ztlvar (("a",""),Nil,[]),Zt˙ 0));
val schtext_3 = (decl_3, Zttrue);

val schtext_1f = (decl_1f, Zttrue);
val schtext_2f = (decl_1, Zt˙ 0);


val c1_1 = Ztß¢ (Nil, [Zt˙ 3]);
val c1_2 = Ztß¢ (Nil, [Zttrue, Ztfalse]);

val c2_1 = Ztsetd (Nil, [Zt˙ 3]);
val c2_2 = Ztsetd (Nil, []);
val c2_1f = Ztsetd (Nil, [Zt˙ 3,Zttrue]);

val c3_1 = Ztseta1 (decl_1, Zttrue);

val c3_1f = Ztseta1 (decl_2, set_1);
val c3_2f = Ztseta1 (decl_1f,Zttrue);
val c3_1error = Ztseta1 ([ZdDec ([],c2_1)],Zttrue);

val c4_1 = Zt (c2_1);

val c4_1f = Zt (Zt˙ 1);

val c5_1 = Zttuple [c1_1, c1_2, Zttrue];

val c6_1 = Zt∏ [c1_1, c1_2, c2_1];

val c6_1f = Zt∏ [c1_1, c1_2, Zt˙ 0];
val c6_2f = Zt∏ [Zt˙ 0,c1_1, Zt˙ 2, c1_2, Zttrue];

val c7_1 = Zt  (Ztschema schtext_2, "'");
val c7_1f = Zt  (Zt˙ 1, "");

val c8_1 = Ztsel (Zt  ((Ztschema schtext_2),""), ("x",""));

val c8_1f = Ztsel (Zt  ((Ztschema schtext_2),""), ("A",""));
val c8_2f = Ztsel (Ztschema schtext_2, ("Y",""));

val c10_1 = ZtÃ (schtext_2, Zttrue);

val c10_1f = ZtÃ (schtext_1, Zteq (Ztlvar(("a",""),Nil,[]), Zt˙ 0));

val c11a_1 = ZtÕ1 schtext_2;
val c11b_1 = ZtÕ2 (schtext_2, Zt˙ 0);

val c11b_1f = ZtÕ2 (schtext_1, Zteq (Ztlvar(("a",""),Nil,[]), Zt˙ 0));
;

val c12_1 = Ztschema ([ZdDec ([("Q","")],Zt (Zt˙ 0))],Zttrue);
val c12_2 = Ztschema ([ZdDec ([("Q","")],Zt (Zt˙ 0))],
		Zteq (Zt˙ 0, Ztlvar (("Q",""), Nil, [])));
val c12_3 = Ztschema ([ZdDec ([("Q","")],Zt (Zttrue))],Zttrue);

val c12_1f = Ztschema ([ZdDec ([("Q","")],Zttrue)],Zttrue);
val c12_2f = Ztschema ([ZdDec ([("Q","")],Zt (Zt˙ 0))],
		Zteq (Zttrue, Ztlvar (("Q",""), Nil, [])));

val c13_1 = Ztdec (Ztschema ([ZdDec ([("Y","")],Zt (Zt˙ 0))],Zttrue), "'");
val c13_1f = Ztdec(Zt˙ 1, "");

val c14_1 = Ztpre (Ztschema schtext_2);
val c14_2 = Ztpre (Ztschema schtext_3);

val c15_1 = Zt≥ (c12_1);
val c15_1f = Zt≥ (Zt˙ 0);

val c24_1 = Zt˚˝ (Nil, [Zt˙ 3]);
val c24_2 = Zt˚˝ (Nil, [Zttrue, Ztfalse]);
val c24_1f = Zt˚˝ (Nil, [Zt˙ 3, Zttrue]);

val c25a_1 = Ztç (Zttrue, Zt Ztfalse);
val c25b_1 = Zteq (Zttrue, Ztfalse);

val c25a_1f = Ztç (Zttrue, Zt˙ 3);
val c25a_2f = Ztç (Zttrue, Ztsetd (Nil, [Zt˙ 3]));
val c25a_3f = Ztç ((Ztschema ([ZdDec ([("X","")],
		Zt (Zt˙ 0))],Zttrue)),Zttrue);
val c25b_1f = Zteq (Zttrue, Zt˙ 3);
val c25b_2f = Zteq (Zt˙ 3, Zt (Zt˙ 3));

val c26_1 = Ztconstrained (Zt˙ 0, Zt (Zt˙ 0));
val c26_2 = Ztconstrained (Zttrue, Zt (Zttrue));

val c26_1f = Ztconstrained (Zt˙ 0, Zttrue);

val c27_1 = Ztlvar (("X",""),Nil, [Ztsetd (Nil,[Zt˙ 3])]); (* wrong *)
val c27_2 = Ztlvar (("A",""),Nil, []);


val Inferred (tm,subs) = type_check_zparagraph
	(AxDes ([("FRED","")],[],
		([ZdDec ([("X",""),("Y","")]
			,Zt (Zttrue))],Zttrue)));

val Inferred (tm,subs) = type_check_zparagraph 
	(Constraint (Zteq (Ztlvar (("X",""),Nil,[]), Zt˙ 0)));


val Inferred (tm,subs) = type_check_zparagraph (AbbDef (("FRED",""),Nil, [],
	Ztschema(([ZdDec ([("X'","")],Zt (Zt˙ 0))],Zttrue))
));


val Inferred (tm,subs) = type_check_zparagraph
	(AbbDef (("JOE",""),Nil,[],
		Zttrue));

let val TypeError info = it in print_zerror info end;
∞
