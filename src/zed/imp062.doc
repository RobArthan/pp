=TEX
% TQtemplatetex
\documentstyle[hol1,11pt,TQ]{article}
\makeindex
% The following macro is used to insert temporary notes
% in the document.
\def\TempNote#1{{\tiny#1}}
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Type Inferrer}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP062}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}                    %% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{Z, HOL}
\TPPauthor{D.J.~King&WIN01}
%\TPPauthors{R.D.~Arthan&WIN01\\D.J.~King&WIN01\\G.T.~Scullard&MAN05}
\TPPauthorisation{R.D.~Arthan & FMU Manager}
\TPPabstract{A type inference mechanism for Z}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	  R.D.~Arthan \\ R.B.~Jones \\ G.T. Scullard
}}
 
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List} \tableofcontents
\subsection{Document Cross References}\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}
\item[\SCCSversion (3 March 1992)] Initial version.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
\subsubsection{Interface}
\subsubsection{Algorithms}
\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
\section{PREAMBLE}
SML
structure ÛZTypeInferenceÝ : ZTypeInference = struct
=TEX
SML
	open Unification ZLex;
	open icl'ZTypesAndTerms;

=TEX

\section{MISCELLANEOUS STUBS}
=SML
fun Ûget_template_infoÝ tmp = Nil;
=TEX

@Z
rel _  _ , _ = _
°


\subsection{Flags and Switches}
=SML
val Ûzti_standard_zÝ = ref true;

=TEX
=SML
val Ûzarray_sizeÝ = 100;
val Ûzti_subsÝ = new_subs zarray_size;
=TEX

\section{CONVERTING STRINGS TO IDENTIFIERS ETC.}

=SMLLITERAL
val stubell = "è";
val stubus = "›";
=TEX

=SML
fun Ûstub_to_stringÝ (st : STUB) : string = (
	case st of
	StubEll => stubell
	|StubUS => stubus
);
=TEX
=SML
fun Ûcore_to_stringÝ (core as (id, opt) : CORE) : string = (
let	fun do_stid (st, id) = (stub_to_string st)^id;
in
	case opt of
	Nil => id
	|Value (stidl, stid) => id^
		(format_list do_stid stidl "") ^(do_stid stid)
end);

=TEX
=SML
fun Ûident_to_stringÝ ((tmpl, d) : IDENT) : string = (
	(case tmpl of
	TmplNon core => core_to_string core
	|TmplIn (stub1, core, stub2) =>
		(stub_to_string stub1)^(core_to_string core)
			^(stub_to_string stub2)
	|TmplPre (core, stub) =>
		(core_to_string core)^(stub_to_string stub)
	|TmplPost (stub, core) =>
		(stub_to_string stub)^(core_to_string core)
	)^d
);
=TEX
=SML
datatype ÛSTUB_OR_IDÝ = ÛStubÝ of STUB | ÛIdÝ of ID | ÛNothingÝ;

fun Ûget_idfragÝ ((s::rest) : string list) (acc : string) :
			 (string list * STUB_OR_ID) = (
	if (s mem [stubell, stubus]) then
		if acc = "" then (s::rest, Nothing)
		else (s::rest, Id acc)
	else get_idfrag rest (acc^s)
) | get_idfrag [] acc = 
	if acc = "" then ([], Nothing)
	else ([], Id acc);

fun Ûget_stubÝ ((s::rest) : string list) : (string list * STUB_OR_ID) = (
	if s = stubell then (rest, Stub StubEll)
	else if s = stubus then (rest, Stub StubUS)
	else ([], Nothing)
) | get_stub [] = ([], Nothing);

=TEX
=SML
fun Ûstring_to_identÝ (s : string) : IDENT = (
let	fun strip_decor (d::rest) decors = (
		if (d mem ["?", "!", "'"])
		then	strip_decor rest (d::decors)
		else	(d::rest, decors)
	)
	  | strip_decor [] decors = ([], decors);
	val (xrs, d) = strip_decor ((rev o explode) s) [];
	val xs = rev xrs;
	fun get_all xs acc = (
		case get_stub xs of
		(_, Nothing) => (
			case get_idfrag xs "" of 
			(_, Nothing) => acc
			|(res', tok') => get_all res' (tok'::acc)
			)
		|(res, tok) => (
			case get_idfrag res "" of 
			(_, Nothing) => get_all res (tok::acc)
			|(res', tok') => get_all res' (tok'::tok::acc)
			)
	);

	fun get_stid ((Stub stub)::(Id id)::rest) = (
		Value (stub,id),rest
	) | get_stid xs = (Nil, xs);

	fun get_stids xs acc = (
	let	val (ostid, rest) = get_stid xs;
	in
		case ostid of
		Nil => (acc, rest)
		|Value stid => get_stids rest (acc@[stid])
	end);
=TEX
=SML
	fun make_core (Id id::rest) = (
	let	val (stids, rest') = get_stids rest [];
	in
		case stids of
		[] => (Value (id, Nil), rest)
		|[stid] => (Value (id, Value ([], stid)), rest')
		|_ => (	let	val rstids = rev stids;
			in
				case rstids of
				[] => error "string_to_ident" 62998 [fn()=>"impossible"]
				|last::rest => (Value (id, Value (rev rest, last)),rest')
			end)
	end
	) | make_core rest = (Nil, rest);

	fun make_stub ((Stub stub)::rest) = (
		(Value stub, rest)
	) | make_stub rest = (Nil, rest);

	val toks = rev (get_all xs []);
in
	((case make_core toks of
	(Nil, _) => (
		case make_stub toks of
		(Nil, _) => fail "string_to_ident" 62950 []
		|(Value stub, rest) => (
			case make_core rest of
			(Nil, _) => fail "string_to_ident" 62951 []
			|(Value core, rest) => (
				case make_stub rest of
				(Nil, []) => TmplPost (stub, core)
				|(Value stub', []) => TmplIn (stub, core, stub')
				|_ => fail "string_to_ident" 62952 []
				)
			)
		)
	|(Value core, rest) => (
		case make_stub rest of
		(Nil, []) => TmplNon core
		|(Value stub, []) => TmplPre (core, stub)
		|_ => fail "string_to_ident" 62952 []
		)
	), implode d)
end);

=TEX


\section{FORMATTING Z SCHEMA TEXT AND TERMS}

=SML
fun Ûformat_identÝ ((tmp, d) : IDENT) : string = (
	(format_template tmp)^d
);
=TEX
=SML
fun Ûformat_ident_listÝ idl = (
	case idl of
	[] => ""
	|_ => " ["^(format_list format_ident idl ", ")^"] "
);
=TEX
=SML
fun Ûformat_extypeÝ (ExVartype ty : EXTYPE) : string = (
	case ty of
	Known name => "'"^name
	|Unknown tvn => "'"^(string_of_int tvn)
) | format_extype (ExType ("ð", [ExType ("¸", [ty1, ty2])])) = (
	(format_extype ty1)^"ª"^(format_extype ty2)
) | format_extype (ExType ("ð", [tyl])) = (
	"ð("^(format_extype tyl)^")"
) | format_extype (ExType ("¸", tyl)) = (
	let	fun aux (ty1::ty2::rest) = (
		(format_extype ty1)^"¸"^(format_extype ty2)
		^(aux rest)
		) | aux [ty] = format_extype ty
		  | aux [] = "";
	in
		aux tyl
	end
) | format_extype (ExType (name, tyl)) = (
	let	fun brkt (s : string) : string = (
		if size s = 0
		then s
		else "(" ^ s ^ ")");
	in
		brkt (format_list format_extype tyl ", ")^name
	end
);
=TEX
=SML
fun Ûformat_otyÝ oty = (
	case oty of
	Nil => ""
	|Value ty => " : "^(format_extype ty)
);
=TEX
=SML
fun Ûformat_zdecÝ (dec : Z_DEC) = (
	case dec of
		ZDec (idl, tm) => (format_list format_ident idl ", ")^" : "^(format_ztm tm)
	|	ZSchemaDec tm => format_ztm tm
)
=TEX
=SML
and Ûformat_zdec_listÝ (decl : Z_DEC list) = (
	case decl of
	[] => ""
	|_ => format_list format_zdec decl "; "
)
=TEX
=SML
and Ûformat_zschtextÝ (sch as (dl, Value tm) : Z_SCH_TEXT) = (
	(format_list format_zdec dl "; ")^" | "^(format_ztm tm)
) | format_zschtext (sch as (dl, Nil)) = (
	format_list format_zdec dl "; "
)
=TEX
=SML
and Ûformat_eqdefÝ (eqdef as (id, tm)) = (format_ident id)^" ¦ "^(format_ztm tm)
=TEX
=SML
and Ûformat_ztmÝ (tm : Z_TM) : string = (
	case tm of
		ZTm§¢ (_, tml) => "§"^(format_list format_ztm tml ",")^"¢"
	|	ZTmSetd (_, tml) => "{"^(format_list format_ztm tml ",")^"}"
	|	ZTmSeta1 sch => "{"^(format_zschtext sch)^"}"
	|	ZTmSeta2 (sch,tm) => "{"^(format_zschtext sch)^"·"^(format_ztm tm)^"}"
	|	ZTmð tm => "ð "^(format_ztm tm)
	|	ZTmTuple tml => "("^(format_list format_ztm tml ", ")^")"
	|	ZTm¸ tml => (format_list format_ztm tml " ¸ ")
	|	ZTmÊ (tm, d) => "Ê "^(format_ztm tm)^d
	|	ZTmSel‰T (tm, i) => (format_ztm tm)^"."^(string_of_int i)
	|	ZTmSel‰B (tm, id) => (format_ztm tm)^"."^(format_ident id)
	|	ZTmApp (tm1, tm2) => (format_ztm tm1)^" "^(format_ztm tm2)
	|	ZTmFancyApp ((n, d), ZTmTuple tml) => (
			format_fancy_fix format_ztm n d tml)
	|	ZTmFancyApp ((n, d), tm) => (format_ident (n,d))^" "^(format_ztm tm)
	|	ZTmÌ (sch, tm) => "Ì "^(format_zschtext sch)^"· "^(format_ztm tm)
	|	ZTmÍ1 sch => "Í "^(format_zschtext sch)
	|	ZTmÍ2 (sch, tm) => "Í "^(format_zschtext sch)^"· "^(format_ztm tm)
	|	ZTmTruth true => "true"
	|	ZTmTruth false => "false"
	|	ZTmLogInOp‰F (inop, tm1, tm2) => (format_ztm tm1)^(
			case inop of
			ZLogInOp± => " ± "
			|ZLogInOp² => " ² "
			|ZLogInOp´ => " ´ "
			|ZLogInOp¤ => " ¤ "
			|ZLogInOpSemi => ";"
			)^(format_ztm tm2)
	|	ZTmQuant‰F (q, sch, tm) => (
			case q of
			ZQuantµ => "µ"	|ZQuant¶ => "¶"	|ZQuant¶‰1 => "¶‰1"
			)^(format_zschtext sch)^" · "^(format_ztm tm)
	|	ZTm³‰F tm => "³ "^(format_ztm tm)
	|	ZTmSchemaPred tm => format_ztm tm
	|	ZTmHorizSchema sch => "["^(format_zschtext sch)^"]"
	|	ZTmDecor (tm, d) => (format_ztm tm)^d
	|	ZTmPre tm => "pre "^(format_ztm tm)
	|	ZTm³‰S tm => "³ "^(format_ztm tm)
=TEX
=SML
	|	ZTmLogInOp‰S (inop, tm1, tm2) => (format_ztm tm1)^(
			case inop of
			ZLogInOp± => " ± "
			|ZLogInOp² => " ² "
			|ZLogInOp´ => " ´ "
			|ZLogInOp¤ => " ¤ "
			|ZLogInOpSemi => "; "
			)^(format_ztm tm2)
	|	ZTmù (tm1, tm2) => (format_ztm tm1)^" ù "^(format_ztm tm2)
	|	ZTmHide (tm, idl) => (format_ztm tm)^"\\ ("^
			(format_list format_ident idl ", ")^")"
	|	ZTmQuant‰S (q, sch, tm) => (
			case q of
			ZQuantµ => "µ "	|ZQuant¶ => "¶ "	|ZQuant¶‰1 => "¶‰1 "
			)^(format_zschtext sch)^" · "^(format_ztm tm)

	|	ZTm„ tm => "„ "^(format_ztm tm)
	|	ZTm˜ tm => "˜ "^(format_ztm tm)
	|	ZTmEq (tm1, tm2) => (format_ztm tm1)^" = "^(format_ztm tm2)
	|	ZTm (tm1, tm2) => (format_ztm tm1)^"  "^(format_ztm tm2)
	|	ZTm» (tm1, tm2) => (format_ztm tm1)^" » "^(format_ztm tm2)
	|	ZTmPipe (tm1, tm2) => (format_ztm tm1)^" >> "^(format_ztm tm2)
	|	ZTmú n => string_of_int n
	|	ZTmString s => "\""^s^"\""
	|	ZTmConstrained (tm1, tm2) => (format_ztm tm1)^" º "^(format_ztm tm2)
	|	ZTmLVar (id, tml) => (format_ident id)^(
			case tml of
			[] => ""
			|_ => "["^(format_list format_ztm tml ",")^"]"
			)
	|	ZTmGVar (id, tml) => (format_ident id)^(
			case tml of
			[] => ""
			|_ => "["^(format_list format_ztm tml ",")^"]"
			)
=TEX
=SML
	|	ZTmLet (eqdefl, tm) => "let "^(format_list format_eqdef eqdefl ", ")^"· "
							^(format_ztm tm)
	|	ZTmRename (tm, ididl) => (format_ztm tm)^(
			case ididl of
			[] => ""
			|_ => " ["^(format_list (fn (id1, id2) => (format_ident id1)^"/"^
				(format_ident id2)) ididl ", ")^"]"
			)
	|	ZTmBracketed tm => "("^(format_ztm tm)^")"
	|	ZTmQuotation holterm => (string_of_term holterm)
);
=TEX

=SML
fun Ûformat_zparafreetypeÝ (id : IDENT, idotml : (IDENT * Z_TM OPT) list) : string = (
let	fun aux (id, otm) =
		(format_ident id)^(
			case otm of
			Nil => ""
			|Value tm => " "^(format_ztm tm));
in
	(format_ident id)^" ::= "^(format_list aux idotml " | ")
end);
=TEX
=SML
fun Ûformat_zparaÝ (p : Z_PARA) : string = (
=SMLLITERAL
	case p of
	ZParaAbbDef (id, idl, tm, oty) =>
		(format_ident id)^(format_ident_list idl)
			^" ¦ "^(format_ztm tm)^(format_oty oty)
	|ZParaSchBox (id, idl, sch as (decl, otm), oty) =>
		"ÿ"^(format_ident id)^(format_ident_list idl)^"ü"^
		(format_zdec_list decl)^(
			case otm of
			Nil => "ˆ"
			|Value tm => "÷"^(format_ztm tm)^"ˆ"
		)
	|ZParaAxDes (idl, sch as (decl, otm), _) =>
		"@ZAX"^(format_ident_list idl)^
		(format_zdec_list decl)^(
			case otm of
			Nil => "°"
			|Value tm => "÷"^(format_ztm tm)^"°"
		)
	|ZParaFreeType ftl => (format_list format_zparafreetype ftl " & ")
	|ZParaGivenSet (idl, oidltm) =>
		(format_ident_list idl)^(
			case oidltm of
			Nil => ""
			|Value (idl', tm) => (format_ident_list idl')^" & "^(format_ztm tm)
		)
	|ZParaConstraint (idl, tm) =>
		(format_ident_list idl)^(format_ztm tm)
	|ZParaConjecture (oid, idl, tm) =>
		(case oid of
		Nil => ""
		|Value id => (format_ident id)^" "
		)^(format_ident_list idl)^" ?ô "^(format_ztm tm)
	|ZParaTerm (idl, tm, oty) =>
		"ñ"^(format_ident_list idl)^(format_ztm tm)^(format_oty oty)^"®"
	|ZParaFixity fix => (
		case fix of
		(ZClFun i, tmpl) => "fun "^(string_of_int i)^" "^
			(format_list format_template tmpl ", ")
		|(ZClRel, tmpl) => "rel "^(format_list format_template tmpl ", ")
		|(ZClGen i, tmpl) => "gen "^(string_of_int i)^" "^
			(format_list format_template tmpl ", ")
		)
);
=TEX
\section{SUPPORTING FUNCTIONS}


\subsection{Auxiliary Functions}
=SML
fun Ûex_ðÝ t = ExType ("ð", [t]);
val Ûex_úÝ = ExType ("ú", []);
val Ûex_stringÝ = ExType ("LIST", [ExType ("CHAR",[])]);
fun Ûex_ªÝ (f, a) = ExType ("ª", [f, a]);
val Ûex_boolÝ = ExType ("BOOL", []);
=TEX


\section{ERROR HANDLING AND REPORTING}

=SML
datatype Z_VAR_TYPE =
		GlobalVar of EXTYPE
	|	BoundVar of EXTYPE
	|	FreeVar of EXTYPE OPT;
=TEX

=SML
type ÛZ_ENVÝ = IDENT -> Z_VAR_TYPE;
=TEX

=SML
datatype ÛZ_DETAILSÝ	=
		Failed§¢ of Z_TM list * EXTYPE list
	|	FailedSetd of Z_TM list * EXTYPE list
	|	FailedSeta of Z_TM * EXTYPE * int
	|	Failedð of Z_TM * EXTYPE
	|	Failed¸ of Z_TM list * EXTYPE list
	|	FailedÊ of Z_TM * EXTYPE
	|	FailedSel‰T1 of int * int
	|	FailedSel‰T2 of Z_TM * EXTYPE
	|	FailedSel‰B1 of Z_TM * IDENT
	|	FailedSel‰B2 of Z_TM * EXTYPE
	|	FailedApp of Z_TM * Z_TM * EXTYPE * EXTYPE
	|	FailedFancyApp of IDENT * Z_TM * EXTYPE * EXTYPE
	|	Failed³‰F of Z_TM * EXTYPE
	|	FailedLogInOp‰F of Z_LOG_IN_OP * Z_TM * EXTYPE
	|	FailedQuant‰F of Z_QUANT * Z_TM * EXTYPE
	|	FailedDecor of Z_TM * EXTYPE
	|	FailedPre of Z_TM * EXTYPE
	|	Failed³‰S of Z_TM * EXTYPE
	|	FailedLogInOp‰S1 of Z_LOG_IN_OP * Z_TM * Z_TM * (IDENT * EXTYPE) list
			* (IDENT * EXTYPE) list
	|	FailedLogInOp‰S2 of Z_LOG_IN_OP * Z_TM * EXTYPE
	|	Failedù1 of Z_TM * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	Failedù2 of Z_TM * EXTYPE
	|	FailedHide of Z_TM * EXTYPE
	|	FailedQuant‰S1 of Z_QUANT * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	FailedQuant‰S2 of Z_QUANT * Z_TM * EXTYPE
	|	FailedQuant‰S3 of Z_QUANT * Z_TM * IDENT list
	|	Failed„ of Z_TM * EXTYPE
	|	Failed˜ of Z_TM * EXTYPE
	|	FailedEq of Z_TM * Z_TM * EXTYPE * EXTYPE
	|	Failed1 of Z_TM * EXTYPE
	|	Failed2 of Z_TM * EXTYPE
	|	Failed»1 of Z_TM * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	Failed»2 of Z_TM * EXTYPE
	|	FailedPipe1 of Z_TM * Z_TM * (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	FailedPipe2 of Z_TM * EXTYPE
	|	FailedConstrained of Z_TM * EXTYPE * Z_TM
	|	FailedRename1 of Z_TM * EXTYPE
	|	FailedRename2 of IDENT list
	|	FailedRename3 of IDENT list
	|	FailedFreeVar of IDENT;

=TEX
=SML
datatype ÛZ_PARA_DETAILSÝ =
		FailedZPGiven
	|	FailedZPConstraint
	|	FailedZPConjecture;
=TEX
The following type definition is visible via the signature
$ZTypeInference$.
=SML
datatype ÛLOCAL_ERROR_INFOÝ =
		FailedZTm of Z_TM * Z_ENV * Z_DETAILS
	|	FailedZSchText of Z_SCH_TEXT * Z_ENV * Z_TM * EXTYPE
	|	FailedZDec1 of Z_DEC * Z_ENV * Z_TM * EXTYPE
	|	FailedZDec2 of Z_DEC * Z_ENV * Z_TM * EXTYPE
	|	FailedZCompat of (IDENT * EXTYPE) list * (IDENT * EXTYPE) list
	|	FailedZIncludes of IDENT list
	|	FailedZPara of Z_TM * EXTYPE * Z_PARA_DETAILS
	|	FailedZFreeVar of IDENT;

type ÛERROR_INFOÝ	=	LOCAL_ERROR_INFO;
=TEX
=SML
exception ÛZExnÝ of LOCAL_ERROR_INFO;
=TEX

=SML
fun ÛreportÝ (msg : int) (inserts : string list) : unit = (
	diag_string (get_error_message msg inserts)
);
=TEX

=SML
fun Ûnot_a_setÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62910 [];
	report 62900 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun Ûnot_a_sequenceÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62911 [];
	report 62900 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun Ûnot_a_predicateÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62912 [];
	report 62900 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun Ûnot_a_schemaÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62913 [];
	report 62900 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun Ûnot_a_bindingÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62914 [];
	report 62900 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun Ûnot_a_tupleÝ (tm : Z_TM) (ty : EXTYPE) = (
	report 62915 [];
	report 62900 [format_ztm tm, format_extype ty]
);
=TEX

=SML
fun Ûprint_zerrlistinfoÝ (tml : Z_TM list) (tyl : EXTYPE list) : unit = (
let	
	fun plu (x1::x2::rest) = "s"
	  | plu [x1] = ""
	  | plu nil = error "print_zerrlistinfo" 62998 [
		fn()=>"plu"];
	fun sort1 (i1 : int, (tm1:string, ty1:string)) (i2, (tm2, ty2)) =
		if ty1 = ty2 then
			if tm1 = tm2 then 0
			else i1 - i2
		else	Sort.string_order ty1 ty2;
	fun grpaux ((ty1, tmlist1)::rest1) ((tm2, ty2)::rest2) =
		if ty1 = ty2
		then grpaux ((ty1, tmlist1@[[tm2]])::rest1) rest2
		else grpaux ((ty2, [[tm2]])::(ty1,tmlist1)::rest1) rest2
	  | grpaux res _ = res;	

	fun grp ((tm, ty)::rest) = grpaux [(ty, [[tm]])] rest
	  | grp _ = error "print_zerrlistinfo" 62999 [];
	fun do_errmsgs ((ty, tmlist)::rest) = (
		report 62902 [ty, plu tmlist];
		map (report 62900) tmlist;
		do_errmsgs rest
	) | do_errmsgs nil = nil;
	val stml = map format_ztm tml;
	val styl = map format_extype tyl;
	val tmty = (combine stml styl);
	val itmty = combine (interval 1 (length styl)) tmty;
	val stmty = (map snd) (Sort.sort sort1 (rev itmty));
in
	(do_errmsgs (grp stmty);()
	)
end);
=TEX

=SML
fun Ûincompatible_schemasÝ (tm1 : Z_TM) (tm2 : Z_TM) (idtyl1 : (IDENT * EXTYPE) list)
	(idtyl2 : (IDENT * EXTYPE) list) = (
	report 62921 [];
	report 62922 [format_ztm tm1];
	map (fn (id, ty) => report 62900 [format_ident id, format_extype ty]) idtyl1;
	report 62922 [format_ztm tm2];
	map (fn (id, ty) => report 62900 [format_ident id, format_extype ty]) idtyl2;
	()
);
=TEX
=SML
fun Ûincompatible_quantÝ (tm : Z_TM) (idtyl1 : (IDENT * EXTYPE) list) (idtyl2 : (IDENT * EXTYPE) list) = (
	report 62921 [];
	report 62924 [];
	map (fn (id, ty) => report 62900 [format_ident id, format_extype ty]) idtyl1;
	report 62922 [format_ztm tm];
	map (fn (id, ty) => report 62900 [format_ident id, format_extype ty]) idtyl2;
	()
);
=TEX
=SML
fun Ûprint_zerrorÝ ((FailedZTm (term, env, details)) : ERROR_INFO) = (
	report 62001 [format_ztm term];
	(case details of

	Failed§¢ (tml, tyl) => (
		report 62011 []; print_zerrlistinfo tml tyl
	) | FailedSetd (tml, tyl) => (
		report 62021 []; print_zerrlistinfo tml tyl
	) | FailedSeta (tm, ty, ierr) => (
		report ierr []; not_a_predicate tm ty
	) | Failedð (tm, ty) => (
		report 62041 []; not_a_set tm ty
	) | Failed¸ (tml, tyl) => (
		report 62061 []; print_zerrlistinfo tml tyl
	) | FailedÊ (tm, ty) => (
		report 62071 []; not_a_schema tm ty
	) | FailedSel‰T1 (i, j) => (
		report 62086 []; report 62087 [string_of_int i, string_of_int j]
	) | FailedSel‰T2 (tm, ty) => (
		report 62088 []; not_a_tuple tm ty
	) | FailedSel‰B1 (tm, id) => (
		report 62081 []; report 62082 [format_ident id];
		report 62083 [format_ztm tm]
	) | FailedSel‰B2 (tm, ty) => (
		report 62084 []; not_a_binding tm ty
	) | FailedApp (tm1, tm2, ty1, ty2) => (
		report 62091 [];
		report 62092 [format_ztm tm1, format_extype ty1];
		report 62093 [format_ztm tm2, format_extype ty2]
	) | FailedFancyApp (id, tm, ty1, ty2) => (
		report 62091 [];
		report 62092 [format_ident id, format_extype ty1];
		report 62093 [format_ztm tm, format_extype ty2]
	) | Failed³‰F (tm, ty) => (
		report 62151 []; not_a_predicate tm ty
	) | FailedLogInOp‰F (inop, tm, ty) => (
		report 62161 [format_z_in_op inop];
		not_a_predicate tm ty
	) | FailedQuant‰F (quant, tm, ty) => (
		report 62162 [format_quant quant]; not_a_predicate tm ty
	) | FailedDecor (tm, ty) => (
		report 62131 []; not_a_schema tm ty
	) | FailedPre (tm, ty) => (
		report 62141 []; not_a_schema tm ty
	) | Failed³‰S (tm, ty) => (
		report 62142 []; not_a_schema tm ty
	) | FailedLogInOp‰S1 (inop, tm1, tm2, idtyl1, idtyl2) => (
		report 62168 [format_z_in_op inop];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | FailedLogInOp‰S2 (inop, tm, ty) => (
		report 62167 [format_z_in_op inop];not_a_schema tm ty
	) | Failedù1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62172 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | Failedù2 (tm, ty) => (
		report 62171 []; not_a_schema tm ty
	) | FailedHide (tm, ty) => (
		report 62181 []; not_a_schema tm ty
	) | FailedQuant‰S1 (quant, tm, idtyl1, idtyl2) => (
		report 62192 [format_quant quant];
		report 62193 [];
		incompatible_quant tm idtyl1 idtyl2
	) | FailedQuant‰S2 (quant, tm, ty) => (
		report 62191 [format_quant quant];
		not_a_schema tm ty
	) | FailedQuant‰S3 (quant, tm, idl) => (
		report 62192 [format_quant quant];
		report 62195 [];
		report 62196 [format_ztm tm];
		map (fn id => report 62901 [format_ident id]) idl;
		()
	) | Failed„ (tm, ty) => (
		report 62200 []; not_a_schema tm ty
	) | Failed˜ (tm, ty) => (
		report 62201 []; not_a_schema tm ty
	) | FailedEq (tm1, tm2, ty1, ty2) => (
		report 62251 [];
		report 62904 [];
		report 62900 [format_ztm tm1, format_extype ty1];
		report 62900 [format_ztm tm2, format_extype ty2]
	) | Failed»1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62281 [];
		report 62282 [];
		report 62283 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | Failed»2 (tm, ty) => (
		report 62280 [];
		not_a_schema tm ty
	) | FailedPipe1 (tm1, tm2, idtyl1, idtyl2) => (
		report 62291 [];
		report 62292 [];
		report 62293 [];
		incompatible_schemas tm1 tm2 idtyl1 idtyl2
	) | FailedPipe2 (tm, ty) => (
		report 62290 [];
		not_a_schema tm ty
	) | Failed1 (tm, ty) => (
		report 62252 []; not_a_set tm ty
	) | Failed2 (tm, ty) => (
		report 62253 [];
		report 62903 [];
		report 62900 [format_ztm tm, format_extype ty]
	) | FailedConstrained (tm1, ty, tm2) => (
		report 62261 [];
		report 62262 [format_ztm tm1, format_extype ty];
		report 62263 [format_ztm tm2]
	) | FailedRename1 (tm, ty) => (
		report 62271 []; not_a_schema tm ty
	) | FailedRename2 idl => (
		report 62272 []; report 62273 [];
		(case idl of
		[_] => report 62916 []
		|_ => report 62917 []);
		map (fn id => report 62901 [format_ident id]) idl;
		()
	) | FailedRename3 idl => (
		report 62272 []; report 62274 [];
		(case idl of
		[_] => report 62916 []
		|_ => report 62917 []);
		map (fn id => report 62901 [format_ident id]) idl;
		()
	) | FailedFreeVar id => (
		report 62980 []; report 62981 [];
		report 62901 [format_ident id]
	) (* end case *)
	);
	fail "Z-Parser" 62000 []
=TEX
=SML
) | print_zerror (FailedZSchText (schtext, env, tm, ty)) = (
	report 62001 [format_zschtext schtext];
	report 62502 [];
	not_a_predicate tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZDec1 (dec, env, tm, ty)) = (
	report 62001 [format_zdec dec];
	report 62501 [];
	not_a_set tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZDec2 (dec, env, tm, ty)) = (
	report 62001 [format_zdec dec];
	report 62503 [];
	not_a_schema tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZCompat (idtyl1,idtyl2)) = (
	report 62920 [];
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZIncludes idl) = (
	report 62923 [];
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZPara (tm, ty, det)) = (
	report 62002 []; (
		case det of
		FailedZPGiven => (report 62801 []; report 62802 [];())
		|FailedZPConstraint => (report 62803 [])
		|FailedZPConjecture => (report 62804 [])
		);
	not_a_predicate tm ty;
	fail "Z-Parser" 62000 []
) | print_zerror (FailedZFreeVar id) = (
	report 62980 []; report 62981 [];
	report 62901 [format_ident id]
);
=TEX

\subsection{The Environment}

=SML
val table:(IDENT * Z_VAR_TYPE) list ref = ref [];
=TEX
=SML
fun Ûinit_zenvÝ (genformals : IDENT list) : Z_ENV = (
let	val dummy = start_again();
	val side = (table := (map (fn id => (id, (BoundVar(ExType("ð",
		[ExVartype(Known(ident_to_string id))]))))) genformals));

in
	fn id => (
	case lassoc5 (!table) id of
	Nil => (
		case get_const_info (ident_to_string id) of
		Nil =>	FreeVar Nil
		| Value (ty, _) => GlobalVar (replaced ty)
	) |Value vty => vty
	)
end
);
=TEX
=SML
fun Ûtype_zenvÝ (env : Z_ENV) (id : IDENT) : EXTYPE = (
	case env id of
	GlobalVar ty => ty
	|BoundVar ty => ty
	|FreeVar (Value ty) => ty
	|FreeVar Nil => fail "type_zenv" 62998 []
);
=TEX
=SML
fun Ûupdate_zenvÝ (env : Z_ENV) (id : IDENT) : Z_ENV = (
	case env id of
	FreeVar Nil =>
		if (!zti_standard_z)
		then
			raise ZExn (FailedZFreeVar id)
		else
			let	val side = table := (id, FreeVar (Value (ExVartype
				(Unknown (next_name()))))):: !table;
			in
				env
			end
	|_ => env
);
=TEX
=SML
fun Ûenv_formalsÝ () : IDENT list = (
let	fun f [] = []
	  | f (h::t) = (
		case h of
		(x,BoundVar ty) => (x::(f t))
		|_ => (f t)
		)
in
	f (!table)
end);
=TEX
=SML
fun Ûshow_envÝ () : (IDENT * Z_VAR_TYPE) list = (
	!table
);
=TEX
=SML
fun Ûsub_tyÝ (env:Z_ENV) : Z_ENV = (
	fn id =>
		case env id of
		GlobalVar ty => GlobalVar (sub_type zti_subs ty)
		|BoundVar ty => BoundVar (sub_type zti_subs ty)
		|FreeVar (Value ty) => FreeVar  (Value (sub_type zti_subs ty))
		|FreeVar Nil => FreeVar Nil
);
=TEX


\section{SUPPORT FOR SCHEMAS}
=SML
datatype ÛMANIFEST_EXTYPEÝ =
		NotManifest
	|	TupleType of EXTYPE list
	|	BindingType of (IDENT * EXTYPE) list
	|	SchemaType of (IDENT * EXTYPE) list;
=TEX

=SML
fun	ÛidsetseqÝ (sl:string list) : string list = Sort.sort Sort.string_order sl;
=TEX
=SML
fun	ÛflatpackÝ ([]:string list) : string 	= ""
|	flatpack (s::[])			= s
|	flatpack (s::ss) 			= s ^ "," ^ (flatpack ss);
=TEX


=SML

fun 	Ûval_setIDENTÝ (sl:string list) :string =
	"[" ^ flatpack(idsetseq sl) ^ "]";

fun	 ÛiextymfunseqÝ (itym:(string * EXTYPE)list) :EXTYPE list =
	map (lassoc3 itym) (idsetseq(fst(split itym)));
=TEX

=SML
fun	Ûbind_exnameÝ (fid :IDENT list) :string = (
let	val sl = map ident_to_string fid;
in	
	"Z'S" ^ (val_setIDENT sl)
end);

fun 	Ûbind_extypeÝ (itym :(IDENT * EXTYPE) list) :EXTYPE = (
let	val itym' = map (fn (id, ty) => (ident_to_string id, ty)) itym;
in
		ExType (bind_exname(fst(split itym)), iextymfunseq itym')
end);

=TEX
=SML
fun Ûunbind_extypeÝ (ty : EXTYPE) : (IDENT * EXTYPE) list = (
	case ty of
	ExType (s, tyl) => (
		let	val (mani, sll) = dest_Z_name s;
		in
			case mani of
			"Z'S" => (
				case sll of
				[sl] => combine (map string_to_ident sl) tyl
				|_ => fail "unbind_extype" 62953 []
				)
			| _ => fail "unbind_extype" 62954 []
			
		end)
	|_ => fail "unbind_extype" 62954 []
);
=TEX

The following makes use of the Z mapping \cite{DS/FMU/IED/ZED003}
and \cite{DS/FMU/IED/ZED002}.
=SML
fun	Ûtuple_exnameÝ (tyl: EXTYPE list) :string = "Z'T[" ^ string_of_int(length tyl) ^ "]";
fun	Ûtuple_extypeÝ (tyl: EXTYPE list) :EXTYPE = ExType(tuple_exname tyl,tyl);
=TEX

=SML
fun Ûuntuple_extypeÝ (ty : EXTYPE) : EXTYPE list = (
	case ty of
	ExType (s, tyl) => (
		let	val (mani, sll) = dest_Z_name s;
		in
			case mani of
			"Z'T" => tyl
			| _ => fail "untuple_extype" 62955 []
			
		end)
	|_ => fail "untuple_extype" 62955 []
);
=TEX


=SML
fun  ÛmanifestÝ (ty:EXTYPE) : MANIFEST_EXTYPE = (
	case ty of

	ExType("ð",[ty']) => (
	   	SchemaType (unbind_extype ty')
		handle Fail _ => NotManifest

	)|ExType(_,_) => (
		TupleType (untuple_extype ty)
		handle Fail _ =>
			BindingType (unbind_extype ty)
			handle Fail _ => NotManifest
	)|_ => NotManifest
);
=TEX
=SML
fun ÛchartupleÝ ((decls, tm) : Z_SCH_TEXT) : Z_TM = (
let	fun f (ZDec(ids, tm)) = (
		map (fn id => ZTmLVar(id,[])) ids
	) | f (ZSchemaDec (ZTmDecor (tm1, d))) = (
		[ZTmÊ(tm1, d)]
	) | f (ZSchemaDec tm1) = (
		[ZTmÊ(tm1, "")]
	);
in
	case decls of
	[] => error "chartuple" 62998 [fn()=>"empty declaration"]
	|[decl] => (case f decl of
			[tm] => tm
			|tms => ZTmTuple tms)
	|decls => ZTmTuple(flat (map f decls)
	)
end);
=TEX

=SML
fun Ûaux_compatibilityÝ [] tym1 tym2 = ([], [], [])
  | aux_compatibility (c::cl) tym1 tym2 = (
let	val 	(tym, idtyl1, idtyl2) = aux_compatibility cl tym1 tym2;
in 
	case (lassoc5 tym1 c,lassoc5 tym2 c) of
	(Nil,Value ty) => ((c,ty)::tym, idtyl1, idtyl2)
	|(Value ty,Nil) => ((c,ty)::tym, idtyl1, idtyl2)
	|(Value ty1, Value ty2) => (
			(unify zti_subs (ty1, ty2);
				((c,sub_type zti_subs ty1)::tym, idtyl1, idtyl2))
			handle Fail msg =>
				(tym, (c,sub_type zti_subs ty1)::idtyl1,
					(c,sub_type zti_subs ty2)::idtyl2)

		)
	|_ => (tym, idtyl1, idtyl2)
end);

=TEX
=SML
fun ÛcompatibleÝ ((tty1,tty2):EXTYPE * EXTYPE) : EXTYPE = (
let	val idtyl1 = unbind_extype tty1;
	val idtyl2 = unbind_extype tty2;
	val cl = (list_cup o (map(map fst))) [idtyl1,idtyl2];
in
	case aux_compatibility cl idtyl1 idtyl2 of
	(tym, [], []) => (
		bind_extype tym
	) | (_, idtyl1, idtyl2) => (
		raise ZExn (FailedZCompat (idtyl1, idtyl2))
	)
end);
=TEX
=SML
fun ÛincludesÝ ((tty1,tty2):EXTYPE * EXTYPE) : EXTYPE = (
let	val idtyl1 = unbind_extype tty1;
	val idtyl2 = unbind_extype tty2;
	val (cl1, tyl1) = split idtyl1;
	val (cl2, tyl2) = split idtyl2;
in
	if cl2 diff cl1 = []
	then
		case aux_compatibility cl1 idtyl1 idtyl2 of
		(tym, [], []) => (
			bind_extype (tym drop (fn (s,_) => s mem cl2))
		) | (_, idtyl1', idtyl2') => (
			raise ZExn (FailedZCompat (idtyl1', idtyl2'))
		)
	else
		raise (ZExn (FailedZIncludes (cl2 diff cl1)))
end);
=TEX

\section{INFERRING TYPES IN Z DECLARATIONS}
=SML
fun Ûti_zdecÝ (env : Z_ENV) (zdec as ZDec (ids, tm): Z_DEC)
				: Z_DEC * Z_ENV * IDENT list = (
let	val uty = ExVartype(Unknown (next_name()));
	val env' = (
		fn id =>
		if id mem ids
		then
			BoundVar uty
		else
			env id
		);
	val (tm', ty') = ti_ztm env' tm;
	val side = unify zti_subs (ty', ExType("ð",[uty]))
		handle Fail msg =>
		raise ZExn (FailedZDec1 (zdec, env', tm', ty'));
	val idty = sub_type zti_subs uty;
	val env'' = sub_ty env';
in
	(ZDec(ids, tm'), env'', ids)
end)
=TEX
=SML
  | ti_zdec env (zdec as ZSchemaDec tm) = (
let	val (tm', ty') = ti_ztm env tm;
	val schty = sub_type zti_subs ty';
in
	case manifest schty of
	SchemaType idtyl => (
	   let	val env' =
			fn id =>
			case lassoc5 idtyl id of
			Nil => env id
			|Value x => BoundVar x;
	   in
		(ZSchemaDec tm', env', map fst idtyl)
	   end)
	|_ => raise ZExn (FailedZDec2 (zdec, env, tm', ty'))
end)
=TEX
=SML
and Ûlist_ti_zdecÝ env ([]:Z_DEC list) : Z_DEC list * Z_ENV * IDENT list = (
	([], env, [])
) | list_ti_zdec env (d::ds) = (
let	val (d', env', ids') = ti_zdec env d
	val (ds'', env'', ids'') = list_ti_zdec (sub_ty env') ds
in
	(d'::ds'', sub_ty env'', ids'@ids'')
end)
=TEX
\section{INFERRING TYPES IN Z SCHEMAS}

Note that if the predicate part of a schema text is
not boolean, then this constitutes a type checking error.
The caller of $ti\_zschtext$ should make this check, as
it is likely
to have more contextual information for reporting informative
error messages than $ti\_zschtext$. 

=SML
and Ûti_zschtextÝ (env : Z_ENV) (schtext : Z_SCH_TEXT as (ds, otm))
			: Z_SCH_TEXT * Z_ENV * (IDENT * EXTYPE) list = (
let	val (ds', env', ids) = list_ti_zdec env ds;
	val env'' = sub_ty env';
	val idtyl = combine ids (map (type_zenv env'') ids);

in
	case otm of
	Nil =>		((ds', Nil), env'', idtyl)
	|Value tm => (
		let	val (tm', ty') = ti_ztm env'' tm;
			val side = unify zti_subs (ty', ex_bool)
				handle Fail msg =>
				raise ZExn (FailedZSchText (schtext, env, tm', ty'));
		in
			((ds', Value tm'), env'', idtyl)
		end)
end)
=TEX

\section{INFERRING TYPES IN Z TERMS}

\subsection{Sequence Display}

=SML
and Ûti_ztmÝ (env : Z_ENV) (term as ZTm§¢ (Nil, tl)) : Z_TM * EXTYPE = (
let	val tmlist = list_ti_ztm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise ZExn (FailedZTm (term, env, Failed§¢(tl, tyl)));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = ex_ð (tuple_extype [ex_ú, sub_type zti_subs ty]);
in
	(ZTm§¢ (Value resty, tml), resty)
end)
  | ti_ztm env (ZTm§¢ (Value _, _)) = (
	fail "ti_ztm" 62998 [fn()=>
		"The expression passed to the type inferrer must not be typed"]
)
=TEX
\subsection{Set Display}
=SML
  | ti_ztm env (term as ZTmSetd (Nil, tl)) = (
let	val tmlist = list_ti_ztm env tl;
	val (tml, tyl) = split tmlist;
	val side = list_unify zti_subs tyl
		handle Fail msg =>
		raise ZExn (FailedZTm (term, env, FailedSetd(tl, tyl)));
	val ty = 
		(case tyl of
		  [] => ExVartype(Unknown(next_name()))
		  | _ => hd tyl
		);
	val resty = ex_ð (sub_type zti_subs ty);
in
	(ZTmSetd (Value resty, tml), resty)
end)
  | ti_ztm env (ZTmSetd (Value _, _)) = (
	fail "ti_ztm" 62998 [fn()=>
		"The expression passed to the type inferrer must not be typed"]
)
=TEX

\subsection{Set Abstraction}
=SML
  | ti_ztm env (term as ZTmSeta1 schtext) = (
let	val ctm = chartuple schtext;
	val (schtext', env', _) = ti_zschtext env schtext
		handle ZExn (FailedZSchText (_, env, tm', ty')) =>
		raise ZExn (FailedZTm (term, env, FailedSeta(tm',ty',62031)));
	val (_, ty') = ti_ztm (sub_ty env') ctm;
in
	(ZTmSeta1 schtext', ty')
end)
=TEX
=SML
  | ti_ztm env (term as ZTmSeta2 (schtext, tm)) = (
let	val (schtext', env', _) = ti_zschtext env schtext
		handle ZExn (FailedZSchText (_, env, tm', ty')) =>
		raise ZExn (FailedZTm (term, env, FailedSeta(tm',ty',62032)));
	val (tm', ty') = ti_ztm (sub_ty env') tm;
in
	(ZTmSeta2(schtext', tm'), ty')
end)
=TEX

\subsection{Powerset}
=SML
  | ti_ztm env (term as ZTmð tm) = (
let	val (tm', ty') = ti_ztm env tm;
	val tya = ex_ð (ExVartype (Unknown (next_name())));
	val side = unify zti_subs (ty', tya)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, Failedð (tm', ty')));
in
	(ZTmð tm, sub_type zti_subs tya)
end)
=TEX

\subsection{Tuple Display}
=SML
  | ti_ztm env (ZTmTuple []) = error "ti_ztm" 62998
		[fn()=>"ZTmTuple (Zero length tuple)"]
  | ti_ztm env (ZTmTuple [tm]) = error "ti_ztm" 62998
		[fn()=>"ZTmTuple (Unit length tuple)"]
  | ti_ztm env (ZTmTuple tml) = (
let	fun f [] n nl = nl
	  | f (h::t) n nl = f t (n+1) ((string_of_int n, "")::nl);
	val tmlist = list_ti_ztm env tml;
	val (tml', tyl') = split tmlist;
	val unkl = map (fn x => ExVartype (Unknown(next_name()))) tml';
	val side = map (unify zti_subs) (combine unkl tyl')
		handle Fail msg =>
		error "ti_ztm" 62998 [fn()=>"ZTmTuple (Unification error)"];
	val ty = tuple_extype (map (sub_type zti_subs) unkl);
in
	(ZTmTuple tml', ty)
end)
=TEX
\subsection{Product}
=SML
  | ti_ztm env (ZTm¸ []) = fail "ti_ztm" 62998 [fn()=>"ZTm¸ (Zero length product type)"]
  | ti_ztm env (ZTm¸ [tm]) = fail "ti_ztm" 62998 [fn()=>"ZTm¸ (Unit length product type)"]
  | ti_ztm env (term as ZTm¸ tml) = (
let	fun f [] n nl = nl
	  | f (h::t) n nl = f t (n+1) ((string_of_int n, "")::nl);
	fun get_unify_failures ((tm, (ty1, ty2))::rest) = (
	let	val res = (unify zti_subs (ty1, ty2);true)
			handle Fail msg => false;
	in
		if res then get_unify_failures rest
		else (tm,ty2)::get_unify_failures rest
	end
	) | get_unify_failures [] = [];
	val tmlist = list_ti_ztm env tml;
	val (tml', tyl') = split tmlist;
	val unkl = map (fn x => ex_ð (ExVartype
			(Unknown(next_name())))) tml';
	val typairs = combine unkl tyl';
	val side = case get_unify_failures (combine tml' typairs) of
		[] => ()
		|failures =>
		   (let	val(ftml, ftyl) = split failures;
		   in
			raise ZExn (FailedZTm (term, env, Failed¸ (ftml, ftyl)))
		   end);
	val ty =  ex_ð (tuple_extype (map (sub_type zti_subs) unkl));

in
	(ZTm¸ tml', ty)
end)
=TEX
\subsection{Theta}
=SML
  | ti_ztm env (term as ZTmÊ (tm, decor)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ =>
		let	val bty = (
				case ty' of
				ExType ("ð", [x]) => x
				|_ => error "ti_ztm" 62998 [fn()=> "ZTmÊ"]
			);
		in
			(ZTmÊ(tm', decor), bty)
		end
	|_ => raise ZExn (FailedZTm (term, env, FailedÊ (tm', ty')))
end)
=TEX

\subsection{Tuple Selection}

=SML
  | ti_ztm env (term as ZTmSel‰T (tm, i)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	TupleType tyl => (
		let	val sz = length tyl;
			val ty'' = nth (i-1) tyl
				handle Fail _ =>
				raise ZExn (FailedZTm  (term, env, FailedSel‰T1 (i, sz)));
		in
			(ZTmSel‰T(tm', i), sub_type zti_subs ty'')
		end)
	|_ => raise ZExn (FailedZTm (term, env, FailedSel‰T2 (tm', ty')))
end)
=TEX

\subsection{Binding Selection}

=SML
  | ti_ztm env (term as ZTmSel‰B (tm, id)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	BindingType idtyl => (
		case lassoc5 idtyl id of
		Nil => raise ZExn (FailedZTm  (term, env, FailedSel‰B1 (tm', id)))
		|Value ty'' =>
			(ZTmSel‰B(tm', id), sub_type zti_subs ty'')
		)
	|_ => raise ZExn (FailedZTm (term, env, FailedSel‰B2 (tm', ty')))
end)
=TEX

\subsection{Application}
=SML
  | ti_ztm env (term as ZTmApp (ZTmLVar ((TmplIn (StubUS, ("=", Nil), StubUS), ""),[]), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val side = unify zti_subs (ty1', ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEq (tm1', tm2', ty1', ty2')));
in
	(ZTmEq (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmApp (ZTmLVar ((TmplIn (StubUS, ("", Nil), StubUS), ""),[]), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val unk = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ex_ð unk, ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed1(tm2', ty2')));
	val side = unify zti_subs (ty1', sub_type zti_subs unk)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed2(tm2', ty2')));
in
	(ZTm (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmApp (tmf, tma)) = (
let	val (tmf', tyf) = ti_ztm env tmf;
	val (tma', tya) = ti_ztm (sub_ty env) tma;
	val tvn = next_name();
	val tyr = ExVartype(Unknown tvn);
	val side = unify zti_subs (tyf, ex_ð (tuple_extype([tya,tyr])))
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env,
				FailedApp (tmf', tma', tyf, tya)));
in
	(ZTmApp(tmf',tma'), sub_type zti_subs tyr)
end
handle ZExn (FailedZTm _) => (
let	val (tmf', tyf) = ti_ztm env tmf;
	val (tma', tya) = ti_ztm (sub_ty env) tma;
	val side = unify zti_subs (tyf, ex_ð tya)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env,
				FailedApp (tmf', tma', tyf, tya)));
in
	(ZTmApp(tmf',tma'), ex_bool)
end)
)
=TEX
=SML
  | ti_ztm env (term as ZTmFancyApp ((TmplIn (StubUS, ("=", Nil), StubUS), ""), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val side = unify zti_subs (ty1', ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, FailedEq (tm1', tm2', ty1', ty2')));
in
	(ZTmEq (tm1', tm2'), ex_bool)
end)
=TEX
=SML
  | ti_ztm env (term as ZTmFancyApp ((TmplIn (StubUS, ("", Nil), StubUS), ""), ZTmTuple [tm1, tm2])) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val unk = ExVartype (Unknown (next_name()));
	val side = unify zti_subs (ex_ð unk, ty2')
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed1(tm2', ty2')));
	val side = unify zti_subs (ty1', sub_type zti_subs unk)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env, Failed2(tm2', ty2')));
in
	(ZTm (tm1', tm2'), ex_bool)
end)
=TEX
=SML

  | ti_ztm env (term as ZTmFancyApp (id, tm)) = (
let	val side = update_zenv env id
		handle ZExn (FailedZFreeVar id) =>
		raise ZExn (FailedZTm (term, env, FailedFreeVar id));
	val tyf =  type_zenv env id;
	val (tm', ty) = ti_ztm env tm;
	val tvn = next_name();
	val tyr = ExVartype(Unknown tvn);
	val side = unify zti_subs (tyf, ex_ð (tuple_extype([ty,tyr])))
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env,
				FailedFancyApp (id, tm', tyf, ty)));
in
	(ZTmFancyApp(id, tm'), sub_type zti_subs tyr)
end
handle ZExn (FailedZTm _) => (
let	val side = update_zenv env id
			handle ZExn (FailedZFreeVar id) =>
			raise ZExn (FailedZTm (term, env, FailedFreeVar id));
	val tyf = type_zenv env id;
	val (tm', ty) = ti_ztm env tm;
	val side = unify zti_subs (tyf, ex_ð ty)
		handle Fail _ =>
			raise ZExn (FailedZTm (term, env,
				FailedFancyApp (id, tm', tyf, ty)));
in
	(ZTmFancyApp(id, tm'), ex_bool)
end)
)
=TEX


\subsection{Ì-abstraction}
=SML
 | ti_ztm env (term as ZTmÌ (sch, tm)) = (
let	val ctm = chartuple sch;
	val (sch', env', _) = ti_zschtext env sch;
	val env2 = sub_ty env';
	val (tm', ty') = ti_ztm env2 tm;
	val env3 = sub_ty env2;
	val (tm2, ty2) = ti_ztm (sub_ty env3) ctm;
	val ty = ex_ð (tuple_extype [ty2, ty']);
in
	(ZTmÌ (sch', tm'), ty)
end)
=TEX

\subsubsection{Definite Description}
=SML
 | ti_ztm env (ZTmÍ1 sch) = (
let	val ctm = chartuple sch;
	val (sch',env', _) = ti_zschtext env sch;
	val (_, ty') = ti_ztm (sub_ty env') ctm;
in
	(ZTmÍ1 sch', ty')
end)
=TEX
=SML
 | ti_ztm env (ZTmÍ2 (sch, tm)) = (
let	val (sch',env', _) = ti_zschtext env sch;
	val (tm', ty') = ti_ztm (sub_ty env') tm;
in
	(ZTmÍ2 (sch', tm'), ty')
end)
=TEX

\subsection{Truth}

=SML
  | ti_ztm env (ZTmTruth _) = (
	error "ti_ztm" 62998 [fn()=>"ZTmTruth (not expected from parser)"]
)
=TEX

\subsection{Predicate Negation}

=SML
 | ti_ztm env (term as ZTm³‰F tm) = (
let	val (tm', ty') = ti_ztm env tm
	val (tm'', ty'') = (
		case manifest ty' of
		SchemaType _ =>
			(ZTmSchemaPred tm', ex_bool)
		|_ => (tm', ty')
		);
	val side = (unify zti_subs (ty'', ex_bool)
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, Failed³‰F (tm', ty')))
		);
in
	(ZTm³‰F tm'', ty'')
end)
=TEX

\subsection{Logical Infix Operators for Predicates}

=SML
 | ti_ztm env (term as ZTmLogInOp‰F (inop, tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
	val (tm1'', ty1'') = (
		case manifest ty1' of
		SchemaType _ =>	(ZTmSchemaPred tm1', ex_bool)
		|_ => (tm1', ty1')
		);
	val (tm2'', ty2'') = (
		case manifest ty2' of
		SchemaType _ =>	(ZTmSchemaPred tm2', ex_bool)
		|_ => (tm2', ty2')
		);
	val side = unify zti_subs (ty1'', ex_bool)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰F (inop, tm1'', ty1'')));
	val side = unify zti_subs (ty2'', ex_bool)
		handle Fail _ =>
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰F (inop, tm2'', ty2'')));
in
	(ZTmLogInOp‰F(inop, tm1'' ,tm2''), ex_bool)
end
)
=TEX

\subsection{Predicate Quantification}
=SML
  | ti_ztm env (term as ZTmQuant‰F (quant, sch, tm)) = (
let	val (sch', env', _) = ti_zschtext env sch;
	val (tm', ty') = ti_ztm (sub_ty env') tm;
	val (tm'', ty'') = (
		case manifest ty' of
		SchemaType _ =>	(ZTmSchemaPred tm', ex_bool)
		|_ => (tm', ty')
		);
	val side = (unify zti_subs (ty'', ex_bool)
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, FailedQuant‰F (quant, tm'', ty'')))
		);
in
	(ZTmQuant‰F (quant, sch', tm''), sub_type zti_subs ty'')
end
)
=TEX


\subsection{Schemas as Predicates}
=SML
  | ti_ztm env (term as ZTmSchemaPred tm) = (
	error "ti_ztm" 62998 [fn()=>"ZTmSchemaPred (not expected from parser)"]
)
=TEX

\subsection{Horizontal Schemas}

=SML
  | ti_ztm env (term as ZTmHorizSchema sch) = (
let	val (sch', env', idtyl) = ti_zschtext env sch;
	val ty = ex_ð (bind_extype idtyl);
in
	(ZTmHorizSchema sch', ty)
end)
=TEX

\subsubsection{Decoration}
=SML
 | ti_ztm env (term as ZTmDecor (tm, d)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ => (ZTmDecor(tm',d), ty')
	| _ => raise ZExn (FailedZTm (term, env, FailedDecor (tm', ty')))
end)
=TEX
\subsubsection{Precondition}
=SML
  | ti_ztm env (term as ZTmPre tm) = (
let	val (tm', ty') = ti_ztm env tm;
	fun is_post (n, d) =
		case (rev o explode) d of
		("!"::rest) => true
		|("'"::rest) => true
		|_ => false;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idtyl' = idtyl drop (fn(id, ty) => is_post id);
			val ty'' = ex_ð (bind_extype idtyl');
		in
			(ZTmPre tm', ty'')
		end)
	| _ => raise ZExn (FailedZTm (term, env, FailedPre (tm', ty')))
end)
=TEX
\subsubsection{Schema Negation}
=SML
 | ti_ztm env (term as ZTm³‰S tm) = (
let	val (tm', ty') = ti_ztm env tm
	val side = (
		case manifest ty' of
		SchemaType _ 	=> ()
		|_ => 	raise ZExn (FailedZTm (term, env, Failed³‰F (tm', ty')))
		)
in
	(ZTm³‰S tm', ty')
end)
=TEX

\subsection{Logical Infix Operators for Schemas}

=SML
 | ti_ztm env (term as ZTmLogInOp‰S (inop, tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType _, SchemaType _) => (
		let	val bty1 = (
				case ty1' of
				ExType("ð",[ty]) => ty
				| _ => error "ti_ztm" 62998 [fn()=>"ZTmLogInOp‰S"]);
			val bty2 = (
				case ty2' of
				ExType("ð",[ty]) => ty
				| _ => error "ti_ztm" 62998 [fn()=>"ZTmLogInOp‰S"])
			val inopty = compatible (bty1, bty2)
				handle ZExn (FailedZCompat (idtyl1, idtyl2)) =>
				raise ZExn (FailedZTm (term, env,
					FailedLogInOp‰S1 (inop, tm1', tm2', idtyl1, idtyl2)))
		in
			(ZTmLogInOp‰S(inop, tm1',tm2'), ex_ð inopty)
		end
	) | (SchemaType _, _) => (
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰S2 (inop, tm2', ty2')))
	) | (_, _) => (
		raise ZExn (FailedZTm (term, env, FailedLogInOp‰S2 (inop, tm1', ty1')))
	)
end
)
=TEX

\subsubsection{Schema Projection}

=SML
  | ti_ztm env (term as ZTmù (tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1, SchemaType idtyl2) => (
		let	val idtyl1' = map (fn ((n,d),t) => ((n,""),t)) idtyl1;
			val idtyl2' = map (fn ((n,d),t) => ((n,""),t)) idtyl2;
			val bty1 = bind_extype idtyl1';
			val bty2 = bind_extype idtyl2';
			val ty = compatible (bty1, bty2)
				handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
				raise ZExn (FailedZTm (term, env,
					Failedù1 (tm1', tm2', idtyl1'', idtyl2'')))
		in
			(ZTmù(tm1',tm2'), ty2')
		end
	) | (SchemaType _, _) => (
		raise ZExn(FailedZTm(term, env, Failedù2 (tm2', ty2')))
	) | (_, _) => (
		raise ZExn(FailedZTm(term, env, Failedù2 (tm1', ty1')))
	)
end
)
=TEX
\subsubsection{Schema Hiding}

=SML
  | ti_ztm env (term as ZTmHide (tm, idl)) = (
let	val (tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType idtyl => (
		let	val idm = idtyl drop (fn(id,ty) => (id mem idl));
			val ty'' = ex_ð (bind_extype idm);
		in
			(ZTmHide(tm',idl), ty'')
		end)
	| _ => raise ZExn(FailedZTm(term, env, FailedHide (tm', ty')))
end
)
=TEX

\subsubsection{Schema Quantification}

=SML
  | ti_ztm env (term as ZTmQuant‰S (quant, sch, tm)) = (
let	val (tm1', ty1') = ti_ztm env (ZTmHorizSchema sch);
	val (tm2', ty2') = ti_ztm env tm;
	val sch' = case tm1' of
		ZTmHorizSchema sch' => sch'
		| _ => error "ti_ztm" 62998 [fn()=>"ZTmQuant‰S (impossible.1)"];
in
	case manifest ty2' of
	SchemaType _ => (
		let	val ty1'' = (	case sub_type zti_subs ty1' of 
						ExType("ð",[ty]) => ty
						| _ => error "ti_ztm" 62998 [fn()=>"ZTmQuant‰S (impossible.2)"]);
			val ty2'' = (	case sub_type zti_subs ty2' of 
						ExType("ð",[ty]) => ty
						| _ => error "ti_ztm" 62998 [fn()=>"ZTmQuant‰S (impossible.3)"]);
			val qty = includes (ty2'', ty1'')
				handle
				ZExn (FailedZCompat (idtyl2'', idtyl1'')) => (
					raise ZExn (FailedZTm (term, env,
					FailedQuant‰S1 (quant, tm2', idtyl1'', idtyl2''))))
				|ZExn (FailedZIncludes idl) => (
					raise ZExn (FailedZTm (term, env, 
					FailedQuant‰S3 (quant, tm2', idl))));
		in
			(ZTmQuant‰S(quant, sch', tm2'), qty)
		end
	) |_ => raise ZExn(FailedZTm(term, env, FailedQuant‰S2 (quant, tm2', ty2')))
end)
=TEX

\subsubsection{„ and ˜}
=SML
  | ti_ztm env (term as ZTm„ tm) = (
let	val(tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ => (ZTm„ tm', ty')
	|_ => raise ZExn (FailedZTm (term, env, Failed„ (tm', ty')))
end)
=TEX

=SML
  | ti_ztm env (term as ZTm˜ tm) = (
let	val(tm', ty') = ti_ztm env tm;
in
	case manifest ty' of
	SchemaType _ => (ZTm˜ tm', ty')
	|_ => raise ZExn (FailedZTm (term, env, Failed˜ (tm', ty')))
end)
=TEX

\subsection{Set Membership and Equality}

=SML
  | ti_ztm env (ZTmEq (_, _)) = (
	error "ti_ztm" 62998 [fn()=>"ZTmEq (not expected from parser)"]
)
=TEX
=SML
  | ti_ztm env (term as ZTm (_, _)) = (
	error "ti_ztm" 62998 [fn()=>"ZTm (not expected from parser)"]
)
=TEX

\subsection{Schema Composition}

=SML
 | ti_ztm env (term as ZTm» (tm1, tm2)) = (
let	fun add_prime (id as (n, d)) =
		(n, d^"'");
	fun f tym1 [] = ([], [], [])
	  | f tym1 ((id2, ty2)::t) = (
		let	val id2' = add_prime id2;
		in
			case lassoc5 tym1 id2' of
			Value ty1 => (
				let	val (dl, idtyl1, idtyl2) = f tym1 t;
				in
					(unify zti_subs (ty1, ty2); (id2::dl, idtyl1, idtyl2))
					handle Fail _ => (dl, (id2',ty1)::idtyl1, (id2,ty2)::idtyl2)
				end)
			| Nil => f tym1 t
		end);
	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1,SchemaType idtyl2) => 
		let	val (dropl, fidtyl1, fidtyl2) = f idtyl1 idtyl2;
			val pdropl = map add_prime dropl;
		in
			case (fidtyl1, fidtyl2) of
			([], []) => (
				let	val idtyl1' = idtyl1 drop
						 (fn (id,ty) => id mem pdropl);
					val idtyl2' = idtyl2 drop
						(fn (id,ty) => id mem dropl);
					val bty1 = bind_extype idtyl1';
					val bty2 = bind_extype idtyl2';
					val ty = compatible (bty1, bty2)

						handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
						raise ZExn (FailedZTm (term, env,
						Failed»1 (tm1', tm2', idtyl1'', idtyl2'')))
				in
					(ZTm»(tm1',tm2'), ex_ð ty)
				end)
			|_ => raise ZExn (FailedZTm (term, env, Failed»1 (tm1', tm2', fidtyl1, fidtyl2)))
		end
	| (SchemaType _, _) => raise ZExn (FailedZTm (term, env, Failed»2 (tm2', ty2')))
	| _ => raise ZExn (FailedZTm (term, env, Failed»2 (tm1', ty1')))
end)
=TEX

\subsection{Schema Piping}
=SML
 | ti_ztm env (term as ZTmPipe (tm1, tm2)) = (
let	fun change_q (id as (n, d)) = (
		case (rev o explode) d of
		"?"::rest => (n, (implode o rev) ("!"::rest))
		|_ => id);
	fun f tym1 [] = ([], [], [])
	  | f tym1 ((id2, ty2)::t) = (
		let	val id2' = change_q id2;
		in
			case lassoc5 tym1 id2' of
			Value ty1 => (
				let	val (dl, idtyl1, idtyl2) = f tym1 t;
				in
					(unify zti_subs (ty1, ty2); (id2::dl, idtyl1, idtyl2))
					handle Fail _ => (dl, (id2',ty1)::idtyl1, (id2,ty2)::idtyl2)
				end)
			| Nil => f tym1 t
		end);
	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', manifest ty2') of
	(SchemaType idtyl1,SchemaType idtyl2) => 
		let	val (dropl, fidtyl1, fidtyl2) = f idtyl1 idtyl2;
			val bang_dropl = map change_q dropl;
		in
			case (fidtyl1, fidtyl2) of
			([], []) => (
				let	val idtyl1' = idtyl1 drop
						 (fn (id,ty) => id mem bang_dropl);
					val idtyl2' = idtyl2 drop
						(fn (id,ty) => id mem dropl);
					val bty1 = bind_extype idtyl1';
					val bty2 = bind_extype idtyl2';
					val ty = compatible (bty1, bty2)

						handle ZExn (FailedZCompat (idtyl1'', idtyl2'')) =>
						raise ZExn (FailedZTm (term, env,
						FailedPipe1 (tm1', tm2', idtyl1'', idtyl2'')))
				in
					(ZTmPipe(tm1',tm2'), ex_ð ty)
				end)
			|_ => raise ZExn (FailedZTm (term, env, FailedPipe1 (tm1', tm2', fidtyl1, fidtyl2)))
		end
	| (SchemaType _, _) => raise ZExn (FailedZTm (term, env, FailedPipe2 (tm2', ty2')))
	| _ => raise ZExn (FailedZTm (term, env, FailedPipe2 (tm1', ty1')))
end)
=TEX



\subsection{Integer and String Quotation}
=SML
  | ti_ztm env (ZTmú i) = (ZTmú i, ex_ú)
  | ti_ztm env (ZTmString s ) = (ZTmString s, ex_string)
=TEX

\subsection{Type Constraints}
=SML
  | ti_ztm env (term as ZTmConstrained (tm1, tm2)) = (
let	val (tm1', ty1') = ti_ztm env tm1;
	val (tm2', ty2') = ti_ztm (sub_ty env) tm2;
in
	case (manifest ty1', ty2') of
	(SchemaType _,ExType("ð",[ExType("BOOL",[])])) => (
		(ZTmSchemaPred (tm1'), ex_bool)
		)
	|_ => (
		let	val side = unify zti_subs (ex_ð ty1', ty2')
			handle Fail msg =>
			raise ZExn (FailedZTm (term, env, FailedConstrained
						(tm1', ty1', tm2')));
		in
			(ZTmConstrained(tm1',tm2'), sub_type  zti_subs ty1')
		end)
	end)
=TEX

\subsection{Local Variables}
=SML
 | ti_ztm env (ZTmLVar ((TmplNon ("true", Nil), ""), tml)) = (
	(ZTmTruth true, ex_bool)
)| ti_ztm env (ZTmLVar ((TmplNon ("false", Nil), ""), tml)) = (
	(ZTmTruth false, ex_bool)
)| ti_ztm env (term as ZTmLVar (id as (n, d), tml)) = (
let	fun find_glob_in_scope (ident as (n, d)) = (
	let
		val exd = (rev o explode) d;
		fun aux (decor as d0::rest) res =
		let	val sd = (implode o rev) decor;
		in
			case env (n, sd) of
			GlobalVar ty => ((n, sd), GlobalVar ty, res)
			|_ => aux rest (d0::res)
		end
		  | aux [] res = (
			case env (n, "") of
			GlobalVar ty => ((n, ""), GlobalVar ty, res)
			|other => ((n, ""), other, res)
			);
	in
		case aux exd [] of
		(id, GlobalVar ty, res) => (id, GlobalVar ty, implode res)
		|(_, other, _) => (ident, other, "")
	end);
	fun gen_actuals id tml ty = (
		case tml of
		[] => (
			(ZTmLVar(id, []), ty)
		)|_ => (
			let	val ttmlist = list_ti_ztm env tml;
				val (ttml,tyl) = split ttmlist
				val argty = tuple_extype tyl;
				val tvn = next_name();
				val resty = ExVartype(Unknown tvn);
				val side = unify zti_subs (ty, ex_ð (tuple_extype [argty, resty]))
					handle Fail msg =>
					fail "ti_ztm" 62998 [fn ()=>
					"ZTmLVar (message to be supplied later)"];
				val ty' = sub_type zti_subs ty;
			in
				(ZTmLVar(id, ttml), ty')
			end)
	);
in
	case find_glob_in_scope id of
	(id', GlobalVar ty', "") => (
		ti_ztm env (ZTmGVar (id', tml))
	)|(id', GlobalVar ty', d') => (
		case manifest ty' of
		SchemaType _ => (
			ti_ztm env (ZTmDecor (ZTmGVar (id', tml), d'))
		) |_ =>
			let	val newenv = update_zenv env id
					handle ZExn (FailedZFreeVar id) =>
					raise ZExn (FailedZTm (term, env, FailedFreeVar id));
				val ty'' = (case newenv id of
					BoundVar ty => ty
					|FreeVar (Value ty) => ty
					|_ =>  error "ti_ztm" 62998 [fn ()=>
						"ZTmLVar (impossible.1)"]
					);
			in
				gen_actuals id tml ty''
			end
	)|(id', BoundVar ty', "") => (
		gen_actuals id tml ty'
	)|(id', FreeVar Nil, "") => (
		let	val newenv = update_zenv env id
				handle ZExn (FailedZFreeVar id) =>
				raise ZExn (FailedZTm (term, env, FailedFreeVar id));
			val ty' = case newenv id of
				FreeVar (Value ty) => ty
				|_ =>  error "ti_ztm" 62998 [fn ()=>
					"ZTmLVar (impossible)"];
		in
			gen_actuals id tml ty'
		end
	)|(id', FreeVar (Value ty'), "") => (
		gen_actuals id tml ty'
	)|_ => error "ti_ztm" 62998 [fn ()=> "ZTmLVar (impossible.2)"]
end
)
=TEX

\subsection{Global Variables}

=SML
 | ti_ztm env (term as ZTmGVar (id as (n, d), tml)) = (
	case (env id, tml, id) of 
	(GlobalVar (ExType ("­",[domty,ranty])), [], (TmplNon ("U", Nil),"")) => 
		let	val (bnam,gentyl) = (
				case domty of
				ExType(b, l) => (b, l)
				| _ => fail "ti_ztm" 62998 [fn()=>"Bad generic constant"]);
			val ztml' = map (fn x => ZTmGVar((TmplNon ("totality",Nil),""),[])) gentyl;
		in
			ti_ztm env (ZTmGVar(id,ztml'))
		end
	| (GlobalVar (ExType ("­",[domty,ranty])),[],_) => 
		let	val (bnam,gentyl) = (
				case domty of
				ExType(b,l) => (b,l)
				| _ => fail "ti_ztm" 62998 [fn()=>"Bad generic constant"]);
			val ztml' = map (fn x => ZTmGVar((TmplNon("U",Nil),""),[]))
									 gentyl;
		in
			ti_ztm env (ZTmGVar(id, ztml'))
		end
	| (GlobalVar (ty as ExType("­",[domty,ranty])), _, _) =>
		let	val (tml', tyl') = split (list_ti_ztm env tml);
			val argty = tuple_extype tyl';
			val resty = ExVartype(Unknown (next_name()));
			val side = unify zti_subs (ExType ("­",[domty, ranty]),
				ExType ("­", [argty, resty]))
			in
				(ZTmGVar(id, tml'), sub_type zti_subs ty)
			end
	| (GlobalVar ty, [], _) =>	(ZTmGVar(id,[]), ty)
	|_ => fail "ti_ztm" 62998 [fn()=>"ZTmGVar: Not a constant"]
)
=TEX

\subsection{Let Expressions}

=SML
 | ti_ztm env (term as ZTmLet (eqdefl, tm)) = (
let	val (abbl, defl) = split eqdefl;
	val (defl', tyl') = split (list_ti_ztm env defl);
	val abbtyl' = combine abbl tyl';
	val eqdefl' = combine abbl defl';
	val env' = (fn id =>
		case lassoc5 abbtyl' id of
		Nil => (update_zenv env id
			handle ZExn (FailedZFreeVar id) =>
			raise ZExn (FailedZTm (term, env, FailedFreeVar id)); env id)
		|Value ty => BoundVar ty
		);
	val (tm', ty') = ti_ztm env' tm;
in
	(ZTmLet (eqdefl', tm'), ty')
end
)
=TEX

\subsection{Renaming}
=SML
 | ti_ztm env (term as ZTmRename (tm, ididl)) = (
let	val (tm', ty') = ti_ztm env tm;
	fun get_repeats idl = (
	let	fun aux (id::rest) = (
			if id mem rest
			then [id]::(aux rest)
			else aux rest
		) | aux [] = [];
	in
		list_cup (aux idl)
	end);
	val (idnewl, idoldl) = split ididl;
	val rep1 = get_repeats idnewl;
	val rep2 = get_repeats idoldl;

	val side = case rep1 of
		[] => ()
		|_ =>	raise ZExn (FailedZTm (term, env, FailedRename2 rep1));
	val side = case rep2 of
		[] => ()
		|_ =>	raise ZExn (FailedZTm (term, env, FailedRename3 rep2));
in
	case manifest ty' of
	SchemaType idtyl =>
		(ZTmRename(tm, ididl), bind_extype (map (fn (id, ty) =>
			(rassoc4 ididl id id, ty)) idtyl))
	|_ => raise ZExn (FailedZTm (term, env, FailedRename1 (tm', ty')))
end
)
=TEX

\subsection{Bracketed Terms}
=SML
 | ti_ztm env (term as ZTmBracketed tm) = (
let	val (tm', ty') = ti_ztm env tm
in
	(ZTmBracketed tm', ty')
end
)
=TEX

\subsection{Term Quotation}
=SML
  | ti_ztm env (ZTmQuotation holtm) = (
	(ZTmQuotation holtm, (type_to_extype o type_of) holtm)
)
=TEX


\subsection{Type Inferring Lists of Z Terms}
=SML
and
Ûlist_ti_ztmÝ (env : Z_ENV) (tml : Z_TM list) : (Z_TM * EXTYPE) list = (
	let	fun list_ti_aux env nil = nil
		  | list_ti_aux env (tm::rest) = (
		let	val (titerm as (tm, ty)) = ti_ztm env tm;
			val newenv = sub_ty env;
			val next = list_ti_aux newenv rest;
		in
			(titerm::next)
		end);
	in
		list_ti_aux env tml
	end
);
=TEX

\section{INFERRING TYPES IN Z PARAGRAPHS}

The paragraph datatype includes a constructor for
Z terms. This is a convenient place to include Z terms,
and avoids having another data type which comprises
paragraphs or Z terms.
=SML
datatype ÛZINFERREDÝ =	Inferred of Z_PARA * SUBS 
		|	TypeError of ERROR_INFO;
=TEX
=SML
fun Ûti_zparaÝ (p as ZParaAbbDef (id, formals, tm, Nil): Z_PARA) : ZINFERRED = (
let	val env = init_zenv formals;
	val (tm', ty') = ti_ztm env tm;
in
	Inferred (ZParaAbbDef (id, formals, tm', Value ty'), zti_subs)

end
) | ti_zpara (ZParaAbbDef (_, _, _, Value _)) = (
	fail "ti_zpara" 62998 [fn()=>"ZParaAbbDef (Unexpected type)"]
=TEX
=SML
) | ti_zpara (p as ZParaSchBox (id, formals, sch, Nil)) = (
let	val env = init_zenv formals;
	val (sch', env', idtyl) = ti_zschtext env sch;
	val ty = ex_ð (bind_extype idtyl);
in
	Inferred (ZParaSchBox (id, formals, sch', Value ty), zti_subs)

end
=TEX
=SML
) | ti_zpara (p as ZParaSchBox (_, _, _, Value _)) = (
	error "ti_zpara" 62998 [fn()=>"ZParaSchBox (Unexpected type)"]
=TEX
=SML
) | ti_zpara  (ZParaAxDes (formals, sch, Nil)) = (
let	val env = init_zenv formals;
	val (sch', env', idtyl) = ti_zschtext env sch;
in
	Inferred (ZParaAxDes (formals, sch', Value idtyl), zti_subs)
end
) | ti_zpara (ZParaAxDes (_, _, Value _)) = error "ti_zpara" 62998
	[fn()=>"ZParaAxDes (Unexpected term-type list)"]
=TEX
=SML
  | ti_zpara  (p as ZParaFreeType _) = (
	Inferred (p, zti_subs)
=TEX

=SML
) | ti_zpara (p as ZParaGivenSet (idl, Nil)) = (
	Inferred (p, zti_subs)
) | ti_zpara (p as ZParaGivenSet (idl, Value (formals, tm))) = (
let	val env = init_zenv (idl@formals);
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPGiven));
in
	Inferred (p, zti_subs)
end
=TEX
=SML
) | ti_zpara (p as ZParaConstraint (idl, tm)) = (
let	val env = init_zenv idl;
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPConstraint));
in
	Inferred (ZParaConstraint (idl, tm'), zti_subs)
end
=TEX
=SML
) | ti_zpara (p as ZParaConjecture (id, formals, tm)) = (
let	val env = init_zenv formals;
	val (tm', ty') = ti_ztm env tm;
	val side = unify zti_subs (ty', ex_bool)
		handle Fail msg =>
		raise ZExn (FailedZPara (tm', ty', FailedZPConjecture));
in
	Inferred (ZParaConjecture (id, formals, tm'), zti_subs)
end
=TEX
=SML
) | ti_zpara (p as ZParaTerm (formals, tm, Nil)) = (
let	val env = init_zenv formals;
	val (tm', ty') = ti_ztm env tm;
in
	Inferred (ZParaTerm (formals, tm', Value ty'), zti_subs)
end
=TEX
=SML
) | ti_zpara (p as ZParaTerm (_, _, Value _)) = (
	error "ti_zpara" 62998 [fn()=>"The term passed to the type inferrer must not be typed"]
=TEX
=SML
) | ti_zpara (p as ZParaFixity _) = (
	error "ti_zpara" 62998 [fn()=>
		"Fixity paragraph should not be passed into the type inferrer"]
);
=TEX
=SML
fun Ûtype_check_zparaÝ {standard : bool} (p:Z_PARA) : ZINFERRED = (
let	val side = init_subs zti_subs;
	val side = (zti_standard_z := standard);
in
	ti_zpara p
		handle ZExn info => TypeError(info)
end);


=IGN




fun Ûextype_to_type1Ý (ty : EXTYPE) : TYPE = (
	extype_to_type zti_subs [] ty
	handle Fail msg => fail "extype_to_type1" 62998 [fn()=>"Attempt to declare a constant with a free type"]
);


fun new_type_nofail (tyname, arity) = (
	case get_type_arity tyname of
	Nil => (new_type (tyname, arity);true)
	|Value arity' =>
		if arity = arity'
		then false
		else fail "new_type_nofail" 62998 []
);

fun new_const_nofail (cname, ty) = (
	case get_const_info cname of
	Nil => (new_const (cname, ty);true)
	|Value (ty', _) =>
		if ty =: ty'
		then false
		else fail "new_const_nofail" 62998 []
);

fun declare_ztype exty = (
let	val ty = extype_to_type1 exty;
in
	if is_vartype ty
	then	let	val tyname = dest_vartype ty;
			val side = new_type_nofail (tyname, 0);
			val side = new_const_nofail (tyname, mk_ctype ("ð",[ty]));
		in () end
	else
		let	val (s, tyl) = dest_ctype ty;
			val side = new_type_nofail (s, length tyl);
			val side = new_const_nofail (s,  mk_ctype ("ð", [ty]));
		in () end
end);

	
fun Ûdeclare_zconstantsÝ  (p as ZParaAbbDef (id, _, _, Value ty) : Z_PARA) : Z_PARA =
	(declare_ztype ty; new_const (ident_to_string id, extype_to_type1 ty);p)
  | declare_zconstants (p as ZParaSchBox (id, _, _, Value ty)) =
	(declare_ztype ty; new_const (ident_to_string id, extype_to_type1 ty);p)
  | declare_zconstants (p as ZParaAxDes (_, _, Value idtyl)) = (
	(map (fn (id, ty) => (
		declare_ztype ty;
		new_const (ident_to_string id, extype_to_type1 ty))) idtyl);
	p
	)
  | declare_zconstants (p as ZParaGivenSet (idl, Nil)) = (
let	val sl = map ident_to_string idl;
	val side = (map (fn s => new_type (s, 0))) sl;
	val side = map (fn s=> new_const (s, mk_ctype ("ð", [mk_ctype (s,[])]))) sl;
in
	p
end
) | declare_zconstants p = (print "NOTHING DECLARED HERE!";p);

=TEX
\section{EPILOGUE}
SML
end (* of structure ZTypeInference *);
=TEX

\end{document}

=IGN
fun Ûz_term_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZTerm")
			andalso	is_same_symbol(finish, ">")
			andalso	(lang = "")
		then	()
		else
			fail "z_term_recogniser" 49010 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val tokens = zlex value;
	val parsed = zparser {is_quot = true, standard = true} tokens;
(*	val type_checked = (
		case type_check_zpara "standard" parsed of
		Inferred x => (diag_line "OK!";x)
		|TypeError e => print_zerror e
		); *)
in	parsed
end);


