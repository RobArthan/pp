% imp020.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Z User Interface Support}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP079}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the implementation for the
Z User Interface Support module.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item [Issue \SCCSversion~(\FormatDate{$Date$%
})]
First draft.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the User Interface Support module for HOL/Z.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD079}.
\subsection{Introduction}
\subsection{Dependencies}

\section{PREAMBLE}
=SML
structure ZUserInterfaceSupport : ZUserInterfaceSupport = struct
open Unification;
=TEX
\section{MISCELLANEA}
=SML
fun €words› (s : string) : string list = (
	let	fun state1 acc (ch :: chs) = (
			if ch = " " orelse ch = "\t" orelse ch = "\n"
			then state1 acc chs
			else state2 (ch :: acc) chs
		) | state1 acc [] = acc
		and state2 (acc as (h :: t)) (ch :: chs) = (
			if ch = " " orelse ch = "\t" orelse ch = "\n"
			then state1 acc chs
			else state2 ((h ^ ch) :: t) chs
		) | state2 [] chs = (state2 [""] chs
		) | state2 acc [] = acc;
	in	rev(state1 [] (explode s))
	end
);
=TEX
\section{TYPES}\label{TYPES}
In this section we give the Standard ML types provided by this module.

We require data types to be used in \cite{DS/FMU/IED/IMP061}
to represent the result of a context-free parse
using the grammar of \cite{DS/FMU/IED/DTD061}. The result is used to
generate a value of type $Z\_TM$ as required by the type inferrer.

The following types are used for identifiers and decoration:
=SML
type €ID›		= string;
type €DECOR›		= string;
=TEX
We represent precedences using 
the integers:
=SML
type €PREC›		= int;
=SML
datatype €CLASS›	=	€ZClFun› of int
			|	€ZClRel›
			|	€ZClGen› of int;
=TEX
=SML
datatype €FANCYFIX›	=	€ZFFBeginOp›
			|	€ZFFEndOp›
			|	€ZFFInOp›
			|	€ZFFPostBeginOp›
			|	€ZFFThenOp›
			|	€ZFFPostOp›
			|	€ZFFPreEndOp›
			|	€ZFFPreOp›;
=TEX
=SML
type €ZFIXITY› 	= FANCYFIX * CLASS;
=TEX
=TEX
The following types are used for the templates which
record information about fancy-fix operators:
=SML
datatype €STUB›		= 	€StubUS›		(* _ *)
			|	€StubEll›		(* ... *);

type €CORE›		=	ID * ((STUB * ID) list * (STUB * ID)) OPT;

datatype €TEMPLATE›	=	€TmplNon› of	CORE
					(* id, {stub, id} *)
			|	€TmplIn› of	(STUB * CORE * STUB)
					(* stub, id, {stub, id}, stub *)	
			|	€TmplPre› of	(CORE * STUB)
					(* id, {stub, id}, stub *)
			|	€TmplPost› of	(STUB * CORE)
					(* {stub, id}, stub, id *);
=TEX
Logical and schema operators are represented using the following
data types:
=SML
datatype €Z_LOG_IN_OP›	= ZLogInOp±
			| ZLogInOp≤
			| ZLogInOp¥
			| ZLogInOp§
			| ZLogInOpSemi;


datatype €SCH_IN_OP›	= €Pipe› | €Filter› | €Comp›;

datatype €SCH_PRE_OP›	= €Pre› | €Delta› | €Xi›;

datatype €Z_QUANT›	= ZQuantµ
			| ZQuant∂
			| ZQuant∂â1;
=TEX
Most of the complexity of the parsing process arises in the treatment of
predicates, schemas and expressions. These are all mapped onto the
data type $PRED$. The type contains a constructor corresponding to
each of the alternatives for $Pred$, $Pred1$, $Pred2$, $Pred3$,
$Schema2$, $Schema3$, $Schema4$, $Expr0$, $Expr1$, $Expr2$, $Expr3$
and $Expr4$, with the exceptions that (i) no constructor is required
for alternatives comprising a single non-terminal, and (ii) in most cases
where one alternative may be obtained from another by omitting part of it,
the data type has a single constructor with optional components in its
operand type.

=SML
datatype €PRED›		= €PredQuantifier› of Z_QUANT * DECL * (PRED OPT) * PRED
			| €PredLet› of EQ_DEF list * PRED
			| €PredLogInOp› of PRED * Z_LOG_IN_OP * PRED
			| €PredNot› of PRED
			| €PredSchInOp› of PRED * SCH_IN_OP * PRED
			| €PredSchPreOp› of SCH_PRE_OP * PRED
			| €PredSchemaHiding› of PRED * (PRED list)
			| €PredMu› of DECL * (PRED OPT) * (PRED OPT)
			| €PredLambda› of DECL * (PRED OPT) * (PRED OPT)
			| €PredFancyFix› of TEMPLATE * DECOR * ((PRED list) list)
			| €PredCrossProduct› of PRED list
			| €PredPow› of PRED
			| €PredApplication› of PRED * PRED
			| €PredTheta› of PRED
			| €PredSelection› of PRED * PRED
			| €PredIdDec› of ID * DECOR
			| €PredQuotation› of TERM
			| €PredPlaceHolder› of STUB
			| €PredNumber› of int
			| €PredString› of string
			| €PredTuple› of PRED list
			| €PredSetDisplay› of PRED list
			| €PredSeqDisplay› of PRED list
			| €PredSetComp› of DECL * (PRED OPT) * (PRED OPT)
			| €PredHorizSchema› of  DECL * (PRED OPT)
			| €PredGenInst› of PRED list
			| €PredRenameList› of (PRED * PRED) list
			| €PredBracketed› of PRED * DECOR
=TEX
The above definition uses the following type abbreviations which correspond
to the non-terminals $Decl$ and $EqDef$ in the grammar. Note that
a declaration is much simpler here than in the grammar (which is
complicated by a need to single out declarations consisting of a single
schema expression as a special case).
=SML
withtype €DECL›		= (PRED list * PRED OPT) list
and €EQ_DEF›		= PRED * PRED;
=TEX
The following type abbreviations and data types correspond to the
various sorts of paragraph:
=SML
type €FIXITY›		= CLASS * (TEMPLATE list);

type €GENERAL_TERM›	= PRED * (PRED OPT);

datatype €ABB_DEF›	= €ADEqDef› of EQ_DEF
			| €ADSchemaBox› of PRED * DECL * (PRED OPT);

type €FREE_TYPE_DEF›	= (PRED * (PRED list)) list;

type €AX_BOX›		= (PRED list) * DECL * (PRED OPT);

type €CONJECTURE›		= (ID OPT) * PRED;
=TEX
The overall result of a context-free parse of a single Z paragraph
is then represented by the following data type:
=SML
datatype €PARAGRAPH›	= €ParFixity› of FIXITY
			| €ParGeneralTerm› of GENERAL_TERM
			| €ParAbbDef› of ABB_DEF
			| €ParFreeTypeDef› of FREE_TYPE_DEF
			| €ParAxBox› of AX_BOX
			| €ParConjecture› of CONJECTURE;
=TEX
The result of the parser of \cite{DS/FMU/IED/DTD062}
for use by the paragraph processor and \cite{DS/FMU/IED/DTD062}
the type inferrer \cite{DS/FMU/IED/DTD062}
are given using the following datatypes:
=TEX
The following types are the ones used to communicate with
the type inferrer as required by \cite{DS/FMU/IED/DTD061}.
=SML
type €IDENT›	=	TEMPLATE * DECOR;
=TEX
=SML
datatype €Z_TM›	=	ZTmß¢ of EXTYPE OPT * Z_TM list
		|	ZTmSetd of EXTYPE OPT * Z_TM list
		|	ZTmSeta1 of Z_SCH_TEXT
		|	ZTmSeta2 of Z_SCH_TEXT * Z_TM
		|	ZTm of Z_TM
		|	ZTmTuple of Z_TM list
		|	ZTm∏ of Z_TM list
		|	ZTm  of Z_TM * DECOR
		|	ZTmSelâB of Z_TM * IDENT
		|	ZTmSelâT of Z_TM * int
		|	ZTmApp of Z_TM * Z_TM
		|	ZTmFancyApp of IDENT * Z_TM
		|	ZTmÃ of Z_SCH_TEXT * Z_TM
		|	ZTmÕ1 of Z_SCH_TEXT
		|	ZTmÕ2 of Z_SCH_TEXT * Z_TM
		|	ZTmTruth of bool
		|	ZTm≥âF of Z_TM
		|	ZTmLogInOpâF of Z_LOG_IN_OP * Z_TM * Z_TM
		|	ZTmSchemaPred of Z_TM
		|	ZTmQuantâF of Z_QUANT * Z_SCH_TEXT * Z_TM
		|	ZTmHorizSchema of Z_SCH_TEXT
		|	ZTmDecor of Z_TM * DECOR
		|	ZTmPre of Z_TM
		|	ZTm≥âS of Z_TM
		|	ZTmLogInOpâS of Z_LOG_IN_OP * Z_TM * Z_TM
		|	ZTm˘ of Z_TM * Z_TM
		|	ZTmHide of Z_TM * IDENT list
		|	ZTmQuantâS of Z_QUANT * Z_SCH_TEXT * Z_TM
		|	ZTmÑ of Z_TM
		|	ZTmò of Z_TM
		|	ZTmEq of Z_TM * Z_TM
		|	ZTmç of Z_TM * Z_TM
		|	ZTmª of Z_TM * Z_TM
		|	ZTmPipe of Z_TM * Z_TM
		|	ZTm˙ of int
		|	ZTmString of string
		|	ZTmConstrained of Z_TM * Z_TM
		|	ZTmLVar of IDENT * EXTYPE OPT * Z_TM list
		|	ZTmGVar of IDENT * EXTYPE OPT * Z_TM list
		|	ZTmLet of Z_EQ_DEF list * Z_TM
		|	ZTmRename of Z_TM * ((IDENT * IDENT) list) 
		|	ZTmBracketed of Z_TM
		|	ZTmQuotation of TERM
=TEX
=SML
and €Z_DEC›	=	ZDec of IDENT list * Z_TM * EXTYPE OPT
		|	ZSchemaDec of Z_TM * EXTYPE OPT
=TEX
=SML
withtype €Z_SCH_TEXT› =	Z_DEC list * Z_TM OPT * EXTYPE OPT
and	€Z_EQ_DEF› =	IDENT * Z_TM;

=SML
datatype €Z_PARA› =	ZParaFixity of FIXITY
|	ZParaAbbDef of IDENT * IDENT list * Z_TM * EXTYPE OPT
|	ZParaSchBox of IDENT * IDENT list * Z_SCH_TEXT * EXTYPE OPT
|	ZParaAxDes of IDENT list * Z_SCH_TEXT * (((IDENT * EXTYPE) list) OPT)
|	ZParaFreeType of (IDENT * (IDENT * EXTYPE OPT * Z_TM OPT) list) list
|	ZParaGivenSet of IDENT list * ((IDENT list * Z_TM) OPT)
|	ZParaConstraint of IDENT list * Z_TM
|	ZParaConjecture of IDENT OPT * IDENT list * Z_TM
|	ZParaTerm of IDENT list * Z_TM * EXTYPE OPT;
=TEX
\section{TEMPLATE FUNCTIONS}\label{TEMPLATEFUNCTIONS}
We need various functions for operating on templates.
These are collected together in this section.

=TEX
We maintain a dictionary mapping names onto templates and
the $ZFIXITY$s.
=TEX
Given a template the following function returns its first identifier component.
=SML
fun €first_tmpl_id›  (tmpl : TEMPLATE) : ID = (
	case tmpl of 
		TmplNon(id, _) => id
	|	TmplIn (_, (id, _), _) => id
	|	TmplPre((id,_), _) => id
	|	TmplPost(_, (id, _)) => id
);
=TEX
=SML
fun €last_tmpl_id›  (tmpl : TEMPLATE) : ID = (
	case tmpl of 
		TmplNon(id, Nil) => id
	|	TmplNon(_, Value(_, (_, id))) => id
	|	TmplIn (_, (id, Nil), _) => id
	|	TmplIn (_, (_, Value(_, (_, id))), _) => id
	|	TmplPre((id, Nil), _) => id
	|	TmplPre((_, Value(_, (_, id))), _) => id
	|	TmplPost(_, (id, Nil)) => id
	|	TmplPost(_, (_, Value(_, (_, id)))) => id
);
=TEX
Given a template the following function returns
the corresponding list of name-$ZFIXITY$ pairs. The list is in no
particular order, however it will always be in the same order for
two templates which differ only in the place-holder positions,
so allowing its use in the $check\_template$ function in phase 2 of \cite{DS/FMU/IED/IMP061}.
=SML
fun €tmpl_ids› (tmpl : TEMPLATE) (cl : CLASS): (ID * ZFIXITY) list = (
	let	val aux = map (fn (_, id) => (id, (ZFFThenOp, cl)));
	in	case tmpl of
			TmplNon (id, Nil) => (
			[]
		) |	TmplNon (id1, Value (stids, (_, id2))) =>(
			(id1, (ZFFBeginOp, cl)) :: (id2, (ZFFEndOp, cl)) :: aux stids
		) |	TmplIn (_, (id, Nil), _) => (
			[(id, (ZFFInOp, cl))]
		) |	TmplIn (_, (id1, Value (stids, (_, id2))), _) => (
			(id1, (ZFFPostBeginOp, cl)) :: (id2, (ZFFPreEndOp, cl)) :: aux stids
		) |	TmplPre ((id, Nil), _) => (
			[(id, (ZFFPreOp, cl))]
		) |	TmplPre ((id1, Value (stids, (_, id2))), _) => (
			(id1, (ZFFBeginOp, cl)) :: (id2, (ZFFPreEndOp, cl)) :: aux stids
		) |	TmplPost (_, (id, Nil)) =>(
			[(id, (ZFFPostOp, cl))]
		) |	TmplPost (_, (id1, Value (stids, (_, id2)))) => (
			(id1, (ZFFPostBeginOp, cl)) :: (id2, (ZFFEndOp, cl)) :: aux stids
		)
	end
);
=TEX
Given a template the following function returns
the corresponding list of stubs. The list is in in the
order of appearance in the template.
=SML
fun €tmpl_stubs› (tmpl : TEMPLATE) : STUB list = (
	let	fun aux(_, Nil) = []
		|   aux(_, (Value (stids, (stn, _)))) = (map fst stids) @ [stn];
	in	case tmpl of
			TmplNon c => (aux c
		) |	TmplIn (st1, c, st2) => (st1 :: aux c @  [st2]
		) |	TmplPre (c, st) => (aux c @ [st]
		) |	TmplPost (st, c) => (st :: aux c
		)
	end
);
=TEX
\section{FORMATTING FUNCTIONS}\label{FORMATTINGFUNCTIONS}
If errors are detected during the transformation to $ZTM$, then values
of type $PARAGRAPH$ etc. have to be printed in the diagnostic report.
The following functions are used to do this:
=TEX
=SML
fun €format_stub› StubUS = " _ "
|    format_stub StubEll = " ... ";
=TEX
=SML
fun €format_core› ( (first, Value (middle, last)) : CORE ) : string = (
	let	fun format_stub_id (stub, id) = (
			format_stub stub ^ id
		);
	in		first
		^	format_list format_stub_id middle ""
		^	format_stub_id last
	end
) | format_core ( (first, Nil) ) = first;
=TEX
\ShowBoxes
\let\crossbar=\BigTurnstile
=SML
fun €format_template› ((TmplNon core) : TEMPLATE) : string =
	" " ^ format_core core ^ " "
|   format_template (TmplIn (st1, core, st2)) =
	format_stub st1 ^ format_core core ^ format_stub st2
|   format_template (TmplPre (core, st)) =
	format_core core ^ format_stub st
|   format_template (TmplPost (st, core)) =
	format_stub st ^ format_core core;
=TEX
=SML
fun €format_z_in_op› (ZLogInOp± : Z_LOG_IN_OP) : string = "±"
|   format_z_in_op (ZLogInOp≤ : Z_LOG_IN_OP) = "≤"
|   format_z_in_op (ZLogInOp¥ : Z_LOG_IN_OP) = "¥"
|   format_z_in_op (ZLogInOp§ : Z_LOG_IN_OP) = "§"
|   format_z_in_op (ZLogInOpSemi : Z_LOG_IN_OP) = ";";
=TEX
=SML
fun €format_sch_in_op› (Pipe : SCH_IN_OP) = ">>"
|   format_sch_in_op (Filter : SCH_IN_OP) = "˘"
|   format_sch_in_op (Comp : SCH_IN_OP) = "ª";
=TEX
=SML
fun €format_sch_pre_op› (Pre : SCH_PRE_OP) = "pre"
|   format_sch_pre_op (Delta : SCH_PRE_OP) = "Ñ"
|   format_sch_pre_op (Xi : SCH_PRE_OP) = "ò";
=TEX
=SML
fun €format_quant› (ZQuantµ : Z_QUANT) = "µ"
|   format_quant (ZQuant∂ : Z_QUANT) = "∂"
|   format_quant (ZQuant∂â1 : Z_QUANT) = "∂â1";
=TEX
=SML
fun €format_fancy_fix›
	(format_item : 'a -> string)
	(tmpl : TEMPLATE)
	(decor : DECOR)
	(items : 'a list) = (
	let	
		val rids = rev (map fst (tmpl_ids tmpl ZClRel));
		val ids = rev (hd rids ^ decor :: tl rids);
		fun aux1 ns its = (
			(format_list
			Combinators.I
			(map (fn (a,b) => a ^ " " ^ b)(combine ns (map format_item its)))
			" ")
		);
		fun aux2 ns its = (
			(format_list
			Combinators.I
			(map (fn (a,b) => a ^ " " ^ b)(combine (map format_item its) ns))
			" ")
		);
	in	case tmpl of
			TmplNon _ => (
				hd ids ^ aux2 (tl ids) items
		) |	TmplIn _ => (
				format_item (hd items)  ^ aux1 ids (tl items)
		) |	TmplPre _ => (
				aux1 ids items
		) |	TmplPost _ => (
				aux2 ids items
		)
	end
	handle (Fail _) => fail "format_fancy_fix" 79001 []
);
=TEX
The following function formats a $PRED$. It marks the $Error$ alternative
by prefixing the erroneous sub-term with `$<?>$' and postfixing it with
a newline. Since none of the other alternatives can cause a newline to
appear in the string, the output may safely be truncated after this
newline if desired.
=SML
fun €format_pred› (pred : PRED) : string = (
	case pred of
			PredQuantifier (q, decl, Value pred1, pred2) =>
			format_quant q ^ format_decl decl ^ " | "
			^ format_pred pred1 ^ " ∑ " ^ format_pred pred2
	|	PredQuantifier (q, decl, Nil, pred2) =>
			format_quant q ^ format_decl decl ^ " ∑ " ^ format_pred pred2
	|	PredLet (eqdefs, pred) =>
			format_list format_eq_def eqdefs "," ^ format_pred pred
	|	PredLogInOp (pred1, rator, pred2) =>
			format_pred pred1 ^ format_z_in_op rator ^ format_pred pred2
	|	PredNot pred => "≥ " ^ format_pred pred
	|	PredSchInOp (pred1, rator, pred2) =>
			format_pred pred1 ^ format_sch_in_op rator ^ format_pred pred2
	|	PredSchPreOp (rator, pred) =>
			format_sch_pre_op rator ^ format_pred pred
	|	PredSchemaHiding (pred, preds) =>
			format_pred pred ^ "\\[" ^ format_list format_pred preds ", " ^ "]"
	|	PredMu body => "Õ " ^ format_decl_bar_pred_dot_pred body
	|	PredLambda body => "Ã " ^ format_decl_bar_pred_dot_pred body
	|	PredFancyFix (tmpl, decor, args) =>
			format_fancy_fix
			(fn ps => format_list format_pred ps ", ")
			 tmpl decor args
	|	PredCrossProduct preds => format_list format_pred preds " ∏ "
	|	PredPow pred => " " ^ format_pred pred
	|	PredApplication (pred1, pred2) => format_pred pred1 ^ " " ^ format_pred pred2
	|	PredTheta pred => "  " ^ format_pred pred
	|	PredSelection (pred1, pred2) =>  format_pred pred1 ^ "." ^ format_pred pred2
	|	PredIdDec (id, decor) => id ^ " " ^ decor
	|	PredQuotation _ => "<term-quotation>"
	|	PredPlaceHolder st => format_stub st
	|	PredNumber n => string_of_int n
	|	PredString s => "\"" ^ s ^ "\""
	|	PredTuple preds => "(" ^ format_list format_pred preds ", " ^ ")"
	|	PredSetDisplay preds  => "{" ^ format_list format_pred preds ", " ^ "}"
	|	PredSeqDisplay preds  => "ß" ^ format_list format_pred preds ", " ^ "¢"
	|	PredSetComp body => "{" ^ format_decl_bar_pred_dot_pred body ^ "}"
	|	PredHorizSchema (decl, predopt) =>
			"[" ^ format_decl_bar_pred_dot_pred(decl, predopt, Nil) ^ "]"
	|	PredGenInst preds => "[" ^ format_list format_pred preds ", " ^ "]"
	|	PredRenameList renames =>
			"["
		^	format_list
			(fn (pred1, pred2) => format_pred pred1 ^ " / " ^ format_pred pred2)
			renames
			", "
		^	"]"
	|	PredBracketed (pred, decor) => "(" ^ format_pred pred ^ ")" ^ decor
)
and €format_decl› (decs : DECL) : string = (
	let	fun format_dec (preds, Nil) =  format_list format_pred preds ", "
		|   format_dec (preds, Value pred2) =
			format_list format_pred preds ", "
			 ^ " : " ^ format_pred pred2;
	in	format_list format_dec decs "; "
	end
)
=TEX
=SML
and €format_eq_def› ((pred1, pred2) : EQ_DEF) : string = (
	format_pred pred1 ^ " ¶ " ^ format_pred pred2
)
=TEX
=SML
and €format_decl_bar_pred_dot_pred›
	(body : DECL * (PRED OPT) * (PRED OPT))
	: string = (
	case body of
		(decl, Value pred1, Value pred2) =>
			format_decl decl ^ " | " ^ format_pred pred1 ^ " ∑ " ^ format_pred pred2
	|	(decl, Nil, Value pred) =>
			format_decl decl ^ " ∑ " ^ format_pred pred
	|	(decl, Value pred, Nil) =>
			format_decl decl ^ " | " ^ format_pred pred
	|	(decl, Nil, Nil) =>
			format_decl decl
);
=TEX
=SML
fun €format_class› ((ZClFun n) : CLASS) : string = "fun " ^ string_of_int n
|   format_class  (ZClGen n) = "gen " ^ string_of_int n
|   format_class  (ZClRel) = "rel";
=TEX
=SML
fun €format_fixity› ((cl, tmpls) : FIXITY) : string = (
	format_class cl ^ " " ^ format_list format_template tmpls ", "
);
=TEX
=SML
fun €format_general_term› ((pred1, Value pred2) : GENERAL_TERM) : string = (
	format_pred pred1 ^ " & " ^ format_pred pred2
) | format_general_term (pred1, Nil) = format_pred pred1;
=TEX
=SML
fun €format_abb_def› (ADEqDef eqdef : ABB_DEF) : string = format_eq_def eqdef
=SMLLITERAL
|   format_abb_def (ADSchemaBox (pred1, decl, Value pred2)) = (
	"  " ^ format_pred pred1 ^ "¸" ^ format_decl decl ^ " ˜ " ^ format_pred pred2 ^ " à"
) | format_abb_def (ADSchemaBox (pred, decl, Nil)) = (
	"ˇ " ^ format_pred pred ^ " ¸ " ^ format_decl decl ^ " à"
);
=TEX
=SML
fun €format_free_type_def› (ftd : FREE_TYPE_DEF) : string = (
	let	fun aux (pred, preds) = (
			format_pred pred ^ " ::= " ^
			format_list format_pred preds " | "
		);
	in 	format_list aux ftd " & "
	end
);
=TEX
=SML
fun €format_ax_box› ((preds as _::_, decl, Value pred) : AX_BOX) : string = (
=SMLLITERAL
	"ù[ " ^ format_list format_pred preds ", " ^ " ]ú " ^
	format_decl decl ^ " ˜ " ^ format_pred pred ^ " à"
) | format_ax_box ([], decl, Value pred) = (
	"πZAX"  ^ format_decl decl ^ " ˜ " ^ format_pred pred ^ " à"
) | format_ax_box ((preds as _::_, decl, Nil) : AX_BOX) = (
	"ù[ " ^ format_list format_pred preds ", " ^ " ]ú " ^
	format_decl decl ^ " à"
) |  format_ax_box ([], decl, Nil) = (
	"πZAX"  ^ format_decl decl ^ " à"
);
=TEX
=SML
fun €format_conjecture› ((Value id, pred) : CONJECTURE) : string = (
	id ^ " Ù " ^ format_pred pred
) | format_conjecture (Nil, pred) = (
	"Ù " ^ format_pred pred
);

=SML
fun €format_paragraph› (para : PARAGRAPH) : string = (
	case para of
		ParFixity f => format_fixity f
	|	ParGeneralTerm gt => format_general_term gt
	|	ParAbbDef ad => format_abb_def ad
	|	ParFreeTypeDef ftd => format_free_type_def ftd
	|	ParAxBox ab => format_ax_box ab
	|	ParConjecture c => format_conjecture c
);
=TEX
Formatting functions for $Z\_TM$ etc. follow:
=SML
fun €format_ident› ((tmp, d) : IDENT) : string = (
	format_template tmp ^ d
);
=TEX
=SML
fun €format_ident_list› idl = (
	case idl of
		[] => ""
	|	_ => " [" ^ format_list format_ident idl ", " ^ "] "
);
=TEX
=SML
fun €format_zdec› (dec : Z_DEC) = (
	case dec of
		ZDec (idl, tm, _) => (format_list format_ident idl ", ")^" : "^(format_ztm tm)
	|	ZSchemaDec (tm, _) => format_ztm tm
)
=TEX
=SML
and €format_zdec_list› (decl : Z_DEC list) = (
	case decl of
	[] => ""
	|_ => format_list format_zdec decl "; "
)
=TEX
=SML
and €format_zschtext› (sch as (dl, Value tm, _) : Z_SCH_TEXT) = (
	(format_list format_zdec dl "; ")^" | "^(format_ztm tm)
) | format_zschtext (sch as (dl, Nil, _)) = (
	format_list format_zdec dl "; "
)
=TEX
=SML
and €format_eqdef› (eqdef as (id, tm)) = (format_ident id)^" ¶ "^(format_ztm tm)
=TEX
=SML
and €format_ztm› (tm : Z_TM) : string = (
	case tm of
		ZTmß¢ (_, tml) => "ß"^(format_list format_ztm tml ",")^"¢"
	|	ZTmSetd (_, tml) => "{"^(format_list format_ztm tml ",")^"}"
	|	ZTmSeta1 sch => "{"^(format_zschtext sch)^"}"
	|	ZTmSeta2 (sch,tm) => "{"^(format_zschtext sch)^"∑"^(format_ztm tm)^"}"
	|	ZTm tm => "set "^(format_ztm tm)
	|	ZTmTuple tml => "("^(format_list format_ztm tml ", ")^")"
	|	ZTm∏ tml => (format_list format_ztm tml " ∏ ")
	|	ZTm  (tm, d) => "  "^(format_ztm tm)^d
	|	ZTmSelâT (tm, i) => (format_ztm tm)^"."^(string_of_int i)
	|	ZTmSelâB (tm, id) => (format_ztm tm)^"."^(format_ident id)
	|	ZTmApp (tm1, tm2) => (format_ztm tm1)^" "^(format_ztm tm2)
	|	ZTmFancyApp ((n, d), ZTmTuple tml) => (
			format_fancy_fix format_ztm n d tml)
	|	ZTmFancyApp ((n, d), tm) => (format_ident (n,d))^" "^(format_ztm tm)
	|	ZTmÃ (sch, tm) => "Ã "^(format_zschtext sch)^"∑ "^(format_ztm tm)
	|	ZTmÕ1 sch => "Õ "^(format_zschtext sch)
	|	ZTmÕ2 (sch, tm) => "Õ "^(format_zschtext sch)^"∑ "^(format_ztm tm)
	|	ZTmTruth true => "true"
	|	ZTmTruth false => "false"
	|	ZTmLogInOpâF (inop, tm1, tm2) => (format_ztm tm1)^(
			case inop of
			ZLogInOp± => " ± "
			|ZLogInOp≤ => " ≤ "
			|ZLogInOp¥ => " ¥ "
			|ZLogInOp§ => " § "
			|ZLogInOpSemi => ";"
			)^(format_ztm tm2)
	|	ZTmQuantâF (q, sch, tm) => (
			case q of
			ZQuantµ => "µ"	|ZQuant∂ => "∂"	|ZQuant∂â1 => "∂â1"
			)^(format_zschtext sch)^" ∑ "^(format_ztm tm)
	|	ZTm≥âF tm => "≥ "^(format_ztm tm)
	|	ZTmSchemaPred tm => format_ztm tm
	|	ZTmHorizSchema sch => "["^(format_zschtext sch)^"]"
	|	ZTmDecor (tm, d) => (format_ztm tm)^d
	|	ZTmPre tm => "pre "^(format_ztm tm)
	|	ZTm≥âS tm => "≥ "^(format_ztm tm)
=TEX
=SML
	|	ZTmLogInOpâS (inop, tm1, tm2) => (format_ztm tm1)^(
			case inop of
			ZLogInOp± => " ± "
			|ZLogInOp≤ => " ≤ "
			|ZLogInOp¥ => " ¥ "
			|ZLogInOp§ => " § "
			|ZLogInOpSemi => "; "
			)^(format_ztm tm2)
	|	ZTm˘ (tm1, tm2) => (format_ztm tm1)^" ˘ "^(format_ztm tm2)
	|	ZTmHide (tm, idl) => (format_ztm tm)^"\\ ("^
			(format_list format_ident idl ", ")^")"
	|	ZTmQuantâS (q, sch, tm) => (
			case q of
			ZQuantµ => "µ "	|ZQuant∂ => "∂ "	|ZQuant∂â1 => "∂â1 "
			)^(format_zschtext sch)^" ∑ "^(format_ztm tm)

	|	ZTmÑ tm => "Ñ "^(format_ztm tm)
	|	ZTmò tm => "ò "^(format_ztm tm)
	|	ZTmEq (tm1, tm2) => (format_ztm tm1)^" = "^(format_ztm tm2)
	|	ZTmç (tm1, tm2) => (format_ztm tm1)^" ç "^(format_ztm tm2)
	|	ZTmª (tm1, tm2) => (format_ztm tm1)^" ª "^(format_ztm tm2)
	|	ZTmPipe (tm1, tm2) => (format_ztm tm1)^" >> "^(format_ztm tm2)
	|	ZTm˙ n => string_of_int n
	|	ZTmString s => "\""^s^"\""
	|	ZTmConstrained (tm1, tm2) => (format_ztm tm1)^" ∫ "^(format_ztm tm2)
	|	ZTmLVar (id, _, tml) => (format_ident id)^(
			case tml of
			[] => ""
			|_ => "["^(format_list format_ztm tml ",")^"]"
			)
	|	ZTmGVar (id, _, tml) => (format_ident id)^(
			case tml of
			[] => ""
			|_ => "["^(format_list format_ztm tml ",")^"]"
			)
=TEX
=SML
	|	ZTmLet (eqdefl, tm) => "let "^(format_list format_eqdef eqdefl ", ")^"∑ "
							^(format_ztm tm)
	|	ZTmRename (tm, ididl) => (format_ztm tm)^(
			case ididl of
			[] => ""
			|_ => " ["^(format_list (fn (id1, id2) => (format_ident id1)^"/"^
				(format_ident id2)) ididl ", ")^"]"
			)
	|	ZTmBracketed tm => "("^(format_ztm tm)^")"
	|	ZTmQuotation holterm => (string_of_term holterm)
);
=TEX
=SML
fun €format_zparafreetype› (id : IDENT, idotml : (IDENT * EXTYPE OPT * Z_TM OPT) list) : string = (
let	fun aux (id, oty, otm) =
		(format_ident id)^(
			case otm of
			Nil => ""
			|Value tm => " "^(format_ztm tm));
in
	(format_ident id)^" ::= "^(format_list aux idotml " | ")
end);
=TEX
=SML
fun €format_zpara› (p : Z_PARA) : string = (
=SMLLITERAL
	case p of
	ZParaAbbDef (id, idl, tm, oty) =>
		(format_ident id)^(format_ident_list idl)
			^" ¶ "^(format_ztm tm)
	|ZParaSchBox (id, idl, sch as (decl, otm, _), oty) =>
		"ˇ"^(format_ident id)^(format_ident_list idl)^"¸"^
		(format_zdec_list decl)^(
			case otm of
			Nil => "à"
			|Value tm => "˜"^(format_ztm tm)^"à"
		)
	|ZParaAxDes (idl, sch as (decl, otm, _), _) =>
		"@ZAX"^(format_ident_list idl)^
		(format_zdec_list decl)^(
			case otm of
			Nil => "∞"
			|Value tm => "˜"^(format_ztm tm)^"∞"
		)
	|ZParaFreeType ftl => (format_list format_zparafreetype ftl " & ")
	|ZParaGivenSet (idl, oidltm) =>
		(format_ident_list idl)^(
			case oidltm of
			Nil => ""
			|Value (idl', tm) => (format_ident_list idl')^" & "^(format_ztm tm)
		)
	|ZParaConstraint (idl, tm) =>
		(format_ident_list idl)^(format_ztm tm)
	|ZParaConjecture (oid, idl, tm) =>
		(case oid of
		Nil => ""
		|Value id => (format_ident id)^" "
		)^(format_ident_list idl)^" ?Ù "^(format_ztm tm)
	|ZParaTerm (idl, tm, oty) =>
		"Ò"^(format_ident_list idl)^(format_ztm tm)^"Æ"
	|ZParaFixity fix => (
		case fix of
		(ZClFun i, tmpl) => "fun "^(string_of_int i)^" "^
			(format_list format_template tmpl ", ")
		|(ZClRel, tmpl) => "rel "^(format_list format_template tmpl ", ")
		|(ZClGen i, tmpl) => "gen "^(string_of_int i)^" "^
			(format_list format_template tmpl ", ")
		)
);
=TEX
\section{THE TEMPLATE CACHE}
In this section we define the cache in which the Z fixity information
is held. We also define the
functions which read and write this cache.
=TEX
=SML
val zfixity_info_cache : (ZFIXITY * (TEMPLATE list)) E_DICT ref = ref initial_e_dict;
=TEX
=SML
fun €get_zfixity_info› (id : ID) : (ZFIXITY * (TEMPLATE list)) OPT = (
	e_lookup id (!zfixity_info_cache)
);
=TEX
$template\_checks$ makes the checks on a template to be added to the
cache.
=SML
fun €cache_zfixity_info› (cltmpl as (cl, tmpl) : CLASS * TEMPLATE) :  unit  = (
	let	fun mapper (id, zfix) = (
			zfixity_info_cache
			:=
			e_enter
			id
			(case e_lookup id (!zfixity_info_cache) of
				Nil => (zfix, [tmpl])
			|	Value (zfix, tmpls) => (zfix, (tmpl :: tmpls)))
			(!zfixity_info_cache)
		);
	in	map mapper (tmpl_ids tmpl cl); ()
	end
);
=TEX
=SML
fun €uncache_zfixity_info› (cltmpl as (cl, tmpl) : CLASS * TEMPLATE) :  unit  = (
	let	fun mapper (id, zfix) = (
			case e_lookup id (!zfixity_info_cache) of
				Nil => ()
			|	Value (zfix, [tmpl]) => (
					zfixity_info_cache :=
					e_delete id (!zfixity_info_cache)
			) |	Value (zfix, tmpls) => (
					zfixity_info_cache :=
					e_enter id (zfix, tmpls less tmpl)(!zfixity_info_cache)
			)
		);
	in	map mapper (tmpl_ids tmpl cl); ()
	end
);
=TEX
=SML
fun €clear_cache› (():unit) : unit = (
	zfixity_info_cache := initial_e_dict
);
=TEX
\section{THEORY DATABASE ACCESS FUNCTIONS}
The symbol table module uses a single slot in the theory user data 
under the key ``icl'z'' to hold the declarations which apply
to the theory. The declarations are held as a fairly direct encoding
of a list of $DECL$s.

In this section we define the functions we use to fetch and store the
lists of $USER\_DATUM$s belonging to the symbol table held in theories.
=SML
val ud_key = "icl'z";
=TEX
The following function is the only place at which we pass an unknown
theory name to the kernel interface.
=SML
fun fetch_sym_tab_data (thy : string) : USER_DATUM list = (
	if thy mem theory_names () orelse thy = "-"
	then	case get_user_datum thy ud_key handle Fail _ => UD_Int(0, []) of
			(UD_Int(0, uds)) => uds
		|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>thy]
	else	fail "fetch_sym_tab_data" 79014 [fn()=>thy]
);
=TEX
The theory name argument to $store\_sym\_tab\_datum$ and
$delete\_sym\_tab\_datum$ are only used in error messages.
=SML
fun store_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "store_sym_tab_datum" 79001 [get_current_theory_name]);
	in 	set_user_datum(ud_key, UD_Int(0, ud :: uds))
	end
);
=TEX
We sometimes need to delete entries. $delete\_sym\_tab\_datum$
does this (and does nothing if the entry to be deleted is not there).
=SML
local

fun list_eq eq (a :: x) (b :: y) = eq (a,b) andalso list_eq eq x y
| list_eq eq [] [] = true
| list_eq eq _ _ = false;

fun ud_equals (UD_Term (tm,udl):USER_DATUM) : USER_DATUM -> bool = (fn ud2 =>
	case ud2 of
	UD_Term (tm1,udl1) => (tm =$ tm1) andalso list_eq (uncurry ud_equals) udl udl1
	| _ => false
) | ud_equals (UD_Type(ty,udl)) = (fn ud2 =>
	case ud2 of
	UD_Type (ty1,udl1) => (ty =: ty1) andalso list_eq (uncurry ud_equals) udl udl1
	| _ => false
) | ud_equals (UD_String(st,udl)) = (fn ud2 =>
	case ud2 of
	UD_String (st1,udl1) => (st = st1) andalso list_eq (uncurry ud_equals) udl udl1
	| _ => false
) | ud_equals (UD_Int(n,udl)) = (fn ud2 =>
	case ud2 of
	UD_Int (n1,udl1) => (n = n1) andalso list_eq (uncurry ud_equals) udl udl1
	| _ => false
);
in
fun delete_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>"-"]);
		val ud_equals_ud = ud_equals ud;
	in 	set_user_datum(ud_key, UD_Int(0, uds drop ud_equals_ud))
	end
);
end;
=TEX
\subsection{Encoding and Decoding Functions}
First of all we give the encoding for templates.
We encode the templates as strings using the template formatting routine
but discarding the extra spaces that gives at the beginning and end
and replacing the three dots by semicolons to save a little space.
=SML
fun €string_of_template› (tmpl : TEMPLATE) : string = (
	let	val bits = words (format_template tmpl);
		val bits' = map (fn "..." => ";" | x => x) bits;
	in	format_list Combinators.I bits' " "
	end
);
=TEX
=SML
fun €stub_of_string› (s : string) : STUB = (
	case s of
		";" => StubEll
	|	"_" => StubUS
	|	_ => fail "stub_of_string" 79001 []
);
=TEX
=SML
fun €core_of_strings› ( (s :: ss) : string list) : CORE = (
	let	fun aux (s1 :: s2 :: more) = (stub_of_string s1, s2) :: aux more
		|   aux [s1] = fail "core_of_strings"  79001 []
		|   aux [] = [];
	in	(	s,
			case rev(aux ss) of
				[] => Nil
			|	stid::stids => Value (rev stids, stid))
	end
) | core_of_strings [] = fail "core_of_strings"  79001 [];
=TEX

=SML
fun €template_of_string› ( s : string) : TEMPLATE = (
	let	val (h, r) = (
			case words s of
				";" :: more => (";", more)
			|	"_" :: more => ("_", more)
			|	other => ("", other));
		val (l, c) = (
			case rev r of
					";" :: more => (";", rev more)
			|	"_" :: more => ("_", rev more)
			|	other => ("", r));
		val core = core_of_strings c;
	in	case (h, l) of
			("", "") => TmplNon core
		|	(_, "") => TmplPost(stub_of_string h, core)
		|	("", _) => TmplPre(core, stub_of_string l)
		|	(_, _) => TmplIn (stub_of_string h, core, stub_of_string l)
	end
);
=TEX
=SML
fun €int_of_class› (ZClFun i : CLASS) : int = 3 * i
|   int_of_class (ZClGen i : CLASS) : int = 3 * i + 1
|   int_of_class (ZClRel : CLASS) : int = 2;
=TEX
=SML
fun €class_of_int› (i : int) : CLASS = (
	case i mod 3 of
		0 => ZClFun (i div 3)
	|	1 => ZClGen (i div 3)
	|	_ => ZClRel
);
=TEX
=SML
fun €encode_zfixity_info› ((cl, tmpl): CLASS * TEMPLATE) : USER_DATUM = (
	UD_Int(int_of_class cl, [UD_String(string_of_template tmpl, [])])
);
=TEX
=SML
fun €decode_zfixity_info› (thy : string) (ud : USER_DATUM)
		: CLASS * TEMPLATE = (
	(case ud of
		UD_Int(c, [UD_String(t, [])]) => (class_of_int c, template_of_string t)
	|	_ => fail "decode_decl" 79001 [fn()=> thy])
	handle Fail _ => fail "decode_decl" 79001 [fn()=> thy]
);
=TEX
\subsection{Theory Access Functions}
The following function is used to extract fixity records from
a theory. 
=SML
fun €get_zfixity_infos› (thy : string) : (CLASS * TEMPLATE) list = (
	(map (decode_zfixity_info thy) (fetch_sym_tab_data thy))
	handle ex => reraise ex "get_zfixity_infos"
);
=TEX
The following function is used to add fixity records to
the current theory. 
=SML
fun €store_zfixity_info› (cltmpl : CLASS * TEMPLATE) : unit = (
	store_sym_tab_datum (encode_zfixity_info cltmpl)
);
=TEX
The following function is used to remove a fixity record from
the current theory. 
=SML
fun €unstore_zfixity_info› (cltmpl : CLASS * TEMPLATE) : unit = (
	delete_sym_tab_datum (encode_zfixity_info cltmpl)
);
=TEX
=SML

=TEX
\subsection{Update Functions}
When a fixity paragraph is encountered
by the paragraph processor \cite{DS/FMU/IED/DTD049}, the function
$set\_zfixity\_info$ is used to enter the fixity information in the
cache and the theory database. It is necessary to make the checks
on the uniqueness of the template identifiers
from \cite{DS/FMU/IED/DEF007} at this point.
These checks amount to saying that

\begin{enumerate}
\item
the new fixity entry must not
change the $ZFIXITY$ value for any identifier
\item
if there is
already a fixity entry for an identifier with
$ZFIXITY$ other than $ZFFThenOP$, then the existing fixity entry must
be identical with the new one.
\item
the first and last identifiers in the template must be distinct and
must each be different from every other identifier in the template.
\end{enumerate}

If the template is invalid the function raises an exception, otherwise
it returns true iff. the entry is already present.

(Note that the local function check checks $f$ and $c$ rather more often
than is strictly necessary, however this considerably simplifies the code,
which is highly unlikely to be critical for performance.)
=SML
fun template_check ((cl, tmpl) : CLASS * TEMPLATE) : bool = (
	let	val idfixes = tmpl_ids tmpl cl;
		val ids = map fst idfixes;
		val ids_entries = combine idfixes (map get_zfixity_info ids);
		fun moan t = (
			fail "cache_zfixity_info" 79010
			[fn()=>format_template tmpl, fn()=>format_template t]
		);
		fun check ((id, (fx, cl)), Value ((f, c), ts)) = (
			let	fun aux t = (
					if fx <> f orelse
					(fx <> ZFFThenOp andalso (t <> tmpl orelse cl <> c))
					then	fail "set_zfixity_info" 79012
						[fn()=>id,
						 fn()=>format_template tmpl,
						 fn()=>format_template t]
					else fx <> ZFFThenOp
				);
			in	any ts aux
			end
		) | check _ = false;
	in	any  ids_entries check
	end
);
=TEX
=SML
fun €set_zfixity_info› ((cl, tmpls) : CLASS * (TEMPLATE list)) : unit = (
	let	val cltmpls_todo = (map (fn tmpl => (cl, tmpl)) tmpls)
			drop template_check;
	in	map cache_zfixity_info cltmpls_todo;
		map store_zfixity_info cltmpls_todo; ()
	end
);
=TEX
=SML
fun €delete_zfixity_info› (cltmpl as (cl, tmpl) : CLASS * TEMPLATE) : unit = (
	if cltmpl mem (get_zfixity_infos "-")
	then	(
		uncache_zfixity_info cltmpl;
		unstore_zfixity_info cltmpl
	) else	fail "delete_zfixity_info" 79013
		[fn()=>format_template tmpl, fn()=>format_class cl]
);
=TEX
\section{HANDLING CONTEXT CHANGES}
When a theory is opened, we rebuild the cache from scratch, this being
by far the most straightforward scheme.
=TEX
$cache\_theory$ loads the symbol table information
contained in a theory and all its ancestors into the caches:
=SML
fun €cache_theory› (current : string) : unit = (
	let	fun aux1 thy (cltmpl :: more) = (
			(if (template_check cltmpl)
				handle Fail msg =>
					(comment "Z User Interface" 79002
					[fn()=>thy, fn()=>get_message msg]; true)
			then ()
			else cache_zfixity_info cltmpl);
			aux1 thy more
		) | aux1 _ [] = ();
		fun aux2 thy = aux1 thy (get_zfixity_infos thy);
	in	clear_cache();
		map aux2 (get_ancestors current);
		()
	end
);
=TEX
Of the various classes of kernel state change, identified in
\cite{DS/FMU/IED/DTD012}, only $open\_theory$, $new\_parent$ and the
operations which introduce or
delete types or constants are currently of relevance
to the symbol table module.
We declare our interest in kernel state changes using
the interface defined in \cite{DS/FMU/IED/DTD012}:
=SML
val _ = on_kernel_state_change
	(fn	OpenTheory (current, (_, _)) => cache_theory current
	|	NewParent _ => cache_theory(get_current_theory_name())
	|	_ => ()
);
=TEX
\section{EPILOGUE}
=SML
end; (* of structure ZUserInterfaceSupport *)
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}


