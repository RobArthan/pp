% usr011S.doc   %Z% $Date$ $Revision$ $RCSfile$
% this should form a Chapter of the document
% Solutions to Exercises
=TEX

The section numbers of this chapter correspond to those in the Exercises chapter.

The source script for this chapter is the file usr011S.doc.
This may be converted into an ML script using $docsml$, or alternatively the formal text can be entered interactively by cut-and-paste from the source document into a command tool in which {\Product} is running.


\section{The Z Predicate Calculus}
=SML
repeat drop_main_goal;
open_theory "z_library";
set_pc "z_language";
open_theory "z_exercises_1";
=TEX
=SML
set_merge_pcs ["'z_fc", "z_language"];
=TEX
\subsection{Forward Propositional Proofs}

Solutions to forward proof exercises.

=SML
(* (a) *)
val ex1a_thm1 = asm_rule Ò a¥bÆ;
val ex1a_thm2 = asm_rule Ò b¥cÆ;
val ex1a_thm3 = asm_rule Ò ê(a)Æ;
val ex1a_thm4 = ¥_elim ex1a_thm1 ex1a_thm3;
val ex1a_thm = ¥_elim ex1a_thm2 ex1a_thm4;

save_thm ("ex1a_thm", ex1a_thm);

(* (b) *)
val ex1b_thm1 =
 ¥_elim (asm_rule Ò a¥b¥cÆ)(asm_rule Ò ê(a)Æ);
val ex1b_thm =
 ¥_elim ex1b_thm1 (asm_rule Ò ê(b)Æ);

save_thm ("ex1b_thm", ex1b_thm);

(* (c) *)
val ex1c_thm = ¥_intro Ò ê(a)Æ ex1b_thm;

save_thm ("ex1c_thm", ex1c_thm);

(* (d) *)
val ex1d_thm1 = ¥_intro Ò ê(b)Æ ex1c_thm;
val ex1d_thm = ¥_intro Ò a ¥ b ¥ cÆ ex1d_thm1;

save_thm ("ex1d_thm", ex1d_thm);

=TEX

\subsection{Goal Oriented Propositional Proofs}

For each of the exercises either:
=GFT SML
a (prove_tac[]);
=TEX
or:
=GFT SML
a (REPEAT z_strip_tac);
=TEX
will complete the proof in one step.

To get an understanding of how this is done the proofs may be obtained in steps by manually repeating:
=GFT SML
a z_strip_tac;
=TEX
or:
=GFT SML
a step_strip_tac;
=TEX

We show here just one example of proof by stripping, you may work through as many other examples as you like.
=SML
setlg "*2.02" PM2;
=TEX

The results may be proven automatically as follows:

=SML
map prove_and_store PM2;
map prove_and_store PM3;
map prove_and_store PM4;
map prove_and_store PM5;
=TEX

Though technically these may be considered forward proofs since they use $prove_rule$, prove rule itself uses $prove_tac$, and so the difference between completely automatic forward and backward proof is insignificant.

%***4***
\subsection{Forward Predicate Calculus Proofs}

Forward proof using elementary rules is less convenient in Z because of the extra complications arising when quantifiers are eliminated or introduced.
=SML
open_theory "z_exercises_1";
set_merge_pcs ["z_language", "'z_numbers"];

(* 1(a) *)
val ex1a_thm1 = z_µ_elim Ò 0Æ z_Ó_≥_plus1_thm;
(* 1(b) *)
val ex1b_thm = z_µ_elim Ò x*xÆ z_Ó_≥_plus1_thm;

(* 2 *)
val ex2_thm = prove_rule [z_º_trans_thm]
	Ò i º j ± j º k ¥ i º kÆ ;
	
(* note that:
z_µ_elim Ò(i¶i∫˙, j¶j∫˙, k¶k∫˙)Æ z_º_trans_thm; 
doesn't do the job.
*)

(* 3(a) *)
val ex3a_thm = prove_rule [z_Ó_≥_plus1_thm]
	Ò≥ 0 + 1 = 0Æ;
(* 3(b) *)
val ex3b_thm = prove_rule [z_Ó_≥_plus1_thm]
	Ò x * x ç Ó ¥ ≥ x * x + 1 = 0Æ;

(* 4(a) *)
val ex4a_thm = prove_rule[z_≥_less_thm]
	Ò≥ 0 < 1 § 1 º 0Æ;
(* 4(b) *)
val ex4b_thm = prove_rule[z_º_trans_thm]
	Òµ n:˙ ∑ 3 º x * x ± x * x º n ¥ 3 º nÆ;

(* 5(a) *)
val ex5a_thm = prove_rule[z_º_clauses]
	Òµ i, m, n :˙∑ i + m º i + n § m º nÆ;
(* 5(b) *)
val ex5b_thm = prove_rule[z_º_clauses]
	Òµ m, i, n :˙∑ i + m º i + n § m º nÆ;
=TEX

\subsection{Goal Oriented Predicate Calculus Proof}

=IGN
a contr_tac;
a z_strip_tac;
a strip_tac;
a step_strip_tac;
a (prove_tac[]);
a (asm_prove_tac[]);
a (z_spec_asm_tac Ò Æ Ò Æ);
a (z_spec_nth_asm_tac 1 Ò Æ);
a (all_asm_fc_tac[]);
=TEX
These proofs are also conducted automatically.
=SML
set_pc "z_language";
open_theory "z_exercises_1";
map prove_and_store PM9;
map prove_and_store PM10;
map prove_and_store PM10b;
map prove_and_store PM11;
=TEX

The problems in PM11b cannot be solved by $prove_tac$.
=SML
set_goal([], lassoc3 PM11b "*11.32");
=GFT ProofPower output
...
(* ?Ù *)  Ò[Y]((µ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y))
             ¥ (µ x, y : Y ∑ ∆ (x, y))
             ¥ (µ x, y : Y ∑ Ÿ (x, y)))Æ
...
=SML
a contr_tac;
=GFT ProofPower output
...
(*  4 *)  Òµ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y)Æ
(*  3 *)  Òµ x, y : Y ∑ ∆ (x, y)Æ
(*  2 *)  Òx ç YÆ
(*  1 *)  Òy ç YÆ

(* ?Ù *)  ÒŸ (x, y)Æ
...
=SML
a(z_spec_nth_asm_tac 5 Ò(x ¶ x, y ¶ y)Æ);
=GFT ProofPower output
...
(*  6 *)  Òµ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y)Æ
(*  5 *)  Òµ x, y : Y ∑ ∆ (x, y)Æ
(*  4 *)  Òx ç YÆ
(*  3 *)  Òy ç YÆ
(*  2 *)  Ò≥ Ÿ (x, y)Æ
(*  1 *)  Ò≥ ∆ (x, y)Æ

(* ?Ù *)  ÒfalseÆ
...
=SML
a(z_spec_nth_asm_tac 5 Ò(x ¶ x, y ¶ y)Æ);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=SML
save_pop_thm("*11.32");
=TEX
=SML
setlg "*11.45" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x', y ¶ y')Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x', y ¶ y')Æ);
save_pop_thm("*11.45");
=TEX
=SML
setlg "*11.54" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
save_pop_thm("*11.54");
=SML
setlg "*11.55" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
save_pop_thm("*11.55");
=TEX
=SML
setlg "*11.6" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm("*11.6");
=TEX
=SML
setlg "*11.62" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x, y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm("*11.62");
=TEX
Though the resolution prover failed to prove the above proofs, forward chaining suffices.

To show this we first delete the theorems from the theory:
=SML
map delete_thm (map fst PM11b);
=TEX
Then we write a function to do the proofs using a simpler approach:
=SML
fun prove_and_store2 (key, term) = save_thm (key,
	tac_proof (([],term),
	(contr_tac
		THEN (all_asm_fc_tac[])
		THEN (all_asm_fc_tac[]))));
		
map prove_and_store2 PM11b;
=TEX

% ***5***
\subsection{Rewriting}
\subsubsection{Rewriting with the Subgoal Package}

No solutions.

% ***6***
\subsubsection{Combining Forward and Backward Proof}

=SML
set_pc "z_library";
=TEX

\begin{enumerate}
\item :
=SML
set_goal([],Ò x + y = y + xÆ);
a (rewrite_tac[]);
save_pop_thm "X6.1";
=TEX
\item :
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
a (rewrite_tac[z_plus_assoc_thm]);
save_pop_thm "X6.2";
=TEX
\item :
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
a (rewrite_tac[z_plus_assoc_thm1]);
save_pop_thm "X6.3";
=TEX
\item :
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
a (rewrite_tac[z_µ_elim Ò(i¶y,j¶z,k¶x)Æ
	z_plus_assoc_thm1]);
save_pop_thm "X6.4";
=TEX
\item :
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
a (rewrite_tac[z_µ_elim Ò xÆ z_plus_order_thm]);
save_pop_thm "X6.5";
=TEX
\end{enumerate}
\subsection{Stripping}
No solutions.

\section{Expressions and Schema Expressions}
=SML
open_theory "z_exercises_2";
set_pc "z_library";
=TEX
\subsection{Expressions}

Group ZE1 are all provable automatically in proof context $z_library$.
=SML
map prove_and_store ZE1;
=TEX
Group ZE2 are provable automatically in proof context $z_library_ext$.
=SML
push_pc "z_library_ext";
map prove_and_store ZE2;
pop_pc();
=TEX
Group ZE3 results are not automatically provable.
=SML
(* ZE3.1 *)
set_goal ([], Ò(Ãx:˙∑ x+1) 3 = 4Æ);
a (conv_tac (MAP_C z_¬_conv));
a (rewrite_tac[]);
save_pop_thm "ZE3.1";
=TEX
=SML
(* ZE3.2 *)
set_goal ([], Ò{(1,2), (3,4)} 3 = 4Æ);
a (z_app_eq_tac);
a (rewrite_tac []);
a (REPEAT strip_tac);
save_pop_thm "ZE3.2";
=TEX
=SML
(* ZE3.3 *)
set_goal ([], Ò(1,~2) ç (abs _) ¥ abs 1 = ~2Æ);
a (REPEAT strip_tac);
a (strip_asm_tac (z_get_spec Ò(abs _)Æ));
a (asm_tac (prove_rule[] Ò 1 ç ˙Æ));
a (all_fc_tac [z_≠_ç_rel_§_app_eq_thm]);
save_pop_thm "ZE3.3";
=TEX
=SML
(* ZE3.4 *)
set_goal ([], Òµ i,j:˙∑ (i,j) ç (abs _) ¥ abs i = jÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (z_get_spec Ò(abs _)Æ));
a (asm_tac (prove_rule[] Ò i ç ˙Æ));
a (all_fc_tac [z_≠_ç_rel_§_app_eq_thm]);
save_pop_thm "ZE3.4";
=TEX
=SML
(* ZE3.5 *)
set_goal ([], Òµi:˙∑ abs i ç ÓÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (z_get_spec Ò(abs _)Æ));
a (asm_tac (prove_rule[] Ò i ç ˙Æ));
a (all_fc_tac [z_fun_ç_clauses]);
save_pop_thm "ZE3.5";
=TEX
=SML
(* ZE3.6 *)
set_goal ([], Ò(Õx:˙ | x=3 ∑ x*x) = 9Æ);
a (strip_asm_tac (z_µ_elim Ò9Æ (z_Õ_rule Ò(Õx:˙ | x=3 ∑ x*x)Æ)));
(* *** Goal "1" *** *)
a (var_elim_nth_asm_tac 2);
a (asm_ante_tac Ò≥ 3 * 3 = 9Æ THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (z_spec_nth_asm_tac 1 Ò3Æ);
a (asm_ante_tac Ò≥ 3 * 3 = 9Æ THEN rewrite_tac[]);
save_pop_thm "ZE3.6";
=TEX
=SML
(* ZE3.7 *)
set_goal ([], Ò25 ç {y:˙ ∑ y*y}Æ);
a (rewrite_tac[]);
a (z_∂_tac Ò5Æ);
a (rewrite_tac[]);
save_pop_thm "ZE3.7";
=TEX
=SML
(* ZE3.8 *)
set_goal ([], Ò(a ∏ b ∏ c) = (d ∏ e ∏ f) ¥ (a ∏ b) = (d ∏ e) ≤ (c ° f) = ö Æ);
a (PC_T1 "z_library_ext" rewrite_tac[]);
a (contr_tac THEN all_asm_fc_tac[]);
a (z_spec_nth_asm_tac 6 Ò(x1 ¶ x1, x2 ¶ x2, x3 ¶ x1')Æ);
a (z_spec_nth_asm_tac 6 Ò(x1 ¶ x1, x2 ¶ x2, x3 ¶ x1')Æ);
save_pop_thm "ZE3.8";
=TEX
(* ZE3.9 *)
set_goal ([], Ò[X,Y](µ p:  (X ∏ Y)∑
			(µ x:X; y:Y∑ (x,y) ç p)
		§	(µ z:X ∏ Y∑ z ç p))Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (z_spec_nth_asm_tac 3 Ò(x ¶ z.1, y ¶ z.2)Æ);

% a (conv_tac (ONCE_MAP_C z_selât_intro_conv));
 a (conv_tac (ONCE_MAP_C z_selt_intro_conv)); (??)

a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (z_spec_nth_asm_tac 3 Ò(x,y)Æ);
save_pop_thm "ZE3.9";
=TEX
=SML
(* ZE3.10 *)
set_goal ([], Ò[File | people = {}] = {File | people = {}}Æ);
a (PC_T "z_library_ext" z_strip_tac);
a (prove_tac[]);
a (z_∂_tac Ò(age ¶ x1, people ¶ x2)Æ);
a (asm_rewrite_tac[]);
save_pop_thm "ZE3.10";
=TEX
=SML
(* ZE3.11 *)
set_goal ([], Òßa,b¢ = ßc,d¢ ¥ a=c ± b=dÆ);
a (PC_T "z_library_ext" contr_tac);
(* *** Goal "1" *** *)
a (z_spec_nth_asm_tac 2 Ò(x1 ¶ 1, x2 ¶ a)Æ);
(* *** Goal "2" *** *)
a (z_spec_nth_asm_tac 2 Ò(x1 ¶ 2, x2 ¶ b)Æ);
save_pop_thm "ZE3.11";
=TEX
=SML
(* ZE3.12 *)
set_goal ([], Òßa,b¢ = ßd,e¢ ¥ ßb,d¢ = ße,a¢Æ);
a (PC_T "z_library_ext" z_strip_tac);
a (z_spec_nth_asm_tac 1 Ò(x1 ¶ 1, x2 ¶ a)Æ);
a (z_spec_nth_asm_tac 2 Ò(x1 ¶ 2, x2 ¶ b)Æ);
a (asm_rewrite_tac[]);
save_pop_thm "ZE3.12";
=TEX

\subsection{Propositional Schema Calculus}

These results can be solved by stripping in a manner analogous to the analogous propositional result.
=SML
set_pc "z_language";
=TEX
We illustrate the proofs by showing one example in detail.
=SML
setlg "*2.03" SCPM2;
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Ò((Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ Pab)Æ
...
=TEX
In the following proof two main things are taking place.

Firstly, the logical schema operators are being transformed into the corresponding propositional logic operators, and secondly, the stripping of these follows the normal course.

In addition there is some switching taking place between schemas-as-predicates, in which there is an implicit binding membership assertion, and explicit statements about membership of bindings.

The basic proof facilities are provided for the binding membership assertions since these are more general than the schema-as-predicate format, and also are likely to arise from the latter when substitutions take place.
At present the stripping facilities will revert to the schema-as-predicate format at the top level of the conclusion or assumptions if possible.
=SML
a z_strip_tac;
=GFT ProofPower output
..
(* ?Ù *)  Ò(a ¶ a, b ¶ b, c ¶ c) ç (Pab ¥ ≥ Qac)
             ¥ (a ¶ a, b ¶ b, c ¶ c) ç (Qac ¥ ≥ Pab)Æ
...
=TEX
The first step has transformed the implication to a logical implication.
=SML
a z_strip_tac;
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ


(* *** Goal "1" *** *)

(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ
...
=TEX
When the implication is stripped the left hand side is completely stripped into the assumptions.
This results in a case split.
Note here that the negation in the assumption is now a logical negation.
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  Ò(a ¶ a, c ¶ c) ç Qac ¥ (a ¶ a, b ¶ b) ç (≥ Pab)Æ
...
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò(≥ Pab)Æ
...
=TEX
Here we are not quite finished because the negation in the assumption is a logical negation while the one in the conclusion is a schema-negation.
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò≥ (a ¶ a, b ¶ b) ç PabÆ
...
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò≥ PabÆ
...
=TEX
Now the conclusion really is the same as the assumption.
=SML
a z_strip_tac;
=GFT ProofPower output
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ
...
=TEX
The proof of this subgoal contains nothing new so we do it in one step.
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=TEX
An alternative approach is to eliminate the schema operations first by rewriting, and then complete the proof by stripping.
=SML
setlg "*2.03" SCPM2;
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Ò((Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ Pab)Æ
...
=TEX
Since all the membership conversions are built in to the proof context $z_language$ rewriting with no parameters suffices to eliminate the schema operators.
This would not be the case if the schema expression had not been used as a predicate, since the implicit membership statement is essential to trigger the transformations in this context.
=SML
a (rewrite_tac[]);
=TEX
This yeilds the syntactically similar goal in which all operators are logical operators rather than schema operators.
=GFT ProofPower output
...
(* ?Ù *)  Ò(Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ PabÆ
...
=TEX
A cleaner proof is now obtained by stripping.
=SML
a z_strip_tac;
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  ÒQac ¥ ≥ PabÆ


(* *** Goal "1" *** *)

(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  ÒQac ¥ ≥ PabÆ
...
=TEX
We will not complete the proof, which proceeds as the previous one but with a number of steps omitted.
=SML
drop_main_goal();
=TEX
Many other examples are provided for you to play through if you wish.
The following script demonstrates that the system can prove them all automatically.
=SML
map prove_and_store SCPM2;
map prove_and_store SCPM3;
map prove_and_store SCPM4;
map prove_and_store SCPM5;
=TEX

\subsection{Schema Calculus Quantification}
=SML
open_theory "z_exercises_2";
set_pc "z_library";
=TEX
=SML
map prove_and_store SCPM9;
map prove_and_store SCPM10;
=TEX

\section{Paragraphs}
First set the context.
=SML
open_theory "z_exercises_3";
set_pc "z_library";
=TEX

\subsection{Axiomatic Descriptions and Generics}

\begin{enumerate}
\item \ 

=SML
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
πZ
fun  if _ then _ else _
∞

\item \ 

ù[X]úúúúúúúúúúúúúúúúúúúúúúú
‹	if _ then _ else _ : (BOOL ∏ X ∏ X) ≠ X
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ e1,e2:X∑ 
‹	if true then e1 else e2 = e1
‹ ±	if false then e1 else e2 = e2
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\item \ 

First specialise the specification to $U$ to simplify using it as a rewrite.
=SML
val if_then_else_thm = z_gen_pred_elim [ÒUÆ]
	(z_get_spec Ò(if _ then _ else _ ) Æ);
=GFT ProofPower output
val if_then_else_thm = Ù (if _ then _ else _) ç BOOL ∏ U ∏ U ≠ U
    ± (µ e1, e2 : U
      ∑ if true then e1 else e2 = e1 ± if false then e1 else e2 = e2) : THM
=TEX
The required result can then be obtained directly using $rewrite_conv$:
=SML
rewrite_conv [if_then_else_thm] Òif 2>1 then 1 else 0Æ;
=GFT ProofPower output
val it = Ù if 2 > 1 then 1 else 0 = 1 : THM   
=TEX
Adding $if_then_else_thm$ to any rewrite will result in elimination of conditionals.

\end{enumerate}

\subsection{Consistency Proofs}

Set the flags appropriately:
=SML
set_flags [("z_type_check_only", false), ("z_use_axioms", false)];
=TEX
Now define the required global variable:
πZAX
num:Ó
˜
 4 º num º 50
∞
Push the consistency goal, and tidy it up:
=SML
z_push_consistency_goal ÒnumÆ;
=TEX
Supply a witness:
=SML
a (z_∂_tac Ò10Æ);
=TEX
Then complete the proof by rewriting:
=SML
a (rewrite_tac[]);
=TEX
Then save the consistency goal.
=SML
save_consistency_thm ÒnumÆ (pop_thm());
=TEX
Now set up the required goal:
=SML
set_goal([], Ò num æ 0Æ);
=TEX
Strip the specification of $num$ into the assumptions:
=SML
a (strip_asm_tac (z_get_spec ÒnumÆ));
=GFT ProofPower output
...
(* *** Goal "" *** *)

(*  3 *)  Ò0 º numÆ
(*  2 *)  Ò4 º numÆ
(*  1 *)  Ònum º 50Æ

(* ?Ù *)  Ònum æ 0Æ
..
=TEX
Then rewrite the conclusion of the goal with the assumptions.
=SML
a (asm_rewrite_tac []);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=SML
save_pop_thm "ZP1";
=TEX

\subsection{Reasoning using Schema Definitions}

Before beginning the proofs we extract the specifications for the relevant constants and bind them to an ML name:

=SML
val specs = (map z_get_spec [ÒOP2Æ, ÒOPÆ, ÒSTATEÆ]);
=TEX
\begin{enumerate}
\item
First set the goal:
=SML
set_goal ([], Ò pre OP § i? æ 0Æ);
=GFT ProofPower output
...
(* ?Ù *)  Ò(pre OP) § i? æ 0Æ
...
=TEX
Now rewrite with the specifications of $OP$ and $STATE$:
=SML
a (rewrite_tac (map z_get_spec [ÒOPÆ, ÒSTATEÆ]));
=GFT ProofPower output
...
(* ?Ù *)  Ò(∂ r' : U ∑ true) ± 0 º i? § 0 º i?Æ
...
=SML
a (REPEAT strip_tac);
=GFT ProofPower output
...
(*  1 *)  Ò0 º i?Æ

(* ?Ù *)  Ò∂ r' : U ∑ trueÆ
=SML
a (z_∂_tac ÒxÆ);
=GFT ProofPower output
...
(* ?Ù *)  Òx ç U ± true ± trueÆ
...
=SML
a contr_tac;
save_pop_thm "ZP2";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

\item
=SML
save_thm ("ZP3", (prove_rule specs
	Ò (pre OP ¥ pre OP2) ± (pre OP ± OP2 ¥ OP)Æ));
=GFT
val it = Ù ((pre OP) ¥ (pre OP2)) ± ((pre OP) ± OP2 ¥ OP) : THM   
=TEX
\end{enumerate}


\section{The Z ToolKit}

=SML
open_theory "z_exercises_4";
=TEX
\subsection{Sets}

All of the examples in this theory can be proven automatically by the system.

First we set up an appropriate context:

=SML
set_pc "z_sets_ext";
=TEX

\subsubsection{Results Provable by Stripping}

%We display one case in full:

=SML
map prove_and_store Z1;
map prove_and_store Z2;
map prove_and_store Z3;
map prove_and_store Z3b;
=TEX

\subsection{Relations}

=SML
open_theory "z_exercises_4";
set_pc "z_rel_ext";
=TEX

=SML
map prove_and_store Z4;
map prove_and_store Z5;
=TEX

=SML
map prove_and_store Z5b;
=TEX
=SML
(* "Z5c.1" *)
set_goal([], Ò[X,Y,Z] (µx:U;g:U∑ g ç X ﬂ Y ± x ç dom g ¥ (x, g x) ç g)Æ);
a (REPEAT z_strip_tac);
a (POP_ASM_T (PC_T1 "z_library_ext" strip_asm_tac));
a (all_fc_tac [z_fun_app_clauses]);
a (asm_rewrite_tac[]);
val Z5c1 = save_pop_thm "Z5c.1";
=TEX
The following proof make use of the previous result (Z5c1).
=SML
(* "Z5c.2" *)
set_goal([], Ò[X,Y,Z] x ç dom g ± g x ç dom f ± g ç X ﬂ Y
	± f ç Y ﬂ Z ¥ (f o g)(x) = f(g(x))Æ);
set_pc "z_library";
a (REPEAT z_strip_tac);
a(z_app_eq_tac);
a (PC_T1 "z_library_ext" rewrite_tac[]);
a (REPEAT z_strip_tac);
a (lemma_tac Òg x = yÆ);
(* *** Goal "1.1" *** *)
a (all_fc_tac [z_fun_app_clauses]);
(* *** Goal "1.2" *** *)
a (all_fc_tac [z_fun_app_clauses]);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (z_∂_tac Òg xÆ);
a (REPEAT z_strip_tac);
(* *** Goal "2.1" *** *)
a (all_fc_tac [Z5c1]);
(* *** Goal "2.2" *** *)
a (all_fc_tac [Z5c1]);
save_pop_thm("Z5c.2");
=TEX
\vfill
=SML
set_pc "z_rel_ext";
map prove_and_store Z6;
map prove_and_store Z6b;
map prove_and_store Z7;
map prove_and_store Z8;
map prove_and_store Z8b;
map prove_and_store Z9;
=TEX
\vfill

=SML
setlg "Z9b.1" Z9b;
a(prove_tac[z_ç_first_thm]);
(* *** Goal "1" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x1, y))Æ);
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(y ¶ (x.2))Æ);
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 1);
a(conv_tac(ONCE_MAP_C z_tuple_intro_conv));
a(asm_rewrite_tac[]);
save_pop_thm "Z9b.1";
=TEX
\vfill
=SML
setlg "Z9b.2" Z9b;
a(prove_tac[z_ç_second_thm]);
(* *** Goal "1" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x, x1))Æ);
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x.1))Æ);
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 1);
a(conv_tac(ONCE_MAP_C z_tuple_intro_conv));
a (asm_rewrite_tac[]);
save_pop_thm "Z9b.2";
=TEX
\vfill
=SML
map prove_and_store Z10;
=TEX
Embedded quantifiers:
=SML
setlg "Z10b.1" Z10b;
a(contr_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
a(z_spec_nth_asm_tac 3 Ò(y ¶ y')Æ);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm "Z10b.1";
=TEX
Application problems:
=SML
set_pc "z_library_ext";
setlg "Z10b.2" Z10b;
a (REPEAT strip_tac);
a(z_app_eq_tac);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 11 Ò(x1 ¶ x,x2 ¶ f_a')Æ);
a(z_spec_nth_asm_tac 11 Ò(x ¶ x, y1 ¶ f_a', y2 ¶ f_a)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 4 Ò(y ¶ f_a)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 4 Ò(y ¶ y')Æ);
(* *** Goal "4" *** *)
a(lemma_tac Òf x = yÆ);
(* *** Goal "4.1" *** *)
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
a(z_spec_nth_asm_tac 11 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
(* *** Goal "4.2" *** *)
a(swap_nth_asm_concl_tac 2);
a(asm_rewrite_tac[]);
save_pop_thm "Z10b.2";
=TEX
Application problems:
=SML
setlg "Z10b.3" Z10b;
a(contr_tac);
a(swap_nth_asm_concl_tac 1);
a(z_app_eq_tac);
a(contr_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 3 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 8 Ò(x1 ¶ x,x2 ¶ f_a')Æ);
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, y1 ¶ f_a', y2 ¶ f_a)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(lemma_tac Òg x = yÆ);
(* *** Goal "3.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "3.2" *** *)
a(swap_nth_asm_concl_tac 4);
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(lemma_tac Òg x = yÆ);
(* *** Goal "4.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "4.2" *** *)
a(swap_nth_asm_concl_tac 4);
a(asm_rewrite_tac[]);
save_pop_thm "Z10b.3";
=TEX


=SML
map prove_and_store Z11;
=TEX
Number of resolution steps, caused by reasoning about membership,
rather than sets:
=SML
setlg "Z11b.1" Z11b;
a contr_tac;
a(z_spec_nth_asm_tac 2 Ò(x1 ¶ x1, x2 ¶ x2)Æ);
a(z_spec_nth_asm_tac 6 Ò(S ¶ S)Æ);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x1', x2 ¶ x2')Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y')Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 6 Ò(S ¶ S)Æ);
(* *** Goal "3.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(z_spec_nth_asm_tac 7 Ò(x1 ¶ x1', x2 ¶ x2')Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y')Æ);
(* *** Goal "3.3" *** *)
a(z_spec_nth_asm_tac 3 Ò(y ¶ y)Æ);
save_pop_thm "Z11b.1";
=TEX

\subsection{Functions}


=SML
setlg "Z12.1" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.1";
=TEX
=SML
setlg "Z12.2" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.2";
=TEX
=SML
setlg "Z12.3" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.3";
=TEX
=SML
setlg "Z12.4" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.4";
=TEX
=SML
setlg "Z12.5" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.5";
=TEX
=SML
setlg "Z12.6" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.6";
=TEX
=SML
setlg "Z12a.1" Z12a;
a (EVERY[
	rewrite_tac[],
	REPEAT strip_tac,
	z_app_eq_tac,
	REPEAT strip_tac,
	all_asm_fc_tac[],
	all_asm_fc_tac[]]);
save_pop_thm "Z12a.1";
=TEX
Too many resolution steps, some equational reasoning:
=SML
setlg "Z12b.1" Z12b;
a(contr_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
a(z_spec_nth_asm_tac 3 Ò(y ¶ x)Æ);
a(swap_nth_asm_concl_tac 6);
a(asm_rewrite_tac[]);
save_pop_thm "z12b.1";
=TEX
Too many resolution steps:
=SML
setlg "Z12b.2" Z12b;
a (contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 7 Ò(x1 ¶ y1, x2 ¶ y2)Æ);
(* *** Goal "1.1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ x)Æ);
(* *** Goal "1.2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ x)Æ);
(* *** Goal "1.3" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_ASM_FC_T rewrite_tac [get_thm "-" "Z12a.1"]);
(* *** Goal "2" *** *)
a(lemma_tac Òy = f x1Æ);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 14 Ò(x1 ¶ x1, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 14 Ò(x ¶ x1, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "2.2" *** *)
a(swap_nth_asm_concl_tac 9);
a(asm_rewrite_tac[]);
a(contr_tac);
a(z_spec_nth_asm_tac 13 Ò(x1 ¶ x1, x2 ¶ f x2)Æ);
a(z_spec_nth_asm_tac 11 Ò(x ¶ Òf x2Æ, y1 ¶ x1, y2 ¶ x2)Æ);
a(lemma_tac Òy' = f x2Æ);
(* *** Goal "2.2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 17 Ò(x1 ¶ x2, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 17 Ò(x ¶ x2, y1 ¶ f_a, y2 ¶ y')Æ);
(* *** Goal "2.2.2" *** *)
a(swap_nth_asm_concl_tac 12);
a(asm_rewrite_tac[]);
save_pop_thm "Z12b.2";
=TEX

No solutions for Z12.b3 to Z12b.7.



\subsection{Numbers and Finiteness}
=SML
open_theory "z_exercises_4";
set_pc "z_library";
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
=TEX
πZAX
‹	ì : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸
‹	µn:Ó∑
‹	ì 0 = 0
‹±	ì (n+1) = (n + 1) + ì n
∞
=SML
set_goal([],Ò µn: Ó∑ (ì n) * 2 = n * (n+1)Æ);
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Òµ n : Ó ∑ ì n * 2 = n * (n + 1)Æ
...
=SML
a (strip_asm_tac (z_get_spec Ò(ì)Æ));
=GFT ProofPower output
...
(*  2 *)  Òì ç Ó ≠ ÓÆ
(*  1 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ

(* ?Ù *)  Òµ n : Ó ∑ ì n * 2 = n * (n + 1)Æ
...
=SML
a (z_strip_tac THEN PC_T1 "z_language" rewrite_tac[]);
=GFT ProofPower output
...
(*  2 *)  Òì ç Ó ≠ ÓÆ
(*  1 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ

(* ?Ù *)  Òn ç Ó ¥ ì n * 2 = n * (n + 1)Æ
...
=SML
a z_Ó_induction_tac;
=GFT ProofPower output
...
(* *** Goal "2" *** *)

(*  4 *)  Òì ç Ó ≠ ÓÆ
(*  3 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ
(*  2 *)  Ò0 º iÆ
(*  1 *)  Òì i * 2 = i * (i + 1)Æ

(* ?Ù *)  Òì (i + 1) * 2 = (i + 1) * ((i + 1) + 1)Æ


(* *** Goal "1" *** *)

(*  2 *)  Òì ç Ó ≠ ÓÆ
(*  1 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ

(* ?Ù *)  Òì 0 * 2 = 0 * (0 + 1)Æ
=SML
(* *** Goal "1" *** *)
a (z_spec_nth_asm_tac 1 Ò0Æ
	THEN asm_rewrite_tac[]);
=GFT ProofPower output
...
Current goal achieved, next goal is:
...
=SML
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
=GFT ProofPower output
...
(*  6 *)  Òì ç Ó ≠ ÓÆ
(*  5 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ
(*  4 *)  Ò0 º iÆ
(*  3 *)  Òì i * 2 = i * (i + 1)Æ
(*  2 *)  Òì 0 = 0Æ
(*  1 *)  Òì (i + 1) = (i + 1) + ì iÆ

(* ?Ù *)  Òì (i + 1) * 2 = (i + 1) * ((i + 1) + 1)Æ
=SML
a (asm_rewrite_tac[]);
=GFT ProofPower output
...
(* ?Ù *)  Ò((i + 1) + ì i) * 2 = (i + 1) * ((i + 1) + 1)Æ
...
=SML
a (asm_rewrite_tac[z_times_plus_distrib_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Ò(i * 2 + 2) + i * i + i = ((i * i + i) + i + 1) + i + 1Æ
...
=SML
a (rewrite_tac [z_µ_elim Òi*iÆ z_plus_order_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Ò(i * 2 + 2) + i = (i + i + 1) + i + 1Æ
...
=SML
a (rewrite_tac [z_µ_elim ÒiÆ z_plus_order_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Òi * 2 + 2 = i + i + 2Æ
...
=SML
a (rewrite_tac[z_plus_assoc_thm1]);
=GFT ProofPower output
...
(* ?Ù *)  Òi * 2 = i + iÆ
=SML
a (pure_rewrite_tac
	[prove_rule []Ò2 = 1 + 1Æ,
	z_times_plus_distrib_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Òi * 1 + i * 1 = i + iÆ
=SML
a (rewrite_tac[]);
=GFT ProofPower output
...
Current and main goal achieved
=SML
save_pop_thm "ZNum.1";
=TEX
=SML
set_pc "z_library_ext";
setlg "ZNum.2" ZNum;
=GFT ProofPower output
(* ?Ù *)  Òµ x, y : ˙ ∑ x º y ¥ 0 .. x Ä 0 .. yÆ
=TEX
First expand $..$.
=SML
a(rewrite_tac[z_get_spec Ò(_.._)Æ] THEN REPEAT strip_tac);
=GFT ProofPower output
...
(*  3 *)  Òx º yÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º xÆ

(* ?Ù *)  Òx1 º yÆ
...
=TEX
Then forward chain using transitivity of $º$.
=SML
a(all_fc_tac[z_º_trans_thm]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
=SML
save_pop_thm "ZNum.2";
=TEX
=SML
setlg "ZNum.3" ZNum;
=GFT ProofPower output
...
(* ?Ù *)  Òµ x, y : ˙ ∑ ≥ x º y ¥ 0 .. y Ä 0 .. x - 1Æ
...
=TEX
First expand the definition of $..$.
=SML
a(rewrite_tac[z_get_spec Ò(_.._)Æ] THEN REPEAT strip_tac);
=GFT ProofPower output
...
(*  3 *)  Òy < xÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º yÆ

(* ?Ù *)  Òx1 º x + ~ 1Æ
...
=TEX
Now forward chain on the assumptions using $z_º_less_trans_thm$ to obtain $x1 < x$.
=SML
a(all_fc_tac[z_º_less_trans_thm]);
=GFT ProofPower output
...
(*  1 *)  Òx1 < xÆ

(* ?Ù *)  Òx1 º x + ~ 1Æ
...
=TEX
Now it is necessary to expand the definition of $<$ in the last assumption.
$POP_ASM_T$ takes out the last assumption and feeds it into the $THM_TACTIC$ supplied to it.
In this case we rewrite the assumption with the specification of $<$ before passing it to $ante_tac$, which inserts in into the conclusion of the goal as the $ante$cedent of a new implication.
=SML
a(POP_ASM_T (ante_tac o pure_once_rewrite_rule[z_get_specÒ(_<_)Æ]));
=GFT ProofPower output
...
(* ?Ù *)  Òx1 + 1 º x ¥ x1 º x + ~ 1Æ
...
=TEX
In the absence of support for linear arithmetic this obvious result must be proven by transforming the conclusion of the goal until the various built in cancellation laws apply.
First we move everything to the left hand side of the inequalities using $z_º_º_0_thm$.
=SML
a(once_rewrite_tac[z_º_º_0_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Ò(x1 + 1) + ~ x º 0 ¥ x1 + ~ (x + ~ 1) º 0Æ
...
=TEX
Now we use $z_plus_order_thm$ to reorder the arithmetic expressions and $z_minus_thm$ to provide some cancellation results which have been omitted from the proof context.
=SML
a(rewrite_tac[z_µ_elim Ò~ xÆ z_plus_order_thm, z_minus_thm]);
=GFT ProofPower output
...
Current and main goal achieved
...
=SML
save_pop_thm "ZNum.3";
=TEX
