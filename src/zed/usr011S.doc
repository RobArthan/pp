=IGN
********************************************************************************
usr011S.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% usr011S.doc   %Z% $Date: 2005/09/09 11:24:33 $ $Revision: 1.18 $ $RCSfile: usr011S.doc,v $
% this should form a Chapter of the document
% Solutions to Exercises
=TEX

The section numbers of this chapter correspond to those in the Exercises chapter.

The source script for this chapter is the file usr011S.doc.
This may be converted into an ML script using $docsml$, or alternatively the formal text can be entered interactively by cut-and-paste from the source document into a command tool in which {\Product} is running.


\section{The Z Predicate Calculus}
\subsection{Forward Propositional Proofs}

Solutions to forward proof exercises.

%   context setting point 1

=SML
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc "z_library";
=TEX



=SML
(* (a) *)
val ex1a_thm1 = asm_rule Ò a¥bÆ;
val ex1a_thm2 = asm_rule Ò b¥cÆ;
val ex1a_thm3 = asm_rule Ò ê(a)Æ;
val ex1a_thm4 = ¥_elim ex1a_thm1 ex1a_thm3;
val ex1a_thm = ¥_elim ex1a_thm2 ex1a_thm4;

save_thm ("ex1a_thm", ex1a_thm);

(* (b) *)
val ex1b_thm1 =
 ¥_elim (asm_rule Ò a¥b¥cÆ)(asm_rule Ò ê(a)Æ);
val ex1b_thm =
 ¥_elim ex1b_thm1 (asm_rule Ò ê(b)Æ);

save_thm ("ex1b_thm", ex1b_thm);

(* (c) *)
val ex1c_thm = ¥_intro Ò ê(a)Æ ex1b_thm;

save_thm ("ex1c_thm", ex1c_thm);

(* (d) *)
val ex1d_thm1 = ¥_intro Ò ê(b)Æ ex1c_thm;
val ex1d_thm = ¥_intro Ò a ¥ b ¥ cÆ ex1d_thm1;

save_thm ("ex1d_thm", ex1d_thm);

=TEX

\subsection{Goal Oriented Propositional Proofs}

For each of the exercises either:
=GFT SML
a (prove_tac[]);
=TEX
or:
=GFT SML
a (REPEAT z_strip_tac);
=TEX
will complete the proof in one step.

To get an understanding of how this is done the proofs may be obtained in steps by manually repeating:
=GFT SML
a z_strip_tac;
=TEX
or:
=GFT SML
a step_strip_tac;
=TEX

We show here just one example of proof by stripping, you may work through as many other examples as you like.
=SML
setlg "*2.02" PM2;
=TEX

The results may be proven automatically as follows:

=SML
map prove_and_store PM2;
map prove_and_store PM3;
map prove_and_store PM4;
map prove_and_store PM5;
=TEX

Though technically these may be considered forward proofs since they use $prove_rule$, prove rule itself uses $prove_tac$, and so the difference between completely automatic forward and backward proof is insignificant.

%***4***
\subsection{Forward Predicate Calculus Proofs}

Forward proof using elementary rules is less convenient in Z because of the extra complications arising when quantifiers are eliminated or introduced.

% context setting point 2

=SML
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc "z_library";


(* 1(a) *)
val ex1a_thm1 = z_µ_elim Ò 0Æ z_Ó_≥_plus1_thm;
(* 1(b) *)
val ex1b_thm = z_µ_elim Ò x*xÆ z_Ó_≥_plus1_thm;

(* 2 *)
val ex2_thm = prove_rule [z_º_trans_thm]
	Ò i º j ± j º k ¥ i º kÆ ;
	
(* note that:
z_µ_elim Ò(i¶i∫˙, j¶j∫˙, k¶k∫˙)Æ z_º_trans_thm;
doesn't do the job.
*)

(* 3(a) *)
val ex3a_thm = prove_rule [z_Ó_≥_plus1_thm]
	Ò≥ 0 + 1 = 0Æ;
(* 3(b) *)
val ex3b_thm = prove_rule [z_Ó_≥_plus1_thm]
	Ò x * x ç Ó ¥ ≥ x * x + 1 = 0Æ;

(* 4(a) *)
val ex4a_thm = prove_rule[z_≥_less_thm]
	Ò≥ 0 < 1 § 1 º 0Æ;
(* 4(b) *)
val ex4b_thm = prove_rule[z_º_trans_thm]
	Òµ n:˙ ∑ 3 º x * x ± x * x º n ¥ 3 º nÆ;

(* 5(a) *)
val ex5a_thm = prove_rule[z_º_clauses]
	Òµ i, m, n :˙∑ i + m º i + n § m º nÆ;
(* 5(b) *)
val ex5b_thm = prove_rule[z_º_clauses]
	Òµ m, i, n :˙∑ i + m º i + n § m º nÆ;
=TEX

\subsection{Goal Oriented Predicate Calculus Proof}

=IGN
a contr_tac;
a z_strip_tac;
a strip_tac;
a step_strip_tac;
a (prove_tac[]);
a (asm_prove_tac[]);
a (z_spec_asm_tac Ò Æ Ò Æ);
a (z_spec_nth_asm_tac 1 Ò Æ);
a (all_asm_fc_tac[]);
=TEX
These proofs are also conducted automatically.

% context setting point 3  (there is none)

=SML
map prove_and_store PM9;
map prove_and_store PM10;
map prove_and_store PM10b;
map prove_and_store PM11;
=TEX

The problems in PM11b cannot be solved by $prove_tac$.
=SML
set_goal([], lassoc3 PM11b "*11.32");
=GFT ProofPower output
...
(* ?Ù *)  Ò[Y]((µ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y))
             ¥ (µ x, y : Y ∑ ∆ (x, y))
             ¥ (µ x, y : Y ∑ Ÿ (x, y)))Æ
...
=SML
a contr_tac;
=GFT ProofPower output
...
(*  4 *)  Òµ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y)Æ
(*  3 *)  Òµ x, y : Y ∑ ∆ (x, y)Æ
(*  2 *)  Òx ç YÆ
(*  1 *)  Òy ç YÆ

(* ?Ù *)  ÒŸ (x, y)Æ
...
=SML
a(z_spec_nth_asm_tac 5 Ò(x ¶ x, y ¶ y)Æ);
=GFT ProofPower output
...
(*  6 *)  Òµ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y)Æ
(*  5 *)  Òµ x, y : Y ∑ ∆ (x, y)Æ
(*  4 *)  Òx ç YÆ
(*  3 *)  Òy ç YÆ
(*  2 *)  Ò≥ Ÿ (x, y)Æ
(*  1 *)  Ò≥ ∆ (x, y)Æ

(* ?Ù *)  ÒfalseÆ
...
=SML
a(z_spec_nth_asm_tac 5 Ò(x ¶ x, y ¶ y)Æ);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit
=SML
save_pop_thm("*11.32");
=TEX
=SML
setlg "*11.45" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x', y ¶ y')Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x', y ¶ y')Æ);
save_pop_thm("*11.45");
=TEX
=SML
setlg "*11.54" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
save_pop_thm("*11.54");
=SML
setlg "*11.55" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
save_pop_thm("*11.55");
=TEX
=SML
setlg "*11.6" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm("*11.6");
=TEX
=SML
setlg "*11.62" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x, y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm("*11.62");
=TEX
Forward chaining suffices.  To show this we first delete the theorems from the theory:
=SML
map delete_thm (map fst PM11b);
=TEX
Then we write a function to do the proofs using a simpler approach:
=SML
fun prove_and_store2 (key, term) = save_thm (key,
	tac_proof (([],term),
	(contr_tac
		THEN (all_asm_fc_tac[])
		THEN (all_asm_fc_tac[]))));
		
map prove_and_store2 PM11b;
=TEX

% ***5***
\subsection{Rewriting}
\subsubsection{Rewriting with the Subgoal Package}

% context setting point 4

=SML
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc "z_library_ext";
=TEX


No solutions.

% ***6***
\subsubsection{Combining Forward and Backward Proof}

% context setting point 5

=SML
repeat drop_main_goal;
open_theory "z_exercises_1";
set_pc "z_library";


=TEX

\begin{enumerate}
\item :
=SML
set_goal([],Ò x + y = y + xÆ);
a (rewrite_tac[]);
save_pop_thm "X6.1";
=TEX
\item :
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
a (rewrite_tac[z_plus_assoc_thm]);
save_pop_thm "X6.2";
=TEX
\item :
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
a (rewrite_tac[z_plus_assoc_thm1]);
save_pop_thm "X6.3";
=TEX
\item :
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
a (rewrite_tac[z_µ_elim Ò(i¶y,j¶z,k¶x)Æ
	z_plus_assoc_thm1]);
save_pop_thm "X6.4";
=TEX
\item :
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
a (rewrite_tac[z_µ_elim Ò xÆ z_plus_order_thm]);
save_pop_thm "X6.5";
=TEX
\end{enumerate}
\subsection{Stripping}
No solutions.

\section{Expressions and Schema Expressions}

\subsection{Expressions}


% context setting point 6

=SML
repeat drop_main_goal;
open_theory "z_exercises_2";
set_pc "z_library";
=TEX

Group ZE1 are all provable automatically in proof context $z_library$.
=SML
map prove_and_store ZE1;
=TEX

% context setting point 7


Group ZE2 are provable automatically in proof context $z_library_ext$.
=SML
repeat drop_main_goal;
open_theory "z_exercises_2";
set_pc "z_language_ext" ;

map prove_and_store ZE2;
=TEX


Group ZE3 results are not automatically provable.
Thought the results are primarily about the language, they make use of definitions in the Z ToolKit and therefore need to be conducted in the proof context $z_library$.

=SML
set_pc "z_library";
=TEX
=SML
(* ZE3.1 *)
set_goal ([], Ò(Ãx:˙∑ x+1) 3 = 4Æ);
a (conv_tac (MAP_C z_¬_conv));
a (rewrite_tac[]);
save_pop_thm "ZE3.1";
=TEX
=SML
(* ZE3.2 *)
set_goal ([], Ò{(1,2), (3,4)} 3 = 4Æ);
a (z_app_eq_tac);
a (rewrite_tac []);
a (REPEAT strip_tac);
save_pop_thm "ZE3.2";
=TEX
=SML
(* ZE3.3 *)
set_goal ([], Ò(1,~2) ç (abs _) ¥ abs 1 = ~2Æ);
a (REPEAT strip_tac);
a (strip_asm_tac (z_get_spec Ò(abs _)Æ));
a (asm_tac (prove_rule[] Ò 1 ç ˙Æ));
a (all_fc_tac [z_≠_ç_rel_§_app_eq_thm]);
save_pop_thm "ZE3.3";
=TEX
=SML
(* ZE3.4 *)
set_goal ([], Òµ i,j:˙∑ (i,j) ç (abs _) ¥ abs i = jÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (z_get_spec Ò(abs _)Æ));
a (asm_tac (prove_rule[] Ò i ç ˙Æ));
a (all_fc_tac [z_≠_ç_rel_§_app_eq_thm]);
save_pop_thm "ZE3.4";
=TEX
=SML
(* ZE3.5 *)
set_goal ([], Òµi:˙∑ abs i ç ÓÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (z_get_spec Ò(abs _)Æ));
a (asm_tac (prove_rule[] Ò i ç ˙Æ));
a (all_fc_tac [z_fun_ç_clauses]);
save_pop_thm "ZE3.5";
=TEX
=SML
(* ZE3.6 *)
set_goal ([], Ò(Õx:˙ | x=3 ∑ x*x) = 9Æ);
a (strip_asm_tac (z_µ_elim Ò9Æ (z_Õ_rule Ò(Õx:˙ | x=3 ∑ x*x)Æ)));
(* *** Goal "1" *** *)
a (var_elim_nth_asm_tac 2);
a (asm_ante_tac Ò≥ 3 * 3 = 9Æ THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a (z_spec_nth_asm_tac 1 Ò3Æ);
a (asm_ante_tac Ò≥ 3 * 3 = 9Æ THEN rewrite_tac[]);
save_pop_thm "ZE3.6";
=TEX
=SML
(* ZE3.7 *)
set_goal ([], Ò25 ç {y:˙ ∑ y*y}Æ);
a (rewrite_tac[]);
a (z_∂_tac Ò5Æ);
a (rewrite_tac[]);
save_pop_thm "ZE3.7";
=TEX
=SML
(* ZE3.8 *)
set_goal ([], Ò(a ∏ b ∏ c) = (d ∏ e ∏ f) ¥ (a ∏ b) = (d ∏ e) ≤ (c ° f) = ö Æ);
a (PC_T1 "z_library_ext" rewrite_tac[]);
a (contr_tac THEN all_asm_fc_tac[]);
a (z_spec_nth_asm_tac 6 Ò(x1 ¶ x1, x2 ¶ x2, x3 ¶ x1')Æ);
a (z_spec_nth_asm_tac 6 Ò(x1 ¶ x1, x2 ¶ x2, x3 ¶ x1')Æ);
save_pop_thm "ZE3.8";
=TEX
=SML
(* ZE3.9 *)
set_goal ([], Ò[X,Y](µ p:  (X ∏ Y)∑
			(µ x:X; y:Y∑ (x,y) ç p)
		§	(µ z:X ∏ Y∑ z ç p))Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (z_spec_nth_asm_tac 3 Ò(x ¶ z.1, y ¶ z.2)Æ);

a (conv_tac (ONCE_MAP_C z_selât_intro_conv));

a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (z_spec_nth_asm_tac 3 Ò(x,y)Æ);
save_pop_thm "ZE3.9";
=TEX
=SML
(* ZE3.10 *)
set_goal ([], Ò[File | people = {}] = {File | people = {}}Æ);
a (PC_T "z_library_ext" z_strip_tac);
a (prove_tac[]);
a (z_∂_tac Ò(age ¶ x1, people ¶ x2)Æ);
a (asm_rewrite_tac[]);
save_pop_thm "ZE3.10";
=TEX
=SML
(* ZE3.11 *)
set_goal ([], Òßa,b¢ = ßc,d¢ ¥ a=c ± b=dÆ);
a (PC_T "z_library_ext" contr_tac);
(* *** Goal "1" *** *)
a (z_spec_nth_asm_tac 2 Ò(x1 ¶ 1, x2 ¶ a)Æ);
(* *** Goal "2" *** *)
a (z_spec_nth_asm_tac 2 Ò(x1 ¶ 2, x2 ¶ b)Æ);
save_pop_thm "ZE3.11";
=TEX
=SML
(* ZE3.12 *)
set_goal ([], Òßa,b¢ = ßd,e¢ ¥ ßb,d¢ = ße,a¢Æ);
a (PC_T "z_library_ext" z_strip_tac);
a (z_spec_nth_asm_tac 1 Ò(x1 ¶ 1, x2 ¶ a)Æ);
a (z_spec_nth_asm_tac 2 Ò(x1 ¶ 2, x2 ¶ b)Æ);
a (asm_rewrite_tac[]);
save_pop_thm "ZE3.12";
=TEX

\subsection{Propositional Schema Calculus}

These results can be solved by stripping in a manner analogous to the analogous propositional result.
=SML
repeat drop_main_goal;
open_theory "z_exercises_2";
set_pc "z_language";
=TEX
We illustrate the proofs by showing one example in detail.
=SML
setlg "*2.03" SCPM2;
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Ò((Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ Pab)Æ
...
=TEX
In the following proof two main things are taking place.

Firstly, the logical schema operators are being transformed into the corresponding propositional logic operators, and secondly, the stripping of these follows the normal course.

In addition there is some switching taking place between schemas-as-predicates, in which there is an implicit binding membership assertion, and explicit statements about membership of bindings.

The basic proof facilities are provided for the binding membership assertions since these are more general than the schema-as-predicate format, and also are likely to arise from the latter when substitutions take place.
At present the stripping facilities will revert to the schema-as-predicate format at the top level of the conclusion or assumptions if possible.
=SML
a z_strip_tac;
=GFT ProofPower output
..
(* ?Ù *)  Ò(a ¶ a, b ¶ b, c ¶ c) ç (Pab ¥ ≥ Qac)
             ¥ (a ¶ a, b ¶ b, c ¶ c) ç (Qac ¥ ≥ Pab)Æ
...
=TEX
The first step has transformed the implication to a logical implication.
=SML
a z_strip_tac;
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ


(* *** Goal "1" *** *)

(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ
...
=TEX
When the implication is stripped the left hand side is completely stripped into the assumptions.
This results in a case split.
Note here that the negation in the assumption is now a logical negation.
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  Ò(a ¶ a, c ¶ c) ç Qac ¥ (a ¶ a, b ¶ b) ç (≥ Pab)Æ
...
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò(≥ Pab)Æ
...
=TEX
Here we are not quite finished because the negation in the assumption is a logical negation while the one in the conclusion is a schema-negation.
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò≥ (a ¶ a, b ¶ b) ç PabÆ
...
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò≥ PabÆ
...
=TEX
Now the conclusion really is the same as the assumption.
=SML
a z_strip_tac;
=GFT ProofPower output
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ
...
=TEX
The proof of this subgoal contains nothing new so we do it in one step.
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit
=TEX
An alternative approach is to eliminate the schema operations first by rewriting, and then complete the proof by stripping.
=SML
setlg "*2.03" SCPM2;
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Ò((Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ Pab)Æ
...
=TEX
Since all the membership conversions are built in to the proof context $z_language$ rewriting with no parameters suffices to eliminate the schema operators.
This would not be the case if the schema expression had not been used as a predicate, since the implicit membership statement is essential to trigger the transformations in this context.
=SML
a (rewrite_tac[]);
=TEX
This yields the syntactically similar goal in which all operators are logical operators rather than schema operators.
=GFT ProofPower output
...
(* ?Ù *)  Ò(Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ PabÆ
...
=TEX
A cleaner proof is now obtained by stripping.
=SML
a z_strip_tac;
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  ÒQac ¥ ≥ PabÆ


(* *** Goal "1" *** *)

(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  ÒQac ¥ ≥ PabÆ
...
=TEX
We will not complete the proof, which proceeds as the previous one but with a number of steps omitted.
=SML
drop_main_goal();
=TEX
Many other examples are provided for you to play through if you wish.
The following script demonstrates that the system can prove them all automatically.
=SML
map prove_and_store SCPM2;
map prove_and_store SCPM3;
map prove_and_store SCPM4;
map prove_and_store SCPM5;
=TEX

\subsection{Schema Calculus Quantification}
=SML
open_theory "z_exercises_2";
set_pc "z_library";
=TEX
=SML
map prove_and_store SCPM9;
map prove_and_store SCPM10;
=TEX

\section{Paragraphs}
% First set the context.
% =SML
% open_theory "z_exercises_3";
% set_pc "z_library";
% =TEX

\subsection{Axiomatic Descriptions and Generics}




\begin{enumerate}
\item \
% context setting point 8

=SML
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
πZ
fun  if _ then _ else _
∞

\item \

ù[X]úúúúúúúúúúúúúúúúúúúúúúú
‹	if _ then _ else _ : (ñ ∏ X ∏ X) ≠ X
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ e1,e2:X∑
‹	if true then e1 else e2 = e1
‹ ±	if false then e1 else e2 = e2
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\item \

First specialise the specification to $É$ to simplify using it as a rewrite.
=SML
val if_then_else_thm = z_gen_pred_elim [ÒÉÆ]
	(z_get_spec Ò(if _ then _ else _ ) Æ);
=GFT ProofPower output
val if_then_else_thm = Ù (if _ then _ else _) ç ñ ∏ É ∏ É ≠ É
    ± (µ e1, e2 : É
      ∑ if true then e1 else e2 = e1 ± if false then e1 else e2 = e2) : THM
=TEX
The required result can then be obtained directly using $rewrite_conv$:
=SML
rewrite_conv [if_then_else_thm] Òif 2>1 then 1 else 0Æ;
=GFT ProofPower output
val it = Ù if 2 > 1 then 1 else 0 = 1 : THM
=TEX
Adding $if_then_else_thm$ to any rewrite will result in elimination of conditionals.

\end{enumerate}

\subsection{Consistency Proofs}

Set the flags appropriately:

% context setting point 9

=SML
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", false)];
=TEX
Now define the required global variable:
πZAX
num:Ó
˜
 4 º num º 50
∞
Push the consistency goal, and tidy it up:
=SML
z_push_consistency_goal ÒnumÆ;
=TEX
Supply a witness:
=SML
a (z_∂_tac Ò10Æ);
=TEX
Then complete the proof by rewriting:
=SML
a (rewrite_tac[]);
=TEX
Then save the consistency goal.
=SML
save_consistency_thm ÒnumÆ (pop_thm());
=TEX
Now set up the required goal:
=SML
set_goal([], Ò num æ 0Æ);
=TEX
Strip the specification of $num$ into the assumptions:
=SML
a (strip_asm_tac (z_get_spec ÒnumÆ));
=GFT ProofPower output
...
(* *** Goal "" *** *)

(*  3 *)  Ò0 º numÆ
(*  2 *)  Ò4 º numÆ
(*  1 *)  Ònum º 50Æ

(* ?Ù *)  Ònum æ 0Æ
..
=TEX
Then rewrite the conclusion of the goal with the assumptions.
=SML
a (asm_rewrite_tac []);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=SML
save_pop_thm "ZP1";
=TEX

\subsection{Reasoning using Schema Definitions}

% context setting point 10

=SML
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", false)];
=TEX

\subsubsection{Simple Pre-conditions and Refinement}

Before beginning the proofs we extract the specifications for the relevant constants and bind them to an ML name:

=SML
val specs = (map z_get_spec [ÒOP2Æ, ÒOPÆ, ÒSTATEÆ]);
=TEX

Conjecture 1:

First set the goal:
=SML
set_goal ([], Ò pre OP § i? æ 0Æ);
=GFT ProofPower output
...
(* ?Ù *)  Ò(pre OP) § i? æ 0Æ
...
=TEX
Now rewrite with the specifications of $OP$ and $STATE$:
=SML
a (rewrite_tac (map z_get_spec [ÒOPÆ, ÒSTATEÆ]));
=GFT ProofPower output
...
(* ?Ù *)  Ò(∂ r' : É ∑ true) ± 0 º i? § 0 º i?Æ
...
=SML
a (REPEAT strip_tac);
=GFT ProofPower output
...
(*  1 *)  Ò0 º i?Æ

(* ?Ù *)  Ò∂ r' : É ∑ trueÆ
=SML
a (z_∂_tac ÒxÆ);
=GFT ProofPower output
...
(* ?Ù *)  Òx ç É ± true ± trueÆ
...
=SML
a contr_tac;
save_pop_thm "ZP2";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

Conjecture 2:

=SML
save_thm ("ZP3", (prove_rule specs
	Ò (pre OP ¥ pre OP2) ± (pre OP ± OP2 ¥ OP)Æ));
=TEX

=GFT ProofPower output
val it = Ù ((pre OP) ¥ (pre OP2)) ± ((pre OP) ± OP2 ¥ OP) : THM
=TEX

\subsubsection{The Vending Machine}

=SML
repeat drop_main_goal;
open_theory "z_exercises_3";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX

πZAX
‹	price :Ó
∞
ˇVMSTATE¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stock, takings :Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇVM_operation¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑVMSTATE;
‹	cash_tendered?, cash_refunded! :Ó;
‹	bars_delivered! :Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇexact_cash¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? :Ó
˜¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? = price
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇinsufficient_cash¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? :Ó
˜¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? < price
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇsome_stock¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stock :Ó
˜¸¸¸¸¸¸¸¸¸¸
‹	stock > 0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇVM_sale¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	VM_operation
˜¸¸¸¸¸¸¸¸¸¸
‹	stock' = stock - 1;
‹	bars_delivered! = 1;
‹	cash_refunded! = cash_tendered? - price;
‹	takings' = takings + price
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇVM_nosale¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	VM_operation
˜¸¸¸¸¸¸¸¸¸¸
‹	stock' = stock;
‹	bars_delivered! = 0;
‹	cash_refunded! = cash_tendered?;
‹	takings' = takings
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

πZ
‹	VM1 ¶ exact_cash ± some_stock ± VM_sale
∞

πZ
‹	VM2 ¶ insufficient_cash ± VM_nosale
∞

πZ
‹	VM3 ¶ VM1 ≤ VM2
∞

Now for convenience we bind the various specifications to ML variables:
=SML
val [price, VMSTATE, VM_operation, exact_cash,
    insufficient_cash, some_stock, VM_sale,
    VM_nosale, VM1, VM2, VM3]
 = map z_get_spec [ÒpriceÆ,ÒVMSTATEÆ,ÒVM_operationÆ,Òexact_cashÆ,
    Òinsufficient_cashÆ,Òsome_stockÆ,ÒVM_saleÆ,
    ÒVM_nosaleÆ,ÒVM1Æ,ÒVM2Æ,ÒVM3Æ];
=TEX
We prove various preconditions (though these are not needed for the following correctness proofs).
First the pre-condition of $VM1$.
=SML
set_goal([],Òpre VM1 §
	(0 < stock
	± cash_tendered? = price
	± 0 º takings)Æ);
a (rewrite_tac [VM1, VM_sale, some_stock,
 VM_operation, VMSTATE, exact_cash]);
a (pure_rewrite_tac [z_get_spec Ò(_ º _)Æ]);
a (rewrite_tac[]);
a (REPEAT z_strip_tac);
a (z_∂_tac Ò(
	bars_delivered! ¶ 1,
	cash_refunded! ¶ cash_tendered? + ~ price,
	stock' ¶ stock + ~ 1,
	takings' ¶ takings + price)Æ
   THEN rewrite_tac[]);
a (PC_T1 "z_library_ext" asm_rewrite_tac
   [rewrite_rule [] price]);
a (LEMMA_T Òstock + ~ 1 º stockÆ asm_tac THEN1 rewrite_tac[]);
a (all_fc_tac [z_º_trans_thm]);
a (asm_rewrite_tac []);
a (strip_asm_tac (z_get_spec ÒpriceÆ));
a (all_fc_tac [z_Ó_plus_thm]);
val pre_VM1_thm = save_pop_thm "pre_VM1_thm";
=TEX
Now we establish the precondition of VM2.
=SML
set_goal([], Òpre VM2 §
	cash_tendered? < price
	± cash_tendered? æ 0
	± stock æ 0
	± takings æ 0Æ);
a (rewrite_tac [VM2, VM_nosale, VM_operation, VMSTATE, insufficient_cash]);
a (REPEAT z_strip_tac);
a (z_∂_tac Ò(
	bars_delivered! ¶ 0,
	cash_refunded! ¶ cash_tendered?,
	stock' ¶ stock,
	takings' ¶ takings)Æ
   THEN PC_T1 "z_library_ext" asm_rewrite_tac[]);
val pre_VM2_thm = save_pop_thm "pre_VM2_thm";
=TEX
We next establish the precondition of VM3.
The proof is simplified if the following result is established first:
=SML
set_goal([], Òpre (VM1 ≤ VM2) § pre VM1 ≤ pre VM2Æ);
a (prove_tac[]);
val VM1VM2_lemma = pop_thm();
=TEX

=SML
set_goal([],Òpre VM3 §
	 0 < stock ± cash_tendered? = price ± 0 º takings
             ≤ cash_tendered? < price
               ± 0 º cash_tendered?
               ± 0 º stock
               ± 0 º takingsÆ);
a (pure_rewrite_tac [VM3, VM1VM2_lemma, pre_VM1_thm, pre_VM2_thm]);
a (z_strip_tac
	THEN z_strip_tac
	THEN z_strip_tac
	THEN strip_asm_tac price
	THEN asm_rewrite_tac[]);
val pre_VM3_thm = save_pop_thm "pre_VM3_thm";
=TEX
Now we prove that VM3 is a correct refinement of VM1.

The results about preconditions are not particularly helpful here, since the top level structure of the specification suffices to obtain the result without detailed knowledge of the preconditions.
=SML
set_goal([], Ò≥ (insufficient_cash ± exact_cash)Æ);
a (rewrite_tac [insufficient_cash, exact_cash]);
=GFT ProofPower output
...
(* ?Ù *)  Ò≥
           ((0 º cash_tendered?
               ± cash_tendered? < price)
               ± 0 º cash_tendered?
               ± cash_tendered? = price)Æ
...
=TEX
We eliminate the $<$ relation by rewriting with its specification.
However, the specification of $<$ contains other facts whose inverses are in the current proof context, so a simple rewrite with the specification loops.
$pure_rewrite_tac$ is therefore used.
=SML
a (pure_rewrite_tac [z_get_spec Ò(_<_)Æ]);
=GFT ProofPower output
(* ?Ù *)  Ò≥
           ((0 º cash_tendered?
               ± 0 º price + ~ (cash_tendered? + 1))
               ± 0 º cash_tendered?
               ± cash_tendered? = price)Æ
=TEX
The remaineder of the proof is a routine arithmetic manipulation.
=SML
a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
a (REPEAT_N 3 z_strip_tac THEN asm_rewrite_tac[]);
val cash_lemma = save_pop_thm "cash_lemma";
=TEX
Proving the correctness of the refinement is now straightforward.
=SML
set_goal([], Ò (pre VM1 ¥ pre VM3) ± (pre VM1 ± VM3 ¥ VM1)Æ);
a (rewrite_tac [VM1, VM2, VM3]);
=GFT ProofPower output
(* ?Ù *)  Ò((∂ bars_delivered! : É;
                   cash_refunded! : É;
                   stock' : É;
                   takings' : É
                 ∑ exact_cash ± some_stock ± VM_sale)
               ¥ (∂ bars_delivered! : É;
                   cash_refunded! : É;
                   stock' : É;
                   takings' : É
                 ∑ exact_cash ± some_stock ± VM_sale
                   ≤ insufficient_cash ± VM_nosale))
             ± ((∂ bars_delivered! : É;
                     cash_refunded! : É;
                     stock' : É;
                     takings' : É
                   ∑ exact_cash ± some_stock ± VM_sale)
                 ± (exact_cash ± some_stock ± VM_sale
                   ≤ insufficient_cash ± VM_nosale)
               ¥ exact_cash ± some_stock ± VM_sale)Æ
=SML
a (strip_asm_tac cash_lemma THEN asm_rewrite_tac[]);
=GFT ProofPower output
(*  1 *)  Ò≥ insufficient_cashÆ

(* ?Ù *)  Ò(∂ bars_delivered! : É;
                   cash_refunded! : É;
                   stock' : É;
                   takings' : É
                 ∑ exact_cash ± some_stock ± VM_sale)
               ± exact_cash
               ± some_stock
               ± VM_sale
             ¥ exact_cash ± some_stock ± VM_saleÆ
=TEX
a (REPEAT z_strip_tac);
val VM3_refines_VM1 = save_pop_thm "VM3_refines_VM1";
=TEX

Next we express the requirement that a vending machine does not undercharge:

πZAX
‹	VM_ok :   VM_operation
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ vm :  VM_operation∑
‹	vm ç VM_ok §
‹		(µ VM_operation ∑ vm ¥
‹		takings' - takings æ price * (stock - stock'))
∞

Before using this definition we convert it into an unconditional rewrite.
=SML
val VM_ok = z_defn_simp_rule (z_get_spec ÒVM_okÆ);
=TEX
We now prove that VM3 is a VM_ok.
=SML
set_goal([], ÒVM3 ç VM_okÆ);
a (rewrite_tac [VM1,VM2,VM3,VM_ok,VM_sale,VM_nosale]);
=GFT ProofPower output
...
(* ?Ù *)  Ò(exact_cash
                   ± some_stock
                   ± [VM_operation
                     | stock' = stock + ~ 1
                       ± bars_delivered! = 1
                       ± cash_refunded! = cash_tendered? + ~ price
                       ± takings' = takings + price]
                 ≤ insufficient_cash
                   ± [VM_operation
                     | stock' = stock
                       ± bars_delivered! = 0
                       ± cash_refunded! = cash_tendered?
                       ± takings' = takings])
                 Ä VM_operation
             ± (µ VM_operation
               ∑ exact_cash
                     ± some_stock
                     ± VM_operation
                     ± stock' = stock + ~ 1
                     ± bars_delivered! = 1
                     ± cash_refunded! = cash_tendered? + ~ price
                     ± takings' = takings + price
                   ≤ insufficient_cash
                     ± VM_operation
                     ± stock' = stock
                     ± bars_delivered! = 0
                     ± cash_refunded! = cash_tendered?
                     ± takings' = takings
                 ¥ price * (stock + ~ stock') º takings' + ~ takings)Æ
...
=TEX
There are a lot of propositional logic (or related schema calculus) operators here which can be simplified by stripping.
The subset sign will need to be treated extensionally, so proof context $z_library_ext$ is probably appropriate.
It is also clear that several equations will arise in the assumptions, and therefore likely that rewriting with the assumptions will be a good idea, so:
=SML
a (PC_T "z_library_ext" (REPEAT z_strip_tac) THEN asm_rewrite_tac[]);
=TEX
Which considerably simplified the problem:
=GFT ProofPower output
...
(*  7 *)  ÒVM_operationÆ
(*  6 *)  Òexact_cashÆ
(*  5 *)  Òsome_stockÆ
(*  4 *)  Òstock' = stock + ~ 1Æ
(*  3 *)  Òbars_delivered! = 1Æ
(*  2 *)  Òcash_refunded! = cash_tendered? + ~ priceÆ
(*  1 *)  Òtakings' = takings + priceÆ

(* ?Ù *)  Òprice * (stock + ~ (stock + ~ 1)) º (takings + price) + ~ takingsÆ
...
=TEX
To solve this little arithmetic problem we move
=INLINEFT
Ò~ takingsÆ
=TEX
\ left to place it next to $takings$:
=SML
a (rewrite_tac [z_µ_elim Ò~ takingsÆ z_plus_order_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Òprice * (stock + ~ (stock + ~ 1)) º ~ takings + takings + priceÆ
...
=TEX
Pushing in the minus sign and associating the additions to the left will result in the goal being proved using the cancellation results built into our current proof context.
=SML
a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
val VM3_ok_thm = save_pop_thm "VM3_ok_thm";
=TEX

\section{The Z ToolKit}

\subsection{Sets}

All of the examples in this theory can be proven automatically by the system.

First we set up an appropriate context:

% context setting point 11

=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_sets_ext";
=TEX

\subsubsection{Results Provable by Stripping}

We display one case partly expanded out:
=GFT SML
set_goal([],Òa ° (b \ c) = a ° b \ cÆ);
a z_strip_tac;
=GFT ProofPower output
(* ?Ù *)  Òµ x1 : É ∑ x1 ç a ° (b \ c) § x1 ç a ° b \ cÆ
=GFT SML
a z_strip_tac;
=GFT ProofPower output
(* ?Ù *)  Òx1 ç É ± true ¥ (x1 ç a ° (b \ c) § x1 ç a ° b \ c)Æ
=TEX
continuing only using $z_strip_tac$ (but omitting the display of this) as follows:
=GFT ProofPower output
(* ?Ù *)  Òx1 ç a ° (b \ c) § x1 ç a ° b \ cÆ
=TEX
=GFT ProofPower output
(* ?Ù *)  Ò(x1 ç a ° (b \ c) ¥ x1 ç a ° b \ c)
             ± (x1 ç a ° b \ c ¥ x1 ç a ° (b \ c))Æ
=TEX
=GFT ProofPower output
(* *** Goal "2" *** *)
(* ?Ù *)  Òx1 ç a ° b \ c ¥ x1 ç a ° (b \ c)Æ

(* *** Goal "1" *** *)
(* ?Ù *)  Òx1 ç a ° (b \ c) ¥ x1 ç a ° b \ cÆ
=TEX
=GFT ProofPower output
(* *** Goal "1" *** *)
(*  3 *)  Òx1 ç aÆ
(*  2 *)  Òx1 ç bÆ
(*  1 *)  Ò≥ x1 ç cÆ

(* ?Ù *)  Òx1 ç a ° b \ cÆ
=TEX
=GFT ProofPower output
...
(* ?Ù *)  Òx1 ç a ° b ± x1 é cÆ
=TEX
=GFT ProofPower output
(* *** Goal "1.2" *** *)
(*  3 *)  Òx1 ç aÆ
(*  2 *)  Òx1 ç bÆ
(*  1 *)  Ò≥ x1 ç cÆ

(* ?Ù *)  Òx1 é cÆ

(* *** Goal "1.1" *** *)
(*  3 *)  Òx1 ç aÆ
(*  2 *)  Òx1 ç bÆ
(*  1 *)  Ò≥ x1 ç cÆ

(* ?Ù *)  Òx1 ç a ° bÆ
=TEX
=GFT ProofPower output
(* *** Goal "1.1" *** *)
(*  3 *)  Òx1 ç aÆ
(*  2 *)  Òx1 ç bÆ
(*  1 *)  Ò≥ x1 ç cÆ

(* ?Ù *)  Òx1 ç a ± x1 ç bÆ
=TEX
=GFT ProofPower output
(* *** Goal "1.1.2" *** *)
(*  3 *)  Òx1 ç aÆ
(*  2 *)  Òx1 ç bÆ
(*  1 *)  Ò≥ x1 ç cÆ

(* ?Ù *)  Òx1 ç bÆ

(* *** Goal "1.1.1" *** *)
(*  3 *)  Òx1 ç aÆ
(*  2 *)  Òx1 ç bÆ
(*  1 *)  Ò≥ x1 ç cÆ

(* ?Ù *)  Òx1 ç aÆ
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "1.1.2" *** *)
...
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "1.2" *** *)
...
=TEX
=GFT ProofPower output
...
(* ?Ù *)  Ò≥ x1 ç cÆ
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(* ?Ù *)  Òx1 ç a ° b \ c ¥ x1 ç a ° (b \ c)Æ
...
=TEX
Goal 2 being similar to goal 1 we complete its proof in one step:
=GFT SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
The following groups of exercises are provable in exactly the same manner.
=SML
map prove_and_store Z1;
map prove_and_store Z2;
map prove_and_store Z3;
map prove_and_store Z3b;
=TEX

\subsection{Relations}


% context-setting point 12

=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_rel_ext";
=TEX
The following simple example shows how stripping followed by forward chaining often suffices for proofs in this theory.
=SML
set_goal([], ÒP ª Q ª R = (P ª Q) ª RÆ);
a contr_tac;
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  4 *)  Ò(x1, y') ç PÆ
(*  3 *)  Ò(y', y) ç QÆ
(*  2 *)  Ò(y, x2) ç RÆ
(*  1 *)  Òµ y : É ∑ ≥ ((x1, y) ç P ± (y, x2) ç Q ª R)Æ

(* ?Ù *)  ÒfalseÆ


(* *** Goal "1" *** *)

(*  4 *)  Ò(x1, y) ç PÆ
(*  3 *)  Ò(y, y') ç QÆ
(*  2 *)  Ò(y', x2) ç RÆ
(*  1 *)  Òµ y : É ∑ ≥ ((x1, y) ç P ª Q ± (y, x2) ç R)Æ

(* ?Ù *)  ÒfalseÆ
=TEX
The ``implications'' in the assumptions of these subgoals are well buried, but are nevertheless uncovered by the forward chaining facilities.
=SML
a (all_asm_fc_tac[]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:
...
=SML
a (all_asm_fc_tac[]);
pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
val it = Ù P ª Q ª R = (P ª Q) ª R : THM
...
=TEX
Many of the exercises are therefore proven automatically as follows.
=SML
map prove_and_store Z4;
map prove_and_store Z5;
=TEX

=SML
map prove_and_store Z5b;
=TEX
=SML
(* "Z5c.1" *)
set_goal([], Ò[X,Y,Z] (µx:É;g:É∑ g ç X ﬂ Y ± x ç dom g ¥ (x, g x) ç g)Æ);
a (REPEAT z_strip_tac);
a (POP_ASM_T (PC_T1 "z_library_ext" strip_asm_tac));
a (all_fc_tac [z_fun_app_clauses]);
a (asm_rewrite_tac[]);
val Z5c1 = save_pop_thm "Z5c.1";
=TEX
The following proof make use of the previous result (Z5c1).
=SML
(* "Z5c.2" *)
set_goal([], Ò[X,Y,Z] x ç dom g ± g x ç dom f ± g ç X ﬂ Y
	± f ç Y ﬂ Z ¥ (f Ö g)(x) = f(g(x))Æ);
set_pc "z_library";
a (REPEAT z_strip_tac);
a(z_app_eq_tac);
a (PC_T1 "z_library_ext" rewrite_tac[]);
a (REPEAT z_strip_tac);
a (lemma_tac Òg x = yÆ);
(* *** Goal "1.1" *** *)
a (all_fc_tac [z_fun_app_clauses]);
(* *** Goal "1.2" *** *)
a (all_fc_tac [z_fun_app_clauses]);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (z_∂_tac Òg xÆ);
a (REPEAT z_strip_tac);
(* *** Goal "2.1" *** *)
a (all_fc_tac [Z5c1]);
(* *** Goal "2.2" *** *)
a (all_fc_tac [Z5c1]);
save_pop_thm("Z5c.2");
=TEX
\vfill
=SML
set_pc "z_rel_ext";
map prove_and_store Z6;
map prove_and_store Z6b;
map prove_and_store Z7;
map prove_and_store Z8;
map prove_and_store Z8b;
map prove_and_store Z9;
=TEX
\vfill

=SML
setlg "Z9b.1" Z9b;
a(prove_tac[z_ç_first_thm]);
(* *** Goal "1" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x1, y))Æ);
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(y ¶ (x.2))Æ);
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 1);
a(conv_tac(ONCE_MAP_C z_tuple_intro_conv));
a(asm_rewrite_tac[]);
save_pop_thm "Z9b.1";
=TEX
\vfill
=SML
setlg "Z9b.2" Z9b;
a(prove_tac[z_ç_second_thm]);
(* *** Goal "1" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x, x1))Æ);
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x.1))Æ);
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 1);
a(conv_tac(ONCE_MAP_C z_tuple_intro_conv));
a (asm_rewrite_tac[]);
save_pop_thm "Z9b.2";
=TEX
\vfill
=SML
map prove_and_store Z10;
=TEX

=SML
setlg "Z10b.1" Z10b;
a(contr_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
a(z_spec_nth_asm_tac 3 Ò(y ¶ y')Æ);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm "Z10b.1";
=TEX


=SML
set_pc "z_library_ext";
setlg "Z10b.2" Z10b;
a (REPEAT strip_tac);
a(z_app_eq_tac);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 11 Ò(x1 ¶ x,x2 ¶ f_a')Æ);
a(z_spec_nth_asm_tac 11 Ò(x ¶ x, y1 ¶ f_a', y2 ¶ f_a)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 4 Ò(y ¶ f_a)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 4 Ò(y ¶ y')Æ);
(* *** Goal "4" *** *)
a(lemma_tac Òf x = yÆ);
(* *** Goal "4.1" *** *)
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
a(z_spec_nth_asm_tac 11 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
(* *** Goal "4.2" *** *)
a(swap_nth_asm_concl_tac 2);
a(asm_rewrite_tac[]);
save_pop_thm "Z10b.2";
=TEX


=SML
setlg "Z10b.3" Z10b;
a(contr_tac);
a(swap_nth_asm_concl_tac 1);
a(z_app_eq_tac);
a(contr_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 3 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 8 Ò(x1 ¶ x,x2 ¶ f_a')Æ);
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, y1 ¶ f_a', y2 ¶ f_a)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(lemma_tac Òg x = yÆ);
(* *** Goal "3.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "3.2" *** *)
a(swap_nth_asm_concl_tac 4);
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(lemma_tac Òg x = yÆ);
(* *** Goal "4.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "4.2" *** *)
a(swap_nth_asm_concl_tac 4);
a(asm_rewrite_tac[]);
save_pop_thm "Z10b.3";
=TEX


=SML
map prove_and_store Z11;
=TEX

=SML
setlg "Z11b.1" Z11b;
a contr_tac;
a(z_spec_nth_asm_tac 2 Ò(x1 ¶ x1, x2 ¶ x2)Æ);
a(z_spec_nth_asm_tac 6 Ò(S ¶ S)Æ);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x1', x2 ¶ x2')Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y')Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 6 Ò(S ¶ S)Æ);
(* *** Goal "3.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(z_spec_nth_asm_tac 7 Ò(x1 ¶ x1', x2 ¶ x2')Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y')Æ);
(* *** Goal "3.3" *** *)
a(z_spec_nth_asm_tac 3 Ò(y ¶ y)Æ);
save_pop_thm "Z11b.1";
=TEX

\subsection{Functions}

% context setting point 13

=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_fun_ext";
=TEX



=SML
setlg "Z12.1" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.1";
=TEX
=SML
setlg "Z12.2" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.2";
=TEX
=SML
setlg "Z12.3" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.3";
=TEX
=SML
setlg "Z12.4" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.4";
=TEX
=SML
setlg "Z12.5" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.5";
=TEX
=SML
setlg "Z12.6" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.6";
=TEX
=SML
setlg "Z12a.1" Z12a;
a (EVERY[
	rewrite_tac[],
	REPEAT strip_tac,
	z_app_eq_tac,
	REPEAT strip_tac,
	all_asm_fc_tac[],
	all_asm_fc_tac[]]);
save_pop_thm "Z12a.1";
=TEX

=SML
setlg "Z12b.1" Z12b;
a(contr_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
a(z_spec_nth_asm_tac 3 Ò(y ¶ x)Æ);
a(swap_nth_asm_concl_tac 6);
a(asm_rewrite_tac[]);
save_pop_thm "z12b.1";
=TEX

=SML
setlg "Z12b.2" Z12b;
a (contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 7 Ò(x1 ¶ y1, x2 ¶ y2)Æ);
(* *** Goal "1.1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ x)Æ);
(* *** Goal "1.2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ x)Æ);
(* *** Goal "1.3" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_ASM_FC_T rewrite_tac [get_thm "-" "Z12a.1"]);
(* *** Goal "2" *** *)
a(lemma_tac Òy = f x1Æ);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 14 Ò(x1 ¶ x1, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 14 Ò(x ¶ x1, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "2.2" *** *)
a(swap_nth_asm_concl_tac 9);
a(asm_rewrite_tac[]);
a(contr_tac);
a(z_spec_nth_asm_tac 13 Ò(x1 ¶ x1, x2 ¶ f x2)Æ);
a(z_spec_nth_asm_tac 11 Ò(x ¶ Òf x2Æ, y1 ¶ x1, y2 ¶ x2)Æ);
a(lemma_tac Òy' = f x2Æ);
(* *** Goal "2.2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 17 Ò(x1 ¶ x2, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 17 Ò(x ¶ x2, y1 ¶ f_a, y2 ¶ y')Æ);
(* *** Goal "2.2.2" *** *)
a(swap_nth_asm_concl_tac 12);
a(asm_rewrite_tac[]);
save_pop_thm "Z12b.2";
=TEX

No solutions for Z12.b3 to Z12b.7.



\subsection{Numbers and Finiteness}

% context setting point 14

=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_library";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];
=TEX
πZAX
‹	ì : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸
‹	µn:Ó∑
‹	ì 0 = 0
‹±	ì (n+1) = (n + 1) + ì n
∞

The second problem:

=SML
set_goal([],Ò µn: Ó∑ (ì n) * 2 = n * (n+1)Æ);
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Òµ n : Ó ∑ ì n * 2 = n * (n + 1)Æ
...
=SML
a (strip_asm_tac (z_get_spec Ò(ì)Æ));
=GFT ProofPower output
...
(*  2 *)  Òì ç Ó ≠ ÓÆ
(*  1 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ

(* ?Ù *)  Òµ n : Ó ∑ ì n * 2 = n * (n + 1)Æ
...
=SML
a (z_strip_tac THEN PC_T1 "z_language" rewrite_tac[]);
=GFT ProofPower output
...
(*  2 *)  Òì ç Ó ≠ ÓÆ
(*  1 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ

(* ?Ù *)  Òn ç Ó ¥ ì n * 2 = n * (n + 1)Æ
...
=SML
a z_Ó_induction_tac;
=GFT ProofPower output
...
(* *** Goal "2" *** *)

(*  4 *)  Òì ç Ó ≠ ÓÆ
(*  3 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ
(*  2 *)  Ò0 º iÆ
(*  1 *)  Òì i * 2 = i * (i + 1)Æ

(* ?Ù *)  Òì (i + 1) * 2 = (i + 1) * ((i + 1) + 1)Æ


(* *** Goal "1" *** *)

(*  2 *)  Òì ç Ó ≠ ÓÆ
(*  1 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ

(* ?Ù *)  Òì 0 * 2 = 0 * (0 + 1)Æ
=SML
(* *** Goal "1" *** *)
a (z_spec_nth_asm_tac 1 Ò0Æ
	THEN asm_rewrite_tac[]);
=GFT ProofPower output
...
Current goal achieved, next goal is:
...
=SML
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
=GFT ProofPower output
...
(*  6 *)  Òì ç Ó ≠ ÓÆ
(*  5 *)  Òµ n : Ó ∑ ì 0 = 0 ± ì (n + 1) = (n + 1) + ì nÆ
(*  4 *)  Ò0 º iÆ
(*  3 *)  Òì i * 2 = i * (i + 1)Æ
(*  2 *)  Òì 0 = 0Æ
(*  1 *)  Òì (i + 1) = (i + 1) + ì iÆ

(* ?Ù *)  Òì (i + 1) * 2 = (i + 1) * ((i + 1) + 1)Æ
=SML
a (asm_rewrite_tac[]);
=GFT ProofPower output
...
(* ?Ù *)  Ò((i + 1) + ì i) * 2 = (i + 1) * ((i + 1) + 1)Æ
...
=SML
a (asm_rewrite_tac[z_times_plus_distrib_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Ò(i * 2 + 2) + i * i + i = ((i * i + i) + i + 1) + i + 1Æ
...
=SML
a (rewrite_tac [z_µ_elim Òi*iÆ z_plus_order_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Ò(i * 2 + 2) + i = (i + i + 1) + i + 1Æ
...
=SML
a (rewrite_tac [z_µ_elim ÒiÆ z_plus_order_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Òi * 2 + 2 = i + i + 2Æ
...
=SML
a (rewrite_tac[z_plus_assoc_thm1]);
=GFT ProofPower output
...
(* ?Ù *)  Òi * 2 = i + iÆ
=SML
a (pure_rewrite_tac
	[prove_rule []Ò2 = 1 + 1Æ,
	z_times_plus_distrib_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Òi * 1 + i * 1 = i + iÆ
=SML
a (rewrite_tac[]);
=GFT ProofPower output
...
Current and main goal achieved
=SML
save_pop_thm "ZNum.1";
=TEX

The solution to the third problem of this section is:

% context setting point 15

=SML
repeat drop_main_goal;
open_theory "z_exercises_4";
set_pc "z_library_ext";
set_flags [("z_type_check_only", false), ("z_use_axioms", true)];

setlg "ZNum.2" ZNum;
=GFT ProofPower output
(* ?Ù *)  Òµ x, y : ˙ ∑ x º y ¥ 0 .. x Ä 0 .. yÆ
=TEX
First expand $..$.
=SML
a(rewrite_tac[z_get_spec Ò(_.._)Æ] THEN REPEAT strip_tac);
=GFT ProofPower output
...
(*  3 *)  Òx º yÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º xÆ

(* ?Ù *)  Òx1 º yÆ
...
=TEX
Then forward chain using transitivity of $º$.
=SML
a(all_fc_tac[z_º_trans_thm]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
=SML
save_pop_thm "ZNum.2";
=TEX
The solution to the fourth problem of this section is:

=SML
setlg "ZNum.3" ZNum;
=GFT ProofPower output
...
(* ?Ù *)  Òµ x, y : ˙ ∑ ≥ x º y ¥ 0 .. y Ä 0 .. x - 1Æ
...
=TEX
First expand the definition of $..$.
=SML
a(rewrite_tac[z_get_spec Ò(_.._)Æ] THEN REPEAT strip_tac);
=GFT ProofPower output
...
(*  3 *)  Òy < xÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º yÆ

(* ?Ù *)  Òx1 º x + ~ 1Æ
...
=TEX
Now forward chain on the assumptions using $z_º_less_trans_thm$ to obtain $x1 < x$.
=SML
a(all_fc_tac[z_º_less_trans_thm]);
=GFT ProofPower output
...
(*  1 *)  Òx1 < xÆ

(* ?Ù *)  Òx1 º x + ~ 1Æ
...
=TEX
Now it is necessary to expand the definition of $<$ in the last assumption.
$POP_ASM_T$ takes out the last assumption and feeds it into the $THM_TACTIC$ supplied to it.
In this case we rewrite the assumption with the specification of $<$ before passing it to $ante_tac$, which inserts in into the conclusion of the goal as the $ante$cedent of a new implication.
=SML
a(POP_ASM_T (ante_tac o pure_once_rewrite_rule[z_get_specÒ(_<_)Æ]));
=GFT ProofPower output
...
(* ?Ù *)  Òx1 + 1 º x ¥ x1 º x + ~ 1Æ
...
=TEX
In the absence of support for linear arithmetic this obvious result must be proven by transforming the conclusion of the goal until the various built in cancellation laws apply.
First we move everything to the left hand side of the inequalities using $z_º_º_0_thm$.
=SML
a(once_rewrite_tac[z_º_º_0_thm]);
=GFT ProofPower output
...
(* ?Ù *)  Ò(x1 + 1) + ~ x º 0 ¥ x1 + ~ (x + ~ 1) º 0Æ
...
=TEX
Now we use $z_plus_order_thm$ to reorder the arithmetic expressions and $z_minus_thm$ to provide some cancellation results which have been omitted from the proof context.
=SML
a(rewrite_tac[z_µ_elim Ò~ xÆ z_plus_order_thm, z_minus_thm]);
=GFT ProofPower output
...
Current and main goal achieved
...
=SML
save_pop_thm "ZNum.3";
=TEX
