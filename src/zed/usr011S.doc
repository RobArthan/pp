% usr011S.doc   %Z% $Date$ $Revision$ $RCSfile$
% this should form a Chapter of the document
% Solutions to Exercises
=TEX
\section{Introduction}

The section numbers of this chapter correspond to those in the Exercises chapter.

The following procedure will assist setting up individual goals using the ML values set up by the exercises source script:
=SML
fun setlg name goallist = set_goal([],lassoc3 goallist name);
=TEX
This procedure will attempt to prove a conjecture using $prove_rule$ and store the results in the current theory:
=SML
fun prove_and_store (key, term) = save_thm (key, prove_rule[] term);
=TEX

\section{The Z Predicate Calculus}
=SML
open_theory "z_bags";
set_pc "z_language";
open_theory "z_exercises_1";
=TEX
=SML
set_merge_pcs ["'z_fc", "z_language"];
=TEX
\subsection{Forward Propositional Proofs}

Solutions to forward proof exercises.

=SML
(* (a) *)
val ex1a_thm1 = asm_rule Ò a¥bÆ;
val ex1a_thm2 = asm_rule Ò b¥cÆ;
val ex1a_thm3 = asm_rule Ò ê(a)Æ;
val ex1a_thm4 = ¥_elim ex1a_thm1 ex1a_thm3;
val ex1a_thm = ¥_elim ex1a_thm2 ex1a_thm4;

save_thm ("ex1a_thm", ex1a_thm);

(* (b) *)
val ex1b_thm1 =
 ¥_elim (asm_rule Ò a¥b¥cÆ)(asm_rule Ò ê(a)Æ);
val ex1b_thm =
 ¥_elim ex1b_thm1 (asm_rule Ò ê(b)Æ);

save_thm ("ex1b_thm", ex1b_thm);

(* (c) *)
val ex1c_thm = ¥_intro Ò ê(a)Æ ex1b_thm;

save_thm ("ex1c_thm", ex1c_thm);

(* (d) *)
val ex1d_thm1 = ¥_intro Ò ê(b)Æ ex1c_thm;
val ex1d_thm = ¥_intro Ò a ¥ b ¥ cÆ ex1d_thm1;

save_thm ("ex1d_thm", ex1d_thm);

=TEX

\subsection{Goal Oriented Propositional Proofs}

For each of the exercises either:
=GFT SML
a (prove_tac[]);
=TEX
or:
=GFT SML
a (REPEAT strip_tac);
=TEX
will complete the proof in one step.

To get an understanding of how this is done the proofs may be obtained in steps by manually repeating:
=GFT SML
a z_strip_tac;
=TEX
or:
=GFT SML
a step_strip_tac;
=TEX

We show here just one example of proof by stripping, you may work through as many other examples as you like.
=SML
setlg "*2.02" PM2;
=TEX

The results may be proven automatically as follows:

=SML
map prove_and_store PM2;
map prove_and_store PM3;
map prove_and_store PM4;
map prove_and_store PM5;
=TEX

Though technically these may be considered forward proofs since they use $prove_rule$, prove rule itself uses $prove_tac$, and so the difference between completely automatic forward and backward proof is insignificant.

\subsection{Forward Predicate Calculus Proofs}

Forward proof using elementary rules is less convenient in Z because of the extra complications arising when quantifiers are eliminated or introduced.
=SML
open_theory "z_exercises_1";
set_merge_pcs ["z_language", "'z_numbers"];

(* 1(a) *)
val ex1a_thm1 = z_µ_elim Ò 0Æ z_Ó_≥_plus1_thm;
(* 1(b) *)
val ex1b_thm = z_µ_elim Ò x*xÆ z_Ó_≥_plus1_thm;

(* 2 *)
val ex2_thm = prove_rule [z_º_trans_thm]
	Ò i º j ± j º k ¥ i º kÆ ;
	
(* note that:
z_µ_elim Ò(i¶i∫˙, j¶j∫˙, k¶k∫˙)Æ z_º_trans_thm; 
doesn't do the job.
*)

(* 3(a) *)
val ex3a_thm = prove_rule [z_Ó_≥_plus1_thm]
	Ò≥ 0 + 1 = 0Æ;
(* 3(b) *)
val ex3b_thm = prove_rule [z_Ó_≥_plus1_thm]
	Ò x * x ç Ó ¥ ≥ x * x + 1 = 0Æ;

(* 4(a) *)
val ex4a_thm = prove_rule[z_≥_less_thm]
	Ò≥ 0 < 1 § 1 º 0Æ;
(* 4(b) *)
val ex4b_thm = prove_rule[z_º_trans_thm]
	Òµ n:˙ ∑ 3 º x * x ± x * x º n ¥ 3 º nÆ;

(* 5(a) *)
val ex5a_thm = prove_rule[z_º_clauses]
	Òµ i, m, n :˙∑ i + m º i + n § m º nÆ;
(* 5(b) *)
val ex5b_thm = prove_rule[z_º_clauses]
	Òµ m, i, n :˙∑ i + m º i + n § m º nÆ;
=TEX

\subsection{Goal Oriented Predicate Calculus Proof}

=IGN
a contr_tac;
a z_strip_tac;
a strip_tac;
a step_strip_tac;
a (prove_tac[]);
a (asm_prove_tac[]);
a (z_spec_asm_tac Ò Æ Ò Æ);
a (z_spec_nth_asm_tac 1 Ò Æ);
a (all_asm_fc_tac[]);
=TEX
These proofs are also conducted automatically.
=SML
set_pc "z_language";
open_theory "z_exercises_1";
map prove_and_store PM9;
map prove_and_store PM10;
map prove_and_store PM10b;
map prove_and_store PM11;
=TEX

The problems in PM11b cannot be solved by $prove_tac$.
=SML
set_goal([], lassoc3 PM11b "*11.32");
=GFT ProofPower output
...
(* ?Ù *)  Ò[Y]((µ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y))
             ¥ (µ x, y : Y ∑ ∆ (x, y))
             ¥ (µ x, y : Y ∑ Ÿ (x, y)))Æ
...
=SML
a contr_tac;
=GFT ProofPower output
...
(*  4 *)  Òµ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y)Æ
(*  3 *)  Òµ x, y : Y ∑ ∆ (x, y)Æ
(*  2 *)  Òx ç YÆ
(*  1 *)  Òy ç YÆ

(* ?Ù *)  ÒŸ (x, y)Æ
...
=SML
a(z_spec_nth_asm_tac 5 Ò(x ¶ x, y ¶ y)Æ);
=GFT ProofPower output
...
(*  6 *)  Òµ x, y : Y ∑ ∆ (x, y) ¥ Ÿ (x, y)Æ
(*  5 *)  Òµ x, y : Y ∑ ∆ (x, y)Æ
(*  4 *)  Òx ç YÆ
(*  3 *)  Òy ç YÆ
(*  2 *)  Ò≥ Ÿ (x, y)Æ
(*  1 *)  Ò≥ ∆ (x, y)Æ

(* ?Ù *)  ÒfalseÆ
...
=SML
a(z_spec_nth_asm_tac 5 Ò(x ¶ x, y ¶ y)Æ);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=SML
save_pop_thm("*11.32");
=TEX
=SML
setlg "*11.45" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x', y ¶ y')Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x', y ¶ y')Æ);
save_pop_thm("*11.45");
=TEX
=SML
setlg "*11.54" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
save_pop_thm("*11.54");
=SML
setlg "*11.55" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x, y ¶ y)Æ);
save_pop_thm("*11.55");
=TEX
=SML
setlg "*11.6" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm("*11.6");
=TEX
=SML
setlg "*11.62" PM11b;
a contr_tac;
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x, y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x)Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm("*11.62");
=TEX
Though the resolution prover failed to prove the above proofs, forward chaining suffices.

To show this we first delete the theorems from the theory:
=SML
map delete_thm (map fst PM11b);
=TEX
Then we write a function to do the proofs using a simpler approach:
=SML
fun prove_and_store2 (key, term) = save_thm (key,
	tac_proof (([],term),
	(contr_tac
		THEN (all_asm_fc_tac[])
		THEN (all_asm_fc_tac[]))));
		
map prove_and_store2 PM11b;
=TEX

\section{Expressions and Schema Expressions}
=SML
open_theory "z_exercises_2";
=TEX
\subsection{Propositional Schema Calculus}

These results can be solved by stripping in a manner analogous to the analogous propositional result.
=SML
set_pc "z_language";
=TEX
We illustrate the proofs by showing one example in detail.
=SML
setlg "*2.03" SCPM2;
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Ò((Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ Pab)Æ
...
=TEX
In the following proof two main things are taking place.

Firstly, the logical schema operators are being transformed into the corresponding propositional logic operators, and secondly, the stripping of these follows the normal course.

In addition there is some sitching taking place between schemas-as-predicates, in which there is an implicit binding membership assertion, and explcit statements about membership of bindings.

The basic proof facilities are provided for the binding membership assertions since these are more general than the schema-as-predicate format, and also are likely to arise from the latter when substitutions take place.
At present the stripping facilities will revert to the schema-as-predicate format at the top level of the conclusion or assumptions if possible.
=SML
a z_strip_tac;
=GFT ProofPower output
..
(* ?Ù *)  Ò(a ¶ a, b ¶ b, c ¶ c) ç (Pab ¥ ≥ Qac)
             ¥ (a ¶ a, b ¶ b, c ¶ c) ç (Qac ¥ ≥ Pab)Æ
...
=TEX
The first step has transformed the implication to a logical implication.
=SML
a z_strip_tac;
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ


(* *** Goal "1" *** *)

(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ
...
=TEX
When the implication is stripped the left hand side is completely stripped into the assumptions.
This results in a case split.
Note here that the negation in the assumption is now a logical negation.
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  Ò(a ¶ a, c ¶ c) ç Qac ¥ (a ¶ a, b ¶ b) ç (≥ Pab)Æ
...
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò(≥ Pab)Æ
...
=TEX
Here we are not quite finished because the negation in the assumption is a logical negation while the one in the conclusion is a schema-negation.
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò≥ (a ¶ a, b ¶ b) ç PabÆ
...
=SML
a z_strip_tac;
=GFT ProofPower output
...
(*  2 *)  Ò≥ PabÆ
(*  1 *)  ÒQacÆ

(* ?Ù *)  Ò≥ PabÆ
...
=TEX
Now the conclusion really is the same as the assumption.
=SML
a z_strip_tac;
=GFT ProofPower output
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  Ò(Qac ¥ ≥ Pab)Æ
...
=TEX
The proof of this subgoal contains nothing new so we do it in one step.
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=TEX
An alternative approach is to eliminate the schema operations first by rewriting, and then complete the proof by stripping.
=SML
setlg "*2.03" SCPM2;
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* ?Ù *)  Ò((Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ Pab)Æ
...
=TEX
Since all the membership conversions are built in to the proof context $z_language$ rewriting with no parameters suffices to eliminate the schema operators.
This would not be the case if the schema expression had not been used as a predicate, since the implicit membership statement is essential to trigger the transformations in this context.
=SML
a (rewrite_tac[]);
=TEX
This yeilds the syntactically similar goal in which all operators are logical operators rather than schema operators.
=GFT ProofPower output
...
(* ?Ù *)  Ò(Pab ¥ ≥ Qac) ¥ Qac ¥ ≥ PabÆ
...
=TEX
A cleaner proof is now obtained by stripping.
=SML
a z_strip_tac;
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò≥ QacÆ

(* ?Ù *)  ÒQac ¥ ≥ PabÆ


(* *** Goal "1" *** *)

(*  1 *)  Ò≥ PabÆ

(* ?Ù *)  ÒQac ¥ ≥ PabÆ
...
=TEX
We will not complete the proof, which proceeds as the previous one but with a number of steps omitted.
=SML
drop_main_goal();
=TEX
Many other examples are provided for you to play through if you wish.
The following script demonstrates that the system can prove them all automatically.
=SML
map prove_and_store SCPM2;
map prove_and_store SCPM3;
map prove_and_store SCPM4;
map prove_and_store SCPM5;
=TEX

\subsection{Schema Calculus Quantification}
=SML
map prove_and_store SCPM9;
=TEX

\section{Paragraphs}
First set the context.
=SML
open_theory "z_exercises_3";
set_pc "z_library";
=TEX
Then clear the flags:
=SML
set_flags [("z_type_check_only", false), ("z_use_axioms", false)];
=TEX
\subsection{Consistency Proofs}
Now define the required global variable:
πZAX
num:Ó
˜
 4 º num º 50
∞
Push the consistency goal, and tidy it up:
=SML
push_consistency_goal ÒnumÆ;
a (rewrite_tac (map get_spec
	[¨Z'AxDesÆ, ¨Z'DeclÆ, ¨Z'DecÆ]));
=TEX
Supply a witness:
=SML
a (∂_tac Ò10Æ);
=TEX
Then complete the proof by rewriting:
=SML
a (rewrite_tac[]);
=TEX
Then save the conssitency goal.
=SML
save_consistency_thm ÒnumÆ (pop_thm());
=TEX
Now set up the required goal:
=SML
set_goal([], Ò num æ 0Æ);
=TEX
Strip the specification of $num$ into the assumptions:
=SML
a (strip_asm_tac (z_get_spec ÒnumÆ));
=GFT ProofPower output
...
(* *** Goal "" *** *)

(*  3 *)  Ò0 º numÆ
(*  2 *)  Ò4 º numÆ
(*  1 *)  Ònum º 50Æ

(* ?Ù *)  Ònum æ 0Æ
..
=TEX
Then rewrite the conclusion of the goal with the assumptions.
=SML
a (asm_rewrite_tac []);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=SML
save_pop_thm "ZP1";
=TEX

\subsection{Reasoning using Schema Definitions}

Before beginning the proofs we extract the specifications for the relevant constants and bind them to an ML name:

=SML
val specs = (map z_get_spec [ÒOP2Æ, ÒOPÆ, ÒSTATEÆ]);
=TEX
\begin{enumerate}
\item
First set the goal:
=SML
set_goal ([], Ò pre OP § i? æ 0Æ);
=GFT ProofPower output
...
(* ?Ù *)  Ò(pre OP) § i? æ 0Æ
...
=TEX
Now rewrite with the specifications of $OP$ and $STATE$:
=SML
a (rewrite_tac (map z_get_spec [ÒOPÆ, ÒSTATEÆ]));
=GFT ProofPower output
...
(* ?Ù *)  Ò(∂ r' : U ∑ true) ± 0 º i? § 0 º i?Æ
...
=SML
a (REPEAT strip_tac);
=GFT ProofPower output
...
(*  1 *)  Ò0 º i?Æ

(* ?Ù *)  Ò∂ r' : U ∑ trueÆ
=SML
a (z_∂_tac ÒxÆ);
=GFT ProofPower output
...
(* ?Ù *)  Òx ç U ± true ± trueÆ
...
=SML
a contr_tac;
save_pop_thm "ZP2";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

\item
=SML
save_thm ("ZP3", (prove_rule specs Ò (pre OP ¥ pre OP2) ± (pre OP ± OP2 ¥ OP)Æ));
=GFT
val it = Ù ((pre OP) ¥ (pre OP2)) ± ((pre OP) ± OP2 ¥ OP) : THM   
=TEX
\end{enumerate}


\section{The Z ToolKit}

=SML
open_theory "z_exercises_4";
=TEX
\subsection{Sets}

All of the examples in this theory can be proven automatically by the system.

First we set up an appropriate context:

=SML
set_pc "z_sets_ext";
=TEX

\subsubsection{Results Provable by Stripping}

%We display one case in full:

=SML
map prove_and_store Z1;
map prove_and_store Z2;
map prove_and_store Z3;
map prove_and_store Z3b;
=TEX

\subsection{Relations}

=SML
open_theory "z_exercises_4";
set_pc "z_rel_ext";
=TEX

=SML
map prove_and_store Z4;
map prove_and_store Z5;
=TEX

=SML
map prove_and_store Z5b;
=TEX
=SML
setlg "Z5c.1" Z5c;
set_pc "z_library_ext";
a(contr_tac);
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x, x2 ¶ y)Æ);
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ g x, x2 ¶ y')Æ);
a(swap_nth_asm_concl_tac 5);
a(z_app_eq_tac);
a(rewrite_tac[]);
a(contr_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 11 Ò(x1 ¶ x, x2 ¶ y'')Æ);
a(z_spec_nth_asm_tac 10 Ò(x1 ¶ y'', x2 ¶ f_a)Æ);
a(swap_nth_asm_concl_tac 3);
a(z_app_eq_tac);
a(contr_tac);
(* *** Goal "1.1" *** *)
a(z_spec_nth_asm_tac 12 Ò(x1 ¶ g x, x2 ¶ f_a')Æ);
a(lemma_tac Òg x = y''Æ);
(* *** Goal "1.1.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 17 Ò(x1 ¶ x, x2 ¶ f_a'')Æ);
a(z_spec_nth_asm_tac 17 Ò(x ¶ x, y1 ¶ f_a'', y2 ¶ y'')Æ);
(* *** Goal "1.1.2" *** *)
a(swap_nth_asm_concl_tac 4);
a(asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 3);
a(z_spec_nth_asm_tac 12 Ò(x ¶ y'', y1 ¶ f_a', y2 ¶ f_a)Æ);
(* *** Goal "1.2" *** *)
a(lemma_tac Òg x = y''Æ);
(* *** Goal "1.2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 14 Ò(x ¶ x, y1 ¶ f_a', y2 ¶ y'')Æ);
a(z_spec_nth_asm_tac 16 Ò(x1 ¶ x, x2 ¶ f_a')Æ);
(* *** Goal "1.2.2" *** *)
a(swap_nth_asm_concl_tac 2);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
a(lemma_tac Òy = g xÆ);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 12 Ò(x1 ¶ x, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 12 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "2.2" *** *)
a(swap_nth_asm_concl_tac 2);
a(asm_rewrite_tac[]);
a(lemma_tac Òf(g x) = y'Æ);
(* *** Goal "2.2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 10 Ò(x1 ¶ g x, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 10 Ò(x ¶ g x, y1 ¶ f_a, y2 ¶ y')Æ);
(* *** Goal "2.2.2" *** *)
a(asm_rewrite_tac[]);
save_pop_thm("Z5c.1");
=TEX
=SML
set_pc "z_rel_ext";
map prove_and_store Z6;
map prove_and_store Z6b;
map prove_and_store Z7;
map prove_and_store Z8;
map prove_and_store Z8b;
map prove_and_store Z9;
=SML
setlg "Z9b.1" Z9b;
a(prove_tac[z_ç_first_thm]);
(* *** Goal "1" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x1, y))Æ);
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(y ¶ (x.2))Æ);
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 1);
a(conv_tac(ONCE_MAP_C z_tuple_intro_conv));
a(asm_rewrite_tac[]);
save_pop_thm "Z9b.1";
=TEX
=SML
setlg "Z9b.2" Z9b;
a(prove_tac[z_ç_second_thm]);
(* *** Goal "1" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x, x1))Æ);
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(contr_tac);
a(z_spec_nth_asm_tac 1 Ò(x ¶ (x.1))Æ);
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 1);
a(conv_tac(ONCE_MAP_C z_tuple_intro_conv));
a (asm_rewrite_tac[]);
save_pop_thm "Z9b.2";
=TEX
=SML
map prove_and_store Z10;
=TEX
Embedded quantifiers:
=SML
setlg "Z10b.1" Z10b;
a(contr_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
a(z_spec_nth_asm_tac 3 Ò(y ¶ y')Æ);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ y)Æ);
save_pop_thm "Z10b.1";
=TEX
Application problems:
=SML
set_pc "z_library_ext";
setlg "Z10b.2" Z10b;
a (REPEAT strip_tac);
a(z_app_eq_tac);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 11 Ò(x1 ¶ x,x2 ¶ f_a')Æ);
a(z_spec_nth_asm_tac 11 Ò(x ¶ x, y1 ¶ f_a', y2 ¶ f_a)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 4 Ò(y ¶ f_a)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 4 Ò(y ¶ y')Æ);
(* *** Goal "4" *** *)
a(lemma_tac Òf x = yÆ);
(* *** Goal "4.1" *** *)
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
a(z_spec_nth_asm_tac 11 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
(* *** Goal "4.2" *** *)
a(swap_nth_asm_concl_tac 2);
a(asm_rewrite_tac[]);
save_pop_thm "Z10b.2";
=TEX
Application problems:
=SML
setlg "Z10b.3" Z10b;
a(contr_tac);
a(swap_nth_asm_concl_tac 1);
a(z_app_eq_tac);
a(contr_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 3 Ò(y ¶ y)Æ);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 8 Ò(x1 ¶ x,x2 ¶ f_a')Æ);
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, y1 ¶ f_a', y2 ¶ f_a)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(lemma_tac Òg x = yÆ);
(* *** Goal "3.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "3.2" *** *)
a(swap_nth_asm_concl_tac 4);
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x,x2 ¶ y)Æ);
a(lemma_tac Òg x = yÆ);
(* *** Goal "4.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 9 Ò(x1 ¶ x,x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "4.2" *** *)
a(swap_nth_asm_concl_tac 4);
a(asm_rewrite_tac[]);
save_pop_thm "Z10b.3";
=TEX

=SML
map prove_and_store Z11;
=TEX
Number of resolution steps, caused by reasoning about membership,
rather than sets:
=SML
setlg "Z11b.1" Z11b;
a contr_tac;
a(z_spec_nth_asm_tac 2 Ò(x1 ¶ x1, x2 ¶ x2)Æ);
a(z_spec_nth_asm_tac 6 Ò(S ¶ S)Æ);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x1', x2 ¶ x2')Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y')Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 6 Ò(S ¶ S)Æ);
(* *** Goal "3.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(z_spec_nth_asm_tac 7 Ò(x1 ¶ x1', x2 ¶ x2')Æ);
a(z_spec_nth_asm_tac 1 Ò(y ¶ y')Æ);
(* *** Goal "3.3" *** *)
a(z_spec_nth_asm_tac 3 Ò(y ¶ y)Æ);
save_pop_thm "Z11b.1";
=TEX

=SML
setlg "Z12.1" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.1";
=TEX
=SML
setlg "Z12.2" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.2";
=TEX
=SML
setlg "Z12.3" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.3";
=TEX
=SML
setlg "Z12.4" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.4";
=TEX
=SML
setlg "Z12.5" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.5";
=TEX
=SML
setlg "Z12.6" Z12;
a (rewrite_tac[] THEN REPEAT strip_tac);
a (z_app_eq_tac THEN REPEAT strip_tac);
a (all_asm_fc_tac[]);
a (all_asm_fc_tac[]);
save_pop_thm "Z12.6";
=TEX
=SML
setlg "Z12a.1" Z12a;
a (EVERY[
	rewrite_tac[],
	REPEAT strip_tac,
	z_app_eq_tac,
	REPEAT strip_tac,
	all_asm_fc_tac[],
	all_asm_fc_tac[]]);
save_pop_thm "Z12a.1";
=TEX
Too many resolution steps, some equational reasoning:
=SML
setlg "Z12b.1" Z12b;
a(contr_tac THEN all_asm_fc_tac[]);
a(all_asm_fc_tac[]);
a(z_spec_nth_asm_tac 3 Ò(y ¶ x)Æ);
a(swap_nth_asm_concl_tac 6);
a(asm_rewrite_tac[]);
save_pop_thm "z12b.1";
=TEX
Too many resolution steps:
=SML
setlg "Z12b.2" Z12b;
a (contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 7 Ò(x1 ¶ y1, x2 ¶ y2)Æ);
(* *** Goal "1.1" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ x)Æ);
(* *** Goal "1.2" *** *)
a(z_spec_nth_asm_tac 1 Ò(y ¶ x)Æ);
(* *** Goal "1.3" *** *)
a(swap_nth_asm_concl_tac 1);
a(ALL_ASM_FC_T rewrite_tac [get_thm "-" "Z12a.1"]);
(* *** Goal "2" *** *)
a(lemma_tac Òy = f x1Æ);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 14 Ò(x1 ¶ x1, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 14 Ò(x ¶ x1, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "2.2" *** *)
a(swap_nth_asm_concl_tac 9);
a(asm_rewrite_tac[]);
a(contr_tac);
a(z_spec_nth_asm_tac 13 Ò(x1 ¶ x1, x2 ¶ f x2)Æ);
a(z_spec_nth_asm_tac 11 Ò(x ¶ Òf x2Æ, y1 ¶ x1, y2 ¶ x2)Æ);
a(lemma_tac Òy' = f x2Æ);
(* *** Goal "2.2.1" *** *)
a(z_app_eq_tac);
a(contr_tac);
a(z_spec_nth_asm_tac 17 Ò(x1 ¶ x2, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 17 Ò(x ¶ x2, y1 ¶ f_a, y2 ¶ y')Æ);
(* *** Goal "2.2.2" *** *)
a(swap_nth_asm_concl_tac 12);
a(asm_rewrite_tac[]);
save_pop_thm "Z12b.2";
=TEX

