=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Z Primitive Constants in the Theory ``Z''}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Z Primitive Constants \cr in the Theory ``Z''}
\TPPref{DS/FMU/IED/DTD052}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
%\TPPauthors{G.T.Scullard&WIN01\\G.M.Prout&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the detailed design of the Z primitive constants in the theory ``Z'' of the Z Proof Support Subsystem.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1] (\TPPdate{\FormatDate{$Date$
}})
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
Z primitive constants in the theory ``Z'' of
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The design is
implemented in \cite{DS/FMU/IED/IMP052}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
In the Z Proof Support Subsystem, two types of constants have been identified:
\begin{enumerate}
\item
 Constants defined as primitive  in the system.
\item 
Constants that belong to infinite families and thus cannot be defined as primitive, see \cite{DS/FMU/IED/DTD050}. 
\end{enumerate}
This document gives the detailed design for the theory ``Z'' which contains the constants of type (1). 
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 ICL HOL System and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Notation}
All constants that are used in the Z semantic mapping described in \cite{DS/FMU/IED/HLD015} are preceded by $z'$. These constants should not be used by the user of the Z proof support system {\bf unless} the user is prepared to drop out of Z into HOL.
=IGN
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=TEX
=TEX
\section{THE THEORY  ``Z''}
\subsection{Design of the Theory ``Z''}
=THDOC
req_name "Z" (Value "char");
=DESCRIBE
The theory ``‚Z·'' defines the primitive constants of the Z Proof Support System.
=ENDDOC

=THDOC
req_type("S_æ1ø",1);
req_const("mk_S_æ1ø",ª:'a ã 'a $"S_æ1ø"º);
req_const("S_æ1ø_1",ª:'a $"S_æ1ø" ã 'aº);
req_type("S_æ1©2ø",2);
req_const("mk_S_æ1©2ø",ª:'a ã 'b ã ('a,'b)$"S_æ1©2ø"º);
req_const("S_æ1©2ø_1",ª:('a,'b)$"S_æ1©2ø" ã 'aº);
req_const("S_æ1©2ø_2",ª:('a,'b)$"S_æ1©2ø" ã 'bº);
=DESCRIBE
The types ``‚S\_æ1ø·'' and ``‚S\_æ1©2ø·'' are binding types  constructed by $mk\_ZtupleT$ of \cite{DS/FMU/IED/DTD047}. The constants ``‚mk\_S\_æ1ø·'',``‚mk\_S\_æ1©2·ø'',``‚S\_æ1ø\_1·'', ``‚S\_æ1©2ø\_1·''and ``‚S\_æ1©2ø\_2·'' are the corresponding binding constructors and binding projections  generated by the function $binding\_type\_definition$, described in \cite{DS/FMU/IED/DTD050}. They are required by some of the constants defined below.
=ENDDOC
=THDOC
req_const ("z'Is_ë_Rep",ª:('a ã BOOL) ã BOOLº);
req_defn("z'Is_ë_Rep",([],ªçP:'a ã BOOLéTº));
=DESCRIBE
The representation type of sets, as given by
``‚z'Is\_ë\_Rep·'' is just any function from
the type of objects of the set to ª:BOOLº.
Its definition is saved under the key ``z'Is\_ë\_Rep''.
=ENDDOC
=THDOC
req_type("ë",1);
req_defn("ë",([],ªÑ P:'a ë ã 'a ã BOOLé TypeDefn z'Is_ë_Rep Pº));
=DESCRIBE
The  type of sets ``‚ë·'' is given by the representation
function z'Is\_ë\_Rep.
=ENDDOC
Same as the  type of sets $SET$ in ICL HOL.
=THDOC
req_const("z'abs_ë",ª:('a ã BOOL) ã 'a ëº);
req_const("ù",ª:'a ã 'a ë ã BOOLº);
req_infix(230,"ù");
list_req_defn(["z'abs_ë","ù"],
	([],ªÉ x p S1 S2é (x ù z'abs_ë p Ç p x) Ä
  (S1 = S2 Ç (É xé x ù S1 Ç x ù S2))º));
req_const("hidden_member",ª:'a ã 'a ë ã BOOLº);
req_infix(230,"hidden_member");
req_const("∫",ª:'a ã 'a ë ã BOOLº);
req_infix(230,"∫");
=DESCRIBE
The constant ``‚z'abs\_ë·'' is the set abstraction function.
The constant ``‚ù·'' is the set membership relation. The constant ``‚∫·'' has exactly the same meaning and is required for use in the predicate implicit in a declaration. The third rendition of membership, ``‚hidden\_member·'', is required for the invisible membership assertions which occur when a schema designator is used as a predicate.
=ENDDOC
``ù'' is the same as $ù$ in ICL HOL.
=THDOC
req_thm("ë_thms",([], ª
	É (x : 'a) (p:'a ã BOOL) (S1: 'a ë) (S2 : 'a ë)é
	(x ù (z'abs_ë p) Ç p x) Ä
	((S1 = S2) Ç (É x:'aé x ù S1 Ç x ù S2)) Ä
	å(x ù §)º));
=DESCRIBE
``‚ë\_thms·'' is a miscellaneous collection of theorems about sets, drawn from the definitions,   
which are appropriate for rewriting.
=ENDDOC

=THDOC
req_const("true",ª:BOOLº);
req_defn("true",([],ªtrue = Tº));
req_const("false",ª:BOOLº);
req_defn("false",([],ªfalse = Fº));
req_const("bool",ª:BOOL ëº);
req_defn("bool",([],ªÉ xé x ù bool Ç (x Ç true) Å (x Ç false)º));
=DESCRIBE
The constants ``‚true·'', ``‚false·''  and ``‚bool·'' are equivalent to $T$, $F$ and $BOOL$ respectively in ICL HOL.
=ENDDOC

=THDOC
req_type("Ì", 0);
req_const("Ü_to_Ì",ª:(Ü)$"S_æ1ø" ã Ìº);
=DESCRIBE
???
=ENDDOC

=THDOC
req_const("z'_§",ª:'a ëº);
req_defn("z'_§",([],ªÉ x é å(x ù z'_§)º));
req_const("z'_°",ª:'a ë ã 'a ë ã 'a ëº);
req_infix(260,"z'_°");
req_defn("z'_°",([],ªÉ x S1 S2é x ù S1 z'_° S2 Ç x ù S1 Å x ù S2º));
req_const("singleton_set",ª:'a ã 'a ëº);
req_defn("singleton_set",([],ªÉ x yé y ù singleton_set x Ç y = xº));
=DESCRIBE
The constant ``‚z'\_§·'' is the empty set and ``‚z'\_°·'' is the set union operator. ``‚singleton\_set·'' is the construnction function for a set containing a single element. These constants are used in the formation of the power set and sequence constructors that follow.
=ENDDOC

=THDOC
req_const("z'mk_pset",ª:'a ë ã ('a ë)ëº);
req_defn("z'mk_pset",([],ªÉ X Sé X ù z'mk_pset S Ç (É xé x ù X ä x ù S)º));
req_const("z'mk_set",ª:'a LIST ã 'a ëº);
req_defn("z'mk_set",([],ªz'mk_set Nil = z'_§
	Ä É h t é z'mk_set (Cons  h t) = (z'mk_set t) z'_° (singleton_set h)º));
req_const("z'list_num",ª:Ü ã 'a LIST ã ((Ì, 'a)$"S_æ1©2ø") ëº);
req_defn("z'list_num",([],ªÉnéz'list_num n Nil = z'_§
	Ä É h t é z'list_num n (Cons  h t) = (singleton_set
		($"mk_S_æ1©2ø" (Ü_to_Ì($"mk_S_æ1ø"(Suc n)))h)) 
		z'_° (z'list_num (Suc n) t) º));

req_const("z'mk_seq",ª:'a LIST ã ((Ì, 'a)$"S_æ1©2ø")ëº);
req_defn("z'mk_seq",([],ªÉléz'mk_seq l =  z'list_num 0 lº));
=DESCRIBE
The constants ``‚z'mk\_pset·'' and ``‚z'mk\_set·'' are the power set and set constructors. ``‚z'list\_num·'' is an auxiliary constant used in the definition of ``‚z'mk\_seq·'', the sequence constructor.
=ENDDOC

=THDOC
req_const("z'decl",ª:BOOL LIST ã BOOLº);
req_defn("z'decl",([],ªz'decl [] Ä (É b blé z'decl (Cons b bl) Ç b Ä z'decl bl)º));
req_const("z'totality",ª:'a ë º);
req_defn("z'totality",([],ªÉx:'aéx ù z'totalityº));
req_const("U",ª:('a)$"S_æ1ø" ã 'aº);
req_defn("U",([],ªU = $"S_æ1ø_1"º));
=DESCRIBE
The constant ``‚totality·'' is the set of all members of a type. It is used by the type inference system. ``‚U·'' represents the universal type. ``‚z'decl·'' takes a declaration list and returns a term of type $BOOL$.
=ENDDOC

=THDOC
req_const("z'_á",ª:('a ã BOOL) ã 'aº);
req_defn("z'_á",([],ªÉ f t é ((f = (çxéx = t)) ä (z'_á f = t))º));
req_const("z'apply",ª:(('a,'b)$"S_æ1©2ø")ë ã 'a ã 'b º);
req_defn("z'apply",([],ªÉf (x:'a) é z'apply  f x = 
	z'_á(çy:'bé($"mk_S_æ1©2ø" x y) ù f)º));
req_const("z'_≠",ª:'a ã 'b ã 'aº);
req_defn("z'_≠",([],ªÉ x y é z'_≠ x y = xº));
req_const("z'bind_å",ª:'a ë ã 'a ëº);
req_defn("z'bind_å",([],ªÉ x s é x ù z'bind_å s Ç å(x ù s)º));
=DESCRIBE
``‚z'\_á·'' is the definite description constant.  ``‚z'apply·'' forms an application of one Z term to another. The constant ``‚z'\_≠·'' has the same meaning as $CombK$, the deletion combinator in ICL HOL. ``‚z'bind\_å·'' is schema negation.
=ENDDOC
\subsection{End of the Design of the Theory ``Z''}
=THSML
summarize_td_results ();
val Z_success = theory_check_success ();
=TEX
\subsection{Signature of the theory ``Z''}
=DOC
signature ‚ZTheory· = sig
	val ‚ë_thms· : THM;
	val ‚hidden_member_def· : THM;
	val ‚∫_def· : THM;
	val ‚true_def· : THM;
	val ‚false_def· : THM;
	val ‚bool_def· : THM;
	val ‚z'mk_pset_def· : THM;
	val ‚z'mk_set_def· : THM;
	val ‚z'mk_seq_def· : THM;
	val ‚z'decl_def· : THM;
	val ‚z'totality_def· : THM;
	val ‚U_def· : THM;
	val ‚z'_á_def· : THM;
	val ‚z'apply_def· : THM;
	val ‚z'_≠_def· : THM;
	val ‚z'bind_å_def· : THM;
	
=DESCRIBE
The theorems which define the Z primitive constants are packaged into this signature.
=ENDDOC


\subsection{End of the Signature of the Theory ``Z''}
=SML
end (* end of signature ZTheory*);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

(******Stuff for imp052*****)
val ‚is_PP_rep_thm· = new_specification(["IsPPRep"],1, (
push_goal([],ªÑ IsPPRep:('a ã BOOL) ã BOOL é
	IsPPRep = ç P: 'a ã BOOLé Tº);
a(Ñ_tac ªç x:'a ã BOOLé Tº THEN rewrite_tac[]);
pop_thm()));
val ‚PP_def· = new_type_defn("PP","PP",["'a"],(
push_goal([],ªÑ x: 'a ã BOOL é IsPPRep xº);
a(rewrite_tac[is_PP_rep_thm]);
pop_thm()));


val _ = declare_infix (230,"ee");

val PP_thm = new_specification(["absPP","ee"],2,(
push_goal([],ªÑ (absPP:('a ã BOOL) ã 'a PP)
	($ee : 'a ã 'a PP ã BOOL) é
	É (x : 'a) (p:'a ã BOOL)(S1: 'a PP) (S2 : 'a PP) é
	(x ee (absPP p) Ç p x) Ä
	(S1 = S2 Ç (É x:'aé x ee S1 Ç x ee S2))º);
a (strip_asm_tac (rewrite_rule [is_PP_rep_thm]
	(simple_ä_match_mp_rule type_lemmas_thm PP_def)));
a(MAP_EVERY Ñ_tac
	[ªç x é abs xº,
	ªç x S é (rep S) xº]);
a(asm_rewrite_tac[]);
a(rewrite_tac[all_É_intro(eq_sym_rule(all_simple_É_elim ext_thm))]);
a(REPEAT simple_É_tac THEN Ç_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (ante_tac o ap_fun_rule ªabsº));
a(asm_rewrite_tac[]);
pop_thm()));


val true_def = simple_new_defn("true","true",ªTº);
val false_def = simple_new_defn("false","false",ªFº);

val ‚bool_def· = new_specification(["bool"],1,(
push_goal([],ªÑ bool:BOOL PP é
	Éx:BOOLé(x ee bool)  Ç (x = true) Å (x = false)º);
a(Ñ_tac ªabsPP (çx é (x = true) Å (x = false))º
	THEN rewrite_tac[PP_thm]);
pop_thm()));


val ‚z'mk_pset_def· = new_specification(["z'mk_pset"],1,(
push_goal([],ªÑ z'mk_pset:'a PP ã ('a PP) PP é
	É (X : 'a PP) (S: 'a PP) é 
	X ee z'mk_pset S Ç (Éxéx ee X ä x ee S)º);
a(Ñ_tac ªç S éabsPP(çXéÉxéx ee X ä x ee S)º
	THEN rewrite_tac[PP_thm]);
pop_thm()));

val ‚z'empty_def· = new_specification(["z'empty"],1,(
push_goal([],ªÑ z'empty:'a PP é É x:'a é å(x ee z'empty)º);
a(Ñ_tac ªabsPP(çXéF)º THEN rewrite_tac[PP_thm]);
pop_thm()));


val _ = declare_infix (260,"z'u");
val ‚z'u_def· = new_specification(["z'u"],1,(
push_goal([],ªÑ $z'u: 'a PP ã 'a PP ã 'a PP é
	É (x:'a) (S1 : 'a PP) (S2 : 'a PP) é 
	x ee S1 z'u S2 Ç x ee S1 Å x ee S2º);
a(Ñ_tac ªç S1 S2 é absPP(çxéx ee S1 Å x ee S2)º
	THEN rewrite_tac[PP_thm]);
pop_thm()));

val ‚singleton_set_def· = new_specification(["singleton_set"],1,(
push_goal([],ªÑ singleton_set: 'a ã 'a PP é
	Éx yéy ee singleton_set x Ç (y = x)º);
a(Ñ_tac ªçyéabsPP(çxéx = y)º
	THEN rewrite_tac[PP_thm]);
pop_thm()));

val ‚z'mk_set_def· = new_specification(["z'mk_set"],1,(
push_goal([],ªÑ z'mk_set:'a LIST ã 'a PP é
	z'mk_set Nil = z'empty
	Ä É h t é z'mk_set (Cons  h t) = (z'mk_set t) z'u (singleton_set h)º);
a(strip_asm_tac (list_É_elim
	[ªz'emptyº,ª(ç (h:'a) b (c: 'a LIST) é b z'u (singleton_set h))º
]
	(inst_type_rule[(ª:'a PPº,ª:'bº)] list_prim_rec_thm)));
a(Ñ_tac ªfº  THEN asm_rewrite_tac[]);
pop_thm()));


val ‚z'decl_def· = new_specification(["z'decl"],1,(
push_goal([],ªÑ z'decl:BOOL LIST ã BOOL é
	z'decl Nil
	Ä É b bl é z'decl (Cons  b bl) = (h Ä (z'decl t))º);
a(strip_asm_tac (list_É_elim
	[ªTº,ª(ç (h:BOOL) b (c: BOOL LIST) é  h Ä b)º]
	(inst_type_rule[(ª:BOOLº,ª:'aº),(ª:BOOLº,ª:'bº)] list_prim_rec_thm)));
a(Ñ_tac ªfº  THEN asm_rewrite_tac[]);
pop_thm()));


val ‚z'totality_def· = new_specification(["z'totality"],1,(
push_goal([],ªÑ z'totality:'a PP é Éx:'aéx ee z'totalityº);
a(Ñ_tac ªabsPP(çxéT)º  THEN rewrite_tac[PP_thm]);
pop_thm()));

val ‚U_def· = new_specification(["U"],1,(
push_goal([],ªÑ U:('a) S_æ1ø ã 'a é
	U = S_æ1ø_1º);
a(Ñ_tac ªS_æ1ø_1º  THEN rewrite_tac[]);
pop_thm()));


val U_def = simple_new_defn("U","U",ªS_æ1ø_1º);


val ‚z'Mu_def· = new_specification(["z'Mu"],1,(
push_goal([],ªÑ z'Mu:('a ã BOOL) ã 'a é
	É f t é ((f = (çxéx = t)) ä (z'Mu f = t))º);
a(Ñ_tac ªçf:('a ã BOOL)éáx:'aé f xº  THEN rewrite_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);

a(LEMMA_TªÑxéx=tº(strip_asm_tac o  Ñ_á_rule));
a(Ñ_tac ªtº THEN rewrite_tac[]);
pop_thm()));

val ‚z'bind_å· = new_specification(["z'bind_å"],1,(
push_goal([],ªÑ z'bind_å:'a PP ã 'a PP é
	É x s é  x ee z'bind_å s Ç å(x ee s)º);
a(Ñ_tac ªçs:'a PPéabsPP(çx:'aéå(x ee s))º  THEN rewrite_tac[PP_thm]);
pop_thm()));



