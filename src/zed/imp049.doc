% imp049.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Paragraphs}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP049}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the interface used to input Z specifications into the Z Proof Support System.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.10 (9 June 1992)] First stable issue.
\item[Issue 1.28 (6th October 1992)]
Changed $simple\_z\_type\_defn$ to define unconstrained given sets
equal to $ñU®$.
\item[Issue 1.29~(\FormatDate{92/11/03
})] Fixed bug in treatment of $Q$ in $get\_Z\_any$.
\item[Issue 1.30] Renamed system control flags.
\item[Issue 1.31 (20th November 1992)]
Changes in cache theory handling.
\item[Issue 1.31 (20th November 1992)]
Changes in cache theory handling.
\item[Issues 1.32-1.34 (27th November-3 December 1992)]
Major sort out. Conservative axiomatic descriptions now possible.
Generic terms are variable binding constructs. Generic constraints
have the right quantification. Free type definitions now supported
(at least axiomatically).
\item[Issues 1.35 (4th December 1992)]
Removed undesired keys, and ``local'' proof context.
\end{description}
\subsection{Changes Forecast}
When a Z lexical analyser and a Z lexis is available
\cite{DS/FMU/IED/DTD060}, the
implementation will be modified to use that. Also, the
Z term representation which is used by the parser for
parsed terms will be modified to be brought into line
when the representation has been agreed and made available
in the Z term/schematext parser design \cite{DS/FMU/IED/DTD061}.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The implementation contained in this document corresponds
to the design of Z paragraphs in \cite{DS/FMU/IED/DTD049}.
\subsection{Introduction}
\subsubsection{Background and Purpose}

This is the Z paragraph processor which is described in \cite{DS/FMU/IED/DTD049}.
In order to recognize fragments of Z, a Z reader is required. This
reader is very similar to the HOL reader of \cite{DS/FMU/IED/IMP005}
and is changed to recognize the end of the first line of Z boxes, and
generate a lexeme to indicate this. This is required by the Z grammar
\cite{DS/FMU/IED/DEF007}.

\subsubsection{Dependencies}
The structure $ZParagraphRecognizers$ is constrained by the signature
of the same name, which is specified in \cite{DS/FMU/IED/DTD049}.

\subsubsection{Possible Enhancements}

Changes to this document will be required when the backend to the user
interface has been implemented.

\subsubsection{Deficiencies}

None known.

\section{Z READER WRITER}

=SMLPLAIN SML
structure ÛZReaderWriterÝ : ZReaderWriter = struct
local
open ReaderWriterSupport HOLReaderWriter;
in
=TEX
\subsection{Warning Messages}

Faults detected in the embedded text are reported via $local_error$ as
they occur, they are also noted in the generated output using these
two functions.

=SMLPLAIN SML
fun Ûlex_error_codeÝ (id : int, prev:string list) : string list = (
	", Lex.Text\"" :: (*="=*)
	"Lex.Error " ^ (string_of_int id) ::
	"\", " :: (*="=*)
	prev
);

fun	Ûlex_error_codesÝ (nil : int list, prev:string list) : string list =
		prev
|	lex_error_codes (errnos, prev) =
		fold lex_error_code errnos prev
;
=TEX

\subsection{Recursive Z Parser}

Brackets within Z text need only be examined to see if they relate to
comments, all the other forms of bracket can simple be passed on for
the Z lexical analyser and parser to deal with.

Since the following gets processed by both SCCS and by the HOL reader/writer
of \cite{DS/FMU/IED/IMP005}, care has to be taken with strings containing
upper case $Q$s. The ASCII code for a $Q$ is $81$.

{\ftlinepenalty=9999
=SMLPLAIN SML
fun Ûget_Z_anyÝ (R:READER_ENV) (prevA:string list) (sep_symbol : string)
			: string list= (
let
	open PrettyNames;

	fun	do_keyword _ (_,Value ch,Simple) p =
			get_Z_any R ((to_ML_string ch) :: p) sep_symbol
	|	do_keyword _ (names,Nil,Simple) p =
			get_Z_any R ("%%" ^ (hd names) ^ "%%" :: p) sep_symbol
	|	do_keyword k (info as (_,_, (Starting(proc, str)))) p =
			get_Z_any R (proc R k str false p) sep_symbol
	|	do_keyword _ (_,_,Middle str) p =
			get_Z_any R (str :: p) sep_symbol
	|	do_keyword (k, _) (_,ch_opt,Ending str) p =
			((*=[(("=*)	"\"))" :: k :: "\"], \"" :: str :: p)
	|	do_keyword _ (_,_,Ignore) p =
			get_Z_any R p sep_symbol
	|	do_keyword (k, is_keyword) (names,_,Invalid) p = (
			local_error "get_Z_any" 5007
				[fn () => if is_keyword then "%%" ^ k ^ "%%" else k];
			get_Z_any R (lex_error_code(5007, p)) sep_symbol);

	fun do_string ML_string = (
		let	val (read_string, ol_name) =
				if ML_string
				then	(get_ML_string, "Lex.String")
				else	(get_primed_string, "Lex.Char");
			val (str, errnos) = read_string R (ol_name :: "\", " :: prevA); (*="=*)
			val text_so_far = ", Lex.Text\"" (*="=*) :: str;
		in
			get_Z_any R (lex_error_codes(errnos, text_so_far)) sep_symbol
		end
	);

	val next = #look_at_next R ()
in
	case read_symbol R
	of	SymCharacter ch => (
			case ch
			of "("	=>	(	if #look_at_next R () = "*"
						then
							(skip_comment R;
							get_Z_any R (" " :: prevA) sep_symbol)
						else
							get_Z_any R ( "(" ::  prevA) sep_symbol)
			|  "\""	=>	do_string true (*="=*)
			|  "`"	=>	do_string false
			|  "\^D" =>	prevA
			|  "\81"	=>	get_Z_any R ("\81\81\81\81" :: prevA) sep_symbol
			|  "\\"	=>	get_Z_any R ("\\\\" :: prevA) sep_symbol
			|  _ => 	get_Z_any R (ch :: prevA) sep_symbol
		)
	|	SymWhite xs =>
			if contains xs "\n"
			then	sep_symbol :: prevA
			else	get_Z_any R (" " :: prevA) sep_symbol
	|	SymKnown(sym, is_keyword, info) => do_keyword (sym, is_keyword) info prevA
	|	SymDoublePercent => get_Z_any R ("%%%%" :: prevA) sep_symbol
	|	SymUnknownKw(sym, is_closed) => (
			local_error "get_Z_any" 5003 [fn () => sym, fn () =>
							implode(rev(" ... " :: (prevA to 20)))];
			get_Z_any R (lex_error_code(5003, prevA)) sep_symbol
		)
	|	SymUnknownChar ch => (
			local_error "get_Z_any" 5005
						[fn () => ch,
						fn () => string_of_int(ord ch),
						fn () => implode(" ... " :: (rev(prevA to 20)))];
				get_Z_any R (lex_error_code(5005, prevA)) sep_symbol
		)
end);
=TEX
}

\subsection{Outer Level of the Z Reader}

Z text is to be read, the opening symbol and language name are
given.  Produce Standard~ML text as follows to add onto the left
hand context.

=GFT SML
( recogniser ( "starting symbol", "language name", quoted_text, "closing symbol" ))
=TEX

When the $add_semi$ argument is true then add, additionaly, a semi-colon
to indicate the end of an outermost Standard~ML expression.

Where the $quoted_text$ is a list of values of type $Lex.INPUT$, see
section\ref{DatatypeForParserInterface}.  Function $Z\_reader$ is
responsible for building the opening part of the Standard~ML text,
function $get\_Z\_any$ reads and assembles the quoted text (i.e., the
body of the quotation) and the closing text.

=SMLPLAIN SML
fun ÛZ_readerÝ (recogniser:string) (add_semi:bool) (sep_symbol : string)
		(R:READER_ENV) (start:string, is_keyword:bool)
		(lang:string) (opening:string) (prevA:string list) : string list = (
let
	val prevB =
		opening ::
		"\", [Lex.Text\"" ::
		lang ::
		"\", \"" ::
		start ::
		"(\"" (*=")=*) ::
		recogniser ::
		"(" ::
		prevA;

	val read_text = get_HOL_any R (get_Z_any R prevB sep_symbol);
in
	if add_semi
	then
		";" :: read_text
	else
		read_text
end
);
=TEX


=SMLPLAIN SML
end (* local ... in *);
end (* of structure ZReaderWriter *);
=TEX

\section{TYPE CHECK ONLY MODE}

=SML
structure ÛZTypeCheckOnlyModeÝ : ZTypeCheckOnlyMode = struct
	open	icl'Kernel Unification ZUserInterfaceSupport ZTypeInference;
	open	ZTermGenerator ZTypesAndTermsSupport ;
=TEX

\subsection{Saving Types and Constants in the Theory}

=SML
fun Ûnew_type_clashesÝ ((tyname, arity) : (string * int)) : (string * int) list = (
	case get_type_arity tyname of
	Nil => []
	|Value arity' => if (arity = arity')
			then	[]
			else	[(tyname, arity)]
);

fun Ûnew_type_nofailÝ ((tyname, arity) : (string * int)) : unit = (
	case get_type_arity tyname of
	Nil => (new_type (tyname, arity);())
	|Value arity' =>
		if arity = arity'
		then ()
		else fail "new_type_nofail" 62998 []
);
=TEX
=TEX
For the following $delete\_$ functions we need an auxiliary ``tco\_delete\_to\_level'' function.
This will find out what is to be deleted, and do all the
kernel and user notification required.
=SML
fun Ûtco_delete_to_levelÝ (caller : string) (target : string) (level : int)
			: (string * int) list * (string * TYPE) list = (
let	val dummy = case (get_current_theory_status()) of
		TSNormal => ()
		| TSDeleted => error caller 6008 
			[fn () => get_current_theory_name()]
		| TSLocked => fail caller 6037
			[fn () => get_current_theory_name()]
		| TSAncestor => fail caller 6071
			[fn () => get_current_theory_name()];

	val {children = children,...} = icl'get_theory_info "-";

	val dummy = if children <> [] 
		then fail caller 6076 [fn () => get_current_theory_name()]
		else ();

	val {con_env = con_env,ty_env = ty_env,
		axiom_dict = axiom_dict, thm_dict = thm_dict,
		defn_dict = defn_dict,...} = icl'get_theory "-";

	val (del_con,del_lev1) = split (map (fn (name,{ty = ty,level = lev,...}) => 
			((name, ty),lev))
		(con_env drop (fn (_,{level = lev,...}) => lev < level)));

	val (del_type,del_lev2) = split(map (fn (name,{level = lev,...}) => (name,lev))
		(ty_env drop (fn (_,{level = lev,...}) => lev < level)));

	val del_type_arities = map (fn ty =>
		case get_type_info ty of
		Nil => error "tco_delete_to_level" 49999 []
		|Value (ar, _) => (ty, ar)) del_type;

	val del_thms = map (fn (key,_) => key)
		(thm_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end));

	val (del_axioms, del_lev3) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(axiom_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));

	val (del_defns, del_lev4) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(defn_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));


	val I = Combinators.I;

	val to_be_d = (
		format_list Combinators.I 
		(flat [
		if is_nil del_thms
		then []
		else [get_error_message 12102 
			[if length del_thms = 1 then "" else "s"] ^ 
			(format_list I del_thms ", ")],
		if is_nil del_axioms
		then []
		else [get_error_message 12103 
			[if length del_axioms = 1 then "" else "s"] ^ 
			(format_list I del_axioms ", ")],
		if is_nil del_defns
		then []
		else [get_error_message 12104 
			[if length del_defns = 1 then "" else "s"] ^ 
			(format_list I del_defns ", ")]])
		) "; ";
=TEX
We now ask the interactive user whether he wishes everything
necessary to be deleted.
=SML
	val dummy = case to_be_d of
		"" => ()
		|_ => warn caller 12012 [(fn () => target),(fn () => to_be_d)];
=TEX
We now have permission to proceed:
=SML
	val dl = list_cup[del_lev1, del_lev2, del_lev3, del_lev4];

	val dummy = map icl'delete_thm del_thms;
	val dummy = map (fn x => icl'delete_extension ()) dl;
	val dummy = open_theory"-";
in
	(del_type_arities, del_con)
end);
=TEX
We can now give the deletion functions:
=SML
fun Ûtco_delete_constÝ (cnt : TERM) : (string * int) list * (string * TYPE) list = (
let	val (cnm, cty) = dest_const cnt
		handle complaint =>
		pass_on complaint "dest_const" "delete_const";

	val {con_env = con_env,...} = icl'get_theory "-";

	val {level = level, ty = ty} = force_value(s_lookup cnm con_env)
		handle complaint =>
		divert complaint "force_value" "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm];

	val dummy = if not(is_type_instance ty cty andalso 
			is_type_instance cty ty)
		then fail "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm]
		else ();
in
	tco_delete_to_level "delete_const" cnm level
end);
=TEX
=SML
fun Ûtco_replace_constÝ ((name, ty) : (string * TYPE)) : TERM = (
	case get_const_info name of
	Nil => new_const (name, ty)
	|Value (ty', _) => (
		if ty' =: ty
		then	mk_const (name,ty)
		else	let
				val (tylist, clist) = tco_delete_const (mk_const (name, ty'));
				val side = map new_type (tylist drop (fn(n,_) => n=name));
				val side = map new_const (clist drop (fn(n,_) => n=name));

			in
				new_const (name,ty)
			end
	)
);
=TEX
=SML
fun Ûz_replace_constsÝ (idtyl : (string * TYPE) list) : unit = (
let	val idtyl' = map (fn (n, ty) => (bind_gvar_name n, ty)) idtyl;
	val side = map tco_replace_const idtyl';
in
	()
end);
=TEX
=SML
fun Ûtype_of_formalÝ (id : IDENT) : TYPE = (
	mk_vartype ("'"^(string_of_ident id))
);
=TEX
=SML
fun	Ûtuple_exnameÝ (tyl: EXTYPE list) : string =
	tuple_tname (map type_of_z_extype tyl);
fun	Ûtuple_extypeÝ (tyl: EXTYPE list) :EXTYPE = ExType(tuple_exname tyl,tyl);
=TEX
=SML
fun Ûconsts_in_z_paraÝ (p : Z_PARA) : (string * TYPE) list = (
	case p of
	ZParaAbbDef (id, [], _, Value ty) =>
		[(string_of_ident id, type_of_z_extype ty)]
	|ZParaAbbDef (id, formals, _, Value ty) => 
	let	val fty = mk_z_tuple_t (map mk_z_power_t (map type_of_formal formals));
		val aty = type_of_z_extype ty;
		val ty' = mk_­_type (fty, aty);
	in
		[(string_of_ident id, ty')]
	end
	|ZParaAbbDef (_, _, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaSchBox (id, [], _, Value ty) =>
		[(string_of_ident id, type_of_z_extype ty)]
	|ZParaSchBox (id, formals, _, Value ty) => 
	let	val fty = mk_z_tuple_t (map mk_z_power_t (map type_of_formal formals));
		val aty = type_of_z_extype ty;
		val ty' = mk_­_type (fty, aty);
	in
		[(string_of_ident id, ty')]
	end
	|ZParaSchBox (_, _, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaAxDes ([], _, Value idtyl) => 
		(map (fn (id, ty) => (string_of_ident id, type_of_z_extype ty)) idtyl)
	|ZParaAxDes (formals, _, Value idtyl) => 
	let	val fty = mk_z_tuple_t (map mk_z_power_t (map type_of_formal formals));
		val idtyl' = map (fn (id, ty) => (string_of_ident id,
			mk_­_type (fty, (type_of_z_extype ty)))) idtyl;
	in
		idtyl'
	end
	|ZParaAxDes (_, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaGivenSet (idl, _) =>
	let	val sl = map string_of_ident idl;
	in
		map (fn s => (s, mk_ctype ("SET", [mk_ctype (s,[])]))) sl
	end

	|ZParaFreeType ftl =>
	let	fun do_branch aty (id, Value fty, _) =
		let	val ty' = ExType ("SET", [tuple_extype [fty, aty]]);
		in
			(string_of_ident id, type_of_z_extype ty')
		end
		  | do_branch aty (id, Nil, _) =
			(string_of_ident id, type_of_z_extype aty)
		fun do_prod (id, branches) =
		let	val s = string_of_ident id;
			val aty = ExType (s, []);
			val idty = (s, mk_z_power_t (type_of_z_extype aty));
		in
			idty::(map (do_branch aty) branches)
		end
		fun do_ftd (prod::rest) =
			do_prod prod@do_ftd rest
		  | do_ftd [] = [];
	in
		do_ftd ftl
	end
	|ZParaConstraint _ => []
	|ZParaConjecture _ => []
	|ZParaTerm _ => []
	|ZParaFixity _ => []
);
=TEX
=SML
fun Ûtco_update_theory_dbÝ ((ZParaFixity fixinfo) : Z_PARA) : unit = (
	set_zfixity_info fixinfo
) | tco_update_theory_db p =
let	val consts = consts_in_z_para p;
	val tys = list_cup (map (fn (s, ty) => type_tycons ty) consts);
	val side =
		case list_cup (map (fn ty => new_type_clashes ty) tys) of
		[] => map new_type_nofail tys
		|failures => fail "update_theory_db" 62998 [fn ()=>PolyML.makestring failures];
	val side = z_replace_consts consts;
in
	()
end;
=TEX
=SML
end (* of structure ZTypeCheckOnlyMode *);
=TEX

\section{PROOF SUPPORT MODE}
=SML
structure ÛZProofModeÝ : ZProofMode = struct
local
	open	Unification
		ZUserInterfaceSupport
		ZTypesAndTermsSupport
		ZTypeInference
		ZGeneratedConstants
		ZTermGenerator
		ZTypeCheckOnlyMode;
	
in
=TEX
=SML
val Ûz_type_check_onlyÝ = ref true;
val _ = if contains (map fst (get_flags()))
			"z_type_check_only"
	then	()
	else	new_flag{name = "z_type_check_only",
			control = z_type_check_only,
			default = fun_true,
			check = fun_true
	};
=TEX
=SML
val Ûz_use_axiomsÝ = ref true;
val _ = if contains (map fst (get_flags()))
			"z_use_axioms"
	then	()
	else	new_flag{name = "z_use_axioms",
			control = z_use_axioms,
			default = fun_true,
			check = fun_true
	};
=TEX
=SML
datatype ÛPARAINFOÝ =
	ÛFixityInfoÝ of FIXITY
	|ÛAbbDefInfoÝ of string * string list * TERM
	|ÛSchBoxInfoÝ of string * string list * TERM
	|ÛAxDesInfoÝ of string list * TERM * TERM OPT * (string * TYPE) list
	|ÛFreeTypeInfoÝ of (string * (string * TERM OPT) list) list
	|ÛGivenSetInfoÝ of string list * (string list * TERM) OPT
	|ÛConstraintInfoÝ of string list * TERM
	|ÛConjectureInfoÝ of string OPT * string list * TERM;
=TEX
=SML
fun Ûmk_fixity_infoÝ (fixinfo : FIXITY) = (
	FixityInfo fixinfo
);
=TEX
=SML
fun Ûmk_abbdef_infoÝ ((id, idl, z_tm, oty) : IDENT * IDENT list * Z_TM * EXTYPE OPT) = (
	AbbDefInfo (string_of_ident id, map string_of_ident idl, term_of_z_tm z_tm)
);
=TEX
=SML
fun Ûmk_schbox_infoÝ ((id,idl,sch, _) : IDENT * IDENT list * Z_SCH_TEXT * EXTYPE OPT) : PARAINFO = (
let	val tm = term_of_z_tm (ZTmHorizSchema sch);
in
	SchBoxInfo (string_of_ident id, map string_of_ident idl, tm)
end);
=TEX
=SML
fun Ûmk_axdes_infoÝ ((idl, sch, Value idtyl) : IDENT list * Z_SCH_TEXT *
				(IDENT * EXTYPE) list OPT) : PARAINFO = (
let	val (tm, otm) = term_of_z_schtext sch;
	val idtyl' = map (fn (id, ty) => (string_of_ident id, type_of_z_extype ty)) idtyl;
in
	AxDesInfo (map string_of_ident idl, tm, otm, idtyl')
end
) | Ûmk_axdes_infoÝ (_, _, Nil) = (
	fail "mk_axdes_info" 49000 []
);
=TEX
=SML
fun Ûmk_freetype_infoÝ (ftdeflist : (IDENT * (IDENT * EXTYPE OPT * Z_TM OPT) list) list) : PARAINFO= ( 
let	fun aux (id, _, Value z_tm) =
		(string_of_ident id, Value (term_of_z_tm z_tm))
	  | aux (id, _, Nil) = (string_of_ident id, Nil);
	fun aux1 (id, branch) = (string_of_ident id, map aux branch);
in
	FreeTypeInfo (map aux1 ftdeflist)
end);
=TEX
=SML
fun Ûmk_givenset_infoÝ ((idl, Value (gens, z_tm)) : IDENT list * (IDENT list * Z_TM) OPT) : PARAINFO = (
	GivenSetInfo (map string_of_ident idl, Value (map string_of_ident gens,term_of_z_tm z_tm))
) | mk_givenset_info (idl, Nil) = GivenSetInfo  (map string_of_ident idl, Nil);

=TEX
=SML
fun Ûmk_constraint_infoÝ ((idl, z_tm) : (IDENT list * Z_TM)) : PARAINFO = (
		ConstraintInfo (map string_of_ident idl, term_of_z_tm z_tm)
);
=TEX
=SML
fun Ûmk_conjecture_infoÝ ((Value id, idl, z_tm) : (IDENT OPT * IDENT list * Z_TM)) : PARAINFO = (
		ConjectureInfo (Value (string_of_ident id),
			map string_of_ident idl, term_of_z_tm z_tm)
) | mk_conjecture_info (Nil, idl, z_tm) = (
		ConjectureInfo (Nil, map string_of_ident idl, term_of_z_tm z_tm)
);
=TEX
=SML
fun Ûparainfo_of_z_paraÝ (p : Z_PARA) : PARAINFO = (
let	fun aux (ZParaFixity pbody) = (
		mk_fixity_info pbody
	) | aux (ZParaAbbDef pbody) = (
		mk_abbdef_info pbody
	) | aux (ZParaSchBox pbody) = (
		mk_schbox_info pbody
	) | aux (ZParaAxDes pbody) = (
		mk_axdes_info pbody
	) | aux (ZParaFreeType pbody) = (
		mk_freetype_info pbody
	) | aux (ZParaGivenSet pbody) = (
		mk_givenset_info pbody
	) | aux (ZParaConstraint pbody) = (
		mk_constraint_info pbody
	) | aux (ZParaConjecture pbody) = (
		mk_conjecture_info pbody
	) | aux _ = (
		fail "parainfo_of_z_para" 49999 []
	);
in
	do_in_theory (force_get_cache_theory()) aux p
end);
=TEX
\subsection{Dummy Caller of const$\_$spec}
The following could have something to force a good proof
context (e.g. one containing ``$'$z$\_predicates'')
to be added, but it seems redundant and inefficient.
=SML
fun Ûparagraph_const_specÝ (args : string list * TERM list * TERM) : THM = (
	const_spec args
);

=TEX
\subsection{Checks}
For given sets we (including free types), we must check that the
name is not in use as a type name and that the z-ified name is
not in use as a constant name:
=SML
fun check_gset_name (s : string) : unit = (
	case (get_type_arity s, get_const_type (bind_gvar_name s)) of
		(_, Value _) => fail "check_gset_name" 49003 [fn _ => s]
	|	(Value _, _) => fail "check_gset_name" 49002 [fn _ => s]
	|	_ => ()
);
=TEX
For other global variables we only need to check the use of the
z-ified name:
=SML
fun check_gvar_name (s : string) : unit = (
	case get_const_type (bind_gvar_name s) of
		Value _ => fail "check_gvar_name" 49003 [fn _ => s]
	|	_ => ()
);
=TEX
\section{DEFINITIONS BY AXIOM} 

=SML
fun Ûabbdef_defnÝ (flag : bool) ((name, gen_formals, tm) : string * string list * TERM) : unit = (
let	val wrap = if flag then ¬$"Z'SchBox"® else ¬$"Z'AbbDef"®;
	val side_effect = check_gvar_name name;
	val name' = bind_gvar_name name;
	val ty = type_of tm;
in
	case map (mk_z_power_t o mk_z_var_t) gen_formals of
	[] => (
		let	val var = mk_var(name, ty);
			val var' = mk_var(name', ty) ;
			val tm' = subst [(var', var)] tm;
			val defn1 = mk_eq(var', tm');
			val defn2 = mk_app (wrap, defn1);
			val side = paragraph_const_spec ([name],[var'], defn2);
		in
			()
		end)
	| gftyl => (
		let	val ty' = mk_­_type(mk_z_tuple_t gftyl,ty);
			val var = mk_var(name, ty');
			val var' = mk_var (name', ty');
			val tm' = subst [(var', var)] tm;
			val gfl = map mk_var (combine gen_formals gftyl);
			val arg = mk_z_tuple gfl;
			val side = do_in_theory (force_get_cache_theory()) tuple_gen_semantic_const arg;
			val defn1 = mk_eq(mk_app(var', arg), tm');
			val defn2 = list_mk_µ (gfl, defn1);
			val defn3 = mk_app (wrap, defn2);
			val side = paragraph_const_spec ([name], [var'], defn3);
		in
			()
		end)
end

);

=TEX
=SML
fun Ûax_axdes_defnÝ ((gen_formals, tm1, otm, idtyl) : string list * TERM * TERM OPT * (string * TYPE) list) : unit = (
let	val def_tm = case otm of
		Value tm2 => mk_± (tm1, tm2)
		|Nil => mk_± (tm1, mk_t);
	val gens = map (fn id => mk_var (id, (mk_z_power_t o mk_z_var_t) id)) gen_formals;
	val vars = map mk_var idtyl;
	val side_effect = (map (check_gvar_name o fst) idtyl; ());
	val zidtyl = map (fn (id, ty) => (bind_gvar_name id, ty)) idtyl;
	val zconsts = map mk_const zidtyl;
	val generify = (
		case gens of
		[] => Combinators.I
		|_ => (
			let	val pval = mk_z_tuple gens;
				val side = do_in_theory (force_get_cache_theory()) tuple_gen_semantic_const pval;
				val ptype = type_of pval;
			in	(fn v =>
					let	val (s, ty) = dest_const v;
						val v' = mk_const(s, mk_­_type (ptype, ty));
					in
						mk_app(v', pval)
					end)
			end
			)
	);

	val constsubs = map (fn (v1, v2) => (generify v1, v2)) (combine zconsts vars);
	val newconsts = map (fst o strip_app o fst) constsubs;
	val def_tm' = subst constsubs def_tm;
	val defn1 = list_mk_µ (gens, def_tm');
	val defn2 = mk_app(¬$"Z'AxDes"®, defn1);
	val side = map (new_const o dest_const) newconsts;
	val side = new_axiom ((map fst idtyl), defn2);
in
	()
end);
=TEX
=SML
fun Ûcons_axdes_defnÝ ((gen_formals, tm1, otm, idtyl) : string list * TERM * TERM OPT * (string * TYPE) list) : unit = (
let	val def_tm = case otm of
		Value tm2 => mk_± (tm1, tm2)
		|Nil => mk_± (tm1, mk_t);
	val gens = map (fn id => mk_var (id, (mk_z_power_t o mk_z_var_t) id)) gen_formals;
	val vars = map mk_var idtyl;
	val side_effect = (map (check_gvar_name o fst) idtyl; ());
	val zidtyl = map (fn (id, ty) => (bind_gvar_name id, ty)) idtyl;
	val zvars = map mk_var zidtyl;
	val generify = (
		case gens of
		[] => Combinators.I
		|_ => (
			let	val pval = mk_z_tuple gens;
				val side = do_in_theory (force_get_cache_theory()) tuple_gen_semantic_const pval;
				val ptype = type_of pval;
			in	(fn v =>
					let	val (s, ty) = dest_var v;
						val v' = mk_var(s, mk_­_type (ptype, ty));
					in
						mk_app(v', pval)
					end)
			end
			)
	);

	val varsubs = map (fn (v1, v2) => (generify v1, v2)) (combine zvars vars);
	val newvars = map (fst o strip_app o fst) varsubs;
	val def_tm' = subst varsubs def_tm;
	val defn1 = list_mk_µ (gens, def_tm');
	val defn2 = mk_app(¬$"Z'AxDes"®, defn1);
	val side = paragraph_const_spec ((map fst idtyl), newvars, defn2);
in
	()
end);
=TEX
=SML
fun Ûsimple_new_z_typeÝ (s : string) : THM = (
let	val side_effect = check_gset_name s;
	val ty = new_type (s, 0);
	val zs = bind_gvar_name s;
	val var = mk_var (zs, mk_z_power_t ty);
	val totty = mk_z_power_t ty;
	val tot = mk_const("Totality",totty);
	val U = mk_const("z'U",mk_­_type(mk_z_tuple_t[totty],totty));
	val tm = mk_eq (var, mk_app(U,mk_z_tuple[tot]));
in
	paragraph_const_spec ([s], [var], tm)
end);
=TEX

=SML
fun Ûnew_z_typeÝ (sl : string list) (tm : TERM) : THM = (
let	val tyl = map (fn s => (check_gset_name s; new_type (s, 0))) sl;
in
	new_axiom (sl, tm)
end);
=TEX

=SML
fun Ûgivenset_defnÝ ((idl, Nil) : string list * (string list * TERM) OPT) : unit = (
	map simple_new_z_type idl; ()
) | givenset_defn (idl, Value (idl', tm)) = (
let	val frees = (map (fst o dest_var) (frees tm)) drop ((switch o curry) (op mem) idl');
	val simplesets = idl drop ((switch o curry) (op mem) frees);
	val side = map simple_new_z_type simplesets;
	val side = new_z_type (idl diff simplesets) tm;
in
	()
end);
=TEX
Free type definition processing involves rather more messing about than
the other sorts of paragraph. We have to build apparatus to construct
the defining property for the free type from the syntax of its constructors.
The following tiresome code does this.
=SML
local
=TEX
We need the following types:
=SML
	val a = ”'a®;
	val Ûð'aÝ : TYPE = mk_z_power_t a;
	val b = ” 'b®;
	val Ûð'bÝ : TYPE = mk_z_power_t b;
	val ú = mk_ctype("ú", []);
=TEX
We need to be able to construct terms formed with $ran$ ...
=SML
	val Ûran_tyÝ = mk_z_power_t(mk_z_tuple_t[
				mk_z_power_t(mk_z_tuple_t[a, b]) , ð'b]);
	val ÛranÝ = mk_z_gvar("ran", ran_ty,  [mk_u ð'a, mk_u ð'b]);
	fun Ûmake_ranÝ (f : TERM) : TERM = (
		let 	val tys = dest_z_tuple_t (dest_z_power_t (type_of f));
			val ty1 = hd tys;
			val ty2 = hd(tl tys);
			val iran = inst [] [(ty1, a), (ty2, b)] ran;
		in	mk_z_app(iran, f)
		end
	);
=TEX
... and $disjoint$ ...
=SML
	val Ûdisjoint_tyÝ : TYPE = mk_z_power_t(mk_z_power_t(mk_z_tuple_t[a, ð'b]));
	val ÛdisjointÝ = mk_z_gvar("disjoint _", disjoint_ty, [mk_u ð'a, mk_u ð'b]);
	fun Ûmk_disjointÝ (ty : TYPE) (sl : TERM list) = (
		let	val idisjoint = inst [] [(ú, a), (ty, b)] disjoint;
		in	mk_z_(mk_z_§¢ (mk_z_power_t ty, sl), idisjoint)
		end
	);
=TEX
... and $À$ ...
=SML
	val ÛÀ_tyÝ : TYPE = mk_z_power_t(mk_z_tuple_t[mk_z_tuple_t[ð'a, ð'a], ð'a]);
	val ÛÀÝ : TERM = mk_z_gvar("_ À _", À_ty, [mk_u ð'a]);
	fun Ûlist_ÀÝ (ty : TYPE) (ts : TERM list) : TERM = (
		let	val iÀ = inst [] [(ty,  a)] À;
			fun make_À t1 t2 = mk_z_app(iÀ, mk_z_tuple[t1, t2]);
			fun aux []  = mk_z_setd (ty, [])
			|   aux [t] = t
			|   aux (t::more) = make_À t (aux more);
		in	aux ts
		end
	);
=TEX
... and $€$ ...
=SML
	val Û€_tyÝ : TYPE = mk_z_power_t(mk_z_tuple_t[ð'a, ð'a]);
	val Û€Ý : TERM = mk_z_gvar("_ € _", €_ty, [mk_u ð'a]);
	fun Ûmake_€Ý (ty : TYPE) (t1 : TERM) (t2 : TERM) : TERM = (
		let	val i€ = inst [] [(ty,  a)] €;
		in	mk_z_(mk_z_tuple[t1, t2], i€)
		end
	);
=TEX
... and relational image ...
=SML
	val Ûrel_image_tyÝ : TYPE = mk_z_power_t(mk_z_tuple_t[
			mk_z_tuple_t[mk_z_power_t(
				mk_z_tuple_t[a, b]), ð'a] , ð'b]);
	val Ûrel_imageÝ : TERM = mk_z_gvar("_ ¨ _ ©", rel_image_ty, [mk_u ð'a, mk_u ð'b]);
	fun Ûmake_rel_imageÝ (f : TERM) (t : TERM): TERM = (
		let 	val tys = dest_z_tuple_t (dest_z_power_t (type_of f));
			val ty1 = hd tys;
			val ty2 = hd(tl tys);
			val irel_image = inst [] [(ty1, a), (ty2, b)] rel_image;
		in	mk_z_app(irel_image, mk_z_tuple[f, t])
		end
	);
=TEX
... and $à$.
=SML
	val Ûà_tyÝ : TYPE = mk_z_power_t(mk_z_power_t(mk_z_tuple_t[a, b]));
	fun Ûmake_àÝ (ty1 : TYPE) (t1 : TERM) (ty2 : TYPE) (t2 : TERM) : TERM = (
		let	val ià_ty = inst_type [(ty1,  a), (ty2,  b)] à_ty;
		in	mk_z_gvar("_ à _", ià_ty, [t1, t2])
		end
	);
=TEX
Now we can define functions to compute the bits of the defining property.
In the following
\begin{description}
\item[$ty$] is the type of the free type
\item[$tyn$] is the name of the free type
\item[$fty$] is the global variable (HOL constant) which is the set of all
elements of the free type
\item[$bs$] is the branches of the free type, with the constructors as
local variables (HOL variables) of the appropriate type, and the domains
of the constructors with instances of $fty$ as global variables (not the
local variables which the type inferrer will have planted).
\item[$w$] is the local variable to appear in the universal quantification
\end{description}


Note that the constructor names need to be local variables here
not globals, (since they will be passed on to $axdes\_defn$, which expects
the variables to be defined to be local).

First a function to construct the set display ...
=SML
	fun Ûmake_ft_setdÝ (ty : TYPE) (bs : (TERM * TERM OPT) list) : TERM OPT = (
		case map fst (bs drop (not o is_Nil o snd)) of
			[] => Nil
		|	ts => Value (mk_z_setd (ty, ts))
		
	);
=TEX
... then the union ...
=SML
	fun Ûmake_ft_ÀÝ (ty : TYPE) (bs : (TERM * TERM OPT) list)
			(w : TERM) (fty : TERM) : TERM = (
		let	fun aux [] = []
			|   aux ((f, Value t) :: more) = (
				let	val t' = subst [(w, fty)] t;
				in	make_rel_image f t'
				end :: aux more
			) | aux (_ :: more) = aux more;
		in	case make_ft_setd ty bs of
				Nil => list_À ty (aux bs)
			|	Value t => list_À ty (t :: aux bs)
		end
	);
=TEX
... then the disjointness assertion ...
=SML
	fun Ûmake_ft_disjointÝ (ty : TYPE) (bs : (TERM * TERM OPT) list) : TERM = (
		let	fun aux [] = []
			|   aux ((f, Value t) :: more) = (
				make_ran f :: aux more
			) | aux ((c, Nil) :: more) = (
				mk_z_setd (ty, [c]) :: aux more
			);
		in	mk_disjoint ty (aux bs)
		end
	);
=TEX
... then put these together to form the predicate part of the definition ...
=SML
	fun Ûmake_ft_predÝ
			(fty : TERM)
			(ty : TYPE) (bs : (TERM * TERM OPT) list) : TERM = (
		let	val w = mk_z_lvar("W", mk_z_power_t ty, []);
			val disj = make_ft_disjoint ty bs;
			val €1 = make_€ ty (make_ft_À ty bs w fty) w;
			val €2 = make_€ ty fty w;
			val decl = mk_z_decl[mk_z_dec([w], mk_z_ð fty)];
		in	mk_±(disj, mk_z_µ(decl, €1, €2))
		end
	);
=TEX
... and, finally, form the declaration part of the definition.
=SML
	fun Ûmake_ft_decsÝ (fty : TERM) (ty : TYPE) (bs : (TERM * TERM OPT) list) : TERM list = (
		let	val cs = map fst (bs drop (not o is_Nil o snd));
			val ds = map (Combinators.I ** force_value)
						(bs drop (is_Nil o snd));
			fun aux [] = []
			|   aux ((f, t) :: more) = (
				mk_z_dec
				([f],
				make_à
				((dest_z_power_t o type_of) t)
				t
				ty
				fty)
				:: aux more
			);
		in	case cs of
				[] =>  (aux ds)
			|	_ =>  (mk_z_dec(cs, fty) :: aux ds)
		end
	);
=TEX
Now a function to construct the constructors from the information
passed on by the type inferrer.
=SML
	fun Ûmake_constructorsÝ
		(tyn : string)
		(ty : TYPE)
		(fty : TERM)
		(pars : (string * TERM OPT) list)
		: (TERM * TERM OPT) list = (
		let	fun make_con_ty t = (
				mk_z_power_t(mk_z_tuple_t[dest_z_power_t(type_of t),ty])
			);
			fun aux (n, Nil) = (mk_var(n, ty), Nil)
			|   aux (n, Value t) = (
					(mk_var(n, make_con_ty t),
					Value (subst
					[(fty, mk_var(tyn, mk_z_power_t ty))] t))
			);
		in	map aux pars
		end
	);
=TEX
We need to check that all of the library objects we use are in scope:
=SML
	val things_to_check = [
		dest_const (fst (strip_app ran)),
		dest_const (fst (strip_app disjoint)),
		dest_const (fst (strip_app À)),
		dest_const (fst (strip_app €)),
		dest_const (fst (strip_app rel_image)),
		dest_const (fst (strip_app (make_à a (mk_u (ð'a)) b (mk_u ð'b))))
	];
	fun Ûfty_scope_checkÝ () : unit = (
		let	fun same_ty ty1 ty2 = (
				(type_match ty1 ty2;
				type_match ty2 ty1;
				true)
				handle Fail _ => false
			);
			fun chk [] = []
			|   chk ((s, ty) :: more) = (
				case get_const_type s of
					Value t => (
						if same_ty ty t
						then chk more
						else mk_const (s, ty) :: chk more
				) |	Nil => mk_const (s, ty) :: chk more
			);
		in	case chk things_to_check of
				[] => ()
			|	tms =>
				fail "freetype_defn" 49005
				[fn () => format_list string_of_term tms " "]
		end
	);
=TEX
And, at long last, the function to bring all the above together.
=SML
in
fun Ûfreetype_defnÝ ([] : (string * ((string * TERM OPT)list))list) : unit = (
	error "freetype_defn" 49004 [fn()=>"unexpected empty list"]
) | Ûfreetype_defnÝ ftyl : unit = (
let	val tynames = map fst ftyl;
	val side_effect = fty_scope_check();
	val side_effect = map (map (check_gvar_name o fst)) (map snd ftyl);
	fun do1 (tyn, pars) = (
		let	val ty = mk_ctype(tyn, []);
			val fty = mk_z_gvar(tyn, mk_z_power_t ty, []);
			val bs = make_constructors tyn ty fty pars;
		in	(make_ft_decs fty ty bs, (make_ft_pred fty ty bs, bs))
		end
	);
	fun do_all ftyl = (
		let	val (decs, predsbs) = split (map do1 ftyl);
			val preds = map fst predsbs;
			val vs = map fst(flat (map snd predsbs));
			val decl = mk_z_decl (flat decs);
			val pred = list_mk_± preds;
		in	([], decl, Value pred, map dest_var vs)
		end
	);
in	givenset_defn (tynames, Nil);
	ax_axdes_defn (do_all ftyl)
end);
end (* of local ... in ... end *)
=TEX
=SML
=SML
fun Ûnext_axiom_nameÝ (s : string) : string = (
let	val axiom_names = flat (map fst (get_axioms "-"));
	fun aux i =
	let	val si = s^(string_of_int i);
	in	if si mem axiom_names
		then	aux (i+1)
		else	si
	end;
in
	aux 1
end);
=TEX
=SML
fun Ûconstraint_defnÝ  ((gpars, tm) : string list * TERM) : unit = (
let	val vs = map (fn n => mk_var(n, mk_z_power_t(mk_vartype("'" ^ n)))) gpars;
in	new_axiom([next_axiom_name "Constraint "], list_mk_µ(vs, tm)); ()
end);
=TEX
=SML
fun Ûax_update_theory_dbÝ (para : Z_PARA) : unit = (
	case parainfo_of_z_para para of
	FixityInfo fixinfo => set_zfixity_info fixinfo
	|AbbDefInfo pbody => abbdef_defn false pbody
	|SchBoxInfo pbody => abbdef_defn true pbody
	|AxDesInfo pbody => ax_axdes_defn pbody
	|GivenSetInfo pbody => givenset_defn pbody
	|FreeTypeInfo pbody => freetype_defn pbody
	|ConstraintInfo pbody => constraint_defn pbody
	|ConjectureInfo _ => ()
);
=TEX
=SML
fun Ûcons_update_theory_dbÝ (para : Z_PARA) : unit = (
	case parainfo_of_z_para para of
	FixityInfo fixinfo => set_zfixity_info fixinfo
	|AbbDefInfo pbody => abbdef_defn false pbody
	|SchBoxInfo pbody => abbdef_defn true pbody
	|AxDesInfo pbody => cons_axdes_defn pbody
	|GivenSetInfo pbody => givenset_defn pbody
	|FreeTypeInfo pbody => freetype_defn pbody
	|ConstraintInfo pbody => constraint_defn pbody
	|ConjectureInfo _ => ()
);
=TEX
=SML
fun Ûmy_tco_update_theory_dbÝ (para : Z_PARA) : unit = (
	case parainfo_of_z_para para of
	FixityInfo fixinfo => set_zfixity_info fixinfo
	|GivenSetInfo pbody => givenset_defn pbody
	|FreeTypeInfo pbody => freetype_defn pbody
	|_ => tco_update_theory_db para
);
=TEX
=SML
fun Ûupdate_theory_dbÝ (para : Z_PARA) : unit = (
	(if get_flag "z_type_check_only"
	then my_tco_update_theory_db
	else if get_flag "z_use_axioms"
	then ax_update_theory_db
	else cons_update_theory_db) para
);
=TEX
=SML
end (* of local ... in *);
end (* of structure ZProofMode *);
=TEX


\section{THE STRUCTURE FOR Z PARAGRAPH PROCESSORS}

=SML
structure ÛZParagraphRecognizersÝ : ZParagraphRecognizers = struct
=TEX
=SML
local
	open Lex SymbolTable ReaderWriterSupport;
	open HOLReaderWriter PrettyNames;
	open ZReaderWriter;
	open ZUserInterfaceSupport ZLex ZParser ZTypeInference ZTermGenerator;
in

val ÛdebugÝ : Z_INFERRED OPT ref = ref Nil;

val Ûstandard_z_parasÝ = ref true;

val _ = if contains (map fst (get_flags()))
			"standard_z_paras"
	then	()
	else	new_flag{name = "standard_z_paras",
			control = standard_z_paras,
			default = fun_true,
			check = fun_true
	};

val Ûstandard_z_termsÝ = ref false;

val _ = if contains (map fst (get_flags()))
			"standard_z_terms"
	then	()
	else	new_flag{name = "standard_z_terms",
			control = standard_z_terms,
			default = fun_false,
			check = fun_true
	};
=TEX


\subsection{Processing Z Terms}

=SML
fun Ûterm_of_z_paraÝ ((ZParaTerm (gpars, tm, _)) : Z_PARA) : TERM = (
let	val vns = map string_of_ident gpars;
	val vs = map (fn vn => mk_var(vn, mk_z_power_t(mk_vartype ("'" ^ vn)))) 
			vns;
in	list_mk_µ(vs, (do_in_theory (force_get_cache_theory()) term_of_z_tm tm))
end
) | term_of_z_para _ = (
fail "z_term_recogniser" 49001 []
);
=TEX

=SML
fun Ûz_para_of_zinferredÝ ((ZInferred p) : Z_INFERRED) : Z_PARA = (
	p
) | z_para_of_zinferred (ZTypeError inf) = (
	print_z_error inf
);
=TEX


\section{THE STRUCTURE FOR Z PARAGRAPHS}


The first thing to do is to tell the reader/writer about the
Z paragraph delimiting symbols.

=SMLLITERAL

val sd = add_new_symbols [
	([	"StartZGeneric"],	Value "", Starting(specific_quotation, "")),
	([	"StartZSchema"],	Value "ÿ", Starting(specific_quotation, "")),
	([	"EndZBox"],		Value "ˆ", Ending ""),
	([	"StartZTerm"],	Value "ñ", Starting(specific_quotation, ""))
] handle (Fail _) => ();
=TEX
The true box recognizers (generic constants and schema boxes) use the
new Z reader. The other boxes can use the HOL reader.
=SML
val Ûz_axbox_readerÝ = HOL_reader "z_axbox_recogniser" true;
val Ûz_genbox_readerÝ = Z_reader "z_genbox_recogniser" true "œ";
val Ûz_schbox_readerÝ = Z_reader "z_schbox_recogniser" true "ü";
val Ûz_term_readerÝ = HOL_reader "z_term_recogniser" false;
val Ûz_other_readerÝ = HOL_reader "z_other_recogniser" true;
=TEX
=SMLLITERAL
val sd = map add_named_reader [
	("¹", "ZAX", "Lex.Term", z_axbox_reader),
	("¹", "Z", "Lex.Term", z_other_reader)
	] handle (Fail _) => [];

val sd = map add_specific_reader [
	("", "Lex.Term", z_genbox_reader),
	("ÿ", "Lex.Term", z_schbox_reader),
	("ñ", "Lex.Term", z_term_reader)
	] handle Fail _ => [];

val sd = map add_general_reader [
	("¬", "Z", "Lex.Term", z_term_reader)
	] handle Fail _ => [];
=TEX


\section{PARAGRAPH RECOGNIZERS}

\subsection{Z Axiomatic Box Recogniser}

=SML
fun Ûz_axbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "¹")
			andalso	is_same_symbol(finish, "°")
			andalso	(lang = "ZAX")
		then	()
		else
			fail "z_axbox_recogniser" 49001 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "standard_z_paras";
	val tco = get_flag "z_type_check_only";
	val tokens = ZTAx::(z_lex value);
	val parsed = z_parser {is_quot = false} tokens;
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = tco} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	(ZProofMode.update_theory_db para)
	handle ex => reraise ex "z_axbox_recogniser"
end);

=TEX
\subsection{Z Generic Box Recogniser}
=SML
fun Ûz_genbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZGeneric")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_genbox_recogniser" 49002 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "standard_z_paras";
	val tco = get_flag "z_type_check_only";
	val tokens = ZTAx::(z_lex value);
	val parsed = z_parser {is_quot = false} tokens;
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = tco} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	(ZProofMode.update_theory_db para)
	handle ex => reraise ex "z_genbox_recogniser"
end);

=TEX
\subsection{Z Schema Box Recogniser}
=SML
fun Ûz_schbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZSchema")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_schbox_recogniser" 49003 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "standard_z_paras";
	val tco = get_flag "z_type_check_only";
	val tokens = ZTSch::(z_lex value);
	val parsed = z_parser {is_quot = false} tokens;
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = tco} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	(ZProofMode.update_theory_db para)
	handle ex => reraise ex "z_schbox_recogniser"
end);
=TEX
\subsection{Z General Text Recogniser}
=SML
fun Ûz_other_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "¹")
			andalso	is_same_symbol(finish, "°")
			andalso	(lang = "Z")
		then	()
		else
			fail "z_other_recogniser" 49004 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "standard_z_paras";
	val tco = get_flag "z_type_check_only";
	val tokens = z_lex value;
	val parsed = z_parser {is_quot = false} tokens;
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = tco} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	(ZProofMode.update_theory_db para)
	handle ex => reraise ex "z_other_recogniser"
end);
=TEX
\section{RECOGNIZING Z TERMS}

=SML
fun Ûz_term_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if(	is_same_symbol(start, "StartZTerm")
			andalso	is_same_symbol(finish, ">")
			andalso	(lang = "")
		) orelse (
			is_same_symbol(start, "<")
			andalso	is_same_symbol(finish, ">")
			andalso	lang = "Z"
		)
		then	()
		else
			fail "z_term_recogniser" 49010 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "standard_z_terms";
	val tokens = z_lex value;
	val parsed = z_parser {is_quot = true} tokens;
	val side = case parsed of
		ZParaTerm _ => ()
		|_ => fail "z_term_recogniser" 49001 [];
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = true} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in	term_of_z_para para
end);


=TEX

\section{EPILOGUE}

The structure for Z paragraphs is required to be open for use by the
reader/writer.

=SML
end (* of local ... in *);
end (* of structure ZParagraphRecognizers *);
open ZParagraphRecognizers;
=TEX

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}


=IGN

val x= mk_z_app (ñ{(a,b)}®, ñy®);

new_axiom(["thing"],x);





°
