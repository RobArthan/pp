% imp049.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Paragraphs}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP049}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the interface used to input Z specifications into the Z Proof Support System.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.10 (9 June 1992)] First stable issue.

\end{description}
\subsection{Changes Forecast}
When a Z lexical analyser and a Z lexis is available
\cite{DS/FMU/IED/DTD060}, the
implementation will be modified to use that. Also, the
Z term representation which is used by the parser for
parsed terms will be modified to be brought into line
when the representation has been agreed and made available
in the Z term/schematext parser design \cite{DS/FMU/IED/DTD061}.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The implementation contained in this document corresponds
to the design of Z paragraphs in \cite{DS/FMU/IED/DTD049}.
\subsection{Introduction}
\subsubsection{Background and Purpose}

This is the Z paragraph processor which is described in \cite{DS/FMU/IED/DTD049}.
In order to recognize fragments of Z, a Z reader is required. This
reader is very similar to the HOL reader of \cite{DS/FMU/IED/IMP005}
and is changed to recognize the end of the first line of Z boxes, and
generate a lexeme to indicate this. This is required by the Z grammar
\cite{DS/FMU/IED/DEF007}.

\subsubsection{Dependencies}
The structure $ZParagraphs$ is constrained by the signature
of the same name, which is specified in \cite{DS/FMU/IED/DTD049}.

\subsubsection{Possible Enhancements}

Changes to this document will be required when the backend to the user
interface has been implemented.

\subsubsection{Deficiencies}

None known.


\section{Z READER WRITER}

=SMLPLAIN SML
structure ÛZReaderWriterÝ : ZReaderWriter = struct
local
open ReaderWriterSupport HOLReaderWriter;
in
=TEX
\subsection{Warning Messages}

Faults detected in the embedded text are reported via $local_error$ as
they occur, they are also noted in the generated output using these
two functions.

=SMLPLAIN SML
fun Ûlex_error_codeÝ (id : int, prev:string list) : string list = (
	", Lex.Text\"" :: (*="=*)
	"Lex.Error " ^ (string_of_int id) ::
	"\", " :: (*="=*)
	prev
);

fun	Ûlex_error_codesÝ (nil : int list, prev:string list) : string list =
		prev
|	lex_error_codes (errnos, prev) =
		fold lex_error_code errnos prev
;
=TEX

\subsection{Recursive Z Parser}

Brackets within Z text need only be examined to see if they relate to
comments, all the other forms of bracket can simple be passed on for
the Z lexical analyser and parser to deal with.

{\ftlinepenalty=9999
=SMLPLAIN SML
fun Ûget_Z_anyÝ (R:READER_ENV) (prevA:string list) (sep_symbol : string)
			: string list= (
let
	open PrettyNames;

	fun	do_keyword _ (_,Value ch,Simple) p =
			get_Z_any R ((to_ML_string ch) :: p) sep_symbol
	|	do_keyword _ (names,Nil,Simple) p =
			get_Z_any R ("%%" ^ (hd names) ^ "%%" :: p) sep_symbol
	|	do_keyword k (info as (_,_, (Starting(proc, str)))) p =
			get_Z_any R (proc R k str false p) sep_symbol
	|	do_keyword _ (_,_,Middle str) p =
			get_Z_any R (str :: p) sep_symbol
	|	do_keyword (k, _) (_,ch_opt,Ending str) p =
			((*=[(("=*)	"\"))" :: k :: "\"], \"" :: str :: p)
	|	do_keyword _ (_,_,Ignore) p =
			get_Z_any R p sep_symbol
	|	do_keyword (k, is_keyword) (names,_,Invalid) p = (
			local_error "get_Z_any" 5007
				[fn () => if is_keyword then "%%" ^ k ^ "%%" else k];
			get_Z_any R (lex_error_code(5007, p)) sep_symbol);

	fun do_string ML_string = (
		let	val (read_string, ol_name) =
				if ML_string
				then	(get_ML_string, "Lex.String")
				else	(get_primed_string, "Lex.Char");
			val (str, errnos) = read_string R (ol_name :: "\", " :: prevA); (*="=*)
			val text_so_far = ", Lex.Text\"" (*="=*) :: str;
		in
			get_Z_any R (lex_error_codes(errnos, text_so_far)) sep_symbol
		end
	);

	val next = #look_at_next R ()
in
	case read_symbol R
	of	SymCharacter ch => (
			case ch
			of "("	=>	(	if #look_at_next R () = "*"
						then
							(skip_comment R;
							get_Z_any R (" " :: prevA) sep_symbol)
						else
							get_Z_any R ( "(" ::  prevA) sep_symbol)
			|  "\""	=>	do_string true (*="=*)
			|  "`"	=>	do_string false
			|  "\^D" =>	prevA
			|  "%Q%"	=>	get_Z_any R ("%Q%%Q%%Q%%Q%" :: prevA) sep_symbol
			|  "\\"	=>	get_Z_any R ("\\\\" :: prevA) sep_symbol
			|  _ => 	get_Z_any R (ch :: prevA) sep_symbol
		)
	|	SymWhite xs =>
			if contains xs "\n"
			then	sep_symbol :: prevA
			else	get_Z_any R (" " :: prevA) sep_symbol
	|	SymKnown(sym, is_keyword, info) => do_keyword (sym, is_keyword) info prevA
	|	SymDoublePercent => get_Z_any R ("%%%%" :: prevA) sep_symbol
	|	SymUnknownKw(sym, is_closed) => (
			local_error "get_Z_any" 5003 [fn () => sym, fn () =>
							implode(rev(" ... " :: (prevA to 20)))];
			get_Z_any R (lex_error_code(5003, prevA)) sep_symbol
		)
	|	SymUnknownChar ch => (
			local_error "get_Z_any" 5005
						[fn () => ch,
						fn () => string_of_int(ord ch),
						fn () => implode(" ... " :: (rev(prevA to 20)))];
				get_Z_any R (lex_error_code(5005, prevA)) sep_symbol
		)
end);
=TEX
}

\subsection{Outer Level of the Z Reader}

Z text is to be read, the opening symbol and language name are
given.  Produce Standard~ML text as follows to add onto the left
hand context.

=GFT SML
( recogniser ( "starting symbol", "language name", quoted_text, "closing symbol" ))
=TEX

When the $add_semi$ argument is true then add, additionaly, a semi-colon
to indicate the end of an outermost Standard~ML expression.

Where the $quoted_text$ is a list of values of type $Lex.INPUT$, see
section\ref{DatatypeForParserInterface}.  Function $Z\_reader$ is
responsible for building the opening part of the Standard~ML text,
function $get\_Z\_any$ reads and assembles the quoted text (i.e., the
body of the quotation) and the closing text.

=SMLPLAIN SML
fun ÛZ_readerÝ (recogniser:string) (add_semi:bool) (sep_symbol : string)
		(R:READER_ENV) (start:string, is_keyword:bool)
		(lang:string) (opening:string) (prevA:string list) : string list = (
let
	val prevB =
		opening ::
		"\", [Lex.Text\"" ::
		lang ::
		"\", \"" ::
		start ::
		"(\"" (*=")=*) ::
		recogniser ::
		"(" ::
		prevA;

	val read_text = get_HOL_any R (get_Z_any R prevB sep_symbol);
in
	if add_semi
	then
		";" :: read_text
	else
		read_text
end
);
=TEX


=SMLPLAIN SML
end (* local ... in *);
end (* of structure ZReaderWriter *);
=TEX

\section{TYPE CHECK ONLY MODE}

=SML
structure ÛZTypeCheckOnlyModeÝ : ZTypeCheckOnlyMode = struct
open ZUserInterfaceSupport  ZTypeInference ZTermGenerator;
open ZTypesAndTermsSupport;
=TEX
=SML
fun Ûstring_of_identÝ ((tmpl, dec) : IDENT) : string = (
	string_of_template tmpl ^ dec
);
=TEX

\subsection{Saving Types and Constants in the Theory}


=SML
fun Ûtype_of_formalÝ (id : IDENT) : TYPE = (
	mk_vartype ("'"^(string_of_ident id))
);
=TEX
=SML
fun Ûconsts_in_zparaÝ (p : Z_PARA) : (string * TYPE) list = (
	case p of
	ZParaAbbDef (id, [], _, Value ty) =>
		[(string_of_ident id, type_of_zextype ty)]
	|ZParaAbbDef (id, formals, _, Value ty) => 
	let	val fty = mk_ZtupleT (map mk_ZpowerT (map type_of_formal formals));
		val aty = type_of_zextype ty;
		val ty' = mk_­_type (fty, aty);
	in
		[(string_of_ident id, ty')]
	end
	|ZParaAbbDef (_, _, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaSchBox (id, [], _, Value ty) =>
		[(string_of_ident id, type_of_zextype ty)]
	|ZParaSchBox (id, formals, _, Value ty) => 
	let	val fty = mk_ZtupleT (map mk_ZpowerT (map type_of_formal formals));
		val aty = type_of_zextype ty;
		val ty' = mk_­_type (fty, aty);
	in
		[(string_of_ident id, ty')]
	end
	|ZParaSchBox (_, _, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaAxDes ([], _, Value idtyl) => 
		(map (fn (id, ty) => (string_of_ident id, type_of_zextype ty)) idtyl)
	|ZParaAxDes (formals, _, Value idtyl) => 
	let	val fty = mk_ZtupleT (map mk_ZpowerT (map type_of_formal formals));
		val idtyl' = map (fn (id, ty) => (string_of_ident id,
			mk_­_type (fty, (type_of_zextype ty)))) idtyl;
	in
		idtyl'
	end
	|ZParaAxDes (_, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaGivenSet (idl, _) =>
	let	val sl = map string_of_ident idl;
	in
		map (fn s => (s, mk_ctype ("SET", [mk_ctype (s,[])]))) sl
	end

	|ZParaFreeType ftl =>
	let	fun do_branch aty (id, Value fty, _) =
		let	val fty' = case fty of
					ExType ("SET", [fty']) => fty'
					| _ => fail "consts_in_zinferred" 62901 [];
			val ty' = (* ex_set (tuple_extype [fty', aty]); *)
				fail "do_branch" 80201 [fn()=>"free types not implemented"]
		in
			(string_of_ident id, type_of_zextype ty')
		end
		  | do_branch aty (id, Nil, _) =
			(string_of_ident id, type_of_zextype aty)
		fun do_prod (id, branches) =
		let	val s = string_of_ident id;
			val aty = ExType (s, []);
			val idty = (s, mk_ZpowerT (type_of_zextype aty));
		in
			idty::(map (do_branch aty) branches)
		end
		fun do_ftd (prod::rest) =
			do_prod prod@do_ftd rest
		  | do_ftd [] = [];
	in
		do_ftd ftl
	end
	|ZParaConstraint _ => []
	|ZParaConjecture _ => []
	|ZParaTerm _ => []
	|ZParaFixity _ => []
);
=TEX
=SML
fun Ûnew_type_clashesÝ ((tyname, arity) : (string * int)) : (string * int) list = (
	case get_type_arity tyname of
	Nil => []
	|Value arity' => if (arity = arity')
			then	[]
			else	[(tyname, arity)]
);

fun Ûnew_type_nofailÝ ((tyname, arity) : (string * int)) : unit = (
	case get_type_arity tyname of
	Nil => (new_type (tyname, arity);())
	|Value arity' =>
		if arity = arity'
		then ()
		else fail "new_type_nofail" 62998 []
);

fun Ûnew_const_clashesÝ ((cname, ty) : (string * TYPE)) : (string * TYPE) list = (
	case (get_const_info o bind_gvar_name)cname of
	Nil => []
	|Value (ty', _) => if (ty =: ty')
			then	[]
			else	[(cname, ty)]
);

fun Ûnew_const_nofailÝ ((cname, ty) : (string * TYPE)) : unit = (
let	val bname = bind_gvar_name cname;
in
	case get_const_info bname of
	Nil => (new_const (bname, ty);())
	|Value (ty', _) =>
		if ty =: ty'
		then ()
		else fail "new_const_nofail" 62998 []
end);
=TEX
=SML
fun Ûupdate_theory_dbÝ ((ZParaFixity fixinfo) : Z_PARA) : unit = (
	set_zfixity_info fixinfo
) | update_theory_db p =
let	val consts = consts_in_zpara p;
	val tys = list_cup (map (fn (s, ty) => type_tycons ty) consts);
	val side =
		case list_cup (map (fn ty => new_type_clashes ty) tys) of
		[] => map new_type_nofail tys
		|failures => fail "update_theory_db" 62998 [fn ()=>PolyML.makestring failures];
	val side =
		case flat (map (fn const => new_const_clashes const) consts) of
		[] => map new_const_nofail consts
		|failures => fail "update_theory_db" 62998 [fn ()=>PolyML.makestring failures];

in
	()
end;
=TEX
=SML
end (* of structure ZTypeCheckOnlyMode *);
=TEX

\section{PROOF SUPPORT MODE}
=SML
structure ÛZProofSupportModeÝ : ZTypeCheckOnlyMode = struct
open	ZUserInterfaceSupport;
=TEX
=SML
fun Ûupdate_theory_dbÝ ((ZParaFixity fixinfo) : Z_PARA) : unit = (
	set_zfixity_info fixinfo
) | update_theory_db _ = ();

=TEX
=SML
end (* of structure ZProofSupportMode *);
=TEX

\section{THE STRUCTURE FOR Z PARAGRAPH PROCESSORS}

=SML
structure ÛZParagraphsÝ : ZParagraphs = struct
=TEX
=SML
	open Lex SymbolTable ReaderWriterSupport;
	open HOLReaderWriter PrettyNames;
	open ZReaderWriter;
	open ZUserInterfaceSupport ZLex ZParser ZTypeInference ZTermGenerator;

val Ûztype_check_onlyÝ = ref false;

val _ = if contains (map fst (get_flags()))
			"ztype_check_only"
	then	()
	else	new_flag{name = "ztype_check_only",
			control = ztype_check_only,
			default = fun_false,
			check = fun_true
	};
=TEX


\section{PARAGRAPH PROCESSING}

=SML
fun Ûterm_of_zparaÝ ((ZParaTerm (_, tm, _)) : Z_PARA) : TERM = (
	term_of_ztm tm
) | term_of_zpara _ = (
	fail "z_term_recogniser" 49001 []
); 
=TEX

=SML
fun Ûzpara_of_zinferredÝ ((ZInferred p) : Z_INFERRED) : Z_PARA = (
	p
) | zpara_of_zinferred (ZTypeError inf) = (
	print_zerror inf
);
=TEX


\section{THE STRUCTURE FOR Z PARAGRAPHS}


The first thing to do is to tell the reader/writer about the
Z paragraph delimiting symbols.

=SMLLITERAL

val sd = add_new_symbols [
	([	"StartZGeneric"],	Value "", Starting(specific_quotation, "")),
	([	"StartZSchema"],	Value "ÿ", Starting(specific_quotation, "")),
	([	"EndZBox"],		Value "", Ending ""),
	([	"StartZTerm"],	Value "ñ", Starting(specific_quotation, ""))
] handle _ => ();
=TEX
The true box recognizers (generic constants and schema boxes) use the
new Z reader. The other boxes can use the HOL reader.
=SML
val Ûz_axbox_readerÝ = HOL_reader "z_axbox_recogniser" true;
val Ûz_genbox_readerÝ = Z_reader "z_genbox_recogniser" true "";
val Ûz_schbox_readerÝ = Z_reader "z_schbox_recogniser" true "ü";
val Ûz_term_readerÝ = HOL_reader "z_term_recogniser" false;
val Ûz_other_readerÝ = HOL_reader "z_other_recogniser" true;
=TEX
=SMLLITERAL
val sd = map add_named_reader [
	("¹", "ZAX", "Lex.Term", z_axbox_reader),
	("¹", "Z", "Lex.Term", z_other_reader)
	] handle _ => [];

val sd = map add_specific_reader [
	("", "Lex.Term", z_genbox_reader),
	("ÿ", "Lex.Term", z_schbox_reader),
	("ñ", "Lex.Term", z_term_reader)
	] handle _ => [];
=TEX


\section{PARAGRAPH RECOGNIZERS}

\subsection{Z Axiomatic Box Recogniser}

=SML
fun Ûz_axbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "¹")
			andalso	is_same_symbol(finish, "°")
			andalso	(lang = "ZAX")
		then	()
		else
			fail "z_axbox_recogniser" 49001 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = ZTAx::(zlex value);
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val para = zpara_of_zinferred type_checked;
in
	if get_flag "ztype_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	ZProofSupportMode.update_theory_db para
end);

=TEX
\subsection{Z Generic Box Recogniser}
=SML
fun Ûz_genbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZGeneric")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_genbox_recogniser" 49002 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = ZTAx::(zlex value);
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val para = zpara_of_zinferred type_checked;
in
	if get_flag "ztype_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	ZProofSupportMode.update_theory_db para
end);

=TEX
\subsection{Z Schema Box Recogniser}
=SML
fun Ûz_schbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZSchema")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_schbox_recogniser" 49003 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = ZTSch::(zlex value);
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val para = zpara_of_zinferred type_checked;
in
	if get_flag "ztype_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	ZProofSupportMode.update_theory_db para
end);
=TEX
\subsection{Z General Text Recogniser}
=SML
fun Ûz_other_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "¹")
			andalso	is_same_symbol(finish, "°")
			andalso	(lang = "Z")
		then	()
		else
			fail "z_other_recogniser" 49004 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = zlex value;
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val para = zpara_of_zinferred type_checked;
in
	if get_flag "ztype_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	ZProofSupportMode.update_theory_db para
end);
=TEX
\section{RECOGNIZING Z TERMS}

=SML
fun Ûz_term_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZTerm")
			andalso	is_same_symbol(finish, ">")
			andalso	(lang = "")
		then	()
		else
			fail "z_term_recogniser" 49010 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val tokens = zlex value;
	val parsed = ZParser.zparser {is_quot = true, standard = false} tokens;
	val side = case parsed of
		ZParaTerm _ => ()
		|_ => fail "z_term_recogniser" 49001 [];
	val type_checked = type_check_zpara {standard=false} parsed;
	val para = zpara_of_zinferred type_checked;
in	term_of_zpara para
end);


=TEX

\section{EPILOGUE}

The structure for Z paragraphs is required to be open for use by the
reader/writer.

=SML
end (* of structure ZParagraphs *);
open ZParagraphs;
=TEX

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
