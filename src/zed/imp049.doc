% imp049.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Paragraphs}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP049}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the interface used to input Z specifications into the Z Proof Support System.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.10 (9 June 1992)] First stable issue.

\end{description}
\subsection{Changes Forecast}
When a Z lexical analyser and a Z lexis is available
\cite{DS/FMU/IED/DTD060}, the
implementation will be modified to use that. Also, the
Z term representation which is used by the parser for
parsed terms will be modified to be brought into line
when the representation has been agreed and made available
in the Z term/schematext parser design \cite{DS/FMU/IED/DTD061}.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The implementation contained in this document corresponds
to the design of Z paragraphs in \cite{DS/FMU/IED/DTD049}.
\subsection{Introduction}
\subsubsection{Background and Purpose}

This is the Z paragraph processor which is described in \cite{DS/FMU/IED/DTD049}.
In order to recognize fragments of Z, a Z reader is required. This
reader is very similar to the HOL reader of \cite{DS/FMU/IED/IMP005}
and is changed to recognize the end of the first line of Z boxes, and
generate a lexeme to indicate this. This is required by the Z grammar
\cite{DS/FMU/IED/DEF007}.

\subsubsection{Dependencies}
The structure $ZParagraphRecognizers$ is constrained by the signature
of the same name, which is specified in \cite{DS/FMU/IED/DTD049}.

\subsubsection{Possible Enhancements}

Changes to this document will be required when the backend to the user
interface has been implemented.

\subsubsection{Deficiencies}

None known.

\section{Z READER WRITER}

=SMLPLAIN SML
structure ÛZReaderWriterÝ : ZReaderWriter = struct
local
open ReaderWriterSupport HOLReaderWriter;
in
=TEX
\subsection{Warning Messages}

Faults detected in the embedded text are reported via $local_error$ as
they occur, they are also noted in the generated output using these
two functions.

=SMLPLAIN SML
fun Ûlex_error_codeÝ (id : int, prev:string list) : string list = (
	", Lex.Text\"" :: (*="=*)
	"Lex.Error " ^ (string_of_int id) ::
	"\", " :: (*="=*)
	prev
);

fun	Ûlex_error_codesÝ (nil : int list, prev:string list) : string list =
		prev
|	lex_error_codes (errnos, prev) =
		fold lex_error_code errnos prev
;
=TEX

\subsection{Recursive Z Parser}

Brackets within Z text need only be examined to see if they relate to
comments, all the other forms of bracket can simple be passed on for
the Z lexical analyser and parser to deal with.

{\ftlinepenalty=9999
=SMLPLAIN SML
fun Ûget_Z_anyÝ (R:READER_ENV) (prevA:string list) (sep_symbol : string)
			: string list= (
let
	open PrettyNames;

	fun	do_keyword _ (_,Value ch,Simple) p =
			get_Z_any R ((to_ML_string ch) :: p) sep_symbol
	|	do_keyword _ (names,Nil,Simple) p =
			get_Z_any R ("%%" ^ (hd names) ^ "%%" :: p) sep_symbol
	|	do_keyword k (info as (_,_, (Starting(proc, str)))) p =
			get_Z_any R (proc R k str false p) sep_symbol
	|	do_keyword _ (_,_,Middle str) p =
			get_Z_any R (str :: p) sep_symbol
	|	do_keyword (k, _) (_,ch_opt,Ending str) p =
			((*=[(("=*)	"\"))" :: k :: "\"], \"" :: str :: p)
	|	do_keyword _ (_,_,Ignore) p =
			get_Z_any R p sep_symbol
	|	do_keyword (k, is_keyword) (names,_,Invalid) p = (
			local_error "get_Z_any" 5007
				[fn () => if is_keyword then "%%" ^ k ^ "%%" else k];
			get_Z_any R (lex_error_code(5007, p)) sep_symbol);

	fun do_string ML_string = (
		let	val (read_string, ol_name) =
				if ML_string
				then	(get_ML_string, "Lex.String")
				else	(get_primed_string, "Lex.Char");
			val (str, errnos) = read_string R (ol_name :: "\", " :: prevA); (*="=*)
			val text_so_far = ", Lex.Text\"" (*="=*) :: str;
		in
			get_Z_any R (lex_error_codes(errnos, text_so_far)) sep_symbol
		end
	);

	val next = #look_at_next R ()
in
	case read_symbol R
	of	SymCharacter ch => (
			case ch
			of "("	=>	(	if #look_at_next R () = "*"
						then
							(skip_comment R;
							get_Z_any R (" " :: prevA) sep_symbol)
						else
							get_Z_any R ( "(" ::  prevA) sep_symbol)
			|  "\""	=>	do_string true (*="=*)
			|  "`"	=>	do_string false
			|  "\^D" =>	prevA
			|  "%Q%"	=>	get_Z_any R ("%Q%%Q%%Q%%Q%" :: prevA) sep_symbol
			|  "\\"	=>	get_Z_any R ("\\\\" :: prevA) sep_symbol
			|  _ => 	get_Z_any R (ch :: prevA) sep_symbol
		)
	|	SymWhite xs =>
			if contains xs "\n"
			then	sep_symbol :: prevA
			else	get_Z_any R (" " :: prevA) sep_symbol
	|	SymKnown(sym, is_keyword, info) => do_keyword (sym, is_keyword) info prevA
	|	SymDoublePercent => get_Z_any R ("%%%%" :: prevA) sep_symbol
	|	SymUnknownKw(sym, is_closed) => (
			local_error "get_Z_any" 5003 [fn () => sym, fn () =>
							implode(rev(" ... " :: (prevA to 20)))];
			get_Z_any R (lex_error_code(5003, prevA)) sep_symbol
		)
	|	SymUnknownChar ch => (
			local_error "get_Z_any" 5005
						[fn () => ch,
						fn () => string_of_int(ord ch),
						fn () => implode(" ... " :: (rev(prevA to 20)))];
				get_Z_any R (lex_error_code(5005, prevA)) sep_symbol
		)
end);
=TEX
}

\subsection{Outer Level of the Z Reader}

Z text is to be read, the opening symbol and language name are
given.  Produce Standard~ML text as follows to add onto the left
hand context.

=GFT SML
( recogniser ( "starting symbol", "language name", quoted_text, "closing symbol" ))
=TEX

When the $add_semi$ argument is true then add, additionaly, a semi-colon
to indicate the end of an outermost Standard~ML expression.

Where the $quoted_text$ is a list of values of type $Lex.INPUT$, see
section\ref{DatatypeForParserInterface}.  Function $Z\_reader$ is
responsible for building the opening part of the Standard~ML text,
function $get\_Z\_any$ reads and assembles the quoted text (i.e., the
body of the quotation) and the closing text.

=SMLPLAIN SML
fun ÛZ_readerÝ (recogniser:string) (add_semi:bool) (sep_symbol : string)
		(R:READER_ENV) (start:string, is_keyword:bool)
		(lang:string) (opening:string) (prevA:string list) : string list = (
let
	val prevB =
		opening ::
		"\", [Lex.Text\"" ::
		lang ::
		"\", \"" ::
		start ::
		"(\"" (*=")=*) ::
		recogniser ::
		"(" ::
		prevA;

	val read_text = get_HOL_any R (get_Z_any R prevB sep_symbol);
in
	if add_semi
	then
		";" :: read_text
	else
		read_text
end
);
=TEX


=SMLPLAIN SML
end (* local ... in *);
end (* of structure ZReaderWriter *);
=TEX

\section{TYPE CHECK ONLY MODE}

=SML
structure ÛZTypeCheckOnlyModeÝ : ZTypeCheckOnlyMode = struct
	open	icl'Kernel Unification ZUserInterfaceSupport ZTypeInference;
	open	ZTermGenerator ZTypesAndTermsSupport ;
=TEX

\subsection{Saving Types and Constants in the Theory}

=SML
fun Ûnew_type_clashesÝ ((tyname, arity) : (string * int)) : (string * int) list = (
	case get_type_arity tyname of
	Nil => []
	|Value arity' => if (arity = arity')
			then	[]
			else	[(tyname, arity)]
);

fun Ûnew_type_nofailÝ ((tyname, arity) : (string * int)) : unit = (
	case get_type_arity tyname of
	Nil => (new_type (tyname, arity);())
	|Value arity' =>
		if arity = arity'
		then ()
		else fail "new_type_nofail" 62998 []
);
=TEX
=TEX
For the following $delete\_$ functions we need an auxiliary ``tco\_delete\_to\_level'' function.
This will find out what is to be deleted, and do all the
kernel and user notification required.
=SML
fun Ûtco_delete_to_levelÝ (caller : string) (target : string) (level : int)
			: (string * int) list * (string * TYPE) list = (
let	val dummy = case (get_current_theory_status()) of
		TSNormal => ()
		| TSDeleted => error caller 6008 
			[fn () => get_current_theory_name()]
		| TSLocked => fail caller 6037
			[fn () => get_current_theory_name()]
		| TSAncestor => fail caller 6071
			[fn () => get_current_theory_name()];

	val {children = children,...} = icl'get_theory_info "-";

	val dummy = if children <> [] 
		then fail caller 6076 [fn () => get_current_theory_name()]
		else ();

	val {con_env = con_env,ty_env = ty_env,
		axiom_dict = axiom_dict, thm_dict = thm_dict,
		defn_dict = defn_dict,...} = icl'get_theory "-";

	val (del_con,del_lev1) = split (map (fn (name,{ty = ty,level = lev,...}) => 
			((name, ty),lev))
		(con_env drop (fn (_,{level = lev,...}) => lev < level)));

	val (del_type,del_lev2) = split(map (fn (name,{level = lev,...}) => (name,lev))
		(ty_env drop (fn (_,{level = lev,...}) => lev < level)));

	val del_type_arities = map (fn ty =>
		case get_type_info ty of
		Nil => error "tco_delete_to_level" 49999 []
		|Value (ar, _) => (ty, ar)) del_type;

	val del_thms = map (fn (key,_) => key)
		(thm_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end));

	val (del_axioms, del_lev3) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(axiom_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));

	val (del_defns, del_lev4) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(defn_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));


	val I = Combinators.I;

	val to_be_d = (
		format_list Combinators.I 
		(flat [
		if is_nil del_thms
		then []
		else [get_error_message 12102 
			[if length del_thms = 1 then "" else "s"] ^ 
			(format_list I del_thms ", ")],
		if is_nil del_axioms
		then []
		else [get_error_message 12103 
			[if length del_axioms = 1 then "" else "s"] ^ 
			(format_list I del_axioms ", ")],
		if is_nil del_defns
		then []
		else [get_error_message 12104 
			[if length del_defns = 1 then "" else "s"] ^ 
			(format_list I del_defns ", ")]])
		) "; ";
=TEX
We now ask the interactive user whether he wishes everything
necessary to be deleted.
=SML
	val dummy = case to_be_d of
		"" => ()
		|_ => warn caller 12012 [(fn () => target),(fn () => to_be_d)];
=TEX
We now have permission to proceed:
=SML
	val dl = list_cup[del_lev1, del_lev2, del_lev3, del_lev4];

	val dummy = map icl'delete_thm del_thms;
	val dummy = map (fn x => icl'delete_extension ()) dl;
	val dummy = open_theory"-";
in
	(del_type_arities, del_con)
end);
=TEX
We can now give the deletion functions:
=SML
fun Ûtco_delete_constÝ (cnt : TERM) : (string * int) list * (string * TYPE) list = (
let	val (cnm, cty) = dest_const cnt
		handle complaint =>
		pass_on complaint "dest_const" "delete_const";

	val {con_env = con_env,...} = icl'get_theory "-";

	val {level = level, ty = ty} = force_value(s_lookup cnm con_env)
		handle complaint =>
		divert complaint "force_value" "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm];

	val dummy = if not(is_type_instance ty cty andalso 
			is_type_instance cty ty)
		then fail "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm]
		else ();
in
	tco_delete_to_level "delete_const" cnm level
end);
=TEX
=SML
fun Ûtco_replace_constÝ ((name, ty) : (string * TYPE)) : TERM = (
	case get_const_info name of
	Nil => new_const (name, ty)
	|Value (ty', _) => (
		if ty' =: ty
		then	mk_const (name,ty)
		else	let
				val (tylist, clist) = tco_delete_const (mk_const (name, ty'));
				val side = map new_type (tylist drop (fn(n,_) => n=name));
				val side = map new_const (clist drop (fn(n,_) => n=name));

			in
				new_const (name,ty)
			end
	)
);
=TEX
=SML
fun Ûz_replace_constsÝ (idtyl : (string * TYPE) list) : unit = (
let	val idtyl' = map (fn (n, ty) => (bind_gvar_name n, ty)) idtyl;
	val side = map tco_replace_const idtyl';
in
	()
end);
=TEX
=SML
fun Ûtype_of_formalÝ (id : IDENT) : TYPE = (
	mk_vartype ("'"^(string_of_ident id))
);
=TEX
=SML
fun	Ûtuple_exnameÝ (tyl: EXTYPE list) : string =
	tuple_tname (map type_of_z_extype tyl);
fun	Ûtuple_extypeÝ (tyl: EXTYPE list) :EXTYPE = ExType(tuple_exname tyl,tyl);
=TEX
=SML
fun Ûconsts_in_z_paraÝ (p : Z_PARA) : (string * TYPE) list = (
	case p of
	ZParaAbbDef (id, [], _, Value ty) =>
		[(string_of_ident id, type_of_z_extype ty)]
	|ZParaAbbDef (id, formals, _, Value ty) => 
	let	val fty = mk_z_tuple_t (map mk_z_power_t (map type_of_formal formals));
		val aty = type_of_z_extype ty;
		val ty' = mk_­_type (fty, aty);
	in
		[(string_of_ident id, ty')]
	end
	|ZParaAbbDef (_, _, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaSchBox (id, [], _, Value ty) =>
		[(string_of_ident id, type_of_z_extype ty)]
	|ZParaSchBox (id, formals, _, Value ty) => 
	let	val fty = mk_z_tuple_t (map mk_z_power_t (map type_of_formal formals));
		val aty = type_of_z_extype ty;
		val ty' = mk_­_type (fty, aty);
	in
		[(string_of_ident id, ty')]
	end
	|ZParaSchBox (_, _, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaAxDes ([], _, Value idtyl) => 
		(map (fn (id, ty) => (string_of_ident id, type_of_z_extype ty)) idtyl)
	|ZParaAxDes (formals, _, Value idtyl) => 
	let	val fty = mk_z_tuple_t (map mk_z_power_t (map type_of_formal formals));
		val idtyl' = map (fn (id, ty) => (string_of_ident id,
			mk_­_type (fty, (type_of_z_extype ty)))) idtyl;
	in
		idtyl'
	end
	|ZParaAxDes (_, _, Nil) =>
		fail "consts_in_zinferred" 62998 [fn()=>"Insufficient type info"]

	|ZParaGivenSet (idl, _) =>
	let	val sl = map string_of_ident idl;
	in
		map (fn s => (s, mk_ctype ("SET", [mk_ctype (s,[])]))) sl
	end

	|ZParaFreeType ftl =>
	let	fun do_branch aty (id, Value fty, _) =
		let	val ty' = ExType ("SET", [tuple_extype [fty, aty]]);
		in
			(string_of_ident id, type_of_z_extype ty')
		end
		  | do_branch aty (id, Nil, _) =
			(string_of_ident id, type_of_z_extype aty)
		fun do_prod (id, branches) =
		let	val s = string_of_ident id;
			val aty = ExType (s, []);
			val idty = (s, mk_z_power_t (type_of_z_extype aty));
		in
			idty::(map (do_branch aty) branches)
		end
		fun do_ftd (prod::rest) =
			do_prod prod@do_ftd rest
		  | do_ftd [] = [];
	in
		do_ftd ftl
	end
	|ZParaConstraint _ => []
	|ZParaConjecture _ => []
	|ZParaTerm _ => []
	|ZParaFixity _ => []
);
=TEX
=SML
fun Ûupdate_theory_dbÝ ((ZParaFixity fixinfo) : Z_PARA) : unit = (
	set_zfixity_info fixinfo
) | update_theory_db p =
let	val consts = consts_in_z_para p;
	val tys = list_cup (map (fn (s, ty) => type_tycons ty) consts);
	val side =
		case list_cup (map (fn ty => new_type_clashes ty) tys) of
		[] => map new_type_nofail tys
		|failures => fail "update_theory_db" 62998 [fn ()=>PolyML.makestring failures];
	val side = z_replace_consts consts;
in
	()
end;
=TEX
=SML
end (* of structure ZTypeCheckOnlyMode *);
=TEX

\section{PROOF SUPPORT MODE}

=SML
structure ÛZProofModeÝ : ZProofMode = struct
local
	open	Unification ZUserInterfaceSupport;
	open	ZTypesAndTermsSupport ZTypeInference ZGeneratedConstants
	open	ZTermGenerator;
	
in
=TEX
=SML
datatype ÛPARAINFOÝ =
	ÛFixityInfoÝ of FIXITY
	|ÛAbbDefInfoÝ of string * string list * TERM
	|ÛSchBoxInfoÝ of string * string list * TERM
	|ÛAxDesInfoÝ of string list * TERM * TERM OPT * (string * TYPE) list
	|ÛFreeTypeInfoÝ of (string * (string * TERM OPT) list) list
	|ÛGivenSetInfoÝ of string list * (string list * TERM) OPT
	|ÛConstraintInfoÝ of string list * TERM
	|ÛConjectureInfoÝ of string OPT * string list * TERM;
=TEX
=SML
fun Ûmk_fixity_infoÝ (fixinfo : FIXITY) = (
	FixityInfo fixinfo
);
=TEX
=SML
fun Ûmk_abbdef_infoÝ ((id, idl, z_tm, oty) : IDENT * IDENT list * Z_TM * EXTYPE OPT) = (
	AbbDefInfo (string_of_ident id, map string_of_ident idl, term_of_z_tm z_tm)
);
=TEX
=SML
fun Ûmk_schbox_infoÝ ((id,idl,sch, _) : IDENT * IDENT list * Z_SCH_TEXT * EXTYPE OPT) : PARAINFO = (
let	val tm = term_of_z_tm (ZTmHorizSchema sch);
in
	SchBoxInfo (string_of_ident id, map string_of_ident idl, tm)
end);
=TEX
=SML
fun Ûmk_axdes_infoÝ ((idl, sch, Value idtyl) : IDENT list * Z_SCH_TEXT *
				(IDENT * EXTYPE) list OPT) : PARAINFO = (
let	val (tm, otm) = term_of_z_schtext sch;
	val idtyl' = map (fn (id, ty) => (string_of_ident id, type_of_z_extype ty)) idtyl;
in
	AxDesInfo (map string_of_ident idl, tm, otm, idtyl')
end
) | Ûmk_axdes_infoÝ (_, _, Nil) = (
	fail "mk_axdes_info" 49000 []
);
=TEX
=SML
fun Ûmk_freetype_infoÝ (ftdeflist : (IDENT * (IDENT * EXTYPE OPT * Z_TM OPT) list) list) : PARAINFO= ( 
let	fun aux (id, _, Value z_tm) =
		(string_of_ident id, Value (term_of_z_tm z_tm))
	  | aux (id, _, Nil) = (string_of_ident id, Nil);
	fun aux1 (id, branch) = (string_of_ident id, map aux branch);
in
	FreeTypeInfo (map aux1 ftdeflist)
end);
=TEX
=SML
fun Ûmk_givenset_infoÝ ((idl, Value (gens, z_tm)) : IDENT list * (IDENT list * Z_TM) OPT) : PARAINFO = (
	GivenSetInfo (map string_of_ident idl, Value (map string_of_ident gens,term_of_z_tm z_tm))
) | mk_givenset_info (idl, Nil) = GivenSetInfo  (map string_of_ident idl, Nil);

=TEX
=SML
fun Ûmk_constraint_infoÝ ((idl, z_tm) : (IDENT list * Z_TM)) : PARAINFO = (
		ConstraintInfo (map string_of_ident idl, term_of_z_tm z_tm)
);
=TEX
=SML
fun Ûmk_conjecture_infoÝ ((Value id, idl, z_tm) : (IDENT OPT * IDENT list * Z_TM)) : PARAINFO = (
		ConjectureInfo (Value (string_of_ident id),
			map string_of_ident idl, term_of_z_tm z_tm)
) | mk_conjecture_info (Nil, idl, z_tm) = (
		ConjectureInfo (Nil, map string_of_ident idl, term_of_z_tm z_tm)
);
=TEX
=SML
fun Ûparainfo_of_z_paraÝ (p : Z_PARA) : PARAINFO = (
let	fun aux (ZParaFixity pbody) = (
		mk_fixity_info pbody
	) | aux (ZParaAbbDef pbody) = (
		mk_abbdef_info pbody
	) | aux (ZParaSchBox pbody) = (
		mk_schbox_info pbody
	) | aux (ZParaAxDes pbody) = (
		mk_axdes_info pbody
	) | aux (ZParaFreeType pbody) = (
		mk_freetype_info pbody
	) | aux (ZParaGivenSet pbody) = (
		mk_givenset_info pbody
	) | aux (ZParaConstraint pbody) = (
		mk_constraint_info pbody
	) | aux (ZParaConjecture pbody) = (
		mk_conjecture_info pbody
	) | aux _ = (
		fail "parainfo_of_z_para" 49999 []
	);
in
	do_in_theory (current_cache_theory()) aux p
end);
=TEX
\subsection{Proof Context Initialization}

=SML
val Ûinit_z_paragraph_pcÝ = (
let	val curr_theory = get_current_theory_name();
in
	let	val side = open_theory"z_language";
		val side = delete_pc "'icl'z_paragraphs"
			handle Fail _ => ();
		val side = new_pc "'icl'z_paragraphs";		val side = set_cs_¶_convs [pure_rewrite_conv [
					z'abbdef_def,
					z'schbox_def,
					z'givenset_def,
					z'axdes_def
				]] "'icl'z_paragraphs";
		val side = open_theory curr_theory;
	in
		()
	end
end);


fun Ûparagraph_const_specÝ (args : string list * TERM list * TERM) : THM = (
let	val was_pcs = fst(get_current_pc ());
in
	merge_pcs_rule (was_pcs @ ["'icl'z_paragraphs"]) const_spec args
end);

=TEX

\section{DEFINITIONS BY AXIOM} 

=SML
fun Ûabbdef_defnÝ (flag : bool) ((name, gen_formals, tm) : string * string list * TERM) : unit = (
let	val wrap = if flag then ¬$"Z'SchBox"® else ¬$"Z'AbbDef"®;
	val name' = bind_gvar_name name;
	val ty = type_of tm;
in
	case map (mk_z_power_t o mk_z_var_t) gen_formals of
	[] => (
		let	val var = mk_var(name, ty);
			val var' = mk_var(name', ty) ;
			val tm' = subst [(var', var)] tm;
			val defn1 = mk_eq(var', tm');
			val defn2 = mk_app (wrap, defn1);
			val side = paragraph_const_spec ([name, name'],[var'], defn2);
		in
			()
		end)
	| gftyl => (
		let	val ty' = mk_­_type(mk_z_tuple_t gftyl,ty);
			val var = mk_var(name, ty');
			val var' = mk_var (name', ty');
			val tm' = subst [(var', var)] tm;
			val gfl = map mk_var (combine gen_formals gftyl);
			val arg = mk_z_tuple gfl;
			val side = do_in_theory (current_cache_theory()) tuple_gen_semantic_const arg;
			val defn1 = mk_eq(mk_app(var', arg), tm');
			val defn2 = list_mk_µ (gfl, defn1);
			val defn3 = mk_app (wrap, defn2);
			val side = paragraph_const_spec ([name, name'], [var'], defn3);
		in
			()
		end)
end

);

=TEX
=SML
fun Ûaxdes_defnÝ ((gen_formals, tm1, otm, idtyl) : string list * TERM * TERM OPT * (string * TYPE) list) : unit = (
let	val def_tm = case otm of
		Value tm2 => mk_± (tm1, tm2)
		|Nil => tm1;
	val gens = map (fn id => mk_var (id, (mk_z_power_t o mk_z_var_t) id)) gen_formals;
	val vars = map mk_var idtyl;
	val zidtyl = map (fn (id, ty) => (bind_gvar_name id, ty)) idtyl;
	val zconsts = map mk_const zidtyl;
	val generify = (
		case gens of
		[] => Combinators.I
		|_ => (
			let	val pval = mk_z_tuple gens;
				val side = do_in_theory (current_cache_theory()) tuple_gen_semantic_const pval;
				val ptype = type_of pval;
			in	(fn v =>
					let	val (s, ty) = dest_const v;
						val v' = mk_const(s, mk_­_type (ptype, ty));
					in
						mk_app(v', pval)
					end)
			end
			)
	);

	val constsubs = map (fn (v1, v2) => (generify v1, v2)) (combine zconsts vars);
	val newconsts = map (fst o strip_app o fst) constsubs;
	val def_tm' = subst constsubs def_tm;
	val defn1 = list_mk_µ (gens, def_tm');
	val defn2 = mk_app(¬$"Z'AxDes"®, defn1);
	val side = map (new_const o dest_const) newconsts;
	val side = new_axiom ((map fst idtyl)@(map fst zidtyl), defn2);
in
	()
end);
=TEX

=SML
fun Ûnext_axiom_nameÝ (s : string) : string = (
let	val axiom_names = flat (map fst (get_axioms "-"));
	fun aux i =
	let	val si = s^(string_of_int i);
	in
		if si mem axiom_names
		then
			aux (i+1)
		else
			if i = 0 then s else si
	end;
in
	aux 0
end);
=TEX
=SML
fun Ûconsts_in_axiomÝ (tm : TERM) : string list = (
let	val tcs = map fst (term_consts tm);
	val cconsts = map (fst o dest_const) (get_consts"-");
in
	tcs drop (fn x => not (x mem cconsts))
end);
=TEX
=SML
fun Ûnames_of_axiomÝ (tm : TERM) : string list = 
	map next_axiom_name (consts_in_axiom tm);
=TEX

=SML
fun Ûsimple_new_z_typeÝ (s : string) : THM = (
let	val ty = new_type (s, 0);
	val zs = bind_gvar_name s;
	val var = mk_var (zs, mk_z_power_t ty);
	val tm = mk_eq (var, mk_set_comp (mk_var ("x", ty), mk_t));
in
	paragraph_const_spec ([s, zs], [var], tm)
end);
=TEX

=SML
fun Ûnew_z_typeÝ (sl : string list) (tm : TERM) : THM = (
let	val tyl = map (fn s => new_type (s, 0)) sl;
	val zsl = map bind_gvar_name sl;
in
	new_axiom (sl@zsl, tm)
end);
=TEX

=SML
fun Ûgivenset_defnÝ ((idl, Nil) : string list * (string list * TERM) OPT) : unit = (
	map simple_new_z_type idl; ()
) | givenset_defn (idl, Value (idl', tm)) = (
let	val frees = (map (fst o dest_var) (frees tm)) drop ((switch o curry) (op mem) idl');
	val simplesets = idl drop ((switch o curry) (op mem) frees);
	val side = map simple_new_z_type simplesets;
	val side = new_z_type (idl diff simplesets) tm;
in
	()
end);
=TEX
=SML
fun Ûax_update_theory_dbÝ (para : Z_PARA) : unit = (
	case parainfo_of_z_para para of
	FixityInfo fixinfo => set_zfixity_info fixinfo
	|AbbDefInfo pbody => abbdef_defn false pbody
	|SchBoxInfo pbody => abbdef_defn true pbody
	|AxDesInfo pbody => axdes_defn pbody
	|GivenSetInfo pbody => givenset_defn pbody
	|other => ZTypeCheckOnlyMode.update_theory_db para
);
=TEX
=SML
end (* of local ... in *);
end (* of structure ZProofMode *);
=TEX


\section{THE STRUCTURE FOR Z PARAGRAPH PROCESSORS}

=SML
structure ÛZParagraphRecognizersÝ : ZParagraphRecognizers = struct
=TEX
=SML
local
	open Lex SymbolTable ReaderWriterSupport;
	open HOLReaderWriter PrettyNames;
	open ZReaderWriter;
	open ZUserInterfaceSupport ZLex ZParser ZTypeInference ZTermGenerator;
in
val Ûz_type_check_onlyÝ = ref true;

val ÛdebugÝ : Z_INFERRED OPT ref = ref Nil;

val _ = if contains (map fst (get_flags()))
			"z_type_check_only"
	then	()
	else	new_flag{name = "z_type_check_only",
			control = z_type_check_only,
			default = fun_true,
			check = fun_true
	};

val Ûz_use_axiomsÝ = ref true;

val _ = if contains (map fst (get_flags()))
			"z_use_axioms"
	then	()
	else	new_flag{name = "z_use_axioms",
			control = z_use_axioms,
			default = fun_true,
			check = fun_true
	};

val Ûz_standard_z_paragraphsÝ = ref true;

val _ = if contains (map fst (get_flags()))
			"z_standard_z_paragraphs"
	then	()
	else	new_flag{name = "z_standard_z_paragraphs",
			control = z_standard_z_paragraphs,
			default = fun_true,
			check = fun_true
	};

val Ûz_extended_z_termsÝ = ref true;

val _ = if contains (map fst (get_flags()))
			"z_extended_z_terms"
	then	()
	else	new_flag{name = "z_extended_z_terms",
			control = z_extended_z_terms,
			default = fun_true,
			check = fun_true
	};
=TEX


\subsection{Processing Z Terms}

=SML
fun Ûterm_of_z_paraÝ ((ZParaTerm (_, tm, _)) : Z_PARA) : TERM = (
	do_in_theory (current_cache_theory()) term_of_z_tm tm
) | term_of_z_para _ = (
	fail "z_term_recogniser" 49001 []
); 
=TEX

=SML
fun Ûz_para_of_zinferredÝ ((ZInferred p) : Z_INFERRED) : Z_PARA = (
	p
) | z_para_of_zinferred (ZTypeError inf) = (
	print_z_error inf
);
=TEX


\section{THE STRUCTURE FOR Z PARAGRAPHS}


The first thing to do is to tell the reader/writer about the
Z paragraph delimiting symbols.

=SMLLITERAL

val sd = add_new_symbols [
	([	"StartZGeneric"],	Value "", Starting(specific_quotation, "")),
	([	"StartZSchema"],	Value "ÿ", Starting(specific_quotation, "")),
	([	"EndZBox"],		Value "", Ending ""),
	([	"StartZTerm"],	Value "ñ", Starting(specific_quotation, ""))
] handle (Fail _) => ();
=TEX
The true box recognizers (generic constants and schema boxes) use the
new Z reader. The other boxes can use the HOL reader.
=SML
val Ûz_axbox_readerÝ = HOL_reader "z_axbox_recogniser" true;
val Ûz_genbox_readerÝ = Z_reader "z_genbox_recogniser" true "";
val Ûz_schbox_readerÝ = Z_reader "z_schbox_recogniser" true "ü";
val Ûz_term_readerÝ = HOL_reader "z_term_recogniser" false;
val Ûz_other_readerÝ = HOL_reader "z_other_recogniser" true;
=TEX
=SMLLITERAL
val sd = map add_named_reader [
	("¹", "ZAX", "Lex.Term", z_axbox_reader),
	("¹", "Z", "Lex.Term", z_other_reader)
	] handle (Fail _) => [];

val sd = map add_specific_reader [
	("", "Lex.Term", z_genbox_reader),
	("ÿ", "Lex.Term", z_schbox_reader),
	("ñ", "Lex.Term", z_term_reader)
	] handle Fail _ => [];

val sd = map add_general_reader [
	("¬", "Z", "Lex.Term", z_term_reader)
	] handle Fail _ => [];
=TEX


\section{PARAGRAPH RECOGNIZERS}

\subsection{Z Axiomatic Box Recogniser}

=SML
fun Ûz_axbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "¹")
			andalso	is_same_symbol(finish, "°")
			andalso	(lang = "ZAX")
		then	()
		else
			fail "z_axbox_recogniser" 49001 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "z_standard_z_paragraphs";
	val tokens = ZTAx::(z_lex value);
	val parsed = z_parser {is_quot = false, standard = standard} tokens;
	val type_checked = type_check_z_para {standard = standard} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	if get_flag "z_type_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	if get_flag "z_use_axioms"
		then
			ZProofMode.ax_update_theory_db para
		else
			ZProofMode.ax_update_theory_db para
end);

=TEX
\subsection{Z Generic Box Recogniser}
=SML
fun Ûz_genbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZGeneric")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_genbox_recogniser" 49002 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "z_standard_z_paragraphs";
	val tokens = ZTAx::(z_lex value);
	val parsed = z_parser {is_quot = false, standard = standard} tokens;
	val type_checked = type_check_z_para {standard = standard} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	if get_flag "z_type_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	if get_flag "z_use_axioms"
		then
			ZProofMode.ax_update_theory_db para
		else
			ZProofMode.ax_update_theory_db para
end);

=TEX
\subsection{Z Schema Box Recogniser}
=SML
fun Ûz_schbox_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZSchema")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_schbox_recogniser" 49003 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "z_standard_z_paragraphs";
	val tokens = ZTSch::(z_lex value);
	val parsed = z_parser {is_quot = false, standard = standard} tokens;
	val type_checked = type_check_z_para {standard = standard} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	if get_flag "z_type_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	if get_flag "z_use_axioms"
		then
			ZProofMode.ax_update_theory_db para
		else
			ZProofMode.ax_update_theory_db para
end);
=TEX
\subsection{Z General Text Recogniser}
=SML
fun Ûz_other_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "¹")
			andalso	is_same_symbol(finish, "°")
			andalso	(lang = "Z")
		then	()
		else
			fail "z_other_recogniser" 49004 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = get_flag "z_standard_z_paragraphs";
	val tokens = z_lex value;
	val parsed = z_parser {is_quot = false, standard = standard} tokens;
	val type_checked = type_check_z_para {standard = standard} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in
	if get_flag "z_type_check_only"
	then	ZTypeCheckOnlyMode.update_theory_db para
	else	if get_flag "z_use_axioms"
		then
			ZProofMode.ax_update_theory_db para
		else
			ZProofMode.ax_update_theory_db para
end);
=TEX
\section{RECOGNIZING Z TERMS}

=SML
fun Ûz_term_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if(	is_same_symbol(start, "StartZTerm")
			andalso	is_same_symbol(finish, ">")
			andalso	(lang = "")
		) orelse (
			is_same_symbol(start, "<")
			andalso	is_same_symbol(finish, ">")
			andalso	lang = "Z"
		)
		then	()
		else
			fail "z_term_recogniser" 49010 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val standard = not (get_flag "z_extended_z_terms");
	val tokens = z_lex value;
	val parsed = z_parser {is_quot = true, standard = standard} tokens;
	val side = case parsed of
		ZParaTerm _ => ()
		|_ => fail "z_term_recogniser" 49001 [];
	val type_checked = type_check_z_para {standard = standard} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in	term_of_z_para para
end);


=TEX

\section{EPILOGUE}

The structure for Z paragraphs is required to be open for use by the
reader/writer.

=SML
end (* of local ... in *);
end (* of structure ZParagraphRecognizers *);
open ZParagraphRecognizers;
=TEX

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}


=IGN

val x= mk_z_app (ñ{(a,b)}®, ñy®);

new_axiom(["thing"],x);





°
