% imp049.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Z Paragraphs}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP049}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the interface used to input Z specifications into the Z Proof Support System.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1] First Draft

\end{description}
\subsection{Changes Forecast}
When a Z lexical analyser and a Z lexis is available
\cite{DS/FMU/IED/DTD060}, the
implementation will be modified to use that. Also, the
Z term representation which is used by the parser for
parsed terms will be modified to be brought into line
when the representation has been agreed and made available
in the Z term/schematext parser design \cite{DS/FMU/IED/DTD061}.
\pagebreak
\section{GENERAL}
\subsection{Scope}
The implementation contained in this document corresponds
to the design of Z paragraphs in \cite{DS/FMU/IED/DTD049}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
\subsubsection{Dependencies}
\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}


\section{Z READER WRITER}

=SMLPLAIN SML
structure €ZReaderWriter›  = struct
local
open ReaderWriterSupport HOLReaderWriter;
in
=TEX
%********************************************************************

\subsection{Warning Messages}

Faults detected in the embedded text are reported via $local_error$ as
they occur, they are also noted in the generated output using these
two functions.

=SMLPLAIN SML
fun €lex_error_code› (id : int, prev:string list) : string list = (
	", Lex.Text\"" :: (*="=*)
	"Lex.Error " ^ (string_of_int id) ::
	"\", " :: (*="=*)
	prev
);

fun	€lex_error_codes› (nil : int list, prev:string list) : string list =
		prev
|	lex_error_codes (errnos, prev) =
		fold lex_error_code errnos prev
;
=TEX

%********************************************************************


\subsection{Recursive Z Parser}

Brackets within Z text need only be examined to see if they relate to
comments, all the other forms of bracket can simple be passed on for
the Z lexical analyser and parser to deal with.

{\ftlinepenalty=9999
=SMLPLAIN SML
fun €get_Z_any› (R:READER_ENV) (prevA:string list) (sep_symbol : string)
			: string list= (
let
	open PrettyNames;

	fun	do_keyword _ (_,Value ch,Simple) p =
			get_Z_any R ((to_ML_string ch) :: p) sep_symbol
	|	do_keyword _ (names,Nil,Simple) p =
			get_Z_any R ("%" ^ (hd names) ^ "%" :: p) sep_symbol
	|	do_keyword k (info as (_,_, (Starting(proc, str)))) p =
			get_Z_any R (proc R k str false p) sep_symbol
	|	do_keyword _ (_,_,Middle str) p =
			get_Z_any R (str :: p) sep_symbol
	|	do_keyword (k, _) (_,ch_opt,Ending str) p =
			((*=[(("=*)	"\"))" :: k :: "\"], \"" :: str :: p)
	|	do_keyword _ (_,_,Ignore) p =
			get_Z_any R p sep_symbol
	|	do_keyword (k, is_keyword) (names,_,Invalid) p = (
			local_error "get_Z_any" 5007
				[fn () => if is_keyword then "%" ^ k ^ "%" else k];
			get_Z_any R (lex_error_code(5007, p)) sep_symbol);

	fun do_string ML_string = (
		let	val (read_string, ol_name) =
				if ML_string
				then	(get_ML_string, "Lex.String")
				else	(get_primed_string, "Lex.Char");
			val (str, errnos) = read_string R (ol_name :: "\", " :: prevA); (*="=*)
			val text_so_far = ", Lex.Text\"" (*="=*) :: str;
		in
			get_Z_any R (lex_error_codes(errnos, text_so_far)) sep_symbol
		end
	);

	val next = #look_at_next R ()
in
	case read_symbol R
	of	SymCharacter ch => (
			case ch
			of "("	=>	(	if #look_at_next R () = "*"
						then
							(skip_comment R;
							get_Z_any R (" " :: prevA) sep_symbol)
						else
							get_Z_any R ( "(" ::  prevA) sep_symbol)
			|  "\""	=>	do_string true (*="=*)
			|  "`"	=>	do_string false
			|  "\^D" =>	prevA
			|  "Q"	=>	get_Z_any R ("QQQQ" :: prevA) sep_symbol
			|  "\\"	=>	get_Z_any R ("\\\\" :: prevA) sep_symbol
			|  _ => 	get_Z_any R (ch :: prevA) sep_symbol
		)
	|	SymWhite xs =>
			if contains xs "\n"
			then	sep_symbol :: prevA
			else	get_Z_any R (" " :: prevA) sep_symbol
	|	SymKnown(sym, is_keyword, info) => do_keyword (sym, is_keyword) info prevA
	|	SymDoublePercent => get_Z_any R ("%%" :: prevA) sep_symbol
	|	SymUnknownKw(sym, is_closed) => (
			local_error "get_Z_any" 5003 [fn () => sym, fn () =>
							implode(rev(" ... " :: (prevA to 20)))];
			get_Z_any R (lex_error_code(5003, prevA)) sep_symbol
		)
	|	SymUnknownChar ch => (
			local_error "get_Z_any" 5005
						[fn () => ch,
						fn () => string_of_int(ord ch),
						fn () => implode(" ... " :: (rev(prevA to 20)))];
				get_Z_any R (lex_error_code(5005, prevA)) sep_symbol
		)
end);
=TEX
}

%********************************************************************

\subsection{Outer Level of the Z Reader}

Z text is to be read, the opening symbol and language name are
given.  Produce Standard~ML text as follows to add onto the left
hand context.

=GFT SML
( recogniser ( "starting symbol", "language name", quoted_text, "closing symbol" ))
=TEX

When the $add_semi$ argument is true then add, additionaly, a semi-colon
to indicate the end of an outermost Standard~ML expression.

Where the $quoted_text$ is a list of values of type $Lex.INPUT$, see
section\ref{DatatypeForParserInterface}.  Function $Z_reader$ is
responsible for building the opening part of the Standard~ML text,
function $get_Z_any$ reads and assembles the quoted text (i.e., the
body of the quotation) and the closing text.

=SMLPLAIN SML
fun €Z_reader› (recogniser:string) (add_semi:bool) (sep_symbol : string)
		(R:READER_ENV) (start:string, is_keyword:bool)
		(lang:string) (opening:string) (prevA:string list) : string list = (
let
	val prevB =
		opening ::
		"\", [Lex.Text\"" ::
		lang ::
		"\", \"" ::
		start ::
		"(\"" (*=")=*) ::
		recogniser ::
		"(" ::
		prevA;

	val read_text = get_HOL_any R (get_Z_any R prevB sep_symbol);
in
	if add_semi
	then
		";" :: read_text
	else
		read_text
end
);
=TEX


=SMLPLAIN SML
end (* local ... in *);
end (* of structure ZReaderWriter *);
=TEX


\section{EXTENSIONS TO READER/WRITER}


=SML
structure €ZParagraphs› = struct
=TEX
=SML
local
	open Lex SymbolTable ReaderWriterSupport;
	open ZReaderWriter;
	open HOLReaderWriter;
	open PrettyNames;
	open ZLex;
in
=TEX
=SMLLITERAL

val sd = add_new_symbols [
	([	"StartZGeneric"],	Value "ù", Starting(specific_quotation, "")),
	([	"StartZSchema"],	Value "ˇ", Starting(specific_quotation, "")),
	([	"EndZBox"],		Value "à", Ending ""),
	([	"StartZTerm"],	Value "Ò", Starting(specific_quotation, ""))
] handle _ => ();
=TEX
=SML
val €z_axbox_reader› = HOL_reader "z_axbox_recogniser" true;
val €z_genbox_reader› = Z_reader "z_genbox_recogniser" true "ú";
val €z_schbox_reader› = Z_reader "z_schbox_recogniser" true "¸";
val €z_term_reader› = HOL_reader "z_term_recogniser" false;
val €z_other_reader› = HOL_reader "z_other_recogniser" true;
=TEX
=SMLLITERAL
val sd = map add_named_reader [
	("π", "ZAX", "Lex.Term", z_axbox_reader),
	("π", "Z", "Lex.Term", z_other_reader)
	] handle _ => [];

val sd = map add_specific_reader [
	("ù", "Lex.Term", z_genbox_reader),
	("ˇ", "Lex.Term", z_schbox_reader),
	("Ò", "Lex.Term", z_term_reader)
	] handle _ => [];

=TEX

\section{RECOGNIZING Z PARAGRAPHS}
=TEX
\subsection{Z Axiomatic Box Recogniser}
=SML
fun €z_axbox_recogniser› (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "π")
			andalso	is_same_symbol(finish, "∞")
			andalso	(lang = "ZAX")
		then	()
		else
			fail "z_axbox_recogniser" 49001 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = ZTAx::(zlex value);
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val side = update_theory_db type_checked;
in	format_zinferred type_checked
end);

=TEX
\subsection{Z Generic Box Recogniser}
=SML
fun €z_genbox_recogniser› (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZGeneric")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_genbox_recogniser" 49002 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = ZTAx::(zlex value);
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val side = update_theory_db type_checked;
in	format_zinferred type_checked
end);

=TEX
\subsection{Z Schema Box Recogniser}
=SML
fun €z_schbox_recogniser› (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZSchema")
			andalso	is_same_symbol(finish, "EndZBox")
			andalso	(lang = "")
		then	()
		else
			fail "z_schbox_recogniser" 49003 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = ZTSch::(zlex value);
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val side = update_theory_db type_checked;
in	format_zinferred type_checked
end);
=TEX
\subsection{Z General Text Recogniser}
=SML
fun €z_other_recogniser› (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "π")
			andalso	is_same_symbol(finish, "∞")
			andalso	(lang = "Z")
		then	()
		else
			fail "z_other_recogniser" 49004 [
				fn () => start,
				fn () => lang,
				fn () => finish]
	val tokens = zlex value;
	val parsed = ZParser.zparser {is_quot = false, standard = true} tokens;
	val type_checked = type_check_zpara {standard=true} parsed;
	val side = update_theory_db type_checked;
in	format_zinferred type_checked
end);
=TEX
\section{RECOGNIZING Z TERMS}

=SML
fun €z_term_recogniser› (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	is_same_symbol(start, "StartZTerm")
			andalso	is_same_symbol(finish, ">")
			andalso	(lang = "")
		then	()
		else
			fail "z_term_recogniser" 49010 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val tokens = zlex value;
	val parsed = ZParser.zparser {is_quot = true, standard = false} tokens;
	val side = case parsed of
		ZParaTerm _ => ()
		|_ => fail "z_term_recogniser" 49001 [];
	val type_checked = type_check_zpara {standard=false} parsed;
in	format_zinferred type_checked
end);

end (* local ... in *);

=TEX

\section{EPILOGUE}
=SML
end (* of structure ZParagraphs *);
open ZParagraphs;
=TEX

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}


=IGN
   πZAX
      c : ˙
   ˜
      c † {0..5}
   ∞

   ˇMYSCHEMA[STATE,MSG]¸
      s : STATE;
      t :  STATE
   ˜¸¸¸¸¸¸
      s ç t
   à¸¸¸¸¸¸


   ù[X]úúúú
      s : X;
      t :  X
   ˜¸¸¸¸¸¸
      s ç t
   à¸¸¸¸¸¸

   πZAX
      s : X
      t :  X
   ˜
      s ç t
   ∞

      Òµx ∑ trueÆ;

   πZ
      [STATE, ENDSYM]
   ∞

   πZ
      FRED[STATE, ENDSYM] ¶ Joe
   ∞

   πZ
      FreeType ::= Cons (x) | Nil 
   ∞

   πZ
      FreeType ::= Cons ßß3*4¢¢ | Thing  
   ∞

   πZ
      FreeType ::= Cons ßß2¢¢ | Nil 
   ∞

   πZ
      x > 5
   ∞

   πZ
      FRED == abbreviation
   ∞

   πZ
      FRED ¶ horiz_schema
   ∞

