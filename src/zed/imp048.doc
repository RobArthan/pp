=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation of Support for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP048}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/IMP047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the detailed design may be found in \cite{DS/FMU/IED/DTD048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{STRUCTURE}
=SML
structure âicl'ZTypesAndTermsá : icl'ZTypesAndTerms = struct
=TEX
\section{DERIVED HOL CONSTRUCTORS}
The functions defined here are an ad-hoc collection of constructors, destructors and discriminators which, at the time of writing, were not provided by the ICL HOL system.
If they are added in future, they will be removed from here.
=SML
fun	âlist_mk_‹_typeá ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_‹_type tyl ty;
=TEX
\section{SCHEMAS} \label{SCHEMAS}

\subsubsection{name formation}
The following specification is reproduced from \cite{DS/FMU/IED/DTD048}.

ê
	âunpack_IDENTá	: string – IDENT
	âpack_IDENTá 	: IDENT  string
É
	pack_IDENT ¯ unpack_IDENT = id[IDENT]
Ë

As discussed in \cite{DS/FMU/IED/DTD048}, the types $IDENT$, $WORD$ and $DECOR$ are simply implemented as $string$s.
=SML
fun	âpack_IDENTá ((w,d) :string * string) :string = (w ^ d);
fun	âunpack_IDENTá (s :string) :string * string =
	let 	fun 	f _ [] = ([],[])
		|	f _ ("'"::t) = ([],("'"::(snd(f true t))))
		|	f _ ("?"::t) = ([],("?"::(snd(f true t))))
		|	f _ ("!"::t) = ([],("!"::(snd(f true t))))
		|	f false (h::t) = 
				let	val (a,b) = f false t
				in	((h::a),b)
				end
		|	f _ _ = fail "unpack_IDENT" 48001 [fn() => s]
	in
		(implode ** implode)(f false (explode s)) 
	end;
=TEX

In the following definitions {\em idsetseq} is intended to sort a set of identifiers.
The ordering is immaterial and has not been specified, though it would be odd to make it other than lexicographic.
{\em flatpack} produces a comma-separated string from a sequence of strings.
It is required to be used on the empty sequence (since schemas obtained by hiding may have an empty signature).

ê
	âidsetseqá		: ’ IDENT  seq IDENT
	âflatpacká		: seq string  string
É
		(ƒfid: ’ IDENTŽ
			ran (idsetseq fid) = fid)
	€	(ƒss:seq string; s1,s2:stringŽ
			flatpack (¾¿) = ``
		€	flatpack (¾s1¿) = s1
		€	flatpack (ssµ¾s1¿µ¾s2¿) = (flatpack (ssµ¾s1¿))^`,`^s2)
Ë

=SML
fun	âidsetseqá (sl:string list) : string list = Sort.sort Sort.stringorder sl;
fun	âflatpacká ([]:string list) : string 	= ""
|	flatpack (s::[])			= s
|	flatpack (s::ss) 			= s ^ "©" ^ (flatpack ss);
=TEX

ê
	âval_setIDENTá	: ’ IDENT  string
	âitymfunseqá		: (IDENT œ TYPE) ‹ seq TYPE
	âbool_typeá		: TYPE
É
		(ƒfid: ’ IDENTŽ
			ran (idsetseq fid) = fid
		€	val_setIDENT fid = `[`^(flatpack((idsetseq fid)¯pack_IDENT))^`]`)
	€	(ƒitym:IDENT œ TYPEŽ
			itymfunseq itym = (idsetseq (dom itym)) ¯ itym)
	€	bool_type	= mk_type (`bool`,¾¿)
Ë

=SML
fun 	âval_setIDENTá (sl:string list) :string =
	"¾" ^ flatpack(idsetseq sl) ^ "¿";
fun	 âitymfunseqá (itym:(string * TYPE)list) :TYPE list =
	map (lassoc3 itym) (idsetseq(fst(split itym)));
val	âbool_typeá = BOOL;
=TEX

{\em number} maps numbers onto numerals.
ê
	ânumberá	: †  string
	âval_numeralá	: string Ú †
É
	ƒi:†Ž val_numeral (number i) = i
Ë

=SML
val	ânumberá :(int -> string) = string_of_int;
val	âval_numeralá :(string -> int) = nat_of_string;
=TEX

It is the schema calculus which causes the greatest problems.
To support schemas it is proposed to introduce infinite families of new HOL type constructors.
For each of these types various associated constants will also be introduced.

These various types and constants are described as follows:


\subsection{Bindings and Tuples}

\subsubsection{binding types}

For each finite set of identifiers a polymorphic type constructor is required which is the type of bindings which bind values to just the identifiers in the set.
It is necessary to give each of these type constructors a unique name, which we will form by appending to the prefix $`S\_`$ the alphabetically ordered list of identifiers.
The type constructor will have the same arity as the cardinality of the set of identifiers, and the types assigned to the identifiers will be supplied as parameters to the constructor in alphabetic order of the identifiers to which they are assigned.

The type will be represented by the set of n-tuples (formed in HOL by iteration of the PAIR constructor) having the same number of components.
A sample representation type predicate is as follows:

óML
let âbind_type_[a,b]_predá = "t:(*a ‰ *b)Ž T"
æ

The type $(*a,*b)S_{[a,b]}$ will be in bijection with the elements having the above property and an axiom will be needed which asserts that this is the case. 

Functions yielding the type name and the type respectively are as follows:
ê
	âbind_tnameá		: ’ IDENT ‹ string
	âbind_typeá		: (IDENT œ TYPE) ‹ TYPE
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	bind_tname fid		= `S_`^(val_setIDENT fid)
€	bind_type itym		= mk_type (bind_tname(dom itym), itymfunseq itym) 
Ë

=SML
fun	âbind_tnameá (fid :string list) :string = "S_" ^ (val_setIDENT fid);
fun 	âbind_typeá (itym :(string * TYPE) list) :TYPE = 
		mk_ctype (bind_tname(fst(split itym)), itymfunseq itym);
=TEX

\subsubsection{tuple types}


ê
	âtuple_tnameá	: seq TYPE ‹ string
	âtuple_typeá	: seq TYPE ‹ TYPE
É
	tuple_tname tyl = `T_¾`^(number #tyl)^`¿`
	tuple_type tyl = mk_type(tuple_tname tyl,tyl)
Ë

=SML
fun	âtuple_tnameá (tyl: TYPE list) :string = "T_¾" ^ number(length tyl) ^ "¿";
fun	âtuple_typeá (tyl: TYPE list) :TYPE = mk_ctype(tuple_tname tyl,tyl);
=TEX

\subsubsection{binding constructors}

For every binding type there will be a constant for constructing bindings of that type.
The name of this constructor will be formed by prefixing $`mk\_`$ to the name of the type of the binding.
The type of the constructor will be that of a curried function taking parameters whose types are type variables having the same name as the identifiers in the signature of the bindings.
The result type will be the binding type with type variables similarly named supplied as parameters,
e.g. `$mk\_S_{[a,b]}:*a ‹ *b ‹ (*a,*b)S_{[a,b]}$'.

The element of the representation type corresponding to the entity constructed is simply the tuple formed from the values supplied as arguments.
A sample definition for the constructor would therefore be:

óHOL Constant
	âmk_S_[a,b]á: *a ‹ *b ‹ (*a,*b)S_[a,b]
É
	mk_S_[a,b] a b = ABS_S_[a,b] (a,b)
æ

In general type instantiations of these constructors will be required rather than the fully polymorphic types and terms.
The functions below provide appropriate instantiations.

ê
	âbind_cnameá		: ’ IDENT ‹ string
	âbind_ctypeá		: (IDENT œ TYPE) ‹ TYPE
	âbind_ctermá		: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	bind_cname fid	= `mk_`^(bind_tname fid)
€	bind_ctype itym	= list_mk_‹_type (itymfunseq itym, bind_type itym)  
€	bind_cterm itym	= mk_const (bind_cname (dom itym), bind_ctype itym)  
Ë

These binding constructors are used in theta terms, {\em termtheta}.

=SML
fun	âbind_cnameá (fid :string list) :string = "mk_" ^ (bind_tname fid);
fun	âbind_ctypeá (itym :(string * TYPE) list) :TYPE =
		list_mk_‹_type(itymfunseq itym, bind_type itym);
fun 	âbind_ctermá (itym :(string * TYPE) list) :TERM =
		mk_const (bind_cname (fst(split itym)), bind_ctype itym);
=TEX

\subsubsection{tuple constructors}

The special case of tuples is also catered for:
ê
	âtuple_cnameá	: seq TYPE ‹ string
	âtuple_ctypeá	: seq TYPE ‹ TYPE
	âtuple_ctermá	: seq TYPE ‹ TERM
É
	ƒsty:seq TYPEŽ

	tuple_cname sty	= "mk_" ^ (tuple_tname sty)
	tuple_ctype sty = list_mk_‹_type (sty, tuple_type sty)
	tuple_cterm sty	= mk_const(tuple_cname sty,tuple_ctype sty)
Ë

=SML
fun	âtuple_cnameá (sty:TYPE list) :string = "mk_" ^ (tuple_tname sty);
fun	âtuple_ctypeá (sty:TYPE list) :TYPE = list_mk_‹_type (sty, tuple_type sty);
fun	âtuple_ctermá (sty:TYPE list) :TERM = mk_const(tuple_cname sty,tuple_ctype sty);
=TEX

\subsubsection{cartesian products}

ê
	âpowertá	: TYPE ‹ TYPE
É
	ƒty:TYPEŽ	powert ty = mk_type(`‘`,¾t¿)
Ë

ê
	âprod_cnameá	: seq TYPE ‹ string
	âprod_ctypeá	: seq TYPE ‹ TYPE
	âprod_ctermá	: seq TYPE ‹ TERM
É
	ƒsty:seq TYPEŽ

	prod_cname sty	= `mkprod_¾`^(number (#sty))^`¿`
	prod_ctype sty		= list_mk_‹_type(
					itymfunseq (pack_IDENT ¯ val_numeral ¯ sty ¯ powert),
					powert (mk_tuple_type sty))
	prod_cterm sty		= mk_const(prod_cname sty, prod_ctype sty)
Ë

=SML
fun	âprod_cnameá (sty: TYPE list) :string = "mkprod_¾" ^ (number(length sty)) ^ "¿";
fun	âprod_ctypeá (sty: TYPE list) :TYPE = list_mk_‹_type(sty,mk_ctype("‘",[tuple_type sty]));
fun	âprod_ctermá (sty: TYPE list) :TERM = mk_const(prod_cname sty, prod_ctype sty);
=TEX

\subsubsection{binding projections}

For every binding type there will be a set of projection functions, which select components of the binding.
These will have names formed by concatenating the identifier of the component to be selected, and the name of the type of the binding.
The type of the projection will be a function.
The domain type of the function is the type of the binding with appropriate type variables, the co-domain is then the type variable having the same name as the component to be selected.

The following is an example of how the projection functions will be defined.

óHOL Constant
	âS_[a,b]_aá:(*a,*b)S_[a,b] ‹ *a
	âS_[a,b]_bá:(*a,*b)S_[a,b] ‹ *b
É
	(S_[a,b]_a x = FST (REP_S_[a,b] x))
€	(S_[a,b]_b x = SND (REP_S_[a,b] x))
æ

Once again the functions defined yield type instantiated terms.

ê
	âbind_pnameá		: ’ IDENT		‹ IDENT ‹ string
	âbind_ptypeá		: (IDENT œ TYPE)	‹ IDENT ‹ TYPE
	âbind_ptermá		: (IDENT œ TYPE)	‹ IDENT ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPE; i:IDENTŽ

	bind_pname fid i	= (bind_tname fid)^val_setIDENT¾pack_IDENT i¿
€	bind_ptype itym i	= mk_funt(bind_type itym, itym i)  
€	bind_pterm itym i	= mk_const (bind_pname (dom itym) i, bind_ptype itym i)  
Ë

The projection constants are used for selection notation {\em S.name}, in {\em termsel}

=SML
fun	âbind_pnameá (fid:string list) (i:string) :string =
		(bind_tname fid) ^ (val_setIDENT[i]);
fun	âbind_ptypeá (itym:(string * TYPE) list) (i:string) :TYPE =
		mk_‹_type(bind_type itym,lassoc3 itym i);
fun	âbind_ptermá (itym:(string * TYPE) list) (i:string) :TERM =
		mk_const (bind_pname (fst(split itym)) i, bind_ptype itym i);
=TEX

\subsubsection{tuple projections}
\subsection{Schemas}

A schema is a set of bindings.
First we deal with schema types (which in this document are the types of schemas, but in \cite{spivey89} are the types of bindings), then with various operations on schemas which are available in Z.

As with bindings there is an infinite collection of schema types.

All the operations of the schema calculus require complete families of constants, indexed by the schema types over which they are legal.
Operations over schemas or schema expression which involve variable binding constructs are deferred to the next section.

\subsubsection{schema types}

A schema is a set of bindings, a schema type is therefore a powerset of a binding type:

ê
	âschema_typeá		: (IDENT œ TYPE) ‹ TYPE
É
	ƒitym:IDENT œ TYPEŽ

	schema_type itym	= mk_type (`‘`,¾bind_type itym¿)  
Ë

=SML
fun	âschema_typeá (itym:(string * TYPE) list) :TYPE =
		mk_ctype("‘",[bind_type itym]);
=TEX

Names for the operations will be formed in general by decorating the normal operation symbol by the type name of the operand or operands.

The operations are of various kinds as follows, grouped by type similarities (of which there are few!):

\subsubsection{schema negation}

Schema negation (schneg), takes any schema type to the same type.
It is semantically simply the complement operation on the set, and need not be restricted to sets of bindings.

óHOL Constant
	âbind_Œá	: (*)‘ ‹ (*)‘
É
	ƒs:(*)‘Ž	bind_Œ s = ABS_‘ (x:*Ž x “ s)
æ

The following definitions serve only to give type instances of the above constant:

ê
	âbind_Œ_typeá		: (IDENT œ TYPE) ‹ TYPE
	âbind_Œ_termá		: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	bind_Œ_type itym	= mk_funt (schema_type itym, schema_type itym)  
€	bind_Œ_term itym	= mk_const (`bind_Œ`, bind_Œ_type itym)  
Ë

=SML
fun	âbind_Œ_typeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type (schema_type itym, schema_type itym);
fun	âbind_Œ_termá (itym:(string * TYPE) list) :TERM = 
		mk_const ("bind_Œ", bind_Œ_type itym);
=TEX

\subsubsection{schema precondition}

óHOL Constant
	âpre_S_[a',b]á:((*a,*b)S_[a',b])‘ ‹ ((*b)S_[b])‘
É
	ƒs:((*a,*b)S_[a',b])‘ Ž

	pre_S_[a',b] s = [b:*b|„a':*aŽ s]
æ

The precondition operator takes a schema and existentially quantifies all the variables which are either outputs or part of the new state.
The type of the resulting schema is therefore obtained by discarding all components of the type of the constituent bindings which have identifiers ending with ' or !.

We first define separately a function which determines which of the identifiers in a binding type are the identifiers of results of the operation described by the schema.
{\em There is room for debate about whether this is the correct interpretation of \cite{spivey89}.}

ê
	âschema_resultsá	: (IDENT œ TYPE) ‹ ’ IDENT
É
	ƒitym:IDENT œ TYPEŽ

	schema_results itym =

	{w:WORD; d,fd:DECOR; s:string
	|	(fd = `'`  fd = `!`) € (w^d = s^fd)
	Ž	(w,d)
	}	  (dom itym)
Ë

The type of the result of the precondition operation is the type of the original schema with the results hidden.
In fact precondition is definable in terms of hiding, but separate operators are needed to preserve the distinction for the concrete syntax.

ê
	âbind_pre_nameá	: ’ IDENT ‹ string
	âbind_pre_typeá	: (IDENT œ TYPE) ‹ TYPE
	âbind_pre_termá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	bind_pre_name fid	= `pre_`^(bind_tname fid)
€	bind_pre_type itym	= mk_funt
				(schema_type itym,
				 schema_type ((schema_results itym)	› itym)
				)  
€	bind_pre_term itym	= mk_const (bind_pre_name (dom itym), bind_pre_type itym)  
Ë

=SML
fun	âbind_pre_nameá (fid:string list) :string = "pre_" ^ (bind_tname fid);
fun	âbind_pre_typeá (itym:(string * TYPE) list) :TYPE =
	let	fun	sch_res ((_,"'"),_) = true
		|	sch_res ((_,"!"),_) = true
		|	sch_res _ = false
	in
		mk_‹_type(
			schema_type itym,
			schema_type(itym drop (sch_res o (unpack_IDENT ** Combinators.I)))
		)
	end;
fun	âbind_pre_termá (itym:(string * TYPE) list) :TERM =
		mk_const (bind_pre_name (fst(split itym)), bind_pre_type itym);
=TEX

\subsubsection{simple dyadic schema operations}

óHOL Constant
	â€[a,b][b,c]á:((*a,*b)S_[a,b])‘ ‹ ((*b,*c)S_[b,c])‘  ‹ ((*a,*b,*c)S_[a,b,c])‘
É
	ƒsc1:((*a,*b)S_[a,b])‘; sc2:((*b,*c)S_[b,c])‘Ž

	€[a,b][b,c] sc1 sc2 = [a:*a; b:*b; c:*c | sc1 € sc2]
æ

(schand, schor, schimp) taking any compatible pair of schema types to the schema type having the union of the components (with appropriate component types).

Since these operations are so similar they are provided by the same functions which take the particular operation name as a parameter:

ê
	âbind_dysc_nameá	: string ‹ ’ IDENT ‹ ’ IDENT ‹ string
	âbind_dysc_typeá	: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TYPE
	âbind_dysc_termá	: string ‹ (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
É
	ƒfid1,fid2:’ IDENT; itym1,itym2:IDENT œ TYPE; n:stringŽ

	bind_dysc_name n fid1 fid2	= n^(val_setIDENT fid1)^(val_setIDENT fid2) 
€	bind_dysc_type itym1 itym2	= list_mk_‹_type
						(¾schema_type itym1,schema_type itym2¿,
						schema_type (itym1 ¡ itym2))
€	bind_dysc_term n itym1 itym2	= mk_const (bind_dysc_name n (dom itym1) (dom itym2),
							bind_dysc_type itym1 itym2)  
Ë

The following are primarily illustrative of the use of the above, and are not used in the sequel.

ê
	âbind_€_termá		: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
	âbind__termá		: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
	âbind_Š_termá	: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
	âbind_‚_termá	: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
É
	bind_€_term		= bind_dysc_term `€` 
 	bind__term		= bind_dysc_term ``  
	bind_Š_term		= bind_dysc_term `Š`  
	bind_‚_term		= bind_dysc_term `‚`  
Ë

It should be noted that the full generality of these functions will not be available in any implementation.
Only the identified operations will be supported.

=SML
fun	âbind_dysc_nameá (n:string) (fid1:string list) (fid2:string list) :string = 
		n ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_dysc_typeá (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TYPE = 
		list_mk_‹_type(
			[schema_type itym1,schema_type itym2],
			schema_type (itym1 cup itym2)
		);
fun	âbind_dysc_termá (n:string) (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TERM = 
		mk_const (	bind_dysc_name n (fst(split itym1)) (fst(split itym2)),
				bind_dysc_type itym1 itym2);
val	âbind_€_termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "€_";
val	âbind__termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "_";
val	âbind_Š_termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Š_";
val	âbind_‚_termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "‚_";
=TEX
\subsubsection{schema projection}

óHOL Constant
	âpro[a,b][b,c]á:((*a,*b)S_[a,b])‘ ‹ ((*b,*c)S_[b,c])‘  ‹ ((*b,*c)S_[b,c])‘
É
	ƒsc1:((*a,*b)S_[a,b])‘; sc2:((*b,*c)S_[b,c])‘Ž

	pro[a,b][b,c] sc1 sc2 = (sc1 € sc2) Ä (a)
æ

(schpro) takes two schemas of compatible types and yields a schema having the same type as the second

ê
	âbind_pro_nameá	: ’ IDENT ‹ ’ IDENT ‹ string
	âbind_pro_typeá	: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TYPE
	âbind_pro_termá	: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
É
	ƒfid1,fid2:’ IDENT; itym1,itym2:IDENT œ TYPEŽ

	bind_pro_name fid1 fid2	= `Á_`^(val_setIDENT fid1)^(val_setIDENT fid2)
€	bind_pro_type itym1 itym2	= list_mk_‹_type
				(	¾schema_type itym1, schema_type itym2¿,
					schema_type itym2
				)  
€	bind_pro_term itym1 itym2
		= mk_const (bind_pro_name (dom itym1) (dom itym2), bind_pro_type itym1 itym2)  
Ë

=SML
fun	âbind_Á_nameá (fid1:string list) (fid2:string list) :string =
		"Á_" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_Á_typeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_‹_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym2
		);

fun	âbind_Á_termá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_Á_name (fst(split itym1)) (fst(split itym2)),
			bind_Á_type itym1 itym2);
=TEX

\subsubsection{schema hiding}

óHOL Constant
	âhide[a,b][b]á:((*a,*b)S_[a,b])‘ ‹ ((*a)S_[a])‘
É
	ƒsc:((*a,*b)S_[a,b])‘Ž

	hide[a,b][b] sc = [a:*a | „b:*bŽ sc]
æ

(schide) takes one schema and a list of identifiers and yields a schema whose type is formed from the type of the first parameter by deleting all components whose identifiers are in the list.

ê
	âbind_hide_nameá	: ’ IDENT ‹ ’ IDENT ‹ string
	âbind_hide_typeá	: (IDENT œ TYPE) ‹ (’ IDENT) ‹ TYPE
	âbind_hide_termá	: (IDENT œ TYPE) ‹ (’ IDENT) ‹ TERM
É
	ƒfid1,fid2:’ IDENT; itym:IDENT œ TYPEŽ

	bind_hide_name fid1 fid2	= `Ä_`^(val_setIDENT fid1)^(val_setIDENT fid2)
€	bind_hide_type itym fid1	= mk_funt
				(	schema_type itym,
					schema_type (fid1 › itym)
				)  
€	bind_hide_term itym fid1
		= mk_const (bind_hide_name (dom itym) fid1, bind_hide_type itym fid)  
Ë

=SML
fun	âbind_Ä_nameá (fid1:string list) (fid2:string list) :string =
		"Ä_" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_Ä_typeá (itym:(string * TYPE) list) (fid2:string list) :TYPE =
		mk_‹_type(
			schema_type itym,
			schema_type(itym drop (fn(s,_)=> s mem fid2))
		);
fun	âbind_Ä_termá (itym:(string * TYPE) list) (fid2:string list) :TERM =
		mk_const (
			bind_Ä_name (fst(split itym)) fid2, 
			bind_Ä_type itym fid2
		);
=TEX

\subsubsection{decoration}

(sdes) when schema designator is used it may be supplied with further decorations.
The effect is to add the decorations to the identifiers in the bindings.
 
ê
	âdecor_idá	: string ‹ IDENT ‹ IDENT
	âdecor_idtá	: string ‹ (IDENT ‰ TYPE) ‹ (IDENT ‰ TYPE)
	âdecor_itymá	: string ‹ (IDENT œ TYPE) ‹ (IDENT œ TYPE)
É
	ƒs:string; w:WORD; d:DECOR; i:IDENT; ty:TYPE; itym:IDENT œ TYPEŽ 

	decor_id s (w,d)	= (w,d^s)
€ 	decor_idt s (i,ty)	= (decor_id s i,ty)
€	decor_itym s itym	= (decor_idt s) ÑitymÒ
Ë
ê
	âbind_decor_nameá	: ’ IDENT ‹ string ‹ string
	âbind_decor_typeá	: (IDENT œ TYPE) ‹ string ‹ TYPE
	âbind_decor_termá	: (IDENT œ TYPE) ‹ string ‹ TERM
É
	ƒfid:’ IDENT; s:string; itym:IDENT œ TYPEŽ

	bind_decor_name fid s	= `decor_`^(val_setIDENT fid)^`¾`^s^`¿`
€	bind_decor_type itym s	= mk_funt
				(	schema_type itym,
					schema_type (decor_itym s itym)
				)  
€	bind_decor_term itym s
		= mk_const (bind_decor_name (dom itym) s, bind_decor_type itym s)  
Ë

=SML
fun	âbind_decor_nameá (fid:string list) (s:string) :string =
		"decor_" ^ (val_setIDENT fid) ^ "¾" ^ s ^ "¿";
fun	âbind_decor_typeá (itym:(string * TYPE) list) (s:string) :TYPE =
		mk_‹_type(
			schema_type itym,
			schema_type(map(fn(id,ty)=>(id^s,ty))itym)
		);
fun	âbind_decor_termá (itym:(string * TYPE) list) (s:string) :TERM =
		mk_const (bind_decor_name (fst(split itym)) s, bind_decor_type itym s);
=TEX

\subsubsection{the delta operation}

The delta operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with ').

ê
	âbind_delta_nameá	: ’ IDENT ‹ string
	âbind_delta_typeá	: (IDENT œ TYPE) ‹ TYPE
	âbind_delta_termá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	bind_delta_name fid	= `delta_`^(val_setIDENT fid)
€	bind_delta_type itym	= mk_funt
				(	schema_type itym,
					schema_type (itym ¡ (decor_itym `'` itym))
				)  
€	bind_delta_term itym
		= mk_const (bind_delta_name (dom itym), bind_delta_type itym)
Ë

=SML
fun	âbind_ñ_nameá (fid:string list) :string = "ñ_" ^ (val_setIDENT fid);
fun	âbind_ñ_typeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type(
			schema_type itym,
			schema_type(itym @ (map (fn(id,ty)=>(id^"'",ty)) itym))
		);
fun	âbind_ñ_termá (itym:(string * TYPE) list) :TERM =
		mk_const (bind_ñ_name (fst(split itym)), bind_ñ_type itym);
=TEX

\subsubsection{the $\Xi$ operation}

The $\Xi$ operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with '), with the before and after values equated in the predicate.
The type is the same as that of the $\Delta$ operation.

ê
	âbind_xi_nameá	: ’ IDENT ‹ string
	âbind_xi_typeá	: (IDENT œ TYPE) ‹ TYPE
	âbind_xi_termá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	bind_xi_name fid	= `xi_`^(val_setIDENT fid)
€	bind_xi_type			= bind_delta_type  
€	bind_xi_term itym
		= mk_const (bind_xi_name (dom itym), bind_xi_type itym)
Ë

=SML
fun	âbind_ò_nameá (fid:string list) :string = "ò_" ^ (val_setIDENT fid);
val	âbind_ò_typeá :(string * TYPE) list -> TYPE = bind_ñ_type;
fun	âbind_ò_termá (itym:(string * TYPE) list) :TERM =
		mk_const (bind_ò_name (fst(split itym)), bind_ò_type itym);
=TEX

\subsubsection{schema composition}

Schema composition is an operation which takes two schemas as arguments.
The schemas must be compatible in the following sense.
The primed components of the first schema must match in name and type the undecorated components of the second.
Any other components common to both must have the same type.

The type of the resulting schema is obtained by merging the two signatures hiding the primed components of the first and the undecorated components of the second.
There is a problem here about exactly what ``primed'' means.
Is a double primed identifier primed?

ê
	âbind_scomp_nameá	: ’ IDENT ‹ ’ IDENT ‹ string
	âbind_scomp_typeá	: (IDENT œ TYPE) ‹ TYPE
	âbind_scomp_termá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid1, fid2:’ IDENT; itym1,itym2:IDENT œ TYPEŽ

	bind_scomp_name fid1 fid2	= `¯_`^(val_setIDENT fid1)^(val_setIDENT fid2)
€	bind_scomp_type itym1 itym2	= list_mk_‹_type (
					¾schema_type itym1, schema_type itym2¿,
					schema_type (
			£{i,i':IDENT | i'  dom itym1 € i  dom itym2 
				€ (pack_IDENT i)^`'` = (pack_IDENT i') Ž {i,i'}}
			› (itym1 ¡ itym2))
€	bind_scomp_term itym1 itym2
		= mk_const (bind_scomp_name (dom itym1) (dom itym2),
			bind_scomp_type itym1 itym2)
Ë

=SML
fun	âbind_¯_nameá (fid1:string list) (fid2:string list) :string =
		"¯_" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_¯_typeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
	let	val itym2' = map (fn(s,ty)=>(s^"'",ty)) itym2;
		val itym =	(itym1 drop (fn(s,_) => (s mem (fst(split itym2')))))
					@
				(itym2 drop (fn(s,_) => ((s^"'") mem (fst(split itym1)))));
	in
		list_mk_‹_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym
		)
	end;
fun	âbind_¯_termá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_¯_name (fst(split itym1)) (fst(split itym2)),
			bind_¯_type itym1 itym2
		);
=TEX

\subsection{Variable Binding Constructs}

Take care to avoid confusion between the two distinct uses of the term {\em binding} in this document.
The {\em binding}s which are members of schemas, bind values to identifiers.
Such bindings are the values denoted by terms with a binding type (e.g. $S_{[a,b,c...]}$).
Constructs involving the syntactic category {\em DECL} also effect a binding.
In this latter case it is variables which are bound within some textual scope, for the purpose, for example, of universal quantification.
These binding constructs may yield terms, predicates or schema expressions depending on the form of the construct.

There are in Z a variety of binding constructs of this latter kind, in which a DECL occurs and serves to bind variables in following predicates or terms.

The general pattern followed in dealing with these constructs is simply an elaboration of the treatment in HOL of binders.

There is just the one primitive binding construct, viz: lambda abstraction.
All binding constructs are therefore first translated into lambda abstractions.
The result of the abstraction is then converted into the value required by the application of a constant which embodies the semantics of the particular binding construct concerned.

The image of the binding construct is therefore formed in the following way:
\begin{enumerate}
\item{}
The constituent expressions are mapped into HOL in the standard way
(in some cases the {\em characteristic tuple}, while not an explicit constituent of the syntax, must be supplied by the mapping as a component of the resulting HOL term).
\item{}
These terms are collected together into a binding.
The binding constructor will be either $mk\_S_{[d,p]}$ (for $schema$, $„_s$, $„_{1s}$ and $ƒ_s$), $mk\_S_{[d,p,v]}$ (for $„$, $„_1$, $ƒ$, $seta$ and $‡$) $mk\_S_{[d,p,t,v]}$ (for $$).
\item{}
An abstraction is formed by abstracting over each of the variables declared in the constituent DECL.
\item{}
A binding operator is applied to the function thus obtained.
There will be a family of binding operators for each of the eight different binding constructs.
\end{enumerate}
The names of the binding operators will be formed from the name of the constructor in the abstract syntax by appending the sequence of names declared in the signature.
Its type will vary according to the signature and the nature of the binder.
Details are filled in below for each of the binders in turn.

\subsubsection{binding constructs by group}

Binding constructs fall into three groups, according to the scope of the bindings which take place.

The full list of binding constructs in Z is as follows:

\begin{tabular}{|l|l|l|l|}\hline
{\bf constructor} & {\bf description} & {\bf category} & {\bf group}\\ \hline
$schema$ & schema & ZTERM (schema expression) & 1\\
$„_s$ & schema existential quantification & ZTERM (schema expression) & 1\\
$„_{1s}$ & schema unique existential quantification & ZTERM (schema expression) & 1\\
$ƒ_s$ & schema universal quantification & ZTERM (schema expression) & 1\\
$„$ & existential quantification & PRED & 2\\
$„_1$ & unique existential quantification & PRED & 2\\
$ƒ$ & universal quantification & PRED & 2\\
$seta$ & set abstraction (separation) & ZTERM & 2\\
$$ & lambda abstraction & ZTERM & 3\\
$‡$ & mu operator (description) & ZTERM & 2\\ \hline
\end{tabular}

In the following descriptions of how these groups of binding constructs are handled the various expressions which fall within the scope of the binding are collected together into a single expression as a schema binding (i.e. a value having a schema product or binding type).

The number of components, and therefore the signature of the binding type, varies between groups, but the significance of the identifiers used is consistently as follows:

\begin{description}
\item[t]
This component is the {\em characteristic tuple} extracted from the declaration part (DECL) of the schema.
\item[d]
This component is the predicate (a boolean term) implicit in the declaration part (DECL) of the schema.
\item[p]
This is the boolean term formed from the predicate (PRED) part of the schema.
\item[v]
This term (the value) is formed from the body of the abstraction (ZTERM or PRED).
In some cases this is defaulted to the characteristic tuple.
\end{description}

\subsubsection{group 1 packs}

In the simplest case (group 1) the variables are bound only in the immediately following predicate (and even this may be omitted in the concrete syntax).
i.e. in $schema$, $„_s$, $„_{1s}$, and $ƒ_s$, the variables declared in the DECL are bound only in the following PRED.

The following functions yield schema product or binding constructors which are appropriate for collecting together the elements within the scope of a group 1 construct.
In group 1 there are just two constituents, the first of which corresponds to the predicate implicit in the DECL, the second corresponding to the explicit predicate (PRED) following the vertical bar.
These are given component identifiers {\em d} and {\em p} respectively.

ê
	âg1_bind_sigá	: string œ TYPE
	âg1_bind_ctypeá	: TYPE
	âg1_bind_ctermá	: TERM
	âg1_bind_typeá	: TYPE
É
		g1_bind_sig		=	{
					`d`—bool_type,
					`p`—bool_type}

	€	g1_bind_ctype	= bind_ctype g1_bind_sig
	€	g1_bind_cterm	= bind_cterm g1_bind_sig
	€	g1_bind_type	= bind_type g1_bind_sig
Ë

=SML
val	âg1_bind_sigá :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type)];
val	âg1_bind_ctermá	:TERM = bind_cterm g1_bind_sig;
val	âg1_bind_typeá :TYPE = bind_type g1_bind_sig;
=TEX
\subsubsection{group 2 packs}

In the next case (group 2) a predicate or term follows, within which the relevant variables are also bound.
This is the ZTERM or PRED following the bullet.
This more complex case includes constructs $„$, $„_1$, $ƒ$, $seta$ and $‡$.
A ZTERM may be omitted in the concrete syntax, in which case the characteristic tuple will be used.
This substitution we presume at present to be undertaken by the parser/type-inference system.

ê
	âg2_bind_sigá	: TYPE ‹ (string œ TYPE)
	âg2_bind_ctypeá	: TYPE ‹ TYPE
	âg2_bind_ctermá	: TYPE ‹ TERM
	âg2_bind_typeá	: TYPE ‹ TYPE
É
	ƒty:TYPEŽ

		g2_bind_sig ty	=	{
					`d`—bool_type,
					`p`—bool_type,
					`v`—ty}

	€	g2_bind_ctype ty	= bind_ctype (g2_bind_sig ty)
	€	g2_bind_cterm ty	= bind_cterm (g2_bind_sig ty)
	€	g2_bind_type ty	= bind_type (g2_bind_sig ty)
Ë

=SML
fun	âg2_bind_sigá (ty:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("v",ty)];
fun	âg2_bind_ctermá (ty:TYPE) :TERM = bind_cterm (g2_bind_sig ty);
fun	âg2_bind_typeá (ty:TYPE) :TYPE = bind_type (g2_bind_sig ty);
=TEX
\subsubsection{group 3 packs}

The last case is that of the lambda abstraction which forms group 3.
In this case the characteristic tuple has a role to play even if a term is supplied following the bullet, and is therefore given an identifier of its own.

ê
	âg3_bind_sigá	: TYPE ‹ TYPE ‹ (string œ TYPE)
	âg3_bind_ctypeá	: TYPE ‹ TYPE ‹ TYPE
	âg3_bind_ctermá	: TYPE ‹ TYPE ‹ TERM
	âg3_bind_typeá	: TYPE ‹ TYPE ‹ TYPE
É
	ƒty1,ty2:TYPEŽ

		g3_bind_sig ty1 ty2	=	{
					`d`—bool_type,
					`p`—bool_type,
					`t`—ty1,
					`v`—ty2}

	€	g3_bind_ctype ty1 ty2	= bind_ctype (g3_bind_sig ty1 ty2)
	€	g3_bind_cterm ty1 ty2	= bind_cterm (g3_bind_sig ty1 ty2)
	€	g3_bind_type ty1 ty2	= bind_type (g3_bind_sig ty1 ty2)
Ë

=SML
fun	âg3_bind_sigá (ty1:TYPE) (ty2:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("t",ty1),
		("v",ty2)];
fun	âg3_bind_ctermá (ty1:TYPE) (ty2:TYPE) :TERM = bind_cterm (g3_bind_sig ty1 ty2);
fun	âg3_bind_typeá (ty1:TYPE) (ty2:TYPE) :TYPE = bind_type (g3_bind_sig ty1 ty2);
=TEX
In the following sections we supply for each variable binding construct:
\begin{enumerate}
\item{}
a verbal description of how it is mapped into HOL,
\item{}
a sample HOL-like definition of one of the binders in each family, showing both the type and the value (as an HOL term) of the binder,
\item{and}
a formal Z specification of functions which compute the binding constant.
\end{enumerate}

In the HOL-like sample definitions the Z dot notation is used as shorthand for the application of the relevant projection function.
The samples are generic in the types assigned to the identifiers in the signature, but are shown for specific signatures.
In these examples the schema types $S_{[d,p]}$, $S_{[d,p,v]}$, $S_{[d,p,t,v]}$ are fixed binding types used for packaging the two three or four components over which the abstraction is to be formed.

\subsubsection{bindings yielding schema expressions}

Variable binding in schema expressions occurs in schemas and in existential and universal quantification.
In its use in quantifiers the schema expression which follows the binding is not within its scope, i.e. the names in the signature are not bound in the schema expression forming the body of the construct.
For this reason, in contrast to all the other binding constructs, this schema expression is not included in the package over which the variables in the signature have been abstracted.
It is supplied as a second argument to the binding constant (which is a curried function).
This can be seen clearly by referring to the type of the binders in the following sections.

\subsubsection{schemas}

The simplest binding construct is that which simply yields a schema.
The following HOL constant is a sample of the infinite family of constants required: 

óHOL Constant
	âschema_[a,b]á	: (*a ‹ *b ‹ (bool,bool)S_[d,p]) ‹ ((*a,*b)S_[a,b])‘
É
	(schema_[a,b] p
		=	ABS_‘(x:S_[a,b]Ž
				let	t = p  x.a  x.b
				in	t.d  €  t.p))

æ

We now specify functions which compute from the elements of the abstract syntax the name, type and term of the binding operators:

ê
	âschema_bnameá	: (’ IDENT) ‹ string
	âschema_btypeá	: (IDENT œ TYPE) ‹ TYPE
	âschema_btermá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	schema_bname fid	= `schema_`^(val_setIDENT fid)
€	schema_btype itym	= mk_funt(
		list_mk_‹_type (itymfunseq itym, g1_bind_type),
		schema_type itym
					)
€	schema_bterm itym	= mk_const (schema_bname (dom itym), schema_btype itym)
Ë

=SML
fun	âschema_bnameá (fid:string list) :string =
		"schema_" ^ (val_setIDENT fid);
fun	âschema_btypeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type(
			list_mk_‹_type (itymfunseq itym, g1_bind_type),
			schema_type itym
		);
fun	âschema_btermá (itym:(string * TYPE) list) :TERM =
		mk_const (schema_bname (fst(split itym)), schema_btype itym);
=TEX

\subsubsection{schema existential quantification}

óHOL Constant
	â„%down%s_[a,b][c,d]á	:
		(*a ‹ *b ‹ (bool,bool)S_[d,p]) ‹ ((*a,*b,*c,*d)S_[a,b,c,d])‘ ‹ ((*c,*d)S_[c,d])‘
É
	(„%down%s_[a,b][c,d] p q
		= 	ABS_‘(x:S_[c,d]Ž „y:S_[a,b]Ž
				let	t = p  y.a  y.b
				in	t.d  €  t.p
					€ (mk_S_[a,b,c,d]  y.a  y.b  x.c  x.d)  q))
æ

ê
	â„%down%s_bnameá	: (’ IDENT) ‹ (’ IDENT) ‹ string
	â„%down%s_btypeá		: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TYPE
	â„%down%s_btermá		: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
É
	ƒfid1,fid2:’ IDENT; itym1,itym2:IDENT œ TYPEŽ

	„%down%s_bname fid1 fid2
		= `„%down%s_`^(val_setIDENT fid1)^(val_setIDENT (fid2Äfid1))
€	„%down%s_btype itym1 itym2
		= list_mk_‹_type
			(¾ list_mk_‹_type (itymfunseq itym1, g1_bind_type),
				schema_type itym2 ¿,
			(schema_type (itym2Äitym1)))
€	„%down%s_bterm itym1 itym2
		= mk_const („%down%s_bname (dom itym1) (dom itym2),
				„%down%s_btype itym1 itym2)
Ë

=SML
fun	â„%down%s_bnameá (fid1:string list) (fid2:string list) :string =
		"„%down%s_" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	â„%down%s_btypeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_‹_type([
			list_mk_‹_type (itymfunseq itym1, g1_bind_type),
			schema_type itym2
			],
			(schema_type (itym2 diff itym1))
			);
fun	â„%down%s_btermá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			„%down%s_bname (fst(split itym1)) (fst(split itym2)),
			„%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema unique existential quantification}

óHOL Constant
	â„%down%1%down%s_[a,b][c,d]á	:
		(*a ‹ *b ‹ (bool,bool)S_[d,p]) ‹ ((*a,*b,*c,*d)S_[a,b,c,d])‘ ‹ ((*c,*d)S_[c,d])‘
É
	(„%down%1%down%s_[a,b][c,d] p q
		= 	ABS_‘(x:S_[c,d]Ž Ày:S_[a,b]Ž
				let	t = p  y.a  y.b
				in	t.d  €  t.p
					€ (mk_S_[a,b,c,d]  y.a  y.b  x.c  x.d)  q))
æ

ê
	â„%down%1%down%s_bnameá		: (’ IDENT) ‹ (’ IDENT) ‹ string
	â„%down%1%down%s_btypeá		: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TYPE
	â„%down%1%down%s_btermá		: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
É
	ƒfid1,fid2:’ IDENT; itym1,itym2:IDENT œ TYPEŽ

	„%down%1%down%s_bname fid1 fid2
		= `„%down%1%down%s_`^(val_setIDENT fid1)^(val_setIDENT (fid2Äfid1))
€	„%down%1%down%s_btype 
		= „%down%s_btype
€	„%down%1%down%s_bterm itym1 itym2
		= mk_const („%down%1%down%s_bname (dom itym1) (dom itym2),
				„%down%1%down%s_btype itym1 itym2)
Ë

=SML
fun	â„%down%1%down%s_bnameá (fid1:string list) (fid2:string list) :string =
		"„%down%1%down%s_" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	â„%down%1%down%s_btypeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		„%down%s_btype itym1 itym2;
fun	â„%down%1%down%s_btermá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			„%down%1%down%s_bname (fst(split itym1)) (fst(split itym2)),
			„%down%1%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema universal quantification}

óHOL Constant
	âƒ%down%s_[a,b][c,d]á	:
		(*a ‹ *b ‹ (bool,bool)S_[d,p]) ‹ ((*a,*b,*c,*d)S_[a,b,c,d])‘ ‹ ((*c,*d)S_[c,d])‘
É
	(ƒ%down%s_[a,b][c,d] p q
		=	ABS_‘(x:S_[c,d]Ž ƒy:S_[a,b]Ž
				let	t = p  y.a  y.b
				in	t.d  €  t.p
					Š (mk_S_[a,b,c,d] y.a y.b x.c x.d)  q))
æ

ê
	âƒ%down%s_bnameá	: (’ IDENT) ‹ (’ IDENT) ‹ string
	âƒ%down%s_btypeá		: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TYPE
	âƒ%down%s_btermá	: (IDENT œ TYPE) ‹ (IDENT œ TYPE) ‹ TERM
É
	ƒfid1,fid2:’ IDENT; itym1,itym2:IDENT œ TYPEŽ

	ƒ%down%s_bname fid1 fid2
		= `ƒ%down%s_`^(val_setIDENT fid1)^(val_setIDENT (fid2Äfid1))
€	ƒ%down%s_btype itym1 itym2
		= list_mk_‹_type
			(¾ list_mk_‹_type (itymfunseq itym1, g1_bind_type),
				schema_type itym2 ¿,
			(schema_type (itym2Äitym1)))
€	ƒ%down%s_bterm itym1 itym2
		= mk_const (ƒ%down%s_bname (dom itym1) (dom itym2),
				ƒ%down%s_btype itym1 itym2)
Ë

=SML
fun	âƒ%down%s_bnameá (fid1:string list) (fid2:string list) :string =
		"ƒ%down%s_" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	âƒ%down%s_btypeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		„%down%s_btype itym1 itym2;
fun	âƒ%down%s_btermá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			ƒ%down%s_bname (fst(split itym1)) (fst(split itym2)),
			ƒ%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{existential quantification}

óHOL Constant
	â„_2á	:
		(*1 ‹ *2 ‹ (bool,bool,bool)S_[d,p,v]) ‹ bool
É
	(„_2 p
		=	„(x:*1)(y:*2)Ž let t = p x y in	t.d € t.p € t.v)
æ

ê
	â„_bnameá	: (’ IDENT) ‹ string
	â„_btypeá	: (IDENT œ TYPE) ‹ TYPE
	â„_btermá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	„_bname fid
		= `„_¾`^(number(length fid))^`¿`
€	„_btype itym
		= mk_funt
			(list_mk_‹_type (itymfunseq itym, g2_bind_type bool_type),
					bool_type)
€	„_bterm itym
		= mk_const („_bname (dom itym), „_btype itym)
Ë

=SML
fun	â„_bnameá (fid:string list) :string = 
		"„_¾" ^ (number(length fid)) ^ "¿";
fun	â„_btypeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g2_bind_type bool_type
			),
			bool_type
		);
fun	â„_btermá (itym:(string * TYPE) list) :TERM =
		mk_const („_bname (fst(split itym)), „_btype itym);
=TEX

\subsubsection{unique existential quantification}

óHOL Constant
	â„%down%1_2á	:
		(*1 ‹ *2 ‹ (bool,bool,bool)S_[d,p,v]) ‹ bool
É
	(„%down%1_2 p
		=	À(x:*1)(y:*2)Ž let t = p x y in	t.d € t.p € t.v)
æ

ê
	â„%down%1_bnameá	: (’ IDENT) ‹ string
	â„%down%1_btypeá	: (IDENT œ TYPE) ‹ TYPE
	â„%down%1_btermá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	„%down%1_bname fid
		= `„%down%1_¾`^(number(length fid))^`¿`
€	„%down%1_btype
		= „_btype
€	„%down%1_bterm itym
		= mk_const („%down%1_bname (dom itym), „%down%1_btype itym)
Ë

=SML
fun	â„%down%1_bnameá (fid:string list) :string = 
		"„%down%1_¾" ^ (number(length fid)) ^ "¿";
fun	â„%down%1_btypeá (itym:(string * TYPE) list) :TYPE =
		„_btype itym;
fun	â„%down%1_btermá (itym:(string * TYPE) list) :TERM =
		mk_const („%down%1_bname (fst(split itym)), „%down%1_btype itym);
=TEX

\subsubsection{universal quantification}

óHOL Constant
	âƒ_2á	:
		(*1 ‹ *2 ‹ (bool,bool,bool)S_[d,p,v]) ‹ bool
É
	(ƒ_2 p
		=	ƒ(x:*1)(y:*2)Ž let t = p x y in	t.d € t.p Š t.v)
æ

ê
	âƒ_bnameá	: (’ IDENT) ‹ string
	âƒ_btypeá	: (IDENT œ TYPE) ‹ TYPE
	âƒ_btermá	: (IDENT œ TYPE) ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPEŽ

	ƒ_bname fid
		= `ƒ_¾`^(number(length fid))^`¿`
€	ƒ_btype itym
		= mk_funt
			(list_mk_‹_type (itymfunseq itym, g2_bind_type bool_type),
					bool_type)
€	ƒ_bterm itym
		= mk_const (ƒ_bname (dom itym), ƒ_btype itym)
Ë

=SML
fun	âƒ_bnameá (fid:string list) :string = 
		"ƒ_¾" ^ (number(length fid)) ^ "¿";
fun	âƒ_btypeá (itym:(string * TYPE) list) :TYPE =
		„_btype itym;
fun	âƒ_btermá (itym:(string * TYPE) list) :TERM =
		mk_const (ƒ_bname (fst(split itym)), ƒ_btype itym);
=TEX

\subsubsection{set abstraction}

óHOL Constant
	âseta_2á	:
		(*1 ‹ *2 ‹ (bool,bool,*v)S_[d,p,v]) ‹ (*v)‘
É
	(seta_2 p
		=	ABS_‘(x:*vŽ „(y:*1) (z:*2)Ž
				let t = p y z in	t.d € t.p € (t.v = x))
æ

ê
	âseta_bnameá	: (’ IDENT) ‹ string
	âseta_btypeá	: (IDENT œ TYPE) ‹ TYPE ‹ TYPE
	âseta_btermá	: (IDENT œ TYPE) ‹ TYPE ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPE; ty:TYPEŽ

	seta_bname fid
		= `seta_¾`^(number(length fid))^`¿`
€	seta_btype itym ty
		= mk_funt
			(list_mk_‹_type (itymfunseq itym, g2_bind_type ty),
					mk_type (`‘`,¾ty¿))
€	seta_bterm itym ty
		= mk_const (seta_bname (dom itym), seta_btype itym ty)
Ë

=SML
fun	âseta_bnameá (fid:string list) :string = 
		"seta_¾" ^ (number(length fid)) ^ "¿";
fun	âseta_btypeá (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			mk_ctype ("‘",[ty])
		);
fun	âseta_btermá (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (seta_bname (fst(split itym)), seta_btype itym ty);
=TEX

\subsubsection{lambda abstraction}

óHOL Constant
	â_2á	:
		(*1 ‹ *2 ‹ (bool,bool,*dv,*cv)S_[d,p,t,v]) ‹ ((*dv,*cv)S_[1,2])‘
É
	(_2 p
		=	ABS_‘(x:(*dv,*cv)S_[1,2]Ž „(y:*1) (z:*2)Ž
				let	t = p y z
				in	t.d € t.p € (t.t = x.1 € t.v = x.2))
æ

ê
	â_bnameá	: (’ IDENT) ‹ string
	â_btypeá	: (IDENT œ TYPE) ‹ TYPE ‹ TYPE ‹ TYPE
	â_btermá	: (IDENT œ TYPE) ‹ TYPE ‹ TYPE ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPE; d_ty,c_ty:TYPEŽ

	_bname fid
		= `_¾`^(number(length fid))^`¿`
€	_btype itym d_ty c_ty
		= mk_funt
			(list_mk_‹_type (itymfunseq itym, g3_bind_type d_ty c_ty),
					mk_type(`‘`,¾mk_tuple_type ¾d_ty,c_ty¿¿))
€	_bterm itym d_ty c_ty
		= mk_const (_bname (dom itym), _btype itym d_ty c_ty)
Ë


=SML
fun	â_bnameá (fid:string list) :string = 
		"_¾" ^ (number(length fid)) ^ "¿";
fun	â_btypeá (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g3_bind_type t_ty v_ty
			),
			mk_ctype ("‘",[tuple_type [t_ty,v_ty]])
		);
fun	â_btermá (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TERM =
		mk_const (_bname (fst(split itym)), _btype itym t_ty v_ty);
=TEX
\subsubsection{definite description}

óHOL Constant
	â‡_2á		:
		(*1 ‹ *2 ‹ (bool,bool,*cv)S_[d,p,v]) ‹ *cv
É
	(‡_2 p
		=	‡(x:*cvŽ „(y:*1) (z:*2)Ž
				let	t = p y z
				in	t.d € t.p € (t.v = x)))
æ

Note that the above definition relies upon $‡$ being defined as definite description rather than choice in HOL.
 
ê
	â‡_bnameá	: (’ IDENT) ‹ string
	â‡_btypeá	: (IDENT œ TYPE) ‹ TYPE ‹ TYPE
	â‡_btermá	: (IDENT œ TYPE) ‹ TYPE ‹ TERM
É
	ƒfid:’ IDENT; itym:IDENT œ TYPE; ty:TYPEŽ

	‡_bname fid
		= `‡_¾`^(number(length fid))^`¿`
€	‡_btype itym ty
		= mk_funt
			(list_mk_‹_type (itymfunseq itym, g2_bind_type ty),
					ty)
€	‡_bterm itym ty
		= mk_const (‡_bname (dom itym), ‡_btype itym ty)
Ë

=SML
fun	â‡_bnameá (fid:string list) :string = 
		"‡_¾" ^ (number(length fid)) ^ "¿";
fun	â‡_btypeá (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			ty
		);
fun	â‡_btermá (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (‡_bname (fst(split itym)), ‡_btype itym ty);
=TEX

\subsection{Computing the Abstractions}

For each of the three groups of abstraction we define a function which constructs the abstraction to which the binding operator will be applied.
The process of abstraction over each of the names in the signature is common to these three functions and is defined first.

ë[A,B]
	âzipá		: (seq A) ‹ (A œ B) ‹ seq (A ‰ B)
É
	ƒseqa:seq A; a:A; m:A œ BŽ

	zip ¾¿ m			= ¾¿
€	zip seqaµ¾a¿ m	= (zip seqa m)µ¾(a, m a)¿
Ë

ê
	âschema_absá	: (IDENT œ TYPE) ‹ TERM ‹ TERM
É
	ƒitym:IDENT œ TYPE; ft:TERMŽ

	schema_abs itym ft
		= list_mk_fabs
				(zip ((idsetseq ¯ pack_IDENT)(dom itym)) stym,
				ft)

		where
		[stym:string œ TYPE | pack_IDENT ¯ stym = itym]
Ë

=SML
fun	âschema_absá (itym:(string * TYPE) list) (ft:TERM) :TERM =
	let	val sl = idsetseq(fst(split itym));
		val tyl = map (lassoc3 itym) sl;
	in
		list_mk_simple_ (map mk_var (combine sl tyl),ft)
	end;
=TEX
\subsubsection{forming the abstractions}

In the following sections the variable names are using in the following way:

\begin{description}
\item[ft1]
characteristic tuple
\item[ft2]
declaration
\item[ft3]
predicate
\item[ft4]
body
\item[ty1]
characteristic tuple type
\item[ty2]
body type
\item[itym]
type map assigning types to identifiers in signature
\end{description}

\subsubsection{group 1 abstractions}
ê
	âg1_absá	: (TERM ‰ TERM ‰ (IDENT œ TYPE)) ‹ TERM
É
	ƒft2,ft3:TERM; itym:IDENT œ TYPEŽ

	g1_abs (ft2,ft3,itym)	= schema_abs itym (list_mk_fcomb (g1_bind_cterm,¾ft2,ft3¿))
Ë

=SML
fun	âg1_absá (ft2:TERM,ft3:TERM,itym:(string * TYPE) list)	= 
		schema_abs itym (list_mk_app (g1_bind_cterm,[ft2,ft3]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g1_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX

\subsubsection{group 2 abstractions}
ê
	âg2_absá	: (TERM ‰ TERM ‰ TERM ‰ (IDENT œ TYPE)) ‹ TERM
É
	ƒft2, ft3, ft4:TERM; ty2:TYPE; itym:IDENT œ TYPEŽ

	g2_abs (ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_fcomb (g2_bind_cterm (type_of ft4), ¾ft2, ft3, ft4¿))
Ë

=SML
fun	âg2_absá (ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g2_bind_cterm (type_of ft4), [ft2, ft3, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g1_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\subsubsection{group 3 abstractions}
ê
	âg3_absá
	: (TERM ‰ TERM ‰ TERM ‰ TERM ‰ (IDENT œ TYPE)) ‹ TERM
É
	ƒft1, ft2, ft3, ft4:TERM; ty1, ty2:TYPE; itym:IDENT œ TYPEŽ

	g3_abs (ft1, ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_fcomb (g3_bind_cterm (type_of ft1) (type_of ft4), ¾ft2, ft3, ft1, ft4¿))
Ë

=SML
fun	âg3_absá (ft1:TERM,ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g3_bind_cterm (type_of ft1) (type_of ft4), [ft2, ft3, ft1, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g1_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\section{END OF SIGNATURE}
=SML
end (* end of structure icl'ZTypesAndTerms *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
