=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation of Support for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP048}  %% Mandatory field
\def\SCCSversion{1.11 %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{92/06/11 %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.10 (28 April 1992)]
Added functions which support sets of things of type $(string * TYPE)$.

\item [Issue 1.13 (15 June 1992)]
Added functions which support distinguishing names for Z global variables.

\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/IMP047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the detailed design may be found in \cite{DS/FMU/IED/DTD048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{STRUCTURE}
=SML
structure ÛZTypesAndTermsSupportÝ = struct
=TEX
\section{DERIVED HOL CONSTRUCTORS}
The functions defined here are an ad-hoc collection of constructors, destructors and discriminators which, at the time of writing, were not provided by the ICL HOL system.
If they are added in future, they will be removed from here.
=SML
fun	Ûlist_mk_­_typeÝ ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_­_type tyl ty;
=TEX

\section{SUPPORT FOR SETS}
The following functions provide set operations for the non-equality type
$string * TYPE$.
=SML
infix 3 mem';
fun ((s,t): string * TYPE) Ûmem'Ý (((s',t') :: xs)  : (string * TYPE) list) : bool = (
	((s = s') andalso (t =: t')) orelse ((s,t) mem' xs)
) | _ mem' [] = false;
=TEX
=SML
infix 4 drop';
fun ((x :: xs) : (string * TYPE) list) Ûdrop'Ý (cond : (string * TYPE)  -> bool) : (string * TYPE) list = (
	if cond x
	then xs drop' cond
	else x :: (xs drop' cond)
) | [] drop' _ = [];
=TEX
=SML
infix 4 grab';
fun (lst : (string * TYPE) list) Ûgrab'Ý (what : string * TYPE) = (
	if what mem' lst
	then lst
	else (what :: lst)
);
=TEX
=SML
infix 4 cup';
fun (list1 : (string * TYPE) list) Ûcup'Ý (list2 : (string * TYPE) list) : (string * TYPE) list = (
	fold (fn(x, xs) => xs grab' x) list1 list2
);
=TEX
$diff$ is the set difference operator for lists.
=SML
infix 4 diff';
fun (list1 : (string * TYPE) list) Ûdiff'Ý (list2 : (string * TYPE) list) : (string * TYPE) list = (
	list1 drop' (fn x => x mem' list2)
);
=TEX

\section{NAME FORMATION}
As discussed in \cite{DS/FMU/IED/DTD048}, the types $IDENT$, $WORD$ and $DECOR$ are simply implemented as $string$s, but
we will frequently need to manipulate them as if they were in the more strongly typed form.
The following functions therefore survive.
=SML
fun	Ûpack_IDENTÝ ((w,d) :string * string) :string = (w ^ d);
fun	Ûunpack_IDENTÝ (s :string) :string * string =
	let 	fun 	f _ [] = ([],[])
		|	f _ ("'"::t) = ([],("'"::(snd(f true t))))
		|	f _ ("?"::t) = ([],("?"::(snd(f true t))))
		|	f _ ("!"::t) = ([],("!"::(snd(f true t))))
		|	f false (h::t) = 
				let	val (a,b) = f false t
				in	((h::a),b)
				end
		|	f _ _ = fail "unpack_IDENT" 48001 [fn() => s]
	in
		(implode ** implode)(f false (explode s)) 
	end;
=TEX

=SML
fun	ÛidsetseqÝ (sl:string list) : string list = Sort.sort Sort.string_order sl;
fun	ÛflatpackÝ ([]:string list) : string 	= ""
|	flatpack (s::[])			= s
|	flatpack (s::ss) 			= s ^ "," ^ (flatpack ss);
=TEX


=SML
fun 	Ûval_setIDENTÝ (sl:string list) :string =
	"[" ^ flatpack(idsetseq sl) ^ "]";
fun	 ÛitymfunseqÝ (itym:(string * TYPE)list) :TYPE list =
	map (lassoc3 itym) (idsetseq(fst(split itym)));
val	Ûbool_typeÝ = BOOL;
=TEX


=SML
val	ÛnumberÝ :(int -> string) = string_of_int;
val	Ûval_numeralÝ :(string -> int) = nat_of_string;
=TEX


\section{BINDINGS AND TUPLES}

\subsection{binding types}


=SML
fun	Ûbind_tnameÝ (fid :string list) :string = "Z'S" ^ (val_setIDENT fid);
fun 	Ûbind_typeÝ (itym :(string * TYPE) list) :TYPE = 
		mk_ctype (bind_tname(fst(split itym)), itymfunseq itym);
=TEX

\subsection{tuple types}



=SML
fun	Ûtuple_tnameÝ (tyl: TYPE list) :string = "Z'T[" ^ number(length tyl) ^ "]";
fun	Ûtuple_typeÝ (tyl: TYPE list) :TYPE = mk_ctype(tuple_tname tyl,tyl);
=TEX

\subsection{binding constructors}


=SML
fun	Ûbind_cnameÝ (fid :string list) :string = "Z'S" ^ (val_setIDENT fid);
fun	Ûbind_ctypeÝ (itym :(string * TYPE) list) :TYPE =
		list_mk_­_type(itymfunseq itym, bind_type itym);
fun 	Ûbind_ctermÝ (itym :(string * TYPE) list) :TERM =
		mk_const (bind_cname (fst(split itym)), bind_ctype itym);
=TEX

\subsection{tuple constructors}


=SML
fun	Ûtuple_cnameÝ (sty:TYPE list) :string = "Z'T[" ^ (number(length sty)) ^ "]";
fun	Ûtuple_ctypeÝ (sty:TYPE list) :TYPE = list_mk_­_type (sty, tuple_type sty);
fun	Ûtuple_ctermÝ (sty:TYPE list) :TERM = mk_const(tuple_cname sty,tuple_ctype sty);
=TEX

\subsection{cartesian products}


=SML
fun	Ûprod_cnameÝ (sty: TYPE list) :string = "Z'¸[" ^ (number(length sty)) ^ "]";
fun	Ûprod_ctypeÝ (sty: TYPE list) :TYPE = 
	let	val spty = map (fn t => mk_ctype("SET",[t])) sty;
	in
		list_mk_­_type(spty,mk_ctype("SET",[tuple_type sty]))
	end;
fun	Ûprod_ctermÝ (sty: TYPE list) :TERM = mk_const(prod_cname sty, prod_ctype sty);
=TEX

\subsection{binding projections}


=SML
fun	Ûbind_pnameÝ (fid:string list) (i:string) :string =
		"Z'S" ^ (val_setIDENT fid) ^ (val_setIDENT[i]);
fun	Ûbind_ptypeÝ (itym:(string * TYPE) list) (i:string) :TYPE =
		mk_­_type(bind_type itym,lassoc3 itym i);
fun	Ûbind_ptermÝ (itym:(string * TYPE) list) (i:string) :TERM =
		mk_const (bind_pname (fst(split itym)) i, bind_ptype itym i);
=TEX

\subsection{tuple projections}
\section{SCHEMAS}


\subsection{schema types}


=SML
fun	Ûschema_typeÝ (itym:(string * TYPE) list) :TYPE =
		mk_ctype("SET",[bind_type itym]);
=TEX

\subsection{schema negation}


=SML
fun	Ûbind_³_typeÝ (itym:(string * TYPE) list) :TYPE =
		mk_­_type (schema_type itym, schema_type itym);
fun	Ûbind_³_termÝ (itym:(string * TYPE) list) :TERM = 
		mk_const ("Z'³%down%s", bind_³_type itym);
=TEX

\subsection{schema precondition}


=SML
fun	Ûbind_pre_nameÝ (fid:string list) :string = "Z'pre%down%s" ^ (val_setIDENT fid);
fun	Ûbind_pre_typeÝ (itym:(string * TYPE) list) :TYPE =
	let	fun	sch_res ((_,"'"),_) = true
		|	sch_res ((_,"!"),_) = true
		|	sch_res _ = false
	in
		mk_­_type(
			schema_type itym,
			schema_type(itym drop (sch_res o (unpack_IDENT ** Combinators.I)))
		)
	end;
fun	Ûbind_pre_termÝ (itym:(string * TYPE) list) :TERM =
		mk_const (bind_pre_name (fst(split itym)), bind_pre_type itym);
=TEX

\subsection{simple dyadic schema operations}


=SML
fun	Ûbind_dysc_nameÝ (n:string) (fid1:string list) (fid2:string list) :string = 
		n ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	Ûbind_dysc_typeÝ (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TYPE = 
		list_mk_­_type(
			[schema_type itym1,schema_type itym2],
			schema_type (itym1 cup' itym2)
		);
fun	Ûbind_dysc_termÝ (n:string) (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TERM = 
		mk_const (	bind_dysc_name n (fst(split itym1)) (fst(split itym2)),
				bind_dysc_type itym1 itym2);
val	Ûbind_±_termÝ :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'±%down%s";
val	Ûbind_²_termÝ :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'²%down%s";
val	Ûbind_´_termÝ :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'´%down%s";
val	Ûbind_¤_termÝ :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'¤%down%s";
=TEX
\subsection{schema projection}


=SML
fun	Ûbind_ù_nameÝ (fid1:string list) (fid2:string list) :string =
		"Z'ù%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	Ûbind_ù_typeÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_­_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym2
		);

fun	Ûbind_ù_termÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_ù_name (fst(split itym1)) (fst(split itym2)),
			bind_ù_type itym1 itym2);
=TEX

\subsection{schema hiding}


=SML
fun	Ûbind_hide_nameÝ (fid1:string list) (fid2:string list) :string =
		"Z'hide%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	Ûbind_hide_typeÝ (itym:(string * TYPE) list) (fid2:string list) :TYPE =
		mk_­_type(
			schema_type itym,
			schema_type(itym drop (fn(s,_)=> s mem fid2))
		);
fun	Ûbind_hide_termÝ (itym:(string * TYPE) list) (fid2:string list) :TERM =
		mk_const (
			bind_hide_name (fst(split itym)) fid2, 
			bind_hide_type itym fid2
		);
=TEX

\subsection{decoration}


=SML
fun	Ûbind_decor_nameÝ (fid:string list) (s:string) :string =
		"Z'dec%down%s" ^ (val_setIDENT fid) ^ "[" ^ s ^ "]";
fun	Ûbind_decor_typeÝ (itym:(string * TYPE) list) (s:string) :TYPE =
		mk_­_type(
			schema_type itym,
			schema_type(map(fn(id,ty)=>(id^s,ty))itym)
		);
fun	Ûbind_decor_termÝ (itym:(string * TYPE) list) (s:string) :TERM =
		mk_const (bind_decor_name (fst(split itym)) s, bind_decor_type itym s);
=TEX

\subsection{the delta operation}


=SML
fun	Ûbind_„_nameÝ (fid:string list) :string = "Z'„%down%s" ^ (val_setIDENT fid);
fun	Ûbind_„_typeÝ (itym:(string * TYPE) list) :TYPE =
		mk_­_type(
			schema_type itym,
			schema_type(itym @ (map (fn(id,ty)=>(id^"'",ty)) itym))
		);
fun	Ûbind_„_termÝ (itym:(string * TYPE) list) :TERM =
		mk_const (bind_„_name (fst(split itym)), bind_„_type itym);
=TEX

\subsection{the $\Xi$ operation}


=SML
fun	Ûbind_˜_nameÝ (fid:string list) :string = "Z'˜%down%s" ^ (val_setIDENT fid);
val	Ûbind_˜_typeÝ :(string * TYPE) list -> TYPE = bind_„_type;
fun	Ûbind_˜_termÝ (itym:(string * TYPE) list) :TERM =
		mk_const (bind_˜_name (fst(split itym)), bind_˜_type itym);
=TEX

\subsection{schema composition}


=SML
fun	Ûbind_»_nameÝ (fid1:string list) (fid2:string list) :string =
		"Z'»%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	Ûbind_»_typeÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
	let	val itym2' = map (fn(s,ty)=>(s^"'",ty)) itym2;
		val itym =	(itym1 drop (fn(s,_) => (s mem (fst(split itym2')))))
					@
				(itym2 drop (fn(s,_) => ((s^"'") mem (fst(split itym1)))));
	in
		list_mk_­_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym
		)
	end;
fun	Ûbind_»_termÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_»_name (fst(split itym1)) (fst(split itym2)),
			bind_»_type itym1 itym2
		);
=TEX

\section{GLOBAL VARIABLES}

=SML
fun	Ûbind_gvar_nameÝ (s : string) : string = "z'" ^ s;
fun	Ûbind_gvar_termÝ ((s,ty) : string * TYPE) : TERM =
		mk_const (bind_gvar_name s, ty);

fun	Ûunbind_gvar_nameÝ (s : string) : string =
 	case explode s of
	("z"::"'"::rest) => implode rest
	|_ => fail "unbind_gvar_name" 48999 [];

fun	Ûunbind_gvar_termÝ (term : TERM) : (string * TYPE) =
	let	val (s, ty) = dest_const term;
	in
		(unbind_gvar_name s, ty)
	end;
=TEX


\section{VARIABLE BINDING CONSTRUCTS}


\subsection{group 1 packs}


=SML
val	Ûg1_bind_sigÝ :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type)];
val	Ûg1_bind_ctermÝ	:TERM = bind_cterm g1_bind_sig;
val	Ûg1_bind_typeÝ :TYPE = bind_type g1_bind_sig;
=TEX
\subsection{group 2 packs}


=SML
fun	Ûg2_bind_sigÝ (ty:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("v",ty)];
fun	Ûg2_bind_ctermÝ (ty:TYPE) :TERM = bind_cterm (g2_bind_sig ty);
fun	Ûg2_bind_typeÝ (ty:TYPE) :TYPE = bind_type (g2_bind_sig ty);
=TEX
\subsection{group 3 packs}


=SML
fun	Ûg3_bind_sigÝ (ty1:TYPE) (ty2:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("t",ty1),
		("v",ty2)];
fun	Ûg3_bind_ctermÝ (ty1:TYPE) (ty2:TYPE) :TERM = bind_cterm (g3_bind_sig ty1 ty2);
fun	Ûg3_bind_typeÝ (ty1:TYPE) (ty2:TYPE) :TYPE = bind_type (g3_bind_sig ty1 ty2);
=TEX

\subsection{bindings yielding schema expressions}


\subsubsection{schemas}


=SML
fun	Ûschema_bnameÝ (fid:string list) :string =
		"Z'%down%s" ^ (val_setIDENT fid);
fun	Ûschema_btypeÝ (itym:(string * TYPE) list) :TYPE =
		mk_­_type(
			list_mk_­_type (itymfunseq itym, g1_bind_type),
			schema_type itym
		);
fun	Ûschema_btermÝ (itym:(string * TYPE) list) :TERM =
		mk_const (schema_bname (fst(split itym)), schema_btype itym);
=TEX

\subsubsection{schema existential quantification}


=SML
fun	Û¶%down%s_bnameÝ (fid1:string list) (fid2:string list) :string =
		"Z'¶%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	Û¶%down%s_btypeÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_­_type([
			list_mk_­_type (itymfunseq itym1, g1_bind_type),
			schema_type itym2
			],
			(schema_type (itym2 diff' itym1))
			);
fun	Û¶%down%s_btermÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			¶%down%s_bname (fst(split itym1)) (fst(split itym2)),
			¶%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema unique existential quantification}


=SML
fun	Û¶%down%1%down%s_bnameÝ (fid1:string list) (fid2:string list) :string =
		"Z'¶%down%1%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	Û¶%down%1%down%s_btypeÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		¶%down%s_btype itym1 itym2;
fun	Û¶%down%1%down%s_btermÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			¶%down%1%down%s_bname (fst(split itym1)) (fst(split itym2)),
			¶%down%1%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema universal quantification}


=SML
fun	Ûµ%down%s_bnameÝ (fid1:string list) (fid2:string list) :string =
		"Z'µ%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	Ûµ%down%s_btypeÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		¶%down%s_btype itym1 itym2;
fun	Ûµ%down%s_btermÝ (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			µ%down%s_bname (fst(split itym1)) (fst(split itym2)),
			µ%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{existential quantification}


=SML
fun	Û¶_bnameÝ (fid:string list) :string = 
		"Z'¶[" ^ (number(length fid)) ^ "]";
fun	Û¶_btypeÝ (itym:(string * TYPE) list) :TYPE =
		mk_­_type(
			list_mk_­_type(
				itymfunseq itym,
				g2_bind_type bool_type
			),
			bool_type
		);
fun	Û¶_btermÝ (itym:(string * TYPE) list) :TERM =
		mk_const (¶_bname (fst(split itym)), ¶_btype itym);
=TEX

\subsubsection{unique existential quantification}


=SML
fun	Û¶%down%1_bnameÝ (fid:string list) :string = 
		"Z'¶%down%1[" ^ (number(length fid)) ^ "]";
fun	Û¶%down%1_btypeÝ (itym:(string * TYPE) list) :TYPE =
		¶_btype itym;
fun	Û¶%down%1_btermÝ (itym:(string * TYPE) list) :TERM =
		mk_const (¶%down%1_bname (fst(split itym)), ¶%down%1_btype itym);
=TEX

\subsubsection{universal quantification}


=SML
fun	Ûµ_bnameÝ (fid:string list) :string = 
		"Z'µ[" ^ (number(length fid)) ^ "]";
fun	Ûµ_btypeÝ (itym:(string * TYPE) list) :TYPE =
		¶_btype itym;
fun	Ûµ_btermÝ (itym:(string * TYPE) list) :TERM =
		mk_const (µ_bname (fst(split itym)), µ_btype itym);
=TEX

\subsubsection{set abstraction}


=SML
fun	Ûseta_bnameÝ (fid:string list) :string = 
		"Z'seta[" ^ (number(length fid)) ^ "]";
fun	Ûseta_btypeÝ (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_­_type(
			list_mk_­_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			mk_ctype ("SET",[ty])
		);
fun	Ûseta_btermÝ (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (seta_bname (fst(split itym)), seta_btype itym ty);
=TEX

\subsubsection{lambda abstraction}



=SML
fun	ÛÌ_bnameÝ (fid:string list) :string = 
		"Z'Ì[" ^ (number(length fid)) ^ "]";
fun	ÛÌ_btypeÝ (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TYPE =
		mk_­_type(
			list_mk_­_type(
				itymfunseq itym,
				g3_bind_type t_ty v_ty
			),
			mk_ctype ("SET",[tuple_type [t_ty,v_ty]])
		);
fun	ÛÌ_btermÝ (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TERM =
		mk_const (Ì_bname (fst(split itym)), Ì_btype itym t_ty v_ty);
=TEX
\subsubsection{definite description}


=SML
fun	ÛÍ_bnameÝ (fid:string list) :string = 
		"Z'Í[" ^ (number(length fid)) ^ "]";
fun	ÛÍ_btypeÝ (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_­_type(
			list_mk_­_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			ty
		);
fun	ÛÍ_btermÝ (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (Í_bname (fst(split itym)), Í_btype itym ty);
=TEX

\subsection{Computing the Abstractions}


=SML
fun	Ûschema_absÝ (itym:(string * TYPE) list) (ft:TERM) :TERM =
	let	val sl = idsetseq(fst(split itym));
		val tyl = map (lassoc3 itym) sl;
	in
		list_mk_simple_Ì (map mk_var (combine sl tyl),ft)
	end;
=TEX


\subsubsection{group 1 abstractions}

=SML
fun	Ûg1_absÝ (ft2:TERM,ft3:TERM,itym:(string * TYPE) list)	= 
		schema_abs itym (list_mk_app (g1_bind_cterm,[ft2,ft3]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g1_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX

\subsubsection{group 2 abstractions}

=SML
fun	Ûg2_absÝ (ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g2_bind_cterm (type_of ft4), [ft2, ft3, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g2_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\subsubsection{group 3 abstractions}

=SML
fun	Ûg3_absÝ (ft1:TERM,ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g3_bind_cterm (type_of ft1) (type_of ft4), [ft2, ft3, ft1, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g3_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\section{END OF SIGNATURE}
=SML
end (* end of structure ZTypesAndTermsSupport *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


