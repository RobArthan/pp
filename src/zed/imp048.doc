=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation of Support for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP048}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/IMP047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the detailed design may be found in \cite{DS/FMU/IED/DTD048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{STRUCTURE}
=SML
structure âicl'ZTypesAndTermsá : icl'ZTypesAndTerms = struct
=TEX
\section{DERIVED HOL CONSTRUCTORS}
The functions defined here are an ad-hoc collection of constructors, destructors and discriminators which, at the time of writing, were not provided by the ICL HOL system.
If they are added in future, they will be removed from here.
=SML
fun	âlist_mk_‹_typeá ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_‹_type tyl ty;
=TEX

\section{NAME FORMATION}
As discussed in \cite{DS/FMU/IED/DTD048}, the types $IDENT$, $WORD$ and $DECOR$ are simply implemented as $string$s, but
we will frequently need to manipulate them as if they were in the more strongly typed form.
The following functions therefore survive.
=SML
fun	âpack_IDENTá ((w,d) :string * string) :string = (w ^ d);
fun	âunpack_IDENTá (s :string) :string * string =
	let 	fun 	f _ [] = ([],[])
		|	f _ ("'"::t) = ([],("'"::(snd(f true t))))
		|	f _ ("?"::t) = ([],("?"::(snd(f true t))))
		|	f _ ("!"::t) = ([],("!"::(snd(f true t))))
		|	f false (h::t) = 
				let	val (a,b) = f false t
				in	((h::a),b)
				end
		|	f _ _ = fail "unpack_IDENT" 48001 [fn() => s]
	in
		(implode ** implode)(f false (explode s)) 
	end;
=TEX

=SML
fun	âidsetseqá (sl:string list) : string list = Sort.sort Sort.stringorder sl;
fun	âflatpacká ([]:string list) : string 	= ""
|	flatpack (s::[])			= s
|	flatpack (s::ss) 			= s ^ "," ^ (flatpack ss);
=TEX


=SML
fun 	âval_setIDENTá (sl:string list) :string =
	"[" ^ flatpack(idsetseq sl) ^ "]";
fun	 âitymfunseqá (itym:(string * TYPE)list) :TYPE list =
	map (lassoc3 itym) (idsetseq(fst(split itym)));
val	âbool_typeá = BOOL;
=TEX


=SML
val	ânumberá :(int -> string) = string_of_int;
val	âval_numeralá :(string -> int) = nat_of_string;
=TEX


\section{BINDINGS AND TUPLES}

\subsection{binding types}


=SML
fun	âbind_tnameá (fid :string list) :string = "S_" ^ (val_setIDENT fid);
fun 	âbind_typeá (itym :(string * TYPE) list) :TYPE = 
		mk_ctype (bind_tname(fst(split itym)), itymfunseq itym);
=TEX

\subsection{tuple types}



=SML
fun	âtuple_tnameá (tyl: TYPE list) :string = "T_[" ^ number(length tyl) ^ "]";
fun	âtuple_typeá (tyl: TYPE list) :TYPE = mk_ctype(tuple_tname tyl,tyl);
=TEX

\subsection{binding constructors}


=SML
fun	âbind_cnameá (fid :string list) :string = "mk_" ^ (bind_tname fid);
fun	âbind_ctypeá (itym :(string * TYPE) list) :TYPE =
		list_mk_‹_type(itymfunseq itym, bind_type itym);
fun 	âbind_ctermá (itym :(string * TYPE) list) :TERM =
		mk_const (bind_cname (fst(split itym)), bind_ctype itym);
=TEX

\subsection{tuple constructors}


=SML
fun	âtuple_cnameá (sty:TYPE list) :string = "mk_" ^ (tuple_tname sty);
fun	âtuple_ctypeá (sty:TYPE list) :TYPE = list_mk_‹_type (sty, tuple_type sty);
fun	âtuple_ctermá (sty:TYPE list) :TERM = mk_const(tuple_cname sty,tuple_ctype sty);
=TEX

\subsection{cartesian products}


=SML
fun	âprod_cnameá (sty: TYPE list) :string = "mk_‰_[" ^ (number(length sty)) ^ "]";
fun	âprod_ctypeá (sty: TYPE list) :TYPE = 
	let	val spty = map (fn t => mk_ctype("‘",[t])) sty;
	in
		list_mk_‹_type(spty,mk_ctype("‘",[tuple_type sty]))
	end;
fun	âprod_ctermá (sty: TYPE list) :TERM = mk_const(prod_cname sty, prod_ctype sty);
=TEX

\subsection{binding projections}


=SML
fun	âbind_pnameá (fid:string list) (i:string) :string =
		(bind_tname fid) ^ (val_setIDENT[i]);
fun	âbind_ptypeá (itym:(string * TYPE) list) (i:string) :TYPE =
		mk_‹_type(bind_type itym,lassoc3 itym i);
fun	âbind_ptermá (itym:(string * TYPE) list) (i:string) :TERM =
		mk_const (bind_pname (fst(split itym)) i, bind_ptype itym i);
=TEX

\subsection{tuple projections}
\section{SCHEMAS}


\subsection{schema types}


=SML
fun	âschema_typeá (itym:(string * TYPE) list) :TYPE =
		mk_ctype("‘",[bind_type itym]);
=TEX

\subsection{schema negation}


=SML
fun	âbind_Œ_typeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type (schema_type itym, schema_type itym);
fun	âbind_Œ_termá (itym:(string * TYPE) list) :TERM = 
		mk_const ("ZŒ%down%s", bind_Œ_type itym);
=TEX

\subsection{schema precondition}


=SML
fun	âbind_pre_nameá (fid:string list) :string = "Zpre%down%s" ^ (bind_tname fid);
fun	âbind_pre_typeá (itym:(string * TYPE) list) :TYPE =
	let	fun	sch_res ((_,"'"),_) = true
		|	sch_res ((_,"!"),_) = true
		|	sch_res _ = false
	in
		mk_‹_type(
			schema_type itym,
			schema_type(itym drop (sch_res o (unpack_IDENT ** Combinators.I)))
		)
	end;
fun	âbind_pre_termá (itym:(string * TYPE) list) :TERM =
		mk_const (bind_pre_name (fst(split itym)), bind_pre_type itym);
=TEX

\subsection{simple dyadic schema operations}


=SML
fun	âbind_dysc_nameá (n:string) (fid1:string list) (fid2:string list) :string = 
		n ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_dysc_typeá (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TYPE = 
		list_mk_‹_type(
			[schema_type itym1,schema_type itym2],
			schema_type (itym1 cup itym2)
		);
fun	âbind_dysc_termá (n:string) (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TERM = 
		mk_const (	bind_dysc_name n (fst(split itym1)) (fst(split itym2)),
				bind_dysc_type itym1 itym2);
val	âbind_€_termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z€%down%s";
val	âbind__termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z%down%s";
val	âbind_Š_termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "ZŠ%down%s";
val	âbind_‚_termá :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z‚%down%s";
=TEX
\subsection{schema projection}


=SML
fun	âbind_Á_nameá (fid1:string list) (fid2:string list) :string =
		"ZÁ%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_Á_typeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_‹_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym2
		);

fun	âbind_Á_termá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_Á_name (fst(split itym1)) (fst(split itym2)),
			bind_Á_type itym1 itym2);
=TEX

\subsection{schema hiding}


=SML
fun	âbind_Ä_nameá (fid1:string list) (fid2:string list) :string =
		"ZÄ%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_Ä_typeá (itym:(string * TYPE) list) (fid2:string list) :TYPE =
		mk_‹_type(
			schema_type itym,
			schema_type(itym drop (fn(s,_)=> s mem fid2))
		);
fun	âbind_Ä_termá (itym:(string * TYPE) list) (fid2:string list) :TERM =
		mk_const (
			bind_Ä_name (fst(split itym)) fid2, 
			bind_Ä_type itym fid2
		);
=TEX

\subsection{decoration}


=SML
fun	âbind_decor_nameá (fid:string list) (s:string) :string =
		"Zdec%down%s" ^ (val_setIDENT fid) ^ "[" ^ s ^ "]";
fun	âbind_decor_typeá (itym:(string * TYPE) list) (s:string) :TYPE =
		mk_‹_type(
			schema_type itym,
			schema_type(map(fn(id,ty)=>(id^s,ty))itym)
		);
fun	âbind_decor_termá (itym:(string * TYPE) list) (s:string) :TERM =
		mk_const (bind_decor_name (fst(split itym)) s, bind_decor_type itym s);
=TEX

\subsection{the delta operation}


=SML
fun	âbind_ñ_nameá (fid:string list) :string = "Zñ%down%s" ^ (val_setIDENT fid);
fun	âbind_ñ_typeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type(
			schema_type itym,
			schema_type(itym @ (map (fn(id,ty)=>(id^"'",ty)) itym))
		);
fun	âbind_ñ_termá (itym:(string * TYPE) list) :TERM =
		mk_const (bind_ñ_name (fst(split itym)), bind_ñ_type itym);
=TEX

\subsection{the $\Xi$ operation}


=SML
fun	âbind_ò_nameá (fid:string list) :string = "Zò%down%s" ^ (val_setIDENT fid);
val	âbind_ò_typeá :(string * TYPE) list -> TYPE = bind_ñ_type;
fun	âbind_ò_termá (itym:(string * TYPE) list) :TERM =
		mk_const (bind_ò_name (fst(split itym)), bind_ò_type itym);
=TEX

\subsection{schema composition}


=SML
fun	âbind_¯_nameá (fid1:string list) (fid2:string list) :string =
		"Z¯%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	âbind_¯_typeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
	let	val itym2' = map (fn(s,ty)=>(s^"'",ty)) itym2;
		val itym =	(itym1 drop (fn(s,_) => (s mem (fst(split itym2')))))
					@
				(itym2 drop (fn(s,_) => ((s^"'") mem (fst(split itym1)))));
	in
		list_mk_‹_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym
		)
	end;
fun	âbind_¯_termá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_¯_name (fst(split itym1)) (fst(split itym2)),
			bind_¯_type itym1 itym2
		);
=TEX

\section{VARIABLE BINDING CONSTRUCTS}


\subsection{group 1 packs}


=SML
val	âg1_bind_sigá :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type)];
val	âg1_bind_ctermá	:TERM = bind_cterm g1_bind_sig;
val	âg1_bind_typeá :TYPE = bind_type g1_bind_sig;
=TEX
\subsection{group 2 packs}


=SML
fun	âg2_bind_sigá (ty:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("v",ty)];
fun	âg2_bind_ctermá (ty:TYPE) :TERM = bind_cterm (g2_bind_sig ty);
fun	âg2_bind_typeá (ty:TYPE) :TYPE = bind_type (g2_bind_sig ty);
=TEX
\subsection{group 3 packs}


=SML
fun	âg3_bind_sigá (ty1:TYPE) (ty2:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("t",ty1),
		("v",ty2)];
fun	âg3_bind_ctermá (ty1:TYPE) (ty2:TYPE) :TERM = bind_cterm (g3_bind_sig ty1 ty2);
fun	âg3_bind_typeá (ty1:TYPE) (ty2:TYPE) :TYPE = bind_type (g3_bind_sig ty1 ty2);
=TEX

\subsection{bindings yielding schema expressions}


\subsubsection{schemas}


=SML
fun	âschema_bnameá (fid:string list) :string =
		"Z%down%s" ^ (val_setIDENT fid);
fun	âschema_btypeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type(
			list_mk_‹_type (itymfunseq itym, g1_bind_type),
			schema_type itym
		);
fun	âschema_btermá (itym:(string * TYPE) list) :TERM =
		mk_const (schema_bname (fst(split itym)), schema_btype itym);
=TEX

\subsubsection{schema existential quantification}


=SML
fun	â„%down%s_bnameá (fid1:string list) (fid2:string list) :string =
		"Z„%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	â„%down%s_btypeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_‹_type([
			list_mk_‹_type (itymfunseq itym1, g1_bind_type),
			schema_type itym2
			],
			(schema_type (itym2 diff itym1))
			);
fun	â„%down%s_btermá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			„%down%s_bname (fst(split itym1)) (fst(split itym2)),
			„%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema unique existential quantification}


=SML
fun	â„%down%1%down%s_bnameá (fid1:string list) (fid2:string list) :string =
		"„%down%1%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	â„%down%1%down%s_btypeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		„%down%s_btype itym1 itym2;
fun	â„%down%1%down%s_btermá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			„%down%1%down%s_bname (fst(split itym1)) (fst(split itym2)),
			„%down%1%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema universal quantification}


=SML
fun	âƒ%down%s_bnameá (fid1:string list) (fid2:string list) :string =
		"ƒ%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	âƒ%down%s_btypeá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		„%down%s_btype itym1 itym2;
fun	âƒ%down%s_btermá (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			ƒ%down%s_bname (fst(split itym1)) (fst(split itym2)),
			ƒ%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{existential quantification}


=SML
fun	â„_bnameá (fid:string list) :string = 
		"„[" ^ (number(length fid)) ^ "]";
fun	â„_btypeá (itym:(string * TYPE) list) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g2_bind_type bool_type
			),
			bool_type
		);
fun	â„_btermá (itym:(string * TYPE) list) :TERM =
		mk_const („_bname (fst(split itym)), „_btype itym);
=TEX

\subsubsection{unique existential quantification}


=SML
fun	â„%down%1_bnameá (fid:string list) :string = 
		"„%down%1[" ^ (number(length fid)) ^ "]";
fun	â„%down%1_btypeá (itym:(string * TYPE) list) :TYPE =
		„_btype itym;
fun	â„%down%1_btermá (itym:(string * TYPE) list) :TERM =
		mk_const („%down%1_bname (fst(split itym)), „%down%1_btype itym);
=TEX

\subsubsection{universal quantification}


=SML
fun	âƒ_bnameá (fid:string list) :string = 
		"ƒ[" ^ (number(length fid)) ^ "]";
fun	âƒ_btypeá (itym:(string * TYPE) list) :TYPE =
		„_btype itym;
fun	âƒ_btermá (itym:(string * TYPE) list) :TERM =
		mk_const (ƒ_bname (fst(split itym)), ƒ_btype itym);
=TEX

\subsubsection{set abstraction}


=SML
fun	âseta_bnameá (fid:string list) :string = 
		"Zseta[" ^ (number(length fid)) ^ "]";
fun	âseta_btypeá (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			mk_ctype ("‘",[ty])
		);
fun	âseta_btermá (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (seta_bname (fst(split itym)), seta_btype itym ty);
=TEX

\subsubsection{lambda abstraction}



=SML
fun	â_bnameá (fid:string list) :string = 
		"Z[" ^ (number(length fid)) ^ "]";
fun	â_btypeá (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g3_bind_type t_ty v_ty
			),
			mk_ctype ("‘",[tuple_type [t_ty,v_ty]])
		);
fun	â_btermá (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TERM =
		mk_const (_bname (fst(split itym)), _btype itym t_ty v_ty);
=TEX
\subsubsection{definite description}


=SML
fun	â‡_bnameá (fid:string list) :string = 
		"Z‡[" ^ (number(length fid)) ^ "]";
fun	â‡_btypeá (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_‹_type(
			list_mk_‹_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			ty
		);
fun	â‡_btermá (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (‡_bname (fst(split itym)), ‡_btype itym ty);
=TEX

\subsection{Computing the Abstractions}


=SML
fun	âschema_absá (itym:(string * TYPE) list) (ft:TERM) :TERM =
	let	val sl = idsetseq(fst(split itym));
		val tyl = map (lassoc3 itym) sl;
	in
		list_mk_simple_ (map mk_var (combine sl tyl),ft)
	end;
=TEX


\subsubsection{group 1 abstractions}

=SML
fun	âg1_absá (ft2:TERM,ft3:TERM,itym:(string * TYPE) list)	= 
		schema_abs itym (list_mk_app (g1_bind_cterm,[ft2,ft3]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g1_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX

\subsubsection{group 2 abstractions}

=SML
fun	âg2_absá (ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g2_bind_cterm (type_of ft4), [ft2, ft3, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g2_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\subsubsection{group 3 abstractions}

=SML
fun	âg3_absá (ft1:TERM,ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g3_bind_cterm (type_of ft1) (type_of ft4), [ft2, ft3, ft1, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g3_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\section{END OF SIGNATURE}
=SML
end (* end of structure icl'ZTypesAndTerms *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
