=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation of Support for Z Types and Terms}
\TPPref{DS/FMU/IED/IMP048}  %% Mandatory field
\def\SCCSversion{1.11 %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{92/06/11 %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.10 (28 April 1992)]
Added functions which support sets of things of type $(string * TYPE)$.

\item [Issue 1.13 (15 June 1992)]
Added functions which support distinguishing names for Z global variables.

\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document provides the implementation of a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/IMP047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the detailed design may be found in \cite{DS/FMU/IED/DTD048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{STRUCTURE}
=SML
structure €ZTypesAndTermsSupport› = struct
=TEX
\section{DERIVED HOL CONSTRUCTORS}
The functions defined here are an ad-hoc collection of constructors, destructors and discriminators which, at the time of writing, were not provided by the ICL HOL system.
If they are added in future, they will be removed from here.
=SML
fun	€list_mk_≠_type› ((tyl,ty):TYPE list * TYPE) :TYPE = fold mk_≠_type tyl ty;
=TEX

\section{SUPPORT FOR SETS}
The following functions provide set operations for the non-equality type
$string * TYPE$.
=SML
infix 3 mem';
fun ((s,t): string * TYPE) €mem'› (((s',t') :: xs)  : (string * TYPE) list) : bool = (
	((s = s') andalso (t =: t')) orelse ((s,t) mem' xs)
) | _ mem' [] = false;
=TEX
=SML
infix 4 drop';
fun ((x :: xs) : (string * TYPE) list) €drop'› (cond : (string * TYPE)  -> bool) : (string * TYPE) list = (
	if cond x
	then xs drop' cond
	else x :: (xs drop' cond)
) | [] drop' _ = [];
=TEX
=SML
infix 4 grab';
fun (lst : (string * TYPE) list) €grab'› (what : string * TYPE) = (
	if what mem' lst
	then lst
	else (what :: lst)
);
=TEX
=SML
infix 4 cup';
fun (list1 : (string * TYPE) list) €cup'› (list2 : (string * TYPE) list) : (string * TYPE) list = (
	fold (fn(x, xs) => xs grab' x) list1 list2
);
=TEX
$diff$ is the set difference operator for lists.
=SML
infix 4 diff';
fun (list1 : (string * TYPE) list) €diff'› (list2 : (string * TYPE) list) : (string * TYPE) list = (
	list1 drop' (fn x => x mem' list2)
);
=TEX

\section{NAME FORMATION}
As discussed in \cite{DS/FMU/IED/DTD048}, the types $IDENT$, $WORD$ and $DECOR$ are simply implemented as $string$s, but
we will frequently need to manipulate them as if they were in the more strongly typed form.
The following functions therefore survive.
=SML
fun	€pack_IDENT› ((w,d) :string * string) :string = (w ^ d);
fun	€unpack_IDENT› (s :string) :string * string =
	let 	fun 	f _ [] = ([],[])
		|	f _ ("'"::t) = ([],("'"::(snd(f true t))))
		|	f _ ("?"::t) = ([],("?"::(snd(f true t))))
		|	f _ ("!"::t) = ([],("!"::(snd(f true t))))
		|	f false (h::t) = 
				let	val (a,b) = f false t
				in	((h::a),b)
				end
		|	f _ _ = fail "unpack_IDENT" 48001 [fn() => s]
	in
		(implode ** implode)(f false (explode s)) 
	end;
=TEX

=SML
fun	€idsetseq› (sl:string list) : string list = Sort.sort Sort.string_order sl;
fun	€flatpack› ([]:string list) : string 	= ""
|	flatpack (s::[])			= s
|	flatpack (s::ss) 			= s ^ "," ^ (flatpack ss);
=TEX


=SML
fun 	€val_setIDENT› (sl:string list) :string =
	"[" ^ flatpack(idsetseq sl) ^ "]";
fun	 €itymfunseq› (itym:(string * TYPE)list) :TYPE list =
	map (lassoc3 itym) (idsetseq(fst(split itym)));
val	€bool_type› = BOOL;
=TEX


=SML
val	€number› :(int -> string) = string_of_int;
val	€val_numeral› :(string -> int) = nat_of_string;
=TEX


\section{BINDINGS AND TUPLES}

\subsection{binding types}


=SML
fun	€bind_tname› (fid :string list) :string = "Z'S" ^ (val_setIDENT fid);
fun 	€bind_type› (itym :(string * TYPE) list) :TYPE = 
		mk_ctype (bind_tname(fst(split itym)), itymfunseq itym);
=TEX

\subsection{tuple types}



=SML
fun	€tuple_tname› (tyl: TYPE list) :string = "Z'T[" ^ number(length tyl) ^ "]";
fun	€tuple_type› (tyl: TYPE list) :TYPE = mk_ctype(tuple_tname tyl,tyl);
=TEX

\subsection{binding constructors}


=SML
fun	€bind_cname› (fid :string list) :string = "Z'S" ^ (val_setIDENT fid);
fun	€bind_ctype› (itym :(string * TYPE) list) :TYPE =
		list_mk_≠_type(itymfunseq itym, bind_type itym);
fun 	€bind_cterm› (itym :(string * TYPE) list) :TERM =
		mk_const (bind_cname (fst(split itym)), bind_ctype itym);
=TEX

\subsection{tuple constructors}


=SML
fun	€tuple_cname› (sty:TYPE list) :string = "Z'T[" ^ (number(length sty)) ^ "]";
fun	€tuple_ctype› (sty:TYPE list) :TYPE = list_mk_≠_type (sty, tuple_type sty);
fun	€tuple_cterm› (sty:TYPE list) :TERM = mk_const(tuple_cname sty,tuple_ctype sty);
=TEX

\subsection{cartesian products}


=SML
fun	€prod_cname› (sty: TYPE list) :string = "Z'∏[" ^ (number(length sty)) ^ "]";
fun	€prod_ctype› (sty: TYPE list) :TYPE = 
	let	val spty = map (fn t => mk_ctype("SET",[t])) sty;
	in
		list_mk_≠_type(spty,mk_ctype("SET",[tuple_type sty]))
	end;
fun	€prod_cterm› (sty: TYPE list) :TERM = mk_const(prod_cname sty, prod_ctype sty);
=TEX

\subsection{binding projections}


=SML
fun	€bind_pname› (fid:string list) (i:string) :string =
		"Z'S" ^ (val_setIDENT fid) ^ (val_setIDENT[i]);
fun	€bind_ptype› (itym:(string * TYPE) list) (i:string) :TYPE =
		mk_≠_type(bind_type itym,lassoc3 itym i);
fun	€bind_pterm› (itym:(string * TYPE) list) (i:string) :TERM =
		mk_const (bind_pname (fst(split itym)) i, bind_ptype itym i);
=TEX

\subsection{tuple projections}
\section{SCHEMAS}


\subsection{schema types}


=SML
fun	€schema_type› (itym:(string * TYPE) list) :TYPE =
		mk_ctype("SET",[bind_type itym]);
=TEX

\subsection{schema negation}


=SML
fun	€bind_≥_type› (itym:(string * TYPE) list) :TYPE =
		mk_≠_type (schema_type itym, schema_type itym);
fun	€bind_≥_term› (itym:(string * TYPE) list) :TERM = 
		mk_const ("Z'≥%down%s", bind_≥_type itym);
=TEX

\subsection{schema precondition}


=SML
fun	€bind_pre_name› (fid:string list) :string = "Z'pre%down%s" ^ (val_setIDENT fid);
fun	€bind_pre_type› (itym:(string * TYPE) list) :TYPE =
	let	fun	sch_res ((_,"'"),_) = true
		|	sch_res ((_,"!"),_) = true
		|	sch_res _ = false
	in
		mk_≠_type(
			schema_type itym,
			schema_type(itym drop (sch_res o (unpack_IDENT ** Combinators.I)))
		)
	end;
fun	€bind_pre_term› (itym:(string * TYPE) list) :TERM =
		mk_const (bind_pre_name (fst(split itym)), bind_pre_type itym);
=TEX

\subsection{simple dyadic schema operations}


=SML
fun	€bind_dysc_name› (n:string) (fid1:string list) (fid2:string list) :string = 
		n ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	€bind_dysc_type› (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TYPE = 
		list_mk_≠_type(
			[schema_type itym1,schema_type itym2],
			schema_type (itym1 cup' itym2)
		);
fun	€bind_dysc_term› (n:string) (itym1:(string * TYPE)list) (itym2:(string * TYPE)list) :TERM = 
		mk_const (	bind_dysc_name n (fst(split itym1)) (fst(split itym2)),
				bind_dysc_type itym1 itym2);
val	€bind_±_term› :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'±%down%s";
val	€bind_≤_term› :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'≤%down%s";
val	€bind_¥_term› :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'¥%down%s";
val	€bind_§_term› :(string * TYPE) list -> (string * TYPE) list -> TERM =
		bind_dysc_term "Z'§%down%s";
=TEX
\subsection{schema projection}


=SML
fun	€bind_˘_name› (fid1:string list) (fid2:string list) :string =
		"Z'˘%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	€bind_˘_type› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_≠_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym2
		);

fun	€bind_˘_term› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_˘_name (fst(split itym1)) (fst(split itym2)),
			bind_˘_type itym1 itym2);
=TEX

\subsection{schema hiding}


=SML
fun	€bind_hide_name› (fid1:string list) (fid2:string list) :string =
		"Z'hide%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	€bind_hide_type› (itym:(string * TYPE) list) (fid2:string list) :TYPE =
		mk_≠_type(
			schema_type itym,
			schema_type(itym drop (fn(s,_)=> s mem fid2))
		);
fun	€bind_hide_term› (itym:(string * TYPE) list) (fid2:string list) :TERM =
		mk_const (
			bind_hide_name (fst(split itym)) fid2, 
			bind_hide_type itym fid2
		);
=TEX

\subsection{decoration}


=SML
fun	€bind_decor_name› (fid:string list) (s:string) :string =
		"Z'dec%down%s" ^ (val_setIDENT fid) ^ "[" ^ s ^ "]";
fun	€bind_decor_type› (itym:(string * TYPE) list) (s:string) :TYPE =
		mk_≠_type(
			schema_type itym,
			schema_type(map(fn(id,ty)=>(id^s,ty))itym)
		);
fun	€bind_decor_term› (itym:(string * TYPE) list) (s:string) :TERM =
		mk_const (bind_decor_name (fst(split itym)) s, bind_decor_type itym s);
=TEX

\subsection{the delta operation}


=SML
fun	€bind_Ñ_name› (fid:string list) :string = "Z'Ñ%down%s" ^ (val_setIDENT fid);
fun	€bind_Ñ_type› (itym:(string * TYPE) list) :TYPE =
		mk_≠_type(
			schema_type itym,
			schema_type(itym @ (map (fn(id,ty)=>(id^"'",ty)) itym))
		);
fun	€bind_Ñ_term› (itym:(string * TYPE) list) :TERM =
		mk_const (bind_Ñ_name (fst(split itym)), bind_Ñ_type itym);
=TEX

\subsection{the $\Xi$ operation}


=SML
fun	€bind_ò_name› (fid:string list) :string = "Z'ò%down%s" ^ (val_setIDENT fid);
val	€bind_ò_type› :(string * TYPE) list -> TYPE = bind_Ñ_type;
fun	€bind_ò_term› (itym:(string * TYPE) list) :TERM =
		mk_const (bind_ò_name (fst(split itym)), bind_ò_type itym);
=TEX

\subsection{schema composition}


=SML
fun	€bind_ª_name› (fid1:string list) (fid2:string list) :string =
		"Z'ª%down%s" ^ (val_setIDENT fid1) ^ (val_setIDENT fid2);
fun	€bind_ª_type› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
	let	val itym2' = map (fn(s,ty)=>(s^"'",ty)) itym2;
		val itym =	(itym1 drop (fn(s,_) => (s mem (fst(split itym2')))))
					@
				(itym2 drop (fn(s,_) => ((s^"'") mem (fst(split itym1)))));
	in
		list_mk_≠_type(
			[schema_type itym1, schema_type itym2],
			schema_type itym
		)
	end;
fun	€bind_ª_term› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			bind_ª_name (fst(split itym1)) (fst(split itym2)),
			bind_ª_type itym1 itym2
		);
=TEX

\section{GLOBAL VARIABLES}

=SML
fun	€bind_gvar_name› (s : string) : string = "z'" ^ s;
fun	€bind_gvar_term› ((s,ty) : string * TYPE) : TERM =
		mk_const (bind_gvar_name s, ty);

fun	€unbind_gvar_name› (s : string) : string =
 	case explode s of
	("z"::"'"::rest) => implode rest
	|_ => fail "unbind_gvar_name" 48999 [];

fun	€unbind_gvar_term› (term : TERM) : (string * TYPE) =
	let	val (s, ty) = dest_const term;
	in
		(unbind_gvar_name s, ty)
	end;
=TEX


\section{VARIABLE BINDING CONSTRUCTS}


\subsection{group 1 packs}


=SML
val	€g1_bind_sig› :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type)];
val	€g1_bind_cterm›	:TERM = bind_cterm g1_bind_sig;
val	€g1_bind_type› :TYPE = bind_type g1_bind_sig;
=TEX
\subsection{group 2 packs}


=SML
fun	€g2_bind_sig› (ty:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("v",ty)];
fun	€g2_bind_cterm› (ty:TYPE) :TERM = bind_cterm (g2_bind_sig ty);
fun	€g2_bind_type› (ty:TYPE) :TYPE = bind_type (g2_bind_sig ty);
=TEX
\subsection{group 3 packs}


=SML
fun	€g3_bind_sig› (ty1:TYPE) (ty2:TYPE) :(string * TYPE) list = [
		("d",bool_type),
		("p",bool_type),
		("t",ty1),
		("v",ty2)];
fun	€g3_bind_cterm› (ty1:TYPE) (ty2:TYPE) :TERM = bind_cterm (g3_bind_sig ty1 ty2);
fun	€g3_bind_type› (ty1:TYPE) (ty2:TYPE) :TYPE = bind_type (g3_bind_sig ty1 ty2);
=TEX

\subsection{bindings yielding schema expressions}


\subsubsection{schemas}


=SML
fun	€schema_bname› (fid:string list) :string =
		"Z'%down%s" ^ (val_setIDENT fid);
fun	€schema_btype› (itym:(string * TYPE) list) :TYPE =
		mk_≠_type(
			list_mk_≠_type (itymfunseq itym, g1_bind_type),
			schema_type itym
		);
fun	€schema_bterm› (itym:(string * TYPE) list) :TERM =
		mk_const (schema_bname (fst(split itym)), schema_btype itym);
=TEX

\subsubsection{schema existential quantification}


=SML
fun	€∂%down%s_bname› (fid1:string list) (fid2:string list) :string =
		"Z'∂%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	€∂%down%s_btype› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		list_mk_≠_type([
			list_mk_≠_type (itymfunseq itym1, g1_bind_type),
			schema_type itym2
			],
			(schema_type (itym2 diff' itym1))
			);
fun	€∂%down%s_bterm› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			∂%down%s_bname (fst(split itym1)) (fst(split itym2)),
			∂%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema unique existential quantification}


=SML
fun	€∂%down%1%down%s_bname› (fid1:string list) (fid2:string list) :string =
		"Z'∂%down%1%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	€∂%down%1%down%s_btype› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		∂%down%s_btype itym1 itym2;
fun	€∂%down%1%down%s_bterm› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			∂%down%1%down%s_bname (fst(split itym1)) (fst(split itym2)),
			∂%down%1%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{schema universal quantification}


=SML
fun	€µ%down%s_bname› (fid1:string list) (fid2:string list) :string =
		"Z'µ%down%s" ^
		(val_setIDENT fid1) ^
		(val_setIDENT (fid2 diff fid1));
fun	€µ%down%s_btype› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TYPE =
		∂%down%s_btype itym1 itym2;
fun	€µ%down%s_bterm› (itym1:(string * TYPE) list) (itym2:(string * TYPE) list) :TERM =
		mk_const (
			µ%down%s_bname (fst(split itym1)) (fst(split itym2)),
			µ%down%s_btype itym1 itym2
		);
=TEX

\subsubsection{existential quantification}


=SML
fun	€∂_bname› (fid:string list) :string = 
		"Z'∂[" ^ (number(length fid)) ^ "]";
fun	€∂_btype› (itym:(string * TYPE) list) :TYPE =
		mk_≠_type(
			list_mk_≠_type(
				itymfunseq itym,
				g2_bind_type bool_type
			),
			bool_type
		);
fun	€∂_bterm› (itym:(string * TYPE) list) :TERM =
		mk_const (∂_bname (fst(split itym)), ∂_btype itym);
=TEX

\subsubsection{unique existential quantification}


=SML
fun	€∂%down%1_bname› (fid:string list) :string = 
		"Z'∂%down%1[" ^ (number(length fid)) ^ "]";
fun	€∂%down%1_btype› (itym:(string * TYPE) list) :TYPE =
		∂_btype itym;
fun	€∂%down%1_bterm› (itym:(string * TYPE) list) :TERM =
		mk_const (∂%down%1_bname (fst(split itym)), ∂%down%1_btype itym);
=TEX

\subsubsection{universal quantification}


=SML
fun	€µ_bname› (fid:string list) :string = 
		"Z'µ[" ^ (number(length fid)) ^ "]";
fun	€µ_btype› (itym:(string * TYPE) list) :TYPE =
		∂_btype itym;
fun	€µ_bterm› (itym:(string * TYPE) list) :TERM =
		mk_const (µ_bname (fst(split itym)), µ_btype itym);
=TEX

\subsubsection{set abstraction}


=SML
fun	€seta_bname› (fid:string list) :string = 
		"Z'seta[" ^ (number(length fid)) ^ "]";
fun	€seta_btype› (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_≠_type(
			list_mk_≠_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			mk_ctype ("SET",[ty])
		);
fun	€seta_bterm› (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (seta_bname (fst(split itym)), seta_btype itym ty);
=TEX

\subsubsection{lambda abstraction}



=SML
fun	€Ã_bname› (fid:string list) :string = 
		"Z'Ã[" ^ (number(length fid)) ^ "]";
fun	€Ã_btype› (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TYPE =
		mk_≠_type(
			list_mk_≠_type(
				itymfunseq itym,
				g3_bind_type t_ty v_ty
			),
			mk_ctype ("SET",[tuple_type [t_ty,v_ty]])
		);
fun	€Ã_bterm› (itym:(string * TYPE) list) (t_ty:TYPE) (v_ty:TYPE) :TERM =
		mk_const (Ã_bname (fst(split itym)), Ã_btype itym t_ty v_ty);
=TEX
\subsubsection{definite description}


=SML
fun	€Õ_bname› (fid:string list) :string = 
		"Z'Õ[" ^ (number(length fid)) ^ "]";
fun	€Õ_btype› (itym:(string * TYPE) list) (ty:TYPE) :TYPE =
		mk_≠_type(
			list_mk_≠_type(
				itymfunseq itym,
				g2_bind_type ty
			),
			ty
		);
fun	€Õ_bterm› (itym:(string * TYPE) list) (ty:TYPE) :TERM =
		mk_const (Õ_bname (fst(split itym)), Õ_btype itym ty);
=TEX

\subsection{Computing the Abstractions}


=SML
fun	€schema_abs› (itym:(string * TYPE) list) (ft:TERM) :TERM =
	let	val sl = idsetseq(fst(split itym));
		val tyl = map (lassoc3 itym) sl;
	in
		list_mk_simple_Ã (map mk_var (combine sl tyl),ft)
	end;
=TEX


\subsubsection{group 1 abstractions}

=SML
fun	€g1_abs› (ft2:TERM,ft3:TERM,itym:(string * TYPE) list)	= 
		schema_abs itym (list_mk_app (g1_bind_cterm,[ft2,ft3]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g1_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX

\subsubsection{group 2 abstractions}

=SML
fun	€g2_abs› (ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g2_bind_cterm (type_of ft4), [ft2, ft3, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g2_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\subsubsection{group 3 abstractions}

=SML
fun	€g3_abs› (ft1:TERM,ft2:TERM,ft3:TERM,ft4:TERM,itym:(string * TYPE) list) = 
		schema_abs 
			itym 
			(list_mk_app (g3_bind_cterm (type_of ft1) (type_of ft4), [ft2, ft3, ft1, ft4]))
	handle X => (
		divert 	X 
			"list_mk_app" 
			"g3_abs" 
			48002 
			[fn() => string_of_term ft2,fn() => string_of_term ft3]
	);
=TEX
\section{END OF SIGNATURE}
=SML
end (* end of structure ZTypesAndTermsSupport *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


