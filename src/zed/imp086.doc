% imp086.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Numbers and Finiteness}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP086}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
%\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\K.~Blackburn & WIN01\\R.D.~Arthan & WIN01}
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Numbers and Finiteness and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1] Initial Draft.
\item[Issue 1.2] Added theorems.
\item[Issue 1.3] Added conversions, proof contexts etc..
\item[Issue 1.4] Tidied up error handling etc..
\item[Issue 1.5 (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.6,1.7 (10th-11th February 1993)]
Rearranging proof contexts, etc.
\item[Issue 1.8 (22nd February 1993)]
Working in a =IGN section only.
\item[Issue 1.9 (11th August 1993)]
Addition of friendly induction theorem.
\item[Issue 1.10 (17th August 1993)]
Addition of course of values induction theorem and tactic.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library numbers and finiteness, meeting the detailed design
given in \cite{DS/FMU/IED/DTD086}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD086}.
\subsection{Dependencies}
The mathematical toolkit for Z Library numbers and finiteness is introduced within the structure
$ZNumbers$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD086}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZNumbers$
(see\cite{DS/FMU/IED/DTD086}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{PROLOGUE}
The structure is split into several pieces to make it small enough for
the Poly/ML compiler. The signature constraint is placed on the
final structure.
=SML
structure €ZNumbers› = struct
=TEX
=SML
	val dummy = open_theory "z_numbers";
=TEX
\section{ML BINDINGS}
=TEX
Get the definitions:
=SML
	val z_˙_def = get_spec Ò(˙)Æ;
	val z_Ó_def = get_spec Ò(Ó)Æ;
	val z_arith_def = get_spec Ò(_ + _)Æ;
	val z_inequality_def = get_spec Ò(_ < _)Æ;
	val z_Óâ1_def = get_spec Ò(Óâ1)Æ;
	val z_succ_def = get_spec Ò(succ)Æ;
	val z_iter_def = get_spec Ò(iter)Æ;
	val z_dots_def = get_spec Ò(_ .. _)Æ;
	val z_Ê_def = get_spec Ò(Ê _)Æ;
	val z_Êâ1_def = get_spec Ò(Êâ1 _)Æ;
	val z_hash_def = get_spec Ò(#)Æ;
	val z_ü_def = get_spec Ò(_ ü _)Æ;
	val z_û_def = get_spec Ò(_ û _)Æ;
	val z_min_def = get_spec Ò(min)Æ;
	val z_max_def = get_spec Ò(max)Æ;
	val z'int_def = get_axiom "-" "Z'Int";
=TEX
\section{SYNTAX FUNCTIONS}
=TEX
=SML
val €˙› = î˙Æ;
local
val €zintn› = (fst o dest_const o fst o dest_app) Ò42Æ;
val €zint› = ¨ëmk_const(zintn, îÓ ≠ ¨ËSML:Í mk_ctype("˙", [])ÆÆ)ÆÆ;
val €minus› = (fst o dest_z_app) Ò~42Æ;
val €minusn› = (fst o dest_const) minus;
val €zabs› = (fst o dest_z_app) Òabs 42Æ;
val €zabsn› = (fst o dest_const) zabs;
in
fun €dest_z_minus› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_z_app tm;
		val (s, _) = dest_const sgn;
	in	if s = minusn
		then a
		else term_fail "dest_z_minus" 86107 [tm]
	end	handle Fail _ => term_fail "dest_z_minus" 86107 [tm]
);
=TEX
=SML
fun €is_z_minus› (tm : TERM) : bool = (
	(dest_z_minus tm; true) handle Fail _ => false
);
=TEX
=SML
fun €mk_z_minus› (tm : TERM) : TERM = (
	if	type_of tm =: ˙
	then	mk_z_app (minus, tm)
	else	term_fail "mk_z_minus"  86201 [tm]
);
=TEX
=SML
fun €dest_z_abs› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_z_app tm;
		val (s, _) = dest_const sgn;
	in	if s = zabsn
		then a
		else term_fail "dest_z_abs" 86103 [tm]
	end	handle Fail _ => term_fail "dest_z_abs" 86103 [tm]
);
=TEX
=SML
fun €is_z_abs› (tm : TERM) : bool = (
	(dest_z_abs tm; true) handle Fail _ => false
);
=TEX
=SML
fun €mk_z_abs› (tm : TERM) : TERM = (
	if	type_of tm =: ˙
	then	mk_z_app (zabs, tm)
	else	term_fail "mk_z_abs"  86201 [tm]
);
=TEX
=SML
fun €dest_z_signed_int› (tm : TERM) : int = (
	let	val (f, a) = dest_app tm;
		val (n, _) = dest_const f;
	in	if n = zintn
		then dest_Ó a
		else	term_fail "dest_z_signed_int" 86110 [tm]
	end	handle Fail _ => (
	let	val (sgn, a) = dest_z_app tm;
		val (s, _) = dest_const sgn;
		val (g, b) = dest_app a;
		val (n, _) = dest_const g;
	in	if s = minusn andalso n = zintn
		then	~(dest_Ó b)
		else	term_fail "dest_z_signed_int" 86110 [tm]
	end
	)	handle Fail _ => (
		term_fail "dest_z_signed_int" 86110 [tm]
	)
);
=TEX
=SML
fun €is_z_signed_int› (tm : TERM) : bool = (
	(dest_z_signed_int tm; true) handle Fail _ => false
);
=TEX
=SML
fun €mk_z_signed_int› (i : int) : TERM = (
	(mk_app (zint, (mk_Ó i)))
	handle ex => mk_z_app(minus, mk_app (zint, (mk_Ó (~i))))
);
end;
=TEX
=SML
fun €dest_z_bin_op› (area : string) (msg : int)
	(n : string) : TERM -> TERM * TERM = (fn tm =>
	let	val (f, args) = (dest_z_app tm);
		val (cn, _) = dest_const f;
		val ops = dest_z_tuple args;
	in	if n = cn
		then (hd ops, hd(tl ops))
		else term_fail area msg [tm]
	end	handle Fail _ => term_fail area msg [tm]
);
=TEX
=SML
fun is_z_bin_op (n : string) : TERM -> bool = (
	let	val dest = dest_z_bin_op "is_z_bin_op" 0 n
	in	(fn tm =>
			(dest tm; true) handle Fail _ => false
		)
	end
);
=TEX
=SML
fun mk_z_simple_bin_op (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_z_app(tm, mk_z_tuple [a1, a2])
);
=TEX
=SML
fun €dest_z_bin_rel› (area : string) (msg : int)
	(n : string) : TERM -> TERM * TERM = (fn tm =>
	let	val (args, r) = (dest_z_ç tm);
		val (cn, _) = dest_const r;
		val ops = dest_z_tuple args;
	in	if n = cn
		then (hd ops, hd(tl ops))
		else term_fail area msg [tm]
	end	handle Fail _ => term_fail area msg [tm]
);
=TEX
=SML
fun is_z_bin_rel (n : string) : TERM -> bool = (
	let	val dest = dest_z_bin_rel "is_z_bin_rel" 0 n
	in	(fn tm =>
			(dest tm; true) handle Fail _ => false
		)
	end
);
=TEX
=SML
fun mk_z_simple_bin_rel (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_z_ç(mk_z_tuple [a1, a2], tm)
);
=TEX
=SML
val €dest_z_plus› = dest_z_bin_op "dest_plus" 86109 (fst(dest_constÒ(_+_)Æ));
val €dest_z_subtract› = dest_z_bin_op "dest_subtract" 86111 (fst(dest_constÒ(_-_)Æ));
val €dest_z_times› = dest_z_bin_op "dest_z_times" 86112 (fst(dest_constÒ(_*_)Æ));
val €dest_z_mod› = dest_z_bin_op "dest_z_mod" 86108 (fst(dest_constÒ(_mod_)Æ));
val €dest_z_div› = dest_z_bin_op "dest_z_div" 86104 (fst(dest_constÒ(_div_)Æ));

val €dest_z_less› = dest_z_bin_rel "dest_z_less" 86106 (fst(dest_constÒ(_<_)Æ));
val €dest_z_º› = dest_z_bin_rel "dest_z_º" 86101 (fst(dest_constÒ(_º_)Æ));
val €dest_z_greater› = dest_z_bin_rel "dest_z_greater" 86105 
	(fst(dest_constÒ(_>_)Æ));
val €dest_z_æ› = dest_z_bin_rel "dest_z_æ" 86102 (fst(dest_constÒ(_æ_)Æ));

val €is_z_plus› = is_z_bin_op (fst(dest_constÒ(_+_)Æ));
val €is_z_subtract› = is_z_bin_op (fst(dest_constÒ(_-_)Æ));
val €is_z_times› = is_z_bin_op (fst(dest_constÒ(_*_)Æ));
val €is_z_mod› = is_z_bin_op (fst(dest_constÒ(_mod_)Æ));
val €is_z_div› = is_z_bin_op (fst(dest_constÒ(_div_)Æ));

val €is_z_less› = is_z_bin_rel (fst(dest_constÒ(_<_)Æ));
val €is_z_º› = is_z_bin_rel (fst(dest_constÒ(_º_)Æ));
val €is_z_greater› = is_z_bin_rel (fst(dest_constÒ(_>_)Æ));
val €is_z_æ› = is_z_bin_rel (fst(dest_constÒ(_æ_)Æ));
=TEX
=SML
fun €mk_˙_bin_op› (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let	val f = mk_z_simple_bin_op tm;
	in	(fn tt as (t1, t2) => (
			if	type_of t1 =: ˙
			then	if	type_of t2 =: ˙
				then	f tt
				else	term_fail area 86201 [t2]
			else	term_fail area 86201 [t1]
		))
	end
);
=TEX
=SML
val €mk_z_plus› = mk_˙_bin_op "mk_z_plus" Ò(_+_)Æ;
val €mk_z_subtract› = mk_˙_bin_op "mk_z_subtract" Ò(_-_)Æ;
val €mk_z_times› = mk_˙_bin_op	"mk_z_times" Ò(_*_)Æ;
val €mk_z_mod› = mk_˙_bin_op "mk_z_mod" Ò(_mod_)Æ;
val €mk_z_div› = mk_˙_bin_op "mk_z_div" Ò(_div_)Æ;
=TEX
=SML
fun €mk_˙_bin_rel› (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let	val f = mk_z_simple_bin_rel tm;
	in	(fn tt as (t1, t2) => (
			if	type_of t1 =: ˙
			then	if	type_of t2 =: ˙
				then	f tt
				else	term_fail area 86201 [t2]
			else	term_fail area 86201 [t1]
		))
	end
);
=TEX
=SML
val €mk_z_less› = mk_˙_bin_rel "mk_z_less" Ò(_<_)Æ;
val €mk_z_º› = mk_˙_bin_rel "mk_z_º" Ò(_º_)Æ;
val €mk_z_greater› = mk_˙_bin_rel "mk_z_greater" Ò(_>_)Æ;
val €mk_z_æ› = mk_˙_bin_rel "mk_z_æ" Ò(_æ_)Æ;
=TEX
=SML
val €Z_FUN_RAND_C› = RAND_C;
val €Z_FUN_RATOR_C› = RATOR_C o RAND_C;

val €Z_REL_LEFT_C› = RATOR_C o RAND_C o RATOR_C o RAND_C;
val €Z_REL_RIGHT_C› = RATOR_C o RAND_C o RAND_C;
val €Z_REL_RANDS_C› = RATOR_C o RAND_C o RANDS_C;

val €Z_FUN_LEFT_C› = RAND_C o RATOR_C o RAND_C;
val €Z_FUN_RIGHT_C› = RAND_C o RAND_C;
val €Z_FUN_RANDS_C› = RAND_C o RANDS_C;

=TEX
=SML
fun €accept_conv› (thm : THM) : CONV = (fn tm => 
	if	(fst(dest_eq (concl thm)) =$ tm) handle Fail _ => false
	then	 thm
	else	fail_conv tm
); 
=TEX
\section{THEOREMS}
=SML
val _ = push_pc"z_predicates";
=TEX
=SML
val €z_more_pcs› = ["'z_tuples", "'z_ç_fun", "'z_ç_rel", "z_sets_ext"];
=TEX
Now we begin the proofs. First of all the following little lemma is required
in the absence of more powerful means for eliminating declarations
involving quantification over a given set. (Such a means now exists, but
time has not permitted exploiting it, yet).
=SML
val €˙_thm› = (
push_goal([], Ò˙ = UÆ);
a(rewrite_tac[get_specÒ˙Æ]);
pop_thm()
);
=TEX

=TEX
\subsection{The Additive Structure}
=SML
val €z_plus_def› = rewrite_rule[˙_thm, z_é_thm] (z_get_spec Ò(_+_)Æ);
=TEX
=SML
val €z_plus_comm_thm› = save_thm("z_plus_comm_thm", (
push_goal ([], Òµi, j : U∑ i + j = j + iÆ);
a(strip_asm_tac z_plus_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_plus_assoc_thm› = save_thm("z_plus_assoc_thm", (
push_goal ([], Òµi, j, k : U∑ (i + j) + k = i + (j + k)Æ);
a(strip_asm_tac z_plus_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_plus_assoc_thm1› = save_thm("z_plus_assoc_thm1", (
push_goal ([], Òµi, j, k : U∑ i + (j + k) = (i + j) + kÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv));
a(accept_tac z_plus_assoc_thm);
pop_thm()
));
=TEX
=SML
val €z_plus_order_thm› = save_thm("z_plus_order_thm", (
push_goal ([], Òµi : U∑ µ j, k : U∑
		j + i = i + j
	±	(i + j) + k = i + j + k
	±	j + i + k = i + j + kÆ);
a(strip_asm_tac z_plus_def);
a(asm_prove_tac[]);
a(rewrite_tac[z_plus_assoc_thm1, z_µ_elimÒ(i¶j, j¶i)Æz_plus_comm_thm]);
pop_thm()
));
=TEX
=SML
val €z_plus0_thm› = save_thm("z_plus0_thm", (
push_goal ([], Òµi : U∑
		i + 0 = i
	±	0 + i = iÆ);
a(strip_asm_tac z_plus_def);
a(rewrite_tac[z_µ_elimÒ(i¶0, j¶i∫˙)Æz_plus_comm_thm]);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_plus_minus_thm› = save_thm("z_plus_minus_thm", (
push_goal ([], Òµi : U∑
		i + ~i = 0
	±	~i + i = 0Æ);
a(strip_asm_tac z_plus_def);
a(rewrite_tac[z_µ_elimÒ(i¶ ~i, j¶i)Æz_plus_comm_thm]);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_Ó_thm› = save_thm("z_Ó_thm", (
push_goal ([], ÒÓ = • {s : U | 0 ç s ± {i : s ∑ i + 1} Ä s} ± ≥ ~1 ç ÓÆ);
a(REPEAT strip_tac THEN strip_asm_tac z_plus_def);
pop_thm()
));
=TEX
=SML
val €z_plus_cyclic_group_thm› = save_thm("z_plus_cyclic_group_thm", (
push_goal ([], Òµ h : U ∑ 1 ç h ± (µ i, j : h ∑ i + j ç h ± ~ i ç h) ¥ h = UÆ);
a(strip_asm_tac z_plus_def);
pop_thm()
));
=TEX
=SML
val  €z_int_homomorphism_thm› = save_thm("z_int_homomorphism_thm", (
push_goal([], ¨µi j∑ Z'Int (i + j) = Ò¨Z'Int iÆ + ¨Z'Int jÆÆÆ);
a(strip_tac);
a(induction_tac ¨iÆ);
(* *** Goal "1" *** *)
a(PC_T1"hol1"rewrite_tac[] THEN rewrite_tac[z_plus0_thm]);
(* *** Goal "2" *** *)
a(strip_tac THEN
	LEMMA_T ¨(i + 1) + j = (i + j) + 1Æ rewrite_thm_tac THEN1
	PC_T1"lin_arith" prove_tac[]);
a(asm_rewrite_tac[get_axiom"-""z'int_def"]);
a(rewrite_tac[z_plus_assoc_thm, z_µ_elimÒ1Æz_plus_order_thm]);
pop_thm()
));
=TEX
\subsection{Induction and Positive/Negative Case Analysis}
The results in the section need the more aggressive proof context.
=SML
val _ = push_merge_pcs z_more_pcs;
val  €z_˙_induction_thm› = save_thm("z_˙_induction_thm", (
push_goal([], ¨µp : ˙ ≠ BOOL∑
		p Ò1Æ
	±	(µi∑ p i ¥ p Ò~iÆ)
	±	(µi j∑ p i ± p j ¥ p Òi + jÆ)
	¥	(µm : ˙∑ p m)
Æ);
a(REPEAT strip_tac);
a(lemma_tacÒ{x : U | ¨p xÆ} = UÆ);
(* *** Goal "1" *** *)
a(bc_tac[conv_rule z_µ_elim_conv1 z_plus_cyclic_group_thm] THEN asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_˙_induction_tac› = gen_induction_tac z_˙_induction_thm;
=TEX
=SML
val  €z_Ó_induction_lemma› = (
push_goal([], ¨µp : ˙ ≠ BOOL∑
		p Ò0Æ
	±	(µi∑ p i ¥ p Òi + 1Æ)
	¥	µm∑ Òm ç ÓÆ ¥ p m
Æ);
a(rewrite_tac[z_Ó_thm] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o  z_µ_elimÒ{m:U|¨p mÆ}Æ));
a(all_asm_fc_tac[]);
a(PC_T1"prop_eq" asm_prove_tac[]);
pop_thm()
);
=TEX
=SML
val  €z_Ó_plus1_thm› = save_thm("z_Ó_plus1_thm", (
push_goal([], Òµi:Ó∑i + 1 ç ÓÆ);
a(rewrite_tac[z_Ó_thm, ˙_thm]);
a(REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o z_µ_elim Òi+1Æ));
a(POP_ASM_T (strip_asm_tac o z_µ_elim ÒiÆ));
pop_thm()
));
=TEX
=SML
val  €z_0_Ó_thm› = save_thm("z_0_Ó_thm", (
push_goal([], Ò0 ç ÓÆ);
a(asm_prove_tac[z_Ó_thm, ˙_thm]);
pop_thm()
));
=TEX
=SML
val  €z_Ó_induction_thm› = save_thm("z_Ó_induction_thm", (
push_goal([], ¨µp : ˙ ≠ BOOL∑
		p Ò0Æ
	±	(µi∑ Òi ç ÓÆ ± p i ¥ p Òi + 1Æ)
	¥	µm∑ Òm ç ÓÆ ¥ p m
Æ);
a(REPEAT strip_tac);
a(PC_T1 "hol1" strip_asm_tac
	(pc_rule1"hol"rewrite_rule[]
		(µ_elim¨Ãj∑j ç ÒÓÆ ± p jÆ z_Ó_induction_lemma))
	THEN (SOLVED_T (asm_prove_tac[z_0_Ó_thm]) ORELSE 
		all_fc_tac[z_Ó_plus1_thm]));
pop_thm()
));
=TEX
=SML
val €z_Ó_induction_tac› = gen_induction_tac1 z_Ó_induction_thm;
=TEX
=SML
val  €z_Ó_plus_thm› = save_thm("z_Ó_plus_thm", (
push_goal([], Òµi, j:Ó∑i + j ç ÓÆ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN z_Ó_induction_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_plus0_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_plus_assoc_thm1]);
a(all_fc_tac[z_Ó_plus1_thm]);
pop_thm()
));
=TEX
=SML
val €z_˙_eq_thm› = save_thm("z_˙_eq_thm", (
push_goal([], Òµi, j:U∑i = j § i + ~j = 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T Ò(i + ~j) + j = jÆ ante_tac THEN1 asm_rewrite_tac[z_plus0_thm]);
a(rewrite_tac[z_plus_assoc_thm, z_plus_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val €z_minus_thm› = save_thm("z_minus_thm", (
push_goal([], Òµi, j:U∑~ ~i = i ± i + ~i = 0 ± ~i + i = 0 ± ~(i + j) = 
		~i + ~j ± ~0 = 0Æ);
a(rewrite_tac[z_plus_minus_thm]);
a(LEMMA_TÒµi, j:U∑~ ~i = iÆ (fn th => rewrite_tac[th] THEN asm_tac th)
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(once_rewrite_tac[z_˙_eq_thm] THEN rewrite_tac[z_plus_minus_thm]);
(* *** Goal "2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[z_˙_eq_thm]);
a(asm_rewrite_tac[]);
a(rewrite_tac[z_µ_elimÒ~iÆz_plus_order_thm] THEN rewrite_tac[z_µ_elimÒiÆz_plus_order_thm]);
a(rewrite_tac[z_plus_minus_thm, z_plus0_thm]);
(* *** Goal "3" *** *)
a(LEMMA_TÒ0 + ~0 = 0Æ (accept_tac o rewrite_rule[z_plus0_thm]));
a(rewrite_tac[z_plus_minus_thm]);
pop_thm()
));
=TEX
=SML
val €z_minus_clauses› = save_thm("z_minus_clauses",(
push_goal([], Òµi : U∑ ~ ~ i = i ± ~0 = 0 ± (i + ~i = 0) ± (~i + i = 0)Æ);
a(rewrite_tac[z_minus_thm]);
pop_thm()
));
=TEX
=SML
val €z_Ó_cases_thm› = save_thm("z_Ó_cases_thm", (
push_goal([], Òµi:Ó∑i = 0 ≤ (∂j:Ó∑i = j + 1)Æ);
a(REPEAT strip_tac THEN all_asm_ante_tac);
a(z_Ó_induction_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_∂_tacÒ0Æ THEN asm_rewrite_tac[]);
a(accept_tac z_0_Ó_thm);
(* *** Goal "2" *** *)
a(z_∂_tacÒiÆ THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €z_˙_cases_lemma› = (
push_goal([], Òµi, j: U| i ç Ó ± ~j ç Ó ± ≥i + j ç Ó ∑ ~(i + j) ç ÓÆ);
a(REPEAT strip_tac);
a(all_asm_ante_tac);
a(z_Ó_induction_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_plus0_thm] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(strip_tac);
(* *** Goal "3" *** *)
a(rewrite_tac[z_µ_elim ÒjÆ z_plus_order_thm]);
a(rewrite_tac[z_µ_elim ÒiÆ z_plus_order_thm] THEN rewrite_tac[z_plus_assoc_thm1]);
a(REPEAT strip_tac THEN all_asm_fc_tac[z_Ó_plus1_thm]);
(* *** Goal "4" *** *)
a(all_asm_ante_tac THEN rewrite_tac[z_minus_thm] THEN REPEAT strip_tac);
a(lemma_tacÒ≥ ~i + ~j = 0Æ);
(* *** Goal "4.1" *** *)
a(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_plus0_thm, z_minus_thm]);
a(swap_nth_asm_concl_tac 1 THEN rewrite_tac[z_µ_elimÒjÆz_plus_order_thm]);
a(rewrite_tac[z_µ_elimÒiÆz_plus_order_thm]);
a(asm_rewrite_tac[z_plus_assoc_thm1]);
a(strip_asm_tac z_0_Ó_thm THEN all_fc_tac[z_Ó_plus1_thm]);
(* *** Goal "4.2" *** *)
a(all_fc_tac[z_Ó_cases_thm]);
a(rewrite_tac[z_µ_elimÒ~jÆz_plus_order_thm]);
a(rewrite_tac[z_µ_elimÒ~iÆz_plus_order_thm]);
a(asm_rewrite_tac[z_plus_assoc_thm1]);
a(asm_rewrite_tac[z_plus_assoc_thm, z_plus_minus_thm, z_plus0_thm]);
pop_thm()
);
=TEX
=SML
val €z_≥_Ó_thm› = save_thm("z_≥_Ó_thm", (
push_goal([], Òµi:U∑≥i ç Ó ¥ ~i ç ÓÆ);
a(strip_tac THEN strip_tac);
a(z_˙_induction_tac ÒiÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_TÒ0 + 1 ç Ó Æ (strip_asm_tac o rewrite_rule[z_plus0_thm]));
a(strip_asm_tac z_0_Ó_thm THEN asm_fc_tac [z_Ó_plus1_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_minus_thm]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[z_Ó_plus_thm]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[z_˙_cases_lemma]);
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac THEN once_rewrite_tac[z_plus_comm_thm] THEN strip_tac);
a(strip_asm_tac(z_µ_elimÒ(i¶j, j¶i)Æz_˙_cases_lemma));
(* *** Goal "6" *** *)
a(rewrite_tac[z_minus_thm]);
a(all_asm_fc_tac[z_Ó_plus_thm]);
pop_thm()
));
=TEX
=SML
val €z_˙_cases_lemma› = (
push_goal([], Ò˙ = Ó ¿ {s:Ó∑~s}Æ);
a(asm_tac z_≥_Ó_thm);
a(rewrite_tac[˙_thm] THEN REPEAT strip_tac);
a(z_∂_tacÒ~ x1Æ);
a(all_asm_fc_tac[]);
a(REPEAT strip_tac);
a(rewrite_tac[z_minus_thm]);
pop_thm()
);
=TEX
=SML
val €z_˙_cases_lemma1› = (
push_goal([], Ò˙ = Ó ¿ {s:Ó \ {0}∑~s}Æ);
a(rewrite_tac[z_˙_cases_lemma] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_∂_tacÒsÆ THEN REPEAT strip_tac);
a(CONTR_T (fn th => all_asm_ante_tac THEN rewrite_thm_tac th));
a(rewrite_tac[z_0_Ó_thm, z_minus_thm]);
a(STRIP_CONCL_T (asm_tac o eq_sym_rule));
a(asm_rewrite_tac[z_0_Ó_thm]);
(* *** Goal "2" *** *)
a(z_∂_tacÒsÆ THEN REPEAT strip_tac);
pop_thm()
);
=TEX
=SML
val €z_˙_cases_thm› = save_thm("z_˙_cases_thm", (
push_goal([], Òµi : U∑∂j:Ó∑i = j ≤ i = ~jÆ);
a(once_rewrite_tac [eq_sym_rule ˙_thm]);
a(rewrite_tac[z_˙_cases_lemma] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒsÆ THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €z_Ó_≥_plus1_thm› = save_thm("z_Ó_≥_plus1_thm", (
push_goal([], Òµi:Ó ∑ ≥i + 1 = 0Æ);
a(REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1);
a(lemma_tac Òi = ~1Æ);
(* *** Goal "1" *** *)
a(once_rewrite_tac[z_˙_eq_thm]);
a(asm_rewrite_tac[z_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[±_right_elim z_Ó_thm]);
pop_thm()
));
=TEX
=SML
val €z_˙_cases_thm1› = save_thm("z_˙_cases_thm1", (
push_goal([], Òµi:U∑i ç Ó ≤ (∂j:Ó∑ i = ~(j+1))Æ);
a(strip_tac THEN strip_tac);
a(conv_tac (LEFT_C(LEFT_C(pure_once_rewrite_conv
	[pure_once_rewrite_rule[˙_thm]z_˙_cases_lemma1]))));
a(REPEAT strip_tac);
a(all_fc_tac[z_Ó_cases_thm]);
a(z_∂_tacÒjÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (asm_rewrite_thm_tac o eq_sym_rule));
pop_thm()
));
=TEX
=SML
val €z_Ó_≥_minus_thm› = save_thm("z_Ó_≥_minus_thm", (
push_goal([], Òµi:Ó ∑ i = 0 ≤ ≥ ~i ç ÓÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(z_µ_elimÒiÆz_Ó_cases_thm));
a(LIST_DROP_NTH_ASM_T [3,4] (MAP_EVERY ante_tac));
a(POP_ASM_T rewrite_thm_tac);
a(REPEAT strip_tac);
a(lemma_tacÒ(j + ~(j + 1)) + 1 = 0Æ);
a(rewrite_tac[z_µ_elimÒ1Æz_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm]);
a(strip_asm_tac(z_µ_elimÒ(i¶j, j¶ ~(j+1))Æz_Ó_plus_thm));
a(strip_asm_tac(z_µ_elimÒj + ~ (j + 1)Æz_Ó_plus1_thm));
a(all_fc_tac[z_Ó_≥_plus1_thm]);
pop_thm()
));
val _ = pop_pc();
=TEX
=SML
val €z_plus_clauses› = save_thm("z_plus_clauses", (
push_goal([], Òµi, j, k : U∑
	(i + k = j + k § i = j)
±	(k + i = j + k § i = j)
±	(i + k = k + j § i = j)
±	(k + i = k + j § i = j)
±	(i + k = k § i = 0)
±	(k + i = k § i = 0)
±	(k = k + j § j = 0)
±	(k = j + k § j = 0)
±	(i + 0 = i)
±	(0 + i = i)
±	≥1 = 0
±	≥0 = 1
Æ);
a(z_µ_tac);
let val th = rewrite_rule[z_0_Ó_thm, z_plus0_thm](z_µ_elimÒ0Æz_Ó_≥_plus1_thm);
in
	a(rewrite_tac [th, conv_rule (RAND_C eq_sym_conv) th,
			z_plus0_thm, z_minus_thm])
end;
a(once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_minus_thm, z_plus_assoc_thm, z_plus0_thm]);
a(rewrite_tac [z_µ_elimÒiÆz_plus_order_thm]);
a(rewrite_tac [z_µ_elimÒ~jÆz_plus_order_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm]);
a(conv_tac(LEFT_C (ONCE_MAP_C eq_sym_conv)));
a(conv_tac(LEFT_C (once_rewrite_conv[z_˙_eq_thm])));
a(rewrite_tac[z_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
\subsection{Multiplicative Structure}
=SML
val €z_times_def› = rewrite_rule[˙_thm] (z_get_spec Ò(_*_)Æ);
=TEX
=SML
val €z_times_comm_thm› = save_thm("z_times_comm_thm", (
push_goal ([], Òµi, j : U∑ i * j = j * iÆ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times_assoc_thm› = save_thm("z_times_assoc_thm", (
push_goal ([], Òµi, j, k : U∑ (i * j) * k = i * (j * k)Æ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times_assoc_thm1› = save_thm("z_times_assoc_thm1", (
push_goal ([], Òµi, j, k : U∑ i * (j * k) = (i * j) * kÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv));
a(accept_tac z_times_assoc_thm);
pop_thm()
));
=TEX
=SML
val €z_times_order_thm› = save_thm("z_times_order_thm", (
push_goal ([], Òµi : U∑ µ j, k : U∑
		j * i = i * j
	±	(i * j) * k = i * j * k
	±	j * i * k = i * j * kÆ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
a(rewrite_tac[z_times_assoc_thm1, z_µ_elimÒ(i¶j, j¶i)Æz_times_comm_thm]);
pop_thm()
));
=TEX
=SML
val €z_times1_thm› = save_thm("z_times1_thm", (
push_goal ([], Òµi : U∑
		i * 1 = i
	±	1 * i = iÆ);
a(strip_asm_tac z_times_def);
a(rewrite_tac[z_µ_elimÒ(i¶i∫˙, j¶1)Æz_times_comm_thm]);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times_plus_distrib_thm› = save_thm("z_times_plus_distrib_thm", (
push_goal ([], Òµi, j, k : U∑
		i*(j + k) = i*j + i*k
	±	(i + j)*k = i*k + j*kÆ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
a(once_rewrite_tac[z_times_comm_thm] THEN asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times0_thm› = save_thm("z_times0_thm", (
push_goal([], Òµi:U∑0*i = 0 ± i*0 = 0Æ);
a(rewrite_tac[z_µ_elimÒi∫˙Æz_times_order_thm]);
a(REPEAT strip_tac);
a(LEMMA_T Òi*(0 + 1) = iÆ (strip_asm_tac o
	rewrite_rule[z_times1_thm, z_plus_assoc_thm, z_plus_minus_thm, z_plus0_thm] o
	once_rewrite_rule[z_˙_eq_thm] o
	rewrite_rule[z_times_plus_distrib_thm]));
a(rewrite_tac[z_plus0_thm, z_times1_thm]);
pop_thm()
));
=TEX
=SML
val €z_minus_times_thm› = save_thm("z_minus_times_thm", (
push_goal([], Òµi, j:U∑(~i)*j = ~(i*j) ± i*(~j) = ~(i*j) ± (~i)*(~j) = i*jÆ);
a(lemma_tacÒµi, j:U∑(~i)*j = ~(i*j)Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(once_rewrite_tac[z_˙_eq_thm] THEN rewrite_tac[z_minus_thm]);
a(LEMMA_TÒ~ i * j + i * j = (~i + i) * jÆ rewrite_thm_tac
	THEN1 rewrite_tac[z_times_plus_distrib_thm]);
a(rewrite_tac[z_plus_minus_thm, z_times0_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(lemma_tacÒµi, j:U∑i*(~j) = ~(i*j)Æ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(rewrite_tac[z_µ_elimÒjÆz_times_order_thm]);
a(asm_rewrite_tac[z_µ_elimÒ~jÆz_times_order_thm]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[z_minus_thm]);
pop_thm()
));
=TEX
=SML
val €z_Ó_times_thm› = save_thm("z_Ó_times_thm", (
push_goal([], Òµi, j:Ó∑i*j ç ÓÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(z_Ó_induction_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_times0_thm, z_0_Ó_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_times_plus_distrib_thm, z_times1_thm]);
a(all_asm_fc_tac[z_Ó_plus_thm]);
pop_thm()
));
=TEX
=SML
val €z_times_eq_0_thm› = save_thm("z_times_eq_0_thm", (
push_goal([], Òµi, j:U∑i*j = 0 § i = 0 ≤ j = 0Æ);
a(lemma_tacÒµa, b:Ó ∑ a*b = 0 ¥ a = 0 ≤ b = 0Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒaÆz_Ó_cases_thm));
a(strip_asm_tac (z_µ_elimÒbÆz_Ó_cases_thm));
a(asm_ante_tac Òa * b = 0Æ THEN
	asm_rewrite_tac[z_times_plus_distrib_thm, z_times1_thm, z_plus_assoc_thm1]);
a(LIST_DROP_NTH_ASM_T [7,6,5,3,1] (fn _ => id_tac));
a(rename_tac[(ÒjÆ, "m"), (¨j'Æ, "n")] THEN all_fc_tac [z_Ó_times_thm]);
a(LIST_DROP_NTH_ASM_T [4,2,1] (fn _ => id_tac));
a(all_fc_tac[z_Ó_plus_thm]);
a(LIST_DROP_NTH_ASM_T [10,9,8,7,5,4,3,2,1] (fn _ => id_tac));
a(all_fc_tac[z_Ó_plus_thm]);
a(LIST_DROP_NTH_ASM_T [12,11,10,9,8,7,6,5,4,2,1] (fn _ => id_tac));
a(all_fc_tac[z_Ó_plus1_thm]);
a(strip_tac THEN all_fc_tac[z_Ó_≥_plus1_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN TRY_T (asm_rewrite_tac[z_times0_thm]));
a(strip_asm_tac (z_µ_elimÒiÆz_˙_cases_thm)
	THEN strip_asm_tac (z_µ_elimÒjÆz_˙_cases_thm));
(* *** Goal "2.1" *** *)
a(PC_T1"prop_eq"asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(asm_ante_tac Òi*j=0Æ THEN asm_rewrite_tac[z_minus_times_thm]);
a(conv_tac(ONCE_MAP_C eq_sym_conv)THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm] THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 Ò(a¶j',b¶j'')Æ);
a(PC_T1"prop_eq"asm_prove_tac[]);
(* *** Goal "2.3" *** *)
a(asm_ante_tac Òi*j=0Æ THEN asm_rewrite_tac[z_minus_times_thm]);
a(conv_tac(LEFT_C(ONCE_MAP_C eq_sym_conv))THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm] THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 Ò(a¶j',b¶j'')Æ);
a(asm_ante_tac Ò≥ i = 0Æ THEN asm_rewrite_tac[z_minus_thm]);
(* *** Goal "2.4" *** *)
a(asm_ante_tac Òi*j=0Æ THEN asm_rewrite_tac[z_minus_times_thm]);
a(REPEAT strip_tac);
a(asm_ante_tac Ò≥i=0Æ THEN asm_rewrite_tac[]);
a(conv_tac(ONCE_MAP_C eq_sym_conv)THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm]);
a(strip_tac);
a(all_asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times_clauses› = save_thm("z_times_clauses",(
push_goal([], Òµi, j : U∑ 
	0 * i = 0 ± i * 0 = 0 ±
	i * 1 = i ± 1 * i = iÆ);
a(rewrite_tac[z_times0_thm, z_times1_thm]);
pop_thm()
));
=TEX
We need to break off here to prevent the structure becoming too large for
the Poly/ML compiler.
=SML
end (* of structure ZNumbers *);
structure €ZNumbers› = struct
open ZNumbers;
=TEX
\subsection{Inequalities}
=SML
val  €z_º_trans_thm› = save_thm("z_º_trans_thm", (
push_goal([], Òµi, j, k : U | i º j º k ∑ i º kÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ)] THEN REPEAT strip_tac);
a(rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n")]  THEN all_fc_tac [z_Ó_plus_thm]);
a(asm_ante_tac Ò(k - n) + n - m ç ÓÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(rewrite_tac[
	prove_rule[z_plus_assoc_thm]
		Òµa,b,c,d:U∑(a + b) + c + d = (a + b + c) + dÆ,
	z_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val  €z_less_trans_thm› = save_thm("z_less_trans_thm", (
push_goal([], Òµi, j, k : U | i < j < k ∑ i < kÆ);
a(once_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ)] THEN REPEAT strip_tac);
a(lemma_tacÒj º j + 1Æ THEN rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n"), (ÒkÆ, "l")]
	THEN fc_tac [z_º_trans_thm] THEN asm_fc_tac[] THEN asm_fc_tac[]);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(rewrite_tac[z_µ_elim Ò~nÆ z_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm]);
a(strip_asm_tac z_0_Ó_thm THEN all_fc_tac [z_Ó_plus1_thm]);
pop_thm()
));
=TEX
=SML
val  €z_less_º_trans_thm› = save_thm("z_less_º_trans_thm", (
push_goal([], Òµi, j, k : U | i < j º k ∑ i < kÆ);
a(REPEAT strip_tac);
a(asm_ante_tac Òi < jÆ THEN
	once_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ)] THEN
	REPEAT strip_tac);
a(rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n"), (ÒkÆ, "l")]
	THEN fc_tac [z_º_trans_thm] THEN asm_fc_tac[] THEN asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val  €z_º_less_trans_thm› = save_thm("z_º_less_trans_thm", (
push_goal([], Òµi, j, k : U | i º j < k ∑ i < kÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]
		THEN REPEAT strip_tac);
a(rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n")]  THEN all_fc_tac [z_Ó_plus_thm]);
a(asm_ante_tacÒ(k + ~ (n + 1)) + n + ~ m ç ÓÆ THEN rewrite_tac[z_minus_thm]);
a(rewrite_tac[z_µ_elim Ò~nÆ z_plus_order_thm]);
a(rewrite_tac[z_µ_elim ÒnÆ z_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm]);
a(rewrite_tac[z_µ_elim Ò~1Æ z_plus_order_thm]);
pop_thm()
));
=TEX
=SML
val  €z_minus_Ó_º_thm› = save_thm("z_minus_Ó_º_thm", (
push_goal([], Òµi : U; j : Ó ∑ i + ~j º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_plus_assoc_thm1,
	z_minus_thm, z_plus0_thm] THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val  €z_º_plus_Ó_thm› = save_thm("z_º_plus_Ó_thm", (
push_goal([], Òµi : U; j : Ó ∑ i  º i + jÆ);
a(REPEAT strip_tac);
a(asm_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ),
	z_µ_elimÒjÆz_plus_order_thm, z_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val  €z_º_cases_thm› = save_thm("z_º_cases_thm", (
push_goal([], Òµi, j : U ∑ i º j ≤ j º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(REPEAT strip_tac);
a(all_fc_tac[z_≥_Ó_thm]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[z_minus_thm] o
	once_rewrite_rule[z_plus_comm_thm]));
pop_thm()
));
=TEX
=SML
val  €z_º_refl_thm› = save_thm("z_º_refl_thm", (
push_goal([], Òµi : U ∑ i º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_minus_thm, z_0_Ó_thm]);
pop_thm()
));
=TEX
=SML
val  €z_ç_Ó_thm› = save_thm("z_ç_Ó_thm", (
push_goal([], Òµi : U ∑ i ç Ó § 0 º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_minus_thm, z_plus0_thm]);
pop_thm()
));
val  €z_0_º_Ó_thm› = conv_rule (ONCE_MAP_C eq_sym_conv) z_ç_Ó_thm;
=TEX
=SML
val  €z_º_º_0_thm› = save_thm("z_º_º_0_thm", (
push_goal([], Òµi, j : U ∑ i º j § i + ~j º 0Æ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_plus0_thm]);
a(rewrite_tac[z_minus_thm]);
a(rewrite_tac[z_µ_elimÒ~iÆz_plus_order_thm]);
pop_thm()
));
=TEX
=SML
val  €z_º_antisym_lemma› = (
push_goal([], Òµi : U | i º 0 ± ~i º 0 ∑ i = 0Æ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_plus0_thm, z_minus_thm]);
a(REPEAT strip_tac);
a(fc_tac[z_Ó_≥_minus_thm]);
pop_thm()
);
=TEX
=SML
val €z_º_antisym_thm› = save_thm("z_º_antisym_thm", (
push_goal([], Òµi, j : U | i º j ± j º i ∑ i = jÆ);
a(once_rewrite_tac[z_º_º_0_thm]);
a(z_µ_tac);
a(rewrite_tac[prove_rule[z_minus_thm, z_µ_elimÒjÆz_plus_order_thm]
	Òj+ ~i = ~(i+ ~j)Æ]);
a(REPEAT strip_tac);
a(all_fc_tac[z_º_antisym_lemma]);
a(once_rewrite_tac[z_˙_eq_thm] THEN strip_tac);
pop_thm()
));
=TEX
=SML
val €z_≥_less_thm› = save_thm("z_≥_less_thm", (
push_goal([], Òµi, j : U∑ ≥i < j § j º iÆ);
a(rewrite_tac[rewrite_rule[z_get_specÒ˙Æ] (z_get_specÒ(_º_)Æ),
	rewrite_rule[z_get_specÒ˙Æ] (z_get_specÒ(_-_)Æ), z_minus_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_≥_Ó_thm]);
a(fc_tac[z_Ó_cases_thm]);
(* *** Goal "1.1" *** *)
a(swap_asm_concl_tac Ò≥ j + ~ i + ~ 1 ç ÓÆ );
a(LEMMA_T Ò~ ~(j + ~ i + ~ 1) = 0Æ (asm_tac o rewrite_rule[z_minus_thm])
	THEN (asm_rewrite_tac[] THEN rewrite_tac[z_minus_thm, z_0_Ó_thm]));
(* *** Goal "1.2" *** *)
a(once_rewrite_tac[z_plus_comm_thm]);
a(LEMMA_TÒ~ (j + ~ i + ~ 1) + ~1 = j' + 1 + ~1Æ 
	(asm_rewrite_thm_tac o
		rewrite_rule [z_plus_assoc_thm, z_minus_thm, z_plus0_thm]));
a(asm_rewrite_tac [z_plus_assoc_thm, z_minus_thm, z_plus0_thm]);
(* *** Goal "2" *** *)
a(asm_tac z_Ó_plus_thm);
a(contr_tac THEN
	strip_asm_tac( z_µ_elimÒ(i¶i + ~ j, j¶j + ~ i + ~ 1)Æz_Ó_plus_thm));
a(asm_ante_tac Ò(i + ~ j) + j + ~ i + ~ 1 ç ÓÆ
	THEN rewrite_tac[z_µ_elimÒ~iÆz_plus_order_thm]);
a(rewrite_tac[z_µ_elimÒ~1Æz_plus_order_thm,
	z_plus_assoc_thm, z_minus_thm, z_plus0_thm, ±_right_elim z_Ó_thm]);
pop_thm()
));
=TEX
=SML
val €z_≥_º_thm› = save_thm("z_≥_º_thm", (
push_goal([], Òµi, j : U∑ ≥i º j § j < iÆ);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) z_≥_less_thm]);
pop_thm()
));
=TEX
The following lemma is useful in proving $z\_º\_clauses$. But as the automatic
proof procedure in the proof context will readily prove such trivia, it
is not saved.
=SML
val €z_º_plus_thm› = ((
push_goal([], Òµi, j, k : U∑ i + k º j + k § i º jÆ);
a(z_µ_tac THEN pure_once_rewrite_tac [z_º_º_0_thm]);
a(rewrite_tac[z_minus_thm, z_µ_elimÒ~jÆ z_plus_order_thm,
	z_plus0_thm, z_plus_assoc_thm]);
pop_thm()
));
=TEX
=SML
val €z_º_clauses› = save_thm("z_º_clauses", (
push_goal([], Òµi, j, k : U∑
	(i + k º j + k § i º j)
±	(k + i º j + k § i º j)
±	(i + k º k + j § i º j)
±	(k + i º k + j § i º j)
±	(i + k º k § i º 0)
±	(k + i º k § i º 0)
±	(i º k + i § 0 º k)
±	(i º i + k § 0 º k)
±	i º i
± 	≥1 º 0
± 	0 º 1
Æ);
a(z_µ_tac);
a(rewrite_tac [z_µ_elimÒiÆz_plus_order_thm]);
a(rewrite_tac[prove_rule[z_plus0_thm]
	Òµx:U∑(x º k § x º k + 0) ± (i º x § i + 0 º x)Æ]);
a(rewrite_tac [z_µ_elimÒjÆz_plus_order_thm]);
a(rewrite_tac [prove_rule[z_plus0_thm]Òk + 0 = 0 + kÆ,
		z_º_refl_thm, z_º_plus_thm]);
a(rewrite_tac [prove_rule[z_plus0_thm]Òi + 0 = 0 + iÆ,
		z_µ_elimÒkÆz_plus_order_thm, z_º_refl_thm, z_º_plus_thm]);
a(rewrite_tac[z_plus0_thm, z_º_refl_thm]);
a(rewrite_tac[rewrite_rule[z_get_specÒ˙Æ] (z_get_specÒ(_º_)Æ),
	rewrite_rule[z_get_specÒ˙Æ] (z_get_specÒ(_-_)Æ), z_plus0_thm,
	±_right_elim z_Ó_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm]);
a(rewrite_tac[rewrite_rule[z_0_Ó_thm, z_plus0_thm](z_µ_elimÒ0Æz_Ó_plus1_thm)]);
pop_thm()
));
=TEX
=SML
val €z_less_clauses› = save_thm("z_less_clauses", (
push_goal([], Òµi, j, k : U∑
	(i + k < j + k § i < j)
±	(k + i < j + k § i < j)
±	(i + k < k + j § i < j)
±	(k + i < k + j § i < j)
±	(i + k < k § i < 0)
±	(k + i < k § i < 0)
±	(i < k + i § 0 < k)
±	(i < i + k § 0 < k)
±	≥i < i
±	0 < 1
±	≥1 < 0
Æ);
a(z_µ_tac);
a(once_rewrite_tac[rewrite_rule[z_get_specÒ˙Æ] (z_get_specÒ(_<_)Æ)]);
a(rewrite_tac [z_º_clauses, z_plus_assoc_thm]);
a(rewrite_tac [z_µ_elimÒkÆz_plus_order_thm]);
a(rewrite_tac [z_º_clauses, z_plus0_thm]);
a(rewrite_tac [z_≥_º_thm]);
a(once_rewrite_tac[rewrite_rule[z_get_specÒ˙Æ] (z_get_specÒ(_<_)Æ)]);
a(rewrite_tac [z_º_clauses, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val €z_less_irrefl_thm› = save_thm("z_less_irrefl_thm", (
push_goal([], Òµi, j : U∑ ≥(i < j ± j < i)Æ);
a(REPEAT strip_tac);
a(once_rewrite_tac[rewrite_rule[z_get_specÒ˙Æ] (z_get_specÒ(_<_)Æ)]
	THEN contr_tac);
a(asm_tac(prove_rule[z_less_clauses]Òi < i + 1Æ));
a(strip_asm_tac(z_µ_elimÒ(i¶j,j¶i,k¶i+1)Æz_less_trans_thm));
a(strip_asm_tac(z_µ_elimÒ(i¶j,j¶i+1,k¶j)Æz_less_º_trans_thm));
a(POP_ASM_T (strip_asm_tac o rewrite_rule[z_less_clauses]));
pop_thm()
));
=TEX
\subsection{Theorems about $abs$}
=SML
val  €z_abs_thm› = save_thm("z_abs_thm", (
push_goal([], Òµi:Ó∑abs i = i ± abs ~i = iÆ);
a(strip_asm_tac (z_get_specÒ(abs_)Æ));
a(strip_asm_tac (nth 1 (strip_±_rule (z_get_specÒ(~_)Æ))));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tacÒi ç ˙Æ THEN1 rewrite_tac[˙_thm]);
a(fc_tac[z_≠_ç_rel_§_app_eq_thm] THEN asm_fc_tac[]);
a(LEMMA_T Ò(i, i) ç (abs_)Æ (fn th => asm_tac th THEN asm_fc_tac[]));
a(asm_rewrite_tac[] THEN MERGE_PCS_T1 z_more_pcs asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tacÒ~i ç ˙Æ THEN1 rewrite_tac[˙_thm]);
a(fc_tac[z_≠_ç_rel_§_app_eq_thm] THEN asm_fc_tac[]);
a(LEMMA_T Ò(~i, i) ç (abs_)Æ (fn th => asm_tac th THEN asm_fc_tac[]));
a(asm_rewrite_tac[] THEN MERGE_PCS_T1 z_more_pcs REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(ALL_FC_T rewrite_tac [z_Ó_≥_minus_thm]);
a(rewrite_tac[z_0_Ó_thm, z_minus_thm]);
(* *** Goal "2.2" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac);
a(LIST_DROP_NTH_ASM_T [9,8,6,5,4,3,2,1] (fn _=> id_tac));
a(lemma_tacÒ~i ç ˙ ± ~ ~i = iÆ THEN1 rewrite_tac[z_minus_thm, ˙_thm]);
a(all_fc_tac[z_≠_app_eq_§_ç_rel_thm] THEN REPEAT strip_tac);
(* *** Goal "2.3" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac);
a(LIST_DROP_NTH_ASM_T [9,8,6,4,3,2,1] (fn _=> id_tac));
a(lemma_tacÒ~i ç ˙ ± ~ ~i = iÆ THEN1 rewrite_tac[z_minus_thm, ˙_thm]);
a(all_fc_tac[z_≠_app_eq_§_ç_rel_thm] THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val  €z_abs_minus_thm› = save_thm("z_abs_minus_thm", (
push_goal([], Òµi:U∑abs ~i = abs iÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_abs_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_minus_thm]);
a(ALL_FC_T rewrite_tac[z_abs_thm]);
(* *** Goal "2" *** *)
pop_thm()
));
=TEX
=SML
val  €z_abs_Ó_thm› = save_thm("z_abs_Ó_thm", (
push_goal([], Òµi:U∑abs i ç ÓÆ);
a(REPEAT strip_tac THEN strip_asm_tac (z_µ_elimÒi∫˙Æz_˙_cases_thm)
	THEN asm_rewrite_tac[] THEN ALL_FC_T asm_rewrite_tac[z_abs_thm]);
pop_thm()
));
=TEX
=SML
val  €z_abs_times_thm› = save_thm("z_abs_times_thm", (
push_goal([], Òµi, j:U∑abs (i * j) = abs i * abs jÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm)
	THEN strip_asm_tac (z_µ_elim ÒjÆ z_˙_cases_thm)
	THEN asm_rewrite_tac[z_minus_times_thm, z_abs_minus_thm]
	THEN all_fc_tac[z_Ó_times_thm]
	THEN ALL_FC_T rewrite_tac[z_abs_thm]);
pop_thm()
));
=TEX
In the following proof of the triangle inequality,
the second and third cases (subgoals 2.3 and 2.4)
of the main case split are virtually the same (as in
fact are the first and fourth, but their proofs are short). The lemma in
the second line of the proof is the second case.
=SML
val  €z_abs_plus_thm› = save_thm("z_abs_plus_thm", (
push_goal([], Òµi, j:U∑abs (i + j) º abs i + abs jÆ);
a(REPEAT strip_tac);
a(lemma_tacÒµi, j, j', j'': U∑
		j' ç Ó ¥ i = j' ¥ j'' ç Ó ¥ j = ~ j''
	¥	abs (j' + ~ j'') º abs j' + abs ~ j''Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim Òj' + ~j''Æ z_˙_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(ALL_FC_T rewrite_tac[z_abs_thm]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_tac[conv_rule z_µ_elim_conv1 z_º_trans_thm]);
a(∂_tacÒj'Æ);
a(all_fc_tac[z_minus_Ó_º_thm, z_º_plus_Ó_thm]);
a(asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(ALL_FC_T rewrite_tac[z_abs_thm]);
a(LEMMA_T Ò~ ~j''' = ~(j' + ~ j'')Æ
	(rewrite_thm_tac o rewrite_rule[z_minus_thm])
	THEN1 POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_tac[conv_rule z_µ_elim_conv1 z_º_trans_thm]);
a(∂_tacÒj''Æ);
a(all_fc_tac[z_minus_Ó_º_thm, z_º_plus_Ó_thm]);
a(once_rewrite_tac [z_plus_comm_thm]);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm)
	THEN strip_asm_tac (z_µ_elim ÒjÆ z_˙_cases_thm)
	THEN asm_rewrite_tac[]
	THEN_LIST [id_tac, id_tac, once_rewrite_tac [z_plus_comm_thm], id_tac]);
(* *** Goal "2.1" *** *)
a(all_fc_tac[z_Ó_plus_thm] THEN ALL_FC_T rewrite_tac[z_abs_thm]
	THEN rewrite_tac[z_º_refl_thm]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a(rename_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a(rewrite_tac[prove_rule[z_minus_thm]Ò~j' + ~j'' = ~(j' + j'')Æ,
	z_abs_minus_thm]);
a(all_fc_tac[z_Ó_plus_thm] THEN ALL_FC_T rewrite_tac[z_abs_thm]
	THEN rewrite_tac[z_º_refl_thm]);
pop_thm()
));
=TEX
=SML
val  €z_abs_eq_0_thm› = save_thm("z_abs_eq_0_thm", (
push_goal([], Òµi:U∑abs i = 0 § i = 0Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm));
(* *** Goal "1.1" *** *)
a(PC_T1"prop_eq" asm_prove_tac[]);
a(all_fc_tac[z_abs_thm]);
a(PC_T1"prop_eq" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(asm_ante_tac Òabs i = 0Æ THEN POP_ASM_T rewrite_thm_tac);
a(all_fc_tac[z_abs_thm]);
a(asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[z_minus_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac z_0_Ó_thm THEN all_fc_tac[z_abs_thm]);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val  €z_Ó_abs_minus_thm› = save_thm("z_Ó_abs_minus_thm", (
push_goal([], Òµi, j:Ó | j º i ∑abs (i + ~j) º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_abs_thm]);
a(asm_rewrite_tac[z_minus_thm, z_plus_assoc_thm1, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val €z_º_induction_thm› = save_thm("z_º_induction_thm", (
push_goal([], ¨µ j : ˙ ∑ µ p : ˙ ≠ BOOL ∑ p j
	±	(µ i : ˙ ∑ Òj º iÆ ± p i ¥ p Òi + 1Æ)
	¥	(µ m : ˙ ∑ Òj º mÆ ¥ p m)Æ);
a (REPEAT z_strip_tac);
a (lemma_tac Ò∂ k : Ó ∑ k = m - jÆ);
a (z_∂_tac Òm - jÆ);
a (REPEAT z_strip_tac);
a (lemma_tac Òj º m ¥ 0 º m - jÆ);
a (asm_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a (asm_ante_tacÒj º mÆ);
a (once_rewrite_tac[z_º_º_0_thm]);
a (rewrite_tac[z_minus_thm, z_plus_clauses]);
a (rewrite_tac[z_µ_elim ÒjÆ z_plus_order_thm]);
a (rewrite_tac[z_ç_Ó_thm]);
a (asm_rewrite_tac[]);
a (lemma_tac Òm = k + jÆ);
a (asm_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a (rewrite_tac[z_plus_assoc_thm, z_plus_clauses, z_minus_clauses]);
a (var_elim_asm_tac Òm = k + jÆ);
a (GET_ASM_T Òk ç ÓÆ ante_tac);
a (z_Ó_induction_tac);
a (asm_rewrite_tac [z_plus_clauses]);
a (lemma_tac Òj º i + jÆ);
a (asm_ante_tacÒi ç ÓÆ);
a (asm_rewrite_tac [z_º_clauses, z_ç_Ó_thm]);
a (all_asm_fc_tac[]);
a (POP_ASM_T ante_tac);
a (rewrite_tac [z_µ_elim ¨j : ˙Æ z_plus_order_thm]);
pop_thm()
));
=TEX
=SML
fun €z_º_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: î˙Æ)
	then term_fail "z_º_induction_tac" 86401 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t => is_z_º t andalso snd(dest_z_º t) =$ tm)
			handle Fail _ => fail "z_º_induction_tac" 86402 [];
		val thm = µ_elim (fst(dest_z_º asm)) z_º_induction_thm;
	in	if not (is_free_in tm conc)
			then term_fail "z_º_induction_tac" 86404 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "z_º_induction_tac" 86403 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 thm) (asms, conc)
	end
	)
);
=TEX
=SML
val z_less_plus1_thm = save_thm("z_less_plus1_thm", (
push_goal([], Òµ m, n : U ∑ m < n + 1 § m = n ≤ m < nÆ);
a (rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_ < _)Æ)]);
a (rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_ - _)Æ)]);
a (rewrite_tac[z_minus_thm, z_plus_assoc_thm]);
a (rewrite_tac[z_µ_elim Ò~ mÆ z_plus_order_thm]);
a (rewrite_tac[z_minus_clauses, z_plus_clauses]);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (eq_sym_asm_tac Ò≥ m = nÆ);
a (GET_ASM_T Ò≥ n = mÆ ante_tac);
a (once_rewrite_tac[z_˙_eq_thm]);
a (rewrite_tac[z_µ_elimÒ~ mÆ z_plus_order_thm]);
a (REPEAT strip_tac);
a (strip_asm_tac (z_µ_elim Ò~ m + nÆ z_Ó_cases_thm));
a (lemma_tac Ò~ m + n + ~ 1 = jÆ);
(* *** Goal "1.1" *** *)
a (asm_ante_tacÒ~ m + n = j + 1Æ);
a (once_rewrite_tac[z_˙_eq_thm]);
a (rewrite_tac[z_minus_thm, z_plus_assoc_thm]);
a (rewrite_tac [z_µ_elim Ò~ jÆ z_plus_order_thm]);
(* *** Goal "1.2" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
a (rewrite_tac[z_minus_clauses]);
a (rewrite_tac[z_0_Ó_thm]);
(* *** Goal "3" *** *)
a (ante_tac (z_µ_elim Ò~ m + n + ~ 1Æ z_Ó_plus1_thm));
a (strip_tac THEN POP_ASM_T ante_tac);
a (rewrite_tac[z_plus_assoc_thm, z_minus_clauses, z_plus_clauses]);
pop_thm()
));
=TEX
=SML
val €z_cov_induction_thm› = save_thm("z_cov_induction_thm", (
set_goal([], ¨µ (j:˙) (p:˙≠BOOL) ∑
	(µ i ∑ Òj º iÆ ± Òµ k : ˙∑ j º k ± k < i ¥ ¨p kÆÆ ¥ p i)
	¥ (µ i ∑ Òj º iÆ ¥ p i)Æ);
a (REPEAT z_strip_tac);
a (lemma_tac ¨Òµ k : ˙∑ j º k ± k < i ¥ ¨p kÆÆÆ);
(* *** Goal "1" *** *)
a (z_º_induction_tac ÒiÆ);
(* *** Goal "1.1" *** *)
a (REPEAT z_strip_tac);
a (lemma_tac Òj º k § ≥ k < jÆ);
a (rewrite_tac[z_≥_less_thm]);
(* *** Goal "1.2" *** *)
a (rewrite_tac [z_less_plus1_thm] THEN REPEAT z_strip_tac);
(* *** Goal "1.2.1" *** *)
a (POP_ASM_T rewrite_thm_tac);
a (all_asm_fc_tac[]);
(* *** Goal "1.2.2" *** *)
a (all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a (all_asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
fun €z_cov_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: î˙Æ)
	then term_fail "z_cov_induction_tac" 86401 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t => is_z_º t andalso snd(dest_z_º t) =$ tm)
			handle Fail _ => fail "z_cov_induction_tac" 86402 [];
		val thm = µ_elim (fst(dest_z_º asm)) z_cov_induction_thm;
	in	if not (is_free_in tm conc)
			then term_fail "z_cov_induction_tac" 86404 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "z_cov_induction_tac" 86403 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 thm) (asms, conc)
	end
	)
);
=TEX
\subsection{Theorems about $div$ and $mod$}
=TEX
=SML
val  €z_div_mod_unique_lemma1› = (
push_goal([], Òµi, j : Ó ∑ i*j < j ¥ i = 0Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_Ó_cases_thm));
a(asm_ante_tacÒi * j < jÆ THEN asm_rewrite_tac[z_times_plus_distrib_thm, z_times1_thm]);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ),
	z_minus_thm]);
a(rewrite_tac[z_µ_elim Ò~jÆz_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm]);
a(LIST_DROP_NTH_ASM_T [1,4] (fn _ => id_tac));
a(all_fc_tac[z_Ó_times_thm]);
a(LIST_DROP_NTH_ASM_T [1,3,4,5] (fn _ => id_tac));
a(rename_tac[(ÒjÆ, "m")]);
a(strip_tac THEN all_fc_tac[z_Ó_plus_thm]);
a(asm_ante_tacÒj' * m + ~ (j' * m) + ~ 1 ç ÓÆ);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm, 
	±_right_elim z_Ó_thm]);
pop_thm()
);
=SML
val  €z_div_mod_unique_lemma2› = (
push_goal([], Òµj, d, r:U | ≥j = 0 ∑ 
		(d*j + r = 0 ± 0 º r < abs j)
	¥	d = 0 ± r = 0Æ);
a(REPEAT_UNTIL is_± strip_tac);
a(LEMMA_T Òd = 0Æ (
	fn th => asm_ante_tac Òd * j + r = 0Æ THEN
	rewrite_tac[th, z_times0_thm, z_plus0_thm]));
a(LEMMA_T Òabs(d*j) = 0Æ 
	(strip_asm_tac o rewrite_rule[z_abs_times_thm, z_abs_eq_0_thm, z_times_eq_0_thm]));
a(LEMMA_T Òabs(d*j) < abs jÆ (strip_asm_tac o rewrite_rule[z_abs_times_thm]));
(* *** Goal "1" *** *)
a(once_rewrite_tac[
	prove_rule[z_plus_assoc_thm,
		z_minus_thm, z_plus0_thm]Òd*j = (d*j + r) + ~rÆ]);
a(bc_tac[conv_rule z_µ_elim_conv1 z_º_less_trans_thm]);
a(∂_tacÒrÆ);
a(asm_ante_tac Ò0 º rÆ THEN asm_rewrite_tac[z_0_º_Ó_thm, z_plus0_thm]);
a(strip_tac THEN ALL_FC_T rewrite_tac [z_abs_thm]);
a(rewrite_tac[z_º_refl_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_abs_times_thm]);
a(strip_asm_tac (z_µ_elimÒdÆ z_abs_Ó_thm));
a(strip_asm_tac (z_µ_elimÒjÆ z_abs_Ó_thm));
a(all_fc_tac [z_Ó_times_thm]);
a(ALL_FC_T rewrite_tac [z_div_mod_unique_lemma1]);
a(rewrite_tac[z_times0_thm]);
pop_thm()
);
=TEX
=SML
val  €z_div_mod_unique_lemma3› = (
push_goal([], Òµi, j, d, r, D, R:U | ≥j = 0 ∑ 
		(D*j + R = d*j + r ± 0 º r º R < abs j)
	¥	D = d ± R = rÆ);
a(REPEAT_UNTIL is_± strip_tac);
a(GET_ASM_TÒD*j + R = d*j + rÆ (ante_tac o once_rewrite_rule[z_˙_eq_thm]));
a(LEMMA_TÒ(D * j + R) + ~ (d * j + r) = (D + ~d)*j + (R + ~r)Æ 
	rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_minus_thm, z_times_plus_distrib_thm, z_minus_times_thm, 
	z_plus_assoc_thm]);
a(rewrite_tac[z_µ_elim ÒRÆ z_plus_order_thm]);
(* *** Goal "2" *** *)
a(GET_ASM_TÒ0 º rÆ(asm_tac o rewrite_rule [z_0_º_Ó_thm]));
a(LEMMA_TÒ0 º RÆ (fn th => asm_tac(rewrite_rule[z_0_º_Ó_thm] th) 
	THEN asm_tac th)
	THEN1 all_fc_tac[z_º_trans_thm]);
a(strip_asm_tac (z_µ_elimÒ(i¶R,j¶r)Æ z_Ó_abs_minus_thm));
a(GET_ASM_TÒr º RÆ (asm_tac o rewrite_rule[
	rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ), 
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]));
a(strip_asm_tac(z_µ_elimÒR + ~ rÆ z_abs_thm));
a(POP_ASM_T(fn _ => POP_ASM_T (fn th => GET_NTH_ASM_T 2 
	(asm_tac o rewrite_rule[th]))));
a(GET_ASM_T ÒR + ~ r ç ÓÆ
	(asm_tac o rewrite_rule[conv_rule (ONCE_MAP_C eq_sym_conv) 
	z_0_º_Ó_thm]));
a(strip_asm_tac (z_µ_elimÒ(i¶R + ~ r,j¶R,k¶abs j)Æ z_º_less_trans_thm));
a(strip_tac THEN
	strip_asm_tac (z_µ_elimÒ(j¶j,d¶D+ ~d,r¶R + ~r)Æ 
	z_div_mod_unique_lemma2));
a(once_rewrite_tac[z_˙_eq_thm] THEN REPEAT strip_tac);
pop_thm()
);
=TEX
=SML
val  €z_div_mod_unique_thm› = save_thm("z_div_mod_unique_thm", (
push_goal([], Òµi, j, d, r:U | ≥j = 0 ∑ 
		(i = d*j + r ± 0 º r < abs j)
	§	(d = i div j ± r = i mod j)Æ);
a(REPEAT_N 9 strip_tac);
a(MERGE_PCS_T1 z_more_pcs strip_asm_tac (z_µ_elim Ò(i¶i,j¶j)Æ
	(rewrite_rule[˙_thm](±_right_elim(z_get_specÒ(_div_)Æ)))));
a(strip_asm_tac (z_µ_elim Ò(i¶r,j¶i mod j)Æz_º_cases_thm));
(* *** Goal "1.1" *** *)
a(strip_asm_tac z_div_mod_unique_lemma3);
a(DROP_ASM_T Òi = d * j + rÆ (fn th1 => DROP_ASM_T
	Òi = (i div j) * j + i mod jÆ
	(fn th2 => asm_tac(eq_trans_rule(eq_sym_rule th2) th1))));
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(strip_asm_tac z_div_mod_unique_lemma3);
a(DROP_ASM_T Òi = d * j + rÆ (fn th1 => DROP_ASM_TÒi = (i div j) * j + i mod jÆ
	(fn th2 => asm_tac(eq_trans_rule(eq_sym_rule th1) th2))));
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(MERGE_PCS_T1 z_more_pcs strip_asm_tac (z_µ_elim Ò(i¶i,j¶j)Æ
	(rewrite_rule[˙_thm](±_right_elim(z_get_specÒ(_div_)Æ)))));
a(DROP_ASM_T Òi = (i div j) * j + i mod jÆ once_rewrite_thm_tac);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
We break off again to prevent the structure becoming too large for
the Poly/ML compiler.
=SML
end (* of structure ZNumbers *);
structure €ZNumbers› = struct
open ZNumbers;
=TEX
\section{CONVERSIONS}
=SML
val _ = set_pc"z_predicates";
val €z_Ó_plus_conv_thm› = ((
push_goal([], ¨µ m n k∑
	m + n = k ¥ Ò¨Z'Int mÆ + ¨Z'Int nÆ = ¨Z'Int kÆÆ
Æ);
a(REPEAT strip_tac THEN
	asm_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) z_int_homomorphism_thm]);
pop_thm()
));
=TEX
=SML
val €z_plus_eg› = Òi + jÆ;
val €z_times_eg› = Òi * jÆ;
val €z_subtract_eg› = Òi - jÆ;
val €z_greater_eg› = Òi > jÆ;
val €z_æ_eg› = Òi æ jÆ;
val €z_ç_Ó_eg› = Òi ç ÓÆ;
val €z_abs_eg› = Òabs iÆ;
val €z_mod_eg› = Òi mod jÆ;
val €z_less_eg› = Òi < jÆ;
val €z_div_eg› = Òi div jÆ;
val €z_º_eg› = Òi º jÆ;
val €z_eq_eg› = Òi = jÆ;
=TEX
=SML
val €z_Ó_plus_conv› : CONV = (fn tm =>
	let	val ((_, hol_op1), (_, hol_op2)) = 
			((dest_app ** dest_app)(dest_z_plus tm))
			handle Fail _ => term_fail "z_Ó_plus_conv" 86303 [tm, z_plus_eg];
		val thm1 = (plus_conv (mk_plus (hol_op1, hol_op2)))
			handle Fail _ => term_fail "z_Ó_plus_conv" 86303 [tm, z_plus_eg];
		val thm2 = simple_¥_match_mp_rule z_Ó_plus_conv_thm thm1
			handle ex => reraise ex "z_Ó_plus_conv";
	in	(accept_conv thm2 tm)
		handle Fail _ => term_fail "z_Ó_plus_conv" 86303 [tm, z_plus_eg]
	end
);
=TEX
=SML
val €z_subtract_minus_conv_thm› = ((
push_goal([], ¨µ m n∑Òm - n = m + ~nÆÆ);
a(rewrite_tac[rewrite_rule[z_get_specÒ˙Æ](z_get_specÒ(_-_)Æ)]);
pop_thm()
));
=TEX
=SML
val €z_subtract_minus_conv› : CONV = (fn tm =>
	(simple_eq_match_conv z_subtract_minus_conv_thm tm)
	handle Fail _ => term_fail "z_subtract_minus_conv" 86302 [tm, z_subtract_eg]
);
=TEX
The order of the conjuncts in the following is crucial to the somewhat
contrived coding of $z\_add\_conv$, hence the two dummy entries.
=SML
val z_plus_conv_thm = ((
push_goal([], ¨µ k m n∑
	(m + n = k ¥ Ò¨Z'Int mÆ + ¨Z'Int nÆ = ¨Z'Int kÆÆ)
±	T
±	(n + k = m ¥ Ò¨Z'Int mÆ + ~¨Z'Int nÆ = ¨Z'Int kÆÆ)
±	(m + k = n ¥ Ò¨Z'Int mÆ + ~¨Z'Int nÆ = ~¨Z'Int kÆÆ)
±	(m + k = n ¥ Ò~¨Z'Int mÆ + ¨Z'Int nÆ = ¨Z'Int kÆÆ)
±	(n + k = m ¥ Ò~¨Z'Int mÆ + ¨Z'Int nÆ = ~¨Z'Int kÆÆ)
±	T
±	(m + n = k ¥ Ò~¨Z'Int mÆ + ~¨Z'Int nÆ = ~¨Z'Int kÆÆ)
Æ);
a(rewrite_tac[z_Ó_plus_conv_thm]);
a(conv_tac (ONCE_MAP_C (LEFT_C eq_sym_conv)));
a(REPEAT strip_tac THEN POP_ASM_T rewrite_thm_tac THEN
	rewrite_tac[z_int_homomorphism_thm, z_minus_thm]
	THEN once_rewrite_tac[z_˙_eq_thm]
	THEN rewrite_tac[z_plus_assoc_thm, z_minus_thm, z_plus0_thm]);
(* *** Goal "1" *** *)
a(rewrite_tac[z_µ_elimÒ~¨Z'Int nÆÆ z_plus_order_thm] THEN
	rewrite_tac[z_plus_assoc_thm, z_minus_thm, z_plus0_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_µ_elim¨Z'Int nÆ z_plus_order_thm] THEN
	rewrite_tac[z_plus_assoc_thm, z_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
local
open Vector;
val €plus_conv_thms_forms› : (THM * (int * int -> int)) vector = vector(combine
	(map (list_µ_intro [¨m : ÓÆ, ¨n : ÓÆ, ¨k : ÓÆ])
		(strip_±_rule (all_µ_elim z_plus_conv_thm)))
	([op +, op +, op -, op - o swap, op - o swap, op -, op +, op +]
			: (int*int->int)list)
);
val plus_minus0_thm = prove_rule[z_plus0_thm, z_minus_thm]¨µi∑Òi + ~0 = iÆÆ;
val minus0_plus_thm = prove_rule[z_plus0_thm, z_minus_thm]¨µj∑Ò~0 + j = jÆÆ;
fun €make_plus_conv_thm› (i : int)  (j : int) : THM = (
	let	val m = abs i;
		val n = abs j;
		val ix =	(if i < 0 then 4 else 0) +
				(if j < 0 then 2 else 0) +
				(if i + j < 0 then 1 else 0);
		val (thm1, f) = sub(plus_conv_thms_forms, ix);
		val mt = mk_Ó m;
		val nt = mk_Ó n;
		val kt = mk_Ó (f(m,n));
		val thm2 = list_simple_µ_elim[mt, nt, kt] thm1;
		val tm = (fst o dest_eq o fst o dest_¥ o concl) thm2;
	in	¥_mp_rule thm2 (plus_conv tm)
	end
);
in
val €z_plus_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = (dest_z_plus tm);
		val i = dest_z_signed_int itm;
		val j = dest_z_signed_int jtm;
	in	(accept_conv (make_plus_conv_thm i j)
		ORELSE_C
		(fn t =>
		(if	j = 0
		then	accept_conv (simple_µ_elim itm plus_minus0_thm)
		else	fail_conv) t)
		ORELSE_C
		(fn t =>
		(if	i = 0
		then	accept_conv (simple_µ_elim jtm minus0_plus_thm)
		else	fail_conv) t)) tm
	end	handle Fail _ => term_fail "z_plus_conv" 86303 [tm, z_plus_eg]
);
end;
=TEX
=SML
val €z_int_times_homomorphism_thm› = ((
push_goal([], ¨µ m n∑
	Ò¨Z'Int (m * n)Æ = ¨Z'Int mÆ * ¨Z'Int nÆÆ
Æ);
a(strip_tac THEN induction_tac¨m:ÓÆ THEN REPEAT strip_tac
	THEN asm_rewrite_tac[plus_clauses, z_times0_thm, times_clauses,
		times_plus_distrib_thm, z_times_plus_distrib_thm,
		z_int_homomorphism_thm, z_times1_thm]);
pop_thm()
));
=TEX
=SML
val €z_Ó_times_conv_thm› = ((
push_goal([], ¨µ m n∑
	m * n = k ¥ Ò¨Z'Int mÆ * ¨Z'Int nÆ = ¨Z'Int kÆÆ
Æ);
a(REPEAT strip_tac);
a(LEMMA_T Ò¨Z'Int mÆ * ¨Z'Int nÆ = ¨Z'Int(m*n)ÆÆ ante_tac THEN_LIST
	[rewrite_tac[z_int_times_homomorphism_thm], asm_rewrite_tac[]]);
pop_thm()
));
=TEX
=SML
val €z_Ó_times_conv› : CONV = (fn tm =>
	let	val ((_, hol_op1), (_, hol_op2)) = 
			((dest_app ** dest_app)(dest_z_times tm))
			handle Fail _ => term_fail "z_Ó_times_conv" 86301 
				[tm, z_times_eg];
		val thm1 = (times_conv (mk_times (hol_op1, hol_op2)))
			handle Fail _ => term_fail "z_Ó_times_conv" 86301 
				[tm, z_times_eg];
		val thm2 = simple_¥_match_mp_rule z_Ó_times_conv_thm thm1
			handle ex => reraise ex "z_Ó_times_conv";
	in	(accept_conv thm2 tm)
		handle Fail _ => term_fail "z_Ó_times_conv" 86301 
			[tm, z_times_eg]
	end
);
=TEX
=SML
local
open Vector;
val €times_convs› : ((CONV -> CONV) * CONV) vector = vector(
	combine
	[Z_FUN_RAND_C, Z_FUN_RAND_C, Combinators.I]
	(map (simple_eq_match_conv o prove_rule[z_minus_times_thm])
		[¨µi j∑ Òi * ~ j = ~ (i * j)ÆÆ,
		¨µi j∑ Ò~i * j = ~ (i * j)ÆÆ,
		¨µi j∑ Ò~i * ~j = i * jÆÆ]));
in
val €z_times_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = (dest_z_times tm);
		val ix = (if is_z_minus itm then 2 else 0) +
			(if is_z_minus jtm then 1 else 0);
	in	(if ix = 0
		then z_Ó_times_conv
		else	let val (f, c) = sub(times_convs, ix - 1)
			in	c THEN_C f z_Ó_times_conv
			end) tm
	end	handle Fail _ => term_fail "z_times_conv" 86303 [tm, z_times_eg]
);
end;
=TEX
=SML
val €z_int_Ó_thm› = ((
push_goal([], ¨µ m∑ Ò¨Z'Int mÆ ç ÓÆÆ);
a(REPEAT strip_tac);
a(induction_tacÒmÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[z_0_Ó_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac [z_Ó_plus1_thm]);
a(asm_rewrite_tac[z_int_homomorphism_thm]);
pop_thm()
));
=TEX
=SML
local
val €z_abs_conv_lemma› = prove_rule [z_int_Ó_thm] ¨µ m∑ Ò¨Z'Int mÆ ç Ó ± trueÆÆ;
in
val €z_abs_conv› : CONV = (fn tm =>
	let	val arg_tm = hd(tl(snd(strip_app tm)));
		val (itm, is_neg) = (dest_z_minus arg_tm, true)
				handle Fail _ => (arg_tm, false);
		val i = snd(dest_app itm);
		val chk = dest_Ó i;
		val thm1 = z_µ_elim itm z_abs_thm;
		val thm2 = simple_µ_elim i z_abs_conv_lemma;
		val thm3 = ¥_mp_rule thm1 thm2;
	in	accept_conv
		(if is_neg
		then ±_right_elim thm3
		else ±_left_elim thm3)
		tm
	end	handle Fail _ => term_fail "z_abs_conv" 86303 [tm, z_abs_eg]
);
end;
=TEX
=SML
val €z_int_onto_Ó_thm› = ((
push_goal([], Òµ i : Ó ∑ ¨∂m∑ Z'Int m = iÆÆ);
a(z_µ_tac THEN rewrite_tac[] THEN z_Ó_induction_tac);
(* *** Goal "1" *** *)
a(∂_tac¨0Æ THEN strip_tac);
(* *** Goal "2" *** *)
a(∂_tac¨i'+1Æ THEN asm_rewrite_tac[z_int_homomorphism_thm]);
pop_thm()
));
=TEX
=SML
val €z_int_one_one_thm› = ((
push_goal([], ¨µ m n ∑ m = n § Z'Int m = Z'Int nÆ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ] less_cases_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[less_def, º_def]));
a(i_contr_tac THEN swap_nth_asm_concl_tac 2);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[z_int_homomorphism_thm]);
a(conv_tac (RAND_C eq_sym_conv));
a(once_rewrite_tac[z_˙_eq_thm]);
a(once_rewrite_tac[z_plus_comm_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm]);
a(once_rewrite_tac[z_plus_comm_thm]);
a(asm_tac (µ_elim¨i:ÓÆ z_int_Ó_thm));
a(all_fc_tac[z_Ó_≥_plus1_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[less_def, º_def]));
a(i_contr_tac THEN swap_nth_asm_concl_tac 2);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[z_int_homomorphism_thm]);
a(once_rewrite_tac[z_˙_eq_thm]);
a(once_rewrite_tac[z_plus_comm_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm]);
a(once_rewrite_tac[z_plus_comm_thm]);
a(asm_tac (µ_elim¨i:ÓÆ z_int_Ó_thm));
a(all_fc_tac[z_Ó_≥_plus1_thm]);
pop_thm()
));
=TEX
=SML
val €z_º_conv_thm1› = ((
push_goal([], ¨µ m n∑
	Ò¨Z'Int mÆ º ¨Z'Int nÆÆ §  m º n
Æ);
a(rewrite_tac[get_spec¨$ºÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_ante_tac THEN rewrite_tac[
	rewrite_rule[z_get_specÒ˙Æ](z_get_specÒ(_º_)Æ),
	rewrite_rule[z_get_specÒ˙Æ](z_get_specÒ(_-_)Æ)]);
a(strip_tac THEN all_fc_tac [z_int_onto_Ó_thm]);
a(rewrite_tac[z_int_one_one_thm, z_int_homomorphism_thm]);
a(∂_tacÒm'Æ THEN asm_rewrite_tac[]);
a(rewrite_tac[z_µ_elimÒ¨Z'Int nÆÆ z_plus_order_thm, z_minus_thm, z_plus0_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[z_int_homomorphism_thm]);
a(strip_asm_tac(µ_elimÒiÆ z_int_Ó_thm));
a(strip_asm_tac(z_µ_elimÒ(i¶¨Z'Int mÆ, j¶¨Z'Int iÆ)Æ z_º_plus_Ó_thm));
pop_thm()
));
=TEX
N.b. in the following it is important that we don't try to be
clever with the case
when both operands are non-negative, since the uses of $z\_plus\_conv$
then handle operands of the form
=INLINEFT
~ 0
=TEX
.
=SML
val €z_º_conv_thm2› = ((
push_goal([], ¨µ i j k∑Òi º j § i + k º j + kÆÆ);
a(REPEAT µ_tac);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv)
		(z_µ_elimÒ(i¶i,j¶j,k¶k)Æz_º_plus_thm)]);
pop_thm()
));
=TEX
=SML
val €z_º_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = dest_z_º tm;
		val i = dest_z_signed_int itm;
		val j = dest_z_signed_int jtm;
		val min = if i < j then i else j;
		val k = if min < 0 then abs min else 0;
		val ktm = mk_z_signed_int k;
	in	(accept_conv(list_simple_µ_elim[itm, jtm, ktm] z_º_conv_thm2)
		THEN_C	Z_REL_RANDS_C z_plus_conv
		THEN_C	simple_eq_match_conv z_º_conv_thm1
		THEN_C	º_conv) tm
	end	handle Fail _ => term_fail "z_º_conv" 86303 [tm, z_º_eg]
);
=TEX
=SML
val €z_less_conv_thm› = ((
push_goal([], ¨µ i j∑Òi < j § i + 1 º jÆÆ);
a(REPEAT µ_tac);
a(conv_tac(LEFT_C(once_rewrite_conv[
	rewrite_rule[z_get_specÒ˙Æ](z_get_specÒ(_º_)Æ)])));
a(REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val €z_less_conv› : CONV = (fn tm =>
	((simple_eq_match_conv z_less_conv_thm
	THEN_C Z_REL_LEFT_C z_plus_conv
	THEN_C z_º_conv) tm)
	handle Fail _ => term_fail "z_less_conv" 86303 [tm, z_less_eg]
);
=TEX
=SML
val €z_greater_less_conv_thm› = ((
push_goal([], ¨µ i j∑Òi > j § j < iÆÆ);
a(REPEAT µ_tac);
a(conv_tac(LEFT_C(once_rewrite_conv[
	rewrite_rule[z_get_specÒ˙Æ](z_get_specÒ(_º_)Æ)])));
a(REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val €z_greater_less_conv› : CONV = (fn tm =>
	((simple_eq_match_conv z_greater_less_conv_thm) tm)
	handle Fail _ => term_fail "z_greater_less_conv" 86302 [tm, z_greater_eg]
);
=TEX
=SML
val €z_æ_º_conv_thm› = ((
push_goal([], ¨µ i j∑Òi æ j § j º iÆÆ);
a(REPEAT µ_tac);
a(conv_tac(LEFT_C(once_rewrite_conv[
	rewrite_rule[z_get_specÒ˙Æ](z_get_specÒ(_º_)Æ)])));
a(REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val €z_æ_º_conv› : CONV = (fn tm =>
	((simple_eq_match_conv z_æ_º_conv_thm) tm)
	handle Fail _ => term_fail "z_æ_º_conv" 86302 [tm, z_æ_eg]
);
=TEX
=SML
val €z_minus0_thm› = ((
push_goal([], Ò~0 = 0Æ);
a(rewrite_tac[z_minus_thm]);
pop_thm()
));
=TEX
=SML
val €z_˙_eq_conv_thm› = ((
push_goal([], ¨µ i j∑Òi < j ¥ (i = j § false)ÆÆ);
a(REPEAT strip_tac);
a(asm_ante_tacÒi < jÆ THEN asm_rewrite_tac[z_less_clauses]);
pop_thm()
));
=TEX
=SML
val €z_˙_eq_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = dest_eq tm;
		val i = dest_z_signed_int itm;
		val j = dest_z_signed_int jtm;
	in	(if	i < j
		then	accept_conv(simple_¥_match_mp_rule z_˙_eq_conv_thm
				(§_t_elim(z_less_conv(mk_z_less(itm, jtm)))))
		else if	i = j
		then		LEFT_C (simple_eq_match_conv z_minus0_thm)
			AND_OR_C RIGHT_C (simple_eq_match_conv z_minus0_thm)
			AND_OR_C accept_conv (§_t_intro(refl_conv (mk_z_signed_int i)))
		else	(* i > j *)
				eq_sym_conv
			THEN_C	accept_conv(simple_¥_match_mp_rule z_˙_eq_conv_thm
				(§_t_elim(z_less_conv(mk_z_less(jtm, itm))))))
		tm
	end
);
=TEX
=SML
val €z_div_mod_conv_thm› = ((
push_goal([], ¨µ i j d r ∑ Ò
		d * j + r = i  ± 0 º r ± r < abs j
	¥	i div j = d ± i mod j = r
ÆÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN REPEAT_UNTIL is_± strip_tac);
a(lemma_tac Ò≥j = 0Æ);
(* *** Goal "1" *** *)
a(swap_asm_concl_tac Òr < abs jÆ THEN asm_rewrite_tac[]);
a(conv_tac (MAP_C z_abs_conv));
a(asm_rewrite_tac[z_≥_less_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac [z_div_mod_unique_thm]);
pop_thm()
));
=TEX
=SML
local
infix 7 zdiv zmod;
fun (i : int) €zmod› (j : int) : int = (
	let	val mlm = i mod j;
	in	if mlm >= 0
		then mlm
		else mlm - j
	end	handle Mod => fail "zdiv" 0 []
);
fun (i : int) €zdiv› (j : int) : int = (
	let	val zm = i zmod j;
	in	(i - zm) div j
	end	handle Mod => fail "zdiv" 0 []
);
val €zero› = Ò0Æ;
fun €z_div_mod_conv› (is_div : bool): TERM * TERM -> THM = (fn (itm, jtm) =>
	let	val i = dest_z_signed_int itm;
		val j = dest_z_signed_int jtm;
		val dtm = mk_z_signed_int (i zdiv j);
		val rtm = mk_z_signed_int (i zmod j);
		val thm1 = (Z_FUN_LEFT_C z_times_conv THEN_C z_plus_conv)
			(mk_z_plus(mk_z_times (dtm, jtm), rtm));
		val thm2 = §_t_elim
			(z_º_conv(mk_z_º(zero, rtm)));
		val thm3 = §_t_elim
			((Z_REL_RIGHT_C z_abs_conv THEN_C z_less_conv)
			(mk_z_less(rtm, mk_z_abs jtm)));
		val thm4 = ¥_mp_rule
			(list_simple_µ_elim[itm, jtm, dtm, rtm]z_div_mod_conv_thm)
			(list_±_intro [thm1, thm2, thm3]);
	in	(if is_div
		then ±_left_elim
		else ±_right_elim) thm4
	end
);
in
val €z_div_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = dest_z_div tm;
	in	if jtm =$ zero
		then	term_fail "z_div_conv" 86303 [tm, z_div_eg]
		else	(accept_conv (z_div_mod_conv true (dest_z_div tm)) tm)
			handle Fail _ => term_fail "z_div_conv" 57003 [tm]
	end
);
val €z_mod_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = dest_z_mod tm;
	in	if jtm =$ zero
		then	term_fail "z_mod_conv" 86303 [tm, z_mod_eg]
		else	(accept_conv (z_div_mod_conv false (dest_z_mod tm)) tm)
			handle Fail _ => term_fail "z_mod_conv" 57007 [tm]
	end
);
end;
=TEX
=SML
val €z_ç_Ó_conv_thm› = conv_rule z_µ_elim_conv1 z_ç_Ó_thm;
=TEX
=SML
val €z_ç_Ó_conv› : CONV = (fn tm =>
	(simple_eq_match_conv z_ç_Ó_conv_thm tm)
	handle Fail _ => term_fail "z_ç_Ó_conv" 86302 [tm, z_ç_Ó_eg]
);
=TEX
=SML
val €z_º_less_eq_thm› : THM = save_thm("z_º_less_eq_thm",(
push_pc "z_sets_ext";
set_goal([],Òµ x, y : U ∑ x º y § (x < y ≤ x = y)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[eq_sym_rule(rewrite_rule[](z_µ_elim Ò(i ¶ y, j ¶ x)Æ z_≥_º_thm))]);
a(contr_tac THEN asm_fc_tac [z_º_antisym_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[eq_sym_rule(rewrite_rule[](z_µ_elim Ò(i ¶ y, j ¶ x)Æ z_≥_less_thm))]);
a(contr_tac THEN asm_fc_tac [z_less_irrefl_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[z_º_refl_thm]);
pop_pc();
pop_thm()
));
=TEX
=SML
val €z_ç_Óâ1_thm› : THM = save_thm("z_ç_Óâ1_thm", (
push_pc "z_sets_ext";
set_goal([],Òµ x:U ∑ x ç Óâ1 § 0 < xÆ);
a(z_µ_tac THEN strip_tac THEN rewrite_tac[z_Óâ1_def, z_ç_Ó_thm]);
a(rewrite_tac[z_º_less_eq_thm]);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(contr_tac);
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac[z_less_clauses]);
pop_pc();
pop_thm()
));
=TEX
\subsection{Concerning ..}
=SML
val €z_high_dots_low_thm› = (
set_goal([],¨µ low high ∑ Òlow < high ¥ high .. low = {}ÆÆ);
push_merge_pcs ["z_sets_ext","'z_ç_rel"];
a(rewrite_tac[rewrite_rule[z_˙_def]z_dots_def, z_º_less_eq_thm]);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[z_less_trans_thm]);
a(contr_tac THEN all_asm_fc_tac [z_less_irrefl_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN all_var_elim_asm_tac);
a( all_asm_fc_tac [z_less_irrefl_thm]);
(* *** Goal "3" *** *)
a(contr_tac THEN all_asm_fc_tac [z_less_irrefl_thm]);
(* *** Goal "4" *** *)
a(contr_tac THEN all_var_elim_asm_tac);
a(contr_tac THEN all_asm_fc_tac [z_less_irrefl_thm]);
pop_thm());
=TEX
=SML
val €z_x_dots_x_thm› = (
set_goal([],¨µ x ∑ Òx .. x = {x}ÆÆ);
a(rewrite_tac[rewrite_rule[z_˙_def]z_dots_def]);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac [z_º_antisym_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_º_refl_thm]);
pop_pc();
pop_thm());
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 z_x_dots_x_thm;
in
val €z_dots_conv› : CONV = (fn tm =>
let	val (low,high) = dest_z_bin_op "z_dots_conv" 86001 (fst(dest_constÒ(_.._)Æ)) tm;
	val res = (
	if low =$ high
	then cnv1 tm
	else (if is_z_int low andalso is_z_int high
	then ((let val s1 = §_t_elim(z_less_conv (mk_z_less(high,low)));
	in
		¥_elim (list_simple_µ_elim[high,low]z_high_dots_low_thm) s1
	end)
	handle (Fail _) =>
	term_fail "z_dots_conv" 86001 [tm])
	else term_fail "z_dots_conv" 86001 [tm]));
in
	check_is_z_conv_result "z_dots_conv" res
end);
end;
=IGN
z_dots_conv Ò5 .. 5Æ;
z_dots_conv Ò7 .. 5Æ;
z_dots_conv ÒtrueÆ; (* fail *)
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 z_x_dots_x_thm;
	val thm1 = all_µ_intro(PC_C1 "z_sets_ext"
		rewrite_conv[rewrite_rule[z_˙_def]z_dots_def] Òx ç y .. zÆ);
	val cnv2 = simple_eq_match_conv1 thm1;
in
val €z_ç_dots_conv› : CONV = (fn tm =>
let	val (x,dots) = dest_z_ç tm
		handle (Fail _) =>
		term_fail "z_ç_dots_conv" 86002 [tm];
	val (low,high) = dest_z_bin_op "z_ç_dots_conv" 86002 (fst(dest_constÒ(_.._)Æ)) dots;
	val res = (
	if low =$ high
	then ((RIGHT_C cnv1) THEN_C z_ç_setd_conv) tm
	else (if is_z_int low andalso is_z_int high
	then ((let val s1 = §_t_elim(z_less_conv (mk_z_less(high,low)));
		val s2 = ¥_elim (list_simple_µ_elim[high,low]z_high_dots_low_thm) s1;
	in
		(RIGHT_C (fn _ => s2)  THEN_C z_ç_setd_conv) tm
	end)
	handle (Fail _) =>
	cnv2 tm)
	else cnv2 tm));
in
	check_is_z_conv_result "z_ç_dots_conv" res
end);
end;
=IGN
z_ç_dots_conv Òp ç 1 .. 0Æ;
z_ç_dots_conv Òp ç f z .. f zÆ;
z_ç_dots_conv Òp ç f z .. g zÆ;
=TEX
\section{PROOF CONTEXTS}
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	
=SML
val _ = delete_pc "'z_numbers" handle Fail _ => ();
val _ = new_pc "'z_numbers";
val _ = set_rw_eqn_cxt	
		[	(Òi + jÆ, z_plus_conv),
			(Òi * jÆ, z_times_conv),
			(Òi - jÆ, z_subtract_minus_conv),
			(Òabs iÆ, z_abs_conv),
			(Òi div jÆ, z_div_conv),
			(Òi mod jÆ, z_mod_conv),
			(Òi = jÆ, z_˙_eq_conv),
			(Òi º jÆ, z_º_conv),
			(Òi < jÆ, z_less_conv),
			(Òi æ jÆ, z_æ_º_conv),
			(Òi > jÆ, z_greater_less_conv),
			(Òi ç ÓÆ, z_ç_Ó_conv),
			(Òx .. yÆ, z_dots_conv),
			(Òp ç x .. yÆ, z_ç_dots_conv)
		] "'z_numbers";
val _ = add_rw_thms [z_plus_clauses, z_minus_clauses, z_º_clauses,
	 z_less_clauses, z_times_clauses, z_≥_º_thm,
	 z_ç_Óâ1_thm, z_≥_less_thm]
	"'z_numbers";
val pos = (thms_to_eqn_cxt[z_ç_Óâ1_thm,
		z_minus_clauses, 
		z_º_clauses, 
		z_less_clauses]) @
	[(Òi = jÆ, z_˙_eq_conv),
	(Òi ç ÓÆ, z_ç_Ó_conv),
	(Òi æ jÆ, z_æ_º_conv),
	(Òi > jÆ, z_greater_less_conv),
	(Òx ç y .. zÆ, z_ç_dots_conv)];
val neg = mapfilter (mk_≥ ** RAND_C) pos;
val neutral = thms_to_eqn_cxt[z_≥_º_thm, z_≥_less_thm] @
	[(Òi º jÆ, z_º_conv),
	(Òi < jÆ, z_less_conv)];

val €strip_eqn_cxt› = neutral @ pos @ neg;

val _ = set_st_eqn_cxt strip_eqn_cxt "'z_numbers";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'z_numbers";
val _ = set_u_simp_eqn_cxt (theory_u_simp_eqn_cxt"z_numbers") "'z_numbers";
val _ = set_pr_tac z_basic_prove_tac "'z_numbers";
val _ = set_pr_conv z_basic_prove_conv "'z_numbers";
val _ = commit_pc "'z_numbers";
=TEX
\section{FINITENESS}
=SML
local
	val s1 = (pure_rewrite_conv [z_Ê_def]) ÒÊ XÆ;
in
val €z_Ê_thm› = save_thm("z_Ê_thm",(all_z_µ_intro s1));
end;
=TEX
=SML
local
	val s1 = (pure_rewrite_conv [z_Êâ1_def]) ÒÊâ1 XÆ;
in
val €z_Êâ1_thm› = save_thm("z_Êâ1_thm",(all_z_µ_intro s1));
end;
=TEX
=SML
val €z_Ê_empty_thm› = save_thm("z_Ê_empty_thm",(
push_merge_pcs ["z_sets_ext","'z_ç_rel","'z_fun_alg","'z_numbers"];
set_goal([],ÒÊ {} =  {}Æ);
a (prove_tac[z_Ê_thm]);
a(asm_rewrite_tac[]);
a(z_∂_tac Ò0Æ THEN rewrite_tac[]);
a(z_∂_tac Ò{}Æ THEN rewrite_tac[]);
pop_pc();
pop_thm()
));
=TEX
=IGN
The following is not exposed or used, but is left "in case".
=IGN
val €z_º_plus_1_thm› = (
push_merge_pcs ["z_sets_ext","'z_ç_rel","'z_numbers"];
set_goal([],Òµ x, n:U∑ x º n + 1 § x º n ≤ x = n+1Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o once_rewrite_rule[z_get_spec Ò(_ < _)Æ]));
a(all_asm_fc_tac [z_º_antisym_thm]);
(* *** Goal "2" *** *)
a(asm_tac (prove_rule []Òn º n + 1Æ));
a(all_asm_fc_tac [z_º_trans_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
pop_pc();
pop_thm()
);
=TEX
=IGN
push_merge_pcs ["z_rel_ext","'z_numbers"];
set_goal([],Òµ x : U∑ Ê ¨Z'Setd xÆ =  ¨Z'Setd xÆÆ);
a(z_strip_tac THEN strip_tac);
a(rewrite_tac[z_Ê_thm]);
a(rewrite_tac[taut_rule ¨µ x y ∑ (x ± y § x) § (x ¥ y)Æ]);
a(list_induction_tac ¨xÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
a(REPEAT strip_tac);
a(asm_rewrite_tac[]);
a(z_∂_tac Ò0Æ THEN rewrite_tac[]);
a(z_∂_tac Ò{}Æ THEN rewrite_tac[]);
a(PC_T1 "z_fun_ext" rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT_N 3 z_strip_tac);
a(rewrite_tac[z'setd_def]);
a(PC_T1 "hol1" rewrite_tac[]);
a(strip_tac);
a(cases_tac Òx' ç ¨Z'Setd xÆÆ);
(* *** Goal "2.1" *** *)
a(lemma_tac Ò(µ x2 : U ∑ x2 ç x1 ¥ x2 ç ¨Z'Setd xÆ)Æ);
(* *** Goal "2.1.1" *** *)
a(REPEAT strip_tac);
a(asm_fc_tac[]);
a(all_var_elim_asm_tac);
(* *** Goal "2.1.2" *** *)
a(ASM_FC_T (MAP_EVERY asm_tac) []);
a(POP_ASM_T (rewrite_thm_tac o rewrite_rule[] o conv_rule z_≥_µ_conv));
(* *** Goal "2.2" *** *)
a(cases_tac Ò≥ x' ç x1Æ);
(* *** Goal "2.2.1" *** *)
a(lemma_tac Òµ x2 : U ∑ x2 ç x1 ¥ x2 ç ¨Z'Setd xÆÆ);
(* *** Goal "2.2.1.1" *** *)
a(REPEAT strip_tac);
a(asm_fc_tac[]);
a(all_var_elim_asm_tac);
(* *** Goal "2.2.1.2" *** *)
a(ASM_FC_T (MAP_EVERY asm_tac) []);
a(POP_ASM_T (rewrite_thm_tac o rewrite_rule[] o conv_rule z_≥_µ_conv));
(* *** Goal "2.2.2" *** *)
a(z_spec_nth_asm_tac 4 Òx1 \ {x'}Æ);
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 7 (fn _ => id_tac));
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(DROP_NTH_ASM_T 7 (fn _ => id_tac));
a(z_∂_tac Òn+1Æ);
a(rewrite_tac[]);
a(lemma_tac Ò0 º n+1Æ);
(* *** Goal "2.2.2.2.1" *** *)
a(asm_tac (prove_rule [] Òn º n+1Æ));
a(all_fc_tac[z_º_trans_thm]);
(* *** Goal "2.2.2.2.2" *** *)
a(REPEAT strip_tac);
a(z_∂_tac Òf ¿ {(n+1,x')}Æ);
a(rewrite_tac[]);
a(strip_tac);
(* *** Goal "2.2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac);
(* nasty *)
set_labelled_goal "2.2.2.2.2.2";
(* *** Goal "2.2.2.2.2.2" *** *)
a(REPEAT strip_tac THEN_TRY_T all_var_elim_asm_tac1);
a(z_spec_nth_asm_tac 3 Òx1'Æ);
(* *** Goal "2.2.2.2.2.2.1.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.2.1.2" *** *)
a(all_var_elim_asm_tac1);
(* *** Goal "2.2.2.2.2.2.1.3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a(z_spec_nth_asm_tac 3 Òx1'Æ);
(* *** Goal "2.2.2.2.2.2.2.1" *** *)
a(all_var_elim_asm_tac1);
a(z_∂_tacÒn+1Æ THEN rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2.2.2" *** *)
a(z_∂_tacÒx''Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2.2.3" *** *)
a(z_∂_tacÒx''Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.1" *** *)
(* back to nasty *)
WANT:
Ù µ a, b, c:U ∑ (a ¿ b) Ä c § (a Ä c) ± (b Ä c)
Ù µ a, b:U ∑ dom (a ¿ b) = dom a ¿ dom b
Ù µ m n ∑ m º n + 1 ¥ (m .. n+1) = (m .. n) ¿ {n+1}
and more work!
=TEX
\section{EPILOG}
=SML
end (* of structure ZNumbers *) ;
structure €ZNumbers› : ZNumbers = ZNumbers;
open ZNumbers;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
