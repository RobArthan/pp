% imp086.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Numbers and Finiteness}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP086}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
%\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\K.~Blackburn & WIN01}
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Numbers and Finiteness and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1] Initial Draft.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library numbers and finiteness, meeting the detailed design
given in \cite{DS/FMU/IED/DTD086}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD086}.
\subsection{Dependencies}
The mathematical toolkit for Z Library numbers and finiteness is introduced within the structure
$ZNumbers$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD086}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZNumbers$
(see\cite{DS/FMU/IED/DTD086}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZNumbers$}
The structure is split into two pieces to make it small enough for
the Poly/ML compiler. The signature constraint is placed on the
second structure.
=SML
structure €ZNumbers› = struct
=TEX
=SML
	val dummy = open_theory "z_numbers";
=TEX
Get the definitions:
=SML
	val z'˙_def = get_spec Ò(˙)Æ;
	val z'Ó_def = get_spec Ò(Ó)Æ;
	val z'arith_def = get_spec Ò(_ + _)Æ;
	val z'inequality_def = get_spec Ò(_ < _)Æ;
	val z'Óâ1_def = get_spec Ò(Óâ1)Æ;
	val z'succ_def = get_spec Ò(succ)Æ;
	val z'iter_def = get_spec Ò(iter)Æ;
	val z'dots_def = get_spec Ò(_ .. _)Æ;
	val z'Ê_def = get_spec Ò(Ê _)Æ;
	val z'Êâ1_def = get_spec Ò(Êâ1 _)Æ;
	val z'hash_def = get_spec Ò(#)Æ;
	val z'ü_def = get_spec Ò(_ ü _)Æ;
	val z'û_def = get_spec Ò(_ û _)Æ;
	val z'min_def = get_spec Ò(min)Æ;
	val z'max_def = get_spec Ò(max)Æ;
=TEX
=TEX
\documentstyle[11pt,hol1,TQa4]{article}
=SML
val _ = open_theory"z_numbers";
val _ = push_pc"z_predicates";
=TEX
=SML
val €z_more_pcs› = ["'z_tuples", "'z_ç_fun", "'z_ç_rel", "z_sets_ext"];
=TEX
Now we begin the proofs. First of all the following little lemma is required
in the absence of more powerful means for eliminating declarations
involving quantification over a given set.
=SML
val €˙_thm› = (
push_goal([], Ò˙ = UÆ);
a(rewrite_tac[get_specÒ˙Æ]);
pop_thm()
);
=TEX

=TEX
\subsection{The Additive Structure}
=SML
val €z_plus_def› = rewrite_rule[˙_thm, z_é_thm] (z_get_spec Ò(_+_)Æ);
=TEX
=SML
val €z_plus_comm_thm› = save_thm("z_plus_comm_thm", (
push_goal ([], Òµi, j : U∑ i + j = j + iÆ);
a(strip_asm_tac z_plus_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_plus_assoc_thm› = save_thm("z_plus_assoc_thm", (
push_goal ([], Òµi, j, k : U∑ (i + j) + k = i + (j + k)Æ);
a(strip_asm_tac z_plus_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_plus_assoc_thm1› = save_thm("z_plus_assoc_thm1", (
push_goal ([], Òµi, j, k : U∑ i + (j + k) = (i + j) + kÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv));
a(accept_tac z_plus_assoc_thm);
pop_thm()
));
=TEX
=SML
val €z_plus_order_thm› = save_thm("z_plus_order_thm", (
push_goal ([], Òµi : U∑ µ j, k : U∑
		j + i = i + j
	±	(i + j) + k = i + j + k
	±	j + i + k = i + j + kÆ);
a(strip_asm_tac z_plus_def);
a(asm_prove_tac[]);
a(rewrite_tac[z_plus_assoc_thm1, z_µ_elimÒ(i¶j, j¶i)Æz_plus_comm_thm]);
pop_thm()
));
=TEX
=SML
val €z_plus0_thm› = save_thm("z_plus0_thm", (
push_goal ([], Òµi : U∑
		i + 0 = i
	±	0 + i = iÆ);
a(strip_asm_tac z_plus_def);
a(rewrite_tac[z_µ_elimÒ(i¶0, j¶i∫˙)Æz_plus_comm_thm]);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_plus_minus_thm› = save_thm("z_plus_minus_thm", (
push_goal ([], Òµi : U∑
		i + ~i = 0
	±	~i + i = 0Æ);
a(strip_asm_tac z_plus_def);
a(rewrite_tac[z_µ_elimÒ(i¶ ~i, j¶i)Æz_plus_comm_thm]);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_Ó_thm› = save_thm("z_Ó_thm", (
push_goal ([], ÒÓ = • {s : U | 0 ç s ± {i : s ∑ i + 1} Ä s} ± ≥ ~1 ç ÓÆ);
a(REPEAT strip_tac THEN strip_asm_tac z_plus_def);
pop_thm()
));
=TEX
=SML
val €z_plus_cyclic_group_thm› = save_thm("z_plus_cyclic_group_thm", (
push_goal ([], Òµ h : U ∑ 1 ç h ± (µ i, j : h ∑ i + j ç h ± ~ i ç h) ¥ h = UÆ);
a(strip_asm_tac z_plus_def);
pop_thm()
));
=TEX
=SML
val  €z_int_homomorphism_thm› = save_thm("z_int_homomorphism_thm", (
push_goal([], ¨µi j∑ Z'Int (i + j) = Ò¨Z'Int iÆ + ¨Z'Int jÆÆÆ);
a(strip_tac);
a(induction_tac ¨iÆ);
(* *** Goal "1" *** *)
a(PC_T1"hol1"rewrite_tac[] THEN rewrite_tac[z_plus0_thm]);
(* *** Goal "2" *** *)
a(strip_tac THEN
	LEMMA_T ¨(i + 1) + j = (i + j) + 1Æ rewrite_thm_tac THEN1
	PC_T1"lin_arith" prove_tac[]);
a(asm_rewrite_tac[get_axiom"-""z'int_def"]);
a(rewrite_tac[z_plus_assoc_thm, z_µ_elimÒ1Æz_plus_order_thm]);
pop_thm()
));
=TEX
\subsection{Induction and Positive/Negative Case Analysis}
The results in the section need the more aggressive proof context.
=SML
val _ = push_merge_pcs z_more_pcs;
val  €z_˙_induction_thm› = save_thm("z_˙_induction_thm", (
push_goal([], ¨µp : ˙ ≠ BOOL∑
		p Ò1Æ
	±	(µi∑ p i ¥ p Ò~iÆ)
	±	(µi j∑ p i ± p j ¥ p Òi + jÆ)
	¥	(µm : ˙∑ p m)
Æ);
a(REPEAT strip_tac);
a(lemma_tacÒ{x : U | ¨p xÆ} = UÆ);
(* *** Goal "1" *** *)
a(bc_tac[conv_rule z_µ_elim_conv1 z_plus_cyclic_group_thm] THEN asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_˙_induction_tac› = gen_induction_tac z_˙_induction_thm;
=TEX
=SML
val  €z_Ó_induction_lemma› = (
push_goal([], ¨µp : ˙ ≠ BOOL∑
		p Ò0Æ
	±	(µi∑ p i ¥ p Òi + 1Æ)
	¥	µm∑ Òm ç ÓÆ ¥ p m
Æ);
a(rewrite_tac[z_Ó_thm] THEN REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o  z_µ_elimÒ{m:U|¨p mÆ}Æ));
a(all_asm_fc_tac[]);
a(PC_T1"prop_eq" asm_prove_tac[]);
pop_thm()
);
=TEX
=SML
val  €z_Ó_plus1_thm› = save_thm("z_Ó_plus1_thm", (
push_goal([], Òµi:Ó∑i + 1 ç ÓÆ);
a(rewrite_tac[z_Ó_thm, ˙_thm]);
a(REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o z_µ_elim Òi+1Æ));
a(POP_ASM_T (strip_asm_tac o z_µ_elim ÒiÆ));
pop_thm()
));
=TEX
=SML
val  €z_0_Ó_thm› = save_thm("z_0_Ó_thm", (
push_goal([], Ò0 ç ÓÆ);
a(asm_prove_tac[z_Ó_thm, ˙_thm]);
pop_thm()
));
=TEX
=SML
val  €z_Ó_induction_thm› = save_thm("z_Ó_induction_thm", (
push_goal([], ¨µp : ˙ ≠ BOOL∑
		p Ò0Æ
	±	(µi∑ Òi ç ÓÆ ± p i ¥ p Òi + 1Æ)
	¥	µm∑ Òm ç ÓÆ ¥ p m
Æ);
a(REPEAT strip_tac);
a(PC_T1 "hol1" strip_asm_tac
	(pc_rule1"hol"rewrite_rule[](µ_elim¨Ãj∑j ç ÒÓÆ ± p jÆ z_Ó_induction_lemma))
	THEN (SOLVED_T (asm_prove_tac[z_0_Ó_thm]) ORELSE all_fc_tac[z_Ó_plus1_thm]));
pop_thm()
));
=TEX
=SML
val €z_Ó_induction_tac› = gen_induction_tac1 z_Ó_induction_thm;
=TEX
=SML
val  €z_Ó_plus_thm› = save_thm("z_Ó_plus_thm", (
push_goal([], Òµi, j:Ó∑i + j ç ÓÆ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN z_Ó_induction_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_plus0_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_plus_assoc_thm1]);
a(all_fc_tac[z_Ó_plus1_thm]);
pop_thm()
));
=TEX
=SML
val €z_˙_eq_thm› = save_thm("z_˙_eq_thm", (
push_goal([], Òµi, j:U∑i = j § i + ~j = 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[z_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T Ò(i + ~j) + j = jÆ ante_tac THEN1 asm_rewrite_tac[z_plus0_thm]);
a(rewrite_tac[z_plus_assoc_thm, z_plus_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val €z_minus_thm› = save_thm("z_minus_thm", (
push_goal([], Òµi, j:U∑~ ~i = i ± i + ~i = 0 ± ~i + i = 0 ± ~(i + j) = ~i + ~j ± ~0 = 0Æ);
a(rewrite_tac[z_plus_minus_thm]);
a(LEMMA_TÒµi, j:U∑~ ~i = iÆ (fn th => rewrite_tac[th] THEN asm_tac th)
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(once_rewrite_tac[z_˙_eq_thm] THEN rewrite_tac[z_plus_minus_thm]);
(* *** Goal "2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[z_˙_eq_thm]);
a(asm_rewrite_tac[]);
a(rewrite_tac[z_µ_elimÒ~iÆz_plus_order_thm] THEN rewrite_tac[z_µ_elimÒiÆz_plus_order_thm]);
a(rewrite_tac[z_plus_minus_thm, z_plus0_thm]);
(* *** Goal "3" *** *)
a(LEMMA_TÒ0 + ~0 = 0Æ (accept_tac o rewrite_rule[z_plus0_thm]));
a(rewrite_tac[z_plus_minus_thm]);
pop_thm()
));
=TEX
=SML
val €z_Ó_cases_thm› = save_thm("z_Ó_cases_thm", (
push_goal([], Òµi:Ó∑i = 0 ≤ (∂j:Ó∑i = j + 1)Æ);
a(REPEAT strip_tac THEN all_asm_ante_tac);
a(z_Ó_induction_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_∂_tacÒ0Æ THEN asm_rewrite_tac[]);
a(accept_tac z_0_Ó_thm);
(* *** Goal "2" *** *)
a(z_∂_tacÒiÆ THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €z_˙_cases_lemma› = (
push_goal([], Òµi, j: U| i ç Ó ± ~j ç Ó ± ≥i + j ç Ó ∑ ~(i + j) ç ÓÆ);
a(REPEAT strip_tac);
a(all_asm_ante_tac);
a(z_Ó_induction_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_plus0_thm] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(strip_tac);
(* *** Goal "3" *** *)
a(rewrite_tac[z_µ_elim ÒjÆ z_plus_order_thm]);
a(rewrite_tac[z_µ_elim ÒiÆ z_plus_order_thm] THEN rewrite_tac[z_plus_assoc_thm1]);
a(REPEAT strip_tac THEN all_asm_fc_tac[z_Ó_plus1_thm]);
(* *** Goal "4" *** *)
a(all_asm_ante_tac THEN rewrite_tac[z_minus_thm] THEN REPEAT strip_tac);
a(lemma_tacÒ≥ ~i + ~j = 0Æ);
(* *** Goal "4.1" *** *)
a(conv_tac (RAND_C eq_sym_conv) THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_plus0_thm, z_minus_thm]);
a(swap_nth_asm_concl_tac 1 THEN rewrite_tac[z_µ_elimÒjÆz_plus_order_thm]);
a(rewrite_tac[z_µ_elimÒiÆz_plus_order_thm]);
a(asm_rewrite_tac[z_plus_assoc_thm1]);
a(strip_asm_tac z_0_Ó_thm THEN all_fc_tac[z_Ó_plus1_thm]);
(* *** Goal "4.2" *** *)
a(all_fc_tac[z_Ó_cases_thm]);
a(rewrite_tac[z_µ_elimÒ~jÆz_plus_order_thm]);
a(rewrite_tac[z_µ_elimÒ~iÆz_plus_order_thm]);
a(asm_rewrite_tac[z_plus_assoc_thm1]);
a(asm_rewrite_tac[z_plus_assoc_thm, z_plus_minus_thm, z_plus0_thm]);
pop_thm()
);
=TEX
=SML
val €z_≥_Ó_thm› = save_thm("z_≥_Ó_thm", (
push_goal([], Òµi:U∑≥i ç Ó ¥ ~i ç ÓÆ);
a(strip_tac THEN strip_tac);
a(z_˙_induction_tac ÒiÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_TÒ0 + 1 ç Ó Æ (strip_asm_tac o rewrite_rule[z_plus0_thm]));
a(strip_asm_tac z_0_Ó_thm THEN asm_fc_tac [z_Ó_plus1_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z_minus_thm]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[z_Ó_plus_thm]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[z_˙_cases_lemma]);
(* *** Goal "5" *** *)
a(POP_ASM_T ante_tac THEN once_rewrite_tac[z_plus_comm_thm] THEN strip_tac);
a(strip_asm_tac(z_µ_elimÒ(i¶j, j¶i)Æz_˙_cases_lemma));
(* *** Goal "6" *** *)
a(rewrite_tac[z_minus_thm]);
a(all_asm_fc_tac[z_Ó_plus_thm]);
pop_thm()
));
=TEX
=SML
val €z_˙_cases_lemma› = (
push_goal([], Ò˙ = Ó ¿ {s:Ó∑~s}Æ);
a(asm_tac z_≥_Ó_thm);
a(rewrite_tac[˙_thm] THEN REPEAT strip_tac);
a(z_∂_tacÒ~ x1Æ);
a(all_asm_fc_tac[]);
a(REPEAT strip_tac);
a(rewrite_tac[z_minus_thm]);
pop_thm()
);
=TEX
=SML
val €z_˙_cases_lemma1› = (
push_goal([], Ò˙ = Ó ¿ {s:Ó \ {0}∑~s}Æ);
a(rewrite_tac[z_˙_cases_lemma] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_∂_tacÒsÆ THEN REPEAT strip_tac);
a(CONTR_T (fn th => all_asm_ante_tac THEN rewrite_thm_tac th));
a(rewrite_tac[z_0_Ó_thm, z_minus_thm]);
a(STRIP_CONCL_T (asm_tac o eq_sym_rule));
a(asm_rewrite_tac[z_0_Ó_thm]);
(* *** Goal "2" *** *)
a(z_∂_tacÒsÆ THEN REPEAT strip_tac);
pop_thm()
);
=TEX
=SML
val €z_˙_cases_thm› = save_thm("z_˙_cases_thm", (
push_goal([], Òµi : U∑∂j:Ó∑i = j ≤ i = ~jÆ);
a(once_rewrite_tac [eq_sym_rule ˙_thm]);
a(rewrite_tac[z_˙_cases_lemma] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tacÒsÆ THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €z_Ó_≥_plus1_thm› = save_thm("z_Ó_≥_plus1_thm", (
push_goal([], Òµi:Ó ∑ ≥i + 1 = 0Æ);
a(REPEAT strip_tac);
a(swap_nth_asm_concl_tac 1);
a(lemma_tac Òi = ~1Æ);
(* *** Goal "1" *** *)
a(once_rewrite_tac[z_˙_eq_thm]);
a(asm_rewrite_tac[z_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[±_right_elim z_Ó_thm]);
pop_thm()
));
=TEX
=SML
val €z_˙_cases_thm1› = save_thm("z_˙_cases_thm1", (
push_goal([], Òµi:U∑i ç Ó ≤ (∂j:Ó∑ i = ~(j+1))Æ);
a(strip_tac THEN strip_tac);
a(conv_tac (LEFT_C(LEFT_C(pure_once_rewrite_conv[pure_once_rewrite_rule[˙_thm]z_˙_cases_lemma1]))));
a(REPEAT strip_tac);
a(all_fc_tac[z_Ó_cases_thm]);
a(z_∂_tacÒjÆ THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (asm_rewrite_thm_tac o eq_sym_rule));
pop_thm()
));
=TEX
=SML
val €z_Ó_≥_minus_thm› = save_thm("z_Ó_≥_minus_thm", (
push_goal([], Òµi:Ó ∑ i = 0 ≤ ≥ ~i ç ÓÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(z_µ_elimÒiÆz_Ó_cases_thm));
a(LIST_DROP_NTH_ASM_T [3,4] (MAP_EVERY ante_tac));
a(POP_ASM_T rewrite_thm_tac);
a(REPEAT strip_tac);
a(lemma_tacÒ(j + ~(j + 1)) + 1 = 0Æ);
a(rewrite_tac[z_µ_elimÒ1Æz_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm]);
a(strip_asm_tac(z_µ_elimÒ(i¶j, j¶ ~(j+1))Æz_Ó_plus_thm));
a(strip_asm_tac(z_µ_elimÒj + ~ (j + 1)Æz_Ó_plus1_thm));
a(all_fc_tac[z_Ó_≥_plus1_thm]);
pop_thm()
));
val _ = pop_pc();
=TEX
\subsection{Multiplicative Structure}
=SML
val €z_times_def› = rewrite_rule[˙_thm] (z_get_spec Ò(_*_)Æ);
=TEX
=SML
val €z_times_comm_thm› = save_thm("z_times_comm_thm", (
push_goal ([], Òµi, j : U∑ i * j = j * iÆ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times_assoc_thm› = save_thm("z_times_assoc_thm", (
push_goal ([], Òµi, j, k : U∑ (i * j) * k = i * (j * k)Æ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times_assoc_thm1› = save_thm("z_times_assoc_thm1", (
push_goal ([], Òµi, j, k : U∑ i * (j * k) = (i * j) * kÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv));
a(accept_tac z_times_assoc_thm);
pop_thm()
));
=TEX
=SML
val €z_times_order_thm› = save_thm("z_times_order_thm", (
push_goal ([], Òµi : U∑ µ j, k : U∑
		j * i = i * j
	±	(i * j) * k = i * j * k
	±	j * i * k = i * j * kÆ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
a(rewrite_tac[z_times_assoc_thm1, z_µ_elimÒ(i¶j, j¶i)Æz_times_comm_thm]);
pop_thm()
));
=TEX
=SML
val €z_times1_thm› = save_thm("z_times1_thm", (
push_goal ([], Òµi : U∑
		i * 1 = i
	±	1 * i = iÆ);
a(strip_asm_tac z_times_def);
a(rewrite_tac[z_µ_elimÒ(i¶i∫˙, j¶1)Æz_times_comm_thm]);
a(asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times_plus_distrib_thm› = save_thm("z_times_plus_distrib_thm", (
push_goal ([], Òµi, j, k : U∑
		i*(j + k) = i*j + i*k
	±	(i + j)*k = i*k + j*kÆ);
a(strip_asm_tac z_times_def);
a(asm_prove_tac[]);
a(once_rewrite_tac[z_times_comm_thm] THEN asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val €z_times0_thm› = save_thm("z_times0_thm", (
push_goal([], Òµi:U∑0*i = 0 ± i*0 = 0Æ);
a(rewrite_tac[z_µ_elimÒi∫˙Æz_times_order_thm]);
a(REPEAT strip_tac);
a(LEMMA_T Òi*(0 + 1) = iÆ (strip_asm_tac o
	rewrite_rule[z_times1_thm, z_plus_assoc_thm, z_plus_minus_thm, z_plus0_thm] o
	once_rewrite_rule[z_˙_eq_thm] o
	rewrite_rule[z_times_plus_distrib_thm]));
a(rewrite_tac[z_plus0_thm, z_times1_thm]);
pop_thm()
));
=TEX
=SML
val €z_minus_times_thm› = save_thm("z_minus_times_thm", (
push_goal([], Òµi, j:U∑(~i)*j = ~(i*j) ± i*(~j) = ~(i*j) ± (~i)*(~j) = i*jÆ);
a(lemma_tacÒµi, j:U∑(~i)*j = ~(i*j)Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(once_rewrite_tac[z_˙_eq_thm] THEN rewrite_tac[z_minus_thm]);
a(LEMMA_TÒ~ i * j + i * j = (~i + i) * jÆ rewrite_thm_tac
	THEN1 rewrite_tac[z_times_plus_distrib_thm]);
a(rewrite_tac[z_plus_minus_thm, z_times0_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(lemma_tacÒµi, j:U∑i*(~j) = ~(i*j)Æ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(rewrite_tac[z_µ_elimÒjÆz_times_order_thm]);
a(asm_rewrite_tac[z_µ_elimÒ~jÆz_times_order_thm]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[z_minus_thm]);
pop_thm()
));
=TEX
=SML
val €z_Ó_times_thm› = save_thm("z_Ó_times_thm", (
push_goal([], Òµi, j:Ó∑i*j ç ÓÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a(z_Ó_induction_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_times0_thm, z_0_Ó_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_times_plus_distrib_thm, z_times1_thm]);
a(all_asm_fc_tac[z_Ó_plus_thm]);
pop_thm()
));
=TEX
=SML
val €z_times_eq_0_thm› = save_thm("z_times_eq_0_thm", (
push_goal([], Òµi, j:U∑i*j = 0 § i = 0 ≤ j = 0Æ);
a(lemma_tacÒµa, b:Ó ∑ a*b = 0 ¥ a = 0 ≤ b = 0Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elimÒaÆz_Ó_cases_thm));
a(strip_asm_tac (z_µ_elimÒbÆz_Ó_cases_thm));
a(asm_ante_tac Òa * b = 0Æ THEN
	asm_rewrite_tac[z_times_plus_distrib_thm, z_times1_thm, z_plus_assoc_thm1]);
a(LIST_DROP_NTH_ASM_T [7,6,5,3,1] (fn _ => id_tac));
a(rename_tac[(ÒjÆ, "m"), (¨j'Æ, "n")] THEN all_fc_tac [z_Ó_times_thm]);
a(LIST_DROP_NTH_ASM_T [4,2,1] (fn _ => id_tac));
a(all_fc_tac[z_Ó_plus_thm]);
a(LIST_DROP_NTH_ASM_T [10,9,8,7,5,4,3,2,1] (fn _ => id_tac));
a(all_fc_tac[z_Ó_plus_thm]);
a(LIST_DROP_NTH_ASM_T [12,11,10,9,8,7,6,5,4,2,1] (fn _ => id_tac));
a(all_fc_tac[z_Ó_plus1_thm]);
a(strip_tac THEN all_fc_tac[z_Ó_≥_plus1_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN TRY_T (asm_rewrite_tac[z_times0_thm]));
a(strip_asm_tac (z_µ_elimÒiÆz_˙_cases_thm)
	THEN strip_asm_tac (z_µ_elimÒjÆz_˙_cases_thm));
(* *** Goal "2.1" *** *)
a(PC_T1"prop_eq"asm_prove_tac[]);
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(asm_ante_tac Òi*j=0Æ THEN asm_rewrite_tac[z_minus_times_thm]);
a(conv_tac(ONCE_MAP_C eq_sym_conv)THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm] THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 Ò(a¶j',b¶j'')Æ);
a(PC_T1"prop_eq"asm_prove_tac[]);
(* *** Goal "2.3" *** *)
a(asm_ante_tac Òi*j=0Æ THEN asm_rewrite_tac[z_minus_times_thm]);
a(conv_tac(LEFT_C(ONCE_MAP_C eq_sym_conv))THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm] THEN REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 Ò(a¶j',b¶j'')Æ);
a(asm_ante_tac Ò≥ i = 0Æ THEN asm_rewrite_tac[z_minus_thm]);
(* *** Goal "2.4" *** *)
a(asm_ante_tac Òi*j=0Æ THEN asm_rewrite_tac[z_minus_times_thm]);
a(REPEAT strip_tac);
a(asm_ante_tac Ò≥i=0Æ THEN asm_rewrite_tac[]);
a(conv_tac(ONCE_MAP_C eq_sym_conv)THEN once_rewrite_tac[z_˙_eq_thm]);
a(rewrite_tac[z_minus_thm, z_plus0_thm]);
a(strip_tac);
a(all_asm_fc_tac[]);
pop_thm()
));
=TEX
We need to break off here to prevent the structure becoming too large for
the Poly/ML compiler.
=SML
end (* of structure ZNumbers *);
structure €ZNumbers› : ZNumbers = struct
open ZNumbers;
=TEX
\subsection{Inequalities}
=SML
val  €z_º_trans_thm› = save_thm("z_º_trans_thm", (
push_goal([], Òµi, j, k : U | i º j º k ∑ i º kÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ)] THEN REPEAT strip_tac);
a(rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n")]  THEN all_fc_tac [z_Ó_plus_thm]);
a(asm_ante_tac Ò(k - n) + n - m ç ÓÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(rewrite_tac[
	prove_rule[z_plus_assoc_thm]
		Òµa,b,c,d:U∑(a + b) + c + d = (a + b + c) + dÆ,
	z_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val  €z_less_trans_thm› = save_thm("z_less_trans_thm", (
push_goal([], Òµi, j, k : U | i < j < k ∑ i < kÆ);
a(once_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ)] THEN REPEAT strip_tac);
a(lemma_tacÒj º j + 1Æ THEN rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n"), (ÒkÆ, "l")]
	THEN fc_tac [z_º_trans_thm] THEN asm_fc_tac[] THEN asm_fc_tac[]);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(rewrite_tac[z_µ_elim Ò~nÆ z_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm]);
a(strip_asm_tac z_0_Ó_thm THEN all_fc_tac [z_Ó_plus1_thm]);
pop_thm()
));
=TEX
=SML
val  €z_less_º_trans_thm› = save_thm("z_less_º_trans_thm", (
push_goal([], Òµi, j, k : U | i < j º k ∑ i < kÆ);
a(REPEAT strip_tac);
a(asm_ante_tac Òi < jÆ THEN
	once_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ)] THEN
	REPEAT strip_tac);
a(rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n"), (ÒkÆ, "l")]
	THEN fc_tac [z_º_trans_thm] THEN asm_fc_tac[] THEN asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val  €z_º_less_trans_thm› = save_thm("z_º_less_trans_thm", (
push_goal([], Òµi, j, k : U | i º j < k ∑ i < kÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]
		THEN REPEAT strip_tac);
a(rename_tac[(ÒiÆ, "m"), (ÒjÆ, "n")]  THEN all_fc_tac [z_Ó_plus_thm]);
a(asm_ante_tacÒ(k + ~ (n + 1)) + n + ~ m ç ÓÆ THEN rewrite_tac[z_minus_thm]);
a(rewrite_tac[z_µ_elim Ò~nÆ z_plus_order_thm]);
a(rewrite_tac[z_µ_elim ÒnÆ z_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm]);
a(rewrite_tac[z_µ_elim Ò~1Æ z_plus_order_thm]);
pop_thm()
));
=TEX
=SML
val  €z_minus_Ó_º_thm› = save_thm("z_minus_Ó_º_thm", (
push_goal([], Òµi : U; j : Ó ∑ i + ~j º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_plus_assoc_thm1,
	z_minus_thm, z_plus0_thm] THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val  €z_º_plus_Ó_thm› = save_thm("z_º_plus_Ó_thm", (
push_goal([], Òµi : U; j : Ó ∑ i  º i + jÆ);
a(REPEAT strip_tac);
a(asm_rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ),
	z_µ_elimÒjÆz_plus_order_thm, z_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val  €z_º_cases_thm› = save_thm("z_º_cases_thm", (
push_goal([], Òµi, j : U ∑ i º j ≤ j º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(REPEAT strip_tac);
a(all_fc_tac[z_≥_Ó_thm]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[z_minus_thm] o
	once_rewrite_rule[z_plus_comm_thm]));
pop_thm()
));
=TEX
=SML
val  €z_º_refl_thm› = save_thm("z_º_refl_thm", (
push_goal([], Òµi : U ∑ i º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_minus_thm, z_0_Ó_thm]);
pop_thm()
));
=TEX
=SML
val  €z_0_º_Ó_thm› = save_thm("z_0_º_Ó_thm", (
push_goal([], Òµi : U ∑ 0 º i § i ç ÓÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_minus_thm, z_plus0_thm]);
pop_thm()
));
=TEX
=SML
val  €z_º_º_0_thm› = save_thm("z_º_º_0_thm", (
push_goal([], Òµi, j : U ∑ i º j § i + ~j º 0Æ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_plus0_thm]);
a(rewrite_tac[z_minus_thm]);
a(rewrite_tac[z_µ_elimÒ~iÆz_plus_order_thm]);
pop_thm()
));
=TEX
=SML
val  €z_º_antisym_lemma› = (
push_goal([], Òµi : U | i º 0 ± ~i º 0 ∑ i = 0Æ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ), z_plus0_thm, z_minus_thm]);
a(REPEAT strip_tac);
a(fc_tac[z_Ó_≥_minus_thm]);
pop_thm()
);
=TEX
=SML
val €z_º_antisym_thm› = save_thm("z_º_antisym_thm", (
push_goal([], Òµi, j : U | i º j ± j º i ∑ i = jÆ);
a(once_rewrite_tac[z_º_º_0_thm]);
a(z_µ_tac);
a(rewrite_tac[prove_rule[z_minus_thm, z_µ_elimÒjÆz_plus_order_thm]
	Òj+ ~i = ~(i+ ~j)Æ]);
a(REPEAT strip_tac);
a(all_fc_tac[z_º_antisym_lemma]);
a(once_rewrite_tac[z_˙_eq_thm] THEN strip_tac);
pop_thm()
));
=TEX
\subsection{Theorems about $abs$}
=SML
val  €z_abs_thm› = save_thm("z_abs_thm", (
push_goal([], Òµi:Ó∑abs i = i ± abs ~i = iÆ);
a(strip_asm_tac (z_get_specÒ(abs_)Æ));
a(strip_asm_tac (nth 1 (strip_±_rule (z_get_specÒ(~_)Æ))));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tacÒi ç ˙Æ THEN1 rewrite_tac[˙_thm]);
a(fc_tac[z_≠_ç_rel_§_app_eq_thm] THEN asm_fc_tac[]);
a(LEMMA_T Ò(i, i) ç (abs_)Æ (fn th => asm_tac th THEN asm_fc_tac[]));
a(asm_rewrite_tac[] THEN MERGE_PCS_T1 z_more_pcs asm_prove_tac[]);
(* *** Goal "2" *** *)
a(lemma_tacÒ~i ç ˙Æ THEN1 rewrite_tac[˙_thm]);
a(fc_tac[z_≠_ç_rel_§_app_eq_thm] THEN asm_fc_tac[]);
a(LEMMA_T Ò(~i, i) ç (abs_)Æ (fn th => asm_tac th THEN asm_fc_tac[]));
a(asm_rewrite_tac[] THEN MERGE_PCS_T1 z_more_pcs REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(ALL_FC_T rewrite_tac [z_Ó_≥_minus_thm]);
a(rewrite_tac[z_0_Ó_thm, z_minus_thm]);
(* *** Goal "2.2" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac);
a(LIST_DROP_NTH_ASM_T [9,8,6,5,4,3,2,1] (fn _=> id_tac));
a(lemma_tacÒ~i ç ˙ ± ~ ~i = iÆ THEN1 rewrite_tac[z_minus_thm, ˙_thm]);
a(all_fc_tac[z_≠_app_eq_§_ç_rel_thm] THEN REPEAT strip_tac);
(* *** Goal "2.3" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac);
a(LIST_DROP_NTH_ASM_T [9,8,6,4,3,2,1] (fn _=> id_tac));
a(lemma_tacÒ~i ç ˙ ± ~ ~i = iÆ THEN1 rewrite_tac[z_minus_thm, ˙_thm]);
a(all_fc_tac[z_≠_app_eq_§_ç_rel_thm] THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val  €z_abs_minus_thm› = save_thm("z_abs_minus_thm", (
push_goal([], Òµi:U∑abs ~i = abs iÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_abs_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_minus_thm]);
a(ALL_FC_T rewrite_tac[z_abs_thm]);
(* *** Goal "2" *** *)
pop_thm()
));
=TEX
=SML
val  €z_abs_Ó_thm› = save_thm("z_abs_Ó_thm", (
push_goal([], Òµi:U∑abs i ç ÓÆ);
a(REPEAT strip_tac THEN strip_asm_tac (z_µ_elimÒi∫˙Æz_˙_cases_thm)
	THEN asm_rewrite_tac[] THEN ALL_FC_T asm_rewrite_tac[z_abs_thm]);
pop_thm()
));
=TEX
=SML
val  €z_abs_times_thm› = save_thm("z_abs_times_thm", (
push_goal([], Òµi, j:U∑abs (i * j) = abs i * abs jÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm)
	THEN strip_asm_tac (z_µ_elim ÒjÆ z_˙_cases_thm)
	THEN asm_rewrite_tac[z_minus_times_thm, z_abs_minus_thm]
	THEN all_fc_tac[z_Ó_times_thm]
	THEN ALL_FC_T rewrite_tac[z_abs_thm]);
pop_thm()
));
=TEX
In the following proof of the triangle inequality,
the second and third cases (subgoals 2.3 and 2.4)
of the main case split are virtually the same (as in
fact are the first and fourth, but their proofs are short). The lemma in
the second line of the proof is the second case.
=SML
val  €z_abs_plus_thm› = save_thm("z_abs_plus_thm", (
push_goal([], Òµi, j:U∑abs (i + j) º abs i + abs jÆ);
a(REPEAT strip_tac);
a(lemma_tacÒµi, j, j', j'': U∑
		j' ç Ó ¥ i = j' ¥ j'' ç Ó ¥ j = ~ j''
	¥	abs (j' + ~ j'') º abs j' + abs ~ j''Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim Òj' + ~j''Æ z_˙_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(ALL_FC_T rewrite_tac[z_abs_thm]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_tac[conv_rule z_µ_elim_conv1 z_º_trans_thm]);
a(∂_tacÒj'Æ);
a(all_fc_tac[z_minus_Ó_º_thm, z_º_plus_Ó_thm]);
a(asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(ALL_FC_T rewrite_tac[z_abs_thm]);
a(LEMMA_T Ò~ ~j''' = ~(j' + ~ j'')Æ
	(rewrite_thm_tac o rewrite_rule[z_minus_thm])
	THEN1 POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(bc_tac[conv_rule z_µ_elim_conv1 z_º_trans_thm]);
a(∂_tacÒj''Æ);
a(all_fc_tac[z_minus_Ó_º_thm, z_º_plus_Ó_thm]);
a(once_rewrite_tac [z_plus_comm_thm]);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm)
	THEN strip_asm_tac (z_µ_elim ÒjÆ z_˙_cases_thm)
	THEN asm_rewrite_tac[]
	THEN_LIST [id_tac, id_tac, once_rewrite_tac [z_plus_comm_thm], id_tac]);
(* *** Goal "2.1" *** *)
a(all_fc_tac[z_Ó_plus_thm] THEN ALL_FC_T rewrite_tac[z_abs_thm]
	THEN rewrite_tac[z_º_refl_thm]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.3" *** *)
a(rename_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a(rewrite_tac[prove_rule[z_minus_thm]Ò~j' + ~j'' = ~(j' + j'')Æ,
	z_abs_minus_thm]);
a(all_fc_tac[z_Ó_plus_thm] THEN ALL_FC_T rewrite_tac[z_abs_thm]
	THEN rewrite_tac[z_º_refl_thm]);
pop_thm()
));
=TEX
=SML
val  €z_abs_eq_0_thm› = save_thm("z_abs_eq_0_thm", (
push_goal([], Òµi:U∑abs i = 0 § i = 0Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_˙_cases_thm));
(* *** Goal "1.1" *** *)
a(PC_T1"prop_eq" asm_prove_tac[]);
a(all_fc_tac[z_abs_thm]);
a(PC_T1"prop_eq" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(asm_ante_tac Òabs i = 0Æ THEN POP_ASM_T rewrite_thm_tac);
a(all_fc_tac[z_abs_thm]);
a(asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[z_minus_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac z_0_Ó_thm THEN all_fc_tac[z_abs_thm]);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val  €z_Ó_abs_minus_thm› = save_thm("z_Ó_abs_minus_thm", (
push_goal([], Òµi, j:Ó | j º i ∑abs (i + ~j) º iÆ);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]);
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_abs_thm]);
a(asm_rewrite_tac[z_minus_thm, z_plus_assoc_thm1, z_plus0_thm]);
pop_thm()
));
=TEX
\subsection{Theorems about $div$ and $mod$}
=TEX
=SML
val  €z_div_mod_unique_lemma1› = (
push_goal([], Òµi, j : Ó ∑ i*j < j ¥ i = 0Æ);
a(REPEAT strip_tac);
a(strip_asm_tac (z_µ_elim ÒiÆ z_Ó_cases_thm));
a(asm_ante_tacÒi * j < jÆ THEN asm_rewrite_tac[z_times_plus_distrib_thm, z_times1_thm]);
a(rewrite_tac[rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ),
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ),
	z_minus_thm]);
a(rewrite_tac[z_µ_elim Ò~jÆz_plus_order_thm]);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm]);
a(LIST_DROP_NTH_ASM_T [1,4] (fn _ => id_tac));
a(all_fc_tac[z_Ó_times_thm]);
a(LIST_DROP_NTH_ASM_T [1,3,4,5] (fn _ => id_tac));
a(rename_tac[(ÒjÆ, "m")]);
a(strip_tac THEN all_fc_tac[z_Ó_plus_thm]);
a(asm_ante_tacÒj' * m + ~ (j' * m) + ~ 1 ç ÓÆ);
a(rewrite_tac[z_plus_assoc_thm1, z_minus_thm, z_plus0_thm, 
	±_right_elim z_Ó_thm]);
pop_thm()
);
=SML
val  €z_div_mod_unique_lemma2› = (
push_goal([], Òµj, d, r:U | ≥j = 0 ∑ 
		(d*j + r = 0 ± 0 º r < abs j)
	¥	d = 0 ± r = 0Æ);
a(REPEAT_UNTIL is_± strip_tac);
a(LEMMA_T Òd = 0Æ (
	fn th => asm_ante_tac Òd * j + r = 0Æ THEN
	rewrite_tac[th, z_times0_thm, z_plus0_thm]));
a(LEMMA_T Òabs(d*j) = 0Æ 
	(strip_asm_tac o rewrite_rule[z_abs_times_thm, z_abs_eq_0_thm, z_times_eq_0_thm]));
a(LEMMA_T Òabs(d*j) < abs jÆ (strip_asm_tac o rewrite_rule[z_abs_times_thm]));
(* *** Goal "1" *** *)
a(once_rewrite_tac[
	prove_rule[z_plus_assoc_thm,
		z_minus_thm, z_plus0_thm]Òd*j = (d*j + r) + ~rÆ]);
a(bc_tac[conv_rule z_µ_elim_conv1 z_º_less_trans_thm]);
a(∂_tacÒrÆ);
a(asm_ante_tac Ò0 º rÆ THEN asm_rewrite_tac[z_0_º_Ó_thm, z_plus0_thm]);
a(strip_tac THEN ALL_FC_T rewrite_tac [z_abs_thm]);
a(rewrite_tac[z_º_refl_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_abs_times_thm]);
a(strip_asm_tac (z_µ_elimÒdÆ z_abs_Ó_thm));
a(strip_asm_tac (z_µ_elimÒjÆ z_abs_Ó_thm));
a(all_fc_tac [z_Ó_times_thm]);
a(ALL_FC_T rewrite_tac [z_div_mod_unique_lemma1]);
a(rewrite_tac[z_times0_thm]);
pop_thm()
);
=TEX
=SML
val  €z_div_mod_unique_lemma3› = (
push_goal([], Òµi, j, d, r, D, R:U | ≥j = 0 ∑ 
		(D*j + R = d*j + r ± 0 º r º R < abs j)
	¥	D = d ± R = rÆ);
a(REPEAT_UNTIL is_± strip_tac);
a(GET_ASM_TÒD*j + R = d*j + rÆ (ante_tac o once_rewrite_rule[z_˙_eq_thm]));
a(LEMMA_TÒ(D * j + R) + ~ (d * j + r) = (D + ~d)*j + (R + ~r)Æ rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_minus_thm, z_times_plus_distrib_thm, z_minus_times_thm, z_plus_assoc_thm]);
a(rewrite_tac[z_µ_elim ÒRÆ z_plus_order_thm]);
(* *** Goal "2" *** *)
a(GET_ASM_TÒ0 º rÆ(asm_tac o rewrite_rule [z_0_º_Ó_thm]));
a(LEMMA_TÒ0 º RÆ (fn th => asm_tac(rewrite_rule[z_0_º_Ó_thm] th) THEN asm_tac th)
	THEN1 all_fc_tac[z_º_trans_thm]);
a(strip_asm_tac (z_µ_elimÒ(i¶R,j¶r)Æ z_Ó_abs_minus_thm));
a(GET_ASM_TÒr º RÆ (asm_tac o rewrite_rule[
	rewrite_rule[˙_thm](z_get_specÒ(_º_)Æ), 
	rewrite_rule[˙_thm](z_get_specÒ(_-_)Æ)]));
a(strip_asm_tac(z_µ_elimÒR + ~ rÆ z_abs_thm));
a(POP_ASM_T(fn _ => POP_ASM_T (fn th => GET_NTH_ASM_T 2 (asm_tac o rewrite_rule[th]))));
a(GET_ASM_T ÒR + ~ r ç ÓÆ
	(asm_tac o rewrite_rule[conv_rule (ONCE_MAP_C eq_sym_conv) z_0_º_Ó_thm]));
a(strip_asm_tac (z_µ_elimÒ(i¶R + ~ r,j¶R,k¶abs j)Æ z_º_less_trans_thm));
a(strip_tac THEN
	strip_asm_tac (z_µ_elimÒ(j¶j,d¶D+ ~d,r¶R + ~r)Æ z_div_mod_unique_lemma2));
a(once_rewrite_tac[z_˙_eq_thm] THEN REPEAT strip_tac);
pop_thm()
);
=TEX
=SML
val  €z_div_mod_unique_thm› = save_thm("z_div_mod_unique_thm", (
push_goal([], Òµi, j, d, r:U | ≥j = 0 ∑ 
		(i = d*j + r ± 0 º r < abs j)
	§	(d = i div j ± r = i mod j)Æ);
a(REPEAT_N 9 strip_tac);
a(MERGE_PCS_T1 z_more_pcs strip_asm_tac (z_µ_elim Ò(i¶i,j¶j)Æ
	(rewrite_rule[˙_thm](±_right_elim(z_get_specÒ(_div_)Æ)))));
a(strip_asm_tac (z_µ_elim Ò(i¶r,j¶i mod j)Æz_º_cases_thm));
(* *** Goal "1.1" *** *)
a(strip_asm_tac z_div_mod_unique_lemma3);
a(DROP_ASM_T Òi = d * j + rÆ (fn th1 => DROP_ASM_TÒi = (i div j) * j + i mod jÆ
	(fn th2 => asm_tac(eq_trans_rule(eq_sym_rule th2) th1))));
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(strip_asm_tac z_div_mod_unique_lemma3);
a(DROP_ASM_T Òi = d * j + rÆ (fn th1 => DROP_ASM_TÒi = (i div j) * j + i mod jÆ
	(fn th2 => asm_tac(eq_trans_rule(eq_sym_rule th1) th2))));
a(all_asm_fc_tac[]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(MERGE_PCS_T1 z_more_pcs strip_asm_tac (z_µ_elim Ò(i¶i,j¶j)Æ
	(rewrite_rule[˙_thm](±_right_elim(z_get_specÒ(_div_)Æ)))));
a(DROP_ASM_T Òi = (i div j) * j + i mod jÆ once_rewrite_thm_tac);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
\section{EPILOG}
=SML
end (* of structure ZNumbers *) ;
open ZNumbers;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
