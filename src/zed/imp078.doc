=IGN
********************************************************************************
imp078.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp078.doc   %Z% $Date: 2005/09/13 15:19:35 $ $Revision: 1.24 $ $RCSfile: imp078.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP078}  %% Mandatory field
\def\SCCSversion{$Revision: 1.24 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2005/09/13 15:19:35 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
% \TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01&WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Set Theory and its proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{92/03/19} ] Initial Draft.

\item [Issue 1.6 (28th July 1992)]
Bug fixing.
\item [Issue 1.7 (12th October 1992)]
Moved $€$ definition to \cite{DS/FMU/IED/DTD052}.
\item [Issue 1.8 (23rd October 1992)]
Change of name and nature to Z Library Set Theory.
\item [Issue 1.9, 11th November 1992] 
Changes as a consequence of changes in dependences.
Added proof contexts ``z$\_$sets$\_$ext'',
``z$\_$sets$\_$alg''
and supporting material.
\item [Issue 1.11, 3rd December 1992] 
Changed $U$ simplification.
\item [Issue 1.12, 3rd December 1992] 
Added .
\item[Issue 1.13 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.14 (19th January 1993)]
Added $z\_sets\_ext\_clauses$.
\item[Issue 1.16 (10th February 1993)]
Changes to proof contexts, etc.
\item[Issue 1.17 (16th February 1999)]
Update for SML'97.
\item[Issue 1.19] Copyright and banner updates for open source release.
\item[Issue 1.20] PPZed-specific updates for open source release
\item[Issue 1.21] The Z universal set is now called ƒ.
\item[Issue 1.22] Allowed for new forms of template and added conditional.
\item[Issues 1.22, 1.23] Added support for conditionals.
\item[Issues 1.24] Added symmetric difference.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the mathematical toolkit for HOL/Z meeting the detailed design
given in \cite{DS/FMU/IED/DTD078}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD078}.
\subsection{Dependencies}
The mathematical toolkit is introduced within the structure
$ZSets$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD078}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZSets$
(see\cite{DS/FMU/IED/DTD078}).

\subsection{Possible Enhancements}
The names of some of the global variables will change once an mechanism for
introducing Z names which do not clash with existing HOL constant
names into the theory database.
For the time being, names common to the toolkit and to HOL have here been
subscripted with $L$ (for library).

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZSets$}

=SML
structure ÛZSetsÝ : ZSets = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory Û"z_sets"Ý;
val _ = push_merge_pcs ["z_predicates","'z__set_lang", "'propositions", "'z_tuples_lang"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:
=SML
	val z_­_def = get_spec ¬$"z'_ ­ _"®;
	val z_ª_def = get_spec ¬$"z'_ ª _"®;
	val z_½_def = get_spec ¬$"z'_ ½ _"®;
	val z_Ž_def = get_spec ¬$"z'_ Ž _"®;
	val z_š_def = get_spec ¬$"z'š"®;
	val z_ _def = get_spec ¬$"z'_   _"®;
	val z_ð‰1_def = get_spec ¬$"z'ð‰1 _"®;
	val z_À_def = get_spec ¬$"z'_ À _"®;
	val z_¡_def = get_spec ¬$"z'_ ¡ _"®;
	val z_setdif_def = get_spec ¬$"z'_ £ _"®;
	val z_£_def = get_spec ¬$"z'_ \\ _"®;
	val z_Þ_def = get_spec ¬$"z'Þ"®;
	val z_¥_def = get_spec ¬$"z'¥"®;
	val z_first_def = get_spec ¬$"z'first"®;
	val z_second_def = get_spec ¬$"z'second"®;
	val z_º_def = get_spec ¬$"z'_ º _"®;
	val z'_def = get_spec ¬$"z' _?"®;
	val z'if_def = get_spec ¬$"z'if _? then _! else _!"®;
=TEX
\section{THE CODE}
\subsection{Utilities}
A precaution, lost outside of structure:
=SML
fun Ûsave_thmÝ(a,b) = KernelInterface.save_thm(a, check_is_z_thm "save_thm" b);
fun Ûlist_save_thmÝ(a,b) = KernelInterface.list_save_thm(a, check_is_z_thm "list_save_thm" b);
=SML
fun Ûlist_eqÝ (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val ÛUaÝ = ñƒ®; (* type = 'a SET *)
val ÛUbÝ = inst [] [(”'b®,”'a®)] Ua;
=TEX
\subsubsection{Conversionals}
Apply through all $Ì$'s.
=SML
val rec ÛALL_SIMPLE_Ì_CÝ : CONV -> CONV = (fn cnv => fn tm => 
	(SIMPLE_Ì_C (ALL_SIMPLE_Ì_C cnv)
	ORELSE_C cnv) tm
);
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun ÛLAST_SIMPLE_µ_CÝ (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun ÛDIAG_CÝ (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun Û±_CÝ (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¬op a1 (op a2 (op a3 ...))®
÷
÷
ô (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = ô a1 = a1'
cnv2 a2 = ô a2 = a2'
cnv3 a3 = ô a3 = a3'
 ...
=TEX
=SML
fun ÛLIST_OP_CÝ [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_Á_conv1 nm :CONV= (fn tm =>
		(simple_Á_conv nm
		ORELSE_C
		simple_Á_conv1 (nm ^ get_variant_suffix())) tm);
in
fun Ûseq_binder_simple_Á_convÝ [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_Á_conv1 nm)
end
) | seq_binder_simple_Á_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_Á_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_Á_conv x)
end
) | seq_binder_simple_Á_conv [] = id_conv;
end;
=TEX
=SML
val rec Ûseq_simple_Â_convÝ :CONV = (fn tm =>
	(simple_Â_conv
	ORELSE_C 
	(RATOR_C seq_simple_Â_conv THEN_C simple_Â_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_Â_conv" 27008 [tm1]))
	tm
);
=TEX
Change a free variable name:
=SML
fun Ûchange_name_ruleÝ from_nm to_nm thm = (
let	val fvs = map dest_var (frees(concl thm));
	val ty = lassoc3 fvs from_nm;
in
	simple_µ_elim (mk_var(to_nm, ty))
	(simple_µ_intro (mk_var(from_nm, ty)) thm)
end);
=TEX

\subsubsection{Projection Conversions}
=SML
val Ûdpvt_proj_thmÝ:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¬$"Z'S[d,p,t,v]v"®))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (Ûd_dptv_proj_convÝ,Ûp_dptv_proj_convÝ,
		Ût_dptv_proj_convÝ, Ûv_dptv_proj_convÝ) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val Ûdpv_proj_thmÝ:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¬$"Z'S[d,p,v]v"®))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val Ûd_dpv_proj_convÝ = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val Ûp_dpv_proj_convÝ = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val Ûv_dpv_proj_convÝ = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specñ(x,y).1®));
in
val Ûtuple2_1_proj_convÝ = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val Ûtuple2_2_proj_convÝ = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
=SML
fun use_ext_pc () = push_merge_pcs ["z_predicates","'z__set_lang",
	"'z_sets_ext_lang","'propositions", "'z_tuples_lang"];
=TEX
\section{THE IMPLEMENTATION}
\subsection{Set Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua](conv_rule z_para_pred_conv z_½_def));
in
val Ûz_½_thmÝ = save_thm("z_½_thm",
	all_z_µ_intro
	(all_µ_elim(
	(conv_rule z_µ_elim_conv1
	(nth 2 (strip_±_rule spec))))));
val Ûz_Ž_thmÝ = save_thm("z_Ž_thm",
	(nth 3 (strip_±_rule spec)));
end;
=TEX
=SML
local	val _ = use_ext_pc();
	val spec = 
		(list_µ_elim[Ua]
		(rewrite_rule[]z_š_def));
	val _ = pop_pc();
in
val Ûz_š_thmÝ = save_thm("z_š_thm",spec);
end;
=TEX
=SML
val Ûz_š_thm1Ý = save_thm("z_š_thm1",
	merge_pcs_rule1 ["z_predicates","'z__set_lang",
		"'propositions","'z_sets_ext_lang"]
		prove_rule[z_š_def] ñš = {}®);

=TEX
=SML
local
	val spec = all_z_µ_intro
		(all_µ_elim
		(conv_rule z_para_pred_conv z_ð‰1_def));
in
val Ûz_ð‰1_thmÝ = save_thm("z_ð‰1_thm",
	spec);
end;
=TEX
=SML
local
	val spec = rewrite_rule[z_sets_ext_thm]
		(list_µ_elim[Ua]
		(rewrite_rule[]z_À_def));
	val s1 = list_µ_elim[¬s:'a SET®,¬t:'a SET®]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val Ûz_À_thmÝ = save_thm("z_À_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1(nth 0 (strip_±_rule s1)))));
val Ûz_¡_thmÝ = save_thm("z_¡_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1	(nth 1 (strip_±_rule s1)))));
val Ûz_set_dif_thmÝ = save_thm("z_set_dif_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1	(nth 2 (strip_±_rule s1)))));
val Ûz_£_thmÝ = save_thm("z_£_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1	(nth 3 (strip_±_rule s1)))));
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_ª_def);
in
val Ûlocal_z_ª_thmÝ = 
	all_z_µ_intro(all_µ_elim 
	(inst_type_rule[(”'b®,”'Y®),(”'a®,”'X®)]spec));
end;
=TEX
=SML
val Ûz_€_thm1Ý = save_thm("z_€_thm1", (
set_goal([], ¬µ X:'a SET·
	ñ((_ € _)[X])  (ð X ª ð X) ±
	(µ S, T : ð X
            · ((S, T)  (_ € _)[X] ¤ (µ x : X · x  S ´ x  T)))®®) ;
use_ext_pc();
a(rewrite_tac[z_€_def, local_z_ª_thm]);
a(PC_T1 "sets_ext" rewrite_tac[]);
a(prove_tac[]);
pop_pc();
pop_thm()));
=TEX
=SML
local
	val spec = 
		(list_µ_elim[Ua]
		z_€_thm1);
	val s1 = list_µ_elim[¬s:'a SET®,¬t:'a SET®]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val Ûz_€_thmÝ = save_thm("z_€_thm",
	all_z_µ_intro s1);
end;
=TEX

=SML
local
	val thm1 = pc_rule1 "z_predicates" prove_rule 
		[z_€_thm, all_µ_intro(z__ð_conv ñp  ð q®)]
		¬µ p q · ñp € q ¤ p  ð q®®;
	val cnv1 = simple_eq_match_conv1 thm1;
	val a_€ = ñ(_ € _)®;
in
val Ûz_€_convÝ : CONV = (fn tm =>
let	val (vw,€) = dest_z_ tm
		handle complaint =>
		divert complaint "dest_z_" "z_€_conv"
			78001 [fn () => string_of_term tm];
	val (v,w) = case dest_z_tuple vw of
		[v,w] => (v,w)
		| _ => term_fail "z_€_conv" 78001 [tm];
	val side = term_match € a_€
		handle (Fail _) =>
		term_fail "z_€_conv" 78001 [tm];
	val check_is_z = set_flag("check_is_z",false);
	val s1 = (cnv1 THEN_C z__ð_conv) tm
		handle complaint =>
		term_fail "z_€_conv" 78001 [tm];
	val dummy = set_flag("check_is_z",check_is_z);
	val s2 = eq_trans_rule (refl_conv tm) s1;
in
	check_is_z_conv_result "z_€_conv" s2
end);
end;
=IGN
z_€_conv ñp € q®;
z_€_conv ñp € r ¸ s ¸ x2®;
z_€_conv ñp € r ¸ [a,b:X] ¸ x2®;
=TEX
=SML
val _ = use_ext_pc();
val Ûz__ð_thmÝ = save_thm ("z__ð_thm",(
set_goal([], ñµ s:ƒ;t:ƒ · s  ð t ¤ s € t®);
a(REPEAT_N 4 strip_tac THEN rewrite_tac[z_€_thm] THEN 
	conv_tac(ONCE_MAP_C z__ð_conv) THEN
	rewrite_tac[]);
pop_thm ()));

val _ = pop_pc();
=TEX

=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(conv_rule z_para_pred_conv z_ _def));
	val s1 = list_µ_elim[¬s:'a SET®,¬t:'a SET®]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val Ûz_ _thmÝ = save_thm("z_ _thm",
	all_z_µ_intro s1);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]z_Þ_def));
	val s1 = list_µ_elim[¬a:'a SET SET®]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
	val s2 = rewrite_rule[z_sets_ext_thm] s1;
	val s4 = prove_rule [all_µ_intro s2] ñ(µ z:ƒ; a:ƒ ·
		z  Þ a ¤ (¶ S : ƒ · S  a ± z  S)) ±
		(µ z:ƒ; a:ƒ ·
		z  ¥ a ¤ (µ S : ƒ · S  a ´ z  S))®;
		
in
val Ûz_Þ_thmÝ = save_thm("z_Þ_thm", ±_left_elim s4);
val Ûz_¥_thmÝ = save_thm("z_¥_thm", 
	inst_type_rule [(”'a®,”'b®)]
		(±_right_elim s4));
end;
=TEX
\subsection{Tuple Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_first_def));
	val x = mk_var("x",type_of ñ(p,q)®);
	val s1 = rewrite_rule[]
		(conv_rule(MAP_C z_tuple_lang_intro_conv)
		(z_µ_elimñ(x ¦ ñ‘x®.1®, y ¦ ñ‘x®.2®)®
		(nth 1 (strip_±_rule spec))));
in
val Ûz_first_thmÝ = save_thm("z_first_thm",
	all_z_µ_intro(±_left_elim s1));
val Ûz_second_thmÝ = save_thm("z_second_thm",
	all_z_µ_intro(±_right_elim s1));
end;
=TEX
=SML
val Ûz_if_thmÝ = save_thm ("z_if_thm",
	inst_type_rule[(”'a®, ”'X®)]
	(±_right_elim(z_gen_pred_u_elim
	(z_get_specñ(if _? then _! else _!)®))));
=TEX
=SML
val Ûz_pred_if_thmÝ = 
	±_right_elim(z_gen_pred_elim[mk_u (type_of ñ–®)]
	(z_get_specñ(if _? then _! else _!)®));
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun Ûmake__ruleÝ thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun Ûmake_pair_trio_ruleÝ thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_sel‰t_lang_conv)
		(µ_elim ñ(p1,p2)® 
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_sel‰t_lang_conv)
		(µ_elim ñ(p1 í p2)® (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val Û_operator_clausesÝ = [
	z_Þ_thm, z_¥_thm,
	z_À_thm, z_¡_thm, z_set_dif_thm, z_£_thm,
	rewrite_rule[z__ð_thm](make__rule z_ð‰1_thm),
	z_š_thm, z__ð_thm];
=TEX
=SML
fun Ûthms_to_eqn_cxtÝ (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX
\subsection{Treatment of Membership of Sets in Z Library}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z__set_lib" handle Fail _ => ();
val _ = new_pc "'z__set_lib";
val _ = set_rw_eqn_cxt []"'z__set_lib";
val _ = add_rw_thms 
	(_operator_clauses @ [z_š_thm1]) "'z__set_lib";

val pos = (thms_to_eqn_cxt _operator_clauses)
	@ [];
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z__set_lib";
val _ = set_sc_eqn_cxt (pos @ neg) "'z__set_lib";
val _ = set_rw_canons [] "'z__set_lib";
val _ = set_pr_tac z_basic_prove_tac "'z__set_lib";
val _ = set_pr_conv z_basic_prove_conv "'z__set_lib";
val _ = set_cs_¶_convs [] "'z__set_lib";
val _ = set_¶_vs_thms [] "'z__set_lib";
val _ = set_u_simp_eqn_cxt (u_simp_eqn_cxt [z_ª_def]) "'z__set_lib";
val _ = commit_pc "'z__set_lib";
=TEX
\subsection{Z Normalisation}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_normal" handle Fail _ => ();
val _ = new_pc "'z_normal";
val _ = set_rw_eqn_cxt []"'z_normal";
val _ = add_rw_thms 
	([z_Ž_thm, z_½_thm, z__ð_thm, z_š_thm1, z_if_thm]) "'z_normal";

val pos = (thms_to_eqn_cxt [z_Ž_thm, z_š_thm, z_½_thm, z__ð_thm, z_pred_if_thm])
	@ [];
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_normal";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_normal";
val _ = set_rw_canons [] "'z_normal";
val _ = set_pr_tac z_basic_prove_tac "'z_normal";
val _ = set_pr_conv z_basic_prove_conv "'z_normal";
val _ = set_cs_¶_convs [] "'z_normal";
val _ = set_¶_vs_thms [] "'z_normal";
val _ = commit_pc "'z_normal";
=TEX
\subsection{Extensionality Treatment of Sets}
=SML
val _ = delete_pc "'z_sets_ext_lib" handle Fail _ => ();
val _ = new_pc "'z_sets_ext_lib";
val _ = set_rw_eqn_cxt [(ña € b®, z_€_conv),
		(ñ¬Z'Setd a® € b®, z_setd_€_conv)]
	"'z_sets_ext_lib";
val _ = add_rw_thms 
	[z_ _thm] "'z_sets_ext_lib";

val pos = [(ña € b®, z_€_conv),
		(ñ¬Z'Setd a® € b®, z_setd_€_conv)]
	@ thms_to_eqn_cxt [z_ _thm];
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_ext_lib";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_ext_lib";
val _ = set_rw_canons [] "'z_sets_ext_lib";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_ext_lib";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_ext_lib";
val _ = set_cs_¶_convs [] "'z_sets_ext_lib";
val _ = set_¶_vs_thms [] "'z_sets_ext_lib";
val _ = commit_pc "'z_sets_ext_lib";
=TEX
	
=IGN
push_merge_pcs ["z_predicates","'z__set_lang","'z_normal",
	"'z_sets_ext_lang", "'z_bindings",
	"'z__set_lib", "'z_sets_ext_lib"];
push_goal([],ñA ½ š ´ (¥ A) \ S = ¥ {T1 : A · T1 \ S}®);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 ¬x1'®);
a(z_spec_nth_asm_tac 6 ¬T1®);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ñS' \ S®);
a(z_spec_nth_asm_tac 1 ¬S'®);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 ñx1 \ S®);
a(z_spec_nth_asm_tac 1 ¬x1®);
pop_thm();
=TEX
\section{ALGEBRAIC TREATMENT OF SETS}
\subsection{Supporting Theorems}
=SML
val _ = push_merge_pcs ["z_predicates","'z__set_lang","'z_normal",
	"'z_sets_ext_lang", "'z_bindings",
	"'z__set_lib", "'z_tuples_lang","'z_sets_ext_lib"];
val Ûz_À_clausesÝ = save_thm("z_À_clauses",(
push_goal([], ñ
	µ a : ƒ ·
		(a À {} = a)
	±	({} À a = a)
	±	(a À ƒ = ƒ)
	±	(ƒ À a = ƒ)
	±	(a À a = a)®);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_¡_clausesÝ = save_thm("z_¡_clauses",(
push_goal([], ñ
	µ a : ƒ ·
		(a ¡ {} = {})
	±	({} ¡ a = {})
	±	(a ¡ ƒ = a)
	±	(ƒ ¡ a = a)
	±	(a ¡ a = a)®);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_set_dif_clausesÝ = save_thm("z_set_dif_clauses",(
push_goal([], ñ
	µ a : ƒ·
		(a \ {} = a)
	±	({} \ a = {})
	±	(a \ ƒ = {})
	±	(a \ a = {})®);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_£_clausesÝ = save_thm("z_£_clauses",(
push_goal([], ñ
	µ a : ƒ ·
		(a £ {} = a)
	±	({} £ a = a)
	±	(a £ ƒ = ƒ \ a)
	±	(ƒ £ a = ƒ \ a)
	±	(a £ a = {})®);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_€_clausesÝ = save_thm("z_€_clauses",(
push_goal([], ñ
	µ a : ƒ ·
		(a € a)
	±	({} € a)
	±	(a € ƒ)®);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_ _clausesÝ = save_thm("z_ _clauses",(
push_goal([], ñ
	µ a : ƒ ·
		³ (a   a)
	±	³ (a   {})
	±	({}   ƒ)®);
a(prove_tac[]);
pop_thm ()));
=TEX
=SML
val Ûz_¥_clausesÝ = save_thm("z_¥_clauses",(
push_goal([], ñ
	(¥ {} = ƒ)
	±	(¥ ƒ = {})®);
a(REPEAT z_strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
a(strip_tac);
a(z_¶_tacñ{}®);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_Þ_clausesÝ = save_thm("z_Þ_clauses",(
push_goal([], ñ
	(Þ {} = {})
	±	(Þ ƒ = ƒ)®);
a(REPEAT z_strip_tac);
a(z_¶_tacñ{x1}®);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_ð_clausesÝ = save_thm("z_ð_clauses",(
push_goal([], ñ
	µ a : ƒ ·
		(ð {} = {{}})
	±	(ð ƒ = ƒ)
	±	a  ð a
	±	{}  ð a®);
a(REPEAT z_strip_tac THEN asm_fc_tac[]);
pop_thm ()));
=TEX
=SML
val Ûz_ð‰1_clausesÝ = save_thm("z_ð‰1_clauses",(
push_goal([], ñ
	µ a : ƒ ·
		(ð‰1 {} = {})
	±	(a  ð‰1 a ¤ a ½ {})
	±	³({}  ð‰1 a)®);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(z_¶_tac ñx1®);
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(z_¶_tac ñx1®);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val Ûz_¸_clausesÝ = save_thm("z_¸_clauses",
	prove_rule[] ñ
	µ a : ƒ ·
		(a ¸ {} = {})
	±	({} ¸ a = {})
	±	(ƒ ¸ ƒ = ƒ)®);
=TEX
=SML
local
	val cnv1 = pure_once_rewrite_conv [z_sets_ext_thm];
	val cnv2 = pure_rewrite_conv [taut_rule
		¬µ x · (x ± F ¤ F) ±
			(F ± x ¤ F) ±
			((F ¤ F) ¤ T)®];
in
val Ûz_seta_false_convÝ : CONV = (fn tm =>
let	val (d,p,v) = dest_z_seta tm
			handle (Fail _) =>
			term_fail "z_seta_false_conv" 78002 [tm];
	val dummy = if p =$ mk_f
		then ()
		else term_fail "z_seta_false_conv" 78002 [tm];
	val s1 = tac_proof(([],mk_z_eq(tm, 
			mk_z_setd(dest_z_power_type (type_of tm),[]))),
		conv_tac (cnv1) THEN
		z_µ_tac THEN 
		´_T (fn _ => id_tac) THEN
		conv_tac(LEFT_C (z__seta_conv THEN_C
			z_¶_inv_conv) THEN_C
		RIGHT_C z__setd_conv
		THEN_C cnv2))
in
	s1
end);
end;		 
=TEX	
		
\subsection{Proof Contexts}

=SML
val z_sets_alg_thms = [
	z_À_clauses, z_¡_clauses, z_set_dif_clauses, z_£_clauses,
	z_€_clauses, z_ _clauses, z_Þ_clauses, z_¥_clauses, 
	z_ð_clauses, z_ð‰1_clauses, z_¸_clauses];

local
	val setty = type_of ñ{}®;
in
fun Ûadd_Ý ((index,cnv)::rest) = (
	(let val tyms = type_match (type_of index) setty @ [(”'a®,”'a®)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		((mk_z_(x,index), _C cnv) :: (index,cnv) :: add_ rest)
	end)
	handle (Fail _) =>
	((index,cnv) :: add_ rest)
) | add_ [] = [];
end;

val z_sets_alg_eqn_cxt = add_(thms_to_eqn_cxt z_sets_alg_thms);

fun Ûmaybe_stripÝ (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else fail "" 0 []
);

val z_sets_alg_eqn_cxt_for_strip = mapfilter maybe_strip z_sets_alg_eqn_cxt;

val _ = delete_pc "'z_sets_alg" handle Fail _ => ();
val _ = new_pc "'z_sets_alg";
val _ = set_rw_eqn_cxt ([(¬y (Ì z · w):'a SET®, z_seta_false_conv),
		(¬Z'Seta[0] y:'a SET®, z_seta_false_conv)]
	@ z_sets_alg_eqn_cxt)
	"'z_sets_alg";
val _ = add_rw_thms [] "'z_sets_alg";

val pos = z_sets_alg_eqn_cxt_for_strip;
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_rw_canons [] "'z_sets_alg";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_alg";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_alg";
val _ = set_cs_¶_convs [] "'z_sets_alg";
val _ = set_¶_vs_thms [] "'z_sets_alg";
val _ = commit_pc "'z_sets_alg";
=TEX
=SML
val _ = pop_pc();
val _ = push_merge_pcs ["z_predicates","'z__set_lang",
	"'z_bindings","'z_normal",
	"'z__set_lib","'z_sets_alg"];
=TEX
=SML
val Ûz_sets_ext_clausesÝ = save_thm("z_sets_ext_clauses",
	merge_pcs_rule1 ["z_predicates","'z__set_lang",
	"'z_bindings","'z_normal",
	"'z__set_lib","'z_sets_ext_lang","'z_sets_ext_lib"] prove_rule []
	ñµ s,t : ƒ ·
	((s = t) ¤ (µ x : ƒ · x  s ¤ x  t))
	±
	((s € t) ¤ (µ x : ƒ · x  s ´ x  t))
	±
	((s   t) ¤ ((µ x : ƒ · x  s ´ x  t) ± (¶ y : ƒ · y  t ± ³(y  s))))
	®);
=TEX
\section{SYNTAX FUNCTIONS}
=SML
local
	val pattern = ñ if c then x else y ®;
	val cv = ¬c : BOOL®;
	val xv = ¬x ®;
	val yv = ¬ y ®;
	val vty = type_of xv;
	val gv = fst(dest_z_app pattern);
in
fun Ûmk_z_ifÝ (c : TERM, x : TERM, y : TERM) = (
	let	val xty = type_of x;
		val yty = type_of y;
	in	if	not(type_of c =: BOOL)
		then	term_fail "mk_z_if" 78005 [c]
		else if	not(xty =: yty)
		then	term_fail "mk_z_if" 78004 [x, y]
		else 	subst[	(c, cv),
				(x, inst[][(xty, vty)]xv),
				(y, inst[][(xty, vty)]yv)]
		(inst[][(xty, vty)] pattern)
	end
);
fun Ûdest_z_ifÝ (tm : TERM) : (TERM * TERM * TERM) = (
	let	val (f, args) = dest_z_app tm;
		val _ = (term_match f gv);
	in	case dest_z_tuple args of
			[c, x, y] => (c, x, y)
		|	_ => fail "" 0 []
	end	handle Fail _ =>
		term_fail "dest_z_if" 78003 [tm]
);
fun Ûis_z_ifÝ (tm : TERM) = (
	(dest_z_if tm; true) handle Fail _ => false
);
end (* local .. in .. end *);
=TEX
\section{EPILOG}
=SML
end (* of struct ZSets *);
open ZSets;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
