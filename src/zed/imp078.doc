% imp078.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP078}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
% \TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01&WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Set Theory and its proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{92/03/19} ] Initial Draft.

\item [Issue 1.6 (28th July 1992)]
Bug fixing.
\item [Issue 1.7 (12th October 1992)]
Moved $Ä$ definition to \cite{DS/FMU/IED/DTD052}.
\item [Issue 1.8 (23rd October 1992)]
Change of name and nature to Z Library Set Theory.
\item [Issue 1.9, 11th November 1992] 
Changes as a consequence of changes in dependences.
Added proof contexts ``z$\_$sets$\_$ext'',
``z$\_$sets$\_$alg''
and supporting material.
\item [Issue 1.11, 3rd December 1992] 
Changed $U$ simplification.
\item [Issue 1.12, 3rd December 1992] 
Added ê.
\item[Issue 1.13 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.14 (19th January 1993)]
Added $z\_sets\_ext\_clauses$.
\item[Issue 1.16 (10th February 1993)]
Changes to proof contexts, etc.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the mathematical toolkit for HOL/Z meeting the detailed design
given in \cite{DS/FMU/IED/DTD078}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD078}.
\subsection{Dependencies}
The mathematical toolkit is introduced within the structure
$ZSets$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD078}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZSets$
(see\cite{DS/FMU/IED/DTD078}).

\subsection{Possible Enhancements}
The names of some of the global variables will change once an mechanism for
introducing Z names which do not clash with existing HOL constant
names into the theory database.
For the time being, names common to the toolkit and to HOL have here been
subscripted with $L$ (for library).

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZSets$}

=SML
structure €ZSets› : ZSets = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_sets"›;
val _ = push_merge_pcs ["z_predicates","'z_ç_set_lang", "'propositions", "'z_tuples_lang"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:
=SML
	val z_≠_def = get_spec ¨$"z'_ ≠ _"Æ;
	val z_™_def = get_spec ¨$"z'_ ™ _"Æ;
	val z_Ω_def = get_spec ¨$"z'_ Ω _"Æ;
	val z_é_def = get_spec ¨$"z'_ é _"Æ;
	val z_ö_def = get_spec ¨$"z'ö"Æ;
	val z_†_def = get_spec ¨$"z'_ † _"Æ;
	val z_â1_def = get_spec ¨$"z'â1 _"Æ;
	val z_¿_def = get_spec ¨$"z'_ ¿ _"Æ;
	val z_°_def = get_spec ¨$"z'_ ° _"Æ;
	val z_setdif_def = get_spec ¨$"z'_ \\ _"Æ;
	val z_ﬁ_def = get_spec ¨$"z'ﬁ"Æ;
	val z_•_def = get_spec ¨$"z'•"Æ;
	val z_first_def = get_spec ¨$"z'first"Æ;
	val z_second_def = get_spec ¨$"z'second"Æ;
	val z_∫_def = get_spec ¨$"z'_ ∫ _"Æ;
	val z'ê_def = get_spec ¨$"z'ê _"Æ;
=TEX
\section{THE CODE}
\subsection{Utilities}
A precaution, lost outside of structure:
=SML
fun €save_thm›(a,b) = KernelInterface.save_thm(a, check_is_z_thm "save_thm" b);
fun €list_save_thm›(a,b) = KernelInterface.list_save_thm(a, check_is_z_thm "list_save_thm" b);
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
val €Ub› = inst [] [(î'bÆ,î'aÆ)] Ua;
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_¡_conv1 nm :CONV= (fn tm =>
		(simple_¡_conv nm
		ORELSE_C
		simple_¡_conv1 (nm ^ get_variant_suffix())) tm);
in
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_¡_conv1 nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_¡_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
end;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX
Change a free variable name:
=SML
fun €change_name_rule› from_nm to_nm thm = (
let	val fvs = map dest_var (frees(concl thm));
	val ty = lassoc3 fvs from_nm;
in
	simple_µ_elim (mk_var(to_nm, ty))
	(simple_µ_intro (mk_var(from_nm, ty)) thm)
end);
=TEX

\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
=SML
fun use_ext_pc () = push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_sets_ext_lang","'propositions", "'z_tuples_lang"];
=TEX
\section{THE IMPLEMENTATION}
\subsection{Set Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua](conv_rule z_para_pred_conv z_Ω_def));
in
val €z_Ω_thm› = save_thm("z_Ω_thm",
	all_z_µ_intro
	(all_µ_elim(
	(conv_rule z_µ_elim_conv1
	(nth 2 (strip_±_rule spec))))));
val €z_é_thm› = save_thm("z_é_thm",
	(nth 3 (strip_±_rule spec)));
end;
=TEX
=SML
local	val _ = use_ext_pc();
	val spec = 
		(list_µ_elim[Ua]
		(rewrite_rule[]z_ö_def));
	val _ = pop_pc();
in
val €z_ö_thm› = save_thm("z_ö_thm",spec);
end;
=TEX
=SML
val €z_ö_thm1› = save_thm("z_ö_thm1",
	merge_pcs_rule1 ["z_predicates","'z_ç_set_lang",
		"'propositions","'z_sets_ext_lang"]
		prove_rule[z_ö_def] Òö = {}Æ);

=TEX
=SML
local
	val spec = all_z_µ_intro
		(all_µ_elim
		(conv_rule z_para_pred_conv z_â1_def));
in
val €z_â1_thm› = save_thm("z_â1_thm",
	spec);
end;
=TEX
=SML
local
	val spec = rewrite_rule[z_sets_ext_thm]
		(list_µ_elim[Ua]
		(rewrite_rule[]z_¿_def));
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_¿_thm› = save_thm("z_¿_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1(nth 0 (strip_±_rule s1)))));
val €z_°_thm› = save_thm("z_°_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1	(nth 1 (strip_±_rule s1)))));
val €z_set_dif_thm› = save_thm("z_set_dif_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1	(nth 2 (strip_±_rule s1)))));
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_™_def);
in
val €local_z_™_thm› = 
	all_z_µ_intro(all_µ_elim 
	(inst_type_rule[(î'bÆ,î'YÆ),(î'aÆ,î'XÆ)]spec));
end;
=TEX
=SML
val €z_Ä_thm1› = save_thm("z_Ä_thm1", (
set_goal([], ¨µ X:'a SET∑
	Ò((_ Ä _)[X]) ç ( X ™  X) ±
	(µ S, T :  X
            ∑ ((S, T) ç (_ Ä _)[X] § (µ x : X ∑ x ç S ¥ x ç T)))ÆÆ) ;
use_ext_pc();
a(rewrite_tac[z_Ä_def, local_z_™_thm]);
a(PC_T1 "sets_ext" rewrite_tac[]);
a(prove_tac[]);
pop_pc();
pop_thm()));
=TEX
=SML
local
	val spec = 
		(list_µ_elim[Ua]
		z_Ä_thm1);
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_Ä_thm› = save_thm("z_Ä_thm",
	all_z_µ_intro s1);
end;
=TEX

=SML
local
	val thm1 = pc_rule1 "z_predicates" prove_rule 
		[z_Ä_thm, all_µ_intro(z_ç__conv Òp ç  qÆ)]
		¨µ p q ∑ Òp Ä q § p ç  qÆÆ;
	val cnv1 = simple_eq_match_conv1 thm1;
	val a_Ä = Ò(_ Ä _)Æ;
in
val €z_Ä_conv› : CONV = (fn tm =>
let	val (vw,Ä) = dest_z_ç tm
		handle complaint =>
		divert complaint "dest_z_ç" "z_Ä_conv"
			78001 [fn () => string_of_term tm];
	val (v,w) = case dest_z_tuple vw of
		[v,w] => (v,w)
		| _ => term_fail "z_Ä_conv" 78001 [tm];
	val side = term_match Ä a_Ä
		handle (Fail _) =>
		term_fail "z_Ä_conv" 78001 [tm];
	val check_is_z = set_flag("check_is_z",false);
	val s1 = (cnv1 THEN_C z_ç__conv) tm
		handle complaint =>
		term_fail "z_Ä_conv" 78001 [tm];
	val dummy = set_flag("check_is_z",check_is_z);
	val s2 = eq_trans_rule (refl_conv tm) s1;
in
	check_is_z_conv_result "z_Ä_conv" s2
end);
end;
=IGN
z_Ä_conv Òp Ä qÆ;
z_Ä_conv Òp Ä r ∏ s ∏ x2Æ;
z_Ä_conv Òp Ä r ∏ [a,b:X] ∏ x2Æ;
=TEX
=SML
val _ = use_ext_pc();
val €z_ç__thm› = save_thm ("z_ç__thm",(
set_goal([], Òµ s:U;t:U ∑ s ç  t § s Ä tÆ);
a(REPEAT_N 4 strip_tac THEN rewrite_tac[z_Ä_thm] THEN 
	conv_tac(ONCE_MAP_C z_ç__conv) THEN
	rewrite_tac[]);
pop_thm ()));

val _ = pop_pc();
=TEX

=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(conv_rule z_para_pred_conv z_†_def));
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_†_thm› = save_thm("z_†_thm",
	all_z_µ_intro s1);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]z_ﬁ_def));
	val s1 = list_µ_elim[¨a:'a SET SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
	val s2 = rewrite_rule[z_sets_ext_thm] s1;
	val s4 = prove_rule [all_µ_intro s2] Ò(µ z:U; a:U ∑
		z ç ﬁ a § (∂ S : U ∑ S ç a ± z ç S)) ±
		(µ z:U; a:U ∑
		z ç • a § (µ S : U ∑ S ç a ¥ z ç S))Æ;
		
in
val €z_ﬁ_thm› = save_thm("z_ﬁ_thm", ±_left_elim s4);
val €z_•_thm› = save_thm("z_•_thm", 
	inst_type_rule [(î'aÆ,î'bÆ)]
		(±_right_elim s4));
end;
=TEX
\subsection{Tuple Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z_first_def));
	val x = mk_var("x",type_of Ò(p,q)Æ);
	val s1 = rewrite_rule[]
		(conv_rule(MAP_C z_tuple_lang_intro_conv)
		(z_µ_elimÒ(x ¶ ÒëxÆ.1Æ, y ¶ ÒëxÆ.2Æ)Æ
		(nth 1 (strip_±_rule spec))));
in
val €z_first_thm› = save_thm("z_first_thm",
	all_z_µ_intro(±_left_elim s1));
val €z_second_thm› = save_thm("z_second_thm",
	all_z_µ_intro(±_right_elim s1));
end;
=TEX

\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun €make_ç_rule› thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun €make_pair_trio_rule› thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_selât_lang_conv)
		(µ_elim Ò(p1,p2)Æ 
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_selât_lang_conv)
		(µ_elim Ò(p1 Ì p2)Æ (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val €ç_operator_clauses› = [
	z_ﬁ_thm, z_•_thm,
	z_¿_thm, z_°_thm, z_set_dif_thm, 
	rewrite_rule[z_ç__thm](make_ç_rule z_â1_thm),
	z_ö_thm, z_ç__thm];
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX
\subsection{Treatment of Membership of Sets in Z Library}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_set_lib" handle Fail _ => ();
val _ = new_pc "'z_ç_set_lib";
val _ = set_rw_eqn_cxt []"'z_ç_set_lib";
val _ = add_rw_thms 
	(ç_operator_clauses @ [z_ö_thm1]) "'z_ç_set_lib";

val pos = (thms_to_eqn_cxt ç_operator_clauses)
	@ [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_ç_set_lib";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_ç_set_lib";
val _ = set_rw_canons [] "'z_ç_set_lib";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_set_lib";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_set_lib";
val _ = set_cs_∂_convs [] "'z_ç_set_lib";
val _ = set_∂_vs_thms [] "'z_ç_set_lib";
val _ = set_u_simp_eqn_cxt (u_simp_eqn_cxt [z_™_def]) "'z_ç_set_lib";
val _ = commit_pc "'z_ç_set_lib";
=TEX
\subsection{Z Normalisation}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_normal" handle Fail _ => ();
val _ = new_pc "'z_normal";
val _ = set_rw_eqn_cxt []"'z_normal";
val _ = add_rw_thms 
	([z_é_thm, z_Ω_thm, z_ç__thm, z_ö_thm1]) "'z_normal";

val pos = (thms_to_eqn_cxt [z_é_thm, z_ö_thm, z_Ω_thm, z_ç__thm])
	@ [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_normal";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_normal";
val _ = set_rw_canons [] "'z_normal";
val _ = set_pr_tac z_basic_prove_tac "'z_normal";
val _ = set_pr_conv z_basic_prove_conv "'z_normal";
val _ = set_cs_∂_convs [] "'z_normal";
val _ = set_∂_vs_thms [] "'z_normal";
val _ = commit_pc "'z_normal";
=TEX
\subsection{Extensionality Treatment of Sets}
=SML
val _ = delete_pc "'z_sets_ext_lib" handle Fail _ => ();
val _ = new_pc "'z_sets_ext_lib";
val _ = set_rw_eqn_cxt [(Òa Ä bÆ, z_Ä_conv),
		(Ò¨Z'Setd aÆ Ä bÆ, z_setd_Ä_conv)]
	"'z_sets_ext_lib";
val _ = add_rw_thms 
	[z_†_thm] "'z_sets_ext_lib";

val pos = [(Òa Ä bÆ, z_Ä_conv),
		(Ò¨Z'Setd aÆ Ä bÆ, z_setd_Ä_conv)]
	@ thms_to_eqn_cxt [z_†_thm];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_ext_lib";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_ext_lib";
val _ = set_rw_canons [] "'z_sets_ext_lib";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_ext_lib";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_ext_lib";
val _ = set_cs_∂_convs [] "'z_sets_ext_lib";
val _ = set_∂_vs_thms [] "'z_sets_ext_lib";
val _ = commit_pc "'z_sets_ext_lib";
=TEX
	
=IGN
push_merge_pcs ["z_predicates","'z_ç_set_lang","'z_normal",
	"'z_sets_ext_lang", "'z_bindings",
	"'z_ç_set_lib", "'z_sets_ext_lib"];
push_goal([],ÒA Ω ö ¥ (• A) \ S = • {T1 : A ∑ T1 \ S}Æ);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 ¨x1'Æ);
a(z_spec_nth_asm_tac 6 ¨T1Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ÒS' \ SÆ);
a(z_spec_nth_asm_tac 1 ¨S'Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Òx1 \ SÆ);
a(z_spec_nth_asm_tac 1 ¨x1Æ);
pop_thm();
=TEX
\section{ALGEBRAIC TREATMENT OF SETS}
\subsection{Supporting Theorems}
=SML
val _ = push_merge_pcs ["z_predicates","'z_ç_set_lang","'z_normal",
	"'z_sets_ext_lang", "'z_bindings",
	"'z_ç_set_lib", "'z_tuples_lang","'z_sets_ext_lib"];
val €z_¿_clauses› = save_thm("z_¿_clauses",(
push_goal([], Ò
	µ a : U ∑
		(a ¿ {} = a)
	±	({} ¿ a = a)
	±	(a ¿ U = U)
	±	(U ¿ a = U)
	±	(a ¿ a = a)Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_°_clauses› = save_thm("z_°_clauses",(
push_goal([], Ò
	µ a : U ∑
		(a ° {} = {})
	±	({} ° a = {})
	±	(a ° U = a)
	±	(U ° a = a)
	±	(a ° a = a)Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_set_dif_clauses› = save_thm("z_set_dif_clauses",(
push_goal([], Ò
	µ a : U∑
		(a \ {} = a)
	±	({} \ a = {})
	±	(a \ U = {})
	±	(a \ a = {})Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_Ä_clauses› = save_thm("z_Ä_clauses",(
push_goal([], Ò
	µ a : U ∑
		(a Ä a)
	±	({} Ä a)
	±	(a Ä U)Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_†_clauses› = save_thm("z_†_clauses",(
push_goal([], Ò
	µ a : U ∑
		≥ (a † a)
	±	≥ (a † {})
	±	({} † U)Æ);
a(prove_tac[]);
pop_thm ()));
=TEX
=SML
val €z_•_clauses› = save_thm("z_•_clauses",(
push_goal([], Ò
	(• {} = U)
	±	(• U = {})Æ);
a(REPEAT z_strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
a(strip_tac);
a(z_∂_tacÒ{}Æ);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val €z_ﬁ_clauses› = save_thm("z_ﬁ_clauses",(
push_goal([], Ò
	(ﬁ {} = {})
	±	(ﬁ U = U)Æ);
a(REPEAT z_strip_tac);
a(z_∂_tacÒ{x1}Æ);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val €z__clauses› = save_thm("z__clauses",(
push_goal([], Ò
	µ a : U ∑
		( {} = {{}})
	±	( U = U)
	±	a ç  a
	±	{} ç  aÆ);
a(REPEAT z_strip_tac THEN asm_fc_tac[]);
pop_thm ()));
=TEX
=SML
val €z_â1_clauses› = save_thm("z_â1_clauses",(
push_goal([], Ò
	µ a : U ∑
		(â1 {} = {})
	±	(a ç â1 a § a Ω {})
	±	≥({} ç â1 a)Æ);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tac Òx1Æ);
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(z_∂_tac Òx1Æ);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val €z_∏_clauses› = save_thm("z_∏_clauses",
	prove_rule[] Ò
	µ a : U ∑
		(a ∏ {} = {})
	±	({} ∏ a = {})
	±	(U ∏ U = U)Æ);
=TEX
=SML
local
	val cnv1 = pure_once_rewrite_conv [z_sets_ext_thm];
	val cnv2 = pure_rewrite_conv [taut_rule
		¨µ x ∑ (x ± F § F) ±
			(F ± x § F) ±
			((F § F) § T)Æ];
in
val €z_seta_false_conv› : CONV = (fn tm =>
let	val (d,p,v) = dest_z_seta tm
			handle (Fail _) =>
			term_fail "z_seta_false_conv" 78002 [tm];
	val dummy = if p =$ mk_f
		then ()
		else term_fail "z_seta_false_conv" 78002 [tm];
	val s1 = tac_proof(([],mk_z_eq(tm, 
			mk_z_setd(dest_z_power_type (type_of tm),[]))),
		conv_tac (cnv1) THEN
		z_µ_tac THEN 
		¥_T (fn _ => id_tac) THEN
		conv_tac(LEFT_C (z_ç_seta_conv THEN_C
			z_∂_inv_conv) THEN_C
		RIGHT_C z_ç_setd_conv
		THEN_C cnv2))
in
	s1
end);
end;		 
=TEX	
		
\subsection{Proof Contexts}

=SML
val z_sets_alg_thms = [
	z_¿_clauses, z_°_clauses, z_set_dif_clauses,
	z_Ä_clauses, z_†_clauses, z_ﬁ_clauses, z_•_clauses, 
	z__clauses, z_â1_clauses, z_∏_clauses];

val z_sets_alg_eqn_cxt = thms_to_eqn_cxt z_sets_alg_thms;

local
	val setty = type_of Ò{}Æ;
in
fun €maybe_ç› (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else (let val tyms = type_match (type_of index) setty @ [(î'aÆ,î'aÆ)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		(mk_z_ç(x,index), ç_C cnv)
	end)
);
end;

val z_sets_alg_eqn_cxt_for_strip = mapfilter maybe_ç z_sets_alg_eqn_cxt;

val _ = delete_pc "'z_sets_alg" handle Fail _ => ();
val _ = new_pc "'z_sets_alg";
val _ = set_rw_eqn_cxt ([(¨y (Ã z ∑ w):'a SETÆ, z_seta_false_conv),
		(¨Z'Seta[0] y:'a SETÆ, z_seta_false_conv)]
	@ z_sets_alg_eqn_cxt)
	"'z_sets_alg";
val _ = add_rw_thms [] "'z_sets_alg";

val pos = z_sets_alg_eqn_cxt_for_strip;
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_rw_canons [] "'z_sets_alg";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_alg";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_alg";
val _ = set_cs_∂_convs [] "'z_sets_alg";
val _ = set_∂_vs_thms [] "'z_sets_alg";
val _ = commit_pc "'z_sets_alg";
=TEX
=SML
val _ = pop_pc();
val _ = push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_bindings","'z_normal",
	"'z_ç_set_lib","'z_sets_alg"];
=TEX
=SML
val €z_sets_ext_clauses› = save_thm("z_sets_ext_clauses",
	merge_pcs_rule1 ["z_predicates","'z_ç_set_lang",
	"'z_bindings","'z_normal",
	"'z_ç_set_lib","'z_sets_ext_lang","'z_sets_ext_lib"] prove_rule []
	Òµ s,t : U ∑
	((s = t) § (µ x : U ∑ x ç s § x ç t))
	±
	((s Ä t) § (µ x : U ∑ x ç s ¥ x ç t))
	±
	((s † t) § ((µ x : U ∑ x ç s ¥ x ç t) ± (∂ y : U ∑ y ç t ± ≥(y ç s))))
	Æ);
=TEX
\section{EPILOG}
=SML
end (* of struct ZSets *);
open ZSets;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
