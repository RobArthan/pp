% imp078.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP078}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
% \TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01&WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Set Theory and its proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{92/03/19} ] Initial Draft.

\item [Issue 1.6 (28th July 1992)]
Bug fixing.
\item [Issue 1.7 (12th October 1992)]
Moved $Ä$ definition to \cite{DS/FMU/IED/DTD052}.
\item [Issue 1.8 (23rd October 1992)]
Change of name and nature to Z Library Set Theory.
\item [Issue 1.9, 11th November 1992] 
Changes as a consequence of changes in dependences.
Added proof contexts ``z$\_$sets$\_$ext'',
``z$\_$sets$\_$alg''
and supporting material.
\item [Issue 1.11, 3rd December 1992] 
Changed $U$ simplification.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the mathematical toolkit for HOL/Z meeting the detailed design
given in \cite{DS/FMU/IED/DTD078}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD078}.
\subsection{Dependencies}
The mathematical toolkit is introduced within the structure
$ZSets$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD078}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZSets$
(see\cite{DS/FMU/IED/DTD078}).

\subsection{Possible Enhancements}
The names of some of the global variables will change once an mechanism for
introducing Z names which do not clash with existing HOL constant
names into the theory database.
For the time being, names common to the toolkit and to HOL have here been
subscripted with $L$ (for library).

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZSets$}

=SML
structure €ZSets› : ZSets = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_sets"›;
val _ = push_merge_pcs ["z_predicates","'z_ç_set_lang", "'propositions", "'z_tuples_lang"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:
=SML
	val z'≠_def = get_spec ¨$"z'_ ≠ _"Æ;
	val z'™_def = get_spec ¨$"z'_ ™ _"Æ;
	val z'Ω_def = get_spec ¨$"z'_ Ω _"Æ;
	val z'é_def = get_spec ¨$"z'_ é _"Æ;
	val z'ö_def = get_spec ¨$"z'ö"Æ;
	val z'†_def = get_spec ¨$"z'_ † _"Æ;
	val z'â1_def = get_spec ¨$"z'â1 _"Æ;
	val z'¿_def = get_spec ¨$"z'_ ¿ _"Æ;
	val z'°_def = get_spec ¨$"z'_ ° _"Æ;
	val z'setdif_def = get_spec ¨$"z'_ \\ _"Æ;
	val z'ﬁ_def = get_spec ¨$"z'ﬁ"Æ;
	val z'•_def = get_spec ¨$"z'•"Æ;
	val z'first_def = get_spec ¨$"z'first"Æ;
	val z'second_def = get_spec ¨$"z'second"Æ;
	val z'∫_def = get_spec ¨$"z'_ ∫ _"Æ;
=TEX
\section{THE CODE}
\subsection{Utilities}
A precaution, lost outside of structure:
=SML
fun €save_thm›(a,b) = KernelInterface.save_thm(a, check_is_z_thm "save_thm" b);
fun €list_save_thm›(a,b) = KernelInterface.list_save_thm(a, check_is_z_thm "list_save_thm" b);
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
val €Ub› = inst [] [(î'bÆ,î'aÆ)] Ua;
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_¡_conv1 nm :CONV= (fn tm =>
		(simple_¡_conv nm
		ORELSE_C
		simple_¡_conv1 (nm ^ get_variant_suffix())) tm);
in
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_¡_conv1 nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_¡_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
end;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX
Change a free variable name:
=SML
fun €change_name_rule› from_nm to_nm thm = (
let	val fvs = map dest_var (frees(concl thm));
	val ty = lassoc3 fvs from_nm;
in
	simple_µ_elim (mk_var(to_nm, ty))
	(simple_µ_intro (mk_var(from_nm, ty)) thm)
end);
=TEX

\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
=SML
fun use_ext_pc () = push_merge_pcs ["z_predicates","'z_ç_set_lang","'z_sets_ext_lang","'propositions", "'z_tuples_lang"];
=TEX
\section{THE IMPLEMENTATION}
\subsection{Set Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua](conv_rule z_para_pred_conv z'Ω_def));
in
val €z_Ω_thm› = save_thm("z_Ω_thm",
	all_z_µ_intro
	(all_µ_elim(
	(conv_rule z_µ_elim_conv1
	(nth 2 (strip_±_rule spec))))));
val €z_é_thm› = save_thm("z_é_thm",
	(nth 3 (strip_±_rule spec)));
end;
=TEX
=SML
local	val _ = use_ext_pc();
	val spec = 
		(list_µ_elim[Ua]
		(rewrite_rule[]z'ö_def));
	val _ = pop_pc();
in
val €z_ö_thm› = save_thm("z_ö_thm",spec);
end;
=TEX
=SML
local
	val spec = all_z_µ_intro
		(all_µ_elim
		(conv_rule z_para_pred_conv z'â1_def));
in
val €z_â1_thm› = save_thm("z_â1_thm",
	spec);
end;
=TEX
=SML
local
	val spec = rewrite_rule[z_sets_ext_thm]
		(list_µ_elim[Ua]
		(rewrite_rule[]z'¿_def));
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_¿_thm› = save_thm("z_¿_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1(nth 0 (strip_±_rule s1)))));
val €z_°_thm› = save_thm("z_°_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1	(nth 1 (strip_±_rule s1)))));
val €z_set_dif_thm› = save_thm("z_set_dif_thm",
	all_z_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1	(nth 2 (strip_±_rule s1)))));
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z'™_def);
in
val €local_z_™_thm› = 
	all_z_µ_intro(all_µ_elim 
	(inst_type_rule[(î'bÆ,î'YÆ),(î'aÆ,î'XÆ)]spec));
end;
=TEX
=SML
val €z_Ä_thm1› = save_thm("z_Ä_thm1", (
set_goal([], ¨µ X:'a SET∑
	Ò((_ Ä _)[X]) ç ( X ™  X) ±
	(µ S, T :  X
            ∑ ((S, T) ç (_ Ä _)[X] § (µ x : X ∑ x ç S ¥ x ç T)))ÆÆ) ;
use_ext_pc();
a(rewrite_tac[z'Ä_def, local_z_™_thm]);
a(PC_T1 "sets_ext" rewrite_tac[]);
a(prove_tac[]);
pop_pc();
pop_thm()));
=TEX
=SML
local
	val spec = 
		(list_µ_elim[Ua]
		z_Ä_thm1);
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_Ä_thm› = save_thm("z_Ä_thm",
	all_z_µ_intro s1);
end;
=TEX
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if ord nm = ordx
		then nm
		else fail "" 0 []);
	fun give_n_names nn lst = (
=SMLLITERAL
	let	fun nextn n = (let val poss = "x" ^ string_of_int n
=SML
			in
			if poss mem lst
			then nextn (n+1)
			else (n,poss)
			end);
		fun nextnm 0 m = []
		| nextnm n m = (let val (ind,next) = nextn m
			in
			(next :: nextnm (n-1) (ind+1))
			end)
	in
		nextnm nn 1
	end);
	val cnv1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z_Ä_thm);
	fun cnv2 nm = cnv1 THEN_C 
			z_µ_elim_conv THEN_C
			RAND_C(simple_¡_conv nm) THEN_C
			z_µ_intro_conv;
	fun uf ty = inst [] [(ty, î'aÆ)] Ua;
	val a_Ä = Ò(_ Ä _)Æ;
	val thm1 = taut_rule ¨µ x y ∑ x ¥ ((y ± T) ¥ x)Æ;
	val thm2 = prove_rule[] ¨µ x y ∑ x ¥ ((y ç ÒUÆ ± T) ¥ x)Æ;
=TEX
=SML
in
val €z_Ä_conv› : CONV = (fn tm =>
let	val (vw,Ä) = dest_z_ç tm
		handle complaint =>
		divert complaint "dest_z_ç" "z_Ä_conv"
			78001 [fn () => string_of_term tm];
	val (v,w) = case dest_z_tuple vw of
		[v,w] => (v,w)
		| _ => term_fail "z_Ä_conv" 78001 [tm];
	val side = term_match Ä a_Ä
		handle (Fail _) =>
		term_fail "z_Ä_conv" 78001 [tm];
	val vty = type_of v;
	val elem_ty = case dest_ctype vty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "z_Ä_conv" 78001 [tm];
	val names = (mapfilter xnames (term_vars v)) cup (mapfilter xnames (term_vars w));
	val res =
	case dest_simple_type elem_ty of
	Ctype (nm,args) => ((case dest_z_name nm of
		("Z'T",[[ns]],Nil) => (
		let 	val n = nat_of_string ns;
			val xs =map mk_var
				(combine
				(give_n_names n names)
				args);
			val xs_decl = mk_z_decl
				(map (fn x => mk_z_dec([x],uf(type_of x))) xs);
			val xs_tuple = mk_z_tuple xs;
			val conc_gl = mk_z_µ(xs_decl,
				mk_t, mk_z_¥(
				mk_z_ç(xs_tuple, v),
				mk_z_ç(xs_tuple, w)));
			val s1 = cnv1 tm;
			val tm' = snd(dest_eq(concl s1));
			val s2 = asm_rule tm';
			val s3 = simple_µ_elim xs_tuple(
				conv_rule z_µ_elim_conv1 s2);
			val s4 = list_simple_µ_elim [concl s3, xs_decl] thm1;
			val s5 = ¥_elim s4 s3;
			val s6 = conv_rule z_µ_intro_conv 
				(list_µ_intro xs s5);
=TEX
Now back the other way:
=SML
			val s7 = asm_rule (concl s6);
			val xv = variant (frees (concl s7)) (mk_var("x",type_of xs_tuple));
			val s8 = z_tuple_selection_intro_conv xv;
			val xparts = dest_z_tuple(snd(dest_eq(concl s8)));
			val s9 = conv_rule z_µ_elim_conv1 s7;
			val s10 = list_µ_elim xparts s9;
			val s11 = conv_rule(RANDS_C (LEFT_C (fn _ => eq_sym_rule s8))) s10;			
			val s12 =  ¥_elim (list_µ_elim [concl s11, xv] thm2) s11;
			val s13 = z_µ_intro s12;
			val s14 = §_intro (all_¥_intro s6) (all_¥_intro s13);	
		in
			eq_trans_rule (refl_conv tm) 
				(eq_trans_rule s1 s14)
		end)
=TEX
=SML
		| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
		handle (Fail _) =>
		(let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
	| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end)
in
	check_is_z_conv_result "z_Ä_conv" res
end);
end; 
=IGN
z_Ä_conv Òp Ä qÆ;
z_Ä_conv Òp Ä r ∏ s ∏ x2Æ;
=TEX
=SML
val _ = use_ext_pc();
val €z_ç__thm› = save_thm ("z_ç__thm",(
set_goal([], Òµ s:U;t:U ∑ s ç  t § s Ä tÆ);
a(REPEAT_N 4 strip_tac THEN rewrite_tac[z_Ä_thm] THEN 
	conv_tac(ONCE_MAP_C z_ç__conv) THEN
	rewrite_tac[]);
pop_thm ()));

val _ = pop_pc();
=TEX

=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(conv_rule z_para_pred_conv z'†_def));
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_†_thm› = save_thm("z_†_thm",
	all_z_µ_intro s1);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]z'ﬁ_def));
	val s1 = list_µ_elim[¨a:'a SET SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
	val s2 = rewrite_rule[z_sets_ext_thm] s1;
	val s4 = prove_rule [all_µ_intro s2] Ò(µ z:U; a:U ∑
		z ç ﬁ a § (∂ S : U ∑ S ç a ± z ç S)) ±
		(µ z:U; a:U ∑
		z ç • a § (µ S : U ∑ S ç a ¥ z ç S))Æ;
		
in
val €z_ﬁ_thm› = save_thm("z_ﬁ_thm", ±_left_elim s4);
val €z_•_thm› = save_thm("z_•_thm", 
	inst_type_rule [(î'aÆ,î'bÆ)]
		(±_right_elim s4));
end;
=TEX
\subsection{Tuple Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]z'first_def));
	val x = mk_var("x",type_of Ò(p,q)Æ);
	val s1 = rewrite_rule[]
		(conv_rule(MAP_C z_tuple_lang_intro_conv)
		(z_µ_elimÒ(x ¶ ÒëxÆ.1Æ, y ¶ ÒëxÆ.2Æ)Æ
		(nth 1 (strip_±_rule spec))));
in
val €z_first_thm› = save_thm("z_first_thm",
	all_z_µ_intro(±_left_elim s1));
val €z_second_thm› = save_thm("z_second_thm",
	all_z_µ_intro(±_right_elim s1));
end;
=TEX

\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun €make_ç_rule› thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun €make_pair_trio_rule› thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_tuple_lang_selection_conv)
		(µ_elim Ò(p1,p2)Æ 
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_tuple_lang_selection_conv)
		(µ_elim Ò(p1 Ì p2)Æ (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val €ç_operator_clauses› = [
	z_ﬁ_thm, z_•_thm,
	z_¿_thm, z_°_thm, z_set_dif_thm, 
	rewrite_rule[z_ç__thm](make_ç_rule z_â1_thm),
	z_ö_thm, z_ç__thm]
=TEX
And, spuriously for the name,
=SML
	@ [z_é_thm, z_Ω_thm];
=TEX 
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX
\subsection{Treatment of Membership of Sets in Z Library}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_set_lib" handle Fail _ => ();
val _ = new_pc "'z_ç_set_lib";
val _ = set_rw_eqn_cxt []"'z_ç_set_lib";
val _ = add_rw_thms 
	(ç_operator_clauses) "'z_ç_set_lib";

val pos = (thms_to_eqn_cxt ç_operator_clauses)
	@ [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_ç_set_lib";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_ç_set_lib";
val _ = set_rw_canons [] "'z_ç_set_lib";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_set_lib";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_set_lib";
val _ = set_cs_∂_convs [] "'z_ç_set_lib";
val _ = set_∂_vs_thms [] "'z_ç_set_lib";
val _ = set_u_simp_eqn_cxt (u_simp_eqn_cxt [z'™_def]) "'z_ç_set_lib";
val _ = commit_pc "'z_ç_set_lib";
=TEX
\subsection{Extensionality Treatment of Sets}
=SML
val _ = delete_pc "'z_sets_ext_lib" handle Fail _ => ();
val _ = new_pc "'z_sets_ext_lib";
val _ = set_rw_eqn_cxt [(Òa Ä bÆ, z_Ä_conv),
		(Ò¨Z'Setd aÆ Ä bÆ, z_setd_Ä_conv)]
	"'z_sets_ext_lib";
val _ = add_rw_thms 
	[z_†_thm] "'z_sets_ext_lib";

val pos = [(Òa Ä bÆ, z_Ä_conv),
		(Ò¨Z'Setd aÆ Ä bÆ, z_setd_Ä_conv)]
	@ thms_to_eqn_cxt [z_†_thm];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_ext_lib";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_ext_lib";
val _ = set_rw_canons [] "'z_sets_ext_lib";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_ext_lib";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_ext_lib";
val _ = set_cs_∂_convs [] "'z_sets_ext_lib";
val _ = set_∂_vs_thms [] "'z_sets_ext_lib";
val _ = commit_pc "'z_sets_ext_lib";
=TEX
=SML
val _ = delete_pc "z_sets_ext" handle Fail _ => ();
val _ = new_pc "z_sets_ext";
val _ = merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_sets_ext_lang", "'z_bindings",
	"'z_ç_set_lib", "'z_sets_ext_lib"] "z_sets_ext";
=TEX
	
=IGN
push_pc "z_sets_ext";
push_goal([],ÒA Ω ö ¥ (• A) \ S = • {T1 : A ∑ T1 \ S}Æ);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 ¨x1'Æ);
a(z_spec_nth_asm_tac 6 ¨T1Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ÒS' \ SÆ);
a(z_spec_nth_asm_tac 1 ¨S'Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Òx1 \ SÆ);
a(z_spec_nth_asm_tac 1 ¨x1Æ);
pop_thm();
=TEX
\section{ALGEBRAIC TREATMENT OF SETS}
\subsection{Supporting Theorems}
=SML
val _ = push_pc "z_sets_ext";
val €z_¿_clauses› = save_thm("z_¿_clauses",(
push_goal([], Ò
	µ a : U ∑
		(a ¿ {} = a)
	±	({} ¿ a = a)
	±	(a ¿ U = U)
	±	(U ¿ a = U)
	±	(a ¿ a = a)Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_°_clauses› = save_thm("z_°_clauses",(
push_goal([], Ò
	µ a : U ∑
		(a ° {} = {})
	±	({} ° a = {})
	±	(a ° U = a)
	±	(U ° a = a)
	±	(a ° a = a)Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_set_dif_clauses› = save_thm("z_set_dif_clauses",(
push_goal([], Ò
	µ a : U∑
		(a \ {} = a)
	±	({} \ a = {})
	±	(a \ U = {})
	±	(a \ a = {})Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_Ä_clauses› = save_thm("z_Ä_clauses",(
push_goal([], Ò
	µ a : U ∑
		(a Ä a)
	±	({} Ä a)
	±	(a Ä U)Æ);
a(REPEAT z_strip_tac);
pop_thm ()));
=TEX
=SML
val €z_†_clauses› = save_thm("z_†_clauses",(
push_goal([], Ò
	µ a : U ∑
		≥ (a † a)
	±	≥ (a † {})
	±	({} † U)Æ);
a(prove_tac[]);
pop_thm ()));
=TEX
=SML
val €z_•_clauses› = save_thm("z_•_clauses",(
push_goal([], Ò
	(• {} = U)
	±	(• U = {})Æ);
a(REPEAT z_strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
a(strip_tac);
a(z_∂_tacÒ{}Æ);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val €z_ﬁ_clauses› = save_thm("z_ﬁ_clauses",(
push_goal([], Ò
	(ﬁ {} = {})
	±	(ﬁ U = U)Æ);
a(REPEAT z_strip_tac);
a(z_∂_tacÒ{x1}Æ);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
val €z__clauses› = save_thm("z__clauses",(
push_goal([], Ò
	µ a : U ∑
		( {} = {{}})
	±	( U = U)
	±	a ç  a
	±	{} ç  aÆ);
a(REPEAT z_strip_tac THEN asm_fc_tac[]);
pop_thm ()));
=TEX
=SML
val €z_â1_clauses› = save_thm("z_â1_clauses",(
push_goal([], Ò
	µ a : U ∑
		(â1 {} = {})
	±	(a ç â1 a § a Ω {})
	±	≥({} ç â1 a)Æ);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(z_∂_tac Òx1Æ);
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(z_∂_tac Òx1Æ);
a(REPEAT strip_tac);
pop_thm ()));
=TEX
=SML
local
	val cnv1 = pure_once_rewrite_conv [z_sets_ext_thm];
	val cnv2 = pure_rewrite_conv [taut_rule
		¨µ x ∑ (x ± F § F) ±
			(F ± x § F) ±
			((F § F) § T)Æ];
in
val €z_seta_false_conv› : CONV = (fn tm =>
let	val (d,p,v) = dest_z_seta tm
			handle (Fail _) =>
			term_fail "z_seta_false_conv" 78002 [tm];
	val dummy = if p =$ mk_f
		then ()
		else term_fail "z_seta_false_conv" 78002 [tm];
	val s1 = tac_proof(([],mk_z_eq(tm, 
			mk_z_setd(dest_z_power_t (type_of tm),[]))),
		conv_tac (cnv1) THEN
		z_µ_tac THEN 
		¥_T (fn _ => id_tac) THEN
		conv_tac(LEFT_C (z_ç_seta_conv THEN_C
			z_∂_inv_conv) THEN_C
		RIGHT_C z_ç_setd_conv
		THEN_C cnv2))
in
	s1
end);
end;
			 
=TEX	
		
\subsection{Proof Contexts}

=SML
val z_sets_alg_thms = [
	z_¿_clauses, z_°_clauses, z_set_dif_clauses,
	z_Ä_clauses, z_†_clauses, z_ﬁ_clauses, z_•_clauses, 
	z__clauses, z_â1_clauses];

val z_sets_alg_strip_thms = [z_Ä_clauses, z_†_clauses] @
	[prove_rule z_sets_alg_thms
	Òµ a:U ∑ (a ç  a) ± ({} ç  a) ± 
		(a ç â1 a § a Ω {}) ±
		(≥ {} ç â1 a)Æ];

val _ = delete_pc "'z_sets_alg" handle Fail _ => ();
val _ = new_pc "'z_sets_alg";
val _ = set_rw_eqn_cxt [(¨y (Ã z ∑ w):'a SETÆ, z_seta_false_conv),
		(¨Z'Seta[0] y:'a SETÆ, z_seta_false_conv)]
	"'z_sets_alg";
val _ = add_rw_thms z_sets_alg_thms "'z_sets_alg";

val pos = thms_to_eqn_cxt z_sets_alg_strip_thms;
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_rw_canons [] "'z_sets_alg";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_alg";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_alg";
val _ = set_cs_∂_convs [] "'z_sets_alg";
val _ = set_∂_vs_thms [] "'z_sets_alg";
val _ = commit_pc "'z_sets_alg";
=TEX
=SML
val _ = delete_pc "z_sets_alg" handle Fail _ => ();
val _ = new_pc "z_sets_alg";
val _ = merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_bindings",
	"'z_ç_set_lib","'z_sets_alg"] "z_sets_alg";
=TEX
=SML
val _ = pop_pc();
val _ = push_pc "z_sets_alg";
=TEX
\section{EPILOG}
=SML
end (* of struct ZSets *);
open ZSets;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
