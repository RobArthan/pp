%  mdt062.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT062}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL, Z}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test data for
the Z type inferrer.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1 (26 May 1992)]
Initial Draft
\item[Issue 1.7 (26th October 1992)]
Corrected a typo preventing loading.
\item[Issue 1.9]
Tests for new treatment of type inference context and nested quotations.
\item[Issues 1.10 (29th October 1992)]
Changes to match Z theory reorganisation.
\item[Issues 1.11 (2nd December 1992)]
Changes to match new treatment of standard-ness etc.
\item[Issues 1.12 (23rd February 1993)]
Changed parent of working theory.
\item[Issues 1.13 (1st March 1993)]
Test for fix of but 109.
\item[Issues 1.14 (2nd March 1993)]
Removed duplicate test identities.
\item[Issues 1.15 (3rd March 1993)]
Test for fix of bug 110.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

The module tests provided in this document test the
Z Type inferrer defined in \cite{DS/FMU/IED/DTD062}.


\subsection{Introduction}

\subsubsection{Background and Purpose}

The purpose of this document is to test
the functions in accordance with the test policy in
\cite{DS/FMU/IED/DTD062} and the guidelines laid out in the
quality plan, \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

This document depends on the signature $ZTypeInference$ specified
in \cite{DS/FMU/IED/DTD062}, and the structure $ZTypeInference$
specified in \cite{DS/FMU/IED/IMP062}. It makes use of the
module test harness described in \cite{DS/FMU/IED/DTD013} and
\cite{DS/FMU/IED/IMP013}.

\subsubsection{Possible Enhancements}

None.

\subsubsection{Deficiencies}

None Known.

\section{INITIALISATION}

Initialise the test harness.

=SML
use_file "dtd013.sml";
use_file "imp013.sml";
=TEX
=SML
	open Unification ZUserInterfaceSupport ZTypeInference;
=TEX
=SML
map diag_line ["Successful execution of these tests will cause error",
"messages to be generated. You should check visually that",
"the error messages are sensible since the harness itself",
"is incapable of doing this. You can consider that the",
"module tests have run successfully provided that",
"	a) you are satisfied with the error messages and",
"	b) that the report states that all module tests have",
"	   passed."];
=TEX
Next, we make the parser and Z type inferrer
directly available to the tests.
=SML
init_mt_results ();
open_theory"z_library";
TypeInference.set_ti_context[];
=TEX
The following is a hack which will be unnecessary, but harmless when
$$ is properly in place:
=SML
case get_zfixity_info "" of
	Value _ => ()
|	Nil =>
¹Z
fun  _
°
\section{SUPPORTING TEST FUNCTIONS}

The functions introduced in this section are using in testing the Z type
inferrer. Their provision enables the test cases to be implmentated in a concise
(and hopefully readable) form.

=SML
fun Ûformat_z_para_termÝ (p as (idl, tm, _)
	: (IDENT list * Z_TM * EXTYPE OPT)) : string = (
	(implode o rev o tl o rev o tl o explode)(format_z_para (ZParaTerm p))
);
=TEX
The function $type\_infer$ is a general interface to the type inferrer, taking
a Z term in string form and producing an inferred Z paragraph.

=SML
fun Ûtype_inferÝ {quot : bool, standard : bool, allow_frees : bool} (s : string) : Z_INFERRED = (
let	val parsed = ZParser.z_parser {is_quot=quot}
			(ZLex.z_lex [Lex.Text s]);
in
	type_check_z_para {standard = standard, allow_frees = allow_frees} parsed
end);
=TEX
The function $formatted\_type\_infer$ produces a formatted form of a type inferred
Z paragraph. The formatted form should be equivalent to the input for paragraphs
which are terms.
=SML
fun Ûformatted_type_inferÝ {quot : bool, standard : bool, allow_frees : bool} (s : string) : string = (
	case type_infer {quot=quot, standard = standard, allow_frees = allow_frees} s of
	ZInferred p => (
		case p of
		ZParaTerm ptm => format_z_para_term ptm
		|_ => format_z_para p
		)
	|ZTypeError info => (print_z_error info;"")
);
=TEX
The following functions provide the general interface to the type inferrer for
use in the module tests.
=SML

fun Ûelim_spacesÝ (s : string) : string = 
	implode ((explode s) drop (fn c => c mem [" ","	"]));


fun Ûtc1Ý (s: string) : string = formatted_type_infer {quot=true, standard=true, allow_frees = false} s;
fun Ûtc2Ý (s: string) : string = formatted_type_infer {quot=false, standard=true, allow_frees = false} s;

fun Ûtq1Ý s = (elim_spaces s) = (elim_spaces (tc1 s));
fun Ûtq2Ý s = (elim_spaces s) = (elim_spaces (tc2 s));

fun Ûxc1Ý (s: string) : string = formatted_type_infer {quot=true, standard=false, allow_frees = true} s;
fun Ûxc2Ý (s: string) : string = formatted_type_infer {quot=false, standard=true, allow_frees = true} s;

fun Ûxq1Ý s = (elim_spaces s) = (elim_spaces (xc1 s));
fun Ûxq2Ý s = (elim_spaces s) = (elim_spaces (xc2 s));
fun Ûxq3Ý s1 s2 = (elim_spaces s1) = (elim_spaces (xc1 s2));

=TEX
=SML
fun Ûmt_run_okÝ rest =
let	val thing = map (fn (x,y,z) => (x,y,z,true)) rest;
in
	mt_run thing
end;

fun Ûmt_run_fail'Ý rest =
let	val msg = gen_fail_msg "Z-Parser" 62000 [];
	val thing = map (fn (x,y,z) => (x,y,z,msg)) rest;
in
	mt_run_fail thing
end;

=TEX

\section{TEST CASES AND TEST DATA}

\subsection{Testing Terms in Extended Z}

\subsubsection{Sequence Display}

=SML
store_mt_results mt_run_ok [
("mdt062.0101", xq1, "§¢"),
("mdt062.0102", xq1, "§1¢"),
("mdt062.0103", xq1, "§1,2¢"),
("mdt062.0104", xq1, "§1,x¢"),
("mdt062.0105", xq1, "§([x:ú]),([x:ú])¢"),
("mdt062.0106", xq1, "§true, false¢"),
("mdt062.0107", xq1, "§ú, ú¢")
];
store_mt_results mt_run_fail' [
("mdt062.0101f", xc1, "§1, ú¢"),
("mdt062.0102f", xc1, "§ðú, ú¢")
];
=TEX
\subsubsection{Set Display}
=SML
store_mt_results mt_run_ok [
("mdt062.0201", xq1, "{1}"),
("mdt062.0202", xq1, "{1}"),
("mdt062.0203", xq1, "{1,2}"),
("mdt062.0204", xq1, "{1,2}  { {1, 2} }"),
("mdt062.0205", xq1, "{ú, ú}")
];
store_mt_results mt_run_fail' [
("mdt062.0201f", xc1, "{1, ú}"),
("mdt062.0202f", xc1, "{ðú, ú}")
];
=TEX
\subsubsection{Set Abstraction}
=SML
store_mt_results mt_run_ok [
("mdt062.0301", xq1, "{x : ú}"),
("mdt062.0302", xq1, "{x : ú | true }"),
("mdt062.0303", xq1, "{x : ú · true }"),
("mdt062.0304", xq1, "{x : ú · x }"),
("mdt062.0305", xq1, "{x : ú | true · true }"),
("mdt062.0306", xq1, "{([x : ú]) · x }"),
("mdt062.0307", xq1, "{([x : ú]); y : ú | x = y · x }"),
("mdt062.0308", xq1, "{([x : ú]); y :  ð ú | x  y · x }"),
("mdt062.0309", xq1, "{y : ð ú | ({x : ú} = y)}"),
("mdt062.0310", xq1, "{y : ð ú | ({x : ú · x} = y)}"),
("mdt062.0311", xq1, "{y : ð ú | ({x : ú} = y) · y}"),
("mdt062.0312", xq1, "{y : ðð ú | ({ {x : ú} } = y)}"),
("mdt062.0313", xq1, "{y : ðð ú | ({ {x : ú · x} } = y)}"),
("mdt062.0314", xq1, "{x : ú | true }")
];
store_mt_results mt_run_fail' [
("mdt062.0301f", xc1, "{x : X | 0}"),
("mdt062.0302f", xc1, "{x : X | 0 · true}")
];
=TEX
\subsubsection{Powerset}
=SML
store_mt_results mt_run_ok [
("mdt062.0401", xq1, "ð {}"),
("mdt062.0402", xq1, "ð ú"),
("mdt062.0403", xq1, "ð {ú}"),
("mdt062.0404", xq1, "ð {ú} = ð {ú}"),
("mdt062.0405", xq1, "ð {ú}  ð ð {ú}"),
("mdt062.0406", xq1, "ð { ([x : ú]) }"),
("mdt062.0407", xq1, "ð { ([x : ú]); y : ð {x} }"),
("mdt062.0408", xq1, "ð ([x : ú])"),
("mdt062.0409", xq1, "ððððð z = ð y"),
("mdt062.0410", xq1, "ð { ð ú } = ð ðð ú"),
("mdt062.0411", xq1, "ð { x : ðð ú } = ð ðð ú")
];
store_mt_results mt_run_fail' [
("mdt062.0401f", xc1, "ð 1"),
("mdt062.0402f", xc1, "(x = 1) ± (ð x)")
];
=TEX
\subsubsection{Tuple Display}

=SML
store_mt_results mt_run_ok [
("mdt062.0501", xq1, "(1,2)"),
("mdt062.0502", xq1, "(ð ú, ú)"),
("mdt062.0503", xq1, "(ú, (ðú, ðú))"),
("mdt062.0504", xq1, "(ú, ðú)  { (ú, ðú) }"),
("mdt062.0505", xq1, "(1,2,3,4,5,6) = (2,3,4,5,6,7)"),
("mdt062.0506", xq1, "(1,2)")
];
store_mt_results mt_run_fail' [
("mdt062.0501f", xc1, "(1,2) = 1"),
("mdt062.0502f", xc1, "(1,2) = (1,2,3)"),
("mdt062.0503f", xc1, "(1,2) = (ú,ú)"),
("mdt062.0504f", xc1, "(1,2) = (ðú, ðú)"),
("mdt062.0505f", xc1, "(x = (1,2)) ± (x = (1,2,3))")
];
=TEX

\subsubsection{Binding Display}
=SML
store_mt_results mt_run_ok [
("mdt062.0601", xq1, "(a¦1, b¦2, c ¦3)"),
("mdt062.0602", xq1, "(a¦(1,2), b¦(1,2))")
];
store_mt_results mt_run_fail' [
("mdt062.0601f", xc1, "(a¦1, b¦2, a ¦3)"),
("mdt062.0602f", xc1, "(a¦(1,2), a¦(1,2))")
];
=TEX

\subsubsection{Product}
=SML
store_mt_results mt_run_ok [
("mdt062.0701", xq1, "ú ¸ ú"),
("mdt062.0702", xq1, "ú ¸ ð ú ¸ ð ú "),
("mdt062.0703", xq1, "ð ú ¸ ú ¸ { x : ú | true · x}"),
("mdt062.0704", xq1, "ð ú ¸ ú ¸ (Ì x : ú · 0)"),
("mdt062.0705", xq1, "(x  ð (ú ¸ ú ¸ ú)); y  x ¸ ð (ú ¸ ú ¸ ú)")
];
store_mt_results mt_run_fail' [
("mdt062.0701f", xc1, "1 ¸ 2"),
("mdt062.0702f", xc1, "ð ú ¸ ú ¸ ( Í x : ú · x)")
];
=TEX
\subsubsection{Theta}
=SML
store_mt_results mt_run_ok [
("mdt062.0801", xq1, "Ê ([x:X])"),
("mdt062.0802", xq1, "Ê ([x:X])'"),
("mdt062.0803", xq1, "Ê ([x:X])' = Ê [x:X]"),
("mdt062.0804", xq1, "Ê ([a,b,c:ú])' =(a¦1, b¦2, c¦3)")
];
store_mt_results mt_run_fail' [
("mdt062.0801f", xc1, "Ê 1"),
("mdt062.0802f", xc1, "Ê (Ê ([x:X]))")
];
=TEX
\subsubsection{Tuple Selection}
=SML
store_mt_results mt_run_ok [
("mdt062.0901", xq1, "(1,2,3).1"),
("mdt062.0902", xq1, "(a,b,c).2"),
("mdt062.0903", xq1, "(a,b,c).3"),
("mdt062.0904", xq1, "(a,b).2")
];
store_mt_results mt_run_fail' [
("mdt062.0901f", xc1, "(1,2,3).0"),
("mdt062.0902f", xc1, "1.0"),
("mdt062.0903f", xc1, "(1,2,3).4")
];
=TEX
\subsubsection{Binding Selection}
=SML
store_mt_results mt_run_ok [
("mdt062.1001", xq1, "(Ê[a:ú]).a"),
("mdt062.1002", xq1, "s=Ê[a:ú] ± s.a = 0"), 
("mdt062.1003", xq1, "(Ê[a:ú;b,c,d:ðú]).d = d")
];
store_mt_results mt_run_fail' [
("mdt062.1001f", xc1, "1.a"),
("mdt062.1002f", xc1, "Ê[x:ú].a"),
("mdt062.1003f", xc1, "s=Ê[a:ú] ± s.c"), 
("mdt062.1004f", xc1, "Ê[a,b,c:ú].abcde")
];
=TEX
\subsubsection{Application}
=SML
store_mt_results mt_run_ok [
("mdt062.1101", xq1, "f a"),
("mdt062.1102", xq1, "{(0, A),(1, B), (2, C)} 1")
];
store_mt_results mt_run_fail' [
("mdt062.1101f", xc1, "1 1"),
("mdt062.1102f", xc1, "(1,2) 3"),
("mdt062.1103f", xc1, "(Ìx : ú · true) (1,2)")
];
=TEX
\subsubsection{Lambda Abstraction}
=SML
store_mt_results mt_run_ok [
("mdt062.1201", xq1, "(Ìx : ú · true)"),
("mdt062.1202", xq1, "(Ì ([x,y:ú]) | x=y · (x,y))"),
("mdt062.1203", xq1, "(Ìx : ú | true · a)")
];
=TEX
\subsubsection{Definite Description}
=SML
store_mt_results mt_run_ok [
("mdt062.1301", xq1, "(Íx : ú · true)"),
("mdt062.1302", xq1, "(Í ([x,y:ú]) | x=y · (x,y))"),
("mdt062.1303", xq1, "(Íx : ú | true · a)")
];
=TEX
\subsubsection{Truth}
=SML
store_mt_results mt_run_ok [
("mdt062.1401", xq1, "true"),
("mdt062.1402", xq1, "false")
];
=TEX
\subsubsection{Predicate Negation}
=SML
store_mt_results mt_run_ok [
("mdt062.1501", xq1, "³ true"),
("mdt062.1502", xq1, "³false"),
("mdt062.1503", xq1, "³ ³ false")
];
store_mt_results mt_run_fail' [
("mdt062.1501f", xc1, "³ 1")
];
=TEX
\subsubsection{Logical Infix Operators for Predicates}
=SML
store_mt_results mt_run_ok [
("mdt062.1601", xq1, "true ± true"),
("mdt062.1602", xq1, "true ² false"),
("mdt062.1603", xq1, "false ´ true"),
("mdt062.1604", xq1, "true ¤ true"),
("mdt062.1605", xq1, "true; true")
];
store_mt_results mt_run_fail' [
("mdt062.1601f", xc1, "1 ± true"),
("mdt062.1602f", xc1, "true ± 1"),
("mdt062.1603f", xc1, "true ² 1"),
("mdt062.1604f", xc1, "true ´ 1"),
("mdt062.1605f", xc1, "true ¤ 1"),
("mdt062.1606f", xc1, "true ; 1"),
("mdt062.1607f", xc1, "1 ; true")
];
=TEX
\subsubsection{Predicate Quantification}
=SML
store_mt_results mt_run_ok [
("mdt062.1701", xq1, "µ x, y : ú · x = y"),
("mdt062.1702", xq1, "¶ x:ú · µ y : ú · x = y"),
("mdt062.1703", xq1, "¶‰1 x:{1,2,3} · x = 2"),
("mdt062.1704", xq1, "µ ([x:ú; y:î]); a,b : ú · ¶ p:ú · p = x ² p=y ² p=a ² p=b"),
("mdt062.1705", xq1, "¶ x:ú · true")
];
store_mt_results mt_run_fail' [
("mdt062.1701f", xc1, "µ x :ú · x"),
("mdt062.1702f", xc1, "¶ x :ú · x"),
("mdt062.1703f", xc1, "¶‰1 x :ú · x"),
("mdt062.1704f", xc1, "µ x:ú ·¶ y:ú · 0")
];
=TEX
\subsubsection{Schemas as Predicates}
=SML
store_mt_results mt_run_ok [
("mdt062.1801", xq1, "{x:ú | true ± [y:ú] }"),
("mdt062.1802", xq1, "µ x : ú · ([a,b,c:ú])")
];
=TEX
\subsubsection{Horizontal Schemas}
=SML
store_mt_results mt_run_ok [
("mdt062.1901", xq1, "[x:ú]"),
("mdt062.1902", xq1, "[x:ú | x=0]"),
("mdt062.1903", xq1, "[x,y,z:ú] ± x=0")
];
store_mt_results mt_run_fail' [
("mdt062.1901f", xc1, "[x,y,z:ú] ± x=(1,2)")
];
=TEX
\subsubsection{Decoration}
=SML
store_mt_results mt_run_ok [
("mdt062.2001", xq1, "([x:ú])'"),
("mdt062.2002", xq1, "([x:ú])!"),
("mdt062.2003", xq1, "([x:ú])?"),
("mdt062.2004", xq1, "x?")
];
store_mt_results mt_run_fail' [
("mdt062.2001f", xc1, "(a=b)'"),
("mdt062.2002f", xc1, "(f x)!"),
("mdt062.2003f", xc1, "(x)?")
];
=TEX
\subsubsection{Precondition}
=SML
store_mt_results mt_run_ok [
("mdt062.2101", xq1, "pre ([x:ú])"),
("mdt062.2102", xq1, "pre (([x:ú])!)"),
("mdt062.2103", xq1, "pre [x', y?, z! : ú]")
];
store_mt_results mt_run_fail' [
("mdt062.2101f", xc1, "pre 0"),
("mdt062.2102f", xc1, "pre {1,2,3}")
];
=TEX
\subsubsection{Schema Negation}
=SML
store_mt_results mt_run_ok [
("mdt062.2201", xq1, "[(³ [x:ú])]"),
("mdt062.2202", xq1, "[(³ ³ ([x:ú]))]")
];
=TEX
\subsubsection{Logical Infix Operators for Schemas}
These particular tests require us to use standard mode for z terms
since this is the only way we can ensure that the schemas which occur in
the terms are not interpreted as predicates.
=SML
store_mt_results mt_run_ok [
("mdt062.2301", xq1, "[[x:ú] ± [y:ú]]"),
("mdt062.2302", xq1, "[[x:ú] ² [y:ú]]"),
("mdt062.2303", xq1, "[[x:ú] ´ [y:ú]]"),
("mdt062.2304", xq1, "[[x:ú] ¤ [y:ú]]"),
("mdt062.2305", xq1, "[[x:ú] ; [y:ú]]")
];
store_mt_results mt_run_fail' [
("mdt062.2301f", xc1, "[1 ± [y:ú]]"),
("mdt062.2302f", xc1, "[[x:ú] ± 1]"),
("mdt062.2303f", xc1, "[1 ² [y:ú]]"),
("mdt062.2304f", xc1, "[1 ´ [y:ú]]"),
("mdt062.2305f", xc1, "[1 ¤ [y:ú]]"),
("mdt062.2306f", xc1, "[1 ; [y:ú]]")
];
=TEX
\subsubsection{Schema Projection}
=SML
store_mt_results mt_run_ok [
("mdt062.2401", xq1, "[x,y,z:ú] ù‰s [x:ú]"),
("mdt062.2402", xq1, "[x:ú] ù‰s [y:ú]")
];
store_mt_results mt_run_fail' [
("mdt062.2401f", xc1, "2 ù‰s [x:ú]"),
("mdt062.2402f", xc1, "[x:ú] ù‰s 2"),
("mdt062.2403f", xc1, "2 ù‰s 2"),
("mdt062.2404f", xc1, "[x:ú] ù‰s [x: seq ú]")
];
=TEX
\subsubsection{Schema Hiding}
=SML
store_mt_results mt_run_ok [
("mdt062.2501", xq1, "[x,y,z:ú] \\‰s  (x,y,z)"),
("mdt062.2502", xq1, "[x:ú] \\‰s  (x)")
];
store_mt_results mt_run_fail' [
("mdt062.2501f", xc1, "1 \\‰s (a) ")
];
=TEX
\subsubsection{Schema Quantification}
=SML
store_mt_results mt_run_ok [
("mdt062.2601", xq1, "µ x: ú · [x,y,z : ú]"),
("mdt062.2602", xq1, "¶ y : ú | y = 5 · [y, z:ú | y = z]"),
("mdt062.2603", xq1, "¶‰1 y : ú | true · [y:X | true]"),
("mdt062.2604", xq1, "¶‰1 y : ú | [x:X] · [y:X | true]")
];
store_mt_results mt_run_fail' [
("mdt062.2601f", xc1, "[(¶ x:ú · true) ± [y:ú]]"),
("mdt062.2602f", xc1, "[(µ x:ú · [x, y:seq ú])]"),
("mdt062.2603f", xc1, "[(¶ x:ú · [y:ú]) ± [y:ú]]")
];
=TEX
\subsubsection{„ and ˜}
=SML
store_mt_results mt_run_ok [
("mdt062.2701", xq1, "[„[x:ú] | x=x']"),
("mdt062.2702", xq1, "„[x:ú]"),
("mdt062.2703", xq1, "[˜[x:ú] | x=x']"),
("mdt062.2704", xq1, "˜[x:ú]")
];
store_mt_results mt_run_fail' [
("mdt062.2701f", xc1, "„ 1"),
("mdt062.2702f", xc1, "˜ 1")
];
=TEX
\subsubsection{Set Membership and Equality}
=SML
store_mt_results mt_run_ok [
("mdt062.2801", xq1, "x  {x}"),
("mdt062.2802", xq1, "a  ð a"),
("mdt062.2803", xq1, "ú  {ú,ú}"),
("mdt062.2804", xq1, "0=0"),
("mdt062.2805", xq1, "a = 2 ² a  ú")
];
store_mt_results mt_run_fail' [
("mdt062.2801f", xc1, "1  1"),
("mdt062.2802f", xc1, "§1,2,3¢  {1,2,3}"),
("mdt062.2803f", xc1, "§1,2,3¢ = 1"),
("mdt062.2804f", xc1, "a = 1 ; a  {ú}")
];
=TEX
\subsubsection{Schema Composition}
=SML
store_mt_results mt_run_ok [
("mdt062.2901", xq1, "[x,y,z:ú] »‰s [x:ú]"),
("mdt062.2902", xq1, "[x:ú] »‰s [y:ú]")
];
store_mt_results mt_run_fail' [
("mdt062.2901f", xc1, "2 »‰s [x:ú]"),
("mdt062.2902f", xc1, "[x:ú] »‰s 2"),
("mdt062.2903f", xc1, "2 »‰s 2"),
("mdt062.2904f", xc1, "[x:ú] »‰s [x: seq ú]")
];
=TEX
\subsubsection{Schema Piping}
=SML
store_mt_results mt_run_ok [
("mdt062.3001", xq1, "[x,y,z:ú] >> [x:ú]"),
("mdt062.3002", xq1, "[x:ú] >> [y:ú]")
];
store_mt_results mt_run_fail' [
("mdt062.3001f", xc1, "2 >> [x:ú]"),
("mdt062.3002f", xc1, "[x:ú] >> 2"),
("mdt062.3003f", xc1, "2 >> 2"),
("mdt062.3004f", xc1, "[x:ú] >> [x: seq ú]")
];
=TEX
\subsubsection{Integers and String Quotation}
String quotations may not appear in strings since they are processed by
reader/writer term recognisers. There is no simple way of testing
string quotation until the recognisers are in place.
=SML
store_mt_results mt_run_ok [
("mdt062.3101", xq1, "0"),
("mdt062.3102", xq1, "99999999")
];
=TEX
\subsubsection{Casts}
The constructor for type constraints is not used, and the ``fat colon''
is now defined as a global variable in the Z library.
=SML
store_mt_results mt_run_ok [
("mdt062.3201", xq3 "var", "var º X"),
("mdt062.3202", xq3 "bool", " bool")
];
store_mt_results mt_run_fail' [
("mdt062.3201f", xc2, "1 º ú"),
("mdt062.3202f", xc2, "(bool)")
];
=TEX
\subsubsection{Local Variables}
=SML
store_mt_results mt_run_ok [
("mdt062.3301", xq1, "µ x:ðú · (µ x,y : ú ¸ ú · x=y) ± x={0}"),
("mdt062.3302", xq1, "[x:ú | x=0] ± x=0"),
("mdt062.3303", xq1, "µ x:ðú · (µ x,y : ú ¸ ú · x=y) ± x={0}"),
("mdt062.3304", xq1, "[x:ú | x=0] ± x=0")
];
=TEX
\subsubsection{Global Variables}
The tests for global variables require the Z library to be present.
The tests for the Z library tests these features more thoroughly.
=SML
store_mt_results mt_run [
("mdt062.3401", xc1, "š", "š[U[Totality]]"),
("mdt062.3402", xc1, "š[U]", "š[U[Totality]]")
];
store_mt_results mt_run_ok [
("mdt062.3403", xq1, "î‰1")
];
=TEX
\subsubsection{Let Expressions}
=SML
store_mt_results mt_run_ok [
("mdt062.3501", xq1, "let x ¦ 1, y ¦ 2 · (x,y)"),
("mdt062.3502", xq1, "let a¦[x:ú], b ¦ [y,z:ú] · a ; b")
];
=TEX
\subsubsection{Renaming}
=SML
store_mt_results mt_run_ok [
("mdt062.3601", xq1, "[b,d:ú] [a/b, c/d]"),
("mdt062.3602", xq1, "[x:ú] [abcdefg/x]")
];
store_mt_results mt_run_fail' [
("mdt062.3601f", xc1, "1 [a/b,c/d]"),
("mdt062.3602f", xc1, "[a:ú] [a/b, c/b]"),
("mdt062.3603f", xc1, "[a:ú] [a/b, a/c]")
];
=TEX
\subsubsection{Bracketed Terms}
=SML
store_mt_results mt_run_ok [
("mdt062.3701", xq1, "1=(1)"),
("mdt062.3702", xq1, "((((((((1,2,(((((((3))))))))))))))= ((1,2,3)))")
];
=TEX

\subsubsection{Term Quotation}
Term quotations may not appear in strings since they are processed by
reader/writer term recognisers. As stated in the detailed
design there is no simple way of testing correct operation of 
term quotation until the term generator is in place.
We can however test the error cases:
=TEX
=SML
fun Ûtq_formatted_type_inferÝ 
	(s1 : string) (tm : TERM) (s2 : string) : string = (
let	val parsed = ZParser.z_parser {is_quot=true}
			(ZLex.z_lex [Lex.Text s1, Lex.Term tm, Lex.Text s2]);
in
	case type_check_z_para {standard = false, allow_frees = true} parsed of
			ZInferred p => (
		case p of
		ZParaTerm ptm => format_z_para_term ptm
		|_ => format_z_para p
		)
	|ZTypeError info => (print_z_error info;"")
end);
fun tfti (s1, tm, s2) = tq_formatted_type_infer s1 tm s2;
val t3703f =
	let val t1 = ¬x:ú­ú®; val t2 = ¬x:ú®
	in	mk_app(t1, t2)
	end;

=SML
store_mt_results mt_run_fail' [
("mdt062.3701f", tfti, ("x=(1,2)±", ¬x = 1®, "") ),
("mdt062.3702f", tfti, ("x = (1,2) ± ", ¬x = {}®, "")),
("mdt062.3703f", tfti, ("", ‘t3703f®, "")),
("mdt062.3704f", tfti, ("x? = (1,2) ± ", ¬$"x?" = {}®, ""))
];
=TEX
\subsection{Inferring Types in Z Paragraphs}

It is difficult to test the correctness
of types in Z paragraphs without having the paragraph processor available. The
testing of these this is left to the module tests of the Z paragraph processor. 

\subsection{Free Variables}
Free variables are permitted in extended Z but not in standard Z. This
is tested as follows:

=SML
store_mt_results mt_run_ok [
("mdt062.5001", xq1, "x"),
("mdt062.5002", xq1, "§a, b, c¢"),
("mdt062.5003", xq1, "let a ¦ X · (a,a)")
];
store_mt_results mt_run_fail' [
("mdt062.5001f", tc1, "x"),
("mdt062.5002f", tc1, "§a, b, c¢"),
("mdt062.5003f", tc1, "let a ¦ X · (a,a)")
];
=TEX

\subsection{Testing the function $make\_chartuple$}

=SML
val ZInferred p1 = type_infer {quot = true, standard = false, allow_frees = true} "[x,y:ú]";
val ZParaTerm (_,ZTmHorizSchema sch1, _) = p1;
val ZInferred p2 = type_infer {quot = true, standard = false, allow_frees = true} "[x:ú; y:X]";
val ZParaTerm (_,ZTmHorizSchema sch2, _) = p2;
val ZInferred p3 = type_infer {quot = true, standard = false, allow_frees = true} "[x, y : ú; a:X]";
val ZParaTerm (_,ZTmHorizSchema sch3, _) = p3;

val do_600i = format_z_tm o fst o make_chartuple;

store_mt_results mt_run [
("mdt062.6001", do_600i, sch1, "(x, y)"),
("mdt062.6002", do_600i, sch2, "(x, y)"),
("mdt062.6003", do_600i, sch3, "(x, y, a)")
];
=TEX

\subsection{Testing the function $type\_of\_z\_extype$}

=SML
store_mt_results (mt_runf ( (op =:))) [
("mdt062.7001", type_of_z_extype, ExType ("BOOL", []), BOOL),
("mdt062.7002", type_of_z_extype, ExVartype (Known "fred"), mk_vartype "fred"),
("mdt062.7003", type_of_z_extype, ExVartype (Unknown 25), mk_vartype "'a")
];
=TEX
\subsection{Testing Integration with Type Context Mechanism}
=SML
val ZInferred (ZParaTerm(_,_, Value ty7_1)) = type_infer {quot = true, standard = false, allow_frees = true} "x";
TypeInference.set_ti_context[¬x:î®, ¬y':î ¸ î®, ¬$"x?":BOOL®];
val ZInferred (ZParaTerm(_,_, Value ty7_2)) = type_infer {quot = true, standard = false, allow_frees = true} "x";
val ZInferred (ZParaTerm(_,_, Value ty7_3)) = type_infer {quot = true, standard = false, allow_frees = true} "y'";
val ZInferred (ZParaTerm(_,_, Value ty7_4)) = type_infer {quot = true, standard = false, allow_frees = true} "x?";

=SML
store_mt_results (mt_runf ( (op =:))) [
("mdt062.8001", type_of_z_extype, ty7_1,  ”'a®),
("mdt062.8002", type_of_z_extype, ty7_2,  ”î®),
("mdt062.8003", type_of_z_extype, ty7_3,  ”î ¸ î®),
("mdt062.8004", type_of_z_extype, ty7_4,  ”BOOL®)
];
=TEX
\subsection{Regression Tests for Bug Fixes}
Cross referenced to bug database.
=SML
store_mt_results mt_run_ok [
("mdt062.9001", xq1, "µx:A·µa:A; b : B; x:A¸B·x = (a, b)")		(* HAT 109 *)
];
store_mt_results mt_run_fail' [
("mdt062.9002f", xc1, "(Ê[a:BOOL], a) = (x, (y, z))")		(* HAT 110 *)
];

=TEX


\section{EPILOGUE}

=SML
diag_string (summarize_mt_results());
=TEX
%\newpage
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}

