%  mdt016.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT062}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL, Z}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test data for
the Z type inferrer.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1 (26 May 1992)]
Initial Draft
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

\subsection{Introduction}

\subsubsection{Background and Purpose}

The purpose of this document is to test
the functions in accordance with the test policy in
\cite{DS/FMU/IED/DTD062} and the guidelines laid out in the
quality plan, \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

This document depends on the signature $ZTypeInference$ specified
in \cite{DS/FMU/IED/DTD062}, and the structure $ZTypeInference$
specified in \cite{DS/FMU/IED/IMP062}. It makes use of the
module test harness described in \cite{DS/FMU/IED/DTD013} and
\cite{DS/FMU/IED/IMP013}.

\subsubsection{Possible Enhancements}

None.

\subsubsection{Deficiencies}

None Known.

\section{MODULE TEST DESIGN}

The module tests provided in this document test the
Z Type inferrer defined in \cite{DS/FMU/IED/DTD062}.



\section{INITIALISATION}

Initialise the test harness.

=SML
use_file "dtd013.sml";
use_file "imp013.sml";
=TEX
=SML
map diag_line ["Successful execution of these tests will cause error",
"messages to be generated. You should check visually that",
"the error messages are sensible since the harness itself",
"is incapable of doing this. You can consider that the",
"module tests have run successfully provided that",
"	a) you are satisfied with the error messages and",
"	b) that the report states that all module tests have",
"	   passed."];
=TEX
Next, we make the parser and Z type inferrer
directly available to the tests.
=SML
init_mt_results ();
open_theory"z_library";
delete_theory"mdt062" handle Fail _ => ();
new_theory"mdt062";
open ZUserInterfaceSupport;
=TEX

\section{SUPPORTING TEST FUNCTIONS}

The functions introduced in this section are using in testing the Z type
inferrer. Their provision enables the test cases to be implmentated in a concise
(and hopefully readable) form.

The function $gen\_type\_check$ is a generalised interface to the type checker,
parameterised by details of usage. The function is called indirectly by
the test code via functions $tc1$, $tq1$ etc.
=SML
fun Ûzpara_to_stringÝ (p : Z_PARA) : string = (
=SMLLITERAL
	case p of
	ZParaAbbDef (id, idl, tm, oty) =>
		(format_ident id)^(format_ident_list idl)
			^" ¦ "^(format_ztm tm)^(format_oty oty)
	|ZParaSchBox (id, idl, sch as (decl, otm), oty) =>
		"ÿ"^(format_ident id)^(format_ident_list idl)^"ü"^
		(format_zdec_list decl)^(
			case otm of
			Nil => "ˆ"
			|Value tm => "÷"^(format_ztm tm)^"ˆ"
		)
	|ZParaAxDes (idl, sch as (decl, otm), _) =>
		"@ZAX"^(format_ident_list idl)^
		(format_zdec_list decl)^(
			case otm of
			Nil => "°"
			|Value tm => "÷"^(format_ztm tm)^"°"
		)
	|ZParaFreeType ftl => (format_list format_zparafreetype ftl " & ")
	|ZParaGivenSet (idl, oidltm) =>
		(format_ident_list idl)^(
			case oidltm of
			Nil => ""
			|Value (idl', tm) => (format_ident_list idl')^" & "^(format_ztm tm)
		)
	|ZParaConstraint (idl, tm) =>
		(format_ident_list idl)^(format_ztm tm)
	|ZParaConjecture (oid, idl, tm) =>
		(case oid of
		Nil => ""
		|Value id => (format_ident id)^" "
		)^(format_ident_list idl)^" ?ô "^(format_ztm tm)
	|ZParaTerm (idl, tm, oty) =>
		(format_ident_list idl)^(format_ztm tm)
	|ZParaFixity fix => (
		case fix of
		(ZClFun i, tmpl) => "fun "^(string_of_int i)^" "^
			(format_list format_template tmpl ", ")
		|(ZClRel, tmpl) => "rel "^(format_list format_template tmpl ", ")
		|(ZClGen i, tmpl) => "gen "^(string_of_int i)^" "^
			(format_list format_template tmpl ", ")
		)
);
=TEX
=SML
fun Ûgen_type_checkÝ {quot : bool, standard : bool} (s : string) : ZINFERRED = (
let	val parsed = ZParser.zparser {is_quot=quot, standard=standard}
			(ZLex.zlex [Lex.Text s]);
in
	type_check_zpara {standard = standard} parsed
end);

fun Ûtype_check_okÝ {quot : bool, standard : bool} (s : string) : string = (
	case gen_type_check {quot=quot, standard = standard} s of
	Inferred (p, _) => zpara_to_string p
	|TypeError info => (print_zerror info;"")
);


fun Ûelim_spacesÝ (s : string) : string = 
	implode ((explode s) drop (fn c => c mem [" ","	"]));


fun Ûtc1Ý (s: string) : string = type_check_ok {quot=true, standard=true} s;
fun Ûtc2Ý (s: string) : string = type_check_ok {quot=false, standard=true} s;

fun Ûtq1Ý s = (elim_spaces s) = (elim_spaces (tc1 s));
fun Ûtq2Ý s = (elim_spaces s) = (elim_spaces (tc2 s));

fun Ûxc1Ý (s: string) : string = type_check_ok {quot=true, standard=false} s;
fun Ûxc2Ý (s: string) : string = type_check_ok {quot=false, standard=false} s;

fun Ûxq1Ý s = (elim_spaces s) = (elim_spaces (xc1 s));
fun Ûxq2Ý s = (elim_spaces s) = (elim_spaces (xc2 s));
fun Ûxq2Ý s = (elim_spaces s) = (elim_spaces (xc2 s));

=TEX
=SML
fun mt_run_ok rest =
let	val thing = map (fn (x,y,z) => (x,y,z,true)) rest;
in
	mt_run thing
end;

fun mt_run_fail' rest =
let	val msg = gen_fail_msg "Z-Parser" 62000 [];
	val thing = map (fn (x,y,z) => (x,y,z,msg)) rest;
in
	mt_run_fail thing
end;

=TEX

\section{TEST CASES AND TEST DATA}

\subsection{Testing Terms in Extended Z}

These tests use the function $xc1$.

\subsubsection{Sequence Display}

=SML
store_mt_results mt_run_ok [
("mdt062.101", xq1, "§¢"),
("mdt062.102", xq1, "§1¢"),
("mdt062.103", xq1, "§1,2¢"),
("mdt062.103", xq1, "§1,x¢"),
("mdt062.103", xq1, "§([x:ú]),([x:ú])¢"),
("mdt062.103", xq1, "§true, false¢"),
("mdt062.104", xq1, "§ú, ú¢")
];
store_mt_results mt_run_fail' [
("mdt062.101f", xc1, "§1, ú¢"),
("mdt062.102f", xc1, "§1, ú, ú¢")
];
=TEX
\subsubsection{Set Display}
=SML
store_mt_results mt_run_ok [
("mdt062.201", xq1, "{1}"),
("mdt062.202", xq1, "{1}"),
("mdt062.203", xq1, "{1,2}"),
("mdt062.203", xq1, "{1,2}  { {1, 2} }"),
("mdt062.204", xq1, "{ú, ú}")
];
store_mt_results mt_run_fail' [
("mdt062.201f", xc1, "{1, ú}"),
("mdt062.202f", xc1, "{1, ú, ú}")
];
=TEX
\subsubsection{Set Abstraction}
=SML
store_mt_results mt_run_ok [
("mdt062.301", xq1, "{x : ú}"),
("mdt062.302", xq1, "{x : ú | true }"),
("mdt062.303", xq1, "{x : ú · true }"),
("mdt062.304", xq1, "{x : ú · x }"),
("mdt062.305", xq1, "{x : ú | true · true }"),
("mdt062.306", xq1, "{([x : ú]) · x }"),
("mdt062.306", xq1, "{([x : ú]); y : ú | x = y · x }"),
("mdt062.306", xq1, "{([x : ú]); y :  ð ú | x  y · x }"),
("mdt062.306", xq1, "{y : ð ú | ({x : ú} = y)}"),
("mdt062.306", xq1, "{y : ð ú | ({x : ú · x} = y)}"),
("mdt062.306", xq1, "{y : ð ú | ({x : ú} = y) · y}"),
("mdt062.306", xq1, "{y : ðð ú | ({ {x : ú} } = y)}"),
("mdt062.306", xq1, "{y : ðð ú | ({ {x : ú · x} } = y)}"),
("mdt062.307", xq1, "{x : ú | true }")
];
=TEX
\subsubsection{Powerset}
=SML
store_mt_results mt_run_ok [
("mdt062.401", xq1, "ð {}"),
("mdt062.402", xq1, "ð ú"),
("mdt062.403", xq1, "ð {ú}"),
("mdt062.403", xq1, "ð {ú} = ð {ú}"),
("mdt062.403", xq1, "ð {ú}  ð ð {ú}"),
("mdt062.404", xq1, "ð { ([x : ú]) }"),
("mdt062.404", xq1, "ð { ([x : ú]); y : ð {x} }"),
("mdt062.404", xq1, "ð ([x : ú])"),
("mdt062.404", xq1, "ððððð z = ð y"),
("mdt062.404", xq1, "ð { ð ú } = ð ðð ú"),
("mdt062.404", xq1, "ð { x : ðð ú } = ð ðð ú")
];
store_mt_results mt_run_fail' [
("mdt062.501f", xc1, "ð 1"),
("mdt062.502f", xc1, "(x = 1) ± (ð x)")
];
=TEX
\subsubsection{Tuple Display}

=SML
store_mt_results mt_run_ok [
("mdt062.501", xq1, "(1,2)"),
("mdt062.501", xq1, "(ð ú, ú)"),
("mdt062.501", xq1, "(ú, (ðú, ðú))"),
("mdt062.501", xq1, "(ú, ðú)  { (ú, ðú) }"),
("mdt062.501", xq1, "(1,2,3,4,5,6) = (2,3,4,5,6,7)"),
("mdt062.501", xq1, "(1,2)")
];
store_mt_results mt_run_fail' [
("mdt062.501f", xc1, "(1,2) = 1"),
("mdt062.502f", xc1, "(1,2) = (1,2,3)"),
("mdt062.502f", xc1, "(1,2) = (ú,ú)"),
("mdt062.502f", xc1, "(1,2) = (ðú, ðú)"),
("mdt062.502f", xc1, "(x = (1,2)) ± (x = (1,2,3))")
];
=TEX
\subsubsection{Product}
=SML
store_mt_results mt_run_ok [
("mdt062.601", xq1, "ú ¸ ú"),
("mdt062.601", xq1, "ú ¸ ð ú ¸ ð ú "),
("mdt062.601", xq1, "ð ú ¸ ú ¸ { x : ú | true · x}"),
("mdt062.601", xq1, "ð ú ¸ ú ¸ (Ì x : ú · 0)"),
("mdt062.601", xq1, "(x  ð (ú ¸ ú ¸ ú)); y  x ¸ ð (ú ¸ ú ¸ ú)")
];
store_mt_results mt_run_fail' [
("mdt062.601f", xc1, "1 ¸ 2"),
("mdt062.601f", xc1, "ð ú ¸ ú ¸ ( Í x : ú · x)")
];
=TEX


\subsubsection{Theta}

=SML
mt_run_ok [
("mdt062.001", xq1, "Ê ([x:X])"),
("mdt062.001", xq1, "Ê ([x:X])'")
];
=TEX
=SML
store_mt_results mt_run_fail' [
("mdt062.601f", xc1, "Ê 1"),
("mdt062.601f", xc1, "Ê (Ê ([x:X]))")
];
=TEX

\subsubsection{Tuple Selection}

=SML
store_mt_results mt_run_ok [
("mdt062.001", xq1, "(1,2,3).1"),
("mdt062.001", xq1, "(a,b,c).2"),
("mdt062.001", xq1, "(a,b,c).3"),
("mdt062.001", xq1, "(a,b).2")
];
=TEX
=SML
store_mt_results mt_run_fail' [
("mdt062.601f", xc1, "(1,2,3).0"),
("mdt062.601f", xc1, "(1,2,3).4")
];
=TEX

\subsubsection{Binding Selection}

=SML
store_mt_results mt_run_ok [
("mdt062.001", xq1, "(1,2,3).1"),
("mdt062.001", xq1, "(a,b,c).2"),
("mdt062.001", xq1, "(a,b,c).3"),
("mdt062.001", xq1, "(a,b).2")
];
=TEX
=SML
store_mt_results mt_run_fail' [
("mdt062.601f", xc1, "(1,2,3).0"),
("mdt062.601f", xc1, "(1,2,3).4")
];
=TEX

\subsubsection{Application}
=SML
store_mt_results mt_run_ok [
("mdt062.001", xq1, "f a"),
("mdt062.001", xq1, "{(0, A),(1, B), (2, C)} 1"),
];
=TEX
\subsubsection{Lambda Abstraction}
\subsubsection{Definite Description}
\subsubsection{Predicate Negation}
\subsubsection{Logical Infix Operators for Predicates}
\subsubsection{Predicate Quantification}
\subsubsection{Schemas as Predicates}
\subsubsection{Horizontal Schemas}
\subsubsection{Decoration}
\subsubsection{Precondition}
\subsubsection{Schema Negation}
\subsubsection{Logical Infix Operators for Schemas}
\subsubsection{Schema Hiding}
\subsubsection{Schema Quantification}
\subsubsection{„ and ˜}
\subsubsection{Set Membership and Equality}
\subsubsection{Schema Composition}

\subsubsection{Schema Piping}
\subsubsection{Integers and String Quotation}
\subsubsection{Type Constraints}
\subsubsection{Local Variables}
\subsubsection{Global Variables}
\subsubsection{Let Expressions}
\subsubsection{Renaming}
\subsubsection{Bracketed Terms}
\subsubsection{Term Quotation}






=IGN




store_mt_results mt_run_ok [
("mdt062.001", xq1, "[X](Ê ([x : X]).x)"),
("mdt062.001", xq1, "a b"),
("mdt062.001", xq1, "f 1"),
("mdt062.001", xq1, "{1,2,3} 1"),
("mdt062.001", xq1, "Ì x : X · (a ² b)"),
("mdt062.001", xq1, "Ì x : X · x")
("mdt062.001", xq1, "Ì x : X |x > 0 · x"),
("mdt062.001", xq1, "Í x : X · x"),
("mdt062.001", xq1, "Í x : X | x > 0 · x"),
("mdt062.001", xq1, "true"),
("mdt062.001", xq1, "false"),
("mdt062.001", xq1, "[X] (³ X)"),
("mdt062.001", xq1, "(³ 1)"),
("mdt062.001", xq1, "³ (1=3)"),
("mdt062.001", xq1, "a ± b"),
("mdt062.001", xq1, "true ² false"),
("mdt062.001", xq1, "µ x : Y · true"),
("mdt062.001", xq1, "[x : X]"),
("mdt062.001", xq1, "[x : X | false]"),
("mdt062.001", xq1, "[X,Y] (pre [x : X; y : Y | true])"),
("mdt062.001", xq1, "[X,Y] (pre [x : X; y' : Y | true])")
];get_mt_results();
=TEX
=SML

summarize_mt_results();

=TEX

%\newpage
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}


