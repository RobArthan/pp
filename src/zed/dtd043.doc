=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Schema Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD043}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the 
 Z schema calculus in the Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.B.~Jones
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] First issue.
\item [Issue 1.2] 
Heavily reworked by KB.
\item [Issue 1.3, 2nd October 1992] 
Reworking.
\item [Issue 1.4, 7th October 1992] 
Changes after comments.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference for
the Z Proof Support System schema calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP043}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules and conversions for the schema calculus of the Z Proof Support System. Section \ref{CONVANDRULE} describes the main conversions and rules for the Z schema calculus. 
The extended Z language supported is documented in the 
Z User Interface subsystem, \cite{DS/FMU/IED/HLD018}.

\subsubsection{Dependencies}
Loading this document is dependent on those
having loaded \cite{DS/FMU/IED/IMP042}.
\pagebreak
\section{Z SCHEMA CALCULUS}
=DOC
signature €ZSchemaCalculus› = sig
=DESCRIBE
This provides the rules of inference for schema calculus in the Z proof support system.
=ENDDOC
=FAILURE
43000	DESIGN ERROR: a check failed that should never fail
=TEX
\section{CONVERSIONS AND RULES}\label{CONVANDRULE}
\subsection{Horizontal Schemas}
=DOC
val €z_ç_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to an existential quantification.  
=FRULE 1 Conversion
z_ç_horiz_schema_conv
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § ∂D'|P'∑ [D'] = v
=TEX
Bound variable renaming may be necessary, and thus the priming in the RHS of the result.
=SEEALSO
$z\_ç\_horiz\_schema\_conv1$ for a faster, if more verbose result from simplifying the same category of terms,
$z\_horiz\_schema\_conv$ for a horizontal schema term  without and outer $ç$.
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
=ENDDOC
=DOC
val €z_ç_horiz_schema_conv1› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to a predicate.  
=FRULE 1 Conversion
z_ç_horiz_schema_conv1
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § D' ± P'
=TEX
where, if $D$ binds $xâ1$, $xâ2$,...,
then $D'$ is 
=GFT
"D[xâ1 \ v.xâ1, ...] as a predicate"
=TEX
and $P'$ is
=GFT
P[xâ1 \ v.xâ1, ...]
=TEX
The execution of the conversion may also involve bound variable renaming.
Though this conversion gives a rather verbose result,
it evaluates faster than $z\_ç\_schema\_conv$,
and is probably of more practical value in a proof.
=SEEALSO
$z\_ç\_horiz\_schema\_conv1$
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
=ENDDOC

=DOC
val €z_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion from a horizontal schema to a set comprehension.  
=FRULE 1 Conversion
z_horiz_schema_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] = {D|P∑ D}
=SEEALSO
$z\_ç\_horiz\_schema\_conv$ and $z\_ç\_horiz\_schema\_conv1$, which are
more appropriate if the schema expression occurs as a 
subterm of a membership expression.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
=DOC
val €z_norm_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion for normalising horizontal schemas.  
=FRULE 1 Conversion
z_norm_horiz_schema_conv 
¨[D|P]Æ
˜
˜
Ù [D|P] = [DU|D1 ± P]
=TEX
D1 is the implicit predicate formed from D by 
=INLINEFT
DECL_C dec_pred_conv
=TEX
{}. Conjuncts that are
provable by $ç\_u\_conv$, q.v., are not included in D1.
DU is the signature formed from the remaining variables of D, all of type U.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
=DOC
val €z_horiz_schema_pred_conv› : CONV;
=DESCRIBE
A conversion for eliminating a horizontal schema as a predicate.  
=FRULE 1 Conversion
z_horiz_schema_pred_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] § "D as Predicate" ± P
=TEX
Projections from bindings, which are likely to be introduced, are not automatically expanded
out.
The user may do so with, e.g.,
=GFT
MAP_C z_binding_proj_conv
=TEX

The horizontal schema may be decorated.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$ for an alternative expansion.
=FAILURE
43012	?0 is not a horizontal schema as a predicate
=ENDDOC
\subsection{Schema References}
=DOC
val €z_schema_ref_conv› : CONV;
=DESCRIBE
A conversion which expands a schema reference that is an expression, using its stored definition. 
=FRULE 1 Conversion
z_schema_ref_conv
ÒSÆ
˜
˜
Ù S = [D|P]
=TEX
where $[D|P]$ is the stored definition of S.
=SEEALSO
$get\_spec$, which is at the core of the implementation
of this function.
=FAILURE
43011	?0 is not a schema reference as an expression
43013	?0 is not a schema reference with a known specification
=ENDDOC
=DOC
val €z_schema_ref_pred_conv› : CONV;
=DESCRIBE
A conversion for eliminating a schema reference as a predicate.  
=FRULE 1 Conversion
z_schema_ref_pred_conv
ÒSÆ
˜
˜
Ù S § "D as Predicate" ± P
=TEX
The declaration part of the schema S is referred to as D,
and $P$ is the predicate part.

Projections from bindings, which are likely to be introduced, are not automatically expanded
out.
The user may do so with, e.g.,
=GFT
MAP_C z_binding_proj_conv
=TEX
The schema reference may be decorated.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$ for an alternative expansion.
=FAILURE
43008	?0 is not a schema reference as a predicate
=ENDDOC
We don't automatically rewrite the bindings because 
there may be more, that should be left untouched, in the 
schema body.

\subsection{Bindings}
=DOC
val €z_binding_eq_conv› : CONV;
val €z_binding_eq_conv1› : CONV;
=DESCRIBE
A conversion for eliminating bindings over equality.  
=FRULE 1 Conversion
z_binding_eq_conv 
¨bâ1 = bâ2Æ
˜
˜
Ù (bâ1 = bâ2) § (bâ1.sâ1 = bâ2.sâ1) ±
	(bâ1.sâ2 = bâ2.sâ2) ± ...
=TEX
where $bâ1$ (and thus $bâ2$) has a binding type equal
to the type of something of the form
=INLINEFT
Ò(sâ1 ¶ ..., sâ2 ¶ ..., ...)Æ
=TEX
{}.

$z\_bind\_eq\_conv1$ first applies conversion
$z\_bind\_eq\_conv$, and then, if either
or both of $bâ1$ and $bâ2$ are binding constructions it then
eliminates the projection functions, in a manner 
similar to $z\_bind\_proj\_conv$.
=FAILURE
43005	?0  is not of the form Òbinding = bindingÆ
=ENDDOC

=DOC
val €z_binding_proj_conv› : CONV;
=DESCRIBE
A conversion for eliminating binding projections.  
=FRULE 1 Conversion
z_binding_proj_conv
¨(nâ1 ¶ tâ1,nâ2 ¶ tâ2,..).nâcÆ
˜
˜
Ù (nâ1 ¶ tâ1,nâ2 ¶ tâ2,..).nâc = tâc
=SEEALSO
$z\_bind\_eq\_conv1$ for an optimised special case.
=FAILURE
43006	?0  is not a binding projection
=ENDDOC
\subsection{Operators on Schemas}
=DOC
val €z_ _ç_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting that the $ $-term of a schema is a member of the schema to that schema as a predicate.
=FRULE 1 Conversion
z_ _ç_schema_conv
Ò S ç SÆ
˜
˜
Ù  S ç S § S
=TEX
Note that the schemas cannot be decorated, as the type of
$Ò \ S\ 'Æ$ is the same as the type of $Ò \ SÆ$.
Other than that $S$ may be any schema as a predicate, including schema references and horizontal schemas.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$, and
$pred\_dec\_conv$, which subsumes this conversion.
=FAILURE
43002	?0 is not of the form ¨ S ç SÆ where ¨SÆ is an undecorated schema
=ENDDOC
=DOC
val €z_ _ç_schema_intro_conv› : CONV;
=DESCRIBE
A conversion from a schema as a predicate to the predicate asserting that its $ $-term is a member of the schema.
=FRULE 1 Conversion
z_ _ç_schema_intro_conv
¨SÆ
˜
˜
Ù S §  S ç S 
=TEX
$S$ is any schema as a predicate, including both schema
references and horizontal schemas.
=SEEALSO
$z\-\_schema\-\_ref\-\_pred\-\_conv$ and
$z\-\_horiz\-\_schema\-\_pred\-\_conv$ for alternatives,
$z\-\_ \-\_ç\-\_schema\-\_conv$ for what to do next.
=FAILURE
43014	?0 is not a schema as a predicate
=ENDDOC
=DOC
val €z_ _conv› : CONV;
=DESCRIBE
A conversion from a $ $-term to the binding constructor for the schema.
=FRULE 1 Conversion
z_ _conv
Ò SÆ
˜
˜
Ù  S = (nâ1 ¶ nâ1, nâ2 ¶ nâ2, ...)
=FAILURE
43010	?0 is not a $ $-term
=ENDDOC
=DOC
val €z_ç_decâs_conv› : CONV;
=DESCRIBE
A conversion which expands a statement of membership
to a decorated schema.
=FRULE 1 Conversion
z_ç_decâs_conv
Òv ç (S)'Æ
˜
˜
Ù v ç (S)' § 
(xâ1 ¶ v.xâ1', ...) ç S
=TEX
where the type of $S$ is
=GFT
 [xâ1:U; ... ]
=TEX
$S$ may be a schema-reference, or (in extended Z) anything
of the stated type.
=ENDDOC
Later issues should provide a general mechanism for turning conversions of
the above sort into a equality on a Z set abstraction.

=DOC
val €z_preâs_conv› : CONV;
=DESCRIBE
Schema precondition elimination. 
=FRULE 1 Conversion
z_preâs_conv
Òpre SÆ
˜
˜
Ù pre S =  [DU|(∂D1|true ∑ S1)]
=TEX
$S$ is any expression of a schema type that has both primed and output variables in its declaration  (i.e. those ending in $'$ or $!$),
as well as some that are not.
$DU$ is the declaration formed from the unprimed variables of $D$, given type $U$.
$D1$ is the declaration formed from the primed variables of $D$, given type $U$.
$S1$ is the schema $S$ as a predicate.
=FAILURE
43007	?0 is not a schema precondition
43009	?0 either has a schema with no, or all, components
	with names ending in ' or !
=FAILUREC
It should not be possible to raise failure 43009 with
a term solely generated by the Z parser, as the fault
is also checked there. However, e.g., $mk\_z\_preâs$ can create 
such faulty terms.
=ENDDOC
\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:
\begin{tabular}{l pw{3in}}
$'z\_bindings$ & Reasoning about Z bindings \\
$'z\_schemas$ & Reasoning about Z schemas other than bindings \\
\end{tabular}

=DOC
(* Proof Context: €'z_bindings› *)
=DESCRIBE
A component proof context for handling the manipulation of Z bindings.
\paragraph{Contents}\ 

Rewriting:
=GFT
=TEX

Stripping theorems:
=GFT
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
plus these all pushed in through ≥
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$bindings''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
=DOC
(* Proof Context: €'z_schemas› *)
=DESCRIBE
A component proof context for handling the manipulation of Z bindings.
\paragraph{Contents}\ 

Rewriting:
=GFT
=TEX

Stripping theorems:
=GFT
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
plus these all pushed in through ≥
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$bindings''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC

\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSchemaCalculus *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


