=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Schema Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD043}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the 
 Z schema calculus in \ProductZ.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] First issue.
\item [Issue 1.2] 
Heavily reworked by KB.
\item [Issue 1.3, 2nd October 1992] 
Reworking.
\item [Issue 1.4, 7th October 1992] 
Changes after comments.
\item [Issue 1.5, 14th October 1992] 
Dependencies changed.
\item [Issue 1.5, 19th October 1992] 
Notes on $schema\_ref\_conv$.
\item [Issue 1.6-8, 29th October 1992] 
Changes to reflect Z theory reorganisation.
\item [Issue 1.9, 11th November 1992] 
Changes as a consequence of changes in dependences.
\item [Issue 1.10, 20th November 1992] 
Completing the Schema Calculus.
\item [Issue 1.11, 25th November 1992] 
Changes after comments.
\item [Issue 1.12, 1st December 1992]
Improved processing of schema quantification.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference for
the Z Proof Support System schema calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP043}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules and conversions for the schema calculus of the Z Proof Support System. Section \ref{CONVANDRULE} describes the main conversions and rules for the Z schema calculus. 
The extended Z language supported is documented in the 
Z User Interface subsystem, \cite{DS/FMU/IED/HLD018}.

Where we provide conversions upon terms that have a Z set type
we provide at least one equivalent conversion upon membership
of such terms, and vice versa.
This may be done by, e.g., the conversional $ç\_C$ applied to
the original conversion,
or both of the pair may have custom implementations.

By default all relevant functions in this document should
be assumed to remain within the Z language and to check this fact, unless otherwise stated.
\subsubsection{Dependencies}
Loading this document is dependent on those
having loaded \cite{DS/FMU/IED/IMP042}.

\pagebreak
\section{Z SCHEMA CALCULUS}
=DOC
signature €ZSchemaCalculus› = sig
=DESCRIBE
This provides the rules of inference for schema calculus in the Z proof support system.
The material is implemented within the theory $z\-\_language\-\_ps$.
=ENDDOC
=FAILURE
43000	DESIGN ERROR: a check failed that should never fail
=TEX
\subsection{Conversionals for ç}
=DOC
val €ç_C› : CONV -> CONV;
=DESCRIBE
$ç\_C$ $cnv$ $tm$ takes a conversion $cnv$,
that applies to set terms,
will check to see if its term argument,
$tm$ is a membership statement.
If so, it will apply its conversion to the set.
If not it will fail.
It does not check that its result remaining in Z
(and indeed is applicable to HOL membership terms as well).
=SEEALSO
$Z\_ç\_ELIM\_C$
=FAILURE
43028	?0 is not of the form Òv ç sÆ or ¨v ç sÆ
=FAILUREC
And as conversion argument upon the set, with the error
being passed through by the conversional untouched.
=ENDDOC
=DOC
val €Z_ç_ELIM_C› : CONV -> CONV;
=DESCRIBE
$Z\_ç\_ELIM\_C$ $cnv$ $tm$ takes a conversion $cnv$ 
that can be applied to set memberships, and a set term $tm$.
The conversion is then modified to make it applicable to the term.
The resulting conversion will check to see if its term argument,
$tm$ is a set.
If so it will form the term: 
=INLINEFT
Òxi ç ëtmÆÆ
=TEX
(where $xi$ is the first variable in $x1$, $x2$,... not 
present in $tm$),
apply $cnv$ to the result,
gaining some equation:
=GFT
Ù xi ç ëtmÆ § f[xi]
=TEX
and then return the theorem
=GFT
Ù ëtmÆ = {xi : U | f[xi]}
=TEX
=FAILURE
43027	?0 is not a Z set
43026	unable to convert ?0 to the form: Òx ç {x:U|s}Æ
=FAILUREC
And as conversion argument upon the membership term, with the error
being passed through by the conversional untouched.
=ENDDOC
\section{CONVERSIONS AND RULES}\label{CONVANDRULE}
\subsection{Horizontal Schemas}
=DOC
val €z_ç_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to an existential quantification.  
=FRULE 1 Conversion
z_ç_horiz_schema_conv
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § ∂D'|P'∑ [D'] = v
=TEX
Bound variable renaming may be necessary, and thus the priming in the RHS of the result.
=SEEALSO
$z\_ç\_horiz\_schema\_conv1$ for a faster, if more verbose result from simplifying the same category of terms,
$z\_horiz\_schema\_conv$ for a horizontal schema term  without and outer $ç$.
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
=ENDDOC
=DOC
val €z_ç_horiz_schema_conv1› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to a predicate.  
=FRULE 1 Conversion
z_ç_horiz_schema_conv1
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § D' ± P'
=TEX
where, if $D$ declares variables $xâ1$, $xâ2$,...,
then $D'$ is 
=GFT
"predicate from D[xâ1 \ v.xâ1, ...]"
=TEX
as converted by $z\_decl\_pred\_conv$,
and $P'$ is
=GFT
P[xâ1 \ v.xâ1, ...]
=TEX
The execution of the conversion may also involve bound variable renaming.
Though this conversion gives a rather verbose result,
it evaluates faster than $z\_ç\_horiz\_schema\_conv$,
and is probably of more practical value in a proof.
=SEEALSO
$z\_ç\_horiz\_schema\_conv$
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
=ENDDOC

=DOC
val €z_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion from a horizontal schema to a set comprehension.  
=FRULE 1 Conversion
z_horiz_schema_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] = {D|P∑ D}
=SEEALSO
$z\_ç\_horiz\_schema\_conv$ and $z\_ç\_horiz\_schema\_conv1$, which are
more appropriate if the schema expression occurs as a 
subterm of a membership expression.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
=DOC
val €z_norm_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion for normalising horizontal schemas.  
=FRULE 1 Conversion
z_norm_horiz_schema_conv 
¨[D|P]Æ
˜
˜
Ù [D|P] = [DU|D1 ± P]
=TEX
D1 is the implicit predicate formed from D by 
=INLINEFT
z_decl_pred_conv
=TEX
{},
and then simplified.
The simplification is that conjuncts of the predicate that are
provable by $ç\_u\_lang\_conv$, q.v., are proven and theneliminated from $D1$.
$DU$ is the signature formed from the variables bound by $D$, all of type $U$.
=EXAMPLE
z_norm_horiz_schema_conv Ò[w:W; x,y:X; z:U | p w x y z]Æ
 =
Ò[w:U; x:U; y:U; z:U | (w ç W ± x ç X ± y ç X) ± p w x y z]Æ
=TEX
Notice how, since $z\ ç\ U$ can be proven by $ç\_u\_lang\_conv$,
it is not included in $D1$.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
The above is deliberately given no $ç$ analogue, against the convention in the introduction.

=DOC
val €z_horiz_schema_pred_conv› : CONV;
=DESCRIBE
A conversion for eliminating a horizontal schema as a predicate.  
=FRULE 1 Conversion
z_horiz_schema_pred_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] § "D as Predicate" ± P
=TEX
Projections from bindings, which are likely to be introduced, are not automatically expanded
out.
The user may do so with, e.g.,
=GFT
MAP_C z_binding_sel_conv
=TEX

The horizontal schema may be decorated.
=SEEALSO
$z\_schema\_pred\_conv$ for a more general conversion.
=FAILURE
43012	?0 is not a horizontal schema as a predicate
=ENDDOC
\subsection{Schema References}
These should be handled by $z\_get\_spec$.

\subsection{Operators on Schemas}
=DOC
val €z_ _ç_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting that the $ $-term of a schema is a member of the schema to that schema as a predicate.
=FRULE 1 Conversion
z_ _ç_schema_conv
Ò S ç SÆ
˜
˜
Ù  S ç S § S
=TEX
Note that the schemas cannot be decorated, as the type of
$Ò \ S\ 'Æ$ is the same as the type of $Ò \ SÆ$.
Other than that $S$ may be any schema as a predicate, including schema references and horizontal schemas.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$; and
$pred\_dec\_conv$, which subsumes this conversion.
=FAILURE
43002	?0 is not of the form ¨ S ç SÆ where ¨SÆ is an undecorated schema
=ENDDOC
=DOC
val €z_schema_pred_conv› : CONV;
val €z_ _ç_schema_intro_conv› : CONV;
=DESCRIBE
$z\_schema\_pred\_conv$ is a conversion from a schema as a predicate to the predicate asserting that its $ $-term is a member of the schema.
=FRULE 1 Conversion
z_ _ç_schema_intro_conv
¨SÆ
˜
˜
Ù S §  S ç S 
=TEX
$S$ is any schema as a predicate, including both schema
references and horizontal schemas.

$z\-\_schema\-\_pred\-\_conv$ is an alias for $z\_ \_ç\_schema\_intro\_conv$.
=SEEALSO
$z\-\_horiz\-\_schema\-\_pred\-\_conv$ for alternative,
$z\-\_ \-\_conv$ for what to do next, and
$z\_ \_ç\_schema\_conv$.
=FAILURE
43014	?0 is not a schema as a predicate
=ENDDOC
=DOC
val €z_ _conv› : CONV;
=DESCRIBE
A conversion from a $ $-term to the binding constructor for the schema.
=FRULE 1 Conversion
z_ _conv
Ò SÆ
˜
˜
Ù  S = (nâ1 ¶ nâ1, nâ2 ¶ nâ2, ...)
=FAILURE
43010	?0 is not a  -term
=ENDDOC
=DOC
val €z_decâs_conv› : CONV;
val €z_ç_decâs_conv› : CONV;
=DESCRIBE
A conversion which expands a statement of membership
to a decorated schema.
=FRULE 1 Conversion
z_ç_decâs_conv
Òv ç (S)'Æ
˜
˜
Ù v ç (S)' § 
(xâ1 ¶ v.xâ1', ...) ç S
=TEX
where the type of $S$ is
=GFT
 [xâ1:U;... ]
=TEX
$S$ may be a schema-reference, or (in extended Z) anything
of the stated type.

=GFT Definition
val z_decâs_conv = Z_ç_ELIM_C z_ç_decâs_conv
=TEX
=FAILURE
43015	?0 not of the form: Òv ç dsÆ where ds is a decorated
	schema expression
=ENDDOC
Later issues of \ProductZ{} should provide a general mechanism for turning conversions of
the above sort into a equality on a Z set abstraction.
E.g. 
from results of the form:
=GFT Example
v ç s § p[v, s]
=TEX
to:
=GFT Example
s = {v | p[v, s]}
=TEX
=DOC
val €z_preâs_conv› : CONV;
val €z_ç_preâs_conv› : CONV;
=DESCRIBE
Schema precondition elimination. 
=FRULE 1 Conversion
z_preâs_conv
Òpre SÆ
˜
˜
Ù pre S =  [DU|(∂D1|true∑ S1)]
=TEX
$S$ is any expression of a schema type that has both primed and output variables in its declaration  (i.e. those ending in $'$ or $!$),
as well as some that are not.
$DU$ is the declaration formed from the unprimed variables of $D$, given type $U$.
$D1$ is the declaration formed from the primed variables of $D$, given type $U$.
$S1$ is the schema $S$ as a predicate.

=GFT Definition
val z_ç_preâs_conv = ç_C z_preâs_conv
=TEX
=FAILURE
43007	?0 is not a schema precondition
43009	?0 either has a schema with no, or all, components
	with names ending in ' or !
=FAILUREC
It should not be possible to raise failure 43009 with
a term solely generated by the Z parser, as the fault
is also checked there. However, e.g., $mk\_z\_preâs$ can create 
such faulty terms.
=ENDDOC
The above could be expressed by existential quantification of a schema.

=DOC
val €z_Ñâs_conv› : CONV;
val €z_ç_Ñâs_conv› : CONV;
=DESCRIBE
A conversion concerning the delta schemas.
=FRULE 1 Conversion
z_Ñâs_conv
ÒÑ SÆ
˜
˜
Ù Ñ S = [S; S']
=TEX

=GFT Definition
val z_ç_Ñâs_conv = ç_C z_Ñâs_conv
=TEX
=FAILURE
43022	?0 is not of the form: ÒÑ SÆ where S is a schema
=ENDDOC
=DOC
val €z_òâs_conv› : CONV;
val €z_ç_òâs_conv› : CONV;
=DESCRIBE
A conversion concerning $ò$ schemas.
=FRULE 1 Conversion
z_òâs_conv
Òò SÆ
˜
˜
Ù ò S = [S; S' |  S =  S']
=TEX
=GFT Definition
val z_ç_òâs_conv = ç_C z_òâs_conv
=TEX

=FAILURE
43023	?0 is not of the form: Òò SÆ where S is a schema
=ENDDOC

\section{PROPOSITION CALCULUS WITH SCHEMAS}
=DOC
val €z_±âs_conv› : CONV;
val €z_ç_±âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema conjunction.
=FRULE 1 Conversion
z_ç_±âs_conv
Òv ç (R ± S)Æ
˜
˜
Ù v ç (R ± S) § 
	bind1 ç R ± bind2 ç S
=TEX
where $R$ and $S$ are schemas that have signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=GFT Definition
val z_±âs_conv = Z_ç_ELIM_C z_ç_±âs_conv;
=TEX
=FAILURE
43001	?0 is not of the form: Òv ç (R ± S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_≤âs_conv› : CONV;
val €z_ç_≤âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema disjunction.
=FRULE 1 Conversion
z_ç_≤âs_conv
Òv ç (R ≤ S)Æ
˜
˜
Ù v ç (R ≤ S) § 
	bind1 ç R ≤ bind2 ç S
=TEX
where $R$ and $S$ are schemas that have signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=GFT Definition
val z_≤âs_conv = Z_ç_ELIM_C z_ç_≤âs_conv;
=TEX
=FAILURE
43005	?0 is not of the form: Òv ç (R ≤ S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_¥âs_conv› : CONV;
val €z_ç_¥âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema implication.
=FRULE 1 Conversion
z_ç_¥âs_conv
Òv ç (R ¥ S)Æ
˜
˜
Ù v ç (R ¥ S) § 
	(bind1 ç R ¥ bind2 ç S)
=TEX
where $R$ and $S$ are schemas that have signature variables variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=GFT Definition
val z_¥âs_conv = Z_ç_ELIM_C z_ç_¥âs_conv;
=TEX
=FAILURE
43006	?0 is not of the form: Òv ç (R ¥ S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_§âs_conv› : CONV;
val €z_ç_§âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema bi-implication.
=FRULE 1 Conversion
z_ç_§âs_conv
Òv ç (R § S)Æ
˜
˜
Ù v ç (R § S) § 
	(bind1 ç R § bind2 ç S)
=TEX
where $R$ and $S$ are schemas that have signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=GFT Definition
val z_§âs_conv = Z_ç_ELIM_C z_ç_§âs_conv;
=TEX
=FAILURE
43016	?0 is not of the form: Òv ç (R § S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_≥âs_conv› : CONV;
val €z_ç_≥âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema negation.
=FRULE 1 Conversion
z_ç_≥âs_conv
Òv ç (≥ S)Æ
˜
˜
Ù v ç (≥ S) § ≥ (v ç S)
=TEX
where $S$ is a schema
=GFT Definition
val z_≥âs_conv = Z_ç_ELIM_C z_ç_≥âs_conv;
=TEX
=FAILURE
43017	?0 is not of the form: Òv ç (≥ S)Æ where S is a schema
=ENDDOC
\section{SCHEMA QUANTIFICATION}
=DOC
val €z_∂âs_conv› : CONV;
val €z_ç_∂âs_conv› : CONV;
=DESCRIBE
A conversion concerning membership of schema existentials.
=FRULE 1 Conversion
z_ç_∂âs_conv
Òv ç (∂ D | P∑ S)Æ
˜
˜
Ù v ç (∂ D | P∑ S) = 
∂ y : U ∑ ``predicate from D[y.yâ1\yâ1,...]'' ±
	P[y.yâ1\yâ1,...] ±
	(xâ1 ¶ v.xâ1,...,yâ1 ¶ y.yâ1,...) ç S
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that declares $yâ1$, $yâ2$, ... .
The ``predicate from D'' will also have schemas as predicates
eliminated in favour of bindings being members of schemas.
=GFT Definition
val z_∂âs_conv = Z_ç_ELIM_C z_ç_∂âs_conv;
=TEX
=FAILURE
43020	?0 is not of the form: Òv ç (∂ D | P∑ S)Æ where S is a schema
=ENDDOC
=DOC
val €z_µâs_conv› : CONV;
val €z_ç_µâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema universals.
=FRULE 1 Conversion
z_ç_µâs_conv
Òv ç (µ D | P∑ S)Æ
˜
˜
Ù v ç (∂ D | P∑ S) = 
µ y : U ∑ ``predicate from D[y.yâ1\yâ1,...]'' ±
	P[y.yâ1\yâ1,...] ±
	(xâ1 ¶ v.xâ1,...,yâ1 ¶ y.yâ1,...) ç S
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that declares $yâ1$, $yâ2$, ... .
The ``predicate from D'' will also have schemas as predicates
eliminated in favour of bindings being members of schemas.
=GFT Definition
val z_µâs_conv = Z_ç_ELIM_C z_ç_µâs_conv;
=TEX
=FAILURE
43030	?0 is not of the form: Òv ç (µ D | P∑ S)Æ where S is a schema
=ENDDOC
=DOC
val €z_∂â1âs_conv› : CONV;
val €z_ç_∂â1âs_conv› : CONV;
=DESCRIBE
A conversion concerning schema unique existentials.
=FRULE 1 Conversion
z_ç_∂â1âs_conv
Òv ç (∂â1 D | P∑ S)Æ
˜
˜
Ù v ç (∂â1 D | P∑ S) = 
∂â1 y : U ∑ ``predicate from D[y.yâ1\yâ1,...]'' ±
	P[y.yâ1\yâ1,...] ±
	(xâ1 ¶ v.xâ1,...,yâ1 ¶ y.yâ1,...) ç S
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that declares $yâ1$, $yâ2$, ... .
The ``predicate from D'' will also have schemas as predicates
eliminated in favour of bindings being members of schemas.
=GFT Definition
val z_∂â1âs_conv = Z_ç_ELIM_C z_ç_∂â1âs_conv;
=TEX
=FAILURE
43021	?0 is not of the form: Òv ç (∂â1 D | P∑ S)Æ where S is a schema
=ENDDOC

\section{OTHER SCHEMA CALCULUS OPERATORS}
=DOC
val €z_˘âs_conv› : CONV;
val €z_ç_˘âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema projection.
=FRULE 1 Conversion
z_˘âs_conv
Ò(R ˘âs S)Æ
˜
˜
Ù (R ˘âs S) = ((R ± S) \âs (sâ1, sâ2, ...)
=TEX
where $R$ and $S$ are schemas that has signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively.
=GFT Definition
val z_ç_˘âs_conv = ç_C z_˘âs_conv
=TEX
=FAILURE
43019	?0 is not of the form: ÒR ˘âs SÆ where R and S are schemas
=ENDDOC
=DOC
val €z_hideâs_conv› : CONV;
val €z_ç_hideâs_conv› : CONV;
=DESCRIBE
A conversion concerning the schema hiding.
=FRULE 1 Conversion
z_hideâs_conv
ÒS \âs (xâ1, ...)Æ
˜
˜
Ù S \âs (xâ1, ...) = 
	[yâ1 : U;... | ∂ xâi : U;...∑ S]
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ... .
=GFT Definition
val z_ç_hideâs_conv = ç_C z_hideâs_conv
=TEX
=FAILURE
43018	?0 is not of the form: ÒS \âs (xâ1, ...)Æ where S is a schema
=ENDDOC
=DOC
val €z_ªâs_conv› : CONV;
val €z_ç_ªâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema sequential composition.
=FRULE 1 Conversion
z_ªâs_conv
Ò(R ªâs S)Æ
˜
˜
Ù (R ªâs S) = ∂ [yâ1:U;...]''∑ 
(∂ [yâ1:U;...]'∑ [R;[yâ1:U;...]''| 
	 [yâ1:U;...]' =  [yâ1:U;...]''])
±
(∂ [yâ1:U;...]∑ [S;[yâ1:U;...]''| 
	 [yâ1:U;...] =  [yâ1:U;...]''])
=TEX
where $R$ has signature variables:
=GFT
Unprimed variables: xâ1, xâ2, ...
Primed variables: yâ1', yâ2', ...
=TEX
and $S$ has signature variables:
=GFT
Unprimed variables: yâ1, yâ2, ...
and also: zâ1, zâ2, ...
Primed variables: wâ1', wâ2', ...
and also perhaps some of xâ1', xâ2', ..., 
	yâ1', yâ2', ...,
	wâ1', wâ2', ...
=TEX
=GFT Definition
val z_ç_ªâs_conv = ç_C z_ªâs_conv
=TEX
=FAILURE
43025	?0 is not of the form: ÒR ªâs SÆ where R and S are schemas
=ENDDOC
=DOC
val €z_renameâs_conv› : CONV;
val €z_ç_renameâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema renaming.
=FRULE 1 Conversion
z_ç_renameâs_conv
Òv ç S[xâ1/yâ1,...]Æ
˜
˜
Ù v ç S[xâ1/yâ1,...] § 
 (yâ1 ¶ v.xâ1, ..., zâ1 ¶ v.zâ1, ...) ç S
=TEX
where $S$ has signature variables $xâ1$,... and $zâ1$,...
=GFT Definition
val z_renameâs_conv = Z_ç_ELIM_C z_ç_renameâs_conv;
=TEX
=FAILURE
43031	?0 is not of the form: ÒS[xâ1/yâ1,...]Æ where S is a schema
=ENDDOC

\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{4in}}
$'z\_schemas$ & For reasoning about Z schemas, other than bindings \\
\end{tabular}

=DOC
(* Proof Context: €'z_schemas› *)
=DESCRIBE
A mild component proof context for handling the manipulation of Z schemas.

\paragraph{Contents}\ 

Rewriting:
=GFT
(RAND_C z_ _conv THEN_C z_binding_sel_conv) 
	- which simplifies terms of the form: Ò(  s).nmÆ 
z_ç_≥âs_conv, z_ç_±âs_conv, z_ç_≤âs_conv, 
z_ç_¥âs_conv, z_ç_§âs_conv, z_ç_∂âs_conv, 
z_ç_∂â1âs_conv, z_ç_µâs_conv, z_ç_horiz_schema_conv1, 
z_ç_decâs_conv, z_ç_preâs_conv, z_ç_˘âs_conv, 
z_ç_hideâs_conv, z_ç_Ñâs_conv, z_ç_òâs_conv, 
z_ç_ªâs_conv, z_ç_renameâs_conv
=TEX

Stripping theorems:
=GFT
z_ç_≥âs_conv, z_ç_±âs_conv, z_ç_≤âs_conv, 
z_ç_¥âs_conv, z_ç_§âs_conv, z_ç_∂âs_conv, 
z_ç_∂â1âs_conv, z_ç_µâs_conv, z_ç_horiz_schema_conv1, 
z_ç_decâs_conv, z_ç_preâs_conv, z_ç_˘âs_conv, 
z_ç_hideâs_conv, z_ç_Ñâs_conv, z_ç_òâs_conv, 
z_ç_ªâs_conv, z_ç_renameâs_conv
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_ç_≥âs_conv, z_ç_±âs_conv, z_ç_≤âs_conv, 
z_ç_¥âs_conv, z_ç_§âs_conv, z_ç_∂âs_conv, 
z_ç_∂â1âs_conv, z_ç_µâs_conv, z_ç_horiz_schema_conv1, 
z_ç_decâs_conv, z_ç_preâs_conv, z_ç_˘âs_conv, 
z_ç_hideâs_conv, z_ç_Ñâs_conv, z_ç_òâs_conv, 
z_ç_ªâs_conv, z_ç_renameâs_conv
plus these all pushed in through ≥
=TEX
All of the above contain rules for the membership of:
=GFT

=TEX
Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_language\-\_ps$.
It is intended to be used with proof context ``z$\_$bindings''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
=DOC
(* Proof Context: €'z_schemas_ext› *)
=DESCRIBE
An agressive component proof context for handling the manipulation of Z schemas.

\paragraph{Contents}\ 

Rewriting:
=GFT
(z_horiz_schema_pred_conv ORELSE_C z_schema_pred_conv)
=TEX

Stripping theorems:
=GFT
(z_horiz_schema_pred_conv ORELSE_C z_schema_pred_conv)
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
(z_horiz_schema_pred_conv ORELSE_C z_schema_pred_conv)
plus these all pushed in through ≥
=TEX
All of the above contain rules for the membership of:
=GFT

=TEX
Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_language\-\_ps$.
It is intended to be used with proof context ``z$\_$schemas''
(and usually with ``$'$z$\_$sets$\_$ext$\_$lang'').
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
\newpage
\section{PROOF RULES AND COVERAGE OF $Z\_TERM$}
In the following ``$pc+=$'' stands for
``predicate calculus plus equality''
which should be reasoned about by $strip\_tac$, $rewrite\_tac[]$ and the ``two-tactic'' method,
in the proof context $z\_predicates$.

\begin{tabular}{| p{1.3in} | p{4.7in} |}\hline
Constructor & Proof Rules \\ \hline
$ZDec$ & $dec\_pred\_conv$ \\
$ZSchemaDec$ & $dec\_pred\_conv$ \\
$ZDecl$ & $z\_decl\_pred\_conv$ \\
$ZEq$ & $pc+=$ \\
$Zç$ & Various $z\_ç\_$ functions, e.g. $z\_ç\_seta\_conv$ \\
$ZTrue$ & $pc+=$ \\
$ZFalse$ & $pc+=$ \\
$Z≥$ & $pc+=$ \\
$Z≥âs$ & $z\_ç\_≥âs\_conv$ \\
$Z±$ & $pc+=$ \\
$Z±âs$ & $z\_ç\_±âs\_conv$ \\
$Z≤$ & $pc+=$ \\
$Z≤âs$ & $z\_ç\_≤âs\_conv$ \\
$Z¥$ & $pc+=$ \\
$Z¥âs$ & $z\_ç\_¥âs\_conv$ \\
$Z§$ & $pc+=$ \\
$Z§âs$ & $z\_ç\_§âs\_conv$ \\
$Z∂$ & $pc+=$ \\
$Z∂âs$ & $z\_∂âs\_conv$ \\
$Z∂â1$ & $pc+=$ \\
$Z∂â1âs$ & $z\_∂â1âs\_conv$ \\
$Zµ$ & $pc+=$ \\
$Zµâs$ & $z\_µâs\_conv$ \\ \hline
\end{tabular}

\begin{tabular}{| p{1.3in} | p{4.7in} |}\hline
Constructor & Proof Rules \\ \hline
$ZSchemaPred$ & $z\_schema\_pred\_conv$ and others \\
$ZLVar$ & $pc+=$ \\
$ZGVar$ & Rewriting with definition from $z\_get\_spec$ \\
$ZInt$ & Various, see \cite{DS/FMU/IED/DTD086} \\
$ZString$ & Strings - ? \\
$Zß¢$ & Sequences - ? \\
$ZSetd$ & $z\_ç\_setd\_conv$ \\
$ZSeta$ & $z\_ç\_seta\_conv$ \\
$Z$ & $z\_ç\_\_thm$ and others \\
$ZTuple$ & Various $z\_tuple\_...$, e.g. $z\_tuple\_eq\_conv$ \\
$ZBinding$ & Various $z\_binding\_...$, e.g. $z\_binding\_eq\_conv$ \\
$Z∏$ & $z\_ç\_∏\_conv$ and $z\_∏\_conv$ \\
$Z $ & $z\_ \_conv$ \\
$ZSelâs$ & $z\_binding\_sel\_conv$ and others \\
$ZSelât$ & $z\_tuple\_selection\_conv$ and others \\
$ZÕ$ & $z\_Õ\_rule$ \\
$ZApp$ & $z\_app\_conv$ \\
$ZÃ$ & $z\_Ã\_conv$ and $z\_¬\_conv$ \\
$Zâs$ & $z\_horiz\_schema\_conv$ or $z\_ç\_horiz\_schema\_conv1$ \\
$ZDecorâs$ & $z\_ç\_decâs\_conv$ \\
$ZPreâs$ & $z\_ç\_preâs\_conv$ \\
$Z˘âs$ & $z\_˘âs\_conv$ \\
$ZHideâs$ & $z\_hideâs\_conv$ \\
$ZÑâs$ & $z\_Ñâs\_conv$ \\
$Zòâs$ & $z\_òâs\_conv$ \\
$Zªâs$ & $z\_ªâs\_conv$ \\
$ZRenameâs$ & $z\_ç\_renameâs\_conv$ \\ \hline
\end{tabular}

\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSchemaCalculus *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


