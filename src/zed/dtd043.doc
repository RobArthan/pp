=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Schema Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD043}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the 
 Z schema calculus in \ProductZ.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] First issue.
\item [Issue 1.2] 
Heavily reworked by KB.
\item [Issue 1.3, 2nd October 1992] 
Reworking.
\item [Issue 1.4, 7th October 1992] 
Changes after comments.
\item [Issue 1.5, 14th October 1992] 
Dependencies changed.
\item [Issue 1.5, 19th October 1992] 
Notes on $schema\_ref\_conv$.
\item [Issue 1.6-8, 29th October 1992] 
Changes to reflect Z theory reorganisation.
\item [Issue 1.9, 11th November 1992] 
Changes as a consequence of changes in dependences.
\item [Issue 1.10, 20th November 1992] 
Completing the Schema Calculus.
\item [Issue 1.11, 25th November 1992] 
Changes after comments.
\item [Issue 1.12, 1st December 1992]
Improved processing of schema quantification.
\item[Issue 1.13 (2nd December 1992)]
Improved $U$ simplification.
\item[Issue 1.13 (3rd December 1992)]
Lost $ç\_C$, and $Z\-\_ç\-\_ELIM\-\_C$.
\item[Issue 1.14 (8th December 1992)]
Improvements to handling of schemas as predicates,
and bindings.
Removed proof context for extensional treatment of schemas.
\item[Issue 1.15 (9th December 1992)]
Added error 43033.
\item[Issue 1.17 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.18 (20th January 1993)]
Gained $z\_strip\_tac$.
\item[Issue 1.20,1.21 (5th-11th February 1993)]
Rearranging proof contexts.
\item[Issue 1.22, 1.23 (22nd September 1993)]
Tidying up descriptions.
\item[Issue 1.24 (4th November 1994)]
Added new conversion for massaging ill-formed schemas-as-declarations back into Z.
\item[Issue 1.25 (25th April 1997)]
Added message 43035.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference for
the Z Proof Support System schema calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP043}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules and conversions for the schema calculus of the Z Proof Support System. Section \ref{CONVANDRULE} describes the main conversions and rules for the Z schema calculus. 
The extended Z language supported is documented in the 
Z User Interface subsystem, \cite{DS/FMU/IED/HLD018}.

Where we provide conversions upon terms that have a Z set type
we provide at least one equivalent conversion upon membership
of such terms, and vice versa.
This may be done by, e.g., the conversional $ç\_C$ applied to
the original conversion,
or both of the pair may have custom implementations.

By default all relevant functions in this document should
be assumed to remain within the Z language and to check this fact, unless otherwise stated.
\subsubsection{Dependencies}
Loading this document is dependent on those
having loaded \cite{DS/FMU/IED/IMP042}.

\pagebreak
\section{Z SCHEMA CALCULUS}
=DOC
signature €ZSchemaCalculus› = sig
=DESCRIBE
This provides the rules of inference for schema calculus in the Z proof support system.
The material is implemented within the theory $z\-\_language\-\_ps$.
=ENDDOC
=FAILURE
43000	DESIGN ERROR: a check failed that should never fail
=TEX
\subsection{Stripping}
The following description could be made more Z-like at the
cost of introducing the aliases $z\_true\_tac$, etc.
=DOC
val €z_strip_tac› : TACTIC;
=DESCRIBE
z\_$strip\_tac$ is a general purpose tactic for simplifying away the outermost
connective of a Z goal.
It first attempts to apply $z\_µ\_tac$.
If that fails it then
tries to apply the current proof context's
conclusion stripping conversion,
to rewrite the outermost connective in the goal.
Failing that it tries to simplify the goal by applying an applicable
member of the following collection of tactics
(only one could possibly apply):
=GFT
simple_µ_tac,		±_tac,			
¥_T strip_asm_tac,	t_tac
=TEX
Failing either being successful, it tries $concl\-\_in\-\_asms\-\_tac$ to prove the goal,
and failing that, returns the error message below.

finally, it will attempt to make the goal a ``schema as predicate'',
if possible, by using $z\_schema\_pred\_intro\_conv$.

Note how new assumptions generated by the tactic are processed using
$strip\_asm\_tac$,
which uses the current proof context's theorem stripping conversion.
$z\_strip\_tac$ may produce several new
subgoals, or may prove the goal.

The tactic is defined as:
=GFT Definition
val z_strip_tac = (z_µ_tac ORELSE_T strip_tac) 
		THEN_TRY_T conv_tac z_schema_pred_intro_conv;
=USES
This is the usual way of simplifying a goal involving Z predicate
calculus connectives,
and other functions ``understood'' by the current prof context.
=SEEALSO
$STRIP\-\_CONCL\_T$ and $STRIP\_THM\_THEN$ which are used
to implement this function.
$taut\_tac$ for an alternative simplifier.
$swap\_≤\_tac$ to rearrange the conclusion for tailored stripping.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC


\section{CONVERSIONS AND RULES}\label{CONVANDRULE}
\subsection{Horizontal Schemas}
=DOC
val €z_ç_h_schema_conv1› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to an existential quantification.  
=FRULE 1 Conversion
z_ç_h_schema_conv1
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § ∂D'|P'∑ [D'] = v
=TEX
Bound variable renaming may be necessary, and thus the priming in the RHS of the result.
Schemas as predicates will be treated as membership
statements by this conversion.
=SEEALSO
$z\_ç\_h\_schema\_conv$ for a faster, if more verbose result from simplifying the same category of terms,
$z\_h\_schema\_conv$ for a horizontal schema term  without and outer $ç$.
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
43033	Unable to prove ?0 equal to something of the form: Ò∂D'|P'∑ [D'] = vÆ
	use z_ç_h_schema_conv instead, and then work by hand
=FAILUREC
Error 43033 indicates that there is some sort of variable capture problem preventing the conversion from functioning
correctly. As indicated, $z\-\_ç\-\_h\-\_schema\-\_conv$
is a conversion that does apply to simplify the input term.
=ENDDOC
=DOC
val €z_ç_h_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to a predicate.  
=FRULE 1 Conversion
z_ç_h_schema_conv
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § D' ± P'
=TEX
where, if $D$ declares variables $xâ1$, $xâ2$,...,
then $D'$ is 
=GFT
"predicate from D[xâ1 \ v.xâ1, ...]"
=TEX
as converted by $z\_decl\_pred\_conv$,
and $P'$ is
=GFT
P[xâ1 \ v.xâ1, ...]
=TEX
The execution of the conversion may also involve bound variable renaming.
If $v$ is a binding display then $v.xâi$ will be simplified.
Though this conversion gives a rather verbose result,
it evaluates faster than $z\_ç\_h\_schema\_conv1$,
and is probably of more practical value in a proof.
Schemas as predicates will be treated as membership
statements by this conversion.
=SEEALSO
$z\_ç\_h\_schema\_conv1$
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
=ENDDOC

=DOC
val €z_h_schema_conv› : CONV;
=DESCRIBE
A conversion from a horizontal schema to a set comprehension.  
=FRULE 1 Conversion
z_h_schema_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] = {D|P∑ D}
=SEEALSO
$z\_ç\_h\_schema\_conv1$ and $z\_ç\_h\_schema\_conv$, which are
more appropriate if the schema expression occurs as a 
subterm of a membership expression.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
=DOC
val €z_norm_h_schema_conv› : CONV;
=DESCRIBE
A conversion for normalising horizontal schemas.  
=FRULE 1 Conversion
z_norm_h_schema_conv 
¨[D|P]Æ
˜
˜
Ù [D|P] = [DU|D1 ± P]
=TEX
D1 is the implicit predicate formed from D by 
=INLINEFT
z_decl_pred_conv
=TEX
{},
and then simplified.
The simplification is that conjuncts of the predicate that are
provable by $z\_ç\_u\_conv$, q.v., are proven and then eliminated from $D1$.
$DU$ is the signature formed from the variables bound by $D$, all of type $U$.
=EXAMPLE
z_norm_h_schema_conv Ò[w:W; x,y:X; z:U | p w x y z]Æ
 =
Ò[w:U; x:U; y:U; z:U | (w ç W ± x ç X ± y ç X) ± p w x y z]Æ
=TEX
Notice how, since $z\ ç\ U$ can be proven by $z\_ç\_u\_conv$,
it is not included in $D1$.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
The above is deliberately given no $ç$ analogue, against the convention in the introduction.

=DOC
val €z_h_schema_pred_conv› : CONV;
=DESCRIBE
A conversion for eliminating a horizontal schema as a predicate.  
=FRULE 1 Conversion
z_h_schema_pred_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] § "D as Predicate" ± P
=TEX
Projections from bindings, which are likely to be introduced, are automatically expanded
out.
The user may do so with, e.g.,
=GFT
MAP_C z_selâs_conv
=TEX

The horizontal schema may be decorated.
=SEEALSO
$z\_schema\_pred\_conv$ for a more general conversion.
=FAILURE
43012	?0 is not a horizontal schema as a predicate
=ENDDOC

\subsection{Ill-formed Schemas as Declarations}
=DOC
val €z_dec_renameâs_conv› : CONV;
=DESCRIBE
This conversion turns an ill-formed schema-as-declaration
into a well-formed one using renaming.
The ill-formed schemas-as-declarations in question are those of the form
=GFT
¨Z'SchemaDec bind schemaÆ;
=TEX
where $bind$ is not equal to $Ò \ schemaÆ$.

=FRULE 1 Conversion
z_schema_renameâs_conv
¨Z'SchemaDec bind schemaÆ
˜
˜
Ù Z'SchemaDec bind schema § 
	schema[y1/x1, ..., yk/xk]
=TEX
=USES
In correcting the results of functions which produce results outside Z because of substitution within variable binding constructs.
=FAILURE
43060	?0 is not an ill-formed schema-as-declaration
=ENDDOC


\subsection{Schema References}
These should be handled by $z\_get\_spec$.

\subsection{Operators on Schemas}
=DOC
val €z_ _ç_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting that the $ $-term of a schema is a member of the schema to that schema as a predicate.
=FRULE 1 Conversion
z_ _ç_schema_conv
Ò S ç SÆ
˜
˜
Ù  S ç S § S
=TEX
Note that the schemas cannot be decorated, as the type of
$Ò \ S\ 'Æ$ is the same as the type of $Ò \ SÆ$.
Other than that $S$ may be any schema as a predicate, including schema references and horizontal schemas.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$; and
$z\_pred\_dec\_conv$, which subsumes this conversion.
=FAILURE
43002	?0 is not of the form ¨ S ç SÆ where ¨SÆ is an undecorated schema
=ENDDOC
=DOC
val €z_schema_pred_conv› : CONV;
val €z_ _ç_schema_intro_conv› : CONV;
=DESCRIBE
$z\_schema\_pred\_conv$ is a conversion from a schema as a predicate to the predicate asserting that its $ $-term is a member of the schema.
=FRULE 1 Conversion
z_ _ç_schema_intro_conv
¨SÆ
˜
˜
Ù S §  S ç S 
=TEX
$S$ is any schema as a predicate, including both schema
references and horizontal schemas.

$z\-\_schema\-\_pred\-\_conv$ is an alias for $z\_ \_ç\_schema\_intro\_conv$.
=SEEALSO
$z\-\_h\-\_schema\-\_pred\-\_conv$ for alternative,
$z\-\_ \-\_conv$, and
$z\-\_ \-\_ç\-\_schema\-\_conv$.
=FAILURE
43014	?0 is not a schema as a predicate
=ENDDOC
=DOC
val €z_schema_pred_intro_conv› : CONV;
=DESCRIBE
This conversion attempts to convert a predicate that is a membership of a schema into a schema as a predicate.
=FRULE 1 Conversion
z_schema_pred_intro_conv
Ò(xâ1 ¶ xâ1, ...) ç SÆ
˜
˜
Ù ((xâ1 ¶ xâ1, ...) ç S) § S
=TEX
The input term must have a binding display that binds
to each label a variable with the label's name (maintaining
decoration).
=FAILURE
43032	?0 cannot be converted to a schema as a predicate
=ENDDOC
=DOC
val €z_ _conv› : CONV;
val €z_ _conv1› : CONV;
=DESCRIBE
$z\_ \_conv$ conversion from a $ $-term to the binding constructor for the schema.
=FRULE 1 Conversion
z_ _conv
Ò SÆ
˜
˜
Ù  S = (nâ1 ¶ nâ1, nâ2 ¶ nâ2, ...)
=TEX
$z\_ \_conv1$ is as $z\_ \_conv$, except that the conversion
only succeeds if the $ $ term is ill-formed (i.e. is not Z).
=FAILURE
43010	?0 is not a  -term
43011	?0 is not an ill-formed  -term
=ENDDOC
=DOC
val €z_ _eq_conv› : CONV;
=DESCRIBE
A conversion from an equality of two $ $-terms,
or a $ $ term and a binding display, to an elementwise
equality condition.
=FRULE 1 Conversion
z_ _eq_conv
Ò S =  TÆ
˜
˜
Ù (  S decS =   T decT)
§ nâ1decS = nâ1decT ± ...
=TEX
where $decS$ and $decT$ are the decoration of the respective schemas.
Also:
=FRULE 1 Conversion
z_ _eq_conv
Ò S = (nâ1 ¶ xâ1, ...)Æ
˜
˜
Ù ( S = (nâ1 ¶ xâ1, ...))
§ (nâ1 = xâ1) ± ...
=TEX
=USES
Used in combination with $z\_binding\_eq\_conv2$
to give $»$-terms the same status as binding displays.
=FAILURE
43034	?0 is not of the form: Ò S =  TÆ or Ò S = (nâ1 ¶ xâ1, ...)Æ
=ENDDOC
The above will work for ill-formed $ $-terms (i.e. not Z). 
=DOC
val €z_decâs_conv› : CONV;
val €z_ç_decâs_conv› : CONV;
=DESCRIBE
A conversion which expands a statement of membership
to a decorated schema.
=FRULE 1 Conversion
z_ç_decâs_conv
Òv ç (S)'Æ
˜
˜
Ù v ç (S)' § 
(xâ1 ¶ v.xâ1', ...) ç S
=TEX
where the type of $S$ is
=GFT
 [xâ1:U;... ]
=TEX
$S$ may be a schema-reference, or (in extended Z) anything
of the stated type.
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
=GFT Definition
val z_decâs_conv = Z_ç_ELIM_C z_ç_decâs_conv
=TEX
=FAILURE
43015	?0 not of the form: Òv ç dsÆ where ds is a decorated
	schema expression
=ENDDOC
Later issues of \ProductZ{} should provide a general mechanism for turning conversions of
the above sort into a equality on a Z set abstraction.
E.g. 
from results of the form:
=GFT Example
v ç s § p[v, s]
=TEX
to:
=GFT Example
s = {v | p[v, s]}
=TEX
=DOC
val €z_preâs_conv› : CONV;
val €z_ç_preâs_conv› : CONV;
=DESCRIBE
Schema precondition elimination. 
=FRULE 1 Conversion
z_preâs_conv
Òpre SÆ
˜
˜
Ù pre S =  [DU|(∂D1|true∑ S1)]
=TEX
$S$ is any expression of a schema type that has both primed and output variables in its declaration  (i.e. those ending in $'$ or $!$),
as well as some that are not.
$DU$ is the declaration formed from the unprimed variables of $D$, given type $U$.
$D1$ is the declaration formed from the primed variables of $D$, given type $U$.
$S1$ is the schema $S$ as a predicate.

=GFT Definition
val z_ç_preâs_conv = ç_C z_preâs_conv
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
=FAILURE
43007	?0 is not a schema precondition
43009	?0 either has a schema with no, or all, components
	with names ending in ' or !
=FAILUREC
It should not be possible to raise failure 43009 with
a term solely generated by the Z parser, as the fault
is also checked there. However, e.g., $mk\_z\_preâs$ can create 
such faulty terms.
=ENDDOC
The above could be expressed by existential quantification of a schema.

=DOC
val €z_Ñâs_conv› : CONV;
val €z_ç_Ñâs_conv› : CONV;
=DESCRIBE
A conversion concerning the delta schemas.
=FRULE 1 Conversion
z_Ñâs_conv
ÒÑ SÆ
˜
˜
Ù Ñ S = [S; S']
=TEX

=GFT Definition
val z_ç_Ñâs_conv = ç_C z_Ñâs_conv
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
=FAILURE
43022	?0 is not of the form: ÒÑ SÆ where S is a schema
=ENDDOC
=DOC
val €z_òâs_conv› : CONV;
val €z_ç_òâs_conv› : CONV;
=DESCRIBE
A conversion concerning $ò$ schemas.
=FRULE 1 Conversion
z_òâs_conv
Òò SÆ
˜
˜
Ù ò S = [S; S' |  S =  S']
=TEX
=GFT Definition
val z_ç_òâs_conv = ç_C z_òâs_conv
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
=FAILURE
43023	?0 is not of the form: Òò SÆ where S is a schema
=ENDDOC

\section{PROPOSITION CALCULUS WITH SCHEMAS}
=DOC
val €z_±âs_conv› : CONV;
val €z_ç_±âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema conjunction.
=FRULE 1 Conversion
z_ç_±âs_conv
Òv ç (R ± S)Æ
˜
˜
Ù v ç (R ± S) § 
	bind1 ç R ± bind2 ç S
=TEX
where $R$ and $S$ are schemas that have signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.

=GFT Definition
val z_±âs_conv = Z_ç_ELIM_C z_ç_±âs_conv;
=TEX
=FAILURE
43001	?0 is not of the form: Òv ç (R ± S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_≤âs_conv› : CONV;
val €z_ç_≤âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema disjunction.
=FRULE 1 Conversion
z_ç_≤âs_conv
Òv ç (R ≤ S)Æ
˜
˜
Ù v ç (R ≤ S) § 
	bind1 ç R ≤ bind2 ç S
=TEX
where $R$ and $S$ are schemas that have signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
=GFT Definition
val z_≤âs_conv = Z_ç_ELIM_C z_ç_≤âs_conv;
=TEX
=FAILURE
43005	?0 is not of the form: Òv ç (R ≤ S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_¥âs_conv› : CONV;
val €z_ç_¥âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema implication.
=FRULE 1 Conversion
z_ç_¥âs_conv
Òv ç (R ¥ S)Æ
˜
˜
Ù v ç (R ¥ S) § 
	(bind1 ç R ¥ bind2 ç S)
=TEX
where $R$ and $S$ are schemas that have signature variables variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
=GFT Definition
val z_¥âs_conv = Z_ç_ELIM_C z_ç_¥âs_conv;
=TEX
=FAILURE
43006	?0 is not of the form: Òv ç (R ¥ S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_§âs_conv› : CONV;
val €z_ç_§âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema bi-implication.
=FRULE 1 Conversion
z_ç_§âs_conv
Òv ç (R § S)Æ
˜
˜
Ù v ç (R § S) § 
	(bind1 ç R § bind2 ç S)
=TEX
where $R$ and $S$ are schemas that have signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
=GFT Definition
val z_§âs_conv = Z_ç_ELIM_C z_ç_§âs_conv;
=TEX
=FAILURE
43016	?0 is not of the form: Òv ç (R § S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_≥âs_conv› : CONV;
val €z_ç_≥âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema negation.
=FRULE 1 Conversion
z_ç_≥âs_conv
Òv ç (≥ S)Æ
˜
˜
Ù v ç (≥ S) § ≥ (v ç S)
=TEX
where $S$ is a schema
Schemas as predicates will be treated as membership
statements by this conversion.
=GFT Definition
val z_≥âs_conv = Z_ç_ELIM_C z_ç_≥âs_conv;
=TEX
=FAILURE
43017	?0 is not of the form: Òv ç (≥ S)Æ where S is a schema
=ENDDOC
\section{SCHEMA QUANTIFICATION}
=DOC
val €z_∂âs_conv› : CONV;
val €z_ç_∂âs_conv› : CONV;
=DESCRIBE
A conversion concerning membership of schema existentials.
=FRULE 1 Conversion
z_ç_∂âs_conv
Òv ç (∂ D | P∑ S)Æ
˜
˜
Ù v ç (∂ D | P∑ S) = 
∂ y : U ∑ "predicate from D[y.yâ1\yâ1,...]"
	± P[y.yâ1\yâ1,...] ±
	(xâ1 ¶ v.xâ1,...,yâ1 ¶ y.yâ1,...) ç S
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that declares $yâ1$, $yâ2$, ... .
The ``predicate from D'' will also have schemas as predicates
eliminated in favour of bindings being members of schemas.
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
=GFT Definition
val z_∂âs_conv = Z_ç_ELIM_C z_ç_∂âs_conv;
=TEX
=FAILURE
43020	?0 is not of the form: Òv ç (∂ D | P∑ S)Æ where S is a schema
=ENDDOC
=DOC
val €z_µâs_conv› : CONV;
val €z_ç_µâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema universals.
=FRULE 1 Conversion
z_ç_µâs_conv
Òv ç (µ D | P∑ S)Æ
˜
˜
Ù v ç (∂ D | P∑ S) = 
µ y : U ∑ ("predicate from D[y.yâ1\yâ1,...]"
	± P[y.yâ1\yâ1,...]) ¥
	(xâ1 ¶ v.xâ1,...,yâ1 ¶ y.yâ1,...) ç S
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that declares $yâ1$, $yâ2$, ... .
The ``predicate from D'' will also have schemas as predicates
eliminated in favour of bindings being members of schemas.
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
=GFT Definition
val z_µâs_conv = Z_ç_ELIM_C z_ç_µâs_conv;
=TEX
=FAILURE
43030	?0 is not of the form: Òv ç (µ D | P∑ S)Æ where S is a schema
=ENDDOC
=DOC
val €z_∂â1âs_conv› : CONV;
val €z_ç_∂â1âs_conv› : CONV;
=DESCRIBE
A conversion concerning schema unique existentials.
=FRULE 1 Conversion
z_ç_∂â1âs_conv
Òv ç (∂â1 D | P∑ S)Æ
˜
˜
Ù v ç (∂â1 D | P∑ S) = 
∂â1 y : U ∑ 
	"predicate from D[y.yâ1\yâ1,...]"
	± P[y.yâ1\yâ1,...] ±
	(xâ1 ¶ v.xâ1,...,yâ1 ¶ y.yâ1,...) ç S
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that declares $yâ1$, $yâ2$, ... .
The ``predicate from D'' will also have schemas as predicates
eliminated in favour of bindings being members of schemas.
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
=GFT Definition
val z_∂â1âs_conv = Z_ç_ELIM_C z_ç_∂â1âs_conv;
=TEX
=FAILURE
43021	?0 is not of the form: Òv ç (∂â1 D | P∑ S)Æ where S is a schema
=ENDDOC

\section{OTHER SCHEMA CALCULUS OPERATORS}
=DOC
val €z_˘âs_conv› : CONV;
val €z_ç_˘âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema projection.
=FRULE 1 Conversion
z_˘âs_conv
Ò(R ˘âs S)Æ
˜
˜
Ù (R ˘âs S) = ((R ± S) \âs (sâ1, sâ2, ...)
=TEX
where $R$ and $S$ are schemas that has signature variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively.
=GFT Definition
val z_ç_˘âs_conv = ç_C z_˘âs_conv
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
=FAILURE
43019	?0 is not of the form: ÒR ˘âs SÆ where R and S are schemas
=ENDDOC
=DOC
val €z_hideâs_conv› : CONV;
val €z_ç_hideâs_conv› : CONV;
=DESCRIBE
A conversion concerning the schema hiding.
=FRULE 1 Conversion
z_hideâs_conv
ÒS \âs (xâ1, ...)Æ
˜
˜
Ù S \âs (xâ1, ...) = 
	[yâ1 : U;... | ∂ xâi : U;...∑ S]
=TEX
where $S$ is a schema that has signature variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ... .
=GFT Definition
val z_ç_hideâs_conv = ç_C z_hideâs_conv
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
=FAILURE
43018	?0 is not of the form: ÒS \âs (xâ1, ...)Æ where S is a schema
=ENDDOC
=DOC
val €z_ªâs_conv› : CONV;
val €z_ç_ªâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema sequential composition.
=FRULE 1 Conversion
z_ªâs_conv
Ò(R ªâs S)Æ
˜
˜
Ù (R ªâs S) = [xâ1 :U; ... zâ1:U; ... vâ1:U; ...; wâ1':U;... |
	∂ x1:U; ... ∑
	(xâ1 ¶ xâ1, ... yâ1' ¶ x1, ... zâ1' ¶ zâ1',...) ç R
	±
	(yâ1 ¶ x1, ..., vâ1 ¶ vâ1, ..., wâ1 ¶ wâ1, ...) ç S
	]
=TEX
where $R$ has signature variables:
=GFT
Unprimed variables: xâ1, xâ2, ...
Primed variables: yâ1', yâ2', ...,zâ1',...
=TEX
and $S$ has signature variables:
=GFT
Unprimed variables: yâ1, yâ2, ...
and also: vâ1, vâ2, ...
Primed variables: wâ1', wâ2', ...
and also perhaps some of xâ1', xâ2', ..., 
	yâ1', yâ2', ...,
	zâ1', zâ2', ...
=TEX
and $x1$, $x2$, ... are variables whose names are not used for variables, or as labels for the binding types of $R$ or $S$.
=GFT Definition
val z_ç_ªâs_conv = ç_C z_ªâs_conv
=TEX
Schemas as predicates will be treated as membership
statements by this conversion.
=FAILURE
43025	?0 is not of the form: ÒR ªâs SÆ where R and S are schemas
=ENDDOC
=DOC
val €z_renameâs_conv› : CONV;
val €z_ç_renameâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema renaming.
=FRULE 1 Conversion
z_ç_renameâs_conv
Òv ç S[xâ1/yâ1,...]Æ
˜
˜
Ù v ç S[xâ1/yâ1,...] § 
(yâ1 ¶ v.xâ1,...,zâ1 ¶ v.zâ1,...) ç S
=TEX
where $S$ has signature variables $xâ1$,... and $zâ1$,...
Schemas as predicates will be treated as membership
statements by this conversion.
If $v$ is a binding display then $v.xâi$ will be simplified.
The conversion will fail with error 43035 if applied to a renaming that renames one component 
to an already existent, unrenamed, component.
=GFT Definition
val z_renameâs_conv = Z_ç_ELIM_C z_ç_renameâs_conv;
=TEX
=FAILURE
43031	?0 is not of the form: ÒS[xâ1/yâ1,...]Æ where S is a schema
43035	?0 is of the form ÒS[...,xâi/yâi,...]Æ where xâi is already an unrenamed component of S
=ENDDOC

\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{4in}}
$'z\_schemas$ & For reasoning about Z schemas, other than bindings \\
\end{tabular}

=DOC
(* Proof Context: €'z_schemas› *)
=DESCRIBE
A component proof context for handling the manipulation of Z schemas. It ``understands'' the membership, or schema as predicate, properties of each of the schema calculus operators.
It will replace an appropriate $Òv\ ç\ SÆ$ by a ``schema $S$ as predicate''.

Predicates and expressions treated by this proof context are constructs formed from:
=GFT
(selection from) horizontal schemas, schemas as predicates, (selection from)   expressions,
≥âs, ±âs, ≤âs, ¥âs, §âs, µâs, ∂âs, ∂â1âs, decâs, preâs, ˘âs, hideâs, Ñâs, òâs, ªâs, renameâs,
=TEX
\paragraph{Contents}\ 

Rewriting:
=GFT
(RAND_C z_ _conv THEN_C z_selâs_conv) 
	- which simplifies terms of the form: Ò(  s).nmÆ
z_ _eq_conv, z_ _conv1,
z_ç_≥âs_conv, z_ç_±âs_conv, z_ç_≤âs_conv, 
z_ç_¥âs_conv, z_ç_§âs_conv, z_ç_∂âs_conv, 
z_ç_∂â1âs_conv, z_ç_µâs_conv, z_ç_h_schema_conv, 
z_ç_decâs_conv, z_ç_preâs_conv, z_ç_˘âs_conv, 
z_ç_hideâs_conv, z_ç_Ñâs_conv, z_ç_òâs_conv, 
z_ç_ªâs_conv, z_ç_renameâs_conv, z_schema_pred_intro_conv
=TEX

Stripping theorems and conclusions:
=GFT
(RAND_C z_ _conv THEN_C z_selâs_conv) 
	- which simplifies boolean terms of the form: Ò(  s).nmÆ
ç_C (RAND_C z_ _conv THEN_C z_selâs_conv) 
	- which simplifies terms of the form: Òx ç (  s).nmÆ
z_ _eq_conv, z_ç_≥âs_conv, z_ç_±âs_conv, z_ç_≤âs_conv, 
z_ç_¥âs_conv, z_ç_§âs_conv, z_ç_∂âs_conv, 
z_ç_∂â1âs_conv, z_ç_µâs_conv, z_ç_h_schema_conv, 
z_ç_decâs_conv, z_ç_preâs_conv, z_ç_˘âs_conv, 
z_ç_hideâs_conv, z_ç_Ñâs_conv, z_ç_òâs_conv, 
z_ç_ªâs_conv, z_ç_renameâs_conv, z_schema_pred_intro_conv
plus these all pushed in through ≥
=TEX
Rewriting canonicalisation:
=GFT
=TEX
Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_language\-\_ps$.
It is intended to be used with proof context ``z$\_$bindings''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
\newpage
\section{PROOF RULES AND COVERAGE OF $Z\_TERM$}
In the following ``$pc+=$'' stands for
``predicate calculus plus equality''
which should be reasoned about by $strip\_tac$, $rewrite\_tac[]$ and the ``two-tactic'' method,
in the proof context $z\_predicates$.

All of the following have both $ç$ and ``straight'' forms
of reasoning rules if the constructor always constructs
items that are sets.
In these cases the proof rule given below will be called $z\_ç\_...$,
and operates on a term of the form $Òv\ ç\ ...Æ$,
and there will also be a $z\_...$ equivalent that operates
directly on the set.
One of these two is likely to be derived in a trivial manner
from the other, by $ç\_C$ or $Z\_ç\_ELIM\_C$, as indicates
in the function's description.

\begin{tabular}{| p{1.3in} | p{4.7in} |}\hline
Constructor & Proof Rules \\ \hline
$ZDec$ & $z\_dec\_pred\_conv$ \\
$ZSchemaDec$ & $z\_dec\_pred\_conv$ \\
$ZDecl$ & $z\_decl\_pred\_conv$ \\
$ZEq$ & $pc+=$ \\
$Zç$ & Various $z\_ç\_$ functions, e.g. $z\_ç\_seta\_conv$ \\
$ZTrue$ & $pc+=$ \\
$ZFalse$ & $pc+=$ \\
$Z≥$ & $pc+=$ \\
$Z≥âs$ & $z\_ç\_≥âs\_conv$ \\
$Z±$ & $pc+=$ \\
$Z±âs$ & $z\_ç\_±âs\_conv$ \\
$Z≤$ & $pc+=$ \\
$Z≤âs$ & $z\_ç\_≤âs\_conv$ \\
$Z¥$ & $pc+=$ \\
$Z¥âs$ & $z\_ç\_¥âs\_conv$ \\
$Z§$ & $pc+=$ \\
$Z§âs$ & $z\_ç\_§âs\_conv$ \\
$Z∂$ & $pc+=$ \\
$Z∂âs$ & $z\_ç\_∂âs\_conv$ \\
$Z∂â1$ & $pc+=$ \\
$Z∂â1âs$ & $z\_ç\_∂â1âs\_conv$ \\
$Zµ$ & $pc+=$ \\
$Zµâs$ & $z\_ç\_µâs\_conv$ \\ \hline
\end{tabular}

\begin{tabular}{| p{1.3in} | p{4.7in} |}\hline
Constructor & Proof Rules \\ \hline
$ZSchemaPred$ & $z\_schema\_pred\_conv$ and others \\
$ZLVar$ & $pc+=$ \\
$ZGVar$ & Rewriting with definition from $z\_get\_spec$ \\
$ZInt$ & Various, see \cite{DS/FMU/IED/DTD086} \\
$ZString$ & $z\-\_string\-\_conv$ \\
$Zß¢$ & $z\_ß¢\_conv$ \\
$ZSetd$ & $z\_ç\_setd\_conv$ \\
$ZSeta$ & $z\_ç\_seta\_conv$ \\
$Z$ & $z\_ç\_\_thm$ and others \\
$ZTuple$ & Various: $z\_selât\_...$, $z\_tuple\_eq\_conv$ \\
$ZBinding$ & Various: $z\_selâs\_...$, $z\_binding\_eq\_conv$ \\
$Z∏$ & $z\_ç\_∏\_conv$ \\
$Z $ & $z\_ \_conv$ \\
$ZSelâs$ & $z\_selâs\_conv$ and others \\
$ZSelât$ & $z\_selât\_conv$ and others \\
$ZÕ$ & $z\_Õ\_rule$ \\
$ZApp$ & $z\_app\_conv$ \\
$ZÃ$ & $z\_ç\_Ã\_conv$ and $z\_¬\_conv$ \\
$ZHSchema$ & $z\_ç\_h\_schema\_conv$ \\
$ZDecorâs$ & $z\_ç\_decâs\_conv$ \\
$ZPreâs$ & $z\_ç\_preâs\_conv$ \\
$Z˘âs$ & $z\_ç\_˘âs\_conv$ \\
$ZHideâs$ & $z\_ç\_hideâs\_conv$ \\
$ZÑâs$ & $z\_ç\_Ñâs\_conv$ \\
$Zòâs$ & $z\_ç\_òâs\_conv$ \\
$Zªâs$ & $z\_ç\_ªâs\_conv$ \\
$ZRenameâs$ & $z\_ç\_renameâs\_conv$ \\ \hline
\end{tabular}

\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSchemaCalculus *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


