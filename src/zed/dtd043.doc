=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Schema Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD043}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the 
 Z schema calculus in \ProductZ.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] First issue.
\item [Issue 1.2] 
Heavily reworked by KB.
\item [Issue 1.3, 2nd October 1992] 
Reworking.
\item [Issue 1.4, 7th October 1992] 
Changes after comments.
\item [Issue 1.5, 14th October 1992] 
Dependencies changed.
\item [Issue 1.5, 19th October 1992] 
Notes on $schema\_ref\_conv$.
\item [Issue 1.6-8, 29th October 1992] 
Changes to reflect Z theory reorganisation.
\item [Issue 1.9, 11th November 1992] 
Changes as a consequence of changes in dependences.
\item [Issue 1.10, 20th November 1992] 
Completing the Schema Calculus.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference for
the Z Proof Support System schema calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP043}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules and conversions for the schema calculus of the Z Proof Support System. Section \ref{CONVANDRULE} describes the main conversions and rules for the Z schema calculus. 
The extended Z language supported is documented in the 
Z User Interface subsystem, \cite{DS/FMU/IED/HLD018}.

By default all relevant functions in this document should
be assumed to remain within the Z language and to check this fact, unless otherwise stated.
\subsubsection{Dependencies}
Loading this document is dependent on those
having loaded \cite{DS/FMU/IED/IMP042}.

\pagebreak
\section{Z SCHEMA CALCULUS}
=DOC
signature €ZSchemaCalculus› = sig
=DESCRIBE
This provides the rules of inference for schema calculus in the Z proof support system.
The material is implemented within the theory $z\-\_language\-\_ps$.
=ENDDOC
=FAILURE
43000	DESIGN ERROR: a check failed that should never fail
=TEX
\section{CONVERSIONS AND RULES}\label{CONVANDRULE}
\subsection{Horizontal Schemas}
=DOC
val €z_ç_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to an existential quantification.  
=FRULE 1 Conversion
z_ç_horiz_schema_conv
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § ∂D'|P'∑ [D'] = v
=TEX
Bound variable renaming may be necessary, and thus the priming in the RHS of the result.
=SEEALSO
$z\_ç\_horiz\_schema\_conv1$ for a faster, if more verbose result from simplifying the same category of terms,
$z\_horiz\_schema\_conv$ for a horizontal schema term  without and outer $ç$.
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
=ENDDOC
=DOC
val €z_ç_horiz_schema_conv1› : CONV;
=DESCRIBE
A conversion from a predicate asserting  membership of a horizontal schema to a predicate.  
=FRULE 1 Conversion
z_ç_horiz_schema_conv1
¨v ç [D|P]Æ
˜
˜
Ù v ç [D|P] § D' ± P'
=TEX
where, if $D$ binds $xâ1$, $xâ2$,...,
then $D'$ is 
=GFT
"D[xâ1 \ v.xâ1, ...] as a predicate"
=TEX
as converted by $z\_decl\_pred\_conv$,
and $P'$ is
=GFT
P[xâ1 \ v.xâ1, ...]
=TEX
The execution of the conversion may also involve bound variable renaming.
Though this conversion gives a rather verbose result,
it evaluates faster than $z\_ç\_schema\_conv$,
and is probably of more practical value in a proof.
=SEEALSO
$z\_ç\_horiz\_schema\_conv$
=FAILURE
43003	?0 is not of the form ¨v ç [D|P]Æ 
=ENDDOC

=DOC
val €z_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion from a horizontal schema to a set comprehension.  
=FRULE 1 Conversion
z_horiz_schema_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] = {D|P∑ D}
=SEEALSO
$z\_ç\_horiz\_schema\_conv$ and $z\_ç\_horiz\_schema\_conv1$, which are
more appropriate if the schema expression occurs as a 
subterm of a membership expression.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
=DOC
val €z_norm_horiz_schema_conv› : CONV;
=DESCRIBE
A conversion for normalising horizontal schemas.  
=FRULE 1 Conversion
z_norm_horiz_schema_conv 
¨[D|P]Æ
˜
˜
Ù [D|P] = [DU|D1 ± P]
=TEX
D1 is the implicit predicate formed from D by 
=INLINEFT
z_decl_pred_conv
=TEX
{}. Conjuncts that are
provable by $ç\_u\_conv$, q.v., are not included in D1.
DU is the signature formed from the remaining variables of D, all of type U.
=FAILURE
43004	?0 is not a horizontal schema 
=ENDDOC
=DOC
val €z_horiz_schema_pred_conv› : CONV;
=DESCRIBE
A conversion for eliminating a horizontal schema as a predicate.  
=FRULE 1 Conversion
z_horiz_schema_pred_conv
Ò[D|P]Æ
˜
˜
Ù [D|P] § "D as Predicate" ± P
=TEX
Projections from bindings, which are likely to be introduced, are not automatically expanded
out.
The user may do so with, e.g.,
=GFT
MAP_C z_binding_sel_conv
=TEX

The horizontal schema may be decorated.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$ for an alternative expansion.
=FAILURE
43012	?0 is not a horizontal schema as a predicate
=ENDDOC
\subsection{Schema References}
The following two functions are of an unusual style of \Product{},
in that they go looking for definitions in theories - something normally left to $get\_spec$.
In addition, their processing can be mimicked by rewriting
in most cases.
They are primarily intended for the tool builder, though not for proof contexts.
=DOC
val €z_schema_ref_conv› : CONV;
=DESCRIBE
A conversion which expands a schema reference that is an expression, using its stored definition. 
=FRULE 1 Conversion
z_schema_ref_conv
ÒSÆ
˜
˜
Ù S = defn
=TEX
where $defn$ is the stored definition of S.
The function insists on its input being a global variable having a schema's type,
but does not require the result, $defn$, to be a horizontal 
schema.
=SEEALSO
$get\_spec$, which is at the core of the implementation
of this function.
=FAILURE
43011	?0 is not a schema reference as an expression
43013	?0 is not a schema reference with a known specification
=ENDDOC
=DOC
val €z_schema_ref_pred_conv› : CONV;
=DESCRIBE
A conversion for eliminating a schema reference as a predicate.  
=FRULE 1 Conversion
z_schema_ref_pred_conv
ÒSÆ
˜
˜
Ù S § "D as Predicate" ± P
=TEX
The declaration part of the schema referred to by 
schema reference $S$ is referred to as $D$,
and $P$ is the predicate part.
The schema reference must be a global variable that refers to a horizontal schema.

Projections from bindings, which are likely to be introduced, are not automatically expanded
out.
The user may do so with, e.g.,
=GFT
MAP_C z_binding_sel_conv
=TEX
The schema reference may be decorated.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$ for an alternative expansion.
=FAILURE
43008	?0 is not a schema reference as a predicate
=ENDDOC
We don't automatically rewrite the bindings because 
there may be more, that should be left untouched, in the 
schema body.

\subsection{Operators on Schemas}
=DOC
val €z_ _ç_schema_conv› : CONV;
=DESCRIBE
A conversion from a predicate asserting that the $ $-term of a schema is a member of the schema to that schema as a predicate.
=FRULE 1 Conversion
z_ _ç_schema_conv
Ò S ç SÆ
˜
˜
Ù  S ç S § S
=TEX
Note that the schemas cannot be decorated, as the type of
$Ò \ S\ 'Æ$ is the same as the type of $Ò \ SÆ$.
Other than that $S$ may be any schema as a predicate, including schema references and horizontal schemas.
=SEEALSO
$z\_ \_ç\_schema\_intro\_conv$, and
$pred\_dec\_conv$, which subsumes this conversion.
=FAILURE
43002	?0 is not of the form ¨ S ç SÆ where ¨SÆ is an undecorated schema
=ENDDOC
=DOC
val €z_ _ç_schema_intro_conv› : CONV;
=DESCRIBE
A conversion from a schema as a predicate to the predicate asserting that its $ $-term is a member of the schema.
=FRULE 1 Conversion
z_ _ç_schema_intro_conv
¨SÆ
˜
˜
Ù S §  S ç S 
=TEX
$S$ is any schema as a predicate, including both schema
references and horizontal schemas.
=SEEALSO
$z\-\_schema\-\_ref\-\_pred\-\_conv$ and
$z\-\_horiz\-\_schema\-\_pred\-\_conv$ for alternatives,
$z\-\_ \-\_ç\-\_schema\-\_conv$ for what to do next.
=FAILURE
43014	?0 is not a schema as a predicate
=ENDDOC
=DOC
val €z_ _conv› : CONV;
=DESCRIBE
A conversion from a $ $-term to the binding constructor for the schema.
=FRULE 1 Conversion
z_ _conv
Ò SÆ
˜
˜
Ù  S = (nâ1 ¶ nâ1, nâ2 ¶ nâ2, ...)
=FAILURE
43010	?0 is not a  -term
=ENDDOC
=DOC
val €z_ç_decâs_conv› : CONV;
=DESCRIBE
A conversion which expands a statement of membership
to a decorated schema.
=FRULE 1 Conversion
z_ç_decâs_conv
Òv ç (S)'Æ
˜
˜
Ù v ç (S)' § 
(xâ1 ¶ v.xâ1', ...) ç S
=TEX
where the type of $S$ is
=GFT
 [xâ1:U;... ]
=TEX
$S$ may be a schema-reference, or (in extended Z) anything
of the stated type.
=FAILURE
43015	?0 not of the form: Òv ç dsÆ where ds is a decorated
	schema expression
=ENDDOC
Later issues of \ProductZ{} should provide a general mechanism for turning conversions of
the above sort into a equality on a Z set abstraction.
E.g. 
from results of the form:
=GFT Example
v ç s § p[v, s]
=TEX
to:
=GFT Example
s = {v | p[v, s]}
=TEX
=DOC
val €z_preâs_conv› : CONV;
=DESCRIBE
Schema precondition elimination. 
=FRULE 1 Conversion
z_preâs_conv
Òpre SÆ
˜
˜
Ù pre S =  [DU|(∂D1|true∑ S1)]
=TEX
$S$ is any expression of a schema type that has both primed and output variables in its declaration  (i.e. those ending in $'$ or $!$),
as well as some that are not.
$DU$ is the declaration formed from the unprimed variables of $D$, given type $U$.
$D1$ is the declaration formed from the primed variables of $D$, given type $U$.
$S1$ is the schema $S$ as a predicate.
=FAILURE
43007	?0 is not a schema precondition
43009	?0 either has a schema with no, or all, components
	with names ending in ' or !
=FAILUREC
It should not be possible to raise failure 43009 with
a term solely generated by the Z parser, as the fault
is also checked there. However, e.g., $mk\_z\_preâs$ can create 
such faulty terms.
=ENDDOC
=DOC
val €z_Ñâs_conv› : CONV;
=DESCRIBE
A conversion concerning the delta schemas.
=FRULE 1 Conversion
z_Ñâs_conv
ÒÑ SÆ
˜
˜
Ù Ñ S § [S; S']
=TEX
=FAILURE
43022	?0 is not of the form: ÒÑ SÆ where S is a schema
=ENDDOC
=DOC
val €z_òâs_conv› : CONV;
=DESCRIBE
A conversion concerning $ò$ schemas.
=FRULE 1 Conversion
z_òâs_conv
Òò SÆ
˜
˜
Ù ò S § [S; S' |  S =  S']
=TEX
=FAILURE
43023	?0 is not of the form: Òò SÆ where S is a schema
=ENDDOC

\section{PROPOSITION CALCULUS WITH SCHEMAS}
=DOC
val €z_ç_±âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema conjunction.
=FRULE 1 Conversion
z_ç_±âs_conv
Òv ç (R ± S)Æ
˜
˜
Ù v ç (R ± S) § 
	bind1 ç R ± bind2 ç S
=TEX
where $R$ and $S$ are schemas that bind variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=FAILURE
43001	?0 is not of the form: Òv ç (R ± S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_ç_≤âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema disjunction.
=FRULE 1 Conversion
z_ç_≤âs_conv
Òv ç (R ≤ S)Æ
˜
˜
Ù v ç (R ≤ S) § 
	bind1 ç R ≤ bind2 ç S
=TEX
where $R$ and $S$ are schemas that bind variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=FAILURE
43005	?0 is not of the form: Òv ç (R ≤ S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_ç_¥âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema implication.
=FRULE 1 Conversion
z_ç_¥âs_conv
Òv ç (R ¥ S)Æ
˜
˜
Ù v ç (R ¥ S) § 
	(bind1 ç R ¥ bind2 ç S)
=TEX
where $R$ and $S$ are schemas that bind variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=FAILURE
43006	?0 is not of the form: Òv ç (R ¥ S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_ç_§âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema bi-implication.
=FRULE 1 Conversion
z_ç_§âs_conv
Òv ç (R § S)Æ
˜
˜
Ù v ç (R § S) § 
	(bind1 ç R § bind2 ç S)
=TEX
where $R$ and $S$ are schemas that bind variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively,
and
=GFT
bind1 = (râ1 ¶ v.râ1, ...)
bind2 = (sâ1 ¶ v.sâ1, ...)
=TEX
=FAILURE
43016	?0 is not of the form: Òv ç (R § S)Æ where R and S are schemas
=ENDDOC
=DOC
val €z_ç_≥âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema negation.
=FRULE 1 Conversion
z_ç_≥âs_conv
Òv ç (≥ S)Æ
˜
˜
Ù v ç (≥ S) § ≥ (v ç S)
=TEX
where $S$ is a schema
=FAILURE
43017	?0 is not of the form: Òv ç (≥ S)Æ where S is a schema
=ENDDOC
\section{SCHEMA QUANTIFICATION}
=DOC
val €z_∂âs_conv› : CONV;
=DESCRIBE
A conversion concerning schema existentials.
=FRULE 1 Conversion
z_∂âs_conv
Ò(∂ D | P∑ S)Æ
˜
˜
Ù (∂ D | P∑ S) § 
[xâ1: U;...| (∂ D | P∑   S ç S)]
=TEX
where $S$ is a schema that binds variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that binds $yâ1$, $yâ2$, ... .
=FAILURE
43020	?0 is not of the form: Ò∂ D | P∑ SÆ where S is a schema
=ENDDOC
=DOC
val €z_µâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema universals.
=FRULE 1 Conversion
z_µâs_conv
Ò(µ D | P∑ S)Æ
˜
˜
Ù (µ D | P∑ S) § 
[xâ1: U;...| (µ D | P∑   S ç S)]
=TEX
where $S$ is a schema that binds variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that binds $yâ1$, $yâ2$, ... .
=FAILURE
43021	?0 is not of the form: Òµ D | P∑ SÆ where S is a schema
=ENDDOC
=DOC
val €z_∂â1âs_conv› : CONV;
=DESCRIBE
A conversion concerning schema unique existentials.
=FRULE 1 Conversion
z_∂â1âs_conv
Ò(∂â1 D | P∑ S)Æ
˜
˜
Ù (∂â1 D | P∑ S) § 
[xâ1: U;... | (∂â1 D | P∑   S ç S)]
=TEX
where $S$ is a schema that binds variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ...
$D$ a declaration that binds $yâ1$, $yâ2$, ... .
=FAILURE
43021	?0 is not of the form: Ò∂â1 D | P∑ SÆ where S is a schema
=ENDDOC

\section{OTHER SCHEMA CALCULUS OPERATORS}
=DOC
val €z_˘âs_conv› : CONV;
=DESCRIBE
A conversion concerning the membership of a schema projection.
=FRULE 1 Conversion
z_˘âs_conv
Ò(R ˘âs S)Æ
˜
˜
Ù (R ˘âs S) § ((R ± S) \âs (sâ1, sâ2, ...)
=TEX
where $R$ and $S$ are schemas that bind variables $râ1$, $râ2$, ... and $sâ1$, $sâ2$, ... respectively.
=FAILURE
43019	?0 is not of the form: ÒR ˘âs SÆ where R and S are schemas
=ENDDOC
=DOC
val €z_hideâs_conv› : CONV;
=DESCRIBE
A conversion concerning the schema hiding.
=FRULE 1 Conversion
z_hideâs_conv
ÒS \ (xâ1, ...)Æ
˜
˜
Ù S \ (xâ1, ...) = 
	[yâ1 : U;... | ∂ xâi : U;...∑ S]
=TEX
where $S$ is a schema that binds variables $xâ1$, $xâ2$, ... and $yâ1$, $yâ2$, ... .
=FAILURE
43018	?0 is not of the form: ÒS \âs (xâ1, ...)Æ where S is a schema
=ENDDOC
=DOC
val €z_ªâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema sequential composition.
=FRULE 1 Conversion
z_ªâs_conv
Ò(R ªâs S)Æ
˜
˜
Ù (R ªâs S) § ∂ [yâ1:U;...]''∑ 
(∂ [yâ1:U;...]'∑ [R;[yâ1:U;...]''| 
	 [yâ1:U;...]' =  [yâ1:U;...]''])
±
(∂ [yâ1:U;...]∑ [S;[yâ1:U;...]''| 
	 [yâ1:U;...] =  [yâ1:U;...]''])
=TEX
where $R$ binds:
=GFT
Undecorated variables: xâ1, xâ2, ...
Decorated variables: yâ1', yâ2', ...
=TEX
and $S$ binds:
=GFT
Undecorated variables: yâ1, yâ2, ...
and also: zâ1, zâ2, ...
Decorated variables: wâ1', wâ2', ...
and also perhaps some of xâ1', xâ2', ..., 
	yâ1', yâ2', ...,
	wâ1', wâ2', ...
=TEX
=FAILURE
43025	?0 is not of the form: ÒR ªâs SÆ where R and S are schemas
=ENDDOC
=DOC
val €z_ç_renameâs_conv› : CONV;
=DESCRIBE
A conversion concerning schema renaming.
=FRULE 1 Conversion
z_renameâs_conv
Òv ç S[xâ1/yâ1,...]Æ
˜
˜
Ù v ç S[xâ1/yâ1,...] § 
 (yâ1 ¶ v.xâ1, ..., zâ1 ¶ v.zâ1, ...) ç S
=TEX
where $S$ binds variables $xâ1$,... and $zâ1$,...
=FAILURE
43023	?0 is not of the form: ÒS[xâ1/yâ1,...]Æ where S is a schema
=ENDDOC

\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{4in}}
$'z\_schemas$ & For reasoning about Z schemas, other than bindings \\
\end{tabular}

=DOC
(* Proof Context: €'z_schemas› *)
=DESCRIBE
A component proof context for handling the manipulation of Z bindings.

NOT YET IMPLEMENTED

\paragraph{Contents}\ 

Rewriting:
=GFT
=TEX

Stripping theorems:
=GFT
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_language\-\_ps$.
It is intended to be used with proof context ``z$\_$bindings''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
\newpage
\section{PROOF RULES AND COVERAGE OF $Z\_TERM$}
In the following ``$pc+=$'' stands for
``predicate calculus plus equality''
which should be reasoned about by $strip\_tac$, $rewrite\_tac[]$ and the ``two-tactic'' method,
in the proof context $z\_predicates$.

\begin{tabular}{| p{1.3in} | p{4.7in} |}\hline
Constructor & Proof Rules \\ \hline
$ZDec$ & $dec\_pred\_conv$ \\
$ZSchemaDec$ & $dec\_pred\_conv$ \\
$ZDecl$ & $z\_decl\_pred\_conv$ \\
$ZEq$ & $pc+=$ \\
$Zç$ & Various $z\_ç\_$ functions, e.g. $z\_ç\_seta\_conv$ \\
$ZTrue$ & $pc+=$ \\
$ZFalse$ & $pc+=$ \\
$Z≥$ & $pc+=$ \\
$Z≥âs$ & $z\_ç\_≥âs\_conv$ \\
$Z±$ & $pc+=$ \\
$Z±âs$ & $z\_ç\_±âs\_conv$ \\
$Z≤$ & $pc+=$ \\
$Z≤âs$ & $z\_ç\_≤âs\_conv$ \\
$Z¥$ & $pc+=$ \\
$Z¥âs$ & $z\_ç\_¥âs\_conv$ \\
$Z§$ & $pc+=$ \\
$Z§âs$ & $z\_ç\_§âs\_conv$ \\
$Z∂$ & $pc+=$ \\
$Z∂âs$ & $z\_∂âs\_conv$ \\
$Z∂â1$ & $pc+=$ \\
$Z∂â1âs$ & $z\_∂â1âs\_conv$ \\
$Zµ$ & $pc+=$ \\
$Zµâs$ & $z\_µâs\_conv$ \\ \hline
\end{tabular}

\begin{tabular}{| p{1.3in} | p{4.7in} |}\hline
Constructor & Proof Rules \\ \hline
$ZSchemaPred$ & $z\_horiz\_schema\_pred\_conv$ and others \\
$ZLVar$ & $pc+=$ \\
$ZGVar$ & Rewriting with definition from $z\_get\_spec$ \\
$ZInt$ & Various, see \cite{DS/FMU/IED/DTD086} \\
$ZString$ & Strings - ? \\
$Zß¢$ & Sequences - ? \\
$ZSetd$ & $z\_ç_setd\_conv$ \\
$ZSeta$ & $z\_ç_seta\_conv$ \\
$Z$ & $z\_ç\_\_thm$ and others \\
$ZTuple$ & Various $z\_tuple\_...$, e.g. $z\_tuple\_eq\_conv$ \\
$ZBinding$ & Various $z\_binding\_...$, e.g. $z\_binding\_eq\_conv$ \\
$Z∏$ & $z\_ç\_∏\_conv$ and $z\_∏\_conv$ \\
$Z $ & $z\_ \_conv$ \\
$ZSelâs$ & $z\_binding\_sel\_conv$ and others \\
$ZSelât$ & $z\_tuple\_selection\_conv$ and others \\
$ZÕ$ & $z\_Õ\_rule$ \\
$ZApp$ & $z\_app\_conv$ \\
$ZÃ$ & $z\_Ã\_conv$ and $z\_¬\_conv$ \\
$Zâs$ & $z\_horiz\_schema\_conv$ or $z\_ç\_horiz\_schema\_conv1$ \\
$ZDecorâs$ & $z\_ç\_decâs\_conv$ \\
$ZPreâs$ & $z\_ç\_preâs\_conv$ \\
$Z˘âs$ & $z\_˘âs\_conv$ \\
$ZHideâs$ & $z\_hideâs\_conv$ \\
$ZÑâs$ & $z\_Ñâs\_conv$ \\
$Zòâs$ & $z\_òâs\_conv$ \\
$Zªâs$ & $z\_ªâs\_conv$ \\
$ZRenameâs$ & $z\_ç\_renameâs\_conv$ \\ \hline
\end{tabular}

\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSchemaCalculus *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


