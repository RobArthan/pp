=IGN
********************************************************************************
imp106.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Implementation of Arithmetic Proof Procedures for Z}

\def\AbstractText{This document contains the implementation of proof procedures for the integers in Z. These include arithmetic normalisation and a linear arithmetic prover.}

\def\Reference{DS/FMU/IED/IMP106}

\def\Author{R.D. Arthan}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{FST PROJECT}  %% Mandatory field
%% LaTeX2e port: %\TPPvolume{}
%% LaTeX2e port: %\TPPpart{}
%% LaTeX2e port: \def\TPPheadtitle{ Arithmetic Proof Procedures for Z}
%% LaTeX2e port: \TPPtitle{Implementation of Arithmetic Proof Procedures for Z}  %% Mandatory field
%% LaTeX2e port: \TPPref{DS/FMU/IED/IMP106}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{$Revision: 1.7 $
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{\FormatDate{$Date: 2004/01/19 12:44:00 $%
%% LaTeX2e port: }}
%% LaTeX2e port: \TPPstatus{Draft}			%% Mandatory field
%% LaTeX2e port: \TPPtype{SML Literate Script}
%% LaTeX2e port: \TPPkeywords{}
%% LaTeX2e port: \TPPauthor{R.D.~Arthan & WIN01}
%% LaTeX2e port: \TPPauthorisation{R.B.~Jones & FMU Manager}
%% LaTeX2e port: \TPPabstract{This document contains the implementation of proof
%% LaTeX2e port: procedures for the integers in Z.
%% LaTeX2e port: These include arithmetic normalisation and a linear arithmetic prover.}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port: 	    Library
%% LaTeX2e port: }}
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item[Issues .1, 1.2 (1994/12/21)] First drafts.
\item[Issue 1.3 (1996/03/07)]
Added $z\_lin\_arith1$.
\item[Issue 1.4 (2002/03/09)]
Stopped it undeclaring the HOL aliases in the theory of HOL integers.
\item[Issue 1.5 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.6 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.7 (2004/01/19)] The Z universal set is now called ƒ.
\item[Issue 1.8 (2006/04/20)] Added support for floating point literals
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes forecast}
As determined by comment and review.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of part of the \ProductZ\ system.
The document responds to \cite{DS/FMU/IED/DTD106}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD106}.
\subsubsection{Dependencies}
This document depends on the theory $z\_numbers$ defined in
\cite{DS/FMU/IED/DTD086} and on the conversions and tactics in
\cite{DS/FMU/IED/DTD105}.
\subsubsection{Algorithms}
Once the right theorems are proved the code is very straightforward.
All the difficulty, such as it is, is captured in the rewrite schemes in the detailed design.
\subsubsection{Known Deficiencies}
None.
\subsubsection{Possible Enhancements}
See \cite{DS/FMU/IED/DTD106}.
\section{PREAMBLE}
=TEX
=SML
structure ÛZArithmeticToolsÝ : ZArithmeticTools = struct
=TEX
=SML
val _ = set_merge_pcs["'ú", "hol"];
=TEX
\section{CONSISTENCY PROOF}
=SML
val Ûz_plus1_hol_plus1_thmÝ = (
set_goal([], ¬µm : î· ñ ¬îú m® + ¬îú 1®® = îú m + îú 1 ®);
a(strip_tac);
a(LEMMA_T ¬ñ¬îú m® + ¬îú 1®® = ¬îú(m + 1)®
	± îú m + îú 1 = îú(m + 1)® rewrite_thm_tac THEN strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[rewrite_rule[get_spec¬Z'Int®]z'int_def]);
(* *** Goal "2" *** *)
a(rewrite_tac[îú_plus_homomorphism_thm]);
(fn _ => pop_thm()) "z_plus1_hol_plus1_thm"
);
val Ûz_plus1_hol_plus1_thm1Ý = (
push_goal([], ¬µm : î· îú m + îú 1 = ñ ¬îú m® + ¬îú 1®® ®);
a(rewrite_tac[z_plus1_hol_plus1_thm]);
(fn _ => pop_thm()) "z_plus1_hol_plus1_thm1"
);
=TEX
=SML
val Ûz_plus_hol_plus_thmÝ = (
set_goal([], ¬µm n : î· ñ ¬îú m® + ¬îú n®® = îú m + îú n ®);
a(REPEAT strip_tac);
a(induction_tac¬n®);
(* *** Goal "1" *** *)
a(rewrite_tac[] THEN PC_T1 "z_predicates" rewrite_tac[z_plus_clauses]
	THEN rewrite_tac[get_spec¬Z'Int®]);
(* *** Goal "2" *** *)
a(rewrite_tac[îú_plus_homomorphism_thm, ú_plus_assoc_thm1]);
a(LEMMA_T ¬(îú m + îú n) = îú (m + n)® rewrite_thm_tac
	THEN1 rewrite_tac[îú_plus_homomorphism_thm]);
a(rewrite_tac[z_plus1_hol_plus1_thm1]);
a(PC_T1 "z_predicates" asm_rewrite_tac[z_plus_assoc_thm1]);
a(rewrite_tac[îú_plus_homomorphism_thm]);
(fn _ => pop_thm()) "z_plus_hol_plus_thm"
);
=TEX
=SML
val Ûz_îú_cases_thmÝ = (
set_goal([], ¬µi : ú· ¶m : î· i = îú m ² i = ñ~¬îú m®®®);
a(REPEAT strip_tac);
a(lemma_tac¬µi·i  ñî® ´ ¶m·i = îú m®);
(* *** Goal "1" *** *)
a(strip_tac THEN z_î_induction_tac);
(* *** Goal "1.1" *** *)
a(¶_tac¬0® THEN rewrite_tac[get_spec¬Z'Int®]);
(* *** Goal "1.2" *** *)
a(all_var_elim_asm_tac1);
a(rewrite_tac[get_spec¬Z'Int®, z_plus1_hol_plus1_thm]);
a(¶_tac¬i' + 1® THEN rewrite_tac[îú_plus_homomorphism_thm]);
a(PC_T1 "z_predicates" strip_asm_tac(pc_rule1 "z_predicates"
	rewrite_rule[](z_µ_elim¬i® z_ú_cases_thm))
	THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
a(¶_tac ¬m® THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[] THEN all_var_elim_asm_tac1);
a(¶_tac ¬m® THEN REPEAT strip_tac);
(fn _ => pop_thm()) "z_îú_cases_thm"
);
=TEX
=SML
val Ûz_ú_iso_lemma1Ý = (
set_goal([], ¬¶f: ú ­ ú·
		f (îú 1) = ñ1®
	±	µi·f(i + îú 1) = ñ¬f i® + 1®
®);
a(¶_tac¬Ìx:ú·if îú 0 ¼ x then x else ñ~¬~(x:ú)®®® THEN	
		rewrite_tac[get_spec¬Z'Int®] THEN
			REPEAT strip_tac);
a(strip_asm_tac(µ_elim¬i®ú_cases_thm1) THEN asm_rewrite_tac[îú_¼_thm]);
(* *** Goal "1" *** *)
a(LEMMA_T¬îú m + îú 1 = îú(m + 1)® rewrite_thm_tac
	THEN1 rewrite_tac[îú_plus_homomorphism_thm]);
a(rewrite_tac[îú_¼_thm]);
a(rewrite_tac[îú_plus_homomorphism_thm, z_plus1_hol_plus1_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[îú_plus_homomorphism_thm, ú_minus_clauses,
		ú_plus_assoc_thm, ú_plus_clauses]);
a(LEMMA_T¬ ³ îú 0 ¼ ~ (îú m) + ~ (îú 1)® rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¬$<‰Z®, ú_plus_assoc_thm]);
a(pure_once_rewrite_tac[ú_¼_¼_0_thm1]);
a(rewrite_tac[îú_¼_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(µ_elim¬m® î_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1" *** *)
a(PC_T1 "z_predicates" rewrite_tac[z_minus_thm, get_spec¬Z'Int®]);
(* *** Goal "2.2.2" *** *)
a(LEMMA_T¬ ³ îú 0 ¼ ~ (îú(i' + 1))® rewrite_thm_tac);
(* *** Goal "2.2.2.1" *** *)
a(rewrite_tac[îú_plus_homomorphism_thm, get_spec¬$<‰Z®, ú_plus_assoc_thm]);
a(pure_once_rewrite_tac[ú_¼_¼_0_thm1]);
a(rewrite_tac[îú_¼_thm]);
(* *** Goal "2.2.2.2" *** *)
a(rewrite_tac[z_plus1_hol_plus1_thm1]);
a(PC_T1 "z_predicates" rewrite_tac[z_minus_thm,
		z_plus_assoc_thm, z_plus_clauses]);
(fn _ => pop_thm()) "z_ú_iso_lemma1"
);
=TEX
=SML
val Ûz_ú_iso_lemma2Ý = (
set_goal([], ¬µf: ú ­ ú·
		f (îú 1) = ñ1®
	±	(µi · f (i + îú 1) = ñ¬f i® + 1®)
	´	f (îú 0) = ñ0®
®);
a(REPEAT strip_tac);
a(lemma_tac¬f (îú 1) = ñ¬f(îú 0)® + ¬f(îú 1)®®®);
(* *** Goal "1" *** *)
a(LEMMA_T¬ñ¬f (îú 0)® + ¬f (îú 1)®® = f(îú 0 + îú 1) ®
	pure_rewrite_thm_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[ú_plus_clauses]);
(* *** Goal "2" *** *)
a(swap_nth_asm_concl_tac 1);
a(conv_tac(RAND_C eq_sym_conv));
a(PC_T1 "z_predicates" once_rewrite_tac[z_ú_eq_thm]);
a(PC_T1 "z_predicates" rewrite_tac
	[z_µ_elimñ~¬f (îú 0)®® z_plus_order_thm,
		z_plus_clauses, z_plus_assoc_thm, z_minus_thm]);
a(REPEAT strip_tac);
(fn _ => pop_thm()) "z_ú_iso_lemma2"
);
=TEX
=SML
val Ûz_ú_iso_lemma3Ý = (
set_goal([], ¬µf: ú ­ ú·
		f (îú 1) = ñ1®
	±	(µi · f (i + îú 1) = ñ¬f i® + 1®)
	´	µi · îú 0 ¼ i ´ f(~i) = ñ~¬f i®®
®);
a(REPEAT_N 3 strip_tac);
a(ú_î_induction_tac);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_ú_iso_lemma2]);
a(PC_T1 "z_predicates" rewrite_tac[z_minus_clauses]);
(* *** Goal "2" *** *)
a(LEMMA_T ñ¬f (~ (i + îú 1) + îú 1)® = ~ ¬f i®® ante_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[ú_minus_thm, ú_plus_assoc_thm, ú_plus_clauses]);
a(asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(PC_T1 "z_predicates" asm_rewrite_tac[z_minus_thm]);
a(PC_T1 "z_predicates" once_rewrite_tac[z_ú_eq_thm]);
a(PC_T1 "z_predicates" rewrite_tac
	[z_µ_elim¬f i® z_plus_order_thm,
		z_plus_clauses, z_plus_assoc_thm, z_minus_thm]);
(fn _ => pop_thm()) "z_ú_iso_lemma3"
);
=TEX
=SML
val Ûz_ú_iso_lemma4Ý = (
set_goal([], ¬µf: ú ­ ú·
		f (îú 1) = ñ1®
	±	(µi · f (i + îú 1) = ñ¬f i® + 1®)
	´	µi · f(~i) = ñ~¬f i®®
®);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim ¬i® ú_cases_thm));
(* *** Goal "1" *** *)
a(lemma_tac ¬îú 0 ¼ îú m®  THEN1 rewrite_tac[îú_¼_thm]);
a(all_fc_tac[z_ú_iso_lemma3]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¬îú 0 ¼ îú m®  THEN1 rewrite_tac[îú_¼_thm]);
a(all_fc_tac[z_ú_iso_lemma3]);
a(asm_rewrite_tac[]);
a(PC_T1 "z_predicates" asm_rewrite_tac[z_minus_thm]);
(fn _ => pop_thm()) "z_ú_iso_lemma4"
);
=TEX
=SML
val Ûz_ú_iso_lemma5Ý = (
set_goal([], ¬µf: ú ­ ú·
		f (îú 1) = ñ1®
	±	(µi · f (i + îú 1) = ñ¬f i® + 1®)
	´	µi j· f(i + j) = ñ¬f i® + ¬f j®®
®);
a(REPEAT_N 3 strip_tac);
a(ú_induction_tac¬i®);
(* *** Goal "1" *** *)
a(PC_T1 "z_predicates" once_rewrite_tac[z_plus_comm_thm]);
a(once_rewrite_tac[ú_plus_comm_thm]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ¬~ i + j = ~(i + ~j)® pure_rewrite_thm_tac
		THEN1 rewrite_tac[ú_minus_thm]);
a(ALL_FC_T pure_rewrite_tac[z_ú_iso_lemma4]);
a(asm_rewrite_tac[]);
a(PC_T1 "z_predicates" rewrite_tac[z_minus_thm]);
a(ALL_FC_T pure_rewrite_tac[z_ú_iso_lemma4]);
a(PC_T1 "z_predicates" rewrite_tac[z_minus_thm]);
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ¬(i + j) + j' = j + i + j'® rewrite_thm_tac
		THEN1 rewrite_tac[ú_plus_assoc_thm, µ_elim¬i®ú_plus_order_thm]);
a(asm_rewrite_tac[]);
a(PC_T1 "z_predicates"
	rewrite_tac[z_plus_assoc_thm, z_µ_elim¬f i®z_plus_order_thm]);
(fn _ => pop_thm()) "z_ú_iso_lemma5"
);
=TEX
=SML
val Ûz_ú_iso_lemma6Ý = (
set_goal([], ¬µf: ú ­ ú·
		f (îú 1) = ñ1®
	±	(µi · f (i + îú 1) = ñ¬f i® + 1®)
	´	(µm· f (îú m)  = îú m)
®);
a(REPEAT strip_tac);
a(induction_tac¬m®);
(* *** Goal "1" *** *)
a(ALL_FC_T rewrite_tac[z_ú_iso_lemma2]);
a(rewrite_tac[get_spec¬Z'Int®]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac
	[get_spec¬Z'Int®, îú_plus_homomorphism_thm, z_plus1_hol_plus1_thm]);
(fn _ => pop_thm()) "z_ú_iso_lemma6"
);
=TEX
=SML
val Ûz_ú_iso_lemma7Ý = (
set_goal([], ¬µf: ú ­ ú·
		f (îú 1) = ñ1®
	±	(µi · f (i + îú 1) = ñ¬f i® + 1®)
	´	(f i  = îú 0 ´ i = îú 0)
®);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim ¬i® ú_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN ALL_FC_T rewrite_tac[z_ú_iso_lemma6]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN ALL_FC_T rewrite_tac[z_ú_iso_lemma6, z_ú_iso_lemma4]);
a(conv_tac (
	LEFT_C(eq_sym_conv THEN_C
			PC_C1 "z_predicates" once_rewrite_conv[z_ú_eq_thm])
		THEN_C
	RIGHT_C(eq_sym_conv THEN_C (once_rewrite_conv[ú_eq_thm]))));
a(rewrite_tac[]);
a(PC_T1"z_predicates" rewrite_tac[z_minus_thm, get_spec¬Z'Int®,
	rewrite_rule[get_spec¬Z'Int®] z_plus_clauses]);
(fn _ => pop_thm()) "z_ú_iso_lemma7"
);
=TEX
=SML
val Ûz_ú_iso_lemma8Ý = (
set_goal([], ¬µf: ú ­ ú·
		f (îú 1) = ñ1®
	±	(µi · f (i + îú 1) = ñ¬f i® + 1®)
	´	OneOne f
	±	Onto f
®);
a(rewrite_tac[one_one_def, onto_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[z_ú_iso_lemma5, z_ú_iso_lemma4]);
a(lemma_tac¬f(x1 + ~ x2) = îú 0® THEN1
	(asm_rewrite_tac[] THEN
		PC_T1"z_predicates" rewrite_tac[z_minus_thm, get_spec¬Z'Int®]));
a(all_fc_tac[z_ú_iso_lemma7]);
a(once_rewrite_tac[ú_eq_thm] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_fc_tac[z_ú_iso_lemma6]);
a(strip_asm_tac (µ_elim ¬y® z_îú_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "2.1" *** *)
a(¶_tac¬îú m® THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(¶_tac¬~(îú m)®);
a(ALL_FC_T asm_rewrite_tac[z_ú_iso_lemma4]);
(fn _ => pop_thm()) "z_ú_iso_lemma8"
);
=TEX
=SML
val Ûz_ú_iso_lemma9Ý = (
set_goal([], ¬µf·
		OneOne f
	±	Onto f
	´	¶g· (µx· g(f x) = x) ± (µy· f(g y) = y)
®);
a(rewrite_tac[one_one_def, onto_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(¶_tac¬Ì y· Å x · f x = y® THEN rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(Å_tac ¬Å x'· f x' = f x® );
(* *** Goal "1.1" *** *)
a(prove_tac[]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(Å_tac ¬Å x· f x = y® );
a(conv_tac (BINDER_C eq_sym_conv) THEN asm_rewrite_tac[]);
(fn _ => pop_thm()) "z_ú_iso_lemma9"
);
=TEX
=SML
val Ûz_ú_iso_lemma10Ý = (
set_goal([], ¬¶f g: ú ­ ú·
	f (îú 1) = ñ1®
±	g ñ1® = îú 1
±	(µ i j· f (i + j) = ñ¬f i® + ¬f j®®)
±	(µ i· f (~ i) = ñ~¬f i®®)
±	(µ i j· g ñi + j® = g i + g j)
±	(µ i· g ñ~ i® = ~(g i))
±	(µx· g(f x) = x) ± (µy· f(g y) = y)
®);
a(strip_asm_tac z_ú_iso_lemma1);
a(all_fc_tac[z_ú_iso_lemma4, z_ú_iso_lemma5, z_ú_iso_lemma8]);
a(¶_tac¬f® THEN asm_rewrite_tac[]);
a(all_fc_tac[z_ú_iso_lemma9]);
a(¶_tac¬g® THEN asm_rewrite_tac[]);
a(LEMMA_T¬g(f (îú 1)) = g ñ1®®
	ante_tac THEN1 GET_NTH_ASM_T 8 rewrite_thm_tac);
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(LEMMA_T¬µ i j· g(f (g (i) + g (j))) = gñ¬f (g (i))® + ¬f (g (j))®®®
	ante_tac THEN1 (GET_NTH_ASM_T 5 rewrite_thm_tac
			THEN LIST_GET_NTH_ASM_T [1, 2] rewrite_tac));
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(LEMMA_T¬µ i· g(f (~ i)) = gñ~ ¬f i®®®
	ante_tac THEN1 (GET_NTH_ASM_T 6 rewrite_thm_tac
			THEN LIST_GET_NTH_ASM_T [1, 2] rewrite_tac));
a(asm_rewrite_tac[] THEN STRIP_T asm_rewrite_thm_tac);
(fn _ => pop_thm()) "z_ú_iso_lemma10"
);
=TEX
=SML
val Ûz_ú_consistent_thmÝ = (
push_consistency_goal ¬z_ú®;
a(strip_asm_tac z_ú_iso_lemma10);
a(¶_tac ¬(g, f)®);
a(asm_rewrite_tac[]);
save_consistency_thm ¬z_ú® (pop_thm())
);
=TEX
\section{HOMOMORPHISM THEOREMS}
=SML
val Ûz_ú_defÝ = get_spec¬z_ú®;
val Ûú_z_defÝ = z_ú_def;
=TEX
=SML
val Ûz_ú_plus_thmÝ = (
set_goal([], ¬µi j:ú·z_úñi + j® = ¬z_ú i + z_ú  j®®);
a(rewrite_tac[ú_z_def]);
save_pop_thm "z_ú_plus_thm"
);
=TEX
=SML
val z_ú_times_thm = (
set_goal([], ¬µi j:ú·z_úñi * j® = ¬z_ú i * z_ú  j®®);
a(strip_tac THEN z_ú_induction_tac¬i:ú®);
(* *** Goal "1" *** *)
a(rewrite_tac[z_ú_def]);
a(PC_T1 "z_predicates" rewrite_tac[z_times_clauses]);
(* *** Goal "2" *** *)
a(rewrite_tac[z_ú_def] THEN strip_tac);
a(LEMMA_T ¬~ ñ¬z_ú i®® * ñ¬z_ú j®® = ~ (ñ¬z_ú i®® * ñ¬z_ú j®®)®
	rewrite_thm_tac THEN1 rewrite_tac[ú_times_minus_thm]);
a(LEMMA_T ñ~ i * j = ~(i*j)® rewrite_thm_tac
	THEN1 PC_T1 "z_predicates" rewrite_tac[z_minus_times_thm]);
a(asm_rewrite_tac[z_ú_def]);
(* *** Goal "3" *** *)
a(PC_T1 "z_predicates" asm_rewrite_tac
	[z_ú_def, ú_times_plus_distrib_thm, z_times_plus_distrib_thm]);
save_pop_thm "z_ú_times_thm"
);
=TEX
=SML
val Ûz_ú_subtract_thmÝ = (
set_goal([], ¬µi j:ú·z_úñi - j® = ¬z_ú i - z_ú  j®®);
a(rewrite_tac[] THEN MERGE_PCS_T1 ["'z_numbers", "z_predicates"] rewrite_tac[]);
a(rewrite_tac[ú_z_def]);
save_pop_thm "z_ú_subtract_thm"
);
=TEX
=SML
val Ûz_ú_minus_thmÝ = (
set_goal([], ¬µi:ú·z_úñ~i® = ¬~(z_ú i)®®);
a(rewrite_tac[ú_z_def]);
save_pop_thm "z_ú_minus_thm"
);
=TEX
=SML
val Ûú_z_îú_thmÝ = (
set_goal([], ¬µm· ú_z(îú m) = îú m®);
a(strip_asm_tac z_ú_def);
a(lemma_tac ¬µ i· ú_z (i + îú 1) = ñ¬ú_z i® + 1®®
	THEN1 asm_rewrite_tac[get_spec¬Z'Int®]);
a(ALL_FC_T rewrite_tac [z_ú_iso_lemma6]);
(fn _ => pop_thm()) "ú_z_îú_thm"
);
=TEX
=SML
val Ûz_ú_îú_thmÝ = (
set_goal([], ¬µm· z_ú(îú m) = îú m®);
a(strip_tac);
a(LEMMA_T ¬z_ú(îú m) = z_ú(ú_z(îú m))® ante_tac THEN1 rewrite_tac[ú_z_îú_thm]);
a(rewrite_tac[z_ú_def]);
(fn _ => pop_thm()) "z_ú_îú_thm"
);
=TEX
=SML
val Ûz_ú_z_int_thmÝ = (
set_goal([], ¬µm· z_ú(Z'Int m) = îú m®);
a(rewrite_tac [get_spec¬Z'Int®, z_ú_îú_thm]);
(fn _ => pop_thm()) "z_ú_z_int_thm"
);
=TEX
=SML
val Ûz_ú_ú_z_thmÝ = (
set_goal([], ¬µi:ú·z_ú(ú_z i) = i®);
a(rewrite_tac[z_ú_def]);
(fn _ => pop_thm()) "z_ú_ú_z_thm"
);
=TEX
=SML
val Ûú_z_z_ú_thmÝ = (
set_goal([], ¬µi:ú·ú_z(z_ú i) = i®);
a(rewrite_tac[z_ú_def]);
(fn _ => pop_thm()) "ú_z_z_ú_thm"
);
=TEX
=SML
val Ûz_ú_eq_eq_ú_z_thmÝ = (
set_goal([], ¬µi j:ú·z_ú i  = j ¤ i = ú_z j®);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN rewrite_tac[z_ú_def]);
(fn _ => pop_thm()) "z_ú_eq_eq_ú_z_thm"
);
=TEX
=SML
val Ûú_z_eq_eq_z_ú_thmÝ = (
set_goal([], ¬µi j:ú·ú_z i  = j ¤ i = z_ú j®);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN rewrite_tac[z_ú_def]);
(fn _ => pop_thm()) "ú_z_eq_eq_z_ú_thm"
);
=TEX
=SML
val Ûú_z_plus_thmÝ = (
set_goal([], ¬µi j:ú·ú_z(i + j) = ñ¬ú_z i® + ¬ú_z j®®®);
a(rewrite_tac[z_ú_plus_thm, z_ú_def]);
save_pop_thm "ú_z_plus_thm"
);
=TEX
=SML
val Ûú_z_times_thmÝ = (
set_goal([], ¬µi j:ú·ú_z(i * j) = ñ¬ú_z i® * ¬ú_z j®®®);
a(rewrite_tac[ú_z_eq_eq_z_ú_thm, z_ú_times_thm, z_ú_def]);
save_pop_thm "ú_z_times_thm"
);
=TEX
=SML
val Ûú_z_subtract_thmÝ = (
set_goal([], ¬µi j:ú·ú_z(i - j) = ñ¬ú_z i® - ¬ú_z j®®®);
a(rewrite_tac[ú_z_eq_eq_z_ú_thm, z_ú_subtract_thm, z_ú_def]);
save_pop_thm "ú_z_subtract_thm"
);
=TEX
=SML
val Ûú_z_minus_thmÝ = (
set_goal([], ¬µ i· ú_z(~ i) = ñ~¬ú_z i®®®);
a(rewrite_tac[z_ú_minus_thm, z_ú_def]);
save_pop_thm "ú_z_minus_thm"
);
=TEX
=SML
val Ûú_z_îú_z_int_thmÝ = (
set_goal([], ¬µm· ú_z(îú m) = (Z'Int m)®);
a(rewrite_tac [get_spec¬Z'Int®, ú_z_îú_thm]);
(fn _ => pop_thm()) "ú_z_îú_z_int_thm"
);
=TEX
\section{HOMOMORHPISM CONVERSIONS}
=SML
val rec Ûz_ú_convÝ : CONV =  (fn tm =>
	let	val (_, t) = dest_app tm;
		fun aux1 dest thm = (
			dest t;
			(simple_eq_match_conv thm THEN_TRY_C RAND_C z_ú_conv) tm
		);
		fun aux2 dest thm = (
			dest t;
			(simple_eq_match_conv thm THEN_TRY_C
			(LEFT_C z_ú_conv AND_OR_C RIGHT_C z_ú_conv)) tm
		);
	in	aux1 dest_z_minus z_ú_minus_thm handle Fail _ =>
		aux1 dest_z_signed_int z_ú_z_int_thm handle Fail _ =>
		aux2 dest_z_plus z_ú_plus_thm handle Fail _ =>
		aux2 dest_z_times z_ú_times_thm handle Fail _ =>
		aux2 dest_z_subtract z_ú_subtract_thm handle Fail _ =>
		simple_eq_match_conv z_ú_ú_z_thm tm
	end	handle Fail _ => term_fail "z_ú_conv" 106001 [tm]
);
=TEX
=SML
val rec Ûú_z_convÝ : CONV =  (fn tm =>
	let	val (_, t) = dest_app tm;
		fun aux1 dest thm = (
			dest t;
			(simple_eq_match_conv thm THEN_TRY_C Z_RAND_C ú_z_conv) tm
		);
		fun aux2 dest thm = (
			dest t;
			(simple_eq_match_conv thm THEN_TRY_C
			(Z_LEFT_C ú_z_conv AND_OR_C Z_RIGHT_C ú_z_conv)) tm
		);
	in	aux1 dest_ú_minus ú_z_minus_thm handle Fail _ =>
		aux1 dest_ú_signed_int ú_z_îú_z_int_thm handle Fail _ =>
		aux2 dest_ú_plus ú_z_plus_thm handle Fail _ =>
		aux2 dest_ú_times ú_z_times_thm handle Fail _ =>
		aux2 dest_ú_subtract ú_z_subtract_thm handle Fail _ =>
		simple_eq_match_conv ú_z_z_ú_thm tm
	end	handle Fail _ => term_fail "ú_z_conv" 106002 [tm]
);
=IGN
ú_z_conv¬ú_z¬(a + b:ú)®®;
ú_z_conv¬ú_z¬(a - b:ú)®®;
ú_z_conv¬ú_z¬(a * îú 1)®®;
ú_z_conv¬ú_z¬~(a + b:ú)®®;
ú_z_conv¬ú_z¬~(a + îú 2)*(b - d)+(a + îú  1)®®;
ú_z_conv¬ú_z¬~(a + îú 2)*(z_ú b - d)+(a + îú  1)®®;
ú_z_conv¬ú_z¬xºú®®;
=TEX
\section{NORMALISATION}
=SML
val Ûz_ú_one_one_thmÝ = (
set_goal([], ¬µi j· z_ú i = z_ú j ¤ i = j®);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T ¬ú_z(z_ú i) = ú_z(z_ú j)® ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[z_ú_def]);
save_pop_thm "z_ú_one_one_thm"
);
=TEX
=SML
val Ûú_z_one_one_thmÝ = (
set_goal([], ¬µi j· ú_z i = ú_z j ¤ i = j®);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(LEMMA_T ¬z_ú(ú_z i) = z_ú(ú_z j)® ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[z_ú_def]);
save_pop_thm "ú_z_one_one_thm"
);
=SML
val Ûz_úÝ = ¬z_ú®;
val Ûz_anf_conv1Ý = (fn tm =>
	(conv_rule
	(simple_eq_match_conv z_ú_eq_eq_ú_z_thm)
	((z_ú_conv THEN_C ú_anf_conv) (mk_app(z_ú, tm))))
	handle Fail _ => term_fail "z_anf_conv1" 106010  [tm]
);
val Ûz_anf_convÝ:CONV = (fn tm =>
	(z_anf_conv1 THEN_C ú_z_conv) tm handle ex => reraise ex "z_anf_conv"
);
=IGN
z_anf_conv1ñ1 + 2 + 3®;
z_anf_conv1ñ(1 + x)*(1 + x)®;
z_anf_conv1ñ(1 + x)*(1 - x)®;
z_anf_convñ1 + 2 + 3®;
z_anf_convñ(1 + x)*(1 + x)®;
z_anf_convñ(1 + x)*(1 - x)®;
=TEX
=SML
val Ûz_¼_ú_¼_thmÝ = (
set_goal([], ¬µi j:ú·ñi ¼ j® ¤ z_ú i ¼ z_ú j®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_¼_induction_tacñj® THEN rewrite_tac[z_ú_def, ú_¼_clauses]);
a(LEMMA_T ¬ñ¬z_ú i'®® ¼ ñ¬z_ú i'®® + îú 1® asm_tac THEN1 rewrite_tac[]);
a(all_fc_tac[ú_¼_trans_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[get_spec¬$¼‰Z®] THEN strip_tac);
a(LEMMA_T ¬ú_z(z_ú i + îú m) = ú_z(z_ú j)®
		ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[z_ú_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(PC_T1 "z_predicates" rewrite_tac [z_¼_clauses]);
a(POP_ASM_T discard_tac THEN induction_tac ¬m®);
(* *** Goal "2.1" *** *)
a(rewrite_tac[ú_z_îú_thm] THEN rewrite_tac[eq_sym_rule(get_spec¬Z'Int®)]);
a(PC_T1 "z_predicates" rewrite_tac [z_¼_clauses]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[îú_plus_homomorphism_thm, z_ú_def]);
a(LEMMA_T ñ¬ú_z (îú m)® ¼ ¬ú_z (îú m)® + 1® asm_tac THEN1
	PC_T1 "z_predicates" rewrite_tac [z_¼_clauses]);
a(PC_T1 "z_predicates" all_fc_tac[z_¼_trans_thm]);
save_pop_thm "z_¼_ú_¼_thm"
);
=TEX
=SML
val Ûz_less_ú_less_thmÝ = (
set_goal([], ¬µi j:ú·ñi < j® ¤ z_ú i < z_ú j®);
a(once_rewrite_tac[taut_rule¬µp q·(p ¤ q) ¤ (³p ¤ ³q)®]);
a(PC_T1 "z_predicates" rewrite_tac
	[z_³_less_thm, ú_³_less_thm, z_¼_ú_¼_thm]);
save_pop_thm "z_less_ú_less_thm"
);
=TEX
=SML
val Ûz_eq_¼_¼_thmÝ = (
set_goal([], ¬µi j:ú· i = j ¤ ñi ¼ j ± j ¼ i®®);
a(REPEAT strip_tac THEN_TRY
	MERGE_PCS_T1 ["'z_numbers", "z_predicates"] asm_rewrite_tac[]);
a(PC_T1 "z_predicates" all_fc_tac[z_¼_antisym_thm]);
(fn _ => pop_thm()) "z_eq_¼_¼_thm"
);
=TEX
=SML
val Ûz_eq_ú_convÝ = simple_eq_match_conv z_eq_¼_¼_thm;
=IGN
z_eq_ú_conv ñxºú = y®;
z_eq_ú_conv ñx = 1®;
z_eq_ú_conv ñx + y = 1®;
z_eq_ú_conv ñx + y = z®;
z_eq_ú_conv ñy = x + z®;

z_eq_ú_conv ñx = 1®;
z_eq_ú_conv ñx - 1 = y +1®;
=TEX
=SML
val Ûz_¼_ú_convÝ : CONV = (fn tm =>
	let	val (t1, t2) = dest_z_¼ tm;
	in	 simple_eq_match_conv z_¼_ú_¼_thm THEN_C RANDS_C (TRY_C z_ú_conv)
	end	tm
);
=IGN
z_¼_ú_conv ñx + y ¼ 1®;
z_¼_ú_conv ñx ¼ 1®;
z_¼_ú_conv ñx ¼ y®;
z_¼_ú_conv ñx + 1 ¼ y + 1®;
z_¼_ú_conv ñx - 1 ¼ y + 1®;
=TEX
=SML
val Ûz_less_ú_convÝ : CONV = (fn tm =>
	let	val (t1, t2) = dest_z_less tm;
	in	simple_eq_match_conv z_less_ú_less_thm THEN_C RANDS_C (TRY_C z_ú_conv)
	end	tm
);
=TEX
\section{THE PROOF CONTEXT}
=IGN
z_less_ú_conv ñx + y < 1®;
z_less_ú_conv ñx < 1®;
z_less_ú_conv ñx < y®;
z_less_ú_conv ñx + 1 < y + 1®;
z_less_ú_conv ñx - 1 < y + 1®;
=SML
val Ûstrip_cxtÝ = [
	(ñ(xºú) = y®, z_eq_ú_conv),
	(ñ(xºú) ¼ y®, z_¼_ú_conv),
	(ñ(xºú) < y®, z_less_ú_conv),
	(ñx  î®, z__î_conv),

	(ñ³(xºú) = y®, RAND_C z_eq_ú_conv),
	(ñ³(xºú) ¼ y®, RAND_C z_¼_ú_conv),
	(ñ³(xºú) < y®, RAND_C z_less_ú_conv),
	(ñ³x  î®, RAND_C z__î_conv)
];
=TEX
=SML
val Ûz_lin_arith_prove_tacÝ : THM list -> TACTIC = (fn thl => fn gl =>
	((	MAP_EVERY ante_tac thl
	THEN	all_asm_ante_tac
	THEN	contr_tac
	THEN	all_asm_ante_tac
	THEN	PC_T "ú_lin_arith" contr_tac THEN ú_lin_arith_tac) gl)
	handle	Fail msg => fail "z_lin_arith_prove_tac" 82200
			[(fn () =>get_message msg),
			 (fn () => string_of_term (snd gl))]
);
=TEX
and the associated conversion:
=SML
val Ûz_lin_arith_prove_convÝ : THM list -> CONV = (fn thl => fn tm =>
	let	val th = tac_proof(([], tm), z_lin_arith_prove_tac thl);
	in	¤_t_intro  th
	end	handle ex => reraise ex "z_lin_arith_prove_conv"
);
=TEX
=SML
val _ = delete_pc "'z_lin_arith" handle Fail _ => ();
val _ = new_pc Û"'z_lin_arith"Ý;
val _ = set_rw_eqn_cxt strip_cxt "'z_lin_arith";
val _ = set_st_eqn_cxt strip_cxt "'z_lin_arith";
val _ = set_sc_eqn_cxt strip_cxt "'z_lin_arith";
val _ = merge_pcs ["'z_numbers"] "'z_lin_arith";
val _ = set_pr_tac z_lin_arith_prove_tac "'z_lin_arith";
val _ = set_pr_conv z_lin_arith_prove_conv "'z_lin_arith";
val _ = commit_pc "'z_lin_arith";
=TEX
=SML
val _ = delete_pc "z_lin_arith" handle Fail _ => ();
val _ = new_pc Û"z_lin_arith"Ý;
val _ = merge_pcs ["z_predicates", "'z_lin_arith"] "z_lin_arith";
val _ = commit_pc "z_lin_arith";
=TEX
=SML
val _ = delete_pc "'z_lin_arith1" handle Fail _ => ();
val _ = new_pc Û"'z_lin_arith1"Ý;
val _ = set_rw_eqn_cxt strip_cxt "'z_lin_arith1";
val _ = set_st_eqn_cxt strip_cxt "'z_lin_arith1";
val _ = set_sc_eqn_cxt strip_cxt "'z_lin_arith1";
val _ = merge_pcs ["'z_numbers1"] "'z_lin_arith1";
val _ = set_pr_tac z_lin_arith_prove_tac "'z_lin_arith1";
val _ = set_pr_conv z_lin_arith_prove_conv "'z_lin_arith1";
val _ = commit_pc "'z_lin_arith1";
=TEX
=SML
val _ = delete_pc "z_lin_arith1" handle Fail _ => ();
val _ = new_pc Û"z_lin_arith1"Ý;
val _ = merge_pcs ["z_predicates", "'z_lin_arith1"] "z_lin_arith1";
val _ = commit_pc "z_lin_arith1";
=TEX
\section{EPILOGUE}
=TEX
=SML
end (* of structure ZArithmeticTools *);
open ZArithmeticTools;
=TEX
=IGN
PC_C1 "'z_lin_arith" rewrite_conv[]ñ1 + 2 = 2 + 1®;
pc_rule1 "z_lin_arith" prove_rule[]ñx < y ± y < z ´ x < z®;
pc_rule1 "z_lin_arith" prove_rule[]ñ³(1 ¼ x ± x + y = z ± y = z)®;
pc_rule1 "z_lin_arith" prove_rule[]ñx + y ¼ y ´ x ¼ 0®;
pc_rule1 "z_lin_arith" prove_rule[]ñ³(¶x, y:ú·x > 0 ± x + a + b + y < b + y + a)®;

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
open_theory"z_library";
new_theory"temp";
new_parent"z_arithmetic_tools";
val eg_thm1 = (
set_goal([], ñµb:î·(b + 1)*(b + 1) > 0®);
a(PC_T1 "z_library" REPEAT strip_tac);
a( z_¼_induction_tacñb® THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
pop_thm()
);
val eg_thm2 = (
set_goal([], ñµa, b, c:ú·a ¼ b ± (a + b < c + a) ´ a < c®);
a(PC_T1 "z_lin_arith" prove_tac[]);
pop_thm()
);
val eg_thm2 = (
set_goal([], ñµa, b, c:ú·a ¾ b ± ³ b < c ´ a ¾ c®);
a(PC_T1 "z_lin_arith" prove_tac[]);
pop_thm()
);
val eg_thm2 = (
set_goal([], ñµa, b, c:ú·a + 2*b < 2*a ´ b + b < a®);
a(PC_T1 "z_lin_arith" prove_tac[]);
pop_thm()
);
val eg_thm3 = (
set_goal([], ñµ x, y:ú· ³ (2*x + y = 4 ± 4*x + 2*y = 7)®);
a(PC_T1 "z_lin_arith" prove_tac[]);
pop_thm()
);
val eg_thm4 = (
set_goal([], ñµm:ú· {i:ú | m ¼ i ± i < m+3} = {m, m+1, m+2}®);
a(MERGE_PCS_T1["z_sets_ext", "'z_lin_arith"]prove_tac[]);
pop_thm()
);
val eg_thm5 = (
set_goal([], ñ{i, j : ú | 30*i = 105*j} = {i, j : ú | 2*i = 7*j}®);
a(MERGE_PCS_T1["z_sets_ext", "'z_lin_arith"]prove_tac[]);
pop_thm()
);
val eg_thm6 = (
set_goal([], ñ{i : ú | 5*i = 6*i} = {0}®);
a(MERGE_PCS_T1["z_sets_ext", "'z_lin_arith"]prove_tac[]);
pop_thm()
);
[eg_thm1, eg_thm2, eg_thm3, eg_thm4, eg_thm5, eg_thm6];

