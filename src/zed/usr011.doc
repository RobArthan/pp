% usr011.doc   %Z% $Date$ $Revision$ $RCSfile$
=IGNORE
           % U s e f u l C o m m a n d s

cp  ~ied/rel001/latest/sun3hol.db example.db; chmod +w example.db

% the style file USR.sty is held in usr024.doc and may be extracted as follows:

docsml usr024.doc ; mv usr024.sml USR.sty

% the make file is held in wrk027.doc and is called usr006.mkf

hol -d ~ied/rel001/latest/zed
rm -f *.aux *.dvi *.idx *.log *.sid

make -f usr006.mkf usr011.dvi1 

doctex usr011
texdvi usr011
texdvi usr011
bibtex usr011
texdvi usr011
dvipage usr011
doctex usr011 usr011A usr011X01 usr011X02 usr011X03; texdvi usr011
=TEX
% COPYRIGHT (c) International Computers Limited, 1992

\documentstyle[hol1,11pt,fleqn,USR]{book}

\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$
}}

\USRmanual{Z TUTORIAL}
\USRref{USR011}
\def\USRdate{\SCCSdate}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}

\makeUSRfrontpage

\long\def\suppress#1{}

\long\def\ignore#1{}

% the following inhibits the interpretation of underscore for subscripting.
\underscoreoff
%\catcode`\_=\active
%\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

\ftlmargin=0.4in
\ftrmargin=0.4in

\chapter*{CONTENTS}

\tableofcontents

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document, one of several making up the user documentation for the \Product\ system,  contains a tutorial on the use of \Product\ for formal reasoning about specifications in the Z language.

\section{Readership}

This document is intended to be among the first to be read by new users of {\Product} wishing to use the specification language Z.
The reader is assumed to have some familiarity with the use of {\Product} for HOL.

\section{Related Publications}
A bibliography is given at the end of this document.  Publications relating specifically to {\Product} are:

\begin{enumerate}
\item {\em \ {\TUTORIAL}}, tutorial covering the basic \Product{} system.
\item {\em \ {\DESCRIPTION}};
\item {\em \ {\REFERENCE}};
\item {\em \ {\INSTALLATION}};
\item {\em \ {\TYPESETTING}}.
\end{enumerate}

\section{Area Covered}

This tutorial is an introductory \ProductZ\ course which gives an idea of the way \Product\ is used for checking specifications and conducting proofs in {\ProductZ}.
After working through  this tutorial, the reader should be capable of using {\Product} with {\ProductZ} for simple tasks, and should be able to make effective use of the {\Product} documentation where necessary for approaching more difficult problems.

This tutorial supplements the {\TUTORIAL} with material relating to the Z language.
The tutorial should enable users of \Product\ to become familiar with the following subjects:

\begin{enumerate}
\item
The dialect of Z supported by the \Product\ system (which we call \ProductZ{}) and its manipulation via the metalanguage.
\item
Forward proof and derived rules of inference for Z.
\item
Goal directed proof, and tactics and tacticals for Z.
\end{enumerate}

\section{Prerequisites}

Some prior acquaintance with {\Product} is assumed, such as may be acquired through reading the {\TUTORIAL}.
Prior acquaintance with Z \cite{spivey92} is also assumed.

=IGN
\section{Changes Forecast}

This is a temporary section not intended for inclusion in versions of the tutorial issued to users.

This section contains two subsections.

The first subsection is a renminder to the author of what needs to be done to this document.

The second is a reminder for the product developers of requests which have arisen from the development of the tutorial for modifications to the product.

\subsection{Changes Required to Tutorial}

\subsection{Changes Requested to Product}

\subsubsection{Declarations}

The conversion $z_pred_decl_conv$ should be supplied.

\subsubsection{String literals}

Both proof contexts for the Z language should be capabale of solving equalities or inequalities concerning string literals.
$z_ç_string_conv$ should be in the rewrites?
Not sure what is the best way.
Maybe a specific conversion for string literal (in)equalities.

\subsubsection{Unique Existence}

We don't appear to have a tactic for unique existential conclusions.

\subsubsection{Bindings and Tuples}

The treatment of bindings and tuples should be made more consistent and should be split into basic and extensional.

Under basic support (in proof context ``$z_language$'') elimination of equations over binding and tuple displays only, in favour of equations over the components, should be included.

Under `extensional' support (in proof context ``$z_language_ext$'') elimination of arbitrary equations over tuple or binding types, with elimination of projections from displays, should be included.

Names should be more consistent, between tuples and bindings.
The words ``binding'' and ``tuple'' should not be used to refer specifically to binding displays or tuple displays, since they apply to arbitrary expressions of the appropriate types.
Instead either `$tupled$' or `$tuple_display$' should be used, and analogously for bindings.
If two conversions are available (as is the case for binding equations), one eliminating projections on displays automatically, the other not doing this, the standard name should be reserved for the one doing the projection elimination with a suffix for the other.

All elimination of displays formed from projections from a variable, in favour of the variable should be supported but should not appear either in ``$z_language$'' or in ``$z_language_ext$''.
Its not clear to me that a proof context containing this is needed, the conversions will probably suffice for manual application.

\subsubsection{Schema Calculus}

The main concerns here are:

\begin{itemize}
\item
That the handling of binding displays should be smooth and consistent.
It seems to me that this would be smoother if variables of type binding were not introduced, but instead variables for each component, with the same name as the component were introduced.
This affects the principle of extensionality when applied to sets of bindings (and probably also tuples), and also the definitions of schema operators, where these definitions quantify over bindings.

This will maximise the extent to which resulting binding membership displays can be eliminated in favour of schemas as predicates, and will largely eliminate the currently frequent occurrence of binding displays whose components are formed using projections.
\item
For reasons of efficiency the use of schema operators on the right hand side of definitions of schema operators (and hence in the definitions of the basic conversions for these operators) should be (cautiously) minimised.
\item
Schema composition needs redefining in a sane way.
\item
Reasoning in the propositional part of the schema calculus should look like propositional reasoning (for product image).
Each individual stripping step should therefore restore schemas as predicates where possible.
\end{itemize}

=TEX

\section{Acknowledgements}

ICL gratefully acknowledges its debt to the many researchers (both academic and industrial) who have provided intellectual capital on which ICL has drawn in the development of \Product.

We are particularly endebted to Mike Gordon of The University of Cambridge, for his leading role in some of the research on which the development of \Product\ has built, and for his positive attitude towards industrial exploitation of his work.

The \Product\ system is a proof tool for Higher Order Logic which builds upon ideas arising from research carried out at the Universities of Cambridge and Edinburgh, and elsewhere. 
In particular the logic supported by the system is (at an abstract level) identical to that implemented in the Cambridge HOL system \cite{gordon93}, and the paradigm adopted for implementation of proof support for the language follows that adopted by Cambridge HOL, originating with the LCF system developed at Edinburgh \cite{gordon79}.
The functional language `Standard ML' used both for the implementation and as an interactive metalanguage for proof development, originates in work at Edinburgh, and has been developed to its present state by an international group of academic and industrial researchers.
The implementation of Standard ML on which \Product\ is based was itself originally implemented by David Matthews at the University of Cambridge, and is now commercially marketed by Abstract Hardware Limited.

The \Product{} system also supports specification and proof in the Z language, developed at the University of Oxford.
We are therefore also endebted to the research at Oxford (and elsewhere) which has contributed to the development of the Z language.

\pagebreak
\chapter{INTRODUCTION TO ProofPower-Z}

\section{Objectives}

The objectives of this tutorial are:

\begin{itemize}
\item
to describe the basic principles and concepts underlying support for Z in {\Product}
\item
to enable the student to write simple specifications and undertake elementary proofs in Z using {\Product}
\item
to enable the student to make effective use of the reference documentation 
\end{itemize}

\section{Tutorial Overview}

The tutorial consists of a number of chapters covering the following topics:

\begin{enumerate}
\item
Introduction to \ProductZ{}.

\item
The Z Predicate Calculus.

\item
Z Expressions and Schema Expressions

\item
Z Paragraphs

\item
The Z ToolKit

\end{enumerate}

\section{Prerequisites}

The tutorial is not intended as an introduction to formal methods or to the language Z.

We assume a working knowledge of:

\begin{itemize}
\item
Z as a specification language

Which may be obtained by reading any of a large number of texts now available on Z, or by attending a course.

\item
Use of \Product{} as used for specification and proof in HOL.

This can be obtained by reading the \TUTORIAL{}.

\end{itemize}

\section{Using ProofPower for Z}

\subsection{Setting Up}

A \Product{} system issued with the \Product-Z{} option will be provided with more than one database, not all of which will contain the Z support facilities.
The installation guide \cite{DS/FMU/IED/USR007} should be consulted to discover what databases have been supplied and their names, but usually a database called `zed' (full name `sun3zed.db' or `sun4zed.db') will be available supporting the \Product-Z{} option.

If the user intends to save the results of his work in a \Product{} database then he should make a database for himself using \verb!pp_make_database! with a suitable parent (for which, see installation guide \cite{DS/FMU/IED/USR007}).

e.g.

\begin{verbatim}
	pp_make_database -p dir/pp_zed demo
\end{verbatim}

The \Product{} system can be entered for work with Z by citing this database as follows:

\begin{verbatim}
	pp -d demo
\end{verbatim}

Apart from selecting or setting up a database including the Z support facilities, entering and leaving \Product{} for work in Z is the same as for work in HOL.

\subsection{Formal Material in this Document}

In this document the behaviour of {\Product} is frequently illustrated by showing how the system responds to various inputs.
In these illustrations a line input to {\Product} is shown by a vertical line on the left, with `SML' at the head of the line, thus: 
 
\vspace*{0.25in}

=SML

=TEX

`SML' is an acronym for {\it standard ML}, the `meta-language' in which the user of {\Product} communicates with the system.

The output from {\Product} usually displayed on the console in response to such an input will be marked by a vertical line on the left, thus:

\vspace*{0.25in}

=GFT ProofPower output

=TEX

Sometimes we omit parts of the output, and supply `...' to mark the point of such an omission.

\subsection{Setting the Context}

A \Product{} database supporting Z will also support HOL.
Though the system does support mixed language working, i.e. working at the same time with both of these languages, it is usual to work normally with a single language.
To do this smoothly the context needs to be set up correctly for that language.

The main aspect of context which is relevant is the current {\it theory}.
Associated with each theory is a language code, and the language code of the current theory influences the behaviour of the system.

The best place in the theory hierarchy to do work in Z is in a descendant of the theories which provide the Z ToolKit.
The theory $z_library$ should therefore be a parent of any theories which the user creates for work in Z.

=SML
open_theory "z_library";
new_theory "usr011";
=TEX

Theories inherit by default the language of their parent, so any theory created while $z_library$ is the current theory will have Z as its language.

A second important aspect of context is the $proof\ context$.
Many of the facilities provided by \Product{} work with either HOL or Z by access to information in the current proof context which may be set by a call to $set_pc$.
A proof context should therefore be chosen which supports Z.
Suitable candidates are $z_language$, which incorporates a knowledge of the Z language but not of the Z ToolKit and $z_library$, which includes knowledge of both.

=SML
set_pc "z_library";
=TEX

A further element of context of which the user should be aware is the current subgoal, when the subgoal package has been invoked.
The subgoal package keeps a record, known as the current `typing context', of the types of the variables which occur freely in the current subgoal.
This context is referred to when type-checking terms entered through the HOL or Z parsers.
If a subgoal relating to an incomplete proof is left on the goal stack, then this may cause terms entered into the system to fail to type-check if they may use of variables with types which disagree with the usage of the same variables in the subgoal.

To clear the goal stack the command:
=SML
repeat drop_main_goal; 
=TEX
may be used.

The command $print_status$ will display information about the current context, e.g.:
=SML
print_status();
=GFT ProofPower output
Current theory name: z_library;
Current proof context name(s): [z_library];
The subgoal package is not in use;
There is no current goal.
val it = () : unit   
=TEX

\chapter{THE Z LANGUAGE IN ProofPower}\label{ZLanguage}
\input{usr011A.tex}

\chapter{THE Z PREDICATE CALCULUS}\label{ZPredicateCalculus}
\input{usr011B.tex}

\chapter{Z EXPRESSIONS}\label{ZExpressions}
\input{usr011C.tex}

\chapter{Z PARAGRAPHS}\label{ZParagraphs}
\input{usr011D.tex}

\chapter{THE Z TOOLKIT IN ProofPower}\label{ToolKit}
\input{usr011T.tex}

\chapter{EXERCISES}\label{Exercises}
\input{usr011X.tex}

\chapter{SOLUTIONS TO EXERCISES}\label{Solutions}
\input{usr011S.tex}

\chapter*{REFERENCES}
\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
\bibliography{fmu} 

\twocolumn[\chapter*{INDEX}]
\addcontentsline{toc}{chapter}{INDEX}
\small
\printindex
\end{document}
