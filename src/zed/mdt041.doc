=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Z Predicate Calculus}
\TPPref{DS/FMU/IED/MDT041}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
rules and tactics for the Z predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 - 1.3]
First versions.
\item [Issue 1.5 (20th August 1992)]
Bug fixing.
\item [Issue 1.6 (9th September 1992)]
Added $z\_¶\_intro\_conv1$ tests.
\item [Issue 1.7 (10th September 1992)]
Typo fixed, title corrected.
\item [Issue 1.8 (10th September 1992)]
Changes after comments.
\item [Issue 1.11,1.12 (29th October 1992)]
changes due to parser changes and theory reorganisation.
\end{description}
\subsection{Changes Forecast}
None known.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD041}.
\subsection{Introduction}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD041}.
This consists of demonstrating at least the simpler uses of the 
functions in question.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP041} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
The testing could be more rigorous.
\section{TEST CASES}
The functions are tested in their order of presentation in the detailed design.
\section{PREAMBLE}
=SML
val use_thy = "z_sets";
open_theory use_thy; (* to access º *)
use_file "dtd013";
use_file "imp013";
init_mt_results();
(* set_flag("subgoal_package_quiet",true); *)
repeat drop_main_goal;
set_flag("check_is_z",true);
=TEX
We use the proof context
``z$\_$predicates''.
=SML
push_merge_pcs ["z_predicates","'z_decl"];
=TEX

=SML
fun Ûlist_eqİ (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
If two terms types are equal, break them apart until they differ.
=SML
fun Ûdiffer_whereİ itm1 itm2 = (
let	fun aux tm1 tm2 (App(f1,x1)) (App(f2,x2)) = (
		Value(force_value(aux f1 f2 (dest_simple_term f1) (dest_simple_term f2)))
		handle _ =>
		aux x1 x2 (dest_simple_term x1) (dest_simple_term x2))
	| aux tm1 tm2 (Const(nm1,ty1)) (Const(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (Var(nm1,ty1)) (Var(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (SimpleÌ(x1,b1)) (SimpleÌ(x2,b2)) = (
		if x1 =$ x2 
		then aux b1 b2 (dest_simple_term b1) (dest_simple_term b2)
		else Value(tm1,tm2))
	| aux tm1 tm2 _ _ = Value(tm1,tm2);
in
	aux itm1 itm2 (dest_simple_term itm1) (dest_simple_term itm2)
end);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun Ûtac_resİ tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_resİ tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_res1İ tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (rasms,gl) = top_goal()
		in
			(drop_main_goal();
			(rasms,gl))
		end);
=TEX
Now a function that returns the multiple goals for the case when a tactic causes multiple goals:
=SML
fun Ûtac_ressİ tac n (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val gll = map (top_labelled_goal o string_of_int)
			(interval 1 n)
		in
			(drop_main_goal();
			gll)
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun Ûtac_solveİ tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun Ûtac_failİ tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
The following tests $is\_z$, $not\_z\_subterms$,
$full\-\_dest\-\_z\-\_term$, $check\-\_is\-\_z\-\_thm$, $check\-\_is\-\_z\-\_goal$,
$check\-\_is\-\_z\-\_term$ together, on a pair of very similar
terms, except that one is Z and one not quite Z,
in a manner $dest\-\_z\-\_term$ doesn't notice.

The following utilities just give rise to lots of information
messages.
=SML
fun Ûtest_check_is_z_thmİ tm = (
let	val thm1 = refl_conv tm;
in
	(thm1 =|- check_is_z_thm "test" thm1)
end
handle _ => false);
fun Ûtest_check_is_z_goalİ tm = (
let	val gl1 = ([],mk_eq(tm, tm));
in
	(gl1 =# check_is_z_goal "test" gl1)
end
handle _ => false);
fun Ûtest_check_is_z_termİ tm = (
	(tm =$ check_is_z_term "test" tm)
handle _ => false);

fun Ûreally_zİ name tm1 tm2 =
store_mt_results mt_run [(name ^ " is_z y",
	(fn x => ((is_z x) handle _ => false)),
	tm1,
	true),
	(name ^ " is_z n",
	(fn x => ((is_z x) handle _ => false)),
	tm2,
	false),
	(name ^ " not_z_subterms []",
	(fn x => length x = 0) o not_z_subterms,
	tm1,
	true),
	(name ^ " not_z_subterms [1]",
	(fn x => length x = 1) o not_z_subterms,
	tm2,
	true),
	(name ^ " dest_z_term y",
	(fn x => ((dest_z_term x; true) handle _ => false)),
	tm1,
	true),
	(name ^ " dest_z_term n",
	(fn x => ((dest_z_term x; true) handle _ => false)),
	tm2,
	true),
	(name ^ " full_dest_z_term y",
	(fn x => ((full_dest_z_term x; true) handle _ => false)),
	tm1,
	true),
	(name ^ " full_dest_z_term n",
	(fn x => ((full_dest_z_term x; true) handle _ => false)),
	tm2,
	false),
	(name ^ " test_check_is_z_thm y",
	test_check_is_z_thm,
	tm1,
	true),
	(name ^ " test_check_is_z_thm n",
	test_check_is_z_thm,
	tm2,
	true),
	(name ^ " test_check_is_z_goal y",
	test_check_is_z_goal,
	tm1,
	true),
	(name ^ " test_check_is_z_goal n",
	test_check_is_z_goal,
	tm2,
	true),
	(name ^ " test_check_is_z_term y",
	test_check_is_z_term,
	tm1,
	true),
	(name ^ " test_check_is_z_term n",
	test_check_is_z_term,
	tm2,
	true)];
=TEX
\subsection{Some Useful Examples}
ÿTEST_SCHEMAü
x:U;
y:U
ˆ
=SML
val notz = ¬¶ x · x = y®;
val trues = string_of_term mk_t;
val notzs = string_of_term notz;
=TEX
\section{TESTS}
\subsection{Checking For Z}
This is primarily done by $really\_z$.
=SML
val _ = diag_string
	"***There should now be a large number of ``In the result of...'' messages***";
=TEX
Note that ``$\#$'' precedes ``$'$'' in the variable sorting.
=SML
let
val tm = mk_z_decsexp(ñ[z:X;x:Y;y:Z]®,"'");
val y' = nth 4 (frees tm);
val y'' = variant [y'] y';
val tm' = subst[(y'',y')] tm;
in
really_z "decsexp" tm tm'
end;
let
val tm = ñµ ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Zµ" tm tm'
end;
let
val tm = ñ¶ ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶" tm tm'
end;
let
val tm = ñ¶‰1 ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶‰1" tm tm'
end;
let
val Z¶(a,b,c) = dest_z_term ñ¶ ##, ### : X | ## = z · [##,### : X | true]®;
val tm = mk_z_¶‰s(a,b,ñ[##,### : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶‰s" tm tm'
end;
let
val Z¶(xa,xb,xc) = dest_z_term ñ¶ ##, ### : X | ## = z · [##,### : X | true]®;
val tm = mk_z_¶‰1‰s(xa,xb,ñ[##,### : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶‰1‰s" tm tm'
end;
let
val Z¶(xa,xb,xc) = dest_z_term ñ¶ ##, ### : X | ## = z · [##,### : X | true]®;
val tm = mk_z_µ‰s(xa,xb,ñ[##,### : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "µ‰s" tm tm'
end;
let
val tm1 = ñ[##,###:X | ## = z] ± true®;
val tm = fst(dest_z_± tm1);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val x_ins' = mk_var("##'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
in
really_z "predsexp" tm tm'
end;
let
val tm = ñ{##, ### : X | ## = z}®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "seta" tm tm'
end;
let
val tm = ñÊ[##, ### : X | ## = z]®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val x_ins' = mk_var("##'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
in
really_z "Ê" tm tm'
end;
let
val tm = ñ Ì ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Ì" tm tm'
end;
let
val tm = ñ Í ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Í" tm tm'
end;
let
val tm = ñ [##,### : X | ## = z]®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "decsexp1" tm tm'
end;

=TEX
=SML
val _ = diag_string
	"***The ``In the result of...'' messages should now cease***";
=TEX
But just to check the error messages:
=SML
val not_a_z_term = ¬Ì x · T®;
val not_a_z_term2 = ¬Ì x · F®;
val not_a_z_term_st = string_of_term not_a_z_term;
val not_a_z_type = ”'a LIST®;
val not_a_z_type_st = string_of_type not_a_z_type;
store_mt_results mt_run_fail [("full_dest_z_term 41002",
	full_dest_z_term,
	not_a_z_term,
	gen_fail_msg "full_dest_z_term" 41002 [not_a_z_term_st])];
store_mt_results mt_run_fail [("is_z 41002",
	is_z,
	not_a_z_term,
	gen_fail_msg "is_z" 41002 [not_a_z_term_st])];
store_mt_results mt_run_fail [("is_all_z_type 41002",
	is_all_z_type,
	not_a_z_type,
	gen_fail_msg "is_all_z_type" 41003 [not_a_z_type_st])];
store_mt_results (mt_runf (list_eq(op =$))) 
	[("not_z_subterms",
	not_z_subterms,
	mk_eq(not_a_z_term,not_a_z_term2),
	[not_a_z_term2, not_a_z_term])];
=TEX
To test the quieting effect of $check\_is\_z$
=SML
val _ = (diag_string "Being Noisy";
	check_is_z_thm "test" (refl_conv not_a_z_term);
	check_is_z_goal "test" ([],mk_eq( not_a_z_term,not_a_z_term2));
	check_is_z_term "test" not_a_z_term;
	diag_string "Going Quiet";
	set_flag("check_is_z",false);
	check_is_z_thm "test" (refl_conv not_a_z_term);
	check_is_z_goal "test" ([],mk_eq(not_a_z_term,not_a_z_term2));
	check_is_z_term "test" not_a_z_term;
	diag_string "Back to Normal";
	set_flag("check_is_z",true)
);
=TEX	
\subsection{Adjustment after Á-conversion}
=SML
val _ = diag_string "Á_to_z NOT YET IMPLEMENTED";
val _ = diag_string "Á_to_z_conv NOT YET IMPLEMENTED";
=TEX
\subsection{Convcerning The Universe}
=SML
fun Ûtest_u_lang_convİ tm = (
let	val thm = u_lang_conv tm;
	val (l,r) = dest_eq (concl thm);
in
	(l =$ tm) andalso (term_match r ñU®;true)
end);
=TEX
=SML
store_mt_results mt_run [
	("u_lang_conv 1",
	test_u_lang_conv,
	ñU ¸ U®,
	true),
	("u_lang_conv 2",
	test_u_lang_conv,
	ñU ¸ U ¸ U ¸ U®,
	true),
	("u_lang_conv 3",
	test_u_lang_conv,
	ñğ U®,
	true),
	("u_lang_conv 4",
	test_u_lang_conv,
	ñ{l1 : U; l2,l3 : U; l4,l5,l6 : U}®,
	true)
	];
store_mt_results mt_run_fail [("u_lang_conv 41060",
	u_lang_conv,
	not_a_z_term,
	gen_fail_msg "u_lang_conv" 41060 [not_a_z_term_st])];

=TEX
=SML
fun Ûtest__u_lang_convİ tm = (
let	val thm = _u_lang_conv tm;
	val (l,r) = dest_eq (concl thm);
in
	(l =$ tm) andalso (r =$ mk_t)
end);
=TEX
=SML
store_mt_results mt_run [
	("_u_lang_conv 1",
	test__u_lang_conv,
	ñx  U®,
	true),
	("_u_lang_conv 2",
	test__u_lang_conv,
	ñx € U®,
	true),
	("_u_lang_conv 3",
	test__u_lang_conv,
	snd(dest_± ñtrue ± [a: U]®),
	true),
	("_u_lang_conv 4",
	test__u_lang_conv,
	ñx  ğ U®,
	true),
	("_u_lang_conv 5",
	test__u_lang_conv,
	ñx  ğ (U ¸ U)®,
	true),
	("_u_lang_conv 6",
	test__u_lang_conv,
	ñx  {x:U; y: U}®,
	true),
	("_u_lang_conv 7",
	test__u_lang_conv,
	ñx  ğ {x:U; y: U ¸ U}®,
	true),
	("_u_lang_conv 8",
	test__u_lang_conv,
	ñx  [a ,b : U; c : U]®,
	true),
	("_u_lang_conv 10",
	test__u_lang_conv,
	ñx  ğ (U ¸ U) ¸ [a ,b : U; c : U]®,
	true),
	("_u_lang_conv 11",
	test__u_lang_conv,
	ñ{x,y} € ğ (U ¸ U) ¸ [a ,b : U; c : U]®,
	true),
	("_u_lang_conv 12",
	test__u_lang_conv,
	snd(dest_±(ñtrue ± [a ,b : U ¸ [a ,b : U; c : U]; c : ğ U]®)),
	true)
	];
=TEX
=SML
store_mt_results mt_run_fail [("_u_lang_conv 41062",
	_u_lang_conv,
	not_a_z_term,
	gen_fail_msg "_u_lang_conv" 41062 [not_a_z_term_st]),
	("_u_lang_conv 41061",
	_u_lang_conv,
	ñy  X®,
	gen_fail_msg "_u_lang_conv" 41061 [string_of_term ñy  X®])];
=TEX
\subsection{Concerning Z Universal Quantification}
=SML
let
	val Ê = ñÊ TEST_SCHEMA®;
in
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim 1",
	concl o z_µ_elim ñ(x ¦ (q º a), y ¦ (r º b), z ¦ (p º a))®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g y z®),
	ñ(((q  X) ± (r  Y) ± (p  X)) ± f q) ´ (g r) p®),
	("z_µ_elim 2",
	concl o z_µ_elim ñ(x ¦ (q º a), y ¦ (r º b), z ¦ (p º a))®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	ñ(((q  X) ± (r  Y) ± (p  X)) ± f q) ´ (g ¬a + b®) p®),
	("z_µ_elim 3",
	concl o z_µ_elim ñSS º [x:a;y:b;z:a]®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  y z®),
	ñ((((SS º [x:a;y:b;z:a]).x  X) ± (SS.y  Y) ± (SS.z  X)) ± f SS.x)
	´ (g SS.y) SS.z®),
	("z_µ_elim 4",
	concl o z_µ_elim mk_t,
	(asm_ruleñµ x:BOOL · x®),
	ñ(true  BOOL ± true) ´ true®),
	("z_µ_elim 5",
	concl o z_µ_elim ñÊ (TEST_SCHEMA º ğ[x:X;y:Y])®,
	(asm_ruleñµ x:U;y: U· f x y®),
	ñ((((Ê (TEST_SCHEMA º ğ[x:X;y:Y])).x  U) ± (Ê (TEST_SCHEMA º ğ[x:X;y:Y])).y  U) ± true) ´ f (Ê (TEST_SCHEMA º ğ[x:X;y:Y])).x (Ê (TEST_SCHEMA º ğ[x:X;y:Y])).y®)
	]
end;
=TEX
Ignore the single ``not in the Z language'' message from the above.
=SML
val mk_t_st = string_of_term mk_t;
val (xyz_decl,_,_) = dest_z_µ ñµ x:X; y:Y; z:X · true®;
store_mt_results mt_run_fail [
	("z_µ_elim 47310",
	z_µ_elim mk_t,
	t_thm,
	gen_fail_msg  "z_µ_elim" 47310 [mk_t_st]),
	("z_µ_elim 41021 a",
	z_µ_elim ñ(x ¦ (q º a), y ¦ (r º b))®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg  "z_µ_elim" 41021 [
		string_of_term ñ(x ¦ (q º ğ a), y ¦ (r º ğ b))®,
		string_of_term xyz_decl]),
	("z_µ_elim 41021 b",
	z_µ_elim mk_t,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg  "z_µ_elim" 41021 [mk_t_st,
		string_of_term xyz_decl])
	];
=TEX
=SML
let 
	val tm1 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z)) ± f x ´ g w y z®;
	val tm2 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z))  ´ g w y z®;
in
store_mt_results (mt_runf(op =$)) [
	("z_µ_intro 1",
	concl o z_µ_intro,
	(all_µ_elim (asm_rule(list_mk_µ(frees tm1, tm1)))),
	ñµ x:W; y:X; p,q:Y; z:Z | f x · g w y z®),
	("z_µ_intro 2",
	concl o z_µ_intro,
	(all_µ_elim (asm_rule(list_mk_µ(frees tm2, tm2)))),
	ñµ x:W; y:X; p,q:Y; z:Z | true · g w y z®)
	]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("z_µ_intro 41026",
	z_µ_intro,
	t_thm,
	gen_fail_msg "z_µ_intro" 41026 [string_of_thm t_thm]),
	("z_µ_intro 41027",
	z_µ_intro,
	asm_rule ñtrue ± true ´ true®,
	gen_fail_msg "z_µ_intro" 41027 [mk_t_st]),
	("z_µ_intro 6005",
	z_µ_intro,
	asm_rule ñx  X ± true ´ true®,
	gen_fail_msg "z_µ_intro" 6005 [string_of_term ñx®])
	];
=TEX
=SML
let 
	val tm1 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z)) ± f x ´ g w y z®;
	val tm2 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z))  ´ g w y z®;
in
store_mt_results (mt_runf(op =$)) [
	("z_µ_intro1 1",
	concl o z_µ_intro1 [],
	(all_µ_elim (asm_rule(list_mk_µ(frees tm1, tm1)))),
	ñµ x:W; y:X; p,q:Y; z:Z | f x · g w y z®),
	("z_µ_intro1 2",
	concl o z_µ_intro1 [¬x:'a®,¬y:'b®],
	taut_rule ñfalse ´ true®,
	ñµ x:U; y:U | false · true®),
	("z_µ_intro1 3",
	concl o z_µ_intro1 [¬x:'a®,¬y:'b®],
	t_thm,
	ñµ x:U; y:U · true®)
	]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("z_µ_intro1 3007",
	z_µ_intro1 [mk_t],
	t_thm,
	gen_fail_msg "z_µ_intro1" 3007 [mk_t_st]),
	("z_µ_intro1 41028",
	z_µ_intro1 [],
	t_thm,
	gen_fail_msg "z_µ_intro1" 41028 [string_of_thm t_thm]),
	("z_µ_intro1 41027",
	z_µ_intro1 [],
	asm_rule ñtrue ± true ´ true®,
	gen_fail_msg "z_µ_intro1" 41027 [mk_t_st]),
	("z_µ_intro1 6005",
	z_µ_intro1 [],
	asm_rule ñx  X ± true ´ true®,
	gen_fail_msg "z_µ_intro1" 6005 [string_of_term ñx®])
	];
=TEX
=SML
let val tm1 = ñµ x : X; y,z : Y | false · y = z®;
in
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv/z_µ_intro_conv",
	snd o dest_eq o concl o conv_rule(RIGHT_C z_µ_intro_conv) o z_µ_elim_conv,
	tm1,
	tm1)]
end;
=TEX
=SML
let
	val (adecl,_,_) = dest_z_µ ñµ x, y:X | false · true®;
in
store_mt_results mt_run_fail [
	("z_µ_elim_conv 41022",
	z_µ_elim_conv,
	mk_t,
	gen_fail_msg "z_µ_elim_conv" 41022 [mk_t_st]),
	("z_µ_intro_conv 41023",
	z_µ_intro_conv,
	mk_t,
	gen_fail_msg "z_µ_intro_conv" 41023 [mk_t_st]),
	("z_µ_intro_conv 41024",
	z_µ_intro_conv,
	¬µ x · ‘adecl® ± T ´ F®,
	gen_fail_msg "z_µ_intro_conv" 41024 [string_of_term ¬µ x · ‘adecl® ± T ´ F®])
	]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv2",
	snd o dest_eq o concl o z_µ_elim_conv2,
	ñµ x, y : X · x= y®,	
	¬µ x y:'a · ñ{x,y} € X ± true ´ x = y®®)];
store_mt_results mt_run_fail [
	("z_µ_elim_conv2 41022",
	z_µ_elim_conv2,
	mk_t,
	gen_fail_msg "z_µ_elim_conv2" 41022 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_elim_conv2",
	snd o dest_eq o concl o z_¶_elim_conv2,
	ñ¶ x, y : X · x= y®,	
	¬¶ x y:'a · ñ{x,y} € X ± true ± x = y®®)];
store_mt_results mt_run_fail [
	("z_¶_elim_conv2 41022",
	z_¶_elim_conv2,
	mk_t,
	gen_fail_msg "z_¶_elim_conv2" 41044 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("all_z_µ_intro 1",
	concl o all_z_µ_intro,
	refl_conv ñ{x,y}®,
	ñµ x : U; y:U | true · {x,y} = {x,y}®),
	("all_z_µ_intro 2",
	concl o all_z_µ_intro,
	asm_rule ñx ± y®,
	ñx ± y®),
	("all_z_µ_intro 3",
	concl o all_z_µ_intro,
	refl_convñx®,
	ñµ x:U · x = x®)
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv1",
	snd o dest_eq o concl o z_µ_elim_conv1,
	ñµ x:U; y,z : U; [a,b:U ¸ U] | f · g®,
	¬µ a b :('c, 'd) $"Z'T[2]" · µ x:'a· µ y z :'b · f ´ g®)];
store_mt_results mt_run_fail [
	("z_µ_elim_conv1 41022",
	z_µ_elim_conv1,
	mk_t,
	gen_fail_msg "z_µ_elim_conv1" 41022 [mk_t_st]),
	("z_µ_elim_conv1 41071",
	z_µ_elim_conv1,
	ñµ x : X · false®,
	gen_fail_msg "z_µ_elim_conv1" 41071 [string_of_term ñµ x : X · false®])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_inv_conv 1",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x, y : X | f · g®,
	ñf ´ (µ x, y : X | true · false) ² g®),
	("z_µ_inv_conv 1b",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x : X | f · g®,
	ñf ´ (µ x : X | true · false) ² g®),
	("z_µ_inv_conv 2",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x, y : X | x > 0 · z®,
	ñ(µ x, y : X | x > 0 · false) ² z®),
	("z_µ_inv_conv 3",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x,y : X | f · x = y®,
	ñf ´ (µ x,y : X | true · x = y)®),
	("z_µ_inv_conv 4",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x,y : X · g®,
	ñ(µ x,y : X · false) ² g®),
	("z_µ_inv_conv 5",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x,y : X | f· false®,
	ñf ´ (µ x,y : X | true · false)®)
	];
store_mt_results mt_run_fail [
	("z_µ_inv_conv 47310",
	z_µ_inv_conv,
	mk_t,
	gen_fail_msg "z_µ_inv_conv" 47310 [mk_t_st]),
	("z_µ_inv_conv 41025",
	z_µ_inv_conv,
	ñµ x :X | f x · g x®,
	gen_fail_msg "z_µ_inv_conv" 41025 [
		string_of_term ñµ x : X | f x · g x®])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_intro_µ_tac 1",
	tac_res (z_intro_µ_tac ñ(x ¦ 1, y ¦ 2)®),
	ñ(1,2) = (3,4)®,
	ñµ x:U;y:U · (x,y) = (3,4)®)
	];

=TEX
=SML
store_mt_results mt_run_fail [("z_intro_µ_tac 41029",
	z_intro_µ_tac,
	mk_t,
	gen_fail_msg "z_intro_µ_tac" 41029 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [("z_spec_asm_tac",
	tac_res1 (z_spec_asm_tac ñµ x :U · x ± y® ñtrue®),
	([ñµ x :U · x ± y®],ñfalse®),
	([¬y:BOOL®, ñµ x : U · x ± y®],ñfalse®))];
store_mt_results (mt_runf (op =#)) [("z_spec_nth_asm_tac",
	tac_res1 (z_spec_nth_asm_tac 1 ñtrue®),
	([ñµ x :U · x ± y®],ñfalse®),
	([¬y:BOOL®, ñµ x : U · x ± y®],ñfalse®))];
=TEX
\subsection{Concerning Z Existential Quantification}
=SML
let val tm1 = ñ¶ x : X; y,z : Y | false · y = z®;
in
store_mt_results (mt_runf (op =$)) [
	("z_¶_elim_conv/z_¶_intro_conv",
	snd o dest_eq o concl o conv_rule(RIGHT_C z_¶_intro_conv) o z_¶_elim_conv,
	tm1,
	tm1)]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_intro_conv1",
	snd o dest_eq o concl o z_¶_intro_conv1,
	¬¶ x y · x = y®,
	ñ¶ x : U; y : U | true · x = y®)];
store_mt_results mt_run_fail [
	("z_¶_intro_conv1 41046",
	z_¶_intro_conv1,
	mk_t,
	gen_fail_msg "z_¶_intro_conv1" 41046 [mk_t_st])];
=TEX
=SML
let
	val (adecl,_,_) = dest_z_¶ ñ¶ x, y:X | false · true®;
in
store_mt_results mt_run_fail [
	("z_¶_elim_conv 41044",
	z_¶_elim_conv,
	mk_t,
	gen_fail_msg "z_¶_elim_conv" 41044 [mk_t_st]),
	("z_¶_intro_conv 41045",
	z_¶_intro_conv,
	mk_t,
	gen_fail_msg "z_¶_intro_conv" 41045 [mk_t_st]),
	("z_¶_intro_conv 41041",
	z_¶_intro_conv,
	¬¶ x · ‘adecl® ± T ± F®,
	gen_fail_msg "z_¶_intro_conv" 41041 [string_of_term ¬¶ x · ‘adecl® ± T ± F®])
	]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_elim_conv1",
	snd o dest_eq o concl o z_¶_elim_conv1,
	ñ¶ x:U; y,z : U; [a,b:U ¸ U] | f · g®,
	¬ ¶ a b :('c, 'd) $"Z'T[2]" · ¶ x:'a· ¶ y z :'b ·f ± g®)];
store_mt_results mt_run_fail [
	("z_¶_elim_conv1 41042",
	z_¶_elim_conv1,
	mk_t,
	gen_fail_msg "z_¶_elim_conv1" 41042 [mk_t_st]),
	("z_¶_elim_conv1 41043",
	z_¶_elim_conv1,
	ñ¶ x : X · false®,
	gen_fail_msg "z_¶_elim_conv1" 41043 [string_of_term ñ¶ x : X · false®])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶‰1_conv 1",
	snd o dest_eq o concl o z_¶‰1_conv,
	ñ¶‰1 x : X | x = y · f x®,
	ñ¶ x : X | x = y ± f x · µ x' : X | x' = y ± f x' · x' = x®),
	("z_¶‰1_conv 2",
	snd o dest_eq o concl o z_¶‰1_conv,
	ñ¶‰1 x,y : X; z:Y | x = y · z = f x®,
	ñ(¶ x, y : X; z : Y
	 | (x = y)
	 ± (z = f x)
	 · µ x', y' : X; z' : Y
	| (x' = y') ± (z' = f x')
      · (x' = x) ± (y' = y) ± (z' = z))®),
	("z_¶‰1_conv 3",
	concl o z_¶‰1_conv,
	ñ¶‰1 [x,y : X; z:Y] | x = x' y y'' · z = f x®,
	ñ[a,b,c](¶‰1 [x, y : (X ºğ a); z : (Y º ğ b)] | x = x' y (y''ºc) · z = f x)
    ¤ (¶ [x, y : (X ºğ a); z : (Y º ğ b)]
      | x = x' y (y''ºc) ± z = f x
      · ‘mk_z_µ(
		mk_z_decl[mk_z_decsexp (ñ[a,b,c][x, y : (X ºğ a); z : (Y º ğ b)]®,"'''")],
		ñ[a,b,c](x'''º a) = x' (y'''ºa) (y''ºc) ± (z'''ºb) = f x'''®,
		ñ[a,b,c](x'''º a) = x ± (y'''ºa) = y ± (z'''ºb) = z®)®)®)
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_tac 1",
	tac_res (z_¶_tac mk_t),
	ñ¶ x : U· x ± y®,
	ñtrue  U ± true ± true ± y®),
	("z_¶_tac 2",
	tac_res (z_¶_tac ñ(x ¦ 1, y ¦ 2)®),
	ñ¶ x : U; y : U· (x,y) = (1,2)®,
	ñ(1  U ± 2  U) ± true ± (1,2) = (1,2)®)];

let
	val t = (mk_var("t", type_of ñ(x ¦ 1, y ¦ 2)®));
	val Ê = inst[] [(”ú®,”'a®), (”ú®,”'b®)] ñÊ TEST_SCHEMA®;
in
store_mt_results (mt_runf (op =$)) [
	("z_¶_tac 3",
	tac_res (z_¶_tac t),
	ñ¶ x : U; y : U· (x,y) = (1,2)®,
	ñ(‘t®.x  U ± ‘t®.y  U) ± true ± (‘t®.x, ‘t®.y) = (1,2)®),
	("z_¶_tac 4",
	tac_res (z_¶_tac ñÊ TEST_SCHEMA®),
	ñ¶ x : U; y : U· (x,y) = (1,2)®,
	ñ(‘Ê®.x  U ± ‘Ê®.y  U) ± true ± (‘Ê®.x, ‘Ê®.y) = (1,2)®)
	]
end;

=TEX
=SML
store_mt_results mt_run_fail [
	("z_¶_tac 47290",
	tac_fail (z_¶_tac mk_t),
	([],ñtrue®),
	gen_fail_msg "z_¶_tac" 47290 [mk_t_st]),
	("z_¶_tac 41021 a",
	tac_fail (z_¶_tac ñ(x ¦ (q º ğ a), y ¦ (r º ğ b))®),
	([],ñ¶ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg "z_¶_tac" 41021 [
		string_of_term ñ(x ¦ (q º ğ a), y ¦ (r º ğ b))®,
		string_of_term xyz_decl]),
	("z_¶_tac 41021 b",
	tac_fail (z_¶_tac mk_t),
	([],ñ¶ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg "z_¶_tac" 41021 [mk_t_st,
		string_of_term xyz_decl])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_inv_conv 1",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x, y : X | f · g®,
	ñf ± (¶ x, y : X | true · true) ± g®),
	("z_¶_inv_conv 1b",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x: X | f · g®,
	ñf ± (¶ x : X | true · true) ± g®),
	("z_¶_inv_conv 2",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x, y : X | x > 0 · z®,
	ñ(¶ x, y : X | x > 0 · true) ± z®),
	("z_¶_inv_conv 3",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x,y : X | f · x = y®,
	ñf ± (¶ x,y : X | true · x = y)®),
	("z_¶_inv_conv 4",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x,y : X · g®,
	ñ(¶ x,y : X · true) ± g®),
	("z_¶_inv_conv 5",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x,y : X | f· true®,
	ñf ± (¶ x,y : X | true · true)®)
	];
store_mt_results mt_run_fail [
	("z_¶_inv_conv 47290",
	z_¶_inv_conv,
	mk_t,
	gen_fail_msg "z_¶_inv_conv" 47290 [mk_t_st]),
	("z_¶_inv_conv 41040",
	z_¶_inv_conv,
	ñ¶ x : X | f x · g x®,
	gen_fail_msg "z_¶_inv_conv" 41040 [
		string_of_term ñ¶ x : X | f x · g x®])];
=TEX
\subsection{Conversions between Z Universal and Existential Quantifications}
The first of the following will fail with HOL version 1.97, but should not fail with later ones.
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_³_µ_conv 1",
	snd o dest_eq o concl o z_³_µ_conv,
	ñ³(µ x:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñ¶ x:X; y,z:Y; [a,b:U] | y = z · ³ a = b®),
	(
	"z_³_µ_conv 2",
	snd o dest_eq o concl o z_³_µ_conv,
	ñ³(µ xx:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñ¶ xx:X; y,z:Y; [a,b:U] | y = z · ³ a = b®)];
=TEX
The first of the following will fail with HOL version 1.97, but should not fail with later ones.
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_³_¶_conv 1",
	snd o dest_eq o concl o z_³_¶_conv,
	ñ³(¶ x:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñµ x:X; y,z:Y; [a,b:U] | y = z · ³ a = b®),
	("z_³_¶_conv 2",
	snd o dest_eq o concl o z_³_¶_conv,
	ñ³(¶ xx:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñµ xx:X; y,z:Y; [a,b:U] | y = z · ³ a = b®)];
store_mt_results mt_run_fail [("z_³_µ_conv 41050",
	z_³_µ_conv,
	mk_t,
	gen_fail_msg "z_³_µ_conv" 41050 [mk_t_st]),
	("z_³_¶_conv 41051",
	z_³_¶_conv,
	mk_t,
	gen_fail_msg "z_³_¶_conv" 41051 [mk_t_st])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_³_in_conv 1",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(³ (x ± y))®,
	ñ(x ± y)®),
	("z_³_in_conv 2",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 ± t2)®,
	ñ³t1 ² ³t2®),
	("z_³_in_conv 3",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 ² t2)®,
	ñ³t1 ± ³t2®),
	("z_³_in_conv 4",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 ´ t2)®,
	ñt1 ± ³t2®),
	("z_³_in_conv 5",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³((x ± y) = t2)®,
	ñ((x ± y) ± ³t2) ² (t2 ± ³(x ± y))®),
	("z_³_in_conv 6",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 = t1)®,
	ñfalse®),
	("z_³_in_conv 7",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(µ x:X | P· V)®,
	ñ¶ x:X | P· ³ V®),
	("z_³_in_conv 8",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³( ¶ x:X | P· V)®,
	ñµ x:X | P· ³ V®),
	("z_³_in_conv 9",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³ (¶‰1 x:X|P· V x)®,
	ñµx:X |P ± V x ·³ (µx':X |P ± V x' · x' = x)®), 
	("z_³_in_conv 10",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³ true®,
	ñfalse®),
	("z_³_in_conv 11",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³ false®,
	ñtrue®)
	];
=TEX
=SML
store_mt_results mt_run_fail [(
	"z_³_in_conv 28131",
	z_³_in_conv,
	ñ³ x®,
	gen_fail_msg "z_³_in_conv" 28131 [string_of_term ñ³ x®]),
	("z_³_in_conv 47240",
	z_³_in_conv,
	mk_t,
	gen_fail_msg "z_³_in_conv" 47240 [mk_t_st])
	];
=TEX
\subsection{Conversions betweens Declarations and Predicates}
=SML
store_mt_results (mt_runf (op =$)) [
	("dec_pred_conv 1",
	snd o dest_eq o concl o dec_pred_conv,
	mk_z_dec([ñx®],ñX º ğ a®),
	ñx  X®),
	("dec_pred_conv 2",
	snd o dest_eq o concl o dec_pred_conv,
	mk_z_dec([ñx®,ñy®],ñX º ğ a®),
	ñ{x,y} € X®),
	("dec_pred_conv 3",
	snd o dest_eq o concl o dec_pred_conv,
	mk_z_decsexp(ñ[x,y:X]®,""),
	mk_z_predsexp(ñ[x,y:X]®,""))];
store_mt_results mt_run_fail [(
	"dec_pred_conv 41010",
	dec_pred_conv,
	mk_t,
	gen_fail_msg "dec_pred_conv" 41010 [mk_t_st])
	];
=TEX
=SML
let
val (d,_,_) = dest_z_µñµ x:X; y,z:Y; [a,b:Z] · true®;
in
	store_mt_results (mt_runf (op =$)) [
	("DECL_C",
	snd o dest_eq o concl o DECL_C dec_pred_conv,
	d,
	ñx  X ± {y,z} € Y ± [a,b:Z]®)
	]
end;
store_mt_results mt_run_fail [(
	"DECL_C 47912",
	DECL_C dec_pred_conv,
	mk_t,
	gen_fail_msg "DECL_C" 47912 [mk_t_st]),
	("DECL_C 41012",
	DECL_C dec_pred_conv,
	mk_z_decl[mk_t],
	gen_fail_msg "DECL_C" 41012 [string_of_term (mk_z_decl[mk_t])])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("pred_dec_conv 1",
	snd o dest_eq o concl o pred_dec_conv,
	ñx  X®,
	mk_z_dec([ñx®],ñX º ğ a®)),
	("pred_dec_conv 2",
	snd o dest_eq o concl o pred_dec_conv,
	ñ{x,y} € X®,
	mk_z_dec([ñx®,ñy®],ñX º ğ a®)),
	("pred_dec_conv 3",
	snd o dest_eq o concl o pred_dec_conv,
	mk_z_predsexp(ñ[x,y:X]®,""),
	mk_z_decsexp(ñ[x,y:X]®,"")),
	("pred_dec_conv 4",
	snd o dest_eq o concl o pred_dec_conv,
	ñÊ[x, ### : X | x = z]  [x, ### : X | x = z]®,
	mk_z_decsexp(ñ[x, ### : X | x = z]®,""))];
store_mt_results mt_run_fail [(
	"pred_dec_conv 41010",
	pred_dec_conv,
	mk_t,
	gen_fail_msg "pred_dec_conv" 41011 [mk_t_st])
	];
=TEX
=SML
let
val (d,_,_) = dest_z_µñµ x:X; y,z:Y; [a,b:Z] · true®;
in
	store_mt_results (mt_runf (op =$)) [
	("DECL_INTRO_C",
	snd o dest_eq o concl o DECL_INTRO_C pred_dec_conv,
	ñx  X ± {y,z} € Y ± [a,b:Z]®,
	d)
	]
end;
store_mt_results mt_run_fail [(
	"DECL_INTRO_C 41013",
	DECL_INTRO_C dec_pred_conv,
	mk_t,
	gen_fail_msg "DECL_INTRO_C" 41013 [mk_t_st]),
	("DECL_INTRO_C 41014",
	DECL_INTRO_C id_conv,
	mk_t,
	gen_fail_msg "DECL_INTRO_C" 41014 [mk_t_st,mk_t_st])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z__setd_conv",
	snd o dest_eq o concl o z__setd_conv,
	mk_z_(ñ2®, ñ{1,2,3}®),
	ñ2 = 1 ² 2 = 2 ² 2 = 3®)];
store_mt_results mt_run_fail [("z__setd_conv 42002 a",
	z__setd_conv,
	mk_t,
	gen_fail_msg "z__setd_conv" 42002 [trues]),
	("z__setd_conv 42002 b",
	z__setd_conv,
	notz,
	gen_fail_msg "z__setd_conv" 42002 [notzs]),
	("z__setd_conv 42002 c",
	z__setd_conv,
	ñx   ¬Z'Setd (Cons h t)®®,
	gen_fail_msg "z__setd_conv" 42002
	   [string_of_term ñx   ¬Z'Setd (Cons h t)®®])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_setd_€_conv 1",
	snd o dest_eq o concl o z_setd_€_conv,
	ñ{} € ğ X®,
	ñtrue®),
	("z_setd_€_conv 2",
	snd o dest_eq o concl o z_setd_€_conv,
	ñ{x,y,z} € ğ X®,
	ñx  ğ X ± y  ğ X ± z  ğ X®),
	("z_setd_€_conv 3",
	snd o dest_eq o concl o z_setd_€_conv,
	ñ{f(x = x ´ y),y} € (h(p = p ´ q))®,
	ñf ¬y:BOOL®  h ¬q:BOOL® ± ¬y:BOOL®  h ¬q:BOOL®®)
	];
store_mt_results mt_run_fail [("z_setd_€_conv 42010",
	z_setd_€_conv,
	mk_t,
	gen_fail_msg "z_setd_€_conv" 42010 [trues])
	];
=TEX
\section{Z REWRITING}
\subsection{Canonicalisation}
=SML
((open_theory "z_sets";
store_mt_results (mt_runf (op =|-)) [("z_defn_canon",
	hd o z_defn_canon,
	z'ª_def,
	pure_rewrite_rule [z'abbdef_def]
		 (z'ª_def))];
open_theory use_thy)
handle (Fail _) =>
store_mt_results mt_run [("z_defn_canon didn't test",
	Combinators.I,
	true,
	false)]
);

store_mt_results mt_run_fail [(
	"z_defn_canon 41080",
	z_defn_canon,
	t_thm,
	gen_fail_msg "z_defn_canon" 41080 [string_of_thm t_thm])];
((open_theory "z_sets";
store_mt_results (mt_runf (op =$)) [("z_defn_conv",
	snd o dest_eq o concl o z_defn_conv,
	concl(z'ª_def),
	concl(pure_rewrite_rule [z'abbdef_def]
		 (z'ª_def)))];
open_theory use_thy)
handle (Fail _) =>
store_mt_results mt_run [("z_defn_conv didn't test",
	Combinators.I,
	true,
	false)]
);
store_mt_results mt_run_fail [(
	"z_defn_conv 41082",
	z_defn_conv,
	mk_t,
	gen_fail_msg "z_defn_conv" 41082 [mk_t_st])];

store_mt_results (mt_runf (op =$)) [("z_µ_rewrite_canon 1",
	concl o hd o z_µ_rewrite_canon,
	asm_rule ñµ x,y : U; z:X| f · x = y®,
	¬µ x y:'a · µ z:'b· z  X ± f ´ x = y®),
	("z_µ_rewrite_canon 2",
	concl o hd o z_µ_rewrite_canon,
	asm_rule ñµ x: U | f · x = y®,
	¬µ x · f ´ x = y®)];
store_mt_results mt_run_fail [(
	"z_µ_rewrite_canon 41081",
	z_µ_rewrite_canon,
	t_thm,
	gen_fail_msg "z_µ_rewrite_canon" 41081 [string_of_thm t_thm])];
=TEX
=SML
store_mt_results (mt_runf (op =|-)) [
	("z_³_rewrite_canon 1",
	hd o z_³_rewrite_canon,
	asm_rule ñ³(t1 ² t2)®,
	conv_rule z_³_in_conv
		 (asm_rule ñ³(t1 ² t2)®)),
	("z_³_rewrite_canon 2",
	hd o z_³_rewrite_canon,
	asm_rule ñ³(¶ x : X | f · g)®,
	conv_rule z_³_in_conv
		 (asm_rule ñ³(¶ x : X | f · g)®)),
	("z_³_rewrite_canon 3",
	hd o z_³_rewrite_canon,
	asm_rule ñ³ (³ t)®,
	conv_rule z_³_in_conv
		 (asm_rule ñ³ (³ t)®)),
	("z_³_rewrite_canon 4",
	hd o z_³_rewrite_canon,
	asm_rule ñ³ t®,
	pure_rewrite_rule [taut_rule ¬µ x · ³ x ¤ x ¤ F®]
		 (asm_rule ñ³ t®))
	];
=TEX
\section{Z STRIPPING AND PROOF CONTEXTS}
Incomplete tests, but certainly strongly hint at
some Z specific stuff:
=SML
store_mt_results (mt_runf (op =$)) [("z_predicates pc 1",
	tac_res (rewrite_tac[]),
	ñ(t = true) ± ³ (³ t1) ± (t2 = t2) ± true ± (false ´ t3) ± 
		(x  (U ¸ U)) ± (µ x : X · true) ± ³(¶ y : X · false) ² false®,
	ñt ± t1®)];
store_mt_results (mt_runf (op =#)) [("z_predicates pc 2",
	tac_res1 strip_tac,
	([],ñ(³(³ t) ± (µ x : U · x = x) ± (¶ x : U · f x) ± z  ğ U ± 
		(µ p:P | p · true)) ´ false®),
	([ñµ p : P | p · false®,
	  ñ[b](f º ğ(b ¸ {true,false})) x®,
	  ñµ x:U· x = x®, ¬t:BOOL®],ñfalse®))];
store_mt_results (mt_runf (op =#)) [("z_predicates pc 3",
	tac_res1 (REPEAT strip_tac),
	([],ñµ y : X · (³(³ t) ± (µ x : U · x = x) ± x  U)®),
	([ñy  X®],¬t:BOOL®))];
store_mt_results (mt_runf (op =#)) [("'z_decl pc 1",
	tac_res1 (REPEAT strip_tac),
	([],ñ(¶ x,y : X · x = y) ´ false®),
	([ñx = y®,ñy  X®,ñx  X®],ñfalse®))];
=TEX
\section{BIT O'NONSENSE}
¹Z
rel	px _,py _, pz _
°
[X]
px _ : ğ X;
py _ : ğ X;
pz _ : ğ X
ˆ

ÿS[X]ü
x:X
÷
px x
ˆ
ÿI[X]ü
y:X
÷
py y
ˆ
ÿO[X]ü
z:X
÷
pz z
ˆ
=SML
push_goal([],ñ(¶[[S;S']; I;O] | p x x' y z· true) ¤
	(¶ S;S'; I;O | p x x' y z· true)®);
a(REPEAT strip_tac);
a(z_¶_tac ñÊ[[S;S']; I;O]®);
a(REPEAT strip_tac);
repeat drop_main_goal;
=TEX
\section{END OF TESTS}
=SML
(* set_flag("subgoal_package_quiet",false); *)
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results (mt_runf (op =$)) [("",
	tac_res ,
	ñ®,
	ñ®)];
store_mt_results (mt_runf (op =#)) [("",
	tac_res1 ,
	([ñ®],ñ®),
	([ñ®],ñ®))];
store_mt_results (mt_runf (list_eq(op =#))) [("",
	tac_ress  2,
	([ñ®],ñ®),
	[([ñ®],ñ®),([ñ®],ñ®)])];
store_mt_results mt_runf [
	("",
	tac_solve ,
	([],ñ®),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],ñ®),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];

