=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Z Predicate Calculus}
\TPPref{DS/FMU/IED/MDT041}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
rules and tactics for the Z predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 - 1.3]
First versions.
\item [Issue 1.5 (20th August 1992)]
Bug fixing.
\item [Issue 1.6 (9th September 1992)]
Added $z\_¶\_intro\_conv$ tests.
\item [Issue 1.7 (10th September 1992)]
Typo fixed, title corrected.
\item [Issue 1.8 (10th September 1992)]
Changes after comments.
\item [Issue 1.11,1.12 (29th October 1992)]
Changes due to parser changes and theory reorganisation.
\item [Issue 1.14 (12th November 1992)]
Changes after comments - proof context changes,
added $z\_µ\_tac$, etc, replaced $z\_defn\_conv$ by $z\_para\_pred\_conv$, etc, added $z\_decl\_pred\_conv$.
\item [Issue 1.16 (17th Novemember 1992)]
Added $z\_term\_of\_type$
\item [Issue 1.17 (25th Novemember 1992)]
Added $z\_term\_of\_type$.
\item [Issue 1.18 (1st December 1992)]
Changed treatment of ill-formed schemas as predicates in $z\-\_dec\-\_pred\-\_conv$.
\item [Issue 1.19 (2nd December 1992)]
Improved $U$ simplification.
\item [Issue 1.20, 7th December 1992] 
Fixing problems from changes to generic formals.
\item [Issue 1.21, 9th December 1992] 
Bug fixing.
\item[Issue 1.22 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.23 (18th December 1992)]
Added $z\_pred\_decl\_conv$.
\item[Issue 1.24 (14th January 1993)]
Added treatment of generic predicates.
\item[Issue 1.25 (20th January 1993)]
Lost $z\_strip\_tac$.
\item[Issue 1.26 (10th February 1993)]
Reacting to changes in proof contexts, et al.
\item[Issue 1.27 (15th February 1993)]
Added $z\_push\_consistency\_goal$.
\end{description}
\subsection{Changes Forecast}
None known.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD041}.
\subsection{Introduction}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD041}.
This consists of demonstrating at least the simpler uses of the 
functions in question.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP041} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
The testing could be more rigorous.
In particular, functions
=GFT
z_basic_prove_tac, z_basic_prove_conv,
z_fc_prove_tac, z_fc_prove_conv
=TEX
and proof context
=GFT
'z_fc
=TEX
are not tested.
Nor do we test error message 41016.
\section{TEST CASES}
The functions are tested in their order of presentation in the detailed design.
\section{PREAMBLE}
=SML
val use_thy = "z_sets";
open_theory use_thy; (* to access º *)
delete_theory "temp" handle _ => ();
new_theory "temp";
use_file "dtd013";
use_file "imp013";
init_mt_results();
(* set_flag("subgoal_package_quiet",true); *)
repeat drop_main_goal;
set_flag("check_is_z",true);
=TEX
We use the proof context
``z$\_$predicates''.
=SML
push_pc "z_predicates";
=TEX

=SML
fun Ûlist_eqİ (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
If two terms types are equal, break them apart until they differ.
=SML
fun Ûdiffer_whereİ itm1 itm2 = (
let	fun aux tm1 tm2 (App(f1,x1)) (App(f2,x2)) = (
		Value(force_value(aux f1 f2 (dest_simple_term f1) (dest_simple_term f2)))
		handle _ =>
		aux x1 x2 (dest_simple_term x1) (dest_simple_term x2))
	| aux tm1 tm2 (Const(nm1,ty1)) (Const(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (Var(nm1,ty1)) (Var(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (SimpleÌ(x1,b1)) (SimpleÌ(x2,b2)) = (
		if x1 =$ x2 
		then aux b1 b2 (dest_simple_term b1) (dest_simple_term b2)
		else Value(tm1,tm2))
	| aux tm1 tm2 _ _ = Value(tm1,tm2);
in
	aux itm1 itm2 (dest_simple_term itm1) (dest_simple_term itm2)
end);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun Ûtac_resİ tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_resİ tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_res1İ tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (rasms,gl) = top_goal()
		in
			(drop_main_goal();
			(rasms,gl))
		end);
=TEX
Now a function that returns the multiple goals for the case when a tactic causes multiple goals:
=SML
fun Ûtac_ressİ tac n (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val gll = map (top_labelled_goal o string_of_int)
			(interval 1 n)
		in
			(drop_main_goal();
			gll)
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun Ûtac_solveİ tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun Ûtac_failİ tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
The following tests $is\_z$, $not\_z\_subterms$,
$dest\-\_z\-\_term1$, $check\-\_is\-\_z\-\_thm$, $check\-\_is\-\_z\-\_goal$,
$check\-\_is\-\_z\-\_term$ together, on a pair of very similar
terms, except that one is Z and one not quite Z,
in a manner $dest\-\_z\-\_term$ doesn't notice.

The following utilities just give rise to lots of information
messages.
=SML
fun Ûtest_check_is_z_thmİ tm = (
let	val thm1 = refl_conv tm;
in
	(thm1 =|- check_is_z_thm "test" thm1)
end
handle _ => false);
fun Ûtest_check_is_z_goalİ tm = (
let	val gl1 = ([],mk_eq(tm, tm));
in
	(gl1 =# check_is_z_goal "test" gl1)
end
handle _ => false);
fun Ûtest_check_is_z_termİ tm = (
	(tm =$ check_is_z_term "test" tm)
handle _ => false);

fun Ûreally_zİ name tm1 tm2 =
store_mt_results mt_run [(name ^ " is_z y",
	(fn x => ((is_z x) handle _ => false)),
	tm1,
	true),
	(name ^ " is_z n",
	(fn x => ((is_z x) handle _ => false)),
	tm2,
	false),
	(name ^ " not_z_subterms []",
	(fn x => length x = 0) o not_z_subterms,
	tm1,
	true),
	(name ^ " not_z_subterms [1]",
	(fn x => length x = 1) o not_z_subterms,
	tm2,
	true),
	(name ^ " dest_z_term y",
	(fn x => ((dest_z_term x; true) handle _ => false)),
	tm1,
	true),
	(name ^ " dest_z_term n",
	(fn x => ((dest_z_term x; true) handle _ => false)),
	tm2,
	true),
	(name ^ " dest_z_term1 y",
	(fn x => ((dest_z_term1 x; true) handle _ => false)),
	tm1,
	true),
	(name ^ " dest_z_term1 n",
	(fn x => ((dest_z_term1 x; true) handle _ => false)),
	tm2,
	false),
	(name ^ " test_check_is_z_thm y",
	test_check_is_z_thm,
	tm1,
	true),
	(name ^ " test_check_is_z_thm n",
	test_check_is_z_thm,
	tm2,
	true),
	(name ^ " test_check_is_z_goal y",
	test_check_is_z_goal,
	tm1,
	true),
	(name ^ " test_check_is_z_goal n",
	test_check_is_z_goal,
	tm2,
	true),
	(name ^ " test_check_is_z_term y",
	test_check_is_z_term,
	tm1,
	true),
	(name ^ " test_check_is_z_term n",
	test_check_is_z_term,
	tm2,
	true)];
=TEX
\subsection{Some Useful Examples}
ÿTEST_SCHEMAü
x:U;
y:U
ˆ
=SML
val notz = ¬¶ x · x = y®;
val trues = string_of_term mk_t;
val notzs = string_of_term notz;
val xX = mk_var("x",”'X®);

=TEX
\section{TESTS}
\subsection{Checking For Z}
This is primarily done by $really\_z$.
=SML
val _ = diag_string
	"***There should now be a large number of ``In the result of...'' messages***";
=TEX
Note that ``$\#$'' precedes ``$'$'' in the variable sorting.
=SML
let
val tm = mk_z_schema_dec(ñ[z:X;x:Y;y:Z]®,"'");
val y' = nth 4 (frees tm);
val y'' = variant [y'] y';
val tm' = subst[(y'',y')] tm;
in
really_z "decsexp" tm tm'
end;
let
val tm = ñµ ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Zµ" tm tm'
end;
let
val tm = ñ¶ ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶" tm tm'
end;
let
val tm = ñ¶‰1 ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶‰1" tm tm'
end;
let
val Z¶(a,b,c) = dest_z_term ñ¶ ##, ### : X | ## = z · [##,### : X | true]®;
val tm = mk_z_¶‰s(a,b,ñ[##,### : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶‰s" tm tm'
end;
let
val Z¶(xa,xb,xc) = dest_z_term ñ¶ ##, ### : X | ## = z · [##,### : X | true]®;
val tm = mk_z_¶‰1‰s(xa,xb,ñ[##,### : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z¶‰1‰s" tm tm'
end;
let
val Z¶(xa,xb,xc) = dest_z_term ñ¶ ##, ### : X | ## = z · [##,### : X | true]®;
val tm = mk_z_µ‰s(xa,xb,ñ[##,### : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "µ‰s" tm tm'
end;
let
val tm1 = ñ[##,###:X | ## = z] ± true®;
val tm = fst(dest_z_± tm1);
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val x_ins' = mk_var("##'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
in
really_z "predsexp" tm tm'
end;
let
val tm = ñ{##, ### : X | ## = z}®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "seta" tm tm'
end;
let
val tm = ñÊ[##, ### : X | ## = z]®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val x_ins' = mk_var("##'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
in
really_z "Ê" tm tm'
end;
let
val tm = ñ Ì ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Ì" tm tm'
end;
let
val tm = ñ Í ##, ### : X · ## = z®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Í" tm tm'
end;
let
val tm = ñ [##,### : X | ## = z]®;
val z = hd(frees tm);
val x_ins = mk_var("##",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "decsexp1" tm tm'
end;

=TEX
=SML
val _ = diag_string
	"***The ``In the result of...'' messages should now cease***";
=TEX
But just to check the error messages:
=SML
val not_a_z_term = ¬Ì x · T®;
val not_a_z_term2 = ¬Ì x · F®;
val not_a_z_term_st = string_of_term not_a_z_term;
val not_a_z_type = ”'a LIST®;
val not_a_z_type_st = string_of_type not_a_z_type;
store_mt_results mt_run_fail [("dest_z_term1 41002",
	dest_z_term1,
	not_a_z_term,
	gen_fail_msg "dest_z_term1" 41002 [not_a_z_term_st])];
store_mt_results mt_run_fail [("is_z 41002",
	is_z,
	not_a_z_term,
	gen_fail_msg "is_z" 41002 [not_a_z_term_st])];
store_mt_results mt_run_fail [("is_all_z_type 41002",
	is_all_z_type,
	not_a_z_type,
	gen_fail_msg "is_all_z_type" 41003 [not_a_z_type_st])];
store_mt_results (mt_runf (list_eq(op =$))) 
	[("not_z_subterms",
	not_z_subterms,
	mk_eq(not_a_z_term,not_a_z_term2),
	[not_a_z_term2, not_a_z_term])];
=TEX
To test the quieting effect of $check\_is\_z$
=SML
val _ = (diag_string "Being Noisy";
	check_is_z_thm "test" (refl_conv not_a_z_term);
	check_is_z_goal "test" ([],mk_eq( not_a_z_term,not_a_z_term2));
	check_is_z_term "test" not_a_z_term;
	diag_string "Going Quiet";
	set_flag("check_is_z",false);
	check_is_z_thm "test" (refl_conv not_a_z_term);
	check_is_z_goal "test" ([],mk_eq(not_a_z_term,not_a_z_term2));
	check_is_z_term "test" not_a_z_term;
	diag_string "Back to Normal";
	set_flag("check_is_z",true)
);
=TEX	
\subsection{Representing HOL Types as Z Terms}
=SML
¹Z
[GS1, GS2]
°
=SML
val zt = z_term_of_type o type_of;
store_mt_results (mt_runf (op =$))  [
	("z_term_of_type 1", zt, ñGS1®, ñğ GS1®),
	("z_term_of_type 2", zt, ñGS1 ¸ GS2®, ñGS1 ª GS2®),
	("z_term_of_type 3", zt, ñGS1 ¸ GS2 ¸ GS1®, ñğ (GS1 ¸ GS2 ¸ GS1)®),
	("z_term_of_type 4", zt, ñ[a,b : GS1]®, ñğ [a,b : GS1]®),
	("z_term_of_type 5", zt, ¬[1;2]®, mk_u ”î LIST SET®)];

val zt = z_type_of;
store_mt_results (mt_runf (op =$))  [
	("z_type_of 1", zt, ñGS1®, ñğ GS1®),
	("z_type_of 2", zt, ñGS1 ¸ GS2®, ñGS1 ª GS2®),
	("z_type_of 3", zt, ñGS1 ¸ GS2 ¸ GS1®, ñğ (GS1 ¸ GS2 ¸ GS1)®),
	("z_type_of 4", zt, ñ[a,b : GS1]®, ñğ [a,b : GS1]®),
	("z_type_of 5", zt, ¬[1;2]®, mk_u ”î LIST SET®)];

=TEX	
\subsection{Adjustment after Á-conversion}
=SML
val _ = diag_string "Á_to_z NOT YET IMPLEMENTED";
val _ = diag_string "Á_to_z_conv NOT YET IMPLEMENTED";
=TEX
\subsection{Concerning The Universe}
=SML
fun Ûtest_z__u_convİ tm = (
let	val thm = z__u_conv tm;
	val (l,r) = dest_eq (concl thm);
in
	(l =$ tm) andalso (r =$ mk_t)
end);
=TEX
=SML
store_mt_results mt_run [
	("z__u_conv 1",
	test_z__u_conv,
	ñx  U®,
	true),
	("z__u_conv 2",
	test_z__u_conv,
	ñx € U®,
	true),
	("z__u_conv 3",
	test_z__u_conv,
	snd(dest_± ñtrue ± [a: U]®),
	true),
	("z__u_conv 4",
	test_z__u_conv,
	ñx  ğ U®,
	true),
	("z__u_conv 5",
	test_z__u_conv,
	ñx  ğ (U ¸ U)®,
	true),
	("z__u_conv 6",
	test_z__u_conv,
	ñx  {x:U; y: U}®,
	true),
	("z__u_conv 7",
	test_z__u_conv,
	ñx  ğ {x:U; y: U ¸ U}®,
	true),
	("z__u_conv 8",
	test_z__u_conv,
	ñx  [a ,b : U; c : U]®,
	true),
	("z__u_conv 10",
	test_z__u_conv,
	ñx  ğ (U ¸ U) ¸ [a ,b : U; c : U]®,
	true),
	("z__u_conv 11",
	test_z__u_conv,
	ñ{x,y} € ğ (U ¸ U) ¸ [a ,b : U; c : U]®,
	true),
	("z__u_conv 12",
	test_z__u_conv,
	snd(dest_±(ñtrue ± [a ,b : U ¸ [a ,b : U; c : U]; c : ğ U]®)),
	true),
	("z__u_conv 13",
	test_z__u_conv,
	ñx  {y:ğ U | true}®,
	true),
	("z__u_conv 14",
	test_z__u_conv,
	ñx  {x:ğ U | true}®,
	true),
	("z__u_conv 15",
	test_z__u_conv,
	ñx  [x:ğ U]®,
	true)
	];
=TEX
=SML
store_mt_results mt_run_fail [("z__u_conv 41062",
	z__u_conv,
	not_a_z_term,
	gen_fail_msg "z__u_conv" 41062 [not_a_z_term_st]),
	("z__u_conv 41061",
	z__u_conv,
	ñy  X®,
	gen_fail_msg "z__u_conv" 41061 [string_of_term ñy  X®])];
=TEX
Test out proof context fields:
=SML
delete_pc "temp" handle (Fail _) => ();
new_pc "temp";
set_u_simp_eqn_cxt (theory_u_simp_eqn_cxt "-") "temp";
store_mt_results mt_run_fail [
	("z__u_conv 41061 a",
	z__u_conv,
	ñy  GS1 ¸ ğ GS2®,
	gen_fail_msg "z__u_conv" 41061 [string_of_term ñy  GS1 ¸ ğ GS2®])];
push_pc "temp";
store_mt_results mt_run [
	("z__u_conv pc 1",
	test_z__u_conv,
	ñy  GS1 ¸ ğ GS2®,
	true)];
pop_pc();
store_mt_results mt_run [
	("get_u_simp_eqn_cxt 1",
	length o fst o hd o get_u_simp_eqn_cxt,
	"temp",
	2)];
delete_pc "temp";
new_pc "temp";
set_u_simp_eqn_cxt (u_simp_eqn_cxt [z_get_spec ñGS1®, z_get_spec ñGS2®]) "temp";
push_pc "temp";
store_mt_results mt_run [
	("z__u_conv pc 2",
	test_z__u_conv,
	ñy  GS1 ¸ ğ GS2®,
	true)];
store_mt_results mt_run [
	("get_u_simp_eqn_cxt 2",
	length o fst o hd o get_u_simp_eqn_cxt,
	"temp",
	2)];
pop_pc();
=TEX
Just to prove errors are being passed on:
=SML
store_mt_results mt_run_fail [
	("set_u_simp_eqn_cxt 51016",
	set_u_simp_eqn_cxt [],
	"initial",
	gen_fail_msg "set_u_simp_eqn_cxt" 51016 ["initial"])];
store_mt_results mt_run_fail [
	("get_u_simp_eqn_cxt 51010",
	get_u_simp_eqn_cxt,
	"rubbish",
	gen_fail_msg "get_u_simp_eqn_cxt" 51010 ["rubbish"])
	];
store_mt_results mt_run_fail [
	("theory_u_simp_eqn_cxt 6035",
	theory_u_simp_eqn_cxt,
	"rubbish",
	gen_fail_msg "theory_u_simp_eqn_cxt" 6035 ["rubbish"])
	];
=TEX
\subsection{Concerning Z Universal Quantification}
=SML
let
	val Ê = ñÊ TEST_SCHEMA®;
in
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim 1",
	concl o z_µ_elim ñ(x ¦ (q º a), y ¦ (r º b), z ¦ (p º a))®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g y z®),
	ñ(((q  X) ± (r  Y) ± (p  X)) ± f q) ´ (g r) p®),
	("z_µ_elim 2",
	concl o z_µ_elim ñ(x ¦ (q º a), y ¦ (r º b), z ¦ (p º a))®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	ñ(((q  X) ± (r  Y) ± (p  X)) ± f q) ´ (g ¬a + b®) p®),
	("z_µ_elim 3",
	concl o z_µ_elim ñSS º [x:a;y:b;z:a]®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  y z®),
	ñ((((SS º [x:a;y:b;z:a]).x  X) ± (SS.y  Y) ± (SS.z  X)) ± f SS.x)
	´ (g SS.y) SS.z®),
	("z_µ_elim 4",
	concl o z_µ_elim mk_t,
	(asm_ruleñµ x:BOOL · x®),
	ñ(true  BOOL ± true) ´ true®),
	("z_µ_elim 5",
	concl o z_µ_elim ñÊ (TEST_SCHEMA º ğ[x:X;y:Y])®,
	(asm_ruleñµ x:U;y: U· f x y®),
	ñ((((Ê (TEST_SCHEMA º ğ[x:X;y:Y])).x  U) ± 
		(Ê (TEST_SCHEMA º ğ[x:X;y:Y])).y  U) ±
		 true) ´ f (Ê (TEST_SCHEMA º ğ[x:X;y:Y])).x 
		(Ê (TEST_SCHEMA º ğ[x:X;y:Y])).y®)
	]
end;
=TEX
Ignore the single ``not in the Z language'' message from the above.
=SML
val mk_t_st = string_of_term mk_t;
val (xyz_decl,_,_) = dest_z_µ ñµ x:X; y:Y; z:X · true®;
store_mt_results mt_run_fail [
	("z_µ_elim 47310",
	z_µ_elim mk_t,
	t_thm,
	gen_fail_msg  "z_µ_elim" 47310 [mk_t_st]),
	("z_µ_elim 41021 a",
	z_µ_elim ñ(x ¦ (q º a), y ¦ (r º b))®,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg  "z_µ_elim" 41021 [
		string_of_term ñ(x ¦ (q º ğ a), y ¦ (r º ğ b))®,
		string_of_term xyz_decl]),
	("z_µ_elim 41021 b",
	z_µ_elim mk_t,
	(asm_ruleñµ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg  "z_µ_elim" 41021 [mk_t_st,
		string_of_term xyz_decl])
	];
=TEX
Notice how second test tests whether $z\_µ\_intro1$ leaks
declaration processing into predicate part.
=SML
let 
	val tm1 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z)) ± f x ´ g w y z®;
	val tm2 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z))  ´ g w y z®;
in
store_mt_results (mt_runf(op =$)) [
	("z_µ_intro1 1",
	concl o z_µ_intro1,
	(all_µ_elim (asm_rule(list_mk_µ(frees tm1, tm1)))),
	ñµ x:W; y:X; p,q:Y; z:Z | f x · g w y z®),
	("z_µ_intro1 2",
	concl o z_µ_intro1,
	(all_µ_elim (asm_rule(list_mk_µ(frees tm2, tm2)))),
	ñµ x : W; y : X | {p, q} € Y ± z  Z · g w y z®)
	]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("z_µ_intro1 41026",
	z_µ_intro1,
	t_thm,
	gen_fail_msg "z_µ_intro1" 41026 [string_of_thm t_thm]),
	("z_µ_intro1 41027",
	z_µ_intro1,
	asm_rule ñtrue ± true ´ true®,
	gen_fail_msg "z_µ_intro1" 41027 [mk_t_st]),
	("z_µ_intro1 6005",
	z_µ_intro1,
	asm_rule ñx  X ± true ´ true®,
	gen_fail_msg "z_µ_intro1" 6005 [string_of_term ñx®])
	];
=TEX
=SML
let 
	val tm1 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z)) ± f x ´ g w y z®;
	val tm2 = ñ((x  W ± y  X) ± ({p,q} € Y) ± (z  Z))  ´ g w y z®;
in
store_mt_results (mt_runf(op =$)) [
	("z_µ_intro 2",
	concl o z_µ_intro [¬x:'a®,¬y:'b®],
	prove_rule[] ñ(x = x) ´ (y = y)®,
	ñµ x:U; y:U | x = x · y = y®),
	("z_µ_intro 3",
	concl o z_µ_intro [¬x:'a®,¬y:'b®],
	prove_rule[] ñ(x = x) ± (y = y)®,
	ñµ x:U; y:U · (x = x) ± (y = y)®)
	]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("z_µ_intro 3007",
	z_µ_intro [mk_t],
	t_thm,
	gen_fail_msg "z_µ_intro" 3007 [mk_t_st]),
	("z_µ_intro 41028",
	z_µ_intro [],
	t_thm,
	gen_fail_msg "z_µ_intro" 41028 [string_of_thm t_thm]),
	("z_µ_intro 6005",
	z_µ_intro [xX],
	asm_rule (snd(strip_µ ñ[X] x  X ± true ´ true®)),
	gen_fail_msg "z_µ_intro" 6005 [string_of_term ñx®])
	];
=TEX
=SML
let val tm1 = ñµ x : X; y,z : Y | false · y = z®;
in
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv2/z_µ_intro_conv1",
	snd o dest_eq o concl o conv_rule(RIGHT_C z_µ_intro_conv1) o z_µ_elim_conv2,
	tm1,
	tm1)]
end;
=TEX
=SML
let
	val (adecl,_,_) = dest_z_µ ñµ x, y:X | false · true®;
in
store_mt_results mt_run_fail [
	("z_µ_elim_conv2 41022",
	z_µ_elim_conv2,
	mk_t,
	gen_fail_msg "z_µ_elim_conv2" 41022 [mk_t_st]),
	("z_µ_intro_conv1 41023",
	z_µ_intro_conv1,
	mk_t,
	gen_fail_msg "z_µ_intro_conv1" 41023 [mk_t_st]),
	("z_µ_intro_conv1 41024",
	z_µ_intro_conv1,
	¬µ x · ‘adecl® ± T ´ F®,
	gen_fail_msg "z_µ_intro_conv1" 41024 [string_of_term ¬µ x · ‘adecl® ± T ´ F®])
	]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv",
	snd o dest_eq o concl o z_µ_elim_conv,
	ñµ x, y : X · x= y®,	
	¬µ x y:'a · ñ{x,y} € X ± true ´ x = y®®)];
store_mt_results mt_run_fail [
	("z_µ_elim_conv 41022",
	z_µ_elim_conv,
	mk_t,
	gen_fail_msg "z_µ_elim_conv" 41022 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_elim_conv",
	snd o dest_eq o concl o z_¶_elim_conv,
	ñ¶ x, y : X · x= y®,	
	¬¶ x y:'a · ñ{x,y} € X ± true ± x = y®®)];
store_mt_results mt_run_fail [
	("z_¶_elim_conv 41022",
	z_¶_elim_conv,
	mk_t,
	gen_fail_msg "z_¶_elim_conv" 41044 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("all_z_µ_intro 1",
	concl o all_z_µ_intro,
	refl_conv ñ{x,y}®,
	ñµ x : U; y:U | true · {x,y} = {x,y}®),
	("all_z_µ_intro 2",
	concl o all_z_µ_intro,
	asm_rule ñx ± y®,
	ñx ± y®),
	("all_z_µ_intro 3",
	concl o all_z_µ_intro,
	refl_convñx®,
	ñµ x:U · x = x®)
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv1",
	snd o dest_eq o concl o z_µ_elim_conv1,
	ñµ x:U; y,z : U; [a,b:U ¸ U] | f · g®,
	¬µ a b :('c, 'd) $"Z'T[2]" · µ x:'a· µ y z :'b · f ´ g®)];
store_mt_results mt_run_fail [
	("z_µ_elim_conv1 41022",
	z_µ_elim_conv1,
	mk_t,
	gen_fail_msg "z_µ_elim_conv1" 41022 [mk_t_st]),
	("z_µ_elim_conv1 41071",
	z_µ_elim_conv1,
	ñµ x : X · false®,
	gen_fail_msg "z_µ_elim_conv1" 41071 [string_of_term ñµ x : X · false®])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_inv_conv 1",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x, y : X | f · g®,
	ñf ´ (µ x, y : X | true · false) ² g®),
	("z_µ_inv_conv 1b",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x : X | f · g®,
	ñf ´ (µ x : X | true · false) ² g®),
	("z_µ_inv_conv 2",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x, y : X | x > 0 · z®,
	ñ(µ x, y : X | x > 0 · false) ² z®),
	("z_µ_inv_conv 3",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x,y : X | f · x = y®,
	ñf ´ (µ x,y : X | true · x = y)®),
	("z_µ_inv_conv 4",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x,y : X · g®,
	ñ(µ x,y : X · false) ² g®),
	("z_µ_inv_conv 5",
	snd o dest_eq o concl o z_µ_inv_conv,
	ñµ x,y : X | f· false®,
	ñf ´ (µ x,y : X | true · false)®)
	];
store_mt_results mt_run_fail [
	("z_µ_inv_conv 47310",
	z_µ_inv_conv,
	mk_t,
	gen_fail_msg "z_µ_inv_conv" 47310 [mk_t_st]),
	("z_µ_inv_conv 41025",
	z_µ_inv_conv,
	ñµ x :X | f x · g x®,
	gen_fail_msg "z_µ_inv_conv" 41025 [
		string_of_term ñµ x : X | f x · g x®])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_intro_µ_tac 1",
	tac_res (z_intro_µ_tac ñ(x ¦ 1, y ¦ 2)®),
	ñ(1,2) = (3,4)®,
	ñµ x:U;y:U · (x,y) = (3,4)®)
	];
store_mt_results mt_run_fail [("z_intro_µ_tac 41029",
	tac_fail (z_intro_µ_tac mk_t),
	([],mk_t),
	gen_fail_msg "z_intro_µ_tac" 41029 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_tac",
	tac_res z_µ_tac,
	(snd(strip_µ ñ[X,Y] (µ x:X; y,z:Y | p x · y = z)®)),
	(snd(strip_µ ñ[X,Y] (x  X ± {y,z} € Y) ± p x ´ y = z®)))
	];
store_mt_results mt_run_fail [("z_µ_tac 41030",
	z_µ_tac,
	([],mk_t),
	gen_fail_msg "z_µ_tac" 41030 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [("z_spec_asm_tac",
	tac_res1 (z_spec_asm_tac ñµ x :U · x ± y® ñtrue®),
	([ñµ x :U · x ± y®],ñfalse®),
	([¬y:BOOL®, ñµ x : U · x ± y®],ñfalse®))];
store_mt_results (mt_runf (op =#)) [("z_spec_nth_asm_tac",
	tac_res1 (z_spec_nth_asm_tac 1 ñtrue®),
	([ñµ x :U · x ± y®],ñfalse®),
	([¬y:BOOL®, ñµ x : U · x ± y®],ñfalse®))];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_intro_conv",
	snd o dest_eq o concl o z_µ_intro_conv,
	¬µ x y · x = y®,
	ñµ x : U; y : U | true · x = y®)];
store_mt_results mt_run_fail [
	("z_µ_intro_conv 41047",
	z_µ_intro_conv,
	mk_t,
	gen_fail_msg "z_µ_intro_conv" 41047 [mk_t_st])];
=TEX
\subsection{Concerning Z Existential Quantification}
=SML
let val tm1 = ñ¶ x : X; y,z : Y | false · y = z®;
in
store_mt_results (mt_runf (op =$)) [
	("z_¶_elim_conv2/z_¶_intro_conv1",
	snd o dest_eq o concl o conv_rule(RIGHT_C z_¶_intro_conv1) o z_¶_elim_conv2,
	tm1,
	tm1)]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_intro_conv",
	snd o dest_eq o concl o z_¶_intro_conv,
	¬¶ x y · x = y®,
	ñ¶ x : U; y : U | true · x = y®)];
store_mt_results mt_run_fail [
	("z_¶_intro_conv 41046",
	z_¶_intro_conv,
	mk_t,
	gen_fail_msg "z_¶_intro_conv" 41046 [mk_t_st])];
=TEX
=SML
let
	val (adecl,_,_) = dest_z_¶ ñ¶ x, y:X | false · true®;
in
store_mt_results mt_run_fail [
	("z_¶_elim_conv2 41044",
	z_¶_elim_conv2,
	mk_t,
	gen_fail_msg "z_¶_elim_conv2" 41044 [mk_t_st]),
	("z_¶_intro_conv1 41045",
	z_¶_intro_conv1,
	mk_t,
	gen_fail_msg "z_¶_intro_conv1" 41045 [mk_t_st]),
	("z_¶_intro_conv1 41041",
	z_¶_intro_conv1,
	¬¶ x · ‘adecl® ± T ± F®,
	gen_fail_msg "z_¶_intro_conv1" 41041 [string_of_term ¬¶ x · ‘adecl® ± T ± F®])
	]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_elim_conv1",
	snd o dest_eq o concl o z_¶_elim_conv1,
	ñ¶ x:U; y,z : U; [a,b:U ¸ U] | f · g®,
	¬ ¶ a b :('c, 'd) $"Z'T[2]" · ¶ x:'a· ¶ y z :'b ·f ± g®)];
store_mt_results mt_run_fail [
	("z_¶_elim_conv1 41042",
	z_¶_elim_conv1,
	mk_t,
	gen_fail_msg "z_¶_elim_conv1" 41042 [mk_t_st]),
	("z_¶_elim_conv1 41043",
	z_¶_elim_conv1,
	ñ¶ x : X · false®,
	gen_fail_msg "z_¶_elim_conv1" 41043 [string_of_term ñ¶ x : X · false®])];
=TEX
\subsection{Concerning Z Unique Existential Quantification}

=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶‰1_conv 1",
	snd o dest_eq o concl o z_¶‰1_conv,
	ñ¶‰1 x : X | x = y · f x®,
	ñ¶ x : X | x = y ± f x · µ x' : X | x' = y ± f x' · x' = x®),
	("z_¶‰1_conv 2",
	snd o dest_eq o concl o z_¶‰1_conv,
	ñ¶‰1 x,y : X; z:Y | x = y · z = f x®,
	ñ(¶ x, y : X; z : Y
	 | (x = y)
	 ± (z = f x)
	 · µ x', y' : X; z' : Y
	| (x' = y') ± (z' = f x')
      · (x' = x) ± (y' = y) ± (z' = z))®),
	("z_¶‰1_conv 3",
	concl o z_¶‰1_conv,
	ñ¶‰1 [x,y : X; z:Y] | x = x' y y'' · z = f x®,
	(snd(strip_µ ñ[a,b,c](¶‰1 [x, y : (X ºğ a); z : (Y º ğ b)] | x = x' y (y''ºc) · z = f x)
    ¤ (¶ [x, y : (X ºğ a); z : (Y º ğ b)]
      | x = x' y (y''ºc) ± z = f x
      · ‘mk_z_µ(
		mk_z_decl[mk_z_schema_dec (ñ[x, y : (X ºğ a); z : (Y º ğ b)]®,"'''")],
		(snd(strip_µ ñ[a,b,c](x'''º a) = x' (y'''ºa) (y''ºc) ± (z'''ºb) = f x'''®)),
		(snd(strip_µ ñ[a,b,c](x'''º a) = x ± (y'''ºa) = y ± (z'''ºb) = z®)))®)®)))
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_¶‰1_tac",
	tac_res (z_¶‰1_tac ñ(x ¦ p, y ¦ q)º[x,y:X]®),
	(snd(strip_µ ñ[X] (¶‰1 x,y:X | r x · y = x)®)),
	(snd(strip_µ ñ[X] {p,q} € X ± (r p ± q = p) ±
		(µ x', y':X | r x' ± y' = x' · (x' = p ± y' = q))®)))
	];
store_mt_results mt_run_fail [
	("z_¶‰1_tac 41123",
	tac_fail (z_¶‰1_tac mk_t),
	([],ñtrue®),
	gen_fail_msg "z_¶‰1_tac" 41123 []),
	("z_¶‰1_tac 41021",
	tac_fail (z_¶‰1_tac mk_t),
	([],ñ¶‰1 x:X | x = 1 · true®),
	gen_fail_msg "z_¶‰1_tac" 41021 [mk_t_st,string_of_term (#1(dest_z_¶‰1 ñ¶‰1 x:X | x = 1 · true®))])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶‰1_intro_conv",
	snd o dest_eq o concl o z_¶‰1_intro_conv,
	¬¶‰1 x · x = y®,
	ñ¶‰1 x : U | true · x = y®)];
store_mt_results mt_run_fail [
	("z_¶‰1_intro_conv 41048",
	z_¶‰1_intro_conv,
	mk_t,
	gen_fail_msg "z_¶‰1_intro_conv" 41048 [mk_t_st])];
=TEX

=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_tac 1",
	tac_res (z_¶_tac mk_t),
	ñ¶ x : U· x ± y®,
	ñtrue  U ± true ± true ± y®),
	("z_¶_tac 2",
	tac_res (z_¶_tac ñ(x ¦ 1, y ¦ 2)®),
	ñ¶ x : U; y : U· (x,y) = (1,2)®,
	ñ(1  U ± 2  U) ± true ± (1,2) = (1,2)®)];

let
	val t = (mk_var("t", type_of ñ(x ¦ 1, y ¦ 2)®));
	val Ê = inst[] [(”ú®,”'a®), (”ú®,”'b®)] ñÊ TEST_SCHEMA®;
in
store_mt_results (mt_runf (op =$)) [
	("z_¶_tac 3",
	tac_res (z_¶_tac t),
	ñ¶ x : U; y : U· (x,y) = (1,2)®,
	ñ(‘t®.x  U ± ‘t®.y  U) ± true ± (‘t®.x, ‘t®.y) = (1,2)®),
	("z_¶_tac 4",
	tac_res (z_¶_tac ñÊ TEST_SCHEMA®),
	ñ¶ x : U; y : U· (x,y) = (1,2)®,
	ñ(‘Ê®.x  U ± ‘Ê®.y  U) ± true ± (‘Ê®.x, ‘Ê®.y) = (1,2)®)
	]
end;

=TEX
=SML
store_mt_results mt_run_fail [
	("z_¶_tac 47290",
	tac_fail (z_¶_tac mk_t),
	([],ñtrue®),
	gen_fail_msg "z_¶_tac" 47290 [mk_t_st]),
	("z_¶_tac 41021 a",
	tac_fail (z_¶_tac ñ(x ¦ (q º ğ a), y ¦ (r º ğ b))®),
	([],ñ¶ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg "z_¶_tac" 41021 [
		string_of_term ñ(x ¦ (q º ğ a), y ¦ (r º ğ b))®,
		string_of_term xyz_decl]),
	("z_¶_tac 41021 b",
	tac_fail (z_¶_tac mk_t),
	([],ñ¶ x:X; y:Y; z:X | f x · g  ¬a + b® z®),
	gen_fail_msg "z_¶_tac" 41021 [mk_t_st,
		string_of_term xyz_decl])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¶_inv_conv 1",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x, y : X | f · g®,
	ñf ± (¶ x, y : X | true · true) ± g®),
	("z_¶_inv_conv 1b",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x: X | f · g®,
	ñf ± (¶ x : X | true · true) ± g®),
	("z_¶_inv_conv 2",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x, y : X | x > 0 · z®,
	ñ(¶ x, y : X | x > 0 · true) ± z®),
	("z_¶_inv_conv 3",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x,y : X | f · x = y®,
	ñf ± (¶ x,y : X | true · x = y)®),
	("z_¶_inv_conv 4",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x,y : X · g®,
	ñ(¶ x,y : X · true) ± g®),
	("z_¶_inv_conv 5",
	snd o dest_eq o concl o z_¶_inv_conv,
	ñ¶ x,y : X | f· true®,
	ñf ± (¶ x,y : X | true · true)®)
	];
store_mt_results mt_run_fail [
	("z_¶_inv_conv 47290",
	z_¶_inv_conv,
	mk_t,
	gen_fail_msg "z_¶_inv_conv" 47290 [mk_t_st]),
	("z_¶_inv_conv 41040",
	z_¶_inv_conv,
	ñ¶ x : X | f x · g x®,
	gen_fail_msg "z_¶_inv_conv" 41040 [
		string_of_term ñ¶ x : X | f x · g x®])];
=TEX
\subsection{Conversions between Z Universal and Existential Quantifications}
The first of the following will fail with HOL version 1.97, but should not fail with later ones.
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_³_µ_conv 1",
	snd o dest_eq o concl o z_³_µ_conv,
	ñ³(µ x:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñ¶ x:X; y,z:Y; [a,b:U] | y = z · ³ a = b®),
	(
	"z_³_µ_conv 2",
	snd o dest_eq o concl o z_³_µ_conv,
	ñ³(µ xx:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñ¶ xx:X; y,z:Y; [a,b:U] | y = z · ³ a = b®)];
=TEX
The first of the following will fail with HOL version 1.97, but should not fail with later ones.
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_³_¶_conv 1",
	snd o dest_eq o concl o z_³_¶_conv,
	ñ³(¶ x:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñµ x:X; y,z:Y; [a,b:U] | y = z · ³ a = b®),
	("z_³_¶_conv 2",
	snd o dest_eq o concl o z_³_¶_conv,
	ñ³(¶ xx:X; y,z:Y; [a,b:U] | y = z · a = b)®,
	ñµ xx:X; y,z:Y; [a,b:U] | y = z · ³ a = b®)];
store_mt_results mt_run_fail [("z_³_µ_conv 41050",
	z_³_µ_conv,
	mk_t,
	gen_fail_msg "z_³_µ_conv" 41050 [mk_t_st]),
	("z_³_¶_conv 41051",
	z_³_¶_conv,
	mk_t,
	gen_fail_msg "z_³_¶_conv" 41051 [mk_t_st])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_³_in_conv 1",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(³ (x ± y))®,
	ñ(x ± y)®),
	("z_³_in_conv 2",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 ± t2)®,
	ñ³t1 ² ³t2®),
	("z_³_in_conv 3",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 ² t2)®,
	ñ³t1 ± ³t2®),
	("z_³_in_conv 4",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 ´ t2)®,
	ñt1 ± ³t2®),
	("z_³_in_conv 5",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³((x ± y) ¤ t2)®,
	ñ((x ± y) ± ³t2) ² (t2 ± ³(x ± y))®),
	("z_³_in_conv 6",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(t1 = t1)®,
	ñfalse®),
	("z_³_in_conv 7",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³(µ x:X | P· V)®,
	ñ¶ x:X | P· ³ V®),
	("z_³_in_conv 8",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³( ¶ x:X | P· V)®,
	ñµ x:X | P· ³ V®),
	("z_³_in_conv 9",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³ (¶‰1 x:X|P· V x)®,
	ñµx:X |P ± V x ·³ (µx':X |P ± V x' · x' = x)®), 
	("z_³_in_conv 10",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³ true®,
	ñfalse®),
	("z_³_in_conv 11",
	snd o dest_eq o concl o z_³_in_conv,
	ñ³ false®,
	ñtrue®)
	];
=TEX
=SML
store_mt_results mt_run_fail [(
	"z_³_in_conv 28131",
	z_³_in_conv,
	ñ³ x®,
	gen_fail_msg "z_³_in_conv" 28131 [string_of_term ñ³ x®]),
	("z_³_in_conv 47240",
	z_³_in_conv,
	mk_t,
	gen_fail_msg "z_³_in_conv" 47240 [mk_t_st])
	];
=TEX
\subsection{Conversions betweens Declarations and Predicates}
=SML
store_mt_results (mt_runf (op =$)) [
	("z_dec_pred_conv 1",
	snd o dest_eq o concl o z_dec_pred_conv,
	mk_z_dec([ñx®],¬X : 'a SET®),
	ñx  X®),
	("z_dec_pred_conv 2",
	snd o dest_eq o concl o z_dec_pred_conv,
	mk_z_dec([ñx®,ñy®],¬X : 'a SET®),
	ñ{x,y} € X®),
	("z_dec_pred_conv 3",
	snd o dest_eq o concl o z_dec_pred_conv,
	mk_z_schema_dec(ñ[x,y:X]®,""),
	mk_z_schema_pred(ñ[x,y:X]®,"")),
	("z_dec_pred_conv 4",
	snd o dest_eq o concl o z_dec_pred_conv,
	subst [(¬x1:'X®,¬x:'X®)]
	(mk_z_schema_dec((inst[][(”'X®,”'a®)] ñ[x,y:X]®),"")),
	(snd(strip_µ ñ[X] (x ¦ x1, y ¦ y)  [x,y:X]®)))
	];
store_mt_results mt_run_fail [(
	"z_dec_pred_conv 41010",
	z_dec_pred_conv,
	mk_t,
	gen_fail_msg "z_dec_pred_conv" 41010 [mk_t_st])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_decl_pred_conv 1",
	snd o dest_eq o concl o z_decl_pred_conv,
	mk_z_decl[mk_z_dec([ñx®],¬X : 'a SET®),
		mk_z_dec([ñx®,ñy®],¬X : 'a SET®),
		mk_z_schema_dec(ñ[x,y:X]®,"")],	
	list_mk_±[ñx  X®, ñ{x,y} € X®, mk_z_schema_pred(ñ[x,y:X]®,"")])];
store_mt_results mt_run_fail [(
	"z_decl_pred_conv 47912",
	z_decl_pred_conv,
	mk_t,
	gen_fail_msg "z_decl_pred_conv" 47912 [mk_t_st])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_pred_decl_conv 1",
	snd o dest_eq o concl o z_pred_decl_conv,
	list_mk_±[ñx  X®, ñ{x,y} € X®, mk_z_schema_pred(ñ[x,y:X]®,"")],	
	mk_z_decl[mk_z_dec([ñx®],¬X : 'a SET®),
		mk_z_dec([ñx®,ñy®],¬X : 'a SET®),
		mk_z_schema_dec(ñ[x,y:X]®,"")])];
store_mt_results mt_run_fail [(
	"z_pred_decl_conv 41011",
	z_pred_decl_conv,
	mk_t,
	gen_fail_msg "z_pred_decl_conv" 41011 [mk_t_st])
	];

=TEX
=SML
let
val (d,_,_) = dest_z_µñµ x:X; y,z:Y; [a,b:Z] · true®;
in
	store_mt_results (mt_runf (op =$)) [
	("Z_DECL_C",
	snd o dest_eq o concl o Z_DECL_C z_dec_pred_conv,
	d,
	ñx  X ± {y,z} € Y ± [a,b:Z]®)
	]
end;
store_mt_results mt_run_fail [(
	"Z_DECL_C 47912",
	Z_DECL_C z_dec_pred_conv,
	mk_t,
	gen_fail_msg "Z_DECL_C" 47912 [mk_t_st]),
	("Z_DECL_C 41012",
	Z_DECL_C z_dec_pred_conv,
	mk_z_decl[mk_t],
	gen_fail_msg "Z_DECL_C" 41012 [string_of_term (mk_z_decl[mk_t])])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_pred_dec_conv 1",
	snd o dest_eq o concl o z_pred_dec_conv,
	ñx  X®,
	mk_z_dec([ñx®],¬X : 'a SET®)),
	("z_pred_dec_conv 2",
	snd o dest_eq o concl o z_pred_dec_conv,
	ñ{x,y} € X®,
	mk_z_dec([ñx®,ñy®],¬X : 'a SET®)),
	("z_pred_dec_conv 3",
	snd o dest_eq o concl o z_pred_dec_conv,
	mk_z_schema_pred(ñ[x,y:X]®,""),
	mk_z_schema_dec(ñ[x,y:X]®,"")),
	("z_pred_dec_conv 4",
	snd o dest_eq o concl o z_pred_dec_conv,
	ñÊ[x, ### : X | x = z]  [x, ### : X | x = z]®,
	mk_z_schema_dec(ñ[x, ### : X | x = z]®,""))];
store_mt_results mt_run_fail [(
	"z_pred_dec_conv 41010",
	z_pred_dec_conv,
	mk_t,
	gen_fail_msg "z_pred_dec_conv" 41011 [mk_t_st]),
	("z_pred_dec_conv 41010 a",
	z_pred_dec_conv,
	ñ(x,y)  z®,
	gen_fail_msg "z_pred_dec_conv" 41011 [string_of_term ñ(x,y)  z®]),
	("z_pred_dec_conv 41010 b",
	z_pred_dec_conv,
	ñ{a} € z®,
	gen_fail_msg "z_pred_dec_conv" 41011 [string_of_term ñ{a} € z®]),
	("z_pred_dec_conv 41010 c",
	z_pred_dec_conv,
	ñ{a,1} € z®,
	gen_fail_msg "z_pred_dec_conv" 41011 [string_of_term ñ{a,1} € z®])
	];
=TEX
=SML
let
val (d,_,_) = dest_z_µñµ x:X; y,z:Y; [a,b:Z] · true®;
in
	store_mt_results (mt_runf (op =$)) [
	("Z_DECL_INTRO_C",
	snd o dest_eq o concl o Z_DECL_INTRO_C z_pred_dec_conv,
	ñx  X ± {y,z} € Y ± [a,b:Z]®,
	d)
	]
end;
store_mt_results mt_run_fail [(
	"Z_DECL_INTRO_C 41013",
	Z_DECL_INTRO_C z_dec_pred_conv,
	mk_t,
	gen_fail_msg "Z_DECL_INTRO_C" 41013 [mk_t_st]),
	("Z_DECL_INTRO_C 41014",
	Z_DECL_INTRO_C id_conv,
	mk_t,
	gen_fail_msg "Z_DECL_INTRO_C" 41014 [mk_t_st,mk_t_st])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z__setd_conv",
	snd o dest_eq o concl o z__setd_conv,
	mk_z_(ñ2®, ñ{1,2,3}®),
	ñ2 = 1 ² 2 = 2 ² 2 = 3®)];
store_mt_results mt_run_fail [("z__setd_conv 41015 a",
	z__setd_conv,
	mk_t,
	gen_fail_msg "z__setd_conv" 41015 [trues]),
	("z__setd_conv 41015 b",
	z__setd_conv,
	notz,
	gen_fail_msg "z__setd_conv" 41015 [notzs]),
	("z__setd_conv 41015 c",
	z__setd_conv,
	ñx   ¬Z'Setd (Cons h t)®®,
	gen_fail_msg "z__setd_conv" 41015
	   [string_of_term ñx   ¬Z'Setd (Cons h t)®®])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_setd_€_conv 1",
	snd o dest_eq o concl o z_setd_€_conv,
	ñ{} € ğ X®,
	ñtrue®),
	("z_setd_€_conv 2",
	snd o dest_eq o concl o z_setd_€_conv,
	ñ{x,y,z} € ğ X®,
	ñx  ğ X ± y  ğ X ± z  ğ X®),
	("z_setd_€_conv 3",
	snd o dest_eq o concl o z_setd_€_conv,
	ñ{f(ñx = x ´ y®),y} € (h(ñp = p ´ q®))®,
	ñf ¬y:BOOL®  h ¬q:BOOL® ± ¬y:BOOL®  h ¬q:BOOL®®)
	];
store_mt_results mt_run_fail [("z_setd_€_conv 41017",
	z_setd_€_conv,
	mk_t,
	gen_fail_msg "z_setd_€_conv" 41017 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_schema_pred_conv1",
	snd o dest_eq o concl o z_schema_pred_conv1,
	¬Z'SchemaPred ñ(x ¦ 1, y ¦ 2)® ñ[x,y:X| x =1]®®,
	ñ(x ¦ 1, y ¦ 2)  [x,y:X| x = 1]®)
	];
let
	val ok = snd(dest_±(ñtrue ± [x,y:X| x =1]®));
in
store_mt_results mt_run_fail [("z_schema_pred_conv1 41018 a",
	z_schema_pred_conv1,
	mk_t,
	gen_fail_msg "z_schema_pred_conv1" 41018 [trues]),
	("z_schema_pred_conv1 41018 b",
	z_schema_pred_conv1,
	ok,
	gen_fail_msg "z_schema_pred_conv1" 41018 [string_of_term ok])
	]
end;
=TEX
\subsection{Generic Predicates}
=SML
store_mt_results (mt_runf (op =$)) [("z_³_gen_pred_conv",
	snd o dest_eq o concl o z_³_gen_pred_conv,
	mk_³ ñ[X,Y,Z] (µ a:X;b:Y;c:Z · f a b c)®,
	inst [] [(”'X®,”'a®),(”'Y®,”'b®),(”'Z®,”'c®)]
	ñ(¶ X:U[¬Totality:'X SET®];Y:U[¬Totality:'Y SET®];Z:U[¬Totality:'Z SET®] · ³(µ a:X;b:Y;c:Z · f a b c))®)
	];
store_mt_results mt_run_fail [("z_³_gen_pred_conv 41031",
	z_³_gen_pred_conv,
	mk_t,
	gen_fail_msg "z_³_gen_pred_conv" 41031 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_gen_pred_intro",
	concl o z_gen_pred_intro [ñX®,ñY®],
	(refl_conv (snd(strip_µñ[X,Y] (µ x:X; y:Y · f x y)®))),
	ñ[X,Y] (µ x:X; y:Y · f x y) ¤ (µ x:X; y:Y · f x y)®)
	];
store_mt_results mt_run_fail [("z_gen_pred_intro 3007",
	z_gen_pred_intro [mk_t],
	t_thm,
	gen_fail_msg "z_gen_pred_intro" 3007 [trues]),
	("z_gen_pred_intro 6005",
	z_gen_pred_intro [ñX®],
	asm_rule (snd(strip_µñ[X] X = X®)),
	gen_fail_msg "z_gen_pred_intro" 6005 [string_of_term ñX®])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_gen_pred_elim",
	concl o z_gen_pred_elim [ñ{1}®,ñ{{1}}®],
	pc_rule1 "z_predicates" prove_rule [] 
		ñ[X,Y] (µ x:X; y:Y · f x y = f x y)®,
	ñµ x:{1};y:{{1}} · f x y = f x y®)
	];
=TEX
=SML
store_mt_results mt_run_fail [("z_gen_pred_elim 41033",
	z_gen_pred_elim [mk_t],
	asm_rule ñ[X] x = 1®,
	gen_fail_msg "z_gen_pred_elim" 41033 [string_of_thm (asm_rule ñ[X] x = 1®)]),
	("z_gen_pred_elim 41034",
	z_gen_pred_elim [mk_t],
	t_thm,
	gen_fail_msg "z_gen_pred_elim" 41034 [string_of_thm t_thm])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_gen_pred_tac",
	tac_res z_gen_pred_tac,
	ñ[X,Y] (µ x:X; y,z:Y | p x · y = z)®,
	(snd(strip_µ ñ[X,Y] (µ x:X; y,z:Y | p x · y = z)®)))
	];
store_mt_results mt_run_fail [
	("z_gen_pred_tac 41035",
	z_gen_pred_tac,
	([],mk_f),
	gen_fail_msg "z_gen_pred_tac" 41035 [])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_intro_gen_pred_tac",
	tac_res (z_intro_gen_pred_tac (map (fn x => (x,x)) 
		(fst(strip_µ ñ[X,Y] (µ x:X; y,z:Y | p x · y = z)®)))),
	(snd(strip_µ ñ[X,Y] (µ x:X; y,z:Y | p x · y = z)®)),
	ñ[X,Y] (µ x:X; y,z:Y | p x · y = z)®)	
	];
store_mt_results mt_run_fail [
	("z_intro_gen_pred_tac 41032",
	z_intro_gen_pred_tac[(¬p®,¬q®)],
	([],mk_f),
	gen_fail_msg "z_intro_gen_pred_tac" 41032 [string_of_term ¬q®]),
	("z_intro_gen_pred_tac 41036",
	z_intro_gen_pred_tac[(¬T®,¬X:'X SET®)],
	([],mk_f),
	gen_fail_msg "z_intro_gen_pred_tac" 41036 [string_of_term ¬X:'X SET®,string_of_term ¬T®]),
	("z_intro_gen_pred_tac 28082",
	z_intro_gen_pred_tac[(¬X:'X SET®,¬X:'X SET®)],
	([],mk_f),
	gen_fail_msg "z_intro_gen_pred_tac" 28082 [string_of_term ¬X:'X SET®]),
	("z_intro_gen_pred_tac 28083",
	z_intro_gen_pred_tac[(¬Y:'X SET®,¬X:'X SET®)],
	([],ñ[X] f X ¬Y:'X SET®®),
	gen_fail_msg "z_intro_gen_pred_tac" 28082 [string_of_term ¬Y:'X SET®,string_of_term ¬X:'X SET®])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("strip_tac-gf",
	tac_res (PC_T "z_predicates" strip_tac),
	mk_³ ñ[X,Y,Z] (µ a:X;b:Y;c:Z · f a b c)®,
	inst [] [(”'X®,”'a®),(”'Y®,”'b®),(”'Z®,”'c®)]
	ñ(¶ X:U[¬Totality:'X SET®];Y:U[¬Totality:'Y SET®];Z:U[¬Totality:'Z SET®] · ³(µ a:X;b:Y;c:Z · f a b c))®)
	];
=TEX
\section{Z REWRITING}
\subsection{Canonicalisation}
=SML
store_mt_results (mt_runf (op =$)) [("z_para_pred_canon",
	concl o hd o z_para_pred_canon,
	asm_rule ¬Z'AbbDef(µ X:'X SET; Y:'Y SET · ‘mk_±(
	mk_z_decl[mk_z_dec([¬x:'X®],¬X : 'X SET®),
		mk_z_dec([¬z:'X®,¬y:'X®],¬X : 'X SET®),
		mk_z_schema_dec((inst[][(”'Y®,”'a®)] ñ[p,q:Y]®),"")],
	(snd(strip_µ ñ[X,Y] (zºX) = y ± (p º Y) = q®)))®)®,
	ñ[X,Y] (x  X ± {z,y} € X ± [p,q:Y]) ± (z = y ± p = q)®)
];

store_mt_results mt_run_fail [(
	"z_para_pred_canon 41080",
	z_para_pred_canon,
	t_thm,
	gen_fail_msg "z_para_pred_canon" 41080 [string_of_thm t_thm])];
store_mt_results (mt_runf (op =$)) [("z_para_pred_conv",
	snd o dest_eq o concl o z_para_pred_conv,
	¬Z'AbbDef(µ X:'X SET; Y:'Y SET · ‘mk_±(
	mk_z_decl[mk_z_dec([¬x:'X®],¬X : 'X SET®),
		mk_z_dec([¬z:'X®,¬y:'X®],¬X : 'X SET®),
		mk_z_schema_dec((inst[][(”'Y®,”'a®)] ñ[p,q:Y]®),"")],
	(snd(strip_µ ñ[X,Y] (zºX) = y ± (p º Y) = q®)))®)®,
	ñ[X,Y] (x  X ± {z,y} € X ± [p,q:Y]) ± (z = y ± p = q)®)
];
store_mt_results mt_run_fail [(
	"z_para_pred_conv 41082",
	z_para_pred_conv,
	mk_t,
	gen_fail_msg "z_para_pred_conv" 41082 [mk_t_st])];

store_mt_results (mt_runf (op =$)) [("z_µ_rewrite_canon 1",
	concl o hd o z_µ_rewrite_canon,
	asm_rule (snd(strip_µ ñ[X] (µ x,y : U; z:X| f · x = y)®)),
	¬µ x y:'a · µ z:'X · ‘(snd(strip_µ ñ[X]({x,y} € U ± z  X) ± f ´ x = y®))®®)];
store_mt_results mt_run_fail [(
	"z_µ_rewrite_canon 41081",
	z_µ_rewrite_canon,
	t_thm,
	gen_fail_msg "z_µ_rewrite_canon" 41081 [string_of_thm t_thm])];
=TEX
=SML
let val combo = (z_µ_rewrite_canon THEN_CAN
	(REPEAT_CAN µ_rewrite_canon) THEN_CAN 
	z_´_rewrite_canon);
in
store_mt_results (mt_runf (op =$)) [("z_´_rewrite_canon 1",
	concl o hd o combo,
	asm_rule (snd(strip_µ ñ[X] (µ x,y : U; z:X| f · x = y)®)),
	(snd(strip_µ ñ[X] z  X ± f ´ x = y®))),
	("z_´_rewrite_canon 2",
	concl o hd o combo,
	asm_rule ñµ x,y :U;z:U | true · x = y®,
	ñx = y®),
	("z_´_rewrite_canon 3",
	concl o hd o combo,
	asm_rule (snd(strip_µ ñ[X,Y] (µ x,y :X;z:Y | true · x = y)®)),
	(snd(strip_µ ñ[X,Y] ({x,y} € X ± z  Y) ´ x = y®)))]
end;
store_mt_results mt_run_fail [(
	"z_´_rewrite_canon 41081",
	z_´_rewrite_canon,
	t_thm,
	gen_fail_msg "z_´_rewrite_canon" 41083 [string_of_thm t_thm]),
	(
	"z_´_rewrite_canon 41084",
	z_´_rewrite_canon,
	asm_rule ¬F ´ F®,
	gen_fail_msg "z_´_rewrite_canon" 41084 [string_of_thm (asm_rule ¬F ´ F®)])];
=TEX
=SML
store_mt_results (mt_runf (op =|-)) [
	("z_³_rewrite_canon 1",
	hd o z_³_rewrite_canon,
	asm_rule ñ³(t1 ² t2)®,
	conv_rule z_³_in_conv
		 (asm_rule ñ³(t1 ² t2)®)),
	("z_³_rewrite_canon 2",
	hd o z_³_rewrite_canon,
	asm_rule ñ³(¶ x : X | f · g)®,
	conv_rule z_³_in_conv
		 (asm_rule ñ³(¶ x : X | f · g)®)),
	("z_³_rewrite_canon 3",
	hd o z_³_rewrite_canon,
	asm_rule ñ³ (³ t)®,
	conv_rule z_³_in_conv
		 (asm_rule ñ³ (³ t)®)),
	("z_³_rewrite_canon 4",
	hd o z_³_rewrite_canon,
	asm_rule ñ³ t®,
	pure_rewrite_rule [taut_rule ¬µ x · ³ x ¤ x ¤ F®]
		 (asm_rule ñ³ t®))
	];

=SML
set_flag ("z_type_check_only", false);
set_flag ("z_use_axioms", true);
=TEX
=TEX
[X,Y]œ
ÜEx : ğ(X ¸ Y)
÷üüüü
ÜEx = {}
ˆüüüü
=SML
store_mt_results (mt_runf (op =$)) [("z_get_spec 1",
	concl o z_get_spec,
	ñEx®,
	concl (conv_rule z_para_pred_conv (get_axiom "-" "Ex"))),
	("z_get_spec 2",
	concl o z_get_spec,
	¬Append®,
	concl (get_spec ¬Append®))];
=TEX
=SML
store_mt_results mt_run_fail [
	("z_get_spec 46009",
	z_get_spec,
	¬rubbish®,
	gen_fail_msg "z_get_spec" 46009 [string_of_term ¬rubbish®]),
	("z_get_spec 46005",
	z_get_spec,
	(mk_const ("rubbish",BOOL)),
	gen_fail_msg "z_get_spec" 46005 ["rubbish"]),
	("z_get_spec 46006",
	z_get_spec,
	¬$´®,
	gen_fail_msg "z_get_spec" 46006 ["´"])
	];
=TEX
\subsection{Consistency Proofs}
=SML
val was_z_type_check_only = set_flag ("z_type_check_only", false);
val was_z_use_axioms = set_flag ("z_use_axioms", false);
push_pc "initial";
[X]œ
f1: (X ­ X) ­ X ­ X
÷
µ x:X; g:X ­ X · f1 g x =  g(g x)
ˆ
[X,Y]œ
f2: (X ª Y);
f3: (X ª Y)
÷
µ x:X; y:Y · (x,y)  f2 ¤ ³ (x,y)  f3
ˆ

¹ZAX
ff: (U ­ U) ­ U ­ U
÷
µ x:U; g:U ­ U · ff g x =  g(g x)
°

¹ZAX
ff2: (U ª U);
ff3: (U ª U)
÷
µ x:U; y:U · (x,y)  ff2 ¤ ³ (x,y)  ff3
°

¹HOLCONST
h : 'a ­ BOOL
÷
µ x :'a · h x = T
°
pop_pc ();
=TEX
=SML
val was_z_type_check_only = set_flag ("z_type_check_only", was_z_type_check_only);
val was_z_use_axioms = set_flag ("z_use_axioms", was_z_use_axioms);
=TEX
=SML
push_pc "hol";
¹HOLCONST
there : î
÷
there = 0
°
pop_pc();
=SML
fun test_pcg tm = (
let val s1 = z_push_consistency_goal tm;
	val (asms,cnc) = (top_goal());
	val tidy = drop_main_goal();
in
	if is_nil asms
	then cnc
	else fail "test_pcg-has asms" 0 []
end);
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_push_consistency_goal-no gf,1 const",
	test_pcg,
	ñff®,
	ñ¶ ff' : (U ­ U) ­ U ­ U
             · µ x : U; g : U ­ U · ff' g x = g (g x)®),
	("z_push_consistency_goal-no gf,2 consts",
	test_pcg,
	ñff2®,
	ñ¶ ff2' : U ª U; ff3' : U ª U
             · µ x : U; y : U
               · (x, y)  ff2' ¤ ³ (x, y)  ff3'®),
	("z_push_consistency_goal-1 gf,1 const",
	test_pcg,
	ñf1®,
	inst [] [(”'X®,”'c®)]
	ñ¶ f1' : U
             · µ X : U
               · ¬f1' ($"Z'Mk_T[1]" X)®  (X ­ X) ­ X ­ X
                 ± (µ x : X; g : X ­ X
                   · ¬f1' ($"Z'Mk_T[1]" X)® g x = g (g x))®),
	("z_push_consistency_goal-2 gf,2 consts",
	test_pcg,
	ñf3®,
	(inst [] [(”'Y®, ”'e®), (”'X®, ”'d®)]
	ñ¶ f3' : U; f2' : U
  	· µ X : U; Y : U
 	   · (¬f2' ñ(X, Y)®®  X ª Y
	      ± ¬f3' ñ(X, Y)®®  X ª Y)
	      ± (µ x : X; y : Y · (x, y)  ¬f2' ñ(X, Y)®® ¤ ³ (x, y)  ¬f3' ñ(X, Y)®®)®)),
	("z_push_consistency_goal-hol",
	test_pcg,
	¬h®,
	¬¶ h''· µ x· h'' x ¤ T®)
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("z_push_consistency_goal 46009",
	z_push_consistency_goal,
	¬rubbish®,
	gen_fail_msg "z_push_consistency_goal" 46009 ["ñrubbish®"]),
	("z_push_consistency_goal 46005",
	z_push_consistency_goal,
	mk_const("rubbish",BOOL),
	gen_fail_msg "z_push_consistency_goal" 46005 ["rubbish"]),
	("z_push_consistency_goal 46006",
	z_push_consistency_goal,
	¬$´®,
	gen_fail_msg "z_push_consistency_goal" 46006 ["´"]),
	("z_push_consistency_goal 46007",
	z_push_consistency_goal,
	¬there®,
	gen_fail_msg "z_push_consistency_goal" 46007 ["there"])
	];
=TEX


\section{Z STRIPPING AND PROOF CONTEXTS}
Incomplete tests, but certainly strongly hint at
some Z specific stuff:
=SML
repeat drop_main_goal;
push_pc "z_predicates";
store_mt_results (mt_runf (op =$)) [("z_predicates pc 1",
	tac_res (rewrite_tac[]),
	ñ(t = true) ± ³ (³ t1) ± (t2 = t2) ± true ± (false ´ t3) ± 
		(x  (U ¸ U)) ± (µ x : X · true) ± ³(¶ y : X · false) ² false®,
	ñt ± t1®)];
store_mt_results (mt_runf (op =#)) [("z_predicates pc 2",
	tac_res1 strip_tac,
	([],ñ(³(³ t) ± (µ x : U · x = x) ± (¶ x : U · f x) ± z  ğ U ± 
		(µ p:P | p · true)) ´ false®),
	([ñµ p : P | p · false®,
	  (snd(strip_µ ñ[b](f º ğ(b ¸ {true,false})) x®)),
	  ñµ x:U· x = x®, ¬t:BOOL®],ñfalse®))];
store_mt_results (mt_runf (op =#)) [("z_predicates pc 3",
	tac_res1 (REPEAT strip_tac),
	([],ñµ y : X · (³(³ t) ± (µ x : U · x = x) ± x  U)®),
	([ñy  X®],¬t:BOOL®))];
store_mt_results (mt_runf (op =#)) [("'z_decl pc 1",
	tac_res1 (REPEAT strip_tac),
	([],ñ(¶ x,y : X · x = y) ´ false®),
	([ñx = y®,ñy  X®,ñx  X®],ñfalse®))];
=TEX
Check everything is at least present:
=SML
push_pc "'z_predicates";
set_pc "'z_decl";
set_pc "'z_fc";
set_pc "z_predicates";
pop_pc();
=TEX
\section{BIT O'NONSENSE}
¹Z
rel	px _,py _, pz _
°
[X]
px _ : ğ X;
py _ : ğ X;
pz _ : ğ X
ˆ

ÿS[X]ü
x:X
÷
px x
ˆ
ÿI[X]ü
y:X
÷
py y
ˆ
ÿO[X]ü
z:X
÷
pz z
ˆ
ÿP[X]ü
z:X
÷
pz z
ˆ
=SML
push_goal([],ñ(¶[[S;S']; I;O] | p x x' y z· true) ¤
	(¶ S;S'; I;O | p x x' y z· true)®);
a(REPEAT strip_tac);
a(z_¶_tac ñÊ[[S;S']; I;O]®);
a(REPEAT strip_tac);
repeat drop_main_goal;
=TEX
\section{END OF TESTS}
=SML
(* set_flag("subgoal_package_quiet",false); *)
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results (mt_runf (op =$)) [("",
	tac_res ,
	ñ®,
	ñ®)];
store_mt_results (mt_runf (op =#)) [("",
	tac_res1 ,
	([ñ®],ñ®),
	([ñ®],ñ®))];
store_mt_results (mt_runf (list_eq(op =#))) [("",
	tac_ress  2,
	([ñ®],ñ®),
	[([ñ®],ñ®),([ñ®],ñ®)])];
store_mt_results mt_runf [
	("",
	tac_solve ,
	([],ñ®),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],ñ®),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];

