=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Tactics II}
\TPPref{DS/FMU/IED/MDT041}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
rules and tactics for the Z predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 - 1.3]
First versions.
\end{description}
\subsection{Changes Forecast}
None known.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD041}.
\subsection{Introduction}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD041}.
This consists of demonstrating at least the simpler uses of the 
functions in question.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP041} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
The testing could be more rigorous.
\section{TEST CASES}
The functions are tested in their order of presentation in the detailed design.
\section{PREAMBLE}
=SML
open_theory "z_predicate_calculus";
use_file "dtd013";
use_file "imp013";
init_mt_results();
(* set_flag("subgoal_package_quiet",true); *)
repeat drop_main_goal;
set_flag("check_is_z",true);
=TEX
We use the proof context
``z$\_$predicates''.
=SML
push_pc "z_predicates";
=TEX

=SML
fun €list_eq› (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
If two terms types are equal, break them apart until they differ.
=SML
fun €differ_where› itm1 itm2 = (
let	fun aux tm1 tm2 (App(f1,x1)) (App(f2,x2)) = (
		Value(force_value(aux f1 f2 (dest_simple_term f1) (dest_simple_term f2)))
		handle _ =>
		aux x1 x2 (dest_simple_term x1) (dest_simple_term x2))
	| aux tm1 tm2 (Const(nm1,ty1)) (Const(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (Var(nm1,ty1)) (Var(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (SimpleÃ(x1,b1)) (SimpleÃ(x2,b2)) = (
		if x1 =$ x2 
		then aux b1 b2 (dest_simple_term b1) (dest_simple_term b2)
		else Value(tm1,tm2))
	| aux tm1 tm2 _ _ = Value(tm1,tm2);
in
	aux itm1 itm2 (dest_simple_term itm1) (dest_simple_term itm2)
end);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun €tac_res› tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun €tac_res› tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun €tac_res1› tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (rasms,gl) = top_goal()
		in
			(drop_main_goal();
			(rasms,gl))
		end);
=TEX
Now a function that returns the multiple goals for the case when a tactic causes multiple goals:
=SML
fun €tac_ress› tac n (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val gll = map (top_labelled_goal o string_of_int)
			(interval 1 n)
		in
			(drop_main_goal();
			gll)
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun €tac_solve› tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun €tac_fail› tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
The following tests $is\_z$, $not\_z\_subterms$,
$full\-\_dest\-\_z\-\_term$, $check\-\_is\-\_z\-\_thm$, $check\-\_is\-\_z\-\_goal$,
$check\-\_is\-\_z\-\_term$ together, on a pair of very similar
terms, except that one is Z and one not quite Z,
in a manner $dest\-\_z\-\_term$ doesn't notice.

TRhe following utilities just give rise to lots of information
messages.
=SML
fun €test_check_is_z_thm› tm = (
let	val thm1 = refl_conv tm;
in
	(thm1 =|- check_is_z_thm "test" thm1)
end
handle _ => false);
fun €test_check_is_z_goal› tm = (
let	val gl1 = ([],mk_eq(tm, tm));
in
	(gl1 =# check_is_z_goal "test" gl1)
end
handle _ => false);
fun €test_check_is_z_term› tm = (
	(tm =$ check_is_z_term "test" tm)
handle _ => false);

fun €really_z› name tm1 tm2 =
store_mt_results mt_run [(name ^ " is_z y",
	(fn x => ((is_z x) handle _ => false)),
	tm1,
	true),
	(name ^ " is_z n",
	(fn x => ((is_z x) handle _ => false)),
	tm2,
	false),
	(name ^ " not_z_subterms []",
	(fn x => length x = 0) o not_z_subterms,
	tm1,
	true),
	(name ^ " not_z_subterms [1]",
	(fn x => length x = 1) o not_z_subterms,
	tm2,
	true),
	(name ^ " dest_z_term y",
	(fn x => ((dest_z_term x; true) handle _ => false)),
	tm1,
	true),
	(name ^ " dest_z_term n",
	(fn x => ((dest_z_term x; true) handle _ => false)),
	tm2,
	true),
	(name ^ " full_dest_z_term y",
	(fn x => ((full_dest_z_term x; true) handle _ => false)),
	tm1,
	true),
	(name ^ " full_dest_z_term n",
	(fn x => ((full_dest_z_term x; true) handle _ => false)),
	tm2,
	false),
	(name ^ " test_check_is_z_thm y",
	test_check_is_z_thm,
	tm1,
	true),
	(name ^ " test_check_is_z_thm n",
	test_check_is_z_thm,
	tm2,
	true),
	(name ^ " test_check_is_z_goal y",
	test_check_is_z_goal,
	tm1,
	true),
	(name ^ " test_check_is_z_goal n",
	test_check_is_z_goal,
	tm2,
	true),
	(name ^ " test_check_is_z_term y",
	test_check_is_z_term,
	tm1,
	true),
	(name ^ " test_check_is_z_term n",
	test_check_is_z_term,
	tm2,
	true)];
=TEX
\subsection{Some Useful Schemas}
ˇTEST_SCHEMA¸
x:U;
y:U
à
\section{TESTS}
\subsection{Checking For Z}
This is primarily done by $really\_z$.
=SML
val _ = diag_string
	"***There should now be a large number of ``In the result of...'' messages***";
=TEX
=SML
let
val tm = mk_z_decsexp(Ò[z:X;x:Y;y:Z]Æ,"'");
val y' = nth 4 (frees tm);
val y'' = variant [y'] y';
val tm' = subst[(y'',y')] tm;
in
really_z "decsexp" tm tm'
end;
let
val tm = Òµ x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Zµ" tm tm'
end;
let
val tm = Ò∂ x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z∂" tm tm'
end;
let
val tm = Ò∂â1 x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z∂â1" tm tm'
end;
let
val Z∂(a,b,c) = dest_z_term Ò∂ x, x! : X | x = z ∑ [x,x! : X | true]Æ;
val tm = mk_z_∂âs(a,b,Ò[x,x! : X | true]Æ);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z∂âs" tm tm'
end;
let
val Z∂(xa,xb,xc) = dest_z_term Ò∂ x, x! : X | x = z ∑ [x,x! : X | true]Æ;
val tm = mk_z_∂â1âs(xa,xb,Ò[x,x! : X | true]Æ);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Z∂â1âs" tm tm'
end;
let
val Z∂(xa,xb,xc) = dest_z_term Ò∂ x, x! : X | x = z ∑ [x,x! : X | true]Æ;
val tm = mk_z_µâs(xa,xb,Ò[x,x! : X | true]Æ);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "µâs" tm tm'
end;
let
val tm1 = Ò[x,x!:X | x = z] ± trueÆ;
val tm = fst(dest_z_± tm1);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val x_ins' = mk_var("x'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
in
really_z "predsexp" tm tm'
end;
let
val tm = Ò{x, x! : X | x = z}Æ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "seta" tm tm'
end;
let
val tm = Ò [x, x! : X | x = z]Æ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val x_ins' = mk_var("x'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
in
really_z " " tm tm'
end;
let
val tm = Ò Ã x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Ã" tm tm'
end;
let
val tm = Ò Õ x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "Õ" tm tm'
end;
let
val tm = Ò [x,x! : X | x = z]Æ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
in
really_z "decsexp1" tm tm'
end;

=TEX
=SML
val _ = diag_string
	"***The ``In the result of...'' messages should now cease***";
=TEX
But just to check the error messages:
=SML
val not_a_z_term = ¨Ã x ∑ TÆ;
val not_a_z_term2 = ¨Ã x ∑ FÆ;
val not_a_z_term_st = string_of_term not_a_z_term;
val not_a_z_type = î'a LISTÆ;
val not_a_z_type_st = string_of_type not_a_z_type;
store_mt_results mt_run_fail [("full_dest_z_term 41002",
	full_dest_z_term,
	not_a_z_term,
	gen_fail_msg "full_dest_z_term" 41002 [not_a_z_term_st])];
store_mt_results mt_run_fail [("is_z 41002",
	is_z,
	not_a_z_term,
	gen_fail_msg "is_z" 41002 [not_a_z_term_st])];
store_mt_results mt_run_fail [("is_all_z_type 41002",
	is_all_z_type,
	not_a_z_type,
	gen_fail_msg "is_all_z_type" 41003 [not_a_z_type_st])];
store_mt_results (mt_runf (list_eq(op =$))) 
	[("not_z_subterms",
	not_z_subterms,
	mk_eq(not_a_z_term,not_a_z_term2),
	[not_a_z_term2, not_a_z_term])];
=TEX
To test the quieting effect of $check\_is\_z$
=SML
val _ = (diag_string "Being Noisy";
	check_is_z_thm "test" (refl_conv not_a_z_term);
	check_is_z_goal "test" ([],mk_eq( not_a_z_term,not_a_z_term2));
	check_is_z_term "test" not_a_z_term;
	diag_string "Going Quiet";
	set_flag("check_is_z",false);
	check_is_z_thm "test" (refl_conv not_a_z_term);
	check_is_z_goal "test" ([],mk_eq(not_a_z_term,not_a_z_term2));
	check_is_z_term "test" not_a_z_term;
	diag_string "Back to Normal";
	set_flag("check_is_z",true)
);
=TEX	
\subsection{Adjustment after ¡-conversion}
=SML
val _ = diag_string "¡_to_z NOT YET IMPLEMENTED";
val _ = diag_string "¡_to_z_conv NOT YET IMPLEMENTED";
=TEX
\subsection{Convcerning The Universe}
=SML
fun €test_u_conv› tm = (
let	val thm = u_conv tm;
	val (l,r) = dest_eq (concl thm);
in
	(l =$ tm) andalso (term_match r ÒUÆ;true)
end);
=TEX
=SML
store_mt_results mt_run [
	("u_conv 1",
	test_u_conv,
	ÒU ∏ UÆ,
	true),
	("u_conv 2",
	test_u_conv,
	ÒU ∏ U ∏ U ∏ UÆ,
	true),
	("u_conv 3",
	test_u_conv,
	Ò UÆ,
	true),
	("u_conv 4",
	test_u_conv,
	Ò{l1 : U; l2,l3 : U; l4,l5,l6 : U}Æ,
	true),
	("u_conv 5",
	test_u_conv,
	Ò[l1 : U; l2,l3 : U; l4,l5,l6 : U]Æ,
	true),
	("u_conv 6",
	test_u_conv,
	ÒU ™ UÆ,
	true)
	];
store_mt_results mt_run_fail [("u_conv 41060",
	u_conv,
	not_a_z_term,
	gen_fail_msg "u_conv" 41060 [not_a_z_term_st])];

=TEX
=SML
fun €test_ç_u_conv› tm = (
let	val thm = ç_u_conv tm;
	val (l,r) = dest_eq (concl thm);
in
	(l =$ tm) andalso (r =$ mk_t)
end);
=TEX
=SML
store_mt_results mt_run [
	("ç_u_conv 1",
	test_ç_u_conv,
	Òx ç UÆ,
	true),
	("ç_u_conv 2",
	test_ç_u_conv,
	Òx Ä UÆ,
	true),
	("ç_u_conv 3",
	test_ç_u_conv,
	snd(dest_± Òtrue ± [a: U]Æ),
	true),
	("ç_u_conv 4",
	test_ç_u_conv,
	Òx ç  UÆ,
	true),
	("ç_u_conv 5",
	test_ç_u_conv,
	Òx ç  (U ∏ U)Æ,
	true),
	("ç_u_conv 6",
	test_ç_u_conv,
	Òx ç {x:U; y: U}Æ,
	true),
	("ç_u_conv 7",
	test_ç_u_conv,
	Òx ç  {x:U; y: U ∏ U}Æ,
	true),
	("ç_u_conv 8",
	test_ç_u_conv,
	Òx ç [a ,b : U; c : U]Æ,
	true),
	("ç_u_conv 9",
	test_ç_u_conv,
	Òx ç U ™ UÆ,
	true),
	("ç_u_conv 10",
	test_ç_u_conv,
	Òx ç  (U ∏ U) ™ [a ,b : U; c : U]Æ,
	true),
	("ç_u_conv 11",
	test_ç_u_conv,
	Ò{x,y} Ä  (U ∏ U) ™ [a ,b : U; c : U]Æ,
	true),
	("ç_u_conv 12",
	test_ç_u_conv,
	snd(dest_±(Òtrue ± [a ,b : U ∏ [a ,b : U; c : U]; c :  U]Æ)),
	true)
	];
=TEX
=SML
store_mt_results mt_run_fail [("ç_u_conv 41062",
	ç_u_conv,
	not_a_z_term,
	gen_fail_msg "ç_u_conv" 41062 [not_a_z_term_st]),
	("ç_u_conv 41061",
	ç_u_conv,
	Òy ç XÆ,
	gen_fail_msg "ç_u_conv" 41061 [string_of_term Òy ç XÆ])];
=TEX
\subsection{Concerning Z Universal Quantification}
=SML
let
	val S = (mk_var("S",type_of Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ, z ¶ ¨p:'aÆ)Æ));
	val   = Ò  TEST_SCHEMAÆ;
in
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim 1",
	concl o z_µ_elim Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ, z ¶ ¨p:'aÆ)Æ,
	(asm_ruleÒµ x:X; y:Y; z:X | f x ∑ g y zÆ),
	Ò(((q ç X) ± (r ç Y) ± (p ç X)) ± f q) ¥ (g r) pÆ),
	("z_µ_elim 2",
	concl o z_µ_elim Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ, z ¶ ¨p:'aÆ)Æ,
	(asm_ruleÒµ x:X; y:Y; z:X | f x ∑ g  ¨a + bÆ zÆ),
	Ò(((q ç X) ± (r ç Y) ± (p ç X)) ± f q) ¥ (g ¨a + bÆ) pÆ),
	("z_µ_elim 3",
	concl o z_µ_elim S,
	(asm_ruleÒµ x:X; y:Y; z:X | f x ∑ g  y zÆ),
	Ò(((ëSÆ.x ç X) ± (ëSÆ.y ç Y) ± (ëSÆ.z ç X)) ± f ëSÆ.x)
	¥ (g ëSÆ.y) ëSÆ.zÆ),
	("z_µ_elim 4",
	concl o z_µ_elim mk_t,
	(asm_ruleÒµ x:BOOL ∑ xÆ),
	Ò(true ç BOOL ± true) ¥ trueÆ),
	("z_µ_elim 5",
	concl o z_µ_elim Ò  TEST_SCHEMAÆ,
	(asm_ruleÒµ x:U;y: U∑ f x yÆ),
	Ò(((ë Æ.x ç U) ± ë Æ.y ç U) ± true) ¥ f ë Æ.x ë Æ.yÆ)
	]
end;
=TEX
Ignore the single ``not in the Z language'' message from the above.
=SML
val mk_t_st = string_of_term mk_t;
val (xyz_decl,_,_) = dest_z_µ Òµ x:X; y:Y; z:X ∑ trueÆ;
store_mt_results mt_run_fail [
	("z_µ_elim 47310",
	z_µ_elim mk_t,
	t_thm,
	gen_fail_msg  "z_µ_elim" 47310 [mk_t_st]),
	("z_µ_elim 41021 a",
	z_µ_elim Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ)Æ,
	(asm_ruleÒµ x:X; y:Y; z:X | f x ∑ g  ¨a + bÆ zÆ),
	gen_fail_msg  "z_µ_elim" 41021 [
		string_of_term Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ)Æ,
		string_of_term xyz_decl]),
	("z_µ_elim 41021 b",
	z_µ_elim mk_t,
	(asm_ruleÒµ x:X; y:Y; z:X | f x ∑ g  ¨a + bÆ zÆ),
	gen_fail_msg  "z_µ_elim" 41021 [mk_t_st,
		string_of_term xyz_decl])
	];
=TEX
=SML
let 
	val tm1 = Ò((x ç W ± y ç X) ± ({p,q} Ä Y) ± (z ç Z)) ± f x ¥ g w y zÆ;
	val tm2 = Ò((x ç W ± y ç X) ± ({p,q} Ä Y) ± (z ç Z))  ¥ g w y zÆ;
in
store_mt_results (mt_runf(op =$)) [
	("z_µ_intro 1",
	concl o z_µ_intro,
	(all_µ_elim (asm_rule(list_mk_µ(frees tm1, tm1)))),
	Òµ x:W; y:X; p,q:Y; z:Z | f x ∑ g w y zÆ),
	("z_µ_intro 2",
	concl o z_µ_intro,
	(all_µ_elim (asm_rule(list_mk_µ(frees tm2, tm2)))),
	Òµ x:W; y:X; p,q:Y; z:Z | true ∑ g w y zÆ)
	]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("z_µ_intro 41026",
	z_µ_intro,
	t_thm,
	gen_fail_msg "z_µ_intro" 41026 [string_of_thm t_thm]),
	("z_µ_intro 41027",
	z_µ_intro,
	asm_rule Òtrue ± true ¥ trueÆ,
	gen_fail_msg "z_µ_intro" 41027 [mk_t_st]),
	("z_µ_intro 6005",
	z_µ_intro,
	asm_rule Òx ç X ± true ¥ trueÆ,
	gen_fail_msg "z_µ_intro" 6005 [string_of_term ÒxÆ])
	];
=TEX
=SML
let 
	val tm1 = Ò((x ç W ± y ç X) ± ({p,q} Ä Y) ± (z ç Z)) ± f x ¥ g w y zÆ;
	val tm2 = Ò((x ç W ± y ç X) ± ({p,q} Ä Y) ± (z ç Z))  ¥ g w y zÆ;
in
store_mt_results (mt_runf(op =$)) [
	("z_µ_intro1 1",
	concl o z_µ_intro1 [],
	(all_µ_elim (asm_rule(list_mk_µ(frees tm1, tm1)))),
	Òµ x:W; y:X; p,q:Y; z:Z | f x ∑ g w y zÆ),
	("z_µ_intro1 2",
	concl o z_µ_intro1 [¨x:'aÆ,¨y:'bÆ],
	taut_rule Òfalse ¥ trueÆ,
	Òµ x:U; y:U | false ∑ trueÆ),
	("z_µ_intro1 3",
	concl o z_µ_intro1 [¨x:'aÆ,¨y:'bÆ],
	t_thm,
	Òµ x:U; y:U ∑ trueÆ)
	]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("z_µ_intro1 3007",
	z_µ_intro1 [mk_t],
	t_thm,
	gen_fail_msg "z_µ_intro1" 3007 [mk_t_st]),
	("z_µ_intro1 41028",
	z_µ_intro1 [],
	t_thm,
	gen_fail_msg "z_µ_intro1" 41028 [string_of_thm t_thm]),
	("z_µ_intro1 41027",
	z_µ_intro1 [],
	asm_rule Òtrue ± true ¥ trueÆ,
	gen_fail_msg "z_µ_intro1" 41027 [mk_t_st]),
	("z_µ_intro1 6005",
	z_µ_intro1 [],
	asm_rule Òx ç X ± true ¥ trueÆ,
	gen_fail_msg "z_µ_intro1" 6005 [string_of_term ÒxÆ])
	];
=TEX
=SML
let val tm1 = Òµ x : X; y,z : Y | false ∑ y = zÆ;
in
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv/z_µ_intro_conv",
	snd o dest_eq o concl o conv_rule(RIGHT_C z_µ_intro_conv) o z_µ_elim_conv,
	tm1,
	tm1)]
end;
=TEX
=SML
let
	val (adecl,_,_) = dest_z_µ Òµ x, y:X | false ∑ trueÆ;
in
store_mt_results mt_run_fail [
	("z_µ_elim_conv 41022",
	z_µ_elim_conv,
	mk_t,
	gen_fail_msg "z_µ_elim_conv" 41022 [mk_t_st]),
	("z_µ_intro_conv 41023",
	z_µ_intro_conv,
	mk_t,
	gen_fail_msg "z_µ_intro_conv" 41023 [mk_t_st]),
	("z_µ_intro_conv 41024",
	z_µ_intro_conv,
	¨µ x ∑ ëadeclÆ ± T ¥ FÆ,
	gen_fail_msg "z_µ_intro_conv" 41024 [string_of_term ¨µ x ∑ ëadeclÆ ± T ¥ FÆ])
	]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("all_z_µ_intro 1",
	concl o all_z_µ_intro,
	refl_conv Ò{x,y}Æ,
	Òµ x : U; y:U | true ∑ {x,y} = {x,y}Æ),
	("all_z_µ_intro 2",
	concl o all_z_µ_intro,
	asm_rule Òx ± yÆ,
	Òx ± yÆ),
	("all_z_µ_intro 3",
	concl o all_z_µ_intro,
	refl_conv¨xÆ,
	Òµ x:U ∑ x = xÆ)
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_elim_conv1",
	snd o dest_eq o concl o z_µ_elim_conv1,
	Òµ x:U; y,z : U; [a,b:U ∏ U] | f ∑ gÆ,
	¨µ a b :('c, 'd) $"Z'T[2]" ∑ µ x:'a∑ µ y z :'b ∑ f ¥ gÆ)];
store_mt_results mt_run_fail [
	("z_µ_elim_conv1 41022",
	z_µ_elim_conv1,
	mk_t,
	gen_fail_msg "z_µ_elim_conv1" 41022 [mk_t_st]),
	("z_µ_elim_conv1 41071",
	z_µ_elim_conv1,
	Òµ x : X ∑ falseÆ,
	gen_fail_msg "z_µ_elim_conv1" 41071 [string_of_term Òµ x : X ∑ falseÆ])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_inv_conv 1",
	snd o dest_eq o concl o z_µ_inv_conv,
	Òµ x, y : X | f ∑ gÆ,
	Òf ¥ (µ x, y : X | true ∑ false) ≤ gÆ),
	("z_µ_inv_conv 1b",
	snd o dest_eq o concl o z_µ_inv_conv,
	Òµ x : X | f ∑ gÆ,
	Òf ¥ (µ x : X | true ∑ false) ≤ gÆ),
	("z_µ_inv_conv 2",
	snd o dest_eq o concl o z_µ_inv_conv,
	Òµ x, y : X | x > 0 ∑ zÆ,
	Ò(µ x, y : X | x > 0 ∑ false) ≤ zÆ),
	("z_µ_inv_conv 3",
	snd o dest_eq o concl o z_µ_inv_conv,
	Òµ x,y : X | f ∑ x = yÆ,
	Òf ¥ (µ x,y : X | true ∑ x = y)Æ),
	("z_µ_inv_conv 4",
	snd o dest_eq o concl o z_µ_inv_conv,
	Òµ x,y : X ∑ gÆ,
	Ò(µ x,y : X ∑ false) ≤ gÆ),
	("z_µ_inv_conv 5",
	snd o dest_eq o concl o z_µ_inv_conv,
	Òµ x,y : X | f∑ falseÆ,
	Òf ¥ (µ x,y : X | true ∑ false)Æ)
	];
store_mt_results mt_run_fail [
	("z_µ_inv_conv 47310",
	z_µ_inv_conv,
	mk_t,
	gen_fail_msg "z_µ_inv_conv" 47310 [mk_t_st]),
	("z_µ_inv_conv 41025",
	z_µ_inv_conv,
	Òµ x :X | f x ∑ g xÆ,
	gen_fail_msg "z_µ_inv_conv" 41025 [
		string_of_term Òµ x : X | f x ∑ g xÆ])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_µ_intro_tac 1",
	tac_res (z_µ_intro_tac Ò(x ¶ 1, y ¶ 2)Æ),
	Ò1 + 2 = 3Æ,
	Òµ x:U;y:U ∑ x + y = 3Æ)
	];

=TEX
=SML
store_mt_results mt_run_fail [("z_µ_intro_tac 41029",
	z_µ_intro_tac,
	mk_t,
	gen_fail_msg "z_µ_intro_tac" 41029 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [("z_spec_asm_tac",
	tac_res1 (z_spec_asm_tac Òµ x :U ∑ x ± yÆ ÒtrueÆ),
	([Òµ x :U ∑ x ± yÆ],ÒfalseÆ),
	([Ò(true ç U ± true) ¥ (true ± y)Æ,Òµ x :U ∑ x ± yÆ],ÒfalseÆ))];
store_mt_results (mt_runf (op =#)) [("z_spec_nth_asm_tac",
	tac_res1 (z_spec_nth_asm_tac 1 ÒtrueÆ),
	([Òµ x :U ∑ x ± yÆ],ÒfalseÆ),
	([Ò(true ç U ± true) ¥ (true ± y)Æ,Òµ x :U ∑ x ± yÆ],ÒfalseÆ))];
=TEX
\subsection{Concerning Z Existential Quantification}
=SML
let val tm1 = Ò∂ x : X; y,z : Y | false ∑ y = zÆ;
in
store_mt_results (mt_runf (op =$)) [
	("z_∂_elim_conv/z_∂_intro_conv",
	snd o dest_eq o concl o conv_rule(RIGHT_C z_∂_intro_conv) o z_∂_elim_conv,
	tm1,
	tm1)]
end;
=TEX
=SML
let
	val (adecl,_,_) = dest_z_∂ Ò∂ x, y:X | false ∑ trueÆ;
in
store_mt_results mt_run_fail [
	("z_∂_elim_conv 41044",
	z_∂_elim_conv,
	mk_t,
	gen_fail_msg "z_∂_elim_conv" 41044 [mk_t_st]),
	("z_∂_intro_conv 41045",
	z_∂_intro_conv,
	mk_t,
	gen_fail_msg "z_∂_intro_conv" 41045 [mk_t_st]),
	("z_∂_intro_conv 41041",
	z_∂_intro_conv,
	¨∂ x ∑ ëadeclÆ ± T ± FÆ,
	gen_fail_msg "z_∂_intro_conv" 41041 [string_of_term ¨∂ x ∑ ëadeclÆ ± T ± FÆ])
	]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_∂_elim_conv1",
	snd o dest_eq o concl o z_∂_elim_conv1,
	Ò∂ x:U; y,z : U; [a,b:U ∏ U] | f ∑ gÆ,
	¨ ∂ a b :('c, 'd) $"Z'T[2]" ∑ ∂ x:'a∑ ∂ y z :'b ∑f ± gÆ)];
store_mt_results mt_run_fail [
	("z_∂_elim_conv1 41042",
	z_∂_elim_conv1,
	mk_t,
	gen_fail_msg "z_∂_elim_conv1" 41042 [mk_t_st]),
	("z_∂_elim_conv1 41043",
	z_∂_elim_conv1,
	Ò∂ x : X ∑ falseÆ,
	gen_fail_msg "z_∂_elim_conv1" 41043 [string_of_term Ò∂ x : X ∑ falseÆ])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_∂â1_conv 1",
	snd o dest_eq o concl o z_∂â1_conv,
	Ò∂â1 x : X | x = y ∑ f xÆ,
	Ò∂ x : X | x = y ± f x ∑ µ x' : X | x' = y ± f x' ∑ x' = xÆ),
	("z_∂â1_conv 2",
	snd o dest_eq o concl o z_∂â1_conv,
	Ò∂â1 x,y : X; z:Y | x = y ∑ z = f xÆ,
	Ò(∂ x, y : X; z : Y
	 | (x = y)
	 ± (z = f x)
	 ∑ µ x', y' : X; z' : Y
	| (x' = y') ± (z' = f x')
      ∑ (x' = x) ± (y' = y) ± (z' = z))Æ),
	("z_∂â1_conv 3",
	snd o dest_eq o concl o z_∂â1_conv,
	Ò∂â1 [x,y : X; z:Y] | x = x' y y'' ∑ z = f xÆ,
	Ò∂ [x, y : X; z : Y | true]
	| (x = ¨x':('a, ('c, 'a) $"Z'T[2]" SET) $"Z'T[2]" SETÆ y y'')
	± (z = ¨f:('a, 'b) $"Z'T[2]" SETÆ x)
	∑ ëmk_z_µ(
		mk_z_decl [mk_z_decsexp(
		mk_z_âs((#1 (dest_z_µÒµ x, y : X; z : Y ∑ trueÆ)),ÒtrueÆ),"'''")],
	  Ò(x''' = x' ¨y''':'aÆ ¨y'':'cÆ)
	  ± (¨z''':'bÆ = ¨f:('a, 'b) $"Z'T[2]" SETÆ x''')Æ,
	  Ò(¨x''':'aÆ = x) ± (¨y''':'aÆ = y) ± (¨z''':'bÆ = z)Æ)ÆÆ)
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_∂_tac 1",
	tac_res (z_∂_tac mk_t),
	Ò∂ x : U∑ x ± yÆ,
	Òtrue ç U ± true ± true ± yÆ),
	("z_∂_tac 2",
	tac_res (z_∂_tac Ò(x ¶ 1, y ¶ 2)Æ),
	Ò∂ x : U; y : U∑ x + y = 3Æ,
	Ò(1 ç U ± 2 ç U) ± true ± 1 + 2 = 3Æ)];

let
	val t = (mk_var("t", type_of Ò(x ¶ 1, y ¶ 2)Æ));
	val   = inst[] [(î˙Æ,î'aÆ), (î˙Æ,î'bÆ)] Ò  TEST_SCHEMAÆ;
in
store_mt_results (mt_runf (op =$)) [
	("z_∂_tac 3",
	tac_res (z_∂_tac t),
	Ò∂ x : U; y : U∑ x + y = 3Æ,
	Ò(ëtÆ.x ç U ± ëtÆ.y ç U) ± true ± ëtÆ.x + ëtÆ.y = 3Æ),
	("z_∂_tac 4",
	tac_res (z_∂_tac Ò  TEST_SCHEMAÆ),
	Ò∂ x : U; y : U∑ x + y = 3Æ,
	Ò(ë Æ.x ç U ± ë Æ.y ç U) ± true ± ë Æ.x + ë Æ.y = 3Æ)
	]
end;

=TEX
=SML
store_mt_results mt_run_fail [
	("z_∂_tac 47290",
	tac_fail (z_∂_tac mk_t),
	([],ÒtrueÆ),
	gen_fail_msg "z_∂_tac" 47290 [mk_t_st]),
	("z_∂_tac 41021 a",
	tac_fail (z_∂_tac Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ)Æ),
	([],Ò∂ x:X; y:Y; z:X | f x ∑ g  ¨a + bÆ zÆ),
	gen_fail_msg "z_∂_tac" 41021 [
		string_of_term Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ)Æ,
		string_of_term xyz_decl]),
	("z_∂_tac 41021 b",
	tac_fail (z_∂_tac mk_t),
	([],Ò∂ x:X; y:Y; z:X | f x ∑ g  ¨a + bÆ zÆ),
	gen_fail_msg "z_∂_tac" 41021 [mk_t_st,
		string_of_term xyz_decl])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_∂_inv_conv 1",
	snd o dest_eq o concl o z_∂_inv_conv,
	Ò∂ x, y : X | f ∑ gÆ,
	Òf ± (∂ x, y : X | true ∑ true) ± gÆ),
	("z_∂_inv_conv 1b",
	snd o dest_eq o concl o z_∂_inv_conv,
	Ò∂ x: X | f ∑ gÆ,
	Òf ± (∂ x : X | true ∑ true) ± gÆ),
	("z_∂_inv_conv 2",
	snd o dest_eq o concl o z_∂_inv_conv,
	Ò∂ x, y : X | x > 0 ∑ zÆ,
	Ò(∂ x, y : X | x > 0 ∑ true) ± zÆ),
	("z_∂_inv_conv 3",
	snd o dest_eq o concl o z_∂_inv_conv,
	Ò∂ x,y : X | f ∑ x = yÆ,
	Òf ± (∂ x,y : X | true ∑ x = y)Æ),
	("z_∂_inv_conv 4",
	snd o dest_eq o concl o z_∂_inv_conv,
	Ò∂ x,y : X ∑ gÆ,
	Ò(∂ x,y : X ∑ true) ± gÆ),
	("z_∂_inv_conv 5",
	snd o dest_eq o concl o z_∂_inv_conv,
	Ò∂ x,y : X | f∑ trueÆ,
	Òf ± (∂ x,y : X | true ∑ true)Æ)
	];
store_mt_results mt_run_fail [
	("z_∂_inv_conv 47290",
	z_∂_inv_conv,
	mk_t,
	gen_fail_msg "z_∂_inv_conv" 47290 [mk_t_st]),
	("z_∂_inv_conv 41040",
	z_∂_inv_conv,
	Ò∂ x : X | f x ∑ g xÆ,
	gen_fail_msg "z_∂_inv_conv" 41040 [
		string_of_term Ò∂ x : X | f x ∑ g xÆ])];
=TEX
\subsection{Concerning Õ}
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_Õ_rule 1",
	concl o z_Õ_rule,
	ÒÕ x,y:X;z:Y;p:X | z ∑ p(x = y)Æ,
	¨µ x':'a ∑
	Ò(µ x, y : X; z : Y; p : X | z ∑ p (x = y) = x') 
	±
	(∂ x, y : X; z : Y; p : X | z ∑ p (x = y) = x')
	¥
	((Õ x, y : X; z : Y; p : X | z ∑ p (x = y)) = ¨x':'aÆ)ÆÆ),
	("z_Õ_rule 2",
	concl o z_Õ_rule,
	ÒÕ x:X | f x ∑ p xÆ,
	¨µ x':'b ∑
	Ò(µ x :X | f x ∑ p x = x') 
	±
	(∂ x:X | f x ∑ p x = x')
	¥
	((Õ x:X | f x ∑ p x) = ¨x':'bÆ)ÆÆ)];
=TEX
=SML
store_mt_results mt_run_fail [
	("z_Õ_rule 47210",
	z_Õ_rule,
	mk_t,
	gen_fail_msg "z_Õ_rule" 47210 [mk_t_st])];
=TEX
\subsection{Concerning Function Application}
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_app_conv",
	snd o dest_eq o concl o z_app_conv,
	Òp qÆ,
	Ò(Õ f_a :U | (¨q:'aÆ,f_a) ç ¨p:('a, 'b) $"Z'T[2]" SETÆ ∑ f_a)Æ)];
store_mt_results mt_run_fail [
	("z_app_conv 47210",
	z_app_conv,
	mk_t,
	gen_fail_msg "z_app_conv" 47190 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_app_rule",
	concl o z_app_rule,
	Òp qÆ,
	¨µ x:'b
  	∑ Ò (µ f_a : U | (¨q:'aÆ, f_a) ç ¨p:('a, 'b) $"Z'T[2]" SETÆ ∑ f_a = x) ± 
		(¨q:'aÆ, x) ç ¨p:('a, 'b) $"Z'T[2]" SETÆ
      ¥ ¨p:('a, 'b) $"Z'T[2]" SETÆ q = ¨x:'bÆÆÆ)];
store_mt_results mt_run_fail [
	("z_app_rule 47190",
	z_app_rule,
	mk_t,
	gen_fail_msg "z_app_rule" 47190 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_app_tac 1",
	tac_res z_app_tac,
	Òp q = rÆ,
	Ò (µ f_a : U | (q, f_a) ç ¨p:('a, 'b) $"Z'T[2]" SETÆ ∑ f_a = r) ± 
		(q, r) ç ¨p:('a, 'b) $"Z'T[2]" SETÆÆ),
	("z_app_tac 2",
	tac_res z_app_tac,
	Ò¨r:BOOLÆ § p qÆ,
	Ò (µ f_a : U | (q, f_a) ç ¨p:('a, BOOL) $"Z'T[2]" SETÆ ∑ f_a § r) ± 
		(q, r) ç ¨p:('a, BOOL) $"Z'T[2]" SETÆÆ),
	("z_app_tac 3",
	tac_res z_app_tac,
	Ò¨p:('a, BOOL) $"Z'T[2]" SETÆ qÆ,
	Ò (µ f_a : U | (q, f_a) ç ¨p:('a, BOOL) $"Z'T[2]" SETÆ ∑ f_a = true) ± 
		(q, true) ç ¨p:('a, BOOL) $"Z'T[2]" SETÆÆ)];
store_mt_results mt_run_fail [
	("z_app_tac 41090",
	tac_fail z_app_tac,
	([],mk_t),
	gen_fail_msg "z_app_tac" 41090 [])];
=TEX
\subsection{Concerning Ã}
=SML
store_mt_results (mt_runf (op =$)) [
	("z_Ã_conv 1",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ x,y:X;a:Y | f x ∑ g y aÆ,
	Ò{x, y : X; a : Y | f x ∑ ((x, y, a), ((g y) a))}Æ),
	("z_Ã_conv 1b",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ x:X | f x ∑ g xÆ,
	Ò{x : X | f x ∑ (x, g x)}Æ),
	("z_Ã_conv 2",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ [z:Y;x,y : X| x = y] | g x ∑ f z xÆ,
	Ò{[z : Y; x, y : X | x = y]
	| g x
	∑ (( [z : Y; x, y : X | x = y]), ((f z) x))}Æ),
	("z_Ã_conv 3",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ [x,y : X | x = y] | g x ∑ f xÆ,
	Ò{[x, y : X | x = y] | g x ∑ (( [x, y : X | x = y]), (f x))}Æ)
	];
store_mt_results mt_run_fail [
	("z_Ã_conv 47200",
	z_Ã_conv,
	mk_t,
	gen_fail_msg "z_Ã_conv" 47200 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_¬_rule 1",
	concl o z_¬_rule,
	Ò(Ã x,y : X; z:Y | x = y ∑ f z x) (1,2,g)Æ,
	¨µ x':'b
	∑ Ò (µ f_a : U | (∂ x, y : X; z : Y
            | x = y
            ∑ ((x, y, z) = (1, 2, g))
            ± ((f z) x = f_a))
          ∑ f_a = x')
        ± (∂ x, y : X; z : Y
          | x = y ∑ ((x, y, z) = (1, 2, g))
          ± ((f z) x = x'))
      ¥ (Ã x, y : X; z : Y | x = y ∑ (f z) x) (1, 2, g) = ¨x':'bÆÆÆ),
	("z_¬_rule 2",
	concl o z_¬_rule,
	Ò(Ã x : X | f x ∑ g x) yÆ,
	¨µ x':'b ∑ Ò (µ f_a : U
          | (∂ x : X | f x ∑ (x = y) ± (g x = f_a))
          ∑ f_a
          = ¨x':'bÆ)
        ± (∂ x : X | f x ∑ (x = y) ± (g x = ¨x':'bÆ))
      ¥ (Ã x : X | f x ∑ g x) y = ¨x':'bÆÆÆ),
	("z_¬_rule 3",
	concl o z_¬_rule,
	Ò(Ã [x,y : X; z:Y| x = y] | g x ∑ f z x) (x ¶ 1,y ¶ 2,z ¶ g)Æ,
	¨µ x':'a
	∑ Ò (µ f_a : U
          | (∂ [x, y : X; z : Y | x = y]
            | g x
            ∑ ( [x, y : X; z : Y | x = y] = (x ¶ 1, y ¶ 2, z ¶ g))
            ± ((f z) x = f_a))
          ∑ f_a
          = x')
        ± (∂ [x, y : X; z : Y | x = y]
          | g x
          ∑ ( [x, y : X; z : Y | x = y] = (x ¶ 1, y ¶ 2, z ¶ g))
          ± ((f z) x = x'))
      ¥ (Ã [x, y : X; z : Y | x = y] | g x ∑ (f z) x)
            (x ¶ 1, y ¶ 2, z ¶ g)
        = ¨x':'aÆÆÆ)
	];

store_mt_results mt_run_fail [
	("z_¬_rule 41110",
	z_¬_rule,
	mk_t,
	gen_fail_msg "z_¬_rule" 41110 [mk_t_st])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [
	("z_¬_conv 1",
	dest_thm o z_¬_conv,
	 Ò(Ã x : X | f x ∑ g x) yÆ,
	([Ò¨f:('a, BOOL) $"Z'T[2]" SETÆ yÆ, 
	Òy ç XÆ], 
	Ò(Ã x : X | f x ∑ g x) y = g yÆ)),
	("z_¬_conv 2",
	dest_thm o z_¬_conv,
	Ò(Ã p : U | f p ∑ g p q) yÆ,
	([Ò¨f:('a, BOOL) $"Z'T[2]" SETÆ yÆ],
	 Ò(Ã p : U | f p ∑ (g p) q) y = (g y) qÆ)),
	("z_¬_conv 3",
	dest_thm o z_¬_conv,
	Ò(Ã p : U ∑ g p q) yÆ,
	([],Ò(Ã p : U ∑ (g p) q) y = (g y) qÆ))
	];
=TEX
\subsection{Conversions between Z Universal and Existential Quantifications}
The first of the following will fail with HOL version 1.97, but should not fail with later ones.
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_≥_µ_conv 1",
	snd o dest_eq o concl o z_≥_µ_conv,
	Ò≥(µ x:X; y,z:Y; [a,b:U] | y = z ∑ a = b)Æ,
	Ò∂ x:X; y,z:Y; [a,b:U] | y = z ∑ ≥ a = bÆ),
	(
	"z_≥_µ_conv 2",
	snd o dest_eq o concl o z_≥_µ_conv,
	Ò≥(µ xx:X; y,z:Y; [a,b:U] | y = z ∑ a = b)Æ,
	Ò∂ xx:X; y,z:Y; [a,b:U] | y = z ∑ ≥ a = bÆ)];
=TEX
The first of the following will fail with HOL version 1.97, but should not fail with later ones.
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_≥_∂_conv 1",
	snd o dest_eq o concl o z_≥_∂_conv,
	Ò≥(∂ x:X; y,z:Y; [a,b:U] | y = z ∑ a = b)Æ,
	Òµ x:X; y,z:Y; [a,b:U] | y = z ∑ ≥ a = bÆ),
	("z_≥_∂_conv 2",
	snd o dest_eq o concl o z_≥_∂_conv,
	Ò≥(∂ xx:X; y,z:Y; [a,b:U] | y = z ∑ a = b)Æ,
	Òµ xx:X; y,z:Y; [a,b:U] | y = z ∑ ≥ a = bÆ)];
store_mt_results mt_run_fail [("z_≥_µ_conv 41050",
	z_≥_µ_conv,
	mk_t,
	gen_fail_msg "z_≥_µ_conv" 41050 [mk_t_st]),
	("z_≥_∂_conv 41051",
	z_≥_∂_conv,
	mk_t,
	gen_fail_msg "z_≥_∂_conv" 41051 [mk_t_st])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_≥_in_conv 1",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥(≥ (x ± y))Æ,
	Ò(x ± y)Æ),
	("z_≥_in_conv 2",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥(t1 ± t2)Æ,
	Ò≥t1 ≤ ≥t2Æ),
	("z_≥_in_conv 3",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥(t1 ≤ t2)Æ,
	Ò≥t1 ± ≥t2Æ),
	("z_≥_in_conv 4",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥(t1 ¥ t2)Æ,
	Òt1 ± ≥t2Æ),
	("z_≥_in_conv 5",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥((x ± y) = t2)Æ,
	Ò((x ± y) ± ≥t2) ≤ (t2 ± ≥(x ± y))Æ),
	("z_≥_in_conv 6",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥(t1 = t1)Æ,
	ÒfalseÆ),
	("z_≥_in_conv 7",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥(µ x:X | P∑ V)Æ,
	Ò∂ x:X | P∑ ≥ VÆ),
	("z_≥_in_conv 8",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥( ∂ x:X | P∑ V)Æ,
	Òµ x:X | P∑ ≥ VÆ),
	("z_≥_in_conv 9",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥ (∂â1 x:X|P∑ V x)Æ,
	Òµx:X |P ± V x ∑≥ (µx':X |P ± V x' ∑ x' = x)Æ), 
	("z_≥_in_conv 10",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥ trueÆ,
	ÒfalseÆ),
	("z_≥_in_conv 11",
	snd o dest_eq o concl o z_≥_in_conv,
	Ò≥ falseÆ,
	ÒtrueÆ)
	];
=TEX
=SML
store_mt_results mt_run_fail [(
	"z_≥_in_conv 28131",
	z_≥_in_conv,
	Ò≥ xÆ,
	gen_fail_msg "z_≥_in_conv" 28131 [string_of_term Ò≥ xÆ]),
	("z_≥_in_conv 47240",
	z_≥_in_conv,
	mk_t,
	gen_fail_msg "z_≥_in_conv" 47240 [mk_t_st])
	];
=TEX
\subsection{Conversions betweens Declarations and Predicates}
=SML
store_mt_results (mt_runf (op =$)) [
	("dec_pred_conv 1",
	snd o dest_eq o concl o dec_pred_conv,
	mk_z_dec([ÒxÆ],¨X:'a SETÆ),
	Òx ç XÆ),
	("dec_pred_conv 2",
	snd o dest_eq o concl o dec_pred_conv,
	mk_z_dec([ÒxÆ,ÒyÆ],¨X:'a SETÆ),
	Ò{x,y} Ä XÆ),
	("dec_pred_conv 3",
	snd o dest_eq o concl o dec_pred_conv,
	mk_z_decsexp(Ò[x,y:X]Æ,""),
	mk_z_predsexp(Ò[x,y:X]Æ,""))];
store_mt_results mt_run_fail [(
	"dec_pred_conv 41010",
	dec_pred_conv,
	mk_t,
	gen_fail_msg "dec_pred_conv" 41010 [mk_t_st])
	];
=TEX
=SML
let
val (d,_,_) = dest_z_µÒµ x:X; y,z:Y; [a,b:Z] ∑ trueÆ;
in
	store_mt_results (mt_runf (op =$)) [
	("DECL_C",
	snd o dest_eq o concl o DECL_C dec_pred_conv,
	d,
	Òx ç X ± {y,z} Ä Y ± [a,b:Z]Æ)
	]
end;
store_mt_results mt_run_fail [(
	"DECL_C 47912",
	DECL_C dec_pred_conv,
	mk_t,
	gen_fail_msg "DECL_C" 47912 [mk_t_st]),
	("DECL_C 41012",
	DECL_C dec_pred_conv,
	mk_z_decl[mk_t],
	gen_fail_msg "DECL_C" 41012 [string_of_term (mk_z_decl[mk_t])])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("pred_dec_conv 1",
	snd o dest_eq o concl o pred_dec_conv,
	Òx ç XÆ,
	mk_z_dec([ÒxÆ],¨X:'a SETÆ)),
	("pred_dec_conv 2",
	snd o dest_eq o concl o pred_dec_conv,
	Ò{x,y} Ä XÆ,
	mk_z_dec([ÒxÆ,ÒyÆ],¨X:'a SETÆ)),
	("pred_dec_conv 3",
	snd o dest_eq o concl o pred_dec_conv,
	mk_z_predsexp(Ò[x,y:X]Æ,""),
	mk_z_decsexp(Ò[x,y:X]Æ,"")),
	("pred_dec_conv 4",
	snd o dest_eq o concl o pred_dec_conv,
	Ò [x, x! : X | x = z] ç [x, x! : X | x = z]Æ,
	mk_z_decsexp(Ò[x, x! : X | x = z]Æ,""))];
store_mt_results mt_run_fail [(
	"pred_dec_conv 41010",
	pred_dec_conv,
	mk_t,
	gen_fail_msg "pred_dec_conv" 41011 [mk_t_st])
	];
=TEX
=SML
let
val (d,_,_) = dest_z_µÒµ x:X; y,z:Y; [a,b:Z] ∑ trueÆ;
in
	store_mt_results (mt_runf (op =$)) [
	("DECL_INTRO_C",
	snd o dest_eq o concl o DECL_INTRO_C pred_dec_conv,
	Òx ç X ± {y,z} Ä Y ± [a,b:Z]Æ,
	d)
	]
end;
store_mt_results mt_run_fail [(
	"DECL_INTRO_C 41013",
	DECL_INTRO_C dec_pred_conv,
	mk_t,
	gen_fail_msg "DECL_INTRO_C" 41013 [mk_t_st]),
	("DECL_INTRO_C 41014",
	DECL_INTRO_C id_conv,
	mk_t,
	gen_fail_msg "DECL_INTRO_C" 41014 [mk_t_st,mk_t_st])
	];
=TEX
\section{Z REWRITING}
\subsection{Canonicalisation}
=SML
store_mt_results (mt_runf (op =|-)) [("z_defn_canon",
	hd o z_defn_canon,
	get_spec ¨$"z'_ ™ _"Æ,
	pure_rewrite_rule [get_spec ¨$"Z'AbbDef"Æ]
		 (get_spec ¨$"z'_ ™ _"Æ))];
store_mt_results mt_run_fail [(
	"z_defn_canon 41080",
	z_defn_canon,
	t_thm,
	gen_fail_msg "z_defn_canon" 41080 [string_of_thm t_thm])];
store_mt_results (mt_runf (op =$)) [("z_defn_conv",
	snd o dest_eq o concl o z_defn_conv,
	concl(get_spec ¨$"z'_ ™ _"Æ),
	concl(pure_rewrite_rule [get_spec ¨$"Z'AbbDef"Æ]
		 (get_spec ¨$"z'_ ™ _"Æ)))];
store_mt_results mt_run_fail [(
	"z_defn_conv 41082",
	z_defn_conv,
	mk_t,
	gen_fail_msg "z_defn_conv" 41082 [mk_t_st])];

store_mt_results (mt_runf (op =$)) [("z_µ_rewrite_canon 1",
	concl o hd o z_µ_rewrite_canon,
	asm_rule Òµ x,y : U; z:X| f ∑ x = yÆ,
	¨µ x y:'a ∑ µ z:'b∑ Òz ç X ± f ¥ ¨x:'aÆ = yÆÆ),
	("z_µ_rewrite_canon 2",
	concl o hd o z_µ_rewrite_canon,
	asm_rule Òµ x: U | f ∑ x = yÆ,
	¨µ x ∑ f ¥ x = yÆ)];
store_mt_results mt_run_fail [(
	"z_µ_rewrite_canon 41081",
	z_µ_rewrite_canon,
	t_thm,
	gen_fail_msg "z_µ_rewrite_canon" 41081 [string_of_thm t_thm])];
=TEX
=SML
store_mt_results (mt_runf (op =|-)) [
	("z_≥_rewrite_canon 1",
	hd o z_≥_rewrite_canon,
	asm_rule Ò≥(t1 ≤ t2)Æ,
	conv_rule z_≥_in_conv
		 (asm_rule Ò≥(t1 ≤ t2)Æ)),
	("z_≥_rewrite_canon 2",
	hd o z_≥_rewrite_canon,
	asm_rule Ò≥(∂ x : X | f ∑ g)Æ,
	conv_rule z_≥_in_conv
		 (asm_rule Ò≥(∂ x : X | f ∑ g)Æ)),
	("z_≥_rewrite_canon 3",
	hd o z_≥_rewrite_canon,
	asm_rule Ò≥ (≥ t)Æ,
	conv_rule z_≥_in_conv
		 (asm_rule Ò≥ (≥ t)Æ)),
	("z_≥_rewrite_canon 4",
	hd o z_≥_rewrite_canon,
	asm_rule Ò≥ tÆ,
	pure_rewrite_rule [taut_rule ¨µ x ∑ ≥ x § x § FÆ]
		 (asm_rule Ò≥ tÆ))
	];
=TEX
\section{Z STRIPPING AND PROOF CONTEXTS}
Incomplete tests, but certainly strongly hint at
some Z specific stuff:
=SML
store_mt_results (mt_runf (op =$)) [("z_predicates pc 1",
	tac_res (rewrite_tac[]),
	Ò(t = true) ± ≥ (≥ t1) ± (t2 = t2) ± true ± (false ¥ t3) ± 
		(x ç (U ∏ U)) ± (µ x : X ∑ true) ± ≥(∂ y : X ∑ false) ≤ falseÆ,
	Òt ± t1Æ)];
store_mt_results (mt_runf (op =#)) [("z_predicates pc 2",
	tac_res1 strip_tac,
	([],Ò(≥(≥ t) ± (µ x : U ∑ x = x) ± (∂ x : U ∑ f x) ± z ç  U ± 
		(µ p:P | p ∑ true)) ¥ falseÆ),
	([Òµ p : P | p ∑ falseÆ,
	  Ò¨f:('b, BOOL) $"Z'T[2]" SETÆ ¨x:'bÆÆ,
	  ¨µ x:'a∑ x = xÆ, ¨t:BOOLÆ],ÒfalseÆ))];
store_mt_results (mt_runf (op =#)) [("z_predicates pc 3",
	tac_res1 (REPEAT strip_tac),
	([],Òµ y : X ∑ (≥(≥ t) ± (µ x : U ∑ x = x) ± x ç U)Æ),
	([Òy ç XÆ],¨t:BOOLÆ))];
store_mt_results (mt_runf (op =$)) [("z_predicates pc 4",
	concl o rewrite_conv [get_spec ¨$"z'_ ™ _"Æ],
	ÒP ™ PÆ,
	ÒP ™ P = (P ∏ P)Æ)];
store_mt_results (mt_runf (op =$)) [("z_predicates pc 5",
	concl o rewrite_conv [],
	Ò(Ã x : U ∑ f x) (1 + 2)Æ,
	Ò(Ã x : U ∑ f x) (1 + 2) = f (1 + 2)Æ)];
=TEX
=TEX
\section{BIT O'NONSENSE}
πZ
rel	px _,py _, pz _
∞
ù[X]
px _ :  X;
py _ :  X;
pz _ :  X
à

ˇS[X]¸
x:X
˜
px x
à
ˇI[X]¸
y:X
˜
py y
à
ˇO[X]¸
z:X
˜
pz z
à
=SML
push_goal([],Ò(∂[[S;S']; I;O] | p x x' y z∑ true) §
	(∂ S;S'; I;O | p x x' y z∑ true)Æ);
a(REPEAT strip_tac);
a(z_∂_tac Ò [[S;S']; I;O]Æ);
a(REPEAT strip_tac);
repeat drop_main_goal;
=TEX
\section{END OF TESTS}
=SML
(* set_flag("subgoal_package_quiet",false); *)
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results (mt_runf (op =$)) [("",
	tac_res ,
	ÒÆ,
	ÒÆ)];
store_mt_results (mt_runf (op =#)) [("",
	tac_res1 ,
	([ÒÆ],ÒÆ),
	([ÒÆ],ÒÆ))];
store_mt_results (mt_runf (list_eq(op =#))) [("",
	tac_ress  2,
	([ÒÆ],ÒÆ),
	[([ÒÆ],ÒÆ),([ÒÆ],ÒÆ)])];
store_mt_results mt_runf [
	("",
	tac_solve ,
	([],ÒÆ),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],ÒÆ),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];

