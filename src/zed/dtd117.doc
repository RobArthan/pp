=IGN
********************************************************************************
dtd117.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Detailed Design of the Z Library Real Numbers }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the detailed design for the theory
of real numbers in \ProductZ.}
\end{center}}

\def\Reference{LEMMA1/HOL/DTD117}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.10 $%
}
\def\Date{\FormatDate{$Date: 2004/01/19 12:44:00 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issue 1.1-1.3] Initial development drafts.
\item[Issue 1.4] Corrected errors in theorems about associativity and multiplication and
some improvements to the treatment of unary negation in the proof contexts.
\item[Issue 1.5] Revisions after module testing.
\item[Issue 1.6] Corrected over-strong definition of exponentiation.
\item[Issue 1.7] Renaming of ML bindings for theorems about division.
\item[Issue 1.8] Copyright and banner updates for open source release.
\item[Issue 1.9] PPZed-specific updates for open source release
\item[Issue 1.10] The Z universal set is now called É.
\item[Issue 1.11] Precedences and associativity of toolkit operators now follow \cite{ISO02}.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document contains the detailed design
of the Z Library theory of real numbers and their proof support.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.


\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{PREAMBLE}
=SML
open_theory"z_numbers";
push_pc "z_sets_alg";
delete_theory"z_reals" handle Fail _ => ();
set_flag ("z_type_check_only", false);
set_flag ("z_use_axioms", true);
new_theory"z_reals";
new_parent"Ø";
=TEX
\section {DEFINITION OF FIXITY}

The following is in the spirit of \cite{ISO02} as regards precedences and associativity.
\cite{ISO02} does not define all of these operators.

πZ
function 20 leftassoc _ ..âR _
∞

πZ
function 30 leftassoc _ +âR _, _ -âR _
∞

πZ
function 40 leftassoc _ *âR _, _ /âR _, _ /âZ _
∞

πZ
function 50 ~âR _
∞
πZ
function 50 absâR _
∞
Exponentiation is necessarily right-associative.

πZ
function 60 rightassoc _ ^âZ _
∞

πZ
relation _ <âR _, _ ºâR _, _ æâR _, _ >âR _
∞

\section{THE REAL NUMBERS}

\subsection{The Numbers and their Basic Operators}

We need to break out into extended Z to define the reals and their operators.
=SML
val _ = set_flag("standard_z_paras", false);
=TEX
πZ
Ø ¶ É[¨Totality:Ø SETÆ]
∞
Now we define the ordering properties of the real numbers.
=TEX

We characterise the main operators as being the same as the HOL ones:
πZAX
‹ €_<âR_› : Ø ™ Ø ;
‹ €_ ºâR _› : Ø ™ Ø ;
‹ €~âR_›  : Ø ≠ Ø ;
‹ €_+âR_› : Ø ∏ Ø ≠ Ø ;
‹ €_*âR_› : Ø ∏ Ø ≠ Ø ;
‹ €_/âR_› : Ø ∏ Ø ≠ Ø ;
‹ €absâR_› : Ø ≠ Ø
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µx, y: Ø∑ x <âR y § ¨x <âR yÆ ;
‹	µx, y: Ø∑ x ºâR y § ¨x ºâR yÆ ;
‹	µx: Ø∑ ~âR x = ¨~âR xÆ ;
‹	µx, y: Ø∑ x +âR y = ¨x +âR yÆ ;
‹	µx, y: Ø∑ x *âR y = ¨x *âR yÆ ;
‹	µx, y: Ø∑ x /âR y = ¨x /âR yÆ ;
‹	µx: Ø∑ absâR x = ¨AbsâR xÆ
∞
πZAX
‹ €_ >âR _› : Ø ™ Ø ;
‹ €_ æâR _› : Ø ™ Ø ;
‹ €_-âR_› : Ø ∏ Ø ≠ Ø
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µx, y: Ø∑ x >âR y § y <âR x ;
‹	µx, y: Ø∑ x æâR y § y ºâR x ;
‹	µx, y: Ø∑ x -âR y = x +âR ~âR y
∞

Conversion of integers to reals:
πZAX
‹	€real›: ˙ ≠ Ø
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	real 1 = ¨ÓØ 1Æ
‹±	(µi: ˙∑ real (~i) = ~âR (real i))
‹±	(µi, j: ˙∑ real (i + j) = real i +âR real j)
∞

Division (of one integer by another):
πZAX
‹	€_/âZ_›: ˙ ∏ ˙ ≠ Ø
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µi, j : ˙∑ i /âZ j = real i /âR real j
∞

=TEX
Exponentiation (with integer exponents):

πZAX
‹	€_^âZ_›: Ø ∏ ˙ ≠ Ø
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	¨µx m∑ Òx ^âZ ¨Z'Int mÆÆ = x ^âN mÆ
‹±	¨µx m∑ Òx ^âZ ~ ¨Z'Int (m+1)ÆÆ =  ÓØ 1 /âR (x ^âN (m+1))Æ
∞
=TEX
Interval:

πZAX
‹	€_..âR_›: Ø ∏ Ø ≠  Ø
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µx, y : Ø∑x ..âR y = { t : Ø | x ºâR t ºâR y }
∞
=THDOC
req_name €"z_reals"› (Value "z_numbers");
req_parent"Ø";
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_reals$ contains the theory of real numbers for Z.
Standard ML bindings for the theory are contained in the structure {\it ZReals}..
=ENDDOC

=TEX
\section{THEOREMS}
=THDOC
req_thm(€"z_Ø_unbounded_below_thm"›, ([], Ò µ x : Ø ∑ ∂ y : Ø ∑ y <âR xÆ));
req_thm(€"z_Ø_unbounded_above_thm"›, ([], Ò µ x : Ø ∑ ∂ y : Ø ∑ x <âR yÆ));
req_thm(€"z_Ø_less_irrefl_thm"›, ([], Ò µ x : Ø ∑ ≥ x <âR xÆ));
req_thm(€"z_Ø_less_antisym_thm"›, ([], Ò µ x, y : Ø ∑ ≥ (x <âR y ± y <âR x)Æ));
req_thm(€"z_Ø_less_trans_thm"›, ([],
	Ò µ x, y, z : Ø ∑ x <âR y ± y <âR z ¥ x <âR zÆ));
req_thm(€"z_Ø_less_cases_thm"›, ([], Ò µ x, y : Ø ∑ x <âR y ≤ x = y ≤ y <âR xÆ));
req_thm(€"z_Ø_less_≥_eq_thm"›, ([], Ò µ x, y : Ø ∑ x <âR y ¥ ≥ x = yÆ));
req_thm(€"z_Ø_less_dense_thm"›, ([],
	Ò µ x, y : Ø ∑ x <âR y ¥ (∂ z : Ø ∑ x <âR z ± z <âR y)Æ));
req_thm(€"z_Ø_complete_thm"›, ([], Ò µ A :  Ø ∑
	≥ A = {} ± (∂ b : Ø ∑ µ x : Ø ∑ x ç A ¥ x ºâR b) ¥
	(∂ s : Ø∑
		(µ x : Ø ∑ x ç A ¥ x ºâR s)
	±	(µ b : Ø ∑ (µ x : Ø ∑ x ç A ¥ x ºâR b) ¥ s ºâR b))Æ));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(€"z_Ø_º_cases_thm"›, ([], Ò µ x, y : Ø ∑ x ºâR y ≤ y ºâR xÆ));
req_thm(€"z_Ø_º_less_cases_thm"›, ([], Ò µ x, y : Ø ∑ x ºâR y ≤ y <âR xÆ));
req_thm(€"z_Ø_eq_º_thm"›, ([], Ò µ x, y : Ø ∑ x = y § x ºâR y ± y ºâR xÆ));
req_thm(€"z_Ø_º_antisym_thm"›, ([], Ò µ x, y : Ø ∑ x ºâR y ± y ºâR x ¥ x = yÆ));
req_thm(€"z_Ø_less_º_trans_thm"›,
	([], Ò µ x, y, z : Ø ∑ x <âR y ± y ºâR z ¥ x <âR zÆ));
req_thm(€"z_Ø_º_less_trans_thm"›,
	([], Ò µ x, y, z : Ø ∑ x ºâR y ± y <âR z ¥ x <âR zÆ));
req_thm(€"z_Ø_º_refl_thm"›, ([], Ò µ x : Ø ∑ x ºâR xÆ));
req_thm(€"z_Ø_º_trans_thm"›, ([],
	Ò µ x, y, z : Ø ∑ x ºâR y ± y ºâR z ¥ x ºâR zÆ));
req_thm(€"z_Ø_º_≥_less_thm"›, ([], Ò µ x, y : Ø ∑ x ºâR y § ≥ y <âR xÆ));
req_thm(€"z_Ø_≥_º_less_thm"›, ([], Ò µ x, y : Ø ∑ ≥ x ºâR y § y <âR xÆ));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(€"z_Ø_plus_assoc_thm"›, ([],
	Ò µ x, y, z : Ø ∑ (x +âR y) +âR z = x +âR (y +âR z)Æ));
req_thm(€"z_Ø_plus_assoc_thm1"›, ([],
	Ò µ x, y, z : Ø ∑ x +âR (y +âR z) = (x +âR y) +âR zÆ));
req_thm(€"z_Ø_plus_comm_thm"›, ([],
	Ò µ x, y : Ø ∑ x +âR y = y +âR xÆ));
req_thm(€"z_Ø_plus_unit_thm"›, ([],
	Ò µ x : Ø ∑ x +âR real 0 = xÆ));
req_thm(€"z_Ø_plus_mono_thm"›, ([],
	Ò µ x, y, z : Ø ∑ y <âR z ¥ x +âR y <âR x +âR zÆ));
req_thm(€"z_Ø_plus_mono_thm1"›, ([],
	Ò µ x, y, z : Ø ∑ y <âR z ¥ y +âR x <âR z +âR xÆ));
req_thm(€"z_Ø_plus_mono_thm2"›, ([],
	Ò µ x, y, s, t : Ø ∑ x <âR y ± s <âR t ¥ x +âR s <âR y +âR tÆ));
req_thm(€"z_Ø_plus_0_thm"›, ([],
	Ò µ x : Ø ∑ x +âR real 0 = x ± real 0 +âR x = xÆ));
req_thm(€"z_Ø_plus_order_thm"›, ([],
	Ò µ x, y, z : Ø ∑ y +âR x = x +âR y
		±	(x +âR y) +âR z = x +âR (y +âR z)
		±	y +âR (x +âR z) = x +âR (y +âR z)Æ));
req_thm(€"z_Ø_plus_minus_thm"›, ([],
	Ò µ x : Ø ∑ x +âR ~âR x = real 0 ± ~âR x +âR x = real 0Æ));
req_thm(€"z_Ø_eq_thm"›, ([],
	Ò µ x, y : Ø ∑ x = y § x +âR ~âR y = real 0Æ));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(€"z_Ø_minus_clauses"›, ([],
	Ò µ x, y : Ø ∑
		~âR ~âR x = x
		±	x +âR ~âR x = real 0
		±	~âR x +âR x = real 0
		±	~âR (x +âR y) = ~âR x +âR ~âR y
		±	~âR real 0 = real 0Æ));
req_thm(€"z_Ø_minus_eq_thm"›, ([], Ò µ x, y : Ø ∑ ~âR x = ~âR y § x = yÆ));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(€"z_Ø_plus_clauses"›, ([], Ò µ x, y, z : Ø ∑ (x +âR z = y +âR z § x = y)
±	(z +âR x = y +âR z § x = y)
±	(x +âR z = z +âR y § x = y)
±	(z +âR x = z +âR y § x = y)
±	(x +âR z = z § x = real 0)
±	(z +âR x = z § x = real 0)
±	(z = z +âR y § y = real 0)
±	(z = y +âR z § y = real 0)
±	x +âR real 0 = x
±	real 0 +âR x = x
±	≥ real 1 = real 0
±	≥ real 0 = real 1Æ));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(€"z_Ø_less_clauses"›, ([], Ò µ x, y, z : Ø ∑ (x +âR z <âR y +âR z § x <âR y)
±	(z +âR x <âR y +âR z § x <âR y)
±	(x +âR z <âR z +âR y § x <âR y)
±	(z +âR x <âR z +âR y § x <âR y)
±	(x +âR z <âR z § x <âR real 0)
±	(z +âR x <âR z § x <âR real 0)
±	(x <âR z +âR x § real 0 <âR z)
±	(x <âR x +âR z § real 0 <âR z)
±	≥ x <âR x
±	real 0 <âR real 1
±	≥ real 1 <âR real 0Æ));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(€"z_Ø_º_clauses"›, ([], Ò µ x, y, z : Ø ∑ (x +âR z ºâR y +âR z § x ºâR y)
±	(z +âR x ºâR y +âR z § x ºâR y)
±	(x +âR z ºâR z +âR y § x ºâR y)
±	(z +âR x ºâR z +âR y § x ºâR y)
±	(x +âR z ºâR z § x ºâR real 0)
±	(z +âR x ºâR z § x ºâR real 0)
±	(x ºâR z +âR x § real 0 ºâR z)
±	(x ºâR x +âR z § real 0 ºâR z)
±	x ºâR x
±	real 0 ºâR real 1
±	≥ real 1 ºâR real 0Æ));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(€"z_Ø_times_assoc_thm"›, ([],
	Ò µ x, y, z : Ø ∑ (x *âR y) *âR z = x *âR (y *âR z)Æ));
req_thm(€"z_Ø_times_assoc_thm1"›, ([],
	Ò µ x, y, z : Ø ∑ x *âR (y *âR z) = (x *âR y) *âR zÆ));
req_thm(€"z_Ø_times_comm_thm"›, ([], Ò µ x, y : Ø ∑ x *âR y = y *âR xÆ));
req_thm(€"z_Ø_times_unit_thm"›, ([], Ò µ x : Ø ∑ x *âR real 1 = xÆ));
req_thm(€"z_Ø_0_less_0_less_times_thm"›, ([], Ò µ x, y : Ø ∑ real 0 <âR x
±	real 0 <âR y ¥ real 0 <âR x *âR yÆ));
req_thm(€"z_Ø_times_plus_distrib_thm"›, ([],
	Ò µ x, y, z : Ø ∑ x *âR (y +âR z) = x *âR y +âR x *âR z
±	(x +âR y) *âR z = x *âR z +âR y *âR zÆ));
req_thm(€"z_Ø_times_order_thm"›, ([], Ò µ x, y, z : Ø ∑ y *âR x = x *âR y
±	(x *âR y) *âR z = x *âR (y *âR z)
±	y *âR (x *âR z) = x *âR (y *âR z)Æ));
req_thm(€"z_Ø_times_clauses"›, ([], Ò µ x : Ø ∑ real 0 *âR x = real 0
±	x *âR real 0 = real 0
±	x *âR real 1 = x
±	real 1 *âR x = xÆ));
req_thm(€"z_Ø_over_clauses"›, ([], Ò (µ y, z : Ø ∑ ≥ z = real 0 ¥ (y *âR z) /âR z = y)
±	(µ x, y, z : Ø ∑ ≥ z = real 0 ¥ (x *âR y) /âR z = x *âR y /âR z)Æ));
=DESCRIBE
=ENDDOC

=TEX
\section{SIGNATURE}
=SML
signature €ZReals› = sig
=TEX

\subsection{Syntax Functions}
=DOC
val €dest_z_Ø_º› : TERM -> TERM * TERM;
val €dest_z_Ø_æ› : TERM -> TERM * TERM;
val €dest_z_Ø_˙_exp› : TERM -> TERM * TERM;
val €dest_z_Ø_abs› : TERM -> TERM;
val €dest_z_Ø_frac› : TERM -> TERM * TERM;
val €dest_z_Ø_greater› : TERM -> TERM * TERM;
val €dest_z_Ø_less› : TERM -> TERM * TERM;
val €dest_z_Ø_minus› : TERM -> TERM;
val €dest_z_Ø_over› : TERM -> TERM * TERM;
val €dest_z_Ø_plus› : TERM -> TERM * TERM;
val €dest_z_real› : TERM -> TERM;
val €dest_z_Ø_subtract› : TERM -> TERM * TERM;
val €dest_z_Ø_times› : TERM -> TERM * TERM;
=DESCRIBE
These are derived destructor
functions for the Z basic arithmetic operations.
An optionally signed integer literal, $signed\_int$, is taken to be either a numeric
literal or the result of applying
=INLINEFT
(~_)
=TEX
\ to a numeric literal. The other constructors correspond directly
to the arithmetic operations of the theory $z\_numbers$ with alphabetic
names assigned to give valid ML name as needed
($greater: <$,
$less: >$,
=INLINEFT
minus: ~
=TEX
,
$plus: +$,
$subtract: -$,
$times: *$).

As usual, there are also corresponding discriminator ($is\_\ldots$) and
constructor functions ($dest\_\ldots$).
For programming convenience, $dest\_z\_signed\_int$ returns $0$  and
$mk\_z\_signed\_int$ returns $true$ when
applied to
=INLINEFT
~0
=TEX
, but $mk\_z\_signed\_int$ cannot be used to construct such a term.
=FAILURE
117101	?0 is not of the form Òx ºâR yÆ
117102	?0 is not of the form Òx æâR yÆ
117103	?0 is not of the form ÒabsâR xÆ
117104	?0 is not of the form Òx /âR yÆ
117105	?0 is not of the form Òx >âR yÆ
117106	?0 is not of the form Òx <âR yÆ
117107	?0 is not of the form Ò~âR xÆ
117109	?0 is not of the form Òx +âR yÆ
117110	?0 is not of the form Òx /âZ yÆ
117111	?0 is not of the form Òx -âR yÆ
117112	?0 is not of the form Òx *âR yÆ
117113	?0 is not of the form Òreal xÆ
=ENDDOC

=DOC
val €is_z_Ø_º› : TERM -> bool;
val €is_z_Ø_æ› : TERM -> bool;
val €is_z_Ø_˙_exp› : TERM -> bool;
val €is_z_Ø_abs› : TERM -> bool;
val €is_z_Ø_frac› : TERM -> bool;
val €is_z_Ø_greater› : TERM -> bool;
val €is_z_Ø_less› : TERM -> bool;
val €is_z_Ø_minus› : TERM -> bool;
val €is_z_Ø_over› : TERM -> bool;
val €is_z_Ø_plus› : TERM -> bool;
val €is_z_real› : TERM -> bool;
val €is_z_Ø_subtract› : TERM -> bool;
val €is_z_Ø_times› : TERM -> bool;
=DESCRIBE
These are derived discriminator
functions for the Z basic arithmetic operations.
See the documentation for the destructor functions ($dest\_z\_plus$ etc.)
for more information.
=ENDDOC

=DOC
val €mk_z_Ø_º› : TERM * TERM -> TERM;
val €mk_z_Ø_æ› : TERM * TERM -> TERM;
val €mk_z_Ø_˙_exp› : TERM * TERM -> TERM;
val €mk_z_Ø_abs› : TERM -> TERM;
val €mk_z_Ø_frac› : TERM * TERM -> TERM;
val €mk_z_Ø_greater› : TERM * TERM -> TERM;
val €mk_z_Ø_less› : TERM * TERM -> TERM;
val €mk_z_Ø_over› : TERM * TERM -> TERM;
val €mk_z_Ø_minus› : TERM -> TERM;
val €mk_z_Ø_plus› : TERM * TERM -> TERM;
val €mk_z_real› : TERM -> TERM;
val €mk_z_Ø_subtract› : TERM * TERM -> TERM;
val €mk_z_Ø_times› : TERM * TERM -> TERM;
=DESCRIBE
These are derived constructor
functions for the Z basic arithmetic operations.
See the documentation for the destructor functions ($dest\_z\_plus$ etc.)
for more information.
=FAILURE
117201	?0 does not have type Ø
=ENDDOC

\subsection{Definitions}
=DOC
val €z_Ø_˙_exp_def› : THM;
val €z_Ø_æ_def› : THM;
val €z_Ø_º_def› : THM;
val €z_Ø_abs_def› : THM;
val €z_Ø_def› : THM;
val €z_Ø_dot_dot_def› : THM;
val €z_Ø_frac_def› : THM;
val €z_Ø_greater_def› : THM;
val €z_Ø_less_def› : THM;
val €z_Ø_minus_def› : THM;
val €z_Ø_over_def› : THM;
val €z_Ø_plus_def› : THM;
val €z_Ø_real_def› : THM;
val €z_Ø_subtract_def› : THM;
val €z_Ø_times_def› : THM;
=DESCRIBE
ML bindings for the definitions in the theory of real numbers.
=ENDDOC

\subsection{Theorems}
=DOC
val €z_Ø_complete_thm› : THM;
val €z_Ø_unbounded_above_thm› : THM;
val €z_Ø_unbounded_below_thm› : THM;
val €z_Ø_less_antisym_thm› : THM;
val €z_Ø_less_cases_thm› : THM;
val €z_Ø_less_clauses› : THM;
val €z_Ø_less_dense_thm› : THM;
val €z_Ø_less_irrefl_thm› : THM;
val €z_Ø_less_thm› : THM;
val €z_Ø_less_trans_thm› : THM;
=DESCRIBE
These are ML bindings for the theorems that characterise the ordering relation
=INLINEFT
_<âR_
=TEX
\ on the real numbers.
=ENDDOC
=DOC
val €z_Ø_eq_º_thm› : THM;
val €z_Ø_eq_thm› : THM;
val €z_Ø_less_º_trans_thm› : THM;
val €z_Ø_less_≥_eq_thm› : THM;
val €z_Ø_º_≥_less_thm› : THM;
val €z_Ø_º_antisym_thm› : THM;
val €z_Ø_º_cases_thm› : THM;
val €z_Ø_º_clauses› : THM;
val €z_Ø_º_less_cases_thm› : THM;
val €z_Ø_º_less_trans_thm› : THM;
val €z_Ø_º_refl_thm› : THM;
val €z_Ø_º_thm› : THM;
val €z_Ø_º_trans_thm› : THM;
val €z_Ø_≥_º_less_thm› : THM;
val €z_Ø_≥_less_º_thm› : THM;
val €z_Ø_0_less_0_less_times_thm› : THM;

val €z_Ø_greater_thm› : THM;
val €z_Ø_æ_thm› : THM;
=DESCRIBE
These are ML bindings for theorems that deal with the equality and ordering relations.
=ENDDOC
=DOC
val €z_Ø_minus_clauses› : THM;
val €z_Ø_minus_eq_thm› : THM;
val €z_Ø_minus_thm› : THM;
val €z_Ø_plus_0_thm› : THM;
val €z_Ø_plus_assoc_thm› : THM;
val €z_Ø_plus_assoc_thm1› : THM;
val €z_Ø_plus_clauses› : THM;
val €z_Ø_plus_comm_thm› : THM;
val €z_Ø_plus_minus_thm› : THM;
val €z_Ø_plus_mono_thm› : THM;
val €z_Ø_plus_mono_thm1› : THM;
val €z_Ø_plus_mono_thm2› : THM;
val €z_Ø_plus_order_thm› : THM;
val €z_Ø_plus_thm› : THM;
val €z_Ø_plus_unit_thm› : THM;
val €z_Ø_subtract_thm› : THM;
=DESCRIBE
ML bindings for theorems about addition, unary minus and subtraction for the real numbers.
=ENDDOC
=DOC
val €z_Ø_real_ÓØ_thm› : THM;
val €z_Ø_real_0_thm› : THM;
=DESCRIBE
ML bindings for theorems relating Z integer real literals with HOL ones.
=ENDDOC
=DOC
val €z_Ø_times_assoc_thm› : THM;
val €z_Ø_times_assoc_thm1› : THM;
val €z_Ø_times_clauses› : THM;
val €z_Ø_times_comm_thm› : THM;
val €z_Ø_times_order_thm› : THM;
val €z_Ø_times_plus_distrib_thm› : THM;
val €z_Ø_times_thm› : THM;
val €z_Ø_times_unit_thm› : THM;
val €z_Ø_over_thm› : THM;
val €z_Ø_over_clauses› : THM;
=DESCRIBE
ML bindings for theorems about multiplication and division of real numbers.
=ENDDOC

\subsection{Conversions and Tactics}

=DOC
val €z_Ø_º_conv› : CONV;		(* _ºâR _ *)
val €z_Ø_eq_conv› : CONV;		(* _=_ *)
val €z_Ø_less_conv› : CONV;		(* _<âR _ *)
val €z_Ø_minus_conv› : CONV;		(* ~âR *)
val €z_Ø_over_conv› : CONV;		(* _/âR _ *)
val €z_Ø_plus_conv› : CONV;		(* _+âR _ *)
val €z_Ø_times_conv› : CONV;		(* _*âR _ *)
val €z_Ø_˙_exp_conv› : CONV;		(* _^âZ _ *)
val €z_Ø_abs_conv› : CONV;		(* absâZ _ *)

val €z_Ø_greater_conv› : CONV;		(* _>âR _ *)
val €z_Ø_æ_conv› : CONV;		(* _æâR _ *)
val €z_Ø_subtract_conv› : CONV;	(* _-âR _ *)

val €z_Ø_lit_norm_conv› : CONV;

val €z_Ø_lit_conv› : CONV;		val €z_Ø_lit_conv1› : CONV;
=DESCRIBE
These are conversions for carrying out real arithmetic computation.
The first and second blocks of conversions deal with expressions of the form {\it c op d},
where {\it c} and {\it d} are real literal expressions (see below) and
where {\it op} is the operator given in the ML comment alongside the conversion above.
The conversions in the first block actually carry out the computation to
give a theorem {\it c op d = e} or
=INLINEFT
c op d § v
=TEX
\ where {\it e} and {\it v} are a real literal expression or a truth value as appropriate.

The conversions in the second block rewrite their argument in terms of the operators
supported by the conversions in the first block.

The conversion
=INLINEFT
z_Ø_lit_norm_conv
=TEX
\ normalises real literal expressions, i.e., expressions of either of
the forms
=INLINEFT
real i
=TEX
\ or
=INLINEFT
i /âZ j
=TEX
, where {\it i} and {\it j} are optionally signed integer literals.
The conversion puts the result in a normal form, where the sign if any is
moved to the outside, where
=INLINEFT
real
=TEX
\ is used whenever possible and where if the form
=INLINEFT
i /âZ j
=TEX
\ has to be used, {\it i} and {it j} are taken to be coprime.
This conversion fails if its argument cannot be normalised or is already in the normal form.

The final two conversions convert to and from Z and HOL real literal expressions.

=FAILURE
117001	?0 is not a Z real fraction with integer literal operands
117002	?0 is not an HOL real fraction with literal operands
117003	?0 is not of the form ?1 where x and y are real literal expressions
117004	?0 is not of the form ?1 where x is a real literal expression
117005	?0 is not of the form x ^âZ i where x is a real literal expression and i is an integer literal
=ENDDOC

=DOC
val €z_Ø_eval_conv› : CONV;	val €Z_Ø_EVAL_C› : CONV -> CONV;
=DESCRIBE
=INLINEFT
z_Ø_eval_conv
=TEX
\ computes theorems of the form
=INLINEFT
Ù t1 = t2
=TEX
\ where $t1$ is an expression made up from rational literals (see
=INLINEFT
z_Ø_plus_conv
=TEX
) using real addition, subtraction, multiplication, division, reciprocal,
absolute value and unary negation.
$t2$ will be an optionally signed rational literal in normal form.
The conversion fails if the expression cannot be evaluated (e.g., because
it contains variables).

=INLINEFT
z_Ø_EVAL_C conv
=TEX
\ is similar to
=INLINEFT
Ø_eval_conv
=TEX
\ but it also applies
=INLINEFT
conv
=TEX
\ to any subterm that cannot be evaluated using the conversions for the
arithmetic operations listed above.
E.g.,
=INLINEFT
z_Ø_EVAL_C z_Ø_˙_exp_conv
=TEX
\ will evaluate expressions involving the usual arithmetic operations and
also exponentiation of rational literals by natural number literals.
=FAILURE
117020	?0 cannot be evaluated
=ENDDOC

=DOC
val €z_Ø_lin_arith_prove_conv› : THM list -> CONV;
val €z_Ø_lin_arith_prove_tac› : THM list -> TACTIC;
=DESCRIBE
This conversion and tactic implement the linear arithmetic decision procedure
for real numbers.
The usual interface to these is via the proof context {\it z\_reals}, q.v.
=ENDDOC

\subsection{Epilogue}
=SML
end (* of signature ZReals *);
val _ = reset_flag("standard_z_paras");
=TEX
\section{PROOF CONTEXTS}
=DOC
(* Proof Context: €'z_reals› *)
=DESCRIBE
A component proof context for handling the basic arithmetic operations
for real numbers in Z. 

Expressions and predicates treated by this proof context are constructs formed from:
=GFT
+âR, *âR, -âR, /âR, ºâR, <âR, æâR, >âR, ^âZ, =
=TEX

\paragraph{Contents}\ 

Rewriting:
=GFT
z_Ø_plus_conv, z_Ø_times_conv, z_Ø_subtract_conv
z_Ø_abs_conv, z_Ø_div_conv, z_Ø_mod_conv
z_Ø_eq_conv, z_Ø_º_conv, z_Ø_less_conv
z_Ø_æ_conv, z_Ø_greater_conv,
z_Ø_plus_clauses, z_Ø_minus_clauses, z_Ø_º_clauses
z_Ø_less_clauses 
=TEX
Stripping theorems:
=GFT
z_Ø_eq_conv, z_Ø_º_conv, z_Ø_less_conv
z_Ø_æ_conv, z_Ø_greater_conv,
z_Ø_plus_clauses, z_Ø_minus_clauses, z_Ø_º_clauses
z_Ø_less_clauses, 
and all the above pushed through ≥

=TEX

Stripping conclusions: as for stripping theorems.

Rewriting canonicalisation: blank.

=TEX
Automatic proof procedures:
=INLINEFT
z_basic_prove_tac
=TEX
,
=INLINEFT
z_basic_prove_conv
=TEX
.

Automatic existence prover: blank.
=ENDDOC
=DOC
(* Proof Context: €z_Ø_lin_arith› *)
=DESCRIBE
This is a component
proof context whose main purpose is to supply a decision procedure
for problems in linear arithmetic for the real numbers in Z.
\paragraph{Contents}
The rewriting components converts Z real arithmetic expressions into equivalent HOL ones
and the automatic proof tactic then uses the HOL linear arithmetic proof context to
attempt the proof.
=ENDDOC

=TEX
\section{TEST POLICY}
The module tests for this module are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN007}.
The various conversions, tactics etc. need to be tested in addition to the
check of the theory design.


\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







