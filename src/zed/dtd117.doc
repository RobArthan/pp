=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Detailed Design of the Z Library Real Numbers }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the detailed design for the theory
of real numbers in \ProductZ.}
\end{center}}

\def\Reference{LEMMA1/HOL/DTD117}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.3 $%
}
\def\Date{\FormatDate{$Date: 2000/12/13 13:47:56 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issue 1.1-1.3] Initial development drafts.
\item[Issue 1.4] Corrected errors in theorems about associativity and multiplication and
some improvements to the treatment of unary negation in the proof contexts.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document contains the detailed design
of the Z Library theory of real numbers and their proof support.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.


\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{PREAMBLE}
=SML
open_theory"z_numbers";
push_pc "z_sets_alg";
delete_theory"z_reals" handle Fail _ => ();
set_flag ("z_type_check_only", false);
set_flag ("z_use_axioms", true);
new_theory"z_reals";
new_parent"¯";
=TEX
\section {DEFINITION OF FIXITY}

¹Z
fun 2 _ ..‰R _
°

¹Z
fun 3 _ +‰R _, _ -‰R _
°

¹Z
fun 4 _ *‰R _, _ /‰R _, _ /‰Z _
°

¹Z
fun 5 ~‰R _
°
¹Z
fun 5 abs‰R _
°

¹Z
fun 6 _ ^‰Z _
°

¹Z
rel _ <‰R _, _ ¼‰R _, _ ¾‰R _, _ >‰R _
°

\section{THE REAL NUMBERS}

\subsection{The Numbers and their Basic Operators}

We need to break out into extended Z to define the reals and their operators.
=SML
val _ = set_flag("standard_z_paras", false);
=TEX
¹Z
¯ ¦ U[¬Totality:¯ SET®]
°
Now we define the ordering properties of the real numbers.
=TEX

We characterise the main operators as being the same as the HOL ones:
¹ZAX
Ü Û_<‰R_Ý : ¯ ª ¯ ;
Ü Û_ ¼‰R _Ý : ¯ ª ¯ ;
Ü Û~‰R_Ý  : ¯ ­ ¯ ;
Ü Û_+‰R_Ý : ¯ ¸ ¯ ­ ¯ ;
Ü Û_*‰R_Ý : ¯ ¸ ¯ ­ ¯ ;
Ü Û_/‰R_Ý : ¯ ¸ ¯ ­ ¯ ;
Ü Ûabs‰R_Ý : ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx, y: ¯· x <‰R y ¤ ¬x <‰R y® ;
Ü	µx, y: ¯· x ¼‰R y ¤ ¬x ¼‰R y® ;
Ü	µx: ¯· ~‰R x = ¬~‰R x® ;
Ü	µx, y: ¯· x +‰R y = ¬x +‰R y® ;
Ü	µx, y: ¯· x *‰R y = ¬x *‰R y® ;
Ü	µx, y: ¯· x /‰R y = ¬x /‰R y® ;
Ü	µx: ¯· abs‰R x = ¬Abs‰R x®
°
¹ZAX
Ü Û_ >‰R _Ý : ¯ ª ¯ ;
Ü Û_ ¾‰R _Ý : ¯ ª ¯ ;
Ü Û_-‰R_Ý : ¯ ¸ ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx, y: ¯· x >‰R y ¤ y <‰R x ;
Ü	µx, y: ¯· x ¾‰R y ¤ y ¼‰R x ;
Ü	µx, y: ¯· x -‰R y = x +‰R ~‰R y
°

Conversion of integers to reals:
¹ZAX
Ü	ÛrealÝ: ú ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	real 1 = ¬î¯ 1®
Ü±	(µi: ú· real (~i) = ~‰R (real i))
Ü±	(µi, j: ú· real (i + j) = real i +‰R real j)
°

Division (of one integer by another):
¹ZAX
Ü	Û_/‰Z_Ý: ú ¸ ú ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi, j : ú· i /‰Z j = real i /‰R real j
°

=TEX
Exponentiation (with integer exponents):

¹ZAX
Ü	Û_^‰Z_Ý: ¯ ¸ ú ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	¬µx m· ñx ^‰Z ¬Z'Int m®® = x ^‰N m®
Ü±	¬µx m· ñx ^‰Z ~ ¬Z'Int m®® =  î¯ 1 /‰R (x ^‰N m)®
°
=TEX
Interval:

¹ZAX
Ü	Û_..‰R_Ý: ¯ ¸ ¯ ­ ð ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx, y : ¯·x ..‰R y = { t : ¯ | x ¼‰R t ¼‰R y }
°
=THDOC
req_name Û"z_reals"Ý (Value "z_numbers");
req_parent"¯";
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_reals$ contains the theory of real numbers for Z.
Standard ML bindings for the theory are contained in the structure {\it ZReals}..
=ENDDOC

=TEX
\section{THEOREMS}
=THDOC
req_thm(Û"z_¯_unbounded_below_thm"Ý, ([], ñ µ x : ¯ · ¶ y : ¯ · y <‰R x®));
req_thm(Û"z_¯_unbounded_above_thm"Ý, ([], ñ µ x : ¯ · ¶ y : ¯ · x <‰R y®));
req_thm(Û"z_¯_less_irrefl_thm"Ý, ([], ñ µ x : ¯ · ³ x <‰R x®));
req_thm(Û"z_¯_less_antisym_thm"Ý, ([], ñ µ x, y : ¯ · ³ (x <‰R y ± y <‰R x)®));
req_thm(Û"z_¯_less_trans_thm"Ý, ([],
	ñ µ x, y, z : ¯ · x <‰R y ± y <‰R z ´ x <‰R z®));
req_thm(Û"z_¯_less_cases_thm"Ý, ([], ñ µ x, y : ¯ · x <‰R y ² x = y ² y <‰R x®));
req_thm(Û"z_¯_less_³_eq_thm"Ý, ([], ñ µ x, y : ¯ · x <‰R y ´ ³ x = y®));
req_thm(Û"z_¯_less_dense_thm"Ý, ([],
	ñ µ x, y : ¯ · x <‰R y ´ (¶ z : ¯ · x <‰R z ± z <‰R y)®));
req_thm(Û"z_¯_complete_thm"Ý, ([], ñ µ A : ð ¯ ·
	³ A = {} ± (¶ b : ¯ · µ x : ¯ · x  A ´ x ¼‰R b) ´
	(¶ s : ¯·
		(µ x : ¯ · x  A ´ x ¼‰R s)
	±	(µ b : ¯ · (µ x : ¯ · x  A ´ x ¼‰R b) ´ s ¼‰R b))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(Û"z_¯_¼_cases_thm"Ý, ([], ñ µ x, y : ¯ · x ¼‰R y ² y ¼‰R x®));
req_thm(Û"z_¯_¼_less_cases_thm"Ý, ([], ñ µ x, y : ¯ · x ¼‰R y ² y <‰R x®));
req_thm(Û"z_¯_eq_¼_thm"Ý, ([], ñ µ x, y : ¯ · x = y ¤ x ¼‰R y ± y ¼‰R x®));
req_thm(Û"z_¯_¼_antisym_thm"Ý, ([], ñ µ x, y : ¯ · x ¼‰R y ± y ¼‰R x ´ x = y®));
req_thm(Û"z_¯_less_¼_trans_thm"Ý,
	([], ñ µ x, y, z : ¯ · x <‰R y ± y ¼‰R z ´ x <‰R z®));
req_thm(Û"z_¯_¼_less_trans_thm"Ý,
	([], ñ µ x, y, z : ¯ · x ¼‰R y ± y <‰R z ´ x <‰R z®));
req_thm(Û"z_¯_¼_refl_thm"Ý, ([], ñ µ x : ¯ · x ¼‰R x®));
req_thm(Û"z_¯_¼_trans_thm"Ý, ([],
	ñ µ x, y, z : ¯ · x ¼‰R y ± y ¼‰R z ´ x ¼‰R z®));
req_thm(Û"z_¯_¼_³_less_thm"Ý, ([], ñ µ x, y : ¯ · x ¼‰R y ¤ ³ y <‰R x®));
req_thm(Û"z_¯_³_¼_less_thm"Ý, ([], ñ µ x, y : ¯ · ³ x ¼‰R y ¤ y <‰R x®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(Û"z_¯_plus_assoc_thm"Ý, ([],
	ñ µ x, y, z : ¯ · (x +‰R y) +‰R z = x +‰R y +‰R z®));
req_thm(Û"z_¯_plus_assoc_thm1"Ý, ([],
	ñ µ x, y, z : ¯ · x +‰R y +‰R z = (x +‰R y) +‰R z®));
req_thm(Û"z_¯_plus_comm_thm"Ý, ([],
	ñ µ x, y : ¯ · x +‰R y = y +‰R x®));
req_thm(Û"z_¯_plus_unit_thm"Ý, ([],
	ñ µ x : ¯ · x +‰R real 0 = x®));
req_thm(Û"z_¯_plus_mono_thm"Ý, ([],
	ñ µ x, y, z : ¯ · y <‰R z ´ x +‰R y <‰R x +‰R z®));
req_thm(Û"z_¯_plus_mono_thm1"Ý, ([],
	ñ µ x, y, z : ¯ · y <‰R z ´ y +‰R x <‰R z +‰R x®));
req_thm(Û"z_¯_plus_mono_thm2"Ý, ([],
	ñ µ x, y, s, t : ¯ · x <‰R y ± s <‰R t ´ x +‰R s <‰R y +‰R t®));
req_thm(Û"z_¯_plus_0_thm"Ý, ([],
	ñ µ x : ¯ · x +‰R real 0 = x ± real 0 +‰R x = x®));
req_thm(Û"z_¯_plus_order_thm"Ý, ([],
	ñ µ x, y, z : ¯ · y +‰R x = x +‰R y
		±	(x +‰R y) +‰R z = x +‰R y +‰R z
		±	y +‰R x +‰R z = x +‰R y +‰R z®));
req_thm(Û"z_¯_plus_minus_thm"Ý, ([],
	ñ µ x : ¯ · x +‰R ~‰R x = real 0 ± ~‰R x +‰R x = real 0®));
req_thm(Û"z_¯_eq_thm"Ý, ([],
	ñ µ x, y : ¯ · x = y ¤ x +‰R ~‰R y = real 0®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(Û"z_¯_minus_clauses"Ý, ([],
	ñ µ x, y : ¯ ·
		~‰R ~‰R x = x
		±	x +‰R ~‰R x = real 0
		±	~‰R x +‰R x = real 0
		±	~‰R (x +‰R y) = ~‰R x +‰R ~‰R y
		±	~‰R real 0 = real 0®));
req_thm(Û"z_¯_minus_eq_thm"Ý, ([], ñ µ x, y : ¯ · ~‰R x = ~‰R y ¤ x = y®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(Û"z_¯_plus_clauses"Ý, ([], ñ µ x, y, z : ¯ · (x +‰R z = y +‰R z ¤ x = y)
±	(z +‰R x = y +‰R z ¤ x = y)
±	(x +‰R z = z +‰R y ¤ x = y)
±	(z +‰R x = z +‰R y ¤ x = y)
±	(x +‰R z = z ¤ x = real 0)
±	(z +‰R x = z ¤ x = real 0)
±	(z = z +‰R y ¤ y = real 0)
±	(z = y +‰R z ¤ y = real 0)
±	x +‰R real 0 = x
±	real 0 +‰R x = x
±	³ real 1 = real 0
±	³ real 0 = real 1®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(Û"z_¯_less_clauses"Ý, ([], ñ µ x, y, z : ¯ · (x +‰R z <‰R y +‰R z ¤ x <‰R y)
±	(z +‰R x <‰R y +‰R z ¤ x <‰R y)
±	(x +‰R z <‰R z +‰R y ¤ x <‰R y)
±	(z +‰R x <‰R z +‰R y ¤ x <‰R y)
±	(x +‰R z <‰R z ¤ x <‰R real 0)
±	(z +‰R x <‰R z ¤ x <‰R real 0)
±	(x <‰R z +‰R x ¤ real 0 <‰R z)
±	(x <‰R x +‰R z ¤ real 0 <‰R z)
±	³ x <‰R x
±	real 0 <‰R real 1
±	³ real 1 <‰R real 0®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(Û"z_¯_¼_clauses"Ý, ([], ñ µ x, y, z : ¯ · (x +‰R z ¼‰R y +‰R z ¤ x ¼‰R y)
±	(z +‰R x ¼‰R y +‰R z ¤ x ¼‰R y)
±	(x +‰R z ¼‰R z +‰R y ¤ x ¼‰R y)
±	(z +‰R x ¼‰R z +‰R y ¤ x ¼‰R y)
±	(x +‰R z ¼‰R z ¤ x ¼‰R real 0)
±	(z +‰R x ¼‰R z ¤ x ¼‰R real 0)
±	(x ¼‰R z +‰R x ¤ real 0 ¼‰R z)
±	(x ¼‰R x +‰R z ¤ real 0 ¼‰R z)
±	x ¼‰R x
±	real 0 ¼‰R real 1
±	³ real 1 ¼‰R real 0®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm(Û"z_¯_times_assoc_thm"Ý, ([],
	ñ µ x, y, z : ¯ · (x *‰R y) *‰R z = x *‰R y *‰R z®));
req_thm(Û"z_¯_times_assoc_thm1"Ý, ([],
	ñ µ x, y, z : ¯ · x *‰R y *‰R z = (x *‰R y) *‰R z®));
req_thm(Û"z_¯_times_comm_thm"Ý, ([], ñ µ x, y : ¯ · x *‰R y = y *‰R x®));
req_thm(Û"z_¯_times_unit_thm"Ý, ([], ñ µ x : ¯ · x *‰R real 1 = x®));
req_thm(Û"z_¯_0_less_0_less_times_thm"Ý, ([], ñ µ x, y : ¯ · real 0 <‰R x
±	real 0 <‰R y ´ real 0 <‰R x *‰R y®));
req_thm(Û"z_¯_times_plus_distrib_thm"Ý, ([],
	ñ µ x, y, z : ¯ · x *‰R (y +‰R z) = x *‰R y +‰R x *‰R z
±	(x +‰R y) *‰R z = x *‰R z +‰R y *‰R z®));
req_thm(Û"z_¯_times_order_thm"Ý, ([], ñ µ x, y, z : ¯ · y *‰R x = x *‰R y
±	(x *‰R y) *‰R z = x *‰R y *‰R z
±	y *‰R x *‰R z = x *‰R y *‰R z®));
req_thm(Û"z_¯_times_clauses"Ý, ([], ñ µ x : ¯ · real 0 *‰R x = real 0
±	x *‰R real 0 = real 0
±	x *‰R real 1 = x
±	real 1 *‰R x = x®));
req_thm(Û"z_¯_over_thm"Ý, ([], ñ (µ y, z : ¯ · ³ z = real 0 ´ (y *‰R z) /‰R z = y)
±	(µ x, y, z : ¯ · ³ z = real 0 ´ (x *‰R y) /‰R z = x *‰R y /‰R z)®));
=DESCRIBE
=ENDDOC

=TEX
\section{SIGNATURE}
=SML
signature ÛZRealsÝ = sig
=TEX

\subsection{Definitions}
=DOC
val Ûz_¯_ú_exp_defÝ : THM;
val Ûz_¯_¾_defÝ : THM;
val Ûz_¯_¼_defÝ : THM;
val Ûz_¯_abs_defÝ : THM;
val Ûz_¯_defÝ : THM;
val Ûz_¯_dot_dot_defÝ : THM;
val Ûz_¯_frac_defÝ : THM;
val Ûz_¯_greater_defÝ : THM;
val Ûz_¯_less_defÝ : THM;
val Ûz_¯_minus_defÝ : THM;
val Ûz_¯_over_defÝ : THM;
val Ûz_¯_plus_defÝ : THM;
val Ûz_¯_real_defÝ : THM;
val Ûz_¯_subtract_defÝ : THM;
val Ûz_¯_times_defÝ : THM;
=DESCRIBE
ML bindings for the definitions in the theory of real numbers.
=ENDDOC

\subsection{Theorems}
=DOC
val Ûz_¯_complete_thmÝ : THM;
val Ûz_¯_unbounded_above_thmÝ : THM;
val Ûz_¯_unbounded_below_thmÝ : THM;
val Ûz_¯_less_antisym_thmÝ : THM;
val Ûz_¯_less_cases_thmÝ : THM;
val Ûz_¯_less_clausesÝ : THM;
val Ûz_¯_less_dense_thmÝ : THM;
val Ûz_¯_less_irrefl_thmÝ : THM;
val Ûz_¯_less_thmÝ : THM;
val Ûz_¯_less_trans_thmÝ : THM;
=DESCRIBE
These are ML bindings for the theorems that characterise the ordering relation
=INLINEFT
_<‰R_
=TEX
\ on the real numbers.
=ENDDOC
=DOC
val Ûz_¯_eq_¼_thmÝ : THM;
val Ûz_¯_eq_thmÝ : THM;
val Ûz_¯_less_¼_trans_thmÝ : THM;
val Ûz_¯_less_³_eq_thmÝ : THM;
val Ûz_¯_¼_³_less_thmÝ : THM;
val Ûz_¯_¼_antisym_thmÝ : THM;
val Ûz_¯_¼_cases_thmÝ : THM;
val Ûz_¯_¼_clausesÝ : THM;
val Ûz_¯_¼_less_cases_thmÝ : THM;
val Ûz_¯_¼_less_trans_thmÝ : THM;
val Ûz_¯_¼_refl_thmÝ : THM;
val Ûz_¯_¼_thmÝ : THM;
val Ûz_¯_¼_trans_thmÝ : THM;
val Ûz_¯_³_¼_less_thmÝ : THM;
val Ûz_¯_³_less_¼_thmÝ : THM;
val Ûz_¯_0_less_0_less_times_thmÝ : THM;

val Ûz_¯_greater_thmÝ : THM;
val Ûz_¯_¾_thmÝ : THM;
=DESCRIBE
These are ML bindings for theorems that deal with the equality and ordering relations.
=ENDDOC
=DOC
val Ûz_¯_minus_clausesÝ : THM;
val Ûz_¯_minus_eq_thmÝ : THM;
val Ûz_¯_minus_lit_thm1Ý : THM;
val Ûz_¯_minus_lit_thm2Ý : THM;
val Ûz_¯_minus_thmÝ : THM;
val Ûz_¯_plus_0_thmÝ : THM;
val Ûz_¯_plus_assoc_thmÝ : THM;
val Ûz_¯_plus_assoc_thm1Ý : THM;
val Ûz_¯_plus_clausesÝ : THM;
val Ûz_¯_plus_comm_thmÝ : THM;
val Ûz_¯_plus_minus_thmÝ : THM;
val Ûz_¯_plus_mono_thmÝ : THM;
val Ûz_¯_plus_mono_thm1Ý : THM;
val Ûz_¯_plus_mono_thm2Ý : THM;
val Ûz_¯_plus_order_thmÝ : THM;
val Ûz_¯_plus_thmÝ : THM;
val Ûz_¯_plus_unit_thmÝ : THM;
val Ûz_¯_subtract_thmÝ : THM;
=DESCRIBE
ML bindings for theorems about addition, unary minus and subtraction for the real numbers.
=ENDDOC
=DOC
val Ûz_¯_real_î¯_thmÝ : THM;
val Ûz_¯_real_0_thmÝ : THM;
=DESCRIBE
ML bindings for theorems relating Z integer real literals with HOL ones.
=ENDDOC
=DOC
val Ûz_¯_times_assoc_thmÝ : THM;
val Ûz_¯_times_assoc_thm1Ý : THM;
val Ûz_¯_times_clausesÝ : THM;
val Ûz_¯_times_comm_thmÝ : THM;
val Ûz_¯_times_order_thmÝ : THM;
val Ûz_¯_times_plus_distrib_thmÝ : THM;
val Ûz_¯_times_thmÝ : THM;
val Ûz_¯_times_unit_thmÝ : THM;
val Ûz_¯_over_thmÝ : THM;
=DESCRIBE
ML bindings for theorems about multiplication and division of real numbers.
=ENDDOC

\subsection{Conversions and Tactics}

=DOC
val Ûz_¯_¼_convÝ : CONV;		(* _¼‰R _ *)
val Ûz_¯_eq_convÝ : CONV;		(* _=_ *)
val Ûz_¯_less_convÝ : CONV;		(* _<‰R _ *)
val Ûz_¯_minus_convÝ : CONV;		(* ~‰R *)
val Ûz_¯_over_convÝ : CONV;		(* _/‰R _ *)
val Ûz_¯_plus_convÝ : CONV;		(* _+‰R _ *)
val Ûz_¯_times_convÝ : CONV;		(* _*‰R _ *)
val Ûz_¯_ú_exp_convÝ : CONV;		(* _^‰Z _ *)

val Ûz_¯_greater_convÝ : CONV;		(* _>‰R _ *)
val Ûz_¯_¾_convÝ : CONV;		(* _¾‰R _ *)
val Ûz_¯_subtract_convÝ : CONV;	(* _-‰R _ *)

val Ûz_¯_lit_norm_convÝ : CONV;

val Ûz_¯_lit_convÝ : CONV;		val Ûz_¯_lit_conv1Ý : CONV;
=DESCRIBE
These are conversions for carrying out real arithmetic computation.
The first and second blocks of conversions deal with expressions of the form {\it c op d},
where {\it c} and {\it d} are real literal expressions (see below) and
where {\it op} is the operator given in the ML comment alongside the conversion above.
The conversions in the first block actually carry out the computation to
give a theorem {\it c op d = e} or
=INLINEFT
c op d ¤ v
=TEX
\ where {\it e} and {\it v} are a real literal expression or a truth value as appropriate.

The conversions in the second block rewrite their argument in terms of the operators
supported by the conversions in the first block.

The conversion
=INLINEFT
z_¯_lit_norm_conv
=TEX
\ normalises real literal expressions, i.e., expressions of either of
the forms
=INLINEFT
real i
=TEX
\ or
=INLINEFT
i /‰Z j
=TEX
, where {\it i} and {\it j} are optionally signed integer literals.
The conversion puts the result in a normal form, where the sign if any is
moved to the outside, where
=INLINEFT
real
=TEX
\ is used whenever possible and where if the form
=INLINEFT
i /‰Z j
=TEX
\ has to be used, {\it i} and {it j} are taken to be coprime.
This conversion fails if its argument cannot be normalised or is already in the normal form.

The final two conversions convert to and from Z and HOL real literal expressions.

=FAILURE
117001	?0 is not a Z real fraction with integer literal operands
117002	?0 is not an HOL real fraction with literal operands
=ENDDOC
=DOC
val Ûz_¯_lin_arith_prove_convÝ : THM list -> CONV;
val Ûz_¯_lin_arith_prove_tacÝ : THM list -> TACTIC;
=DESCRIBE
This conversion and tactic implement the linear arithmetic decision procedure
for real numbers.
The usual interface to these is via the proof context {\it z\_reals}, q.v.
=ENDDOC

\subsection{Epilogue}
=SML
end (* of signature ZReals *);
val _ = reset_flag("standard_z_paras");
=TEX
\section{PROOF CONTEXTS}
=DOC
(* Proof Context: Û'z_realsÝ *)
=DESCRIBE
A component proof context for handling the basic arithmetic operations
for real numbers in Z. 

Expressions and predicates treated by this proof context are constructs formed from:
=GFT
+‰R, *‰R, -‰R, /‰R, ¼‰R, <‰R, ¾‰R, >‰R, ^‰Z, =
=TEX

\paragraph{Contents}\ 

Rewriting:
=GFT
z_¯_plus_conv, z_¯_times_conv, z_¯_subtract_conv
z_¯_abs_conv, z_¯_div_conv, z_¯_mod_conv
z_¯_eq_conv, z_¯_¼_conv, z_¯_less_conv
z_¯_¾_conv, z_¯_greater_conv,
z_¯_plus_clauses, z_¯_minus_clauses, z_¯_¼_clauses
z_¯_less_clauses 
=TEX
Stripping theorems:
=GFT
z_¯_eq_conv, z_¯_¼_conv, z_¯_less_conv
z_¯_¾_conv, z_¯_greater_conv,
z_¯_plus_clauses, z_¯_minus_clauses, z_¯_¼_clauses
z_¯_less_clauses, 
and all the above pushed through ³

=TEX

Stripping conclusions: as for stripping theorems.

Rewriting canonicalisation: blank.

=TEX
Automatic proof procedures:
=INLINEFT
z_basic_prove_tac
=TEX
,
=INLINEFT
z_basic_prove_conv
=TEX
.

Automatic existence prover: blank.
=ENDDOC
=DOC
(* Proof Context: Ûz_¯_lin_arithÝ *)
=DESCRIBE
This is a component
proof context whose main purpose is to supply a decision procedure
for problems in linear arithmetic for the real numbers in Z.
\paragraph{Contents}
The rewriting components converts Z real arithmetic expressions into equivalent HOL ones
and the automatic proof tactic then uses the HOL linear arithmetic proof context to
attempt the proof.
=ENDDOC

=TEX
\section{TEST POLICY}
The module tests for this module are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN007}.
The various conversions, tactics etc. need to be tested in addition to the
check of the theory design.


\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







