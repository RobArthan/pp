=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD042}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout  & WIN01\\K.~Blackburn&WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and theorems for the Proof Power Z set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}

\item [Issue 1.1]  First draft.
\item [Issue 1.2 (19th August 1992)]
Taken over by K.Blackburn, and heavily reworked.
\item [Issue 1.3 (8th September 1992)]
Further development.
\item [Issue 1.4 (10th September 1992)]
Correcting text.
\item [Issue 1.5 (10th September 1992)]
Added $z\_≠\_app\_thm$, $z\_setd\_Ä\_conv$.
Removed use of $Ì$ from RHS of rewrite theorems.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for some of the 
derived rules of inference, conversions and theorems for
the Z Proof Support System, described in \cite{DS/FMU/IED/HLD015}. The rules and theorems cover set theory and associated constructs.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP042}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and theorems for the set theory of the Z proof support system. This covers :
\begin{itemize}
\item
set abstractions
\item
set displays
\item
tuples and cartesian products
\end{itemize}
See \cite{DS/FMU/IED/DTD041} 
for the Z predicate calculus, function application, $Ã$ and $Õ$.

See \cite{DS/FMU/IED/DTD043} 
for the Z schema calculus.

See \cite{???}
for numbers, bags, sequences and finiteness.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP041}.
\subsubsection{Deficiencies}
Perhaps ought to use theory check mechanisms.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $Ò...Æ$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $¡\_to\_z\_conv$ to correct
what problems it can.

\section{SET THEORY}
=DOC
signature €ZSetTheory› = sig
=DESCRIBE
This provides the rules of inference, conversions and theorems for set theory, tuples and cartesian products in the Z proof support system.
=ENDDOC
=THDOC
req_name €"z_set_theory"› (Value "z_library");
req_language "Z";
=DESCRIBE
The theory ``$z\_set\_theory$'' contains various ``defining theorems'' of Z set constants, derived from the definitions of
those constants, and consistency theorems for those
constants where necessary.
It is created in structure $ZPredicateCalculus$,
but primarily added to in 
structure $ZSetTheory$.
=ENDDOC
=THDOC
req_consistency_thm ¨$"z'_ ™ _"Æ;
req_consistency_thm ¨$"z'ö"Æ;
req_consistency_thm ¨$"z'â1 _"Æ;
req_consistency_thm ¨$"z'id _"Æ;
req_consistency_thm ¨$"z'_ ﬂ _"Æ;
req_consistency_thm ¨$"z'_ ≠ _"Æ;
req_consistency_thm ¨$"z'_ ˛ _"Æ;
req_consistency_thm ¨$"z'_ ‡ _"Æ;
req_consistency_thm ¨$"z'_ œ _"Æ;
req_consistency_thm ¨$"z'_ Ô _"Æ;
req_consistency_thm ¨$"z'_ è _"Æ;
=DESCRIBE
Consistency theorems for various constants implementing
Z predicate calculus and set theory.
=ENDDOC

\subsection{Reflexivity, Symmetry, Transitivity of Equality}
The reflexivity of equality considered as a conversion is implemented by $refl\_conv$ in HOL, see \cite{DS/FMU/IED/DTD007}. 
This conversion may also be used for Z terms. 

Similarly $eq\_sym\_conv$ and $eq\_trans\_rule$ also apply to Z.
\subsection{Extensionality}
=THDOC
req_thm(€"z_sets_ext_thm"›, ([],¨µ x y:'a SET∑
	Ò(x = y) = 
	(µz: U∑ ((z ç x) § (z ç y)))ÆÆ));
=DESCRIBE
The extensionality theorem for the equality of two sets.
=ENDDOC

\subsection{Power Set}
=THDOC
req_thm(€"z__thm"›, ([],¨µ t u:'a SET∑
	Ò(t ç  u) = (µz: U∑ ((z ç t) ¥ (z ç u)))ÆÆ));
=DESCRIBE
Power set.
=ENDDOC
=TEX
\subsection{Set Abstraction}
=DOC
val €z_ç_seta_conv› : CONV;
=DESCRIBE
A conversion of membership of a Z set abstraction into a Z existential quantification. Bound variables in the existential quantification are renamed as necessary.
=FRULE 1 Conversion
Z_seta_elim_conv 
Òt ç { D | P∑ T}Æ
˜
˜
Ù (t ç { D | P∑ T}) = 
  (∂ D | P∑ T = t)
=TEX
Remains within the Z language.
=FAILURE
42001	?0 is not a set abstraction
=ENDDOC
=TEX
\subsection{Set Display}
=DOC
val €z_ç_setd_conv› : CONV;
=DESCRIBE
A conversion of membership of a Z set display into equality with a member of the set.
=FRULE 1 Conversion
Z_ç_setd_conv 
Òt ç { tâ1, tâ2, ...}Æ
˜
˜
Ù t ç { tâ1, tâ2, ...} =
((t = tâ1) ≤ (t = tâ2) ...)
=TEX
Remains within the Z language.
=SEEALSO
$z\_ç\_setd\_conv1$
=FAILURE
42002	?0 is not of the form: Òx ç {t1,...}Æ
42008	?0 is an ill-formed fragment of the membership of a set display
=ENDDOC
=DOC
val €z_ç_setd_conv1› : CONV;
=DESCRIBE
A conversion proving membership of a Z set display where
the member is syntactically identical
(up to $¡$-conversion) to a member of the set.
=FRULE 1 Conversion
Z_ç_setd_conv1 
Òt ç { ..., t, ...}Æ
˜

˜
Ù t ç { ..., t, ...} = true
=TEX
Remains within the Z language.
=SEEALSO
$z\_ç\_setd\_conv$
=FAILURE
42009	?0 is not of the form: Òt ç {...,t,...}Æ
=ENDDOC
=TEX
\subsection{Set Theorems From the Z Mathematical Toolkit}
The following theorems are mostly just definitions
instantiated to $ÒUÆ$ where appropriate,
perhaps with the addition of set extensionality.
=THDOC
req_thm(€"z_Ω_thm"›, ([],¨µ x y:'a∑ Ò(x Ω y) § ≥(x = y)ÆÆ));
req_thm(€"z_é_thm"›, ([],¨µ S:'a SET; x:'a∑
	Òx é S § ≥(x ç S)ÆÆ));
=DESCRIBE
Inequality and ``non-membership''.
=ENDDOC
Spivey Ed 1. page 89.

=THDOC
req_thm(€"z_ö_thm"›, ([],¨µ z:'a∑ Ò≥(z ç ö)ÆÆ));
req_thm(€"z_Ä_thm"›, ([],¨µ s t:'a SET∑
	Ò(s Ä t) § (µ x:U∑x ç s ¥ x ç t)ÆÆ));
req_thm(€"z_†_thm"›, ([],¨µ s t: 'a SET∑
	Ò(s † t) § (s Ä t) ± s Ω tÆÆ));
req_thm(€"z_â1_thm"›, ([],Ò(â1 _) = {S : U | S Ω ö∑ S}Æ));
=DESCRIBE
Empty set, subset, proper subset and non-empty power set.
=ENDDOC
Spivey Ed 1. page 90.
=DOC
val €z_setd_Ä_conv› : CONV
=DESCRIBE
Expand out expressions that state that a set display
is a subset of some other set.
This is particularly aimed at processing declarations
of the form 
=INLINEFT
xâ1,...,xân : X
=TEX
{}.
=FRULE 1 Conversion
z_setd_Ä_conv
Ò{xâ1,...} Ä XÆ
˜
˜
Ò{xâ1,...} Ä X §
(xâ1 ç X ± ...) 
=TEX
and
=FRULE 1 Conversion
z_setd_Ä_conv
Ò{} Ä XÆ
˜
˜
Ò{} Ä X § true
=TEX
The conversion will all simplify certain subterms involving
$true$ or terms of the form $x\_=\_x$.

Remains within the Z language.
=FAILURE
42010	?0 is not of the form Ò{xâ1,...} Ä XÆ
=ENDDOC
=THDOC
req_thm(€"z_¿_thm"›, ([],¨µ z:'a; s t:'a SET∑
	Òz ç (s ¿ t) § z ç s ≤ z ç tÆÆ));
req_thm(€"z_°_thm"›, ([],¨µ z:'a; s t:'a SET∑
	Òz ç (s ° t) § z ç s ± z ç tÆÆ));
req_thm(€"z_set_dif_thm"›, ([],¨µ z:'a; s t:'a SET∑
	Òz ç (s \ t) § z ç s ± (z é t)ÆÆ));
=DESCRIBE
Set union, intersection and difference.
=ENDDOC
Spivey Ed 1. page 91.

=THDOC
req_thm(€"z_ﬁ_thm"›, ([],¨µ z:'a; a:'a SET SET∑
	Òz ç ﬁ a § (∂ S : a∑ z ç S)ÆÆ));
req_thm(€"z_•_thm"›, ([],¨µ z:'a; a:'a SET SET∑
	Òz ç • a § (µ S : a∑ z ç S)ÆÆ));
=DESCRIBE
Generalised set union and intersection.
=ENDDOC
Spivey Ed 1. page 92.


\section{TUPLES}
=DOC
val €z_tuple_eq_conv› : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_eq_conv 
Ò(tâ1,tâ2,...) = (uâ1,uâ2,...)Æ
˜
˜
Ù (tâ1,tâ2,...) = (uâ1,uâ2,...) § 
((tâ1 = uâ1) ± (tâ2 = uâ2) ± ...) 
=TEX
$x\ Ì\ y$ will be treated as a 2-tuple.

Remains within the Z language.
=FAILURE
42003	?0 is not of the form: Ò(x1,...) = (y1,...)Æ
=ENDDOC
=DOC
val €z_tuple_selection_conv› : CONV;
=DESCRIBE
This conversion carries out the
selection from a tuple display.
=FRULE 1 Conversion
z_tuple_selection_conv 
Ò(tâ1,...,tâi,...,tân).iÆ
˜
˜
Ù (tâ1,...,tâi,...,tân).i = tâi
=TEX
$x\ Ì\ y$ will be treated as a 2-tuple.
=FAILURE
47185	?0 is not a Z tuple selection
42006	?0 is not of the form Ò(x,...).iÆ
=ENDDOC
=DOC
val €z_tuple_intro_conv› : CONV;
=DESCRIBE
This conversion carries out the
elimination of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_intro_conv 
Ò(t.1,...,t.n)Æ
˜
˜
Ù (t.1,...,t.n) = t
=TEX
where $n$ is the arity of $t$.
$x\ Ì\ y$ will be treated as a 2-tuple.
=FAILURE
42005	?0 is not of the form: Ò(t.1,...,t.n)Æ
=ENDDOC
=DOC
val €z_tuple_selection_intro_conv› : CONV;
=DESCRIBE
This conversion carries out the
introduction of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_selection_intro_conv 
ÒtÆ
˜
˜
Ù t = (t.1,...,t.n)
=TEX
=FAILURE
42004	?0 does not have a Z tuple type
=ENDDOC
\subsection{Tuple Theorems From the Z Mathematical Toolkit}
The following theorems are mostly just definitions
instantiated to $ÒUÆ$ where appropriate,
perhaps with the addition of set extensionality.
=THDOC
req_thm(€"z_first_thm"›, ([],¨µ x: ('a, 'b) $"Z'T[2]"∑
	Òfirst x = x.1ÆÆ));
req_thm(€"z_second_thm"›, ([],¨µ x: ('a, 'b) $"Z'T[2]"∑
	Òsecond x = x.2ÆÆ));
=DESCRIBE
Projections from pairs.
=ENDDOC
These theorems reflect a preference for the
general tuple selection functions.
Spivey Ed 1. page 89.

\section{CARTESIAN PRODUCTS}
=DOC
val €z_∏_conv› : CONV;
=DESCRIBE
A conversion for eliminating cartesian products.
=FRULE 1 Conversion
z_∏_conv 
ÒTâ1 ∏ Tâ2 ∏ ...Æ
˜
˜
Ù (Tâ1 ∏ Tâ2 ∏ ...) =
	{tâ1:Tâ1; tâ2:Tâ2; ...∑(tâ1, tâ2,...)}
=TEX
The $tâi$ used are distinct from any variable names
in the $Tâi$.

Remains within the Z language.
=SEEALSO
$z\_ç\_∏\_conv$, which is a faster function, if appropriate.
=FAILURE
47160	?0 is not a Z cartesian product
=ENDDOC
=DOC
val €z_ç_∏_conv› : CONV;
=DESCRIBE
A conversion for the membership of cartesian products.
=FRULE 1 Conversion
z_ç_∏_conv 
Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
˜
˜
Ù t ç (Tâ1 ∏ Tâ2 ∏ ...) = 
	t.1 ç Tâ1 ± t.2 ç Tâ2 ± ...
=TEX
$z\_tuple\_selection\_conv$, q.v., will be atempted on each of the
tuple selections.

Remains within the Z language.
=SEEALSO
$z\_∏\_conv$
=FAILURE
42007	?0 is not of the form: Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
=ENDDOC
\section{RELATIONS}
The following theorems are mostly just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.

We choose to preserve maplets (formed by $Ì$) presented by the user,
but not to introduce new ones in, e.g., any rewriting theorems we provide. 
=THDOC
req_thm(€"z_™_thm"›, ([],¨µ X:'X SET; Y:'Y SET∑
	Ò(¨X:'X SETÆ ™ ¨Y:'Y SETÆ) = (X ∏ Y)ÆÆ));
req_thm(€"z_Ì_thm"›, ([],¨µ x:'a; y:'b∑
	Ò(x Ì y) = (x,y)ÆÆ));
=DESCRIBE
Binary relations and maplets.
=ENDDOC
Spivey Ed 1. page 95.

=THDOC
req_thm(€"z_dom_thm"›, ([],¨µ z:'a; R: ('a, 'b) $"Z'T[2]" SET∑
	Òz ç dom R § (∂ y : U∑ (z, y) ç R)ÆÆ));
req_thm(€"z_ran_thm"›, ([],¨µ z:'b; R:('a, 'b) $"Z'T[2]" SET∑
	Ò¨z:'bÆ ç ran R § (∂ x : U∑ (x, ¨z:'bÆ) ç R)ÆÆ));
=DESCRIBE
Domain and range.
=ENDDOC
Spivey Ed 1. page 96.

=THDOC
req_thm(€"z_id_thm"›, ([],¨µ X:'X SET∑ Òid ¨X:'X SETÆ = {x : ¨X:'X SETÆ∑ (x, x)}ÆÆ));
req_thm(€"z_ª_thm"›, ([],¨µ R: ('a, 'b) $"Z'T[2]" SET; S: ('b, 'c) $"Z'T[2]" SET∑
	ÒR ª S = S o RÆÆ));
req_thm(€"z_o_thm"›, ([],¨µ p: ('a, 'c) $"Z'T[2]"; S:('b, 'c) $"Z'T[2]" SET; 
	R: ('a, 'b) $"Z'T[2]" SET∑
	Ò¨p: ('a, 'c) $"Z'T[2]"Æ ç S o R § 
	 (∂ y : U∑ (¨p: ('a, 'c) $"Z'T[2]"Æ.1, y) ç R ± 
	 (y, ¨p: ('a, 'c) $"Z'T[2]"Æ.2) ç S)ÆÆ));
=DESCRIBE
Identity relation, relational composition, backward relational composition.
=ENDDOC
Spivey Ed 1. page 97.

=THDOC
req_thm(€"z_Ú_thm"›, ([],¨µ p:('a, 'b) $"Z'T[2]";
	 S:'a SET; R:('a, 'b) $"Z'T[2]" SET∑
	Òp ç S Ú R § p.1 ç S ± p ç RÆÆ));
req_thm(€"z_í_thm"›, ([],¨µ p:('a, 'b) $"Z'T[2]";
	R:('a, 'b) $"Z'T[2]" SET; S:'b SET∑
	Òp ç R í S § p ç R ± p.2 ç SÆÆ));
=DESCRIBE
Domain restriction, range restriction.
=ENDDOC
Spivey Ed 1. page 98.

=THDOC
req_thm(€"z_·_thm"›, ([],¨µ p:('a, 'b) $"Z'T[2]";
	 S:'a SET; R:('a, 'b) $"Z'T[2]" SET∑
	Òp ç S · R § p.1 é S ± p ç RÆÆ));
req_thm(€"z_Å_thm"›, ([],¨µ p:('a, 'b) $"Z'T[2]";
	R:('a, 'b) $"Z'T[2]" SET; S:'b SET∑
	Òp ç R Å S § p ç R ± p.2 é SÆÆ));
=DESCRIBE
Domain anti-restriction and range anti-restriction.
=ENDDOC
Spivey Ed 1. page 99.

=THDOC
req_thm(€"z_rel_inv_thm"›, ([],¨µ p:('a, 'b) $"Z'T[2]"; R: ('b, 'a) $"Z'T[2]" SET∑
	Òp ç R Á~Í § (p.2, p.1) ç RÆÆ));
=DESCRIBE
Relational inversion.
=ENDDOC
Spivey Ed 1. page 100.

=THDOC
req_thm(€"z_rel_image_thm"›, ([],¨µ p:'b; 
	R:('a, 'b) $"Z'T[2]" SET; S: 'a SET∑
	Ò¨p:'bÆ ç R ®  S © § (∂ x : S∑ (x, p) ç R)ÆÆ));
=DESCRIBE
Relational image.
=ENDDOC
Spivey Ed 1. page 101

=THDOC
req_thm(€"z_trans_closure_thm"›, ([],¨µ R: ('a, 'a) $"Z'T[2]" SET∑
	 ÒR Á+Í = • {Q : U | (R Ä Q) ± (Q ª Q Ä Q)∑ Q}ÆÆ));
req_thm(€"z_reflex_trans_closure_thm"›, ([],¨µ R: ('a, 'a) $"Z'T[2]" SET
∑ ÒR Á*Í
      = • {Q : U
	      | (id U Ä Q) ± (R Ä Q) ± (Q ª Q Ä Q)∑
	 Q}ÆÆ));
=DESCRIBE
Transitive and reflexive-transitive closure operations.
=ENDDOC
Spivey Ed 1. page 102

=THDOC
req_thm(€"z_ﬂ_thm"›, ([],¨µ f:('a, 'b) $"Z'T[2]" SET;
	X:'a SET; Y:'b SET∑
	Òf ç X ﬂ Y
      § f ç X ™ Y
	± (µ x : X; yâ1, yâ2 : Y∑ (x, yâ1) ç f ± (x, yâ2) ç f ¥ yâ1 = yâ2)ÆÆ));
req_thm(€"z_≠_thm"›, ([],¨µ f:('a, 'b) $"Z'T[2]" SET;
	X:'a SET; Y:'b SET∑
	Òf ç X ≠ Y § f ç X ﬂ Y ± dom f = XÆÆ));
req_thm(€"z_≠_app_thm"›, ([],¨µ X:'a SET; Y:'b SET; 
	f:('a, 'b) $"Z'T[2]" SET; x:'a∑
	Òf ç X ≠ Y ± x ç X ¥ f x ç Y ± (x, f x) ç fÆÆ));
=DESCRIBE
Partial and total functions.
=ENDDOC
Spivey Ed 1. page 105

=THDOC
req_thm(€"z_˛_thm"›, ([],¨µ f:('a, 'b) $"Z'T[2]" SET;
	X:'a SET; Y:'b SET∑
	Òf ç X ˛ Y
      § f ç X ﬂ Y ± (µ xâ1, xâ2 : dom f∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)ÆÆ));
req_thm(€"z_‡_thm"›, ([],¨µ f:('a, 'b) $"Z'T[2]" SET;
	X:'a SET; Y:'b SET∑
	Òf ç X ‡ Y
      § f ç X ≠ Y ± (µ xâ1, xâ2 : dom f∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)ÆÆ));
=DESCRIBE
Partial and total injections.
=ENDDOC
Spivey Ed 1. page 106

=THDOC
req_thm(€"z_œ_thm"›, ([], ¨µ f:('a, 'b) $"Z'T[2]" SET;
	X:'a SET; Y:'b SET∑
	Òf ç X œ Y § f ç X ﬂ Y ± ran f = YÆÆ));
req_thm(€"z_Ô_thm"›, ([],¨µ f:('a, 'b) $"Z'T[2]" SET;
	X:'a SET; Y:'b SET∑
	Òf ç X Ô Y § f ç X ≠ Y ± ran f = YÆÆ));
req_thm(€"z_è_thm"›, ([],¨µ f:('a, 'b) $"Z'T[2]" SET;
	X:'a SET; Y:'b SET∑
	Òf ç X è Y
	§ f ç X ≠ Y
	 ± ran f = Y
	 ± (µ xâ1, xâ2 : dom f∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)ÆÆ));
=DESCRIBE
Partial and total surjections, and bijections.
=ENDDOC
Spivey Ed 1. page 106

=THDOC
req_thm(€"z_´_thm"›, ([],¨µ f g: ('a, 'b) $"Z'T[2]" SET∑
	Òf ´ g = dom g · f ¿ gÆÆ));
=DESCRIBE
Functional overriding.
=ENDDOC
Spivey Ed 1. page 108

\section{MISCELLANEOUS}
=DOC
val €z_defn_simp_rule› : THM -> THM;
=DESCRIBE
This rule is a method of processing a standard style
of specification into a simple rewriting theorem.
=FRULE 1 Rule
z_defn_simp_rule
˜
Ù x ç ( y) ± (µz:y∑ z ç x § f[z])
˜
Ù ¨µ z ∑ Òz ç x § z ç y ± f[z]ÆÆ
=TEX
The rule will also attempt to preprocess its input with $z\_defn\_conv$, on the basis that the input is often from a Z definition.

Remains within the Z language.
=FAILURE
42011	?0 is not of the form `á Ù x ç ( y) ± (µz:y∑ z ç x § f[z])`
=ENDDOC
\section{PROOF CONTEXTS}
Somewhere $µ\_rewrite\_thm$ needs to get inside an early Z proof context.

Some stripping theorems (e.g. for $Ú$)
raise the dilemma of how and whether to
avoid leaving terms of the forms $Ò(x,y).1Æ$ 
(a special case is $Ò(x\ Ì\ y).1Æ$)
and $Ò(p.1,p.2)Æ$.
The first form is bad because of functionality problems;
the second is primarily bad because it is verbose,
but also because it provides a less general term for,
e.g., rewriting with.
We currently address this by including three theorems for
each problem operator, and relying on the discrimination
net effect of choosing ``the best match'' (see \cite{DS/FMU/IED/DTD008})
to get results that avoid the forms $Ò(x,y).1Æ$ and $Ò(p.1,p.2)Æ$.
We include all three theorems in both rewriting and stripping,
without relying on $z\-\_tuple\-\_selection\-\_conv$
during rewriting.
Thus for instance we include the theorems:
=GFT
Ù µ p S R∑ Òp ç S Ú R § p.1 ç S ± p ç RÆ
Ù µ p1 p2 S R∑ Ò(p1,p2) ç S Ú R § p1 ç S ± (p1,p2) ç RÆ
Ù µ p1 p2 S R∑ Ò(p1 Ì p2) ç S Ú R § p1 ç S ± (p1 Ì p2) ç RÆ
=TEX
The latter two theorems are automatically generated from the first.
This is only one possible solution, and not even necessarily the best.
Others include addressing the introduction of extensionality
variables, or ``fall back'' conversions if nothing else
applies to a term of the form $Òp\ ç\ qÆ$.
The operators affected (to date) are:
=INLINEFT
·, Å, Ú, í, and o
=TEX
{}.
=DOC
(* Proof Context: €'z_sets_alg› *)
=DESCRIBE
A component proof context for handling the algebraic manipulation of Z sets, tuples and cartesian products.
It expands memberships of terms formed by Z operators,
and provides some simplifications.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç_∏_conv,
z_tuple_eq_conv, z_tuple_selection_conv, z_tuple_intro_conv,
z_second_thm, z_first_thm
=TEX

Stripping theorems:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç_∏_conv,
z_tuple_eq_conv, 
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç_∏_conv,
z_tuple_eq_conv,
plus these all pushed in through ≥
=TEX
All three of the above also have theorems concerning the membership of terms generated by the following operators:
=GFT
´, è, Ô, ‡, œ, ˛, ≠, ﬂ, _ Á+Í, _ Á*Í, _ ® _ ©, Å, ·, í, Ú,
o, ª, id, ran, dom, ™, •, ﬁ, \, °, ¿, â1, , ö
=TEX
and
=GFT
z_é_thm, z_Ω_thm
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''.
It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_ext$
=ENDDOC

The above proof context
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language if its argument starts there.
=DOC
(* Proof Context: €'z_sets_ext› *)
=DESCRIBE
An aggressive component proof context for handling the manipulation of Z sets by breaking them into predicate calculus, plus handling for tuples and cartesian products.
It is intended to always be used in conjunction with ``$'$z$\_$sets$\_$alg''.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_sets_ext_thm, z_Ä_thm, z_†_thm, z_setd_Ä_conv,
=TEX

Stripping theorems:
=GFT
z_sets_ext_thm, z_Ä_thm, z_†_thm, z_setd_Ä_conv,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_sets_ext_thm, z_Ä_thm, z_†_thm, z_setd_Ä_conv,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to always be used in conjunction with ``$'$z$\_$sets$\_$alg''.

It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_alg$
=ENDDOC
Perhaps later releases will add rules such as 
=GFT
(a,b,...) = p § (a = p.1 ± b = p.2 ± ...)
=TEX
Extensionality where the generated $µ$ will be a block 
to further stripping (e.g. if positive in a stripped theorem)
is possibly pointless, and therefore perhaps
should be removed.

The above proof context
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language if its argument starts there.

=TEX
\section{Theorems in the Signature}
=DOC
val z_sets_ext_thm: THM;
val z__thm: THM;
val z_Ω_thm: THM;
val z_é_thm: THM;
val z_ö_thm: THM;
val z_Ä_thm: THM;
val z_†_thm: THM;
val z_â1_thm: THM;
val z_¿_thm: THM;
val z_°_thm: THM;
val z_set_dif_thm: THM;
val z_ﬁ_thm: THM;
val z_•_thm: THM;
val z_first_thm: THM;
val z_second_thm: THM;
val z_™_thm: THM;
val z_Ì_thm: THM;
val z_dom_thm: THM;
val z_ran_thm: THM;
val z_id_thm: THM;
val z_ª_thm: THM;
val z_o_thm: THM;
val z_Ú_thm: THM;
val z_í_thm: THM;
val z_·_thm: THM;
val z_Å_thm: THM;
val z_rel_inv_thm: THM;
val z_rel_image_thm: THM;
val z_trans_closure_thm: THM;
val z_reflex_trans_closure_thm: THM;
val z_ﬂ_thm: THM;
val z_≠_thm: THM;
val z_≠_app_thm: THM;
val z_˛_thm: THM;
val z_‡_thm: THM;
val z_œ_thm: THM;
val z_Ô_thm: THM;
val z_è_thm: THM;
val z_´_thm: THM;
=DESCRIBE
The ML bindings of the theorems (other than consistency ones)
in theory $z\-\_set\-\_theory$.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSetTheory *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
