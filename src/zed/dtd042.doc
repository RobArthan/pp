=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD042}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout  & WIN01\\K.~Blackburn&WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and theorems for the Proof Power Z set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}

\item [Issue 1.1]  First draft.
\item [Issue 1.2 (19th August 1992)]
Taken over by K.Blackburn, and heavily reworked.
\item [Issue 1.3 (8th September 1992)]
Further development.
\item [Issue 1.4 (10th September 1992)]
Correcting text.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for some of the 
derived rules of inference, conversions and theorems for
the Z Proof Support System, described in \cite{DS/FMU/IED/HLD015}. The rules and theorems cover set theory and associated constructs.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP042}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and theorems for the set theory of the Z proof support system. This covers :
\begin{itemize}
\item
set abstractions
\item
set displays
\item
tuples and cartesian products
\end{itemize}
See \cite{DS/FMU/IED/DTD041} 
for the Z predicate calculus, function application, $Ã$ and $Õ$.

See \cite{DS/FMU/IED/DTD043} 
for the Z schema calculus.

See \cite{???}
for numbers, bags, sequences and finiteness.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP041}.
\subsubsection{Deficiencies}
Perhaps ought to use theory check mechanisms.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $Ò...Æ$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $¡\_to\_z\_conv$ to correct
what problems it can.

\section{SET THEORY}
=DOC
signature €ZSetTheory› = sig
=DESCRIBE
This provides the rules of inference, conversions and theorems for set theory, tuples and cartesian products in the Z proof support system.
=ENDDOC
\subsection{Reflexivity, Symmetry, Transitivity of Equality}
The reflexivity of equality considered as a conversion is implemented by $refl\_conv$ in HOL, see \cite{DS/FMU/IED/DTD007}. 
This conversion may also be used for Z terms. 

Similarly $eq\_sym\_conv$ and $eq\_trans\_rule$ also apply to Z.
\subsection{Extensionality}
=DOC
val €z_sets_ext_thm› : THM;
=DESCRIBE
The extensionality theorem for the equality of two sets.
=GFT
z_sets_ext_thm = Ù ¨µ x y∑
Ò(x = y) = 
(µz: U∑ ((z ç x) § (z ç y)))ÆÆ
=TEX
=ENDDOC

\subsection{Power Set}
=DOC
val €z__thm› : THM;
=DESCRIBE
The definitional theorem for power set, $$.
=GFT
Z__thm = Ù ¨µ t u∑
Ò(t ç  u) = (µz: U∑ ((z ç t) ¥ (z ç u)))ÆÆ
=TEX
=ENDDOC
=TEX
\subsection{Set Abstraction}
=DOC
val €z_ç_seta_conv› : CONV;
=DESCRIBE
A conversion from membership of a Z set abstraction to a Z existential quantification. Bound variables in the existential quantification are renamed as necessary.
=FRULE 1 Conversion
Z_seta_elim_conv 
Òt ç { D | P∑ T}Æ
˜
˜
Ù (t ç { D | P∑ T}) = 
  (∂ D | P∑ T = t)
=TEX
Remains within the Z language.
=FAILURE
42001	?0 is not a set abstraction
=ENDDOC
=TEX
\subsection{Set Display}
=DOC
val €z_ç_setd_conv› : CONV;
=DESCRIBE
A conversion from membership of a Z set display to equality with a member of the set.
=FRULE 1 Conversion
Z_ç_setd_conv 
Òt ç { tâ1, tâ2, ...}Æ
˜
˜
Ù t ç { tâ1, tâ2, ...} =
((t = tâ1) ≤ (t = tâ2) ...)
=TEX
Remains within the Z language.
=SEEALSO
$z\_ç\_setd\_conv1$
=FAILURE
42002	?0 is not of the form: Òx ç {t1,...}Æ
42008	?0 is an ill-formed fragment of the membership of a set display
=ENDDOC
=DOC
val €z_ç_setd_conv1› : CONV;
=DESCRIBE
A conversion from membership of a Z set display where
the member is trivially equal to a member of the set.
=FRULE 1 Conversion
Z_ç_setd_conv1 
Òt ç { ..., t, ...}Æ
˜

˜
Ù t ç { ..., t, ...} = true
=TEX
Remains within the Z language.
=SEEALSO
$z\_ç\_setd\_conv$
=FAILURE
42009	?0 is not of the form: Òt ç {...,t,...}Æ
=ENDDOC
=TEX
\subsection{Set Theorems From the Z Mathematical Toolkit}
The following theorems are mostly just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.
=DOC
val €z_Ω_thm› : THM;
val €z_é_thm› : THM;
=DESCRIBE
Inequality and ``not a member of''.
=GFT
z_Ω_thm = Ù ¨µ x y∑ Ò(x Ω y) § ≥(x = y)ÆÆ

z_é_thm = Ù ¨µ S x∑ Òx é S § ≥(x ç S)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 89.

=DOC
val €z_ö_thm› : THM;
val €z_Ä_thm› : THM;
val €z_†_thm› : THM;
val €z_â1_thm› : THM;
=DESCRIBE
Empty set, subset, proper subset and non-empty power set.
=GFT
z_ö_thm = Ù ¨µ x∑ Ò≥(x ç ö)ÆÆ
z_Ä_thm = Ù ¨µ s t∑ Ò(s Ä t) § (µ x:U∑x ç s ¥ x ç t)ÆÆ
z_†_thm = Ù ¨µ s t∑ Ò(s † t) § (s Ä t) ± s Ω tÆÆ
z_â1_thm = Ù â1 _ = {S : U | S Ω ö[U]∑ S}
=TEX
=ENDDOC
Spivey Ed 1. page 90.

=DOC
val €z_¿_thm› : THM;
val €z_°_thm› : THM;
val €z_set_dif_thm› : THM;
=DESCRIBE
Set union, intersection and difference.
=GFT
z_¿_thm = Ù ¨µ z s t∑ Òz ç (s ¿ t) § z ç s ≤ z ç tÆÆ
z_°_thm = Ù ¨µ z s t∑ Òz ç (s ° t) § z ç s ± z ç tÆÆ
z_set_dif_thm = Ù ¨µ z s t∑ Òz ç (s \ t) § z ç s ± (z é t)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 91.


=DOC
val €z_ﬁ_thm› : THM;
val €z_•_thm› : THM;
=DESCRIBE
Generalised set union and intersection.
=GFT
z_ﬁ_thm = Ù ¨µ z a∑ Òz ç ﬁ a § ∂ S : a∑ z ç SÆÆ
z_•_thm = Ù ¨µ z a∑ Òz ç • a § µ S : a∑ z ç SÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 92.


\section{TUPLES}
=DOC
val €z_tuple_eq_conv› : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_eq_conv 
Ò(tâ1,tâ2,...) = (uâ1,uâ2,...)Æ
˜
˜
Ù (tâ1,tâ2,...) = (uâ1,uâ2,...) § 
((tâ1 = uâ1) ± (tâ2 = uâ2) ± ...) 
=TEX
$x\ Ì\ y$ will be treated as a 2-tuple.

Remains within the Z language.
=FAILURE
42003	?0 is not of the form: Ò(x1,...) = (y1,...)Æ
=ENDDOC
=DOC
val €z_tuple_selection_conv› : CONV;
=DESCRIBE
This conversion will carry out the appropriate
selection from an explicit tuple.
=FRULE 1 Conversion
z_tuple_selection_conv 
Ò(tâ1,...,tâi,...,tân).iÆ
˜
˜
Ù (tâ1,...,tâi,...,tân).i = tâi
=TEX
$x\ Ì\ y$ will be treated as a 2-tuple.
=FAILURE
47185	?0 is not a Z tuple selection
42006	?0 is not of the form Ò(x,...).iÆ
=ENDDOC
=DOC
val €z_tuple_intro_conv› : CONV;
=DESCRIBE
This conversion will carry out the appropriate
elimination of a tuple of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_intro_conv 
Ò(t.1,...,t.n)Æ
˜
˜
Ù (t.1,...,t.n) = t
=TEX
$x\ Ì\ y$ will be treated as a 2-tuple.
=FAILURE
42005	?0 is not of the form: Ò(t.1,...,t.n)Æ
=ENDDOC
=DOC
val €z_tuple_selection_intro_conv› : CONV;
=DESCRIBE
This conversion will carry out the appropriate
introduction of a tuple of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_selection_intro_conv 
ÒtÆ
˜
˜
Ù t = (t.1,...,t.n)
=TEX
=FAILURE
42004	?0 does not have a Z tuple type
=ENDDOC
\subsection{Tuple Theorems From the Z Mathematical Toolkit}
The following theorems are mostly just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.
=DOC
val €z_first_thm› : THM;
val €z_second_thm› : THM;
val €z_first_second_thm› : THM;
=DESCRIBE
Projections from pairs.
=GFT
z_first_thm = Ù ¨µ x y∑ Òfirst(x,y) = xÆÆ
z_second_thm = Ù ¨µ x y∑ Òsecond(x,y) = yÆÆ
z_first_second_thm = Ù ¨µ x∑ Ò(first x, second x) = xÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 89.

\section{CARTESIAN PRODUCTS}
=DOC
val €z_∏_conv› : CONV;
=DESCRIBE
A conversion for eliminating cartesian products.
=FRULE 1 Conversion
z_∏_conv 
ÒTâ1 ∏ Tâ2 ∏ ...Æ
˜
˜
Ù (Tâ1 ∏ Tâ2 ∏ ...) =
	{tâ1:Tâ1; tâ2:Tâ2; ...∑(tâ1, tâ2,...)}
=TEX
The $tâi$ used are distinct from any variable names
in the $Tâi$.

Remains within the Z language.
=SEEALSO
$z\_ç\_∏\_conv$, which is a faster function, if appropriate.
=FAILURE
47160	?0 is not a Z cartesian product
=ENDDOC
=DOC
val €z_ç_∏_conv› : CONV;
=DESCRIBE
A conversion for the membership of cartesian products.
=FRULE 1 Conversion
z_ç_∏_conv 
Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
˜
˜
Ù t ç (Tâ1 ∏ Tâ2 ∏ ...) = 
	t.1 ç Tâ1 ± t.2 ç Tâ2 ± ...
=TEX
The $tâi$ used are distinct from any variable names
in the $Tâi$.

Remains within the Z language.
=SEEALSO
$z\_∏\_conv$
=FAILURE
42007	?0 is not of the form: Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
=ENDDOC
\section{RELATIONS}
The following theorems are mostly just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.
=DOC
val €z_™_thm› : THM;
val €z_Ì_thm› : THM;
=DESCRIBE
Binary relations and maplets.
=GFT
z_™_thm = Ù ¨µ X Y∑ Ò(X ™ Y) = (X ∏ Y)ÆÆ
z_Ì_thm = Ù ¨µ X Y∑ ÒX Ì Y = (X,Y)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 95.

=DOC
val €z_dom_thm› : THM;
val €z_ran_thm› : THM;
=DESCRIBE
Domain and range.
=GFT
z_dom_thm = Ù ¨µ z R∑ Òz ç dom R § ∂ y : U∑ (z Ì y) ç RÆÆ
z_ran_thm = Ù ¨µ z R∑ Òz ç ran R § ∂ x : U∑ (x Ì z) ç RÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 96.

=DOC
val €z_id_thm› : THM;
val €z_ª_thm› : THM;
val €z_o_thm› : THM;
=DESCRIBE
Identity relation, relational composition, backward relational composition.
=GFT
z_id_thm = Ù ¨µ X∑ Òid X = {y : X∑ y Ì y}ÆÆ
val z_ª_thm = Ù ¨µ R S∑ ÒR ª S = S o RÆÆ
z_o_thm = Ù ¨µ p q S R
  ∑ Ò(p, q) ç S o R § ∂ y : U ∑ (p Ì y) ç R ± (y Ì q) ç SÆÆ 
=TEX
=ENDDOC
Spivey Ed 1. page 97.

=DOC
val €z_Ú_thm› : THM;
val €z_í_thm› : THM;
=DESCRIBE
Domain restriction, range restriction.
=GFT
z_Ú_thm = Ù ¨µ p q S R∑ Ò(p, q) ç S Ú R § p ç S ± p Ì q ç RÆÆ
z_í_thm = Ù ¨µ p q R S∑ Ò(p, q) ç R í S § p Ì q ç R ± q ç SÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 98.

=DOC
val €z_·_thm› : THM;
val €z_Å_thm› : THM;
=DESCRIBE
Domain anti-restriction and range anti-restriction.
=GFT
z_·_thm = Ù ¨µ p q S R∑ 
	Ò(p, q) ç S · R § p é S ± p Ì q ç RÆÆ
z_Å_thm = Ù ¨µ p q R S∑ 
	Ò(p, q) ç R Å S § p Ì q ç R ± q é SÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 99.

=DOC
val €z_rel_inv_thm› : THM;
=DESCRIBE
Relational inversion.
=GFT
z_rel_inv_thm = Ù ¨µ p q R∑ Ò(p, q) ç R Á~Í § q Ì p ç RÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 100.

=DOC
val €z_rel_image_thm› : THM;
=DESCRIBE
Relational image.
=GFT
z_rel_image_thm = 
Ù µ p R S∑ Òp ç R ®  S © § ∂ x : S ∑ (x Ì p) ç RÆ
=TEX
=ENDDOC
Spivey Ed 1. page 101

=DOC
val €z_trans_closure_thm› : THM;
val €z_reflex_trans_closure_thm› : THM;
=DESCRIBE
Transitive and reflexive-transitive closure operations.
=GFT
z_trans_closure_thm = 
Ù µ R
  ∑ ÒR Á+Í = • {Q : U | (R Ä Q) ± (Q ª Q Ä Q) ∑ Q}Æ
z_reflex_trans_closure_thm = 
Ù µ R
  ∑ ÒR Á*Í
      = Ò• {Q : U
              | (id U Ä Q) ± (R Ä Q) ± (Q ª Q Ä Q)
              ∑ Q}Æ
=TEX
=ENDDOC
Spivey Ed 1. page 102

=DOC
val €z_ﬂ_thm› : THM;
val €z_≠_thm› : THM;
=DESCRIBE
Partial and total functions.
=GFT
z_ﬂ_thm = Ù ¨µ f X Y
  ∑ Òf ç X ﬂ Y
      § f ç X ™ Y
        ± µ x : X; yâ1, yâ2 : Y ∑ (x Ì yâ1) ç f ± (x Ì yâ2) ç f ¥ yâ1 = yâ2ÆÆ
z_≠_thm = Ù ¨µ f X Y∑ Òf ç X ≠ Y § f ç X ﬂ Y ± dom f = XÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 105

=DOC
val €z_˛_thm› : THM;
val €z_‡_thm› : THM;
=DESCRIBE
Partial and total injections.
=GFT
z_˛_thm = Ù ¨µ f X Y
  ∑ Òf ç X ˛ Y
      § f ç X ﬂ Y ± µ xâ1, xâ2 : dom f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2ÆÆ
z_‡_thm = Ù ¨µ f X Y
  ∑ Òf ç X ‡ Y
      § f ç X ≠ Y ± µ xâ1, xâ2 : dom f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 106

=DOC
val €z_œ_thm› : THM;
val €z_Ô_thm› : THM;
val €z_è_thm› : THM;
=DESCRIBE
Partial and total surjections, and bijections.
=GFT
z_œ_thm = Ù ¨µ f X Y∑ 
	Òf ç X œ Y § f ç X ﬂ Y ± ran f = YÆÆ
z_Ô_thm = Ù ¨µ f X Y∑ 
	Òf ç X Ô Y § f ç X ≠ Y ± ran f = YÆÆ
z_è_thm = Ù ¨µ f X Y
  ∑ Òf ç X è Y
      § f ç X ≠ Y
        ± ran f = Y
        ± µ xâ1, xâ2 : dom f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 106

=DOC
val €z_´_thm› : THM;
=DESCRIBE
Functional overriding.
=GFT
z_´_thm = Ù ¨µ f g∑
	Òf ´ g = dom g · f ¿ gÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 108


\section{PROOF CONTEXTS}
Somewhere $µ\_rewrite\_thm$ needs to get inside an early Z proof context.
=DOC
(* Proof Context: €'z_sets_alg› *)
=DESCRIBE
A component proof context for handling the algebraic manipulation of Z sets, tuples and cartesian products.
It expands memberships of terms formed by Z operators,
and provides some simplifications.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç_∏_conv, 
z_tuple_eq_conv, z_tuple_selection_conv, z_tuple_intro_conv,
z_first_second_thm, z_second_thm, z_first_thm
=TEX

Stripping theorems:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç_∏_conv,
z_tuple_eq_conv, 
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç_∏_conv,
z_tuple_eq_conv,
plus these all pushed in through ≥
=TEX
All three of the above also have theorems concerning the membership of terms generated by the following operators:
=GFT
´, è, Ô, ‡, œ, ˛, ≠, ﬂ, _ Á+Í, _ Á*Í, _ ® _ ©, Å, ·, í, Ú,
o, ª, id, ran, dom, ™, •, ﬁ, \, °, ¿, â1, , ö
=TEX
and
=GFT
z_é_thm, z_Ω_thm
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''.
It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_ext$
=ENDDOC

This proof context
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
 will remain within the Z language if its argument starts there.
=DOC
(* Proof Context: €'z_sets_ext› *)
=DESCRIBE
An aggressive component proof context for handling the manipulation of Z sets by breaking them into predicate calculus, plus handling for tuples and cartesian products.
It is intended to always be used in conjunction with ``$'$z$\_$sets$\_$alg''.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_sets_ext_thm, z_Ä_thm, z_†_thm
=TEX

Stripping theorems:
=GFT
z_sets_ext_thm, z_Ä_thm, z_†_thm,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_sets_ext_thm, z_Ä_thm, z_†_thm,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to always be used in conjunction with ``$'$z$\_$sets$\_$alg''.

It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_alg$
=ENDDOC
Perhaps later releases will add rules such as 
=GFT
(a,b,...) = p = (a = p.1 ± b = p.2 ± ...)
=TEX
Extensionality where the generated $µ$ will be a block 
to further stripping (e.g. if positive in a stripped theorem)
is possibly pointless, and therefore perhaps
should be removed.

This proof context
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
 will remain within the Z language if its argument starts there.

=TEX
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSetTheory *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
