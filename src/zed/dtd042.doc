=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Language Expressions}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD042}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout  & WIN01\\K.~Blackburn&WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and theorems for the \ProductZ{} Language expressions, which includes set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}

\item [Issue 1.1]  First draft.
\item [Issue 1.2 (19th August 1992)]
Taken over by K.Blackburn, and heavily reworked.
\item [Issue 1.3 (8th September 1992)]
Further development.
\item [Issue 1.4 (10th September 1992)]
Correcting text.
\item [Issue 1.5 (10th September 1992)]
Added $z\_≠\_app\_thm$, $z\_setd\_Ä\_conv$.
Removed use of $Ì$ from RHS of rewrite theorems.
\item [Issue 1.6,1.7 (29th September 1992)]
Changes after comments, removal of HOL $µ$'s where possible.
\item [Issue 1.8 (6th October 1992)]
Restructuring proof contexts again.
\item [Issue 1.9 (9th October 1992)]
Changed $z\_ﬁ/•\_thm$.
\item [Issue 1.10 (12th October 1992)]
Added $z'Ä_thm1$.
Removed Z Library material.
\item [Issue 1.11,1.12 (30th October 1992)]
Changes after comments - rearrangement of material
between 041, 042 and 043. 
\item [Issue 1.13 (10th November 1992)]
Changes to reflect changes in issue 1.18 of dtd041.
Changes to $z\-\_ç\-\_seta\-\_conv$.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for some of the 
derived rules of inference, conversions and theorems for
\ProductZ, described in \cite{DS/FMU/IED/HLD015}. The rules and theorems cover Z language expressions, which includes some set theory, cartesian products and tuples.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP042}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and theorems for language expressions of \ProductZ{}. This covers :
\begin{itemize}
\item
set abstractions
\item
set displays
\item
tuples and cartesian products
\item
function application
\end{itemize}
See \cite{DS/FMU/IED/DTD041} 
for the Z predicate calculus.

See \cite{DS/FMU/IED/DTD043} 
for the Z schema calculus.

See \cite{DS/FMU/IED/DTD078} 
for the start of the Z Library material.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP041}.
\subsubsection{Deficiencies}
None known.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $Ò...Æ$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $¡\_to\_z\_conv$ to correct
what problems it can.

By default all relevant functions in this document should
be assumed to remain within the Z language and to check this fact, unless otherwise stated.
\section{EXPRESSIONS}
=DOC
signature €ZExpressions› = sig
=DESCRIBE
This provides the rules of inference, conversions and theorems for Z language set theory, tuples and cartesian products in the Z proof support system.
=ENDDOC
=THDOC
req_name €"z_language_ps"› (Value "z_language");
req_language "Z";
=DESCRIBE
The theory ``$z\_language\_ps$'' contains various ``defining theorems'' of Z language constants, derived from the definitions of
those constants, and consistency theorems for those
constants where necessary.
It is created in structure $ZPredicateCalculus$,
but primarily added to in 
structure $ZExpressions$.
=ENDDOC
\subsection{Concerning Õ}
=DOC
val €z_Õ_rule› : TERM -> THM;
=DESCRIBE
This rule is given a Z $Õ$ expression (i.e. a Z definite description), and returns a theorem
that states what is required for this $Õ$ expression
to be equal to some value, $x$.
The requirement is
that if any value satisfies the schema text of the $Õ$ expression
then it must equal $x$,
and that $x$ satisfies the schema text of the $Õ$ expression.
=FRULE 1 Rule
z_Õ_rule
ÒÕ D | P∑ VÆ
˜
˜
Ù ¨µ x∑
 Ò (µ D' | P'∑ V' = x) ±
   (∂ D' | P'∑ V' = x)
   ¥
   (Õ D | P∑ V) = xÆÆ
=TEX
The result may require bound variable renaming and thus the priming of $D$, etc.
=FAILURE
47210	?0 is not a Z Õ term
=ENDDOC
There may be a flaw in the mapping that allows us to do this!

\subsection{Concerning Function Application}
=DOC
val €z_app_conv› : CONV;
=DESCRIBE
A function to convert a Z application into the
corresponding $Õ$ expression (i.e. definite description).
=FRULE 1 Conversion
z_app_conv
Òf aÆ
˜
˜
Ù f a = (Õ f_a :U | (a,f_a) ç f∑ f_a) 
=TEX
Remains within the Z language though this is not checked.
=SEEALSO 
$z\_app\_thm$, $z\_app\_tac$
=FAILURE
47190	?0 is not a Z function application
=ENDDOC
=THDOC
req_thm("€z_app_thm›",
	([],inst [] [(î'bÆ,î'aÆ), (î'aÆ,î'bÆ)]
	Òµ a : U; f : U; x : U
    ∑ (µ f_a : U | (a, f_a) ç f ∑ f_a = x) ± (a, x) ç f ¥ f a = xÆ));
=DESCRIBE
A theorem that states sufficient conditions to prove that a function application
is equal to a value.
=GFT
Ù µ a : U; f : U; x : U
    ∑ (µ f_a : U | (a, f_a) ç f ∑ f_a = x) ± (a, x) ç f ¥ f a = x
=TEX
=USES
In implementing methods of reasoning about applications.
=SEEALSO
$z\_app\_conv$, $z\_app\_tac$, $z\_app\_ç\_thm$, $z\_ç\_app\_thm$ 
=ENDDOC
=THDOC
req_thm(€"z_app_ç_thm"›, ([],
	Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ f_x ç a ± (x, f_x) ç f ± 
	(µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ f x ç aÆ));
req_thm(€"z_ç_app_thm"›, ([],
	Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ a ç f_x ± (x, f_x) ç f ± 
	(µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ a ç f xÆ));
=DESCRIBE
For reasoning about membership and function application.
=SEEALSO
$z\_app\_thm$
=ENDDOC
=DOC
val €z_app_tac› : TACTIC;
=DESCRIBE
Reduces a subgoal that states a Z application is equal to
something to sufficient conditions for this to be provable.
The conditions are not ``necessary'' only because they
ignore the fact that in \ProductZ{} every predicate or expression is 
equal to itself, and other vacuous variants of this.
=FRULE 2 Tactic
z_app_tac
˜
{á} f a = v
˜
{á} (µ f_a : U | (a, f_a) ç f∑ f_a = v)
	± (a,v) ç f
=TEX
If this does not match the pattern of the goal then
=FRULE 2 Tactic
z_app_tac
˜
{á} v = f a
˜
{á} (µ f_a : U | (a, f_a) ç f∑ f_a = v)
	± (a,v) ç f
=TEX
will be tried instead.
In addition an implicit ``$§\ true$'' will be used
if the conclusion of the goal is an application.
=SEEALSO
$z\_app\_thm$, $z\_app\_conv$
=FAILURE
42002	Conclusion of goal is not of the form: Òf a = vÆ, Òv = f aÆ or Òf xÆ
=ENDDOC
There may be a flaw in the mapping that allows us to do these!
\subsection{Concerning Ã}
=DOC
val €z_Ã_conv› : CONV;
=DESCRIBE
Convert a Z $Ã$ abstraction into a set abstraction.
=FRULE 1 Conversion
z_Ã_conv
ÒÃ D | P∑ VÆ
˜
˜
Ù (Ã D | P∑ V) = { D | P∑ (charD,V)}
=TEX
Where $charD$ is the characteristic tuple of $D$.
=SEEALSO
$z\_¬\_rule$, $z\_¬\_tac$
=FAILURE
47200	?0 is not a Z Ã abstraction
=ENDDOC
=DOC
val €z_¬_rule› : TERM -> THM;
=DESCRIBE
Given a Z $¬$ redex this function will return a theorem
stating sufficient conditions for this redex
to be proven equal to some arbitrary value.
=FRULE 1 Rule
z_¬_rule
Ò(Ã D | P∑ V) tÆ
˜
˜
Ù Òµ x:U ∑ (µ f_a :U | (∂ D' | P'∑ 
charD' = t ± V' = f_a) ∑ f_a = x)
  ±
  (∂ D' | P'∑ (charD' = t) ± V' = x)
  ¥
  (Ã D | P∑ V) t = xÆ
=TEX
Some renaming of bound variables may occur, thus the priming
of $D$, etc.
=FAILURE
42008	?0 is not of the form: Ò(Ã D | P∑ V) tÆ
=ENDDOC
=DOC
val €z_¬_conv› : CONV;
=DESCRIBE
A conversion for a simple Z $¬$ redex.
The $Ã$-term of the redex must have only a single variable in its declaration
part. 
=FRULE 1 Conversion
z_¬_conv
Ò(Ã x:X | P[x]∑ V[x]) tÆ
˜
˜
t ç X,
P[t]
Ù  (Ã x:X | P[x]∑ V[x]) t = V'[t]
=TEX
The assumptions will be eliminated if trivial
(i.e. if the first assumption can be proven true by $ç\_u\_lang\_conv$,
the second if the assumption is just $ÒtrueÆ$).
Some renaming of bound variables may occur, thus the priming
of $V$.
=FAILURE
42012	?0 is not of the form Ò(Ã x:X | P∑ V) tÆ
=ENDDOC
Later releases could make this function more intelligent.

\subsection{Reflexivity, Symmetry, Transitivity of Equality}
The reflexivity of equality considered as a conversion is implemented by $refl\_conv$ in HOL, see \cite{DS/FMU/IED/DTD007}. 
This conversion may also be used for Z terms. 

Similarly $eq\_sym\_conv$ and $eq\_trans\_rule$ also apply in Z reasoning.
\subsection{Extensionality}
=THDOC
req_thm(€"z_sets_ext_thm"›, ([],Òµ x:U; y: U ∑
	(x = y) §
	(µz: U∑ ((z ç x) § (z ç y)))Æ));
=DESCRIBE
The extensionality theorem for the equality of two sets.
=SEEALSO
$z\_sets\_ext\_conv$
=ENDDOC
=DOC
val €z_sets_ext_conv› : CONV;
=DESCRIBE
Use the extensionality of sets in combination with
knowledge about tuples.
Given as input an equality of the form $v\ =\ w$ then:

If $v$ is of type $ty$ $SET$ where $ty$ is not a tuple type:
=FRULE 1 Conversion
z_sets_ext_conv
Òv = wÆ
˜
˜
Ù (v = w) § 
	(µ xn : U ∑ xn ç v § xn ç w)
=TEX
where $xn$ is the first variable in the list $x1$, $x2$,...
that doesn't appear in $v$ or $w$ (free or bound).

If $v$ is of type $ty$ $SET$ where $ty$ is an n-tuple type:
=FRULE 1 Conversion
z_sets_ext_conv
Òv = wÆ
˜
˜
Ù (v = w) § (µ xp : U; µ xq : U; ... ∑
	(xp, xq, ...) ç v § 
	(xp, xq, ...) ç w)
=TEX
where the $xi$ are the first $n$ variable names in the list
$x1$, $x2$,...
that do not appear in $v$ or $w$ (free or bound).
=SEEALSO
$z\_sets\_ext\_thm$
=FAILURE
42010	?0 is not of the form: Òv = wÆ where ÒvÆ has a set type
=ENDDOC

\subsection{Power Set}
=THDOC
req_thm(€"z__thm"›, ([],Òµ t:U; u: U∑
	(t ç  u) § (µz: U∑ ((z ç t) ¥ (z ç u)))Æ));
=DESCRIBE
Power set.
=SEEALSO
$z\_ç\_\_conv$
=ENDDOC
=TEX
=DOC
val €z_ç__conv› : CONV;
=DESCRIBE
Use $z\_\_thm$ in combination with
knowledge about tuples.
Given as input a term of the form $v\ ç \ w$ then:

If $w$ is of type $ty$ $SET$ where $ty$ is not a tuple type:
=FRULE 1 Conversion
z_ç__conv
Òv ç  wÆ
˜
˜
Ù (v ç  w) § 
	(µ xn : U ∑ xn ç v ¥ xn ç w)
=TEX
where $xn$ is the first variable in the list $x1$, $x2$,...
that doesn't appear in $v$ or $w$ (free or bound).

If $w$ is of type $ty$ $SET$ where $ty$ is an n-tuple type:
=FRULE 1 Conversion
z_ç__conv
Òv ç  wÆ
˜
˜
Ù (v = w) § (µ xp : U; µ xq : U; ... ∑
	(xp, xq, ...) ç v ¥ 
	(xp, xq, ...) ç w)
=TEX
where the $xi$ are the first $n$ variable names in the list
$x1$, $x2$,...
that do not appear in $v$ or $w$ (free or bound).
=SEEALSO
$z\_\_thm$, $z\_ç\_\_thm$
=FAILURE
42016	?0 is not of the form Òv ç  wÆ
=ENDDOC
\subsection{Set Abstraction}
=DOC
val €z_ç_seta_conv› : CONV;
val €z_ç_seta_conv1› : CONV;
=DESCRIBE
A conversion of membership of a Z set abstraction into a Z existential quantification. Bound variables in the existential quantification are renamed as necessary.
=FRULE 1 Conversion
Z_seta_elim_conv 
Òt ç { D | P∑ T}Æ
˜
˜
Ù (t ç { D | P∑ T}) §
  (∂ D' | P'∑ T' = t)
=TEX
In the case of $z\_ç\_seta\_conv1$,
if $T$ is a tuple or simple variable
then the conversion will attempt to eliminate
the existential quantification via 
the methods of $basic\_prove\_∂\_conv$.
In particular, this attempt should succeed if $T$ is
the characteristic tuple of $D$.

No simplification is attempted by $$z\_ç\_seta\_conv$
 
Renaming of bound variables may be necessary, thus the priming in the RHS.
=FAILURE
42001	?0 is not a set abstraction
=ENDDOC
=TEX
\subsection{Set Display}
=DOC
val €z_ç_setd_conv1› : CONV;
=DESCRIBE
A conversion proving membership of a Z set display where
the member is syntactically identical
(up to $¡$-conversion) to a member of the set.
=FRULE 1 Conversion
Z_ç_setd_conv1 
Òt ç { ..., t, ...}Æ
˜

˜
Ù t ç { ..., t, ...} § true
=TEX
=SEEALSO
$z\_ç\_setd\_conv$
=FAILURE
42009	?0 is not of the form: Òt ç {...,t,...}Æ
=ENDDOC

\section{TUPLES}
=DOC
val €z_tuple_lang_eq_conv› : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_lang_eq_conv 
Ò(tâ1,tâ2,...) = (uâ1,uâ2,...)Æ
˜
˜
Ù (tâ1,tâ2,...) = (uâ1,uâ2,...) § 
((tâ1 = uâ1) ± (tâ2 = uâ2) ± ...) 
=TEX
=SEEALSO

=FAILURE
42003	?0 is not of the form: Ò(x1,...) = (y1,...)Æ
=ENDDOC
=DOC
val €z_tuple_lang_selection_conv› : CONV;
=DESCRIBE
This conversion carries out the
selection from a tuple display.
=FRULE 1 Conversion
z_tuple_lang_selection_conv 
Ò(tâ1,...,tâi,...,tân).iÆ
˜
˜
Ù (tâ1,...,tâi,...,tân).i = tâi
=TEX
=FAILURE
47185	?0 is not a Z tuple selection
42006	?0 is not of the form Ò(x,...).iÆ
=ENDDOC
=DOC
val €z_tuple_lang_intro_conv› : CONV;
=DESCRIBE
This conversion carries out the
elimination of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_lang_intro_conv 
Ò(t.1,...,t.n)Æ
˜
˜
Ù (t.1,...,t.n) = t
=TEX
where $n$ is the arity of $t$.
=FAILURE
42005	?0 is not of the form: Ò(t.1,...,t.n)Æ
=ENDDOC
=DOC
val €z_tuple_selection_intro_conv› : CONV;
=DESCRIBE
This conversion carries out the
introduction of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_lang_selection_intro_conv 
ÒtÆ
˜
˜
Ù t = (t.1,...,t.n)
=TEX
=FAILURE
42004	?0 does not have a Z tuple type
=ENDDOC

\section{CARTESIAN PRODUCTS}
=DOC
val €z_∏_conv› : CONV;
=DESCRIBE
A conversion for eliminating cartesian products.
=FRULE 1 Conversion
z_∏_conv 
ÒTâ1 ∏ Tâ2 ∏ ...Æ
˜
˜
Ù (Tâ1 ∏ Tâ2 ∏ ...) =
	{tâ1:Tâ1; tâ2:Tâ2; ...∑(tâ1, tâ2,...)}
=TEX
The $tâi$ used are distinct from any variable names
in the $Tâi$.
=SEEALSO
$z\_ç\_∏\_conv$, which is a faster function, if appropriate.
=FAILURE
47160	?0 is not a Z cartesian product
=ENDDOC
=DOC
val €z_ç_∏_conv› : CONV;
=DESCRIBE
A conversion for the membership of cartesian products.
=FRULE 1 Conversion
z_ç_∏_conv 
Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
˜
˜
Ù t ç (Tâ1 ∏ Tâ2 ∏ ...) § 
	t.1 ç Tâ1 ± t.2 ç Tâ2 ± ...
=TEX
$z\_tuple\_selection\_conv$, q.v., will be attempted on each of the
tuple selections.
=SEEALSO
$z\_∏\_conv$
=FAILURE
42007	?0 is not of the form: Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
=ENDDOC
\subsection{Bindings}
=DOC
val €z_binding_eq_conv› : CONV;
val €z_binding_eq_conv1› : CONV;
=DESCRIBE
A conversion for eliminating equations of bindings.  
=FRULE 1 Conversion
z_binding_eq_conv 
¨bâ1 = bâ2Æ
˜
˜
Ù (bâ1 = bâ2) § (bâ1.sâ1 = bâ2.sâ1) ±
	(bâ1.sâ2 = bâ2.sâ2) ± ...
=TEX
where $bâ1$ (and thus $bâ2$) has a binding type equal
to the type of something of the form
=INLINEFT
Ò(sâ1 ¶ ..., sâ2 ¶ ..., ...)Æ
=TEX
{}.

$z\_bind\_eq\_conv1$ first applies conversion
$z\_bind\_eq\_conv$, and then, if either
or both of $bâ1$ and $bâ2$ are binding constructions it
eliminates the projection functions, in a manner 
similar to $z\_bind\_sel\_conv$.
=SEEALSO
$z\_binding\_sel\_conv$
=FAILURE
42013	?0  is not of the form Òbinding = bindingÆ
=ENDDOC

=DOC
val €z_binding_sel_conv› : CONV;
=DESCRIBE
A conversion for selecting a component from a binding.  
=FRULE 1 Conversion
z_binding_sel_conv
¨(nâ1 ¶ tâ1,...).nâcÆ
˜
˜
Ù (nâ1 ¶ tâ1,...).nâc = tâc
=SEEALSO
$z\_bind\_eq\_conv$
=FAILURE
42014	?0  is not of the form: ¨(nâ1 ¶ tâ1,...).nâcÆ
=ENDDOC
\section{MISCELLANEOUS}
=DOC
val €z_defn_simp_rule› : THM -> THM;
=DESCRIBE
This rule is a method of processing a standard style
of specification into a simple rewriting theorem.
=FRULE 1 Rule
z_defn_simp_rule
˜
Ù x ç ( y) ± (µz:y∑ z ç x § f[z])
˜
Ù µ z: U ∑ z ç x § z ç y ± f[z]
=TEX
The rule will also attempt to preprocess its input with $z\_para\_pred\_conv$.
This is on the basis that theorems that
are of an appropriate form for this
rule are often derived from a Z definition, and
this pre-processing is all the processing required to 
convert the definition to acceptable input. 
The rule can also handle generic parameters to the theorem.
=FAILURE
42011	?0 cannot be converted to the form:
	`á Ù x ç ( y) ± (µz:y∑ z ç x § f[z])`
=ENDDOC
\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{3in}}
$'z\_ç\_set\_lang$ & Simple algebraic reasoning about set theory of the Z language, especially $ç$. (e.g. $$) \\
$'z\_tuples\_lang$ & Reasoning about Z tuples and cartesian products within the Z language\\
$'z\_sets\_ext\_lang$ & Reasoning about Z set extensionality within the Z language\\
$'z\_bindings$ & Reasoning about Z binding displays\\
\end{tabular}

The above proof contexts
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language if its argument starts there.

Some stripping theorems (e.g., later, for $Ú$)
raise the dilemma of how and whether to
avoid leaving terms of the forms $Ò(x,y).1Æ$ 
(a special case is $Ò(x\ Ì\ y).1Æ$)
and $Ò(p.1,p.2)Æ$.
The first form is bad because of functionality problems;
the second is primarily bad because it is verbose,
but also because it provides a less general term for,
e.g., rewriting with.
We currently address this by including three theorems for
each problem operator, and relying on the discrimination
net effect of choosing ``the best match'' (see \cite{DS/FMU/IED/DTD008})
to get results that avoid the forms $Ò(x,y).1Æ$ and $Ò(p.1,p.2)Æ$.
We include all three theorems in both rewriting and stripping,
without relying on $z\-\_tuple\-\_selection\-\_conv$
during rewriting.
Thus for instance we include the theorems:
=GFT
Ù µ p S R∑ Òp ç S Ú R § p.1 ç S ± p ç RÆ
Ù µ p1 p2 S R∑ Ò(p1,p2) ç S Ú R § p1 ç S ± (p1,p2) ç RÆ
Ù µ p1 p2 S R∑ Ò(p1 Ì p2) ç S Ú R § p1 ç S ± (p1 Ì p2) ç RÆ
=TEX
The latter two theorems are automatically generated from the first.
This is only one possible solution, and not even necessarily the best.
Others include addressing the introduction of extensionality
variables, or ``fall back'' conversions if nothing else
applies to a term of the form $Òp\ ç\ qÆ$.
The operators affected (to date) are:
=INLINEFT
·, Å, Ú, í, and o
=TEX
{}.
=DOC
(* Proof Context: €'z_ç_set_lang› *)
=DESCRIBE
A component proof context for handling the membership of expressions created by Z language set operations.
It also provides some simplifications.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_seta_conv1, z_ç_setd_conv1
z_¬_conv if its resulting theorem has no assumptions.
=TEX

Stripping theorems:
=GFT
z_ç_seta_conv1, z_ç_setd_conv1
plus these all pushed in through ≥,
and z_¬_conv if its resulting theorem has no assumptions.
=TEX

Stripping conclusions:
=GFT
z_ç_seta_conv1, z_ç_setd_conv1
plus these all pushed in through ≥,
and z_¬_conv if its resulting theorem has no assumptions.
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''.
It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_ext$
=ENDDOC
The universal set, $U$, is processed by proof context
$z\_predicates$.
No aspect of the proof context concerns itself with function
application, other than the limited $¬$-reduction,
nor with $Õ$-terms.
This is because there is no ``usually good'' approach
that can be offered for these.
=DOC
(* Proof Context: €'z_sets_ext_lang› *)
=DESCRIBE
An aggressive component proof context for handling the manipulation of Z sets by breaking them into predicate calculus, within the Z language.
It is intended to always be used in conjunction with ``$'$z$\_$set$\_$lib''.

$z\_setd\_Ä\_conv$ concerns the operator $Ä$ which is part of the Z library.
However, the operator and conversion are implemented
with the Z language material, and is included here to
simplify certain Z declarations.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_sets_ext_conv, z_setd_Ä_conv, z_ç__conv
=TEX

Stripping theorems:
=GFT
z_sets_ext_conv, z_setd_Ä_conv, z_ç__conv,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_sets_ext_conv, z_setd_Ä_conv, z_ç__conv,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to always be used in conjunction with ``$'$z$\_$set$\_$lang''.

It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_ç\_set$
=ENDDOC

=DOC
(* Proof Context: €'z_tuples_lang› *)
=DESCRIBE
A component proof context for handling the manipulation of Z tuples and cartesian products within the Z language.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_∏_conv,
z_tuple_lang_eq_conv, z_tuple_lang_selection_conv, z_tuple_lang_intro_conv
=TEX

Stripping theorems:
=GFT
z_ç_∏_conv, z_tuple_lang_eq_conv, 
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_ç_∏_conv, z_tuple_lang_eq_conv,
plus these all pushed in through ≥
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$\-\_basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''.
It should not be used with ``$'$z$\_$tuples$\_$lang''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
Perhaps later releases will add rules such as 
=GFT
(a,b,...) = p § (a = p.1 ± b = p.2 ± ...)
=TEX
perhaps into a separate $'z\_tuples\_ext$.
=DOC
(* Proof Context: €'z_bindings› *)
=DESCRIBE
A component proof context for handling the manipulation of Z bindings.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_binding_eq_conv1 when both sides of equality are binding displays,
z_binding_sel_conv
=TEX

Stripping theorems:
=GFT
z_binding_eq_conv1 when both sides of equality are binding displays,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_binding_eq_conv1 when both sides of equality are binding displays,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_language\-\_ps$.
It is intended to be used with proof context ``z$\_$predicates''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
Further proof contexts could be more aggressive in
handling the equality of bindings.
=TEX
\section{Theorems in the Signature}
=DOC
val z_sets_ext_thm: THM;
val z__thm: THM;
val z_app_thm : THM;
val z_app_ç_thm: THM;
val z_ç_app_thm: THM;
=DESCRIBE
The ML bindings of the theorems (other than consistency ones)
in theory $z\-\_set\-\_theory$.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZExpressions *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
