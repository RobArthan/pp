=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Language Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD042}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout  & WIN01\\K.~Blackburn&WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and theorems for the Proof Power Z Language set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}

\item [Issue 1.1]  First draft.
\item [Issue 1.2 (19th August 1992)]
Taken over by K.Blackburn, and heavily reworked.
\item [Issue 1.3 (8th September 1992)]
Further development.
\item [Issue 1.4 (10th September 1992)]
Correcting text.
\item [Issue 1.5 (10th September 1992)]
Added $z\_≠\_app\_thm$, $z\_setd\_Ä\_conv$.
Removed use of $Ì$ from RHS of rewrite theorems.
\item [Issue 1.6,1.7 (29th September 1992)]
Changes after comments, removal of HOL $µ$'s where possible.
\item [Issue 1.8 (6th October 1992)]
Restructuring proof contexts again.
\item [Issue 1.9 (9th October 1992)]
Changed $z\_ﬁ/•\_thm$.
\item [Issue 1.10 (12th October 1992)]
Added $z'Ä_thm1$.
Removed Z Library material.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for some of the 
derived rules of inference, conversions and theorems for
the Z Proof Support System, described in \cite{DS/FMU/IED/HLD015}. The rules and theorems cover set theory and associated constructs.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP042}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and theorems for the set theory of the Z proof support system. This covers :
\begin{itemize}
\item
set abstractions
\item
set displays
\item
tuples and cartesian products
\end{itemize}
See \cite{DS/FMU/IED/DTD041} 
for the Z predicate calculus, function application, $Ã$ and $Õ$.

See \cite{DS/FMU/IED/DTD043} 
for the Z schema calculus.

See \cite{DS/FMU/IED/DTD083} 
for the Z Library proof support.

See \cite{???}
for numbers, bags, sequences and finiteness.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP041}.
\subsubsection{Deficiencies}
Perhaps ought to use theory check mechanisms.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $Ò...Æ$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $¡\_to\_z\_conv$ to correct
what problems it can.

\section{SET THEORY}
=DOC
signature €ZSetTheory› = sig
=DESCRIBE
This provides the rules of inference, conversions and theorems for Z language set theory, tuples and cartesian products in the Z proof support system.
=ENDDOC
=THDOC
req_name €"z_set_theory"› (Value "z_language");
req_language "Z";
=DESCRIBE
The theory ``$z\_set\_theory$'' contains various ``defining theorems'' of Z set constants, derived from the definitions of
those constants, and consistency theorems for those
constants where necessary.
It is created in structure $ZPredicateCalculus$,
but primarily added to in 
structure $ZSetTheory$.
=ENDDOC

\subsection{Reflexivity, Symmetry, Transitivity of Equality}
The reflexivity of equality considered as a conversion is implemented by $refl\_conv$ in HOL, see \cite{DS/FMU/IED/DTD007}. 
This conversion may also be used for Z terms. 

Similarly $eq\_sym\_conv$ and $eq\_trans\_rule$ also apply to Z.
\subsection{Extensionality}
=THDOC
req_thm(€"z_sets_ext_thm"›, ([],Òµ x:U; y: U ∑
	(x = y) §
	(µz: U∑ ((z ç x) § (z ç y)))Æ));
=DESCRIBE
The extensionality theorem for the equality of two sets.
=SEEALSO
$z\_sets\_ext\_conv$
=ENDDOC
=DOC
val €z_sets_ext_conv› : CONV;
=DESCRIBE
Use the extensionality of sets in combination with
knowledge about tuples.
Given as input an equality of the form $v\ =\ w$ then:

If $v$ is of type $ty$ $SET$ where $ty$ is not a tuple type:
=FRULE 1 Conversion
z_sets_ext_conv
Òv = wÆ
˜
˜
Ù (v = w) § 
	(µ xân : U ∑ xân ç v § xân ç w)
=TEX
where $xân$ is the first variable in the list $xâ1$, $xâ2$,...
that doesn't appear in $v$ or $w$ (free or bound).

If $v$ is of type $ty$ $SET$ where $ty$ is an n-tuple type:
=FRULE 1 Conversion
z_sets_ext_conv
Òv = wÆ
˜
˜
Ù (v = w) § (µ xâp : U; µ xâq : U; ... ∑
	(xâp, xâq, ...) ç v § 
	(xâp, xâq, ...) ç w)
=TEX
where the $xâi$ are the first $n$ variable names in the list
$xâ1$, $xâ2$,...
that do not appear in $v$ or $w$ (free or bound).
=SEEALSO
$z\_sets\_ext\_thm$
=FAILURE
42010	?0 is not of the form Òv = wÆ where ÒvÆ has a set type
=ENDDOC

\subsection{Power Set}
=THDOC
req_thm(€"z__thm"›, ([],Òµ t:U; u: U∑
	(t ç  u) § (µz: U∑ ((z ç t) ¥ (z ç u)))Æ));
=DESCRIBE
Power set.
=SEEALSO
$z\_ç\_\_conv$
=ENDDOC
=TEX
=DOC
val €z_ç__conv› : CONV;
=DESCRIBE
Use $z\_\_thm$ in combination with
knowledge about tuples.
Given as input an equality of the form $v ç  w$ then:

If $w$ is of type $ty$ $SET$ where $ty$ is not a tuple type:
=FRULE 1 Conversion
z_ç__conv
Òv ç  wÆ
˜
˜
Ù (v ç  w) § 
	(µ xân : U ∑ xân ç v ¥ xân ç w)
=TEX
where $xân$ is the first variable in the list $xâ1$, $xâ2$,...
that doesn't appear in $v$ or $w$ (free or bound).

If $w$ is of type $ty$ $SET$ where $ty$ is an n-tuple type:
=FRULE 1 Conversion
z_ç__conv
Òv ç  wÆ
˜
˜
Ù (v = w) § (µ xâp : U; µ xâq : U; ... ∑
	(xâp, xâq, ...) ç v ¥ 
	(xâp, xâq, ...) ç w)
=TEX
where the $xâi$ are the first $n$ variable names in the list
$xâ1$, $xâ2$,...
that do not appear in $v$ or $w$ (free or bound).
=SEEALSO
$z\_\_thm$
=FAILURE
42016	?0 is not of the form Òv ç  wÆ
=ENDDOC
\subsection{Set Abstraction}
=DOC
val €z_ç_seta_conv› : CONV;
=DESCRIBE
A conversion of membership of a Z set abstraction into a Z existential quantification. Bound variables in the existential quantification are renamed as necessary.
=FRULE 1 Conversion
Z_seta_elim_conv 
Òt ç { D | P∑ T}Æ
˜
˜
Ù (t ç { D | P∑ T}) §
  (∂ D' | P'∑ T' = t)
=TEX
Remains within the Z language.
Renaming of bound variables may be necessary, thus the priming in the RHS.
=FAILURE
42001	?0 is not a set abstraction
=ENDDOC
=TEX
\subsection{Set Display}
=DOC
val €z_ç_setd_conv1› : CONV;
=DESCRIBE
A conversion proving membership of a Z set display where
the member is syntactically identical
(up to $¡$-conversion) to a member of the set.
=FRULE 1 Conversion
Z_ç_setd_conv1 
Òt ç { ..., t, ...}Æ
˜

˜
Ù t ç { ..., t, ...} § true
=TEX
Remains within the Z language.
=SEEALSO
$z\_ç\_setd\_conv$
=FAILURE
42009	?0 is not of the form: Òt ç {...,t,...}Æ
=ENDDOC

\section{TUPLES}
=DOC
val €z_tuple_lang_eq_conv› : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_lang_eq_conv 
Ò(tâ1,tâ2,...) = (uâ1,uâ2,...)Æ
˜
˜
Ù (tâ1,tâ2,...) = (uâ1,uâ2,...) § 
((tâ1 = uâ1) ± (tâ2 = uâ2) ± ...) 
=TEX
Remains within the Z language.
=SEEALSO

=FAILURE
42003	?0 is not of the form: Ò(x1,...) = (y1,...)Æ
=ENDDOC
=DOC
val €z_tuple_lang_selection_conv› : CONV;
=DESCRIBE
This conversion carries out the
selection from a tuple display.
=FRULE 1 Conversion
z_tuple_lang_selection_conv 
Ò(tâ1,...,tâi,...,tân).iÆ
˜
˜
Ù (tâ1,...,tâi,...,tân).i = tâi
=TEX
=FAILURE
47185	?0 is not a Z tuple selection
42006	?0 is not of the form Ò(x,...).iÆ
=ENDDOC
=DOC
val €z_tuple_lang_intro_conv› : CONV;
=DESCRIBE
This conversion carries out the
elimination of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_lang_intro_conv 
Ò(t.1,...,t.n)Æ
˜
˜
Ù (t.1,...,t.n) = t
=TEX
where $n$ is the arity of $t$.
=FAILURE
42005	?0 is not of the form: Ò(t.1,...,t.n)Æ
=ENDDOC
=DOC
val €z_tuple_selection_intro_conv› : CONV;
=DESCRIBE
This conversion carries out the
introduction of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_lang_selection_intro_conv 
ÒtÆ
˜
˜
Ù t = (t.1,...,t.n)
=TEX
=FAILURE
42004	?0 does not have a Z tuple type
=ENDDOC

\section{CARTESIAN PRODUCTS}
=DOC
val €z_∏_conv› : CONV;
=DESCRIBE
A conversion for eliminating cartesian products.
=FRULE 1 Conversion
z_∏_conv 
ÒTâ1 ∏ Tâ2 ∏ ...Æ
˜
˜
Ù (Tâ1 ∏ Tâ2 ∏ ...) =
	{tâ1:Tâ1; tâ2:Tâ2; ...∑(tâ1, tâ2,...)}
=TEX
The $tâi$ used are distinct from any variable names
in the $Tâi$.

Remains within the Z language.
=SEEALSO
$z\_ç\_∏\_conv$, which is a faster function, if appropriate.
=FAILURE
47160	?0 is not a Z cartesian product
=ENDDOC
=DOC
val €z_ç_∏_conv› : CONV;
=DESCRIBE
A conversion for the membership of cartesian products.
=FRULE 1 Conversion
z_ç_∏_conv 
Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
˜
˜
Ù t ç (Tâ1 ∏ Tâ2 ∏ ...) § 
	t.1 ç Tâ1 ± t.2 ç Tâ2 ± ...
=TEX
$z\_tuple\_selection\_conv$, q.v., will be atempted on each of the
tuple selections.

Remains within the Z language.
=SEEALSO
$z\_∏\_conv$
=FAILURE
42007	?0 is not of the form: Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
=ENDDOC

\section{MISCELLANEOUS}
=DOC
val €z_defn_simp_rule› : THM -> THM;
=DESCRIBE
This rule is a method of processing a standard style
of specification into a simple rewriting theorem.
=FRULE 1 Rule
z_defn_simp_rule
˜
Ù x ç ( y) ± (µz:y∑ z ç x § f[z])
˜
Ù µ z: U ∑ z ç x § z ç y ± f[z]
=TEX
The rule will also attempt to preprocess its input with $z\_defn\_conv$, and if the first conjunct is a declaration,
replace it by a predicate.
This is on the basis that theorems that
are of an appropriate form for this
rule are often derived from a Z definition, and
this pre-processing is all the processing required to 
convert the definition to acceptable input. 

Remains within the Z language.
=FAILURE
42011	?0 is not of the form `á Ù x ç ( y) ± (µz:y∑ z ç x § f[z])`
=ENDDOC
=THDOC
req_thm(€"z_app_ç_thm"›, ([],
	Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ f_x ç a ± (x, f_x) ç f ± (µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ f x ç aÆ));
req_thm(€"z_ç_app_thm"›, ([],
	Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ a ç f_x ± (x, f_x) ç f ± 
	(µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ a ç f xÆ));
=DESCRIBE
For reasoning about membership and function application.
=SEEALSO
$z\_app\_thm$
=ENDDOC
\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{3in}}
$'z\_ç\_set\_lang$ & Simple algebraic reasoning about set theory of the Z language, especially $ç$. (e.g. $$) \\
$'z\_tuples\_lang$ & Reasoning about Z tuples and cartesian products within the Z language\\
$'z\_sets\_ext\_lang$ & Reasoning about Z set extensionality within the Z language\\
\end{tabular}

The above proof contexts
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language if its argument starts there.

Some stripping theorems (e.g. for $Ú$)
raise the dilemma of how and whether to
avoid leaving terms of the forms $Ò(x,y).1Æ$ 
(a special case is $Ò(x\ Ì\ y).1Æ$)
and $Ò(p.1,p.2)Æ$.
The first form is bad because of functionality problems;
the second is primarily bad because it is verbose,
but also because it provides a less general term for,
e.g., rewriting with.
We currently address this by including three theorems for
each problem operator, and relying on the discrimination
net effect of choosing ``the best match'' (see \cite{DS/FMU/IED/DTD008})
to get results that avoid the forms $Ò(x,y).1Æ$ and $Ò(p.1,p.2)Æ$.
We include all three theorems in both rewriting and stripping,
without relying on $z\-\_tuple\-\_selection\-\_conv$
during rewriting.
Thus for instance we include the theorems:
=GFT
Ù µ p S R∑ Òp ç S Ú R § p.1 ç S ± p ç RÆ
Ù µ p1 p2 S R∑ Ò(p1,p2) ç S Ú R § p1 ç S ± (p1,p2) ç RÆ
Ù µ p1 p2 S R∑ Ò(p1 Ì p2) ç S Ú R § p1 ç S ± (p1 Ì p2) ç RÆ
=TEX
The latter two theorems are automatically generated from the first.
This is only one possible solution, and not even necessarily the best.
Others include addressing the introduction of extensionality
variables, or ``fall back'' conversions if nothing else
applies to a term of the form $Òp\ ç\ qÆ$.
The operators affected (to date) are:
=INLINEFT
·, Å, Ú, í, and o
=TEX
{}.
=DOC
(* Proof Context: €'z_ç_set_lang› *)
=DESCRIBE
A component proof context for handling the membership of expressions created by Z language set operations.
It also provides some simplifications.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç__conv
z_¬_conv if its resulting theorem has no assumptions.
=TEX

Stripping theorems:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç__conv
plus these all pushed in through ≥,
and z_¬_conv if its resulting theorem has no assumptions.
=TEX

Stripping conclusions:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, z_ç__conv
plus these all pushed in through ≥,
and z_¬_conv if its resulting theorem has no assumptions.
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''
(and thus ``$'$z$\_$decl'')
It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_ext$
=ENDDOC
The universal set, $U$, is processed by proof context
$z\_predicates$.
No aspect of the proof context concerns itself with function
application, other than the limited $¬$-reduction,
nor with $Õ$-terms.
This is because there is no ``usually good'' approach
that can be offered for these.
=DOC
(* Proof Context: €'z_sets_ext_lang› *)
=DESCRIBE
An aggressive component proof context for handling the manipulation of Z sets by breaking them into predicate calculus, within the Z language.
It is intended to always be used in conjunction with ``$'$z$\_$set$\_$lib''.

$z\_setd\_Ä\_conv$ concerns the operator $Ä$ which is part of the Z library.
However, the operator and conversion are implemented
with the Z language material, and is included here to
simplify certain Z declarations.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_sets_ext_conv, z_setd_Ä_conv
=TEX

Stripping theorems:
=GFT
z_sets_ext_conv, z_setd_Ä_conv,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_sets_ext_conv, z_setd_Ä_conv,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to always be used in conjunction with ``$'$z$\_$set$\_$lang''.

It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_ç\_set$
=ENDDOC

=DOC
(* Proof Context: €'z_tuples_lang› *)
=DESCRIBE
A component proof context for handling the manipulation of Z tuples and cartesian products within the Z language.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_∏_conv,
z_tuple_lang_eq_conv, z_tuple_lang_selection_conv, z_tuple_lang_intro_conv
=TEX

Stripping theorems:
=GFT
z_ç_∏_conv, z_tuple_lang_eq_conv, 
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_ç_∏_conv, z_tuple_lang_eq_conv,
plus these all pushed in through ≥
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$\-\_basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''
(and thus ``$'$z$\_$decl'').
It should not be used with ``$'$z$\_$tuples$\_$lang''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
Perhaps later releases will add rules such as 
=GFT
(a,b,...) = p § (a = p.1 ± b = p.2 ± ...)
=TEX
perhaps into a separate $'z\_tuples\_ext$.

=TEX
\section{Theorems in the Signature}
=DOC
val z_sets_ext_thm: THM;
val z__thm: THM;
val z_app_ç_thm: THM;
val z_ç_app_thm: THM;
=DESCRIBE
The ML bindings of the theorems (other than consistency ones)
in theory $z\-\_set\-\_theory$.
=ENDDOC
\section{Theorems from Elsewhere}
The following are in the signature of \cite{DS/FMU/IED/DTD041},
but require a $req\_thm$ here:
=THDOC
req_thm("z_app_thm",
	([],inst [] [(î'bÆ,î'aÆ), (î'aÆ,î'bÆ)]
	Òµ a : U; f : U; x : U
    ∑ (µ f_a : U | (a, f_a) ç f ∑ f_a = x) ± (a, x) ç f ¥ f a = xÆ));
=DESCRIBE
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSetTheory *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
