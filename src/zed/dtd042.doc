=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD042}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout  & WIN01\\K.~Blackburn&WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
derived rules of inference, conversions and theorems for the Proof Power Z set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes history} 
\begin{description}

\item [Issue 1.1]  First draft.
\item [Issue 1.2 (19th August 1992)]
Taken over by K.Blackburn, and heavily reworked.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for some of the 
derived rules of inference, conversions and theorems for
the Z Proof Support System, described in \cite{DS/FMU/IED/HLD015}. The rules and theorems cover set theory and associated constructs.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP042}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of rules, conversions and theorems for the set theory of the Z proof support system. This covers :
\begin{itemize}
\item
set abstractions
\item
set displays
\item
tuples and cartesian products
\end{itemize}
See \cite{DS/FMU/IED/DTD041} 
for the Z predicate calculus, function application, $Ã$ and $Õ$.

See \cite{DS/FMU/IED/DTD043} 
for the Z schema calculus.

See \cite{???}
for numbers, bags, sequences and finiteness.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP041}.
\subsubsection{Deficiencies}
Perhaps out to use theory check mechanisms.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $Ò...Æ$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $¡\_to\_z\_conv$ to correct
what problems it can.

\section{SET THEORY}
=DOC
signature €ZSetTheory› = sig
=DESCRIBE
This provides the rules of inference, conversions and theorems for set theory, tuples and cartesian products in the Z proof support system.
=ENDDOC
\subsection{Reflexivity, Symmetry, Transitivity of Equality}
The reflexivity of equality considered as a conversion is implemented by $refl\_conv$ in HOL, see \cite{DS/FMU/IED/DTD007}. 
This conversion may also be used for Z terms. 

Similiarly $eq\_sym\_conv$ and $eq\_trans\_rule$ also apply to Z.
\subsection{Extensionality}
=DOC
val €z_sets_ext_thm› : THM;
=DESCRIBE
The extensionality theorem for the equality of two sets.
=FRULE 1 Theorem
z_set_eq_thm
˜
˜
¨µ x y ∑
Ò(x = y) = (µz: U ∑ ((z ç x) § (z ç y)))ÆÆ
=TEX
=ENDDOC

\subsection{Power Set}
=DOC
val €z__thm› : THM;
=DESCRIBE
The definitional theorem for power set, $$.
=FRULE 1 Theorem
Z__thm
˜
˜
¨µ t u ∑
Ò(t ç  u) = (µz: U ∑ ((z ç t) ¥ (z ç u)))ÆÆ
=TEX
=ENDDOC
=TEX
\subsection{Set Abstraction}
=DOC
val €z_ç_seta_conv› : CONV;
=DESCRIBE
A conversion from membership of a Z set abstraction to a Z existential quantification. Bound variables in the existential quantification are renamed as necessary.
=FRULE 1 Conversion
Z_seta_elim_conv 
¨t ç { D | P ∑ T}Æ
˜
˜
Ù (t ç { D | P ∑ T}) = (∂ D | P ∑ T = t)
=TEX
Remains within the Z language.
=FAILURE
42001	?0 is not a set abstraction
=ENDDOC
=TEX
\subsection{Set Display}
=DOC
val €z_ç_setd_conv› : CONV;
=DESCRIBE
A conversion from membership of a Z set display to equality with a member of the set.
=FRULE 1 Conversion
Z_setd_elim_conv 
¨t ç { tâ1, tâ2, ...}Æ
˜

˜
Ù t ç { tâ1, tâ2, ...} =
	((t = tâ1) ≤ (t = tâ2) ...)
=TEX
Remains within the Z language.
=SEEALSO
$z\_ç\_setd\_conv1$
=FAILURE
42002	?0 is not of the form: Òx ç {t1,...}Æ
42008	?0 is an ill-formed fragment of the membership of a set display
=ENDDOC
=DOC
val €z_ç_setd_conv1› : CONV;
=DESCRIBE
A conversion from membership of a Z set display where
the member is trivially equal to a member of the set.
=FRULE 1 Conversion
Z_setd_elim_conv 
¨t ç { ..., t, ...}Æ
˜

˜
Ù t ç { ..., t, ...} = true
=TEX
Remains within the Z language.
=SEEALSO
$z\_ç\_setd\_conv$
=FAILURE
42002	?0 is not of the form: Òx ç {t1,...}Æ
42009	?0 is not of the form: Òt ç {...,t,...}Æ
=ENDDOC
=TEX
\subsection{Set Theorems From the Z Mathematical Toolkit}
The following theorems are generally just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.
=DOC
val €z_Ω_thm› : THM;
val €z_é_thm› : THM;
=DESCRIBE
=GFT 
z_Ω_thm = Ù ¨µ x y∑ Ò(x Ω y) § ≥(x = y)ÆÆ

z_é_thm = Ù ¨µ S x∑ Òx é S § ≥(x ç S)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 89.

=DOC
val €z_ö_thm› : THM;
val €z_Ä_thm› : THM;
val €z_†_thm› : THM;
val €z_â1_thm› : THM;
=DESCRIBE
=GFT 
z_ö_thm = Ù ¨µ x ∑ Ò≥(x ç ö)ÆÆ
z_Ä_thm = Ù ¨µ s t ∑ Ò(s Ä t) § (µ x:U ∑x ç s ¥ x ç t)ÆÆ
z_†_thm = Ù ¨µ s t ∑ Ò(s † t) § (s Ä t) ± s Ω tÆÆ
z_â1_thm = Ù â1 _ = {S : U | S Ω ö[U] ∑ S}
=TEX
=ENDDOC
Spivey Ed 1. page 90.

=DOC
val €z_¿_thm› : THM;
val €z_°_thm› : THM;
val €z_set_dif_thm› : THM;
=DESCRIBE
=GFT 
z_¿_thm = Ù ¨µ z s t ∑ Òz ç (s ¿ t) § z ç s ≤ z ç tÆÆ
z_°_thm = Ù ¨µ z s t ∑ Òz ç (s ° t) § z ç s ± z ç tÆÆ
z_set_dif_thm = Ù ¨µ z s t ∑ Òz ç (s \ t) § z ç s ± (z é t)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 91.


=DOC
val €z_ﬁ_thm› : THM;
val €z_•_thm› : THM;
=DESCRIBE
=GFT 
z_ﬁ_thm = Ù ¨µ z a ∑ Òz ç ﬁ a § ∂ S : a ∑ z ç SÆÆ
z_•_thm = Ù ¨µ z a ∑ Òz ç • a § µ S : a ∑ z ç SÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 92.


\section{TUPLES}
=DOC
val €z_tuple_eq_conv› : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_eq_conv 
¨(tâ1,tâ2,...) = (uâ1,uâ2,...)Æ
˜
˜
Ù (tâ1,tâ2,...) = (uâ1,uâ2,...) § 
((tâ1 = uâ1) ± (tâ2 = uâ2) ± ...) 
=TEX
Remains within the Z language.
=FAILURE
42003	?0 is not of the form: Ò(x1,...) = (y1,...)Æ
=ENDDOC
=DOC
val €z_tuple_selection_conv› : CONV;
=DESCRIBE
This conversion will carry out the appropriate
selection from an explicit tuple.
=FRULE 1 Conversion
z_tuple_selection_conv 
¨(tâ1,...,tâi,...,tân).iÆ
˜
˜
Ù (tâ1,...,tâi,...,tân).i = tâi
=TEX
=FAILURE
42004	?0 is not of the form: Ò(tâ1,...,tâi,...,tân).iÆ
=ENDDOC
=DOC
val €z_tuple_intro_conv› : CONV;
=DESCRIBE
This conversion will carry out the appropriate
elimination of a tuple of tule selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_intro_conv 
¨(t.1,...,t.n)Æ
˜
˜
Ù (t.1,...,t.n) = t
=TEX
=FAILURE
42005	?0 is not of the form: Ò(t.1,...,t.n)Æ
=ENDDOC
\subsection{Tuple Theorems From the Z Mathematical Toolkit}
The following theorems are generally just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.
=DOC
val €z_first_thm› : THM;
val €z_second_thm› : THM;
=DESCRIBE
=GFT 
z_first_thm = Ù ¨µ x y∑ Òfirst(x,y) = xÆÆ
z_second_thm = Ù ¨µ x y∑ Òsecond(x,y) = yÆÆ
z_first_second_thm = Ù ¨µ x∑ Ò(first x, second x) = xÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 89.

\section{CARTESIAN PRODUCTS}
=DOC
val €z_∏_conv› : CONV;
=DESCRIBE
A conversion for eliminating cartesian products.
=FRULE 1 Conversion
z_∏_conv 
¨(Tâ1 ∏ Tâ2 ∏ ...)Æ
˜
˜
Ù (Tâ1 ∏ Tâ2 ∏ ...) = 
	{tâ1:Tâ1; tâ2:Tâ2; ...∑(tâ1, tâ2,...)}
=TEX
The $tâi$ used are distinct from any variable names
in the $Tâi$.

Remains within the Z language.
=FAILURE
42006	?0 is not of the form: Ò(Tâ1 ∏ Tâ2 ∏ ...)Æ
=ENDDOC
=DOC
val €z_ç_∏_conv› : CONV;
=DESCRIBE
A conversion for the membership of cartesian products.
=FRULE 1 Conversion
z_ç_∏_conv 
¨t ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
˜
˜
Ù t ç (Tâ1 ∏ Tâ2 ∏ ...) = t.1 ç Tâ1 ± t.2 ç Tâ2 ± ...
=TEX
The $tâi$ used are distinct from any variable names
in the $Tâi$.

Remains within the Z language.
=FAILURE
42007	?0 is not of the form: Òt ç (Tâ1 ∏ Tâ2 ∏ ...)Æ
=ENDDOC
\section{RELATIONS}
The following theorems are generally just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.
=DOC
val €z_™_thm› : THM;
val €z_Ì_thm› : THM;
=DESCRIBE
=GFT 
z_™_thm = Ù ¨µ x y∑ Ò(x ™ y) = (x ∏ y)ÆÆ
z_Ì_thm = Ù ¨µ x y∑ Òx Ì y = (x,y)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 95.

=DOC
val €z_dom_thm› : THM;
val €z_ran_thm› : THM;
=DESCRIBE
=GFT 
z_dom_thm = Ù ¨µ x r∑ Òx ç dom r § ∂ y : U ∑ (x Ì y) ç rÆÆ
z_ran_thm = Ù ¨µ y r∑ Òy ç ran r § ∂ x : U ∑ (x Ì y) ç rÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 96.

=DOC
val €z_id_thm› : THM;
val €z_ª_thm› : THM;
val €z_o_thm› : THM;
=DESCRIBE
=GFT 
z_id_thm = Ù ¨µ x ∑ Òid x = {y : x ∑ y Ì y}ÆÆ
z_ª_thm = Ù ¨µ x z r s ∑ 
	Ò(x,z) ç (r ª s) = (∂ y:U ∑ (x Ì y) ç r ± (y Ì z) ç s)ÆÆ
z_o_thm = Ù ¨µ r s ∑ Ò(r o s) = (s ª r)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 97.

=DOC
val €z_Ú_thm› : THM;
val €z_í_thm› : THM;
=DESCRIBE
=GFT 
z_Ú_thm = Ù ¨µ x y s r ∑ 
	Ò(x,y) ç (s Ú r) § x ç s ± (x Ì y) ç rÆÆ
z_í_thm = Ù ¨µ x y s r ∑ 
	Ò(x,y) ç (s í r) § y ç r ± (x Ì y) ç sÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 98.

=DOC
val €z_·_thm› : THM;
val €z_Å_thm› : THM;
=DESCRIBE
=GFT 
z_·_thm = Ù ¨µ x y s r ∑ 
	Ò(x,y) ç (s · r) § ≥(x ç s) ± (x Ì y) ç rÆÆ
z_Å_thm = Ù ¨µ x y s r ∑ 
	Ò(x,y) ç (s Å r) § ≥(y ç r) ± (x Ì y) ç sÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 99.

=DOC
val €z_rel_inv_thm› : THM;
=DESCRIBE
=GFT 
z_rel_inv_thm = Ù ¨µ x y r ∑ 
	Ò(x,y) ç r Á~Í § (y Ì x) ç rÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 100.

=DOC
val €z_rel_image_thm› : THM;
=DESCRIBE
=GFT 
z_rel_image_thm = Ù ¨µ y r s ∑ 
	Òx ç r®s© § ∂ x ∑ x ç s ± (x Ì y) ç rÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 101

=DOC
val €z_trans_closure_thm› : THM;
val €z_reflex_trans_closure_thm› : THM;
=DESCRIBE
=GFT 
z_trans_closure_thm = Ù ¨µ r ∑
	Òr Á+Í = •{q:U| r Ä q ± (q ª q) Ä q}ÆÆ
z_reflex_trans_closure_thm = Ù ¨µ r ∑
	Òr Á+Í = •{q:U| id U ç q ± r Ä q ± (q ª q) Ä q}ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 102

=DOC
val €z_ﬂ_thm› : THM;
val €z_≠_thm› : THM;
=DESCRIBE
=GFT 
z_ﬂ_thm = Ù ¨µ f x y ∑
	Òf ç (x ﬂ y) § µ x1 : x; y1,y2 : y∑
		(x1 Ì y1) ç f ± (x1 Ì y2) ç f ¥ y1 = y2ÆÆ
z_≠_thm = Ù ¨µ f x y ∑
	Òf ç (x ≠ y) § f ç (x ﬂ y) ± dom f = xÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 105

=DOC
val €z_˛_thm› : THM;
val €z_‡_thm› : THM;
=DESCRIBE
=GFT 
z_˛_thm = Ù ¨µ f x y ∑
	Òf ç (x ˛ y) § f ç (x ﬂ y) ± 
		µ x1 x2 : dom f ∑ f x1 = f x2 ¥ x1 = x2ÆÆ
z_‡_thm = Ù ¨µ f x y ∑
	Òf ç (x ‡ y) § f ç (x ﬂ y) ± dom f = x ± 
		µ x1 x2 : x ∑ f x1 = f x2 ¥ x1 = x2ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 106

=DOC
val €z_œ_thm› : THM;
val €z_Ô_thm› : THM;
val €z_û_thm› : THM;
=DESCRIBE
=GFT 
z_œ_thm = Ù ¨µ f x y ∑
	Òf ç (x ˛ y) § f ç (x ﬂ y) ± ran f = yÆÆ
z_Ô_thm = Ù ¨µ f x y ∑
	Òf ç (x Ô y) § f ç (x ﬂ y) ± dom f = x ± ran f = yÆÆ
z_û_thm = Ù ¨µ f x y ∑
	Òf ç (x û y) § f ç (x ﬂ y) ± dom f = x ± ran f = y
		± (µ x1 x2 : x ∑ f x1 = f x2 ¥ x1 = x2)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 106

=DOC
val €z_´_thm› : THM;
=DESCRIBE
=GFT 
z_´_thm = Ù ¨µ f g ∑
	Òf ´ g = ((dom g) · f) ¿ g)ÆÆ
=TEX
=ENDDOC
Spivey Ed 1. page 108


\section{PROOF CONTEXTS}
Somewhere $µ\_rewrite\_thm$ needs to get inside an early Z proof context.
=DOC
(* Proof Context: €'z_sets_alg› *)
=DESCRIBE
A component proof context for handling the algebraic manipulation of Z sets, tuples and cartesian products.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, 
z_tuple_eq_conv, z_tuple_selection_conv, z_tuple_intro_conv,
z_ç_∏_conv
=TEX

Stripping theorems:
=GFT
z_ç_seta_conv, z_ç_setd_conv1,
z_tuple_eq_conv, z_ç_∏_conv,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_ç_seta_conv, z_ç_setd_conv1,
z_tuple_eq_conv, z_ç_∏_conv,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates$.
It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_ext$
=ENDDOC

This proof context
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
 will remain within the Z language if its argument starts there.
=DOC
(* Proof Context: €'z_sets_ext› *)
=DESCRIBE
An agressive component proof context for handling the manipulation of Z sets by breaking them into predicate calculus, plus handling for tuples and cartesian products.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_seta_conv, z_ç_setd_conv1, 
z_tuple_eq_conv, z_tuple_selection_conv, z_tuple_intro_conv
z_ç_∏_conv
=TEX

Stripping theorems:
=GFT
z_ç_seta_conv, z_ç_setd_conv1,
z_tuple_eq_conv, z_ç_∏_conv,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_ç_seta_conv, z_ç_setd_conv,
z_tuple_eq_conv, z_ç_∏_conv,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $basic\-\_prove\-\_tac$,
$basic\-\_prove\-\_conv$,
and
no existence prover (2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates$.
It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_alg$
=ENDDOC
Perhaps later releases will add rules such as 
=GFT
(a,b,...) = p = (a = p.1 ± b = p.2 ± ...)
=TEX

This proof context
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
 will remain within the Z language if its argument starts there.

=TEX
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZSetTheory *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


