=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Schema Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP043}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z schema calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1, 1.2] 
First versions.
\item[Issue 1.3 (14th October 1992)]
Changes in theory hierarchy.
\item[Issue 1.4 (19th October 1992)]
Tightened domain of $z\_schema\_ref\_conv$.
\item [Issue 1.7, 11th November 1992] 
Changes as a consequence of changes in dependences.
\item [Issue 1.8, 20th+ November 1992] 
Completing the Schema Calculus.
\item [Issue 1.9, 30th November 1992] 
Further schema calculus additions.
\item[Issue 1.10 (2nd December 1992)]
Improved $U$ simplification.
\item[Issue 1.11 (3rd December 1992)]
Lost $ç\_C$, and $Z\-\_ç\-\_ELIM\-\_C$.
\item[Issue 1.12 (8th December 1992)]
Improvements to handling of schemas as predicates, and bindings.
Removed proof context for extensional treatment of schemas.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) schema calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD043}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the schema calculus of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD043}.
\subsubsection{Deficiencies}
There is something wrong with
=INLINEFT
full_dest_z_term ÒS'Æ;
=TEX
{}.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure €ZSchemaCalculus› : ZSchemaCalculus = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_language_ps"›;
val _ = set_merge_pcs ["z_predicates","'z_ç_set_lang", "'z_tuples_lang"];
val _ = set_flag("z_type_check_only",false);
=TEX

\section{THE CODE}
\subsection{Utilities}
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
=TEX
=SML
val sets_ext_thm = pc_rule1 "hol1" prove_rule[] 
	¨µ r s ∑ r = s § (µ x ∑ x ç r § x ç s)Æ;
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_¡_conv1 nm :CONV= (fn tm =>
		(simple_¡_conv nm
		ORELSE_C
		simple_¡_conv1 (nm ^ get_variant_suffix())) tm);
in
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_¡_conv1 nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_¡_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
end;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX
=SML
fun (€seq_simple_¬_conv1›:CONV) (tm:TERM) = (
	(TRY_C (RAND_C z_binding_sel_conv)
	THEN_C
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv1 THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv1" 27008 [tm1])))
	tm
);
=TEX
\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
val €dp_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p]d"Æ))
		to 1));
local
	val cnjs = strip_±_rule(all_µ_elim dp_proj_thm);
in
	val €d_dp_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dp_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX

\section{THE IMPLEMENTATION}
=IGN
 πZ
rel	px _,py _, pz _
 ∞
 ù[X]
px _ :  X;
py _ :  X;
pz _ :  X
 à

 ˇS[X]¸
x:X
 ˜
px x
 à
 ˇDS[X]¸
x:X;
x':X
 ˜
px x ± px x'
 à
=TEX
\subsection{Duplicating Treatment of ç for Schema as Predicates}
=SML
local
	val cnv1 = simple_eq_match_conv1 z'schemapred_def;
in	
fun €DUP_SAP_C› (cnv:CONV) : CONV = TRY_C (RATOR_C(RATOR_C cnv1)) THEN_C cnv;
end;
=TEX
\subsection{Local Existence Provers}
=SML
local
	val c1 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ (x = x) § TÆ);
	val c2 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ T ± x § xÆ);
	val c3 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ x ± T § xÆ);
	val ¥_thm = tac_proof(([],¨µ x ∑ x ¥ xÆ),REPEAT strip_tac);
	fun local_rule thm gl = (
	let 	val (a,b) = dest_¥ gl;
		val (x,bdy) = dest_eq(concl thm);
		val ithm = simple_µ_elim b ¥_thm;
	in
		subst_rule[(eq_sym_rule thm,x)] gl ithm
	end);
	val rw_tac2_thm = tac_proof(([],
		¨µ t∑ ≥ (F ± t) ± ≥ (t ± F) ±
		((∂ x ∑ F) § F) ± ≥(µ x ∑ F) ±
		(µ x∑ x = x § T) ± (F ¥ t) ±
		(≥ T § F) ± (≥ F § T)Æ),
		PC_T1 "hol1" rewrite_tac[]);
	val rw_tac2 = (prim_rewrite_tac	
		(make_net(flat(map (cthm_eqn_cxt initial_rw_canon)
			[rw_tac2_thm])))
		initial_rw_canon 
		TOP_MAP_C
		[]);
in
fun €local_prove_∂_conv› (wit : TERM) : CONV = (fn tm =>
let	val (x,bdy) = dest_simple_∂ tm;
	val res = var_subst [(wit,x)] bdy;
	val s1 = ALL_SIMPLE_∂_C (RIGHT_C(RIGHT_C (c1 ORELSE_C (LEFT_C c1 THEN_C c2)))) res;
	val new_term = snd(dest_eq(concl s1));
	val s2 = tac_proof(([],mk_eq(tm, new_term)),
		§_T2
		(fn thm =>
		t_tac ORELSE
		conv_tac(fn ag => eq_sym_rule s1)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @ frees (concl s1)) x;
			in
			CASES_T2 (mk_eq(x',wit))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac wit THEN accept_tac 
			(§_mp_rule (eq_sym_rule s1) thm)
		));
in
	s2
end);
fun €local_prove_∂_conv1› (wit : TERM) : CONV = (fn tm =>
let	val (x,bdy) = dest_simple_∂ tm;
	val res = var_subst [(wit,x)] bdy;
	val s1 = ALL_SIMPLE_∂_C (RIGHT_C c1 THEN_C c3) res;
	val new_term = snd(dest_eq(concl s1));
	val s2 = tac_proof(([],mk_eq(tm, new_term)),
		§_T2
		(fn thm =>
		conv_tac(fn ag => eq_sym_rule s1)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @ frees (concl s1)) x;
			in
			CASES_T2 (mk_eq(x',wit))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				conv_rule(RAND_C eq_sym_conv) thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac wit THEN accept_tac 
			(§_mp_rule (eq_sym_rule s1) thm)
		));
in
	s2
end);
end;

		
=TEX
=IGN
local_prove_∂_conv1 ¨x:'aÆ ¨∂ y :'a∑ p y ± x = yÆ;
=TEX
\subsection{New Names}
Return a ``pleasant'' name, so far unused in a term.
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if ord nm = ordx
		then nm
		else fail "" 0 []);
	fun lgive_n_name lst = (
	let	fun nextn n = (let val poss = "x" ^ string_of_int n
			in
			if poss mem lst
			then nextn (n+1)
			else poss
			end);
	in
		nextn 1
	end);
in
fun €give_n_name› (tm:TERM) : string = (
let	val names = mapfilter xnames (term_vars tm);
in
	lgive_n_name names
end)
end;
=TEX
Apply a conversion to each of the subterms bound by
a binding:
=SML
fun €BINDING_C› cnv1 = COND_C is_z_binding (RANDS_C cnv1) fail_conv;
=TEX

\subsection{  Terms}
=SML
local
val cnv1 = simple_eq_match_conv1 z' _def;
in
val €z_ _conv› : CONV = (fn tm => (
let	val s1 = cnv1 tm
in
	check_is_z_conv_result "z_ _conv" s1
end)
handle complaint =>
divert complaint "simple_eq_match_conv1" "z_ _conv" 43010
	[fn () => string_of_term tm]
);
end;
=IGN
z_ _conv Ò  DSÆ;
=SML
local
val cnv1 = simple_eq_match_conv1 z' _def;
val cnv2 = simple_eq_match_conv1 z'schemadec_def;
val cnv3 = simple_eq_match_conv1 (prove_rule[]¨µ x:'a ∑ (x = x) § TÆ);
in
val €z_ _ç_schema_conv› : CONV = (fn tm => (
let	val ( s,s) = dest_z_ç tm;
	val (s',decor) = dest_z_   s;
	val dummy = if s' =$ s andalso decor = ""
		then ()
		else term_fail "z_ _ç_schema_conv" 43002 [tm];
	val decs = mk_z_decsexp(s',"");
	val res_tm = mk_eq(tm,decs);
in
	check_is_z_conv_result "z_ _ç_schema_conv"
	(§_t_elim((APP_C(RAND_C(LEFT_C cnv1),
			RATOR_C(RATOR_C cnv2)) THEN_C
		cnv3) res_tm))
end)
handle complaint =>
list_divert complaint "z_ _ç_schema_conv" 
	[("dest_z_ç", 43002, [fn () => string_of_term tm]),
	("dest_z_ ", 43002, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43002, [fn () => string_of_term tm])])
;
end;
=IGN
 z_ _ç_schema_conv Ò S ç SÆ;
=TEX
The following is necessary because we may have, e.g., a variable
of a given binding type:
=SML
fun €const_of_binding_type› (ty : TYPE) : TERM = ( 
let	val (tyname,tys) = (dest_ctype ty);
	val (tcname,tysname,_) = dest_z_name tyname;
	val dummy = if length tysname <> 1 orelse tcname <> "Z'S"
		then fail "const_of_binding_type" 0 []
		else ();
	val cons_of_ty = ZTypesAndTermsSupport.bind_cterm 
		(combine (hd tysname) tys);
in
	cons_of_ty
end);
=TEX
A local version of $z\_binding\_eq\_conv2$, that just processes the LHS binding,
which had better be present.
=SML
val €z_binding_eq_conv2› : CONV = (fn tm => (
let	val (b1,b2) = dest_z_eq tm;
	val aconst = const_of_binding_type (type_of b1);
	val spec = binding_gen_semantic_const aconst
		handle (Fail _) => 
		(diag_string "binding_gen_semantic_const fail - z_binding_eq_conv2";
		get_spec aconst);
	val (bcons,bproj) = get_binding_info (type_of b1);
	val ty_insts = type_match (type_of b1) (type_of(fst(dest_µ(concl spec))));
	val bcons' = map (inst[] ty_insts) bproj;
	val s1 = asm_rule tm;
	val s1s = map (fn x => app_fun_rule  x s1) bcons';
	val s2 = list_±_intro s1s;
	val s3s = strip_±_rule(asm_rule(list_mk_± (map concl s1s)));
	val s4 = fold (fn (x,y) =>  mk_app_rule y x) (rev s3s)
		(refl_conv (inst [] ty_insts bcons));
	val s5 = all_µ_intro(hd(rev(strip_±_rule(all_µ_elim spec))));
	val s6 = conv_rule(LEFT_C (simple_eq_match_conv1 s5)
		THEN_C RIGHT_C (simple_eq_match_conv1 s5)) s4;
	val s7 = §_intro (all_¥_intro s2) (all_¥_intro s6);
	val b1args = map snd(dest_z_binding b1);
	val proj_thms = rev(tl(rev
		(strip_±_rule(list_µ_elim (b1 :: b1args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn thm => LEFT_C (fn _ => thm)) proj_thms))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end
)
handle complaint =>
list_divert complaint "z_binding_eq_conv2"
	[("dest_z_eq", 43005, [fn () => string_of_term tm]),
	("get_spec", 43005, [fn () => string_of_term tm]),
	("const_of_binding_type", 43005, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=TEX
=IGN
z_binding_eq_conv2 Ò(x ¶ 1, y ¶ 2, z ¶ 3) = (y ¶ 2, x ¶ 1, z ¶ 3)Æ; (* not in signature *)
=SML
local
	val c1 = simple_eq_match_conv1 z' _def;
	val c2 = simple_eq_match_conv1(taut_rule
		¨µ x ∑ x ± T § xÆ);
in
val €lz_ç_horiz_schema_conv› : CONV = (fn tm => (
let	val (x,s) = dest_z_ç tm;
	val (d,p) = dest_z_âs s;
	val spec = schema_gen_semantic_const s;
	val s1 = (RAND_C(simple_eq_match_conv spec)
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule(RAND_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv) THEN_C
			RIGHT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm )) s1;
	val res = mk_z_∂(d, p,mk_z_eq(mk_z_ (mk_z_âs(d,mk_t),""),x));
	val s3 = (z_∂_elim_conv THEN_C ALL_SIMPLE_∂_C
		(RIGHT_C(RIGHT_C (LEFT_C c1 THEN_C 
			z_binding_eq_conv2)))) res;
	val wits = map (snd o dest_eq)
		(strip_±(snd(dest_app(snd(dest_app(
		snd(strip_∂ (snd(dest_eq (concl s3))))))))));
	val s4 = conv_rule (RIGHT_C(EVERY_C (map local_prove_∂_conv wits)
			)) s3;
	val s5 = conv_rule (RIGHT_C (RIGHT_C c2)) s4;
	val s6 = eq_trans_rule s2 (eq_sym_rule s5);
in
	check_is_z_conv_result "z_ç_horiz_schema_conv" s6
end
)
handle complaint =>
list_divert complaint "z_ç_horiz_schema_conv" 
	[("dest_z_ç", 43003, [fn () => string_of_term tm]),
	("dest_z_âs", 43003, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43003, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
val €z_ç_horiz_schema_conv› : CONV = DUP_SAP_C lz_ç_horiz_schema_conv;
=IGN
z_ç_horiz_schema_conv Òy ç [z:X; S; S'| x = z]Æ;
=TEX
=SML
local
	val c1 = simple_eq_match_conv1 z' _def;
	val c2 = simple_eq_match_conv1(taut_rule
		¨µ x ∑ x ± T § xÆ);
	val c3 = simple_eq_match_conv1 z'schemapred_def;
in
val €lz_ç_horiz_schema_conv1› : CONV = (fn tm => (
let	val (x,s) = dest_z_ç tm;
	val (d,p) = dest_z_âs s;
	val spec = schema_gen_semantic_const s;
	val s1 = (RAND_C(simple_eq_match_conv spec)
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule(RAND_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv1 ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv) THEN_C
			RIGHT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm )) s1;
	val s3 = conv_rule(RAND_C(LEFT_C(DECL_C 
		(dec_pred_conv THEN_TRY_C (RATOR_C(RATOR_C c3)))))) s2; 
in
	check_is_z_conv_result "z_ç_horiz_schema_conv1" s3
end
)
handle complaint =>
list_divert complaint "z_ç_horiz_schema_conv1" 
	[("dest_z_ç", 43003, [fn () => string_of_term tm]),
	("dest_z_âs", 43003, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43003, [fn () => string_of_term tm])])
;
end;
val €z_ç_horiz_schema_conv1› : CONV = DUP_SAP_C lz_ç_horiz_schema_conv1;

=IGN
z_ç_horiz_schema_conv1 Òy ç [z:X; S; S'| x = z]Æ;

=TEX
=SML
local
	val thm1 = conv_rule z_µ_elim_conv1 z_sets_ext_thm;
in
val €lz_sets_ext_conv› :CONV = simple_eq_match_conv1  thm1;
end;
=TEX
=SML
local
	val c2 = simple_eq_match_conv1 (pc_rule1 "hol1" prove_rule []
		¨µ x ∑ (x = x) § TÆ);
	val c3 = simple_eq_match_conv1 
		(prove_rule[] Ò(µ z:U ∑ true) § trueÆ);
in
val €z_horiz_schema_conv› : CONV = (fn tm => (
let	val (d,p) = dest_z_âs tm;
	val res = mk_z_seta(d, p,mk_z_ (mk_z_âs(d,mk_t),""));
	val s1 = lz_sets_ext_conv (mk_eq (tm, res));
	val s2 = conv_rule(RAND_C(RAND_C(BINDER_C(RAND_C(
		LEFT_C z_ç_horiz_schema_conv THEN_C
		RIGHT_C z_ç_seta_conv
		THEN_C c2)))
		THEN_C c3)) s1;
	val s3 = §_t_elim s2;
in
	check_is_z_conv_result "z_horiz_schema_conv" 
	(eq_trans_rule (refl_conv tm) s3)
end
)
handle complaint =>
list_divert complaint "z_horiz_schema_conv" 
	[("dest_z_âs", 43004, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43004, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_horiz_schema_conv Ò[z:X; S; S'| x = z]Æ;
=TEX
=SML
local
	fun mk_u_dec v = mk_z_dec([v],
		inst [] [(type_of v, tva)] Ua);
	val c1 = pure_rewrite_conv[taut_rule
		¨µ x ∑ ((x ± T) § x) ± ((T ± x) § x)Æ];
	val c2 = pure_rewrite_conv[taut_rule
		¨µ x ∑ ((T ± x) § x)Æ];
in
val €z_norm_horiz_schema_conv› : CONV = (fn tm => (
let	val (d,p) = dest_z_âs tm;
	val spec = get_spec tm;
	val s1 = simple_eq_match_conv spec tm;
	val dvars = fst(strip_Ã(fst(strip_app(snd(dest_app
		(fst(dest_±(snd(dest_set_comp (snd(dest_eq (concl s1))))))))))));
	val res_decl = mk_z_decl (map mk_u_dec dvars);
	val s2 = conv_rule(RAND_C(BINDER_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv THEN_C
			DECL_C (dec_pred_conv
				THEN_TRY_C ç_u_conv) THEN_TRY_C
			c1
			) THEN_C
			RIGHT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm ))) s1;
	val x_set_abs = fst(dest_set_comp (snd(dest_eq (concl s1))));
	val x_sels = map (fn y => mk_z_selâs(x_set_abs,fst(dest_var y)))
		dvars;
	val res_pred = subst(combine dvars x_sels) (snd(dest_set_comp (snd(dest_eq (concl s2)))));
	val res = mk_z_âs(res_decl, res_pred);
	val s3 = simple_eq_match_conv spec res;
	val s4 = conv_rule(RAND_C(BINDER_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv THEN_C
			DECL_C (dec_pred_conv
				THEN_C ç_u_conv) THEN_TRY_C
			c1
			) THEN_C c2
			THEN_C (RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm ))) s3;
	val s5 = eq_trans_rule s2 (eq_sym_rule s4);
in
	check_is_z_conv_result "z_norm_horiz_schema_conv" 
	(eq_trans_rule (refl_conv tm) s5)

end)
handle complaint =>
list_divert complaint "z_norm_horiz_schema_conv" 
	[("dest_z_âs", 43004, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43004, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_norm_horiz_schema_conv Ò[x,y1:X; z: Y; p,q : U; r : U; S; S' | x1 = x]Æ;
=TEX
=SML
val €lz_ç_decâs_conv› : CONV = (fn tm => (
let	val (x,sd) = dest_z_ç tm;
	val (s,dec) = dest_z_decâs sd;
	val spec = decâs_gen_semantic_const sd
		handle (Fail _) =>
		(diag_string "decâs_gen_semantic_const fail - z_ç_decâs_conv";
		get_spec sd);
	val s1 = conv_rule(BINDER_C(RIGHT_C(BINDER_C(BINDER_C
		(RIGHT_C (z_binding_eq_conv1)))))) spec;
	val wits = map dest_eq
		(strip_±(snd(dest_app(
		snd(strip_∂ (snd(dest_set_comp(snd(dest_eq (snd(dest_µ(concl s1))))))))))));
	val labs = map (snd o dest_z_selâs o snd) wits;
	val vs = map fst wits;
	val wit = mk_z_binding(combine labs vs);
	val bind = fst(dest_z_selâs(snd(hd wits)));
	val s2 =eq_sym_rule(z_binding_eq_conv2 (mk_eq(wit,bind)));
	val s3= conv_rule(BINDER_C(RIGHT_C(BINDER_C(BINDER_C(RIGHT_C
		(fn _ => s2)))))) s1;
	val s4 = conv_rule (BINDER_C(RIGHT_C(BINDER_C(local_prove_∂_conv1 wit)))) s3;
	val s5 = (RIGHT_C (simple_eq_match_conv1 s4)
		THEN_C ç_comp_conv) tm;
	val s6 = conv_rule(RIGHT_C(LEFT_C(BINDING_C(TRY_C z_binding_sel_conv)))) s5; 
in
	check_is_z_conv_result "z_ç_decâs_conv" s6
end)
handle complaint =>
list_divert complaint "z_ç_decâs_conv" 
	[("dest_z_decâs", 43015, [fn () => string_of_term tm]),
	("dest_z_ç", 43015, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43015, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
val €z_ç_decâs_conv› : CONV = DUP_SAP_C lz_ç_decâs_conv;
=IGN
z_ç_decâs_conv Òp ç ë(mk_z_decâs(Ò[z:X; S; S'| x = z]Æ,"'"))ÆÆ;
=TEX
=SML
val €z_decâs_conv› = Z_ç_ELIM_C z_ç_decâs_conv;
=TEX
=SML
local
	val c1 = RATOR_C(RATOR_C(simple_eq_match_conv1 z'schemapred_def));
	val c2 = simple_eq_match_conv1 z' _def;
in
val €z_ _ç_schema_intro_conv› : CONV = (fn tm => (
let	val (sd,dec) = dest_z_predsexp tm;
	val s1 = c1 tm; 
	val  _tm = mk_z_ (sd,dec);
	val s2 = c2  _tm;
	val s3 = conv_rule (RIGHT_C(LEFT_C (fn _ => eq_sym_rule s2))) s1;
in
	check_is_z_conv_result "z_ _ç_schema_intro_conv"
	(eq_trans_rule (refl_conv tm) s3)
end)
handle complaint =>
list_divert complaint "z_ _ç_schema_intro_conv"
	[("dest_z_predsexp",43014,[fn () => string_of_term tm]),
	("eq_trans_rule",43000,[fn () => string_of_term tm])]
);
end;

val €z_schema_pred_conv› : CONV = z_ _ç_schema_intro_conv;
=IGN
z_ _ç_schema_intro_conv (mk_z_predsexp( ÒSÆ,""));
z_ _ç_schema_intro_conv (mk_z_predsexp( ÒSÆ,"'"));
z_ _ç_schema_intro_conv (mk_z_predsexp( mk_z_decâs(ÒSÆ,"'"),""));
\subsubsection{Reintroucing Schema as Predicate Carefully}

=SML
local

open ZTypesAndTermsSupport;

local
	val aux = Sort.sort Sort.string_order;
in
fun €dest_sorted_strings› (ss : string list) : string list = (
	if aux ss = ss
	then ss
	else fail "dest_sorted_strings" 0 []
);
end;
fun €dest_bind_tname› (nm : string) : string list = (
	case dest_z_name nm of
	("Z'S",[fid],Nil) => dest_sorted_strings fid
	| _ => fail "dest_bind_tname" 0 []
);
=TEX
=SML
fun €dest_bind_type› (ty : TYPE) : (string * TYPE) list = (
let	val (nm,tys) = dest_ctype ty;
	val fst_itym = dest_bind_tname nm;
in
	combine fst_itym tys
end);
=TEX
=SML
fun €dest_bind_ctype› (ty : TYPE) : (string * TYPE) list = (
let	val tys = rev(strip_≠_type ty);
	val core_type = hd tys;
	val atypes = rev(tl tys);
	val itym = dest_bind_type core_type;
in
	if list_eq (op =:) atypes (map snd itym)
	then itym
	else fail "dest_bind_ctype" 0 []
end);
=TEX
=SML
fun €dest_bind_cname› (s : string) : string list = (
case dest_z_name s of
("Z'Mk_S",[fid],Nil) => dest_sorted_strings fid
| _ => fail "dest_bind_cname" 0 []
);
=TEX
=SML
fun €dest_bind_cterm› (tm : TERM) : (string * TYPE) list = (
let	val (cnm,cty) = dest_const tm;
	val nm_fst_itym = dest_bind_cname cnm;
	val ty_itym = dest_bind_ctype cty;
in
	if nm_fst_itym = map fst ty_itym
	then ty_itym
	else fail "dest_bind_cterm" 0 []
end);

val cnv1 = simple_eq_match_conv1 z'schemapred_def;
in
val €z_schema_pred_intro_conv› : CONV = (fn tm =>(
let	val (bind,s) = dest_z_ç tm;
	val (bcons,argl) = strip_app bind;
	val args_itym = map dest_var argl;
	val b_itym = dest_bind_cterm bcons;
	val d_args = case args_itym of
		(a :: x) => snd(unpack_ident (fst a))
		| _ => "";
	val d_ty = case b_itym of
		(a :: x) => snd(unpack_ident (fst a))
		| _ => "";
	val d = implode ((explode d_args) from (size d_ty));
	val dummy = if d_args = d_ty ^ d
		then ()
		else fail "z_schema_pred_intro_conv" 0 [];
	val dummy = (if list_eq (fn ((a,aty),(b,bty)) => 
		let	val (anm,ad) = unpack_ident a;
			val (bnm,bd) = unpack_ident b;
		in
		anm=bnm andalso ad = bd ^ d andalso (aty =: bty)
		end) 
		args_itym b_itym
		then ()
		else fail "full_dest_binding" 0 []);
	val res = mk_z_predsexp (s,d);
	val res_thm = eq_trans_rule (refl_conv tm) (eq_sym_rule
		(RATOR_C(RATOR_C cnv1) res));
	val check = case full_dest_z_term res of
		ZSchemaPred(s1,d1) => if (s1 =$ s) andalso (d = d1)
			then ()
			else term_fail "schema_pred_intro_conv" 43032 [tm]
		| _ => term_fail "schema_pred_intro_conv" 43032 [tm];
in
	res_thm
end)
handle (Fail _) =>
term_fail "z_schema_pred_intro_conv" 43032 [tm]
);
end;
=TEX
\subsubsection{Back to the Rest}
=SML
local
	val c1 = RATOR_C(RATOR_C(simple_eq_match_conv1 z'schemapred_def));
in
val €z_horiz_schema_pred_conv› : CONV = (fn tm => (
let	val (s,dec) = dest_z_predsexp tm;
	val s1 = c1 tm;
	val res_thm =
	(if is_z_decâs s
	then (
let	val s2 =  conv_rule (RIGHT_C (z_ç_decâs_conv THEN_C
		LEFT_C(TRY_C(ONCE_MAP_C z_binding_sel_conv)))) s1;
	val s3 = conv_rule(RIGHT_C z_ç_horiz_schema_conv1) s2;
in
	s3
end)
else (
let	val s2 = conv_rule(RIGHT_C z_ç_horiz_schema_conv1) s1;
in
	s2
end));
	val res_thm' = conv_rule(RIGHT_C(TRY_C(LEFT_C(±_C(
		LEFT_C (ONCE_MAP_C z_binding_sel_conv)))))) res_thm;

in
	check_is_z_conv_result "z_horiz_schema_pred_conv" 
	(eq_trans_rule (refl_conv tm) res_thm')
end
)
handle complaint =>
list_divert complaint "z_horiz_schema_pred_conv" 
	[("dest_z_predsexp", 43012, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43012, [fn () => string_of_term tm]),
	("z_ç_horiz_schema_conv1", 43012, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_horiz_schema_pred_conv (mk_z_predsexp( Ò[z:X; S; S'| x = z]Æ,""));
z_horiz_schema_pred_conv (mk_z_predsexp( Ò[zz,z:X; S; S'| x = z]Æ,"'"));
z_horiz_schema_pred_conv (mk_z_predsexp( mk_z_decâs(Ò[z:X; S; S'| x = z]Æ,"'"),""));
=TEX
=SML
val €z_preâs_conv› : CONV = (fn tm => (
let	val s = dest_z_preâs tm;
	val spec = preâs_gen_semantic_const tm;
	val s1 = simple_eq_match_conv1 spec tm;
in
	check_is_z_conv_result "z_preâs_conv" s1
end)
handle complaint =>
list_divert complaint "z_preâs_conv"
	[("Z Term-Generator", 43009, [fn () => string_of_term tm]),
	("preâs_gen_semantic_const", 43009, [fn () => string_of_term tm]),
	("dest_z_preâs", 43007, [fn () => string_of_term tm])]);

=IGN
z_preâs_conv Òpre DSÆ;
z_preâs_conv (mk_z_preâs ÒSÆ) (* fails with 43009 *);
z_preâs_conv Òpre (DS[Y])Æ;
z_preâs_conv Òpre [a',b',c:˙]Æ;
=TEX
=SML
val €z_ç_preâs_conv› = DUP_SAP_C(ç_C z_preâs_conv);
=TEX
=SML
val €z_Ñâs_conv› : CONV = (fn tm => (
let	val s = dest_z_Ñâs tm;
	val spec = Ñâs_gen_semantic_const tm;
	val s1 = simple_eq_match_conv1 spec tm;
in
	check_is_z_conv_result "z_Ñâs_conv" s1
end)
handle complaint =>
list_divert complaint "z_Ñâs_conv"
	[("Ñâs_gen_semantic_const", 43022, [fn () => string_of_term tm]),
	("dest_z_Ñâs", 43022, [fn () => string_of_term tm])]);

val €z_ç_Ñâs_conv› = DUP_SAP_C(ç_C z_Ñâs_conv);
=TEX
=IGN
z_Ñâs_conv ÒÑ [a',b,c:X]Æ;
z_ç_Ñâs_conv Òp ç (Ñ [a',b,c:X])Æ;
=TEX
=SML
val €z_òâs_conv› : CONV = (fn tm => (
let	val s = dest_z_òâs tm;
	val spec = òâs_gen_semantic_const tm;
	val s1 = simple_eq_match_conv1 spec tm;
in
	check_is_z_conv_result "z_òâs_conv" s1
end)
handle complaint =>
list_divert complaint "z_òâs_conv"
	[("òâs_gen_semantic_const", 43023, [fn () => string_of_term tm]),
	("dest_z_òâs", 43023, [fn () => string_of_term tm])]);

val €z_ç_òâs_conv› = DUP_SAP_C(ç_C z_òâs_conv);
=TEX
=IGN
z_òâs_conv Òò [a',b,c:X]Æ;
z_ç_òâs_conv Òp ç (ò [a',b,c:X])Æ;
=TEX
\section{PREDICATE CALCULUS WITH SCHEMAS}
=SML
fun €DYOP_SOP_BINDING_C› cnv1 = APP_C(
	RAND_C(LEFT_C(BINDING_C cnv1)),
	LEFT_C(BINDING_C cnv1));
val €dyop_sop_binding_sel_conv› = DYOP_SOP_BINDING_C (TRY_C z_binding_sel_conv);
=SML
val €lz_ç_±âs_conv› : CONV = (fn tm =>(
let	val (v,sc) = dest_z_ç tm;
	val (r,s) = dest_z_±âs sc
		handle complaint => 
		divert complaint "dest_z_±âs" "z_ç_±âs_conv" 43001 [fn () => string_of_term tm];
	val spec = dyopâs_gen_semantic_const sc
		handle (Fail _) =>
		(diag_string "dyopâs_gen_semantic_const fail - z_ç_±âs_conv";
		get_spec sc);
	val s1 = (RIGHT_C (simple_eq_match_conv spec) 
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule (RIGHT_C dyop_sop_binding_sel_conv) s1;
in
	check_is_z_conv_result "z_ç_±âs_conv" s2
end)
handle complaint =>
list_divert complaint "z_ç_±âs_conv" [
	("dest_z_ç",43001,[fn () => string_of_term tm]),
	("dest_z_±âs",43001,[fn () => string_of_term tm])]
);
val €z_ç_±âs_conv› : CONV = DUP_SAP_C lz_ç_±âs_conv;
val €z_±âs_conv› = Z_ç_ELIM_C z_ç_±âs_conv;	
=IGN
z_ç_±âs_convÒp ç (([x:U; y:U| f x y] ± [y:U;z:U | g y z]) ∫ U)Æ;
z_±âs_convÒ(([x:U; y:U| f x y] ± [y:U;z:U | g y z]) ∫ U)Æ;
=TEX
=SML
val €lz_ç_≤âs_conv› : CONV = (fn tm =>(
let	val (v,sc) = dest_z_ç tm;
	val (r,s) = dest_z_≤âs sc;
	val spec = dyopâs_gen_semantic_const sc
		handle (Fail _) =>
		(diag_string "dyopâs_gen_semantic_const fail - z_ç_≤âs_conv";
		get_spec sc);
	val s1 = (RIGHT_C (simple_eq_match_conv spec) 
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule (RIGHT_C dyop_sop_binding_sel_conv) s1;
in
	check_is_z_conv_result "z_ç_≤âs_conv" s2
end)
handle complaint =>
list_divert complaint "z_ç_≤âs_conv" [
	("dest_z_ç",43005,[fn () => string_of_term tm]),
	("dest_z_≤âs",43005,[fn () => string_of_term tm])]);
val €z_ç_≤âs_conv› : CONV = DUP_SAP_C lz_ç_≤âs_conv;
val €z_≤âs_conv› = Z_ç_ELIM_C z_ç_≤âs_conv;	
=IGN
z_ç_≤âs_convÒp ç (([x:U; y:U| f x y] ≤ [y:U;z:U | g y z]) ∫ U)Æ;
z_≤âs_convÒ(([x:U; y:U| f x y] ≤ [y:U;z:U | g y z]) ∫ U)Æ;
=TEX
=SML
val €lz_ç_¥âs_conv› : CONV = (fn tm =>(
let	val (v,sc) = dest_z_ç tm;
	val (r,s) = dest_z_¥âs sc;
	val spec = dyopâs_gen_semantic_const sc
		handle (Fail _) =>
		(diag_string "dyopâs_gen_semantic_const fail - z_ç_¥âs_conv";
		get_spec sc);
	val s1 = (RIGHT_C (simple_eq_match_conv spec) 
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule (RIGHT_C dyop_sop_binding_sel_conv) s1;
in
	check_is_z_conv_result "z_ç_¥âs_conv" s2
end)
handle complaint =>
list_divert complaint "z_ç_¥âs_conv" [
	("dest_z_ç",43006,[fn () => string_of_term tm]),
	("dest_z_¥âs",43006,[fn () => string_of_term tm])]);
val €z_ç_¥âs_conv› : CONV = DUP_SAP_C lz_ç_¥âs_conv;
val €z_¥âs_conv› = Z_ç_ELIM_C z_ç_¥âs_conv;	
=IGN
z_ç_¥âs_convÒp ç (([x:U; y:U| f x y] ¥ [y:U;z:U | g y z]) ∫ U)Æ;
z_¥âs_convÒ(([x:U; y:U| f x y] ¥ [y:U;z:U | g y z]) ∫ U)Æ;
=TEX
=SML
val €lz_ç_§âs_conv› : CONV = (fn tm =>(
let	val (v,sc) = dest_z_ç tm;
	val (r,s) = dest_z_§âs sc;
	val spec = dyopâs_gen_semantic_const sc
		handle (Fail _) =>
		(diag_string "dyopâs_gen_semantic_const fail - z_ç_§âs_conv";
		get_spec sc);
	val s1 = (RIGHT_C (simple_eq_match_conv spec) 
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule (RIGHT_C dyop_sop_binding_sel_conv) s1;
in
	check_is_z_conv_result "z_ç_§âs_conv" s2
end)
handle complaint =>
list_divert complaint "z_ç_§âs_conv" [
	("dest_z_ç",43016,[fn () => string_of_term tm]),
	("dest_z_§âs",43016,[fn () => string_of_term tm])]);
val €z_ç_§âs_conv› : CONV = DUP_SAP_C lz_ç_§âs_conv;
val €z_§âs_conv› = Z_ç_ELIM_C z_ç_§âs_conv;	
=IGN
z_ç_§âs_convÒp ç (([x:U; y:U| f x y] § [y:U;z:U | g y z]) ∫ U)Æ;
z_§âs_convÒ(([x:U; y:U| f x y] § [y:U;z:U | g y z]) ∫ U)Æ;
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 z'≥âs_def;
in
val €lz_ç_≥âs_conv› : CONV = (fn tm =>(
let	val (v,sc) = dest_z_ç tm;
	val r = dest_z_≥âs sc;
	val s1 = cnv1 tm;
in
	check_is_z_conv_result "z_ç_≥âs_conv" s1
end)
handle complaint =>
list_divert complaint "z_ç_≥âs_conv" [
	("dest_z_ç",43017,[fn () => string_of_term tm]),
	("dest_z_≥âs",43017,[fn () => string_of_term tm])]);
end;
val €z_ç_≥âs_conv› : CONV = DUP_SAP_C lz_ç_≥âs_conv;
val €z_≥âs_conv› = Z_ç_ELIM_C z_ç_≥âs_conv;	
=IGN
z_ç_≥âs_convÒp ç ((≥[x:U; y:U| f x y]) ∫ U)Æ;
z_≥âs_convÒ(≥[x:U; y:U| f x y]) ∫ UÆ;
=TEX
\section{SCHEMA QUANTIFICATION}
=SML
fun €QUANT_SOP_BINDING_C› cnv1 = BINDER_C(
	RIGHT_C(LEFT_C(BINDING_C cnv1)));
val €quant_sop_binding_sel_conv› = QUANT_SOP_BINDING_C (TRY_C z_binding_sel_conv);
=TEX
=SML
local
	val cnv1 = BINDER_C(LEFT_C(
		fn tm1 =>
		let	val ¬red = snd(dest_app(fst(dest_± tm1)));
			val ¬red_thm = seq_simple_¬_conv ¬red;
		in
		APP_C (
		RAND_C(RAND_C (fn _ => ¬red_thm) THEN_C d_dp_proj_conv THEN_C z_decl_pred_conv),
		RAND_C (fn _ => ¬red_thm) THEN_C p_dp_proj_conv) tm1
		end));
in
val €lz_ç_∂âs_conv› : CONV = (fn tm =>(
let	val (x,st) = dest_z_ç tm;
	val (d,p,v) = dest_z_∂âs st;
	val xnm = give_n_name tm;
	val spec = quantâs_gen_semantic_const st;
	val spec' = conv_rule(ALL_SIMPLE_µ_C(RAND_C(BINDER_C(RAND_C(simple_¡_conv xnm))))) spec;
	val s1 = (RAND_C (simple_eq_match_conv1 spec') THEN_C
		ç_comp_conv) tm;
	val s1' = conv_rule (RIGHT_C quant_sop_binding_sel_conv) s1;
	val s2 = conv_rule(RIGHT_C cnv1) s1';
	val s3 = conv_rule(RIGHT_C z_∂_intro_conv1) s2;
in
	check_is_z_conv_result "z_ç_∂âs_conv" 
		(eq_trans_rule (refl_conv tm) s3)
end)
handle complaint =>
list_divert complaint "z_ç_∂âs_conv" 
	[("dest_z_ç", 43020, [fn () => string_of_term tm]),
	("dest_z_∂âs", 43020, [fn () => string_of_term tm])]);
end;
val €z_ç_∂âs_conv› : CONV = DUP_SAP_C lz_ç_∂âs_conv;
val €z_∂âs_conv› = Z_ç_ELIM_C z_ç_∂âs_conv;
=IGN
z_ç_∂âs_conv Òv ç ((∂ x,y:X;z:U | p x z ∑ ([w:W;x,y:X;z:U | q w x y z] ∫ U))∫ U)Æ;
z_ç_∂âs_conv Ò(x ¶ x1, y ¶ y1) ç (∂ z:U | g x y ∑ [x,y:X;z:Y | f x y z])Æ;
z_∂âs_conv Ò((∂ x,y:X;z:U | p x z ∑ ([w:W;x,y:X;z:U | q w x y z] ∫ U))∫ U)Æ;

=TEX
=SML
local
	val cnv1 = BINDER_C(LEFT_C(
		fn tm1 =>
		let	val ¬red = snd(dest_app(fst(dest_± tm1)));
			val ¬red_thm = seq_simple_¬_conv ¬red;
		in
		APP_C (
		RAND_C(RAND_C (fn _ => ¬red_thm) THEN_C d_dp_proj_conv THEN_C z_decl_pred_conv),
		RAND_C (fn _ => ¬red_thm) THEN_C p_dp_proj_conv) tm1
		end));
in
val €lz_ç_µâs_conv› : CONV = (fn tm =>(
let	val (x,st) = dest_z_ç tm;
	val (d,p,v) = dest_z_µâs st;
	val xnm = give_n_name tm;
	val spec = quantâs_gen_semantic_const st;
	val spec' = conv_rule(ALL_SIMPLE_µ_C(RAND_C(BINDER_C(RAND_C(simple_¡_conv xnm))))) spec;
	val s1 = (RAND_C (simple_eq_match_conv1 spec') THEN_C
		ç_comp_conv) tm;
	val s1' = conv_rule (RIGHT_C quant_sop_binding_sel_conv) s1;
	val s2 = conv_rule(RIGHT_C cnv1) s1';
	val s3 = conv_rule(RIGHT_C z_µ_intro_conv1) s2;
in
	check_is_z_conv_result "z_ç_µâs_conv" 
		(eq_trans_rule (refl_conv tm) s3)
end)
handle complaint =>
list_divert complaint "z_ç_µâs_conv" 
	[("dest_z_ç", 43030, [fn () => string_of_term tm]),
	("dest_z_µâs", 43030, [fn () => string_of_term tm])]);
end;
val €z_ç_µâs_conv› : CONV = DUP_SAP_C lz_ç_µâs_conv;
val €z_µâs_conv› :CONV = Z_ç_ELIM_C z_ç_µâs_conv;

=IGN
z_ç_µâs_conv Òw ç ((µ x,y:X;z:U | p x z ∑ ([w:W;x,y:X;z:U | q w x y z] ∫ U))∫ U)Æ;
z_µâs_conv Ò((µ x,y:X;z:U | p x z ∑ ([w:W;x,y:X;z:U | q w x y z] ∫ U))∫ U)Æ;

=TEX
=SML
local
	val cnv1 = BINDER_C(LEFT_C(
		fn tm1 =>
		let	val ¬red = snd(dest_app(fst(dest_± tm1)));
			val ¬red_thm = seq_simple_¬_conv ¬red;
		in
		APP_C (
		RAND_C(RAND_C (fn _ => ¬red_thm) THEN_C d_dp_proj_conv THEN_C z_decl_pred_conv),
		RAND_C (fn _ => ¬red_thm) THEN_C p_dp_proj_conv) tm1
		end));
in
val €lz_ç_∂â1âs_conv› : CONV = (fn tm =>(
let	val (x,st) = dest_z_ç tm;
	val (d,p,v) = dest_z_∂â1âs st;
	val xnm = give_n_name tm;
	val spec = quantâs_gen_semantic_const st;
	val spec' = conv_rule(ALL_SIMPLE_µ_C(RAND_C(BINDER_C(RAND_C(simple_¡_conv xnm))))) spec;
	val s1 = (RAND_C (simple_eq_match_conv1 spec') THEN_C
		ç_comp_conv) tm;
	val s1' = conv_rule (RIGHT_C quant_sop_binding_sel_conv) s1;
	val s2 = conv_rule(RIGHT_C cnv1) s1';
	val s3 = conv_rule(RIGHT_C z_∂â1_intro_conv) s2;
in
	check_is_z_conv_result "z_ç_∂â1âs_conv" 
		(eq_trans_rule (refl_conv tm) s3)
end)
handle complaint =>
list_divert complaint "z_ç_∂â1âs_conv" 
	[("dest_z_ç", 43021, [fn () => string_of_term tm]),
	("dest_z_∂â1âs", 43021, [fn () => string_of_term tm])]);
end;
val €z_ç_∂â1âs_conv› : CONV = DUP_SAP_C lz_ç_∂â1âs_conv;
val €z_∂â1âs_conv› = Z_ç_ELIM_C z_ç_∂â1âs_conv;
=IGN
z_ç_∂â1âs_conv Òv ç ((∂â1 x,y:X;z:U | p x z ∑ ([w:W;x,y:X;z:U | q w x y z] ∫ U))∫ U)Æ;
z_∂â1âs_conv Ò((∂â1 x,y:X;z:U | p x z ∑ ([w:W;x,y:X;z:U | q w x y z] ∫ U))∫ U)Æ;
=TEX
\section{OTHER SCHEMA CALCULUS OPERATORS}
=SML
val €z_˘âs_conv› : CONV = (fn tm =>
let	val (r,s) = dest_z_˘âs tm
		handle complaint => 
		divert complaint "dest_z_˘âs" "z_˘âs_conv" 43019 [fn () => string_of_term tm];
	val s1 = simple_eq_match_conv1 (get_spec tm) tm;
in
	check_is_z_conv_result "z_˘âs_conv" s1
end);
val €z_ç_˘âs_conv› = DUP_SAP_C(ç_C z_˘âs_conv);
=IGN
z_ç_˘âs_convÒp ç ([x:X; y,z:Y| f x z y] ˘âs [p:P;y:Y | g p y])Æ;
z_˘âs_convÒ[x:X; y,z:Y| f x  zy] ˘âs [p:P;y:Y | g p y]Æ;
=TEX
=SML
val €z_hideâs_conv› : CONV = (fn tm =>
let	val (s,xs) = dest_z_hideâs tm
		handle complaint => 
		divert complaint "dest_z_hideâs" "z_hideâs_conv" 43018 [fn () => string_of_term tm];
	val s1 = simple_eq_match_conv1 (get_spec tm) tm;
in
	check_is_z_conv_result "z_ç_hideâs_conv" s1
end);
val €z_ç_hideâs_conv› = DUP_SAP_C(ç_C z_hideâs_conv);
=IGN
z_ç_hideâs_convÒp ç ([w,x:X; y,z:Y| f w x z y] \âs (x,z))Æ;
z_hideâs_convÒ[w,x:X; y,z:Y| f w x z y] \âs (x,z)Æ;
=TEX
=SML
val €z_ªâs_conv› : CONV = (fn tm =>
let	val (r,s) = dest_z_ªâs tm
		handle complaint => 
		divert complaint "dest_z_ªâs" "z_ªâs_conv" 43025 [fn () => string_of_term tm];
	val s1 = simple_eq_match_conv1 (get_spec tm) tm;
in
	check_is_z_conv_result "z_ç_ªâs_conv" s1
end);
val €z_ç_ªâs_conv› = DUP_SAP_C (ç_C z_ªâs_conv);
=IGN
z_ç_ªâs_convÒp ç ([x,x':X; y,z,w':Y| f w' x x' z y] ªâs [p:P;x:X;w,y:Y | g x p y])Æ;
z_ªâs_convÒ[x,x':X; y,z,w':Y| f x x' z y] ªâs [p:P;x:X;w,y:Y | g x p y]Æ;
=TEX
=SML
val €z_binding_intro_conv› : CONV = (fn tm =>
let	val s1 = binding_gen_semantic_const tm;
	val s2 = all_µ_intro(eq_sym_rule(hd(rev(strip_±_rule(all_µ_elim s1)))));
in
	(simple_eq_match_conv1 s2 tm)
end);
val €z_binding_elim_conv› : CONV = (fn tm =>
let	val s1 = binding_gen_semantic_const tm;
	val s2 = all_µ_intro((hd(rev(strip_±_rule(all_µ_elim s1)))));
in
	(simple_eq_match_conv1 s2 tm)
end);
=TEX
=SML
local
	val rwt = pure_rewrite_tac[
		pc_rule1 "hol1" prove_rule[] ¨µ x ∑ (x = x) § TÆ];
in
val €lz_ç_renameâs_conv› : CONV = (fn tm =>
let	val (x,st) = dest_z_ç tm
		handle complaint => 
		divert complaint "dest_z_ç" "z_ç_renameâs_conv" 43031 [fn () => string_of_term tm];
	val (s,rs) = dest_z_renameâs st
		handle complaint => 
		divert complaint "dest_z_renameâs" "z_ç_renameâs_conv" 43031 [fn () => string_of_term tm];
	val spec = get_spec st;
	val s1 = (RAND_C(simple_eq_match_conv1 spec) THEN_C
		ç_comp_conv)tm;
	val bind = snd(dest_eq(snd(dest_±(snd(dest_simple_∂(snd(dest_eq (concl s1))))))));
	val change = map (fn (nm,sel) =>
		(snd(dest_z_selâs sel),mk_z_selâs(x,nm)))
		(dest_z_binding bind);
	val wit = mk_z_binding change;
	val s2 = tac_proof(([],mk_eq(snd(dest_eq(concl s1)),
		mk_z_ç(wit,s))),
		§_T2
		(fn ∂_thm => SIMPLE_∂_THEN 
			(fn thm => asm_tac (±_left_elim thm)
			THEN pure_rewrite_thm_tac (conv_rule 
		(z_binding_eq_conv THEN_C
		(±_C (RIGHT_C z_binding_sel_conv)))
		(±_right_elim thm)))
			∂_thm
		THEN conv_tac(LEFT_C z_binding_elim_conv)
		THEN concl_in_asms_tac)
		(fn res_thm =>
		simple_∂_tac wit THEN
		±_tac THEN_LIST [
		accept_tac res_thm,
		conv_tac(RIGHT_C(ONCE_MAP_C z_binding_sel_conv)
			THEN_C RIGHT_C z_binding_elim_conv)
		THEN rwt])
		);
	val s3 = conv_rule(RIGHT_C(LEFT_C(BINDING_C
		(TRY_C z_binding_sel_conv)))) s2;
	val s4 = eq_trans_rule s1 s3;
in
	check_is_z_conv_result "z_ç_renameâs_conv" 
		(eq_trans_rule (refl_conv tm) s3)
end);
end;
val €z_ç_renameâs_conv› : CONV = DUP_SAP_C z_ç_renameâs_conv;
val €z_renameâs_conv› : CONV = Z_ç_ELIM_C z_ç_renameâs_conv;
=IGN
z_ç_renameâs_conv Òv ç Ò[x,x':X; y,z,w':Y| f w' x x' z y][p/x,q/x',r/s]ÆÆ;
z_ç_renameâs_conv Ò(p ¶ p1, q ¶ q1, y ¶ y1, z ¶ z1, w' ¶ w1) ç Ò[x,x':X; y,z,w':Y| f w' x x' z y][p/x,q/x',r/s]ÆÆ;
z_renameâs_convÒ[x,x':X; y,z,w':Y| f w' x x' z y][p/x,q/x',r/s]Æ;
=TEX

\section{PROOF CONTEXTS}
=SML
val €z_schema_ç_conv› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
in
	case (dest_z_term s) of
	Z≥âs _ => z_ç_≥âs_conv tm
	| Z±âs _ => z_ç_±âs_conv tm
	| Z≤âs _ => z_ç_≤âs_conv tm
	| Z¥âs _ => z_ç_¥âs_conv tm
	| Z§âs _ => z_ç_§âs_conv tm
	| Z∂âs _ => z_ç_∂âs_conv tm
	| Z∂â1âs _ => z_ç_∂â1âs_conv tm
	| Zµâs _ => z_ç_µâs_conv tm
	| Zâs _ => z_ç_horiz_schema_conv1 tm
	| ZDecorâs _ => z_ç_decâs_conv tm
	| ZPreâs _ => z_ç_preâs_conv tm
	| Z˘âs _ => z_ç_˘âs_conv tm
	| ZHideâs _ => z_ç_hideâs_conv tm
	| ZÑâs _ => z_ç_Ñâs_conv tm
	| Zòâs _ => z_ç_òâs_conv tm
	| Zªâs _ => z_ç_ªâs_conv tm
	| ZRenameâs _ => z_ç_renameâs_conv tm
	| _ => z_schema_pred_intro_conv tm
end);
=TEX
=SML
val €z_schema_pred_ç_conv› : CONV = (fn tm =>
let	val (x,s) = dest_bin_op "z_schema_pred_ç_conv" 0 "Z'SchemaPred" tm;
in
	case (dest_z_term s) of
	Z≥âs _ => z_ç_≥âs_conv tm
	| Z±âs _ => z_ç_±âs_conv tm
	| Z≤âs _ => z_ç_≤âs_conv tm
	| Z¥âs _ => z_ç_¥âs_conv tm
	| Z§âs _ => z_ç_§âs_conv tm
	| Z∂âs _ => z_ç_∂âs_conv tm
	| Z∂â1âs _ => z_ç_∂â1âs_conv tm
	| Zµâs _ => z_ç_µâs_conv tm
	| Zâs _ => z_ç_horiz_schema_conv1 tm
	| ZDecorâs _ => z_ç_decâs_conv tm
	| ZPreâs _ => z_ç_preâs_conv tm
	| Z˘âs _ => z_ç_˘âs_conv tm
	| ZHideâs _ => z_ç_hideâs_conv tm
	| ZÑâs _ => z_ç_Ñâs_conv tm
	| Zòâs _ => z_ç_òâs_conv tm
	| Zªâs _ => z_ç_ªâs_conv tm
	| ZRenameâs _ => z_ç_renameâs_conv tm
	| _ => fail "" 0 []
end);
=TEX
=SML
val sp_conv = simple_eq_match_conv1 z'schemapred_def;
val €schema_ec› = [(Òx ç yÆ,z_schema_ç_conv),
	(¨Z'SchemaPred x yÆ,z_schema_pred_ç_conv)];
val €sel_ _conv› = (fn tm =>
	if is_z_selâs tm
	then (RAND_C z_ _conv THEN_C z_binding_sel_conv) tm
	else fail "" 0 []
);
=IGN
sel_ _conv Ò(  [x,y,z:X|f x y z]) .yÆ;
=TEX
=SML
val _ = delete_pc "'z_schemas" handle (Fail _) => ();
val _ = new_pc "'z_schemas";
val _ = set_rw_eqn_cxt (schema_ec @ 
		[(¨f(Z'  x)Æ,sel_ _conv)])"'z_schemas";
val _ = add_rw_thms ([]) "'z_schemas";
val _ = set_st_eqn_cxt (schema_ec @
		(map (mk_≥ ** RAND_C) schema_ec)) "'z_schemas";
val _ = add_st_thms ([]) "'z_schemas";
val _ = set_sc_eqn_cxt (schema_ec @
		(map (mk_≥ ** RAND_C) schema_ec)) "'z_schemas";
val _ =set_rw_canons [] "'z_schemas";
val _ =set_pr_tac z_basic_prove_tac "'z_schemas";
val _ =set_pr_conv z_basic_prove_conv "'z_schemas";
val _ =set_cs_∂_convs[] 
	"'z_schemas";
val _ =set_∂_vs_thms [] "'z_schemas";
val _ = commit_pc "'z_schemas";

=TEX
\section{EPILOGUE}
=SML
end; (* of structure ZSchemaCalculus *)
open ZSchemaCalculus;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
