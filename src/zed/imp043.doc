=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Schema Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP043}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z schema calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1, 1.2] 
First versions.
\item[Issue 1.3 (14th October 1992)]
Changes in theory hierarchy.
\item[Issue 1.4 (19th October 1992)]
Tightened domain of $z\_schema\_ref\_conv$.
\item [Issue 1.7, 11th November 1992] 
Changes as a consequence of changes in dependences.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) schema calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD043}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the schema calculus of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD043}.
\subsubsection{Deficiencies}
There is something wrong with
=INLINEFT
full_dest_z_term ÒS'Æ;
=TEX
{}.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure €ZSchemaCalculus› : ZSchemaCalculus = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_language_ps"›;
val _ = set_merge_pcs ["z_predicates","'z_ç_set_lang", "'z_tuples_lang"];
val _ = set_flag("z_type_check_only",false);
=TEX

\section{THE CODE}
\subsection{Utilities}
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_¡_conv1 nm :CONV= (fn tm =>
		(simple_¡_conv nm
		ORELSE_C
		simple_¡_conv1 (nm ^ get_variant_suffix())) tm);
in
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_¡_conv1 nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_¡_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
end;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX

\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
val €dp_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p]d"Æ))
		to 1));
local
	val cnjs = strip_±_rule(all_µ_elim dp_proj_thm);
in
	val €d_dp_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dp_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
\section{THE IMPLEMENTATION}
=IGN
 πZ
rel	px _,py _, pz _
 ∞
 ù[X]
px _ :  X;
py _ :  X;
pz _ :  X
 à

 ˇS[X]¸
x:X
 ˜
px x
 à
 ˇDS[X]¸
x:X;
x':X
 ˜
px x ± px x'
 à
=SML
local
val cnv1 = simple_eq_match_conv1 z' _def;
in
val €z_ _conv› : CONV = (fn tm => (
let	val s1 = cnv1 tm
in
	check_is_z_conv_result "z_ _conv" s1
end)
handle complaint =>
divert complaint "simple_eq_match_conv1" "z_ _conv" 43010
	[fn () => string_of_term tm]
);
end;
=IGN
z_ _conv Ò  DSÆ;
=SML
local
val cnv1 = simple_eq_match_conv1 z' _def;
val cnv2 = simple_eq_match_conv1 z'schemadec_def;
val cnv3 = simple_eq_match_conv1 (prove_rule[]¨µ x:'a ∑ (x = x) § TÆ);
in
val €z_ _ç_schema_conv› : CONV = (fn tm => (
let	val ( s,s) = dest_z_ç tm;
	val (s',decor) = dest_z_   s;
	val dummy = if s' =$ s andalso decor = ""
		then ()
		else term_fail "z_ _ç_schema_conv" 43002 [tm];
	val decs = mk_z_decsexp(s',"");
	val res_tm = mk_eq(tm,decs);
in
	check_is_z_conv_result "z_ _ç_schema_conv"
	(§_t_elim((APP_C(RAND_C(LEFT_C cnv1),
			RATOR_C(RATOR_C cnv2)) THEN_C
		cnv3) res_tm))
end)
handle complaint =>
list_divert complaint "z_ _ç_schema_conv" 
	[("dest_z_ç", 43002, [fn () => string_of_term tm]),
	("dest_z_ ", 43002, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43002, [fn () => string_of_term tm])])
;
end;
=IGN
 z_ _ç_schema_conv Ò S ç SÆ;
=TEX
The following is necessary because we may have, e.g., a variable
of a given binding type:
=SML
fun €const_of_binding_type› (ty : TYPE) : TERM = ( 
let	val (tyname,tys) = (dest_ctype ty);
	val (tcname,tysname,_) = dest_z_name tyname;
	val dummy = if length tysname <> 1 orelse tcname <> "Z'S"
		then fail "const_of_binding_type" 0 []
		else ();
	val cons_of_ty = ZTypesAndTermsSupport.bind_cterm 
		(combine (hd tysname) tys);
in
	cons_of_ty
end);
=TEX
A local version of $z\_binding\_eq\_conv2$, that just processes the LHS binding,
which had better be present.
=SML
val €z_binding_eq_conv2› : CONV = (fn tm => (
let	val (b1,b2) = dest_z_eq tm;
	val aconst = const_of_binding_type (type_of b1);
	val spec = binding_gen_semantic_const aconst
		handle (Fail _) => 
		(diag_string "binding_gen_semantic_const fail - z_binding_eq_conv2";
		get_spec aconst);
	val (bcons,bproj) = get_binding_info (type_of b1);
	val ty_insts = type_match (type_of b1) (type_of(fst(dest_µ(concl spec))));
	val bcons' = map (inst[] ty_insts) bproj;
	val s1 = asm_rule tm;
	val s1s = map (fn x => app_fun_rule  x s1) bcons';
	val s2 = list_±_intro s1s;
	val s3s = strip_±_rule(asm_rule(list_mk_± (map concl s1s)));
	val s4 = fold (fn (x,y) =>  mk_app_rule y x) (rev s3s)
		(refl_conv (inst [] ty_insts bcons));
	val s5 = all_µ_intro(hd(rev(strip_±_rule(all_µ_elim spec))));
	val s6 = conv_rule(LEFT_C (simple_eq_match_conv1 s5)
		THEN_C RIGHT_C (simple_eq_match_conv1 s5)) s4;
	val s7 = §_intro (all_¥_intro s2) (all_¥_intro s6);
	val b1args = map snd(dest_z_binding b1);
	val proj_thms = rev(tl(rev
		(strip_±_rule(list_µ_elim (b1 :: b1args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn thm => LEFT_C (fn _ => thm)) proj_thms))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end
)
handle complaint =>
list_divert complaint "z_binding_eq_conv2"
	[("dest_z_eq", 43005, [fn () => string_of_term tm]),
	("get_spec", 43005, [fn () => string_of_term tm]),
	("const_of_binding_type", 43005, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=TEX
=IGN
z_binding_eq_conv2 Ò(x ¶ 1, y ¶ 2, z ¶ 3) = (y ¶ 2, x ¶ 1, z ¶ 3)Æ; (* not in signature *)
=SML
local
	val c1 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ (x = x) § TÆ);
	val c2 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ T ± x § xÆ);
	val c3 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ x ± T § xÆ);
	val ¥_thm = tac_proof(([],¨µ x ∑ x ¥ xÆ),REPEAT strip_tac);
	fun local_rule thm gl = (
	let 	val (a,b) = dest_¥ gl;
		val (x,bdy) = dest_eq(concl thm);
		val ithm = simple_µ_elim b ¥_thm;
	in
		subst_rule[(eq_sym_rule thm,x)] gl ithm
	end);
	val rw_tac2_thm = tac_proof(([],
		¨µ t∑ ≥ (F ± t) ± ≥ (t ± F) ±
		((∂ x ∑ F) § F) ± ≥(µ x ∑ F) ±
		(µ x∑ x = x § T) ± (F ¥ t) ±
		(≥ T § F) ± (≥ F § T)Æ),
		PC_T1 "hol1" rewrite_tac[]);
	val rw_tac2 = (prim_rewrite_tac	
		(make_net(flat(map (cthm_eqn_cxt initial_rw_canon)
			[rw_tac2_thm])))
		initial_rw_canon 
		TOP_MAP_C
		[]);
in
fun €local_prove_∂_conv› (wit : TERM) : CONV = (fn tm =>
let	val (x,bdy) = dest_simple_∂ tm;
	val res = var_subst [(wit,x)] bdy;
	val s1 = ALL_SIMPLE_∂_C (RIGHT_C(RIGHT_C (c1 ORELSE_C (LEFT_C c1 THEN_C c2)))) res;
	val new_term = snd(dest_eq(concl s1));
	val s2 = tac_proof(([],mk_eq(tm, new_term)),
		§_T2
		(fn thm =>
		t_tac ORELSE
		conv_tac(fn ag => eq_sym_rule s1)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @ frees (concl s1)) x;
			in
			CASES_T2 (mk_eq(x',wit))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac wit THEN accept_tac 
			(§_mp_rule (eq_sym_rule s1) thm)
		));
in
	s2
end);
fun €local_prove_∂_conv1› (wit : TERM) : CONV = (fn tm =>
let	val (x,bdy) = dest_simple_∂ tm;
	val res = var_subst [(wit,x)] bdy;
	val s1 = ALL_SIMPLE_∂_C (RIGHT_C c1 THEN_C c3) res;
	val new_term = snd(dest_eq(concl s1));
	val s2 = tac_proof(([],mk_eq(tm, new_term)),
		§_T2
		(fn thm =>
		conv_tac(fn ag => eq_sym_rule s1)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @ frees (concl s1)) x;
			in
			CASES_T2 (mk_eq(x',wit))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				conv_rule(RAND_C eq_sym_conv) thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac wit THEN accept_tac 
			(§_mp_rule (eq_sym_rule s1) thm)
		));
in
	s2
end);
end;

		
=TEX
=IGN
local_prove_∂_conv1 ¨x:'aÆ ¨∂ y :'a∑ p y ± x = yÆ;
=SML
local
	val c1 = simple_eq_match_conv1 z' _def;
	val c2 = simple_eq_match_conv1(taut_rule
		¨µ x ∑ x ± T § xÆ);
in
val €z_ç_horiz_schema_conv› : CONV = (fn tm => (
let	val (x,s) = dest_z_ç tm;
	val (d,p) = dest_z_âs s;
	val spec = schema_gen_semantic_const s;
	val s1 = (RAND_C(simple_eq_match_conv spec)
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule(RAND_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv) THEN_C
			RIGHT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm )) s1;
	val res = mk_z_∂(d, p,mk_z_eq(mk_z_ (mk_z_âs(d,mk_t),""),x));
	val s3 = (z_∂_elim_conv THEN_C ALL_SIMPLE_∂_C
		(RIGHT_C(RIGHT_C (LEFT_C c1 THEN_C 
			z_binding_eq_conv2)))) res;
	val wits = map (snd o dest_eq)
		(strip_±(snd(dest_app(snd(dest_app(
		snd(strip_∂ (snd(dest_eq (concl s3))))))))));
	val s4 = conv_rule (RIGHT_C(EVERY_C (map local_prove_∂_conv wits)
			)) s3;
	val s5 = conv_rule (RIGHT_C (RIGHT_C c2)) s4;
	val s6 = eq_trans_rule s2 (eq_sym_rule s5);
in
	check_is_z_conv_result "z_ç_horiz_schema_conv" s6
end
)
handle complaint =>
list_divert complaint "z_ç_horiz_schema_conv" 
	[("dest_z_ç", 43003, [fn () => string_of_term tm]),
	("dest_z_âs", 43003, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43003, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_ç_horiz_schema_conv Òy ç [z:X; S; S'| x = z]Æ;
=TEX
=SML
local
	val c1 = simple_eq_match_conv1 z' _def;
	val c2 = simple_eq_match_conv1(taut_rule
		¨µ x ∑ x ± T § xÆ);
	val c3 = simple_eq_match_conv1 z'schemapred_def;
in
val €z_ç_horiz_schema_conv1› : CONV = (fn tm => (
let	val (x,s) = dest_z_ç tm;
	val (d,p) = dest_z_âs s;
	val spec = schema_gen_semantic_const s;
	val s1 = (RAND_C(simple_eq_match_conv spec)
		THEN_C ç_comp_conv) tm;
	val s2 = conv_rule(RAND_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv) THEN_C
			RIGHT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm )) s1;
	val s3 = conv_rule(RAND_C(LEFT_C(DECL_C 
		(dec_pred_conv THEN_TRY_C (RATOR_C(RATOR_C c3)))))) s2; 
in
	check_is_z_conv_result "z_ç_horiz_schema_conv1" s3
end
)
handle complaint =>
list_divert complaint "z_ç_horiz_schema_conv1" 
	[("dest_z_ç", 43003, [fn () => string_of_term tm]),
	("dest_z_âs", 43003, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43003, [fn () => string_of_term tm])])
;
end;
=IGN
z_ç_horiz_schema_conv1 Òy ç [z:X; S; S'| x = z]Æ;

=TEX
=SML
val €lz_sets_ext_conv› :CONV = simple_eq_match_conv1 
		(conv_rule z_µ_elim_conv1 z_sets_ext_thm);
=TEX
=SML
local
	val c2 = simple_eq_match_conv1 (pc_rule1 "hol1" prove_rule []
		¨µ x ∑ (x = x) § TÆ);
	val c3 = simple_eq_match_conv1 
		(prove_rule[] Ò(µ z:U ∑ true) § trueÆ);
in
val €z_horiz_schema_conv› : CONV = (fn tm => (
let	val (d,p) = dest_z_âs tm;
	val res = mk_z_seta(d, p,mk_z_ (mk_z_âs(d,mk_t),""));
	val s1 = lz_sets_ext_conv (mk_eq (tm, res));
	val s2 = conv_rule(RAND_C(RAND_C(BINDER_C(RAND_C(
		LEFT_C z_ç_horiz_schema_conv THEN_C
		RIGHT_C z_ç_seta_conv
		THEN_C c2)))
		THEN_C c3)) s1;
	val s3 = §_t_elim s2;
in
	check_is_z_conv_result "z_horiz_schema_conv" 
	(eq_trans_rule (refl_conv tm) s3)
end
)
handle complaint =>
list_divert complaint "z_horiz_schema_conv" 
	[("dest_z_âs", 43004, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43004, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_horiz_schema_conv Ò[z:X; S; S'| x = z]Æ;
=TEX
=SML
local
	fun mk_u_dec v = mk_z_dec([v],
		inst [] [(type_of v, tva)] Ua);
	val c1 = pure_rewrite_conv[taut_rule
		¨µ x ∑ ((x ± T) § x) ± ((T ± x) § x)Æ];
	val c2 = pure_rewrite_conv[taut_rule
		¨µ x ∑ ((T ± x) § x)Æ];
in
val €z_norm_horiz_schema_conv› : CONV = (fn tm => (
let	val (d,p) = dest_z_âs tm;
	val spec = get_spec tm;
	val s1 = simple_eq_match_conv spec tm;
	val dvars = fst(strip_Ã(fst(strip_app(snd(dest_app
		(fst(dest_±(snd(dest_set_comp (snd(dest_eq (concl s1))))))))))));
	val res_decl = mk_z_decl (map mk_u_dec dvars);
	val s2 = conv_rule(RAND_C(BINDER_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv THEN_C
			DECL_C (dec_pred_conv
				THEN_TRY_C ç_u_lang_conv) THEN_TRY_C
			c1
			) THEN_C
			RIGHT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm ))) s1;
	val x_set_abs = fst(dest_set_comp (snd(dest_eq (concl s1))));
	val x_sels = map (fn y => mk_z_selâs(x_set_abs,fst(dest_var y)))
		dvars;
	val res_pred = subst(combine dvars x_sels) (snd(dest_set_comp (snd(dest_eq (concl s2)))));
	val res = mk_z_âs(res_decl, res_pred);
	val s3 = simple_eq_match_conv spec res;
	val s4 = conv_rule(RAND_C(BINDER_C(fn itm =>
		(let	val ¬red = snd(dest_app(fst(dest_± itm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
			LEFT_C(RAND_C (fn _ => ¬red_thm)
			THEN_C d_dp_proj_conv THEN_C
			DECL_C (dec_pred_conv
				THEN_C ç_u_lang_conv) THEN_TRY_C
			c1
			) THEN_C c2
			THEN_C (RAND_C (fn _ => ¬red_thm)
			THEN_C p_dp_proj_conv)
		end) itm ))) s3;
	val s5 = eq_trans_rule s2 (eq_sym_rule s4);
in
	check_is_z_conv_result "z_norm_horiz_schema_conv" 
	(eq_trans_rule (refl_conv tm) s5)

end)
handle complaint =>
list_divert complaint "z_norm_horiz_schema_conv" 
	[("dest_z_âs", 43004, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43004, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_norm_horiz_schema_conv Ò[x,y1:X; z: Y; p,q : U; r : U; S; S' | x1 = x]Æ;
=TEX
=SML
val €z_ç_decâs_conv› : CONV = (fn tm => (
let	val (x,sd) = dest_z_ç tm;
	val (s,dec) = dest_z_decâs sd;
	val spec = decâs_gen_semantic_const sd
		handle (Fail _) =>
		(diag_string "decâs_gen_semantic_const fail - z_ç_decâs_conv";
		get_spec sd);
	val s1 = conv_rule(BINDER_C(RIGHT_C(BINDER_C(BINDER_C
		(RIGHT_C (z_binding_eq_conv1)))))) spec;
	val wits = map dest_eq
		(strip_±(snd(dest_app(
		snd(strip_∂ (snd(dest_set_comp(snd(dest_eq (snd(dest_µ(concl s1))))))))))));
	val labs = map (snd o dest_z_selâs o snd) wits;
	val vs = map fst wits;
	val wit = mk_z_binding(combine labs vs);
	val bind = fst(dest_z_selâs(snd(hd wits)));
	val s2 =eq_sym_rule(z_binding_eq_conv2 (mk_eq(wit,bind)));
	val s3= conv_rule(BINDER_C(RIGHT_C(BINDER_C(BINDER_C(RIGHT_C
		(fn _ => s2)))))) s1;
	val s4 = conv_rule (BINDER_C(RIGHT_C(BINDER_C(local_prove_∂_conv1 wit)))) s3;
	val s5 = (RIGHT_C (simple_eq_match_conv1 s4)
		THEN_C ç_comp_conv) tm;
in
	check_is_z_conv_result "z_ç_decâs_conv" s5
end)
handle complaint =>
list_divert complaint "z_ç_decâs_conv" 
	[("dest_z_decâs", 43015, [fn () => string_of_term tm]),
	("dest_z_ç", 43015, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43015, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=IGN
z_ç_decâs_conv Òp ç ë(mk_z_decâs(Ò[z:X; S; S'| x = z]Æ,"'"))ÆÆ;
=TEX
In the below we first(?) encounter the situation where,
because a schema definition may well have a (consistency) assumption,
we must use $simple\-\_eq\-\_match\-\_conv$.
=SML
val €z_schema_ref_conv› : CONV = (fn tm => (
let	val dummy = dest_z_gvar tm;
	val ty = type_of tm;
	val dummy = if is_z_power_t ty andalso is_z_schema_t(
			dest_z_power_t ty)
		then ()
		else term_fail "z_schema_ref_conv" 43011 [];
	val spec = conv_rule (TRY_C z_para_pred_conv) (get_spec tm);
	val s1 = simple_eq_match_conv spec tm;
in
	check_is_z_conv_result "z_schema_ref_conv" s1
end)
handle complaint =>
list_divert complaint "z_schema_ref_conv"
	[("dest_z_gvar",43011,[fn () => string_of_term tm]),
	("simple_eq_match_conv",43011,[fn () => string_of_term tm]),
	 ("get_spec",43013,[fn () => string_of_term tm])]
);
=IGN
z_schema_ref_conv ÒSÆ;
z_schema_ref_conv ÒS[V]Æ;
z_schema_ref_conv ÒS[ X]Æ;
=TEX
A quiet (if not Z) version of the above:
=SML
fun €qz_schema_ref_conv› (tm : TERM) = (
let	val f = get_flag "check_is_z";
	val dummy = set_flag("check_is_z",false);
	val res= z_schema_ref_conv tm;
	val dummy = set_flag("check_is_z",f);
in
	res
end);
=TEX
=SML
local
	val c1 = RATOR_C(RATOR_C(simple_eq_match_conv1 z'schemapred_def));
in
val €z_schema_ref_pred_conv› : CONV = (fn tm => (
let	val (s,dec) = dest_z_predsexp tm;
	val s1 = c1 tm;
	val res_thm =
	(if is_z_decâs s
	then (
let	val s2 = conv_rule (RIGHT_C (z_ç_decâs_conv THEN_C
		LEFT_C(TRY_C(ONCE_MAP_C z_binding_sel_conv)))) s1;
	val s3 = conv_rule(RIGHT_C(RIGHT_C qz_schema_ref_conv THEN_C
			z_ç_horiz_schema_conv1)) s2;
in
	s3
end)
else (
let	val s2 = conv_rule(RIGHT_C(RIGHT_C qz_schema_ref_conv THEN_C
			z_ç_horiz_schema_conv1)) s1;
in
	s2
end));
	val res_thm' = conv_rule(RIGHT_C(TRY_C(LEFT_C(±_C(
		LEFT_C (ONCE_MAP_C z_binding_sel_conv)))))) res_thm;
in
	check_is_z_conv_result "z_schema_ref_pred_conv" 
	(eq_trans_rule (refl_conv tm) res_thm')
end
)
handle complaint =>
list_divert complaint "z_schema_ref_pred_conv" 
	[("dest_z_predsexp", 43008, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43008, [fn () => string_of_term tm]),
	("z_schema_ref_conv", 43008, [fn () => string_of_term tm]),
	("z_ç_horiz_schema_conv1", 43008, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_schema_ref_pred_conv (mk_z_predsexp( ÒSÆ,""));
z_schema_ref_pred_conv (mk_z_predsexp( ÒSÆ,"'"));
z_schema_ref_pred_conv (mk_z_predsexp( mk_z_decâs(ÒSÆ,"'"),""));
=SML
local
	val c1 = RATOR_C(RATOR_C(simple_eq_match_conv1 z'schemapred_def));
	val c2 = simple_eq_match_conv1 z' _def;
in
val €z_ _ç_schema_intro_conv› : CONV = (fn tm => (
let	val (sd,dec) = dest_z_predsexp tm;
	val s1 = c1 tm; 
	val  _tm = mk_z_ (sd,dec);
	val s2 = c2  _tm;
	val s3 = conv_rule (RIGHT_C(LEFT_C (fn _ => eq_sym_rule s2))) s1;
in
	check_is_z_conv_result "z_ _ç_schema_intro_conv"
	(eq_trans_rule (refl_conv tm) s3)
end)
handle complaint =>
list_divert complaint "z_ _ç_schema_intro_conv"
	[("dest_z_predsexp",43014,[fn () => string_of_term tm]),
	("eq_trans_rule",43000,[fn () => string_of_term tm])]
);
end;
=IGN
z_ _ç_schema_intro_conv (mk_z_predsexp( ÒSÆ,""));
z_ _ç_schema_intro_conv (mk_z_predsexp( ÒSÆ,"'"));
z_ _ç_schema_intro_conv (mk_z_predsexp( mk_z_decâs(ÒSÆ,"'"),""));

=SML
local
	val c1 = RATOR_C(RATOR_C(simple_eq_match_conv1 z'schemapred_def));
in
val €z_horiz_schema_pred_conv› : CONV = (fn tm => (
let	val (s,dec) = dest_z_predsexp tm;
	val s1 = c1 tm;
	val res_thm =
	(if is_z_decâs s
	then (
let	val s2 =  conv_rule (RIGHT_C (z_ç_decâs_conv THEN_C
		LEFT_C(TRY_C(ONCE_MAP_C z_binding_sel_conv)))) s1;
	val s3 = conv_rule(RIGHT_C z_ç_horiz_schema_conv1) s2;
in
	s3
end)
else (
let	val s2 = conv_rule(RIGHT_C z_ç_horiz_schema_conv1) s1;
in
	s2
end));
	val res_thm' = conv_rule(RIGHT_C(TRY_C(LEFT_C(±_C(
		LEFT_C (ONCE_MAP_C z_binding_sel_conv)))))) res_thm;

in
	check_is_z_conv_result "z_horiz_schema_pred_conv" 
	(eq_trans_rule (refl_conv tm) res_thm')
end
)
handle complaint =>
list_divert complaint "z_horiz_schema_pred_conv" 
	[("dest_z_predsexp", 43012, [fn () => string_of_term tm]),
	("simple_eq_match_conv1", 43012, [fn () => string_of_term tm]),
	("z_ç_horiz_schema_conv1", 43012, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
end;
=IGN
z_horiz_schema_pred_conv (mk_z_predsexp( Ò[z:X; S; S'| x = z]Æ,""));
z_horiz_schema_pred_conv (mk_z_predsexp( Ò[zz,z:X; S; S'| x = z]Æ,"'"));
z_horiz_schema_pred_conv (mk_z_predsexp( mk_z_decâs(Ò[z:X; S; S'| x = z]Æ,"'"),""));
=TEX
=SML
val €z_preâs_conv› : CONV = (fn tm => (
let	val s = dest_z_preâs tm;
	val spec = preâs_gen_semantic_const tm;
	val s1 = simple_eq_match_conv1 spec tm;
in
	check_is_z_conv_result "z_preâs_conv" s1
end)
handle complaint =>
list_divert complaint "z_preâs_conv"
	[("Z Term-Generator", 43009, [fn () => string_of_term tm]),
	("preâs_gen_semantic_const", 43009, [fn () => string_of_term tm]),
	("dest_z_preâs", 43007, [fn () => string_of_term tm])]);

=IGN
z_preâs_conv Òpre DSÆ;
z_preâs_conv (mk_z_preâs ÒSÆ) (* fails with 43009 *);
z_preâs_conv Òpre (DS[Y])Æ;
z_preâs_conv Òpre [a',b',c:˙]Æ;
=TEX
\section{PROOF CONTEXTS}

\section{EPILOGUE}
=SML
end; (* of structure ZSchemaCalculus *)
open ZSchemaCalculus;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
