=IGN
********************************************************************************
imp085.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp085.doc   %Z% $Date: 2003/07/16 15:20:12 $ $Revision: 1.10 $ $RCSfile: imp085.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Functions}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP085}  %% Mandatory field
\def\SCCSversion{$Revision: 1.10 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2003/07/16 15:20:12 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Functions and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (22nd October 1992)]
First version, derived from 078 and 083.
\item [Issue 1.2, 12th November 1992]
Changes as a consequence of changes in dependences.
\item[Issue 1.4 (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.5-1.6 (8th-12th February 1993)]
Rearranging proof contexts.
\item[Issue 1.8] Copyright and banner updates for open source release.
\item[Issue 1.9] PPZed-specific updates for open source release
\item[Issue 1.10] Cured theorems that used to have free variables.
\item[Issue 1.11] The Z universal set is now called É.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library functions
given in \cite{DS/FMU/IED/DTD085}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD085}.
\subsection{Dependencies}
The mathematical toolkit for Z Library functions is introduced within the structure
$ZFunctions$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD085}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZFunctions$
(see\cite{DS/FMU/IED/DTD085}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZFunctions$}
\section{PREAMBLE}
Structure done in two parts.
=SML
structure €ZFunctions› : ZFunctions = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_functions"›;
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples","'z_ç_rel"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:

=SML
	val z_≠_def = get_spec Ò(_ ≠ _)Æ;
	val z_ﬂ_def = get_spec Ò(_ ﬂ _)Æ;
	val z_˛_def = get_spec Ò(_ ˛ _)Æ;
	val z_‡_def = get_spec Ò(_ ‡ _)Æ;
	val z_œ_def = get_spec Ò(_ œ _)Æ;
	val z_Ô_def = get_spec Ò(_ Ô _)Æ;
	val z_è_def = get_spec Ò(_ è _)Æ;
=TEX
=SML
val €Ua› = ÒÉÆ; (* type = 'a SET *)
val €Ub› = inst [] [(î'bÆ,î'aÆ)] Ua;
=TEX
=SML
val dummy = push_merge_pcs ["z_sets_ext", "'z_tuples"];
local
	val spec = (rewrite_rule[] z_ﬂ_def);
	val s1 = rewrite_conv [spec] Òf ç (X ﬂ Y)Æ;
in
val €z_ﬂ_thm› = save_thm("z_ﬂ_thm",
 	pure_rewrite_rule[z_Ì_thm]
	(all_z_µ_intro s1));
end;
val dummy = pop_pc();
=TEX
=SML
val €z_ﬂ_thm1› = save_thm("z_ﬂ_thm1",(
push_goal([],
	Òµ f : É; X : É; Y : É
          ∑ f ç (X ﬂ Y)
            § (f ç (X ™ Y)
              ± (µ x : É; y1, y2 : É |
		x ç X ± y1 ç Y ± y2 ç Y
                ∑ (x, y1) ç f ± (x, y2) ç f ¥ y1 = y2))Æ);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z_ç_rel"];
a(rewrite_tac[z_ﬂ_thm]);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(asm_fc_tac[]);
(* *** Goal "5" *** *)
a(asm_fc_tac[]);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[]);
pop_pc();
pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]z_≠_def);
	val s1 = rewrite_conv [spec] Òf ç (X ≠ Y)Æ;
	val s3 = (
push_goal([],Òf ç (X ≠ Y) § f ç (X ﬂ Y) ± dom f = XÆ);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z_ç_rel"];
a(rewrite_tac[z_ﬂ_thm, s1, z_dom_thm, z_Ì_thm]);
a(REPEAT strip_tac THEN_TRY_T(SOLVED_T (all_asm_fc_tac[])));
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 ÒxÆ);
a(z_spec_nth_asm_tac 1 Òy1Æ);
a(z_spec_nth_asm_tac 2 Òy2Æ);
a(all_var_elim_asm_tac THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
a(z_∂_tac ÒyÆ);
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "3.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(z_∂â1_tac ÒyÆ);
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x, x2 ¶ y)Æ);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ y', y2 ¶ y)Æ);
pop_pc();
pop_thm());
in
val €z_≠_thm› = save_thm("z_≠_thm", all_z_µ_intro s3);
end;
=TEX
=SML
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples"];
local
	val spec = (rewrite_rule[]z_˛_def);
	val s1 = rewrite_conv [spec] Òf ç (X ˛ Y)Æ;
	val s3 = prove_rule[s1] Òµ f: É;
	X: É; Y: É∑
	f ç X ˛ Y
      § f ç X ﬂ Y ± (µ x1, x2 : É |
		x1 ç dom f ± x2 ç dom f ∑ f x1 = f x2 ¥ x1 = x2)Æ;
in
val €z_˛_thm› = save_thm("z_˛_thm", s3);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_‡_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_˛_thm] Òf ç (X ‡ Y)Æ;
	val s2 = (
push_goal([], Òf ç (X ‡ Y) § f ç (X ≠ Y) ±
	(µ x1, x2 :É |
		x1 ç dom f ± x2 ç dom f ∑ f x1 = f x2 ¥ x1 = x2)Æ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_‡_thm› = save_thm("z_‡_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_œ_def);
	val s1 = rewrite_conv [spec] Òf ç (X œ Y)Æ;
in
val €z_œ_thm› = save_thm("z_œ_thm", all_z_µ_intro s1);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_Ô_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_œ_thm] Òf ç (X Ô Y)Æ;
	val s2 = (
push_goal([],
	Òf ç (X Ô Y) § f ç (X ≠ Y) ± ran f = YÆ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_Ô_thm› = save_thm("z_Ô_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_è_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_Ô_thm, z_‡_thm] Òf ç (X è Y)Æ;
	val s2 = (prove_rule[s1]
	Òf ç (X è Y) § f ç (X ≠ Y) ± ran f = Y ±
	   (µ x1, x2 : É | x1 ç dom f ± x2 ç dom f ∑
	    f x1 = f x2 ¥ x1 = x2)Æ);
in
val €z_è_thm› = save_thm("z_è_thm", all_z_µ_intro s2);
end;
val _ = pop_pc();
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun €make_ç_rule› thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun €make_pair_trio_rule› thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_selât_conv)
		(µ_elim Ò(p1,p2)Æ
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_selât_conv)
		(µ_elim Ò(p1 Ì p2)Æ (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val €ç_operator_clauses2› = [
	z_œ_thm, z_Ô_thm, z_è_thm,
	z_˛_thm, z_‡_thm, z_ﬂ_thm1, z_≠_thm];
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX
\subsection{Treatment of Membership of Functions}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_fun" handle Fail _ => ();
val _ = new_pc "'z_ç_fun";
val _ = set_rw_eqn_cxt []"'z_ç_fun";
val _ = add_rw_thms
	([]
	@ ç_operator_clauses2) "'z_ç_fun";

val pos = (thms_to_eqn_cxt ç_operator_clauses2)
	@ [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_ç_fun";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_ç_fun";
val _ = set_rw_canons [] "'z_ç_fun";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_fun";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_fun";
val _ = set_cs_∂_convs [] "'z_ç_fun";
val _ = set_∂_vs_thms [] "'z_ç_fun";
val _ = commit_pc "'z_ç_fun";

=TEX
\section{ADDITIONAL WORK}
This material relies on the just created proof contexts.
=SML
val €z_ext_pcs› = ["z_sets_ext", "'z_ç_rel", "'z_ç_fun", "'z_tuples"];
val €z_≠_app_thm› = (
push_merge_pcs z_ext_pcs;
set_goal([],Òµ X:É; Y:É;
	f: É; x:É∑
	f ç X ≠ Y ± x ç X ¥ f x ç Y ± (x, f x) ç fÆ);
a(z_strip_tac THEN z_strip_tac THEN z_strip_tac);
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òf x = yÆ);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 6  Ò(x1 ¶ x, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 7  Ò(x1 ¶ x, x2 ¶ y)Æ);
a(asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x, x2 ¶ y)Æ);
pop_pc();
save_thm ("z_≠_app_thm",pop_thm()));
=TEX
=SML
val _ = set_merge_pcs ["z_sets_alg", "'z_ç_rel", "'z_ç_fun", "'z_tuples"];
=TEX
=SML
local
val s1 = conv_rule z_para_pred_conv z_first_def;
val s2 = ±_left_elim (list_µ_elim[Ua,Ub] s1);
val s3 = s2;
val s4 = z_µ_elim Ò(X ¶ ((É ∫  a) ∏ (É ∫  b)),
		Y ¶ (É ∫  a), f ¶ first[(É ∫  a),(É ∫  b)],
		x ¶ (x ∫ (a ∏ b)))Æ z_≠_app_thm;
val s5 = pure_rewrite_rule [s3] s4;
val s6 = rewrite_rule[]  s5;
val s7 = all_µ_intro s6;
val s8 = z_µ_elim Ò(X ¶ ((É ∫  a) ∏ (É ∫  b)),
		Y ¶ (É ∫  b), f ¶ second[(É ∫  a),(É ∫  b)],
		x ¶ (x ∫ (a ∏ b)))Æ z_≠_app_thm;
val s9 = pure_rewrite_rule [s3] s8;
val s10 = rewrite_rule[]  s9;
val s11 = all_µ_intro s10;
in
val €z_ç_first_thm› = (
set_goal([],Òµ x : É ∑ x ç first § x.1.1 = x.2Æ);
push_merge_pcs z_ext_pcs;
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_left_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_selât_intro_conv)));
a(strip_asm_tac(µ_elim Òx.1Æ s7));
a(z_spec_nth_asm_tac 4  Ò(x ¶ x.1, y1 ¶ x.1.1, y2 ¶ x.2)Æ);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_selât_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s7]);
save_thm("z_ç_first_thm",pop_thm()));

val €z_ç_second_thm› = (
set_goal([],Òµ x : É ∑ x ç second § x.1.2 = x.2Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_right_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_selât_intro_conv)));
a(strip_asm_tac(µ_elim Òx.1Æ s11));
a(z_spec_nth_asm_tac 4  Ò(x ¶ x.1, y1 ¶ x.1.2, y2 ¶ x.2)Æ);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_selât_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s11]);
pop_pc();
save_thm("z_ç_second_thm",pop_thm()));
end;
=TEX
=SML
val  €z_≠_app_ç_rel_thm› = save_thm("z_≠_app_ç_rel_thm", (
push_goal([], ÒµX: É; Y : É∑µf : X ≠ Y; x : X∑(x, f x) ç fÆ);
a(REPEAT strip_tac);
a(all_fc_tac[z_≠_app_thm]);
pop_thm()
));
=TEX
=SML
val  €z_≠_app_eq_§_ç_rel_thm› = save_thm("z_≠_app_eq_§_ç_rel_thm", (
push_goal([], ÒµX: É; Y : É∑µf : X ≠ Y; x : X; z : É∑f x = z § (x, z) ç fÆ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(all_fc_tac[z_≠_app_ç_rel_thm]);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN MERGE_PCS_T1 z_ext_pcs REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(MERGE_PCS_T1 z_ext_pcs all_asm_fc_tac[] THEN all_asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val  €z_≠_ç_rel_§_app_eq_thm› = save_thm("z_≠_ç_rel_§_app_eq_thm", (
push_goal([], ÒµX: É; Y : É∑µf : X ≠ Y; x : X; z : É∑(x, z) ç f § f x = zÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN accept_tac z_≠_app_eq_§_ç_rel_thm);
pop_thm()
));
=TEX
\subsection{Simplification}
=SML
val _ = push_merge_pcs ["z_sets_ext", "'z_ç_rel", "'z_ç_fun", "'z_tuples"];

val €z_ﬂ_clauses› = save_thm("z_ﬂ_clauses", (
	prove_rule [] Òµ Y:É ∑
	{} ﬂ Y = {{}} ±
	Y ﬂ {} = {{}}Æ));
=TEX
=SML
val €z_≠_clauses› = save_thm("z_≠_clauses", (
set_goal( [], Òµ Y:É ∑
	{} ≠ Y = {{}} ±
	Y ≠ {} = {x: É | x = {} ± Y = {}}Æ);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val €z_˛_clauses› = save_thm("z_˛_clauses",
	prove_rule [] Òµ Y:É ∑
	{} ˛ Y = {{}} ±
	Y ˛ {} = {{}}Æ);
=TEX
=SML
val €z_‡_clauses› = save_thm("z_‡_clauses", (
set_goal( [], Òµ Y:É ∑
	{} ‡ Y = {{}} ±
	Y ‡ {} = {x:É| x = {} ± Y = {}}Æ);
a(prove_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val €z_œ_clauses› = save_thm("z_œ_clauses", (
set_goal( [], Òµ Y:É ∑
	{} œ Y = {x:É| x = {} ± Y = {}} ±
	Y œ {} = {{}}Æ);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val €z_Ô_clauses› = save_thm("z_Ô_clauses", (
set_goal( [], Òµ Y:É ∑
	{} Ô Y = {x:É| x = {} ± Y = {}} ±
	Y Ô {} = {x:É| x = {} ± Y = {}}Æ);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val €z_è_clauses› = save_thm("z_è_clauses", (
set_goal( [], Òµ Y:É ∑
	{} è Y = {x:É| x = {} ± Y = {}} ±
	Y è {} = {x:É| x = {} ± Y = {}}Æ);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));

val _ = pop_pc();
=TEX
=SML
fun €maybe_strip› (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else fail "" 0 []
);
local
	val setty = type_of Ò{}Æ;
in
fun €add_ç› ((index,cnv)::rest) = (
	(let val tyms = type_match (type_of index) setty @ [(î'aÆ,î'aÆ)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		((mk_z_ç(x,index), ç_C cnv) :: (index,cnv) :: add_ç rest)
	end)
	handle (Fail _) =>
	((index,cnv) :: add_ç rest)
) | add_ç [] = [];
end;

val z_fun_alg_eqn_cxt = add_ç(thms_to_eqn_cxt [z_ﬂ_clauses, z_≠_clauses, z_˛_clauses,
	z_‡_clauses, z_Ô_clauses, z_œ_clauses, z_è_clauses]);

val z_fun_alg_eqn_cxt_for_strip = mapfilter maybe_strip z_fun_alg_eqn_cxt;


val _ = delete_pc "'z_fun_alg" handle Fail _ => ();
val _ = new_pc "'z_fun_alg";
val _ = set_rw_eqn_cxt z_fun_alg_eqn_cxt"'z_fun_alg";
val _ = add_rw_thms ([]) "'z_fun_alg";

val pos = z_fun_alg_eqn_cxt_for_strip;
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_rw_canons [] "'z_fun_alg";
val _ = set_pr_tac z_basic_prove_tac "'z_fun_alg";
val _ = set_pr_conv z_basic_prove_conv "'z_fun_alg";
val _ = set_cs_∂_convs [] "'z_fun_alg";
val _ = set_∂_vs_thms [] "'z_fun_alg";
val _ = commit_pc "'z_fun_alg";

=TEX
=SML
val _ = delete_pc "z_fun_ext" handle Fail _ => ();
val _ = new_pc "z_fun_ext";
val _ = merge_pcs ["z_rel_ext","'z_fun_alg",
	"'z_ç_fun"] "z_fun_ext";
val _ = commit_pc "z_fun_ext";
=TEX
\subsection{Type Inference By Theorems}
=SML
val _ = push_pc "z_fun_ext";
=TEX
We use $z_spec_nth_asm_tac$ for speed, $all\_asm\_fc\_tac$
still works (?).
=SML
val €z_fun_app_clauses› = save_thm("z_fun_app_clauses", (
set_goal([],Òµ f:É; x:É;y:É; X:É;Y:É ∑
	(f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y ≤
	 f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	± (x,y) ç f
	¥ f x = yÆ);
a(REPEAT strip_tac THEN all_asm_fc_tac[] THEN z_app_eq_tac
	THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "5" *** *)
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "7" *** *)
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);

pop_thm()));
=TEX
=SML
val €z_fun_ç_clauses› = save_thm("z_fun_ç_clauses", (
set_goal([],Òµ f:É; x:É; X:É;Y:É ∑
	((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	± x ç X
	¥ f x ç Y)
	±
	((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
	± x ç dom f
	¥ f x ç Y)Æ);
a(PC_T1 "z_sets_alg" rewrite_tac[z_dom_thm] THEN
	REPEAT (PC_T "z_sets_alg" strip_tac) THEN
	GET_NTH_ASM_T 2 strip_asm_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 ÒxÆ);
(* *** Goal "1.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "3.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 3 ÒxÆ);
(* *** Goal "4.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "7" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
pop_thm()));
=TEX
=SML
val €z_fun_dom_clauses› = save_thm("z_fun_dom_clauses", (
set_goal([],Òµ f:É; X:É;Y:É ∑
	((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
	¥ dom f Ä X)
 	±
	((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	¥ dom f = X)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
(* *** Goal "5.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ THEN all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ);
(* *** Goal "7.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "7.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "8" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "9" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ);
(* *** Goal "9.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "9.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "10" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "11" *** *)
a(z_spec_nth_asm_tac 4 Òx1Æ);
(* *** Goal "11.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "11.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);

pop_thm()));
=TEX
=SML
val €z_fun_ran_clauses› = save_thm("z_fun_ran_clauses", (
set_goal([],Òµ f:É; X:É;Y:É ∑
	((f ç X ≠ Y ≤ f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X ‡ Y)
	¥ ran f Ä Y)
	±
	((f ç X œ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	¥ ran f = Y)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
(* *** Goal "6.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "8" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
(* *** Goal "8.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "8.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "9" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "10" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ);
(* *** Goal "10.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "10.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
pop_thm()));
=TEX
=SML
val _ = pop_pc();
=TEX
\section{EPILOG}
=SML
end (* of structure ZFunctions *);
open ZFunctions;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
