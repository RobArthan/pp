% imp085.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Functions}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP085}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Functions and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (22nd October 1992)]
First version, derived from 078 and 083.
\item [Issue 1.2, 12th November 1992] 
Changes as a consequence of changes in dependences.
\item[Issue 1.4 (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.5 (8th February 1993)]
Rearranging proof contexts.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library functions
given in \cite{DS/FMU/IED/DTD085}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD085}.
\subsection{Dependencies}
The mathematical toolkit for Z Library functions is introduced within the structure
$ZFunctions$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD085}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZFunctions$
(see\cite{DS/FMU/IED/DTD085}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZFunctions$}
\section{PREAMBLE}
Structure done in two parts.
=SML
structure ÛZFunctionsÝ : ZFunctions = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory Û"z_functions"Ý;
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples","'z__rel"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:

=SML
	val z_­_def = get_spec ñ(_ ­ _)®;
	val z_ß_def = get_spec ñ(_ ß _)®;
	val z_þ_def = get_spec ñ(_ þ _)®;
	val z_à_def = get_spec ñ(_ à _)®;
	val z_Ï_def = get_spec ñ(_ Ï _)®;
	val z_ï_def = get_spec ñ(_ ï _)®;
	val z__def = get_spec ñ(_  _)®;
=TEX
=SML
val ÛUaÝ = ñU®; (* type = 'a SET *)
val ÛUbÝ = inst [] [(”'b®,”'a®)] Ua;
=TEX
=SML
val dummy = push_merge_pcs ["z_sets_ext", "'z_tuples"];
local
	val spec = (rewrite_rule[] z_ß_def);
	val s1 = rewrite_conv [spec] ñf  (X ß Y)®;
in
val Ûz_ß_thmÝ = save_thm("z_ß_thm",
 	pure_rewrite_rule[z_í_thm]
	(all_z_µ_intro s1));
end;
val dummy = pop_pc();
=TEX
=SML
val Ûz_ß_thm1Ý = save_thm("z_ß_thm1",(
push_goal([],
	ñµ f : U; X : U; Y : U
          · f  (X ß Y)
            ¤ (f  (X ª Y)
              ± (µ x : U; y1, y2 : U |
		x  X ± y1  Y ± y2  Y
                · (x, y1)  f ± (x, y2)  f ´ y1 = y2))®);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z__rel"];
a(rewrite_tac[z_ß_thm]);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(asm_fc_tac[]);
(* *** Goal "5" *** *)
a(asm_fc_tac[]);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[]);
pop_pc();
pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]z_­_def);
	val s1 = rewrite_conv [spec] ñf  (X ­ Y)®;
	val s3 = (
push_goal([],ñf  (X ­ Y) ¤ f  (X ß Y) ± dom f = X®);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z__rel"];
a(rewrite_tac[z_ß_thm, s1, z_dom_thm, z_í_thm]);
a(REPEAT strip_tac THEN_TRY_T(SOLVED_T (all_asm_fc_tac[])));
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 ñx®);
a(z_spec_nth_asm_tac 1 ñy1®);
a(z_spec_nth_asm_tac 2 ñy2®);
a(all_var_elim_asm_tac THEN rewrite_tac[]);
(* *** Goal "2" *** *) 
a(z_spec_nth_asm_tac 2 ñx1®);
a(z_¶_tac ñy®);
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ñx®);
(* *** Goal "3.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(z_¶‰1_tac ñy®);
a(z_spec_nth_asm_tac 5 ñ(x1 ¦ x, x2 ¦ y)®);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 ñ(x ¦ x, y1 ¦ y', y2 ¦ y)®);
pop_pc();
pop_thm());
in
val Ûz_­_thmÝ = save_thm("z_­_thm", all_z_µ_intro s3);
end;
=TEX
=SML
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples"];
local
	val spec = (rewrite_rule[]z_þ_def);
	val s1 = rewrite_conv [spec] ñf  (X þ Y)®;
	val s3 = prove_rule[s1] ñµ f: U;
	X: U; Y: U·
	f  X þ Y
      ¤ f  X ß Y ± (µ x1, x2 : U | 
		x1  dom f ± x2  dom f · f x1 = f x2 ´ x1 = x2)®;
in
val Ûz_þ_thmÝ = save_thm("z_þ_thm", s3);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_à_def);
	val s1 = rewrite_conv [spec, z_¡_thm, z_þ_thm] ñf  (X à Y)®;
	val s2 = (
push_goal([], ñf  (X à Y) ¤ f  (X ­ Y) ±
	(µ x1, x2 :U | 
		x1  dom f ± x2  dom f · f x1 = f x2 ´ x1 = x2)®);
a(rewrite_tac[s1, z_­_thm]);
a(taut_tac);
pop_thm());
in
val Ûz_à_thmÝ = save_thm("z_à_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_Ï_def);
	val s1 = rewrite_conv [spec] ñf  (X Ï Y)®;
in
val Ûz_Ï_thmÝ = save_thm("z_Ï_thm", all_z_µ_intro s1);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_ï_def);
	val s1 = rewrite_conv [spec, z_¡_thm, z_Ï_thm] ñf  (X ï Y)®;
	val s2 = (
push_goal([],
	ñf  (X ï Y) ¤ f  (X ­ Y) ± ran f = Y®);
a(rewrite_tac[s1, z_­_thm]);
a(taut_tac);
pop_thm());
in
val Ûz_ï_thmÝ = save_thm("z_ï_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z__def);
	val s1 = rewrite_conv [spec, z_¡_thm, z_ï_thm, z_à_thm] ñf  (X  Y)®;
	val s2 = (prove_rule[s1]
	ñf  (X  Y) ¤ f  (X ­ Y) ± ran f = Y ± 
	   (µ x1, x2 : U | x1  dom f ± x2  dom f ·
	    f x1 = f x2 ´ x1 = x2)®);
in
val Ûz__thmÝ = save_thm("z__thm", all_z_µ_intro s2);
end;
val _ = pop_pc();
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun Ûmake__ruleÝ thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun Ûmake_pair_trio_ruleÝ thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_sel‰t_conv)
		(µ_elim ñ(p1,p2)® 
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_sel‰t_conv)
		(µ_elim ñ(p1 í p2)® (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val Û_operator_clauses2Ý = [
	z_Ï_thm, z_ï_thm, z__thm,
	z_þ_thm, z_à_thm, z_ß_thm1, z_­_thm];
=TEX
=SML
fun Ûthms_to_eqn_cxtÝ (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX
\subsection{Treatment of Membership of Functions}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z__fun" handle Fail _ => ();
val _ = new_pc "'z__fun";
val _ = set_rw_eqn_cxt []"'z__fun";
val _ = add_rw_thms 
	([]
	@ _operator_clauses2) "'z__fun";

val pos = (thms_to_eqn_cxt _operator_clauses2)
	@ [];
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z__fun";
val _ = set_sc_eqn_cxt (pos @ neg) "'z__fun";
val _ = set_rw_canons [] "'z__fun";
val _ = set_pr_tac z_basic_prove_tac "'z__fun";
val _ = set_pr_conv z_basic_prove_conv "'z__fun";
val _ = set_cs_¶_convs [] "'z__fun";
val _ = set_¶_vs_thms [] "'z__fun";
val _ = commit_pc "'z__fun";

=TEX
\section{ADDITIONAL WORK}
This material relies on the just created proof contexts.
=SML
val Ûz_ext_pcsÝ = ["z_sets_ext", "'z__rel", "'z__fun", "'z_tuples"];
val Ûz_­_app_thmÝ = ( 
push_merge_pcs z_ext_pcs;
set_goal([],ñµ X:U; Y:U; 
	f: U; x:U·
	f  X ­ Y ± x  X ´ f x  Y ± (x, f x)  f®);
a(z_strip_tac THEN z_strip_tac THEN z_strip_tac);
a(z_spec_nth_asm_tac 2 ñx®);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ñf x = y®);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 6  ñ(x1 ¦ x, x2 ¦ f_a)®);
a(z_spec_nth_asm_tac 7  ñ(x1 ¦ x, x2 ¦ y)®);
a(asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 6 ñ(x1 ¦ x, x2 ¦ y)®);
pop_pc();
save_thm ("z_­_app_thm",pop_thm()));
=TEX
=SML
val _ = set_merge_pcs ["z_sets_alg", "'z__rel", "'z__fun", "'z_tuples"];
=TEX
=SML
local
val s1 = conv_rule z_para_pred_conv z_first_def;
val s2 = ±_left_elim (list_µ_elim[Ua,Ub] s1);
val s3 = s2;
val s4 = z_µ_elim ñ(X ¦ ((U º ð a) ¸ (U º ð b)),
		Y ¦ (U º ð a), f ¦ first[(U º ð a),(U º ð b)],
		x ¦ (x º (a ¸ b)))® z_­_app_thm;
val s5 = pure_rewrite_rule [s3] s4;
val s6 = rewrite_rule[]  s5;
val s7 = all_µ_intro s6;
val s8 = z_µ_elim ñ(X ¦ ((U º ð a) ¸ (U º ð b)),
		Y ¦ (U º ð b), f ¦ second[(U º ð a),(U º ð b)],
		x ¦ (x º (a ¸ b)))® z_­_app_thm;
val s9 = pure_rewrite_rule [s3] s8;
val s10 = rewrite_rule[]  s9;
val s11 = all_µ_intro s10;
in
val Ûz__first_thmÝ = (
set_goal([],ñµ x : U · x  first ¤ x.1.1 = x.2®);
push_merge_pcs z_ext_pcs;
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_left_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_sel‰t_intro_conv)));
a(strip_asm_tac(µ_elim ñx.1® s7));
a(z_spec_nth_asm_tac 4  ñ(x ¦ x.1, y1 ¦ x.1.1, y2 ¦ x.2)®);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_sel‰t_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s7]);
save_thm("z__first_thm",pop_thm()));

val Ûz__second_thmÝ = (
set_goal([],ñµ x : U · x  second ¤ x.1.2 = x.2®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_right_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_sel‰t_intro_conv)));
a(strip_asm_tac(µ_elim ñx.1® s11));
a(z_spec_nth_asm_tac 4  ñ(x ¦ x.1, y1 ¦ x.1.2, y2 ¦ x.2)®);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_sel‰t_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s11]);
pop_pc();
save_thm("z__second_thm",pop_thm()));
end;
=TEX
=SML
val  Ûz_­_app__rel_thmÝ = save_thm("z_­_app__rel_thm", (
push_goal([], ñµX: U; Y : U·µf : X ­ Y; x : X·(x, f x)  f®);
a(REPEAT strip_tac);
a(all_fc_tac[z_­_app_thm]);
pop_thm()
));
=TEX
=SML
val  Ûz_­_app_eq_¤__rel_thmÝ = save_thm("z_­_app_eq_¤__rel_thm", (
push_goal([], ñµX: U; Y : U·µf : X ­ Y; x : X·f x = z ¤ (x, z)  f®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(all_fc_tac[z_­_app__rel_thm]);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN MERGE_PCS_T1 z_ext_pcs REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(MERGE_PCS_T1 z_ext_pcs all_asm_fc_tac[] THEN all_asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val  Ûz_­__rel_¤_app_eq_thmÝ = save_thm("z_­__rel_¤_app_eq_thm", (
push_goal([], ñµX: U; Y : U·µf : X ­ Y; x : X·(x, z)  f ¤ f x = z®);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN accept_tac z_­_app_eq_¤__rel_thm);
pop_thm()
));
=TEX
\subsection{Simplification}
=SML
val _ = push_merge_pcs ["z_sets_ext", "'z__rel", "'z__fun", "'z_tuples"];

val Ûz_ß_clausesÝ = save_thm("z_ß_clauses", (
	prove_rule [] ñµ Y:U ·
	{} ß Y = {{}} ±
	Y ß {} = {{}}®));
=TEX
=SML
val Ûz_­_clausesÝ = save_thm("z_­_clauses", (
set_goal( [], ñµ Y:U ·
	{} ­ Y = {{}} ±
	Y ­ {} = {x:U| x = {} ± Y = {}}®);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(´_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val Ûz_þ_clausesÝ = save_thm("z_þ_clauses", 
	prove_rule [] ñµ Y:U ·
	{} þ Y = {{}} ±
	Y þ {} = {{}}®);
=TEX
=SML
val Ûz_à_clausesÝ = save_thm("z_à_clauses", (
set_goal( [], ñµ Y:U ·
	{} à Y = {{}} ±
	Y à {} = {x:U| x = {} ± Y = {}}®);
a(prove_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(´_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val Ûz_Ï_clausesÝ = save_thm("z_Ï_clauses", (
set_goal( [], ñµ Y:U ·
	{} Ï Y = {x:U| x = {} ± Y = {}} ±
	Y Ï {} = {{}}®);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(´_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val Ûz_ï_clausesÝ = save_thm("z_ï_clauses", (
set_goal( [], ñµ Y:U ·
	{} ï Y = {x:U| x = {} ± Y = {}} ±
	Y ï {} = {x:U| x = {} ± Y = {}}®);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(´_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(´_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val Ûz__clausesÝ = save_thm("z__clauses", (
set_goal( [], ñµ Y:U ·
	{}  Y = {x:U| x = {} ± Y = {}} ±
	Y  {} = {x:U| x = {} ± Y = {}}®);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(´_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(´_T rewrite_thm_tac);
pop_thm()
));

val _ = pop_pc();
=TEX
=SML
local
	val setty = type_of ñ{}®;
in
fun Ûmaybe_Ý (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else (let val tyms = type_match (type_of index) setty @ [(”'a®,”'a®)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		(mk_z_(x,index), _C cnv)
	end)
);
end;

val z_fun_alg_eqn_cxt = thms_to_eqn_cxt [z_ß_clauses, z_­_clauses, z_þ_clauses,
	z_à_clauses, z_ï_clauses, z_Ï_clauses, z__clauses];

val z_fun_alg_eqn_cxt_for_strip = mapfilter maybe_ z_fun_alg_eqn_cxt;


val _ = delete_pc "'z_fun_alg" handle Fail _ => ();
val _ = new_pc "'z_fun_alg";
val _ = set_rw_eqn_cxt z_fun_alg_eqn_cxt"'z_fun_alg";
val _ = add_rw_thms ([]) "'z_fun_alg";

val pos = z_fun_alg_eqn_cxt_for_strip;
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_rw_canons [] "'z_fun_alg";
val _ = set_pr_tac z_basic_prove_tac "'z_fun_alg";
val _ = set_pr_conv z_basic_prove_conv "'z_fun_alg";
val _ = set_cs_¶_convs [] "'z_fun_alg";
val _ = set_¶_vs_thms [] "'z_fun_alg";
val _ = commit_pc "'z_fun_alg";

=TEX

\section{EPILOG}
=SML
end (* of structure ZFunctions *);
open ZFunctions;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
