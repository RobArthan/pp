=IGN
********************************************************************************
imp085.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp085.doc   %Z% $Date: 2003/07/16 15:20:12 $ $Revision: 1.10 $ $RCSfile: imp085.doc,v $
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Implementation of the Z Library Functions}

\def\AbstractText{This document contains the implementation of the Z Library Functions and their proof support.}

\def\Reference{DS/FMU/IED/IMP085}

\def\Author{D.J. King}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: % TQtemplate.tex
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
\def\Hide#1{}
%% LaTeX2e port: \def\Bool{``$\it{:}bool\,$''}
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{FST PROJECT}  %% Mandatory field
%% LaTeX2e port: %\TPPvolume{}
%% LaTeX2e port: %\TPPpart{}
%% LaTeX2e port: \TPPtitle{Implementation of the Z Library Functions}  %% Mandatory field
%% LaTeX2e port: \TPPref{DS/FMU/IED/IMP085}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{$Revision: 1.10 $%
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{\FormatDate{$Date: 2003/07/16 15:20:12 $%
%% LaTeX2e port: }}
%% LaTeX2e port: \TPPstatus{Draft}			%% Mandatory field
%% LaTeX2e port: \TPPtype{Specification}
%% LaTeX2e port: \TPPkeywords{HOL}
%% LaTeX2e port: \TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%% LaTeX2e port: %\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%% LaTeX2e port: \TPPauthorisation{R.D.~Arthan & FST Team Leader}
%% LaTeX2e port: \TPPabstract{This document contains the implementation of
%% LaTeX2e port: the Z Library Functions and their proof support.}
%% LaTeX2e port: %\TPPabstractB{}
%% LaTeX2e port: %\TPPabstractC{}
%% LaTeX2e port: %\TPPabstractD{}
%% LaTeX2e port: %\TPPabstractE{}
%% LaTeX2e port: %\TPPabstractF{}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port:       Library}}
%% LaTeX2e port: 
%% LaTeX2e port: %\TPPclass{CLASSIFICATION}
%% LaTeX2e port: %\def\TPPheadlhs{}
%% LaTeX2e port: %\def\TPPheadcentre{}
%% LaTeX2e port: %def\TPPheadrhs{}
%% LaTeX2e port: %\def\TPPfootlhs{}
%% LaTeX2e port: %\def\TPPfootcentre{}
%% LaTeX2e port: %\def\TPPfootrhs{}
%% LaTeX2e port: 
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \TPPsetsizes
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: 
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: 
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: 
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (1992/10/28) (22nd October 1992)]
First version, derived from 078 and 083.
\item [Issue 1.2 (1992/11/12), 12th November 1992]
Changes as a consequence of changes in dependences.
\item[Issue 1.4 (1992/12/11) (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.5 (1993/02/10)-1.6 (1993/02/12) (8th-12th February 1993)]
Rearranging proof contexts.
\item[Issue 1.8 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.9 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.10 (2003/07/16)] Cured theorems that used to have free variables.
\item[Issue 1.11 (2004/01/19)] The Z universal set is now called É.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

\item[2015/04/17]
Ported PPZed to Lemma 1 document template.

\item[2025/03/05]
Added theorem for pushing function application through a conditional.
%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library functions
given in \cite{DS/FMU/IED/DTD085}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD085}.
\subsection{Dependencies}
The mathematical toolkit for Z Library functions is introduced within the structure
$ZFunctions$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD085}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZFunctions$
(see\cite{DS/FMU/IED/DTD085}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZFunctions$}
\section{PREAMBLE}
Structure done in two parts.
=SML
structure €ZFunctions› : ZFunctions = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_functions"›;
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples","'z_ç_rel"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:

=SML
	val z_≠_def = get_spec Ò(_ ≠ _)Æ;
	val z_ﬂ_def = get_spec Ò(_ ﬂ _)Æ;
	val z_˛_def = get_spec Ò(_ ˛ _)Æ;
	val z_‡_def = get_spec Ò(_ ‡ _)Æ;
	val z_œ_def = get_spec Ò(_ œ _)Æ;
	val z_Ô_def = get_spec Ò(_ Ô _)Æ;
	val z_è_def = get_spec Ò(_ è _)Æ;
=TEX
=SML
val €Ua› = ÒÉÆ; (* type = 'a SET *)
val €Ub› = inst [] [(î'bÆ,î'aÆ)] Ua;
=TEX
=SML
val dummy = push_merge_pcs ["z_sets_ext", "'z_tuples"];
local
	val spec = (rewrite_rule[] z_ﬂ_def);
	val s1 = rewrite_conv [spec] Òf ç (X ﬂ Y)Æ;
in
val €z_ﬂ_thm› = save_thm("z_ﬂ_thm",
 	pure_rewrite_rule[z_Ì_thm]
	(all_z_µ_intro s1));
end;
val dummy = pop_pc();
=TEX
=SML
val €z_ﬂ_thm1› = save_thm("z_ﬂ_thm1",(
push_goal([],
	Òµ f : É; X : É; Y : É
          ∑ f ç (X ﬂ Y)
            § (f ç (X ™ Y)
              ± (µ x : É; y1, y2 : É |
		x ç X ± y1 ç Y ± y2 ç Y
                ∑ (x, y1) ç f ± (x, y2) ç f ¥ y1 = y2))Æ);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z_ç_rel"];
a(rewrite_tac[z_ﬂ_thm]);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(asm_fc_tac[]);
(* *** Goal "5" *** *)
a(asm_fc_tac[]);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[]);
pop_pc();
pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]z_≠_def);
	val s1 = rewrite_conv [spec] Òf ç (X ≠ Y)Æ;
	val s3 = (
push_goal([],Òf ç (X ≠ Y) § f ç (X ﬂ Y) ± dom f = XÆ);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z_ç_rel"];
a(rewrite_tac[z_ﬂ_thm, s1, z_dom_thm, z_Ì_thm]);
a(REPEAT strip_tac THEN_TRY_T(SOLVED_T (all_asm_fc_tac[])));
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 ÒxÆ);
a(z_spec_nth_asm_tac 1 Òy1Æ);
a(z_spec_nth_asm_tac 2 Òy2Æ);
a(all_var_elim_asm_tac THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
a(z_∂_tac ÒyÆ);
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "3.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(z_∂â1_tac ÒyÆ);
a(z_spec_nth_asm_tac 5 Ò(x1 ¶ x, x2 ¶ y)Æ);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ y', y2 ¶ y)Æ);
pop_pc();
pop_thm());
in
val €z_≠_thm› = save_thm("z_≠_thm", all_z_µ_intro s3);
end;
=TEX
=SML
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples"];
local
	val spec = (rewrite_rule[]z_˛_def);
	val s1 = rewrite_conv [spec] Òf ç (X ˛ Y)Æ;
	val s3 = prove_rule[s1] Òµ f: É;
	X: É; Y: É∑
	f ç X ˛ Y
      § f ç X ﬂ Y ± (µ x1, x2 : É |
		x1 ç dom f ± x2 ç dom f ∑ f x1 = f x2 ¥ x1 = x2)Æ;
in
val €z_˛_thm› = save_thm("z_˛_thm", s3);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_‡_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_˛_thm] Òf ç (X ‡ Y)Æ;
	val s2 = (
push_goal([], Òf ç (X ‡ Y) § f ç (X ≠ Y) ±
	(µ x1, x2 :É |
		x1 ç dom f ± x2 ç dom f ∑ f x1 = f x2 ¥ x1 = x2)Æ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_‡_thm› = save_thm("z_‡_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_œ_def);
	val s1 = rewrite_conv [spec] Òf ç (X œ Y)Æ;
in
val €z_œ_thm› = save_thm("z_œ_thm", all_z_µ_intro s1);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_Ô_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_œ_thm] Òf ç (X Ô Y)Æ;
	val s2 = (
push_goal([],
	Òf ç (X Ô Y) § f ç (X ≠ Y) ± ran f = YÆ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_Ô_thm› = save_thm("z_Ô_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_è_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_Ô_thm, z_‡_thm] Òf ç (X è Y)Æ;
	val s2 = (prove_rule[s1]
	Òf ç (X è Y) § f ç (X ≠ Y) ± ran f = Y ±
	   (µ x1, x2 : É | x1 ç dom f ± x2 ç dom f ∑
	    f x1 = f x2 ¥ x1 = x2)Æ);
in
val €z_è_thm› = save_thm("z_è_thm", all_z_µ_intro s2);
end;
val _ = pop_pc();
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun €make_ç_rule› thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun €make_pair_trio_rule› thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_selât_conv)
		(µ_elim Ò(p1,p2)Æ
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_selât_conv)
		(µ_elim Ò(p1 Ì p2)Æ (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val €ç_operator_clauses2› = [
	z_œ_thm, z_Ô_thm, z_è_thm,
	z_˛_thm, z_‡_thm, z_ﬂ_thm1, z_≠_thm];
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX
\subsection{Treatment of Membership of Functions}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_fun" handle Fail _ => ();
val _ = new_pc "'z_ç_fun";
val _ = set_rw_eqn_cxt []"'z_ç_fun";
val _ = add_rw_thms
	([]
	@ ç_operator_clauses2) "'z_ç_fun";

val pos = (thms_to_eqn_cxt ç_operator_clauses2)
	@ [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_ç_fun";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_ç_fun";
val _ = set_rw_canons [] "'z_ç_fun";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_fun";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_fun";
val _ = set_cs_∂_convs [] "'z_ç_fun";
val _ = set_∂_vs_thms [] "'z_ç_fun";
val _ = commit_pc "'z_ç_fun";

=TEX
\section{ADDITIONAL WORK}
This material relies on the just created proof contexts.
=SML
val €z_ext_pcs› = ["z_sets_ext", "'z_ç_rel", "'z_ç_fun", "'z_tuples"];
val €z_≠_app_thm› = (
push_merge_pcs z_ext_pcs;
set_goal([],Òµ X:É; Y:É;
	f: É; x:É∑
	f ç X ≠ Y ± x ç X ¥ f x ç Y ± (x, f x) ç fÆ);
a(z_strip_tac THEN z_strip_tac THEN z_strip_tac);
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òf x = yÆ);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 6  Ò(x1 ¶ x, x2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 7  Ò(x1 ¶ x, x2 ¶ y)Æ);
a(asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 6 Ò(x1 ¶ x, x2 ¶ y)Æ);
pop_pc();
save_thm ("z_≠_app_thm",pop_thm()));
=TEX
=SML
val _ = set_merge_pcs ["z_sets_alg", "'z_ç_rel", "'z_ç_fun", "'z_tuples"];
=TEX
=SML
local
val s1 = conv_rule z_para_pred_conv z_first_def;
val s2 = ±_left_elim (list_µ_elim[Ua,Ub] s1);
val s3 = s2;
val s4 = z_µ_elim Ò(X ¶ ((É ∫  a) ∏ (É ∫  b)),
		Y ¶ (É ∫  a), f ¶ first[(É ∫  a),(É ∫  b)],
		x ¶ (x ∫ (a ∏ b)))Æ z_≠_app_thm;
val s5 = pure_rewrite_rule [s3] s4;
val s6 = rewrite_rule[]  s5;
val s7 = all_µ_intro s6;
val s8 = z_µ_elim Ò(X ¶ ((É ∫  a) ∏ (É ∫  b)),
		Y ¶ (É ∫  b), f ¶ second[(É ∫  a),(É ∫  b)],
		x ¶ (x ∫ (a ∏ b)))Æ z_≠_app_thm;
val s9 = pure_rewrite_rule [s3] s8;
val s10 = rewrite_rule[]  s9;
val s11 = all_µ_intro s10;
in
val €z_ç_first_thm› = (
set_goal([],Òµ x : É ∑ x ç first § x.1.1 = x.2Æ);
push_merge_pcs z_ext_pcs;
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_left_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_selât_intro_conv)));
a(strip_asm_tac(µ_elim Òx.1Æ s7));
a(z_spec_nth_asm_tac 4  Ò(x ¶ x.1, y1 ¶ x.1.1, y2 ¶ x.2)Æ);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_selât_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s7]);
save_thm("z_ç_first_thm",pop_thm()));

val €z_ç_second_thm› = (
set_goal([],Òµ x : É ∑ x ç second § x.1.2 = x.2Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_right_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_selât_intro_conv)));
a(strip_asm_tac(µ_elim Òx.1Æ s11));
a(z_spec_nth_asm_tac 4  Ò(x ¶ x.1, y1 ¶ x.1.2, y2 ¶ x.2)Æ);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_selât_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s11]);
pop_pc();
save_thm("z_ç_second_thm",pop_thm()));
end;
=TEX
=SML
val  €z_≠_app_ç_rel_thm› = save_thm("z_≠_app_ç_rel_thm", (
push_goal([], ÒµX: É; Y : É∑µf : X ≠ Y; x : X∑(x, f x) ç fÆ);
a(REPEAT strip_tac);
a(all_fc_tac[z_≠_app_thm]);
pop_thm()
));
=TEX
=SML
val  €z_≠_app_eq_§_ç_rel_thm› = save_thm("z_≠_app_eq_§_ç_rel_thm", (
push_goal([], ÒµX: É; Y : É∑µf : X ≠ Y; x : X; z : É∑f x = z § (x, z) ç fÆ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(all_fc_tac[z_≠_app_ç_rel_thm]);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN MERGE_PCS_T1 z_ext_pcs REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(MERGE_PCS_T1 z_ext_pcs all_asm_fc_tac[] THEN all_asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val  €z_≠_ç_rel_§_app_eq_thm› = save_thm("z_≠_ç_rel_§_app_eq_thm", (
push_goal([], ÒµX: É; Y : É∑µf : X ≠ Y; x : X; z : É∑(x, z) ç f § f x = zÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN accept_tac z_≠_app_eq_§_ç_rel_thm);
pop_thm()
));
=TEX
\subsection{Simplification}
=SML
val _ = push_merge_pcs ["z_sets_ext", "'z_ç_rel", "'z_ç_fun", "'z_tuples"];

val €z_ﬂ_clauses› = save_thm("z_ﬂ_clauses", (
	prove_rule [] Òµ Y:É ∑
	{} ﬂ Y = {{}} ±
	Y ﬂ {} = {{}}Æ));
=TEX
=SML
val €z_≠_clauses› = save_thm("z_≠_clauses", (
set_goal( [], Òµ Y:É ∑
	{} ≠ Y = {{}} ±
	Y ≠ {} = {x: É | x = {} ± Y = {}}Æ);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val €z_˛_clauses› = save_thm("z_˛_clauses",
	prove_rule [] Òµ Y:É ∑
	{} ˛ Y = {{}} ±
	Y ˛ {} = {{}}Æ);
=TEX
=SML
val €z_‡_clauses› = save_thm("z_‡_clauses", (
set_goal( [], Òµ Y:É ∑
	{} ‡ Y = {{}} ±
	Y ‡ {} = {x:É| x = {} ± Y = {}}Æ);
a(prove_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val €z_œ_clauses› = save_thm("z_œ_clauses", (
set_goal( [], Òµ Y:É ∑
	{} œ Y = {x:É| x = {} ± Y = {}} ±
	Y œ {} = {{}}Æ);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val €z_Ô_clauses› = save_thm("z_Ô_clauses", (
set_goal( [], Òµ Y:É ∑
	{} Ô Y = {x:É| x = {} ± Y = {}} ±
	Y Ô {} = {x:É| x = {} ± Y = {}}Æ);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val €z_è_clauses› = save_thm("z_è_clauses", (
set_goal( [], Òµ Y:É ∑
	{} è Y = {x:É| x = {} ± Y = {}} ±
	Y è {} = {x:É| x = {} ± Y = {}}Æ);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
pop_thm()
));

val _ = pop_pc();
=TEX
=SML
fun €maybe_strip› (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else fail "" 0 []
);
local
	val setty = type_of Ò{}Æ;
in
fun €add_ç› ((index,cnv)::rest) = (
	(let val tyms = type_match (type_of index) setty @ [(î'aÆ,î'aÆ)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		((mk_z_ç(x,index), ç_C cnv) :: (index,cnv) :: add_ç rest)
	end)
	handle (Fail _) =>
	((index,cnv) :: add_ç rest)
) | add_ç [] = [];
end;

val z_fun_alg_eqn_cxt = add_ç(thms_to_eqn_cxt [z_ﬂ_clauses, z_≠_clauses, z_˛_clauses,
	z_‡_clauses, z_Ô_clauses, z_œ_clauses, z_è_clauses]);

val z_fun_alg_eqn_cxt_for_strip = mapfilter maybe_strip z_fun_alg_eqn_cxt;


val _ = delete_pc "'z_fun_alg" handle Fail _ => ();
val _ = new_pc "'z_fun_alg";
val _ = set_rw_eqn_cxt z_fun_alg_eqn_cxt"'z_fun_alg";
val _ = add_rw_thms ([]) "'z_fun_alg";

val pos = z_fun_alg_eqn_cxt_for_strip;
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_rw_canons [] "'z_fun_alg";
val _ = set_pr_tac z_basic_prove_tac "'z_fun_alg";
val _ = set_pr_conv z_basic_prove_conv "'z_fun_alg";
val _ = set_cs_∂_convs [] "'z_fun_alg";
val _ = set_∂_vs_thms [] "'z_fun_alg";
val _ = commit_pc "'z_fun_alg";

=TEX
=SML
val _ = delete_pc "z_fun_ext" handle Fail _ => ();
val _ = new_pc "z_fun_ext";
val _ = merge_pcs ["z_rel_ext","'z_fun_alg",
	"'z_ç_fun"] "z_fun_ext";
val _ = commit_pc "z_fun_ext";
=TEX
\subsection{Type Inference By Theorems}
=SML
val _ = push_pc "z_fun_ext";
=TEX
We use $z_spec_nth_asm_tac$ for speed, $all\_asm\_fc\_tac$
still works (?).
=SML
val €z_fun_app_clauses› = save_thm("z_fun_app_clauses", (
set_goal([],Òµ f:É; x:É;y:É; X:É;Y:É ∑
	(f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y ≤
	 f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	± (x,y) ç f
	¥ f x = yÆ);
a(REPEAT strip_tac THEN all_asm_fc_tac[] THEN z_app_eq_tac
	THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "5" *** *)
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);
(* *** Goal "7" *** *)
a(z_spec_nth_asm_tac 9 Ò(x ¶ x, y1 ¶ f_a, y2 ¶ y)Æ);

pop_thm()));
=TEX
=SML
val €z_fun_ç_clauses› = save_thm("z_fun_ç_clauses", (
set_goal([],Òµ f:É; x:É; X:É;Y:É ∑
	((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	± x ç X
	¥ f x ç Y)
	±
	((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
	± x ç dom f
	¥ f x ç Y)Æ);
a(PC_T1 "z_sets_alg" rewrite_tac[z_dom_thm] THEN
	REPEAT (PC_T "z_sets_alg" strip_tac) THEN
	GET_NTH_ASM_T 2 strip_asm_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 ÒxÆ);
(* *** Goal "1.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "3.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 3 ÒxÆ);
(* *** Goal "4.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "7" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
pop_thm()));
=TEX
=SML
val €z_fun_dom_clauses› = save_thm("z_fun_dom_clauses", (
set_goal([],Òµ f:É; X:É;Y:É ∑
	((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
	¥ dom f Ä X)
 	±
	((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	¥ dom f = X)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
(* *** Goal "5.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ THEN all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ);
(* *** Goal "7.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "7.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "8" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "9" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ);
(* *** Goal "9.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "9.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "10" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "11" *** *)
a(z_spec_nth_asm_tac 4 Òx1Æ);
(* *** Goal "11.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "11.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);

pop_thm()));
=TEX
=SML
val €z_fun_ran_clauses› = save_thm("z_fun_ran_clauses", (
set_goal([],Òµ f:É; X:É;Y:É ∑
	((f ç X ≠ Y ≤ f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X ‡ Y)
	¥ ran f Ä Y)
	±
	((f ç X œ Y ≤ f ç X Ô Y ≤ f ç X è Y)
	¥ ran f = Y)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
(* *** Goal "6.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "8" *** *)
a(z_spec_nth_asm_tac 2 Òx1Æ);
(* *** Goal "8.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "8.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "9" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "10" *** *)
a(z_spec_nth_asm_tac 3 Òx1Æ);
(* *** Goal "10.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "10.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
pop_thm()));
=TEX
=SML
val €z_fun_app_if_thm› : THM = (
set_goal([], Òµf : É; c : É; x, y : É∑
	f(if c then x else y) = if c then f x else f yÆ);
a(REPEAT strip_tac);
a(cases_tac ÒcÆ THEN asm_rewrite_tac[]);
save_pop_thm "z_fun_app_if_thm"
);
=TEX
=SML
val _ = pop_pc();
=TEX
\section{EPILOG}
=SML
end (* of structure ZFunctions *);
open ZFunctions;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
