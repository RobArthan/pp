% imp085.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Library Functions}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP085}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Functions and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (22nd October 1992)]
First version, derived from 078 and 083.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library functions
given in \cite{DS/FMU/IED/DTD085}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD085}.
\subsection{Dependencies}
The mathematical toolkit for Z Library functions is introduced within the structure
$ZFunctions$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD085}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZFunctions$
(see\cite{DS/FMU/IED/DTD085}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZFunctions$}
\section{PREAMBLE}
Structure done in two parts.
=SML
structure €ZFunctions› : ZFunctions = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_functions"›;
val _ = push_merge_pcs ["z_predicates","'z_ç_set_lang","'z_decl", "'propositions", "'z_tuples_lang"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:

=SML
	val z'≠_def = get_spec Ò(_ ≠ _)Æ;
	val z'ﬂ_def = get_spec Ò(_ ﬂ _)Æ;
	val z'˛_def = get_spec Ò(_ ˛ _)Æ;
	val z'‡_def = get_spec Ò(_ ‡ _)Æ;
	val z'œ_def = get_spec Ò(_ œ _)Æ;
	val z'Ô_def = get_spec Ò(_ Ô _)Æ;
	val z'è_def = get_spec Ò(_ è _)Æ;
=TEX
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
val €Ub› = inst [] [(î'bÆ,î'aÆ)] Ua;
=TEX
=SML
local
	val spec = (rewrite_rule[] z'ﬂ_def);
	val s1 = rewrite_conv [spec] Òf ç (X ﬂ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
in
val €z_ﬂ_thm› = save_thm("z_ﬂ_thm",
 	pure_rewrite_rule[z_Ì_thm]
	(all_z_µ_intro s2));
end;
=TEX
=SML
val €z_ﬂ_thm1› = save_thm("z_ﬂ_thm1",
	prove_rule[z_ﬂ_thm]
	Òµ f : U; X : U; Y : U
          ∑ f ç (X ﬂ Y)
            § (f ç (X ™ Y)
              ± (µ x : U; yâ1, yâ2 : U |
		x ç X ± yâ1 ç Y ± yâ2 ç Y
                ∑ (x, yâ1) ç f ± (x, yâ2) ç f ¥ yâ1 = yâ2))Æ);
=TEX
=SML
local
	val spec = (rewrite_rule[]z'≠_def);
	val s1 = rewrite_conv [spec] Òf ç (X ≠ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
	val s3 = (
push_goal([],Òf ç (X ≠ Y) § f ç (X ﬂ Y) ± dom f = XÆ);
a(rewrite_tac[z_ﬂ_thm, s2, z_dom_thm, z_sets_ext_thm, z_Ì_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 ÒxÆ);
a(z_spec_nth_asm_tac 1 Òyâ1Æ);
a(z_spec_nth_asm_tac 2 Òyâ2Æ);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *) 
a(DROP_NTH_ASM_T 3 (strip_asm_tac o conv_rule(MAP_C  z_ç__conv) o
	rewrite_rule[z_™_thm]));
a(z_spec_nth_asm_tac 1 Ò(xâ1 ¶ z,xâ2 ¶ y)Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ÒzÆ);
a(z_∂_tac ÒyÆ);
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "4.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(z_∂_tac ÒyÆ);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o conv_rule(MAP_C  z_ç__conv) o
	rewrite_rule [z_™_thm]));
a(z_spec_nth_asm_tac 1 Ò(xâ1 ¶ x, xâ2 ¶ y)Æ);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 8 Ò(x ¶ x, yâ1 ¶ Òy'Æ, yâ2 ¶ y)Æ);
pop_thm());
in
val €z_≠_thm› = save_thm("z_≠_thm", all_z_µ_intro s3);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z'˛_def);
	val s1 = rewrite_conv [spec] Òf ç (X ˛ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
	val s3 = prove_rule[s2] Òµ f: U;
	X: U; Y: U∑
	f ç X ˛ Y
      § f ç X ﬂ Y ± (µ xâ1, xâ2 : U | 
		xâ1 ç dom f ± xâ2 ç dom f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ;
in
val €z_˛_thm› = save_thm("z_˛_thm", s3);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z'‡_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_˛_thm] Òf ç (X ‡ Y)Æ;
	val s2 = (
push_goal([], Òf ç (X ‡ Y) § f ç (X ≠ Y) ±
	(µ xâ1, xâ2 :U | 
		xâ1 ç dom f ± xâ2 ç dom f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_‡_thm› = save_thm("z_‡_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z'œ_def);
	val s1 = rewrite_conv [spec] Òf ç (X œ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
in
val €z_œ_thm› = save_thm("z_œ_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z'Ô_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_œ_thm] Òf ç (X Ô Y)Æ;
	val s2 = (
push_goal([],
	Òf ç (X Ô Y) § f ç (X ≠ Y) ± ran f = YÆ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_Ô_thm› = save_thm("z_Ô_thm", all_z_µ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z'è_def);
	val s1 = rewrite_conv [spec, z_°_thm, z_Ô_thm, z_‡_thm] Òf ç (X è Y)Æ;
	val s2 = (prove_rule[s1]
	Òf ç (X è Y) § f ç (X ≠ Y) ± ran f = Y ± 
	   (µ xâ1, xâ2 : U | xâ1 ç dom f ± xâ2 ç dom f ∑
	    f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ);
in
val €z_è_thm› = save_thm("z_è_thm", all_z_µ_intro s2);
end;
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_µ_elim_conv1 z_sets_ext_thm);
in
fun €make_ç_rule› thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule cnv1
	(all_µ_elim
	(conv_rule(TRY_C z_µ_elim_conv1) thm))));
end;
=TEX
=SML
fun €make_pair_trio_rule› thm = (
let	val s1 = all_µ_intro
		(conv_rule (MAP_C z_tuple_selection_conv)
		(µ_elim Ò(p1,p2)Æ 
		(all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
	val s2 = all_µ_intro
		(conv_rule (MAP_C z_tuple_selection_conv)
		(µ_elim Ò(p1 Ì p2)Æ (all_µ_intro
		(all_µ_elim
		(conv_rule z_µ_elim_conv1 thm)))));
in
	list_±_intro [thm, s1, s2]
end);
=TEX
=SML
val €ç_operator_clauses2› = [
	z_œ_thm, z_Ô_thm, z_è_thm,
	z_˛_thm, z_‡_thm, z_ﬂ_thm1, z_≠_thm];
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	\subsection{Treatment of Membership of Functions}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_fun" handle Fail _ => ();
val _ = new_pc "'z_ç_fun";
val _ = set_rw_eqn_cxt []"'z_ç_fun";
val _ = add_rw_thms 
	([]
	@ ç_operator_clauses2) "'z_ç_fun";

val pos = (thms_to_eqn_cxt ç_operator_clauses2)
	@ [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_ç_fun";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_ç_fun";
val _ = set_rw_canons [] "'z_ç_fun";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_fun";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_fun";
val _ = set_cs_∂_convs [] "'z_ç_fun";
val _ = set_∂_vs_thms [] "'z_ç_fun";
=TEX
\section{ADDITIONAL WORK}
This material relies on the just created proof contexts.
=SML
val _ = set_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_ç_set_lib", "'z_ç_rel", "'z_ç_fun", "'z_tuples", "'z_decl"];
=TEX
=SML
val €z_≠_app_thm› = ( 
push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_ç_set_lib", "'z_ç_rel", "'z_ç_fun", "'z_tuples", "'z_decl","'z_sets_ext_lang","'z_sets_ext_lib"];
set_goal([],Òµ X:U; Y:U; 
	f: U; x:U∑
	f ç X ≠ Y ± x ç X ¥ f x ç Y ± (x, f x) ç fÆ);
a(strip_tac THEN REPEAT µ_tac THEN strip_tac THEN strip_tac);
a(z_spec_nth_asm_tac 2 ÒxÆ);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac Òf x = yÆ);
(* *** Goal "2.1" *** *)
a(z_app_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 6  Ò(xâ1 ¶ x, xâ2 ¶ f_a)Æ);
a(z_spec_nth_asm_tac 7  Ò(xâ1 ¶ x, xâ2 ¶ y)Æ);
a(asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 6 Ò(xâ1 ¶ x, xâ2 ¶ y)Æ);
pop_pc();
save_thm ("z_≠_app_thm",pop_thm()));
=TEX
=SML
local
val s1 = conv_rule z_defn_conv z'first_def;
val s2 = ±_left_elim (list_µ_elim[Ua,Ub] s1);
val s3 = conv_rule(DECL_C dec_pred_conv) s2;
val s4 = z_µ_elim Ò(X ¶ ((U ∫  a) ∏ (U ∫  b)),
		Y ¶ (U ∫  a), f ¶ first[(U ∫  a),(U ∫  b)],
		x ¶ (x ∫ (a ∏ b)))Æ z_≠_app_thm;
val s5 = pure_rewrite_rule [s3] s4;
val s6 = rewrite_rule[]  s5;
val s7 = all_µ_intro s6;
val s8 = z_µ_elim Ò(X ¶ ((U ∫  a) ∏ (U ∫  b)),
		Y ¶ (U ∫  b), f ¶ second[(U ∫  a),(U ∫  b)],
		x ¶ (x ∫ (a ∏ b)))Æ z_≠_app_thm;
val s9 = pure_rewrite_rule [s3] s8;
val s10 = rewrite_rule[]  s9;
val s11 = all_µ_intro s10;
in
val €z_ç_first_thm› = (
set_goal([],Òµ x : U ∑ x ç first § x.1.1 = x.2Æ);
push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_ç_set_lib", "'z_ç_rel", "'z_ç_fun", "'z_tuples", "'z_decl","'z_sets_ext_lang","'z_sets_ext_lib"];
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_left_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_tuple_selection_intro_conv)));
a(strip_asm_tac(µ_elim Òx.1Æ s7));
a(z_spec_nth_asm_tac 4  Ò(x ¶ x.1, yâ1 ¶ x.1.1, yâ2 ¶ x.2)Æ);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_tuple_selection_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s7]);
save_thm("z_ç_first_thm",pop_thm()));

val €z_ç_second_thm› = (
set_goal([],Òµ x : U ∑ x ç second § x.1.2 = x.2Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(±_right_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_tuple_selection_intro_conv)));
a(strip_asm_tac(µ_elim Òx.1Æ s11));
a(z_spec_nth_asm_tac 4  Ò(x ¶ x.1, yâ1 ¶ x.1.2, yâ2 ¶ x.2)Æ);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_tuple_selection_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s11]);
pop_pc();
save_thm("z_ç_second_thm",pop_thm()));
end;
=TEX
\section{EPILOG}
=SML
end (* of structure ZFunctions *);
open ZFunctions;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
