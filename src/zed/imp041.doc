=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Predicate Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP041}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.4] 
First versions.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) predicate calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD041}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the predicate calculus of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD041}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure €ZPredicateCalculus› : ZPredicateCalculus = struct
local
open ZTypesAndTermsSupport;
open ZGeneratedConstants;
open Resolution;
in
=TEX
=IGN
delete_pc "'z_predicate_calculus_build" handle _ => ();
open Resolution;
open ZTypesAndTermsSupport;
open ZGeneratedConstants;
=SML
val lthy = get_current_theory_name();
val _ = open_theory "z_library";
val _ = delete_theory "z_predicate_calculus" handle _ => ();
val _ = new_theory "z_predicate_calculus";
val _ = push_pc "hol";
val _ = set_flag("z_type_check_only",false);
val _ = push_pc "hol1";
val _ = new_pc "'z_predicate_calculus_build";
val _ = set_pr_tac basic_prove_tac "'z_predicate_calculus_build";
val _ = set_pr_conv basic_prove_conv "'z_predicate_calculus_build";
=TEX
\section{HIJACKED FROM IMP050.DOC}
These ought to be in the signature of ZGeneratedConstants,
but are not.
=SML
fun €bind_con_proj›(ty:TYPE) =
let	val (sl,tyl) = split(dest_z_schema_t ty)
		handle complaint => 
		divert complaint "dest_z_schema_t" "bind_con_proj" 47050 
			[fn () => string_of_type ty];
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val pnaml = map (curry (op ^) nam)  sl;
in
	(cnam,pnaml)
end;
=TEX
=SML
fun €get_binding_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = bind_con_proj ty
		handle complaint => 
		divert complaint "bind_con_proj" "get_binding_info" 47050 
			[fn () => string_of_type ty];
	val (sl,tyl) = split(dest_z_schema_t ty);
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = map mk_z_var_t sl;	
		val	bty = (hd o rev o strip_≠_type) pty;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end	
	| _ => fail "get_binding_info" 50001 [fn () => cnam]
end;
=TEX
=SML
local
fun (€int_to_tyvl› : int -> TYPE list) 1 = [mk_z_var_t (string_of_int 1)]
| int_to_tyvl n = (int_to_tyvl(n - 1)) @ [mk_z_var_t (string_of_int n)];
=TEX
=SML
fun (€int_to_sl› : int -> string list) 1 = [string_of_int 1]
| int_to_sl n = (int_to_sl(n - 1)) @ [string_of_int n];
=TEX
=SML
fun €tuple_con_proj›(ty:TYPE) =
let	val tyl = dest_z_tuple_t ty
		handle complaint => 
		divert complaint "dest_z_tuple_t" "tuple_con_proj" 47040 
			[fn () => string_of_type ty];
	val n = length tyl;
	val nam = fst(dest_ctype ty);
	val typart = implode(tl(tl(explode nam)));
	val cnam = "Z'Mk_"^typart;
	val isl = int_to_sl n;
	val pnaml = map (curry (op ^) nam)  isl;
in	
	(cnam,pnaml)
end;
in
=TEX
=SML
fun €get_tuple_info›(ty : TYPE) : TERM * TERM list =
let 	val (cnam,pnaml) = tuple_con_proj ty
		handle complaint => 
		divert complaint "tuple_con_proj" "get_tuple_info" 47040 
			[fn () => string_of_type ty];
	val n = length pnaml;
in
	case get_const_type cnam  of Value pty => 
	let	val 	ctm = mk_const(cnam,pty);
		val 	tyvl = int_to_tyvl n;	
		val 	bty = mk_z_tuple_t tyvl;
		val 	ptyl = map (curry mk_≠_type bty) tyvl;
		val 	ptml = map mk_const(combine pnaml ptyl);	
	in	(ctm,ptml)
	end		| _ => fail "get_tuple_info" 50002 [fn () => cnam]
end;
end;
=TEX

\section{THE CODE}
\subsection{Utilities}
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Swap a universally quanitifed equation around:
=SML
fun €eqn_sym_rule› (thm : THM) = (
let 	val (vs,bdy) = strip_µ(concl thm);
	val s1 = eq_sym_rule (list_µ_elim vs thm);
in
	list_µ_intro vs s1
end);
=TEX
Sort a list of destroyed variables, by name, returning the
sorted variables as terms.
=SML
fun €var_sort› (itym: (string * TYPE)list) : TERM list = (
let	val sl = idsetseq(fst(split itym));
	val vs = map (fn nm => mk_var(nm, lassoc3 itym nm)) sl;
in
	vs
end);
=TEX
Find the Z constants (i.e. declared in 
=INLINEFT
get_descendants "z_language"
=TEX
) in a term.
Note we return terms, not name/type pairs like
$term\_consts$.
=SML
fun €term_z_consts› (tm : TERM) : TERM list = (
let	val in_thys = get_descendants "z_language";
	val hol_cons = term_consts tm;
	val zed_consts = mapfilter
		(fn (nm,ty) => if get_const_theory nm mem in_thys
			then mk_const(nm,ty)
			else fail "" 0 [])
		hol_cons;
in
	zed_consts
end);
=TEX
=FRULE 1
∂_§_rule
¨xÆ
˜
á Ù s § t
˜
á Ù (∂ x ∑ s) § (∂ x ∑ t)
=TEX
=SML
fun €∂_§_rule› x t = app_fun_rule 
	(mk_const("∂",mk_≠_type(mk_≠_type(type_of x,BOOL),BOOL)))
	(Ã_eq_rule x t);
=TEX
Rename a sequence of quantified variables:
=SML
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_¡_conv nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_¡_conv nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX

\subsection{Recognising Z}
\subsubsection{Destroying Bindings}
Could the term in question have been formed by $mk\_binding$?
=SML
local
	val aux = Sort.sort Sort.string_order;
in
fun €dest_sorted_strings› (ss : string list) : string list = (
	if aux ss = ss
	then ss
	else fail "dest_sorted_strings" 0 []
);
end;
fun €dest_bind_tname› (nm : string) : string list = (
	case dest_z_name nm of
	("Z'S",[fid],Nil) => dest_sorted_strings fid
	| _ => fail "dest_bind_tname" 0 []
);
=TEX
In the following the results are ordered by the strings.
=SML
fun €dest_bind_type› (ty : TYPE) : (string * TYPE) list = (
let	val (nm,tys) = dest_ctype ty;
	val fst_itym = dest_bind_tname nm;
in
	combine fst_itym tys
end);
=TEX
In the following the results are ordered by the strings.
=SML
fun €dest_bind_ctype› (ty : TYPE) : (string * TYPE) list = (
let	val tys = rev(strip_≠_type ty);
	val core_type = hd tys;
	val atypes = rev(tl tys);
	val itym = dest_bind_type core_type;
in
	if list_eq (op =:) atypes (map snd itym)
	then itym
	else fail "dest_bind_ctype" 0 []
end);
=TEX
=SML
fun €dest_bind_cname› (s : string) : string list = (
case dest_z_name s of
("Z'Mk_S",[fid],Nil) => dest_sorted_strings fid
| _ => fail "dest_bind_cname" 0 []
);
=TEX
=SML
fun €dest_bind_cterm› (tm : TERM) : (string * TYPE) list = (
let	val (cnm,cty) = dest_const tm;
	val nm_fst_itym = dest_bind_cname cnm;
	val ty_itym = dest_bind_ctype cty;
in
	if nm_fst_itym = map fst ty_itym
	then ty_itym
	else fail "dest_bind_cterm" 0 []
end);
=TEX
The following returns the list of original bound variables, paired
with their types, and the decoration to be applied to them.
the originally input schema cannot be recreated.

Notice the following is NOT the inverse of 
=INLINEFT
mk_z_binding
=TEX
 just
=INLINEFT
mk_binding
=TEX
=SML
fun €full_dest_binding› (tm : TERM) : (string * TYPE)list * string = (
let	val (bcons,argl) = strip_app tm;
	val args_itym = map dest_var argl;
	val b_itym = dest_bind_cterm bcons;
	val d = case b_itym of
		(a :: x) => implode
 				((explode(fst (hd args_itym))) from 
				(length(explode(fst a))))
		| _ => "";
in
	if list_eq (fn ((a,aty),(b,bty)) => a=b ^ d andalso (aty =: bty)) 
		args_itym b_itym
	then (b_itym, d)
	else fail "full_dest_binding" 0 []
end);
=TEX
\subsubsection{Utilities of Destruction}
The following function produces a type map from a declaration.
=SML
local
fun	f ([] :TERM list) :(string * TYPE)list = []
|	f (h::t) = (
		map dest_var (fst(dest_z_dec h))
		handle Fail _ =>
		let val (sch,d) = dest_z_decsexp h
		in
			map 	(fn(s,ty)=>(pack_ident(s,d),ty)) 
				(dest_z_schema_t(dest_z_power_t(type_of sch)))
		end) @ (f t);
in
fun	€dest_decl› (t:TERM) :(string * TYPE)list =
		f (dest_z_decl t)
	handle Fail _ => term_fail "dest_decl" 47912 [t]
end;
=TEX
=SML
fun €strip_simple_Ã› (itm: TERM) : TERM list * TERM = (
let	fun aux acc tm = (let val (v,bdy) = dest_Ã tm;
		in
		aux (v::acc) bdy
		end)
		handle (Fail _) => (rev acc, tm);
in
	aux [] itm
end);
=TEX
=SML
fun €dest_schema_abs› (tm : TERM) : (string * TYPE) list * TERM = (
let	val (vs,bdy) = strip_simple_Ã tm;
	val itym = map dest_var vs;
	val dummy = dest_sorted_strings(map fst itym);
in
	(itym, bdy)
end);
=TEX
=SML
fun €dest_g3_abs› (tm : TERM) 
	: TERM * TERM * TERM * TERM * (string * TYPE) list = (
let	val (itym,bdy) = dest_schema_abs tm;
	val (root,args) = strip_app bdy;
	val sg = dest_bind_cterm root;
	val to_ft1 = snd(nth 2 sg);
	val to_ft4 = snd(nth 3 sg);
in
	if to_ft4 =: type_of (nth 3 args) andalso
		to_ft1 =: type_of (nth 2 args)
	then (case args of
	[ft2,ft3,ft1,ft4] => (ft1,ft2,ft3,ft4,itym)
	| _ => fail "dest_g2_abs" 0 [])
	else fail "dest_g2_abs" 0 []
end);
=TEX
=SML
fun €dest_g2_abs› (tm : TERM) : TERM * TERM * TERM * (string * TYPE) list = (
let	val (itym,bdy) = dest_schema_abs tm;
	val (root,args) = strip_app bdy;
	val sg = dest_bind_cterm root;
	val to_ft4 = snd(nth 2 sg);
in
	if to_ft4 =: type_of (nth 2 args)
	then (case args of
	[ft2,ft3,ft4] => (ft2,ft3,ft4,itym)
	| _ => fail "dest_g2_abs" 0 [])
	else fail "dest_g2_abs" 0 []
end);
=TEX
=SML
fun €dest_g1_abs› (tm : TERM) : TERM * TERM * (string * TYPE) list = (
let	val (itym,bdy) = dest_schema_abs tm;
	val (root,args) = strip_app bdy;
	val dummy = if root =$ g1_bind_cterm
		then ()
		else fail "dest_g1_abs" 0 [];
in
	(case args of
	[ft2,ft3] => (ft2,ft3,itym)
	| _ => fail "dest_g1_abs" 0 [])
end);
=TEX
=SML
local
val rt = g2_bind_type BOOL;

fun €dest_∂â1_bterm› (tm : TERM) : TYPE list = (
let	val (bnm,bty) = dest_const tm;
	val lfid = case (dest_z_name bnm) of
		("Z'∂â1",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_∂â1_bterm" 0 [];
	val (ty1,ty2) = dest_≠_type bty;
	val tys = rev(strip_≠_type ty1);
in
	if (ty2 =: BOOL) andalso (hd tys =: rt)
	then rev (tl tys)
	else fail "dest_∂â1_bterm" 0 []
end);
in
=TEX
=SML
fun €full_dest_z_∂â1›  
	(tm : TERM) : TERM * TERM * TERM = (
let	val (bterm1,term) = dest_app tm;
	val ity = dest_∂â1_bterm bterm1;
	val (d,p,v,itym) = dest_g2_abs term;
	val itym' = dest_decl d;
in
	if list_eq (op =:) ity (map snd itym) andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_∂â1" 0 []
end);
end;
=TEX
=SML
fun €dest_schema_type› (ty : TYPE) : (string * TYPE) list = (
	case dest_ctype ty of
	("SET",[ty1]) => dest_bind_type ty1
	| _ => fail "dest_schema_type" 0 []
);
=TEX
\subsubsection{Top Level Destructors}
=SML
fun €full_dest_z_binder2› (binds:string) (bterm: TERM) (body_bterm: TERM) 
	(tm : TERM) : TERM * TERM * TERM = (
let	val (bterm1,term) = dest_app tm;
	val dummy = if bterm =$ bterm1
		then ()
		else fail "full_dest_z_binder2" 0 [];
	val (vars, bdy) = strip_simple_binder binds term;
	val itym = map dest_var vars;
	val (sl,tyl) = (dest_sorted_strings ** Combinators.I)
			(split itym);
	val (body_bterm1,fts) = strip_app bdy;
	val dummy = if body_bterm1 =$ body_bterm
		then ()
		else fail "full_dest_z_binder2" 0 [];
	val (ft1,ft2,ft3) = case fts of
		[ft1,ft2,ft3] => (ft1,ft2,ft3)
		| _ => fail "full_dest_z_binder2" 0 [];
	val itym_us = dest_decl ft1;
	val dummy = if all itym_us (fn (nm,ty) =>
		lassoc3 itym nm =: ty)
		then ()
		else fail "full_dest_z_binder2" 0 [];
in
	(ft1,ft2,ft3)
end);

=TEX
=SML
local
fun €dest_∂âs_bterm› (tm : TERM) : (string * TYPE) list * (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val (fid1,fid2_diff_fid1) = case (dest_z_name nm) of
		("Z'∂âs",[a,b],Nil) => (a,b)
		| _ => fail "dest_∂âs_bterm" 0 [];
	val (ty1,ty2,ty3) = case strip_≠_type ty of
		[t1,t2,t3] => (t1,t2,t3)
		| _ => fail "dest_∂âs_bterm" 0 [];
	val ty1' = rev(strip_≠_type ty1);
	val ity1 = rev(tl ty1');
	val dummy = dest_sorted_strings fid1;
	val itym1 = combine fid1 ity1;
	val itym2 = dest_schema_type ty2;
	val itym2_diff_itym1 = dest_schema_type ty3;
	val dummy = if hd ty1' =: g1_bind_type andalso
		fid2_diff_fid1 = map fst itym2_diff_itym1 andalso
		list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) 
			itym2_diff_itym1 (diff' (itym2, itym1)) andalso
		is_nil(diff' (itym1, itym2))
		then ()
		else fail "dest_∂âs_bterm" 0 [];
in
	(itym1, itym2)
end);
in
=TEX
=SML
fun €full_dest_z_∂âs› (tm : TERM) : TERM * TERM * TERM = (
let	val (∂âs_bterm1, g1, v) = case strip_app tm of
		(a,[b,c]) => (a,b,c)
		| _ => fail "full_dest_z_∂âs" 0 [];
	val (dtym, vtym) = dest_∂âs_bterm ∂âs_bterm1;
	val (d,p,dtym1) = dest_g1_abs g1;
	val dtym' = dest_decl d;
	val vtym' = dest_z_schema_t(dest_z_power_t(type_of v));
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) dtym dtym1 andalso
		all dtym' (fn (nm,ty) => lassoc3 dtym nm =: ty) andalso
		all vtym' (fn (nm,ty) => lassoc3 vtym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_∂âs" 0 []
end);
end;
=TEX
=SML
local
fun €dest_∂â1âs_bterm› (tm : TERM) 
	: (string * TYPE) list * (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val (fid1,fid2_diff_fid1) = case (dest_z_name nm) of
		("Z'∂â1âs",[a,b],Nil) => (a,b)
		| _ => fail "dest_∂âs_bterm" 0 [];
	val (ty1,ty2,ty3) = case strip_≠_type ty of
		[t1,t2,t3] => (t1,t2,t3)
		| _ => fail "dest_∂â1âs_bterm" 0 [];
	val ty1' = rev(strip_≠_type ty1);
	val ity1 = rev(tl ty1');
	val dummy = dest_sorted_strings fid1;
	val itym1 = combine fid1 ity1;
	val itym2 = dest_schema_type ty2;
	val itym2_diff_itym1 = dest_schema_type ty3;
	val dummy = if hd ty1' =: g1_bind_type andalso
		fid2_diff_fid1 = map fst itym2_diff_itym1 andalso
		list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) 
			itym2_diff_itym1 (diff' (itym2, itym1)) andalso
		is_nil(diff' (itym1, itym2))

		then ()
		else fail "dest_∂â1âs_bterm" 0 [];
in
	(itym1, itym2)
end);
in
=TEX
=SML
fun €full_dest_z_∂â1âs› (tm : TERM) : TERM * TERM * TERM = (
let	val (∂â1âs_bterm1, g1, v) = case strip_app tm of
		(a,[b,c]) => (a,b,c)
		| _ => fail "full_dest_z_∂âs" 0 [];
	val (dtym, vtym) = dest_∂â1âs_bterm ∂â1âs_bterm1;
	val (d,p,dtym1) = dest_g1_abs g1;
	val dtym' = dest_decl d;
	val vtym' = dest_z_schema_t(dest_z_power_t(type_of v));
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) dtym dtym1 andalso
		all dtym' (fn (nm,ty) => lassoc3 dtym nm =: ty) andalso
		all vtym' (fn (nm,ty) => lassoc3 vtym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_∂â1âs" 0 []
end);
end;
=TEX
=SML
local
fun €dest_µâs_bterm› (tm : TERM) : (string * TYPE) list * (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val (fid1,fid2_diff_fid1) = case (dest_z_name nm) of
		("Z'µâs",[a,b],Nil) => (a,b)
		| _ => fail "dest_µâs_bterm" 0 [];
	val (ty1,ty2,ty3) = case strip_≠_type ty of
		[t1,t2,t3] => (t1,t2,t3)
		| _ => fail "dest_µâs_bterm" 0 [];
	val ty1' = rev(strip_≠_type ty1);
	val ity1 = rev(tl ty1');
	val dummy = dest_sorted_strings fid1;
	val itym1 = combine fid1 ity1;
	val itym2 = dest_schema_type ty2;
	val itym2_diff_itym1 = dest_schema_type ty3;
	val dummy = if hd ty1' =: g1_bind_type andalso
		fid2_diff_fid1 = map fst itym2_diff_itym1 andalso
		list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) 
			itym2_diff_itym1 (diff' (itym2, itym1)) andalso
		is_nil(diff' (itym1, itym2))

		then ()
		else fail "dest_µâs_bterm" 0 [];
in
	(itym1, itym2)
end);
in
=TEX
=SML
fun €full_dest_z_µâs› (tm : TERM) : TERM * TERM * TERM = (
let	val (µâs_bterm1, g1, v) = case strip_app tm of
		(a,[b,c]) => (a,b,c)
		| _ => fail "full_dest_z_µâs" 0 [];
	val (dtym, vtym) = dest_µâs_bterm µâs_bterm1;
	val (d,p,dtym1) = dest_g1_abs g1;
	val dtym' = dest_decl d;
	val vtym' = dest_z_schema_t(dest_z_power_t(type_of v));
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) dtym dtym1 andalso
		all dtym' (fn (nm,ty) => lassoc3 dtym nm =: ty) andalso
		all vtym' (fn (nm,ty) => lassoc3 vtym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_µâs" 0 []
end);
end;
=TEX
=SML
fun €full_dest_z_predsexp› (tm : TERM) : TERM * string = (
let	val (con,args) = strip_app tm;
	val (bind,sch) = case args of
		[bind,sch] => (bind,sch)
		| _ => fail "full_dest_z_predsexp" 0 [];
	val dummy = if (fst(dest_const con) = "Z'SchemaPred")
			andalso type_of tm =: BOOL
		then ()
		else fail "full_dest_z_predsexp" 0 [];
	val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
	val (itym,d) = full_dest_binding bind;
in	if all (combine itym stym)
			(fn ((inm,_),(snm,_)) => inm = snm)
	then (sch,d)
	else fail "full_dest_z_predsexp" 0 []
end);
=TEX
=SML
local
fun €dest_z_seta_bterm› (tm :TERM) : TYPE list * TYPE = (
let	val (nm,ty) = dest_const tm;
	val litym = case (dest_z_name nm) of
		("Z'Seta",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_z_seta_bterm" 0 [];
	val (ty1,ty2) = dest_≠_type ty;
	val ty3 = case dest_ctype ty2 of
		("SET",[ty3]) => ty3
		| _ => fail "dest_z_seta_bterm" 0 [];
	val tys = rev(strip_≠_type ty1);
	val g2bt = hd tys;
	val ity = rev(tl tys);
in
	if g2bt =: g2_bind_type ty3 andalso
		length ity = litym
	then (ity,ty3)
	else fail "dest_z_seta_bterm" 0 []
end);
in
=TEX
=SML
fun €full_dest_z_seta› (tm : TERM) : TERM * TERM * TERM = (
let	val (seta_bterm1, bdy) = dest_app tm;
	val (d,p,v,itym) = dest_g2_abs bdy;
	val (ity,vty) = dest_z_seta_bterm seta_bterm1;
	val itym' = dest_decl d;
in
	if list_eq(op =:) ity (map snd itym) andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_seta" 0 []
end);
end;
=TEX
=SML
fun €full_dest_z_ › (tm : TERM) : TERM * string = (
let	val (con,args) = strip_app tm;
	val (bind,sch) = case args of
		[a,b] => (a,b)
		| _ => fail "full_dest_z_ " 0 [];
	val dummy = if (fst(dest_const con) = "Z' ")
			andalso type_of tm =: type_of bind
		then ()
		else fail "full_dest_z_ " 0 [];
	val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
	val (itym,d) = full_dest_binding bind;
in	if all (combine itym stym)
			(fn ((inm,_),(snm,_)) => inm = snm)
	then (sch,d)
	else fail "full_dest_z_ " 0 []
end);
=TEX
=SML
fun €dest_tuple_type› (ty : TYPE) : TYPE list = (
let	val (nm,args) = dest_ctype ty;
	val nfid = case dest_z_name nm of
		("Z'T",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_tuple_type" 0 [];
in
	if nfid = length args
	then args
	else fail "dest_tuple_type" 0 []
end);
=TEX
=SML
local
fun €dest_Ã_bterm› (tm : TERM) : TYPE list * TYPE * TYPE = (
let	val (nm,ty) =dest_const tm;
	val nfid = case dest_z_name nm of
		("Z'Ã",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_Ã_bterm" 0 [];
	val (ty1,ty2) = dest_≠_type ty;
	val ty3 = case dest_ctype ty2 of
		("SET",[ty3]) => ty3
		| _ => fail "dest_Ã_bterm" 0 [];
	val (t_ty,v_ty) = case dest_tuple_type ty3 of
		[t1,t2] => (t1,t2)
		| _ => fail "dest_Ã_bterm" 0 [];
	val ity = rev(tl(rev(strip_≠_type ty1)));
in
	(ity, t_ty, v_ty)
end);
=TEX
=SML
fun	f ([]:Z_TERM list) :TERM list = []
|	f (ZDec(tml,_)::z_tml) = tml @ (f z_tml)
|	f (ZSchemaDec(sch,d)::z_tml) = (mk_z_ (sch,d)) :: (f z_tml)
|	f _ = term_fail "mk_z_Ã" 0 [];

fun	chartuple ((ZDecl tml):Z_TERM) :TERM = (
		case (f (map dest_z_term tml)) of
			[] => fail "mk_z_Ã" 0 []
		|	[tm] => tm
		|	tml' => mk_z_tuple tml'
		)
|	chartuple _ = fail "mk_z_Ã" 0 [];
in
fun €full_dest_z_Ã› (tm : TERM) : TERM * TERM * TERM = (
let	val (Ã_bterm1, g3abs) = dest_app tm;
	val (ity,t_ty,v_ty) = dest_Ã_bterm Ã_bterm1;
	val (t,d,p,v,itym) = dest_g3_abs g3abs;
	val itym' = dest_decl d;
	val t' = chartuple(dest_z_term d);
in
	if list_eq (op =:) ity (map snd itym) andalso
		t_ty =: type_of t andalso
		v_ty =: type_of v andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty) andalso
		t' =$ t
	then (d,p,v)
	else fail "full_dest_z_Ã" 0 []
end);
end;
=TEX
=SML
local
fun €dest_Õ_bterm› (tm :TERM) : TYPE list * TYPE = (
let	val (nm,ty) = dest_const tm;
	val litym = case (dest_z_name nm) of
		("Z'Õ",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_Õ_bterm" 0 [];
	val (ty1,ty2) = dest_≠_type ty;
	val tys = rev(strip_≠_type ty1);
	val g2bt = hd tys;
	val ity = rev(tl tys);
in
	if g2bt =: g2_bind_type ty2 andalso
		length ity = litym
	then (ity,ty2)
	else fail "dest_Õ_bterm" 0 []
end);
in
=TEX
=SML
fun €full_dest_z_Õ› (tm : TERM) : TERM * TERM * TERM = (
let	val (Õ_bterm1, bdy) = dest_app tm;
	val (d,p,v,itym) = dest_g2_abs bdy;
	val (ity,vty) = dest_Õ_bterm Õ_bterm1;
	val itym' = dest_decl d;
in
	if list_eq(op =:) ity (map snd itym) andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_Õ" 0 []
end);
end;
=TEX
=SML
local
fun €dest_schema_bterm› (tm:TERM): (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val fid = case (dest_z_name nm) of
		("Z'âs",[fid],Nil) => fid
		| _ => fail "dest_schema_bterm" 0 [];
	val (ty1,ty2) = dest_≠_type ty;
	val itym = dest_schema_type ty2;
	val tys = rev(strip_≠_type ty1);
	val g1bt = hd tys;
	val ity = rev(tl tys);
in
	if g1bt =: g1_bind_type andalso
		list_eq(op =:) ity (map snd itym)
	then itym
	else fail "dest_schema_bterm" 0 []
end);
in
=TEX
=SML
fun €full_dest_z_âs› (tm : TERM) : TERM * TERM = (
let	val (schema_bterm1, bdy) = dest_app tm;
	val (d,p,itym) = dest_g1_abs bdy;
	val itym' = dest_schema_bterm schema_bterm1;
	val itym'' = dest_decl d;
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) itym itym'
		andalso
		all itym'' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p)
	else fail "full_dest_z_âs" 0 []
end);
end;
=TEX
=SML
fun €full_dest_z_decsexp› (tm : TERM) : TERM * string = (
let 	val (con,args) = (strip_app tm);
	val (bind,sch) = case args of
		[bind,sch] => (bind,sch)
		| _ => fail "full_dest_z_decsexp" 0 [];
	val dummy = if (fst(dest_const con) = "Z'SchemaDec")
			andalso type_of tm =: BOOL
		then ()
		else fail "full_dest_z_decsexp" 0 [];
	val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
	val (itym,d) = full_dest_binding bind;
in	if all (combine itym stym)
			(fn ((inm,_),(snm,_)) => inm = snm)
	then (sch,d)
	else fail "full_dest_z_decsexp" 0 []
end);

=TEX
\subsubsection{Bringing it Together}
=SML
fun €full_dest_z_term› (tm : TERM) : Z_TERM = (
let val dzt = dest_z_term tm;
in
case dzt of
ZSchemaDec(sch,d) => (full_dest_z_decsexp tm; dzt)
| Z∂(d,p,v) => (full_dest_z_binder2 "∂" ∂_bterm ∂body_bterm tm; dzt)
| Zµ(d,p,v) => (full_dest_z_binder2 "µ" µ_bterm µbody_bterm tm; dzt)
| Z∂â1(d,p,v) => (full_dest_z_∂â1 tm; dzt)
| Z∂âs(d,p,v) => (full_dest_z_∂âs tm; dzt)
| Z∂â1âs(d,p,v) => (full_dest_z_∂â1âs tm; dzt)
| Zµâs(d,p,v) => (full_dest_z_µâs tm; dzt)
| ZSchemaPred(sch,d) => (full_dest_z_predsexp tm; dzt)
| ZSeta(d,p,v) => (full_dest_z_seta tm; dzt)
| Z (sch,d) => (full_dest_z_  tm; dzt)
| ZÃ(d,p,v) => (full_dest_z_Ã tm; dzt)
| ZÕ(d,p,v) => (full_dest_z_Õ tm; dzt)
| Zâs(d,p) => (full_dest_z_âs tm; dzt)
| _ => dzt
end
handle (Fail _) =>
term_fail "full_dest_z_term" 41002 [tm]
);
=TEX
The following cannot ``cheat'' $dest\_z\_term$, unless the constants
have been given types incompatible with their generated forms
from \cite{DS/FMU/IED/DTD047}.
=GFT
ZDec, ZDecl, ZEq, Zç, ZTrue, ZFalse, Z≥, Z±, Z≤, Z¥,
Z§, ZLVar, ZGVar, ZInt, ZString, Zß¢, ZSetd, Z, ZTuple,
ZBinding, Z∏, ZSelâs, ZSelât, ZApp, ZDecorâs, ZPreâs, 
Z≥âs, Z±âs, Z≤âs, Z¥âs, Z§âs, Z˘âs, ZHideâs, ZÑâs, 
Zòâs, Zªâs, ZRenameâs
=TEX
\subsection{Problems to be Caught}
=GFT
val tm = mk_z_decsexp(Ò[z:X;x:Y;y:Z]Æ,"'");
val y' = nth 4 (frees tm);
val y'' = variant [y'] y';
val tm' = subst[(y'',y')] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
As ``!'' is before ```'' in ordering:
=GFT
val tm = Òµ x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
As ``!'' is before ```'' in ordering:
=GFT
val tm = Ò∂ x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
As ``!'' is before ```'' in ordering:
=GFT
val tm = Ò∂â1 x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val Z∂(a,b,c) = dest_z_term Ò∂ x, x! : X | x = z ∑ [x,x! : X | true]Æ;
val tm = mk_z_∂âs(a,b,Ò[x,x! : X | true]Æ);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val Z∂(xa,xb,xc) = dest_z_term Ò∂ x, x! : X | x = z ∑ [x,x! : X | true]Æ;
val tm = mk_z_∂â1âs(xa,xb,Ò[x,x! : X | true]Æ);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val Z∂(xa,xb,xc) = dest_z_term Ò∂ x, x! : X | x = z ∑ [x,x! : X | true]Æ;
val tm = mk_z_µâs(xa,xb,Ò[x,x! : X | true]Æ);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val tm1 = Ò[x,x!:X | x = z] ± trueÆ;
val tm = fst(dest_z_± tm1);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val x_ins' = mk_var("x'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = Ò{x, x! : X | x = z}Æ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = Ò [x, x! : X | x = z]Æ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val x_ins' = mk_var("x'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = Ò Ã x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = Ò Õ x, x! : X ∑ x = zÆ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = Ò [x,x! : X | x = z]Æ;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=SML
fun €is_all_z_type› (ty : TYPE) : bool = (
let
	fun aux (a :: x) = is_all_z_type a andalso aux x
	| aux [] = true;
	fun aux1 ((_,a) :: x) = is_all_z_type a andalso aux1 x
	| aux1 [] = true;
in
(case (dest_z_type ty 
	handle (Fail _) => 
	type_fail "is_all_z_type"  41003 [ty]) of
Zgiven_t _ => true
| Zvar_t _ => true
| Zpower_t ty' => is_all_z_type ty'
| ZTuple_t tyl => aux tyl
| Zschema_t ltyl => aux1 ltyl)
end);
=TEX
Note the special case of $ÒUÆ$, which parses to $ÒU[¨TotalityÆ]$, is legal Z, for all $Totality$ is not a Z, but a HOL, constant.
=SML
fun €is_z› (tm : TERM) : bool = (
let fun aux (a :: x) = is_z a andalso aux x
	| aux _ = true;
in
case (full_dest_z_term tm
	handle (Fail _) =>
	term_fail "is_z" 41002 [tm]) of
ZLVar (_,ty,tml) => is_all_z_type ty andalso aux tml
| ZGVar (nm,ty,tml) => is_all_z_type ty andalso 
		if (nm = "U" andalso length tml = 1
			andalso is_const (hd tml) andalso
			fst(dest_const (hd tml)) = "Totality")
		then true
		else aux tml
| ZApp (tm1,tm2) => is_z tm1 andalso is_z tm2
| ZDec (tml,tm1) => aux tml andalso is_z tm1
| ZSchemaDec (tm1,_) => is_z tm1
| ZDecl tml => aux tml
| ZEq (tm1,tm2) => is_z tm1 andalso is_z tm2
| Zç (tm1, tm2) => is_z tm1 andalso is_z tm2
| ZTrue => true
| ZFalse => true
| Z≥ tm1 => is_z tm1
| Z≥âs tm1 => is_z tm1
| Z± (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z≤ (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z¥ (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z§ (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z±âs (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z≤âs (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z¥âs (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z§âs (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z∂ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z∂âs (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z∂â1 (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z∂â1âs (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Zµ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Zµâs (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| ZSchemaPred (tm1,_) => is_z tm1
| ZInt _ => true
| ZString _ => true
| Zß¢ (ty,tml) => is_all_z_type ty andalso aux tml
| ZSetd (ty,tml) => is_all_z_type ty andalso aux tml
| ZSeta (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z tm1 => is_z tm1
| ZTuple tml => aux tml
| Z∏ tml => aux tml
| Z  (tm1,_) => is_z tm1
| ZSelâs (tm1,_) => is_z tm1
| ZSelât (tm1,_) => is_z tm1
| ZÕ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| ZÃ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Zâs (tm1,tm2) => is_z tm1 andalso is_z tm2
| ZDecorâs (tm1,_) => is_z tm1
| ZPreâs tm1 => is_z tm1
| Z˘âs (tm1,tm2) => is_z tm1 andalso is_z tm2
| ZHideâs (tm1,_) => is_z tm1
| ZÑâs tm1  => is_z tm1
| Zòâs tm1  => is_z tm1
| Zªâs (tm1,tm2) => is_z tm1 andalso is_z tm2
| ZRenameâs (tm1,_) => is_z tm1
| ZBinding (stml) => aux (map snd stml)
end);

=TEX
=SML
fun €not_z_subterms› (itm : TERM) : TERM list = (
let 	val acc = ref ([]:TERM list);
	fun aux1 tm ty = (if is_all_z_type ty 
		then () 
		else acc := tm :: (!acc));

fun tz (tm : TERM) = (
let	fun aux (a :: x) = (tz a ; aux x)
	| aux _ = ();
in
case (full_dest_z_term tm
	handle (Fail _) =>
	(acc := tm :: (!acc); ZTrue)) of
ZLVar (_,ty,tml) => (aux1 tm ty ; aux tml)
| ZGVar (nm,ty,tml) => (aux1 tm ty ; 
		if (nm = "U" andalso length tml = 1
			andalso is_const (hd tml) andalso
			fst(dest_const (hd tml)) = "Totality")
		then ()
		else aux tml
) | ZApp (tm1,tm2) => (tz tm1 ; tz tm2)
| ZDec (tml,tm1) => (aux tml ; tz tm1)
| ZSchemaDec (tm1,_) => tz tm1
| ZDecl tml => aux tml
| ZEq (tm1,tm2) => (tz tm1 ; tz tm2)
| Zç (tm1, tm2) => (tz tm1 ; tz tm2)
| ZTrue => ()
| ZFalse => ()
| Z≥ tm1 => tz tm1
| Z≥âs tm1 => tz tm1
| Z± (tm1, tm2) => (tz tm1 ; tz tm2)
| Z≤ (tm1, tm2) => (tz tm1 ; tz tm2)
| Z¥ (tm1, tm2) => (tz tm1 ; tz tm2)
| Z§ (tm1, tm2) => (tz tm1 ; tz tm2)
| Z±âs (tm1, tm2) => (tz tm1 ; tz tm2)
| Z≤âs (tm1, tm2) => (tz tm1 ; tz tm2)
| Z¥âs (tm1, tm2) => (tz tm1 ; tz tm2)
| Z§âs (tm1, tm2) => (tz tm1 ; tz tm2)
| Z∂ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z∂âs (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z∂â1 (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z∂â1âs (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Zµ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Zµâs (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| ZSchemaPred (tm1,_) => tz tm1
| ZInt _ => ()
| ZString _ => ()
| Zß¢ (ty,tml) => (aux1 tm ty ; aux tml)
| ZSetd (ty,tml) => (aux1 tm ty ; aux tml)
| ZSeta (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z tm1 => tz tm1
| ZTuple tml => aux tml
| Z∏ tml => aux tml
| Z  (tm1,_) => tz tm1
| ZSelâs (tm1,_) => tz tm1
| ZSelât (tm1,_) => tz tm1
| ZÕ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| ZÃ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Zâs (tm1,tm2) => (tz tm1 ; tz tm2)
| ZDecorâs (tm1,_) => tz tm1
| ZPreâs tm1 => tz tm1
| Z˘âs (tm1,tm2) => (tz tm1 ; tz tm2)
| ZHideâs (tm1,_) => tz tm1
| ZÑâs tm1  => tz tm1
| Zòâs tm1  => tz tm1
| Zªâs (tm1,tm2) => (tz tm1 ; tz tm2)
| ZRenameâs (tm1,_) => tz tm1
| ZBinding (stml) => aux (map snd stml)
end);
in
	(tz itm;
	(!acc))
end);
=TEX
\subsection{Using the Checks}
We handle failures from $new\_flag$ to allow repeated loadings of this function.
=SML
local
	val €check_is_z› = ref true;
in
	val _ = new_flag{name = "check_is_z",
		check = fun_true,
		control = check_is_z,
		default = (fn () => false)}
	handle (Fail _) => ();
end;
=TEX
=SML
local
	fun not_z_subterms1 tm = not_z_subterms(snd(strip_simple_µ tm));
in
fun €check_is_z_term› (caller : string) (tm : TERM): TERM = (
	if not(get_flag("check_is_z"))
	then tm
	else (
	case (not_z_subterms1 tm) of
	[] => tm
	| lst => (diag_string (get_error_message 41005
		[caller,(format_list string_of_term lst ", ")]);
		tm)
));
=TEX
=SML
fun €check_is_z_thm› (caller : string) (thm : THM): THM = (
	if not(get_flag("check_is_z"))
	then thm
	else (
let	val nZ = not_z_subterms1 (concl thm) @ flat (map not_z_subterms1 (asms thm));
in
	case nZ of
	[] => thm
	| lst => (diag_string (get_error_message 41005
		[caller,(format_list string_of_term lst ", ")]);
		thm)
end));
=TEX
=SML
fun €check_is_z_goal› (caller : string) ((gasms,conc): GOAL):GOAL = (
	if not(get_flag "check_is_z")
	then (gasms,conc)
	else (
let	val nZ = not_z_subterms1 conc @ flat (map not_z_subterms1 gasms);
in
	case nZ of
	[] => (gasms,conc)
	| lst => (diag_string (get_error_message 41005
		[caller,(format_list string_of_term lst ", ")]);
		(gasms,conc))
end));
=TEX
=SML
fun €CHECK_IS_Z_T› (caller:string) (tac:TACTIC) : TACTIC = (fn gl =>
let	val (sgs,prf) = tac gl;
	val dummy = map (check_is_z_goal caller) sgs;
in
	(sgs,prf)
end);
end; (* of local not_z_subterms1 *)
=TEX
\subsubsection{Adjustment after ¡-conversion}
=SML
fun €¡_to_z› (tm : TERM):TERM = term_fail "¡_to_z NOT YET IMPLEMENTED" 41100 [tm];
val €¡_to_z_conv› : CONV = fail_with_conv "¡_to_z NOT YET IMPLEMENTED";
=TEX
\subsection{Getting Things into the Existence Prover}
Tuple type ``varstruct'' constructions:
=SML
fun €tt_to_∂_vs›  (ty : TYPE) : (string * (TERM list * THM)) = (
let	val (abs,cons) = get_tuple_info ty;
	val def_thm = get_spec (hd cons);
	val abs_nm = fst(dest_const abs);
in
	(abs_nm,(cons, def_thm))
end);

local
val tt_sofar : (string * (TERM list * THM)) list ref = ref [];
in
fun €add_tt_to_pc› (ty : TYPE) : unit = (
let	val (abs_nm,(cons, def_thm)) = tt_to_∂_vs ty;
in
	case lassoc5 (!tt_sofar) abs_nm of
	Nil => (tt_sofar := (abs_nm,(cons, def_thm)) :: (!tt_sofar);
		set_∂_vs_thms (!tt_sofar) "'z_predicate_calculus_build";
		set_merge_pcs ["hol1","'z_predicate_calculus_build"])
	| Value _ => ()
end);
end;

=TEX
Theorems to rewrite with before further existence proof:
=SML
local
val ∂_rw_thms : THM list ref = ref [];
in
fun €add_∂_rw_thm› (thm :THM) : unit = (
let	val dummy = (∂_rw_thms := thm :: (!∂_rw_thms));
	val ∂_conv = pure_rewrite_conv (!∂_rw_thms);
in
	(set_cs_∂_convs [∂_conv] "'z_predicate_calculus_build";
	set_merge_pcs ["hol1","'z_predicate_calculus_build"]
	)
end);
end;
=TEX
=SML
local
	val z'abb_def = get_spec ¨$"Z'AbbDef"Æ;
	val dummy = set_rw_canons 
		[fn thm => [conv_rule(simple_eq_match_conv1 z'abb_def) thm]]
		"'z_predicate_calculus_build";
in
val _ = set_merge_pcs ["hol1","'z_predicate_calculus_build"];
end;
=TEX
\section{Consistency Proofs I}
=SML
val _ = add_tt_to_pc (type_of Ò(x,y)Æ);
val _ = add_∂_rw_thm (get_spec ¨$"Z'AbbDef"Æ);
=TEX
=SML
val _ = (
push_consistency_goal ÒU ™ UÆ;
a(prove_∂_tac);
save_consistency_thm ÒU ™ UÆ (pop_thm()));
=TEX
\section{Concerning The Universe, U}
=SML
val €ç_u_thm› = (
push_goal([],¨µ x ∑ Òx ç UÆÆ);
a(µ_tac);
set_current_language "HOL";
a(rewrite_tac[get_specÒUÆ,get_spec ¨TotalityÆ]);
a(rewrite_tac[get_spec ¨$"Z'T[1]1"Æ, get_spec ¨$"Z'Mk_T[1]"Æ]);
set_current_language "Z";
pop_thm());
val €ç_u_thm1› = prove_rule[ç_u_thm]¨µ x ∑ Òx ç UÆ § TÆ;
=TEX
=SML
val €_u_thm› =  (
push_goal([],¨Ò U = UÆÆ);
a(rewrite_tac[ç_u_thm]);
a(rewrite_tac[get_specÒ UÆ, get_specÒUÆ,
	get_spec¨TotalityÆ]);
a(rewrite_tac[get_spec ¨$"Z'T[1]1"Æ, get_spec ¨$"Z'Mk_T[1]"Æ]);
pop_thm());
=TEX
The following is not used in the general $U$ simplification,
but helps get there.
=SML
val €u_∏_u_thm› = prove_rule 
	[ç_u_thm, get_spec ¨$"Z'∏[2]"Æ] 
	Ò (U ∏ U) = UÆ;
=TEX
\section{Concerning The Universe, U II}

=SML
val €u_™_u_thm› = prove_rule
	[ç_u_thm, get_specÒU ™ UÆ,u_∏_u_thm, _u_thm] 
	 ÒU ™ U = UÆ;
=TEX

\section{Concerning Declarations}
\subsection{Theorems}
=SML
val adec = mk_z_dec([¨x:'aÆ],¨s:'a SETÆ);
val €single_dec_thm› = prove_rule
	[z'dec_def]
	¨µ x:'a; s:'a SET ∑ 
	ÒëadecÆ = Ò¨x:'aÆ ç ¨s:'a SETÆÆÆÆ;
val €sym_single_dec_thm› = eqn_sym_rule single_dec_thm;
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 z'µ_def;
	val cnv2 = simple_eq_match_conv1 z'µbody_def;
in
val €z_µ_elim_conv› :CONV = (
	(cnv1 THEN_C ALL_SIMPLE_µ_C cnv2)
	ORELSE_C (fn tm =>  term_fail "z_µ_elim_conv" 41022 [tm])
);
end;
=GFT Example
z_µ_elim_conv Òµ a,b : U; [c,d:U]; e:U | f ∑ gÆ;
=SML
local
val s1 = rewrite_rule[get_spec ¨$"Z'AxDes"Æ] 
	(get_spec ¨$"z'_ Ä _"Æ);
val s2 = rewrite_rule[_u_thm, u_™_u_thm]
	(µ_elim ÒUÆ s1);
val s3 = conv_rule z_µ_elim_conv (±_right_elim s2);
val s4 = list_simple_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ] s3;
val s5 = conv_rule(LEFT_C(rewrite_conv[z'dec_def,z'decl_def,ç_u_thm])) s4;
val s6 = rewrite_rule [] s5;
val s7 = rewrite_rule[z'dec_def,z'decl_def,ç_u_thm]
		(conv_rule(MAP_C z_µ_elim_conv) s6);
in
val €z_Ä_thm› = all_µ_intro (±_left_elim s6);
val €z_Ä_thm1› = all_µ_intro (±_left_elim s7);
val €z_†_thm› =  all_µ_intro (±_right_elim s6);
end;
=TEX
=SML
val €many_dec_thm› = 
(push_goal ([],¨µ xs:'a LIST; s:'a SET ∑  
	Ò¨$"Z'Dec"((xs:'a LIST),(s:'a SET))Æ = ¨$"Z'Setd"(xs:'a LIST)Æ Ä ¨s:'a SETÆÆÆ);
a(µ_tac);
a(rewrite_tac[z_Ä_thm1]);
a(LIST_INDUCTION_T ¨xs:'a LISTÆ asm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z'setd_def,z'dec_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[z'setd_def,z'dec_def]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(basic_res_tac 3 []);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(basic_res_tac 1 []);
(* *** Goal "2.4" *** *)
a(basic_res_tac 1 []);
pop_thm());

val €sym_many_dec_thm› = eqn_sym_rule many_dec_thm;
=TEX
=SML
val €decsexp_predsexp_thm› = prove_rule[get_spec¨$"Z'SchemaDec"Æ,
		get_spec¨$"Z'SchemaPred"Æ]
	¨µ x y ∑ $"Z'SchemaDec" x y = $"Z'SchemaPred" x yÆ;
val €predsexp_decsexp_thm› = eqn_sym_rule decsexp_predsexp_thm;
=TEX
\subsection{Functions}
=SML
val €dec_pred_conv› :CONV = (fn tm => (
	(simple_eq_match_conv single_dec_thm ORELSE_C
	simple_eq_match_conv many_dec_thm ORELSE_C
	simple_eq_match_conv decsexp_predsexp_thm ORELSE_C
	(fn tm1 => term_fail "dec_pred_conv" 41010 [tm1])
	) tm)
);
=TEX
=SML
local
val cnv1 = simple_eq_match_conv1 z' _def;
val cnv2 = simple_eq_match_conv1 (get_spec¨$"Z'SchemaDec"Æ);
val cnv3 = simple_eq_match_conv1 (prove_rule[]¨µ x:'a ∑ (x = x) § TÆ);
in
val € _s_ç_s_conv› : CONV = (fn tm =>
let	val ( s,s) = dest_z_ç tm;
	val (s',decor) = dest_z_   s;
	val dummy = if s' =$ s andalso decor = ""
		then ()
		else fail " _s_ç_s_conv" 0 [];
	val decs = mk_z_decsexp(s',decor);
	val res_tm = mk_eq(tm,decs);
in
	§_t_elim((APP_C(RAND_C(LEFT_C cnv1),RATOR_C(RATOR_C cnv2)) THEN_C
		cnv3) res_tm)
end);
end;
=TEX
=SML
val €pred_dec_conv› : CONV = 
	(simple_eq_match_conv1 sym_many_dec_thm ORELSE_C
	 _s_ç_s_conv ORELSE_C
	simple_eq_match_conv1 sym_single_dec_thm ORELSE_C
	simple_eq_match_conv1 predsexp_decsexp_thm ORELSE_C
	(fn tm => term_fail "pred_dec_conv" 41011 [tm]));
=TEX
=GFT Examples
val p = fst(dest_±(Ò[a,b:X| a = b] ± trueÆ));

=SML
local 
	val decl_nil = §_t_intro(±_left_elim z'decl_def);
	val decl_cons = ±_right_elim z'decl_def;
	val decl_cons_nil = rewrite_rule[decl_nil] 
		(simple_µ_intro ¨b:BOOLÆ
		(list_simple_µ_elim[¨b:BOOLÆ,¨[]:BOOL LISTÆ]
			decl_cons));
	val cnv_nil = simple_eq_match_conv1 decl_nil;
	val cnv_cons = simple_eq_match_conv1 decl_cons;
	val cnv_cons_nil = simple_eq_match_conv1 decl_cons_nil;
in
fun €DECL_C› (cnv:CONV) : CONV = (fn tm1 =>
let	val dummy = dest_z_decl tm1
		handle complaint =>
		pass_on complaint "dest_z_decl" "DECL_C";
	fun aux tm = ((cnv_cons_nil THEN_C cnv) ORELSE_C
		(cnv_cons THEN_C APP_C(RAND_C cnv,aux))
			ORELSE_C cnv_nil
			ORELSE_C (fn tm2 =>
			term_fail "DECL_C" 41012 [tm1])
		) tm;
in
	aux tm1
end);
end;
=TEX
=GFT Example
val (d,p,v) = dest_z_µ
	Òµ x :X; y,z : Y; p,q,r : X; [a,b : Z | a = b] ∑ trueÆ;
DECL_C dec_pred_conv d;
=TEX
The following applies a conversion to each member of a declaration,
without disturbing the declaration form.
=SML	
fun €DECL_C1› (cnv:CONV) : CONV = (fn tm1 =>
let	val dummy = dest_z_decl tm1
		handle complaint =>
		pass_on complaint "dest_z_decl" "DECL_C1";
	fun aux tm = ((LEFT_C cnv THEN_C RIGHT_C aux)
		ORELSE_C id_conv) tm;
in
	RAND_C aux tm1
end);
=GFT Example
val (d,p,v) = dest_z_µ Òµ a,b : U; c : U | true ∑ trueÆ;
DECL_C1 id_conv d;

A conversional to apply something to the ``types'' of a ``dec'':
=SML
fun €DEC_TYPES_C› (cnv:CONV) : CONV = (fn tm =>
case dest_z_term tm of
ZDec _ => RAND_C(RIGHT_C cnv) tm
| Zâs _ => RAND_C(ALL_SIMPLE_Ã_C (LEFT_C(DEC_TYPES_C cnv))) tm
| _ => term_fail "DEC_TYPES_C" 0 [tm]);
=TEX

=SML
local 
	val bons = ¨Cons:BOOL ≠ BOOL LIST  ≠ BOOL LISTÆ;
	val bnil = ¨[]:BOOL LISTÆ;
	val thm1 = (push_goal([], 
		¨µ a b ∑ (a § b) ¥ (a § $"Z'Decl" [b])Æ);
		a(REPEAT µ_tac THEN ¥_T rewrite_thm_tac);
		a(rewrite_tac[z'decl_def]);
		pop_thm());
	fun thm1_rule thm = (
	let	val (a,b) = dest_§ (concl thm);
		val dummy = (if is_z_dec b orelse is_z_decsexp b
			then ()
			else fail "thm1_rule" 0 [])
	in	¥_elim (list_simple_µ_elim[a,b] thm1) thm
	end);
	val thm2 = (push_goal([],
		¨µ a v1 ∑ (a = $"Z'Decl" v1) ¥ 
		 µ b v2 ∑ (b = $"Z'Decl" v2) ¥
			((a ± b) = $"Z'Decl" (Append v1 v2))Æ);
		a(REPEAT µ_tac THEN ¥_T rewrite_thm_tac);
		a(REPEAT µ_tac THEN ¥_T rewrite_thm_tac);
		a(list_induction_tac ¨v1:BOOL LISTÆ THEN
		  asm_rewrite_tac[append_def, z'decl_def]);
		pop_thm());

	val athm1 = ±_left_elim append_def;
	val athm2 = ±_right_elim append_def;
	fun cnv3 tm = ((simple_eq_match_conv1 athm2 THEN_C RIGHT_C cnv3)
		ORELSE_C simple_eq_match_conv1 athm1) tm;
in
fun €DECL_INTRO_C› (cnv:CONV) : CONV = (fn tm =>
let	fun cnv' tm2 = cnv tm2
		handle (Fail _) =>
		term_fail "DECL_INTRO_C" 41013 [tm];
	fun aux tm1 = if is_± tm1
		then (
		let	val (v1,v2) = dest_± tm1;
			val v1_thm = aux v1;
			val v2_thm = aux v2;
			val append_v1_v2_thm = 
			((simple_¥_match_mp_rule 
			(simple_¥_match_mp_rule thm2 v1_thm)
			v2_thm));
		in
			conv_rule (RIGHT_C(RAND_C cnv3)) append_v1_v2_thm			
		end) 
		else (thm1_rule (cnv' tm1)
		handle complaint =>
		divert complaint "thm1_rule"
			"DECL_INTRO_C" 41014 [
			fn () => string_of_term tm1,
			fn () => string_of_term((snd o dest_eq)(concl (cnv tm1)))]);
in
	aux tm
end);
end;

=TEX
=GFT
DECL_INTRO_C id_conv ¨(a ± b ± (c ± d) ± e) ± ((f ± g) ± h)Æ;
DECL_INTRO_C pred_dec_conv 
	Ò(a ç X ± {b,b1} Ä X1 ± 
	(c ç X ± {d,d1,d2} Ä X2) ± [p,q:X | p = q]) ± 
	(({f} Ä X2 ± g ç X) ± h ç X1)Æ;
=TEX
\section{Concerning The Universe, U, II}
=SML
val €dec_u_thm› = prove_rule[many_dec_thm, z_Ä_thm1, ç_u_thm]
	¨µ xs:'a LIST ∑  
	Ò¨$"Z'Dec"((xs:'a LIST),ÒUÆ)Æ = trueÆÆ;
local val dummy = Ò[a ,b : U; c : U]Æ
in
val €dp_proj_thm› = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p]p"Æ))
		to 1));
end;
val €sets_ext_thm› = prove_rule[]
	¨µs t ∑ (s = t) = µ x ∑x ç s = x ç tÆ;

local
	val cnv1 = simple_eq_match_conv1 dec_u_thm;
	val cnv2 = simple_eq_match_conv1(taut_rule ¨µx ∑ T ± x § xÆ);
	fun cnv3 tm = ((cnv2 THEN_C cnv3) ORELSE_C id_conv) tm;
	val cnv4 = simple_eq_match_conv1 sets_ext_thm;
	val thm5 = prove_rule[ç_u_thm]
		¨µx y ∑ (x § Òy ç UÆ) § xÆ;
	val cnv5 = simple_eq_match_conv1 thm5;
	val cnv6 = simple_eq_match_conv1 (prove_rule[ç_u_thm]¨{x|T} = ÒUÆÆ);
in
val €decl_u_conv› : CONV = DECL_C cnv1 THEN_C cnv3;
=GFT Example
val (d,p,v) = dest_z_µ Òµ a,b : U; c : U | true ∑ trueÆ;

decl_u_conv d;
=TEX
The following is slow, because of the $tac\_proof$.
=SML
fun €seta_u_conv› (tm : TERM) : THM = (
let	val (decl,pred,vl) = dest_z_seta tm;
	val s1 = simple_eq_match_conv1 (get_spec tm) tm;
	val s2 = conv_rule(RIGHT_C(all_¬_conv THEN_C
		pure_rewrite_conv [dpv_proj_thm] THEN_C
		(BINDER_C
		(ALL_SIMPLE_∂_C (
			(LEFT_C decl_u_conv)
			THEN_C cnv2 THEN_C cnv2)))			)) s1;
	val s4 = tac_proof (([],ÒëtmÆ = UÆ),
		conv_tac(LEFT_C (fn _ => s2) THEN_C cnv4) THEN
		simple_µ_tac THEN
		conv_tac(cnv5
			THEN_C simple_ç_comp_conv) THEN
		(fn (asms,gl) =>
		let	val (tup,used_x) = dest_eq(snd(strip_∂ gl));
			val lspec1 = µ_elim used_x (get_spec tup);
			val lspec2 = hd(rev(strip_±_rule (all_µ_elim lspec1)));
			val wits = snd(strip_app(fst(dest_eq(concl lspec2))));
		in
			((MAP_EVERY simple_∂_tac wits THEN
			accept_tac lspec2) (asms,gl))
		end));
	
in
	s4
end);
=GFT Example
seta_u_conv Ò{a ,b : U; c : U}Æ;
=TEX
=SML
fun €decsexp_u_conv› (tm : TERM) : THM = (
let	val (decl,pred) = dest_z_âs tm;
	val s1 = simple_eq_match_conv1 (get_spec tm) tm;
	val s2 = conv_rule(RIGHT_C(all_¬_conv THEN_C
		pure_rewrite_conv [dp_proj_thm] THEN_C
		(BINDER_C
			((LEFT_C decl_u_conv)
			THEN_C cnv2)) THEN_C
		cnv6
		)) s1;
in
	s2
end);
=GFT Example
decsexp_u_conv Ò[a ,b : U; c : U]Æ;
=TEX
=SML
end; (* local *)
=TEX
=SML
local
	val thm1 = prove_rule[ç_u_thm]
		¨µ x y ∑ Òx ç U ± yÆ § yÆ;
	val cnv1 = simple_eq_match_conv1 thm1;
	val cnv2 = simple_eq_match_conv1 ç_u_thm1;
	fun cnv3 tm = ((cnv1 THEN_C cnv3) ORELSE_C cnv2) tm;
	val cnv4 = simple_eq_match_conv1 (prove_rule[ç_u_thm]¨{x|T} = ÒUÆÆ);
in
val €∏_u_conv› : CONV = (fn tm =>
let	val dummy = dest_z_∏ tm;
	val s1 = simple_eq_match_conv1 (get_spec tm) tm;
	val s2 = conv_rule(RIGHT_C((BINDER_C cnv3) THEN_C cnv4)) s1;
in
	s2
end);
end;
=GFT Example
∏_u_conv ÒU ∏ U ∏ U ∏ UÆ;
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 _u_thm;
	val cnv2 = simple_eq_match_conv1 u_™_u_thm;
in
val €u_conv› : CONV = (fn tm => (
if fst(dest_ctype(type_of tm)) = "SET"
then
(case dest_z_term tm of
Z _ => cnv1 tm
| Z∏ _ => ∏_u_conv tm
| ZSeta _ => seta_u_conv tm
| Zâs _ => decsexp_u_conv tm
| ZGVar("_ ™ _",_,_) => cnv2 tm
| _ => term_fail "u_conv" 41060 [tm]
)
else term_fail "u_conv" 41060 [tm])
handle (Fail _) => term_fail "u_conv" 41060 [tm]);
end;
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 _u_thm;
	val cnv2 = simple_eq_match_conv1 ç_u_thm1;
	val cnv3 = simple_eq_match_conv1 u_™_u_thm;
	val thm1 = prove_rule [z_Ä_thm1,ç_u_thm] ¨µx:'a SET ∑ Ò(¨x:'a SETÆ Ä U) = trueÆÆ;
	val cnv4 = simple_eq_match_conv1 u_™_u_thm;
	val cnv5 = simple_eq_match_conv1 thm1;
	val thm2 = prove_rule [get_spec ¨$"Z'SchemaPred"Æ,ç_u_thm]
		¨µ x ∑ $"Z'SchemaPred" x ÒUÆ § TÆ;
	val cnv6 = simple_eq_match_conv1 thm2;
	
	fun dest_z_Ä tm = (
	let 	val (x,y) = dest_z_ç tm;
		val dummy = case dest_z_term y of
			ZGVar("_ Ä _",_,_) => ()
			| _ => term_fail "dest_z_Ä" 0 [tm];
		val (a1,a2) = case dest_z_term x of
			ZTuple[a1,a2] => (a1,a2)
			| _ => term_fail "dest_z_Ä" 0 [tm];
	in
		(a1,a2)
	end);
in
val €ç_u_conv› : CONV = (fn tm =>
let	val cse = (dest_z_Ä tm; 0)
		handle (Fail _) =>
		(dest_z_ç tm; 1)
		handle (Fail _) =>
		(dest_z_predsexp tm; 2)
		handle (Fail _) =>
		term_fail "ç_u_conv" 41062 [tm];
	fun aux tm1 = 
	case dest_z_term tm1 of
	Z _ => (RAND_C aux THEN_C cnv1) tm1
	| Z∏ _ => (RANDS_C aux THEN_C ∏_u_conv) tm1
	| ZSeta _ => ((RAND_C(ALL_SIMPLE_Ã_C(RATOR_C(LEFT_C (DECL_C1 (DEC_TYPES_C aux))))))
		THEN_C seta_u_conv) tm1
	| Zâs _ =>(RAND_C (ALL_SIMPLE_Ã_C(LEFT_C (DECL_C1 (DEC_TYPES_C aux)))) THEN_C decsexp_u_conv) tm1
	| ZGVar("_ ™ _",_,_) => (RAND_C(LEFT_C aux THEN_C RIGHT_C aux) THEN_C cnv3) tm1
	| ZGVar ("U",_,_) => id_conv tm1
	| _ => term_fail "ç_u_conv" 41061 [tm];
in
	case cse of
	0 => (LEFT_C(RAND_C aux) THEN_C cnv5) tm
	| 1 => (RIGHT_C aux THEN_C cnv2) tm
	| _ => (RIGHT_C aux THEN_C cnv6) tm
	handle (Fail _) =>
	term_fail "ç_u_conv" 41061 [tm]
end);
end;
=GFT
ç_u_conv Òx ç UÆ;
ç_u_conv Òx Ä UÆ;
RIGHT_C ç_u_conv Òtrue ± [a: U]Æ;
ç_u_conv Òx ç  UÆ;
ç_u_conv Òx ç  (U ∏ U)Æ;
ç_u_conv Òx ç {x:U; y: U}Æ;
ç_u_conv Òx ç  {x:U; y: U ∏ U}Æ;
ç_u_conv Òx ç [a ,b : U; c : U]Æ;
ç_u_conv Òx ç U ™ UÆ;
ç_u_conv Òx ç  (U ∏ U) ™ [a ,b : U; c : U]Æ;
ç_u_conv Ò{x,y} Ä  (U ∏ U) ™ [a ,b : U; c : U]Æ;
RIGHT_C ç_u_conv Òtrue ± [a ,b : U ∏ [a ,b : U; c : U]; c :  U]Æ;
ç_u_conv ÒtrueÆ; (* fails *)
ç_u_conv Òx ç  (U ∏ X)Æ; (* fails *)
ç_u_conv Ò{x,y} Ä  (U ∏ X)Æ; (* fails *)
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 z'µ_def;
	val cnv2 = simple_eq_match_conv1 z'µbody_def;
	val cnv3 = simple_eq_match_conv1 (taut_rule¨µ x ∑ T ± x § xÆ);
	fun cnv4 tm = ((cnv3 THEN_C cnv4) ORELSE_C id_conv) tm;
	val cnv5 = (simple_eq_match_conv1 (taut_rule¨µ x ∑ T ¥ x § xÆ) AND_OR_C
		simple_eq_match_conv1 (taut_rule¨µ x ∑ F ¥ x § TÆ) AND_OR_C
		simple_eq_match_conv1 (taut_rule¨µ x ∑ x ¥ F § ≥ xÆ) AND_OR_C
		simple_eq_match_conv1 (taut_rule¨µ x ∑ x ¥ T § TÆ) ORELSE_C
		id_conv);
in
val €z_µ_elim_conv1› :CONV = (fn tm =>
let	val cnv1' = (fn t => cnv1 t
		handle (Fail _) =>
		term_fail "z_µ_elim_conv1" 41022 [tm]);
	val cnv2' = (fn t => cnv2 t
		handle (Fail _) =>
		term_fail "z_µ_elim_conv1" 41022 [tm]);
	val cnv3' = (fn t => cnv3 t
		handle (Fail _) =>
		term_fail "z_µ_elim_conv1" 41071 [tm]);
in
	(cnv1' THEN_C ALL_SIMPLE_µ_C (cnv2' THEN_C LEFT_C(LEFT_C
		((DECL_C (dec_pred_conv THEN_C ç_u_conv)
		 ORELSE_C (fn tm1 => term_fail "z_µ_elim_conv1" 41071 [tm]))
		THEN_C cnv4)
		THEN_C cnv3')
		THEN_C cnv5))tm
end);
end;
=GFT Example
z_µ_elim_conv1 Òµ a,b : U; [c,d:U]; e:U | f ∑ gÆ;
z_µ_elim_conv1 Òµ a,b : U; [c,d:U]; e:U | true ∑ gÆ;
z_µ_elim_conv1 Òµ a,b : U; [c,d:U]; e:U | x ∑ trueÆ;
z_µ_elim_conv1 Òµ a,b : U; [c,d:U]; e:U | true ∑ falseÆ;
=TEX
\section{Concerning Z Universal Quantification}
=SML
local
	val cnv1 = simple_eq_match_conv1 z'µ_def;
	val cnv2 = simple_eq_match_conv1 z'µbody_def;
	val cnv3 = simple_eq_match_conv1 (eqn_sym_rule z'µbody_def);
	val cnv4 = simple_eq_match_conv1 (eqn_sym_rule z'µ_def);

 
in
val €z_µ_elim_conv› :CONV = 
	(cnv1 THEN_C ALL_SIMPLE_µ_C cnv2)
	ORELSE_C (fn tm => 
	term_fail "z_µ_elim_conv" 41022 [tm]
	);

val €z_µ_intro_conv› :CONV = (
all_µ_uncurry_conv AND_OR_C
(fn tm =>(
let	val (vs,bdy) = strip_simple_µ tm;
	val dummy = if is_nil vs
		then term_fail "z_µ_intro_conv" 41023 [tm]
		else ();
	val ((d,p),v) = (dest_± ** Combinators.I)(dest_¥ bdy);
	val dbind =  dest_decl d;
	val vs' = map dest_var vs;
	val vnames = map fst vs';
	val dummy = if vnames ~= (map fst dbind)
		then ()
		else term_fail "z_µ_intro_conv" 41024 [tm];
	val dummy = if all vs' (fn (nm,ty) => lassoc3 dbind nm =: ty)
		then ()
		else term_fail "z_µ_intro_conv" 41024 [tm];
	val s1 = cnv3 bdy;
	val s2 = fold (fn (x,t) => µ_§_rule x t) vs s1;
	val svs = var_sort vs';
	val rs2 = snd(dest_eq(concl s2));
	val rbs2 = snd(strip_simple_µ rs2);
	val s3 = µ_reorder_conv (list_mk_simple_µ (svs,rbs2)) rs2;
	val s4 = eq_trans_rule s2 s3;
	val s5 = conv_rule(RIGHT_C cnv4) s4;
	val dummy = check_is_z_term "z_µ_intro_conv" (snd(dest_eq(concl s5)));
in
	s5
end)
handle complaint =>
list_divert complaint "z_µ_intro_conv"
[("dest_±", 41023, [fn () => string_of_term tm]),
("dest_¥", 41023, [fn () => string_of_term tm]),
("dest_decl", 41023, [fn () => string_of_term tm])]
));
end;
=TEX
Examples:
=GFT
val thm1 = z_µ_elim_conv Òµ z:X; x,y : Ó  ∑ (x = 0) ≤ (y = 0) ≤ (z = z)Æ;
val tmr = snd(dest_eq(concl thm1));
z_µ_intro_conv tmr;
val (d,p,v) = dest_z_µ Òµ z:X; x,y : Ó  ∑ (x = 0) ≤ (y = 0) ≤ (z = z)Æ;
z_µ_intro_conv ¨µ x:˙∑ µ z:'a∑µ y:˙ ∑ ëdÆ ± ëpÆ ¥ ëvÆÆ;
=TEX

Compose a list of type instantiations, checking that we
are not send one type variable to two different types.
=SML
local 
	fun lrassoc5 ((a1,a2) :: x) v = (if a2 =: v
		then Value a1
		else lrassoc5 x v
	) | lrassoc5 [] v = Nil;
in
fun €compose_tyi› (tys : (TYPE * TYPE) list list) : (TYPE * TYPE) list = (
let	fun aux1 acc ((tyn,tyo) :: x) = (
		case lrassoc5 acc tyo of
		Nil => aux1 ((tyn,tyo) :: acc) x
		| Value tyn' => (if tyn =: tyn'
			then aux1 acc x
			else fail "compose_tyi" 0 [])
	) | aux1 acc [] = acc;

	fun aux acc [] = acc 
	| aux acc (a :: x) = aux (aux1 acc a) x;
in
	aux [] tys
end);
end;
=TEX
The following copes with three forms of $bind$ - 
a true binding, a single value, or an object with a binding type.
It returns the required specialisations and type instantiations for the decl.
=SML
fun €match_decl_tm› (caller : string) (decl : TERM) (tm: TERM) : (string * TERM) list * (TYPE * TYPE) list = (
let	val dbinds = dest_decl decl
		handle complaint =>
		pass_on complaint "dest_decl" caller;
	val dnms = map fst dbinds;
in
=TEX
Conventional binding:
=SML
(let	val tbinds = dest_z_binding tm;
	val dummy = if dnms ~= map fst tbinds
		then ()
		else fail "" 0 [];
	fun aux (nm,ty) = (
	let val v = lassoc3 tbinds nm;
		val tyi = type_match (type_of v) ty;
	in
		tyi
	end);
	val tys = map aux dbinds;
in
	(tbinds,compose_tyi tys)
end
handle (Fail _) =>
=TEX
Single variable in declaration:
=SML
	case dbinds of
	[(nm,ty)] => ([(nm,tm)],type_match (type_of tm) ty)
	| _ => fail "" 0 []
handle (Fail _) =>
=TEX
Term has a binding type:
=SML
let	val to_tm = type_of tm;
	val dbt_tm = dest_bind_type to_tm;
	val (_,projs) = get_binding_info to_tm;
	val projs' = map (fn f => match_mk_app(f,tm)) projs;
	val tbinds = combine(fst (split dbt_tm)) projs';
	val dummy = if dnms ~= map fst tbinds
		then ()
		else fail "" 0 [];
	fun aux (nm,ty) = (
	let val v = lassoc3 tbinds nm;
		val tyi = type_match (type_of v) ty;
	in
		tyi
	end);
	val tys = map aux dbinds;
in
	(tbinds,compose_tyi tys)
end
handle (Fail _) =>
term_fail caller 41021 [tm,decl]
)
end);
=TEX
Tests:
=GFT
val (d,_,_) = dest_z_µ Òµx,y : Z; z : Y ∑ trueÆ;
val (d1,_,_) = dest_z_µ Òµx : Z∑ trueÆ;
val tm1 = Ò(y ¶ 1, x ¶ 2, z ¶ y)Æ;

match_decl_tm "hello" d tm1;
match_decl_tm "hello" d (mk_var("B",type_of tm1));
match_decl_tm "hello" d1 ¨1Æ;
=TEX
=SML
fun €µ_elim_by_template› (template : (string * TERM)list)(thm : THM) : THM = (
let	val (vs,_) = strip_simple_µ (concl thm);
	val exps = map (lassoc3 template) (map (fst o dest_var) vs);
in
	list_simple_µ_elim exps thm
end);
=SML
local
	val cnv1 = simple_eq_match_conv1 z'µ_def;
	val cnv2 = simple_eq_match_conv1 z'µbody_def;
in
fun €z_µ_elim› (tm : TERM) (thm : THM) : THM = (
let	val (d,p,v) = dest_z_µ (concl thm)
		handle complaint =>
		pass_on complaint "dest_z_µ" "z_µ_elim";
	val (specs,insts) = match_decl_tm "z_µ_elim" d tm;
	val s1 = conv_rule cnv1 thm;
	val s2 = inst_type_rule insts s1
		handle complaint =>
		pass_on complaint "inst_type_rule" "z_µ_elim";
	val s3 = µ_elim_by_template specs s2;
	val s4 = conv_rule cnv2 s3;
	val s5 = conv_rule (LEFT_C(LEFT_C (DECL_C dec_pred_conv))) s4;
	val s6 = check_is_z_thm "z_µ_elim" s5;
		(* should actually make any renaming changes
		   the declaration to the thm *)
in
	s6
end);
end;
=TEX
=GFT
z_µ_elim Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ, z ¶ ¨p:'aÆ)Æ
	(asm_ruleÒµ x:X; y:Y; z:X | f x ∑ g y zÆ);

z_µ_elim  Ò(x ¶ ¨q:'aÆ, y ¶ ¨r:'bÆ, z ¶ ¨p:'aÆ)Æ
	(asm_rule Òµ x:X; y:Y; z:X | f x ∑ g ¨a + bÆ zÆ);
=TEX
=SML
local
	val sym_z'µbody_def = eqn_sym_rule z'µbody_def;
	val sym_z'µ_def = eqn_sym_rule z'µ_def;
	val cnv1 = simple_eq_match_conv1 (taut_rule ¨µ x y ∑ (x ¥ y) § ((x ± T) ¥ y)Æ);
in
fun €z_µ_intro› (thm : THM) : THM = (
let	val (dp,v) = dest_¥ (concl thm)
		handle complaint =>
		divert complaint "dest_¥" "z_µ_intro"
			41026 [fn () => string_of_thm thm];
in
	if ((DECL_INTRO_C pred_dec_conv dp;true)handle (Fail _) => false)
	then z_µ_intro (conv_rule cnv1 thm)
	else (
let
	val (d,p) = dest_± dp
		handle complaint =>
		divert complaint "dest_±" "z_µ_intro"
			41026 [fn () => string_of_thm thm];
	val s1 = conv_rule (LEFT_C(LEFT_C (DECL_INTRO_C pred_dec_conv))) thm
		handle (Fail _) =>
		term_fail "z_µ_intro" 41027 [d];
	val ((d',_),_) = (dest_± ** Combinators.I)(dest_¥ (concl s1));
	val dest_vs = dest_decl d';
	val s2 = §_mp_rule (list_simple_µ_elim[d',p,v] 
		sym_z'µbody_def) s1;
	val sl = idsetseq(fst(split dest_vs));
	val vs = map (fn nm => mk_var(nm,lassoc3 dest_vs nm)) sl;
	val s3 = list_simple_µ_intro vs s2
		handle complaint =>
		pass_on complaint "list_simple_µ_intro" "z_µ_intro";
	val s4 = §_mp_rule  (simple_µ_elim(concl s3) sym_z'µ_def) s3;
in
	check_is_z_thm "z_µ_intro" s4
end)
end)
end;
=TEX
Examples
=GFT
let val tm1 = Ò((x ç W ± y ç X) ± (w ç Y) ± (z ç Z)) ± f x ¥ g w y zÆ
in
z_µ_intro (all_µ_elim (asm_rule
	(list_mk_µ(frees tm1, tm1))
	))
end;

z_µ_intro (all_µ_elim (asm_rule
	¨µ w x z ∑
	((x ç W ± y ç X) ± (w ç Y) ± (z ç Z)) ± f x ¥ g w y zÆ)); (* fails *)

=TEX
Our strategy in the following is to get something that
$z\_µ\_intro$ will accept (perhaps) and then call that.
=SML
local
	val ut= ÒUÆ;
	val tya = î'aÆ;
	fun mk_ç_u tm = mk_z_ç(tm,inst [][(type_of tm,tya)] ut);
	val thm1 = prove_rule[]¨µ d d' p v ∑
		(d ± p ¥ v) ¥ ((d ± d') ± p ¥ v)Æ;
	val thm2 = prove_rule[]¨µ dp d' v ∑
		(dp ¥ v) ¥ (d' ± dp ¥ v)Æ;
	val thm3 = prove_rule[]¨µ d' v ∑
		(v) ¥ (d' ± T ¥ v)Æ;
in
fun €z_µ_intro1› (tml: TERM list) (thm : THM) : THM = ((
let 	val cthm = concl thm;
	val dummy = map dest_var tml
		handle complaint =>
		pass_on complaint "dest_var" "z_µ_intro1";
	val tml_ç1 = if is_nil tml
		then Nil
		else Value(list_mk_±(map mk_ç_u tml));
in
	if is_¥ cthm
	then (let val (dp,v) = dest_¥ cthm;
	in
		if is_± dp
		then (let val (d,p) = dest_± dp;
		in
		case tml_ç1 of
		Nil => z_µ_intro thm
		| Value tml_ç => z_µ_intro (¥_elim(list_µ_elim[d,tml_ç,p,v] thm1) thm)
		end)
		else (
		case tml_ç1 of
		Nil => thm_fail "z_µ_intro1" 41028 [thm]
		| Value tml_ç => z_µ_intro (¥_elim(list_µ_elim[dp,tml_ç,v] thm2) thm)
		)
	end)
	else
	case tml_ç1 of
	Nil => thm_fail "z_µ_intro1" 41028 [thm]
	| Value tml_ç => (z_µ_intro (¥_elim(list_µ_elim[tml_ç,cthm] thm3) thm))
end)
handle complaint =>
pass_on complaint "z_µ_intro" "z_µ_intro1");
end;
=TEX
=GFT
z_µ_intro1 [] (all_µ_elim (asm_rule
	¨µ w x y z ∑
	((x ç W ± y ç X) ± (w ç Y) ± (z ç Z)) ± f x ¥ g w y zÆ));
z_µ_intro1 [Òx1Æ,ÒpÆ] (all_µ_elim (asm_rule
	¨µ w x y z ∑
	((x ç W ± y ç X) ± (w ç Y) ± (z ç Z)) ± f x ¥ g w y zÆ));
z_µ_intro1 [Òx1Æ,ÒpÆ] (all_µ_elim (asm_rule
	¨µ w x y z ∑
	f x ¥ g w y zÆ));
z_µ_intro1 [Òx1Æ,ÒpÆ] (all_µ_elim (asm_rule
	¨µ w y z ∑
	g w y zÆ));
=TEX
In the following we know we drop out of Z temporarily, and protect
against warnings of such.
=SML
local
fun Z_µ_V_C cnv = RAND_C(ALL_SIMPLE_µ_C(RIGHT_C cnv));
val cnv1 = simple_eq_match_conv1 comb_i_def;
in
fun €all_z_µ_intro› (thm : THM) : THM = (
let	val (asms,conc) = dest_thm thm;
	val fs = rev(frees conc term_diff (flat(map frees asms)));
	val thm1 = §_mp_rule (eq_sym_rule(µ_elim conc comb_i_def)) thm;
	val was_check_flag = set_flag("check_is_z",false);
	val thm2 = z_µ_intro1 fs thm1;
	val restore_check_flag = set_flag("check_is_z",was_check_flag);
	val thm3 = conv_rule (Z_µ_V_C cnv1) thm2
in
	check_is_z_thm "all_z_µ_intro" thm3
end
handle (Fail _) => thm);
end;
=TEX
=GFT
all_z_µ_intro (refl_conv Ò(x,y)Æ);
all_z_µ_intro (¥_intro Òa ± bÆ (asm_rule Òa ± bÆ));
=SML
local
val cnv1 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ (t § (T ¥ t)) § TÆ);
val cnv2 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ F ¥ t § TÆ);
val thm1 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(simple_µ_intro ¨d:BOOLÆ
	(list_simple_µ_elim[¨d:BOOLÆ, mk_f] z'µbody_def));
val cnv3 = simple_eq_match_conv1 thm1;
val tac1 = pure_rewrite_tac[z'µ_def,µ_rewrite_thm,
	eq_rewrite_thm];
val cnv4 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ (t § (t ≤ F)) § TÆ);
val cnv5 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ t ≤ T § TÆ);
val thm2 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(list_simple_µ_intro [¨d:BOOLÆ,¨p:BOOLÆ]
	(list_simple_µ_elim[¨d:BOOLÆ, ¨p:BOOLÆ, mk_t] z'µbody_def));
val cnv6 = simple_eq_match_conv1 thm2;
val cnv7 = simple_eq_match_conv1 (taut_rule ¨µ s t ∑ (t ¥ (s ≤ T)) § TÆ);
val cnv8 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ (t § (T ¥ (t ≤ F))) § TÆ);
fun Z_µ_P_C cnv = RAND_C(ALL_SIMPLE_µ_C(LEFT_C cnv));
fun Z_µ_V_C cnv = RAND_C(ALL_SIMPLE_µ_C(RIGHT_C cnv));

fun cnv9 thm = APP_C(RAND_C(Z_µ_P_C(fn _ => thm)),(LEFT_C(fn _ => thm)));
fun cnv10 thm = APP_C(RAND_C(Z_µ_V_C(fn _ => thm)),(RIGHT_C(fn _ => thm)));
fun cnv11 thm = APP_C(RAND_C(Z_µ_V_C(fn _ => thm)),RIGHT_C(RIGHT_C(fn _ => thm)));

in
val €z_µ_inv_conv› : CONV = (fn tm => 
let	val (d,p,v) = dest_z_µ tm
		handle complaint =>
		pass_on complaint "dest_z_µ" "z_µ_inv_conv";
	val vs = fst(strip_simple_µ(snd(dest_app tm)));
in
	case (any (frees p) (fn x => x term_mem vs) orelse (is_t p),
		any (frees v) (fn x => x term_mem vs) orelse (is_f v)) of
 	(true, true) => term_fail "z_µ_inv_conv" 41025 [tm]
	| (false, true) => tac_proof(([],mk_eq(tm,
			mk_¥(p,mk_z_µ(d,mk_t,v)))),
		≤_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv1,
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv3))), cnv2)) THEN
		tac1] )
	| (true, false) =>  tac_proof(([],mk_eq(tm,
			mk_≤(mk_z_µ(d,p,mk_f),v))),
		≤_THEN (conv_tac o cnv10) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv6))), cnv5)) THEN
		tac1,
		conv_tac cnv4] )
	| (false,false) => tac_proof(([],mk_eq(tm,
			mk_¥(p,mk_≤(mk_z_µ(d,mk_t,mk_f),v)))),
		≤_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) THEN
		≤_THEN (conv_tac o cnv11) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv6)), cnv7)) THEN
		tac1,
		conv_tac cnv8,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv6)), cnv7)) THEN
		tac1,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv3)), cnv2)) THEN
		tac1		
		])
end);
end;
=TEX
Examples:
=GFT
z_µ_inv_conv Òµ x ,y : X | f ∑ gÆ;
z_µ_inv_conv Òµ x ,y : X | x > 0 ∑ zÆ;
z_µ_inv_conv Òµ x,y : X | f ∑ x = yÆ;
z_µ_inv_conv Òµ x,y : X ∑ gÆ;
z_µ_inv_conv Òµ x,y : X | f∑ falseÆ;
=TEX
=SML	
fun €z_µ_intro_tac› (d: TERM) : TACTIC = (
let	val binds = (dest_z_binding d);
	val decl_as_pred_thm = list_±_intro(map (fn (y,x) => µ_elim x ç_u_thm) binds);
	val decl_as_pred_thm' = conv_rule(DECL_INTRO_C pred_dec_conv) decl_as_pred_thm;	
	val decl_as_pred_thm'' = ±_intro decl_as_pred_thm' t_thm;
	val iµ_arg = map (fn (x,y) => (y,mk_var(x,type_of y))) binds;
in
	CHECK_IS_Z_T "z_µ_intro_tac" 
	(ante_tac decl_as_pred_thm'' THEN
	MAP_EVERY intro_µ_tac iµ_arg THEN
	conv_tac z_µ_intro_conv)
end
handle complaint =>
if area_of complaint = "dest_z_binding"
then term_fail "z_µ_intro_tac" 41029 [d]
else pass_on complaint "intro_µ_tac" "z_µ_intro_tac"
);
=GFT Examples
push_goal([],Òa ± b ± cÆ);
a(z_µ_intro_tac Ò(d ¶ ¨b:BOOLÆ, e ¶ ¨a:BOOLÆ)Æ);
drop_main_goal();
(* To demonstrate wrecking a binding *)
push_goal([],Òa ± b ± [p,q:X| p = q]Æ);
a(z_µ_intro_tac Ò(c ¶ ¨b:BOOLÆ, d ¶ ¨p:'aÆ)Æ);
drop_main_goal();
=TEX
\section{Concerning Z Existential Quantification}
=SML
local
val cnv1 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ (t § (T ± t)) § TÆ);
val cnv2 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ F ± t § FÆ);
val thm1 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(simple_µ_intro ¨d:BOOLÆ
	(list_simple_µ_elim[¨d:BOOLÆ, mk_f] z'∂body_def));
val cnv3 = simple_eq_match_conv1 thm1;
val tac1 = pure_rewrite_tac[z'∂_def,∂_rewrite_thm,
	eq_rewrite_thm];
val cnv4 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ (t § (t ± T)) § TÆ);
val cnv5 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ t ± F § FÆ);
val thm2 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(list_simple_µ_intro [¨d:BOOLÆ,¨p:BOOLÆ]
	(list_simple_µ_elim[¨d:BOOLÆ, ¨p:BOOLÆ, mk_f] z'∂body_def));
val cnv6 = simple_eq_match_conv1 thm2;
val cnv7 = simple_eq_match_conv1 (taut_rule ¨µ s t ∑ (t ± s ± F) § FÆ);
val cnv8 = simple_eq_match_conv1 (taut_rule ¨µ t ∑ (t § (T ± t ± T)) § TÆ);
fun Z_∂_P_C cnv = RAND_C(ALL_SIMPLE_∂_C(LEFT_C cnv));
fun Z_∂_V_C cnv = RAND_C(ALL_SIMPLE_∂_C(RIGHT_C cnv));

fun cnv9 thm = APP_C(RAND_C(Z_∂_P_C(fn _ => thm)),(LEFT_C(fn _ => thm)));
fun cnv10 thm = APP_C(RAND_C(Z_∂_V_C(fn _ => thm)),(RIGHT_C(fn _ => thm)));
fun cnv11 thm = APP_C(RAND_C(Z_∂_V_C(fn _ => thm)),RIGHT_C(RIGHT_C(fn _ => thm)));

in
val €z_∂_inv_conv› : CONV = (fn tm => 
let	val (d,p,v) = dest_z_∂ tm
		handle complaint =>
		pass_on complaint "dest_z_∂" "z_∂_inv_conv";
	val vs = fst(strip_simple_∂(snd(dest_app tm)));
in
	case (any (frees p) (fn x => x term_mem vs) orelse  (is_t p),
		any (frees v) (fn x => x term_mem vs) orelse (is_t v)) of
 	(true, true) => term_fail "z_∂_inv_conv" 41040 [tm]
	| (false, true) => tac_proof(([],mk_eq(tm,
			mk_±(p,mk_z_∂(d,mk_t,v)))),
		≤_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv1,
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_∂_C cnv3))), cnv2)) THEN
		tac1] )
	| (true, false) =>  tac_proof(([],mk_eq(tm,
			mk_±(mk_z_∂(d,p,mk_t),v))),
		≤_THEN (conv_tac o cnv10) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv4,
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_∂_C cnv6))), cnv5)) THEN
		tac1] )
	| (false,false) => tac_proof(([],mk_eq(tm,
			mk_±(p,mk_±(mk_z_∂(d,mk_t,mk_t),v)))),
		≤_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) THEN
		≤_THEN (conv_tac o cnv11) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv8,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_∂_C cnv6)), cnv7)) THEN
		tac1,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_∂_C cnv3)), cnv2)) THEN
		tac1,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_∂_C cnv6)), cnv7)) THEN
		tac1
		])
end);
end;
=TEX
Examples:
=GFT
z_∂_inv_conv Ò∂ x ,y : X | f ∑ gÆ;
z_∂_inv_conv Ò∂ x ,y : X | x > 0 ∑ zÆ;
z_∂_inv_conv Ò∂ x,y : X | f ∑ x = yÆ;
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 z'∂_def;
	val cnv2 = simple_eq_match_conv1 z'∂body_def;
	val cnv3 = simple_eq_match_conv1 (eqn_sym_rule z'∂body_def);
	val cnv4 = simple_eq_match_conv1 (eqn_sym_rule z'∂_def);
in
val €z_∂_elim_conv› :CONV = 
	(cnv1 THEN_C ALL_SIMPLE_∂_C cnv2)
	ORELSE_C (fn tm =>
	term_fail "z_∂_elim_conv" 41044 [tm]);

val €z_∂_intro_conv› :CONV = (
all_∂_uncurry_conv AND_OR_C
(fn tm =>
let	val (vs,bdy) = strip_simple_∂ tm;
	val duimmy = if is_nil vs
		then term_fail "z_∂_intro_conv"  41045 [tm]
		else ();
	val (d,(p,v)) = (Combinators.I ** dest_±)(dest_± bdy)
		handle complaint =>
		divert complaint "dest_±" "z_∂_intro_conv"  41045 [fn () => string_of_term tm];
	val dbind =  dest_decl d;
	val vs' = map dest_var vs;
	val vnames = map fst vs';
	val dummy = if vnames ~= (map fst dbind)
		then ()
		else term_fail "z_∂_intro_conv" 41041 [tm];
	val dummy = if all vs' (fn (nm,ty) => lassoc3 dbind nm =: ty)
		then ()
		else term_fail "z_∂_intro_conv" 41041 [tm];
	val s1 = cnv3 bdy;
	val s2 = fold (fn (x,t) => ∂_§_rule x t) vs s1;
	val svs = var_sort vs';
	val rs2 = snd(dest_eq(concl s2));
	val rbs2 = snd(strip_simple_∂ rs2);
	val s3 = ∂_reorder_conv (list_mk_simple_∂ (svs,rbs2)) rs2;
	val s4 = eq_trans_rule s2 s3;
	val s5 = conv_rule(RIGHT_C cnv4) s4;
	val dummy = check_is_z_term "z_∂_intro_conv" (snd(dest_eq(concl s5)));
in
	s5
end));
end;
=TEX
Examples:
=GFT
val thm1 = z_∂_elim_conv Ò∂ z:X; x,y : Ó  ∑ (x = 0) ≤ (y = 0) ≤ (z = z)Æ;
val tmr = snd(dest_eq(concl thm1));
z_∂_intro_conv tmr;
val (d,p,v) = dest_z_∂ Ò∂ z:X; x,y : Ó  ∑ (x = 0) ≤ (y = 0) ≤ (z = z)Æ;
z_∂_intro_conv ¨∂ x:˙∑ ∂ z:'a∑∂ y:˙ ∑ ëdÆ ± ëpÆ ± ëvÆÆ;
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 z'∂_def;
	val cnv2 = simple_eq_match_conv1 z'∂body_def;
	val cnv3 = simple_eq_match_conv1 (taut_rule¨µ x ∑ T ± x § xÆ);
	fun cnv4 tm = ((cnv3 THEN_C cnv4) ORELSE_C id_conv) tm;
	val cnv5 = cnv3 AND_OR_C
		simple_eq_match_conv1 (taut_rule¨µ x ∑ x ± T § xÆ) AND_OR_C
		simple_eq_match_conv1 (taut_rule¨µ x ∑ F ± x § FÆ) AND_OR_C
		simple_eq_match_conv1 (taut_rule¨µ x ∑ x ± F § FÆ) ORELSE_C
		id_conv
in
val €z_∂_elim_conv1› :CONV = (fn tm =>
let	val cnv1' = (fn t => cnv1 t
		handle (Fail _) =>
		term_fail "z_∂_elim_conv1" 41042 [tm]);
	val cnv2' = (fn t => cnv2 t
		handle (Fail _) =>
		term_fail "z_∂_elim_conv1" 41042 [tm]);
	val cnv3' = (fn t => cnv3 t
		handle (Fail _) =>
		term_fail "z_∂_elim_conv1" 41043 [tm]);
in
	(cnv1' THEN_C ALL_SIMPLE_∂_C (cnv2' THEN_C LEFT_C 
		((DECL_C (dec_pred_conv THEN_C ç_u_conv)
		 ORELSE_C (fn tm1 => term_fail "z_∂_elim_conv1" 41043 [tm]))
		THEN_C cnv4)
		THEN_C cnv3'
		THEN_C cnv5))tm
end);
end;
=GFT Example
z_∂_elim_conv1 Ò∂ a,b : U; [c,d:U]; e:U | f ∑ gÆ;
z_∂_elim_conv1 Ò∂ a,b : U; [c,d:U]; e:U  ∑ gÆ;
=TEX
The following copes with three forms of $bind$ - 
a true binding, a single value, or an object with a binding type.
It returns the association of names to required type instantiated terms.
It is very similar to $match\_decl\_tm$ above.
=SML
fun €match_tm_decl› (caller : string) (decl : TERM) (tm: TERM) : (string * TERM) list = (
let	val dbinds = dest_decl decl
		handle complaint =>
		pass_on complaint "dest_decl" caller;
	val dnms = map fst dbinds;
in
=TEX
Conventional binding:
=SML
(let	val tbinds = dest_z_binding tm;
	val dummy = if dnms ~= map fst tbinds
		then ()
		else fail "" 0 [];
	fun aux (nm,ty) = (
	let val v = lassoc3 tbinds nm;
		val tyi = type_match ty (type_of v);
	in
		tyi
	end);
	val tys = map aux dbinds;
	val ctys = compose_tyi tys;
in
	map (fn (nm,tm) => (nm, inst [] ctys tm)) tbinds
end
handle (Fail _) =>
=TEX
Single variable in declaration:
=SML
	case dbinds of
	[(nm,ty)] => ([(nm,inst [] (type_match ty (type_of tm)) tm)])
	| _ => fail "" 0 []
handle (Fail _) =>
=TEX
Term has a binding type:
=SML
let	val to_tm = type_of tm;
	val dbt_tm = dest_bind_type to_tm;
	val (_,projs) = get_binding_info to_tm;
	val projs' = map (fn f => match_mk_app(f,tm)) projs;
	val tbinds = combine(fst (split dbt_tm)) projs';
	val dummy = if dnms ~= map fst tbinds
		then ()
		else fail "" 0 [];
	fun aux (nm,ty) = (
	let val v = lassoc3 tbinds nm;
		val tyi = type_match ty (type_of v);
	in
		tyi
	end);
	val tys = map aux dbinds;
	val ctys = compose_tyi tys;
in
	map (fn (nm,tm) => (nm, inst [] ctys tm)) tbinds
end
handle (Fail _) =>
term_fail caller 41021 [tm,decl]
)
end);
=TEX
=GFT Examples
val (d,_,_) = dest_z_µ Òµx,y : Ó; z : X ∑ trueÆ;
val (d1,_,_) = dest_z_µ Òµx : ˙ ∑ trueÆ;
val tm1 = Ò(y ¶ ¨a:'aÆ, x ¶ 1, z ¶ ¨b:'aÆ)Æ;
fun aux (nm,tm) = (nm,tm,type_of tm);
map aux (match_tm_decl "hello" d tm1);
map aux (match_tm_decl "hello" d (mk_var("B",type_of tm1)));
map aux (match_tm_decl "hello" d1 Ò1Æ);
=TEX
=SML
fun €∂_by_template_tac› (template : (string * TERM)list) :TACTIC = (
let	fun aux (asms,conc) = (
	let	val (x,bdy) = dest_simple_∂ conc;
		val wit = lassoc3 template (fst(dest_var x));
	in
		simple_∂_tac wit (asms,conc)
	end);
in
	REPEAT aux
end);
=SML
local
	val cnv1 = simple_eq_match_conv1 z'∂_def;
	val cnv2 = simple_eq_match_conv1 z'∂body_def;
in
fun €z_∂_tac› (tm : TERM): TACTIC = (fn (asms,conc) =>
let	val (d,p,v) = dest_z_∂ conc
		handle complaint =>
		pass_on complaint "dest_z_∂" "z_∂_tac";
	val wittemp = match_tm_decl "z_∂_tac" d tm;
in
	CHECK_IS_Z_T "z_∂_tac" (conv_tac cnv1 THEN
	∂_by_template_tac wittemp THEN
	conv_tac cnv2 THEN
	conv_tac (LEFT_C (DECL_C dec_pred_conv))) (asms,conc)
end);
end;
=GFT Examples
(* in which [p,q:Ó | p = q] ceases to be Z when specialised *)
push_goal([],Ò∂ a,b : Ó; c : X; [p,q:Ó | p = q] ∑
	(a = p) ± (b = q) ± (c = c)Æ);
val tm = Ò(b ¶ ¨b:'aÆ, a ¶ ¨a:'aÆ, c ¶ ¨cc:'zÆ, p ¶ 5, q ¶ 6)Æ;
a(z_∂_tac tm);
undo 1;
a(z_∂_tac (mk_var("w",type_of tm)));
drop_main_goal();
push_goal([],Ò∂ p :Ó ∑ p = 1Æ);
a(z_∂_tac Ò1Æ);
a(rewrite_tac[]);
drop_main_goal();
=TEX
\subsection{Concerning Õ}
=INLINEFT
¨$"Z'Õ"Æ
=TEX
{} is a sort of marker function for Z $Õ$ constructions.
=SML
val €z'Õ_def› = get_spec ¨$"Z'Õ"Æ;
val €z'Õ_thm› = (
push_goal([],¨µ s x ∑ (µ y ∑ y ç s ¥ y = x) ± (x ç s) ¥ ($"Z'Õ" s = x)Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨s = {x}Æ (fn x => rewrite_tac [z'Õ_def,x]));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
pop_thm());
=TEX
=FRULE 1 Conversion
ante_∂_¥_conv
¨(∂ x ∑ p[x]) ¥ yÆ
˜
˜
Ù ((∂ x ∑ p[x]) ¥ y) § µ x ∑ p[x] ¥ y
=TEX
=SML
val €ante_∂_¥_thm›  = (
push_goal ([],¨µ p q ∑ (($∂ p) ¥ q) § µ x ∑ p x ¥ qÆ);
a(REPEAT µ_tac);
a(pure_once_rewrite_tac[prove_rule[]¨p = (Ã y ∑ p y)Æ]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (ante_tac o rewrite_rule[]));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[]));
a(asm_fc_tac[]);
pop_thm());

val €ante_∂_¥_conv› : CONV = (fn tm =>
let	val (∂p,q) = dest_¥ tm;
	val xnm = fst(dest_var(fst(dest_simple_∂ ∂p)));
	val p = snd(dest_app ∂p);
	val s1 = list_µ_elim[p,q] ante_∂_¥_thm;
	val s2 = conv_rule(RIGHT_C(RAND_C(simple_¡_conv xnm
		THEN_C SIMPLE_Ã_C(LEFT_C simple_¬_conv)))) s1;
in
	eq_trans_rule (refl_conv tm) s2
end);
=TEX
=SML
fun (seq_ante_∂_¥_conv:CONV) (tm:TERM) = ((
	(ante_∂_¥_conv THEN_C BINDER_C seq_ante_∂_¥_conv)
	ORELSE_C id_conv)
	tm
);
=GFT Example
ante_∂_¥_conv ¨(∂ x y z ∑ f x y z) ¥ gÆ;
seq_ante_∂_¥_conv ¨(∂ x y z ∑ f x y z) ¥ gÆ;

=TEX
=SML
=TEX
=SML
fun (seq_simple_¬_conv:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX
=SML
fun (€seq_≥_simple_∂_conv› : CONV) tm = ((≥_simple_∂_conv THEN_C 
		BINDER_C seq_≥_simple_∂_conv) ORELSE_C
		id_conv) tm;
=TEX
=SML
val €hd_last_µ_conv› : CONV = (fn tm =>
let 	val (hdv,bdy) = dest_simple_µ tm;
	val (vs,bdy') = strip_simple_µ bdy;
in
	µ_reorder_conv (list_mk_µ((vs @ [hdv]), bdy')) tm
end);
=TEX
=SML
local

val thm1 = (
push_goal([],¨µ a b c d ∑ 
	(µ y ∑ (a ± b ± (c = y)) ¥ (y = d)) §
	(a ± b ¥ (c = d))Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim ¨cÆ));
(* *** Goal "2" *** *)
a(POP_ASM_T(asm_rewrite_thm_tac o eq_sym_rule));
pop_thm());

	val cnv1 = simple_eq_match_conv1 thm1; 
in
fun €z_Õ_rule› (tm : TERM) :THM = (
let	val (d,p,v) = dest_z_Õ tm
		handle complaint =>
		pass_on complaint "dest_z_Õ" "z_Õ_rule";
	val vars =  map (fst o dest_var)
		(list_variant(map mk_var (term_vars tm))
		(map (fn x => mk_var(x,BOOL))["x","x","y"]));
	val var_x = hd (tl vars);
	val var_x1 = hd vars;
	val var_y = hd (tl(tl vars));
	val spec = conv_rule (BINDER_C(RIGHT_C(RAND_C(RAND_C
		(simple_¡_conv var_x))))) (get_spec tm);
	val s1 = simple_eq_match_conv1 spec tm;
	val s2 = conv_rule (RIGHT_C(RAND_C(BINDER_C
		(ALL_SIMPLE_∂_C(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		((RAND_C (fn _ => ¬red_thm)) THEN_C d_dpv_proj_conv),
		((RAND_C (fn _ => ¬red_thm)) THEN_C p_dpv_proj_conv),
		(LEFT_C((RAND_C (fn _ => ¬red_thm))THEN_C v_dpv_proj_conv))] tm
		end))))) s1;
	val was_sig = fst(strip_Ã(snd(dest_app tm)));
	val s3 = conv_rule (RIGHT_C(RAND_C(BINDER_C
		(seq_binder_simple_¡_conv was_sig)))) s2;
	val new_set = snd(dest_app(snd(dest_eq (concl s3))));
	val z'Õ_thm' = conv_rule (BINDER_C
		(RAND_C (simple_¡_conv var_x1 THEN_C
		SIMPLE_Ã_C (LEFT_C(LEFT_C(RAND_C(simple_¡_conv var_y))))))) z'Õ_thm;
	val s4 = conv_rule (BINDER_C(RIGHT_C(LEFT_C(
		fn tm => (if tm =$ snd(dest_eq (concl s3))
			then eq_sym_rule s3
			else term_fail "z_Õ_rule" 0 [])))))
		(µ_elim new_set z'Õ_thm');
	val s5 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(BINDER_C((LEFT_C
				simple_ç_comp_conv)
			THEN_C seq_ante_∂_¥_conv)),
			simple_ç_comp_conv THEN_C z_∂_intro_conv)))) s4;
	val s6 = conv_rule(BINDER_C(LEFT_C(LEFT_C(
		hd_last_µ_conv THEN_C
		LAST_SIMPLE_µ_C cnv1 THEN_C
		z_µ_intro_conv)
		))) s5;
in
	check_is_z_thm "z_Õ_rule" s6
end);
end;
=TEX
=GFT Example
z_Õ_rule ÒÕ x,y:X;z:Y;p:X | z ∑ x = yÆ;
z_Õ_rule ÒÕ x,y:X;z:Y;p:X | z ∑ p(x = y)Æ;
=TEX
\subsection{Concerning Function Application}
=SML
val €z_app_thm› = (
push_goal([],¨µ f a ∑ Òf a = (Õ f_a :U | (a,f_a) ç f ∑ f_a)ÆÆ);
a(REPEAT µ_tac);
let val (lhs,rhs) = dest_eq(snd(top_goal()));
in
a(rewrite_tac[dpv_proj_thm, get_spec lhs, get_spec rhs])
end;
a(conv_tac (ONCE_MAP_C (DECL_C dec_pred_conv)));
a(conv_tac (ONCE_MAP_C ç_u_conv));
a(rewrite_tac[]);
a(conv_tac (ONCE_MAP_C prove_∂_conv));
a(rewrite_tac[]);
pop_thm());
=TEX
=SML
val €z_app_conv› :CONV = simple_eq_match_conv1 z_app_thm
	ORELSE_C (fn tm => term_fail "z_app_conv" 47190 [tm]);
=TEX
=SML
val €z'app_def› = get_spec Òf aÆ;
local
val thm1 = simple_eq_match_conv1 z'app_def Òf aÆ;
val thm2 = all_µ_intro(
		rewrite_rule[] (
		µ_elim ¨{f_a:'b|Ò(¨a:'aÆ,¨f_a:'bÆ) ç fÆ}Æ 
		z'Õ_thm));
val thm3 = all_µ_intro(
push_goal([],Ò(µ f_a:U | (a, f_a) ç f ∑ f_a = x) ±
	(a,x) ç f
	¥
	(f a = x)Æ);
a(REPEAT strip_tac);
a(rewrite_tac[thm1]);
a(strip_asm_tac(list_µ_elim[¨aÆ,¨fÆ,¨xÆ] thm2));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule z_µ_elim_conv1));
a(asm_fc_tac[]);
pop_thm());
		
in
fun €z_app_rule› (tm : TERM) : THM = (
let	val  (f,a) = dest_z_app tm
		handle complaint =>
		pass_on complaint "dest_z_app" "z_app_rule";
	val var_x = string_variant (map fst (term_vars tm)) "x";
in
	check_is_z_thm "z_app_rule" (conv_rule (RAND_C (simple_¡_conv var_x))
		(list_µ_elim[a,f] thm3))
end);
end;

=GFT Example
z_app_rule Òp 1Æ;
z_app_rule Òp xÆ;
=TEX
=SML
local
	val thm1 = taut_rule ¨µ x ∑ x § (x § T)Æ;
	val cnv1 = simple_eq_match_conv1 thm1;
in
fun (€z_app_tac› : TACTIC) ((asms,conc):GOAL) = (
	if not(is_z_eq conc) andalso is_z_app conc
	then (conv_tac cnv1 THEN z_app_tac)(asms,conc)
	else
let	val (fa,v) = dest_z_eq conc
		handle complaint as (Fail _) =>
		dest_z_§ conc
		handle complaint as (Fail _) =>
		(divert complaint "dest_eq" "z_app_tac" 41090 []);
in
	if is_z_app fa
	then ¥_thm_tac (simple_µ_elim v (z_app_rule fa))(asms,conc)
	else if is_z_app v
	then ¥_thm_tac (conv_rule(RIGHT_C eq_sym_conv)
		(simple_µ_elim fa (z_app_rule v)))(asms,conc)
	else fail "z_app_tac" 41090 []
end);
end;
=GFT Example
set_goal([],Òp 1 = 2Æ);
a(z_app_tac);
set_goal([],Ò2 = p 1Æ);
a(z_app_tac);
set_goal([],Ò¨r:(˙, BOOL) $"Z'T[2]" SETÆ 1Æ);
a(z_app_tac);
drop_main_goal();
=TEX
\subsection{Concerning Ã}
=SML
local
val x = mk_var("x",type_of Ò(x,y)Æ);
in
val €p1_q2_thm› = all_µ_intro(
push_goal([],Ò((p = ëxÆ.1) ± (q = ëxÆ.2)) = ((p,q) = ëxÆ)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_specÒ(x,y)Æ]);
(* *** Goal "2" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_specÒ(x,y)Æ]);
(* *** Goal "3" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_specÒ(x,y)Æ]);
pop_thm());
end;
=TEX
=SML
local

	val z'Ã_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		((fn tm => 
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv),
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv)
		] tm
		end)
		THEN_C RIGHT_C(RAND_C (simple_eq_match_conv1 p1_q2_thm))));

	val z'seta_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		(fn tm => 
		let val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dpv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dpv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dpv_proj_conv)
		] tm
		end
		));
in
val €z_Ã_conv› : CONV = (fn tm =>
let	val (d,p,v) = dest_z_Ã tm
		handle complaint =>
		pass_on complaint "dest_z_Ã" "z_Ã_conv";
	val was_sig = fst(strip_Ã(snd(dest_app tm)));
	val s1 = get_spec tm;
	val s2 = simple_eq_match_conv1 s1 tm;
	val s3 = conv_rule (RIGHT_C z'Ã_conv1) s2;
	val s4 = conv_rule (RIGHT_C(BINDER_C (seq_binder_simple_¡_conv was_sig))) s3;
	val v' = fst(dest_eq(snd(dest_±(snd(dest_±(snd(strip_∂(snd(dest_set_comp(snd(dest_eq(concl s4))))))))))));
	val tar_tm = mk_z_seta(d,p,v');
	val s5 = seta_gen_semantic_const tar_tm;
	val s6 = simple_eq_match_conv1 s5 tar_tm;
	val s7 = conv_rule(RIGHT_C z'seta_conv1) s6;
	val s8 = conv_rule (RIGHT_C(BINDER_C (seq_binder_simple_¡_conv was_sig))) s7;
	val s9 = eq_trans_rule s4 (eq_sym_rule s8);
in
	check_is_z_thm "z_Ã_conv" s9
end);
end;
=TEX
=GFT Example
z_Ã_conv ÒÃ x,y:X;a:Y | f x ∑ g y aÆ;
z_Ã_conv Ò(Ã [z:Y;x,y : X| x = y] | g x ∑ f z x)Æ;
z_Ã_conv Ò(Ã [x,y : X | x = y] | g x ∑ f x)Æ;
=SML
local
	val z'Ã_conv1 = ALL_SIMPLE_∂_C
		(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_1_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_2_proj_conv
		] tm
		end)
		THEN_C z_∂_intro_conv;
in
fun €z_¬_rule› (tm :TERM):THM  = (
let	val (lam,arg) = dest_z_app tm
		handle complaint =>
		divert complaint "dest_z_app" "z_¬_rule" 41110 
			[fn () => string_of_term tm];
	val (d,p,v) = dest_z_Ã lam
		handle complaint =>
		divert complaint "dest_z_Ã" "z_¬_rule" 41110 
			[fn () => string_of_term tm];
	val was_sig = fst(strip_Ã(snd(dest_app lam)));
	val s1 = (z_app_rule tm);
	val s2 = get_spec lam;
	val cnv1 = RIGHT_C (simple_eq_match_conv1 s2) THEN_C
		simple_ç_comp_conv THEN_C 
		seq_binder_simple_¡_conv was_sig THEN_C
		z'Ã_conv1;
	val s3 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(RAND_C(BINDER_C(LEFT_C cnv1))),
		cnv1)))) s1;
in
	check_is_z_thm "z_¬_rule" s3
end);
end;
=GFT Example
z_¬_rule Ò(Ã x,y : X; z:Y | x = y ∑ f z x) (1,2,g)Æ;
z_¬_rule Ò(Ã x : X | f x ∑ g x) yÆ;
z_¬_rule Ò(Ã [x,y : X; z:Y| x = y] | g x ∑ f z x) (x ¶ 1,y ¶ 2,z ¶ g)Æ;
=TEX
=SML
fun €all_undisch_rule› (thm:THM) : THM = (
	if is_¥(concl thm)
	then all_undisch_rule (undisch_rule thm)
	else thm
);
=TEX
=SML
local
	val ¥_thm = taut_rule¨µ x ∑ x ¥ xÆ;

	fun local_rule thm gl = (
	let 	val (a,b) = dest_¥ gl;
		val (x,bdy) = dest_eq(concl thm);
		val ithm = simple_µ_elim b ¥_thm;
	in
		subst_rule[(eq_sym_rule thm,x)] gl ithm
	end);
	val rwc = prim_rewrite_conv empty_net
		initial_rw_canon
		TOP_MAP_C
		[]
		[±_rewrite_thm, eq_rewrite_thm];
	val rw_tac2_thm = tac_proof(([],
		¨µ t∑ ≥ (F ± t) ± ≥ (t ± F) ±
		(µ x∑ x = x § T) ± (F ¥ t) ±
		(≥ T § F) ± (≥ F § T)Æ),
		rewrite_tac[]);
	val rw_rule = prim_rewrite_rule empty_net
		initial_rw_canon
		TOP_MAP_C
		[]
		[rw_tac2_thm, ≥_§_thm];
	val rw_tac2 = (prim_rewrite_tac	
		(make_net(flat(map (cthm_eqn_cxt initial_rw_canon)
			[rw_tac2_thm])))
		initial_rw_canon 
		TOP_MAP_C
		[]);
in
fun local_simple_∂_equation_conv witness tm = (
let	val (x,bdy) = dest_simple_∂ tm;
	val (xnm,xty) = dest_var x;
	val new_term = var_subst [(witness,x)] bdy;
	val new_term_rw = rwc new_term;
	val new_term' = snd(dest_eq(concl new_term_rw));
	val thm = tac_proof(([],mk_§(tm,new_term')),
		§_T2 (fn thm =>
		t_tac ORELSE
		conv_tac(fn ag => eq_sym_rule new_term_rw)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @ frees new_term) x;
			in
			CASES_T2 (mk_eq(x',witness))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				thm1,
				((rw_rule thm1) handle (Fail _) => t_thm),
				≥_eq_sym_rule thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac witness THEN accept_tac 
			(§_mp_rule (eq_sym_rule new_term_rw) thm)
		))
in
	eq_trans_rule (refl_conv tm) thm
end);
end;
=TEX
=SML
local
	val z'Ã_conv1 = BINDER_C
		(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_1_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_2_proj_conv
		] tm
		end);

val cnv2 = simple_eq_match_conv1 (tac_proof(([],
		¨µ a b c d e ∑ 
		(a ± b ± c ± (d = e) ¥ (e = d)) § TÆ),
		REPEAT strip_tac THEN asm_rewrite_tac[]))
	ORELSE_C
	simple_eq_match_conv1 (tac_proof(([],
		¨µ a b d e ∑ 
		(a ± b ± (d = e) ¥ (e = d)) § TÆ),
		REPEAT strip_tac THEN asm_rewrite_tac[]));
val cnv3 = simple_eq_match_conv1 (prove_rule[]¨(µ x ∑ T) § TÆ);
val cnv4 = simple_eq_match_conv1 (prove_rule[]¨µ x ∑ (T ± x) § xÆ);
val cnv5 = simple_eq_match_conv1 (taut_rule ¨µ x ∑ ((T ± T) ¥ x) § xÆ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x y ∑ ((T ± y) ¥ x) § (y ¥ x)Æ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x y ∑ ((y ± T) ¥ x) § (y ¥ x)Æ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x y z ∑ ((y ± z) ¥ x) § (z ¥ y ¥ x)Æ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x ∑ (T ¥ x) § xÆ);
in
fun €z_¬_conv› (tm :TERM):THM  = (
let	val (lam,arg) = dest_z_app tm;
	val (d,p,v) = dest_z_Ã lam;
	val was_sig = fst(strip_Ã(snd(dest_app lam)));
	val d' = dest_z_decl d;
	val dummy = if (length d' <> 1) orelse (not(is_z_dec (hd d'))) orelse 
			length(fst(dest_z_dec (hd d'))) <> 1
		then term_fail "z_¬_conv" 41111 [tm]
		else ();
	val (singx,aset) = (hd ** Combinators.I) (dest_z_dec (hd d'));
	val s1 = (z_app_rule tm);
	val s2 = get_spec lam;
	val cnv1 = RIGHT_C (simple_eq_match_conv1 s2) THEN_C
		simple_ç_comp_conv THEN_C 
		seq_binder_simple_¡_conv was_sig THEN_C
		z'Ã_conv1;
	val s3 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(RAND_C(BINDER_C(LEFT_C cnv1))),
		cnv1)))) s1;
	val resu = var_subst[(arg,singx)] v;
	val s4 = simple_µ_elim resu s3;
	val s5 = conv_rule(LEFT_C(APP_C(
		RAND_C (z_µ_elim_conv THEN_C
		BINDER_C(LEFT_C(RIGHT_C (local_simple_∂_equation_conv arg))
		THEN_C cnv2)
		THEN_C cnv3),
		(local_simple_∂_equation_conv arg) THEN_C (DIAG_C "1" (LEFT_C (DECL_C (dec_pred_conv THEN_TRY_C ç_u_conv)))
		ORELSE_C (DECL_C (dec_pred_conv THEN_TRY_C ç_u_conv))))
		THEN_C cnv4)) s4;
	val s6 = all_undisch_rule(conv_rule cnv5 s5);
in
	check_is_z_thm "z_¬_rule" s6
end);
end;
=TEX
=GFT Example
z_¬_conv Ò(Ã x : X | f x ∑ g x) yÆ;
z_¬_conv Ò(Ã p : U | f p ∑ g p q) yÆ;
z_¬_conv Ò(Ã p : U  ∑ g p q) yÆ;
=TEX
\subsection{Concerning Unique Existence}
=SML
local
val pair_eq_thm = prove_rule[pair_clauses]
	¨µ a b c d∑ ((a,b) = (c,d)) § ((a = c) ± (b = d))Æ;
val cnv1 = simple_eq_match_conv1 pair_eq_thm;
in
fun €pair_eq_conv› tm = (
let	val (a,b) = dest_eq tm;
in
	if is_pair a
	then (cnv1 THEN_C RIGHT_C pair_eq_conv) tm
	else id_conv tm
end);
end;
=TEX
A variant on $list\_variant$ which will only add the same
decoration to each variable.
=SML
fun €list_variant_same_dec› avoid new = (
let	val avoid_nms = map (fst o dest_var) avoid;
	val new_nms = map (fst o dest_var) new;
	val vsuffix = get_variant_suffix();
in
	if any new_nms (fn x => x mem avoid_nms)
	then list_variant_same_dec avoid
		(map (fn x => let val (nm,ty) = dest_var x
		in
			mk_var(nm ^ vsuffix,ty)
		end) new)
	else new
end);
=TEX
=SML
local
val cnv1 = simple_eq_match_conv1 (taut_rule ¨µ x y z∑
	((x ± y) ± z) = (x ± y ± z)Æ);
in
val €z_∂â1_conv› : CONV =  (fn tm =>
let	val (d,p,v) = dest_z_∂â1 tm;
	val was_sig = fst(strip_Ã(snd(dest_app tm)));
	val was_sig' = list_variant_same_dec (frees tm @ was_sig) was_sig;	 
	val s1 = ((eq_match_conv1 (get_spec tm)) THEN_C 
		∂â1_conv THEN_C ∂_uncurry_conv THEN_C
		ALL_SIMPLE_∂_C (RIGHT_C µ_uncurry_conv)
		)tm;
	val s2 = conv_rule(RIGHT_C(ALL_SIMPLE_∂_C(
		APP_C(RAND_C(
			RAND_C seq_simple_¬_conv THEN_C
			simple_¬_conv THEN_C
			LIST_OP_C[d_dpv_proj_conv,p_dpv_proj_conv,v_dpv_proj_conv]),
		 ALL_SIMPLE_µ_C(LEFT_C(
			RAND_C seq_simple_¬_conv THEN_C
			simple_¬_conv THEN_C
			LIST_OP_C[d_dpv_proj_conv,p_dpv_proj_conv,v_dpv_proj_conv]))
		)))) s1;
	val was_check = set_flag("check_is_z",false);
	val s3 = conv_rule(RIGHT_C
		(seq_binder_simple_¡_conv was_sig THEN_C
		ALL_SIMPLE_∂_C (RIGHT_C
		(seq_binder_simple_¡_conv was_sig'
		THEN_C ALL_SIMPLE_µ_C (RIGHT_C pair_eq_conv)
		THEN_C z_µ_intro_conv)
		THEN_C cnv1)
		THEN_C z_∂_intro_conv)) s2;
	val was_check' = set_flag("check_is_z",was_check);
in
	check_is_z_thm "z_∂â1_conv" s3
end);
end;
=GFT Example
z_∂â1_conv Ò ∂â1 x,y : X; z:Y | x = y ∑ z = f xÆ;
z_∂â1_conv Ò ∂â1 [x,y : X; z:Y] | x = y ∑ z = f xÆ;
z_∂â1_conv Ò ∂â1 [x,y : X; z:Y] | x = x' y ∑ z = f xÆ;
z_∂â1_conv Ò ∂â1 [x,y : X; z:Y] | x = x' y y'' ∑ z = f xÆ;
=TEX
\subsection{Concerning Assumptions}
=SML
fun €z_spec_asm_tac› (asm:TERM) (bind:TERM):TACTIC = 
	GET_ASM_T asm (strip_asm_tac o z_µ_elim bind);
fun €z_spec_nth_asm_tac› (n:int) (bind:TERM):TACTIC = 
	GET_NTH_ASM_T n (strip_asm_tac o z_µ_elim bind);

=TEX
\subsection{Conversions between Z Universal and Existential Quantifications}
=SML
local
val thm1 = prove_rule [z'µ_def, z'∂_def] 
	¨µ x ∑ (≥ ($"Z'µ" x)) § $"Z'∂" (≥ x)Æ;

val cnv1 = simple_eq_match_conv1 thm1;

val thm2 = prove_rule [z'µbody_def, z'∂body_def]
	¨µ x y z ∑ (≥($"Z'µBody" x y z)) § $"Z'∂Body" x y (≥ z)Æ;

val cnv2 = simple_eq_match_conv1 thm2;

fun (lall_≥_simple_µ_conv : CONV) tm = ((≥_simple_µ_conv THEN_C 
		BINDER_C lall_≥_simple_µ_conv) ORELSE_C
		cnv2) tm;

val thm3 = prove_rule [z'µ_def, z'∂_def] 
	¨µ x ∑ (≥ ($"Z'∂" x)) § $"Z'µ" (≥ x)Æ;

val cnv3 = simple_eq_match_conv1 thm3;

val thm4 = prove_rule [z'µbody_def, z'∂body_def]
	¨µ x y z ∑ (≥($"Z'∂Body" x y z)) § $"Z'µBody" x y (≥ z)Æ;

val cnv4 = simple_eq_match_conv1 thm4;

fun (lall_≥_simple_∂_conv : CONV) tm = ((≥_simple_∂_conv THEN_C 
		BINDER_C lall_≥_simple_∂_conv) ORELSE_C
		cnv4) tm;

in
val z_≥_µ_conv : CONV = ((cnv1 THEN_C 
	(RAND_C lall_≥_simple_µ_conv))
	ORELSE_C (fn tm => term_fail "z_≥_µ_conv" 41050 [tm]));
val z_≥_∂_conv : CONV = ((cnv3 THEN_C 
	(RAND_C lall_≥_simple_∂_conv))
	ORELSE_C (fn tm => term_fail "z_≥_∂_conv" 41051 [tm]));
end;
=GFT
z_≥_µ_conv Ò ≥(µ x, y : X; z : Y | f x ∑ g y z)Æ;
z_≥_∂_conv Ò ≥(∂ x, y : X; z : Y | f x ∑ g y z)Æ;
=TEX
\subsection{Negations}
=SML
local
	val thm1 = taut_rule ¨µ x ∑ ≥ ≥ x § xÆ;
	val thm2 = taut_rule ¨µ x y ∑ ≥(x ± y) § ≥x ≤ ≥yÆ;
	val thm3 = taut_rule ¨µ x y ∑ ≥(x ≤ y) § ≥x ± ≥yÆ;
	val thm4 = taut_rule ¨µ x y ∑ ≥(x ¥ y) § x ± ≥yÆ;
	val thm5 = taut_rule ¨≥ T § FÆ;
	val thm6 = taut_rule ¨≥ F § TÆ;
	val thm7 = prove_rule [] ¨µ x :'a ∑ ≥(x = x) § FÆ;
	val thm8 = taut_rule ¨µ x y ∑ ≥(x § y) § 
		((x ± ≥ y) ≤ (y ± ≥ x))Æ;
in
val €z_≥_in_conv› : CONV = (fn tm =>
let	val tm' = dest_z_≥ tm
		handle complaint =>
		pass_on complaint "dest_z_≥" "z_≥_in_conv";
in
	case (dest_z_term tm') of
	Z≥ tm'' => simple_µ_elim tm'' thm1
	| Z± (a,b) => list_simple_µ_elim [a,b] thm2
	| Z≤ (a,b) => list_simple_µ_elim [a,b] thm3
	| Z¥ (a,b) => list_simple_µ_elim [a,b] thm4
	| ZEq (a,b) => (if a =$ b
		then simple_µ_elim a thm7
		else  term_fail "z_≥_in_conv" 28131 [tm]
	) | Z§ (a,b) => (if a =$ b
		then simple_µ_elim a thm7
		else list_simple_µ_elim [a,b] thm8
	) | Zµ _ => z_≥_µ_conv tm
	| Z∂ _ => z_≥_∂_conv tm
	| Z∂â1 _ => ((RAND_C z_∂â1_conv) THEN_C z_≥_∂_conv) tm
	| ZTrue => thm5
	| ZFalse => thm6
	| _ => term_fail "z_≥_in_conv" 28131 [tm]
end);
end;
=TEX
\subsection{Canonicalisation}
=SML
val €z_defn_marker_thms› = 	
		[get_spec ¨$"Z'Constraint"Æ,
		get_spec ¨$"Z'FreeTypeDef"Æ,
		get_spec ¨$"Z'GivenSet"Æ,
		get_spec ¨$"Z'AxDes"Æ,
		get_spec ¨$"Z'SchBox"Æ,
		get_spec ¨$"Z'AbbDef"Æ
		];

local
	val indicators = map simple_eq_match_conv1 z_defn_marker_thms
	
in
val €z_defn_conv› : CONV = FIRST_C (indicators @
	[fn tm => term_fail "z_defn_conv" 41082 [tm]]);

fun €z_defn_canon› (thm : THM) : THM list = (
	[conv_rule (FIRST_C (indicators
	@ [fn _ => thm_fail "z_defn_canon" 41080 [thm]])) thm]
);
end;
=GFT Example
z_defn_canon (get_spec ¨$"z'_ ™ _"Æ);
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 (taut_rule¨µ x ∑ T ± x § xÆ);
	fun cnv2 tm = ((cnv1 THEN_C cnv2) ORELSE_C 
		(RIGHT_C cnv2) ORELSE_C
		id_conv) tm;
	val cnv3 = simple_eq_match_conv1 (taut_rule¨µ x ∑ x ± T § xÆ);
	val cnv4 = simple_eq_match_conv1 (taut_rule¨µ x ∑ T ¥ x § xÆ);	
in
fun €z_µ_rewrite_canon› (thm : THM) : THM list = (
let	val s1 = conv_rule 
		(z_µ_elim_conv THEN_C ALL_SIMPLE_µ_C
		(LEFT_C(LEFT_C (DECL_C (dec_pred_conv THEN_TRY_C ç_u_conv) THEN_C
		cnv2) THEN_C
		(TRY_C cnv3))
		THEN_TRY_C cnv4)) thm
in
	[s1]
end
handle complaint =>
divert complaint "z_µ_elim_conv" "z_µ_rewrite_canon" 41081 
	[fn () => string_of_thm thm]);
end;
=GFT Examples
z_µ_rewrite_canon (asm_rule Òµ x,y :X | x = z ∑ x = yÆ);
=TEX
=SML
fun €z_≥_rewrite_canon› (thm : THM) : THM list = (
	(dest_z_≥(concl thm);
	[conv_rule (FIRST_C[
		simple_eq_match_conv ≥_≤_thm,
		z_≥_∂_conv,
		≥_≥_conv,
		simple_eq_match_conv ≥_thm1])thm])
	handle complaint =>
	fail_canon thm
);
=TEX
\subsection{Proof Contexts}
=SML
val _ = new_pc "z_predicates";
val _ =set_rw_eqn_cxt [(¨p qÆ,u_conv), 
	(¨$"Z'µ" xÆ,z_µ_inv_conv),
	(¨$"Z'∂" xÆ,z_∂_inv_conv),
	(¨x (Ã y ∑ z)Æ,z_∂â1_conv)]"z_predicates";
val _ =add_rw_thms ([§_rewrite_thm, 
	eq_rewrite_thm,
	≥_rewrite_thm, 
	±_rewrite_thm, 
	≤_rewrite_thm, 
	¥_rewrite_thm,
	ç_u_thm]
	@ z_defn_marker_thms) "z_predicates";
val _ =add_st_thms ([¥_thm,
	§_thm, 
	eq_rewrite_thm]
	@ z_defn_marker_thms) "z_predicates";
val _ =set_st_eqn_cxt [(¨≥ xÆ,z_≥_in_conv),
	(¨$"Z'µ" xÆ,z_µ_elim_conv1),
	(¨$"Z'∂" xÆ,z_∂_elim_conv),
	(¨$"Z'∂â1" xÆ,z_∂â1_conv),
	(¨x ç yÆ,ç_u_conv),
	(¨$"Z'µ" xÆ,z_µ_inv_conv),
	(¨$"Z'Decl" xÆ,DECL_C dec_pred_conv)
	] "z_predicates";
val _ =set_sc_eqn_cxt [(¨$"Z'µ" xÆ,z_µ_elim_conv THEN_C 
		ALL_SIMPLE_µ_C(LEFT_C(LEFT_C(DECL_C dec_pred_conv)))),
	(¨$"Z'∂â1" xÆ,z_∂â1_conv),
	(¨≥ xÆ,z_≥_in_conv),
	(¨x ç yÆ,ç_u_conv),
	(¨$"Z'µ" xÆ,z_∂_inv_conv)
	] "z_predicates";
val _ = (let
	val thm1 = taut_rule ¨µa b∑(a ≤ ≥b) § (b ¥ a)Æ;
	val thm2 = taut_rule ¨µa b∑≥ a ≤ b § a ¥ bÆ;
	val thm3 = taut_rule ¨µa b∑a ≤ b § ≥ a ¥ bÆ;
in
add_sc_thms ([§_thm, 
	eq_rewrite_thm,
	thm1,thm2,thm3]
	@ z_defn_marker_thms) "z_predicates"
end);

val _ =set_rw_canons [
	µ_rewrite_canon, z_≥_rewrite_canon,
	±_rewrite_canon, f_rewrite_canon,
	z_µ_rewrite_canon, z_defn_canon] "z_predicates";
val _ =set_pr_tac basic_prove_tac "z_predicates";
val _ =set_pr_conv basic_prove_conv "z_predicates";
val _ =set_cs_∂_convs[basic_prove_∂_conv, 
	ALL_SIMPLE_∂_C z_defn_conv,
	z_∂_elim_conv] 
	"z_predicates";
val _ =set_∂_vs_thms [tt_to_∂_vs (type_of Ò(x,y)Æ)] "z_predicates";
val _ = set_pc "z_predicates";
=GFT
push_goal([],Òµ x, y:U ∑ (x ± y) = (y ± x)Æ);
a(step_strip_tac);
=TEX
\section{EPILOGUE}
=SML
end; (* local open ... *)
end; (* of structure ZPredicateCalculus *)
open ZPredicateCalculus;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
