=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Predicate Calculus}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP041}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z predicate calculus.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1,1.2] 
First versions.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) predicate calculus.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD041}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the predicate calculus of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD041}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=IGN
structure ÛZPredicateCalculusÝ : ZPredicateCalculus = struct
local
open ZTypesAndTermsSupport;
in
=TEX
=SML
open ZTypesAndTermsSupport;
=SML
val lthy = get_current_theory_name();
val _ = open_theory "z_library";
val _ = new_theory "z_predicate_calculus" handle _ => open_theory "z_predicate_calculus";
val _ = push_pc "hol";
val _ = set_flag("z_type_check_only",false);
val _ = push_pc "hol1";
val _ = new_pc "'z_predicate_calculus_build";
=TEX
\section{THE CODE}
\subsection{Utilities}
=SML
fun Ûlist_eqÝ (eq : 'a * 'a -> bool) (a :: x) (b :: y) = eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Swap a universally quanitifed equation around:
=SML
fun Ûsym_eqn_ruleÝ (thm : THM) = (
let 	val (vs,bdy) = strip_µ(concl thm);
	val s1 = eq_sym_rule (list_µ_elim vs thm);
in
	list_µ_intro vs s1
end);
=TEX
Find the Z constants (i.e. declared in 
=INLINEFT
get_descendants "cache'zed"
=TEX
) in a term.
Note we return terms, not name/type pairs like
$term\_consts$.
=SML
fun Ûterm_z_constsÝ (tm : TERM) : TERM list = (
let	val in_thys = get_descendants "cache'zed";
	val hol_cons = term_consts tm;
	val zed_consts = mapfilter
		(fn (nm,ty) => if get_const_theory nm mem in_thys
			then mk_const(nm,ty)
			else fail "" 0 [])
		hol_cons;
in
	zed_consts
end);
=TEX
\subsection{Recognising Z}
\subsubsection{Destroying Bindings}
Could the term in question have been formed by $mk\_binding$?
=SML
local
	val aux = Sort.sort Sort.string_order;
in
fun Ûdest_sorted_stringsÝ (ss : string list) : string list = (
	if aux ss = ss
	then ss
	else fail "dest_sorted_strings" 0 []
);
end;
fun Ûdest_bind_tnameÝ (nm : string) : string list = (
	case dest_z_name nm of
	("Z'S",[fid],Nil) => dest_sorted_strings fid
	| _ => fail "dest_bind_tname" 0 []
);
=TEX
In the following the results are ordered by the strings.
=SML
fun Ûdest_bind_typeÝ (ty : TYPE) : (string * TYPE) list = (
let	val (nm,tys) = dest_ctype ty;
	val fst_itym = dest_bind_tname nm;
in
	combine fst_itym tys
end);
=TEX
In the following the results are ordered by the strings.
=SML
fun Ûdest_bind_ctypeÝ (ty : TYPE) : (string * TYPE) list = (
let	val tys = rev(strip_­_type ty);
	val core_type = hd tys;
	val atypes = rev(tl tys);
	val itym = dest_bind_type core_type;
in
	if list_eq (op =:) atypes (map snd itym)
	then itym
	else fail "dest_bind_ctype" 0 []
end);
=TEX
=SML
fun Ûdest_bind_cnameÝ (s : string) : string list = (
case dest_z_name s of
("Z'Mk_S",[fid],Nil) => dest_sorted_strings fid
| _ => fail "dest_bind_cname" 0 []
);
=TEX
=SML
fun Ûdest_bind_ctermÝ (tm : TERM) : (string * TYPE) list = (
let	val (cnm,cty) = dest_const tm;
	val nm_fst_itym = dest_bind_cname cnm;
	val ty_itym = dest_bind_ctype cty;
in
	if nm_fst_itym = map fst ty_itym
	then ty_itym
	else fail "dest_bind_cterm" 0 []
end);
=TEX
The following returns the list of original bound variables, paired
with their types, and the decoration to be applied to them.
the originally input schema cannot be recreated.

Notice the following is NOT the inverse of 
=INLINEFT
mk_z_binding
=TEX
 just
=INLINEFT
mk_binding
=TEX
=SML
fun Ûfull_dest_bindingÝ (tm : TERM) : (string * TYPE)list * string = (
let	val (bcons,argl) = strip_app tm;
	val args_itym = map dest_var argl;
	val b_itym = dest_bind_cterm bcons;
	val d = case b_itym of
		(a :: x) => implode 						((explode(fst (hd args_itym))) from 
				(length(explode(fst a))))
		| _ => "";
in
	if list_eq (fn ((a,aty),(b,bty)) => a=b ^ d andalso (aty =: bty)) 
		args_itym b_itym
	then (b_itym, d)
	else fail "full_dest_binding" 0 []
end);
=TEX
\subsubsection{Utilities of Destruction}
The following function produces a type map from a declaration.
=SML
local
fun	f ([] :TERM list) :(string * TYPE)list = []
|	f (h::t) = (
		map dest_var (fst(dest_z_dec h))
		handle Fail _ =>
		let val (sch,d) = dest_z_decsexp h
		in
			map 	(fn(s,ty)=>(pack_ident(s,d),ty)) 
				(dest_z_schema_t(dest_z_power_t(type_of sch)))
		end) @ (f t);
in
fun	Ûdest_declÝ (t:TERM) :(string * TYPE)list =
		f (dest_z_decl t)
	handle Fail _ => term_fail "dest_decl" 47912 [t]
end;
=TEX
=SML
fun Ûstrip_simple_ÌÝ (itm: TERM) : TERM list * TERM = (
let	fun aux acc tm = (let val (v,bdy) = dest_Ì tm;
		in
		aux (v::acc) bdy
		end)
		handle (Fail _) => (rev acc, tm);
in
	aux [] itm
end);
=TEX
=SML
fun Ûdest_schema_absÝ (tm : TERM) : (string * TYPE) list * TERM = (
let	val (vs,bdy) = strip_simple_Ì tm;
	val itym = map dest_var vs;
	val dummy = dest_sorted_strings(map fst itym);
in
	(itym, bdy)
end);
=TEX
=SML
fun Ûdest_g3_absÝ (tm : TERM) : TERM * TERM * TERM * TERM * (string * TYPE) list = (
let	val (itym,bdy) = dest_schema_abs tm;
	val (root,args) = strip_app bdy;
	val sg = dest_bind_cterm root;
	val to_ft1 = snd(nth 2 sg);
	val to_ft4 = snd(nth 3 sg);
in
	if to_ft4 =: type_of (nth 3 args) andalso
		to_ft1 =: type_of (nth 2 args)
	then (case args of
	[ft2,ft3,ft1,ft4] => (ft1,ft2,ft3,ft4,itym)
	| _ => fail "dest_g2_abs" 0 [])
	else fail "dest_g2_abs" 0 []
end);
=TEX
=SML
fun Ûdest_g2_absÝ (tm : TERM) : TERM * TERM * TERM * (string * TYPE) list = (
let	val (itym,bdy) = dest_schema_abs tm;
	val (root,args) = strip_app bdy;
	val sg = dest_bind_cterm root;
	val to_ft4 = snd(nth 2 sg);
in
	if to_ft4 =: type_of (nth 2 args)
	then (case args of
	[ft2,ft3,ft4] => (ft2,ft3,ft4,itym)
	| _ => fail "dest_g2_abs" 0 [])
	else fail "dest_g2_abs" 0 []
end);
=TEX
=SML
fun Ûdest_g1_absÝ (tm : TERM) : TERM * TERM * (string * TYPE) list = (
let	val (itym,bdy) = dest_schema_abs tm;
	val (root,args) = strip_app bdy;
	val dummy = if root =$ g1_bind_cterm
		then ()
		else fail "dest_g1_abs" 0 [];
in
	(case args of
	[ft2,ft3] => (ft2,ft3,itym)
	| _ => fail "dest_g1_abs" 0 [])
end);
=TEX
=SML
local
val rt = g2_bind_type BOOL;

fun Ûdest_¶‰1_btermÝ (tm : TERM) : TYPE list = (
let	val (bnm,bty) = dest_const tm;
	val lfid = case (dest_z_name bnm) of
		("Z'¶‰1",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_¶‰1_bterm" 0 [];
	val (ty1,ty2) = dest_­_type bty;
	val tys = rev(strip_­_type ty1);
in
	if (ty2 =: BOOL) andalso (hd tys =: rt)
	then rev (tl tys)
	else fail "dest_¶‰1_bterm" 0 []
end);
in
=TEX
=SML
fun Ûfull_dest_z_¶‰1Ý  
	(tm : TERM) : TERM * TERM * TERM = (
let	val (bterm1,term) = dest_app tm;
	val ity = dest_¶‰1_bterm bterm1;
	val (d,p,v,itym) = dest_g2_abs term;
	val itym' = dest_decl d;
in
	if list_eq (op =:) ity (map snd itym) andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_¶‰1" 0 []
end);
end;
=TEX
=SML
fun Ûdest_schema_typeÝ (ty : TYPE) : (string * TYPE) list = (
	case dest_ctype ty of
	("SET",[ty1]) => dest_bind_type ty1
	| _ => fail "dest_schema_type" 0 []
);
=TEX
\subsubsection{Top Level Destructors}
=SML
fun Ûfull_dest_z_binder2Ý (binds:string) (bterm: TERM) (body_bterm: TERM) 
	(tm : TERM) : TERM * TERM * TERM = (
let	val (bterm1,term) = dest_app tm;
	val dummy = if bterm =$ bterm1
		then ()
		else fail "full_dest_z_binder2" 0 [];
	val (vars, bdy) = strip_simple_binder binds term;
	val itym = map dest_var vars;
	val (sl,tyl) = (dest_sorted_strings ** Combinators.I)
			(split itym);
	val (body_bterm1,fts) = strip_app bdy;
	val dummy = if body_bterm1 =$ body_bterm
		then ()
		else fail "full_dest_z_binder2" 0 [];
	val (ft1,ft2,ft3) = case fts of
		[ft1,ft2,ft3] => (ft1,ft2,ft3)
		| _ => fail "full_dest_z_binder2" 0 [];
	val itym_us = dest_decl ft1;
	val dummy = if all itym_us (fn (nm,ty) =>
		lassoc3 itym nm =: ty)
		then ()
		else fail "full_dest_z_binder2" 0 [];
in
	(ft1,ft2,ft3)
end);

=TEX
=SML
local
fun Ûdest_¶‰s_btermÝ (tm : TERM) : (string * TYPE) list * (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val (fid1,fid2_diff_fid1) = case (dest_z_name nm) of
		("Z'¶‰s",[a,b],Nil) => (a,b)
		| _ => fail "dest_¶‰s_bterm" 0 [];
	val (ty1,ty2,ty3) = case strip_­_type ty of
		[t1,t2,t3] => (t1,t2,t3)
		| _ => fail "dest_¶‰s_bterm" 0 [];
	val ty1' = rev(strip_­_type ty1);
	val ity1 = rev(tl ty1');
	val dummy = dest_sorted_strings fid1;
	val itym1 = combine fid1 ity1;
	val itym2 = dest_schema_type ty2;
	val itym2_diff_itym1 = dest_schema_type ty3;
	val dummy = if hd ty1' =: g1_bind_type andalso
		fid2_diff_fid1 = map fst itym2_diff_itym1 andalso
		list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) itym2_diff_itym1 (diff' (itym2, itym1)) andalso
		is_nil(diff' (itym1, itym2))
		then ()
		else fail "dest_¶‰s_bterm" 0 [];
in
	(itym1, itym2)
end);
in
=TEX
=SML
fun Ûfull_dest_z_¶‰sÝ (tm : TERM) : TERM * TERM * TERM = (
let	val (¶‰s_bterm1, g1, v) = case strip_app tm of
		(a,[b,c]) => (a,b,c)
		| _ => fail "full_dest_z_¶‰s" 0 [];
	val (dtym, vtym) = dest_¶‰s_bterm ¶‰s_bterm1;
	val (d,p,dtym1) = dest_g1_abs g1;
	val dtym' = dest_decl d;
	val vtym' = dest_z_schema_t(dest_z_power_t(type_of v));
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) dtym dtym1 andalso
		all dtym' (fn (nm,ty) => lassoc3 dtym nm =: ty) andalso
		all vtym' (fn (nm,ty) => lassoc3 vtym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_¶‰s" 0 []
end);
end;
=TEX
=SML
local
fun Ûdest_¶‰1‰s_btermÝ (tm : TERM) : (string * TYPE) list * (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val (fid1,fid2_diff_fid1) = case (dest_z_name nm) of
		("Z'¶‰1‰s",[a,b],Nil) => (a,b)
		| _ => fail "dest_¶‰s_bterm" 0 [];
	val (ty1,ty2,ty3) = case strip_­_type ty of
		[t1,t2,t3] => (t1,t2,t3)
		| _ => fail "dest_¶‰1‰s_bterm" 0 [];
	val ty1' = rev(strip_­_type ty1);
	val ity1 = rev(tl ty1');
	val dummy = dest_sorted_strings fid1;
	val itym1 = combine fid1 ity1;
	val itym2 = dest_schema_type ty2;
	val itym2_diff_itym1 = dest_schema_type ty3;
	val dummy = if hd ty1' =: g1_bind_type andalso
		fid2_diff_fid1 = map fst itym2_diff_itym1 andalso
		list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) itym2_diff_itym1 (diff' (itym2, itym1)) andalso
		is_nil(diff' (itym1, itym2))

		then ()
		else fail "dest_¶‰1‰s_bterm" 0 [];
in
	(itym1, itym2)
end);
in
=TEX
=SML
fun Ûfull_dest_z_¶‰1‰sÝ (tm : TERM) : TERM * TERM * TERM = (
let	val (¶‰1‰s_bterm1, g1, v) = case strip_app tm of
		(a,[b,c]) => (a,b,c)
		| _ => fail "full_dest_z_¶‰s" 0 [];
	val (dtym, vtym) = dest_¶‰1‰s_bterm ¶‰1‰s_bterm1;
	val (d,p,dtym1) = dest_g1_abs g1;
	val dtym' = dest_decl d;
	val vtym' = dest_z_schema_t(dest_z_power_t(type_of v));
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) dtym dtym1 andalso
		all dtym' (fn (nm,ty) => lassoc3 dtym nm =: ty) andalso
		all vtym' (fn (nm,ty) => lassoc3 vtym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_¶‰1‰s" 0 []
end);
end;
=TEX
=SML
local
fun Ûdest_µ‰s_btermÝ (tm : TERM) : (string * TYPE) list * (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val (fid1,fid2_diff_fid1) = case (dest_z_name nm) of
		("Z'µ‰s",[a,b],Nil) => (a,b)
		| _ => fail "dest_µ‰s_bterm" 0 [];
	val (ty1,ty2,ty3) = case strip_­_type ty of
		[t1,t2,t3] => (t1,t2,t3)
		| _ => fail "dest_µ‰s_bterm" 0 [];
	val ty1' = rev(strip_­_type ty1);
	val ity1 = rev(tl ty1');
	val dummy = dest_sorted_strings fid1;
	val itym1 = combine fid1 ity1;
	val itym2 = dest_schema_type ty2;
	val itym2_diff_itym1 = dest_schema_type ty3;
	val dummy = if hd ty1' =: g1_bind_type andalso
		fid2_diff_fid1 = map fst itym2_diff_itym1 andalso
		list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) itym2_diff_itym1 (diff' (itym2, itym1)) andalso
		is_nil(diff' (itym1, itym2))

		then ()
		else fail "dest_µ‰s_bterm" 0 [];
in
	(itym1, itym2)
end);
in
=TEX
=SML
fun Ûfull_dest_z_µ‰sÝ (tm : TERM) : TERM * TERM * TERM = (
let	val (µ‰s_bterm1, g1, v) = case strip_app tm of
		(a,[b,c]) => (a,b,c)
		| _ => fail "full_dest_z_µ‰s" 0 [];
	val (dtym, vtym) = dest_µ‰s_bterm µ‰s_bterm1;
	val (d,p,dtym1) = dest_g1_abs g1;
	val dtym' = dest_decl d;
	val vtym' = dest_z_schema_t(dest_z_power_t(type_of v));
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) dtym dtym1 andalso
		all dtym' (fn (nm,ty) => lassoc3 dtym nm =: ty) andalso
		all vtym' (fn (nm,ty) => lassoc3 vtym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_µ‰s" 0 []
end);
end;
=TEX
=SML
fun Ûfull_dest_z_predsexpÝ (tm : TERM) : TERM * string = (
let	val (con,(bind,sch)) = (Combinators.I ** dest_pair)(dest_app tm);
	val dummy = if (fst(dest_const con) = "Z'SchemaPred")
			andalso type_of tm =: BOOL
		then ()
		else fail "full_dest_z_predsexp" 0 [];
	val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
	val (itym,d) = full_dest_binding bind;
in	if all (combine itym stym)
			(fn ((inm,_),(snm,_)) => inm = snm)
	then (sch,d)
	else fail "full_dest_z_predsexp" 0 []
end);
=TEX
=SML
local
fun Ûdest_z_seta_btermÝ (tm :TERM) : TYPE list * TYPE = (
let	val (nm,ty) = dest_const tm;
	val litym = case (dest_z_name nm) of
		("Z'Seta",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_z_seta_bterm" 0 [];
	val (ty1,ty2) = dest_­_type ty;
	val ty3 = case dest_ctype ty2 of
		("SET",[ty3]) => ty3
		| _ => fail "dest_z_seta_bterm" 0 [];
	val tys = rev(strip_­_type ty1);
	val g2bt = hd tys;
	val ity = rev(tl tys);
in
	if g2bt =: g2_bind_type ty3 andalso
		length ity = litym
	then (ity,ty3)
	else fail "dest_z_seta_bterm" 0 []
end);
in
=TEX
=SML
fun Ûfull_dest_z_setaÝ (tm : TERM) : TERM * TERM * TERM = (
let	val (seta_bterm1, bdy) = dest_app tm;
	val (d,p,v,itym) = dest_g2_abs bdy;
	val (ity,vty) = dest_z_seta_bterm seta_bterm1;
	val itym' = dest_decl d;
in
	if list_eq(op =:) ity (map snd itym) andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_seta" 0 []
end);
end;
=TEX
=SML
fun Ûfull_dest_z_ÊÝ (tm : TERM) : TERM * string = (
let	val (con,args) = strip_app tm;
	val (bind,sch) = case args of
		[a,b] => (a,b)
		| _ => fail "full_dest_z_Ê" 0 [];
	val dummy = if (fst(dest_const con) = "Z'Ê")
			andalso type_of tm =: type_of bind
		then ()
		else fail "full_dest_z_Ê" 0 [];
	val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
	val (itym,d) = full_dest_binding bind;
in	if all (combine itym stym)
			(fn ((inm,_),(snm,_)) => inm = snm)
	then (sch,d)
	else fail "full_dest_z_Ê" 0 []
end);
=TEX
=SML
fun Ûdest_tuple_typeÝ (ty : TYPE) : TYPE list = (
let	val (nm,args) = dest_ctype ty;
	val nfid = case dest_z_name nm of
		("Z'T",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_tuple_type" 0 [];
in
	if nfid = length args
	then args
	else fail "dest_tuple_type" 0 []
end);
=TEX
=SML
local
fun Ûdest_Ì_btermÝ (tm : TERM) : TYPE list * TYPE * TYPE = (
let	val (nm,ty) =dest_const tm;
	val nfid = case dest_z_name nm of
		("Z'Ì",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_Ì_bterm" 0 [];
	val (ty1,ty2) = dest_­_type ty;
	val ty3 = case dest_ctype ty2 of
		("SET",[ty3]) => ty3
		| _ => fail "dest_Ì_bterm" 0 [];
	val (t_ty,v_ty) = case dest_tuple_type ty3 of
		[t1,t2] => (t1,t2)
		| _ => fail "dest_Ì_bterm" 0 [];
	val ity = rev(tl(rev(strip_­_type ty1)));
in
	(ity, t_ty, v_ty)
end);
=TEX
=SML
fun	f ([]:Z_TERM list) :TERM list = []
|	f (Zdec(tml,_)::z_tml) = tml @ (f z_tml)
|	f (Zdecsexp(sch,d)::z_tml) = (mk_z_Ê(sch,d)) :: (f z_tml)
|	f _ = term_fail "mk_z_Ì" 0 [];

fun	chartuple ((Zdecl tml):Z_TERM) :TERM = (
		case (f (map dest_z_term tml)) of
			[] => fail "mk_z_Ì" 0 []
		|	[tm] => tm
		|	tml' => mk_z_tuple tml'
		)
|	chartuple _ = fail "mk_z_Ì" 0 [];
in
fun Ûfull_dest_z_ÌÝ (tm : TERM) : TERM * TERM * TERM = (
let	val (Ì_bterm1, g3abs) = dest_app tm;
	val (ity,t_ty,v_ty) = dest_Ì_bterm Ì_bterm1;
	val (t,d,p,v,itym) = dest_g3_abs g3abs;
	val itym' = dest_decl d;
	val t' = chartuple(dest_z_term d);
in
	if list_eq (op =:) ity (map snd itym) andalso
		t_ty =: type_of t andalso
		v_ty =: type_of v andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty) andalso
		t' =$ t
	then (d,p,v)
	else fail "full_dest_z_Ì" 0 []
end);
end;
=TEX
=SML
local
fun Ûdest_Í_btermÝ (tm :TERM) : TYPE list * TYPE = (
let	val (nm,ty) = dest_const tm;
	val litym = case (dest_z_name nm) of
		("Z'Í",[[n]],Nil) => nat_of_string n
		| _ => fail "dest_Í_bterm" 0 [];
	val (ty1,ty2) = dest_­_type ty;
	val tys = rev(strip_­_type ty1);
	val g2bt = hd tys;
	val ity = rev(tl tys);
in
	if g2bt =: g2_bind_type ty2 andalso
		length ity = litym
	then (ity,ty2)
	else fail "dest_Í_bterm" 0 []
end);
in
=TEX
=SML
fun Ûfull_dest_z_ÍÝ (tm : TERM) : TERM * TERM * TERM = (
let	val (Í_bterm1, bdy) = dest_app tm;
	val (d,p,v,itym) = dest_g2_abs bdy;
	val (ity,vty) = dest_Í_bterm Í_bterm1;
	val itym' = dest_decl d;
in
	if list_eq(op =:) ity (map snd itym) andalso
		all itym' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p,v)
	else fail "full_dest_z_Í" 0 []
end);
end;
=TEX
=SML
local
fun Ûdest_schema_btermÝ (tm:TERM): (string * TYPE) list = (
let	val (nm,ty) = dest_const tm;
	val fid = case (dest_z_name nm) of
		("Z'‰s",[fid],Nil) => fid
		| _ => fail "dest_schema_bterm" 0 [];
	val (ty1,ty2) = dest_­_type ty;
	val itym = dest_schema_type ty2;
	val tys = rev(strip_­_type ty1);
	val g1bt = hd tys;
	val ity = rev(tl tys);
in
	if g1bt =: g1_bind_type andalso
		list_eq(op =:) ity (map snd itym)
	then itym
	else fail "dest_schema_bterm" 0 []
end);
in
=TEX
=SML
fun Ûfull_dest_z_‰sÝ (tm : TERM) : TERM * TERM = (
let	val (schema_bterm1, bdy) = dest_app tm;
	val (d,p,itym) = dest_g1_abs bdy;
	val itym' = dest_schema_bterm schema_bterm1;
	val itym'' = dest_decl d;
in
	if list_eq (fn ((a,b),(c,d)) => a = c andalso b =: d) itym itym'
		andalso
		all itym'' (fn (nm,ty) => lassoc3 itym nm =: ty)
	then (d,p)
	else fail "full_dest_z_‰s" 0 []
end);
end;
=TEX
=SML
fun Ûfull_dest_z_decsexpÝ (tm : TERM) : TERM * string = (
let 	val (con,(bind,sch)) = (Combinators.I ** dest_pair)(dest_app tm);
	val dummy = if (fst(dest_const con) = "Z'SchemaDec")
			andalso type_of tm =: BOOL
		then ()
		else fail "full_dest_z_decsexp" 0 [];
	val stym = dest_z_schema_t(dest_z_power_t(type_of sch));
	val (itym,d) = full_dest_binding bind;
in	if all (combine itym stym)
			(fn ((inm,_),(snm,_)) => inm = snm)
	then (sch,d)
	else fail "full_dest_z_decsexp" 0 []
end);

=TEX
\subsubsection{Bringing it Together}
=SML
fun Ûfull_dest_z_termÝ (tm : TERM) : Z_TERM = (
let val dzt = dest_z_term tm;
in
case dzt of
Zdecsexp(sch,d) => (full_dest_z_decsexp tm; dzt)
| Z¶(d,p,v) => (full_dest_z_binder2 "¶" ¶_bterm ¶body_bterm tm; dzt)
| Zµ(d,p,v) => (full_dest_z_binder2 "µ" µ_bterm µbody_bterm tm; dzt)
| Z¶‰1(d,p,v) => (full_dest_z_¶‰1 tm; dzt)
| Z¶‰s(d,p,v) => (full_dest_z_¶‰s tm; dzt)
| Z¶‰1‰s(d,p,v) => (full_dest_z_¶‰1‰s tm; dzt)
| Zµ‰s(d,p,v) => (full_dest_z_µ‰s tm; dzt)
| Zpredsexp(sch,d) => (full_dest_z_predsexp tm; dzt)
| Zseta(d,p,v) => (full_dest_z_seta tm; dzt)
| ZÊ(sch,d) => (full_dest_z_Ê tm; dzt)
| ZÌ(d,p,v) => (full_dest_z_Ì tm; dzt)
| ZÍ(d,p,v) => (full_dest_z_Í tm; dzt)
| Z‰s(d,p) => (full_dest_z_‰s tm; dzt)
| _ => dzt
end
handle (Fail _) =>
term_fail "full_dest_z_term" 41002 [tm]
);
=TEX
The following cannot ``cheat'' $dest\_z\_term$, unless the constants
have been given types incompatible with their generated forms
from \cite{DS/FMU/IED/DTD047}.
=GFT
Zdec, Zdecl, Zeq, Z, Ztrue, Zfalse, Z³, Z±, Z², Z´,
Z¤, Zlvar, Zgvar, Zint, ZString, Z§¢, Zsetd, Zð, Ztuple,
Zbinding, Z¸, Zsel, Zapp, Zdec‰s, Zpre‰s, Z³‰s,
Z±‰s, Z²‰s, Z´‰s, Z¤‰s, Zù‰s, Zhide‰s, Z„‰s, Z˜‰s, 
Z»‰s, ZRename‰s
=TEX
\subsection{Problems to be Caught}
=GFT
val tm = mk_z_decsexp(ñ[z:X;x:Y;y:Z]®,"'");
val y' = nth 4 (frees tm);
val y'' = variant [y'] y';
val tm' = subst[(y'',y')] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
As ``!'' is before ```'' in ordering:
=GFT
val tm = ñµ x, x! : X · x = z®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
As ``!'' is before ```'' in ordering:
=GFT
val tm = ñ¶ x, x! : X · x = z®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
As ``!'' is before ```'' in ordering:
=GFT
val tm = ñ¶‰1 x, x! : X · x = z®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val Z¶(a,b,c) = dest_z_term ñ¶ x, x! : X | x = z · [x,x! : X | true]®;
val tm = mk_z_¶‰s(a,b,ñ[x,x! : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val Z¶(xa,xb,xc) = dest_z_term ñ¶ x, x! : X | x = z · [x,x! : X | true]®;
val tm = mk_z_¶‰1‰s(xa,xb,ñ[x,x! : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val Z¶(xa,xb,xc) = dest_z_term ñ¶ x, x! : X | x = z · [x,x! : X | true]®;
val tm = mk_z_µ‰s(xa,xb,ñ[x,x! : X | true]®);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm'; (* fails *)
=TEX
=GFT
val tm1 = ñ[x,x!:X | x = z] ± true®;
val tm = fst(dest_z_± tm1);
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val x_ins' = mk_var("x'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = ñ{x, x! : X | x = z}®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = ñÊ[x, x! : X | x = z]®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val x_ins' = mk_var("x'",type_of z);
val tm' = subst [(x_ins',x_ins)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = ñ Ì x, x! : X · x = z®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = ñ Í x, x! : X · x = z®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=GFT
val tm = ñ [x,x! : X | x = z]®;
val z = hd(frees tm);
val x_ins = mk_var("x",type_of z);
val tm' = subst [(x_ins,z)] tm;
full_dest_z_term tm;
dest_z_term tm';
full_dest_z_term tm';
=TEX
=SML
fun Ûis_all_z_typeÝ (ty : TYPE) : bool = (
let
	fun aux (a :: x) = is_all_z_type a andalso aux x
	| aux [] = true;
	fun aux1 ((_,a) :: x) = is_all_z_type a andalso aux1 x
	| aux1 [] = true;
in
(case (dest_z_type ty 
	handle (Fail _) => 
	type_fail "is_all_z_type"  41003 [ty]) of
Zgiven_t _ => true
| Zvar_t _ => true
| Zpower_t ty' => is_all_z_type ty'
| Ztuple_t tyl => aux tyl
| Zschema_t ltyl => aux1 ltyl)
end);
=TEX
=SML
fun Ûis_zÝ (tm : TERM) : bool = (
let fun aux (a :: x) = is_z a andalso aux x
	| aux _ = true;
in
case (full_dest_z_term tm
	handle (Fail _) =>
	term_fail "is_z" 41002 [tm]) of
Zlvar (_,ty,tml) => is_all_z_type ty andalso aux tml
| Zgvar (_,ty,tml) => is_all_z_type ty andalso aux tml
| Zapp (tm1,tm2) => is_z tm1 andalso is_z tm2
| Zdec (tml,tm1) => aux tml andalso is_z tm1
| Zdecsexp (tm1,_) => is_z tm1
| Zdecl tml => aux tml
| Zeq (tm1,tm2) => is_z tm1 andalso is_z tm2
| Z (tm1, tm2) => is_z tm1 andalso is_z tm2
| Ztrue => true
| Zfalse => true
| Z³ tm1 => is_z tm1
| Z³‰s tm1 => is_z tm1
| Z± (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z² (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z´ (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z¤ (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z±‰s (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z²‰s (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z´‰s (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z¤‰s (tm1, tm2) => is_z tm1 andalso is_z tm2
| Z¶ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z¶‰s (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z¶‰1 (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z¶‰1‰s (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Zµ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Zµ‰s (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Zpredsexp (tm1,_) => is_z tm1
| Zint _ => true
| ZString _ => true
| Z§¢ (ty,tml) => is_all_z_type ty andalso aux tml
| Zsetd (ty,tml) => is_all_z_type ty andalso aux tml
| Zseta (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Zð tm1 => is_z tm1
| Ztuple tml => aux tml
| Z¸ tml => aux tml
| ZÊ (tm1,_) => is_z tm1
| Zsel (tm1,_) => is_z tm1
| ZÍ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| ZÌ (tm1,tm2,tm3) => is_z tm1 andalso is_z tm2 andalso is_z tm3
| Z‰s (tm1,tm2) => is_z tm1 andalso is_z tm2
| Zdec‰s (tm1,_) => is_z tm1
| Zpre‰s tm1 => is_z tm1
| Zù‰s (tm1,tm2) => is_z tm1 andalso is_z tm2
| Zhide‰s (tm1,_) => is_z tm1
| Z„‰s tm1  => is_z tm1
| Z˜‰s tm1  => is_z tm1
| Z»‰s (tm1,tm2) => is_z tm1 andalso is_z tm2
| ZRename‰s (tm1,_) => is_z tm1
| Zbinding (stml) => aux (map snd stml)
end);

=TEX
=SML
fun Ûnot_z_subtermsÝ (itm : TERM) : TERM list = (
let 	val acc = ref ([]:TERM list);
	fun aux1 tm ty = (if is_all_z_type ty 
		then () 
		else acc := tm :: (!acc));

fun tz (tm : TERM) = (
let	fun aux (a :: x) = (tz a ; aux x)
	| aux _ = ();
in
case (full_dest_z_term tm
	handle (Fail _) =>
	(acc := tm :: (!acc); Ztrue)) of
Zlvar (_,ty,tml) => (aux1 tm ty ; aux tml)
| Zgvar (_,ty,tml) => (aux1 tm ty ; aux tml)
| Zapp (tm1,tm2) => (tz tm1 ; tz tm2)
| Zdec (tml,tm1) => (aux tml ; tz tm1)
| Zdecsexp (tm1,_) => tz tm1
| Zdecl tml => aux tml
| Zeq (tm1,tm2) => (tz tm1 ; tz tm2)
| Z (tm1, tm2) => (tz tm1 ; tz tm2)
| Ztrue => ()
| Zfalse => ()
| Z³ tm1 => tz tm1
| Z³‰s tm1 => tz tm1
| Z± (tm1, tm2) => (tz tm1 ; tz tm2)
| Z² (tm1, tm2) => (tz tm1 ; tz tm2)
| Z´ (tm1, tm2) => (tz tm1 ; tz tm2)
| Z¤ (tm1, tm2) => (tz tm1 ; tz tm2)
| Z±‰s (tm1, tm2) => (tz tm1 ; tz tm2)
| Z²‰s (tm1, tm2) => (tz tm1 ; tz tm2)
| Z´‰s (tm1, tm2) => (tz tm1 ; tz tm2)
| Z¤‰s (tm1, tm2) => (tz tm1 ; tz tm2)
| Z¶ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z¶‰s (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z¶‰1 (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z¶‰1‰s (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Zµ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Zµ‰s (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Zpredsexp (tm1,_) => tz tm1
| Zint _ => ()
| ZString _ => ()
| Z§¢ (ty,tml) => (aux1 tm ty ; aux tml)
| Zsetd (ty,tml) => (aux1 tm ty ; aux tml)
| Zseta (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Zð tm1 => tz tm1
| Ztuple tml => aux tml
| Z¸ tml => aux tml
| ZÊ (tm1,_) => tz tm1
| Zsel (tm1,_) => tz tm1
| ZÍ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| ZÌ (tm1,tm2,tm3) => (tz tm1 ; tz tm2; tz tm3)
| Z‰s (tm1,tm2) => (tz tm1 ; tz tm2)
| Zdec‰s (tm1,_) => tz tm1
| Zpre‰s tm1 => tz tm1
| Zù‰s (tm1,tm2) => (tz tm1 ; tz tm2)
| Zhide‰s (tm1,_) => tz tm1
| Z„‰s tm1  => tz tm1
| Z˜‰s tm1  => tz tm1
| Z»‰s (tm1,tm2) => (tz tm1 ; tz tm2)
| ZRename‰s (tm1,_) => tz tm1
| Zbinding (stml) => aux (map snd stml)
end);
in
	(tz itm;
	(!acc))
end);
=TEX
\subsection{Using the Checks}
We handle failures from $new\_flag$ to allow repeated loadings of this function.
=SML
local
	val Ûcheck_is_zÝ = ref true;
in
	val _ = new_flag{name = "check_is_z",
		check = fun_true,
		control = check_is_z,
		default = (fn () => false)}
	handle (Fail _) => ();
end;
=TEX
=SML
fun Ûcheck_is_z_termÝ (caller : string) (tm : TERM): TERM = (
	if get_flag("check_is_z")
	then tm
	else (
	case (not_z_subterms tm) of
	[] => tm
	| lst => (diag_string (get_error_message 41004 
		[caller,(format_list string_of_term lst ", ")]);
		tm)
));
=TEX
=SML
fun Ûcheck_is_z_thmÝ (caller : string) (thm : THM): THM = (
	if get_flag("check_is_z")
	then thm
	else (
let	val nZ = not_z_subterms (concl thm) @ flat (map not_z_subterms (asms thm));
in
	case nZ of
	[] => thm
	| lst => (diag_string (get_error_message 41004 
		[caller,(format_list string_of_term lst ", ")]);
		thm)
end));
=TEX
=SML
fun Ûcheck_is_z_goalÝ (caller : string) ((gasms,conc): GOAL):GOAL = (
	if get_flag("check_is_z")
	then (gasms,conc)
	else (
let	val nZ = not_z_subterms conc @ flat (map not_z_subterms gasms);
in
	case nZ of
	[] => (gasms,conc)
	| lst => (diag_string (get_error_message 41004 
		[caller,(format_list string_of_term lst ", ")]);
		(gasms,conc))
end));
=TEX
\section{Getting Things into the Existence Prover}
Tuple type ``varstruct'' constructions:
=SML
local
val tt_sofar : (string * (TERM list * THM)) list ref = ref [];
in
fun add_tt_to_pc (ty : TYPE) : unit = (
let	val (abs,cons) = get_tuple_info ty;
	val def_thm = get_spec (hd cons);
	val abs_nm = fst(dest_const abs);
in
	case lassoc5 (!tt_sofar) abs_nm of
	Nil => (tt_sofar := (abs_nm,(cons, def_thm)) :: (!tt_sofar);
		set_¶_vs_thms (!tt_sofar) "'z_predicate_calculus_build";
		set_merge_pcs ["hol1","'z_predicate_calculus_build"])
	| Value _ => ()
end);
end;

=TEX
Theorems to rewrite with before further existence proof:
=SML
local
val ¶_rw_thms : THM list ref = ref [];
in
fun Ûadd_¶_rw_thmÝ (thm :THM) : unit = (
let	val dummy = (¶_rw_thms := thm :: (!¶_rw_thms));
	val ¶_conv = pure_rewrite_conv (!¶_rw_thms);
in
	(set_cs_¶_convs [¶_conv] "'z_predicate_calculus_build";
	set_merge_pcs ["hol1","'z_predicate_calculus_build"]
	)
end);
end;
=TEX
=SML
local
	val z'abb_def = get_spec ¬$"Z'AbbDef"®;
	val dummy = set_rw_canons 
		[fn thm => [conv_rule(eq_match_conv1 z'abb_def) thm]]
		"'z_predicate_calculus_build";
in
val _ = set_merge_pcs ["hol1","'z_predicate_calculus_build"];
end;
=TEX
\section{Consistency Proofs I}
=SML
val _ = add_tt_to_pc (type_of ñ(x,y)®);
val _ = add_¶_rw_thm (get_spec ¬$"Z'AbbDef"®);
=TEX
=SML
val _ = (
push_consistency_goal ñU ª U®;
a(prove_¶_tac);
save_consistency_thm ñU ª U® (pop_thm()));
=TEX
\section{Concerning The Universe, U}
=SML
push_goal([],¬µ x · ñx  U®®);
a(µ_tac);
set_current_language "HOL";
a(rewrite_tac[get_specñU®,get_spec ñTotality®]);
a(rewrite_tac[get_spec ¬$"Z'T[1]1"®, get_spec ¬$"Z'Mk_T[1]"®]);
set_current_language "Z";
val _u_thm = pop_thm();
=TEX
=SML
val ð_u_thm =  (
push_goal([],¬ñð U = U®®);
a(rewrite_tac[_u_thm]);
a(rewrite_tac[get_specñð U[Totality]®, get_specñU[Totality]®,
	get_specñTotality®]);
a(rewrite_tac[get_spec ¬$"Z'T[1]1"®, get_spec ¬$"Z'Mk_T[1]"®]);
pop_thm());
=TEX
The following is not used in the general $U$ simplification,
but helps get there.
=SML
push_goal([],ñ¬$"Z'¸[2]" ñU® ñU®® = U®);
a(rewrite_tac[_u_thm]);
a(rewrite_tac [get_spec ¬$"Z'¸[2]"®]);
drop_main_goal(); (* HARDLY CORRECT! *)
=TEX
\section{Concerning The Universe, U II}

=SML
push_goal([],ñU ª U = U®);
a(rewrite_tac[_u_thm, get_specñU ª U®]);
drop_main_goal(); (* HARDLY CORRECT! *)
=TEX

\section{Concerning Declarations}
\subsection{Theorems}
=SML
val adecl = mk_z_dec([¬x:'a®],¬s:'a SET®);
push_goal ([],¬µ x:'a; s:'a SET · 
	ñ‘adecl® = ¬x:'a®  ¬s:'a SET®®®);
a(rewrite_tac[get_spec adecl]);
val single_dec_thm = pop_thm();
val sym_single_dec_thm = sym_eqn_rule single_dec_thm;
=TEX
=SML
push_goal ([],¬µ xs:'a LIST; s:'a SET ·  
	ñ¬$"Z'Dec"((xs:'a LIST),(s:'a SET))® = ¬$"Z'Setd"(xs:'a LIST)® € ¬s:'a SET®®®);
a(REPEAT µ_tac);
a(LIST_INDUCTION_T ¬xs:'a LIST® asm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec [¬$"Z'Dec"®,¬$"Z'Setd"®,¬$"z'_ € _"®]));
drop_main_goal(); (* HARDLY CORRECT! *)
=IGN
val many_dec_thm = pop_thm();
val sym_many_dec_thm = sym_eqn_rule many_dec_thm;
=TEX
=SML
val Ûdecsexp_predsexp_thmÝ = prove_rule[get_spec¬$"Z'SchemaDec"®,
		get_spec¬$"Z'SchemaPred"®]
	¬µ x · $"Z'SchemaDec" x = $"Z'SchemaPred" x®;
val Ûpredsexp_decsexp_thmÝ = sym_eqn_rule decsexp_predsexp_thm;
=TEX
\subsection{Functions}
=SML
val Ûdec_pred_convÝ :CONV = (fn tm => (
	(eq_match_conv single_dec_thm ORELSE_C
	eq_match_conv many_dec_thm ORELSE_C
	eq_match_conv decsexp_predsexp_thm
	) tm)
handle (Fail _) =>
term_fail "dec_pred_conv" 41010 [tm]
);
=TEX
=SML
local
in
val ÛÊ_s__s_convÝ : CONV (fn tm =>
let	val (Ês,s) = dest_z_ tm;
	val (s',decor) = dest_z_Ê Ês;
	val dummy = if s' =$ s andalso decor = ""
		then ()
		else fail "Ê_s__s_conv" 0 [];
	val decs = mk_z_decsexp(s',decor);
	val gl = ([],mk_eq(tm,decs));
in
	tac_proof (gl ,
		pure_rewrite_tac[z'Ê_def,
			z'decsexp_def] (* NOT ENOUGH! *)
	)
end);		
=TEX
=SML
val Ûpred_dec_convÝ : CONV = (fn tm =>
	(eq_match_conv sym_single_dec_thm ORELSE_C
	eq_match_conv sym_many_dec_thm ORLSE_C
	eq_match_conv predsexp_decsexp_thm ORLSE_C
	Ê_s__s_conv
	) tm)
handle (Fail _) =>
term_fail "pred_dec_conv" 41010 [tm]
);
=TEX
\section{Concerning The Universe, U, II}
=SML
val dpv_proj_thm = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¬$"Z'S[d,p,v]v"®))
		to 2));

fun Ûseta_u_convÝ (tm : TERM) : THM = (
let	val (decl,pred,vl) = dest_z_seta tm;
	val s1 = eq_match_conv1(get_spec tm) tm;
	val s2 = conv_rule(RIGHT_C(all_Â_conv THEN_C
		pure_rewrite_conv [_u_thm,dpv_proj_thm])) s1;
in	
	s2 (* HARDLY CORRECT! *)
end);
=TEX
\section{Concerning Z Universal Quantification}
=SML
local
	val cnv1 = eq_match_conv1 z'µ_def;
	val cnv2 = eq_match_conv1 z'µbody_def;
	val cnv3 = eq_match_conv1 (sym_eqn_rule z'µbody_def);
	val cnv4 = eq_match_conv1 (sym_eqn_rule z'µ_def);

 	fun var_sort (itym: (string * TYPE)list) : TERM list = (
	let	val sl = idsetseq(fst(split itym));
		val tyl = map (lassoc3 itym) sl;
	in
		map mk_var (combine sl tyl)
	end);
 
in
val Ûz_µ_elim_convÝ :CONV = (
	cnv1 THEN_C ALL_SIMPLE_µ_C cnv2
);

val Ûz_µ_intro_convÝ :CONV = (
all_µ_uncurry_conv AND_OR_C
(fn tm =>
let	val (vs,bdy) = strip_simple_µ tm;
	val ((d,p),v) = (dest_± ** Combinators.I)(dest_´ bdy);
	val dbind =  dest_decl d;
	val vs' = map dest_var vs;
	val vnames = map fst vs';
	val dummy = if vnames ~= (map fst dbind)
		then ()
		else term_fail "z_µ_intro_conv" 41024 [tm];
	val dummy = if all vs' (fn (nm,ty) => lassoc3 dbind nm =: ty)
		then ()
		else term_fail "z_µ_intro_conv" 41024 [tm];
	val s1 = cnv3 bdy;
	val s2 = fold (fn (x,t) => µ_¤_rule x t) vs s1;
	val svs = var_sort vs';
	val rs2 = snd(dest_eq(concl s2));
	val rbs2 = snd(strip_simple_µ rs2);
	val s3 = µ_reorder_conv rs2 (list_mk_simple_µ (svs,rbs2));
	val s4 = eq_trans_rule s2 s3;
	val s5 = conv_rule(RIGHT_C cnv4) s4;
in
	s5
end));
end;
=TEX
Examples:
=GFT
val thm1 = z_µ_elim_conv ñµ z:X; x,y : î  · (x = 0) ² (y = 0) ² (z = z)®;
val tmr = snd(dest_eq(concl thm1));
z_µ_intro_conv tmr;
=SML

Compose a list of type instantiations, checking that we
are not send one type variable to two different types.
=SML
local 
	fun lrassoc5 ((a1,a2) :: x) v = (if a2 =: v
		then Value a1
		else lrassoc5 x v
	) | lrassoc5 [] v = Nil;
in
fun Ûcompose_tyiÝ (tys : (TYPE * TYPE) list list) : (TYPE * TYPE) list = (
let	fun aux1 acc ((tyn,tyo) :: x) = (
		case lrassoc5 acc tyo of
		Nil => aux1 ((tyn,tyo) :: acc) x
		| Value tyn' => (if tyn =: tyn'
			then aux1 acc x
			else fail "compose_tyi" 0 [])
	) | aux1 acc [] = acc;

	fun aux acc [] = acc 
	| aux acc (a :: x) = aux (aux1 acc a) x;
in
	aux [] tys
end);
end;
=TEX
The following copes with three forms of $bind$ - 
a true binding, a single value, or an object with a binding type.
It returns the required specialisations and type instantiations.
=SML
fun Ûmatch_decl_tmÝ (caller : string) (decl : TERM) (tm: TERM) : (string * TERM) list * (TYPE * TYPE) list = (
let	val dbinds = dest_decl decl
		handle complaint =>
		pass_on complaint "dest_decl" caller;
	val dnms = map fst dbinds;
in
=TEX
Conventional binding:
=SML
(let	val tbinds = dest_z_binding tm;
	val dummy = if dnms ~= map fst tbinds
		then ()
		else fail "" 0 [];
	fun aux (nm,ty) = (
	let val v = lassoc3 tbinds nm;
		val tyi = type_match (type_of v) ty;
	in
		tyi
	end);
	val tys = map aux dbinds;
in
	(tbinds,compose_tyi tys)
end
handle (Fail _) =>
=TEX
Single variable in declaration:
=SML
	case dbinds of
	[(nm,ty)] => ([(nm,tm)],type_match (type_of tm) ty)
	| _ => fail "" 0 []
handle (Fail _) =>
=TEX
Term has a binding type:
=SML
let	val to_tm = type_of tm;
	val dbt_tm = dest_bind_type to_tm;
	val (_,projs) = get_binding_info to_tm;
	val projs' = map (fn f => match_mk_app(f,tm)) projs;
	val tbinds = combine(fst (split dbt_tm)) projs';
	val dummy = if dnms ~= map fst tbinds
		then ()
		else fail "" 0 [];
	fun aux (nm,ty) = (
	let val v = lassoc3 tbinds nm;
		val tyi = type_match (type_of v) ty;
	in
		tyi
	end);
	val tys = map aux dbinds;
in
	(tbinds,compose_tyi tys)
end
handle (Fail _) =>
term_fail caller 41021 [tm]
)
end);
=TEX
Tests:
=GFT
val (d,_,_) = dest_z_µ ñµx,y : Z; z : Y · true®;
val (d1,_,_) = dest_z_µ ñµx : Z· true®;
val tm1 = ñ(y ¦ 1, x ¦ 2, z ¦ y)®;

match_decl_tm "hello" d tm1;
match_decl_tm "hello" d (mk_var("B",type_of tm1));
match_decl_tm "hello" d1 ¬1®;
=TEX
fun Ûµ_elim_by_templateÝ (template : (string * TERM)list)(thm : THM) : THM = (
let	val (vs,_) = strip_simple_µ (concl thm);
	val exps = map (lassoc3 template) (map (fst o dest_var) vs);
in
	list_simple_µ_elim exps thm
end);
=SML
local
	val cnv1 = eq_match_conv1 z'µ_def;
	val cnv2 = eq_match_conv1 z'µbody_def;
in
fun Ûz_µ_elimÝ (tm : TERM) (thm : THM) : THM = (
let	val (d,p,v) = dest_z_µ (concl thm)
		handle complaint =>
		pass_on complaint "dest_z_µ" "z_µ_elim";
	val (specs,insts) = match_decl_tm "z_µ_elim" d tm;
	val s1 = conv_rule cnv1 thm;
	val s2 = inst_type_rule insts s1
		handle complaint =>
		pass_on complaint "inst_type_rule" "z_µ_elim";
	val s3 = µ_elim_by_template specs s2;
	val s4 = conv_rule cnv2 s3;
	val s5 = conv_rule (LEFT_C(LEFT_C id_conv)) s4;
		(* should actually change the declaration to
		   a predicate *)
	val s6 = check_is_z_thm "z_µ_elim" s5;
		(* should actually make any renaming changes
		   the declaration to the thm *)
in
	s6
end);
end;
=TEX
=SML
local
val cnv1 = eq_match_conv1 (taut_rule ¬µ t · (t ¤ (T ´ t)) ¤ T®);
val cnv2 = eq_match_conv1 (taut_rule ¬µ t · F ´ t ¤ T®);
val thm1 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(simple_µ_intro ¬d:BOOL®
	(list_simple_µ_elim[¬d:BOOL®, mk_f] z'µbody_def));
val cnv3 = eq_match_conv1 thm1;
val tac1 = pure_rewrite_tac[z'µ_def,µ_rewrite_thm,
	eq_rewrite_thm];
val cnv4 = eq_match_conv1 (taut_rule ¬µ t · (t ¤ (t ² F)) ¤ T®);
val cnv5 = eq_match_conv1 (taut_rule ¬µ t · t ² T ¤ T®);
val thm2 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(list_simple_µ_intro [¬d:BOOL®,¬p:BOOL®]
	(list_simple_µ_elim[¬d:BOOL®, ¬p:BOOL®, mk_t] z'µbody_def));
val cnv6 = eq_match_conv1 thm2;
val cnv7 = eq_match_conv1 (taut_rule ¬µ s t · (t ´ (s ² T)) ¤ T®);
val cnv8 = eq_match_conv1 (taut_rule ¬µ t · (t ¤ (T ´ (t ² F))) ¤ T®);
fun Z_µ_P_C cnv = RAND_C(ALL_SIMPLE_µ_C(LEFT_C cnv));
fun Z_µ_V_C cnv = RAND_C(ALL_SIMPLE_µ_C(RIGHT_C cnv));

fun cnv9 thm = APP_C(RAND_C(Z_µ_P_C(fn _ => thm)),(LEFT_C(fn _ => thm)));
fun cnv10 thm = APP_C(RAND_C(Z_µ_V_C(fn _ => thm)),(RIGHT_C(fn _ => thm)));
fun cnv11 thm = APP_C(RAND_C(Z_µ_V_C(fn _ => thm)),RIGHT_C(RIGHT_C(fn _ => thm)));

in
val Ûz_µ_inv_convÝ : CONV = (fn tm => 
let	val (d,p,v) = dest_z_µ tm
		handle complaint =>
		pass_on complaint "dest_z_µ" "z_µ_inv_conv";
	val vs = fst(strip_simple_µ(snd(dest_app tm)));
in
	case (any (frees p) (fn x => x term_mem vs) andalso (not (is_t p)),
		any (frees v) (fn x => x term_mem vs) andalso (not (is_f v))) of
 	(true, true) => term_fail "z_µ_inv_conv" 41025 [tm]
	| (false, true) => tac_proof(([],mk_eq(tm,
			mk_´(p,mk_z_µ(d,mk_t,v)))),
		²_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv1,
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv3))), cnv2)) THEN
		tac1] )
	| (true, false) =>  tac_proof(([],mk_eq(tm,
			mk_²(mk_z_µ(d,p,mk_f),v))),
		²_THEN (conv_tac o cnv10) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv6))), cnv5)) THEN
		tac1,
		conv_tac cnv4] )
	| (false,false) => tac_proof(([],mk_eq(tm,
			mk_´(p,mk_²(mk_z_µ(d,mk_t,mk_f),v)))),
		²_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) THEN
		²_THEN (conv_tac o cnv11) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv6)), cnv7)) THEN
		tac1,
		conv_tac cnv8,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv6)), cnv7)) THEN
		tac1,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_µ_C cnv3)), cnv2)) THEN
		tac1		
		])
end);
end;
=TEX
Examples:
=GFT
z_µ_inv_conv ñµ x ,y : X | f · g®;
z_µ_inv_conv ñµ x ,y : X | x > 0 · z®;
z_µ_inv_conv ñµ x,y : X | f · x = y®;
=TEX
\section{Concerning Z Existential Quantification}
=SML
local
val cnv1 = eq_match_conv1 (taut_rule ¬µ t · (t ¤ (T ± t)) ¤ T®);
val cnv2 = eq_match_conv1 (taut_rule ¬µ t · F ± t ¤ F®);
val thm1 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(simple_µ_intro ¬d:BOOL®
	(list_simple_µ_elim[¬d:BOOL®, mk_f] z'¶body_def));
val cnv3 = eq_match_conv1 thm1;
val tac1 = pure_rewrite_tac[z'¶_def,¶_rewrite_thm,
	eq_rewrite_thm];
val cnv4 = eq_match_conv1 (taut_rule ¬µ t · (t ¤ (t ± T)) ¤ T®);
val cnv5 = eq_match_conv1 (taut_rule ¬µ t · t ± F ¤ F®);
val thm2 = conv_rule(ALL_SIMPLE_µ_C (RIGHT_C (rewrite_conv[])))
	(list_simple_µ_intro [¬d:BOOL®,¬p:BOOL®]
	(list_simple_µ_elim[¬d:BOOL®, ¬p:BOOL®, mk_f] z'¶body_def));
val cnv6 = eq_match_conv1 thm2;
val cnv7 = eq_match_conv1 (taut_rule ¬µ s t · (t ± s ± F) ¤ F®);
val cnv8 = eq_match_conv1 (taut_rule ¬µ t · (t ¤ (T ± t ± T)) ¤ T®);
fun Z_¶_P_C cnv = RAND_C(ALL_SIMPLE_¶_C(LEFT_C cnv));
fun Z_¶_V_C cnv = RAND_C(ALL_SIMPLE_¶_C(RIGHT_C cnv));

fun cnv9 thm = APP_C(RAND_C(Z_¶_P_C(fn _ => thm)),(LEFT_C(fn _ => thm)));
fun cnv10 thm = APP_C(RAND_C(Z_¶_V_C(fn _ => thm)),(RIGHT_C(fn _ => thm)));
fun cnv11 thm = APP_C(RAND_C(Z_¶_V_C(fn _ => thm)),RIGHT_C(RIGHT_C(fn _ => thm)));

in
val Ûz_¶_inv_convÝ : CONV = (fn tm => 
let	val (d,p,v) = dest_z_¶ tm
		handle complaint =>
		pass_on complaint "dest_z_¶" "z_¶_inv_conv";
	val vs = fst(strip_simple_¶(snd(dest_app tm)));
in
	case (any (frees p) (fn x => x term_mem vs) andalso (not (is_t p)),
		any (frees v) (fn x => x term_mem vs) andalso (not (is_f v))) of
 	(true, true) => term_fail "z_¶_inv_conv" 41025 [tm]
	| (false, true) => tac_proof(([],mk_eq(tm,
			mk_±(p,mk_z_¶(d,mk_t,v)))),
		²_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv1,
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_¶_C cnv3))), cnv2)) THEN
		tac1] )
	| (true, false) =>  tac_proof(([],mk_eq(tm,
			mk_±(mk_z_¶(d,p,mk_t),v))),
		²_THEN (conv_tac o cnv10) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv4,
		conv_tac(APP_C ((RAND_C(RAND_C(ALL_SIMPLE_¶_C cnv6))), cnv5)) THEN
		tac1] )
	| (false,false) => tac_proof(([],mk_eq(tm,
			mk_±(p,mk_±(mk_z_¶(d,mk_t,mk_t),v)))),
		²_THEN (conv_tac o cnv9) (µ_elim p bool_cases_axiom) THEN
		²_THEN (conv_tac o cnv11) (µ_elim v bool_cases_axiom) 
		THEN_LIST [
		conv_tac cnv8,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_¶_C cnv6)), cnv7)) THEN
		tac1,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_¶_C cnv3)), cnv2)) THEN
		tac1,
		conv_tac(APP_C(RAND_C(RAND_C(ALL_SIMPLE_¶_C cnv6)), cnv7)) THEN
		tac1
		])
end);
end;
=TEX
Examples:
=GFT
z_¶_inv_conv ñ¶ x ,y : X | f · g®;
z_¶_inv_conv ñ¶ x ,y : X | x > 0 · z®;
z_¶_inv_conv ñ¶ x,y : X | f · x = y®;
=TEX
\subsection{Conversions between Z Universal and Existential Quantifications}
=SML
die;
local
val thm1 = prove_rule [z'µ_def] ¬µ x · ³ ($"Z
\section{EPILOGUE}
=IGN
val _ = open_theory lthy;
val _ = pop_pc();
=IGN
end; (* local open ... *)
end; (* of structure ZPredicateCalculus *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
