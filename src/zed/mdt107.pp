=IGN
********************************************************************************
mdt107.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Module Tests: Z Fiiteness and Sequences}

\def\AbstractText{This document gives the module tests for the Z Finiteness and Sequences material.}

\def\Reference{DS/FMU/IED/MDT107}

\def\Author{K. Blackburn}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{FST PROJECT}  %% Mandatory field
%% LaTeX2e port: \TPPtitle{Module Tests: Z Fiiteness and Sequences}
%% LaTeX2e port: \TPPref{DS/FMU/IED/MDT107}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{$Revision: 1.12 $
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{\FormatDate{$Date: 2005/08/04 12:05:51 $ %
%% LaTeX2e port: }}  %% Mandatory field
%% LaTeX2e port: \TPPstatus{Draft}			%% Mandatory field
%% LaTeX2e port: \TPPtype{SML Literate Script}
%% LaTeX2e port: \TPPkeywords{}
%% LaTeX2e port: \TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%% LaTeX2e port: %\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
%% LaTeX2e port: \TPPauthorisation{R.D.Arthan & FST Team Leader}
%% LaTeX2e port: \TPPabstract{This document gives the module tests for the
%% LaTeX2e port: Z Finiteness and Sequences material.}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port: 	    Project Library
%% LaTeX2e port: }}
%% LaTeX2e port: %\TPPclass{CLASSIFICATION}
%% LaTeX2e port: %\def\TPPheadlhs{}
%% LaTeX2e port: %\def\TPPheadcentre{}
%% LaTeX2e port: %def\TPPheadrhs{}
%% LaTeX2e port: %\def\TPPfootlhs{}
%% LaTeX2e port: %\def\TPPfootcentre{}
%% LaTeX2e port: %\def\TPPfootrhs{}
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 (1996/01/16)]
First version.
\item [Issue 1.2 (1996/03/26)--1.4 (1996/06/14)]
Added $z\_size\_dot\_dot\_conv$.
\item [Issue 1.5 (2001/07/05)]
Added material on sequence displays.
\item [Issue 1.6 (2002/07/10)]
Added tests for induction tactics.
\item[Issue 1.7 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.8 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.9 (2003/04/30)] Added tests for conversion for equality of sequence displays.
\item[Issue 1.10 (2004/01/19)] The Z universal set is now called ùïå.
\item[Issue 1.11 (2005/02/26)] Precedences and associativity of toolkit operators now follow \cite{ISO02}.
\item[Issue 1.12 (2005/08/04)] Made it work in child databases.
\item[Issue 1.13 (2007/05/28)] Added tests for {\em z\_dot\_dot\_conv}.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

\item[2015/04/17]
Ported PPZed to Lemma 1 document template.
\item[2018/09/18]
Added tests for
=INLINEFT
z_string_conv
=TEX
.

%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes Forecast}

\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in \cite{DS/FMU/IED/DTD107}.
\subsection{Introduction}
This document contains the module tests for the material
whose detailed design is given in \cite{DS/FMU/IED/DTD107}.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP107} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
Mainly doing just theory testing at present.
\section{TEST CASES}
The functions are tested in their order of presentation in the detailed design.
\section{PREAMBLE ZFunctions1}
=SML
open_theory "z_functions1";
delete_theory "temp" handle _ => ();
new_theory "temp";
set_pc "z_language";
use_file "dtd013";
use_file "imp013";
init_mt_results();
(* set_flag("subgoal_package_quiet",true); *)
repeat drop_main_goal;
set_flag("check_is_z",true);
=TEX

\subsection{Utilities}
=SML
fun ‚¶èlist_eq‚¶é (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
If two terms types are equal, break them apart until they differ.
=SML
fun ‚¶èdiffer_where‚¶é itm1 itm2 = (
let	fun aux tm1 tm2 (App(f1,x1)) (App(f2,x2)) = (
		Value(force_value(aux f1 f2 (dest_simple_term f1) (dest_simple_term f2)))
		handle _ =>
		aux x1 x2 (dest_simple_term x1) (dest_simple_term x2))
	| aux tm1 tm2 (Const(nm1,ty1)) (Const(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (Var(nm1,ty1)) (Var(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (SimpleŒª(x1,b1)) (SimpleŒª(x2,b2)) = (
		if x1 =$ x2
		then aux b1 b2 (dest_simple_term b1) (dest_simple_term b2)
		else Value(tm1,tm2))
	| aux tm1 tm2 _ _ = Value(tm1,tm2);
in
	aux itm1 itm2 (dest_simple_term itm1) (dest_simple_term itm2)
end);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal.
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun ‚¶ètac_res‚¶é tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun ‚¶ètac_res‚¶é tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun ‚¶ètac_res1‚¶é tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (rasms,gl) = top_goal()
		in
			(drop_main_goal();
			(rasms,gl))
		end);
=TEX
Now a function that returns the multiple goals for the case when a tactic causes multiple goals:
=SML
fun ‚¶ètac_ress‚¶é tac n (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val gll = map (top_labelled_goal o string_of_int)
			(interval 1 n)
		in
			(drop_main_goal();
			gll)
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun ‚¶ètac_solve‚¶é tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun ‚¶ètac_fail‚¶é tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX

\section{TESTS}
\section{CHECK THE THEORY DESIGN}
=SML
use_file "dtd107.tch";
store_mt_results mt_run [("theory design of ZFunctions1",
	(fn _ => z_functions1_success),
	(),
	true)];
store_mt_results mt_run [("theory design of ZNumbers1",
	(fn _ => z_numbers1_success),
	(),
	true)];
store_mt_results mt_run [("theory design of ZSequences1",
	(fn _ => z_sequences1_success),
	(),
	true)];
=TEX
\subsection{Tools}
=SML
store_mt_results (mt_runf (op =$)) [("z_size_dot_dot_conv 1",
	snd o dest_eq o concl o  z_size_dot_dot_conv,
	‚ì©#( 2 .. 6)‚åù,
	‚ì©5‚åù),
	("z_size_dot_dot_conv 2",
	snd o dest_eq o concl o  z_size_dot_dot_conv,
	‚ì©#( 6 .. 2)‚åù,
	‚ì©0‚åù),
	("z_size_dot_dot_conv 3",
	snd o dest_eq o concl o  z_size_dot_dot_conv,
	‚ì©#( 6 .. 6)‚åù,
	‚ì©1‚åù),
	("z_size_dot_dot_conv 34",
	snd o dest_eq o concl o  z_size_dot_dot_conv,
	‚ì©#( ~6 .. ~6)‚åù,
	‚ì©1‚åù),
	("z_size_dot_dot_conv 5",
	snd o dest_eq o concl o  z_size_dot_dot_conv,
	‚ì©#( ~9 .. ~7)‚åù,
	‚ì©3‚åù)];
store_mt_results mt_run_fail [("z_size_dot_dot_conv 107001 a",
	z_size_dot_dot_conv,
	‚ì©5‚åù,
	gen_fail_msg "z_size_dot_dot_conv" 107001 ["‚ì©5‚åù"]),
	("z_size_dot_dot_conv 107001 b",
	z_size_dot_dot_conv,
	‚ì©size (5 .. a)‚åù,
	gen_fail_msg "z_size_dot_dot_conv" 107001 ["‚ì©size (5 .. a)‚åù"])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_dot_dot_conv 1",
	snd o dest_eq o concl o  z_dot_dot_conv,
	‚ì©2 .. 6‚åù,
	‚ì©{2, 3, 4, 5, 6}‚åù),
	("z_dot_dot_conv 2",
	snd o dest_eq o concl o  z_dot_dot_conv,
	‚ì©6 .. 2‚åù,
	‚ì©{} ‚¶Ç ‚Ñô{1}‚åù),
	("z_dot_dot_conv 3",
	snd o dest_eq o concl o  z_dot_dot_conv,
	‚ì©6 .. 6‚åù,
	‚ì©{6}‚åù),
	("z_dot_dot_conv 4",
	snd o dest_eq o concl o  z_dot_dot_conv,
	‚ì©~1 .. 1‚åù,
	‚ì©{~1, 0, 1}‚åù),
	("z_dot_dot_conv 5",
	snd o dest_eq o concl o  z_dot_dot_conv,
	‚ì©~1 .. ~2‚åù,
	‚ì©{} ‚¶Ç ‚Ñô{1}‚åù)];
store_mt_results mt_run_fail [("z_dot_dot_conv 107001 a",
	z_dot_dot_conv,
	‚ì©5‚åù,
	gen_fail_msg "z_dot_dot_conv" 107002 ["‚ì©5‚åù"]),
	("z_dot_dot_conv 107002 b",
	z_dot_dot_conv,
	‚ì©size (5 .. a)‚åù,
	gen_fail_msg "z_dot_dot_conv" 107002 ["‚ì©size (5 .. a)‚åù"])];
=TEX
\section{SEQUENCE DISPLAYS}
=SML
open_theory"z_sequences1";
delete_theory "temp" handle _ => ();
new_theory "temp";
=TEX
=SML
store_mt_results
(mt_runf (fn (thm, tm) => snd(dest_eq(concl thm)) =$ tm))
[
	("2.1.1", rewrite_conv[z_seqd_‚ÅÄ_rw_thm, z_seqd_‚ÅÄ_‚ü®‚ü©_clauses], ‚ì©‚ü®1, y‚ü©‚åù, ‚ì©‚ü®1‚ü© ‚ÅÄ ‚ü®y‚ü©‚åù),
	("2.1.2", rewrite_conv[z_seqd_‚ÅÄ_rw_thm, z_seqd_‚ÅÄ_‚ü®‚ü©_clauses], ‚ì©‚ü®x, 2, z‚ü©‚åù, ‚ì©‚ü®x‚ü© ‚ÅÄ (‚ü®2‚ü© ‚ÅÄ ‚ü®z‚ü©)‚åù),
	("2.1.3", rewrite_conv[z_seqd_‚ÅÄ_rw_thm, z_seqd_‚ÅÄ_‚ü®‚ü©_clauses], ‚ì©‚ü®x, 2, z, w‚ü©‚åù, ‚ì©‚ü®x‚ü© ‚ÅÄ (‚ü®2‚ü© ‚ÅÄ (‚ü®z‚ü© ‚ÅÄ ‚ü®w‚ü©))‚åù)
];
=TEX
=SML
store_mt_results
(mt_runf (fn (thm, tm) => snd(dest_eq(concl thm)) =$ tm))
[
	("2.2.1", z_seqd_app_conv, ‚ì©‚ü®"a"‚ü© 1‚åù, ‚ì©"a"‚åù),
	("2.2.2", z_seqd_app_conv, ‚ì©‚ü®"a", "b"‚ü© 1‚åù, ‚ì©"a"‚åù),
	("2.2.3", z_seqd_app_conv, ‚ì©‚ü®"a", "b"‚ü© 2‚åù, ‚ì©"b"‚åù),
	("2.2.4", z_seqd_app_conv, ‚ì©‚ü®"a", "b", "c", "d"‚ü© 4‚åù, ‚ì©"d"‚åù)
];
=TEX
=SML
store_mt_results
mt_run_fail [("2.3.1", z_seqd_app_conv, ‚ì©(~4)‚åù,
	gen_fail_msg "z_seqd_app_conv" 107011 (map string_of_term[‚ì©~ 4‚åù])),
	("2.3.2", z_seqd_app_conv, ‚ì©‚ü®a, b, c, d, x‚ü© (~4)‚åù,
	gen_fail_msg "z_seqd_app_conv" 107012 (map string_of_term[‚ì©~ 4‚åù])),
	("2.3.3", z_seqd_app_conv, ‚ì©‚ü®a, b, c, d, x‚ü© (7)‚åù,
	gen_fail_msg "z_seqd_app_conv" 107013 (map string_of_term[‚ì©7‚åù, ‚ì©‚ü®a, b, c, d, x‚ü©‚åù]))
];
=TEX
=SML
store_mt_results
(mt_runf (fn (thm, tm) => snd(dest_eq(concl thm)) =$ tm))
[
	("2.4.1", z_size_seqd_conv,  ‚ì©#‚ü®‚ü©‚åù, ‚ì©0‚åù),
	("2.4.2", z_size_seqd_conv, ‚ì©#‚ü®x‚ü©‚åù, ‚ì©1‚åù),
	("2.4.3", z_size_seqd_conv, ‚ì©#‚ü®x, y, z, a,  b, c‚ü©‚åù, ‚ì©6‚åù)
];
=TEX
=SML
store_mt_results
mt_run_fail [("2.5.1", z_size_seqd_conv, ‚ì©# (tail s)‚åù,
	gen_fail_msg "z_size_seqd_conv" 107021 (map string_of_term[‚ì©# (tail s)‚åù]))
];
=TEX
=SML
val old_tic = TypeInference.get_ti_context();
TypeInference.set_ti_context[];
TypeInference.set_ti_context[
	‚åúx1 : ‚Ñ§‚åù,
	‚åúx2 : ‚Ñ§‚åù,
	‚åúx3 : ‚Ñ§ ‚åù,
	‚åúx4 : ‚Ñ§ ‚åù,
	‚åúx5 : ‚Ñ§ ‚åù,
	‚åúy1 : ‚Ñ§ ‚åù,
	‚åúy2 : ‚Ñ§ ‚åù,
	‚åúy3 : ‚Ñ§ ‚åù,
	‚åúy4 : ‚Ñ§ ‚åù,
	‚åúy5 : ‚Ñ§ ‚åù
];
store_mt_results
(mt_runf (fn (thm, tm) => snd(dest_eq(concl thm)) =$ tm))
[
	("2.6.1", z_seqd_eq_conv,  ‚ì©‚ü®‚ü© = ‚ü®‚ü©‚åù, ‚ì© true ‚åù),
	("2.6.2", z_seqd_eq_conv,  ‚ì©‚ü®x1‚ü© = ‚ü®y1‚ü©‚åù, ‚ì© x1 = y1‚åù),
	("2.6.3", z_seqd_eq_conv,  ‚ì©‚ü®x1‚ü© = ‚ü®x1‚ü©‚åù, ‚ì© true ‚åù),
	("2.6.4", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2‚ü© = ‚ü®y1‚ü©‚åù, ‚ì© false ‚åù),
	("2.6.5", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2, x3, x4‚ü© = ‚ü®y1, y2‚ü©‚åù, ‚ì© false ‚åù),
	("2.6.6", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2, x3, x4‚ü© = ‚ü®y1, x2, y3, x4‚ü©‚åù, ‚ì© x1 = y1 ‚àß x3 = y3 ‚åù),
	("2.6.7", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2‚ü© = ‚ü®‚ü©‚åù, ‚ì© false ‚åù),
	("2.6.8", z_seqd_eq_conv,  ‚ì©‚ü®‚ü© = ‚ü®x1, x2‚ü©‚åù, ‚ì© false ‚åù),
	("2.6.9", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2‚ü© = ‚ü®y1, 2‚ü©‚åù, ‚ì© x1 = y1 ‚àß x2 = 2 ‚åù),
	("2.6.10", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2, x3‚ü© = ‚ü®y1, y2, y3‚ü©‚åù, ‚ì© x1 = y1 ‚àß x2 = y2 ‚àß x3 = y3 ‚åù),
	("2.6.11", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2, x3, x4‚ü© = ‚ü®1, y2, y3, y4‚ü©‚åù, ‚ì© x1 = 1 ‚àß x2 = y2 ‚àß x3 = y3 ‚àß x4 = y4‚åù),
	("2.6.12", (TOP_MAP_C z_seqd_eq_conv),  ‚ì©‚ü®‚ü®2‚ü©, ‚ü®4‚ü©, ‚ü®4, 54, 1‚ü©, ‚ü®5‚ü©‚ü© = ‚ü®‚ü®2‚ü©, ‚ü®4‚ü©, ‚ü®4, 54, 1‚ü©, ‚ü®5‚ü©‚ü©‚åù, ‚ì© true ‚åù),

	("2.6.13", z_seqd_eq_conv,  ‚ì©‚ü®x1, x2, x3, x4, x5‚ü© = ‚ü®y1, y2, y3, y4, x5‚ü©‚åù, ‚ì© x1 = y1 ‚àß x2 = y2 ‚àß x3 = y3 ‚àß x4 = y4 ‚åù),
	("2.6.14", z_seqd_eq_conv,  ‚ì©‚ü®a1, a2‚ü© = ‚ü®"a", "b"‚ü©‚åù, ‚ì© a1 = "a" ‚àß a2 = "b" ‚åù)
];
TypeInference.set_ti_context old_tic;
=TEX
\section{SEQUENCE INDUCTION}
=TEX
Correct operation of the tactics
=INLINEFT
z_ùîΩ_induction_tac
=TEX
\ and  {\it z\_seq\_induction\_thm} is validated by their use in
proving the theorems in the theory. Here we check correct operation
of {\it z\_seq\_induction\_thm1} and error cases for the other two.
=TEX
=SML
store_mt_results
mt_run [
	("z_seq_induction_tac1.1",
	tac_solve
	(REPEAT strip_tac THEN z_seq_induction_tac ‚ì©is ‚¶Ç seq ‚Ñï‚åù THEN_LIST [
	DROP_NTH_ASM_T 2 (fn th => ante_tac (z_‚àÄ_elim ‚ì©(i‚âú i ‚¶Ç ‚Ñï, is ‚âú ‚ü®‚ü© ‚¶Ç seq ‚Ñï)‚åù th))  THEN
	strip_asm_tac (z_‚àÄ_elim ‚ì©i ‚¶Ç ‚Ñï‚åù z_singleton_seq_thm) THEN
	rewrite_tac[ z_‚ü®‚ü©_seq_thm] THEN
	ALL_FC_T rewrite_tac[ z_‚ü®‚ü©_seq_thm, z_‚ü®‚ü©_‚ÅÄ_thm, z_‚ÅÄ_‚ü®‚ü©_thm] THEN
	REPEAT strip_tac,
	(lemma_tac ‚ì©‚ü®i‚ü© ‚àà seq ‚Ñï ‚àß ‚ü®x‚ü© ‚àà seq ‚Ñï‚åù THEN1
		asm_rewrite_tac[z_singleton_seq_x_thm]) THEN
	all_fc_tac[z_seq_u_thm] THEN
	ALL_FC_T rewrite_tac[z_‚ÅÄ_assoc_thm1] THEN
	(lemma_tac ‚ì©‚ü®i‚ü© ‚ÅÄ is ‚àà seq ‚Ñï‚åù THEN1
		ALL_FC_T1 fc_‚áî_canon asm_rewrite_tac[z_‚ÅÄ_seq_x_thm]) THEN
	ALL_ASM_FC_T asm_rewrite_tac[] THEN
	PC_T1 "z_lin_arith" prove_tac[]
	]),
	([], ‚ì©‚àÄf:ùïå | f ‚ü®‚ü© = 0 ‚àß (‚àÄi:‚Ñï; is : seq ‚Ñï‚¶Åf(is ‚ÅÄ ‚ü®i‚ü©)  = i + f is) ‚¶Å
		(‚àÄi:‚Ñï; is : seq ‚Ñï‚¶Åf(‚ü®i‚ü© ‚ÅÄ is)= i + f is)‚åù),
	true)
];
=TEX
=SML
store_mt_results
mt_run_fail [
("z_seq_induction_tac.fail.1",
	tac_fail ( z_seq_induction_tac ‚ì©s ‚¶Ç seq ‚Ñ§‚åù),
	([],‚ì©true‚åù),
	gen_fail_msg "z_seq_induction_tac"  107031 []),
("z_seq_induction_tac1.fail.1",
	tac_fail ( z_seq_induction_tac1 ‚ì©s ‚¶Ç seq ‚Ñ§‚åù),
	([],‚ì©true‚åù),
	gen_fail_msg "z_seq_induction_tac1"  107031 []),
("z_ùîΩ_induction_tac.fail.1",
	tac_fail ( z_ùîΩ_induction_tac ‚ì©a ‚¶Ç ‚Ñô ‚Ñ§‚åù),
	([],‚ì©true‚åù),
	gen_fail_msg "z_ùîΩ_induction_tac"  107033 [])
];
=TEX
=SML
store_mt_results
mt_run_fail [
("z_seq_induction_tac.fail.2",
	z_seq_induction_tac,
	‚ì©1‚åù,
	gen_fail_msg "z_seq_induction_tac"  107032 ["‚ì©1‚åù"]),
("z_seq_induction_tac1.fail.2",
	z_seq_induction_tac1,
	‚ì©1‚åù,
	gen_fail_msg "z_seq_induction_tac1"  107032 ["‚ì©1‚åù"]),
("z_ùîΩ_induction_tac.fail.2",
	z_ùîΩ_induction_tac,
	‚ì©1‚åù,
	gen_fail_msg "z_ùîΩ_induction_tac"  107032 ["‚ì©1‚åù"])
];
=TEX
=SML
store_mt_results
mt_run_fail [
("z_seq_induction_tac.fail.3",
	tac_fail ( z_seq_induction_tac ‚ì©s ‚¶Ç seq ‚Ñ§‚åù),
	([‚ì©s ‚àà seq ‚Ñï‚åù],‚ì©true‚åù),
	gen_fail_msg "z_seq_induction_tac"  86404 ["‚ì©s‚åù"]),
("z_seq_induction_tac1.fail.3",
	tac_fail ( z_seq_induction_tac1 ‚ì©s ‚¶Ç seq ‚Ñ§‚åù),
	([‚ì©s ‚àà seq ‚Ñï‚åù],‚ì©true‚åù),
	gen_fail_msg "z_seq_induction_tac1"  86404 ["‚ì©s‚åù"]),
("z_ùîΩ_induction_tac.fail.3",
	tac_fail ( z_ùîΩ_induction_tac ‚ì©a ‚¶Ç ‚Ñô ‚Ñ§‚åù),
	([‚ì©a ‚àà ùîΩ ‚Ñï‚åù],‚ì©true‚åù),
	gen_fail_msg "z_ùîΩ_induction_tac"  86404 ["‚ì©a‚åù"])
];
=TEX
=SML
store_mt_results
mt_run_fail [
("z_seq_induction_tac.fail.4",
	tac_fail ( z_seq_induction_tac ‚ì©s ‚¶Ç seq ‚Ñ§‚åù),
	([‚ì©s ‚àà seq ‚Ñï‚åù, ‚ì©s = ‚ü®1‚ü©‚åù],‚ì©s = ‚ü®1‚ü©‚åù),
	gen_fail_msg "z_seq_induction_tac"  86403 ["‚ì©s‚åù"]),
("z_seq_induction_tac1.fail.4",
	tac_fail ( z_seq_induction_tac1 ‚ì©s ‚¶Ç seq ‚Ñ§‚åù),
	([‚ì©s ‚àà seq ‚Ñï‚åù, ‚ì©s = ‚ü®1‚ü©‚åù],‚ì©s = ‚ü®1‚ü©‚åù),
	gen_fail_msg "z_seq_induction_tac1"  86403 ["‚ì©s‚åù"]),
("z_ùîΩ_induction_tac.fail.4",
	tac_fail ( z_ùîΩ_induction_tac ‚ì©a ‚¶Ç ‚Ñô ‚Ñ§‚åù),
	([‚ì©a ‚àà ùîΩ ‚Ñï‚åù, ‚ì©a = {1}‚åù],‚ì©a = {1}‚åù),
	gen_fail_msg "z_ùîΩ_induction_tac"  86403 ["‚ì©a‚åù"])
];
=TEX
\section{STRING EQUALITY}
=SML
fun tzsec tm1 tm2 = (
	let	val thm = z_string_eq_conv tm1;
		val res = mk_eq (tm1, tm2);
	in	asms thm = [] andalso concl thm = res
	end
);

store_mt_results
mt_run
[
	("2.7.1", tzsec ‚ì©"" = ""‚åù, ‚ì©true‚åù, true),
	("2.7.2", tzsec ‚ì©"a" = "a"‚åù, ‚ì©true‚åù, true),
	("2.7.3", tzsec ‚ì©"abcd" = "abcd"‚åù, ‚ì©true‚åù, true),
	("2.7.4", tzsec ‚ì©"abcd" = "abce"‚åù, ‚ì©false‚åù, true),
	("2.7.5", tzsec ‚ì©"abcd" = "bbcd"‚åù, ‚ì©false‚åù, true),
	("2.7.6", tzsec ‚ì©"abcd" = "accd"‚åù, ‚ì©false‚åù, true)
];
=TEX
=SML
store_mt_results
mt_run_fail [
("2.7.7",
	z_string_eq_conv,
	‚ì©(s ‚¶Ç seq ùïä) = "abc"‚åù,
	gen_fail_msg "z_string_eq_conv"  107030 ["‚ì©s = \"abc\"‚åù"])
];


=TEX
\section{END OF TESTS}
=SML
(* set_flag("subgoal_package_quiet",false); *)
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
