=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Library Proof Support}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD083}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{G.~Prout  & WIN01\\K.~Blackburn&WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
proof support for the Z Library.}
\TPPdistribution{\parbox[t]{4.0in}{%
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}

\item [Issue 1.1]
First version, derived from \cite{DS/FMU/IED/DTD042}.
\item [Issue 1.2 (20th October 1992)]
Typo fixing.
\item [Issue 1.3 (21th October 1992)]
Added $z\_rel\_inv\_thm$ into appropriate proof context.
Added $z\-\_ç\-\_first\-\_thm$, $z\-\_ç\-\_second\-\_thm$.
\item [Issue 1.4 (22nd October 1992)]
Changed $z\_id\_thm$.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for proof support for
the Z Library, described in \cite{DS/FMU/IED/HLD015}. The rules and theorems cover set theory and associated constructs.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP083}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of proof support for
the Z Library.
\subsubsection{Dependencies}
Loading this document is dependent on 
the Z Library, \cite{DS/FMU/IED/IMP078}.
\subsubsection{Deficiencies}
Perhaps ought to use theory check mechanisms.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $Ò...Æ$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $¡\_to\_z\_conv$ to correct
what problems it can.
=DOC
signature €ZLibraryProofSupport› = sig
=DESCRIBE
This provides the basic proof support for the Z library.
=ENDDOC
=THDOC
req_name €"z_library_ps"› (Value "z_library");
req_language "Z";
=DESCRIBE
The theory $z\_library\_ps$ contains various ``defining theorems'' of Z library constants, derived from the definitions of
those constants, and consistency theorems for those
constants where necessary.
It is created in structure $ZLibraryProofSupport$.
=ENDDOC

\section{TUPLES}
This is a reworking of the language functions, but
with a knowledge of $Ì$.
=DOC
val €z_tuple_eq_conv› : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_eq_conv 
Ò(tâ1,tâ2,...) = (uâ1,uâ2,...)Æ
˜
˜
Ù (tâ1,tâ2,...) = (uâ1,uâ2,...) § 
((tâ1 = uâ1) ± (tâ2 = uâ2) ± ...) 
=TEX
$x\ Ì\ y$ will be treated as a 2-tuple.

Remains within the Z language.
=SEEALSO
$z\_tuple\_lang\_eq\_conv$
=FAILURE
42003	?0 is not of the form: Ò(x1,...) = (y1,...)Æ
=ENDDOC
=DOC
val €z_tuple_selection_conv› : CONV;
=DESCRIBE
This conversion carries out the
selection from a tuple display.
=FRULE 1 Conversion
z_tuple_selection_conv 
Ò(tâ1,...,tâi,...,tân).iÆ
˜
˜
Ù (tâ1,...,tâi,...,tân).i = tâi
=TEX
$x\ Ì\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_selection\_conv$
=FAILURE
47185	?0 is not a Z tuple selection
42006	?0 is not of the form Ò(x,...).iÆ
=ENDDOC
=DOC
val €z_tuple_intro_conv› : CONV;
=DESCRIBE
This conversion carries out the
elimination of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_intro_conv 
Ò(t.1,...,t.n)Æ
˜
˜
Ù (t.1,...,t.n) = t
=TEX
where $n$ is the arity of $t$.
$x\ Ì\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_intro\_conv$
=FAILURE
42005	?0 is not of the form: Ò(t.1,...,t.n)Æ
=ENDDOC


=TEX
The following theorems are mostly just definitions
instantiated to $ÒUÆ$ where appropriate,
perhaps with the addition of set extensionality.
=THDOC
req_thm(€"z_Ω_thm"›, ([],Òµ x:U; y: U∑ (x Ω y) § ≥(x = y)Æ));
req_thm(€"z_é_thm"›, ([],Òµ x: U; S: U∑
	x é S § ≥(x ç S)Æ));
=DESCRIBE
Inequality and ``non-membership''.
=ENDDOC
Spivey Ed 1. page 89.
=THDOC
req_thm(€"z_Ä_thm1"›,([],¨µ X:'a SET∑
	Ò((_ Ä _)[X]) ç (_ ™ _)[ X,  X] ±
	(µ S, T :  X
            ∑ ((S, T) ç (_ Ä _)[X] § (µ x : X ∑ x ç S ¥ x ç T)))ÆÆ));
=DESCRIBE
This is the form that a definition of $Ä$ would have taken if
it had been introduced in the Z library.
=ENDDOC
	
=THDOC
req_thm(€"z_ö_thm"›, ([],Òµ xâ1: U∑ ≥(xâ1 ç ö)Æ));
req_thm(€"z_Ä_thm"›, ([],Òµ s:U; t: U∑
	(s Ä t) § (µ x: U∑x ç s ¥ x ç t)Æ));
req_thm(€"z_ç__thm"›, ([],Òµ s:U; t: U∑
	(s ç  t) § (s Ä t)Æ));
req_thm(€"z_†_thm"›, ([],Òµ s:U; t: U∑
	(s † t) § (s Ä t) ± s Ω tÆ));
req_thm(€"z_â1_thm"›, ([],Ò(â1 _) = {S : U | S Ω ö∑ S}Æ));
=DESCRIBE
Empty set, subset, proper subset and non-empty power set.
=ENDDOC
Spivey Ed 1. page 90.
=THDOC
req_thm(€"z_¿_thm"›, ([],Òµ z: U; s:U; t: U ∑
	z ç (s ¿ t) § z ç s ≤ z ç tÆ));
req_thm(€"z_°_thm"›, ([],Òµ z: U; s:U; t: U∑
	z ç (s ° t) § z ç s ± z ç tÆ));
req_thm(€"z_set_dif_thm"›, ([],Òµ z: U; s:U; t: U∑
	z ç (s \ t) § z ç s ± (z é t)Æ));
=DESCRIBE
Set union, intersection and difference.
=ENDDOC
Spivey Ed 1. page 91.

=THDOC
req_thm(€"z_ﬁ_thm"›, ([],Òµ z: U; a: U∑
	z ç ﬁ a § (∂ S : U ∑ S ç a ± z ç S)Æ));
req_thm(€"z_•_thm"›, ([],Òµ z: U; a: U∑
	z ç • a § (µ S : U ∑ S ç a ¥ z ç S)Æ));
=DESCRIBE
Generalised set union and intersection.
=ENDDOC
Spivey Ed 1. page 92.
=DOC
val €z_Ä_conv› : CONV;
=DESCRIBE
Use $z\_Ä\_thm$ in combination with
knowledge about tuples.
Given as input an equality of the form $v\ Ä\ w$ then:

If $w$ is of type $ty$ $SET$ where $ty$ is not a tuple type:
=FRULE 1 Conversion
z_Ä_conv
Òv Ä wÆ
˜
˜
Ù (v Ä w) § 
	(µ xân : U ∑ xân ç v ¥ xân ç w)
=TEX
where $xân$ is the first variable in the list $xâ1$, $xâ2$,...
that doesn't appear in $v$ or $w$ (free or bound).

If $w$ is of type $ty$ $SET$ where $ty$ is an n-tuple type:
=FRULE 1 Conversion
z_Ä_conv
Òv Ä wÆ
˜
˜
Ù (v = w) § (µ xâp : U; µ xâq : U; ... ∑
	(xâp, xâq, ...) ç v ¥ 
	(xâp, xâq, ...) ç w)
=TEX
where the $xâi$ are the first $n$ variable names in the list
$xâ1$, $xâ2$,...
that do not appear in $v$ or $w$ (free or bound).
=SEEALSO
$z\_Ä\_thm$
=FAILURE
83001	?0 is not of the form Òv Ä wÆ
=ENDDOC


\subsection{Tuple Theorems}
The following theorems are mostly just definitions
instantiated to $ÒUÆ$ where appropriate,
perhaps with the addition of set extensionality.
=THDOC
req_thm(€"z_first_thm"›, ([],Òµ x: U ∑
	first x = x.1Æ));
req_thm(€"z_second_thm"›, ([],Òµ x: U ∑
	second x = x.2Æ));
=DESCRIBE
Projections from pairs.
=SEEALSO
$z\_ç\_first\_thm$, $z\_ç\_second\_thm$.
=ENDDOC
=THDOC
req_thm(€"z_ç_first_thm"›, ([],Òµ x: U ∑
	x ç first § x.1.1 = x.2Æ));
req_thm(€"z_ç_second_thm"›, ([],Òµ x: U ∑
	x ç second § x.1.2 = x.2Æ));
=DESCRIBE
Projections from pairs considered as relations.
=SEEALSO
$z\_first\_thm$, $z\_second\_thm$.
=ENDDOC
These theorems reflect a preference for the
general tuple selection functions.
Spivey Ed 1. page 89.

\section{RELATIONS}
The following theorems are mostly just the definition
instantiated to $ÒUÆ$ where appropriate,
and perhaps with the addition of set extensionality.

We choose to preserve maplets (formed by $Ì$) presented by the user,
but not to introduce new ones in, e.g., any rewriting theorems we provide. 
=THDOC
req_thm(€"z_™_thm"›, ([],Òµ X: U; Y: U∑
	(X ™ Y) = (X ∏ Y)Æ));
req_thm(€"z_Ì_thm"›, ([],Òµ x: U; y: U∑
	(x Ì y) = (x,y)Æ));
=DESCRIBE
Binary relations and maplets.
=ENDDOC
Spivey Ed 1. page 95.

=THDOC
req_thm(€"z_dom_thm"›, ([],Òµ z: U; R: U ∑
	z ç dom R § (∂ y : U∑ (z, y) ç R)Æ));
req_thm(€"z_ran_thm"›, ([],Òµ z: U; R: U ∑
	z ç ran R § (∂ x : U∑ (x, z) ç R)Æ));
=DESCRIBE
Domain and range.
=ENDDOC
Spivey Ed 1. page 96.

=THDOC
req_thm(€"z_id_thm"›, ([],Òµ X: U∑ id X = {x : U | x ç X ∑ (x, x)}Æ));
req_thm(€"z_ª_thm"›, ([],Òµ R: U; S: U∑
	R ª S = S o RÆ));
req_thm(€"z_o_thm"›, ([],Òµ p: U; S: U; 
	R: U∑
	p ç S o R § 
	(∂ y : U∑ (p.1, y) ç R ± (y, p.2) ç S)Æ));
=DESCRIBE
Identity relation, relational composition, backward relational composition.
=ENDDOC
Spivey Ed 1. page 97.

=THDOC
req_thm(€"z_Ú_thm"›, ([],Òµ p: U;
	 S: U; R: U∑
	p ç S Ú R § p.1 ç S ± p ç RÆ));
req_thm(€"z_í_thm"›, ([],Òµ p: U;
	R: U; S: U∑
	p ç R í S § p ç R ± p.2 ç SÆ));
=DESCRIBE
Domain restriction, range restriction.
=ENDDOC
Spivey Ed 1. page 98.

=THDOC
req_thm(€"z_·_thm"›, ([],Òµ p: U;
	 S: U; R: U ∑
	p ç S · R § p.1 é S ± p ç RÆ));
req_thm(€"z_Å_thm"›, ([],Òµ p: U;
	R: U; S: U∑
	p ç R Å S § p ç R ± p.2 é SÆ));
=DESCRIBE
Domain anti-restriction and range anti-restriction.
=ENDDOC
Spivey Ed 1. page 99.

=THDOC
req_thm(€"z_rel_inv_thm"›, ([],Òµ p: U; R: U∑
	p ç R Á~Í § (p.2, p.1) ç RÆ));
=DESCRIBE
Relational inversion.
=ENDDOC
Spivey Ed 1. page 100.

=THDOC
req_thm(€"z_rel_image_thm"›, ([],
	Òµ p : U; R : U; S : U
	∑ p ç (R ®  S ©) § 
	 (∂ x : U ∑ x ç S ± (x, p) ç R)Æ));
=DESCRIBE
Relational image.
=ENDDOC
Spivey Ed 1. page 101

=THDOC
req_thm(€"z_trans_closure_thm"›, ([],Òµ R: U∑
	 R Á+Í = • {Q : U | (R Ä Q) ± (Q ª Q Ä Q)∑ Q}Æ));
req_thm(€"z_reflex_trans_closure_thm"›, ([],Òµ R: U
∑ R Á*Í
      = • {Q : U
	      | (id U Ä Q) ± (R Ä Q) ± (Q ª Q Ä Q)∑
	 Q}Æ));
=DESCRIBE
Transitive and reflexive-transitive closure operations.
=ENDDOC
Spivey Ed 1. page 102

=THDOC
req_thm(€"z_ﬂ_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ﬂ Y
      § f ç X ™ Y
	± (µ x : X; yâ1, yâ2 : Y∑ (x, yâ1) ç f ± (x, yâ2) ç f ¥ yâ1 = yâ2)Æ));
req_thm(€"z_ﬂ_thm1"›, ([],Òµ f : U; X : U; Y : U
          ∑ f ç (X ﬂ Y)
            § f ç (X ™ Y)
              ± (µ x : U; yâ1, yâ2 : U |
		x ç X ± yâ1 ç Y ± yâ2 ç Y
                ∑ (x, yâ1) ç f ± (x, yâ2) ç f ¥ yâ1 = yâ2)Æ));
req_thm(€"z_≠_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ≠ Y § f ç X ﬂ Y ± dom f = XÆ));
req_thm(€"z_≠_app_thm"›, ([],Òµ X: U; Y: U; 
	f: U; x: U∑
	f ç X ≠ Y ± x ç X ¥ f x ç Y ± (x, f x) ç fÆ));
=DESCRIBE
Partial and total functions.
$z\_ﬂ\_thm$ is compact, but $z\_ﬂ\_thm1$ is better for
rewriting.
=ENDDOC
Spivey Ed 1. page 105

=THDOC
req_thm(€"z_˛_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ˛ Y
      § f ç X ﬂ Y ± (µ xâ1, xâ2 : U | 
		xâ1 ç dom f ± xâ2 ç dom f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ));
req_thm(€"z_‡_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X ‡ Y
      § f ç X ≠ Y ± (µ xâ1, xâ2 : U | 
		xâ1 ç dom f ± xâ2 ç dom f∑ 
		f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ));
=DESCRIBE
Partial and total injections.
=ENDDOC
Spivey Ed 1. page 106

=THDOC
req_thm(€"z_œ_thm"›, ([], Òµ f: U;
	X: U; Y: U∑
	f ç X œ Y § f ç X ﬂ Y ± ran f = YÆ));
req_thm(€"z_Ô_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X Ô Y § f ç X ≠ Y ± ran f = YÆ));
req_thm(€"z_è_thm"›, ([],Òµ f: U;
	X: U; Y: U∑
	f ç X è Y
	§ f ç X ≠ Y
	 ± ran f = Y
	 ± (µ xâ1, xâ2 : U |
		xâ1 ç dom f ± xâ2 ç dom f ∑
		f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ));
=DESCRIBE
Partial and total surjections, and bijections.
=ENDDOC
Spivey Ed 1. page 106

=THDOC
req_thm(€"z_´_thm"›, ([],Òµ f : U; g: U∑
	f ´ g = dom g · f ¿ gÆ));
=DESCRIBE
Functional overriding.
=ENDDOC
Spivey Ed 1. page 108
\subsection{Simplifying Universals}
=DOC
val €u_lib_conv› : CONV;
=DESCRIBE
Simplify an expression made from solely from $U$, and $™$. 
Remains within the Z language, though this is not checked.
=FRULE 1 Conversion
u_lib_conv
ÒStructure[U]Æ
˜
˜
Ù Structure[U] = U
=TEX
by one application of one of the following:
=GFT
Ù (U ™ U) = U
=TEX
=TEX
=USES
In the rewriting section of a proof context,
and to simplify declarations as predicates, while preserving
their declaration as predicate form.
=SEEALSO
$ç\_u\_lib\_conv$
=FAILURE
41060	?0 cannot be proven equal to ÒUÆ in one step
=ENDDOC

=DOC
val €ç_u_lib_conv› : CONV;
=DESCRIBE
Simplifies to $true$ a predicate of the form 
=INLINEFT
Òx ç S[U]Æ
=TEX
{} or 
=INLINEFT
Òx Ä S[U]Æ
=TEX
{} or  a schema as an expression:
=INLINEFT
Ò[a,b: S[U]; c : S'[U]; ...]Æ
=TEX
{}, where
$S[U]$ and $S'[U]$ are structures made solely from $U$, $™$ and those operators supported
by $ç\_u\_lang\_conv$.
Remains within the Z language, though this is not checked.
=FRULE 1 Conversion
ç_u_lib_conv
Òx ç S[U]Æ
˜
˜
Ù x ç S[U] § true
=TEX
=FRULE 1 Conversion
ç_u_lib_conv
Òx Ä S[U]Æ
˜
˜
Ù x Ä S[U] § true
=TEX
=FRULE 1 Conversion
ç_u_lib_conv
Ò[a,b: S[U]; c : S'[U]; ...]Æ
˜
˜
Ù [a,b: S[U]; c : S'[U]; ...] § true
=TEX
based on recursively using
=GFT
Ù (U ™ U) = U
<< operator rules from ç_u_lang_conv>>
Ù µ x∑ x ç U
Ù µ x∑ x Ä U
=TEX
=USES
In stripping proof contexts, and in eliminating redundant declarations that have been
converted to predicates.
=SEEALSO
$u\_lib\_conv$,
$ç\_u\_lang\_conv$.
=FAILURE
41061	cannot prove ?0 to be ÒtrueÆ
41062	?0 is not of the form Òx Ä sÆ, Òx ç sÆ or a schema as a predicate
=ENDDOC
Ought to be in a proof context!
\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{4in}}
$'z\_ç\_set\_lib$ & Simple algebraic reasoning about set theory of the Z library, especially $ç$. (e.g. $¿$) \\
$'z\_sets\_ext\_lib$ & Extensional reasoning about set theory (e.g. $°$) \\
$'z\_ç\_rel$ & Membership of Z relations (e.g. $í$). \\
$'z\_ç\_fun$ & Membership of Z functions (e.g. $ﬂ$). \\
$'z\_tuples$ & handling Z tuples and cartesian products in both language and library (e.g. $Ì$ and $∏$). \\
\end{tabular}

The above proof contexts
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language if its argument starts there.

Some stripping theorems (e.g. for $Ú$)
raise the dilemma of how and whether to
avoid leaving terms of the forms $Ò(x,y).1Æ$ 
(a special case is $Ò(x\ Ì\ y).1Æ$)
and $Ò(p.1,p.2)Æ$.
The first form is bad because of functionality problems;
the second is primarily bad because it is verbose,
but also because it provides a less general term for,
e.g., rewriting with.
We currently address this by including three theorems for
each problem operator, and relying on the discrimination
net effect of choosing ``the best match'' (see \cite{DS/FMU/IED/DTD008})
to get results that avoid the forms $Ò(x,y).1Æ$ and $Ò(p.1,p.2)Æ$.
We include all three theorems in both rewriting and stripping,
without relying on $z\-\_tuple\-\_selection\-\_conv$
during rewriting.
Thus for instance we include the theorems:
=GFT
Ù µ p S R∑ Òp ç S Ú R § p.1 ç S ± p ç RÆ
Ù µ p1 p2 S R∑ Ò(p1,p2) ç S Ú R § p1 ç S ± (p1,p2) ç RÆ
Ù µ p1 p2 S R∑ Ò(p1 Ì p2) ç S Ú R § p1 ç S ± (p1 Ì p2) ç RÆ
=TEX
The latter two theorems are automatically generated from the first.
This is only one possible solution, and not even necessarily the best.
Others include addressing the introduction of extensionality
variables, or ``fall back'' conversions if nothing else
applies to a term of the form $Òp\ ç\ qÆ$.
The operators affected (to date) are:
=INLINEFT
·, Å, Ú, í, and o
=TEX
{}.
=DOC
(* Proof Context: €'z_ç_set_lib› *)
=DESCRIBE
A component proof context for handling the membership of expressions created by Z set operations of the Z library.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç__thm
=TEX

Stripping theorems:
=GFT
z_ç__thm
=TEX

Stripping conclusions:
=GFT
z_ç__thm
=TEX
All three of the above have theorems concerning the membership of terms generated by the following operators:
=GFT
•, ﬁ, °, ¿, \, â1, ö
=TEX
and
=GFT
z_é_thm, z_Ω_thm
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``$'$z$\_$set$\_$lang''.
It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_sets\_ext$
=ENDDOC
Strictly $z\_Ω\_thm$ is a Z library predicate operator,
rather than a set operator.

$z\_ç\_\_thm$ is included as this seems the best non-extensional rule for $$, given $Ä$ is available.
=DOC
(* Proof Context: €'z_ç_rel› *)
=DESCRIBE
A component proof context for handling the membership of Z relations created by Z library operations.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_Ì_thm
=TEX

Stripping theorems:
=GFT
=TEX

Stripping conclusions:
=GFT
=TEX
All three of the above also have theorems concerning the membership of terms generated by the following operators:
=GFT
´, _ Á+Í, _ Á*Í,_ Á~Í, _ ® _ ©, Å, ·, í, Ú,
o, ª, id, ran, dom, ™
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``$'$z$\_ç\_$set$\_$lib''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
=DOC
(* Proof Context: €'z_ç_fun› *)
=DESCRIBE
A component proof context for handling the membership of Z functions created by Z library operations.
\paragraph{Contents}\ 

Rewriting:
=GFT
=TEX

Stripping theorems:
=GFT
=TEX

Stripping conclusions:
=GFT
=TEX
All three of the above also have theorems concerning the membership of terms generated by the following operators:
=GFT
œ, Ô, è, ˛, ‡, ﬂ, ≠
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``$'$z$\_ç\_$rel''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC

=DOC
(* Proof Context: €'z_sets_ext_lib› *)
=DESCRIBE
An aggressive component proof context for handling the manipulation of Z sets by breaking them into predicate calculus, within the Z library.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_Ä_conv, z_†_thm, z_setd_Ä_conv
=TEX

Stripping theorems:
=GFT
z_Ä_conv, z_†_thm, z_setd_Ä_conv,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_Ä_conv, z_†_thm, z_setd_Ä_conv,
plus these all pushed in through ≥
=TEX

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to always be used in conjunction with ``$'$z$\_$set$\_$lib'' and ``$'$z$\_$set$\_$ext$\_$lang''.

It is not intended to be mixed with HOL proof contexts.
=SEEALSO
$'z\_ç\_set$
=ENDDOC
=DOC
(* Proof Context: €'z_tuples› *)
=DESCRIBE
A component proof context for handling the manipulation of Z tuples and cartesian products within the Z language and library.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_ç_∏_conv,
z_tuple_eq_conv, z_tuple_selection_conv, z_tuple_intro_conv,
z_second_thm, z_first_thm
=TEX

Stripping theorems:
=GFT
z_tuple_eq_conv, z_ç_∏_conv,
plus these all pushed in through ≥
=TEX

Stripping conclusions:
=GFT
z_tuple_eq_conv, z_ç_∏_conv,
plus these all pushed in through ≥
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$\-\_basic\-\_prove\-\_conv$,
and
no existence prover (1-tuples and 2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''
(and thus ``$'$z$\_$decl'').
It should not be used with ``$'$z$\_$tuples$\_$lang''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
Perhaps later releases will add rules such as 
=GFT
(a,b,...) = p § (a = p.1 ± b = p.2 ± ...)
=TEX
perhaps into a separate $'z\_tuples\_ext$.


=TEX
\section{Theorems in the Signature}
=DOC
val z_Ω_thm: THM;
val z_é_thm: THM;
val z_ö_thm: THM;
val z_Ä_thm: THM;
val z_†_thm: THM;
val z_ç__thm: THM;
val z_â1_thm: THM;
val z_¿_thm: THM;
val z_°_thm: THM;
val z_set_dif_thm: THM;
val z_ﬁ_thm: THM;
val z_•_thm: THM;
val z_first_thm: THM;
val z_ç_first_thm: THM;
val z_second_thm: THM;
val z_ç_second_thm: THM;
val z_™_thm: THM;
val z_Ì_thm: THM;
val z_dom_thm: THM;
val z_ran_thm: THM;
val z_id_thm: THM;
val z_ª_thm: THM;
val z_o_thm: THM;
val z_Ú_thm: THM;
val z_í_thm: THM;
val z_·_thm: THM;
val z_Å_thm: THM;
val z_rel_inv_thm: THM;
val z_rel_image_thm: THM;
val z_trans_closure_thm: THM;
val z_reflex_trans_closure_thm: THM;
val z_ﬂ_thm: THM;
val z_ﬂ_thm1: THM;
val z_≠_thm: THM;
val z_≠_app_thm: THM;
val z_˛_thm: THM;
val z_‡_thm: THM;
val z_œ_thm: THM;
val z_Ô_thm: THM;
val z_è_thm: THM;
val z_´_thm: THM;
=DESCRIBE
The ML bindings of the theorems (other than consistency ones)
in theory $z\-\_set\-\_theory$.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZLibraryProofSupport *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
