=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Library Relations}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD083}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the 
proof support for the Z Library Relations.}
\TPPdistribution{\parbox[t]{4.0in}{%
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History} 
\begin{description}

\item [Issue 1.1]
First version, derived from \cite{DS/FMU/IED/DTD042}.
\item [Issue 1.2 (20th October 1992)]
Typo fixing.
\item [Issue 1.3 (21th October 1992)]
Added $z\_rel\_inv\_thm$ into appropriate proof context.
Added $z\-\_\-\_first\-\_thm$, $z\-\_\-\_second\-\_thm$.
\item [Issue 1.4 (22nd October 1992)]
Changed $z\_id\_thm$.
\item [Issue 1.5 (22nd October 1992)]
Change of name and nature to Z Library Relations.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for proof support for
the Z Library, described in \cite{DS/FMU/IED/HLD015}. The rules and theorems cover set theory and associated constructs.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP083}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
initial set of proof support for
the Z Library.
\subsubsection{Dependencies}
Loading this document is dependent on 
the Z Library, \cite{DS/FMU/IED/IMP078}.
\subsubsection{Deficiencies}
Perhaps ought to use theory check mechanisms.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $ñ...®$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $Á\_to\_z\_conv$ to correct
what problems it can.

By default all relavent functions in this document should
be assumed to remain within the Z language and to check this fact, unless otherwise stated.
\section{PROLOG}
=SML
open_theory"z_sets";
push_pc "z_predicates";
delete_theory"z_relations" handle Fail _ => ();
val icl'was_tco_flag = get_flag "z_type_check_only";
val icl'was_ax_flag = get_flag "z_use_axioms";
set_flag ("z_type_check_only", false);
set_flag ("z_use_axioms", true);
new_theory"z_relations";
=TEX
\section {DEFINITION OF FIXITY}

The following fixity information has been taken from \cite{Spivey89}.

¹Z
fun 1 _ í _
°
¹Z
fun 4 _ » _, _ o _
°
¹Z
fun 5 _ « _
°

¹Z
fun 6 _ ò _, _ ’ _, _ á _, _  _
°

¹Z
fun 7 _ ç~ê, _ ç*ê, _ ç+ê, _ º _
°

¹Z
fun 7 _ ¨ _ ©
°
¹Z
gen 7 id _
°
\section{RELATIONS}
Note that $ª$ is defined in \cite{DS/FMU/IED/DTD078},
as it is required to define the Z Library set material.
\subsection{Maplet}

[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûíİ _ : X ¸ Y ­ X ¸ Y
÷üüüüüüüüüüüüüüüüüü
Ü µ x : X; y : Y ·
Ü	x í y = (x, y)
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Domain and Range}

[X, Y]œœœœœœœœœœœœœœœœ
Ü Ûdomİ : (X ª Y) ­ ğ X;
Ü Ûranİ : (X ª Y) ­ ğ Y
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y ·
Ü	dom R = {x : X; y : Y | (x í y)  R · x} ±
Ü	ran R = {x : X; y : Y | (x í y)  R · y}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Identity}

¹Z
Ûidİ X ¦ {x : X · x í x}
°

\subsection{Relational and Backward Relational Composition}

[X, Y, Z]œœœœœœœœœœœœœœœœ
Ü _ Û»İ _ : (X ª Y) ¸ (Y ª Z) ­ (X ª Z);
Ü _ Ûoİ _ : (Y ª Z) ¸ (X ª Y) ­ (X ª Z)
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y; S : Y ª Z ·
Ü	R » S = S o R ±
Ü	S o R = {x : X; y : Y; z : Z |
Ü		(x í y)  R ± (y í z)  S · x í z}
ˆüüüüüüüüüüüüüüüüüüüü


\subsection{Domain and Range Restriction}

[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûòİ _ : ğ X ¸ (X ª Y) ­ (X ª Y);
Ü _ Û’İ _ : (X ª Y) ¸ ğ Y ­ (X ª Y)
÷üüüüüüüüüüüüüüüüüü
Ü (µ S : ğ X; R : X ª Y ·
Ü	S ò R = {x : X; y : Y | x  S ± (x í y)  R · x í y}) ±
Ü(µ R : X ª Y; T : ğ Y ·
Ü	R ’ T = {x : X; y : Y | (x í y)  R ± y  T · x í y})
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Domain and Range Anti-restriction}


[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûáİ _ : ğ X ¸ (X ª Y) ­ (X ª Y);
Ü _ Ûİ _ : (X ª Y) ¸ ğ Y ­ (X ª Y)
÷üüüüüüüüüüüüüüüüüü
Ü (µ S : ğ X; R : X ª Y ·
Ü	S á R = {x : X; y : Y | x  S ± (x í y)  R · x í y}) ±
Ü(µ R : X ª Y; T : ğ Y ·
Ü	R  T = {x : X; y : Y | (x í y)  R ± y  T · x í y})
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Relational Inversion}


[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûç~êİ : (X ª Y) ­ (Y ª X)
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y ·
Ü	R ç~ê = {x : X; y : Y | (x í y)  R · y í x}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Relational Image}

[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Û¨İ _ Û©İ : (X ª Y) ¸ ğ X ­ ğ Y
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y; S : ğ X ·
Ü	R¨S© = {x : X; y : Y | x  S ± (x í y)  R · y}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Transitive and Reflexive-Transitive Closure}

[X]œœœœœœœœœœœœœœœœ
Ü _ Ûç+êİ, _ Ûç*êİ : (X ª X) ­ (X ª X)
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª X ·
Ü	R ç+ê = ¥ {Q : X ª X | R € Q ± Q » Q € Q} ± 
Ü	R ç*ê = ¥ {Q : X ª X | id X € Q ± R € Q ± Q » Q € Q}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Override}
[X,Y]œœœœœœœœœœœœœœœœ
Ü _ Û«İ _ : (X ª Y) ¸ (X ª Y) ­ (X ª Y)
÷üüüüüüüüüüüüüüüüüü
Ü µ f, g : X ª Y ·
Ü	f « g = ((dom g) á f) À g
ˆüüüüüüüüüüüüüüüüüüüü

\section{START OF STRUCTURE}
=DOC
signature ÛZRelationsİ = sig
=DESCRIBE
This provides the basic proof support for the Z library relations.
It creates the theory $z\_relations$.
=ENDDOC
=THDOC
req_name Û"z_relations"İ (Value "z_sets");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_relations$ contains various definitions of relation operators, and ``defining theorems'' of Z library constants derived from these definitions.
It is created in structure $ZRelations$.
=ENDDOC
The following theorems are mostly just the definition
instantiated to $ñU®$ where appropriate,
and perhaps with the addition of set extensionality.

We choose to preserve maplets (formed by $í$) presented by the user,
but not to introduce new ones in, e.g., any rewriting theorems we provide. 
=THDOC
req_thm(Û"z_ª_thm"İ, ([],ñµ X: U; Y: U·
	(X ª Y) = ğ(X ¸ Y)®));
req_thm(Û"z_í_thm"İ, ([],ñµ x: U; y: U·
	(x í y) = (x,y)®));
=DESCRIBE
Binary relations and maplets.
=ENDDOC
Spivey Ed 1. page 95.

=THDOC
req_thm(Û"z_dom_thm"İ, ([],ñµ z: U; R: U ·
	z  dom R ¤ (¶ y : U· (z, y)  R)®));
req_thm(Û"z_ran_thm"İ, ([],ñµ z: U; R: U ·
	z  ran R ¤ (¶ x : U· (x, z)  R)®));
=DESCRIBE
Domain and range.
=ENDDOC
Spivey Ed 1. page 96.

=THDOC
req_thm(Û"z_id_thm"İ, ([],ñµ X: U· id X = {x : U | x  X · (x, x)}®));
req_thm(Û"z_»_thm"İ, ([],ñµ R: U; S: U·
	R » S = S o R®));
req_thm(Û"z_o_thm"İ, ([],ñµ p: U; S: U; 
	R: U·
	p  S o R ¤ 
	(¶ y : U· (p.1, y)  R ± (y, p.2)  S)®));
=DESCRIBE
Identity relation, relational composition, backward relational composition.
=ENDDOC
Spivey Ed 1. page 97.

=THDOC
req_thm(Û"z_ò_thm"İ, ([],ñµ p: U;
	 S: U; R: U·
	p  S ò R ¤ p.1  S ± p  R®));
req_thm(Û"z_’_thm"İ, ([],ñµ p: U;
	R: U; S: U·
	p  R ’ S ¤ p  R ± p.2  S®));
=DESCRIBE
Domain restriction, range restriction.
=ENDDOC
Spivey Ed 1. page 98.

=THDOC
req_thm(Û"z_á_thm"İ, ([],ñµ p: U;
	 S: U; R: U ·
	p  S á R ¤ p.1  S ± p  R®));
req_thm(Û"z__thm"İ, ([],ñµ p: U;
	R: U; S: U·
	p  R  S ¤ p  R ± p.2  S®));
=DESCRIBE
Domain anti-restriction and range anti-restriction.
=ENDDOC
Spivey Ed 1. page 99.

=THDOC
req_thm(Û"z_rel_inv_thm"İ, ([],ñµ p: U; R: U·
	p  R ç~ê ¤ (p.2, p.1)  R®));
=DESCRIBE
Relational inversion.
=ENDDOC
Spivey Ed 1. page 100.

=THDOC
req_thm(Û"z_rel_image_thm"İ, ([],
	ñµ p : U; R : U; S : U
	· p  (R ¨  S ©) ¤ 
	 (¶ x : U · x  S ± (x, p)  R)®));
=DESCRIBE
Relational image.
=ENDDOC
Spivey Ed 1. page 101

=THDOC
req_thm(Û"z_trans_closure_thm"İ, ([],ñµ R: U·
	 R ç+ê = ¥ {Q : U | (R € Q) ± (Q » Q € Q)· Q}®));
req_thm(Û"z_reflex_trans_closure_thm"İ, ([],ñµ R: U
· R ç*ê
      = ¥ {Q : U
	      | (id U € Q) ± (R € Q) ± (Q » Q € Q)·
	 Q}®));
=DESCRIBE
Transitive and reflexive-transitive closure operations.
=ENDDOC
Spivey Ed 1. page 102

=THDOC
req_thm(Û"z_«_thm"İ, ([],ñµ f : U; g: U·
	f « g = dom g á f À g®));
=DESCRIBE
Functional overriding.
=ENDDOC

\section{TUPLES}
This is a reworking of the language functions, but
with a knowledge of $í$.
=DOC
val Ûz_tuple_eq_convİ : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_eq_conv 
ñ(t‰1,t‰2,...) = (u‰1,u‰2,...)®
÷
÷
ô (t‰1,t‰2,...) = (u‰1,u‰2,...) ¤ 
((t‰1 = u‰1) ± (t‰2 = u‰2) ± ...) 
=TEX
$x\ í\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_eq\_conv$
=FAILURE
42003	?0 is not of the form: ñ(x1,...) = (y1,...)®
=ENDDOC
=DOC
val Ûz_tuple_selection_convİ : CONV;
=DESCRIBE
This conversion carries out the
selection from a tuple display.
=FRULE 1 Conversion
z_tuple_selection_conv 
ñ(t‰1,...,t‰i,...,t‰n).i®
÷
÷
ô (t‰1,...,t‰i,...,t‰n).i = t‰i
=TEX
$x\ í\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_selection\_conv$
=FAILURE
47185	?0 is not a Z tuple selection
42006	?0 is not of the form ñ(x,...).i®
=ENDDOC
=DOC
val Ûz_tuple_intro_convİ : CONV;
=DESCRIBE
This conversion carries out the
elimination of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_intro_conv 
ñ(t.1,...,t.n)®
÷
÷
ô (t.1,...,t.n) = t
=TEX
where $n$ is the arity of $t$.
$x\ í\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_intro\_conv$
=FAILURE
42005	?0 is not of the form: ñ(t.1,...,t.n)®
=ENDDOC


=TEX

Spivey Ed 1. page 108
\subsection{Simplifying Universals}
=DOC
val Ûu_lib_convİ : CONV;
=DESCRIBE
Simplify an expression made from solely from $U$, and $ª$. 
Remains within the Z language, though this is not checked.
=FRULE 1 Conversion
u_lib_conv
ñStructure[U]®
÷
÷
ô Structure[U] = U
=TEX
by one application of one of the following:
=GFT
ô (U ª U) = U
=TEX
=TEX
=USES
In the rewriting section of a proof context,
and to simplify declarations as predicates, while preserving
their declaration as predicate form.
=SEEALSO
$\_u\_lib\_conv$
=FAILURE
41060	?0 cannot be proven equal to ñU® in one step
=ENDDOC

=DOC
val Û_u_lib_convİ : CONV;
=DESCRIBE
Simplifies to $true$ a predicate of the form 
=INLINEFT
ñx  S[U]®
=TEX
{} or 
=INLINEFT
ñx € S[U]®
=TEX
{} or  a schema as an expression:
=INLINEFT
ñ[a,b: S[U]; c : S'[U]; ...]®
=TEX
{}, where
$S[U]$ and $S'[U]$ are structures made solely from $U$, $ª$ and those operators supported
by $\_u\_lang\_conv$.
Remains within the Z language, though this is not checked.
=FRULE 1 Conversion
_u_lib_conv
ñx  S[U]®
÷
÷
ô x  S[U] ¤ true
=TEX
=FRULE 1 Conversion
_u_lib_conv
ñx € S[U]®
÷
÷
ô x € S[U] ¤ true
=TEX
=FRULE 1 Conversion
_u_lib_conv
ñ[a,b: S[U]; c : S'[U]; ...]®
÷
÷
ô [a,b: S[U]; c : S'[U]; ...] ¤ true
=TEX
based on recursively using
=GFT
ô (U ª U) = U
<< operator rules from _u_lang_conv>>
ô µ x· x  U
ô µ x· x € U
=TEX
=USES
For stripping in proof contexts, and in eliminating redundant declarations that have been
converted to predicates.
=SEEALSO
$u\_lib\_conv$,
$\_u\_lang\_conv$.
=FAILURE
41061	cannot prove ?0 to be ñtrue®
41062	?0 is not of the form ñx € s®, ñx  s® or a schema as a predicate
=ENDDOC
Ought to be in a proof context!
\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{4in}}
$'z\_\_rel$ & Membership of Z relations (e.g. $’$). \\
$'z\_tuples$ & handling Z tuples and cartesian products in both language and library (e.g. $í$ and $¸$). \\
\end{tabular}

The above proof contexts
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for 
stripping
a Z existentially quantified antecedent to an implication.
However, 
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language.

Some stripping theorems (e.g. for $ò$)
raise the dilemma of how and whether to
avoid leaving terms of the forms $ñ(x,y).1®$ 
(a special case is $ñ(x\ í\ y).1®$)
and $ñ(p.1,p.2)®$.
The first form is bad because of functionality problems;
the second is primarily bad because it is verbose,
but also because it provides a less general term for,
e.g., rewriting with.
We currently address this by including three theorems for
each problem operator, and relying on the discrimination
net effect of choosing ``the best match'' (see \cite{DS/FMU/IED/DTD008})
to get results that avoid the forms $ñ(x,y).1®$ and $ñ(p.1,p.2)®$.
We include all three theorems in both rewriting and stripping,
without relying on $z\-\_tuple\-\_selection\-\_conv$
during rewriting.
Thus for instance we include the theorems:
=GFT
ô µ p S R· ñp  S ò R ¤ p.1  S ± p  R®
ô µ p1 p2 S R· ñ(p1,p2)  S ò R ¤ p1  S ± (p1,p2)  R®
ô µ p1 p2 S R· ñ(p1 í p2)  S ò R ¤ p1  S ± (p1 í p2)  R®
=TEX
The latter two theorems are automatically generated from the first.
This is only one possible solution, and not even necessarily the best.
Others include addressing the introduction of extensionality
variables, or ``fall back'' conversions if nothing else
applies to a term of the form $ñp\ \ q®$.
The operators affected (to date) are:
=INLINEFT
á, , ò, ’, and o
=TEX
{}.
=DOC
(* Proof Context: Û'z__relİ *)
=DESCRIBE
A component proof context for handling the membership of Z relations created by Z library operations.
\paragraph{Contents}\ 

Rewriting:
=GFT
z_í_thm
=TEX

Stripping theorems:
=GFT
=TEX

Stripping conclusions:
=GFT
=TEX
All three of the above also have theorems concerning the membership of terms generated by the following operators:
=GFT
«, _ ç+ê, _ ç*ê,_ ç~ê, _ ¨ _ ©, , á, ’, ò,
o, », id, ran, dom, ª
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``$'$z$\_\_$set$\_$lib''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC

=DOC
(* Proof Context: Û'z_tuplesİ *)
=DESCRIBE
A component proof context for handling the manipulation of Z tuples and cartesian products within the Z language and library.
\paragraph{Contents}\ 

Rewriting:
=GFT
z__¸_conv,
z_tuple_eq_conv, z_tuple_selection_conv, z_tuple_intro_conv,
z_second_thm, z_first_thm
=TEX

Stripping theorems:
=GFT
z_tuple_eq_conv, z__¸_conv,
plus these all pushed in through ³
=TEX

Stripping conclusions:
=GFT
z_tuple_eq_conv, z__¸_conv,
plus these all pushed in through ³
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$\-\_basic\-\_prove\-\_conv$,
and
no existence prover (1-tuples and 2-tuples are handled in proof 
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_set\-\_theory$.
It is intended to be used with proof context ``z$\_$predicates''
(and thus ``$'$z$\_$decl'').
It should not be used with ``$'$z$\_$tuples$\_$lang''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
Perhaps later releases will add rules such as 
=GFT
(a,b,...) = p ¤ (a = p.1 ± b = p.2 ± ...)
=TEX
perhaps into a separate $'z\_tuples\_ext$.


=TEX
\section{Theorems in the Signature}
=DOC
val z_ª_thm: THM;
val z_í_thm: THM;
val z_dom_thm: THM;
val z_ran_thm: THM;
val z_id_thm: THM;
val z_»_thm: THM;
val z_o_thm: THM;
val z_ò_thm: THM;
val z_’_thm: THM;
val z_á_thm: THM;
val z__thm: THM;
val z_rel_inv_thm: THM;
val z_rel_image_thm: THM;
val z_trans_closure_thm: THM;
val z_reflex_trans_closure_thm: THM;
val z_«_thm: THM;
=DESCRIBE
The ML bindings of the theorems (other than consistency ones)
in theory $z\-\_set\-\_theory$.
=ENDDOC
=DOC
val Ûz'í_defİ : THM;
val Ûz'dom_defİ : THM;	val Ûz'ran_defİ : THM;
val Ûz'id_defİ : THM;	val Ûz'»_defİ : THM;
val Ûz'o_defİ : THM;	val Ûz'ò_defİ : THM;
val Ûz'’_defİ : THM;	val Ûz'á_defİ : THM;
val Ûz'_defİ : THM;	val Ûz'rel_inv_defİ : THM;
val Ûz'rel_image_defİ : THM;	val Ûz'tc_defİ : THM;
val Ûz'rtc_defİ : THM;	val Ûz'«_defİ : THM;
=DESCRIBE
These are the definitions of the theory $z\_relations$.
=ENDDOC

\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZRelations *)
=TEX
=SML
set_flag ("z_type_check_only", icl'was_tco_flag);
set_flag ("z_use_axioms", icl'was_ax_flag);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
