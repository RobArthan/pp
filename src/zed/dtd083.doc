=IGN
********************************************************************************
dtd083.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Library Relations}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD083}  %% Mandatory field
\def\SCCSversion{$Revision: 1.19 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2005/08/11 12:13:04 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPclass{}
\TPPkeywords{}
% \TPPauthor{G.~Prout  & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design for the
proof support for the Z Library Relations.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Project Library}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}

\item [Issue 1.1]
First version, derived from \cite{DS/FMU/IED/DTD042}.
\item [Issue 1.2 (20th October 1992)]
Typo fixing.
\item [Issue 1.3 (21th October 1992)]
Added $z\_rel\_inv\_thm$ into appropriate proof context.
Added $z\-\_\-\_first\-\_thm$, $z\-\_\-\_second\-\_thm$.
\item [Issue 1.4 (22nd October 1992)]
Changed $z\_id\_thm$.
\item [Issue 1.5 (22nd October 1992)]
Change of name and nature to Z Library Relations.
\item [Issue 1.6 (30th October 1992)]
Tidying.
\item [Issue 1.7, 12th November 1992]
Changes as a consequence of changes in dependences.
\item[Issue 1.8 (3nd December 1992)]
Improved $ƒ$ simplification.
Added Z language proof contexts.
\item[Issue 1.9 (8th December 1992)]
Removed mention of ``$'$z$\_$schemas$\_$ext''.
\item[Issue 1.10 (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.11 (17th December 1992)]
Removed spurious ML bindings.
\item[Issue 1.12-1.14 (5th-12th February 1993)]
Rearranging proof contexts.
\item[Issue 1.15] Copyright and banner updates for open source release.
\item[Issue 1.16] PPZed-specific updates for open source release
\item[Issue 1.17] The Z universal set is now called ƒ.
\item[Issue 1.18] Precedences and associativity of toolkit operators now follow \cite{ISO02}.
\item[Issue 1.25] Corrected {\em z\_dom\_clauses} and {\em z\_ran\_clauses}.
\item[Issue 1.26] Functional composition is now called ``…''.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for proof support for
the Z Library Relations, described in \cite{DS/FMU/IED/HLD015}.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
implemented in \cite{DS/FMU/IED/IMP083}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
initial set of proof support for
the Z Library.
\subsubsection{Dependencies}
Loading this document and its implementation is dependent on
the Z Library Sets, \cite{DS/FMU/IED/IMP078}.
\subsubsection{Deficiencies}
Perhaps ought to use theory check mechanisms.
\section{LANGUAGE OVERLAP BETWEEN Z AND HOL}\label{ZCAVEAT}
Many of the functions below that generate results involving terms
are stated to ``remain within the Z language''
(indicated by their results being in $ñ...®$ or
left without any such brackets at all - this document assumes
Z as the default language, HOL terms are explicitly quoted).
This should be taken to mean that in so far as the original
input was within the Z language (i.e. the range of the Z mapping)
the results will also be
(except for certain renaming problems, etc).
This will be checked by some derivative of $is\_z$, unless
otherwise noted, informing the user
if Z has been left.
Later releases will use $Á\_to\_z\_conv$ to correct
what problems it can.

By default all relevant functions in this document should
be assumed to remain within the Z language and to check this fact, unless otherwise stated.
\section{PROLOG}
=SML
open_theory"z_sets";
push_merge_pcs ["z_predicates","'z__set_lang",
	"'z_bindings","'z_normal","'z_tuples_lang",
	"'z__set_lib","'z_sets_ext_lang","'z_sets_ext_lib"];
delete_theory"z_relations" handle Fail _ => ();
set_flag ("z_type_check_only", false);
set_flag ("z_use_axioms", true);
new_theory"z_relations";
=TEX
\section {DEFINITION OF FIXITY}

The following fixity information is taken from \cite{ISO02}.

¹Z
function 10 leftassoc _ í _
°
¹Z
function 40 leftassoc _ » _, _ … _
°
¹Z
function 50 leftassoc _ « _
°

¹Z
function 60 leftassoc _ ’ _, _  _
°
¹Z
function 65 rightassoc _ ò _, _ á _
°

¹Z
function 70 _ ç~ê, _ ç*ê, _ ç+ê
°

¹Z
function 70 _ ¨ _ ©
°
¹Z
generic 70 id _
°
\section{RELATIONS}
Note that $ª$ is defined in \cite{DS/FMU/IED/DTD078},
as it is required to define the Z Library set material.
\subsection{Maplet}

[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûíİ _ : X ¸ Y ­ X ¸ Y
÷üüüüüüüüüüüüüüüüüü
Ü µ x : X; y : Y ·
Ü	x í y = (x, y)
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Domain and Range}

[X, Y]œœœœœœœœœœœœœœœœ
Ü Ûdomİ : (X ª Y) ­ ğ X;
Ü Ûranİ : (X ª Y) ­ ğ Y
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y ·
Ü	dom R = {x : X; y : Y | (x í y)  R · x} ±
Ü	ran R = {x : X; y : Y | (x í y)  R · y}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Identity}

¹Z
Ûidİ X ¦ {x : X · x í x}
°

\subsection{Relational and Backward Relational Composition}

[X, Y, Z]œœœœœœœœœœœœœœœœ
Ü _ Û»İ _ : (X ª Y) ¸ (Y ª Z) ­ (X ª Z);
Ü _ Û…İ _ : (Y ª Z) ¸ (X ª Y) ­ (X ª Z)
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y; S : Y ª Z ·
Ü	R » S = S … R ±
Ü	S … R = {x : X; y : Y; z : Z |
Ü		(x í y)  R ± (y í z)  S · x í z}
ˆüüüüüüüüüüüüüüüüüüüü


\subsection{Domain and Range Restriction}

[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûòİ _ : ğ X ¸ (X ª Y) ­ (X ª Y);
Ü _ Û’İ _ : (X ª Y) ¸ ğ Y ­ (X ª Y)
÷üüüüüüüüüüüüüüüüüü
Ü (µ S : ğ X; R : X ª Y ·
Ü	S ò R = {x : X; y : Y | x  S ± (x í y)  R · x í y}) ±
Ü(µ R : X ª Y; T : ğ Y ·
Ü	R ’ T = {x : X; y : Y | (x í y)  R ± y  T · x í y})
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Domain and Range Anti-restriction}


[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûáİ _ : ğ X ¸ (X ª Y) ­ (X ª Y);
Ü _ Ûİ _ : (X ª Y) ¸ ğ Y ­ (X ª Y)
÷üüüüüüüüüüüüüüüüüü
Ü (µ S : ğ X; R : X ª Y ·
Ü	S á R = {x : X; y : Y | x  S ± (x í y)  R · x í y}) ±
Ü(µ R : X ª Y; T : ğ Y ·
Ü	R  T = {x : X; y : Y | (x í y)  R ± y  T · x í y})
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Relational Inversion}


[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Ûç~êİ : (X ª Y) ­ (Y ª X)
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y ·
Ü	R ç~ê = {x : X; y : Y | (x í y)  R · y í x}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Relational Image}

[X, Y]œœœœœœœœœœœœœœœœ
Ü _ Û¨İ _ Û©İ : (X ª Y) ¸ ğ X ­ ğ Y
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª Y; S : ğ X ·
Ü	R¨S© = {x : X; y : Y | x  S ± (x í y)  R · y}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Transitive and Reflexive-Transitive Closure}

[X]œœœœœœœœœœœœœœœœ
Ü _ Ûç+êİ, _ Ûç*êİ : (X ª X) ­ (X ª X)
÷üüüüüüüüüüüüüüüüüü
Ü µ R : X ª X ·
Ü	R ç+ê = ¥ {Q : X ª X | R € Q ± Q » Q € Q} ±
Ü	R ç*ê = ¥ {Q : X ª X | id X € Q ± R € Q ± Q » Q € Q}
ˆüüüüüüüüüüüüüüüüüüüü

\subsection{Override}
[X,Y]œœœœœœœœœœœœœœœœ
Ü _ Û«İ _ : (X ª Y) ¸ (X ª Y) ­ (X ª Y)
÷üüüüüüüüüüüüüüüüüü
Ü µ f, g : X ª Y ·
Ü	f « g = ((dom g) á f) À g
ˆüüüüüüüüüüüüüüüüüüüü

\section{START OF STRUCTURE}
=DOC
signature ÛZRelationsİ = sig
=DESCRIBE
This provides the basic proof support for the Z library relations.
It creates the theory $z\_relations$.
=ENDDOC
=THDOC
req_name Û"z_relations"İ (Value "z_sets");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_relations$ contains various definitions of relation operators, and ``defining theorems'' of Z library constants derived from these definitions.
It is created in structure $ZRelations$.
=ENDDOC
The following theorems are mostly just the definition
instantiated to $ñƒ®$ where appropriate,
and perhaps with the addition of set extensionality.
They are supplimented by the $clauses$ theorems, which
show the interaction of a single operator, and $ƒ$ or ${}$.
Only those interactions giving uncontroversially simpler
results are given.

We choose to preserve maplets (formed by $í$) presented by the user,
but not to introduce new ones in, e.g., any rewriting theorems we provide.
=THDOC
req_thm(Û"z_ª_thm"İ, ([],ñµ X: ƒ; Y: ƒ·
	(X ª Y) = ğ(X ¸ Y)®));
req_thm(Û"z_í_thm"İ, ([],ñµ x: ƒ; y: ƒ·
	(x í y) = (x,y)®));
req_thm(Û"z_ª_clauses"İ, ([],ñµ X: ƒ·
	(X ª {} = {{}}) ±
	({} ª X = {{}})®));
=DESCRIBE
Binary relations and maplets.
Note that $ƒ\ ª\ ƒ$ is simplified to $ƒ$ by, e.g., rewriting in proof
context $z\_language$.
=ENDDOC
Spivey Ed 1. page 95.

=THDOC
req_thm(Û"z_dom_thm"İ, ([],ñµ z: ƒ; R: ƒ ·
	z  dom R ¤ (¶ y : ƒ· (z, y)  R)®));
req_thm(Û"z_ran_thm"İ, ([],ñµ z: ƒ; R: ƒ ·
	z  ran R ¤ (¶ x : ƒ· (x, z)  R)®));
req_thm(Û"z_dom_clauses"İ, ([],ñµ a:ƒ; b:ƒ ·
	dom ƒ = ƒ ±
	dom {} = {} ±
	dom {a í b} = {a} ±
	dom {(a, b)} = {a}®));
req_thm(Û"z_ran_clauses"İ, ([],ñµ a:ƒ; b:ƒ ·
	ran ƒ = ƒ ±
	ran {} = {} ±
	ran {a í b} = {b} ±
	ran {(a, b)} = {b}®));
=DESCRIBE
Domain and range.
=ENDDOC
Spivey Ed 1. page 96.

The addition of clauses for the domain and range of singleton sets is the only place in this document where such kinds of clauses seem appropriate.

=THDOC
req_thm(Û"z_id_thm"İ, ([],ñµ X: ƒ· id X = {x : ƒ | x  X · (x, x)}®));
req_thm(Û"z_»_thm"İ, ([],ñµ R: ƒ; S: ƒ·
	R » S = S … R®));
req_thm(Û"z_…_thm"İ, ([],ñµ x: ƒ; S: ƒ;
	R: ƒ·
	x  S … R ¤
	(¶ y : ƒ· (x.1, y)  R ± (y, x.2)  S)®));
req_thm(Û"z_id_clauses"İ, ([],ñid {} = {}®));
req_thm(Û"z_»_clauses"İ, ([],ñµ R: ƒ ·
	R » {} = {} ±
	{} » R = {} ±
	ƒ » ƒ = ƒ®));
req_thm(Û"z_…_clauses"İ, ([],ñµ R: ƒ ·
	R … {} = {} ±
	{} … R = {} ±
	ƒ … ƒ = ƒ®));
=DESCRIBE
Identity relation, relational composition, backward relational composition.
=ENDDOC
Spivey Ed 1. page 97.

=THDOC
req_thm(Û"z_ò_thm"İ, ([],ñµ x: ƒ;
	 S: ƒ; R: ƒ·
	x  S ò R ¤ x.1  S ± x  R®));
req_thm(Û"z_’_thm"İ, ([],ñµ x: ƒ;
	R: ƒ; S: ƒ·
	x  R ’ S ¤ x  R ± x.2  S®));
req_thm(Û"z_ò_clauses"İ, ([],ñµ R: ƒ;S:ƒ·
	(ƒ ò R = R) ±
	({} ò R = {}) ±
	(S ò {} = {})®));
req_thm(Û"z_’_clauses"İ, ([],ñµ R: ƒ;S:ƒ·
	(R ’ ƒ = R) ±
	({} ’ S = {}) ±
	(R ’ {} = {})®));
=DESCRIBE
Domain restriction, range restriction.
=ENDDOC
Spivey Ed 1. page 98.

=THDOC
req_thm(Û"z_á_thm"İ, ([],ñµ x: ƒ;
	 S: ƒ; R: ƒ ·
	x  S á R ¤ ³(x.1  S) ± x  R®));
req_thm(Û"z__thm"İ, ([],ñµ x: ƒ;
	R: ƒ; S: ƒ·
	x  R  S ¤ x  R ± ³(x.2  S)®));
req_thm(Û"z_á_clauses"İ, ([],ñµ R: ƒ;S:ƒ·
	(ƒ á R = {}) ±
	({} á R = R) ±
	(S á {} = {})®));
req_thm(Û"z__clauses"İ, ([],ñµ R: ƒ;S:ƒ·
	(R  ƒ = {}) ±
	({}  S = {}) ±
	(R  {} = R)®));
=DESCRIBE
Domain anti-restriction and range anti-restriction.
=ENDDOC
Spivey Ed 1. page 99.

=THDOC
req_thm(Û"z_rel_inv_thm"İ, ([],ñµ x: ƒ; R: ƒ·
	x  R ç~ê ¤ (x.2, x.1)  R®));
req_thm(Û"z_rel_inv_clauses"İ, ([],ñ
	ƒ ç~ê = ƒ ±
	{} ç~ê = {}®));
=DESCRIBE
Relational inversion.
=ENDDOC
Spivey Ed 1. page 100.

=THDOC
req_thm(Û"z_rel_image_thm"İ, ([],
	ñµ y : ƒ; R : ƒ; S : ƒ
	· y  (R ¨  S ©) ¤
	 (¶ x : ƒ · x  S ± (x, y)  R)®));
req_thm(Û"z_rel_image_clauses"İ, ([],
	ñµ R : ƒ; S:ƒ ·
	R ¨ {} © = {} ±
	{} ¨ S © = {}®));
=DESCRIBE
Relational image.
=ENDDOC
Spivey Ed 1. page 101

=THDOC
req_thm(Û"z_trans_closure_thm"İ, ([],ñµ R: ƒ·
	 R ç+ê = ¥ {Q : ƒ | (R € Q) ± (Q » Q € Q)· Q}®));
req_thm(Û"z_reflex_trans_closure_thm"İ, ([],ñµ R: ƒ
· R ç*ê
      = ¥ {Q : ƒ
	      | (id ƒ € Q) ± (R € Q) ± (Q » Q € Q)·
	 Q}®));
req_thm(Û"z_trans_closure_clauses"İ, ([],ñ
	ƒ ç+ê = ƒ ±
	{} ç+ê = {}®));
req_thm(Û"z_reflex_closure_clauses"İ, ([],ñ
	ƒ ç*ê = ƒ ±
	{} ç*ê = id ƒ®));
=DESCRIBE
Transitive and reflexive-transitive closure operations.
=ENDDOC
Spivey Ed 1. page 102

=THDOC
req_thm(Û"z_«_thm"İ, ([],ñµ f : ƒ; g: ƒ·
	f « g = dom g á f À g®));
req_thm(Û"z_«_clauses"İ, ([],ñµ f : ƒ·
	f « {} = f ±
	{} « f = f ±
	f « ƒ = ƒ®));
=DESCRIBE
Functional overriding.
=ENDDOC

\section{TUPLES}
This is a reworking of the language functions, but
with a knowledge of $í$.
=DOC
val Ûz_tuple_eq_convİ : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality.
=FRULE 1 Conversion
z_tuple_eq_conv
ñ(t‰1,t‰2,...) = (u‰1,u‰2,...)®
÷
÷
ô (t‰1,t‰2,...) = (u‰1,u‰2,...) ¤
((t‰1 = u‰1) ± (t‰2 = u‰2) ± ...)
=TEX
$x\ í\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_eq\_conv$
=FAILURE
42003	?0 is not of the form: ñ(x1,...) = (y1,...)®
=ENDDOC
=DOC
val Ûz_sel‰t_convİ : CONV;
=DESCRIBE
This conversion carries out the
selection from a tuple display.
=FRULE 1 Conversion
z_sel‰t_conv
ñ(t‰1,...,t‰i,...,t‰n).i®
÷
÷
ô (t‰1,...,t‰i,...,t‰n).i = t‰i
=TEX
$x\ í\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_sel‰t\_lang\_conv$
=FAILURE
47185	?0 is not a Z tuple selection
42006	?0 is not of the form ñ(x,...).i®
=ENDDOC
=DOC
val Ûz_tuple_intro_convİ : CONV;
=DESCRIBE
This conversion carries out the
elimination of a tuple display of tuple selections
from the same tuple.
=FRULE 1 Conversion
z_tuple_intro_conv
ñ(t.1,...,t.n)®
÷
÷
ô (t.1,...,t.n) = t
=TEX
where $n$ is the arity of $t$.
$x\ í\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_intro\_conv$
=FAILURE
42005	?0 is not of the form: ñ(t.1,...,t.n)®
=ENDDOC

Spivey Ed 1. page 108
\subsection{Elementwise Equalities}
=DOC
val Ûz_binding_eq_conv3İ : CONV;
=DESCRIBE
A conversion for eliminating equations of bindings
to an elementwise equality clause.
In general this does:
=FRULE 1 Conversion
z_binding_eq_conv3
ñb‰1 = b‰2®
÷
÷
ô (b‰1 = b‰2) ¤ (b‰1.s‰1 = b‰2.s‰1) ±
	(b‰1.s‰2 = b‰2.s‰2) ± ...
=TEX
However, it will expand on either side $Ê$-terms into binding displays, and also use $z\_sel‰s\_conv$ on selections from binding displays (whether from $Ê$-terms or otherwise).
=FAILURE
42013	?0  is not of the form ñbinding = binding®
=ENDDOC
=DOC
val Ûz_tuple_eq_conv1İ : CONV;
=DESCRIBE
A conversion for eliminating tuples over equality to an elementwise equality clause.
=FRULE 1 Conversion
z_tuple_eq_conv
ñt1 = t2®
÷
÷
ô (t1 = t2) ¤ (t1.1 = t2.1 ± ...)
=TEX
This will then use $z\_sel‰t\_conv$ to eliminate explicit
tuples.
$x\ í\ y$ will be treated as a 2-tuple.
=SEEALSO
$z\_tuple\_lang\_eq\_conv$
=FAILURE
83001	?0 is not of the form: ñtuple1 = tuple2®
=ENDDOC


\section{PROOF CONTEXTS}
We provide the following proof contexts to reason about the above:

\begin{tabular}{l p{4in}}
$'z\_\_rel$ & Membership of Z relations (e.g. $’$). \\
$'z\_rel\_alg$ & Simplification of Z relations (e.g. $’$). \\
$'z\_tuples$ & handling Z tuples and cartesian products in both language and library (e.g. $í$ and $¸$). \\
$z\_language$ & Z Language reasoning with minimal Library. \\
$z\_language\_ext$ & Extensional Z Language reasoning with minimal Library. \\
$z\_sets\_alg$ & Z Set (and language) reasoning. \\
$z\_sets\_ext$ & Extensional Z Set (and language) reasoning. \\
\end{tabular}

The above proof contexts
will allow $strip\_tac$ to remain within the Z language
on each of its steps, though with the caveat noted in \ref{ZCAVEAT}.

$step\_strip\_tac$ is able to
leave the Z language, which it does for
stripping
a Z existentially quantified antecedent to an implication.
However,
=INLINEFT
REPEAT step_strip_tac
=TEX
{} will remain within the Z language.

Some stripping theorems (e.g. for $ò$)
raise the dilemma of how and whether to
avoid leaving terms of the forms $ñ(x,y).1®$
(a special case is $ñ(x\ í\ y).1®$)
and $ñ(p.1,p.2)®$.
The first form is bad because of functionality problems;
the second is primarily bad because it is verbose,
but also because it provides a less general term for,
e.g., rewriting with.
We currently address this by including three theorems for
each problem operator, and relying on the discrimination
net effect of choosing ``the best match'' (see \cite{DS/FMU/IED/DTD008})
to get results that avoid the forms $ñ(x,y).1®$ and $ñ(p.1,p.2)®$.
We include all three theorems in both rewriting and stripping,
without relying on $z\-\_sel‰t\-\_conv$
during rewriting.
Thus for instance we include the theorems:
=GFT
ô µ p S R· ñp  S ò R ¤ p.1  S ± p  R®
ô µ p1 p2 S R· ñ(p1,p2)  S ò R ¤ p1  S ± (p1,p2)  R®
ô µ p1 p2 S R· ñ(p1 í p2)  S ò R ¤ p1  S ± (p1 í p2)  R®
=TEX
The latter two theorems are automatically generated from the first.
This is only one possible solution, and not even necessarily the best.
Others include addressing the introduction of extensionality
variables, or ``fall back'' conversions if nothing else
applies to a term of the form $ñp\ \ q®$.
The operators affected (to date) are:
=INLINEFT
á, , ò, ’, and o
=TEX
{}.
=DOC
(* Proof Context: Û'z__relİ *)
=DESCRIBE
A component proof context for handling the membership of Z relations created by Z library operations.

Predicates treated by this proof context are constructs formed from:
=GFT
í, «, _ ç+ê, _ ç*ê,_ ç~ê, _ ¨ _ ©, , á, ’, ò,
o, », id, ran, dom, ª
=TEX
\paragraph{Contents}\

Rewriting:
=GFT
z_í_thm
=TEX

Stripping theorems:
=GFT
=TEX

Stripping conclusions:
=GFT
=TEX
All three of the above also have theorems concerning the membership of terms generated by the following operators:
=GFT
«, _ ç+ê, _ ç*ê,_ ç~ê, _ ¨ _ ©, , á, ’, ò,
o, », id, ran, dom, ª
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_relations$.
It is intended to be used with proof contexts ``z$\_$sets$\_$ext'' and ``z$\_$sets$\_$alg''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC

=DOC
(* Proof Context: Û'z_rel_algİ *)
=DESCRIBE
A component proof context for the simplification of Z relations created by Z library operations.

Predicates treated by this proof context are constructs formed from:
=GFT
«, _ ç+ê, _ ç*ê,_ ç~ê, _ ¨ _ ©, , á, ’, ò,
o, », id, ran, dom, ª
=TEX
\paragraph{Contents}\

Rewriting:
=GFT
z_ª_clauses, z_dom_clauses, z_ran_clauses,z_id_clauses,
z_»_clauses, z_…_clauses, z_ò_clauses, z_’_clauses,
z_á_clauses, z__clauses, z_rel_inv_clauses, z_rel_image_clauses,
z_trans_closure_clauses, z_reflex_closure_clauses,
z_«_clauses
=TEX

Stripping theorems:
=GFT
z_ª_clauses, z_dom_clauses, z_ran_clauses,z_id_clauses,
z_»_clauses, z_…_clauses, z_ò_clauses, z_’_clauses,
z_á_clauses, z__clauses, z_rel_inv_clauses, z_rel_image_clauses,
z_trans_closure_clauses, z_reflex_closure_clauses,
z_«_clauses
Expressed as memberships, as necessary, using _C
All also pushed through ³
=TEX

Stripping conclusions:
=GFT
z_ª_clauses, z_dom_clauses, z_ran_clauses,z_id_clauses,
z_»_clauses, z_…_clauses, z_ò_clauses, z_’_clauses,
z_á_clauses, z__clauses, z_rel_inv_clauses, z_rel_image_clauses,
z_trans_closure_clauses, z_reflex_closure_clauses,
z_«_clauses
Expressed as memberships, as necessary, using _C
All also pushed through ³
=TEX
Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_relations$.
It is intended to be used with proof contexts ``z$\_$sets$\_$ext'' and ``z$\_$sets$\_$alg''.
There are clashes of effects if merged with ``z$\_\_$rel'', resolved
in favour of ``z$\_\_$rel'', though the resulting merge
has its uses.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
Membership analogues of these rules could be put in the
stripping.
=DOC
(* Proof Context: Û'z_tuplesİ *)
=DESCRIBE
A component proof context for handling the manipulation of Z tuples and cartesian products within the Z language and library.

Expressions and predicates treated by this proof context are constructs formed from:
=GFT
(membership of) ¸, equations of tuple displays,
selection from tuple displays, first, second, í
=TEX

\paragraph{Contents}\

Rewriting:
=GFT
z__¸_conv,
z_tuple_eq_conv, z_sel‰t_conv,
z_second_thm, z_first_thm
=TEX

Stripping theorems:
=GFT
z__¸_conv,
z_tuple_eq_conv, _C z_sel‰t_conv,
z_sel‰t_conv (where component of tuple is boolean),
plus these all pushed in through ³
=TEX

Stripping conclusions:
=GFT
z__¸_conv,
z_tuple_eq_conv, _C z_sel‰t_conv,
z_sel‰t_conv (where component of tuple is boolean),
plus these all pushed in through ³
=TEX
Stripping also contains the above in negated forms.

Rewriting canonicalisation:
=GFT
=TEX

Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$\-\_basic\-\_prove\-\_conv$,
and
no existence prover (1-tuples and 2-tuples are handled in proof
context ``z$\_$predicates'').
\paragraph{Usage Notes}
It requires theory $z\-\_relations$.
It is intended to be used with proof contexts ``z$\_$sets$\_$ext'' and ``z$\_$sets$\_$alg''.
It should not be used with ``$'$z$\_$tuples$\_$lang''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC
Perhaps later releases will add rules such as
=GFT
(a,b,...) = p ¤ (a = p.1 ± b = p.2 ± ...)
=TEX
perhaps into a separate $'z\_tuples\_ext$.
=DOC
(* Proof Context: Û'z_elementwise_eqİ *)
=DESCRIBE
A aggressive component proof context for forcing the elementwise
comparison of any two items of tuple or binding types.


Predicates and expressions treated by this proof context are:
=GFT
x = y   where x has a tuple type
x = y   where x has the type of a bidning display
=TEX
\paragraph{Contents}\

Rewriting:
=GFT
z_binding_eq_conv3, z_tuple_eq_conv1
=TEX

Stripping theorems:
=GFT
z_binding_eq_conv3, z_tuple_eq_conv1
plus these all pushed in through ³
=TEX

Stripping conclusions:
=GFT
z_binding_eq_conv3, z_tuple_eq_conv1,
plus these all pushed in through ³
=TEX
Rewriting canonicalisation:
=GFT
=TEX
Automatic proof procedures are respectively $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$,
and
no existence prover.
\paragraph{Usage Notes}
It requires theory $z\-\_relations$.
It is intended to be used with proof context ``z$\_$language''.
It is not intended to be mixed with HOL proof contexts.
=ENDDOC

=DOC
(* Proof Context: Ûz_languageİ *)
=DESCRIBE
A mild complete proof context for reasoning in the Z language.
It will also do some minor peices of Z Library reasoning - in
particular, it ``understands'' maplets and $€$.

It consists of the merge of the proof contexts:
=GFT
"z_predicates",
"'z__set_lang",
"'z_bindings",
"'z_schemas",
"'z_tuples"
=TEX
\paragraph{Usage Notes}
It requires theory $z\-\_relations$
(rather than $z\_language\_ps$ as one might expect).
This is because we wish to provide a proof context that
can be added to to provide Library reasoning facilities.
This means that we cannot use the Z language proof context ``$'$z$\_tuples$\_$lang'',
as this is incompatible with ``$'$z$\_tuples'', its
library extension.
This is why this proof context understands maplets, which
are Z Library contructs.
=ENDDOC
=DOC
(* Proof Context: Ûz_language_extİ *)
=DESCRIBE
An aggressive complete proof context for reasoning in the Z language.
It uses the extensionality of sets, and will also decompose
any equality of objects of schema or tuple type
into a pairwise equality clause.
It will also do some minor peices of Z Library reasoning - in
particular, it ``understands'' maplets and $€$.

It consists of the merge of the proof contexts:
=GFT
"z_predicates",
"'z__set_lang",
"'z_sets_ext_lang",
"'z_bindings",
"'z_schemas",
"'z_tuples",
"'z_elementwise_eq"
=TEX
\paragraph{Usage Notes}
It requires theory $z\-\_relations$
(rather than $z\_language\_ps$ as one might expect).
This is because we wish to provide a proof context that
can be added to to provide Library reasoning facilities.
This means that we cannot use the Z language proof context ``$'$z$\_tuples$\_$lang'',
as this is incompatible with ``$'$z$\_tuples'', its
library extension.
This is why this proof context understands maplets, which
are Z Library contructs.
=ENDDOC
=DOC
(* Proof Context: Ûz_sets_extİ *)
=DESCRIBE
An aggressive complete proof context for handling the manipulation of Z set expressions, by breaking them into predicate calculus.

It consists of the merge of the proof contexts:
=GFT
"z_language_ext",
"'z__set_lib",
"'z_sets_ext_lib",
"'z_normal"
=TEX
\paragraph{Usage Notes}
It requires theory $z\-\_relations$.

It is not intended to be mixed with HOL proof contexts
or ``z$\_$sets$\_$alg'', which offers an alternative
approach to reasoning about sets.
=ENDDOC
=DOC
(* Proof Context: Ûz_sets_algİ *)
=DESCRIBE
A mild complete proof context for handling the manipulation of Z set expressions, by algebraic reasoning and knowledge
of the set membership of the set operators.

It consists of the merge of the proof contexts:
=GFT
"z_language",
"'z__set_lib",
"'z_sets_alg",
"'z_normal"
=TEX
\paragraph{Usage Notes}
It requires theory $z\-\_relations$.
The proof context ensures that its simplifications will
be attempted before more general rules concerned membership
of set operators are used (including extensionality rules).

It is not intended to be mixed with HOL proof contexts.
=ENDDOC
=DOC
(* Proof Context: Ûz_rel_extİ *)
=DESCRIBE
An aggressive complete proof context for reasoning about
Z relations. When stripping or rewriting it attempts to
reduce any predicate concerning relational constructs to predicate calculus. As a side effect set constructs
are also reduced to predicate calculus.
The proof context is a merge of:
=GFT
z_sets_ext - extensional reasoning about sets
'z__rel - membership of relational constructs
'z_rel_alg - simplifications of relational constructs
=TEX
It requires the theory ``z$\_$relations''.
=ENDDOC

=TEX
\section{Theorems in the Signature}
=DOC
val z_ª_thm: THM;
val z_í_thm: THM;
val z_dom_thm: THM;
val z_ran_thm: THM;
val z_id_thm: THM;
val z_»_thm: THM;
val z_…_thm: THM;
val z_ò_thm: THM;
val z_’_thm: THM;
val z_á_thm: THM;
val z__thm: THM;
val z_rel_inv_thm: THM;
val z_rel_image_thm: THM;
val z_trans_closure_thm: THM;
val z_reflex_trans_closure_thm: THM;
val z_«_thm: THM;
val z_ª_clauses: THM;
val z_dom_clauses: THM;
val z_ran_clauses: THM;
val z_id_clauses: THM;
val z_»_clauses: THM;
val z_…_clauses: THM;
val z_ò_clauses: THM;
val z_’_clauses: THM;
val z_á_clauses: THM;
val z__clauses: THM;
val z_rel_inv_clauses: THM;
val z_rel_image_clauses: THM;
val z_trans_closure_clauses: THM;
val z_reflex_closure_clauses: THM;
val z_«_clauses: THM;
=DESCRIBE
The ML bindings of the theorems (other than consistency ones)
in theory $z\-\_relations$.
=ENDDOC
=DOC
val Ûz_í_defİ : THM;
val Ûz_dom_defİ : THM;
val Ûz_ran_defİ : THM;
val Ûz_id_defİ : THM;
val Ûz_»_defİ : THM;
val Ûz_…_defİ : THM;
val Ûz_ò_defİ : THM;
val Ûz_’_defİ : THM;
val Ûz_á_defİ : THM;
val Ûz__defİ : THM;
val Ûz_rel_inv_defİ : THM;
val Ûz_rel_image_defİ : THM;
val Ûz_tc_defİ : THM;
val Ûz_rtc_defİ : THM;
val Ûz_«_defİ : THM;
=DESCRIBE
These are the definitions of the theory $z\_relations$.
=ENDDOC

\section{END OF THE SIGNATURE}
=SML
end; (* signature of ZRelations *)
=TEX
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
pop_pc();
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
