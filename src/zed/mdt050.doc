%  mdt050.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Generated Constants}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT050}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL, Z}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test data for
the Z type inferrer.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1 (4th August 1992)]
Initial Draft
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

The module tests provided in this document test the
Z Constant Generation defined in \cite{DS/FMU/IED/DTD050}.


\subsection{Introduction}

\subsubsection{Background and Purpose}

The purpose of this document is to test
the functions in accordance with the test policy in
\cite{DS/FMU/IED/DTD050} and the guidelines laid out in the
quality plan, \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

This document depends on the signature $ZGeneratedConstants$ specified
in \cite{DS/FMU/IED/DTD050}, and the structure $ZGeneratedConstants$
specified in \cite{DS/FMU/IED/IMP050}. It makes use of the
module test harness described in \cite{DS/FMU/IED/DTD013} and
\cite{DS/FMU/IED/IMP013}.

\subsubsection{Possible Enhancements}

None.

\subsubsection{Deficiencies}

None Known.

\section{INITIALISATION}

Initialise the test harness.

SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
=TEX
=SML
open	ZGeneratedConstants;
=TEX

Next, we make the parser and Z type inferrer
directly available to the tests.
=SML
open_theory"z_library";
delete_theory"mdt050" handle _ => ();
new_theory"mdt050";
=TEX

\section{SUPPORTING TEST FUNCTIONS}

The functions introduced in this section are using in testing the Z type
inferrer. Their provision enables the test cases to be implemented in a concise
(and hopefully readable) form.

The function $type\_infer$ is a general interface to the type inferrer, taking
a Z term in string form and producing an inferred Z paragraph.

=SML
local
	open ZTermGenerator ZTypeInference ZUserInterfaceSupport;
in

fun Ûtype_inferÝ {quot : bool, standard : bool} (s : string) : Z_INFERRED = (
let	val parsed = ZParser.z_parser {is_quot=quot, standard=standard}
			(ZLex.z_lex [Lex.Text s]);
in
	type_check_z_para {standard = standard} parsed
end);

fun Ûz_tm_of_stringÝ  (s : string) : Z_TM = (
	case type_infer {quot=true, standard = false} s of
	ZInferred p => (
		case p of
		ZParaTerm (_, tm, _) => tm
		|_ => fail "" 0 []
		)
	|ZTypeError info => (print_z_error info)
);
=SML
val Ûgenerate_termÝ : string -> TERM = 
	 (do_in_theory "z_language" term_of_z_tm) o z_tm_of_string;
=TEX
=SML
fun Ûz_decl_of_stringÝ (s : string)  = (
let	val s1 = "Ì"^s^"·true";
in
	case (z_tm_of_string s1) of
	ZTmÌ((dl,t, _), _) => list_term_of_z_dec dl
	|_ => fail "mdt050" 0 []
end);
=TEX

=SML
fun ÛcrossÝ (a::rest1) rest2 =
let	fun aux a (b::rest) = (a, b)::aux a rest
	  | aux a _ = [];
in
	 aux a rest2@cross rest1 rest2
end
  | cross _ _ = [];
=TEX
=SML
fun Ûgen_listsÝ lst = (
let	val is = interval 1 (length lst-1);
in
	map (fn i => lst to i) is
end);
=TEX
=SML
val labelref : int ref = ref 0;
fun next_name () = (
let	val lab = !labelref;
in
	(labelref := lab+1; lab)
end);
fun ÛlabelÝ s = "mdt050."^s^"."^(string_of_int o next_name)();
=TEX
=SML
fun Ûapply1Ý ((mapping, cgen, cons1), (cons2, decl)) = (
let	val tm = mapping decl;
	val thm = do_in_theory "z_language" cgen tm;
	val constr = cons1^cons2;
	val flag = ((get_defn "z_language" constr;true)
			handle Fail _ => false);
in
	(label constr, flag)
end);
=TEX
=SML
fun Ûapply2Ý ((mapping, cgen, cons1), (cons2, decl)) = (
let	val tm = mapping decl;
	val thm = do_in_theory "z_language" cgen tm;
	val constr = cons1^cons2;
	val flag = (get_defn "z_language" constr;true
			handle Fail _ => false);
in
	(label constr, flag)
end);
=TEX
=SML
fun Ûapply3Ý ((mapping, cgen, cons1), (cons2, decl)) = (
let	val tm = mapping (decl, mk_z_true, mk_z_true);
	val thm = do_in_theory "z_language" cgen tm;
	val constr = cons1^cons2;
	val flag = (get_defn "z_language" constr;true
			handle Fail _ => false);
in
	(label constr, flag)
end);
=TEX
=SML
end (* of local ... in ... *);
=TEX

=SML
fun Ûzd_in_xÝ (s : string) = z_decl_of_string (s^":X");
fun Ûzd_in_yÝ (s : string) = z_decl_of_string (s^":Y");
fun ÛnargsÝ s = (length o explode) s div 2 + 1;
fun ÛsqbrkÝ s = (
let	val name = "Z'S["^s^"]";
	val names = 
		case dest_z_name name of
		(_,[names],_) => names
		|_ => fail "donames" 0 [];
	val snames = idsetseq names;
	val name' = bind_tname snames;
in
		case explode name' of
		("Z"::"'"::"S"::rest) =>
			implode rest
		|_ => fail "donames" 0 []
end);
=TEX
=SML
fun Ûmake_mdt050_ndsÝ (sl : string list) (ty: string) = (
let	val nums = map nargs sl;
	val decls = map (fn s=> z_decl_of_string(s^":"^ty)) sl;
	val schs = map (((switch o curry) mk_z_‰s) mk_z_true) decls;
in
	(nums, decls, schs)
end);

fun Ûmake_mdt050_declsÝ (sl : string list) (ty: string) = (
let
	val (nums, decls, _) = make_mdt050_nds sl ty;
	val ndecls = combine (map (sqbrk o string_of_int) nums) decls;
	val sdecls = combine (map sqbrk sl) decls;
in
	(ndecls, sdecls)
end);

fun Ûmake_mdt050_schsÝ (sl : string list) (ty: string) = (
let
	val (nums, _, schs) = make_mdt050_nds sl ty;
	val nschs = combine (map (sqbrk o string_of_int) nums) schs;
	val sschs = combine (map sqbrk sl) schs;
in
	(nschs, sschs)
end);

fun Ûmake_mdt050_varsÝ (sl : string list) = (
let	val s = (sqbrk o string_of_int o length) sl;
in

	(s, map generate_term sl)
end);

fun Ûmake_mdt050_setsÝ (sl : string list) = (
	(make_mdt050_vars(map (fn s => "ð"^s) sl))
);
=TEX
\section{TEST CASES AND TEST DATA}

\subsection{Common Test Input}

=SML
val simple_names = ["a","b","c","d","e"];
val decl_names = ["a","a,b","a,b,c","a,b,c,d","a,b,c,d,e"];
=TEX
\subsection{Numerically Indexed Families ([2])}
\subsubsection{Where Arguments are Lists}
=SML

val grp_1 = 
[
(mk_z_¸, ¸_gen_semantic_const, "Z'¸"),
(mk_z_tuple, tuple_gen_semantic_const, "Z'T")
];
val data_1 = map make_mdt050_sets
	(gen_lists simple_names);
fun do_grp_1 () = map apply1 (cross grp_1 data_1);
store_mt_results do_grp_1 ();
=TEX

\subsubsection{Where Arguments are Triples}
=SML
val grp_2 = 
[
(mk_z_Ì, Ì_gen_semantic_const, "Z'Ì"),
(mk_z_Í, Í_gen_semantic_const, "Z'Í"),
(mk_z_seta, seta_gen_semantic_const, "Z'Seta"),
(mk_z_¶‰1, ¶‰1_gen_semantic_const, "Z'¶‰1")
];

val data_2 = fst (make_mdt050_decls decl_names "X");
fun do_grp_2 () = map apply3 (cross grp_2 data_2);
store_mt_results do_grp_2 ();
=TEX

\subsection{Component-Indexed Families ([a,b])}
\subsubsection{With One Argument}

=SML
val grp_3 = 
[
(mk_z_„‰s, „‰s_gen_semantic_const, "Z'„‰s"),
(mk_z_˜‰s, ˜‰s_gen_semantic_const, "Z'˜‰s")
];
val data_3 = snd (make_mdt050_schs decl_names "X");
fun do_grp_3 () = map apply1 (cross grp_3 data_3);
store_mt_results do_grp_3 ();

val grp_3a = 
[
(mk_z_pre‰s, pre‰s_gen_semantic_const, "Z'Pre‰s")
];
val predata = ["a,b'", "a,b',c", "a,b',c,d'", "a,b',c,d',e"];
val data_3a = snd (make_mdt050_schs predata "X");
fun do_grp_3a () = map apply1 (cross grp_3a data_3a);
store_mt_results do_grp_3a ();
=TEX

\subsubsection{With Two Arguments}
=SML
val grp_4 = 
[
(mk_z_‰s, schema_gen_semantic_const, "Z'‰s")
];
val data_4 = map (fn (s, sc)=> (s, dest_z_‰s sc)) data_3;
fun do_grp_4 () = map apply2 (cross grp_4 data_4);
store_mt_results do_grp_4 ();
=TEX
\subsubsection{With Two Arguments}
=SML
val grp_5 = 
[
(mk_z_dec‰s, dec‰s_gen_semantic_const, "Z'Dec‰s")
];
val data_5 = data_3;
fun do_grp_4 () = map apply2 (cross grp_4 data_4);
store_mt_results do_grp_4 ();
=TEX

(mk_z_rename‰s, rename‰s_gen_semantic_const, "Z'Rename‰s"),
(mk_z_hide‰s, hide‰s_gen_semantic_const, "Z'Hide‰s"),

val grp_4 = 
[
(mk_z_µ‰s, quant‰s_gen_semantic_const, "Z'µ‰s"),
(mk_z_¶‰s, quant‰s_gen_semantic_const, "Z'¶‰s"),
(mk_z_¶‰1‰s, quant‰s_gen_semantic_const, "Z'¶‰1‰s")
];
fun do_grp_4 () = map apply3 (cross grp_3 sdecls);
store_mt_results do_grp_3 ();
=SML
val grp_5 = 
[
(mk_z_±‰s, dyop‰s_gen_semantic_const, "Z'±‰s"),
(mk_z_²‰s, dyop‰s_gen_semantic_const, "Z'²‰s"),
(mk_z_´‰s, dyop‰s_gen_semantic_const, "Z'´‰s"),
(mk_z_¤‰s, dyop‰s_gen_semantic_const, "Z'¤‰s")
];
val d_5a = snd (make_mdt050_schs ["x", "x,y", "x,y,z"] "ú");
val d_5b = snd (make_mdt050_schs ["a,p", "a,p,q"] "X");
val d_5 = data_3@d_5a@d_5b;
val data_5 = map (fn ((s1,sc1),(s2,sc2)) =>
	(s1^s2, (sc1,sc2)))(combine d_5 (rev d_5));
fun do_grp_5 () = map apply2 (cross grp_5 data_5);
store_mt_results do_grp_5 ();
=TEX

(mk_z_ù‰s, ù‰s_gen_semantic_const, "Z'ù‰s")

[
(mk_z_binding, binding_gen_semantic_const, "Z'Binding‰s"),
(mk_z_»‰s, »‰s_gen_semantic_const, "Z'»‰s")
];






\section{EPILOGUE}
=SML
diag_string (summarize_mt_results());
=TEX

%\newpage
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}

