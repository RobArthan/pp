% mdt064.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% mdt064.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Module Tests for Pretty Printer}
\TPPref{DS/FMU/IED/MDT064}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

docsml mdt064
use_file "mdt064.sml";

make -f rel001.mkf mdt064.dvi
doctex mdt064
texdvi mdt064
bibtex mdt064
doctex mdt064 ; texdvi mdt064
doctex mdt064 ; texdvi mdt064 ; bibtex mdt064
dvipage mdt064 &

docsml mdt064
use_file "mdt064.sml";

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains the module tests for the \ProductZ\
	Pretty Printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}


\item[Issue 1.3, \FormatDate{92/11/02
} ]
	First draft. 
\item[Issue \SCCSissue, \FormatDate{$Date$%
} ]
	Fixed bracketing of cartesian products. 

\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the module tests for the pretty printing
routines for the \ProductZ\ system which are discussed
in~\cite{DS/FMU/IED/DTD064}.  The tests use the module testing system
of~\cite{DS/FMU/IED/DTD013} and~\cite{DS/FMU/IED/IMP013}.
The tests depend on the Z library of \cite{DS/FMU/IED/DTD088} etc.

%********************************************************************


\subsection{Deficiencies}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST CASES}

We provide several groups of tests as follows:

\begin{description}
\item[Group.1] This covers an instance of each form of Z term (as
given in the grammar of \cite{DS/FMU/IED/DEF007}).
\item[Group.2] This checks bracket elimination in several contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus;
(4) around decoration.
\item[Group.3] This checks the handling of the eliding of generic
parameters of the form $U[Totality]$.
\item[Group.4] This checks the elision of characteristic tuples from
set abstractions
\item[Group.5] This checks the handling of generic predicates
\item[Group.6] This checks the handling of declarations
\end{description}

Results are checked by reparsing where possible,
and, if desired, by visual inspection. Note that not everything prints
exactly as input (e.g. `;' as low priority conjunction prints as ordinary
conjunction).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
docsml dtd013
docsml imp013

docsml mdt064
use_file "mdt064.sml";

=TEX

Load and initialise the module test system.

=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
open_theory"z_bags";
new_theory "mdt064_test";
ˇSchema
	x:˙;
	y,z:˙∏˙
˜
	(x, x) = y = z
à
ˇAnotherSchema
	t:˙;
	y,z:˙∏˙
˜
	(t, t) = y = z
à
ˇA
	x:˙
à
ˇB[X]
	x:X
à


=TEX


Functions $ft$ and $uft$ are used to invoke the tests.  The first just
formats the term into a single string, the second formats the term into
a single string, parses it back as a term and formats the result of
that.

=SML
fun ft (x:TERM) : string list = PrettyPrinter.format_term false x;

val uft_aux : TERM ref = ref ¨1Æ;

fun uft (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := Ò" ^ t1 ^ "Æ; !uft_aux)");
in
	!uft_aux
end;
fun uft∫u (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := Ò(" ^ t1 ^ ")∫U Æ; !uft_aux)");
in
	!uft_aux
end;
fun term_of_string (x : string) : TERM = (
let
	val side_effect = use_string
		("(uft_aux := Ò" ^ x ^ "Æ; !uft_aux)");
in
	!uft_aux
end
);

fun chk1 (x : TERM) : bool = (
	x =$ uft x
);
fun chk1∫u (x : TERM) : bool = (
	x =$ uft∫u x
);
fun chk2 (y : string) (x : TERM) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft x)) y
	end
);
fun chk3 (x : string) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft(term_of_string x))) x
	end
);
=TEX
Most tests are run with one or other of the following.
$rp1$ is for cases which will reparse; $rp2$ and $rp3$ for ones which won't. $rp2$ is for cases where casts or
whatever mean that the output is not expected to
be the same as the input; $rp3$ is for cases where
only the input needs to be provided (and is currently no longer necessary).
=SML
fun rp1 (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1, t, true))) data
);
fun rp2 (data: (string * TERM * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t, u) => (s, chk2 u, t, true))) data
);
fun rp3 (data: (string * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk3, t, true))) data
);
=TEX
$rp1∫u$ is for cases which will reparse if we force
an expression context:
=SML
fun rp1∫u (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1∫u, t, true))) data
);

=TEX
%********************************************************************

\section{THE TESTS}
\subsection{Group 1}
These follow the grammar of \cite{DS/FMU/IED/DTD061}.
We label the blocks with the non-terminal names.
=TEX
Block 1: Pred \& Pred1
=SML
store_mt_results rp1 [
("064.1.1.1", Òa ; bÆ),
("064.1.1.2", Òµx:Y|R x∑P x ; bÆ),
("064.1.1.3", Òa ; µx:Y|R x∑P xÆ),
("064.1.1.4", Ò∂[x:X]∑x = xÆ),
("064.1.1.5", Ò∂â1[x:X]∑x = xÆ),
("064.1.1.6", Òµ[x,y:X]| y = y∑x = xÆ)
];
=TEX
Block 2: Pred2
=SML
store_mt_results rp1 [
("064.1.2.1", Òa ± bÆ),
("064.1.2.2", Òa ≤ bÆ),
("064.1.2.3", Òa ¥ bÆ),
("064.1.2.4", Òa § bÆ)
];
=TEX
Block 3: Pred3
=SML
store_mt_results rp1 [
("064.1.3.1", Ò≥a ± bÆ)
];
=TEX
Block 4: Schema2
=SML
store_mt_results rp2 [
("064.1.4.1", Ò([x,y:X] ± [y:Y]) ∫ UÆ, "[x,y:X] ± [y:Y]"),
("064.1.4.2", Ò([x,y:X] ≤ [y:Y]) ∫ UÆ, "[x,y:X] ≤ [y:Y]"),
("064.1.4.3", Ò([x,y:X] § [y:Y]) ∫ UÆ, "[x,y:X] § [y:Y]"),
("064.1.4.4", Ò([x,y:X]  ˘âs [y:Y]) ∫ UÆ, "[x,y:X]  ˘âs [y:Y]"),
("064.1.4.5", Ò([x,x':X]  ªâs [x,x':X]) ∫ UÆ, "[x,x':X]  ªâs [x,x':X]"),
("064.1.4.6", Ò(µx,y:X |x = y∑[x,y,z:X]) ∫ UÆ, "µx,y:X |x = y∑[x,y,z:X]"),
("064.1.4.7", Ò(∂x,y:X |x = y∑[x,y,z:X]) ∫ UÆ, "∂x,y:X |x = y∑[x,y,z:X]"),
("064.1.4.8", Ò(∂â1x,y:X |x = y∑[x,y,z:X]) ∫ UÆ, "∂â1x,y:X |x = y∑[x,y,z:X]")
];
=TEX
Block 5: Schema3
=SML
store_mt_results rp1 [
("064.1.5.1", Òpre[x,x':X|x Ω x']Æ),
("064.1.5.2", Òò[x:X|x Ω x']Æ),
("064.1.5.3", ÒÑ[x:X|x Ω x']Æ)
];
=TEX
Block 6: Schema4
=SML
store_mt_results rp1 [
("064.1.6.1", Ò[x,y,x':X|x Ω x']\âs(x,y)Æ)
];
=TEX
Block 7: Renames
=SML
store_mt_results rp1 [
("064.1.7.1", Ò[x,y,x':X|x Ω x'][a/x]Æ),
("064.1.7.2", Ò[x,y,x':X|x Ω x'][a/x,b/y]Æ)
];
=TEX
Block 8: Decl
=SML
store_mt_results rp1 [
("064.1.8.1", Ò{[x:X]∑x}Æ),
("064.1.8.2", Ò{a,b,c:ABC; d,e,f:DEF∑x}Æ),
("064.1.8.3", Ò{[x:X];[a,b,c:ABC]∑x}Æ),
("064.1.8.4", Ò{[x:X]; a,b,c:ABC;[x:X]; a,b,c:ABC∑x}Æ)
];
=TEX
Block 9: Expr0
=SML
store_mt_results rp1 [
("064.1.9.1", Ò(Õx:X)Æ),
("064.1.9.2", Ò(Ãx:X∑y)Æ),
("064.1.9.3", Ò(Ãx:X|x = x∑y)Æ),
("064.1.9.4", Ò(Õ[x:X]|x = x∑y)Æ)
];
=TEX
Block 10: Expr1
=SML
store_mt_results rp1 [
("064.1.10.1", Ò1+2*3Æ),
("064.1.10.2", Ò1+(2*3)Æ),
("064.1.10.3", Ò~1+2Æ),
("064.1.10.4", Ò~(1+2)Æ),
("064.1.10.5", Òf®{1+2}©Æ)
];
=TEX
Block 11: Expr2
=SML
store_mt_results rp1 [
("064.1.11.1", Ò(˙ ∏ ˙)Æ),
("064.1.11.2", Ò ˙ ∏ ˙Æ),
("064.1.11.3", ÒI ¿ B ∏ CÆ),
("064.1.11.4", ÒI ¿ (B ∏ C)Æ),
("064.1.11.5", Òseq X  ∏ YÆ),
("064.1.11.6", Ò(seq X) ∏ YÆ),
("064.1.11.7", ÒX ∏ Y ∏ ZÆ),
("064.1.11.8", Ò(X ∏ Y) ∏ (Z ∏ W)Æ),
("064.1.11.9", Ò(X ∏ Y) ∏ (Z ¿ W)Æ)
];
=TEX
Block 12: Expr3
=SML
store_mt_results rp1 [
("064.1.12.1", Òf aÆ),
("064.1.12.2", Òf a b cÆ),
("064.1.12.3", Ò SchemaÆ),
("064.1.12.4", Ò Schema!Æ),
("064.1.12.5", Ò (Schema!)Æ),
("064.1.12.6", Ò (Schema!)?Æ),
("064.1.12.7", Ò(x¶1,y¶(1,2)).yÆ)
];
=TEX
Block 13: Expr4
=SML
store_mt_results rp1 [
("064.1.13.1", ÒfÆ),
("064.1.13.2", Òx = ¨CombK 1 2ÆÆ),
("064.1.13.3", Ò99Æ),
("064.1.13.4", Ò"a string"Æ),
("064.1.13.5", Ò"(1,2,3,4)"Æ),
("064.1.13.6", Ò"{1,2,3,4}"Æ),
("064.1.13.7", Ò"{}"Æ),
("064.1.13.8", Ò"{1}"Æ),
("064.1.13.9", Ò"ß1,2,3,4¢"Æ),
("064.1.13.10", Ò"{x:X|x=x∑x}"Æ),
("064.1.13.11", Ò"{x:X|x=x}"Æ),
("064.1.13.12", Ò"{x:X∑x}"Æ),
("064.1.13.13", Ò"[x:X|x = x]"Æ),
("064.1.13.14", Ò"[x:X]"Æ),
("064.1.13.15", Ò"([x:X])'!?"Æ),
("064.1.13.16", Ò(Schema '?!) ??'Æ)
];
=TEX
Block 14: IdDec
=SML
store_mt_results rp1 [
("064.1.14.1", ÒfÆ),
("064.1.14.2", Òf'?!??'Æ),
("064.1.14.3", ÒSchema'?!??'Æ)
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Group 2}
 This checks bracket elimination in three contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus. We simply check that things which should reparse do,
leaving the check that there aren't too many brackets to
be done visually.
=TEX
Block 1: bracket elimination for fancy-fix
=SML
store_mt_results rp1 [
("064.2.1.1", Ò1+2*3Æ),
("064.2.1.2", Ò1+(2*3)Æ),
("064.2.1.3", Ò~1+2Æ),
("064.2.1.4", Ò~(1+2)Æ),
("064.2.1.5", Òf®{1+2}© ° A ¿ B \ CÆ),
("064.2.1.6", Ò(1+2)+3Æ),
("064.2.1.7", Ò1+2+3Æ)
];
=TEX
Block 2: bracket elimination for schema calculus
=SML
store_mt_results rp1∫u [
("064.2.2.1", Ò([x,x':X] ªâs [x,x':X] ± Schema)∫UÆ),
("064.2.2.2", Ò(Schema ˘âs [x,x':X] ªâs Schema)∫UÆ),
("064.2.2.3", Ò(Schema ≤ Schema § Schema)∫UÆ),
("064.2.2.4", Ò(Schema ≤ Schema ± Schema)∫UÆ),
("064.2.2.5", Ò(≥Schema ≤ Schema ± Schema)∫UÆ),
("064.2.2.6", Ò(≥Schema ¥ Schema ± Schema)∫UÆ),
("064.2.2.7", Ò(([x,x':X] ªâs [x,x':X]) ± Schema)∫UÆ),
("064.2.2.8", Ò(Schema' ˘âs ([x,x':X] ªâs Schema))∫UÆ),
("064.2.2.9", Ò(Schema ≤ (Schema § Schema))∫UÆ),
("064.2.2.10", Ò((Schema ≤ Schema) ± Schema)∫UÆ),
("064.2.2.11", Ò(≥(Schema ≤ Schema) ± Schema)∫UÆ),
("064.2.2.12", Ò(≥(Schema ¥ Schema) ± Schema)∫UÆ)
];
=TEX
Not all the $∫U$s above are strictly necessary.
=TEX
Block 3: bracket elimination for propositional calculus (part 1)
=SML
store_mt_results rp1 [
("064.2.3.1.1", ÒA ± B ± CÆ),
("064.2.3.1.2", ÒA ± B ≤ CÆ),
("064.2.3.1.3", ÒA ± B ¥ CÆ),
("064.2.3.1.4", ÒA ± B § CÆ),
("064.2.3.1.5", ÒA ≤ B ± CÆ),
("064.2.3.1.6", ÒA ≤ B ≤ CÆ),
("064.2.3.1.7", ÒA ≤ B ¥ CÆ),
("064.2.3.1.8", ÒA ≤ B § CÆ),
("064.2.3.1.9", ÒA ¥ B ± CÆ),
("064.2.3.1.10", ÒA ¥ B ≤ CÆ),
("064.2.3.1.11", ÒA ¥ B ¥ CÆ),
("064.2.3.1.12", ÒA ¥ B § CÆ),
("064.2.3.1.13", ÒA § B ± CÆ),
("064.2.3.1.14", ÒA § B ≤ CÆ),
("064.2.3.1.15", ÒA § B ¥ CÆ),
("064.2.3.1.16", ÒA § B § CÆ)
];
=TEX
Block 3: bracket elimination for propositional calculus (part 2)
=SML
store_mt_results rp1 [
("064.2.3.2.1", Ò(A ± B) ± CÆ),
("064.2.3.2.2", ÒA ± (B ≤ C)Æ),
("064.2.3.2.3", ÒA ± (B ¥ C)Æ),
("064.2.3.2.4", ÒA ± (B § C)Æ),
("064.2.3.2.5", Ò(A ≤ B) ± CÆ),
("064.2.3.2.6", Ò(A ≤ B) ≤ CÆ),
("064.2.3.2.7", ÒA ≤ (B ¥ C)Æ),
("064.2.3.2.8", ÒA ≤ (B § C)Æ),
("064.2.3.2.9", Ò(A ¥ B) ± CÆ),
("064.2.3.2.10", Ò(A ¥ B) ≤ CÆ),
("064.2.3.2.11", Ò(A ¥ B) ¥ CÆ),
("064.2.3.2.12", Ò(A ¥ B) § CÆ),
("064.2.3.2.13", ÒA § (B ± C)Æ),
("064.2.3.2.14", ÒA § (B ≤ C)Æ),
("064.2.3.2.15", ÒA § (B ¥ C)Æ),
("064.2.3.2.16", ÒA § (B § C)Æ)
];
=TEX
Block 4: bracket elimination around decoration
=SML
store_mt_results rp1 [
("064.2.4.2.1", Ò∂(B[X])'∑trueÆ),
("064.2.4.2.2", Ò∂(A')∑trueÆ),
("064.2.4.2.3", Ò∂A; (A?)'; ((B[X])'')?∑trueÆ)
];
=TEX
\subsection{Group 3}
Elision of $U[Totality]$.
=SML
store_mt_results rp2 [
("064.3.1", ÒUÆ, "U"),
("064.3.2", ÒU[˙]Æ, "U[˙]")
];
=TEX
\subsection{Group 4}
Elision of characteristic tuple.
=SML
store_mt_results rp1 [
("064.4.1", Ò{x:X}Æ),
("064.4.2", Ò{x,y:X|x = y}Æ),
("064.4.3", Ò{Schema|z = y}Æ)
];
=TEX
\subsection{Group 5}
Generic predicates.
=SML
store_mt_results rp1 [
("064.5.1", Ò[X](x ç X)Æ),
("064.5.2", Ò[Z]z ç Z ≤ y ç YÆ),
("064.5.3", Ò[X, Y, Z](x ç X ± z ç Z ± Ò[Z]z ç Z ≤ y ç YÆ)Æ),
("064.5.4", Ò[X, Y](x ç X ± ¨µy∑x = yÆ)Æ)
];
=TEX
\subsection{Group 6}
Declarations.
=SML
store_mt_results rp1 [
("064.6.1", fst(dest_z_âs Ò[x,y,z:˙]Æ)),
("064.6.2", fst(dest_z_âs Ò[Schema]Æ)),
("064.6.3", hd(dest_z_decl(fst(dest_z_âs Ò[x,y,z:˙]Æ)))),
("064.6.4", hd(dest_z_decl(fst(dest_z_âs Ò[Schema]Æ))))
];
=TEX
\section{SUMMARY OF RESULTS}

=SML
"Summary Of Results";

set_line_length 80;

diag_string(summarize_mt_results());
=TEX

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------
 rp1 [
("064.1.9.1", Ò(Õx:X)Æ),
("064.1.9.2", Ò(Ãx:X∑y)Æ),
("064.1.9.2", Ò(Ãx:X|x = x∑y)Æ)
];
