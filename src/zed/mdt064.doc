=IGN
********************************************************************************
mdt064.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% mdt064.doc   %Z% $Date: 2005/08/03 15:12:49 $ $Revision: 1.18 $ $RCSfile: mdt064.doc,v $

=TEX
% mdt064.doc   %Z% $Date: 2005/08/03 15:12:49 $ $Revision: 1.18 $ $RCSfile: mdt064.doc,v $
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Module Tests for Pretty Printer}
\TPPref{DS/FMU/IED/MDT064}
\def\SCCSissue{$Revision: 1.18 $%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date: 2005/08/03 15:12:49 $%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

docsml mdt064
use_file "mdt064.sml";

make -f rel001.mkf mdt064.dvi
doctex mdt064
texdvi mdt064
bibtex mdt064
doctex mdt064 ; texdvi mdt064
doctex mdt064 ; texdvi mdt064 ; bibtex mdt064
dvipage mdt064 &

docsml mdt064
use_file "mdt064.sml";

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains the module tests for the \ProductZ\
	Pretty Printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}


\item[Issue 1.3, \FormatDate{92/11/02
} ]
	First draft. 
\item[Issue 1.4, \FormatDate{92/11/30} ]
	Fixed bracketing of cartesian products. 
\item[Issue 1.5, \FormatDate{92/12/03} ]
Improved treatment of declarations and generic predicates plus some fixes. 
\item[Issue 1.6, \FormatDate{92/12/09} ]
Tests for bug fixes of version 1.20 of implementation. 
\item[Issue 1. 7 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.8 (18th February 1993)]
Regression test for fix of bug HAT 97.
\item[Issue 1.9 (23th February 1993)]
Modified parent of working theory.
\item[Issue 1.10 (1st May 1997)]
Module tests fix to bug HAT 64.
\item[Issue 1.11 (30th June 2000)]
Extra test for Í added.
\item[Issue 1.12] Copyright and banner updates for open source release.
\item[Issue 1.13] PPZed-specific updates for open source release
\item[Issue 1.14] The Z universal set is now called ƒ.
\item[Issue 1.15] Added test for fixed handling of relations like {\it\_partition\_}.
\item[Issue 1.16] Added tests for binding and tuple selection.
\item[Issue 1.17] Added more tests for bracket-elimination around function application.
\item[Issue 1.18] Schema projection is now left-associative.
\item[Issue 1.19] Added tests for \$-feature.
\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the module tests for the pretty printing
routines for the \ProductZ\ system which are discussed
in~\cite{DS/FMU/IED/DTD064}.  The tests use the module testing system
of~\cite{DS/FMU/IED/DTD013} and~\cite{DS/FMU/IED/IMP013}.
The tests depend on the Z library of \cite{DS/FMU/IED/DTD088} etc.

%********************************************************************


\subsection{Deficiencies}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST CASES}

We provide several groups of tests as follows:

\begin{description}
\item[Group.1] This covers an instance of each form of Z term (as
given in the grammar of \cite{DS/FMU/IED/DEF007}).
\item[Group.2] This checks bracket elimination in several contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus;
(4) around decoration.
\item[Group.3] This checks the handling of the eliding of generic
parameters of the form $ƒ[Totality]$.
\item[Group.4] This checks the elision of characteristic tuples from
set abstractions
\item[Group.5] This checks the handling of generic predicates
\item[Group.6] This checks the handling of declarations
\item[Group.7] Miscellaneous regression tests for various fixes
\end{description}

Results are checked by reparsing where possible,
and, if desired, by visual inspection. Note that not everything prints
exactly as input (e.g. `;' as low priority conjunction prints as ordinary
conjunction).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
docsml dtd013
docsml imp013

docsml mdt064
use_file "mdt064.sml";

=TEX

Load and initialise the module test system.

=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
open_theory"z_library";
new_theory "mdt064_test";
ÿSchema
	x:ú;
	y,z:ú¸ú
÷
	(x, x) = y = z
ˆ
ÿAnotherSchema
	t:ú;
	y,z:ú¸ú
÷
	(t, t) = y = z
ˆ
ÿA
	x:ú
ˆ
ÿB[X]
	x:X
ˆ


=TEX


Functions $ft$ and $uft$ are used to invoke the tests.  The first just
formats the term into a single string, the second formats the term into
a single string, parses it back as a term and formats the result of
that.

=SML
fun ft (x:TERM) : string list = PrettyPrinter.format_term false x;

val uft_aux : TERM ref = ref ¬1®;

fun uft (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := ñ" ^ t1 ^ "®; !uft_aux)");
in
	!uft_aux
end;
fun uftºu (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := ñ(" ^ t1 ^ ")ºƒ ®; !uft_aux)");
in
	!uft_aux
end;
fun term_of_string (x : string) : TERM = (
let
	val side_effect = use_string
		("(uft_aux := ñ" ^ x ^ "®; !uft_aux)");
in
	!uft_aux
end
);

fun chk1 (x : TERM) : bool = (
	x =$ uft x
);
fun chk1ºu (x : TERM) : bool = (
	x =$ uftºu x
);
fun chk2 (y : string) (x : TERM) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft x)) y
	end
);
fun chk3 (x : string) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft(term_of_string x))) x
	end
);
=TEX
Most tests are run with one or other of the following.
$rp1$ is for cases which will reparse; $rp2$ and $rp3$ for ones which won't. $rp2$ is for cases where casts or
whatever mean that the output is not expected to
be the same as the input; $rp3$ is for cases where
only the input needs to be provided (and is currently not used).
=SML
fun rp1 (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1, t, true))) data
);
fun rp2 (data: (string * TERM * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t, u) => (s, chk2 u, t, true))) data
);
fun rp3 (data: (string * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk3, t, true))) data
);
=TEX
$rp1ºu$ is for cases which will reparse if we force
an expression context:
=SML
fun rp1ºu (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1ºu, t, true))) data
);

=TEX
%********************************************************************

\section{THE TESTS}
\subsection{Group 1}
These follow the grammar of \cite{DS/FMU/IED/DTD061}.
We label the blocks with the non-terminal names.
=TEX
Block 1: Pred \& Pred1
=SML
store_mt_results rp1 [
("064.1.1.1", ña ; b®),
("064.1.1.2", ñµx:Y|R x·P x ; b®),
("064.1.1.3", ña ; µx:Y|R x·P x®),
("064.1.1.4", ñ¶[x:X]·x = x®),
("064.1.1.5", ñ¶‰1[x:X]·x = x®),
("064.1.1.6", ñµ[x,y:X]| y = y·x = x®)
];
=TEX
Block 2: Pred2
=SML
store_mt_results rp1 [
("064.1.2.1", ña ± b®),
("064.1.2.2", ña ² b®),
("064.1.2.3", ña ´ b®),
("064.1.2.4", ña ¤ b®)
];
=TEX
Block 3: Pred3
=SML
store_mt_results rp1 [
("064.1.3.1", ñ³a ± b®)
];
=TEX
Block 4: Schema2
=SML
store_mt_results rp2 [
("064.1.4.1", ñ([x,y:X] ± [y:Y]) º ƒ®, "[x,y:X] ± [y:Y]"),
("064.1.4.2", ñ([x,y:X] ² [y:Y]) º ƒ®, "[x,y:X] ² [y:Y]"),
("064.1.4.3", ñ([x,y:X] ¤ [y:Y]) º ƒ®, "[x,y:X] ¤ [y:Y]"),
("064.1.4.4", ñ([x,y:X]  ù‰s [y:Y]) º ƒ®, "[x,y:X]  ù‰s [y:Y]"),
("064.1.4.5", ñ([x,x':X]  »‰s [x,x':X]) º ƒ®, "[x,x':X]  »‰s [x,x':X]"),
("064.1.4.6", ñ(µx,y:X |x = y·[x,y,z:X]) º ƒ®, "µx,y:X |x = y·[x,y,z:X]"),
("064.1.4.7", ñ(¶x,y:X |x = y·[x,y,z:X]) º ƒ®, "¶x,y:X |x = y·[x,y,z:X]"),
("064.1.4.8", ñ(¶‰1x,y:X |x = y·[x,y,z:X]) º ƒ®, "¶‰1x,y:X |x = y·[x,y,z:X]")
];
=TEX
Block 5: Schema3
=SML
store_mt_results rp1 [
("064.1.5.1", ñpre[x,x':X|x ½ x']®),
("064.1.5.2", ñ˜[x:X|x ½ x']®),
("064.1.5.3", ñ„[x:X|x ½ x']®)
];
=TEX
Block 6: Schema4
=SML
store_mt_results rp1 [
("064.1.6.1", ñ[x,y,x':X|x ½ x']\‰s(x,y)®)
];
=TEX
Block 7: Renames
=SML
store_mt_results rp1 [
("064.1.7.1", ñ[x,y,x':X|x ½ x'][a/x]®),
("064.1.7.2", ñ[x,y,x':X|x ½ x'][a/x,b/y]®)
];
=TEX
Block 8: Decl
=SML
store_mt_results rp1 [
("064.1.8.1", ñ{[x:X]·x}®),
("064.1.8.2", ñ{a,b,c:ABC; d,e,f:DEF·x}®),
("064.1.8.3", ñ{[x:X];[a,b,c:ABC]·x}®),
("064.1.8.4", ñ{[x:X]; a,b,c:ABC;[x:X]; a,b,c:ABC·x}®)
];
=TEX
Block 9: Expr0
=SML
store_mt_results rp1 [
("064.1.9.1", ñ(Íx:X)®),
("064.1.9.2", ñ(Ìx:X·y)®),
("064.1.9.3", ñ(Ìx:X|x = x·y)®),
("064.1.9.4", ñ(Í[x:X]|x = x·y)®),
("064.1.9.5", ñ(Í[x:X]|x = x)®)
];
=TEX
Block 10: Expr1
=SML
store_mt_results rp1 [
("064.1.10.1", ñ1+2*3®),
("064.1.10.2", ñ1+(2*3)®),
("064.1.10.3", ñ~1+2®),
("064.1.10.4", ñ~(1+2)®),
("064.1.10.5", ñf¨{1+2}©®)
];
=TEX
Block 11: Expr2
=SML
store_mt_results rp1 [
("064.1.11.1", ñğ(ú ¸ ú)®),
("064.1.11.2", ñğ ú ¸ ú®),
("064.1.11.3", ñI À B ¸ C®),
("064.1.11.4", ñI À (B ¸ C)®),
("064.1.11.5", ñseq X  ¸ Y®),
("064.1.11.6", ñ(seq X) ¸ Y®),
("064.1.11.7", ñX ¸ Y ¸ Z®),
("064.1.11.8", ñ(X ¸ Y) ¸ (Z ¸ W)®),
("064.1.11.9", ñ(X ¸ Y) ¸ (Z À W)®)
];
=TEX
Block 12: Expr3
=SML
store_mt_results rp1 [
("064.1.12.1", ñf a®),
("064.1.12.2", ñf a b c®),
("064.1.12.3", ñÊSchema®),
("064.1.12.4", ñÊSchema!®),
("064.1.12.5", ñÊ(Schema!)®),
("064.1.12.6", ñÊ(Schema!)?®),
("064.1.12.7", ñ(x¦1,y¦(1,2)).y®)
];
=TEX
Block 13: Expr4
=SML
store_mt_results rp1 [
("064.1.13.1", ñf®),
("064.1.13.2", ñx = ¬CombK 1 2®®),
("064.1.13.3", ñ99®),
("064.1.13.4", ñ"a string"®),
("064.1.13.5", ñ"(1,2,3,4)"®),
("064.1.13.6", ñ"{1,2,3,4}"®),
("064.1.13.7", ñ"{}"®),
("064.1.13.8", ñ"{1}"®),
("064.1.13.9", ñ"§1,2,3,4¢"®),
("064.1.13.10", ñ"{x:X|x=x·x}"®),
("064.1.13.11", ñ"{x:X|x=x}"®),
("064.1.13.12", ñ"{x:X·x}"®),
("064.1.13.13", ñ"[x:X|x = x]"®),
("064.1.13.14", ñ"[x:X]"®),
("064.1.13.15", ñ"([x:X])'!?"®),
("064.1.13.16", ñ(Schema '?!) ??'®)
];
=TEX
Block 14: IdDec
=SML
store_mt_results rp1 [
("064.1.14.1", ñf®),
("064.1.14.2", ñf'?!??'®),
("064.1.14.3", ñSchema'?!??'®)
];
=TEX
Block 15: \$-feature:
=SML
store_mt_results rp1 [
("064.1.15.1", ñ$"abc def"®),
("064.1.15.2", ñ$"_*_"®),
("064.1.15.3", ñ$"_ * _"®),
("064.1.15.4", ñ$"aa##"®)
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Group 2}
 This checks bracket elimination in several contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus;
(4) around decoration; (5) equality and membership;
(6) binding and tuple selection;
(7) function application.

In many cases, we just check that things which should reparse do,
leaving the check that there aren't too many brackets to
be done visually.
=TEX
Block 1: bracket elimination for fancy-fix
=SML
store_mt_results rp2 [
("064.2.1.1", ñ1+2*3®, "1+2*3"),
("064.2.1.2", ñ1+(2*3)®, "1+2*3"),
("064.2.1.3", ñ~1+2®, "~1+2"),
("064.2.1.4", ñ~(1+2)®, "~(1+2)"),
("064.2.1.5", ñf¨{1+2}© ¡ A À B \ C®, "f¨{1+2}© ¡ A À B \\ C"),
("064.2.1.6", ñ(1+2)+3®, "1+2+3"),
("064.2.1.7", ñ1+2+3®, "1+2+3"),
("064.2.1.8", ñ1+(2+3)®, "1+(2+3)")
];
=TEX
Block 2: bracket elimination for schema calculus
=SML
store_mt_results rp2 [
("064.2.2.1", ñ([x,x':X] »‰s [x,x':X] ± Schema)ºƒ®,
	"[x,x':X] »‰s [x,x':X] ± Schema"),
("064.2.2.2", ñ(Schema ù‰s [x,x':X] »‰s Schema)ºƒ®,
	"Schema ù‰s [x,x':X] »‰s Schema"),
("064.2.2.3", ñ(Schema ² Schema ¤ Schema)ºƒ®,
	"Schema ² Schema ¤ Schema"),
("064.2.2.4", ñ(Schema ² Schema ± Schema)ºƒ®,
	"Schema ² Schema ± Schema"),
("064.2.2.5", ñ(³Schema ² Schema ± Schema)ºƒ®,
	"³Schema ² Schema ± Schema"),
("064.2.2.6", ñ(³Schema ´ Schema ± Schema)ºƒ®,
	"³Schema ´ Schema ± Schema"),
("064.2.2.7", ñ(([x,x':X] »‰s [x,x':X]) ± Schema)ºƒ®,
	"([x,x':X] »‰s [x,x':X]) ± Schema"),
("064.2.2.8", ñ(Schema' ù‰s ([x,x':X] »‰s Schema))ºƒ®,
	"(Schema') ù‰s ([x,x':X] »‰s Schema)"),
("064.2.2.9", ñ(Schema ² (Schema ¤ Schema))ºƒ®,
	"Schema ² (Schema ¤ Schema)"),
("064.2.2.10", ñ((Schema ² Schema) ± Schema)ºƒ®,
	"(Schema ² Schema) ± Schema"),
("064.2.2.11", ñ(³(Schema ² Schema) ± Schema)ºƒ®,
	"³(Schema ² Schema) ± Schema"),
("064.2.2.12", ñ(³(Schema ´ Schema) ± Schema)ºƒ®,
	"³(Schema ´ Schema) ± Schema"),
("064.2.2.13", ñ(Schema ù‰s [x, x':ú] ù‰s Schema)ºƒ®,
	"Schema ù‰s [x, x' : ú] ù‰s Schema"),
("064.2.2.14", ñSchema ù‰s ([x, x' : ú] ù‰s [a:ú])ºƒ®,
	"Schema ù‰s ([x, x' : ú] ù‰s [a:ú])")
];
=TEX
Not all the $ºƒ$s above are strictly necessary.
=TEX
Block 3: bracket elimination for propositional calculus (part 1)
=SML
store_mt_results rp2 [
("064.2.3.1.1", ñA ± B ± C®, "A ± B ± C"),
("064.2.3.1.2", ñA ± B ² C®, "A ± B ² C"),
("064.2.3.1.3", ñA ± B ´ C®, "A ± B ´ C"),
("064.2.3.1.4", ñA ± B ¤ C®, "A ± B ¤ C"),
("064.2.3.1.5", ñA ² B ± C®, "A ² B ± C"),
("064.2.3.1.6", ñA ² B ² C®, "A ² B ² C"),
("064.2.3.1.7", ñA ² B ´ C®, "A ² B ´ C"),
("064.2.3.1.8", ñA ² B ¤ C®, "A ² B ¤ C"),
("064.2.3.1.9", ñA ´ B ± C®, "A ´ B ± C"),
("064.2.3.1.10", ñA ´ B ² C®, "A ´ B ² C"),
("064.2.3.1.11", ñA ´ B ´ C®, "A ´ B ´ C"),
("064.2.3.1.12", ñA ´ B ¤ C®, "A ´ B ¤ C"),
("064.2.3.1.13", ñA ¤ B ± C®, "A ¤ B ± C"),
("064.2.3.1.14", ñA ¤ B ² C®, "A ¤ B ² C"),
("064.2.3.1.15", ñA ¤ B ´ C®, "A ¤ B ´ C"),
("064.2.3.1.16", ñA ¤ B ¤ C®, "A ¤ B ¤ C")
];
=TEX
Block 3: bracket elimination for propositional calculus (part 2)
=SML
store_mt_results rp2 [
("064.2.3.2.1", ñ(A ± B) ± C®, "(A ± B) ± C"),
("064.2.3.2.2", ñA ± (B ² C)®, "A ± (B ² C)"),
("064.2.3.2.3", ñA ± (B ´ C)®, "A ± (B ´ C)"),
("064.2.3.2.4", ñA ± (B ¤ C)®, "A ± (B ¤ C)"),
("064.2.3.2.5", ñ(A ² B) ± C®, "(A ² B) ± C"),
("064.2.3.2.6", ñ(A ² B) ² C®, "(A ² B) ² C"),
("064.2.3.2.7", ñA ² (B ´ C)®, "A ² (B ´ C)"),
("064.2.3.2.8", ñA ² (B ¤ C)®, "A ² (B ¤ C)"),
("064.2.3.2.9", ñ(A ´ B) ± C®, "(A ´ B) ± C"),
("064.2.3.2.10", ñ(A ´ B) ² C®, "(A ´ B) ² C"),
("064.2.3.2.11", ñ(A ´ B) ´ C®, "(A ´ B) ´ C"),
("064.2.3.2.12", ñ(A ´ B) ¤ C®, "A ´ B ¤ C"),
("064.2.3.2.13", ñA ¤ (B ± C)®, "A ¤ B ± C"),
("064.2.3.2.14", ñA ¤ (B ² C)®, "A ¤ B ² C"),
("064.2.3.2.15", ñA ¤ (B ´ C)®, "A ¤ B ´ C"),
("064.2.3.2.16", ñA ¤ (B ¤ C)®, "A ¤ B ¤ C")
];
=TEX
Block 4: bracket elimination around decoration
=SML
store_mt_results rp2 [
("064.2.4.1.1", ñ¶(B[X])'·true®, "¶(B[X])'·true"),
("064.2.4.1.2", ñ¶(A')·true®, "¶(A')·true"),
("064.2.4.1.3", ñ¶A; (A?)'; ((B[X])'')?·true®, "¶A; (A?)'; ((B[X])'')?·true")
];
=TEX
Block 5: bracket elimination around equality and membership
=SML
store_mt_results rp2 [
("064.2.5.1.1", ñ[A] (x = (Ìa:A·true))®, "[A] (x = (Ìa:A·true))"),
("064.2.5.1.2", ñ[A] (x  (Ìa:A·true))®, "[A] (x  (Ìa:A·true))"),
("064.2.5.1.3", ñ[A] ((Ìa:A·true) = F)®, "[A] ((Ìa:A·true) = F)"),
("064.2.5.1.4", ñ[A] ((Ìa:A·true)  F)®, "[A] ((Ìa:A·true)  F)"),
("064.2.5.1.5", ñ[A] ((x = A)  F)®, "[A] ((x = A)  F)"),
("064.2.5.1.6", ñ[A] ((x  A)  F)®, "[A] ((x  A)  F)"),
("064.2.5.1.7", ñ[A] (x  A  F)®, "[A] (x  A ± A  F)"),
("064.2.5.1.8", ñ[A] (x  A = F)®, "[A] (x  A ± A = F)"),
("064.2.5.1.9", ñ[A] (x = A  F)®, "[A] (x = A ± A  F)"),
("064.2.5.1.10", ñ[A] (x = A = F)®, "[A] (x = A ± A = F)")
];
=TEX
Block 6: bracket elimination around binding and tuple selection
=SML
store_mt_results rp2 [
("064.2.6.1.1",  ñµ t : [a, b :[x, y:ú]]· t.a.x = t.b.y ² f(t.a.x + t.b.y)®,
	"µ t : [a, b :[x, y:ú]]· t.a.x = t.b.y ² f(t.a.x + t.b.y)"),
("064.2.6.1.2",  ñµ t : [a, b :[x, y:ú]]· 2 + t.a.x = t.b.y + 1 ² f(t.a.x + t.b.y)®,
	"µ t : [a, b :[x, y:ú]]· 2 + t.a.x = t.b.y + 1 ² f(t.a.x + t.b.y)"),
("064.2.6.1.3",  ñµ t : (ú ¸ ú) ¸ (ú ¸ ú)· t.1.2 = t.2.1 ² f(t.1.1 + t.2.2)®,
	"µ t : (ú ¸ ú) ¸ (ú ¸ ú)· t.1.2 = t.2.1 ² f(t.1.1 + t.2.2)"),
("064.2.6.1.4",  ñµ t : (ú ¸ ú) ¸ (ú ¸ ú)· 2 + t.1.2 = t.2.1 + 1 ² f(t.1.1 + t.2.2)
®,
	"µ t : (ú ¸ ú) ¸ (ú ¸ ú)· 2 + t.1.2 = t.2.1 + 1 ² f(t.1.1 + t.2.2)")
];
=TEX
Block 7: bracket elimination around function application
=SML
store_mt_results rp2 [
("064.2.7.1.1",  ñf a b®,
	"f a b"),
("064.2.7.1.2",  ñf (Á a) (Â b)®,
	"f (Á a) (Â b)"),
("064.2.7.1.3",  ñf (ÊA) x®,
	"f (ÊA) x"),
("064.2.7.1.4",  ñÊ((Ìx:ú·A) 1)®,
	"Ê((Ìx:ú·A) 1)"),
("064.2.7.1.5",  ñf(Ê((Ìx:ú·A) 1)) x®,
	"f(Ê((Ìx:ú·A) 1)) x")
];
=TEX
\subsection{Group 3}
Elision of $ƒ[Totality]$.
=SML
store_mt_results rp2 [
("064.3.1", ñƒ®, "ƒ"),
("064.3.2", ñƒ[ú]®, "ƒ[ú]")
];
=TEX
\subsection{Group 4}
Elision of characteristic tuple.
=SML
store_mt_results rp1 [
("064.4.1", ñ{x:X}®),
("064.4.2", ñ{x,y:X|x = y}®),
("064.4.3", ñ{Schema|z = y}®)
];
=TEX
\subsection{Group 5}
Generic predicates.
=SML
store_mt_results rp1 [
("064.5.1", ñ[X](x  X)®),
("064.5.2", ñ[Z]z  Z ² y  Y®),
("064.5.3", ñ[X, Y, Z](x  X ± z  Z ± ñ[Z]z  Z ² y  Y®)®),
("064.5.4", ñ[X, Y](x  X ± ¬µy·x = y®)®)
];
=TEX
\subsection{Group 6}
Declarations.
=SML
store_mt_results rp1 [
("064.6.1", fst(dest_z_h_schema ñ[x,y,z:ú]®)),
("064.6.2", fst(dest_z_h_schema ñ[Schema]®)),
("064.6.3", hd(dest_z_decl(fst(dest_z_h_schema ñ[x,y,z:ú]®)))),
("064.6.4", hd(dest_z_decl(fst(dest_z_h_schema ñ[Schema]®)))),
("064.6.5", mk_z_dec([ñ(x ¦ 1, x' ¦ 2, z ¦ 3).z®],ñú®))
];
=TEX
\subsection{Group 7}
Regression tests for bug fixes.
=SML
store_mt_results rp1 [
("064.7.1", ñ¬Z'Dec ([z'x'], XX)®®)	,	(* HAT 97 *)
("064.7.2", ñ{[x : ƒ] | true}®),		(* HAT 64 *)
("064.7.3", ñ{[x : ƒ]}®),		(* HAT 64 *)
("064.7.4", ñ{A | true}®),		(* HAT 64 *)
("064.7.5", ñ{A}®),			(* HAT 64 *)
("064.7.6", ñ{[x : ƒ] · (x,x)}®),	(* HAT 64 *)
("064.7.7", ñ{A · (x,x)}®)		(* HAT 64 *)
];
=TEX
=SML
store_mt_results rp1 [
("064.7.8", ñ(_partition_)[ú, ú ¸ ú]®)
];
=TEX
Associativity of schema calculus operations:
ÿ AA üüüüüüüüüüü
Ü a, ab, ac, abc : ú
ˆüüüüüüüüüüüüüü
ÿ BB üüüüüüüüüüü
Ü b, ab, bc, abc : ú
ˆüüüüüüüüüüüüüü
ÿ CC üüüüüüüüüüü
Ü c, ac, bc, abc : ú
ˆüüüüüüüüüüüüüü
=SML
store_mt_results rp1 [
("064.7.9", ñAA ± (BB ± CC)®),
("064.7.10", ñAA ² (BB ² CC)®),
("064.7.11", ñ(AA ± BB) ± CC®),
("064.7.12", ñ(AA ² BB) ² CC®),
("064.7.13", ñAA ù‰s (BB ù‰s CC)®),
("064.7.14", ñ(AA ù‰s BB) ù‰s CC®)
];
=TEX
\section{SUMMARY OF RESULTS}

=SML
val _ = set_line_length 80;
val _ = diag_line "Summary Of Results";
val _ = diag_string(summarize_mt_results());
=TEX

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------
