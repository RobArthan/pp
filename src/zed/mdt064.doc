=IGN
********************************************************************************
mdt064.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% mdt064.doc   %Z% 2008/09/05 14:23:03 1.27 mdt064.doc,v

=TEX
% mdt064.doc   %Z% 2008/09/05 14:23:03 1.27 mdt064.doc,v
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Module Tests for Pretty Printer}
\TPPref{DS/FMU/IED/MDT064}
\def\SCCSissue{1.27%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{2008/09/05 14:23:03%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

docsml mdt064
use_file "mdt064.sml";

make -f rel001.mkf mdt064.dvi
doctex mdt064
texdvi mdt064
bibtex mdt064
doctex mdt064 ; texdvi mdt064
doctex mdt064 ; texdvi mdt064 ; bibtex mdt064
dvipage mdt064 &

docsml mdt064
use_file "mdt064.sml";

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains the module tests for the \ProductZ\
	Pretty Printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}


\item[Issue 1.3 (1992/11/02), \FormatDate{92/11/02
} ]
	First draft.
\item[Issue 1.4 (1992/11/30), \FormatDate{92/11/30} ]
	Fixed bracketing of cartesian products.
\item[Issue 1.5 (1992/12/03), \FormatDate{92/12/03} ]
Improved treatment of declarations and generic predicates plus some fixes.
\item[Issue 1.6 (1992/12/09), \FormatDate{92/12/09} ]
Tests for bug fixes of version 1.20 of implementation.
\item[Issue 1. 7 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.8 (1993/02/18) (18th February 1993)]
Regression test for fix of bug HAT 97.
\item[Issue 1.9 (1993/02/23) (23th February 1993)]
Modified parent of working theory.
\item[Issue 1.10 (1997/05/02) (1st May 1997)]
Module tests fix to bug HAT 64.
\item[Issue 1.11 (2000/06/30) (30th June 2000)]
Extra test for Õ added.
\item[Issue 1.12 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.13 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.14 (2004/01/19)] The Z universal set is now called É.
\item[Issue 1.15 (2005/02/21)] Added test for fixed handling of relations like {\it\_partition\_}.
\item[Issue 1.16 (2005/05/18)] Added tests for binding and tuple selection.
\item[Issue 1.17 (2005/06/17)] Added more tests for bracket-elimination around function application.
\item[Issue 1.18 (2005/08/03)] Schema projection is now left-associative.
\item[Issue 1.19 (2005/09/10)] Added tests for \$-feature.
\item[Issue 1.20 (2005/09/13)] Added test for new subscripted forms of schema operators.
\item[Issue 1.21 (2006/01/24)] Revised tests for \$-feature.
\item[Issue 1.22 (2006/01/25)] Added test for decorated fancyfix identifiers.
\item[Issue 1.23 (2006/06/12)] Added tests for floating point literals.
\item[Issue 1.23 (2006/06/12)] Added more tests for dollar-quoted identifiers.
\item[Issue 1.24 (2007/08/04)] Allowed for changes to lexical rules for underscores.
\item[Issue 1.25 (2008/02/10)] Tested new feature that optionally puts strings in Quine corners.
\item[Issue 1.26 (2008/07/24)] Allowed for changes to feature that optionally puts strings in Quine corners.
\item[Issue 1.27 (2008/09/05)] Added more tests for IdDec involving combinations of decoration and generics.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

%%%% END OF CHANGES HISTORY %%%%
\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the module tests for the pretty printing
routines for the \ProductZ\ system which are discussed
in~\cite{DS/FMU/IED/DTD064}.  The tests use the module testing system
of~\cite{DS/FMU/IED/DTD013} and~\cite{DS/FMU/IED/IMP013}.
The tests depend on the Z library of \cite{DS/FMU/IED/DTD088} etc.

%********************************************************************


\subsection{Deficiencies}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST CASES}

We provide several groups of tests as follows:

\begin{description}
\item[Group.1] This covers an instance of each form of Z term (as
given in the grammar of \cite{DS/FMU/IED/DEF007}).
\item[Group.2] This checks bracket elimination in several contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus;
(4) around decoration.
\item[Group.3] This checks the handling of the eliding of generic
parameters of the form $É[Totality]$.
\item[Group.4] This checks the elision of characteristic tuples from
set abstractions
\item[Group.5] This checks the handling of generic predicates
\item[Group.6] This checks the handling of declarations
\item[Group.7] Miscellaneous regression tests for various fixes
\end{description}

Results are checked by reparsing where possible,
and, if desired, by visual inspection. Note that not everything prints
exactly as input (e.g. `;' as low priority conjunction prints as ordinary
conjunction).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
docsml dtd013
docsml imp013

docsml mdt064
use_file "mdt064.sml";

=TEX

Load and initialise the module test system.

=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
open_theory"z_library";
new_theory "mdt064_test";
ˇSchema
	x:˙;
	y,z:˙∏˙
˜
	(x, x) = y = z
à
ˇAnotherSchema
	t:˙;
	y,z:˙∏˙
˜
	(t, t) = y = z
à
ˇA
	x:˙
à
ˇB[X]
	x:X
à
ˇC
	x:˙
à
ˇC'
	x:˙
à
ˇD[X]
	x:X
à
ˇD'[X]
	x:X
à
πZ
‹ generic (E _)
∞
ˇE X
	x:X
à
ˇE' X
	x:X
à



=TEX


Functions $ft$ and $uft$ are used to invoke the tests.  The first just
formats the term into a single string, the second formats the term into
a single string, parses it back as a term and formats the result of
that.

=SML
fun ft (x:TERM) : string list = PrettyPrinter.format_term false x;

val uft_aux : TERM ref = ref ¨1Æ;

fun uft (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := Ò" ^ t1 ^ "Æ; !uft_aux)");
in
	!uft_aux
end;
fun uft∫u (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := Ò(" ^ t1 ^ ")∫É Æ; !uft_aux)");
in
	!uft_aux
end;
fun term_of_string (x : string) : TERM = (
let
	val side_effect = use_string
		("(uft_aux := Ò" ^ x ^ "Æ; !uft_aux)");
in
	!uft_aux
end
);

fun chk1 (x : TERM) : bool = (
	x =$ uft x
);
fun chk1∫u (x : TERM) : bool = (
	x =$ uft∫u x
);
fun chk2 (y : string) (x : TERM) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft x)) y
	end
);
fun chk3 (x : string) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft(term_of_string x))) x
	end
);
=TEX
Most tests are run with one or other of the following.
$rp1$ is for cases which will reparse; $rp2$ and $rp3$ for ones which won't. $rp2$ is for cases where casts or
whatever mean that the output is not expected to
be the same as the input; $rp3$ is for cases where
only the input needs to be provided (and is currently not used).
=SML
fun rp1 (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1, t, true))) data
);
fun rp2 (data: (string * TERM * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t, u) => (s, chk2 u, t, true))) data
);
fun rp3 (data: (string * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk3, t, true))) data
);
=TEX
$rp1∫u$ is for cases which will reparse if we force
an expression context:
=SML
fun rp1∫u (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1∫u, t, true))) data
);

=TEX
%********************************************************************

\section{THE TESTS}
\subsection{Group 1}
These follow the grammar of \cite{DS/FMU/IED/DTD061}.
We label the blocks with the non-terminal names.
=TEX
Block 1: Pred \& Pred1
=SML
store_mt_results rp1 [
("064.1.1.1", Òa ; bÆ),
("064.1.1.2", Òµx:Y|R x∑P x ; bÆ),
("064.1.1.3", Òa ; µx:Y|R x∑P xÆ),
("064.1.1.4", Ò∂[x:X]∑x = xÆ),
("064.1.1.5", Ò∂â1[x:X]∑x = xÆ),
("064.1.1.6", Òµ[x,y:X]| y = y∑x = xÆ)
];
=TEX
Block 2: Pred2
=SML
store_mt_results rp1 [
("064.1.2.1", Òa ± bÆ),
("064.1.2.2", Òa ≤ bÆ),
("064.1.2.3", Òa ¥ bÆ),
("064.1.2.4", Òa § bÆ)
];
=TEX
Block 3: Pred3
=SML
store_mt_results rp1 [
("064.1.3.1", Ò≥a ± bÆ)
];
=TEX
Block 4: Schema2
=SML
store_mt_results rp2 [
("064.1.4.1", Ò([x,y:X] ± [y:Y]) ∫ ÉÆ, "[x,y:X] ± [y:Y]"),
("064.1.4.2", Ò([x,y:X] ≤ [y:Y]) ∫ ÉÆ, "[x,y:X] ≤ [y:Y]"),
("064.1.4.3", Ò([x,y:X] § [y:Y]) ∫ ÉÆ, "[x,y:X] § [y:Y]"),
("064.1.4.4", Ò([x,y:X]  ˘âs [y:Y]) ∫ ÉÆ, "[x,y:X]  ˘âs [y:Y]"),
("064.1.4.5", Ò([x,x':X]  ªâs [x,x':X]) ∫ ÉÆ, "[x,x':X]  ªâs [x,x':X]"),
("064.1.4.6", Ò(µx,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "µx,y:X |x = y∑[x,y,z:X]"),
("064.1.4.7", Ò(∂x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "∂x,y:X |x = y∑[x,y,z:X]"),
("064.1.4.8", Ò(∂â1x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "∂â1x,y:X |x = y∑[x,y,z:X]"),
("064.1.4.9", Ò([x,y:X] ±âs [y:Y]) ∫ ÉÆ, "[x,y:X] ± [y:Y]"),
("064.1.4.10", Ò([x,y:X] ≤âs [y:Y]) ∫ ÉÆ, "[x,y:X] ≤ [y:Y]"),
("064.1.4.11", Ò([x,y:X] §âs [y:Y]) ∫ ÉÆ, "[x,y:X] § [y:Y]"),
("064.1.4.12", Ò(µâs x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "µx,y:X |x = y∑[x,y,z:X]"),
("064.1.4.13", Ò(∂âs x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "∂x,y:X |x = y∑[x,y,z:X]"),
("064.1.4.14", Ò(∂â1âs x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "∂â1x,y:X |x = y∑[x,y,z:X]")
];
=TEX
Block 5: Schema3
=SML
store_mt_results rp1 [
("064.1.5.1", Òpre[x,x':X|x Ω x']Æ),
("064.1.5.2", Òò[x:X|x Ω x']Æ),
("064.1.5.3", ÒÑ[x:X|x Ω x']Æ)
];
=TEX
Block 6: Schema4
=SML
store_mt_results rp1 [
("064.1.6.1", Ò[x,y,x':X|x Ω x']\âs(x,y)Æ)
];
=TEX
Block 7: Renames
=SML
store_mt_results rp1 [
("064.1.7.1", Ò[x,y,x':X|x Ω x'][a/x]Æ),
("064.1.7.2", Ò[x,y,x':X|x Ω x'][a/x,b/y]Æ)
];
=TEX
Block 8: Decl
=SML
store_mt_results rp1 [
("064.1.8.1", Ò{[x:X]∑x}Æ),
("064.1.8.2", Ò{a,b,c:ABC; d,e,f:DEF∑x}Æ),
("064.1.8.3", Ò{[x:X];[a,b,c:ABC]∑x}Æ),
("064.1.8.4", Ò{[x:X]; a,b,c:ABC;[x:X]; a,b,c:ABC∑x}Æ)
];
=TEX
Block 9: Expr0
=SML
store_mt_results rp1 [
("064.1.9.1", Ò(Õx:X)Æ),
("064.1.9.2", Ò(Ãx:X∑y)Æ),
("064.1.9.3", Ò(Ãx:X|x = x∑y)Æ),
("064.1.9.4", Ò(Õ[x:X]|x = x∑y)Æ),
("064.1.9.5", Ò(Õ[x:X]|x = x)Æ)
];
=TEX
Block 10: Expr1
=SML
store_mt_results rp1 [
("064.1.10.1", Ò1+2*3Æ),
("064.1.10.2", Ò1+(2*3)Æ),
("064.1.10.3", Ò~1+2Æ),
("064.1.10.4", Ò~(1+2)Æ),
("064.1.10.5", Òf®{1+2}©Æ)
];
=TEX
Block 11: Expr2
=SML
store_mt_results rp1 [
("064.1.11.1", Ò(˙ ∏ ˙)Æ),
("064.1.11.2", Ò ˙ ∏ ˙Æ),
("064.1.11.3", ÒI ¿ B ∏ CÆ),
("064.1.11.4", ÒI ¿ (B ∏ C)Æ),
("064.1.11.5", Òseq X  ∏ YÆ),
("064.1.11.6", Ò(seq X) ∏ YÆ),
("064.1.11.7", ÒX ∏ Y ∏ ZÆ),
("064.1.11.8", Ò(X ∏ Y) ∏ (Z ∏ W)Æ),
("064.1.11.9", Ò(X ∏ Y) ∏ (Z ¿ W)Æ)
];
=TEX
Block 12: Expr3
=SML
store_mt_results rp1 [
("064.1.12.1", Òf aÆ),
("064.1.12.2", Òf a b cÆ),
("064.1.12.3", Ò SchemaÆ),
("064.1.12.4", Ò Schema!Æ),
("064.1.12.5", Ò (Schema!)Æ),
("064.1.12.6", Ò (Schema!)?Æ),
("064.1.12.7", Ò(x¶1,y¶(1,2)).yÆ)
];
=TEX
Block 13: Expr4
=SML
store_mt_results rp1 [
("064.1.13.1", ÒfÆ),
("064.1.13.2", Òx = ¨CombK 1 2ÆÆ),
("064.1.13.3", Ò99Æ),
("064.1.13.4", Ò"a string"Æ),
("064.1.13.5", Ò"(1,2,3,4)"Æ),
("064.1.13.6", Ò"{1,2,3,4}"Æ),
("064.1.13.7", Ò"{}"Æ),
("064.1.13.8", Ò"{1}"Æ),
("064.1.13.9", Ò"ß1,2,3,4¢"Æ),
("064.1.13.10", Ò"{x:X|x=x∑x}"Æ),
("064.1.13.11", Ò"{x:X|x=x}"Æ),
("064.1.13.12", Ò"{x:X∑x}"Æ),
("064.1.13.13", Ò"[x:X|x = x]"Æ),
("064.1.13.14", Ò"[x:X]"Æ),
("064.1.13.15", Ò"([x:X])'!?"Æ),
("064.1.13.16", Ò(Schema '?!) ??'Æ)
];
=TEX
Block 14: IdDec
=SML
store_mt_results rp1 [
("064.1.14.1", ÒfÆ),
("064.1.14.2", Òf'?!??'Æ),
("064.1.14.3", ÒSchema'?!??'Æ),
("064.1.14.4.1", ÒAÆ),
("064.1.14.4.2", ÒA'Æ),
("064.1.14.4.4", Ò(A)'Æ),
("064.1.14.4.3", ÒA 'Æ),
("064.1.14.4.5", Ò(A')'Æ),
("064.1.14.5.1", ÒBÆ),
("064.1.14.5.2", ÒB'Æ),
("064.1.14.5.3", ÒB 'Æ),
("064.1.14.5.4", Ò(B)'Æ),
("064.1.14.5.5", Ò(B')'Æ),
("064.1.14.6.1", ÒB[X]Æ),
("064.1.14.6.2", ÒB'[X]Æ),
("064.1.14.6.3", ÒB '[X]Æ),
("064.1.14.6.4", Ò(B[X])'Æ),
("064.1.14.6.5", Ò(B'[X])'Æ),
("064.1.14.7.1", ÒCÆ),
("064.1.14.7.2", ÒC'Æ),
("064.1.14.7.3", ÒC 'Æ),
("064.1.14.7.4", Ò(C)'Æ),
("064.1.14.7.5", Ò(C')'Æ),
("064.1.14.7.6", ÒC''Æ),
("064.1.14.7.7", ÒC ''Æ),
("064.1.14.7.8", Ò(C)''Æ),
("064.1.14.7.9", Ò(C')''Æ),
("064.1.14.7.10", Ò(C'')'Æ),
("064.1.14.8.1", ÒDÆ),
("064.1.14.8.2", ÒD'Æ),
("064.1.14.8.3", ÒD 'Æ),
("064.1.14.8.4", Ò(D)'Æ),
("064.1.14.8.5", Ò(D')'Æ),
("064.1.14.8.6", ÒD''Æ),
("064.1.14.8.7", ÒD ''Æ),
("064.1.14.8.8", Ò(D)''Æ),
("064.1.14.8.9", Ò(D')''Æ),
("064.1.14.8.10", Ò(D'')'Æ),
("064.1.14.9.1", ÒD[X]Æ),
("064.1.14.9.2", ÒD'[X]Æ),
("064.1.14.9.3", ÒD '[X]Æ),
("064.1.14.9.4", Ò(D[X])'Æ),
("064.1.14.9.5", Ò(D'[X])'Æ),
("064.1.14.9.6", ÒD''[X]Æ),
("064.1.14.9.7", ÒD ''[X]Æ),
("064.1.14.9.8", Ò(D[X])''Æ),
("064.1.14.9.9", Ò(D'[X])''Æ),
("064.1.14.9.10", Ò(D''[X])'Æ),
("064.1.14.10.1", Ò(E _)Æ),
("064.1.14.10.2", Ò(E' _)Æ),
("064.1.14.10.3", Ò(E ' _)Æ),
("064.1.14.10.4", Ò(E _)'Æ),
("064.1.14.10.5", Ò(E' _)'Æ),
("064.1.14.10.6", Ò(E'' _)Æ),
("064.1.14.10.7", Ò(E '' _)Æ),
("064.1.14.10.8", Ò(E _)''Æ),
("064.1.14.10.9", Ò(E' _)''Æ),
("064.1.14.10.10", Ò(E'' _)'Æ),
("064.1.14.11.1", ÒE XÆ),
("064.1.14.11.2", ÒE' XÆ),
("064.1.14.11.3", ÒE ' XÆ),
("064.1.14.11.4", Ò(E X)'Æ),
("064.1.14.11.5", Ò(E' X)'Æ),
("064.1.14.11.6", ÒE'' XÆ),
("064.1.14.11.7", ÒE '' XÆ),
("064.1.14.11.8", Ò(E X)''Æ),
("064.1.14.11.9", Ò(E' X)''Æ),
("064.1.14.11.10", Ò(E'' X)'Æ)
];
=TEX
Block 15: \$-feature:
=SML
store_mt_results rp1 [
("064.1.15.1", Ò$"abc def"Æ),
("064.1.15.2", Ò$"_*_"Æ),
("064.1.15.3", Ò$"_ * _"Æ),
("064.1.15.4", Ò$"aa##"Æ),
("064.1.15.5", Ò$"_ *' _"Æ),
("064.1.15.6", Ò$""Æ),
("064.1.15.7", Ò$"\\\""Æ),
("064.1.15.8", Ò$"x\\ \"42\\"Æ)
];
=TEX
Block 15: strings:
=SML
val t1 = string_of_term Ò"abc def"Æ;
store_mt_results rp1 [
("064.1.16.1", Ò"abc def"Æ)
];
set_flag("pp_quote_z_strings", true);
val t2 = string_of_term Ò"\"abc def"Æ;
store_mt_results rp1 [
("064.1.16.2", Ò"abc def"Æ)
];
reset_flag("pp_quote_z_strings");
store_mt_results mt_run [
("064.1.16.3", (implode o curry (op to) (explode t1)), 1, "Ò\""),
("064.1.16.4", (implode o curry (op to) (explode t2)), 2, "ÒÒ\"")
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Group 2}
 This checks bracket elimination in several contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus;
(4) around decoration; (5) equality and membership;
(6) binding and tuple selection;
(7) function application.

In many cases, we just check that things which should reparse do,
leaving the check that there aren't too many brackets to
be done visually.
=TEX
Block 1: bracket elimination for fancy-fix
=SML
store_mt_results rp2 [
("064.2.1.1", Ò1+2*3Æ, "1+2*3"),
("064.2.1.2", Ò1+(2*3)Æ, "1+2*3"),
("064.2.1.3", Ò~1+2Æ, "~1+2"),
("064.2.1.4", Ò~(1+2)Æ, "~(1+2)"),
("064.2.1.5", Òf®{1+2}© ° A ¿ B \ CÆ, "f®{1+2}© ° A ¿ B \\ C"),
("064.2.1.6", Ò(1+2)+3Æ, "1+2+3"),
("064.2.1.7", Ò1+2+3Æ, "1+2+3"),
("064.2.1.8", Ò1+(2+3)Æ, "1+(2+3)")
];
=TEX
Block 2: bracket elimination for schema calculus
=SML
store_mt_results rp2 [
("064.2.2.1", Ò([x,x':X] ªâs [x,x':X] ± Schema)∫ÉÆ,
	"[x,x':X] ªâs [x,x':X] ± Schema"),
("064.2.2.2", Ò(Schema ˘âs [x,x':X] ªâs Schema)∫ÉÆ,
	"Schema ˘âs [x,x':X] ªâs Schema"),
("064.2.2.3", Ò(Schema ≤ Schema § Schema)∫ÉÆ,
	"Schema ≤ Schema § Schema"),
("064.2.2.4", Ò(Schema ≤ Schema ± Schema)∫ÉÆ,
	"Schema ≤ Schema ± Schema"),
("064.2.2.5", Ò(≥Schema ≤ Schema ± Schema)∫ÉÆ,
	"≥Schema ≤ Schema ± Schema"),
("064.2.2.6", Ò(≥Schema ¥ Schema ± Schema)∫ÉÆ,
	"≥Schema ¥ Schema ± Schema"),
("064.2.2.7", Ò(([x,x':X] ªâs [x,x':X]) ± Schema)∫ÉÆ,
	"([x,x':X] ªâs [x,x':X]) ± Schema"),
("064.2.2.8", Ò(Schema' ˘âs ([x,x':X] ªâs Schema))∫ÉÆ,
	"(Schema') ˘âs ([x,x':X] ªâs Schema)"),
("064.2.2.9", Ò(Schema ≤ (Schema § Schema))∫ÉÆ,
	"Schema ≤ (Schema § Schema)"),
("064.2.2.10", Ò((Schema ≤ Schema) ± Schema)∫ÉÆ,
	"(Schema ≤ Schema) ± Schema"),
("064.2.2.11", Ò(≥(Schema ≤ Schema) ± Schema)∫ÉÆ,
	"≥(Schema ≤ Schema) ± Schema"),
("064.2.2.12", Ò(≥(Schema ¥ Schema) ± Schema)∫ÉÆ,
	"≥(Schema ¥ Schema) ± Schema"),
("064.2.2.13", Ò(Schema ˘âs [x, x':˙] ˘âs Schema)∫ÉÆ,
	"Schema ˘âs [x, x' : ˙] ˘âs Schema"),
("064.2.2.14", ÒSchema ˘âs ([x, x' : ˙] ˘âs [a:˙])∫ÉÆ,
	"Schema ˘âs ([x, x' : ˙] ˘âs [a:˙])")
];
=TEX
Not all the $∫É$s above are strictly necessary.
=TEX
Block 3: bracket elimination for propositional calculus (part 1)
=SML
store_mt_results rp2 [
("064.2.3.1.1", ÒA ± B ± CÆ, "A ± B ± C"),
("064.2.3.1.2", ÒA ± B ≤ CÆ, "A ± B ≤ C"),
("064.2.3.1.3", ÒA ± B ¥ CÆ, "A ± B ¥ C"),
("064.2.3.1.4", ÒA ± B § CÆ, "A ± B § C"),
("064.2.3.1.5", ÒA ≤ B ± CÆ, "A ≤ B ± C"),
("064.2.3.1.6", ÒA ≤ B ≤ CÆ, "A ≤ B ≤ C"),
("064.2.3.1.7", ÒA ≤ B ¥ CÆ, "A ≤ B ¥ C"),
("064.2.3.1.8", ÒA ≤ B § CÆ, "A ≤ B § C"),
("064.2.3.1.9", ÒA ¥ B ± CÆ, "A ¥ B ± C"),
("064.2.3.1.10", ÒA ¥ B ≤ CÆ, "A ¥ B ≤ C"),
("064.2.3.1.11", ÒA ¥ B ¥ CÆ, "A ¥ B ¥ C"),
("064.2.3.1.12", ÒA ¥ B § CÆ, "A ¥ B § C"),
("064.2.3.1.13", ÒA § B ± CÆ, "A § B ± C"),
("064.2.3.1.14", ÒA § B ≤ CÆ, "A § B ≤ C"),
("064.2.3.1.15", ÒA § B ¥ CÆ, "A § B ¥ C"),
("064.2.3.1.16", ÒA § B § CÆ, "A § B § C")
];
=TEX
Block 3: bracket elimination for propositional calculus (part 2)
=SML
store_mt_results rp2 [
("064.2.3.2.1", Ò(A ± B) ± CÆ, "(A ± B) ± C"),
("064.2.3.2.2", ÒA ± (B ≤ C)Æ, "A ± (B ≤ C)"),
("064.2.3.2.3", ÒA ± (B ¥ C)Æ, "A ± (B ¥ C)"),
("064.2.3.2.4", ÒA ± (B § C)Æ, "A ± (B § C)"),
("064.2.3.2.5", Ò(A ≤ B) ± CÆ, "(A ≤ B) ± C"),
("064.2.3.2.6", Ò(A ≤ B) ≤ CÆ, "(A ≤ B) ≤ C"),
("064.2.3.2.7", ÒA ≤ (B ¥ C)Æ, "A ≤ (B ¥ C)"),
("064.2.3.2.8", ÒA ≤ (B § C)Æ, "A ≤ (B § C)"),
("064.2.3.2.9", Ò(A ¥ B) ± CÆ, "(A ¥ B) ± C"),
("064.2.3.2.10", Ò(A ¥ B) ≤ CÆ, "(A ¥ B) ≤ C"),
("064.2.3.2.11", Ò(A ¥ B) ¥ CÆ, "(A ¥ B) ¥ C"),
("064.2.3.2.12", Ò(A ¥ B) § CÆ, "A ¥ B § C"),
("064.2.3.2.13", ÒA § (B ± C)Æ, "A § B ± C"),
("064.2.3.2.14", ÒA § (B ≤ C)Æ, "A § B ≤ C"),
("064.2.3.2.15", ÒA § (B ¥ C)Æ, "A § B ¥ C"),
("064.2.3.2.16", ÒA § (B § C)Æ, "A § B § C")
];
=TEX
Block 4: bracket elimination around decoration
=SML
store_mt_results rp2 [
("064.2.4.1.1", Ò∂(B[X])'∑trueÆ, "∂(B[X])'∑true"),
("064.2.4.1.2", Ò∂(A')∑trueÆ, "∂(A')∑true"),
("064.2.4.1.3", Ò∂A; (A?)'; ((B[X])'')?∑trueÆ, "∂A; (A?)'; ((B[X])'')?∑true")
];
=TEX
Block 5: bracket elimination around equality and membership
=SML
store_mt_results rp2 [
("064.2.5.1.1", Ò[A] (x = (Ãa:A∑true))Æ, "[A] (x = (Ãa:A∑true))"),
("064.2.5.1.2", Ò[A] (x ç (Ãa:A∑true))Æ, "[A] (x ç (Ãa:A∑true))"),
("064.2.5.1.3", Ò[A] ((Ãa:A∑true) = F)Æ, "[A] ((Ãa:A∑true) = F)"),
("064.2.5.1.4", Ò[A] ((Ãa:A∑true) ç F)Æ, "[A] ((Ãa:A∑true) ç F)"),
("064.2.5.1.5", Ò[A] ((x = A) ç F)Æ, "[A] ((x = A) ç F)"),
("064.2.5.1.6", Ò[A] ((x ç A) ç F)Æ, "[A] ((x ç A) ç F)"),
("064.2.5.1.7", Ò[A] (x ç A ç F)Æ, "[A] (x ç A ± A ç F)"),
("064.2.5.1.8", Ò[A] (x ç A = F)Æ, "[A] (x ç A ± A = F)"),
("064.2.5.1.9", Ò[A] (x = A ç F)Æ, "[A] (x = A ± A ç F)"),
("064.2.5.1.10", Ò[A] (x = A = F)Æ, "[A] (x = A ± A = F)")
];
=TEX
Block 6: bracket elimination around binding and tuple selection
=SML
store_mt_results rp2 [
("064.2.6.1.1",  Òµ t : [a, b :[x, y:˙]]∑ t.a.x = t.b.y ≤ f(t.a.x + t.b.y)Æ,
	"µ t : [a, b :[x, y:˙]]∑ t.a.x = t.b.y ≤ f(t.a.x + t.b.y)"),
("064.2.6.1.2",  Òµ t : [a, b :[x, y:˙]]∑ 2 + t.a.x = t.b.y + 1 ≤ f(t.a.x + t.b.y)Æ,
	"µ t : [a, b :[x, y:˙]]∑ 2 + t.a.x = t.b.y + 1 ≤ f(t.a.x + t.b.y)"),
("064.2.6.1.3",  Òµ t : (˙ ∏ ˙) ∏ (˙ ∏ ˙)∑ t.1.2 = t.2.1 ≤ f(t.1.1 + t.2.2)Æ,
	"µ t : (˙ ∏ ˙) ∏ (˙ ∏ ˙)∑ t.1.2 = t.2.1 ≤ f(t.1.1 + t.2.2)"),
("064.2.6.1.4",  Òµ t : (˙ ∏ ˙) ∏ (˙ ∏ ˙)∑ 2 + t.1.2 = t.2.1 + 1 ≤ f(t.1.1 + t.2.2)
Æ,
	"µ t : (˙ ∏ ˙) ∏ (˙ ∏ ˙)∑ 2 + t.1.2 = t.2.1 + 1 ≤ f(t.1.1 + t.2.2)")
];
=TEX
Block 7: bracket elimination around function application
=SML
store_mt_results rp2 [
("064.2.7.1.1",  Òf a bÆ,
	"f a b"),
("064.2.7.1.2",  Òf (¡ a) (¬ b)Æ,
	"f (¡ a) (¬ b)"),
("064.2.7.1.3",  Òf ( A) xÆ,
	"f ( A) x"),
("064.2.7.1.4",  Ò ((Ãx:˙∑A) 1)Æ,
	" ((Ãx:˙∑A) 1)"),
("064.2.7.1.5",  Òf( ((Ãx:˙∑A) 1)) xÆ,
	"f( ((Ãx:˙∑A) 1)) x")
];
=TEX
\subsection{Group 3}
Elision of $É[Totality]$.
=SML
store_mt_results rp2 [
("064.3.1", ÒÉÆ, "É"),
("064.3.2", ÒÉ[˙]Æ, "É[˙]")
];
=TEX
\subsection{Group 4}
Elision of characteristic tuple.
=SML
store_mt_results rp1 [
("064.4.1", Ò{x:X}Æ),
("064.4.2", Ò{x,y:X|x = y}Æ),
("064.4.3", Ò{Schema|z = y}Æ)
];
=TEX
\subsection{Group 5}
Generic predicates.
=SML
store_mt_results rp1 [
("064.5.1", Ò[X](x ç X)Æ),
("064.5.2", Ò[Z]z ç Z ≤ y ç YÆ),
("064.5.3", Ò[X, Y, Z](x ç X ± z ç Z ± Ò[Z]z ç Z ≤ y ç YÆ)Æ),
("064.5.4", Ò[X, Y](x ç X ± ¨µy∑x = yÆ)Æ)
];
=TEX
\subsection{Group 6}
Declarations.
=SML
store_mt_results rp1 [
("064.6.1", fst(dest_z_h_schema Ò[x,y,z:˙]Æ)),
("064.6.2", fst(dest_z_h_schema Ò[Schema]Æ)),
("064.6.3", hd(dest_z_decl(fst(dest_z_h_schema Ò[x,y,z:˙]Æ)))),
("064.6.4", hd(dest_z_decl(fst(dest_z_h_schema Ò[Schema]Æ)))),
("064.6.5", mk_z_dec([Ò(x ¶ 1, x' ¶ 2, z ¶ 3).zÆ],Ò˙Æ))
];
=TEX
\subsection{Group 7}
Regression tests for bug fixes.
=SML
store_mt_results rp1 [
("064.7.1", Ò¨Z'Dec ([z'x'], XX)ÆÆ)	,	(* HAT 97 *)
("064.7.2", Ò{[x : É] | true}Æ),		(* HAT 64 *)
("064.7.3", Ò{[x : É]}Æ),		(* HAT 64 *)
("064.7.4", Ò{A | true}Æ),		(* HAT 64 *)
("064.7.5", Ò{A}Æ),			(* HAT 64 *)
("064.7.6", Ò{[x : É] ∑ (x,x)}Æ),	(* HAT 64 *)
("064.7.7", Ò{A ∑ (x,x)}Æ)		(* HAT 64 *)
];
=TEX
=SML
store_mt_results rp1 [
("064.7.8", Ò(_ partition _)[˙, ˙ ∏ ˙]Æ)
];
=TEX
Associativity of schema calculus operations:
ˇ AA ¸¸¸¸¸¸¸¸¸¸¸
‹ a, ab, ac, abc : ˙
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ BB ¸¸¸¸¸¸¸¸¸¸¸
‹ b, ab, bc, abc : ˙
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ CC ¸¸¸¸¸¸¸¸¸¸¸
‹ c, ac, bc, abc : ˙
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
store_mt_results rp1 [
("064.7.9", ÒAA ± (BB ± CC)Æ),
("064.7.10", ÒAA ≤ (BB ≤ CC)Æ),
("064.7.11", Ò(AA ± BB) ± CCÆ),
("064.7.12", Ò(AA ≤ BB) ≤ CCÆ),
("064.7.13", ÒAA ˘âs (BB ˘âs CC)Æ),
("064.7.14", Ò(AA ˘âs BB) ˘âs CCÆ)
];
=TEX
=SML
set_flag("subscript_z_schema_ops", true);
store_mt_results rp2 [
("064.7.15", Ò([x,y:X] ±âs [y:Y]) ∫ ÉÆ, "[x,y:X] ±âs [y:Y]"),
("064.7.16", Ò([x,y:X] ≤âs [y:Y]) ∫ ÉÆ, "[x,y:X] ≤âs [y:Y]"),
("064.7.17", Ò([x,y:X] §âs [y:Y]) ∫ ÉÆ, "[x,y:X] §âs [y:Y]"),
("064.7.18", Ò(µâs x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "µâs x,y:X |x = y∑[x,y,z:X]"),
("064.7.19", Ò(∂âs x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "∂âs x,y:X |x = y∑[x,y,z:X]"),
("064.7.20", Ò(∂â1âs x,y:X |x = y∑[x,y,z:X]) ∫ ÉÆ, "∂â1âs x,y:X |x = y∑[x,y,z:X]")
];
set_flag("subscript_z_schema_ops", false);
=SML
store_mt_results rp1 [
("064.7.21", Ò1.2Æ),
("064.7.22", Ò1.2e3Æ),
("064.7.23", Ò1.2e~3Æ)
];
=TEX
\section{SUMMARY OF RESULTS}

=SML
val _ = set_line_length 80;
val _ = diag_line "Summary Of Results";
val _ = diag_string(summarize_mt_results());
=TEX

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------
