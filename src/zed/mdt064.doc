% mdt064.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% mdt064.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Module Tests for Pretty Printer}
\TPPref{DS/FMU/IED/MDT064}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

docsml mdt064
use_file "mdt064.sml";

make -f rel001.mkf mdt064.dvi
doctex mdt064
texdvi mdt064
bibtex mdt064
doctex mdt064 ; texdvi mdt064
doctex mdt064 ; texdvi mdt064 ; bibtex mdt064
dvipage mdt064 &

docsml mdt064
use_file "mdt064.sml";

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document contains the module tests for the \ProductZ\
	Pretty Printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}


\item[Issue \SCCSissue, \FormatDate{$Date$%
} ]
	First draft. 

\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the module tests for the pretty printing
routines for the \ProductZ\ system which are discussed
in~\cite{DS/FMU/IED/DTD064}.  The tests use the module testing system
of~\cite{DS/FMU/IED/DTD013} and~\cite{DS/FMU/IED/IMP013}.
The tests depend on the Z library of \cite{DS/FMU/IED/DTD088} etc.

%********************************************************************


\subsection{Deficiencies}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST CASES}

We provide several groups of tests as follows:

\begin{description}
\item[Group.1] This covers an instance of each form of Z term (as
given in the grammar of \cite{DS/FMU/IED/DEF007}).
\item[Group.2] This checks bracket elimination in several contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus;
(4) around decoration.
\item[Group.3] This checks the handling of the eliding of generic
parameters of the form $U[Totality]$.
\item[Group.4] This checks the elision of characteristic tuples from
set abstractions
\end{description}

Results are checked by reparsing where possible,
and, if desired, by visual inspection. Note that not everything prints
exactly as input (e.g. `;' as low priority conjunction prints as ordinary
conjunction).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
docsml dtd013
docsml imp013

docsml mdt064
use_file "mdt064.sml";

=TEX

Load and initialise the module test system.

=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
open_theory"z_bags";
new_theory "mdt064_test";
ÿSchema
	x:ú;
	y,z:ú¸ú
÷
	(x, x) = y = z
ˆ
ÿAnotherSchema
	t:ú;
	y,z:ú¸ú
÷
	(t, t) = y = z
ˆ
ÿA
	x:ú
ˆ
ÿB[X]
	x:X
ˆ


=TEX


Functions $ft$ and $uft$ are used to invoke the tests.  The first just
formats the term into a single string, the second formats the term into
a single string, parses it back as a term and formats the result of
that.

=SML
fun ft (x:TERM) : string list = PrettyPrinter.format_term false x;

val uft_aux : TERM ref = ref ¬1®;

fun uft (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := ñ" ^ t1 ^ "®; !uft_aux)");
in
	!uft_aux
end;
fun uftºu (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = use_string
		("(uft_aux := ñ(" ^ t1 ^ ")ºU ®; !uft_aux)");
in
	!uft_aux
end;
fun term_of_string (x : string) : TERM = (
let
	val side_effect = use_string
		("(uft_aux := ñ" ^ x ^ "®; !uft_aux)");
in
	!uft_aux
end
);

fun chk1 (x : TERM) : bool = (
	x =$ uft x
);
fun chk1ºu (x : TERM) : bool = (
	x =$ uftºu x
);
fun chk2 (y : string) (x : TERM) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft x)) y
	end
);
fun chk3 (x : string) : bool = (
	let	fun is_sp "\n" = true
		|   is_sp " " = true
		|   is_sp _ = false;
		fun cmp s1 s2 = (explode s1 drop is_sp) = (explode s2 drop is_sp);
	in	cmp (implode (ft(term_of_string x))) x
	end
);
=TEX
Most tests are run with one or other of the following.
$rp1$ is for cases which will reparse; $rp2$ and $rp3$ for ones which won't. $rp2$ is for cases where casts or
whatever mean that the output is not expected to
be the same as the input; $rp3$ is for cases where
only the input needs to be provided.
=SML
fun rp1 (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1, t, true))) data
);
fun rp2 (data: (string * TERM * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t, u) => (s, chk2 u, t, true))) data
);
fun rp3 (data: (string * string) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk3, t, true))) data
);
=TEX
$rp1ºu$ is for cases which will reparse if we force
an expression context:
=SML
fun rp1ºu (data: (string * TERM) list) : (string * bool) list = (
	(mt_run o map (fn (s, t) => (s, chk1ºu, t, true))) data
);

=TEX
%********************************************************************

\section{THE TESTS}
\subsection{Group 1}
These follow the grammar of \cite{DS/FMU/IED/DTD061}.
We label the blocks with the non-terminal names.
=TEX
Block 1: Pred \& Pred1
=SML
store_mt_results rp1 [
("064.1.1.1", ña ; b®),
("064.1.1.2", ñµx:Y|R x·P x ; b®),
("064.1.1.3", ña ; µx:Y|R x·P x®),
("064.1.1.4", ñ¶[x:X]·x = x®),
("064.1.1.5", ñ¶‰1[x:X]·x = x®),
("064.1.1.6", ñµ[x,y:X]| y = y·x = x®)
];
=TEX
Block 2: Pred2
=SML
store_mt_results rp1 [
("064.1.2.1", ña ± b®),
("064.1.2.2", ña ² b®),
("064.1.2.3", ña ´ b®),
("064.1.2.4", ña ¤ b®)
];
=TEX
Block 3: Pred3
=SML
store_mt_results rp1 [
("064.1.3.1", ñ³a ± b®)
];
=TEX
Block 4: Schema2
=SML
store_mt_results rp2 [
("064.1.4.1", ñ([x,y:X] ± [y:Y]) º U®, "[x,y:X] ± [y:Y]"),
("064.1.4.2", ñ([x,y:X] ² [y:Y]) º U®, "[x,y:X] ² [y:Y]"),
("064.1.4.3", ñ([x,y:X] ¤ [y:Y]) º U®, "[x,y:X] ¤ [y:Y]"),
("064.1.4.4", ñ([x,y:X]  ù‰s [y:Y]) º U®, "[x,y:X]  ù‰s [y:Y]"),
("064.1.4.5", ñ([x,x':X]  »‰s [x,x':X]) º U®, "[x,x':X]  »‰s [x,x':X]"),
("064.1.4.6", ñ(µx,y:X |x = y·[x,y,z:X]) º U®, "µx,y:X |x = y·[x,y,z:X]"),
("064.1.4.7", ñ(¶x,y:X |x = y·[x,y,z:X]) º U®, "¶x,y:X |x = y·[x,y,z:X]"),
("064.1.4.8", ñ(¶‰1x,y:X |x = y·[x,y,z:X]) º U®, "¶‰1x,y:X |x = y·[x,y,z:X]")
];
=TEX
Block 5: Schema3
=SML
store_mt_results rp1 [
("064.1.5.1", ñpre[x,x':X|x ½ x']®),
("064.1.5.2", ñ˜[x:X|x ½ x']®),
("064.1.5.3", ñ„[x:X|x ½ x']®)
];
=TEX
Block 6: Schema4
=SML
store_mt_results rp1 [
("064.1.6.1", ñ[x,y,x':X|x ½ x']\‰s(x,y)®)
];
=TEX
Block 7: Renames
=SML
store_mt_results rp1 [
("064.1.7.1", ñ[x,y,x':X|x ½ x'][a/x]®),
("064.1.7.2", ñ[x,y,x':X|x ½ x'][a/x,b/y]®)
];
=TEX
Block 8: Decl
=SML
store_mt_results rp1 [
("064.1.8.1", ñ{[x:X]·x}®),
("064.1.8.2", ñ{a,b,c:ABC; d,e,f:DEF·x}®),
("064.1.8.3", ñ{[x:X];[a,b,c:ABC]·x}®),
("064.1.8.4", ñ{[x:X]; a,b,c:ABC;[x:X]; a,b,c:ABC·x}®)
];
=TEX
Block 9: Expr0
=SML
store_mt_results rp1 [
("064.1.9.1", ñ(Íx:X)®),
("064.1.9.2", ñ(Ìx:X·y)®),
("064.1.9.3", ñ(Ìx:X|x = x·y)®),
("064.1.9.4", ñ(Í[x:X]|x = x·y)®)
];
=TEX
Block 10: Expr1
=SML
store_mt_results rp1 [
("064.1.10.1", ñ1+2*3®),
("064.1.10.2", ñ1+(2*3)®),
("064.1.10.3", ñ~1+2®),
("064.1.10.4", ñ~(1+2)®),
("064.1.10.5", ñf¨{1+2}©®)
];
=TEX
Block 11: Expr2
=SML
store_mt_results rp1 [
("064.1.11.1", ñð(ú ¸ ú)®),
("064.1.11.2", ñð ú ¸ ú®)
];
=TEX
Block 12: Expr3
=SML
store_mt_results rp1 [
("064.1.12.1", ñf a®),
("064.1.12.2", ñf a b c®),
("064.1.12.3", ñÊSchema®),
("064.1.12.4", ñÊSchema!®),
("064.1.12.5", ñÊ(Schema!)®),
("064.1.12.6", ñÊ(Schema!)?®),
("064.1.12.7", ñ(x¦1,y¦(1,2)).y®)
];
=TEX
Block 13: Expr4
=SML
store_mt_results rp1 [
("064.1.13.1", ñf®),
("064.1.13.2", ñx = ¬CombK 1 2®®),
("064.1.13.3", ñ99®),
("064.1.13.4", ñ"a string"®),
("064.1.13.5", ñ"(1,2,3,4)"®),
("064.1.13.6", ñ"{1,2,3,4}"®),
("064.1.13.7", ñ"{}"®),
("064.1.13.8", ñ"{1}"®),
("064.1.13.9", ñ"§1,2,3,4¢"®),
("064.1.13.10", ñ"{x:X|x=x·x}"®),
("064.1.13.11", ñ"{x:X|x=x}"®),
("064.1.13.12", ñ"{x:X·x}"®),
("064.1.13.13", ñ"[x:X|x = x]"®),
("064.1.13.14", ñ"[x:X]"®),
("064.1.13.15", ñ"([x:X])'!?"®),
("064.1.13.16", ñ(Schema '?!) ??'®)
];
=TEX
Block 14: IdDec
=SML
store_mt_results rp1 [
("064.1.14.1", ñf®),
("064.1.14.2", ñf'?!??'®),
("064.1.14.3", ñSchema'?!??'®)
];
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Group 2}
 This checks bracket elimination in three contexts: (1)
fancy-fix terms; (2) schema calculus; (3) propositional calculus. We simply check that things which should reparse do,
leaving the check that there aren't too many brackets to
be done visually.
=TEX
Block 1: bracket elimination for fancy-fix
=SML
store_mt_results rp1 [
("064.2.1.1", ñ1+2*3®),
("064.2.1.2", ñ1+(2*3)®),
("064.2.1.3", ñ~1+2®),
("064.2.1.4", ñ~(1+2)®),
("064.2.1.5", ñf¨{1+2}© ¡ A À B \ C®),
("064.2.1.6", ñ(1+2)+3®),
("064.2.1.7", ñ1+2+3®)
];
=TEX
Block 2: bracket elimination for schema calculus
=SML
store_mt_results rp1ºu [
("064.2.2.1", ñ([x,x':X] »‰s [x,x':X] ± Schema)ºU®),
("064.2.2.2", ñ(Schema ù‰s [x,x':X] »‰s Schema)ºU®),
("064.2.2.3", ñ(Schema ² Schema ¤ Schema)ºU®),
("064.2.2.4", ñ(Schema ² Schema ± Schema)ºU®),
("064.2.2.5", ñ(³Schema ² Schema ± Schema)ºU®),
("064.2.2.6", ñ(³Schema ´ Schema ± Schema)ºU®),
("064.2.2.7", ñ(([x,x':X] »‰s [x,x':X]) ± Schema)ºU®),
("064.2.2.8", ñ(Schema' ù‰s ([x,x':X] »‰s Schema))ºU®),
("064.2.2.9", ñ(Schema ² (Schema ¤ Schema))ºU®),
("064.2.2.10", ñ((Schema ² Schema) ± Schema)ºU®),
("064.2.2.11", ñ(³(Schema ² Schema) ± Schema)ºU®),
("064.2.2.12", ñ(³(Schema ´ Schema) ± Schema)ºU®)
];
=TEX
Not all the $ºU$s above are strictly necessary.
=TEX
Block 3: bracket elimination for propositional calculus (part 1)
=SML
store_mt_results rp1 [
("064.2.3.1.1", ñA ± B ± C®),
("064.2.3.1.2", ñA ± B ² C®),
("064.2.3.1.3", ñA ± B ´ C®),
("064.2.3.1.4", ñA ± B ¤ C®),
("064.2.3.1.5", ñA ² B ± C®),
("064.2.3.1.6", ñA ² B ² C®),
("064.2.3.1.7", ñA ² B ´ C®),
("064.2.3.1.8", ñA ² B ¤ C®),
("064.2.3.1.9", ñA ´ B ± C®),
("064.2.3.1.10", ñA ´ B ² C®),
("064.2.3.1.11", ñA ´ B ´ C®),
("064.2.3.1.12", ñA ´ B ¤ C®),
("064.2.3.1.13", ñA ¤ B ± C®),
("064.2.3.1.14", ñA ¤ B ² C®),
("064.2.3.1.15", ñA ¤ B ´ C®),
("064.2.3.1.16", ñA ¤ B ¤ C®)
];
=TEX
Block 3: bracket elimination for propositional calculus (part 2)
=SML
store_mt_results rp1 [
("064.2.3.2.1", ñ(A ± B) ± C®),
("064.2.3.2.2", ñA ± (B ² C)®),
("064.2.3.2.3", ñA ± (B ´ C)®),
("064.2.3.2.4", ñA ± (B ¤ C)®),
("064.2.3.2.5", ñ(A ² B) ± C®),
("064.2.3.2.6", ñ(A ² B) ² C®),
("064.2.3.2.7", ñA ² (B ´ C)®),
("064.2.3.2.8", ñA ² (B ¤ C)®),
("064.2.3.2.9", ñ(A ´ B) ± C®),
("064.2.3.2.10", ñ(A ´ B) ² C®),
("064.2.3.2.11", ñ(A ´ B) ´ C®),
("064.2.3.2.12", ñ(A ´ B) ¤ C®),
("064.2.3.2.13", ñA ¤ (B ± C)®),
("064.2.3.2.14", ñA ¤ (B ² C)®),
("064.2.3.2.15", ñA ¤ (B ´ C)®),
("064.2.3.2.16", ñA ¤ (B ¤ C)®)
];
=TEX
Block 4: bracket elimination around decoration
=SML
store_mt_results rp1 [
("064.2.4.2.1", ñ¶(B[X])'·true®),
("064.2.4.2.2", ñ¶(A')·true®),
("064.2.4.2.3", ñ¶A; (A?)'; ((B[X])'')?·true®)
];
=TEX
\subsection{Group 3}
Elision of $U[Totality]$.
=SML
store_mt_results rp2 [
("064.3.1", ñU®, "U"),
("064.3.2", ñU[ú]®, "U[ú]")
];
=TEX
\subsection{Group 4}
Elision of characteristic tuple.
=SML
store_mt_results rp1 [
("064.4.1", ñ{x:X}®),
("064.4.2", ñ{x,y:X|x = y}®),
("064.4.3", ñ{Schema|z = y}®)
];
=TEX
\section{SUMMARY OF RESULTS}

=SML
"Summary Of Results";

set_line_length 80;

diag_string(summarize_mt_results());
=TEX

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------
 rp1 [
("064.1.9.1", ñ(Íx:X)®),
("064.1.9.2", ñ(Ìx:X·y)®),
("064.1.9.2", ñ(Ìx:X|x = x·y)®)
];
