=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Support for Z Types and Terms}
\TPPref{DS/FMU/IED/DTD048}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document provides a detailed design for a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/DTD047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the corresponding implementation document is \cite{DS/FMU/IED/IMP048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{?} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intercepted and reported as helpfully as possible.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{SIGNATURE}
=DOC
signature âZAbstractMachineSupportá = sig
=DESCRIBE
The Z Abstract Machine support functions are packaged into this signature.
=ENDDOC
\section{TYPE CONSTRUCTORS}
\subsection{Binding Types}
=DOC
val âbind_typeá : (string * TYPE) list -> TYPE; 
=DESCRIBE
=ENDDOC

\subsection{Tuple Types}
=DOC
val âtuple_typeá : TYPE list -> TYPE; 
=DESCRIBE
=ENDDOC

\section{TERM CONSTRUCTORS}
\subsection{Binding Constructors}
=DOC
val âbind_ctermá : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Binding Projections}
=DOC
val âbind_ptermá : (string * TYPE) list -> string -> TYPE;
=DESCRIBE
=ENDDOC

\subsection{Tuples}  
=DOC
val âtuple_ctermá : TYPE list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Cartesian Products}
=DOC
val âprod_ctermá : TYPE list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Negation}
=DOC
val âbind_neg_termá : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Precondition}
=DOC
val âbind_pre_termá : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Dyadic Operations}
=DOC
val âbind_dysc_termá : string -> (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âbind_conj_termá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âbind_disj_termá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âbind_imp_termá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âbind_iff_termá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Projection}
=DOC
val âbind_pro_termá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Hiding}
=DOC
val âbind_hide_termá : (string * TYPE) list -> string list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Decoration}
=DOC
val âbind_decor_termá : (string * TYPE) list -> string -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Delta}
=DOC
val âbind_delta_termá : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Xi}
=DOC
val âbind_xi_termá : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Composition}
=DOC
val âbind_scomp_termá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Construction}
=DOC
val âschema_btermá : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Existential Quantification}
=DOC
val âschexi_btermá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Unique Existential Quantification}
=DOC
val âschunexi_btermá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Schema Universal Quantification}
=DOC
val âschuni_btermá : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Existential Quantification}
=DOC
val âpredexi_btermá : (IDENT * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Unique Existential Quantification}
=DOC
val âpredunexi_btermá : (IDENT * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Universal Quantification}
=DOC
val âpreduni_btermá : (IDENT * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Set Comprehension}
=DOC
val âtermseta_btermá : (IDENT * TYPE) list -> TYPE -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Lambda Abstraction}
=DOC
val âtermlam_btermá : (IDENT * TYPE) list -> TYPE -> TYPE -> TERM;
=DESCRIBE
=ENDDOC

\subsection{Definite Description}
=DOC
val âtermmu_btermá : (IDENT * TYPE) list -> TYPE -> TERM;
=DESCRIBE
=ENDDOC

\section{PACKAGES}
=DOC
val âg1_bind_typeá : TYPE;
=DESCRIBE
=ENDDOC

=DOC
val âg1_bind_ctermá : TERM;
=DESCRIBE
=ENDDOC

=DOC
val âg2_bind_typeá : TYPE -> TYPE;
=DESCRIBE
=ENDDOC

=DOC
val âg2_bind_ctermá : TYPE -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âg3_bind_typeá : TYPE -> TYPE -> TYPE;
=DESCRIBE
=ENDDOC

=DOC
val âg3_bind_ctermá : TYPE -> TYPE -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âg1_absá : TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âg2_absá : TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

=DOC
val âg3_absá : TERM * TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\section{END OF SIGNATURE}
=SML
end (* end of ZAbstractMachineSupport signature *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
