=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Support for Z Types and Terms}
\TPPref{DS/FMU/IED/DTD048}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1 to 1.12]
First draft versions.
\item [Issue 1.13 (July 16th 1992)]
Added support for schema renaming.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides a detailed design for a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/DTD047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the corresponding implementation document is \cite{DS/FMU/IED/IMP048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{?} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intercepted and reported as helpfully as possible.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{SIGNATURE}
=DOC
signature €icl'ZTypesAndTerms› = sig
=DESCRIBE
The Z Abstract Machine support functions are packaged into this signature.
=ENDDOC
\section{THE ABSTRACT SYNTAX OF HOL TYPES AND TERMS} \label{TYPESANDZ_TERMS}

\subsection{Types}

We reproduce here for convenience the definitions relating to HOL types from \cite{DS/FMU/IED/ZED001}.

πIZ
‹	[€char›]
=TEX

πIZ
‹	€string› == seq char
=TEX

We define constructors for abstract HOL types.

πIZ
	€TYPE› ::=		€mk_vartype›	ßß string ¢¢
			|	€mk_ctype›	ßß string ∏ seq TYPE ¢¢
=TEX
A discriminator and destructors.
πIZ
	€is_vartype_›	: SET TYPE
	€dest_vartype›	: TYPE ﬂ string
	€dest_ctype›	: TYPE ﬂ (string ∏ seq TYPE)
˜
	µs:string; ty:TYPE; sty:seq TYPE∑

	(is_vartype (mk_vartype s))
	≥ (is_vartype (mk_ctype (s, sty)))

	dom(dest_vartype) = is_vartype
	dom(dest_ctype) = TYPE \ is_vartype

	dest_vartype(mk_vartype s) = s
	dest_ctype(mk_ctype(s, sty)) = (s, sty)
=TEX

\subsection{Terms}

The definitions of the type {\it TERM} are complicated by the well formedness constraints imposed in \cite{DS/FMU/IED/ZED001}.
{\em pro-tem} we introduce {\em TERM} as a given set, and give under-specifications of the constructors.
πIZ
‹	[€TERM›]
=TEX
Here we show just the signatures of the relevant functions.
πIZ
	€mk_var›	:(string ∏ TYPE) ≠ TERM
‹	€mk_const›	:(string ∏ TYPE) ≠ TERM
‹	€mk_app›	:(TERM ∏ TERM) ﬂ TERM
‹	€mk_abs›	:(TERM ∏ TERM) ﬂ TERM
	€is_var_›, €is_const_›, €is_app_›, €is_abs_›	:SET TERM
	€dest_var›	: TERM ≠ (string ∏ TYPE)
‹	€dest_const›	:TERM ≠ (string ∏ TYPE)
‹	€dest_app›	:TERM ≠ (TERM ∏ TERM)
‹	€dest_abs›	:TERM ≠ (TERM ∏ TERM)
˜
	is_var	= ran(mk_var)	= dom(dest_var)
	is_const	= ran(mk_const)	= dom(dest_const)
	is_app	= ran(mk_app)	= dom(dest_app)
	is_abs	= ran(mk_abs)	= dom(dest_abs)
	mk_var o dest_var	= id[is_var]
	mk_const o dest_const	= id[is_const]
	mk_app o dest_app	= id[is_app]
	mk_abs o dest_abs	= id[is_abs]
=TEX

\subsection{Derived HOL Syntactic Constructors}

πIZAX
	€mk_≠_type›	: TYPE ≠ TYPE ≠ TYPE
˜
	µd,c:TYPE∑

	mk_≠_type d c 	= mk_ctype(`≠`,ßd,c¢)
∞ 
=TEX

πIZAX
	€Z_type›	: TYPE
	€mk_list_type›	: TYPE ≠ TYPE
	€mk_set_type›	: TYPE ≠ TYPE
	€mk_seq_type›	: TYPE ≠ TYPE
˜
	µt:TYPE∑

	Z_type	= mk_ctype (`Z`, ß¢)
	mk_list_type t 	= mk_ctype(`list`,ßt¢)
	mk_set_type t 	= mk_ctype(`SET`,ßt¢)
	mk_seq_type t 	= mk_set_type (mk_tuple_typeßZ_type,t¢)
=TEX

πIZAX
	€list_mk_≠_type›		: (seq TYPE ∏ TYPE) ≠ TYPE
	€list_mk_simple_Ã›		: (seq (string ∏ TYPE) ∏ TERM) ≠ TERM
	€list_mk_app›	: (TERM ∏ seq TERM) ≠ TERM
˜
	µty,ty1,ty2:TYPE; tm,tm1,tm2:TERM;
		stm:seq TERM; sty:seq TYPE; ssty:seq(string ∏ TYPE); s:string∑
 
	list_mk_≠_type (ß¢, ty)			= ty
±	list_mk_≠_type (styÎßty1¢,ty2)		= list_mk_≠_type(sty,mk_≠_type(ty1,ty2))

±	list_mk_simple_Ã (ß¢, tm)			= tm
±	list_mk_simple_Ã (sstyÎß(s,ty)¢, tm)	= list_mk_simple_Ã(ssty, mk_simple_Ã(s,ty,t))

±	list_mk_app (tm, ß¢)			= tm
±	list_mk_app (tm1, ßtm2¢Îstm)	= list_mk_app(mk_app (tm1,tm2), stm)
=TEX

πIZAX
	€mk_binop›	: TERM ≠ TERM ≠ TERM ≠ TERM
˜
	µft1,ft2,ft3:TERM∑

	mk_binop ft1 ft2 ft3 = mk_app(mk_app(ft1,ft2),ft3)
=TEX

\subsection{New HOL Constants}
\subsubsection{power set type constructor}

The power set type constructor SET must be defined, together with its abstraction function:

=GFT HOL Constant
	ABS_SET : (*a ≠ bool) ≠ (*a)SET
˜
	T
=TEX
and its inverse (modulo order of arguments), the membership relation:

=GFT HOL Constant
	ç : *a ≠ *a SET ≠ bool
˜
	T
=TEX
a second constant which means exactly the same as membership is also required for use in the predicate implicit in a declaration:
=GFT HOL Constant
	∫ : *a ≠ *a SET ≠ bool
˜
	∫ = ç
=TEX
and yet another rendition of membership is required for the invisible membership assertions which occur when a schema designator is used as a predicate:
=GFT HOL Constant
	hidden_membership : *a ≠ *a SET ≠ bool
˜
	hidden_membership = ç
=TEX
=IGN
\subsubsection{partial elements}

A new 1-ary type constructor $Z\_TERM$ is required to introduce an undefined element.
The representation type for $Z_TERM(*)$ will be $*+one$.
=TEX
\subsection{HOL lists}

Constants enabling the formation and use of lists of terms:
=GFT HOL Constant
	NIL		: (*a)list
	CONS		: *a ≠ (*a)list ≠ (*a)list
	contains	: (*a)list ≠ *a ≠ bool
˜
	(contains NIL x = F)
±	(contains (CONS x y) x)
±	(contains y x ¥ contains (CONS z y) x)
=TEX
Function application in Z:
=GFT HOL Constant
	apply	: (*a ∏ *b)SET ≠ *a ≠ *b
˜
	µx:*a∑ (∂â1 y:*b∑ (x,y) ç f) ¥ (x, apply f x) ç f
=TEX

\section{THE ABSTRACT SYNTAX OF Z} \label{ZSYNTAX}

We need some definition of the sort of data structure which we might expect to obtain from a Z syntax and type checker, so that we may consider how this can be related to the abstract syntax of HOL to enable mapping of Z into HOL terms.
In default of any more definitive information I have adapted the syntax from \cite{spivey88} and \cite{spivey89}.
The differences between these two references are that the former provides a more abstract syntax, simplified by avoiding issues such as operator precedences, and omits some features to simplify the semantics, e.g. schema designators as predicates, and generic constants.
For our present purposes an abstract syntax is required, but no features of the language should be omitted.

The syntax thus obtained has now been subject to various modifications which bring it closer into line with the structures known to be required for representing Z in HOL


\subsection{types}

The abstract syntax fails to take account of genericity.
It will be convenient in giving an account of how to deal with genericity to have an augmented abstract syntax for types as follows (the name has been changed to prevent a clash with the HOL types):
πIZ
	€Z_TYPE›	::=	€given_t›	ßßIDENT¢¢
			|	€var_t›		ßßIDENT¢¢
			|	€power_t›	ßßZ_TYPE¢¢
			|	€tuple_t›	ßßseq Z_TYPE¢¢
			|	€schema_t›	ßßIDENT ü Z_TYPE¢¢.

	€GTYPE›	==	seq IDENT ∏ Z_TYPE
=TEX
In the above syntax we have introduced type variables.
This is because generic constants in Z take as actual parameters sets of arbitrary types, and hence must be regarded not simply as having parameters which are sets, but as having parameters as sets of indeterminate type.
These types variables are therefore used exclusively in the types of the formal parameters of generic constants, and hence in the types of any expression which includes a reference to the formal parameters.

The introduction of a rule for $GTYPE$ recognises the existence of constants which are generic.
The identifiers in the sequence will include all those which occur in type variables in the $Z\_TYPE$, but not all these identifiers are bound to so occur (formal parameters need not be used).
In addition the fact that the identifiers are supplied as a sequence gives the necessary additional information about the order in which the actual parameters are to be supplied. 

A further desirable extension could be made to support generic free types, but is beyond the present scope of this document.

\subsection{the rest}

The syntax differs from the cited references in the following ways:

\begin{enumerate}
\item{}
Spivey's syntax has been translated into a set of mutually recursive free type definitions in Z.
\item{}
The data structure has been decorated with types in appropriate places, since these are essential to the translation process.
\item{}
Provision has been made for generic axiomatic definitions (see {\em axdefs}).
\item{}
Provision has been made for schema designators to be used as predicates (see {\em predsdes}).
\item{}
Various additional constructs have been introduced from \cite{spivey89}.
These are:
\begin{itemize}
\item
The precondition operator ({\em schpre}).
\item
Schema equivalence ({\em scheq}) and logical equivalence ({\em prediff}).
\item
$\Delta$ and $\Xi$ operators ($schdel$ and $schxi$).
\item
Schema composition ({\em schcomp}).
\item
Sequence displays ({\em termseq}).
\item
Schema expressions (schema designators in \cite{spivey89}, generalised to give closure under substitution) as predicates ({\em predsexp}).
\end{itemize}
\item{}
I have assumed that the type inference system will have inferred the relevant instance of a generic schema type where a theta term (or anything which is interpreted as including a theta term, e.g. a schema designator in a predicate) is used.
\item{}
The distinction between variables and constants has been introduced; variables and constants include a sequence of generic parameters (which may be empty in the case of non-generics).
\item{}
The distinct syntactic categories for terms and schema expressions ($SEXP$ and $Z\_TERM$) have been merged.
Schema expressions, like sets, are just terms with certain types (schema types).
\item
The syntax of SPEC has been modified to permit conservative extensions to be employed.
The syntax is changed so that a $SPEC$ is associated with the introduction of given sets.
This $SPEC$ may be used to constrain the given sets, and in this case we should be able to provide support for the establishment of the consistency of the constraints.
All the other forms will also be required to be conservative, except $constr$ which cannot be non-trivial and conservative since it introduces no new objects.
The theories will clearly show which extensions are conservative and which are not.
(This is a modification to standard Z)
\end{enumerate}
πIZ
	€Z_DEC›		::=	€dec›		ßßZ_TERM ∏ Z_TERM¢¢
			|	€decsexp›	ßßZ_TERM ∏ DECOR¢¢

	€Z_DECL›	==	seq Z_DEC
=TEX
πIZ
	€Z_PRED›	::=	€predeq›	ßßZ_TERM ∏ Z_TERM¢¢
			|	€predmem›	ßßZ_TERM ∏ Z_TERM¢¢
			|	€predtrue›
			|	€predfalse›
			|	€predneg›	ßßZ_PRED¢¢
			|	€predand›	ßßZ_PRED ∏ Z_PRED¢¢
			|	€predor›	ßßZ_PRED ∏ Z_PRED¢¢
			|	€predimp›	ßßZ_PRED ∏ Z_PRED¢¢
			|	€prediff›	ßßZ_PRED ∏ Z_PRED¢¢
			|	€∂›	ßßZ_DECL ∏ Z_PRED ∏ Z_PRED¢¢
			|	€∂â1›	ßßZ_DECL ∏ Z_PRED ∏ Z_PRED¢¢
			|	€µ›	ßßZ_DECL ∏ Z_PRED ∏ Z_PRED¢¢
			|	€predsexp›	ßßZ_TERM ∏ DECOR¢¢
=TEX
πIZ
	€Z_TERM›	::=	€termvar›	ßßIDENT ∏ Z_TYPE ∏ seq Z_TERM¢¢
			|	€termcon›	ßßIDENT ∏ Z_TYPE ∏ seq Z_TERM¢¢
			|	€termseq›	ßßseq Z_TERM¢¢
			|	€termsetd›	ßßseq Z_TERM¢¢
			|	€seta›	ßßZ_DECL ∏ Z_PRED ∏ Z_TERM¢¢
			|	€termtuple›	ßßseq Z_TERM¢¢
			|	€termprod›	ßßseq Z_TERM¢¢
			|	€termtheta›	ßßZ_TERM ∏ DECOR¢¢
			|	€termsel›	ßßZ_TERM ∏ IDENT¢¢
			|	€termapp›	ßßZ_TERM ∏ Z_TERM¢¢
			|	€Ã›	ßßZ_DECL ∏ Z_PRED ∏ Z_TERM¢¢
			|	€Õ›	ßßZ_DECL ∏ Z_PRED ∏ Z_TERM¢¢

			|	€schema›	ßßZ_DECL ∏ Z_PRED¢¢
			|	€schdec›		ßßZ_TERM ∏ DECOR¢¢
			|	€schpre›		ßßZ_TERM¢¢
			|	€schneg›	ßßZ_TERM¢¢
			|	€schand›	ßßZ_TERM ∏ Z_TERM¢¢
			|	€schor›		ßßZ_TERM ∏ Z_TERM¢¢
			|	€schimp›	ßßZ_TERM ∏ Z_TERM¢¢
			|	€scheq›		ßßZ_TERM ∏ Z_TERM¢¢
			|	€schpro›		ßßZ_TERM ∏ Z_TERM¢¢
			|	€schide›		ßßZ_TERM ∏ seq IDENT¢¢
			|	€∂âs›		ßßZ_DECL ∏ Z_PRED ∏ Z_TERM¢¢
			|	€∂â1âs›	ßßZ_DECL ∏ Z_PRED ∏ Z_TERM¢¢
			|	€µâs›		ßßZ_DECL ∏ Z_PRED ∏ Z_TERM¢¢
			|	€schdel›		ßßZ_TERM¢¢
			|	€schxi›		ßßZ_TERM¢¢
			|	€schcomp›	ßßZ_TERM ∏ Z_TERM¢¢
=TEX
πIZ
	€IDENT›	==	WORD ∏ DECOR
	€WORD›	==	string
	€DECOR›	==	string
=TEX

\section{SCHEMAS} \label{SCHEMAS}

Our purpose is to describe informally a mapping from Z into HOL.
This has been done by hanging informal descriptions around a partial formal definition of the mapping.
The mapping is intended to be fully systematic; our previous translations have had a more {\em ad hoc} flavour.
The systematic nature of the mapping is first apparent in the definition of the mapping of Z types into HOL types.
This follows the obvious pattern of chosing appropriate HOL representatives for the type constructors of Z and then mapping complex types in Z into similarly structured complex types in HOL.

The next most substantial departure from our previous practice, is to map those things which look like types in Z but are in fact terms denoting sets, into terms in HOL.
In our previous work we have mapped these into HOL types.
Signatures in Z are dual purpose, supplying an assignment of types to identifiers, and a predicate constraining the scope of abstraction or quantification.
This is reflected in the proposed mapping.

\subsection{Auxiliary Functions}

$∫$ forms a boolean term asserting that its first argument is a member of its second.
(Note that this symbol occurs here both as a Z constant being defined, and as an HOL constant defined above)
πIZAX
	€mk_optype›	: FTYPE ≠ FTYPE ≠ FTYPE ≠ FTYPE
	€mk_reltype›	: FTYPE ≠ FTYPE ≠ FTYPE
˜
	µft1,ft2,ft3:TERM∑

	mk_optype ft1 ft2 ft3	= mk_≠_type (ft1, mk_≠_type (ft2,ft3))
±	mk_reltype ft1 ft2 	= mk_optype ft1 ft2 bool_type
∞ 
=TEX
πIZAX
	_€member›_		: TERM ≠ TERM ≠ TERM
	_€∫›_			: TERM ≠ TERM ≠ TERM
	_€hidden_member›_	: TERM ≠ TERM ≠ TERM
˜
	µft1,ft2:TERM∑

	ft1 member ft2
	= mk_binop ft1 (mk_const (`ç`, mk_reltype (type_of ft1) (type_of ft2))) ft2

±	ft1 ∫ ft2
	= mk_binop ft1 (mk_const (`∫`, mk_reltype (type_of ft1) (type_of ft2))) ft2

±	ft1 hidden_member ft2
	= mk_binop ft1 (mk_const (`hidden_member`, mk_reltype (type_of ft1) (type_of ft2))) ft2
=TEX
πIZAX
	€NIL›		: TYPE ≠ TERM
	€CONS›		: TERM ≠ TERM ≠ TERM
˜
	µft1,ft2:TERM; ty:TYPE∑

	NIL ty
	= mk_const(`NIL`, mk_ctype (`list`,ßty¢))

±	CONS ft1 ft2
	= mk_binop ft1 (mk_const (`CONS`,mk_optype (type_of ft1) (type_of ft2) (type_of ft2))) ft2
=TEX

{\em equals} forms a boolean term asserting that its first argument is equal to its second.

πIZAX
	_€equals›_	: TERM ≠ TERM ≠ TERM
˜
	µft1,ft2:TERM∑

	ft1 equals ft2
		= mk_binop ft1 (mk_const (`=`, mk_reltype (type_of ft1) (type_of ft2) )) ft2
=TEX
{\em apply} forms an application of one Z term to another.

πIZAX
	_€apply›_	: TERM ≠ TERM ≠ TERM
˜
	µft1,ft2:TERM∑

	ft1 apply ft2
		= mk_binop ft1 (mk_const (`apply`, mk_optype funtype argtype restype)) ft2

	where
	[funtype,argtype,restype:FTYPE
	|	funtype = type_of ft1
	±	argtype = type_of ft2
	±	funtype = mk_≠_type(argtype,restype)]
=TEX

πIZAX
	€mk_schtype›	: (IDENT ü Z_TYPE) ≠ Z_TYPE
	€dest_schtype›	: Z_TYPE ﬂ (IDENT ü Z_TYPE)
	€sexp_idty›	: Z_TERM ≠ (IDENT ü TYPE)
˜
	µitym:(IDENT ü Z_TYPE); sexpb:Z_TERM ; zt:Z_TYPE∑

	dom dest_schtype	= ran mk_schtype
±	mk_schtype itym	= power_t(schema_t itym)
±	dest_schtype (power_t(schema_t itym))
				= itym
±	sexp_idty (sexpb, zt)	= dest_schtype zt ª hol_mtype
=TEX

\subsubsection{name formation}

The HOL syntax given above allows an arbitrary string for the name of a type constructor, type variable, constant or individual variable.
In general the names used in the HOL are derived from WORDs and DECORs used in the Z source, but the manner of derivation must be defined.
In addition there will be a number of type constructors, type variables, and constants used in the HOL which do not correspond directly to identifiers in the source Z.

The most complex names are those associated with schema types.
An infinite family of schema type constructors is required, one for each finite set of IDENTs.
Associated with each schema type constructor there will be various constants.
The names of each of these types and constants must distinguish it from the others, and we therefore need a mapping from sets of IDENTs to strings.

πIZAX
	€unpack_ident›	: string ﬂ IDENT
	€pack_ident› 	: IDENT ‡ string
˜
	pack_ident ª unpack_ident = id[IDENT]
=TEX

In fact, it is usually more convenient to deal with IDENTs in their packed forms, so we will not have the type abbreviations IDENT, WORD and DECOR in the implementation but simply use strings to represent each of them.
Thus, whilst they are retained in the Z specification paragraphs, the signature boxes will use $string$ (or sometimes $string ∏ string$).

=DOC
val €unpack_ident› : string -> (string * string);
val €pack_ident› : (string * string) -> string;
=DESCRIBE
$unpack\_ident$ splits a string representing an IDENT into its WORD and DECOR parts.
$pack\_ident$ is simply string concatenation.
=FAILURE
48001	?0 is not a valid identifier
=ENDDOC

In the following definitions {\em idsetseq} is intended to sort a set of identifiers.
The ordering is immaterial and has not been specified, though it would be odd to make it other than lexicographic.
{\em flatpack} produces a comma-separated string from a sequence of strings.
It is required to be used on the empty sequence (since schemas obtained by hiding may have an empty signature).

πIZAX
	€idsetseq›		: Ê IDENT ‡ seq IDENT
	€flatpack›		: seq string ‡ string
˜
		(µfid: Ê IDENT∑
			ran (idsetseq fid) = fid)
	±	(µss:seq string; s1,s2:string∑
			flatpack (ß¢) = ``
		±	flatpack (ßs1¢) = s1
		±	flatpack (ssÎßs1¢Îßs2¢) = (flatpack (ssÎßs1¢))^`,`^s2)
∞ 
=TEX


πIZAX
	€val_setIDENT›	: Ê IDENT ‡ string
	€itymfunseq›		: (IDENT ü TYPE) ≠ seq TYPE
	€bool_type›		: TYPE
˜
		(µfid: Ê IDENT∑
			ran (idsetseq fid) = fid
		±	val_setIDENT fid = `[`^(flatpack((idsetseq fid)ªpack_ident))^`]`)
	±	(µitym:IDENT ü TYPE∑
			itymfunseq itym = (idsetseq (dom itym)) ª itym)
	±	bool_type	= mk_ctype (`bool`,ß¢)
=TEX

{\em number} maps numbers onto numerals.
πIZAX
	€number›	: Ó ‡ string
	€val_numeral›	: string Ô Ó
˜
	µi:Ó∑ val_numeral (number i) = i
=TEX


It is the schema calculus which causes the greatest problems.
To support schemas it is proposed to introduce infinite families of new HOL type constructors.
For each of these types various associated constants will also be introduced.

These various types and constants are described as follows:


\subsection{Bindings and Tuples}

\subsubsection{binding types}

For each finite set of identifiers a polymorphic type constructor is required which is the type of bindings which bind values to just the identifiers in the set.
It is necessary to give each of these type constructors a unique name, which we will form by appending to the prefix $`S\_`$ the alphabetically ordered list of identifiers.
The type constructor will have the same arity as the cardinality of the set of identifiers, and the types assigned to the identifiers will be supplied as parameters to the constructor in alphabetic order of the identifiers to which they are assigned.

The type will be represented by the set of n-tuples (formed in HOL by iteration of the PAIR constructor) having the same number of components.
A sample representation type predicate is as follows:

=GFT ML
let €bind_type_[a,b]_pred› = "Ãt:(*a ∏ *b)∑ T"
=TEX

The type $(*a,*b)S_{[a,b]}$ will be in bijection with the elements having the above property and an axiom will be needed which asserts that this is the case. 

Functions yielding the type name and the type respectively are as follows:
πIZAX
	€bind_tname›		: Ê IDENT ≠ string
	€bind_type›		: (IDENT ü TYPE) ≠ TYPE
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	bind_tname fid		= `S_`^(val_setIDENT fid)
±	bind_type itym		= mk_ctype (bind_tname(dom itym), itymfunseq itym) 
∞ 
=TEX

=DOC
val €bind_type› : (string * TYPE) list -> TYPE; 
=DESCRIBE
Makes a Z binding type from the supplied component to type map.
=EXAMPLE
bind_type [("a",tya),("b",tyb)] = ¨:(tya,tyb)S_[a,b]Æ
=ENDDOC

\subsubsection{tuple types}


πIZAX
	€tuple_type›	: seq TYPE ≠ TYPE
˜
∞ 
=TEX

=DOC
val €tuple_type› : TYPE list -> TYPE; 
=DESCRIBE
Makes a Z tuple type from the supplied type list.
=EXAMPLE
tuple_type [tya,tyb] = ¨:(tya,tyb)T_[2]Æ
=ENDDOC

\subsubsection{binding constructors}

For every binding type there will be a constant for constructing bindings of that type.
The name of this constructor will be formed by prefixing $`mk\_`$ to the name of the type of the binding.
The type of the constructor will be that of a curried function taking parameters whose types are type variables having the same name as the identifiers in the signature of the bindings.
The result type will be the binding type with type variables similarly named supplied as parameters,
e.g. `$mk\_S_{[a,b]}:*a ≠ *b ≠ (*a,*b)S_{[a,b]}$'.

The element of the representation type corresponding to the entity constructed is simply the tuple formed from the values supplied as arguments.
A sample definition for the constructor would therefore be:

=GFT HOL Constant
	€Z'S[a,b]›: *a ≠ *b ≠ (*a,*b)S_[a,b]
˜
	Z'S[a,b] a b = ABS_S_[a,b] (a,b)
=TEX

In general type instantiations of these constructors will be required rather than the fully polymorphic types and terms.
The functions below provide appropriate instantiations.

πIZAX
	€bind_cname›		: Ê IDENT ≠ string
	€bind_ctype›		: (IDENT ü TYPE) ≠ TYPE
	€bind_cterm›		: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	bind_cname fid	= `mk_`^(bind_tname fid)
±	bind_ctype itym	= list_mk_≠_type (itymfunseq itym, bind_type itym)  
±	bind_cterm itym	= mk_const (bind_cname (dom itym), bind_ctype itym)  
∞ 
=TEX

These binding constructors are used in theta terms, {\em termtheta}.

=DOC
val €bind_cterm› : (string * TYPE) list -> TERM;
=DESCRIBE
Makes a Z binding constructor from the supplied component to type map.
=EXAMPLE
bind_cterm [("a",tya),("b",tyb)] = ¨Z'S[a,b] : tya ≠ tyb ≠ (tya,tyb)S_[a,b]Æ
=ENDDOC

\subsubsection{tuple constructors}

The special case of tuples is also catered for:
πIZAX
	€tuple_cname›	: seq TYPE ≠ string
	€tuple_ctype›	: seq TYPE ≠ TYPE
	€tuple_cterm›	: seq TYPE ≠ TERM
˜
	µsty:seq TYPE∑

	tuple_cname sty	= `Z'T[`^(number #sty)^`]`
	tuple_ctype sty		= list_mk_≠_type(sty,tuple_type sty)
	tuple_cterm sty	= mk_const(tuple_cname sty,tuple_ctype sty)
∞ 
=TEX

=DOC
val €tuple_cterm› : TYPE list -> TERM;
=DESCRIBE
Makes a Z tuple constructor from the supplied type list.
=EXAMPLE
tuple_cterm [tya,tyb] = ¨Z'T[2] : tya ≠ tyb ≠ (tya,tyb)T_[2]Æ
=ENDDOC

\subsubsection{cartesian products}

πIZAX
	€powert›	: TYPE ≠ TYPE
˜
	µty:TYPE∑	powert ty = mk_ctype(`SET`,ßt¢)
∞ 
=TEX

πIZAX
	€prod_cname›	: seq TYPE ≠ string
	€prod_ctype›	: seq TYPE ≠ TYPE
	€prod_cterm›	: seq TYPE ≠ TERM
˜
	µsty:seq TYPE∑

	prod_cname sty	= `Z'∏[`^(number (#sty))^`]`
	prod_ctype sty		= list_mk_≠_type(sty,powert(tuple_type sty))
	prod_cterm sty		= mk_const(prod_cname sty, prod_ctype sty)
=TEX

=DOC
val €prod_cterm› : TYPE list -> TERM;
=DESCRIBE
Makes a Z cartesian product constructor from the supplied type list.
=EXAMPLE
prod_cterm [tya,tyb] = ¨`Z'∏[2] : ((tya)SET,(tyb)SET)T_[2] ≠ ((tya,tyb)T_[2])SETÆ
=ENDDOC

\subsubsection{binding projections}

For every binding type there will be a set of projection functions, which select components of the binding.
These will have names formed by concatenating the identifier of the component to be selected, and the name of the type of the binding.
The type of the projection will be a function.
The domain type of the function is the type of the binding with appropriate type variables, the co-domain is then the type variable having the same name as the component to be selected.

The following is an example of how the projection functions will be defined.

=GFT HOL Constant
	€Z'Sel[a,b][a]›:(*a,*b)S_[a,b] ≠ *a
	€Z'Sel[a,b][b]›:(*a,*b)S_[a,b] ≠ *b
˜
	(Z'Sel[a,b][a] x = FST (REP_S_[a,b] x))
±	(Z'Sel[a,b][b] x = SND (REP_S_[a,b] x))
=TEX

Once again the functions defined yield type instantiated terms.

πIZAX
	€bind_pname›		: Ê IDENT		≠ IDENT ≠ string
	€bind_ptype›		: (IDENT ü TYPE)	≠ IDENT ≠ TYPE
	€bind_pterm›		: (IDENT ü TYPE)	≠ IDENT ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE; i:IDENT∑

	bind_pname fid i	= `Z'Sel` ^ (val_setIDENT fid) ^`[`^(pack_ident i)^`]`
±	bind_ptype itym i	= mk_≠_type(bind_type itym, itym i)  
±	bind_pterm itym i	= mk_const (bind_pname (dom itym) i, bind_ptype itym i)  
∞ 
=TEX

The projection constants are used for selection notation {\em S.name}, in {\em termsel}

=DOC
val €bind_pterm› : (string * TYPE) list -> string -> TERM;
=DESCRIBE
Makes a Z binding projection function for the supplied component to type map; the component to be projected is supplied as the second argument.
=EXAMPLE
bind_pterm [("a",tya),("b",tyb)] "a" = ¨Z'Sel[a,b][a] : (tya,tyb)S_[a,b] ≠ tyaÆ
=ENDDOC

\subsubsection{tuple projections}
\subsection{Schemas}

A schema is a set of bindings.
First we deal with schema types (which in this document are the types of schemas, but in \cite{spivey89} are the types of bindings), then with various operations on schemas which are available in Z.

As with bindings there is an infinite collection of schema types.

All the operations of the schema calculus require complete families of constants, indexed by the schema types over which they are legal.
Operations over schemas or schema expression which involve variable binding constructs are deferred to the next section.

\subsubsection{schema types}

A schema is a set of bindings, a schema type is therefore a powerset of a binding type:

πIZAX
	€schema_type›		: (IDENT ü TYPE) ≠ TYPE
˜
	µitym:IDENT ü TYPE∑

	schema_type itym	= mk_ctype (`SET`,ßbind_type itym¢)  
∞ 
=TEX

=DOC
val €schema_type› : (string * TYPE) list -> TYPE;
=DESCRIBE
Makes a Z schema type from the supplied component to type map.
=EXAMPLE
schema_type [("a",tya),("b",tyb)] = ¨:((tya,tyb)S_[a,b])SETÆ
=ENDDOC

Names for the operations will be formed in general by decorating the normal operation symbol by the type name of the operand or operands.

The operations are of various kinds as follows, grouped by type similarities (of which there are few!):

\subsubsection{schema negation}

Schema negation (schneg), takes any schema type to the same type.
It is semantically simply the complement operation on the set, and need not be restricted to sets of bindings.

=GFT HOL Constant
	€Z'≥›	: (*)SET ≠ (*)SET
˜
	µs:(*)SET∑	bind_Z'≥ s = ABS_SET (Ãx:*∑ x é s)
=TEX

The following definitions serve only to give type instances of the above constant:

πIZAX
	€bind_≥_type›		: (IDENT ü TYPE) ≠ TYPE
	€bind_≥_term›		: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	bind_≥_type itym	= mk_≠_type (schema_type itym, schema_type itym)  
±	bind_≥_term itym	= mk_const (`Z'≥`, bind_≥_type itym)  
∞ 
=TEX

=DOC
val €bind_≥_term› : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema negation constructor from the supplied component to type map.
=EXAMPLE
bind_≥_term [("a",tya),("b",tyb)] = ¨Z'≥ : ((tya,tyb)S_[a,b])SET ≠ ((tya,tyb)S_[a,b])SETÆ
=ENDDOC

\subsubsection{schema precondition}

=GFT HOL Constant
	€Z'Preâs[a',b]›:((*a,*b)S_[a',b])SET ≠ ((*b)S_[b])SET
˜
	µs:((*a,*b)S_[a',b])SET ∑

	Z'Preâs[a',b] s = [b:*b|∂a':*a∑ s]
=TEX

The precondition operator takes a schema and existentially quantifies all the variables which are either outputs or part of the new state.
The type of the resulting schema is therefore obtained by discarding all components of the type of the constituent bindings which have identifiers ending with ' or !.

We first define separately a function which determines which of the identifiers in a binding type are the identifiers of results of the operation described by the schema.
{\em There is room for debate about whether this is the correct interpretation of \cite{spivey89}.}

πIZAX
	€schema_results›	: (IDENT ü TYPE) ≠ Ê IDENT
˜
	µitym:IDENT ü TYPE∑

	schema_results itym =

	{w:WORD; d,fd:DECOR; s:string
	|	(fd = `'` ≤ fd = `!`) ± (w^d = s^fd)
	∑	(w,d)
	}	° (dom itym)
∞ 
=TEX

The type of the result of the precondition operation is the type of the original schema with the results hidden.
In fact precondition is definable in terms of hiding, but separate operators are needed to preserve the distinction for the concrete syntax.

πIZAX
	€bind_pre_name›	: Ê IDENT ≠ string
	€bind_pre_type›	: (IDENT ü TYPE) ≠ TYPE
	€bind_pre_term›	: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	bind_pre_name fid	= `Z'Preâs`^(val_set_ident fid)
±	bind_pre_type itym	= mk_≠_type
				(schema_type itym,
				 schema_type ((schema_results itym)	· itym)
				)  
±	bind_pre_term itym	= mk_const (bind_pre_name (dom itym), bind_pre_type itym)  
=TEX

=DOC
val €bind_pre_term› : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema precondition constructor from the supplied component to type map.
=EXAMPLE
bind_pre_term [("a'",tya),("b",tyb)] = ¨Z'Preâs[a',b] : ((tya,tyb)S_[a',b])SET ≠ ((tyb)S_[b])SETÆ
=ENDDOC

\subsubsection{simple dyadic schema operations}

=GFT HOL Constant
	€Z'±âs[a,b][b,c]›:((*a,*b)S_[a,b])SET ≠ ((*b,*c)S_[b,c])SET  ≠ ((*a,*b,*c)S_[a,b,c])SET
˜
	µsc1:((*a,*b)S_[a,b])SET; sc2:((*b,*c)S_[b,c])SET∑

	Z'±âs[a,b][b,c] sc1 sc2 = [a:*a; b:*b; c:*c | sc1 ± sc2]
=TEX

(schand, schor, schimp) taking any compatible pair of schema types to the schema type having the union of the components (with appropriate component types).

Since these operations are so similar they are provided by the same functions which take the particular operation name as a parameter:

πIZAX
	€bind_dysc_name›	: string ≠ Ê IDENT ≠ Ê IDENT ≠ string
	€bind_dysc_type›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TYPE
	€bind_dysc_term›	: string ≠ (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
˜
	µfid1,fid2:Ê IDENT; itym1,itym2:IDENT ü TYPE; n:string∑

	bind_dysc_name n fid1 fid2	= n^(val_setIDENT fid1)^(val_setIDENT fid2) 
±	bind_dysc_type itym1 itym2	= list_mk_≠_type
						(ßschema_type itym1,schema_type itym2¢,
						schema_type (itym1 ¿ itym2))
±	bind_dysc_term n itym1 itym2	= mk_const (bind_dysc_name n (dom itym1) (dom itym2),
							bind_dysc_type itym1 itym2)  
∞ 
=TEX

The following are primarily illustrative of the use of the above, and are not used in the sequel.

πIZAX
	€bind_±_term›		: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
	€bind_≤_term›		: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
	€bind_¥_term›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
	€bind_§_term›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
˜
	bind_±_term		= bind_dysc_term `Z'±âs` 
 	bind_≤_term		= bind_dysc_term `Z'≤âs`  
	bind_¥_term		= bind_dysc_term `Z'¥âs`  
	bind_§_term		= bind_dysc_term `Z'§âs`  
=TEX

It should be noted that the full generality of these functions will not be available in any implementation.
Only the identified operations will be supported.

=DOC
val €bind_±_term› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema conjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_±_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¨Z'±âs[a,b][b,c] : (((tya, tyb)S_[a,b])SET ≠ ((tyb, tyc)S_[b,c])SET ≠ ((tya, tyb, tyc)S_[a,b,c])SET)Æ
=ENDDOC

=DOC
val €bind_≤_term› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema disjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_≤_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¨Z'≤âs[a,b][b,c] : (((tya, tyb)S_[a,b])SET ≠ ((tyb, tyc)S_[b,c])SET ≠ ((tya, tyb, tyc)S_[a,b,c])SET)Æ
=ENDDOC

=DOC
val €bind_¥_term› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema implication constructor from the supplied component to type maps.
=EXAMPLE
bind_¥_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¨Z'¥âs[a,b][b,c] : (((tya, tyb)S_[a,b])SET ≠ ((tyb, tyc)S_[b,c])SET ≠ ((tya, tyb, tyc)S_[a,b,c])SET)Æ
=ENDDOC

=DOC
val €bind_§_term› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema equivalence constructor from the supplied component to type maps.
=EXAMPLE
bind_§_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¨Z'§âs[a,b][b,c] : (((tya, tyb)S_[a,b])SET ≠ ((tyb, tyc)S_[b,c])SET ≠ ((tya, tyb, tyc)S_[a,b,c])SET)Æ
=ENDDOC

\subsubsection{schema projection}

=GFT HOL Constant
	€Z'˘âs[a,b][b,c]›:((*a,*b)S_[a,b])SET ≠ ((*b,*c)S_[b,c])SET  ≠ ((*b,*c)S_[b,c])SET
˜
	µsc1:((*a,*b)S_[a,b])SET; sc2:((*b,*c)S_[b,c])SET∑

	Z'˘âs[a,b][b,c] sc1 sc2 = (sc1 ± sc2) \ (a)
=TEX

(schpro) takes two schemas of compatible types and yields a schema having the same type as the second

πIZAX
	€bind_˘_name›	: Ê IDENT ≠ Ê IDENT ≠ string
	€bind_˘_type›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TYPE
	€bind_˘_term›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
˜
	µfid1,fid2:Ê IDENT; itym1,itym2:IDENT ü TYPE∑

	bind_˘_name fid1 fid2	= `Z'˘âs`^(val_setIDENT fid1)^(val_setIDENT fid2)
±	bind_˘_type itym1 itym2	= list_mk_≠_type
				(	ßschema_type itym1, schema_type itym2¢,
					schema_type itym2
				)  
±	bind_˘_term itym1 itym2
		= mk_const (bind_˘_name (dom itym1) (dom itym2), bind_˘_type itym1 itym2)  
∞ 
=TEX

=DOC
val €bind_˘_term› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema projection constructor from the supplied component to type maps.
=EXAMPLE
bind_˘_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¨Z'˘âs[a,b][b,c] : (((tya, tyb)S_[a,b])SET ≠ ((tyb, tyc)S_[b,c])SET ≠ ((tyb, tyc)S_[b,c])SET)Æ
=ENDDOC

\subsubsection{schema hiding}

=GFT HOL Constant
	€Z'Hideâs[a,b][b]›:((*a,*b)S_[a,b])SET ≠ ((*a)S_[a])SET
˜
	µsc:((*a,*b)S_[a,b])SET∑

	Z'Hideâs[a,b][b] sc = [a:*a | ∂b:*b∑ sc]
=TEX

(schide) takes one schema and a list of identifiers and yields a schema whose type is formed from the type of the first parameter by deleting all components whose identifiers are in the list.

πIZAX
	€bind_hide_name›	: Ê IDENT ≠ Ê IDENT ≠ string
	€bind_hide_type›	: (IDENT ü TYPE) ≠ (Ê IDENT) ≠ TYPE
	€bind_hide_term›	: (IDENT ü TYPE) ≠ (Ê IDENT) ≠ TERM
˜
	µfid1,fid2:Ê IDENT; itym:IDENT ü TYPE∑

	bind_hide_name fid1 fid2	= `Z'Hideâs`^(val_setIDENT fid1)^(val_setIDENT fid2)
±	bind_hide_type itym fid2	= mk_≠_type
				(	schema_type itym,
					schema_type (fid2 · itym)
				)  
±	bind_hide_term itym fid2
		= mk_const (bind_hide_name (dom itym) fid2, bind_hide_type itym fid2)  
∞ 
=TEX

=DOC
val €bind_hide_term› : (string * TYPE) list -> string list -> TERM;
=DESCRIBE
Makes the Z schema hiding constructor from the supplied component to type map; the components to be hidden are supplied as the second argument.
=EXAMPLE
bind_hide_term [("a",tya),("b",tyb)] ["a"] = 
	¨Z'Hideâs[a,b][a] : (((tya, tyb)S_[a,b])SET ≠ ((tyb)S_[b])SET)Æ
=ENDDOC

\subsubsection{decoration}

(sdes) when schema designator is used it may be supplied with further decorations.
The effect is to add the decorations to the identifiers in the bindings.
 
πIZAX
	€decor_id›	: string ≠ IDENT ≠ IDENT
	€decor_idt›	: string ≠ (IDENT ∏ TYPE) ≠ (IDENT ∏ TYPE)
	€decor_itym›	: string ≠ (IDENT ü TYPE) ≠ (IDENT ü TYPE)
˜
	µs:string; w:WORD; d:DECOR; i:IDENT; ty:TYPE; itym:IDENT ü TYPE∑ 

	decor_id s (w,d)	= (w,d^s)
± 	decor_idt s (i,ty)	= (decor_id s i,ty)
±	decor_itym s itym	= (decor_idt s) ®itym©
∞ 
=TEX
πIZAX
	€bind_decor_name›	: Ê IDENT ≠ string ≠ string
	€bind_decor_type›	: (IDENT ü TYPE) ≠ string ≠ TYPE
	€bind_decor_term›	: (IDENT ü TYPE) ≠ string ≠ TERM
˜
	µfid:Ê IDENT; s:string; itym:IDENT ü TYPE∑

	bind_decor_name fid s	= `Z'Decâs`^(val_setIDENT fid)^`[`^s^`]`
±	bind_decor_type itym s	= mk_≠_type
				(	schema_type itym,
					schema_type (decor_itym s itym)
				)  
±	bind_decor_term itym s
		= mk_const (bind_decor_name (dom itym) s, bind_decor_type itym s)  
=TEX

=DOC
val €bind_decor_term› : (string * TYPE) list -> string -> TERM;
=DESCRIBE
Makes the Z schema systematic decoration constructor from the supplied component to type map; the decoration is supplied as the second argument.
=EXAMPLE
bind_decor_term [("a",tya),("b",tyb)] "'" = 
	¨Z'Decâs[a,b]['] : ((tya, tyb)S_[a,b])SET ≠ ((tya, tyb)S_[a',b'])SET)Æ
=ENDDOC

\subsubsection{the delta operation}

The delta operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with ').

πIZAX
	€bind_delta_name›	: Ê IDENT ≠ string
	€bind_delta_type›	: (IDENT ü TYPE) ≠ TYPE
	€bind_delta_term›	: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	bind_delta_name fid	= `Z'Ñâs`^(val_setIDENT fid)
±	bind_delta_type itym	= mk_≠_type
				(	schema_type itym,
					schema_type (itym ¿ (decor_itym `'` itym))
				)  
±	bind_delta_term itym
		= mk_const (bind_delta_name (dom itym), bind_delta_type itym)
∞ 
=TEX

=DOC
val €bind_Ñ_term› : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{the $\Xi$ operation}

The $\Xi$ operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with '), with the before and after values equated in the predicate.
The type is the same as that of the $\Delta$ operation.

πIZAX
	€bind_xi_name›	: Ê IDENT ≠ string
	€bind_xi_type›	: (IDENT ü TYPE) ≠ TYPE
	€bind_xi_term›	: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	bind_xi_name fid	= `Z'òâs`^(val_setIDENT fid)
±	bind_xi_type			= bind_delta_type  
±	bind_xi_term itym
		= mk_const (bind_xi_name (dom itym), bind_xi_type itym)
∞ 
=TEX

=DOC
val €bind_ò_term› : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{schema composition}

Schema composition is an operation which takes two schemas as arguments.
The schemas must be compatible in the following sense.
The primed components of the first schema must match in name and type the undecorated components of the second.
Any other components common to both must have the same type.

The type of the resulting schema is obtained by merging the two signatures hiding the primed components of the first and the undecorated components of the second.
There is a problem here about exactly what ``primed'' means.
Is a double primed identifier primed?

πIZAX
	€bind_scomp_name›	: Ê IDENT ≠ Ê IDENT ≠ string
	€bind_scomp_type›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TYPE
	€bind_scomp_term›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
˜
	µfid1, fid2:Ê IDENT; itym1,itym2:IDENT ü TYPE∑

	bind_scomp_name fid1 fid2	= `Z'ªâs`^(val_setIDENT fid1)^(val_setIDENT fid2)
±	bind_scomp_type itym1 itym2	= list_mk_≠_type (
					ßschema_type itym1, schema_type itym2¢,
					schema_type (
			ﬁ{i,i':IDENT | i' ç dom itym1 ± i ç dom itym2 
				± (pack_ident i)^`'` = (pack_ident i') ∑ {i,i'}}
			· (itym1 ¿ itym2))
±	bind_scomp_term itym1 itym2
		= mk_const (bind_scomp_name (dom itym1) (dom itym2),
			bind_scomp_type itym1 itym2)
∞ 
=TEX

=DOC
val €bind_ª_term› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema composition constructor from the supplied component to type maps.
=EXAMPLE
bind_scomp_term [("a",tya),("b'",tyb)] [("b",tyb),("c'",tyc)] = 
	¨Z'ªâs[a,b'][b,c'] : (((tya, tyb)S_[a,b'])SET ≠ ((tyb, tyc)S_[b,c'])SET ≠ ((tya, tyc)S_[a,c'])SET)Æ
=ENDDOC
\subsubsection{the rename operation}

The rename operation takes a schema and a renaming
and yields one which which is the original with the matching names renamed.

πIZAX
	€val_set_renames› : (IDENT û IDENT) ≠ string
˜
	µ ididl: (IDENT û IDENT)∑
	val_set_renames ididl = val_setIDENT {(x,y) : ididl ∑ x ^ " " ^ y}
∞
=IGN
Might instead use the following in bind_rename_type:

(dom ididl · itym) ¿ (itym o (dom itym · ididl~))
=TEX
πIZAX
	€bind_rename_name›	: Ê IDENT ≠ (IDENT û IDENT) ≠ string
	€bind_rename_type›	: (IDENT ü TYPE) ≠ (IDENT û IDENT) ≠ TYPE
	€bind_rename_term›	: (IDENT ü TYPE) ≠ (IDENT û IDENT) ≠ TERM
˜
	µfid:Ê IDENT; ididl: (IDENT û IDENT); itym:IDENT ü TYPE∑

	bind_rename_name fid ididl = `Z'Renameâs`^(val_setIDENT fid)^
				val_set_renames ididl
±	bind_rename_type itym	= mk_≠_type
		(schema_type itym,
		schema_type {x Ì y | 
			(∂ x1:IDENT ∑ (x1,x) ç ididl ± (x1,y) ç itym) ≤
			(x é dom ididl ± (x,y) ç itym)} 
		)
±	bind_rename_term itym ididl
		= mk_const (bind_rename_name (dom itym) ididl,
			bind_rename_type itym ididl)
∞ 
=TEX
Note that in the above the renamings are viewed as 
``first identifier is old name''
whereas the list provided to the below has
``first identifier is new name''
=DOC
val €bind_rename_term› : (string * TYPE) list -> (string * string)list -> TERM;
=DESCRIBE
=FAILURE
48011	Unable to form constant name: identifier names not legal Z?
=ENDDOC
\section{GLOBAL CONSTANTS}
=DOC
val €bind_gvar_name› : string -> string;
val €bind_gvar_term› : (string * TYPE) -> TERM;
val €unbind_gvar_name› : string -> string;
val €unbind_gvar_term› : TERM -> (string * TYPE);
=DESCRIBE
Construction and destruction of Z global variables names.
=EXAMPLE
bind_gvar_term ("a",tya) = ¨Z'a : tyaÆ
=ENDDOC

\subsection{Variable Binding Constructs}

Take care to avoid confusion between the two distinct uses of the term {\em binding} in this document.
The {\em binding}s which are members of schemas, bind values to identifiers.
Such bindings are the values denoted by terms with a binding type (e.g. $S_{[a,b,c...]}$).
Constructs involving the syntactic category {\em DECL} also effect a binding.
In this latter case it is variables which are bound within some textual scope, for the purpose, for example, of universal quantification.
These binding constructs may yield terms, predicates or schema expressions depending on the form of the construct.

There are in Z a variety of binding constructs of this latter kind, in which a DECL occurs and serves to bind variables in following predicates or terms.

The general pattern followed in dealing with these constructs is simply an elaboration of the treatment in HOL of binders.

There is just the one primitive binding construct, viz: lambda abstraction.
All binding constructs are therefore first translated into lambda abstractions.
The result of the abstraction is then converted into the value required by the application of a constant which embodies the semantics of the particular binding construct concerned.

The image of the binding construct is therefore formed in the following way:
\begin{enumerate}
\item{}
The constituent expressions are mapped into HOL in the standard way
(in some cases the {\em characteristic tuple}, while not an explicit constituent of the syntax, must be supplied by the mapping as a component of the resulting HOL term).
\item{}
These terms are collected together into a binding.
The binding constructor will be either $mk\_S_{[d,p]}$ (for $schema$, $∂_s$, $∂_{1s}$ and $µ_s$), $mk\_S_{[d,p,v]}$ (for $∂$, $∂_1$, $µ$, $seta$ and $Õ$) $mk\_S_{[t,d,p,v]}$ (for $Ã$).
\item{}
An abstraction is formed by abstracting over each of the variables declared in the constituent DECL.
\item{}
A binding operator is applied to the function thus obtained.
There will be a family of binding operators for each of the eight different binding constructs.
\end{enumerate}
The names of the binding operators will be formed from the name of the constructor in the abstract syntax by appending the sequence of names declared in the signature.
Its type will vary according to the signature and the nature of the binder.
Details are filled in below for each of the binders in turn.

\subsubsection{binding constructs by group}

Binding constructs fall into three groups, according to the scope of the bindings which take place.

The full list of binding constructs in Z is as follows:

\begin{tabular}{|l|l|l|l|}\hline
{\bf constructor} & {\bf description} & {\bf category} & {\bf group}\\ \hline
$schema$ & schema & $Z\_TERM$ (schema expression) & 1\\
$∂_s$ & schema existential quantification & $Z\_TERM$ (schema expression) & 1\\
$∂_{1s}$ & schema unique existential quantification & $Z\_TERM$ (schema expression) & 1\\
$µ_s$ & schema universal quantification & $Z\_TERM$ (schema expression) & 1\\
$∂$ & existential quantification & $PRED$ & 2\\
$∂_1$ & unique existential quantification & $PRED$ & 2\\
$µ$ & universal quantification & $PRED$ & 2\\
$seta$ & set abstraction (separation) & $Z\_TERM$ & 2\\
$Ã$ & lambda abstraction & $Z\_TERM$ & 3\\
$Õ$ & mu operator (description) & $Z\_TERM$ & 2\\ \hline
\end{tabular}

In the following descriptions of how these groups of binding constructs are handled the various expressions which fall within the scope of the binding are collected together into a single expression as a schema binding (i.e. a value having a schema product or binding type).

The number of components, and therefore the signature of the binding type, varies between groups, but the significance of the identifiers used is consistently as follows:

\begin{description}
\item[t]
This component is the {\em characteristic tuple} extracted from the declaration part (DECL) of the schema.
\item[d]
This component is the predicate (a boolean term) implicit in the declaration part (DECL) of the schema.
\item[p]
This is the boolean term formed from the predicate (PRED) part of the schema.
\item[v]
This term (the value) is formed from the body of the abstraction (Z\_TERM or PRED).
In some cases this is defaulted to the characteristic tuple.
\end{description}

\subsubsection{group 1 packs}

In the simplest case (group 1) the variables are bound only in the immediately following predicate (and even this may be omitted in the concrete syntax).
i.e. in schema, $∂_s$, $∂_{1s}$, and $µ_s$, the variables declared in the DECL are bound only in the following PRED.

The following functions yield schema product or binding constructors which are appropriate for collecting together the elements within the scope of a group 1 construct.
In group 1 there are just two constituents, the first of which corresponds to the predicate implicit in the DECL, the second corresponding to the explicit predicate (PRED) following the vertical bar.
These are given component identifiers {\em d} and {\em p} respectively.

πIZAX
	€g1_bind_sig›	: string ü TYPE
	€g1_bind_ctype›	: TYPE
	€g1_bind_cterm›	: TERM
	€g1_bind_type›	: TYPE
˜
		g1_bind_sig		=	{
					`d`Ìbool_type,
					`p`Ìbool_type}

	±	g1_bind_ctype	= bind_ctype g1_bind_sig
	±	g1_bind_cterm	= bind_cterm g1_bind_sig
	±	g1_bind_type	= bind_type g1_bind_sig
∞ 
=TEX

\subsubsection{group 2 packs}

In the next case (group 2) a predicate or term follows, within which the relevant variables are also bound.
This is the Z\_TERM or PRED following the bullet.
This more complex case includes constructs $∂$, $∂_1$, $µ$, $seta$ and $Õ$.
A Z\_TERM may be omitted in the concrete syntax, in which case the characteristic tuple will be used.
This substitution we presume at present to be undertaken by the parser/type-inference system.

πIZAX
	€g2_bind_sig›	: TYPE ≠ (string ü TYPE)
	€g2_bind_ctype›	: TYPE ≠ TYPE
	€g2_bind_cterm›	: TYPE ≠ TERM
	€g2_bind_type›	: TYPE ≠ TYPE
˜
	µty:TYPE∑

		g2_bind_sig ty	=	{
					`d`Ìbool_type,
					`p`Ìbool_type,
					`v`Ìty}

	±	g2_bind_ctype ty	= bind_ctype (g2_bind_sig ty)
	±	g2_bind_cterm ty	= bind_cterm (g2_bind_sig ty)
	±	g2_bind_type ty	= bind_type (g2_bind_sig ty)
=TEX

\subsubsection{group 3 packs}

The last case is that of the lambda abstraction which forms group 3.
In this case the characteristic tuple has a role to play even if a term is supplied following the bullet, and is therefore given an identifier of its own.

πIZAX
	€g3_bind_sig›	: TYPE ≠ TYPE ≠ (string ü TYPE)
	€g3_bind_ctype›	: TYPE ≠ TYPE ≠ TYPE
	€g3_bind_cterm›	: TYPE ≠ TYPE ≠ TERM
	€g3_bind_type›	: TYPE ≠ TYPE ≠ TYPE
˜
	µty1,ty2:TYPE∑

		g3_bind_sig ty1 ty2	=	{
					`d`Ìbool_type,
					`p`Ìbool_type,
					`t`Ìty1,
					`v`Ìty2}

	±	g3_bind_ctype ty1 ty2	= bind_ctype (g3_bind_sig ty1 ty2)
	±	g3_bind_cterm ty1 ty2	= bind_cterm (g3_bind_sig ty1 ty2)
	±	g3_bind_type ty1 ty2	= bind_type (g3_bind_sig ty1 ty2)
=TEX

In the following sections we supply for each variable binding construct:
\begin{enumerate}
\item{}
a verbal description of how it is mapped into HOL,
\item{}
a sample HOL-like definition of one of the binders in each family, showing both the type and the value (as an HOL term) of the binder,
\item{and}
a formal Z specification of functions which compute the binding constant.
\end{enumerate}

In the HOL-like sample definitions the Z dot notation is used as shorthand for the application of the relevant projection function.
The samples are generic in the types assigned to the identifiers in the signature, but are shown for specific signatures.
In these examples the schema types $S_{[d,p]}, S_{[d,p,v]}, S_{[t,d,p,v]}$ are fixed binding types used for packaging the two three or four components over which the abstraction is to be formed.

\subsubsection{bindings yielding schema expressions}

Variable binding in schema expressions occurs in schemas and in existential and universal quantification.
In its use in quantifiers the schema expression which follows the binding is not within its scope, i.e. the names in the signature are not bound in the schema expression forming the body of the construct.
For this reason, in contrast to all the other binding constructs, this schema expression is not included in the package over which the variables in the signature have been abstracted.
It is supplied as a second argument to the binding constant (which is a curried function).
This can be seen clearly by referring to the type of the binders in the following sections.

\subsubsection{schemas}

The simplest binding construct is that which simply yields a schema.
The following HOL constant is a sample of the infinite family of constants required: 

=GFT HOL Constant
	€Z'âs[a,b]›	: (*a ≠ *b ≠ (bool,bool)S_[d,p]) ≠ ((*a,*b)S_[a,b])SET
˜
	(Z'âs[a,b] p
		=	ABS_SET(Ãx:S_[a,b]∑
				let	t = p  x.a  x.b
				in	t.d  ±  t.p))

=TEX

We now specify functions which compute from the elements of the abstract syntax the name, type and term of the binding operators:

πIZAX
	€schema_bname›	: (Ê IDENT) ≠ string
	€schema_btype›	: (IDENT ü TYPE) ≠ TYPE
	€schema_bterm›	: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	schema_bname fid	= `Z'âs`^(val_setIDENT fid)
±	schema_btype itym	= mk_≠_type(
		list_mk_≠_type ((itymfunseq itym), g1_bind_type),
		schema_type itym
					)
±	schema_bterm itym	= mk_const (schema_bname (dom itym), schema_btype itym)
∞ 
=TEX

=DOC
val €schema_bterm› : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema constructor from the supplied component to type map.
=EXAMPLE
schema_bterm [("a",tya),("b",tyb)] = ¨Z'âs[a,b] : ((tya ≠ tyb ≠ (bool, bool)S_[d,p]) ≠ ((tya, tyb)S_[a,b])SET)Æ
=ENDDOC

\subsubsection{schema existential quantification}

=GFT HOL Constant
	€Z'∂âs[a,b][c,d]›	:
		(*a ≠ *b ≠ (bool,bool)S_[d,p]) ≠ ((*a,*b,*c,*d)S_[a,b,c,d])SET ≠ ((*c,*d)S_[c,d])SET
˜
	(Z'∂âs[a,b][c,d] p q
		= 	ABS_SET(Ãx:S_[c,d]∑ ∂y:S_[a,b]∑
				let	t = p  y.a  y.b
				in	t.d  ±  t.p
					± (Z'S[a,b,c,d]  y.a  y.b  x.c  x.d) ç q))
=TEX

πIZAX
	€∂âs_bname›	: (Ê IDENT) ≠ (Ê IDENT) ≠ string
	€∂âs_btype›		: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TYPE
	€∂âs_bterm›		: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
˜
	µfid1,fid2:Ê IDENT; itym1,itym2:IDENT ü TYPE∑

	∂âs_bname fid1 fid2
		= `Z'∂âs`^(val_setIDENT fid1)^(val_setIDENT (fid2\fid1))
±	∂âs_btype itym1 itym2
		= list_mk_≠_type
			(ß list_mk_≠_type ((itymfunseq itym1), g1_bind_type),
				schema_type itym2 ¢,
			(schema_type (itym2\itym1)))
±	∂âs_bterm itym1 itym2
		= mk_const (∂âs_bname (dom itym1) (dom itym2),
				∂âs_btype itym1 itym2)
∞ 
=TEX

=DOC
val €∂âs_bterm› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema existential quantification constructor from the supplied component to type maps.
=EXAMPLE
∂âs_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
¨Z'∂âs[a,b][c,d] : ((tya ≠ tyb ≠ (bool,bool)S_[d,p]) ≠ ((tya,tyb,tyc,tyd)S_[a,b,c,d])SET ≠ ((tyc,tyd)S_[c,d])SET)Æ
=ENDDOC

\subsubsection{schema unique existential quantification}

=GFT HOL Constant
	€Z'∂â1âs[a,b][c,d]›	:
		(*a ≠ *b ≠ (bool,bool)S_[d,p]) ≠ ((*a,*b,*c,*d)S_[a,b,c,d])SET ≠ ((*c,*d)S_[c,d])SET
˜
	(Z'∂â1âs[a,b][c,d] p q
		= 	ABS_SET(Ãx:S_[c,d]∑ ∂â1y:S_[a,b]∑
				let	t = p  y.a  y.b
				in	t.d  ±  t.p
					± (Z'S[a,b,c,d]  y.a  y.b  x.c  x.d) ç q))
=TEX

πIZAX
	€∂â1âs_bname›		: (Ê IDENT) ≠ (Ê IDENT) ≠ string
	€∂â1âs_btype›		: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TYPE
	€∂â1âs_bterm›		: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
˜
	µfid1,fid2:Ê IDENT; itym1,itym2:IDENT ü TYPE∑

	∂â1âs_bname fid1 fid2
		= `Z'∂â1âs`^(val_setIDENT fid1)^(val_setIDENT (fid2\fid1))
±	∂â1âs_btype 
		= ∂âs_btype
±	∂â1âs_bterm itym1 itym2
		= mk_const (∂â1âs_bname (dom itym1) (dom itym2),
				∂â1âs_btype itym1 itym2)
∞ 
=TEX

=DOC
val €∂â1âs_bterm› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema unique existential quantification constructor from the supplied component to type maps.
=EXAMPLE
∂â1âs_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
¨Z'∂â1âs[a,b][c,d] : ((tya ≠ tyb ≠ (bool,bool)S_[d,p]) ≠ ((tya,tyb,tyc,tyd)S_[a,b,c,d])SET ≠ ((tyc,tyd)S_[c,d])SET)Æ
=ENDDOC

\subsubsection{schema universal quantification}

=GFT HOL Constant
	€Z'µâs[a,b][c,d]›	:
		(*a ≠ *b ≠ (bool,bool)S_[d,p]) ≠ ((*a,*b,*c,*d)S_[a,b,c,d])SET ≠ ((*c,*d)S_[c,d])SET
˜
	(Z'µâs[a,b][c,d] p q
		=	ABS_SET(Ãx:S_[c,d]∑ µy:S_[a,b]∑
				let	t = p  y.a  y.b
				in	t.d  ±  t.p
					¥ (Z'S[a,b,c,d] y.a y.b x.c x.d) ç q))
=TEX

πIZAX
	€µâs_bname›	: (Ê IDENT) ≠ (Ê IDENT) ≠ string
	€µâs_btype›		: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TYPE
	€µâs_bterm›	: (IDENT ü TYPE) ≠ (IDENT ü TYPE) ≠ TERM
˜
	µfid1,fid2:Ê IDENT; itym1,itym2:IDENT ü TYPE∑

	µâs_bname fid1 fid2
		= `Z'µâs`^(val_setIDENT fid1)^(val_setIDENT (fid2\fid1))
±	µâs_btype itym1 itym2
		= list_mk_≠_type
			(ß list_mk_≠_type ((itymfunseq itym1), g1_bind_type),
				schema_type itym2 ¢,
			(schema_type (itym2\itym1)))
±	µâs_bterm itym1 itym2
		= mk_const (µâs_bname (dom itym1) (dom itym2),
				µâs_btype itym1 itym2)
∞ 
=TEX

=DOC
val €µâs_bterm› : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema universal quantification constructor from the supplied component to type maps.
=EXAMPLE
µâs_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
¨Z'µâs[a,b][c,d] : ((tya ≠ tyb ≠ (bool,bool)S_[d,p]) ≠ ((tya,tyb,tyc,tyd)S_[a,b,c,d])SET ≠ ((tyc,tyd)S_[c,d])SET)Æ
=ENDDOC

\subsubsection{existential quantification}

=GFT HOL Constant
	€Z'∂[2]›	:
		(*1 ≠ *2 ≠ (bool,bool,bool)S_[d,p,v]) ≠ bool
˜
	(Z'∂[2] p
		=	∂(x:*1)(y:*2)∑ let t = p x y in	t.d ± t.p ± t.v)
=TEX

πIZAX
	€∂_bname›	: (Ê IDENT) ≠ string
	€∂_btype›	: (IDENT ü TYPE) ≠ TYPE
	€∂_bterm›	: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	∂_bname fid
		= `Z'∂[`^(number(length fid))^`]`
±	∂_btype itym
		= mk_≠_type
			(list_mk_≠_type ((itymfunseq itym), g2_bind_type bool_type),
					bool_type)
±	∂_bterm itym
		= mk_const (∂_bname (dom itym), ∂_btype itym)
∞ 
=TEX

=DOC
val €∂_bterm› : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z existential quantification constructor from the supplied component to type map.
=EXAMPLE
∂_bterm [("a",tya),("b",tyb)] = 
¨Z'∂[2] : ((tya ≠ tyb ≠ (bool,bool,bool)S_[d,p,v]) ≠ bool)Æ
=ENDDOC

\subsubsection{unique existential quantification}

=GFT HOL Constant
	€Z'∂â1[2]›	:
		(*1 ≠ *2 ≠ (bool,bool,bool)S_[d,p,v]) ≠ bool
˜
	(Z'∂â1[2] p
		=	∂â1(x:*1)(y:*2)∑ let t = p x y in	t.d ± t.p ± t.v)
=TEX

πIZAX
	€∂â1_bname›	: (Ê IDENT) ≠ string
	€∂â1_btype›	: (IDENT ü TYPE) ≠ TYPE
	€∂â1_bterm›	: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	∂â1_bname fid
		= `Z'∂â1[`^(number(length fid))^`]`
±	∂â1_btype
		= ∂_btype
±	∂â1_bterm itym
		= mk_const (∂â1_bname (dom itym), ∂â1_btype itym)
∞ 
=TEX

=DOC
val €∂â1_bterm› : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z unique existential quantification constructor from the supplied component to type map.
=EXAMPLE
∂â1_bterm [("a",tya),("b",tyb)] = 
¨Z'∂â1[2] : ((tya ≠ tyb ≠ (bool,bool,bool)S_[d,p,v]) ≠ bool)Æ
=ENDDOC

\subsubsection{universal quantification}

=GFT HOL Constant
	€Z'µ[2]›	:
		(*1 ≠ *2 ≠ (bool,bool,bool)S_[d,p,v]) ≠ bool
˜
	(Z'µ[2] p
		=	µ(x:*1)(y:*2)∑ let t = p x y in	t.d ± t.p ¥ t.v)
=TEX

πIZAX
	€µ_bname›	: (Ê IDENT) ≠ string
	€µ_btype›	: (IDENT ü TYPE) ≠ TYPE
	€µ_bterm›	: (IDENT ü TYPE) ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE∑

	µ_bname fid
		= `Z'µ[`^(number(length fid))^`]`
±	µ_btype itym
		= mk_≠_type
			(list_mk_≠_type ((itymfunseq itym), g2_bind_type bool_type),
					bool_type)
±	µ_bterm itym
		= mk_const (µ_bname (dom itym), µ_btype itym)
∞ 
=TEX

=DOC
val €µ_bterm› : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z universal quantification constructor from the supplied component to type map.
=EXAMPLE
µ_bterm [("a",tya),("b",tyb)] = 
¨Z'µ[2] : ((tya ≠ tyb ≠ (bool,bool,bool)S_[d,p,v]) ≠ bool)Æ
=ENDDOC

\subsubsection{set abstraction}

=GFT HOL Constant
	€Z'Seta[2]›	:
		(*1 ≠ *2 ≠ (bool,bool,*v)S_[d,p,v]) ≠ (*v)SET
˜
	(Z'Seta[2] p
		=	ABS_SET(Ãx:*v∑ ∂(y:*1) (z:*2)∑
				let t = p y z in	t.d ± t.p ± (t.v = x))
=TEX

πIZAX
	€seta_bname›	: (Ê IDENT) ≠ string
	€seta_btype›	: (IDENT ü TYPE) ≠ TYPE ≠ TYPE
	€seta_bterm›	: (IDENT ü TYPE) ≠ TYPE ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE; ty:TYPE∑

	seta_bname fid
		= `Z'Seta[`^(number(length fid))^`]`
±	seta_btype itym ty
		= mk_≠_type
			(list_mk_≠_type ((itymfunseq itym), g2_bind_type ty),
					mk_ctype (`SET`,ßty¢))
±	seta_bterm itym ty
		= mk_const (seta_bname (dom itym), seta_btype itym ty)
∞ 
=TEX

=DOC
val €seta_bterm› : (string * TYPE) list -> TYPE -> TERM;
=DESCRIBE
Makes the Z set comprehension constructor from the supplied component to type map.
The type of the members of the resulting set is supplied as the second argument.
=EXAMPLE
seta_bterm [("a",tya),("b",tyb)] tyv = 
¨Z'Seta[2] : ((tya ≠ tyb ≠ (bool,bool,tyv)S_[d,p,v]) ≠ (tyv)SET)Æ
=ENDDOC

\subsubsection{lambda abstraction}

=GFT HOL Constant
	€Z'Ã[2]›	:
		(*1 ≠ *2 ≠ (bool,bool,*dv,*cv)S_[d,p,t,v]) ≠ ((*dv,*cv)S_[1,2])SET
˜
	(Z'Ã[2] p
		=	ABS_SET(Ãx:(*dv,*cv)S_[1,2]∑ ∂(y:*1) (z:*2)∑
				let	t = p y z
				in	t.d ± t.p ± (t.t = x.1 ± t.v = x.2))
=TEX

πIZAX
	€Ã_bname›	: (Ê IDENT) ≠ string
	€Ã_btype›	: (IDENT ü TYPE) ≠ TYPE ≠ TYPE ≠ TYPE
	€Ã_bterm›	: (IDENT ü TYPE) ≠ TYPE ≠ TYPE ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE; d_ty,c_ty:TYPE∑

	Ã_bname fid
		= `Z'Ã[`^(number(length fid))^`]`
±	Ã_btype itym d_ty c_ty
		= mk_≠_type
			(list_mk_≠_type ((itymfunseq itym), g3_bind_type d_ty c_ty),
					mk_ctype(`SET`,ßmk_tuple_type ßd_ty,c_ty¢¢))
±	Ã_bterm itym d_ty c_ty
		= mk_const (Ã_bname (dom itym), Ã_btype itym d_ty c_ty)
∞ 
=TEX

=DOC
val €Ã_bterm› : (string * TYPE) list -> TYPE -> TYPE -> TERM;
=DESCRIBE
Makes the Z lambda abstraction constructor from the supplied component to type map.
The types of the domain (characteristic tuple) and range of the resulting function are supplied as the second and third arguments respectively.
=EXAMPLE
Ã_bterm [("a",tya),("b",tyb)] tyt tyv = 
¨Z'Ã[2] : ((tya ≠ tyb ≠ (bool,bool,tyt,tyv)S_[d,p,t,v]) ≠ ((tyt,tyv)T_2)SET)Æ
=ENDDOC

\subsubsection{definite description}

=GFT HOL Constant
	€Z'Õ[2]›		:
		(*1 ≠ *2 ≠ (bool,bool,*cv)S_[d,p,v]) ≠ *cv
˜
	(Z'Õ[2] p
		=	Õ(Ãx:*cv∑ ∂(y:*1) (z:*2)∑
				let	t = p y z
				in	t.d ± t.p ± (t.v = x)))
=TEX

Note that the above definition relies upon $Õ$ being defined as definite description rather than choice in HOL.
 
πIZAX
	€Õ_bname›	: (Ê IDENT) ≠ string
	€Õ_btype›	: (IDENT ü TYPE) ≠ TYPE ≠ TYPE
	€Õ_bterm›	: (IDENT ü TYPE) ≠ TYPE ≠ TERM
˜
	µfid:Ê IDENT; itym:IDENT ü TYPE; ty:TYPE∑

	Õ_bname fid
		= `Z'Õ[`^(number(length fid))^`]`
±	Õ_btype itym ty
		= mk_≠_type
			(list_mk_≠_type ((itymfunseq itym), g2_bind_type ty),
					ty)
±	Õ_bterm itym ty
		= mk_const (Õ_bname (dom itym), Õ_btype itym ty)
∞ 
=TEX

=DOC
val €Õ_bterm› : (string * TYPE) list -> TYPE -> TERM;
=DESCRIBE
Makes the Z definite description constructor from the supplied component to type map.
The type of the result is supplied as the second argument.
=EXAMPLE
Õ_bterm [("a",tya),("b",tyb)] tyv = 
¨Z'Õ[2] : ((tya ≠ tyb ≠ (bool,bool,tyv)S_[d,p,v]) ≠ tyv)Æ
=ENDDOC

\subsection{Computing the Abstractions}

For each of the three groups of abstraction we define a function which constructs the abstraction to which the binding operator will be applied.
The process of abstraction over each of the names in the signature is common to these three functions and is defined first.

πù [A,B]
	€zip›		: (seq A) ≠ (A ü B) ≠ seq (A ∏ B)
˜
	µseqa:seq A; a:A; m:A ü B∑

	zip ß¢ m			= ß¢
±	zip seqaÎßa¢ m	= (zip seqa m)Îß(a, m a)¢
∞ 
=TEX

πIZAX
	€schema_abs›	: (IDENT ü TYPE) ≠ TERM ≠ TERM
˜
	µitym:IDENT ü TYPE; ft:TERM∑

	schema_abs itym ft
		= list_mk_simple_Ã
				(zip ((idsetseq ª pack_ident)(dom itym)) stym,
				ft)

		where
		[stym:string ü TYPE | pack_ident ª stym = itym]
=TEX

\subsubsection{forming the abstractions}

In the following sections the variable names are using in the following way:

\begin{description}
\item[ft1]
characteristic tuple
\item[ft2]
declaration
\item[ft3]
predicate
\item[ft4]
body
\item[ty1]
characteristic tuple type
\item[ty2]
body type
\item[itym]
type map assigning types to identifiers in signature
\end{description}

\subsubsection{group 1 abstractions}
πIZAX
	€g1_abs›	: (TERM ∏ TERM ∏ (IDENT ü TYPE)) ≠ TERM
˜
	µft2,ft3:TERM; itym:IDENT ü TYPE∑

	g1_abs (ft2,ft3,itym)	= schema_abs itym (list_mk_app (g1_bind_cterm,ßft2,ft3¢))
=TEX

=DOC
val €g1_abs› : TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¨:BOOLÆ
=ENDDOC

\subsubsection{group 2 abstractions}
πIZAX
	€g2_abs›	: (TERM ∏ TERM ∏ TERM ∏ (IDENT ü TYPE)) ≠ TERM
˜
	µft2, ft3, ft4:TERM; ty2:TYPE; itym:IDENT ü TYPE∑

	g2_abs (ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_app (g2_bind_cterm (type_of ft4), ßft2, ft3, ft4¢))
∞ 
=TEX

=DOC
val €g2_abs› : TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¨:BOOLÆ
=ENDDOC

\subsubsection{group 3 abstractions}
πIZAX
	€g3_abs›
	: (TERM ∏ TERM ∏ TERM ∏ TERM ∏ (IDENT ü TYPE)) ≠ TERM
˜
	µft1, ft2, ft3, ft4:TERM; ty1, ty2:TYPE; itym:IDENT ü TYPE∑

	g3_abs (ft1, ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_app (g3_bind_cterm (type_of ft1) (type_of ft4), ßft2, ft3, ft1, ft4¢))
∞ 
=TEX

=DOC
val €g3_abs› : TERM * TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¨:BOOLÆ
=ENDDOC

\section{END OF SIGNATURE}
=SML
end (* end of icl'ZTypesAndTerms signature *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


