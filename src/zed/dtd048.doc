=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Support for Z Types and Terms}
\TPPref{DS/FMU/IED/DTD048}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document provides a detailed design for a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/DTD047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the corresponding implementation document is \cite{DS/FMU/IED/IMP048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{?} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intercepted and reported as helpfully as possible.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{SIGNATURE}
=DOC
signature Ûicl'ZTypesAndTermsÝ = sig
=DESCRIBE
The Z Abstract Machine support functions are packaged into this signature.
=ENDDOC
\section{THE ABSTRACT SYNTAX OF HOL TYPES AND ZTERMS} \label{TYPESANDZTERMS}

\subsection{Types}

We reproduce here for convenience the definitions relating to HOL types from \cite{DS/FMU/IED/ZED001}.

¹IZ
Ü	[ÛcharÝ]
=TEX

¹IZ
Ü	ÛstringÝ == seq char
=TEX

We define constructors for abstract HOL types.

¹IZ
	ÛTYPEÝ ::=		Ûmk_vartypeÝ	§§ string ¢¢
			|	Ûmk_ctypeÝ	§§ string ¸ seq TYPE ¢¢
=TEX
A discriminator and destructors.
¹IZ
	Ûis_vartype_Ý	: ð TYPE
	Ûdest_vartypeÝ	: TYPE ß string
	Ûdest_ctypeÝ	: TYPE ß (string ¸ seq TYPE)
÷
	µs:string; ty:TYPE; sty:seq TYPE·

	(is_vartype (mk_vartype s))
	³ (is_vartype (mk_ctype (s, sty)))

	dom(dest_vartype) = is_vartype
	dom(dest_ctype) = TYPE \ is_vartype

	dest_vartype(mk_vartype s) = s
	dest_ctype(mk_ctype(s, sty)) = (s, sty)
=TEX

\subsection{Terms}

The definitions of the type {\it TERM} are complicated by the well formedness constraints imposed in \cite{DS/FMU/IED/ZED001}.
{\em pro-tem} we introduce {\em TERM} as a given set, and give under-specifications of the constructors.
¹IZ
Ü	[ÛTERMÝ]
=TEX
Here we show just the signatures of the relevant functions.
¹IZ
	Ûmk_varÝ	:(string ¸ TYPE) ­ TERM
Ü	Ûmk_constÝ	:(string ¸ TYPE) ­ TERM
Ü	Ûmk_appÝ	:(TERM ¸ TERM) ß TERM
Ü	Ûmk_absÝ	:(TERM ¸ TERM) ß TERM
	Ûis_var_Ý, Ûis_const_Ý, Ûis_app_Ý, Ûis_abs_Ý	:ð TERM
	Ûdest_varÝ	: TERM ­ (string ¸ TYPE)
Ü	Ûdest_constÝ	:TERM ­ (string ¸ TYPE)
Ü	Ûdest_appÝ	:TERM ­ (TERM ¸ TERM)
Ü	Ûdest_absÝ	:TERM ­ (TERM ¸ TERM)
÷
	is_var	= ran(mk_var)	= dom(dest_var)
	is_const	= ran(mk_const)	= dom(dest_const)
	is_app	= ran(mk_app)	= dom(dest_app)
	is_abs	= ran(mk_abs)	= dom(dest_abs)
	mk_var o dest_var	= id[is_var]
	mk_const o dest_const	= id[is_const]
	mk_app o dest_app	= id[is_app]
	mk_abs o dest_abs	= id[is_abs]
=TEX

\subsection{Derived HOL Syntactic Constructors}

¹IZAX
	Ûmk_­_typeÝ	: TYPE ­ TYPE ­ TYPE
÷
	µd,c:TYPE·

	mk_­_type d c 	= mk_ctype(`­`,§d,c¢)
° 
=TEX

¹IZAX
	ÛZ_typeÝ	: TYPE
	Ûmk_list_typeÝ	: TYPE ­ TYPE
	Ûmk_set_typeÝ	: TYPE ­ TYPE
	Ûmk_seq_typeÝ	: TYPE ­ TYPE
÷
	µt:TYPE·

	Z_type	= mk_ctype (`Z`, §¢)
	mk_list_type t 	= mk_ctype(`list`,§t¢)
	mk_set_type t 	= mk_ctype(`ð`,§t¢)
	mk_seq_type t 	= mk_set_type (mk_tuple_type§Z_type,t¢)
=TEX

¹IZAX
	Ûlist_mk_­_typeÝ		: (seq TYPE ¸ TYPE) ­ TYPE
	Ûlist_mk_simple_ÌÝ		: (seq (string ¸ TYPE) ¸ TERM) ­ TERM
	Ûlist_mk_appÝ	: (TERM ¸ seq TERM) ­ TERM
÷
	µty,ty1,ty2:TYPE; tm,tm1,tm2:TERM;
		stm:seq TERM; sty:seq TYPE; ssty:seq(string ¸ TYPE); s:string·
 
	list_mk_­_type (§¢, ty)			= ty
±	list_mk_­_type (styë§ty1¢,ty2)		= list_mk_­_type(sty,mk_­_type(ty1,ty2))

±	list_mk_simple_Ì (§¢, tm)			= tm
±	list_mk_simple_Ì (sstyë§(s,ty)¢, tm)	= list_mk_simple_Ì(ssty, mk_simple_Ì(s,ty,t))

±	list_mk_app (tm, §¢)			= tm
±	list_mk_app (tm1, §tm2¢ëstm)	= list_mk_app(mk_app (tm1,tm2), stm)
=TEX

¹IZAX
	Ûmk_binopÝ	: TERM ­ TERM ­ TERM ­ TERM
÷
	µft1,ft2,ft3:TERM·

	mk_binop ft1 ft2 ft3 = mk_app(mk_app(ft1,ft2),ft3)
=TEX

\subsection{New HOL Constants}
\subsubsection{power set type constructor}

The power set type constructor ð must be defined, together with its abstraction function:

=GFT HOL Constant
	ABS_ð : (*a ­ bool) ­ (*a)ð
÷
	T
=TEX
and its inverse (modulo order of arguments), the membership relation:

=GFT HOL Constant
	 : *a ­ *a ð ­ bool
÷
	T
=TEX
a second constant which means exactly the same as membership is also required for use in the predicate implicit in a declaration:
=GFT HOL Constant
	º : *a ­ *a ð ­ bool
÷
	º = 
=TEX
and yet another rendition of membership is required for the invisible membership assertions which occur when a schema designator is used as a predicate:
=GFT HOL Constant
	hidden_membership : *a ­ *a ð ­ bool
÷
	hidden_membership = 
=TEX
=IGN
\subsubsection{partial elements}

A new 1-ary type constructor $ZTERM$ is required to introduce an undefined element.
The representation type for $ZTERM(*)$ will be $*+one$.
=TEX
\subsection{HOL lists}

Constants enabling the formation and use of lists of terms:
=GFT HOL Constant
	NIL		: (*a)list
	CONS		: *a ­ (*a)list ­ (*a)list
	contains	: (*a)list ­ *a ­ bool
÷
	(contains NIL x = F)
±	(contains (CONS x y) x)
±	(contains y x ´ contains (CONS z y) x)
=TEX
Function application in Z:
=GFT HOL Constant
	apply	: (*a ¸ *b)ð ­ *a ­ *b
÷
	µx:*a· (¶‰1 y:*b· (x,y)  f) ´ (x, apply f x)  f
=TEX

\section{THE ABSTRACT SYNTAX OF Z} \label{ZSYNTAX}

We need some definition of the sort of data structure which we might expect to obtain from a Z syntax and type checker, so that we may consider how this can be related to the abstract syntax of HOL to enable mapping of Z into HOL terms.
In default of any more definitive information I have adapted the syntax from \cite{spivey88} and \cite{spivey89}.
The differences between these two references are that the former provides a more abstract syntax, simplified by avoiding issues such as operator precedences, and omits some features to simplify the semantics, e.g. schema designators as predicates, and generic constants.
For our present purposes an abstract syntax is required, but no features of the language should be omitted.

The syntax thus obtained has now been subject to various modifications which bring it closer into line with the structures known to be required for representing Z in HOL


\subsection{types}

The abstract syntax fails to take account of genericity.
It will be convenient in giving an account of how to deal with genericity to have an augmented abstract syntax for types as follows (the name has been changed to prevent a clash with the HOL types):
¹IZ
	ÛZTYPEÝ	::=	ÛgivenTÝ	§§IDENT¢¢
			|	ÛvarTÝ		§§IDENT¢¢
			|	ÛpowerTÝ	§§ZTYPE¢¢
			|	ÛtupleTÝ	§§seq ZTYPE¢¢
			|	ÛschemaTÝ	§§IDENT Ÿ ZTYPE¢¢.

	ÛGTYPEÝ	==	seq IDENT ¸ ZTYPE
=TEX
In the above syntax we have introduced type variables.
This is because generic constants in Z take as actual parameters sets of arbitrary types, and hence must be regarded not simply as having parameters which are sets, but as having parameters as sets of indeterminate type.
These types variables are therefore used exclusively in the types of the formal parameters of generic constants, and hence in the types of any expression which includes a reference to the formal parameters.

The introduction of a rule for $GTYPE$ recognises the existence of constants which are generic.
The identifiers in the sequence will include all those which occur in type variables in the $ZTYPE$, but not all these identifiers are bound to so occur (formal parameters need not be used).
In addition the fact that the identifiers are supplied as a sequence gives the necessary additional information about the order in which the actual parameters are to be supplied. 

A further desirable extension could be made to support generic free types, but is beyond the present scope of this document.

\subsection{the rest}

The syntax differs from the cited references in the following ways:

\begin{enumerate}
\item{}
Spivey's syntax has been translated into a set of mutually recursive free type definitions in Z.
\item{}
The data structure has been decorated with types in appropriate places, since these are essential to the translation process.
\item{}
Provision has been made for generic axiomatic definitions (see {\em axdefs}).
\item{}
Provision has been made for schema designators to be used as predicates (see {\em predsdes}).
\item{}
Various additional constructs have been introduced from \cite{spivey89}.
These are:
\begin{itemize}
\item
The precondition operator ({\em schpre}).
\item
Schema equivalence ({\em scheq}) and logical equivalence ({\em prediff}).
\item
$\Delta$ and $\Xi$ operators ($schdel$ and $schxi$).
\item
Schema composition ({\em schcomp}).
\item
Sequence displays ({\em termseq}).
\item
Schema expressions (schema designators in \cite{spivey89}, generalised to give closure under substitution) as predicates ({\em predsexp}).
\end{itemize}
\item{}
I have assumed that the type inference system will have inferred the relevant instance of a generic schema type where a theta term (or anything which is interpreted as including a theta term, e.g. a schema designator in a predicate) is used.
\item{}
The distinction between variables and constants has been introduced; variables and constants include a sequence of generic parameters (which may be empty in the case of non-generics).
\item{}
The distinct syntactic categories for terms and schema expressions (SEXP and ZTERM) have been merged.
Schema expressions, like sets, are just terms with certain types (schema types).
\item
The syntax of SPEC has been modified to permit conservative extensions to be employed.
The syntax is changed so that a $SPEC$ is associated with the introduction of given sets.
This $SPEC$ may be used to constrain the given sets, and in this case we should be able to provide support for the establishment of the consistency of the constraints.
All the other forms will also be required to be conservative, except $constr$ which cannot be non-trivial and conservative since it introduces no new objects.
The theories will clearly show which extensions are conservative and which are not.
(This is a modification to standard Z)
\end{enumerate}
¹IZ
	ÛZDECÝ		::=	ÛdecÝ		§§ZTERM ¸ ZTERM¢¢
			|	ÛdecsexpÝ	§§ZTERM ¸ DECOR¢¢

	ÛZDECLÝ	==	seq ZDEC
=TEX
¹IZ
	ÛZPREDÝ	::=	ÛpredeqÝ	§§ZTERM ¸ ZTERM¢¢
			|	ÛpredmemÝ	§§ZTERM ¸ ZTERM¢¢
			|	ÛpredtrueÝ
			|	ÛpredfalseÝ
			|	ÛprednegÝ	§§ZPRED¢¢
			|	ÛpredandÝ	§§ZPRED ¸ ZPRED¢¢
			|	ÛpredorÝ	§§ZPRED ¸ ZPRED¢¢
			|	ÛpredimpÝ	§§ZPRED ¸ ZPRED¢¢
			|	ÛprediffÝ	§§ZPRED ¸ ZPRED¢¢
			|	Û¶Ý	§§ZDECL ¸ ZPRED ¸ ZPRED¢¢
			|	Û¶%down%1Ý	§§ZDECL ¸ ZPRED ¸ ZPRED¢¢
			|	ÛµÝ	§§ZDECL ¸ ZPRED ¸ ZPRED¢¢
			|	ÛpredsexpÝ	§§ZTERM ¸ DECOR¢¢
=TEX
¹IZ
	ÛZTERMÝ	::=	ÛtermvarÝ	§§IDENT ¸ ZTYPE ¸ seq ZTERM¢¢
			|	ÛtermconÝ	§§IDENT ¸ ZTYPE ¸ seq ZTERM¢¢
			|	ÛtermseqÝ	§§seq ZTERM¢¢
			|	ÛtermsetdÝ	§§seq ZTERM¢¢
			|	ÛsetaÝ	§§ZDECL ¸ ZPRED ¸ ZTERM¢¢
			|	ÛtermtupleÝ	§§seq ZTERM¢¢
			|	ÛtermprodÝ	§§seq ZTERM¢¢
			|	ÛtermthetaÝ	§§ZTERM ¸ DECOR¢¢
			|	ÛtermselÝ	§§ZTERM ¸ IDENT¢¢
			|	ÛtermappÝ	§§ZTERM ¸ ZTERM¢¢
			|	ÛÌÝ	§§ZDECL ¸ ZPRED ¸ ZTERM¢¢
			|	ÛÍÝ	§§ZDECL ¸ ZPRED ¸ ZTERM¢¢

			|	ÛschemaÝ	§§ZDECL ¸ ZPRED¢¢
			|	ÛschdecÝ		§§ZTERM ¸ DECOR¢¢
			|	ÛschpreÝ		§§ZTERM¢¢
			|	ÛschnegÝ	§§ZTERM¢¢
			|	ÛschandÝ	§§ZTERM ¸ ZTERM¢¢
			|	ÛschorÝ		§§ZTERM ¸ ZTERM¢¢
			|	ÛschimpÝ	§§ZTERM ¸ ZTERM¢¢
			|	ÛscheqÝ		§§ZTERM ¸ ZTERM¢¢
			|	ÛschproÝ		§§ZTERM ¸ ZTERM¢¢
			|	ÛschideÝ		§§ZTERM ¸ seq IDENT¢¢
			|	Û¶%down%sÝ		§§ZDECL ¸ ZPRED ¸ ZTERM¢¢
			|	Û¶%down%1%down%sÝ	§§ZDECL ¸ ZPRED ¸ ZTERM¢¢
			|	Ûµ%down%sÝ		§§ZDECL ¸ ZPRED ¸ ZTERM¢¢
			|	ÛschdelÝ		§§ZTERM¢¢
			|	ÛschxiÝ		§§ZTERM¢¢
			|	ÛschcompÝ	§§ZTERM ¸ ZTERM¢¢
=TEX
¹IZ
	ÛIDENTÝ	==	WORD ¸ DECOR
	ÛWORDÝ	==	string
	ÛDECORÝ	==	string
=TEX

\section{SCHEMAS} \label{SCHEMAS}

Our purpose is to describe informally a mapping from Z into HOL.
This has been done by hanging informal descriptions around a partial formal definition of the mapping.
The mapping is intended to be fully systematic; our previous translations have had a more {\em ad hoc} flavour.
The systematic nature of the mapping is first apparent in the definition of the mapping of Z types into HOL types.
This follows the obvious pattern of chosing appropriate HOL representatives for the type constructors of Z and then mapping complex types in Z into similarly structured complex types in HOL.

The next most substantial departure from our previous practice, is to map those things which look like types in Z but are in fact terms denoting sets, into terms in HOL.
In our previous work we have mapped these into HOL types.
Signatures in Z are dual purpose, supplying an assignment of types to identifiers, and a predicate constraining the scope of abstraction or quantification.
This is reflected in the proposed mapping.

\subsection{Auxiliary Functions}

$º$ forms a boolean term asserting that its first argument is a member of its second.
(Note that this symbol occurs here both as a Z constant being defined, and as an HOL constant defined above)
¹IZAX
	Ûmk_optypeÝ	: FTYPE ­ FTYPE ­ FTYPE ­ FTYPE
	Ûmk_reltypeÝ	: FTYPE ­ FTYPE ­ FTYPE
÷
	µft1,ft2,ft3:TERM·

	mk_optype ft1 ft2 ft3	= mk_­_type (ft1, mk_­_type (ft2,ft3))
±	mk_reltype ft1 ft2 	= mk_optype ft1 ft2 bool_type
° 
=TEX
¹IZAX
	_ÛmemberÝ_		: TERM ­ TERM ­ TERM
	_ÛºÝ_			: TERM ­ TERM ­ TERM
	_Ûhidden_memberÝ_	: TERM ­ TERM ­ TERM
÷
	µft1,ft2:TERM·

	ft1 member ft2
	= mk_binop ft1 (mk_const (``, mk_reltype (type_of ft1) (type_of ft2))) ft2

±	ft1 º ft2
	= mk_binop ft1 (mk_const (`º`, mk_reltype (type_of ft1) (type_of ft2))) ft2

±	ft1 hidden_member ft2
	= mk_binop ft1 (mk_const (`hidden_member`, mk_reltype (type_of ft1) (type_of ft2))) ft2
=TEX
¹IZAX
	ÛNILÝ		: TYPE ­ TERM
	ÛCONSÝ		: TERM ­ TERM ­ TERM
÷
	µft1,ft2:TERM; ty:TYPE·

	NIL ty
	= mk_const(`NIL`, mk_ctype (`list`,§ty¢))

±	CONS ft1 ft2
	= mk_binop ft1 (mk_const (`CONS`,mk_optype (type_of ft1) (type_of ft2) (type_of ft2))) ft2
=TEX

{\em equals} forms a boolean term asserting that its first argument is equal to its second.

¹IZAX
	_ÛequalsÝ_	: TERM ­ TERM ­ TERM
÷
	µft1,ft2:TERM·

	ft1 equals ft2
		= mk_binop ft1 (mk_const (`=`, mk_reltype (type_of ft1) (type_of ft2) )) ft2
=TEX
{\em apply} forms an application of one Z term to another.

¹IZAX
	_ÛapplyÝ_	: TERM ­ TERM ­ TERM
÷
	µft1,ft2:TERM·

	ft1 apply ft2
		= mk_binop ft1 (mk_const (`apply`, mk_optype funtype argtype restype)) ft2

	where
	[funtype,argtype,restype:FTYPE
	|	funtype = type_of ft1
	±	argtype = type_of ft2
	±	funtype = mk_­_type(argtype,restype)]
=TEX

¹IZAX
	Ûmk_schtypeÝ	: (IDENT Ÿ ZTYPE) ­ ZTYPE
	Ûdest_schtypeÝ	: ZTYPE ß (IDENT Ÿ ZTYPE)
	Ûsexp_idtyÝ	: ZTERM ­ (IDENT Ÿ TYPE)
÷
	µitym:(IDENT Ÿ ZTYPE); sexpb:ZTERM ; zt:ZTYPE·

	dom dest_schtype	= ran mk_schtype
±	mk_schtype itym	= powerT(schemaT itym)
±	dest_schtype (powerT(schemaT itym))
				= itym
±	sexp_idty (sexpb, zt)	= dest_schtype zt » hol_mtype
=TEX

\subsubsection{name formation}

The HOL syntax given above allows an arbitrary string for the name of a type constructor, type variable, constant or individual variable.
In general the names used in the HOL are derived from WORDs and DECORs used in the Z source, but the manner of derivation must be defined.
In addition there will be a number of type constructors, type variables, and constants used in the HOL which do not correspond directly to identifiers in the source Z.

The most complex names are those associated with schema types.
An infinite family of schema type constructors is required, one for each finite set of IDENTs.
Associated with each schema type constructor there will be various constants.
The names of each of these types and constants must distinguish it from the others, and we therefore need a mapping from sets of IDENTs to strings.

¹IZAX
	Ûunpack_IDENTÝ	: string ß IDENT
	Ûpack_IDENTÝ 	: IDENT à string
÷
	pack_IDENT » unpack_IDENT = id[IDENT]
=TEX

In fact, it is usually more convenient to deal with IDENTs in their packed forms, so we will not have the type abbreviations IDENT, WORD and DECOR in the implementation but simply use strings to represent each of them.
Thus, whilst they are retained in the Z specification paragraphs, the signature boxes will use $string$ (or sometimes $string ¸ string$).

=DOC
val Ûunpack_IDENTÝ : string -> (string * string);
val Ûpack_IDENTÝ : (string * string) -> string;
=DESCRIBE
$unpack\_IDENT$ splits a string representing an IDENT into its WORD and DECOR parts.
$pack\_IDENT$ is simply string concatenation.
=FAILURE
48001	?0 is not a valid identifier
=ENDDOC

In the following definitions {\em idsetseq} is intended to sort a set of identifiers.
The ordering is immaterial and has not been specified, though it would be odd to make it other than lexicographic.
{\em flatpack} produces a comma-separated string from a sequence of strings.
It is required to be used on the empty sequence (since schemas obtained by hiding may have an empty signature).

¹IZAX
	ÛidsetseqÝ		: æ IDENT à seq IDENT
	ÛflatpackÝ		: seq string à string
÷
		(µfid: æ IDENT·
			ran (idsetseq fid) = fid)
	±	(µss:seq string; s1,s2:string·
			flatpack (§¢) = ``
		±	flatpack (§s1¢) = s1
		±	flatpack (ssë§s1¢ë§s2¢) = (flatpack (ssë§s1¢))^`,`^s2)
° 
=TEX


¹IZAX
	Ûval_setIDENTÝ	: æ IDENT à string
	ÛitymfunseqÝ		: (IDENT Ÿ TYPE) ­ seq TYPE
	Ûbool_typeÝ		: TYPE
÷
		(µfid: æ IDENT·
			ran (idsetseq fid) = fid
		±	val_setIDENT fid = `[`^(flatpack((idsetseq fid)»pack_IDENT))^`]`)
	±	(µitym:IDENT Ÿ TYPE·
			itymfunseq itym = (idsetseq (dom itym)) » itym)
	±	bool_type	= mk_ctype (`bool`,§¢)
=TEX

{\em number} maps numbers onto numerals.
¹IZAX
	ÛnumberÝ	: î à string
	Ûval_numeralÝ	: string ï î
÷
	µi:î· val_numeral (number i) = i
=TEX


It is the schema calculus which causes the greatest problems.
To support schemas it is proposed to introduce infinite families of new HOL type constructors.
For each of these types various associated constants will also be introduced.

These various types and constants are described as follows:


\subsection{Bindings and Tuples}

\subsubsection{binding types}

For each finite set of identifiers a polymorphic type constructor is required which is the type of bindings which bind values to just the identifiers in the set.
It is necessary to give each of these type constructors a unique name, which we will form by appending to the prefix $`S\_`$ the alphabetically ordered list of identifiers.
The type constructor will have the same arity as the cardinality of the set of identifiers, and the types assigned to the identifiers will be supplied as parameters to the constructor in alphabetic order of the identifiers to which they are assigned.

The type will be represented by the set of n-tuples (formed in HOL by iteration of the PAIR constructor) having the same number of components.
A sample representation type predicate is as follows:

=GFT ML
let Ûbind_type_[a,b]_predÝ = "Ìt:(*a ¸ *b)· T"
=TEX

The type $(*a,*b)S_{[a,b]}$ will be in bijection with the elements having the above property and an axiom will be needed which asserts that this is the case. 

Functions yielding the type name and the type respectively are as follows:
¹IZAX
	Ûbind_tnameÝ		: æ IDENT ­ string
	Ûbind_typeÝ		: (IDENT Ÿ TYPE) ­ TYPE
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	bind_tname fid		= `S_`^(val_setIDENT fid)
±	bind_type itym		= mk_ctype (bind_tname(dom itym), itymfunseq itym) 
° 
=TEX

=DOC
val Ûbind_typeÝ : (string * TYPE) list -> TYPE; 
=DESCRIBE
Makes a Z binding type from the supplied component to type map.
=EXAMPLE
bind_type [("a",tya),("b",tyb)] = ¬:(tya,tyb)S_[a,b]®
=ENDDOC

\subsubsection{tuple types}


¹IZAX
	Ûtuple_typeÝ	: seq TYPE ­ TYPE
÷
° 
=TEX

=DOC
val Ûtuple_typeÝ : TYPE list -> TYPE; 
=DESCRIBE
Makes a Z tuple type from the supplied type list.
=EXAMPLE
tuple_type [tya,tyb] = ¬:(tya,tyb)T_[2]®
=ENDDOC

\subsubsection{binding constructors}

For every binding type there will be a constant for constructing bindings of that type.
The name of this constructor will be formed by prefixing $`mk\_`$ to the name of the type of the binding.
The type of the constructor will be that of a curried function taking parameters whose types are type variables having the same name as the identifiers in the signature of the bindings.
The result type will be the binding type with type variables similarly named supplied as parameters,
e.g. `$mk\_S_{[a,b]}:*a ­ *b ­ (*a,*b)S_{[a,b]}$'.

The element of the representation type corresponding to the entity constructed is simply the tuple formed from the values supplied as arguments.
A sample definition for the constructor would therefore be:

=GFT HOL Constant
	ÛZ'S[a,b]Ý: *a ­ *b ­ (*a,*b)S_[a,b]
÷
	Z'S[a,b] a b = ABS_S_[a,b] (a,b)
=TEX

In general type instantiations of these constructors will be required rather than the fully polymorphic types and terms.
The functions below provide appropriate instantiations.

¹IZAX
	Ûbind_cnameÝ		: æ IDENT ­ string
	Ûbind_ctypeÝ		: (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_ctermÝ		: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	bind_cname fid	= `mk_`^(bind_tname fid)
±	bind_ctype itym	= list_mk_­_type (itymfunseq itym, bind_type itym)  
±	bind_cterm itym	= mk_const (bind_cname (dom itym), bind_ctype itym)  
° 
=TEX

These binding constructors are used in theta terms, {\em termtheta}.

=DOC
val Ûbind_ctermÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes a Z binding constructor from the supplied component to type map.
=EXAMPLE
bind_cterm [("a",tya),("b",tyb)] = ¬Z'S[a,b] : tya ­ tyb ­ (tya,tyb)S_[a,b]®
=ENDDOC

\subsubsection{tuple constructors}

The special case of tuples is also catered for:
¹IZAX
	Ûtuple_cnameÝ	: seq TYPE ­ string
	Ûtuple_ctypeÝ	: seq TYPE ­ TYPE
	Ûtuple_ctermÝ	: seq TYPE ­ TERM
÷
	µsty:seq TYPE·

	tuple_cname sty	= `Z'T[`^(number #sty)^`]`
	tuple_ctype sty		= list_mk_­_type(sty,tuple_type sty)
	tuple_cterm sty	= mk_const(tuple_cname sty,tuple_ctype sty)
° 
=TEX

=DOC
val Ûtuple_ctermÝ : TYPE list -> TERM;
=DESCRIBE
Makes a Z tuple constructor from the supplied type list.
=EXAMPLE
tuple_cterm [tya,tyb] = ¬Z'T[2] : tya ­ tyb ­ (tya,tyb)T_[2]®
=ENDDOC

\subsubsection{cartesian products}

¹IZAX
	ÛpowertÝ	: TYPE ­ TYPE
÷
	µty:TYPE·	powert ty = mk_ctype(`ð`,§t¢)
° 
=TEX

¹IZAX
	Ûprod_cnameÝ	: seq TYPE ­ string
	Ûprod_ctypeÝ	: seq TYPE ­ TYPE
	Ûprod_ctermÝ	: seq TYPE ­ TERM
÷
	µsty:seq TYPE·

	prod_cname sty	= `Z'¸[`^(number (#sty))^`]`
	prod_ctype sty		= list_mk_­_type(sty,powert(tuple_type sty))
	prod_cterm sty		= mk_const(prod_cname sty, prod_ctype sty)
=TEX

=DOC
val Ûprod_ctermÝ : TYPE list -> TERM;
=DESCRIBE
Makes a Z cartesian product constructor from the supplied type list.
=EXAMPLE
prod_cterm [tya,tyb] = ¬`Z'¸[2] : ((tya)ð,(tyb)ð)T_[2] ­ ((tya,tyb)T_[2])ð®
=ENDDOC

\subsubsection{binding projections}

For every binding type there will be a set of projection functions, which select components of the binding.
These will have names formed by concatenating the identifier of the component to be selected, and the name of the type of the binding.
The type of the projection will be a function.
The domain type of the function is the type of the binding with appropriate type variables, the co-domain is then the type variable having the same name as the component to be selected.

The following is an example of how the projection functions will be defined.

=GFT HOL Constant
	ÛZ'sel[a,b][a]Ý:(*a,*b)S_[a,b] ­ *a
	ÛZ'sel[a,b][b]Ý:(*a,*b)S_[a,b] ­ *b
÷
	(Z'sel[a,b][a] x = FST (REP_S_[a,b] x))
±	(Z'sel[a,b][b] x = SND (REP_S_[a,b] x))
=TEX

Once again the functions defined yield type instantiated terms.

¹IZAX
	Ûbind_pnameÝ		: æ IDENT		­ IDENT ­ string
	Ûbind_ptypeÝ		: (IDENT Ÿ TYPE)	­ IDENT ­ TYPE
	Ûbind_ptermÝ		: (IDENT Ÿ TYPE)	­ IDENT ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE; i:IDENT·

	bind_pname fid i	= `Z'sel` ^ (val_setIDENT fid) ^`[`^(pack_IDENT i)^`]`
±	bind_ptype itym i	= mk_­_type(bind_type itym, itym i)  
±	bind_pterm itym i	= mk_const (bind_pname (dom itym) i, bind_ptype itym i)  
° 
=TEX

The projection constants are used for selection notation {\em S.name}, in {\em termsel}

=DOC
val Ûbind_ptermÝ : (string * TYPE) list -> string -> TERM;
=DESCRIBE
Makes a Z binding projection function for the supplied component to type map; the component to be projected is supplied as the second argument.
=EXAMPLE
bind_pterm [("a",tya),("b",tyb)] "a" = ¬Z'sel[a,b][a] : (tya,tyb)S_[a,b] ­ tya®
=ENDDOC

\subsubsection{tuple projections}
\subsection{Schemas}

A schema is a set of bindings.
First we deal with schema types (which in this document are the types of schemas, but in \cite{spivey89} are the types of bindings), then with various operations on schemas which are available in Z.

As with bindings there is an infinite collection of schema types.

All the operations of the schema calculus require complete families of constants, indexed by the schema types over which they are legal.
Operations over schemas or schema expression which involve variable binding constructs are deferred to the next section.

\subsubsection{schema types}

A schema is a set of bindings, a schema type is therefore a powerset of a binding type:

¹IZAX
	Ûschema_typeÝ		: (IDENT Ÿ TYPE) ­ TYPE
÷
	µitym:IDENT Ÿ TYPE·

	schema_type itym	= mk_ctype (`ð`,§bind_type itym¢)  
° 
=TEX

=DOC
val Ûschema_typeÝ : (string * TYPE) list -> TYPE;
=DESCRIBE
Makes a Z schema type from the supplied component to type map.
=EXAMPLE
schema_type [("a",tya),("b",tyb)] = ¬:((tya,tyb)S_[a,b])ð®
=ENDDOC

Names for the operations will be formed in general by decorating the normal operation symbol by the type name of the operand or operands.

The operations are of various kinds as follows, grouped by type similarities (of which there are few!):

\subsubsection{schema negation}

Schema negation (schneg), takes any schema type to the same type.
It is semantically simply the complement operation on the set, and need not be restricted to sets of bindings.

=GFT HOL Constant
	ÛZ'³Ý	: (*)ð ­ (*)ð
÷
	µs:(*)ð·	bind_Z'³ s = ABS_ð (Ìx:*· x Ž s)
=TEX

The following definitions serve only to give type instances of the above constant:

¹IZAX
	Ûbind_³_typeÝ		: (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_³_termÝ		: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	bind_³_type itym	= mk_­_type (schema_type itym, schema_type itym)  
±	bind_³_term itym	= mk_const (`Z'³`, bind_³_type itym)  
° 
=TEX

=DOC
val Ûbind_³_termÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema negation constructor from the supplied component to type map.
=EXAMPLE
bind_³_term [("a",tya),("b",tyb)] = ¬Z'³ : ((tya,tyb)S_[a,b])ð ­ ((tya,tyb)S_[a,b])ð®
=ENDDOC

\subsubsection{schema precondition}

=GFT HOL Constant
	ÛZ'pre%down%s[a',b]Ý:((*a,*b)S_[a',b])ð ­ ((*b)S_[b])ð
÷
	µs:((*a,*b)S_[a',b])ð ·

	Z'pre%down%s[a',b] s = [b:*b|¶a':*a· s]
=TEX

The precondition operator takes a schema and existentially quantifies all the variables which are either outputs or part of the new state.
The type of the resulting schema is therefore obtained by discarding all components of the type of the constituent bindings which have identifiers ending with ' or !.

We first define separately a function which determines which of the identifiers in a binding type are the identifiers of results of the operation described by the schema.
{\em There is room for debate about whether this is the correct interpretation of \cite{spivey89}.}

¹IZAX
	Ûschema_resultsÝ	: (IDENT Ÿ TYPE) ­ æ IDENT
÷
	µitym:IDENT Ÿ TYPE·

	schema_results itym =

	{w:WORD; d,fd:DECOR; s:string
	|	(fd = `'` ² fd = `!`) ± (w^d = s^fd)
	·	(w,d)
	}	¡ (dom itym)
° 
=TEX

The type of the result of the precondition operation is the type of the original schema with the results hidden.
In fact precondition is definable in terms of hiding, but separate operators are needed to preserve the distinction for the concrete syntax.

¹IZAX
	Ûbind_pre_nameÝ	: æ IDENT ­ string
	Ûbind_pre_typeÝ	: (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_pre_termÝ	: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	bind_pre_name fid	= `Z'pre%down%s`^(val_set_IDENT fid)
±	bind_pre_type itym	= mk_­_type
				(schema_type itym,
				 schema_type ((schema_results itym)	á itym)
				)  
±	bind_pre_term itym	= mk_const (bind_pre_name (dom itym), bind_pre_type itym)  
=TEX

=DOC
val Ûbind_pre_termÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema precondition constructor from the supplied component to type map.
=EXAMPLE
bind_pre_term [("a'",tya),("b",tyb)] = ¬Z'pre%down%s[a',b] : ((tya,tyb)S_[a',b])ð ­ ((tyb)S_[b])ð®
=ENDDOC

\subsubsection{simple dyadic schema operations}

=GFT HOL Constant
	ÛZ'±%down%s[a,b][b,c]Ý:((*a,*b)S_[a,b])ð ­ ((*b,*c)S_[b,c])ð  ­ ((*a,*b,*c)S_[a,b,c])ð
÷
	µsc1:((*a,*b)S_[a,b])ð; sc2:((*b,*c)S_[b,c])ð·

	Z'±%down%s[a,b][b,c] sc1 sc2 = [a:*a; b:*b; c:*c | sc1 ± sc2]
=TEX

(schand, schor, schimp) taking any compatible pair of schema types to the schema type having the union of the components (with appropriate component types).

Since these operations are so similar they are provided by the same functions which take the particular operation name as a parameter:

¹IZAX
	Ûbind_dysc_nameÝ	: string ­ æ IDENT ­ æ IDENT ­ string
	Ûbind_dysc_typeÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_dysc_termÝ	: string ­ (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
÷
	µfid1,fid2:æ IDENT; itym1,itym2:IDENT Ÿ TYPE; n:string·

	bind_dysc_name n fid1 fid2	= n^(val_setIDENT fid1)^(val_setIDENT fid2) 
±	bind_dysc_type itym1 itym2	= list_mk_­_type
						(§schema_type itym1,schema_type itym2¢,
						schema_type (itym1 À itym2))
±	bind_dysc_term n itym1 itym2	= mk_const (bind_dysc_name n (dom itym1) (dom itym2),
							bind_dysc_type itym1 itym2)  
° 
=TEX

The following are primarily illustrative of the use of the above, and are not used in the sequel.

¹IZAX
	Ûbind_±_termÝ		: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
	Ûbind_²_termÝ		: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
	Ûbind_´_termÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
	Ûbind_¤_termÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
÷
	bind_±_term		= bind_dysc_term `Z'±%down%s` 
 	bind_²_term		= bind_dysc_term `Z'²%down%s`  
	bind_´_term		= bind_dysc_term `Z'´%down%s`  
	bind_¤_term		= bind_dysc_term `Z'¤%down%s`  
=TEX

It should be noted that the full generality of these functions will not be available in any implementation.
Only the identified operations will be supported.

=DOC
val Ûbind_±_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema conjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_±_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'±%down%s[a,b][b,c] : (((tya, tyb)S_[a,b])ð ­ ((tyb, tyc)S_[b,c])ð ­ ((tya, tyb, tyc)S_[a,b,c])ð)®
=ENDDOC

=DOC
val Ûbind_²_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema disjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_²_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'²%down%s[a,b][b,c] : (((tya, tyb)S_[a,b])ð ­ ((tyb, tyc)S_[b,c])ð ­ ((tya, tyb, tyc)S_[a,b,c])ð)®
=ENDDOC

=DOC
val Ûbind_´_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema implication constructor from the supplied component to type maps.
=EXAMPLE
bind_´_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'´%down%s[a,b][b,c] : (((tya, tyb)S_[a,b])ð ­ ((tyb, tyc)S_[b,c])ð ­ ((tya, tyb, tyc)S_[a,b,c])ð)®
=ENDDOC

=DOC
val Ûbind_¤_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema equivalence constructor from the supplied component to type maps.
=EXAMPLE
bind_¤_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'¤%down%s[a,b][b,c] : (((tya, tyb)S_[a,b])ð ­ ((tyb, tyc)S_[b,c])ð ­ ((tya, tyb, tyc)S_[a,b,c])ð)®
=ENDDOC

\subsubsection{schema projection}

=GFT HOL Constant
	ÛZ'ù%down%s[a,b][b,c]Ý:((*a,*b)S_[a,b])ð ­ ((*b,*c)S_[b,c])ð  ­ ((*b,*c)S_[b,c])ð
÷
	µsc1:((*a,*b)S_[a,b])ð; sc2:((*b,*c)S_[b,c])ð·

	Z'ù%down%s[a,b][b,c] sc1 sc2 = (sc1 ± sc2) \ (a)
=TEX

(schpro) takes two schemas of compatible types and yields a schema having the same type as the second

¹IZAX
	Ûbind_ù_nameÝ	: æ IDENT ­ æ IDENT ­ string
	Ûbind_ù_typeÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_ù_termÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
÷
	µfid1,fid2:æ IDENT; itym1,itym2:IDENT Ÿ TYPE·

	bind_ù_name fid1 fid2	= `Z'ù%down%s`^(val_setIDENT fid1)^(val_setIDENT fid2)
±	bind_ù_type itym1 itym2	= list_mk_­_type
				(	§schema_type itym1, schema_type itym2¢,
					schema_type itym2
				)  
±	bind_ù_term itym1 itym2
		= mk_const (bind_ù_name (dom itym1) (dom itym2), bind_ù_type itym1 itym2)  
° 
=TEX

=DOC
val Ûbind_ù_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema projection constructor from the supplied component to type maps.
=EXAMPLE
bind_ù_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'ù%down%s[a,b][b,c] : (((tya, tyb)S_[a,b])ð ­ ((tyb, tyc)S_[b,c])ð ­ ((tyb, tyc)S_[b,c])ð)®
=ENDDOC

\subsubsection{schema hiding}

=GFT HOL Constant
	ÛZ'hide%down%s[a,b][b]Ý:((*a,*b)S_[a,b])ð ­ ((*a)S_[a])ð
÷
	µsc:((*a,*b)S_[a,b])ð·

	Z'hide%down%s[a,b][b] sc = [a:*a | ¶b:*b· sc]
=TEX

(schide) takes one schema and a list of identifiers and yields a schema whose type is formed from the type of the first parameter by deleting all components whose identifiers are in the list.

¹IZAX
	Ûbind_hide_nameÝ	: æ IDENT ­ æ IDENT ­ string
	Ûbind_hide_typeÝ	: (IDENT Ÿ TYPE) ­ (æ IDENT) ­ TYPE
	Ûbind_hide_termÝ	: (IDENT Ÿ TYPE) ­ (æ IDENT) ­ TERM
÷
	µfid1,fid2:æ IDENT; itym:IDENT Ÿ TYPE·

	bind_hide_name fid1 fid2	= `Z'hide%down%s`^(val_setIDENT fid1)^(val_setIDENT fid2)
±	bind_hide_type itym fid2	= mk_­_type
				(	schema_type itym,
					schema_type (fid2 á itym)
				)  
±	bind_hide_term itym fid2
		= mk_const (bind_hide_name (dom itym) fid2, bind_hide_type itym fid2)  
° 
=TEX

=DOC
val Ûbind_hide_termÝ : (string * TYPE) list -> string list -> TERM;
=DESCRIBE
Makes the Z schema hiding constructor from the supplied component to type map; the components to be hidden are supplied as the second argument.
=EXAMPLE
bind_hide_term [("a",tya),("b",tyb)] ["a"] = 
	¬Z'hide%down%s[a,b][a] : (((tya, tyb)S_[a,b])ð ­ ((tyb)S_[b])ð)®
=ENDDOC

\subsubsection{decoration}

(sdes) when schema designator is used it may be supplied with further decorations.
The effect is to add the decorations to the identifiers in the bindings.
 
¹IZAX
	Ûdecor_idÝ	: string ­ IDENT ­ IDENT
	Ûdecor_idtÝ	: string ­ (IDENT ¸ TYPE) ­ (IDENT ¸ TYPE)
	Ûdecor_itymÝ	: string ­ (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE)
÷
	µs:string; w:WORD; d:DECOR; i:IDENT; ty:TYPE; itym:IDENT Ÿ TYPE· 

	decor_id s (w,d)	= (w,d^s)
± 	decor_idt s (i,ty)	= (decor_id s i,ty)
±	decor_itym s itym	= (decor_idt s) ¨itym©
° 
=TEX
¹IZAX
	Ûbind_decor_nameÝ	: æ IDENT ­ string ­ string
	Ûbind_decor_typeÝ	: (IDENT Ÿ TYPE) ­ string ­ TYPE
	Ûbind_decor_termÝ	: (IDENT Ÿ TYPE) ­ string ­ TERM
÷
	µfid:æ IDENT; s:string; itym:IDENT Ÿ TYPE·

	bind_decor_name fid s	= `Z'dec%down%s`^(val_setIDENT fid)^`[`^s^`]`
±	bind_decor_type itym s	= mk_­_type
				(	schema_type itym,
					schema_type (decor_itym s itym)
				)  
±	bind_decor_term itym s
		= mk_const (bind_decor_name (dom itym) s, bind_decor_type itym s)  
=TEX

=DOC
val Ûbind_decor_termÝ : (string * TYPE) list -> string -> TERM;
=DESCRIBE
Makes the Z schema systematic decoration constructor from the supplied component to type map; the decoration is supplied as the second argument.
=EXAMPLE
bind_decor_term [("a",tya),("b",tyb)] "'" = 
	¬Z'dec%down%s[a,b]['] : ((tya, tyb)S_[a,b])ð ­ ((tya, tyb)S_[a',b'])ð)®
=ENDDOC

\subsubsection{the delta operation}

The delta operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with ').

¹IZAX
	Ûbind_delta_nameÝ	: æ IDENT ­ string
	Ûbind_delta_typeÝ	: (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_delta_termÝ	: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	bind_delta_name fid	= `Z'„%down%s`^(val_setIDENT fid)
±	bind_delta_type itym	= mk_­_type
				(	schema_type itym,
					schema_type (itym À (decor_itym `'` itym))
				)  
±	bind_delta_term itym
		= mk_const (bind_delta_name (dom itym), bind_delta_type itym)
° 
=TEX

=DOC
val Ûbind_„_termÝ : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{the $\Xi$ operation}

The $\Xi$ operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with '), with the before and after values equated in the predicate.
The type is the same as that of the $\Delta$ operation.

¹IZAX
	Ûbind_xi_nameÝ	: æ IDENT ­ string
	Ûbind_xi_typeÝ	: (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_xi_termÝ	: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	bind_xi_name fid	= `Z'˜%down%s`^(val_setIDENT fid)
±	bind_xi_type			= bind_delta_type  
±	bind_xi_term itym
		= mk_const (bind_xi_name (dom itym), bind_xi_type itym)
° 
=TEX

=DOC
val Ûbind_˜_termÝ : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{schema composition}

Schema composition is an operation which takes two schemas as arguments.
The schemas must be compatible in the following sense.
The primed components of the first schema must match in name and type the undecorated components of the second.
Any other components common to both must have the same type.

The type of the resulting schema is obtained by merging the two signatures hiding the primed components of the first and the undecorated components of the second.
There is a problem here about exactly what ``primed'' means.
Is a double primed identifier primed?

¹IZAX
	Ûbind_scomp_nameÝ	: æ IDENT ­ æ IDENT ­ string
	Ûbind_scomp_typeÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TYPE
	Ûbind_scomp_termÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
÷
	µfid1, fid2:æ IDENT; itym1,itym2:IDENT Ÿ TYPE·

	bind_scomp_name fid1 fid2	= `Z'»%down%s`^(val_setIDENT fid1)^(val_setIDENT fid2)
±	bind_scomp_type itym1 itym2	= list_mk_­_type (
					§schema_type itym1, schema_type itym2¢,
					schema_type (
			Þ{i,i':IDENT | i'  dom itym1 ± i  dom itym2 
				± (pack_IDENT i)^`'` = (pack_IDENT i') · {i,i'}}
			á (itym1 À itym2))
±	bind_scomp_term itym1 itym2
		= mk_const (bind_scomp_name (dom itym1) (dom itym2),
			bind_scomp_type itym1 itym2)
° 
=TEX

=DOC
val Ûbind_»_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema composition constructor from the supplied component to type maps.
=EXAMPLE
bind_scomp_term [("a",tya),("b'",tyb)] [("b",tyb),("c'",tyc)] = 
	¬Z'»%down%s[a,b'][b,c'] : (((tya, tyb)S_[a,b'])ð ­ ((tyb, tyc)S_[b,c'])ð ­ ((tya, tyc)S_[a,c'])ð)®
=ENDDOC

\subsection{Variable Binding Constructs}

Take care to avoid confusion between the two distinct uses of the term {\em binding} in this document.
The {\em binding}s which are members of schemas, bind values to identifiers.
Such bindings are the values denoted by terms with a binding type (e.g. $S_{[a,b,c...]}$).
Constructs involving the syntactic category {\em DECL} also effect a binding.
In this latter case it is variables which are bound within some textual scope, for the purpose, for example, of universal quantification.
These binding constructs may yield terms, predicates or schema expressions depending on the form of the construct.

There are in Z a variety of binding constructs of this latter kind, in which a DECL occurs and serves to bind variables in following predicates or terms.

The general pattern followed in dealing with these constructs is simply an elaboration of the treatment in HOL of binders.

There is just the one primitive binding construct, viz: lambda abstraction.
All binding constructs are therefore first translated into lambda abstractions.
The result of the abstraction is then converted into the value required by the application of a constant which embodies the semantics of the particular binding construct concerned.

The image of the binding construct is therefore formed in the following way:
\begin{enumerate}
\item{}
The constituent expressions are mapped into HOL in the standard way
(in some cases the {\em characteristic tuple}, while not an explicit constituent of the syntax, must be supplied by the mapping as a component of the resulting HOL term).
\item{}
These terms are collected together into a binding.
The binding constructor will be either $mk\_S_{[d,p]}$ (for $schema$, $¶_s$, $¶_{1s}$ and $µ_s$), $mk\_S_{[d,p,v]}$ (for $¶$, $¶_1$, $µ$, $seta$ and $Í$) $mk\_S_{[t,d,p,v]}$ (for $Ì$).
\item{}
An abstraction is formed by abstracting over each of the variables declared in the constituent DECL.
\item{}
A binding operator is applied to the function thus obtained.
There will be a family of binding operators for each of the eight different binding constructs.
\end{enumerate}
The names of the binding operators will be formed from the name of the constructor in the abstract syntax by appending the sequence of names declared in the signature.
Its type will vary according to the signature and the nature of the binder.
Details are filled in below for each of the binders in turn.

\subsubsection{binding constructs by group}

Binding constructs fall into three groups, according to the scope of the bindings which take place.

The full list of binding constructs in Z is as follows:

\begin{tabular}{|l|l|l|l|}\hline
{\bf constructor} & {\bf description} & {\bf category} & {\bf group}\\ \hline
$schema$ & schema & ZTERM (schema expression) & 1\\
$¶_s$ & schema existential quantification & ZTERM (schema expression) & 1\\
$¶_{1s}$ & schema unique existential quantification & ZTERM (schema expression) & 1\\
$µ_s$ & schema universal quantification & ZTERM (schema expression) & 1\\
$¶$ & existential quantification & PRED & 2\\
$¶_1$ & unique existential quantification & PRED & 2\\
$µ$ & universal quantification & PRED & 2\\
$seta$ & set abstraction (separation) & ZTERM & 2\\
$Ì$ & lambda abstraction & ZTERM & 3\\
$Í$ & mu operator (description) & ZTERM & 2\\ \hline
\end{tabular}

In the following descriptions of how these groups of binding constructs are handled the various expressions which fall within the scope of the binding are collected together into a single expression as a schema binding (i.e. a value having a schema product or binding type).

The number of components, and therefore the signature of the binding type, varies between groups, but the significance of the identifiers used is consistently as follows:

\begin{description}
\item[t]
This component is the {\em characteristic tuple} extracted from the declaration part (DECL) of the schema.
\item[d]
This component is the predicate (a boolean term) implicit in the declaration part (DECL) of the schema.
\item[p]
This is the boolean term formed from the predicate (PRED) part of the schema.
\item[v]
This term (the value) is formed from the body of the abstraction (ZTERM or PRED).
In some cases this is defaulted to the characteristic tuple.
\end{description}

\subsubsection{group 1 packs}

In the simplest case (group 1) the variables are bound only in the immediately following predicate (and even this may be omitted in the concrete syntax).
i.e. in schema, $¶_s$, $¶_{1s}$, and $µ_s$, the variables declared in the DECL are bound only in the following PRED.

The following functions yield schema product or binding constructors which are appropriate for collecting together the elements within the scope of a group 1 construct.
In group 1 there are just two constituents, the first of which corresponds to the predicate implicit in the DECL, the second corresponding to the explicit predicate (PRED) following the vertical bar.
These are given component identifiers {\em d} and {\em p} respectively.

¹IZAX
	Ûg1_bind_sigÝ	: string Ÿ TYPE
	Ûg1_bind_ctypeÝ	: TYPE
	Ûg1_bind_ctermÝ	: TERM
	Ûg1_bind_typeÝ	: TYPE
÷
		g1_bind_sig		=	{
					`d`íbool_type,
					`p`íbool_type}

	±	g1_bind_ctype	= bind_ctype g1_bind_sig
	±	g1_bind_cterm	= bind_cterm g1_bind_sig
	±	g1_bind_type	= bind_type g1_bind_sig
° 
=TEX

\subsubsection{group 2 packs}

In the next case (group 2) a predicate or term follows, within which the relevant variables are also bound.
This is the ZTERM or PRED following the bullet.
This more complex case includes constructs $¶$, $¶_1$, $µ$, $seta$ and $Í$.
A ZTERM may be omitted in the concrete syntax, in which case the characteristic tuple will be used.
This substitution we presume at present to be undertaken by the parser/type-inference system.

¹IZAX
	Ûg2_bind_sigÝ	: TYPE ­ (string Ÿ TYPE)
	Ûg2_bind_ctypeÝ	: TYPE ­ TYPE
	Ûg2_bind_ctermÝ	: TYPE ­ TERM
	Ûg2_bind_typeÝ	: TYPE ­ TYPE
÷
	µty:TYPE·

		g2_bind_sig ty	=	{
					`d`íbool_type,
					`p`íbool_type,
					`v`íty}

	±	g2_bind_ctype ty	= bind_ctype (g2_bind_sig ty)
	±	g2_bind_cterm ty	= bind_cterm (g2_bind_sig ty)
	±	g2_bind_type ty	= bind_type (g2_bind_sig ty)
=TEX

\subsubsection{group 3 packs}

The last case is that of the lambda abstraction which forms group 3.
In this case the characteristic tuple has a role to play even if a term is supplied following the bullet, and is therefore given an identifier of its own.

¹IZAX
	Ûg3_bind_sigÝ	: TYPE ­ TYPE ­ (string Ÿ TYPE)
	Ûg3_bind_ctypeÝ	: TYPE ­ TYPE ­ TYPE
	Ûg3_bind_ctermÝ	: TYPE ­ TYPE ­ TERM
	Ûg3_bind_typeÝ	: TYPE ­ TYPE ­ TYPE
÷
	µty1,ty2:TYPE·

		g3_bind_sig ty1 ty2	=	{
					`d`íbool_type,
					`p`íbool_type,
					`t`íty1,
					`v`íty2}

	±	g3_bind_ctype ty1 ty2	= bind_ctype (g3_bind_sig ty1 ty2)
	±	g3_bind_cterm ty1 ty2	= bind_cterm (g3_bind_sig ty1 ty2)
	±	g3_bind_type ty1 ty2	= bind_type (g3_bind_sig ty1 ty2)
=TEX

In the following sections we supply for each variable binding construct:
\begin{enumerate}
\item{}
a verbal description of how it is mapped into HOL,
\item{}
a sample HOL-like definition of one of the binders in each family, showing both the type and the value (as an HOL term) of the binder,
\item{and}
a formal Z specification of functions which compute the binding constant.
\end{enumerate}

In the HOL-like sample definitions the Z dot notation is used as shorthand for the application of the relevant projection function.
The samples are generic in the types assigned to the identifiers in the signature, but are shown for specific signatures.
In these examples the schema types $S_{[d,p]}, S_{[d,p,v]}, S_{[t,d,p,v]}$ are fixed binding types used for packaging the two three or four components over which the abstraction is to be formed.

\subsubsection{bindings yielding schema expressions}

Variable binding in schema expressions occurs in schemas and in existential and universal quantification.
In its use in quantifiers the schema expression which follows the binding is not within its scope, i.e. the names in the signature are not bound in the schema expression forming the body of the construct.
For this reason, in contrast to all the other binding constructs, this schema expression is not included in the package over which the variables in the signature have been abstracted.
It is supplied as a second argument to the binding constant (which is a curried function).
This can be seen clearly by referring to the type of the binders in the following sections.

\subsubsection{schemas}

The simplest binding construct is that which simply yields a schema.
The following HOL constant is a sample of the infinite family of constants required: 

=GFT HOL Constant
	ÛZ'%down%s[a,b]Ý	: (*a ­ *b ­ (bool,bool)S_[d,p]) ­ ((*a,*b)S_[a,b])ð
÷
	(Z'%down%s[a,b] p
		=	ABS_ð(Ìx:S_[a,b]·
				let	t = p  x.a  x.b
				in	t.d  ±  t.p))

=TEX

We now specify functions which compute from the elements of the abstract syntax the name, type and term of the binding operators:

¹IZAX
	Ûschema_bnameÝ	: (æ IDENT) ­ string
	Ûschema_btypeÝ	: (IDENT Ÿ TYPE) ­ TYPE
	Ûschema_btermÝ	: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	schema_bname fid	= `Z'%down%s`^(val_setIDENT fid)
±	schema_btype itym	= mk_­_type(
		list_mk_­_type ((itymfunseq itym), g1_bind_type),
		schema_type itym
					)
±	schema_bterm itym	= mk_const (schema_bname (dom itym), schema_btype itym)
° 
=TEX

=DOC
val Ûschema_btermÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema constructor from the supplied component to type map.
=EXAMPLE
schema_bterm [("a",tya),("b",tyb)] = ¬Z'%down%s[a,b] : ((tya ­ tyb ­ (bool, bool)S_[d,p]) ­ ((tya, tyb)S_[a,b])ð)®
=ENDDOC

\subsubsection{schema existential quantification}

=GFT HOL Constant
	ÛZ'¶%down%s[a,b][c,d]Ý	:
		(*a ­ *b ­ (bool,bool)S_[d,p]) ­ ((*a,*b,*c,*d)S_[a,b,c,d])ð ­ ((*c,*d)S_[c,d])ð
÷
	(Z'¶%down%s[a,b][c,d] p q
		= 	ABS_ð(Ìx:S_[c,d]· ¶y:S_[a,b]·
				let	t = p  y.a  y.b
				in	t.d  ±  t.p
					± (Z'S[a,b,c,d]  y.a  y.b  x.c  x.d)  q))
=TEX

¹IZAX
	Û¶%down%s_bnameÝ	: (æ IDENT) ­ (æ IDENT) ­ string
	Û¶%down%s_btypeÝ		: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TYPE
	Û¶%down%s_btermÝ		: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
÷
	µfid1,fid2:æ IDENT; itym1,itym2:IDENT Ÿ TYPE·

	¶%down%s_bname fid1 fid2
		= `Z'¶%down%s`^(val_setIDENT fid1)^(val_setIDENT (fid2\fid1))
±	¶%down%s_btype itym1 itym2
		= list_mk_­_type
			(§ list_mk_­_type ((itymfunseq itym1), g1_bind_type),
				schema_type itym2 ¢,
			(schema_type (itym2\itym1)))
±	¶%down%s_bterm itym1 itym2
		= mk_const (¶%down%s_bname (dom itym1) (dom itym2),
				¶%down%s_btype itym1 itym2)
° 
=TEX

=DOC
val Û¶%down%s_btermÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema existential quantification constructor from the supplied component to type maps.
=EXAMPLE
¶%down%s_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
¬Z'¶%down%s[a,b][c,d] : ((tya ­ tyb ­ (bool,bool)S_[d,p]) ­ ((tya,tyb,tyc,tyd)S_[a,b,c,d])ð ­ ((tyc,tyd)S_[c,d])ð)®
=ENDDOC

\subsubsection{schema unique existential quantification}

=GFT HOL Constant
	ÛZ'¶%down%1%down%s[a,b][c,d]Ý	:
		(*a ­ *b ­ (bool,bool)S_[d,p]) ­ ((*a,*b,*c,*d)S_[a,b,c,d])ð ­ ((*c,*d)S_[c,d])ð
÷
	(Z'¶%down%1%down%s[a,b][c,d] p q
		= 	ABS_ð(Ìx:S_[c,d]· ¶‰1y:S_[a,b]·
				let	t = p  y.a  y.b
				in	t.d  ±  t.p
					± (Z'S[a,b,c,d]  y.a  y.b  x.c  x.d)  q))
=TEX

¹IZAX
	Û¶%down%1%down%s_bnameÝ		: (æ IDENT) ­ (æ IDENT) ­ string
	Û¶%down%1%down%s_btypeÝ		: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TYPE
	Û¶%down%1%down%s_btermÝ		: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
÷
	µfid1,fid2:æ IDENT; itym1,itym2:IDENT Ÿ TYPE·

	¶%down%1%down%s_bname fid1 fid2
		= `Z'¶%down%1%down%s`^(val_setIDENT fid1)^(val_setIDENT (fid2\fid1))
±	¶%down%1%down%s_btype 
		= ¶%down%s_btype
±	¶%down%1%down%s_bterm itym1 itym2
		= mk_const (¶%down%1%down%s_bname (dom itym1) (dom itym2),
				¶%down%1%down%s_btype itym1 itym2)
° 
=TEX

=DOC
val Û¶%down%1%down%s_btermÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema unique existential quantification constructor from the supplied component to type maps.
=EXAMPLE
¶%down%1%down%s_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
¬Z'¶%down%1%down%s[a,b][c,d] : ((tya ­ tyb ­ (bool,bool)S_[d,p]) ­ ((tya,tyb,tyc,tyd)S_[a,b,c,d])ð ­ ((tyc,tyd)S_[c,d])ð)®
=ENDDOC

\subsubsection{schema universal quantification}

=GFT HOL Constant
	ÛZ'µ%down%s[a,b][c,d]Ý	:
		(*a ­ *b ­ (bool,bool)S_[d,p]) ­ ((*a,*b,*c,*d)S_[a,b,c,d])ð ­ ((*c,*d)S_[c,d])ð
÷
	(Z'µ%down%s[a,b][c,d] p q
		=	ABS_ð(Ìx:S_[c,d]· µy:S_[a,b]·
				let	t = p  y.a  y.b
				in	t.d  ±  t.p
					´ (Z'S[a,b,c,d] y.a y.b x.c x.d)  q))
=TEX

¹IZAX
	Ûµ%down%s_bnameÝ	: (æ IDENT) ­ (æ IDENT) ­ string
	Ûµ%down%s_btypeÝ		: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TYPE
	Ûµ%down%s_btermÝ	: (IDENT Ÿ TYPE) ­ (IDENT Ÿ TYPE) ­ TERM
÷
	µfid1,fid2:æ IDENT; itym1,itym2:IDENT Ÿ TYPE·

	µ%down%s_bname fid1 fid2
		= `Z'µ%down%s`^(val_setIDENT fid1)^(val_setIDENT (fid2\fid1))
±	µ%down%s_btype itym1 itym2
		= list_mk_­_type
			(§ list_mk_­_type ((itymfunseq itym1), g1_bind_type),
				schema_type itym2 ¢,
			(schema_type (itym2\itym1)))
±	µ%down%s_bterm itym1 itym2
		= mk_const (µ%down%s_bname (dom itym1) (dom itym2),
				µ%down%s_btype itym1 itym2)
° 
=TEX

=DOC
val Ûµ%down%s_btermÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema universal quantification constructor from the supplied component to type maps.
=EXAMPLE
µ%down%s_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
¬Z'µ%down%s[a,b][c,d] : ((tya ­ tyb ­ (bool,bool)S_[d,p]) ­ ((tya,tyb,tyc,tyd)S_[a,b,c,d])ð ­ ((tyc,tyd)S_[c,d])ð)®
=ENDDOC

\subsubsection{existential quantification}

=GFT HOL Constant
	ÛZ'¶[2]Ý	:
		(*1 ­ *2 ­ (bool,bool,bool)S_[d,p,v]) ­ bool
÷
	(Z'¶[2] p
		=	¶(x:*1)(y:*2)· let t = p x y in	t.d ± t.p ± t.v)
=TEX

¹IZAX
	Û¶_bnameÝ	: (æ IDENT) ­ string
	Û¶_btypeÝ	: (IDENT Ÿ TYPE) ­ TYPE
	Û¶_btermÝ	: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	¶_bname fid
		= `Z'¶[`^(number(length fid))^`]`
±	¶_btype itym
		= mk_­_type
			(list_mk_­_type ((itymfunseq itym), g2_bind_type bool_type),
					bool_type)
±	¶_bterm itym
		= mk_const (¶_bname (dom itym), ¶_btype itym)
° 
=TEX

=DOC
val Û¶_btermÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z existential quantification constructor from the supplied component to type map.
=EXAMPLE
¶_bterm [("a",tya),("b",tyb)] = 
¬Z'¶[2] : ((tya ­ tyb ­ (bool,bool,bool)S_[d,p,v]) ­ bool)®
=ENDDOC

\subsubsection{unique existential quantification}

=GFT HOL Constant
	ÛZ'¶%down%1[2]Ý	:
		(*1 ­ *2 ­ (bool,bool,bool)S_[d,p,v]) ­ bool
÷
	(Z'¶%down%1[2] p
		=	¶‰1(x:*1)(y:*2)· let t = p x y in	t.d ± t.p ± t.v)
=TEX

¹IZAX
	Û¶%down%1_bnameÝ	: (æ IDENT) ­ string
	Û¶%down%1_btypeÝ	: (IDENT Ÿ TYPE) ­ TYPE
	Û¶%down%1_btermÝ	: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	¶%down%1_bname fid
		= `Z'¶%down%1[`^(number(length fid))^`]`
±	¶%down%1_btype
		= ¶_btype
±	¶%down%1_bterm itym
		= mk_const (¶%down%1_bname (dom itym), ¶%down%1_btype itym)
° 
=TEX

=DOC
val Û¶%down%1_btermÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z unique existential quantification constructor from the supplied component to type map.
=EXAMPLE
¶%down%1_bterm [("a",tya),("b",tyb)] = 
¬Z'¶%down%1[2] : ((tya ­ tyb ­ (bool,bool,bool)S_[d,p,v]) ­ bool)®
=ENDDOC

\subsubsection{universal quantification}

=GFT HOL Constant
	ÛZ'µ[2]Ý	:
		(*1 ­ *2 ­ (bool,bool,bool)S_[d,p,v]) ­ bool
÷
	(Z'µ[2] p
		=	µ(x:*1)(y:*2)· let t = p x y in	t.d ± t.p ´ t.v)
=TEX

¹IZAX
	Ûµ_bnameÝ	: (æ IDENT) ­ string
	Ûµ_btypeÝ	: (IDENT Ÿ TYPE) ­ TYPE
	Ûµ_btermÝ	: (IDENT Ÿ TYPE) ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE·

	µ_bname fid
		= `Z'µ[`^(number(length fid))^`]`
±	µ_btype itym
		= mk_­_type
			(list_mk_­_type ((itymfunseq itym), g2_bind_type bool_type),
					bool_type)
±	µ_bterm itym
		= mk_const (µ_bname (dom itym), µ_btype itym)
° 
=TEX

=DOC
val Ûµ_btermÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z universal quantification constructor from the supplied component to type map.
=EXAMPLE
µ_bterm [("a",tya),("b",tyb)] = 
¬Z'µ[2] : ((tya ­ tyb ­ (bool,bool,bool)S_[d,p,v]) ­ bool)®
=ENDDOC

\subsubsection{set abstraction}

=GFT HOL Constant
	ÛZ'seta[2]Ý	:
		(*1 ­ *2 ­ (bool,bool,*v)S_[d,p,v]) ­ (*v)ð
÷
	(Z'seta[2] p
		=	ABS_ð(Ìx:*v· ¶(y:*1) (z:*2)·
				let t = p y z in	t.d ± t.p ± (t.v = x))
=TEX

¹IZAX
	Ûseta_bnameÝ	: (æ IDENT) ­ string
	Ûseta_btypeÝ	: (IDENT Ÿ TYPE) ­ TYPE ­ TYPE
	Ûseta_btermÝ	: (IDENT Ÿ TYPE) ­ TYPE ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE; ty:TYPE·

	seta_bname fid
		= `Z'seta[`^(number(length fid))^`]`
±	seta_btype itym ty
		= mk_­_type
			(list_mk_­_type ((itymfunseq itym), g2_bind_type ty),
					mk_ctype (`ð`,§ty¢))
±	seta_bterm itym ty
		= mk_const (seta_bname (dom itym), seta_btype itym ty)
° 
=TEX

=DOC
val Ûseta_btermÝ : (string * TYPE) list -> TYPE -> TERM;
=DESCRIBE
Makes the Z set comprehension constructor from the supplied component to type map.
The type of the members of the resulting set is supplied as the second argument.
=EXAMPLE
seta_bterm [("a",tya),("b",tyb)] tyv = 
¬Z'seta[2] : ((tya ­ tyb ­ (bool,bool,tyv)S_[d,p,v]) ­ (tyv)ð)®
=ENDDOC

\subsubsection{lambda abstraction}

=GFT HOL Constant
	ÛZ'Ì[2]Ý	:
		(*1 ­ *2 ­ (bool,bool,*dv,*cv)S_[d,p,t,v]) ­ ((*dv,*cv)S_[1,2])ð
÷
	(Z'Ì[2] p
		=	ABS_ð(Ìx:(*dv,*cv)S_[1,2]· ¶(y:*1) (z:*2)·
				let	t = p y z
				in	t.d ± t.p ± (t.t = x.1 ± t.v = x.2))
=TEX

¹IZAX
	ÛÌ_bnameÝ	: (æ IDENT) ­ string
	ÛÌ_btypeÝ	: (IDENT Ÿ TYPE) ­ TYPE ­ TYPE ­ TYPE
	ÛÌ_btermÝ	: (IDENT Ÿ TYPE) ­ TYPE ­ TYPE ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE; d_ty,c_ty:TYPE·

	Ì_bname fid
		= `Z'Ì[`^(number(length fid))^`]`
±	Ì_btype itym d_ty c_ty
		= mk_­_type
			(list_mk_­_type ((itymfunseq itym), g3_bind_type d_ty c_ty),
					mk_ctype(`ð`,§mk_tuple_type §d_ty,c_ty¢¢))
±	Ì_bterm itym d_ty c_ty
		= mk_const (Ì_bname (dom itym), Ì_btype itym d_ty c_ty)
° 
=TEX

=DOC
val ÛÌ_btermÝ : (string * TYPE) list -> TYPE -> TYPE -> TERM;
=DESCRIBE
Makes the Z lambda abstraction constructor from the supplied component to type map.
The types of the domain (characteristic tuple) and range of the resulting function are supplied as the second and third arguments respectively.
=EXAMPLE
Ì_bterm [("a",tya),("b",tyb)] tyt tyv = 
¬Z'Ì[2] : ((tya ­ tyb ­ (bool,bool,tyt,tyv)S_[d,p,t,v]) ­ ((tyt,tyv)T_2)ð)®
=ENDDOC

\subsubsection{definite description}

=GFT HOL Constant
	ÛZ'Í[2]Ý		:
		(*1 ­ *2 ­ (bool,bool,*cv)S_[d,p,v]) ­ *cv
÷
	(Z'Í[2] p
		=	Í(Ìx:*cv· ¶(y:*1) (z:*2)·
				let	t = p y z
				in	t.d ± t.p ± (t.v = x)))
=TEX

Note that the above definition relies upon $Í$ being defined as definite description rather than choice in HOL.
 
¹IZAX
	ÛÍ_bnameÝ	: (æ IDENT) ­ string
	ÛÍ_btypeÝ	: (IDENT Ÿ TYPE) ­ TYPE ­ TYPE
	ÛÍ_btermÝ	: (IDENT Ÿ TYPE) ­ TYPE ­ TERM
÷
	µfid:æ IDENT; itym:IDENT Ÿ TYPE; ty:TYPE·

	Í_bname fid
		= `Z'Í[`^(number(length fid))^`]`
±	Í_btype itym ty
		= mk_­_type
			(list_mk_­_type ((itymfunseq itym), g2_bind_type ty),
					ty)
±	Í_bterm itym ty
		= mk_const (Í_bname (dom itym), Í_btype itym ty)
° 
=TEX

=DOC
val ÛÍ_btermÝ : (string * TYPE) list -> TYPE -> TERM;
=DESCRIBE
Makes the Z definite description constructor from the supplied component to type map.
The type of the result is supplied as the second argument.
=EXAMPLE
Í_bterm [("a",tya),("b",tyb)] tyv = 
¬Z'Í[2] : ((tya ­ tyb ­ (bool,bool,tyv)S_[d,p,v]) ­ tyv)®
=ENDDOC

\subsection{Computing the Abstractions}

For each of the three groups of abstraction we define a function which constructs the abstraction to which the binding operator will be applied.
The process of abstraction over each of the names in the signature is common to these three functions and is defined first.

¹ [A,B]
	ÛzipÝ		: (seq A) ­ (A Ÿ B) ­ seq (A ¸ B)
÷
	µseqa:seq A; a:A; m:A Ÿ B·

	zip §¢ m			= §¢
±	zip seqaë§a¢ m	= (zip seqa m)ë§(a, m a)¢
° 
=TEX

¹IZAX
	Ûschema_absÝ	: (IDENT Ÿ TYPE) ­ TERM ­ TERM
÷
	µitym:IDENT Ÿ TYPE; ft:TERM·

	schema_abs itym ft
		= list_mk_simple_Ì
				(zip ((idsetseq » pack_IDENT)(dom itym)) stym,
				ft)

		where
		[stym:string Ÿ TYPE | pack_IDENT » stym = itym]
=TEX

\subsubsection{forming the abstractions}

In the following sections the variable names are using in the following way:

\begin{description}
\item[ft1]
characteristic tuple
\item[ft2]
declaration
\item[ft3]
predicate
\item[ft4]
body
\item[ty1]
characteristic tuple type
\item[ty2]
body type
\item[itym]
type map assigning types to identifiers in signature
\end{description}

\subsubsection{group 1 abstractions}
¹IZAX
	Ûg1_absÝ	: (TERM ¸ TERM ¸ (IDENT Ÿ TYPE)) ­ TERM
÷
	µft2,ft3:TERM; itym:IDENT Ÿ TYPE·

	g1_abs (ft2,ft3,itym)	= schema_abs itym (list_mk_app (g1_bind_cterm,§ft2,ft3¢))
=TEX

=DOC
val Ûg1_absÝ : TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\subsubsection{group 2 abstractions}
¹IZAX
	Ûg2_absÝ	: (TERM ¸ TERM ¸ TERM ¸ (IDENT Ÿ TYPE)) ­ TERM
÷
	µft2, ft3, ft4:TERM; ty2:TYPE; itym:IDENT Ÿ TYPE·

	g2_abs (ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_app (g2_bind_cterm (type_of ft4), §ft2, ft3, ft4¢))
° 
=TEX

=DOC
val Ûg2_absÝ : TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\subsubsection{group 3 abstractions}
¹IZAX
	Ûg3_absÝ
	: (TERM ¸ TERM ¸ TERM ¸ TERM ¸ (IDENT Ÿ TYPE)) ­ TERM
÷
	µft1, ft2, ft3, ft4:TERM; ty1, ty2:TYPE; itym:IDENT Ÿ TYPE·

	g3_abs (ft1, ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_app (g3_bind_cterm (type_of ft1) (type_of ft4), §ft2, ft3, ft1, ft4¢))
° 
=TEX

=DOC
val Ûg3_absÝ : TERM * TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\section{END OF SIGNATURE}
=SML
end (* end of icl'ZTypesAndTerms signature *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


