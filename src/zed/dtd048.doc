=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Support for Z Types and Terms}
\TPPref{DS/FMU/IED/DTD048}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document provides a detailed design for a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/DTD047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the corresponding implementation document is \cite{DS/FMU/IED/IMP048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{?} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intercepted and reported as helpfully as possible.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{SIGNATURE}
=DOC
signature ‚ZAbstractMachineSupport· = sig
=DESCRIBE
The Z Abstract Machine support functions are packaged into this signature.
=ENDDOC
\section{THE ABSTRACT SYNTAX OF HOL TYPES AND ZTERMS} \label{TYPESANDZTERMS}

\subsection{Types}

We reproduce here for convenience the definitions relating to HOL types from \cite{DS/FMU/IED/ZED001}.

Ë
›	[‚char·]
Ê

Ë
›	‚string· == seq char
Ê

We define constructors for abstract HOL types.

Ë
	‚TYPE· ::=		‚mk_vartype·	ææ string øø
			|	‚mk_ctype·	ææ string â seq TYPE øø
Ê
A discriminator and destructors.
Ë
	‚is_vartype_·	: ë TYPE
	‚dest_vartype·	: TYPE ñ string
	‚dest_ctype·	: TYPE ñ (string â seq TYPE)
…
	És:string; ty:TYPE; sty:seq TYPEé

	(is_vartype (mk_vartype s))
	å (is_vartype (mk_ctype (s, sty)))

	dom(dest_vartype) = is_vartype
	dom(dest_ctype) = TYPE \ is_vartype

	dest_vartype(mk_vartype s) = s
	dest_ctype(mk_ctype(s, sty)) = (s, sty)
Ê

\subsection{Terms}

The definitions of the type {\it TERM} are complicated by the well formedness constraints imposed in \cite{DS/FMU/IED/ZED001}.
{\em pro-tem} we introduce {\em TERM} as a given set, and give under-specifications of the constructors.
Ë
›	[‚TERM·]
Ê
Here we show just the signatures of the relevant functions.
Ë
	‚mk_var·	:(string â TYPE) ã TERM
›	‚mk_const·	:(string â TYPE) ã TERM
›	‚mk_app·	:(TERM â TERM) ñ TERM
›	‚mk_abs·	:(TERM â TERM) ñ TERM
	‚is_var_·, ‚is_const_·, ‚is_app_·, ‚is_abs_·	:ë TERM
	‚dest_var·	: TERM ã (string â TYPE)
›	‚dest_const·	:TERM ã (string â TYPE)
›	‚dest_app·	:TERM ã (TERM â TERM)
›	‚dest_abs·	:TERM ã (TERM â TERM)
…
	is_var	= ran(mk_var)	= dom(dest_var)
	is_const	= ran(mk_const)	= dom(dest_const)
	is_app	= ran(mk_app)	= dom(dest_app)
	is_abs	= ran(mk_abs)	= dom(dest_abs)
	mk_var œ dest_var	= id[is_var]
	mk_const œ dest_const	= id[is_const]
	mk_app œ dest_app	= id[is_app]
	mk_abs œ dest_abs	= id[is_abs]
Ê

\subsection{Derived HOL Syntactic Constructors}

Í
	‚mk_ã_type·	: TYPE ã TYPE ã TYPE
…
	Éd,c:TYPEé

	mk_ã_type d c 	= mk_ctype(`ã`,æd,cø)
À

Í
	‚Z_type·	: TYPE
	‚mk_list_type·	: TYPE ã TYPE
	‚mk_set_type·	: TYPE ã TYPE
	‚mk_seq_type·	: TYPE ã TYPE
…
	Ét:TYPEé

	Z_type	= mk_ctype (`Z`, æø)
	mk_list_type t 	= mk_ctype(`list`,ætø)
	mk_set_type t 	= mk_ctype(`ë`,ætø)
	mk_seq_type t 	= mk_set_type (mk_tuple_typeæZ_type,tø)
À

Í
	‚list_mk_ã_type·		: (seq TYPE â TYPE) ã TYPE
	‚list_mk_simple_ç·		: (seq (string â TYPE) â TERM) ã TERM
	‚list_mk_app·	: (TERM â seq TERM) ã TERM
…
	Éty,ty1,ty2:TYPE; tm,tm1,tm2:TERM;
		stm:seq TERM; sty:seq TYPE; ssty:seq(string â TYPE); s:stringé
 
	list_mk_ã_type (æø, ty)			= ty
Ä	list_mk_ã_type (styµæty1ø,ty2)		= list_mk_ã_type(sty,mk_ã_type(ty1,ty2))

Ä	list_mk_simple_ç (æø, tm)			= tm
Ä	list_mk_simple_ç (sstyµæ(s,ty)ø, tm)	= list_mk_simple_ç(ssty, mk_simple_ç(s,ty,t))

Ä	list_mk_app (tm, æø)			= tm
Ä	list_mk_app (tm1, ætm2øµstm)	= list_mk_app(mk_app (tm1,tm2), stm)
À

Í
	‚mk_binop·	: TERM ã TERM ã TERM ã TERM
…
	Éft1,ft2,ft3:TERMé

	mk_binop ft1 ft2 ft3 = mk_app(mk_app(ft1,ft2),ft3)
À

\subsection{New HOL Constants}
\subsubsection{power set type constructor}

The power set type constructor ë must be defined, together with its abstraction function:

ÛHOL Constant
	ABS_ë : (*a ã bool) ã (*a)ë
…
	T
Ê
and its inverse (modulo order of arguments), the membership relation:

ÛHOL Constant
	ù : *a ã *a ë ã bool
…
	T
Ê
a second constant which means exactly the same as membership is also required for use in the predicate implicit in a declaration:
ÛHOL Constant
	∫ : *a ã *a ë ã bool
…
	∫ = ù
Ê
and yet another rendition of membership is required for the invisible membership assertions which occur when a schema designator is used as a predicate:
ÛHOL Constant
	hidden_membership : *a ã *a ë ã bool
…
	hidden_membership = ù
Ê
=IGN
\subsubsection{partial elements}

A new 1-ary type constructor $ZTERM$ is required to introduce an undefined element.
The representation type for $ZTERM(*)$ will be $*+one$.
=TEX
\subsection{HOL lists}

Constants enabling the formation and use of lists of terms:
ÛHOL Constant
	NIL		: (*a)list
	CONS		: *a ã (*a)list ã (*a)list
	contains	: (*a)list ã *a ã bool
…
	(contains NIL x = F)
Ä	(contains (CONS x y) x)
Ä	(contains y x ä contains (CONS z y) x)
Ê
Function application in Z:
ÛHOL Constant
	apply	: (*a â *b)ë ã *a ã *b
…
	Éx:*aé (¿ y:*bé (x,y) ù f) ä (x, apply f x) ù f
Ê

\section{THE ABSTRACT SYNTAX OF Z} \label{ZSYNTAX}

We need some definition of the sort of data structure which we might expect to obtain from a Z syntax and type checker, so that we may consider how this can be related to the abstract syntax of HOL to enable mapping of Z into HOL terms.
In default of any more definitive information I have adapted the syntax from \cite{spivey88} and \cite{spivey89}.
The differences between these two references are that the former provides a more abstract syntax, simplified by avoiding issues such as operator precedences, and omits some features to simplify the semantics, e.g. schema designators as predicates, and generic constants.
For our present purposes an abstract syntax is required, but no features of the language should be omitted.

The syntax thus obtained has now been subject to various modifications which bring it closer into line with the structures known to be required for representing Z in HOL


\subsection{types}

The abstract syntax fails to take account of genericity.
It will be convenient in giving an account of how to deal with genericity to have an augmented abstract syntax for types as follows (the name has been changed to prevent a clash with the HOL types):
Ë
	‚ZTYPE·	::=	‚givenT·	ææIDENTøø
			|	‚varT·		ææIDENTøø
			|	‚powerT·	ææZTYPEøø
			|	‚tupleT·	ææseq ZTYPEøø
			|	‚schemaT·	ææIDENT ú ZTYPEøø.

	‚GTYPE·	==	seq IDENT â ZTYPE
Ê
In the above syntax we have introduced type variables.
This is because generic constants in Z take as actual parameters sets of arbitrary types, and hence must be regarded not simply as having parameters which are sets, but as having parameters as sets of indeterminate type.
These types variables are therefore used exclusively in the types of the formal parameters of generic constants, and hence in the types of any expression which includes a reference to the formal parameters.

The introduction of a rule for $GTYPE$ recognises the existence of constants which are generic.
The identifiers in the sequence will include all those which occur in type variables in the $ZTYPE$, but not all these identifiers are bound to so occur (formal parameters need not be used).
In addition the fact that the identifiers are supplied as a sequence gives the necessary additional information about the order in which the actual parameters are to be supplied. 

A further desirable extension could be made to support generic free types, but is beyond the present scope of this document.

\subsection{the rest}

The syntax differs from the cited references in the following ways:

\begin{enumerate}
\item{}
Spivey's syntax has been translated into a set of mutually recursive free type definitions in Z.
\item{}
The data structure has been decorated with types in appropriate places, since these are essential to the translation process.
\item{}
Provision has been made for generic axiomatic definitions (see {\em axdefs}).
\item{}
Provision has been made for schema designators to be used as predicates (see {\em predsdes}).
\item{}
Various additional constructs have been introduced from \cite{spivey89}.
These are:
\begin{itemize}
\item
The precondition operator ({\em schpre}).
\item
Schema equivalence ({\em scheq}) and logical equivalence ({\em prediff}).
\item
$\Delta$ and $\Xi$ operators ($schdel$ and $schxi$).
\item
Schema composition ({\em schcomp}).
\item
Sequence displays ({\em termseq}).
\item
Schema expressions (schema designators in \cite{spivey89}, generalised to give closure under substitution) as predicates ({\em predsexp}).
\end{itemize}
\item{}
I have assumed that the type inference system will have inferred the relevant instance of a generic schema type where a theta term (or anything which is interpreted as including a theta term, e.g. a schema designator in a predicate) is used.
\item{}
The distinction between variables and constants has been introduced; variables and constants include a sequence of generic parameters (which may be empty in the case of non-generics).
\item{}
The distinct syntactic categories for terms and schema expressions (SEXP and ZTERM) have been merged.
Schema expressions, like sets, are just terms with certain types (schema types).
\item
The syntax of SPEC has been modified to permit conservative extensions to be employed.
The syntax is changed so that a $SPEC$ is associated with the introduction of given sets.
This $SPEC$ may be used to constrain the given sets, and in this case we should be able to provide support for the establishment of the consistency of the constraints.
All the other forms will also be required to be conservative, except $constr$ which cannot be non-trivial and conservative since it introduces no new objects.
The theories will clearly show which extensions are conservative and which are not.
(This is a modification to standard Z)
\end{enumerate}
Ë
	‚ZDEC·		::=	‚dec·		ææZTERM â ZTERMøø
			|	‚decsexp·	ææZTERM â DECORøø

	‚ZDECL·	==	seq ZDEC
Ê
Ë
	‚ZPRED·	::=	‚predeq·	ææZTERM â ZTERMøø
			|	‚predmem·	ææZTERM â ZTERMøø
			|	‚predtrue·
			|	‚predfalse·
			|	‚predneg·	ææZPREDøø
			|	‚predand·	ææZPRED â ZPREDøø
			|	‚predor·	ææZPRED â ZPREDøø
			|	‚predimp·	ææZPRED â ZPREDøø
			|	‚prediff·	ææZPRED â ZPREDøø
			|	‚predexi·	ææZDECL â ZPRED â ZPREDøø
			|	‚predunexi·	ææZDECL â ZPRED â ZPREDøø
			|	‚preduni·	ææZDECL â ZPRED â ZPREDøø
			|	‚predsexp·	ææZTERM â DECORøø
Ê
Ë
	‚ZTERM·	::=	‚termvar·	ææIDENT â ZTYPE â seq ZTERMøø
			|	‚termcon·	ææIDENT â ZTYPE â seq ZTERMøø
			|	‚termseq·	ææseq ZTERMøø
			|	‚termsetd·	ææseq ZTERMøø
			|	‚termseta·	ææZDECL â ZPRED â ZTERMøø
			|	‚termtuple·	ææseq ZTERMøø
			|	‚termprod·	ææseq ZTERMøø
			|	‚termtheta·	ææZTERM â DECORøø
			|	‚termsel·	ææZTERM â IDENTøø
			|	‚termapp·	ææZTERM â ZTERMøø
			|	‚termlam·	ææZDECL â ZPRED â ZTERMøø
			|	‚termmu·	ææZDECL â ZPRED â ZTERMøø

			|	‚schema·	ææZDECL â ZPREDøø
			|	‚schdec·		ææZTERM â DECORøø
			|	‚schpre·		ææZTERMøø
			|	‚schneg·	ææZTERMøø
			|	‚schand·	ææZTERM â ZTERMøø
			|	‚schor·		ææZTERM â ZTERMøø
			|	‚schimp·	ææZTERM â ZTERMøø
			|	‚scheq·		ææZTERM â ZTERMøø
			|	‚schpro·		ææZTERM â ZTERMøø
			|	‚schide·		ææZTERM â seq IDENTøø
			|	‚schexi·		ææZDECL â ZPRED â ZTERMøø
			|	‚schunexi·	ææZDECL â ZPRED â ZTERMøø
			|	‚schuni·		ææZDECL â ZPRED â ZTERMøø
			|	‚schdel·		ææZTERMøø
			|	‚schxi·		ææZTERMøø
			|	‚schcomp·	ææZTERM â ZTERMøø
Ê
Ë
	‚IDENT·	==	WORD â DECOR
	‚WORD·	==	string
	‚DECOR·	==	string
Ê

\section{SCHEMAS} \label{SCHEMAS}

Our purpose is to describe informally a mapping from Z into HOL.
This has been done by hanging informal descriptions around a partial formal definition of the mapping.
The mapping is intended to be fully systematic; our previous translations have had a more {\em ad hoc} flavour.
The systematic nature of the mapping is first apparent in the definition of the mapping of Z types into HOL types.
This follows the obvious pattern of chosing appropriate HOL representatives for the type constructors of Z and then mapping complex types in Z into similarly structured complex types in HOL.

The next most substantial departure from our previous practice, is to map those things which look like types in Z but are in fact terms denoting sets, into terms in HOL.
In our previous work we have mapped these into HOL types.
Signatures in Z are dual purpose, supplying an assignment of types to identifiers, and a predicate constraining the scope of abstraction or quantification.
This is reflected in the proposed mapping.

\subsection{Auxiliary Functions}

$∫$ forms a boolean term asserting that its first argument is a member of its second.
(Note that this symbol occurs here both as a Z constant being defined, and as an HOL constant defined above)
Í
	‚mk_optype·	: FTYPE ã FTYPE ã FTYPE ã FTYPE
	‚mk_reltype·	: FTYPE ã FTYPE ã FTYPE
…
	Éft1,ft2,ft3:TERMé

	mk_optype ft1 ft2 ft3	= mk_ã_type (ft1, mk_ã_type (ft2,ft3))
Ä	mk_reltype ft1 ft2 	= mk_optype ft1 ft2 bool_type
À
Í
	_‚member·_		: TERM ã TERM ã TERM
	_‚∫·_			: TERM ã TERM ã TERM
	_‚hidden_member·_	: TERM ã TERM ã TERM
…
	Éft1,ft2:TERMé

	ft1 member ft2
	= mk_binop ft1 (mk_const (`ù`, mk_reltype (type_of ft1) (type_of ft2))) ft2

Ä	ft1 ∫ ft2
	= mk_binop ft1 (mk_const (`∫`, mk_reltype (type_of ft1) (type_of ft2))) ft2

Ä	ft1 hidden_member ft2
	= mk_binop ft1 (mk_const (`hidden_member`, mk_reltype (type_of ft1) (type_of ft2))) ft2
À
Í
	‚NIL·		: TYPE ã TERM
	‚CONS·		: TERM ã TERM ã TERM
…
	Éft1,ft2:TERM; ty:TYPEé

	NIL ty
	= mk_const(`NIL`, mk_ctype (`list`,ætyø))

Ä	CONS ft1 ft2
	= mk_binop ft1 (mk_const (`CONS`,mk_optype (type_of ft1) (type_of ft2) (type_of ft2))) ft2
À

{\em equals} forms a boolean term asserting that its first argument is equal to its second.

Í
	_‚equals·_	: TERM ã TERM ã TERM
…
	Éft1,ft2:TERMé

	ft1 equals ft2
		= mk_binop ft1 (mk_const (`=`, mk_reltype (type_of ft1) (type_of ft2) )) ft2
À
{\em apply} forms an application of one Z term to another.

Í
	_‚apply·_	: TERM ã TERM ã TERM
…
	Éft1,ft2:TERMé

	ft1 apply ft2
		= mk_binop ft1 (mk_const (`apply`, mk_optype funtype argtype restype)) ft2

	where
	[funtype,argtype,restype:FTYPE
	|	funtype = type_of ft1
	Ä	argtype = type_of ft2
	Ä	funtype = mk_ã_type(argtype,restype)]
À

Í
	‚mk_schtype·	: (IDENT ú ZTYPE) ã ZTYPE
	‚dest_schtype·	: ZTYPE ñ (IDENT ú ZTYPE)
	‚sexp_idty·	: ZTERM ã (IDENT ú TYPE)
…
	Éitym:(IDENT ú ZTYPE); sexpb:ZTERM ; zt:ZTYPEé

	dom dest_schtype	= ran mk_schtype
Ä	mk_schtype itym	= powerT(schemaT itym)
Ä	dest_schtype (powerT(schemaT itym))
				= itym
Ä	sexp_idty (sexpb, zt)	= dest_schtype zt Ø hol_mtype
À

\subsubsection{name formation}

The HOL syntax given above allows an arbitrary string for the name of a type constructor, type variable, constant or individual variable.
In general the names used in the HOL are derived from WORDs and DECORs used in the Z source, but the manner of derivation must be defined.
In addition there will be a number of type constructors, type variables, and constants used in the HOL which do not correspond directly to identifiers in the source Z.

The most complex names are those associated with schema types.
An infinite family of schema type constructors is required, one for each finite set of IDENTs.
Associated with each schema type constructor there will be various constants.
The names of each of these types and constants must distinguish it from the others, and we therefore need a mapping from sets of IDENTs to strings.

Í
	‚unpack_IDENT·	: string ñ IDENT
	‚pack_IDENT· 	: IDENT è string
…
	pack_IDENT Ø unpack_IDENT = id[IDENT]
À

In fact, it is usually more convenient to deal with IDENTs in their packed forms, so we will not have the type abbreviations IDENT, WORD and DECOR in the implementation but simply use strings to represent each of them.
Thus, whilst they are retained in the Z specification paragraphs, the signature boxes will use $string$ (or sometimes $string â string$).

=DOC
val ‚unpack_IDENT· : string -> (string * string);
val ‚pack_IDENT· : (string * string) -> string;
=DESCRIBE
$unpack\_IDENT$ splits a string representing an IDENT into its WORD and DECOR parts.
$pack\_IDENT$ is simply string concatenation.
=FAILURE
48001	?0 is not a valid identifier
=ENDDOC

In the following definitions {\em idsetseq} is intended to sort a set of identifiers.
The ordering is immaterial and has not been specified, though it would be odd to make it other than lexicographic.
{\em flatpack} produces a comma-separated string from a sequence of strings.
It is required to be used on the empty sequence (since schemas obtained by hiding may have an empty signature).

Í
	‚idsetseq·		: í IDENT è seq IDENT
	‚flatpack·		: seq string è string
…
		(Éfid: í IDENTé
			ran (idsetseq fid) = fid)
	Ä	(Éss:seq string; s1,s2:stringé
			flatpack (æø) = ``
		Ä	flatpack (æs1ø) = s1
		Ä	flatpack (ssµæs1øµæs2ø) = (flatpack (ssµæs1ø))^`,`^s2)
À


Í
	‚val_setIDENT·	: í IDENT è string
	‚itymfunseq·		: (IDENT ú TYPE) ã seq TYPE
	‚bool_type·		: TYPE
…
		(Éfid: í IDENTé
			ran (idsetseq fid) = fid
		Ä	val_setIDENT fid = `[`^(flatpack((idsetseq fid)Øpack_IDENT))^`]`)
	Ä	(Éitym:IDENT ú TYPEé
			itymfunseq itym = (idsetseq (dom itym)) Ø itym)
	Ä	bool_type	= mk_ctype (`bool`,æø)
À

{\em number} maps numbers onto numerals.
Í
	‚number·	: Ü è string
	‚val_numeral·	: string ⁄ Ü
…
	Éi:Üé val_numeral (number i) = i
À


It is the schema calculus which causes the greatest problems.
To support schemas it is proposed to introduce infinite families of new HOL type constructors.
For each of these types various associated constants will also be introduced.

These various types and constants are described as follows:


\subsection{Bindings and Tuples}

\subsubsection{binding types}

For each finite set of identifiers a polymorphic type constructor is required which is the type of bindings which bind values to just the identifiers in the set.
It is necessary to give each of these type constructors a unique name, which we will form by appending to the prefix $`S\_`$ the alphabetically ordered list of identifiers.
The type constructor will have the same arity as the cardinality of the set of identifiers, and the types assigned to the identifiers will be supplied as parameters to the constructor in alphabetic order of the identifiers to which they are assigned.

The type will be represented by the set of n-tuples (formed in HOL by iteration of the PAIR constructor) having the same number of components.
A sample representation type predicate is as follows:

ÛML
let ‚bind_type_[a,b]_pred· = "çt:(*a â *b)é T"
Ê

The type $(*a,*b)S_{[a,b]}$ will be in bijection with the elements having the above property and an axiom will be needed which asserts that this is the case. 

Functions yielding the type name and the type respectively are as follows:
Í
	‚bind_tname·		: í IDENT ã string
	‚bind_type·		: (IDENT ú TYPE) ã TYPE
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	bind_tname fid		= `S_`^(val_setIDENT fid)
Ä	bind_type itym		= mk_ctype (bind_tname(dom itym), itymfunseq itym) 
À

=DOC
val ‚bind_type· : (string * TYPE) list -> TYPE; 
=DESCRIBE
Makes a Z binding type from the supplied component to type map.
=EXAMPLE
bind_type [("a",tya),("b",tyb)] = ª:(tya,tyb)S_æa©bøº
=ENDDOC

\subsubsection{tuple types}


Í
	‚tuple_type·	: seq TYPE ã TYPE
…
À

=DOC
val ‚tuple_type· : TYPE list -> TYPE; 
=DESCRIBE
Makes a Z tuple type from the supplied type list.
=EXAMPLE
tuple_type [tya,tyb] = ª:(tya,tyb)T_2º
=ENDDOC

\subsubsection{binding constructors}

For every binding type there will be a constant for constructing bindings of that type.
The name of this constructor will be formed by prefixing $`mk\_`$ to the name of the type of the binding.
The type of the constructor will be that of a curried function taking parameters whose types are type variables having the same name as the identifiers in the signature of the bindings.
The result type will be the binding type with type variables similarly named supplied as parameters,
e.g. `$mk\_S_{[a,b]}:*a ã *b ã (*a,*b)S_{[a,b]}$'.

The element of the representation type corresponding to the entity constructed is simply the tuple formed from the values supplied as arguments.
A sample definition for the constructor would therefore be:

ÛHOL Constant
	‚mk_S_[a,b]·: *a ã *b ã (*a,*b)S_[a,b]
…
	mk_S_[a,b] a b = ABS_S_[a,b] (a,b)
Ê

In general type instantiations of these constructors will be required rather than the fully polymorphic types and terms.
The functions below provide appropriate instantiations.

Í
	‚bind_cname·		: í IDENT ã string
	‚bind_ctype·		: (IDENT ú TYPE) ã TYPE
	‚bind_cterm·		: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	bind_cname fid	= `mk_`^(bind_tname fid)
Ä	bind_ctype itym	= list_mk_ã_type (itymfunseq itym, bind_type itym)  
Ä	bind_cterm itym	= mk_const (bind_cname (dom itym), bind_ctype itym)  
À

These binding constructors are used in theta terms, {\em termtheta}.

=DOC
val ‚bind_cterm· : (string * TYPE) list -> TERM;
=DESCRIBE
Makes a Z binding constructor from the supplied component to type map.
=EXAMPLE
bind_cterm [("a",tya),("b",tyb)] = ªmk_S_æa©bø : tya ã tyb ã (tya,tyb)S_æa©bøº
=ENDDOC

\subsubsection{tuple constructors}

The special case of tuples is also catered for:
Í
	‚tuple_ctype·	: seq TYPE ã TYPE
	‚tuple_cterm·	: seq TYPE ã TERM
…
	Ésty:seq TYPEé

	tuple_ctype sty		= bind_ctype (pack_IDENT Ø val_numeral Ø sty)
	tuple_cterm sty	= bind_cterm (pack_IDENT Ø val_numeral Ø sty)
À

=DOC
val ‚tuple_cterm· : TYPE list -> TERM;
=DESCRIBE
Makes a Z tuple constructor from the supplied type list.
=EXAMPLE
tuple_cterm [tya,tyb] = ªmk_T_2 : tya ã tyb ã (tya,tyb)T_2º
=ENDDOC

\subsubsection{cartesian products}

Í
	‚powert·	: TYPE ã TYPE
…
	Éty:TYPEé	powert ty = mk_ctype(`ë`,ætø)
À

Í
	‚prod_cname·	: seq TYPE ã string
	‚prod_ctype·	: seq TYPE ã TYPE
	‚prod_cterm·	: seq TYPE ã TERM
…
	Ésty:seq TYPEé

	prod_cname sty	= `mk_prod`^(number (#sty))
	prod_ctype sty		= list_mk_ã_type(
					itymfunseq (pack_IDENT Ø val_numeral Ø sty Ø powert),
					powert (mk_tuple_type sty))
	prod_cterm sty		= mk_const(prod_cname sty, prod_ctype sty)
À

=DOC
val ‚prod_cterm· : TYPE list -> TERM;
=DESCRIBE
Makes a Z cartesian product constructor from the supplied type list.
=EXAMPLE
prod_cterm [tya,tyb] = ªmkprod_2 : ((tya)ë,(tyb)ë)T_2 ã ((tya,tyb)T_2)ëº
=ENDDOC

\subsubsection{binding projections}

For every binding type there will be a set of projection functions, which select components of the binding.
These will have names formed by concatenating the identifier of the component to be selected, and the name of the type of the binding.
The type of the projection will be a function.
The domain type of the function is the type of the binding with appropriate type variables, the co-domain is then the type variable having the same name as the component to be selected.

The following is an example of how the projection functions will be defined.

ÛHOL Constant
	‚S_[a,b]_a·:(*a,*b)S_[a,b] ã *a
	‚S_[a,b]_b·:(*a,*b)S_[a,b] ã *b
…
	(S_[a,b]_a x = FST (REP_S_[a,b] x))
Ä	(S_[a,b]_b x = SND (REP_S_[a,b] x))
Ê

Once again the functions defined yield type instantiated terms.

Í
	‚bind_pname·		: í IDENT		ã IDENT ã string
	‚bind_ptype·		: (IDENT ú TYPE)	ã IDENT ã TYPE
	‚bind_pterm·		: (IDENT ú TYPE)	ã IDENT ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPE; i:IDENTé

	bind_pname fid i	= (bind_tname fid)^`_`^(pack_IDENT i)
Ä	bind_ptype itym i	= mk_ã_type(bind_type itym, itym i)  
Ä	bind_pterm itym i	= mk_const (bind_pname (dom itym) i, bind_ptype itym i)  
À

The projection constants are used for selection notation {\em S.name}, in {\em termsel}

=DOC
val ‚bind_pterm· : (string * TYPE) list -> string -> TYPE;
=DESCRIBE
Makes a Z binding projection function for the supplied component to type map; the component to be projected is supplied as the second argument.
=EXAMPLE
bind_pterm [("a",tya),("b",tyb)] "a" = ªS_æa©bø_a : (tya,tyb)S_æa©bø ã tyaº
=ENDDOC

\subsubsection{tuple projections}
\subsection{Schemas}

A schema is a set of bindings.
First we deal with schema types (which in this document are the types of schemas, but in \cite{spivey89} are the types of bindings), then with various operations on schemas which are available in Z.

As with bindings there is an infinite collection of schema types.

All the operations of the schema calculus require complete families of constants, indexed by the schema types over which they are legal.
Operations over schemas or schema expression which involve variable binding constructs are deferred to the next section.

\subsubsection{schema types}

A schema is a set of bindings, a schema type is therefore a powerset of a binding type:

Í
	‚schema_type·		: (IDENT ú TYPE) ã TYPE
…
	Éitym:IDENT ú TYPEé

	schema_type itym	= mk_ctype (`ë`,æbind_type itymø)  
À

=DOC
val ‚schema_type· : (string * TYPE) list -> TYPE;
=DESCRIBE
Makes a Z schema type from the supplied component to type map.
=EXAMPLE
schema_type [("a",tya),("b",tyb)] = ª:((tya,tyb)S_æa©bø)ëº
=ENDDOC

Names for the operations will be formed in general by decorating the normal operation symbol by the type name of the operand or operands.

The operations are of various kinds as follows, grouped by type similarities (of which there are few!):

\subsubsection{schema negation}

Schema negation (schneg), takes any schema type to the same type.
It is semantically simply the complement operation on the set, and need not be restricted to sets of bindings.

ÛHOL Constant
	‚bind_å·	: (*)ë ã (*)ë
…
	És:(*)ëé	bind_å s = ABS_ë (çx:*é x ì s)
Ê

The following definitions serve only to give type instances of the above constant:

Í
	‚bind_å_type·		: (IDENT ú TYPE) ã TYPE
	‚bind_å_term·		: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	bind_å_type itym	= mk_ã_type (schema_type itym, schema_type itym)  
Ä	bind_å_term itym	= mk_const (`bind_å`, bind_å_type itym)  
À

=DOC
val ‚bind_å_term· : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema negation constructor from the supplied component to type map.
=EXAMPLE
bind_å_term [("a",tya),("b",tyb)] = ªbind_å : ((tya,tyb)S_æa©bø)ë ã ((tya,tyb)S_æa©bø)ëº
=ENDDOC

\subsubsection{schema precondition}

ÛHOL Constant
	‚pre_S_[a',b]·:((*a,*b)S_[a',b])ë ã ((*b)S_[b])ë
…
	És:((*a,*b)S_[a',b])ë é

	pre_S_[a',b] s = [b:*b|Ña':*aé s]
Ê

The precondition operator takes a schema and existentially quantifies all the variables which are either outputs or part of the new state.
The type of the resulting schema is therefore obtained by discarding all components of the type of the constituent bindings which have identifiers ending with ' or !.

We first define separately a function which determines which of the identifiers in a binding type are the identifiers of results of the operation described by the schema.
{\em There is room for debate about whether this is the correct interpretation of \cite{spivey89}.}

Í
	‚schema_results·	: (IDENT ú TYPE) ã í IDENT
…
	Éitym:IDENT ú TYPEé

	schema_results itym =

	{w:WORD; d,fd:DECOR; s:string
	|	(fd = `'` Å fd = `!`) Ä (w^d = s^fd)
	é	(w,d)
	}	† (dom itym)
À

The type of the result of the precondition operation is the type of the original schema with the results hidden.
In fact precondition is definable in terms of hiding, but separate operators are needed to preserve the distinction for the concrete syntax.

Í
	‚bind_pre_name·	: í IDENT ã string
	‚bind_pre_type·	: (IDENT ú TYPE) ã TYPE
	‚bind_pre_term·	: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	bind_pre_name fid	= `pre_`^(bind_tname fid)
Ä	bind_pre_type itym	= mk_ã_type
				(schema_type itym,
				 schema_type ((schema_results itym)	õ itym)
				)  
Ä	bind_pre_term itym	= mk_const (bind_pre_name (dom itym), bind_pre_type itym)  
À

=DOC
val ‚bind_pre_term· : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema precondition constructor from the supplied component to type map.
=EXAMPLE
bind_pre_term [("a'",tya),("b",tyb)] = ªpre_S_æa'©bø : ((tya,tyb)S_æa'©bø)ë ã ((tyb)S_æbø)ëº
=ENDDOC

\subsubsection{simple dyadic schema operations}

ÛHOL Constant
	‚Ä[a,b][b,c]·:((*a,*b)S_[a,b])ë ã ((*b,*c)S_[b,c])ë  ã ((*a,*b,*c)S_[a,b,c])ë
…
	Ésc1:((*a,*b)S_[a,b])ë; sc2:((*b,*c)S_[b,c])ëé

	Ä[a,b][b,c] sc1 sc2 = [a:*a; b:*b; c:*c | sc1 Ä sc2]
Ê

(schand, schor, schimp) taking any compatible pair of schema types to the schema type having the union of the components (with appropriate component types).

Since these operations are so similar they are provided by the same functions which take the particular operation name as a parameter:

Í
	‚bind_dysc_name·	: string ã í IDENT ã í IDENT ã string
	‚bind_dysc_type·	: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TYPE
	‚bind_dysc_term·	: string ã (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
…
	Éfid1,fid2:í IDENT; itym1,itym2:IDENT ú TYPE; n:stringé

	bind_dysc_name n fid1 fid2	= n^(val_setIDENT fid1)^(val_setIDENT fid2) 
Ä	bind_dysc_type itym1 itym2	= list_mk_ã_type
						(æschema_type itym1,schema_type itym2ø,
						schema_type (itym1 ° itym2))
Ä	bind_dysc_term n itym1 itym2	= mk_const (bind_dysc_name n (dom itym1) (dom itym2),
							bind_dysc_type itym1 itym2)  
À

The following are primarily illustrative of the use of the above, and are not used in the sequel.

Í
	‚bind_Ä_term·		: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
	‚bind_Å_term·		: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
	‚bind_ä_term·	: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
	‚bind_Ç_term·	: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
…
	bind_Ä_term		= bind_dysc_term `Ä` 
 	bind_Å_term		= bind_dysc_term `Å`  
	bind_ä_term		= bind_dysc_term `ä`  
	bind_Ç_term		= bind_dysc_term `Ç`  
À

It should be noted that the full generality of these functions will not be available in any implementation.
Only the identified operations will be supported.

=DOC
val ‚bind_Ä_term· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema conjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_Ä_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = ªÄæa©bøæb©cø : (((tya, tyb)S_æa©bø)ë ã ((tyb, tyc)S_æb©cø)ë ã ((tya, tyb, tyc)S_æa©b©cø)ë)º
=ENDDOC

=DOC
val ‚bind_Å_term· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema disjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_Å_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = ªÅæa©bøæb©cø : (((tya, tyb)S_æa©bø)ë ã ((tyb, tyc)S_æb©cø)ë ã ((tya, tyb, tyc)S_æa©b©cø)ë)º
=ENDDOC

=DOC
val ‚bind_ä_term· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema implication constructor from the supplied component to type maps.
=EXAMPLE
bind_ä_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = ªäæa©bøæb©cø : (((tya, tyb)S_æa©bø)ë ã ((tyb, tyc)S_æb©cø)ë ã ((tya, tyb, tyc)S_æa©b©cø)ë)º
=ENDDOC

=DOC
val ‚bind_Ç_term· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema equivalence constructor from the supplied component to type maps.
=EXAMPLE
bind_Ç_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = ªÇæa©bøæb©cø : (((tya, tyb)S_æa©bø)ë ã ((tyb, tyc)S_æb©cø)ë ã ((tya, tyb, tyc)S_æa©b©cø)ë)º
=ENDDOC

\subsubsection{schema projection}

ÛHOL Constant
	‚pro[a,b][b,c]·:((*a,*b)S_[a,b])ë ã ((*b,*c)S_[b,c])ë  ã ((*b,*c)S_[b,c])ë
…
	Ésc1:((*a,*b)S_[a,b])ë; sc2:((*b,*c)S_[b,c])ëé

	pro[a,b][b,c] sc1 sc2 = (sc1 Ä sc2) ƒ (a)
Ê

(schpro) takes two schemas of compatible types and yields a schema having the same type as the second

Í
	‚bind_pro_name·	: í IDENT ã í IDENT ã string
	‚bind_pro_type·	: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TYPE
	‚bind_pro_term·	: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
…
	Éfid1,fid2:í IDENT; itym1,itym2:IDENT ú TYPEé

	bind_pro_name fid1 fid2	= `pro_`^(val_setIDENT fid1)^(val_setIDENT fid2)
Ä	bind_pro_type itym1 itym2	= list_mk_ã_type
				(	æschema_type itym1, schema_type itym2ø,
					schema_type itym2
				)  
Ä	bind_pro_term itym1 itym2
		= mk_const (bind_pro_name (dom itym1) (dom itym2), bind_pro_type itym1 itym2)  
À

=DOC
val ‚bind_pro_term· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema projection constructor from the supplied component to type maps.
=EXAMPLE
bind_pro_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = ªpro_æa©bøæb©cø : (((tya, tyb)S_æa©bø)ë ã ((tyb, tyc)S_æb©cø)ë ã ((tyb, tyc)S_æb©cø)ë)º
=ENDDOC

\subsubsection{schema hiding}

ÛHOL Constant
	‚hide[a,b][b]·:((*a,*b)S_[a,b])ë ã ((*a)S_[a])ë
…
	Ésc:((*a,*b)S_[a,b])ëé

	hide[a,b][b] sc = [a:*a | Ñb:*bé sc]
Ê

(schide) takes one schema and a list of identifiers and yields a schema whose type is formed from the type of the first parameter by deleting all components whose identifiers are in the list.

Í
	‚bind_hide_name·	: í IDENT ã í IDENT ã string
	‚bind_hide_type·	: (IDENT ú TYPE) ã (í IDENT) ã TYPE
	‚bind_hide_term·	: (IDENT ú TYPE) ã (í IDENT) ã TERM
…
	Éfid1,fid2:í IDENT; itym:IDENT ú TYPEé

	bind_hide_name fid1 fid2	= `hide_`^(val_setIDENT fid1)^(val_setIDENT fid2)
Ä	bind_hide_type itym fid1	= mk_ã_type
				(	schema_type itym,
					schema_type (fid1 õ itym)
				)  
Ä	bind_hide_term itym fid1
		= mk_const (bind_hide_name (dom itym) fid1, bind_hide_type itym fid)  
À

=DOC
val ‚bind_hide_term· : (string * TYPE) list -> string list -> TERM;
=DESCRIBE
Makes the Z schema hiding constructor from the supplied component to type map; the components to be hidden are supplied as the second argument.
=EXAMPLE
bind_hide_term [("a",tya),("b",tyb)] ["a"] = ªhide_æa©bøæaø : (((tya, tyb)S_æa©bø)ë ã ((tyb)S_æbø)ë)º
=ENDDOC

\subsubsection{decoration}

(sdes) when schema designator is used it may be supplied with further decorations.
The effect is to add the decorations to the identifiers in the bindings.
 
Í
	‚decor_id·	: string ã IDENT ã IDENT
	‚decor_idt·	: string ã (IDENT â TYPE) ã (IDENT â TYPE)
	‚decor_itym·	: string ã (IDENT ú TYPE) ã (IDENT ú TYPE)
…
	És:string; w:WORD; d:DECOR; i:IDENT; ty:TYPE; itym:IDENT ú TYPEé 

	decor_id s (w,d)	= (w,d^s)
Ä 	decor_idt s (i,ty)	= (decor_id s i,ty)
Ä	decor_itym s itym	= (decor_idt s) —itym“
À
Í
	‚bind_decor_name·	: í IDENT ã string ã string
	‚bind_decor_type·	: (IDENT ú TYPE) ã string ã TYPE
	‚bind_decor_term·	: (IDENT ú TYPE) ã string ã TERM
…
	Éfid:í IDENT; s:string; itym:IDENT ú TYPEé

	bind_decor_name fid s	= `decor_`^(val_setIDENT fid)^s
Ä	bind_decor_type itym s	= mk_ã_type
				(	schema_type itym,
					schema_type (decor_itym s itym)
				)  
Ä	bind_decor_term itym s
		= mk_const (bind_decor_name (dom itym) s, bind_decor_type itym s)  
À

=DOC
val ‚bind_decor_term· : (string * TYPE) list -> string -> TERM;
=DESCRIBE
Makes the Z schema systematic decoration constructor from the supplied component to type map; the decoration is supplied as the second argument.
=EXAMPLE
bind_decor_term [("a",tya),("b",tyb)] "'" = ªdecor_æa©bø' : ((tya, tyb)S_æa©bø)ë ã ((tya, tyb)S_æa'©b'ø)ë)º
=ENDDOC

\subsubsection{the delta operation}

The delta operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with ').

Í
	‚bind_delta_name·	: í IDENT ã string
	‚bind_delta_type·	: (IDENT ú TYPE) ã TYPE
	‚bind_delta_term·	: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	bind_delta_name fid	= `delta_`^(val_setIDENT fid)
Ä	bind_delta_type itym	= mk_ã_type
				(	schema_type itym,
					schema_type (itym ° (decor_itym `'` itym))
				)  
Ä	bind_delta_term itym
		= mk_const (bind_delta_name (dom itym), bind_delta_type itym)
À

=DOC
val ‚bind_delta_term· : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{the $\Xi$ operation}

The $\Xi$ operation takes a schema and yields one which is the conjunction of the schema and itself primed (decorated with '), with the before and after values equated in the predicate.
The type is the same as that of the $\Delta$ operation.

Í
	‚bind_xi_name·	: í IDENT ã string
	‚bind_xi_type·	: (IDENT ú TYPE) ã TYPE
	‚bind_xi_term·	: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	bind_xi_name fid	= `xi_`^(val_setIDENT fid)
Ä	bind_xi_type			= bind_delta_type  
Ä	bind_xi_term itym
		= mk_const (bind_xi_name (dom itym), bind_xi_type itym)
À

=DOC
val ‚bind_xi_term· : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{schema composition}

Schema composition is an operation which takes two schemas as arguments.
The schemas must be compatible in the following sense.
The primed components of the first schema must match in name and type the undecorated components of the second.
Any other components common to both must have the same type.

The type of the resulting schema is obtained by merging the two signatures hiding the primed components of the first and the undecorated components of the second.
There is a problem here about exactly what ``primed'' means.
Is a double primed identifier primed?

Í
	‚bind_scomp_name·	: í IDENT ã í IDENT ã string
	‚bind_scomp_type·	: (IDENT ú TYPE) ã TYPE
	‚bind_scomp_term·	: (IDENT ú TYPE) ã TERM
…
	Éfid1, fid2:í IDENT; itym1,itym2:IDENT ú TYPEé

	bind_scomp_name fid1 fid2	= `scomp_`^(val_setIDENT fid1)^(val_setIDENT fid2)
Ä	bind_scomp_type itym1 itym2	= list_mk_ã_type (
					æschema_type itym1, schema_type itym2ø,
					schema_type (
			£{i,i':IDENT | i' ù dom itym1 Ä i ù dom itym2 
				Ä (pack_IDENT i)^`'` = (pack_IDENT i') é {i,i'}}
			õ (itym1 ° itym2))
Ä	bind_scomp_term itym1 itym2
		= mk_const (bind_scomp_name (dom itym1) (dom itym2),
			bind_scomp_type itym1 itym2)
À

=DOC
val ‚bind_scomp_term· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema composition constructor from the supplied component to type maps.
=EXAMPLE
bind_scomp_term [("a",tya),("b'",tyb)] [("b",tyb),("c'",tyc)] = 
	ªscomp_æa©b'øæb©c'ø : (((tya, tyb)S_æa©b'ø)ë ã ((tyb, tyc)S_æb©c'ø)ë ã ((tya, tyc)S_æa©c'ø)ë)º
=ENDDOC

\subsection{Variable Binding Constructs}

Take care to avoid confusion between the two distinct uses of the term {\em binding} in this document.
The {\em binding}s which are members of schemas, bind values to identifiers.
Such bindings are the values denoted by terms with a binding type (e.g. $S_{[a,b,c...]}$).
Constructs involving the syntactic category {\em DECL} also effect a binding.
In this latter case it is variables which are bound within some textual scope, for the purpose, for example, of universal quantification.
These binding constructs may yield terms, predicates or schema expressions depending on the form of the construct.

There are in Z a variety of binding constructs of this latter kind, in which a DECL occurs and serves to bind variables in following predicates or terms.

The general pattern followed in dealing with these constructs is simply an elaboration of the treatment in HOL of binders.

There is just the one primitive binding construct, viz: lambda abstraction.
All binding constructs are therefore first translated into lambda abstractions.
The result of the abstraction is then converted into the value required by the application of a constant which embodies the semantics of the particular binding construct concerned.

The image of the binding construct is therefore formed in the following way:
\begin{enumerate}
\item{}
The constituent expressions are mapped into HOL in the standard way
(in some cases the {\em characteristic tuple}, while not an explicit constituent of the syntax, must be supplied by the mapping as a component of the resulting HOL term).
\item{}
These terms are collected together into a binding.
The binding constructor will be either $mk\_S_{[d,p]}$ (for {\em schema, schexi, schunexi} and {\em schuni}), $mk\_S_{[d,p,v]}$ (for {\em predexi, predunexi, preduni, termseta} and {\em termmu}) $mk\_S_{[t,d,p,v]}$ (for {\em termlam}).
\item{}
An abstraction is formed by abstracting over each of the variables declared in the constituent DECL.
\item{}
A binding operator is applied to the function thus obtained.
There will be a family of binding operators for each of the eight different binding constructs.
\end{enumerate}
The names of the binding operators will be formed from the name of the constructor in the abstract syntax by appending the sequence of names declared in the signature.
Its type will vary according to the signature and the nature of the binder.
Details are filled in below for each of the binders in turn.

\subsubsection{binding constructs by group}

Binding constructs fall into three groups, according to the scope of the bindings which take place.

The full list of binding constructs in Z is as follows:

\begin{tabular}{|l|l|l|l|}\hline
{\bf constructor} & {\bf description} & {\bf category} & {\bf group}\\ \hline
schema & schema & ZTERM (schema expression) & 1\\
schexi & schema existential quantification & ZTERM (schema expression) & 1\\
schunexi & schema unique existential quantification & ZTERM (schema expression) & 1\\
schuni & schema universal quantification & ZTERM (schema expression) & 1\\
predexi & existential quantification & PRED & 2\\
predunexi & unique existential quantification & PRED & 2\\
preduni & universal quantification & PRED & 2\\
termseta & set abstraction (separation) & ZTERM & 2\\
termlam & lambda abstraction & ZTERM & 3\\
termmu & mu operator (description) & ZTERM & 2\\ \hline
\end{tabular}

In the following descriptions of how these groups of binding constructs are handled the various expressions which fall within the scope of the binding are collected together into a single expression as a schema binding (i.e. a value having a schema product or binding type).

The number of components, and therefore the signature of the binding type, varies between groups, but the significance of the identifiers used is consistently as follows:

\begin{description}
\item[t]
This component is the {\em characteristic tuple} extracted from the declaration part (DECL) of the schema.
\item[d]
This component is the predicate (a boolean term) implicit in the declaration part (DECL) of the schema.
\item[p]
This is the boolean term formed from the predicate (PRED) part of the schema.
\item[v]
This term (the value) is formed from the body of the abstraction (ZTERM or PRED).
In some cases this is defaulted to the characteristic tuple.
\end{description}

\subsubsection{group 1 packs}

In the simplest case (group 1) the variables are bound only in the immediately following predicate (and even this may be omitted in the concrete syntax).
i.e. in {\em schema, schexi, schunexi, and schuni}, the variables declared in the DECL are bound only in the following PRED.

The following functions yield schema product or binding constructors which are appropriate for collecting together the elements within the scope of a group 1 construct.
In group 1 there are just two constituents, the first of which corresponds to the predicate implicit in the DECL, the second corresponding to the explicit predicate (PRED) following the vertical bar.
These are given component identifiers {\em d} and {\em p} respectively.

Í
	‚g1_bind_sig·	: string ú TYPE
	‚g1_bind_ctype·	: TYPE
	‚g1_bind_cterm·	: TERM
	‚g1_bind_type·	: TYPE
…
		g1_bind_sig		=	{
					`d`óbool_type,
					`p`óbool_type}

	Ä	g1_bind_ctype	= bind_ctype g1_bind_sig
	Ä	g1_bind_cterm	= bind_cterm g1_bind_sig
	Ä	g1_bind_type	= bind_type g1_bind_sig
À

\subsubsection{group 2 packs}

In the next case (group 2) a predicate or term follows, within which the relevant variables are also bound.
This is the ZTERM or PRED following the bullet.
This more complex case includes constructs {\em predexi predunexi preduni termseta} and {\em termmu}.
A ZTERM may be omitted in the concrete syntax, in which case the characteristic tuple will be used.
This substitution we presume at present to be undertaken by the parser/type-inference system.

Í
	‚g2_bind_sig·	: TYPE ã (string ú TYPE)
	‚g2_bind_ctype·	: TYPE ã TYPE
	‚g2_bind_cterm·	: TYPE ã TERM
	‚g2_bind_type·	: TYPE ã TYPE
…
	Éty:TYPEé

		g2_bind_sig ty	=	{
					`d`óbool_type,
					`p`óbool_type,
					`v`óty}

	Ä	g2_bind_ctype ty	= bind_ctype (g2_bind_sig ty)
	Ä	g2_bind_cterm ty	= bind_cterm (g2_bind_sig ty)
	Ä	g2_bind_type ty	= bind_type (g2_bind_sig ty)
À

\subsubsection{group 3 packs}

The last case is that of the lambda abstraction which forms group 3.
In this case the characteristic tuple has a role to play even if a term is supplied following the bullet, and is therefore given an identifier of its own.

Í
	‚g3_bind_sig·	: TYPE ã TYPE ã (string ú TYPE)
	‚g3_bind_ctype·	: TYPE ã TYPE ã TYPE
	‚g3_bind_cterm·	: TYPE ã TYPE ã TERM
	‚g3_bind_type·	: TYPE ã TYPE ã TYPE
…
	Éty1,ty2:TYPEé

		g3_bind_sig ty1 ty2	=	{
					`d`óbool_type,
					`p`óbool_type,
					`t`óty1,
					`v`óty2}

	Ä	g3_bind_ctype ty1 ty2	= bind_ctype (g3_bind_sig ty1 ty2)
	Ä	g3_bind_cterm ty1 ty2	= bind_cterm (g3_bind_sig ty1 ty2)
	Ä	g3_bind_type ty1 ty2	= bind_type (g3_bind_sig ty1 ty2)
À

In the following sections we supply for each variable binding construct:
\begin{enumerate}
\item{}
a verbal description of how it is mapped into HOL,
\item{}
a sample HOL-like definition of one of the binders in each family, showing both the type and the value (as an HOL term) of the binder,
\item{and}
a formal Z specification of functions which compute the binding constant.
\end{enumerate}

In the HOL-like sample definitions the Z dot notation is used as shorthand for the application of the relevant projection function.
The samples are generic in the types assigned to the identifiers in the signature, but are shown for specific signatures.
In these examples the schema types $S_{[d,p]}, S_{[d,p,v]}, S_{[t,d,p,v]}$ are fixed binding types used for packaging the two three or four components over which the abstraction is to be formed.

\subsubsection{bindings yielding schema expressions}

Variable binding in schema expressions occurs in schemas and in existential and universal quantification.
In its use in quantifiers the schema expression which follows the binding is not within its scope, i.e. the names in the signature are not bound in the schema expression forming the body of the construct.
For this reason, in contrast to all the other binding constructs, this schema expression is not included in the package over which the variables in the signature have been abstracted.
It is supplied as a second argument to the binding constant (which is a curried function).
This can be seen clearly by referring to the type of the binders in the following sections.

\subsubsection{schemas}

The simplest binding construct is that which simply yields a schema.
The following HOL constant is a sample of the infinite family of constants required: 

ÛHOL Constant
	‚schema_[a,b]·	: (*a ã *b ã (bool,bool)S_[d,p]) ã ((*a,*b)S_[a,b])ë
…
	(schema_[a,b] p
		=	ABS_ë(çx:S_[a,b]é
				let	t = p  x.a  x.b
				in	t.d  Ä  t.p))

Ê

We now specify functions which compute from the elements of the abstract syntax the name, type and term of the binding operators:

Í
	‚schema_bname·	: (í IDENT) ã string
	‚schema_btype·	: (IDENT ú TYPE) ã TYPE
	‚schema_bterm·	: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	schema_bname fid	= `schema_`^(val_setIDENT fid)
Ä	schema_btype itym	= mk_ã_type(
		list_mk_ã_type ((itymfunseq itym), g1_bind_type),
		schema_type itym
					)
Ä	schema_bterm itym	= mk_const (schema_bname (dom itym), schema_btype itym)
À

=DOC
val ‚schema_bterm· : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema constructor from the supplied component to type map.
=EXAMPLE
schema_bterm [("a",tya),("b",tyb)] = ªschema_æa©bø : ((tya ã tyb ã (bool, bool)S_æd©pø) ã ((tya, tyb)S_æa©bø)ë)º
=ENDDOC

\subsubsection{schema existential quantification}

ÛHOL Constant
	‚schexi_[a,b][c,d]·	:
		(*a ã *b ã (bool,bool)S_[d,p]) ã ((*a,*b,*c,*d)S_[a,b,c,d])ë ã ((*c,*d)S_[c,d])ë
…
	(schexi_[a,b][c,d] p q
		= 	ABS_ë(çx:S_[c,d]é Ñy:S_[a,b]é
				let	t = p  y.a  y.b
				in	t.d  Ä  t.p
					Ä (mk_S_[a,b,c,d]  y.a  y.b  x.c  x.d) ù q))
Ê

Í
	‚schexi_bname·	: (í IDENT) ã (í IDENT) ã string
	‚schexi_btype·		: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TYPE
	‚schexi_bterm·		: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
…
	Éfid1,fid2:í IDENT; itym1,itym2:IDENT ú TYPEé

	schexi_bname fid1 fid2
		= `schexi_`^(val_setIDENT fid1)^(val_setIDENT (fid2ƒfid1))
Ä	schexi_btype itym1 itym2
		= list_mk_ã_type
			(æ list_mk_ã_type ((itymfunseq itym1), g1_bind_type),
				schema_type itym2 ø,
			(schema_type (itym2ƒitym1)))
Ä	schexi_bterm itym1 itym2
		= mk_const (schexi_bname (dom itym1) (dom itym2),
				schexi_btype itym1 itym2)
À

=DOC
val ‚schexi_bterm· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema existential quantification constructor from the supplied component to type maps.
=EXAMPLE
schexi_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
ªschexi_æa©bøæc©dø : ((tya ã tyb ã (bool,bool)S_æd©pø) ã ((tya,tyb,tyc,tyd)S_æa©b©c©dø)ë ã ((tyc,tyd)S_æc©dø)ë)º
=ENDDOC

\subsubsection{schema unique existential quantification}

ÛHOL Constant
	‚schunexi_[a,b][c,d]·	:
		(*a ã *b ã (bool,bool)S_[d,p]) ã ((*a,*b,*c,*d)S_[a,b,c,d])ë ã ((*c,*d)S_[c,d])ë
…
	(schunexi_[a,b][c,d] p q
		= 	ABS_ë(çx:S_[c,d]é ¿y:S_[a,b]é
				let	t = p  y.a  y.b
				in	t.d  Ä  t.p
					Ä (mk_S_[a,b,c,d]  y.a  y.b  x.c  x.d) ù q))
Ê

Í
	‚schunexi_bname·		: (í IDENT) ã (í IDENT) ã string
	‚schunexi_btype·		: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TYPE
	‚schunexi_bterm·		: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
…
	Éfid1,fid2:í IDENT; itym1,itym2:IDENT ú TYPEé

	schunexi_bname fid1 fid2
		= `schunexi_`^(val_setIDENT fid1)^(val_setIDENT (fid2ƒfid1))
Ä	schunexi_btype 
		= schexi_btype
Ä	schunexi_bterm itym1 itym2
		= mk_const (schunexi_bname (dom itym1) (dom itym2),
				schunexi_btype itym1 itym2)
À

=DOC
val ‚schunexi_bterm· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema unique existential quantification constructor from the supplied component to type maps.
=EXAMPLE
schunexi_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
ªschunexi_æa©bøæc©dø : ((tya ã tyb ã (bool,bool)S_æd©pø) ã ((tya,tyb,tyc,tyd)S_æa©b©c©dø)ë ã ((tyc,tyd)S_æc©dø)ë)º
=ENDDOC

\subsubsection{schema universal quantification}

ÛHOL Constant
	‚schuni_[a,b][c,d]·	:
		(*a ã *b ã (bool,bool)S_[d,p]) ã ((*a,*b,*c,*d)S_[a,b,c,d])ë ã ((*c,*d)S_[c,d])ë
…
	(schuni_[a,b][c,d] p q
		=	ABS_ë(çx:S_[c,d]é Éy:S_[a,b]é
				let	t = p  y.a  y.b
				in	t.d  Ä  t.p
					ä (mk_S_[a,b,c,d] y.a y.b x.c x.d) ù q))
Ê

Í
	‚schuni_bname·	: (í IDENT) ã (í IDENT) ã string
	‚schuni_btype·		: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TYPE
	‚schuni_bterm·	: (IDENT ú TYPE) ã (IDENT ú TYPE) ã TERM
…
	Éfid1,fid2:í IDENT; itym1,itym2:IDENT ú TYPEé

	schuni_bname fid1 fid2
		= `schuni_`^(val_setIDENT fid1)^(val_setIDENT (fid2ƒfid1))
Ä	schuni_btype itym1 itym2
		= list_mk_ã_type
			(æ list_mk_ã_type ((itymfunseq itym1), g1_bind_type),
				schema_type itym2 ø,
			(schema_type (itym2ƒitym1)))
Ä	schuni_bterm itym1 itym2
		= mk_const (schuni_bname (dom itym1) (dom itym2),
				schuni_btype itym1 itym2)
À

=DOC
val ‚schuni_bterm· : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema universal quantification constructor from the supplied component to type maps.
=EXAMPLE
schuni_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
ªschuni_æa©bøæc©dø : ((tya ã tyb ã (bool,bool)S_æd©pø) ã ((tya,tyb,tyc,tyd)S_æa©b©c©dø)ë ã ((tyc,tyd)S_æc©dø)ë)º
=ENDDOC

\subsubsection{existential quantification}

ÛHOL Constant
	‚predexi_2·	:
		(*1 ã *2 ã (bool,bool,bool)S_[d,p,v]) ã bool
…
	(predexi_2 p
		=	Ñ(x:*1)(y:*2)é let t = p x y in	t.d Ä t.p Ä t.v)
Ê

Í
	‚predexi_bname·	: (í IDENT) ã string
	‚predexi_btype·	: (IDENT ú TYPE) ã TYPE
	‚predexi_bterm·	: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	predexi_bname fid
		= `predexi_`^(number(length fid))
Ä	predexi_btype itym
		= mk_ã_type
			(list_mk_ã_type ((itymfunseq itym), g2_bind_type bool_type),
					bool_type)
Ä	predexi_bterm itym
		= mk_const (predexi_bname (dom itym), predexi_btype itym)
À

=DOC
val ‚predexi_bterm· : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z existential quantification constructor from the supplied component to type map.
=EXAMPLE
predexi_bterm [("a",tya),("b",tyb)] = 
ªpredexi_2 : ((tya ã tyb ã (bool,bool,bool)S_æd©p©vø) ã bool)º
=ENDDOC

\subsubsection{unique existential quantification}

ÛHOL Constant
	‚predunexi_2·	:
		(*1 ã *2 ã (bool,bool,bool)S_[d,p,v]) ã bool
…
	(predunexi_2 p
		=	¿(x:*1)(y:*2)é let t = p x y in	t.d Ä t.p Ä t.v)
Ê

Í
	‚predunexi_bname·	: (í IDENT) ã string
	‚predunexi_btype·	: (IDENT ú TYPE) ã TYPE
	‚predunexi_bterm·	: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	predunexi_bname fid
		= `predunexi_`^(number(length fid))
Ä	predunexi_btype
		= predexi_btype
Ä	predunexi_bterm itym
		= mk_const (predunexi_bname (dom itym), predunexi_btype itym)
À

=DOC
val ‚predunexi_bterm· : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z unique existential quantification constructor from the supplied component to type map.
=EXAMPLE
predunexi_bterm [("a",tya),("b",tyb)] = 
ªpredunexi_2 : ((tya ã tyb ã (bool,bool,bool)S_æd©p©vø) ã bool)º
=ENDDOC

\subsubsection{universal quantification}

ÛHOL Constant
	‚preduni_2·	:
		(*1 ã *2 ã (bool,bool,bool)S_[d,p,v]) ã bool
…
	(preduni_2 p
		=	É(x:*1)(y:*2)é let t = p x y in	t.d Ä t.p ä t.v)
Ê

Í
	‚preduni_bname·	: (í IDENT) ã string
	‚preduni_btype·	: (IDENT ú TYPE) ã TYPE
	‚preduni_bterm·	: (IDENT ú TYPE) ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPEé

	preduni_bname fid
		= `preduni_`^(number(length fid))
Ä	preduni_btype itym
		= mk_ã_type
			(list_mk_ã_type ((itymfunseq itym), g2_bind_type bool_type),
					bool_type)
Ä	preduni_bterm itym
		= mk_const (preduni_bname (dom itym), preduni_btype itym)
À

=DOC
val ‚preduni_bterm· : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z universal quantification constructor from the supplied component to type map.
=EXAMPLE
preduni_bterm [("a",tya),("b",tyb)] = 
ªpreduni_2 : ((tya ã tyb ã (bool,bool,bool)S_æd©p©vø) ã bool)º
=ENDDOC

\subsubsection{set abstraction}

ÛHOL Constant
	‚termseta_2·	:
		(*1 ã *2 ã (bool,bool,*v)S_[d,p,v]) ã (*v)ë
…
	(termseta_2 p
		=	ABS_ë(çx:*vé Ñ(y:*1) (z:*2)é
				let t = p y z in	t.d Ä t.p Ä (t.v = x))
Ê

Í
	‚termseta_bname·	: (í IDENT) ã string
	‚termseta_btype·	: (IDENT ú TYPE) ã TYPE ã TYPE
	‚termseta_bterm·	: (IDENT ú TYPE) ã TYPE ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPE; ty:TYPEé

	termseta_bname fid
		= `termseta_`^(number(length fid))
Ä	termseta_btype itym ty
		= mk_ã_type
			(list_mk_ã_type ((itymfunseq itym), g2_bind_type ty),
					mk_ctype (`ë`,ætyø))
Ä	termseta_bterm itym ty
		= mk_const (termseta_bname (dom itym), termseta_btype itym ty)
À

=DOC
val ‚termseta_bterm· : (string * TYPE) list -> TYPE -> TERM;
=DESCRIBE
Makes the Z set comprehension constructor from the supplied component to type map.
The type of the members of the resulting set is supplied as the second argument.
=EXAMPLE
termseta_bterm [("a",tya),("b",tyb)] tyv = 
ªtermseta_2 : ((tya ã tyb ã (bool,bool,tyv)S_æd©p©vø) ã (tyv)ë)º
=ENDDOC

\subsubsection{lambda abstraction}

ÛHOL Constant
	‚termlam_2·	:
		(*1 ã *2 ã (bool,bool,*dv,*cv)S_[d,p,t,v]) ã ((*dv,*cv)S_[1,2])ë
…
	(termlam_2 p
		=	ABS_ë(çx:(*dv,*cv)S_[1,2]é Ñ(y:*1) (z:*2)é
				let	t = p y z
				in	t.d Ä t.p Ä (t.t = x.1 Ä t.v = x.2))
Ê

Í
	‚termlam_bname·	: (í IDENT) ã string
	‚termlam_btype·	: (IDENT ú TYPE) ã TYPE ã TYPE ã TYPE
	‚termlam_bterm·	: (IDENT ú TYPE) ã TYPE ã TYPE ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPE; d_ty,c_ty:TYPEé

	termlam_bname fid
		= `termlam_`^(number(length fid))
Ä	termlam_btype itym d_ty c_ty
		= mk_ã_type
			(list_mk_ã_type ((itymfunseq itym), g3_bind_type d_ty c_ty),
					mk_ctype(`ë`,æmk_tuple_type æd_ty,c_tyøø))
Ä	termlam_bterm itym d_ty c_ty
		= mk_const (termlam_bname (dom itym), termlam_btype itym d_ty c_ty)
À

=DOC
val ‚termlam_bterm· : (string * TYPE) list -> TYPE -> TYPE -> TERM;
=DESCRIBE
Makes the Z lambda abstraction constructor from the supplied component to type map.
The types of the domain (characteristic tuple) and range of the resulting function are supplied as the second and third arguments respectively.
=EXAMPLE
termlam_bterm [("a",tya),("b",tyb)] tyt tyv = 
ªtermlam_2 : ((tya ã tyb ã (bool,bool,tyt,tyv)S_æd©p©t©vø) ã ((tyt,tyv)T_2)ë)º
=ENDDOC

\subsubsection{definite description}

ÛHOL Constant
	‚termmu_2·		:
		(*1 ã *2 ã (bool,bool,*cv)S_[d,p,v]) ã *cv
…
	(termmu_2 p
		=	á(çx:*cvé Ñ(y:*1) (z:*2)é
				let	t = p y z
				in	t.d Ä t.p Ä (t.v = x)))
Ê

Note that the above definition relies upon $á$ being defined as definite description rather than choice in HOL.
 
Í
	‚termmu_bname·	: (í IDENT) ã string
	‚termmu_btype·	: (IDENT ú TYPE) ã TYPE ã TYPE
	‚termmu_bterm·	: (IDENT ú TYPE) ã TYPE ã TERM
…
	Éfid:í IDENT; itym:IDENT ú TYPE; ty:TYPEé

	termmu_bname fid
		= `termmu_`^(number(length fid))
Ä	termmu_btype itym ty
		= mk_ã_type
			(list_mk_ã_type ((itymfunseq itym), g2_bind_type ty),
					ty)
Ä	termmu_bterm itym ty
		= mk_const (termmu_bname (dom itym), termmu_btype itym ty)
À

=DOC
val ‚termmu_bterm· : (string * TYPE) list -> TYPE -> TERM;
=DESCRIBE
Makes the Z definite description constructor from the supplied component to type map.
The type of the result is supplied as the second argument.
=EXAMPLE
termmu_bterm [("a",tya),("b",tyb)] tyv = 
ªtermmu_2 : ((tya ã tyb ã (bool,bool,tyv)S_æd©p©vø) ã tyv)º
=ENDDOC

\subsection{Computing the Abstractions}

For each of the three groups of abstraction we define a function which constructs the abstraction to which the binding operator will be applied.
The process of abstraction over each of the names in the signature is common to these three functions and is defined first.

Î[A,B]
	‚zip·		: (seq A) ã (A ú B) ã seq (A â B)
…
	Éseqa:seq A; a:A; m:A ú Bé

	zip æø m			= æø
Ä	zip seqaµæaø m	= (zip seqa m)µæ(a, m a)ø
À

Í
	‚schema_abs·	: (IDENT ú TYPE) ã TERM ã TERM
…
	Éitym:IDENT ú TYPE; ft:TERMé

	schema_abs itym ft
		= list_mk_simple_ç
				(zip ((idsetseq Ø pack_IDENT)(dom itym)) stym,
				ft)

		where
		[stym:string ú TYPE | pack_IDENT Ø stym = itym]
À

\subsubsection{forming the abstractions}

In the following sections the variable names are using in the following way:

\begin{description}
\item[ft1]
characteristic tuple
\item[ft2]
declaration
\item[ft3]
predicate
\item[ft4]
body
\item[ty1]
characteristic tuple type
\item[ty2]
body type
\item[itym]
type map assigning types to identifiers in signature
\end{description}

\subsubsection{group 1 abstractions}
Í
	‚g1_abs·	: (TERM â TERM â (IDENT ú TYPE)) ã TERM
…
	Éft2,ft3:TERM; itym:IDENT ú TYPEé

	g1_abs (ft2,ft3,itym)	= schema_abs itym (list_mk_app (g1_bind_cterm,æft2,ft3ø))
À

=DOC
val ‚g1_abs· : TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{group 2 abstractions}
Í
	‚g2_abs·	: (TERM â TERM â TERM â (IDENT ú TYPE)) ã TERM
…
	Éft2, ft3, ft4:TERM; ty2:TYPE; itym:IDENT ú TYPEé

	g2_abs (ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_app (g2_bind_cterm (type_of ft4), æft2, ft3, ft4ø))
À

=DOC
val ‚g2_abs· : TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{group 3 abstractions}
Í
	‚g3_abs·
	: (TERM â TERM â TERM â TERM â (IDENT ú TYPE)) ã TERM
…
	Éft1, ft2, ft3, ft4:TERM; ty1, ty2:TYPE; itym:IDENT ú TYPEé

	g3_abs (ft1, ft2, ft3, ft4, itym)
	= schema_abs itym (list_mk_app (g3_bind_cterm (type_of ft1) (type_of ft4), æft2, ft3, ft1, ft4ø))
À

=DOC
val ‚g3_abs· : TERM * TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\section{END OF SIGNATURE}
=SML
end (* end of ZAbstractMachineSupport signature *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
