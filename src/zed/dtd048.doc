=IGN
********************************************************************************
dtd048.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% dtd048.doc %Z% $Date: 2006/01/12 12:42:18 $ $Revision: 1.24 $ $RCSfile: dtd048.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Support for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Support for Z Types and Terms}
\TPPref{DS/FMU/IED/DTD048}  %% Mandatory field
\def\SCCSversion{$Revision: 1.24 $ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/01/12 12:42:18 $ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
\TPPauthors{G.T.Scullard & MAN05\\D.J.King&WIN01}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1 to 1.12]
First draft versions.
\item [Issue 1.13,1.14 (July 16th 1992)]
Added support for schema renaming.
\item [Issue 1.16 (31st July 1992)]
Removed all the text cribbed from \cite{DS/FMU/IED/ZED002} and
added many functions which should have been in the signature.
\item[Issue 1.18  (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.19,1.20]
Added $z\_sig\_order$.
\item[Issue 1.21] Copyright and banner updates for open source release.
\item[Issue 1.22] PPZed-specific updates for open source release
\item[Issue 1.23] Added error message for {\em unbind\_gvar\_name}.
\item[Issue 1.24] {\em unpack\_ident} redesigned so that only trailing decoration counts and to drop the check on the first part of the name (which is faster and nicer if the user is using non-standard identifiers with embedded decoration characters).
\item[Issue 1.25] Now support decoration on fancyfix identifiers.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document provides a detailed design for a set of support functions for the construction of HOL representations of Z types and terms.
The functions defined here are intended for use in \cite{DS/FMU/IED/DTD047}, the user accessible type and term constructors.
This document is called for in \cite{DS/FMU/IED/HLD017}; the corresponding implementation document is \cite{DS/FMU/IED/IMP048}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{DS/FMU/IED/DTD064} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intercepted and reported as helpfully as possible.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{SIGNATURE}
=DOC
signature ÛZTypesAndTermsSupportÝ = sig
=DESCRIBE
The Z Abstract Machine support functions are packaged into this signature.
=ENDDOC

\subsubsection{Packing and Unpacking Functions}

=DOC
val Ûunpack_identÝ : string -> (string * string);
val Ûpack_identÝ : string * string -> string;
=DESCRIBE
$unpack\_ident$ splits a string representing an IDENT into its WORD and DECOR parts.
It takes the DECOR part of a string to be the longest trailing substring consisting of decoration characters.
The IDENT part of the name may contain embedded decoration characters.

$pack\_ident$ is simply string concatenation.

=ENDDOC

=DOC
val Ûmem'Ý : (string * TYPE) * (string * TYPE) list -> bool
val Ûdrop'Ý : (string * TYPE) list * (string * TYPE -> bool) ->
(string * TYPE) list
val Ûgrab'Ý : (string * TYPE) list * (string * TYPE) -> (string * TYPE) list
val Ûcup'Ý : (string * TYPE) list * (string * TYPE) list ->
(string * TYPE) list
val Ûdiff'Ý : (string * TYPE) list * (string * TYPE) list ->
(string * TYPE) list
=DESCRIBE
=FAILURE
=ENDDOC
=DOC
val Ûz_sig_orderÝ : string -> string -> int
=DESCRIBE
$z\_sig\_order$ defines the order to be used when the signature variables of a Z binding or schema are sorted into canonical order (using $Sort.sort$, q.v.).
It has the property that decorating the signature variables does not change their order.
=ENDDOC

=DOC
val ÛidsetseqÝ : string list -> string list
val ÛflatpackÝ : string list -> string
=DESCRIBE
=ENDDOC


=DOC
val Ûval_set_identÝ : string list -> string
val ÛitymfunseqÝ : (string * TYPE)list -> TYPE list
=DESCRIBE
=ENDDOC

=DOC
val ÛnumberÝ : int -> string
val Ûval_numeralÝ : string -> int
=DESCRIBE
=ENDDOC

=DOC
val Ûsplit_on_barÝ :string -> string * string
=DESCRIBE
=ENDDOC

\subsection{Bindings and Tuples}

\subsubsection{Binding Types}

=DOC
val Ûbind_tnameÝ : string list -> string
val Ûbind_typeÝ : (string * TYPE) list -> TYPE 
=DESCRIBE
Makes a Z binding type from the supplied component to type map.
=EXAMPLE
bind_type [("a",tya),("b",tyb)] = ”(tya,tyb)Z'S[a,b]®
=ENDDOC

\subsubsection{Tuple Types}

=DOC
val Ûtuple_tnameÝ : TYPE list -> string
val Ûtuple_typeÝ : TYPE list -> TYPE 
=DESCRIBE
Makes a Z tuple type from the supplied type list.
=EXAMPLE
tuple_type [tya,tyb] = ¬:(tya,tyb)Z'T[2]®
=ENDDOC

\subsubsection{Binding Constructors}

=DOC
val Ûbind_cnameÝ : string list -> string
val Ûbind_ctypeÝ : (string * TYPE) list -> TYPE
val Ûbind_ctermÝ : (string * TYPE) list -> TERM
=DESCRIBE
Makes a Z binding constructor from the supplied component to type map.
=EXAMPLE
bind_cterm [("a",tya),("b",tyb)] = ¬Z'Mk_S[a,b] : tya ­ tyb ­ (tya,tyb)Z'S[a,b]®
=ENDDOC

\subsubsection{Tuple Constructors}

=DOC
val Ûtuple_cnameÝ : TYPE list -> string
val Ûtuple_ctypeÝ : TYPE list -> TYPE
val Ûtuple_ctermÝ : TYPE list -> TERM
=DESCRIBE
Makes a Z tuple constructor from the supplied type list.
=EXAMPLE
tuple_cterm [tya,tyb] = ¬Z'Mk_T[2] : tya ­ tyb ­ (tya,tyb)Z'T[2]®
=ENDDOC

\subsubsection{Binding Projections}

=DOC
val Ûbind_pnameÝ : string list -> string -> string
val Ûbind_ptypeÝ : (string * TYPE) list -> string -> TYPE
val Ûbind_ptermÝ : (string * TYPE) list -> string -> TERM
=DESCRIBE
Makes a Z binding projection function for the supplied component to type map; the component to be projected is supplied as the second argument.
=EXAMPLE
bind_pterm [("a",tya),("b",tyb)] "a" = ¬Z'S[a,b]a : (tya,tyb)Z'S[a,b] ­ tya®
=ENDDOC

\subsubsection{Tuple Projections}
=DOC
val Ûtuple_pnameÝ : TYPE list -> int -> string
val Ûtuple_ptypeÝ : TYPE list -> int -> TYPE
val Ûtuple_ptermÝ : TYPE list -> int -> TERM
=DESCRIBE
Makes a Z tuple projection function for the supplied
list of types; the component to be projected is supplied
as the second argument.
=EXAMPLE
tuple_pterm [tya,tyb] 1 = ¬Z'S[2]1 : (tya,tyb)Z'T[2] ­ tya®
=FAILURE
48003	Tuple selector must be within the arity of the tuple
=ENDDOC

\subsection{Schemas}

\subsubsection{Schema Types}

=DOC
val Ûschema_typeÝ : (string * TYPE) list -> TYPE
=DESCRIBE
Makes a Z schema type from the supplied component to type map.
=EXAMPLE
schema_type [("a",tya),("b",tyb)] = ¬:((tya,tyb)Z'S[a,b])SET®
=ENDDOC

\subsubsection{Schema Negation}

=DOC
val Ûbind_³_typeÝ : (string * TYPE) list -> TYPE
val Ûbind_³_termÝ : (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z schema negation constructor from the supplied component to type map.
=EXAMPLE
bind_³_term [("a",tya),("b",tyb)] = ¬Z'³‰s : ((tya,tyb)Z'S[a,b])SET
					­ ((tya,tyb)Z'S[a,b])SET®
=ENDDOC

\subsubsection{Schema Precondition}

=DOC
val Ûbind_pre_nameÝ : string list -> string
val Ûbind_pre_typeÝ : (string * TYPE) list -> TYPE
val Ûbind_pre_termÝ : (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z schema precondition constructor from the supplied component to type map.
=EXAMPLE
bind_pre_term [("a'",tya),("b",tyb)] = ¬Z'Pre‰s[a',b] : ((tya,tyb)Z'S[a',b])SET
					­ ((tyb)Z'S[b])SET®
=ENDDOC

\subsubsection{Simple Dyadic Schema Operations}

=DOC
val Ûbind_dysc_nameÝ : string -> string list -> string list -> string 
val Ûbind_dysc_typeÝ : (string * TYPE) list -> (string * TYPE) list -> TYPE 
val Ûbind_dysc_termÝ : string -> (string * TYPE) list -> (string * TYPE) list
				-> TERM  
=DESCRIBE
=ENDDOC


=DOC
val Ûbind_±_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema conjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_±_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'±‰s[a,b][b,c] : (((tya, tyb)Z'S[a,b])SET ­ ((tyb, tyc)Z'S[b,c])SET
					­ ((tya, tyb, tyc)Z'S[a,b,c])SET)®
=ENDDOC

=DOC
val Ûbind_²_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema disjunction constructor from the supplied component to type maps.
=EXAMPLE
bind_²_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'²‰s[a,b][b,c] : (((tya, tyb)Z'S[a,b])SET ­ ((tyb, tyc)Z'S[b,c])SET
					­ ((tya, tyb, tyc)Z'S[a,b,c])SET)®
=ENDDOC

=DOC
val Ûbind_´_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema implication constructor from the supplied component to type maps.
=EXAMPLE
bind_´_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'´‰s[a,b][b,c] : (((tya, tyb)Z'S[a,b])SET ­ ((tyb, tyc)Z'S[b,c])SET
					­ ((tya, tyb, tyc)Z'S[a,b,c])SET)®
=ENDDOC

=DOC
val Ûbind_¤_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema equivalence constructor from the supplied component to type maps.
=EXAMPLE
bind_¤_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'¤‰s[a,b][b,c] : (((tya, tyb)Z'S[a,b])SET ­ ((tyb, tyc)Z'S[b,c])SET
					­ ((tya, tyb, tyc)Z'S[a,b,c])SET)®
=ENDDOC

\subsubsection{Schema Projection}

=DOC
val Ûbind_ù_nameÝ : string list -> string list -> string
val Ûbind_ù_typeÝ : (string * TYPE) list -> (string * TYPE) list -> TYPE
val Ûbind_ù_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z schema projection constructor from the supplied component to type maps.
=EXAMPLE
bind_ù_term [("a",tya),("b",tyb)] [("b",tyb),("c",tyc)] = 
	¬Z'ù‰s[a,b][b,c] : (((tya, tyb)Z'S[a,b])SET ­ ((tyb, tyc)Z'S[b,c])SET
					­ ((tyb, tyc)Z'S[b,c])SET)®
=ENDDOC

\subsubsection{Schema Hiding}

=DOC
val Ûbind_hide_nameÝ : string list -> string list -> string
val Ûbind_hide_typeÝ : (string * TYPE) list -> string list -> TYPE
val Ûbind_hide_termÝ : (string * TYPE) list -> string list -> TERM
=DESCRIBE
Makes the Z schema hiding constructor from the supplied component to type map; the components to be hidden are supplied as the second argument.
=EXAMPLE
bind_hide_term [("a",tya),("b",tyb)] ["a"] = 
	¬Z'Hide‰s[a,b][a] : (((tya, tyb)Z'S[a,b])SET ­ ((tyb)Z'S[b])SET)®
=ENDDOC

\subsubsection{Decoration}

=DOC
val Ûbind_decor_nameÝ : string list -> string -> string
val Ûbind_decor_typeÝ : (string * TYPE) list -> string -> TYPE
val Ûbind_decor_termÝ : (string * TYPE) list -> string -> TERM
=DESCRIBE
Makes the Z schema systematic decoration constructor from the supplied component to type map; the decoration is supplied as the second argument.
=EXAMPLE
bind_decor_term [("a",tya),("b",tyb)] "'" = 
	¬Z'Dec‰s[a,b]['] : ((tya, tyb)Z'S[a,b])SET ­ ((tya, tyb)Z'S[a',b'])SET)®
=ENDDOC

\subsubsection{Delta}

=DOC
val Ûbind_„_nameÝ : string list -> string
val Ûbind_„_typeÝ : (string * TYPE) list -> TYPE
val Ûbind_„_termÝ : (string * TYPE) list -> TERM
=DESCRIBE
=ENDDOC

\subsubsection{Xi}

=DOC
val Ûbind_˜_nameÝ : string list -> string
val Ûbind_˜_typeÝ : (string * TYPE) list -> TYPE
val Ûbind_˜_termÝ : (string * TYPE) list -> TERM;
=DESCRIBE
=ENDDOC

\subsubsection{Schema Composition}

=DOC
val Ûbind_»_nameÝ : string list -> string list -> string
val Ûbind_»_typeÝ : (string * TYPE) list -> (string * TYPE) list -> TYPE
val Ûbind_»_termÝ : (string * TYPE) list -> (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z schema composition constructor from the supplied component to type maps.
=EXAMPLE
bind_scomp_term [("a",tya),("b'",tyb)] [("b",tyb),("c'",tyc)] = 
	¬Z'»‰s[a,b'][b,c'] : (((tya, tyb)Z'S[a,b'])SET ­ ((tyb, tyc)Z'S[b,c'])SET
					­ ((tya, tyc)Z'S[a,c'])SET)®
=ENDDOC

\subsubsection{Global Variables}

=DOC
val Ûbind_gvar_nameÝ : string -> string;
val Ûbind_gvar_termÝ : (string * TYPE) -> TERM;
val Ûunbind_gvar_nameÝ : string -> string;
val Ûunbind_gvar_termÝ : TERM -> (string * TYPE);
=DESCRIBE
Construction and destruction of Z global variables names.
=EXAMPLE
bind_gvar_term ("a",tya) = ¬z'a : tya®
=FAILURE
48012	?0 is not a valid Z global variable name
=ENDDOC


\subsubsection{Renaming}

=DOC
val Ûbind_rename_nameÝ : string list -> (string * string) list -> string
val Ûbind_rename_typeÝ : (string * TYPE) list -> (string * string) list -> TYPE
val Ûbind_rename_termÝ : (string * TYPE) list -> (string * string) list -> TERM
=DESCRIBE
=FAILURE
48011	Unable to form constant name: identifier names not legal Z?
=ENDDOC
\subsection{Variable Binding Constructs}


\subsubsection{Group 1 packs}

=DOC
val Ûg1_bind_sigÝ :(string * TYPE) list
val Ûg1_bind_ctermÝ : TERM
val Ûg1_bind_typeÝ : TYPE
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\subsubsection{Group 2 packs}

=DOC
val Ûg2_bind_sigÝ : TYPE -> (string * TYPE) list
val Ûg2_bind_ctermÝ : TYPE -> TERM
val Ûg2_bind_typeÝ : TYPE -> TYPE
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\subsubsection{Group 3 packs}

=DOC
val Ûg3_bind_sigÝ : TYPE -> TYPE -> (string * TYPE) list
val Ûg3_bind_ctermÝ : TYPE -> TYPE -> TERM
val Ûg3_bind_typeÝ : TYPE -> TYPE -> TYPE
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\subsubsection{Bindings yielding Schema Expressions}

\subsubsection{Schemas}

=DOC
val Ûschema_bnameÝ : string list -> string
val Ûschema_btypeÝ : (string * TYPE) list -> TYPE
val Ûschema_btermÝ : (string * TYPE) list -> TERM;
=DESCRIBE
Makes the Z schema constructor from the supplied component to type map.
=EXAMPLE
schema_bterm [("a",tya),("b",tyb)] = ¬Z'‰s[a,b] : ((tya ­ tyb ­ (BOOL, BOOL)Z'S[d,p])
					­ ((tya, tyb)Z'S[a,b])SET)®
=ENDDOC

\subsubsection{Schema Existential Quantification}

=DOC
val Û¶‰s_bnameÝ : string list -> string list -> string
val Û¶‰s_btypeÝ : (string * TYPE) list -> (string * TYPE) list -> TYPE
val Û¶‰s_btermÝ : (string * TYPE) list -> (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z schema existential quantification constructor from the supplied component to type maps.
=EXAMPLE
¶‰s_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
	¬Z'¶‰s[a,b][c,d] : ((tya ­ tyb ­ (BOOL,BOOL)Z'S[d,p])
		­ ((tya,tyb,tyc,tyd)Z'S[a,b,c,d])SET ­ ((tyc,tyd)Z'S[c,d])SET)®
=ENDDOC

\subsubsection{Schema Unique Existential Quantification}
=DOC
val Û¶‰1‰s_bnameÝ : string list -> string list -> string
val Û¶‰1‰s_btypeÝ : (string * TYPE) list -> (string * TYPE) list -> TYPE
val Û¶‰1‰s_btermÝ : (string * TYPE) list -> (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z schema unique existential quantification constructor from the supplied component to type maps.
=EXAMPLE
¶‰1‰s_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
	¬Z'¶‰1‰s[a,b][c,d] : ((tya ­ tyb ­ (BOOL,BOOL)Z'S[d,p])
		­ ((tya,tyb,tyc,tyd)Z'S[a,b,c,d])SET ­ ((tyc,tyd)Z'S[c,d])SET)®
=ENDDOC

\subsubsection{Schema Universal Quantification}

=DOC
val Ûµ‰s_bnameÝ : string list -> string list ->string
val Ûµ‰s_btypeÝ : (string * TYPE) list -> (string * TYPE) list -> TYPE
val Ûµ‰s_btermÝ : (string * TYPE) list -> (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z schema universal quantification constructor from the supplied component to type maps.
=EXAMPLE
µ‰s_bterm [("a",tya),("b",tyb)][("c",tyc),("d",tyd)] = 
	¬Z'µ‰s[a,b][c,d] : ((tya ­ tyb ­ (BOOL,BOOL)Z'S[d,p])
		­ ((tya,tyb,tyc,tyd)Z'S[a,b,c,d])SET ­ ((tyc,tyd)Z'S[c,d])SET)®
=ENDDOC

\subsubsection{Unique Existential Quantification}

=DOC
val Û¶‰1_bnameÝ : string list -> string 
val Û¶‰1_btypeÝ : (string * TYPE) list -> TYPE
val Û¶‰1_btermÝ : (string * TYPE) list -> TERM
=DESCRIBE
Makes the Z unique existential quantification constructor from the supplied component to type map.
=EXAMPLE
¶‰1_bterm [("a",tya),("b",tyb)] = 
	¬Z'¶‰1[2] : ((tya ­ tyb ­ (BOOL,BOOL,BOOL)Z'S[d,p,v]) ­ BOOL)®
=ENDDOC
\subsubsection{Set Abstraction}

=DOC
val Ûseta_bnameÝ : string list -> string 
val Ûseta_btypeÝ : (string * TYPE) list -> TYPE -> TYPE
val Ûseta_btermÝ : (string * TYPE) list -> TYPE -> TERM
=DESCRIBE
Makes the Z set comprehension constructor from the supplied component to type map.
The type of the members of the resulting set is supplied as the second argument.
=EXAMPLE
seta_bterm [("a",tya),("b",tyb)] tyv = 
	¬Z'Seta[2] : ((tya ­ tyb ­ (BOOL,BOOL,tyv)Z'S[d,p,v]) ­ (tyv)SET)®
=ENDDOC

\subsubsection{Lambda Abstraction}

=DOC
val ÛÌ_bnameÝ : string list -> string 
val ÛÌ_btypeÝ : (string * TYPE) list -> TYPE -> TYPE -> TYPE
val ÛÌ_btermÝ : (string * TYPE) list -> TYPE -> TYPE -> TERM
=DESCRIBE
Makes the Z lambda abstraction constructor from the supplied component to type map.
The types of the domain (characteristic tuple) and range of the resulting function are supplied as the second and third arguments respectively.
=EXAMPLE
Ì_bterm [("a",tya),("b",tyb)] tyt tyv = 
	¬Z'Ì[2] : ((tya ­ tyb ­ (BOOL,BOOL,tyt,tyv)Z'S[d,p,t,v])
		­ ((tyt,tyv)Z'T2)SET)®
=ENDDOC

\subsubsection{Cartesian Products}

=DOC
val Ûprod_cnameÝ : TYPE list -> string
val Ûprod_ctypeÝ : TYPE list -> TYPE 
val Ûprod_ctermÝ : TYPE list -> TERM
=DESCRIBE
Makes a Z cartesian product constructor from the supplied type list.
=EXAMPLE
prod_cterm [tya,tyb] = ¬Z'¸[2] : ((tya)SET,(tyb)SET)Z'T[2] ­ ((tya,tyb)Z'T[2])SET®
=ENDDOC

\subsubsection{Definite Description}

=DOC
val ÛÍ_bnameÝ : string list -> string 
val ÛÍ_btypeÝ : (string * TYPE) list -> TYPE -> TYPE
val ÛÍ_btermÝ : (string * TYPE) list -> TYPE -> TERM
=DESCRIBE
Makes the Z definite description constructor from the supplied component to type map.
The type of the result is supplied as the second argument.
=EXAMPLE
Í_bterm [("a",tya),("b",tyb)] tyv = 
	¬Z'Í[2] : ((tya ­ tyb ­ (BOOL,BOOL,tyv)Z'S[d,p,v]) ­ tyv)®
=ENDDOC

\subsection{Computing the Abstractions}

=DOC
val Ûschema_absÝ : (string * TYPE) list -> TERM -> TERM 
=DESCRIBE
=ENDDOC

\subsubsection{Group 1 Abstractions}

=DOC
val Ûg1_absÝ : TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\subsubsection{Group 2 Abstractions}
=DOC
val Ûg2_¶Ý : TERM * TERM * TERM * (string * TYPE) list -> TERM
val Ûg2_µÝ : TERM * TERM * TERM * (string * TYPE) list -> TERM
=DESCRIBE
=ENDDOC

=DOC
val Ûg2_absÝ : TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC

\subsubsection{Group 3 Abstractions}

=DOC
val Ûg3_absÝ : TERM * TERM * TERM * TERM * (string * TYPE) list -> TERM;
=DESCRIBE
=FAILURE
48002	?0 and ?1 must both be of type ¬:BOOL®
=ENDDOC
\subsection{Predicate Quantification}

\subsubsection{Existential Quantification}

=DOC
val Û¶_bnameÝ : string
val Û¶_btermÝ : TERM
val Û¶body_btermÝ : TERM
=DESCRIBE
The Z existential quantification constructors.
=ENDDOC


\subsubsection{Universal Quantification}

=DOC
val Ûµ_bnameÝ : string
val Ûµ_btermÝ : TERM
val Ûµbody_btermÝ : TERM
=DESCRIBE
The Z universal quantification constructors.
=ENDDOC

\subsubsection{Computing the Abstractions}

=DOC
val Ûschema_¶Ý : (string * TYPE) list -> TERM -> TERM 
val Ûschema_µÝ : (string * TYPE) list -> TERM -> TERM 
=DESCRIBE
=ENDDOC

\section{END OF SIGNATURE}
=SML
end (* end of ZTypesAndTermsSupport signature *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


