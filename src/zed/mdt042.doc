=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Z Expressions}
\TPPref{DS/FMU/IED/MDT042}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
rules and tactics for the Z set theory.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2 (14th September 1992)]
Added theory check.
\item [Issue 1.3 (12th October 1992)]
Split library material into \cite{DS/FMU/IED/MDT083}.
\item [Issue 1.8, 1.9 (30th October 1992)]
Reorganising Z theory material.
\item [Issue 1.10 (13th November)]
Removed duplicated tests.
\item [Issue 1.10 (3rd December 1992)]
Parser error corrected.
\end{description}
\subsection{Changes Forecast}
None known.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD042}.
\subsection{Introduction}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD042}.
This consists of demonstrating at least the simpler uses of the 
functions in question.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP042} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
The testing could be more rigorous.
\section{TEST CASES}
The functions are tested in their order of presentation in the detailed design.
\section{PREAMBLE}
=SML
open_theory "z_sets"; (* to access º *)
delete_theory "temp" handle _ => ();
new_theory "temp";
use_file "dtd013";
use_file "imp013";
init_mt_results();
(* set_flag("subgoal_package_quiet",true); *)
repeat drop_main_goal;
set_flag("check_is_z",true);
=TEX
=SML
push_merge_pcs ["z_predicates","'z__set_lang", "'z_tuples_lang"];
=TEX
\subsection{Utilities}
=SML
fun Ûlist_eqİ (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
If two terms types are equal, break them apart until they differ.
=SML
fun Ûdiffer_whereİ itm1 itm2 = (
let	fun aux tm1 tm2 (App(f1,x1)) (App(f2,x2)) = (
		Value(force_value(aux f1 f2 (dest_simple_term f1) (dest_simple_term f2)))
		handle _ =>
		aux x1 x2 (dest_simple_term x1) (dest_simple_term x2))
	| aux tm1 tm2 (Const(nm1,ty1)) (Const(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (Var(nm1,ty1)) (Var(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (SimpleÌ(x1,b1)) (SimpleÌ(x2,b2)) = (
		if x1 =$ x2 
		then aux b1 b2 (dest_simple_term b1) (dest_simple_term b2)
		else Value(tm1,tm2))
	| aux tm1 tm2 _ _ = Value(tm1,tm2);
in
	aux itm1 itm2 (dest_simple_term itm1) (dest_simple_term itm2)
end);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun Ûtac_resİ tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_resİ tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_res1İ tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (rasms,gl) = top_goal()
		in
			(drop_main_goal();
			(rasms,gl))
		end);
=TEX
Now a function that returns the multiple goals for the case when a tactic causes multiple goals:
=SML
fun Ûtac_ressİ tac n (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val gll = map (top_labelled_goal o string_of_int)
			(interval 1 n)
		in
			(drop_main_goal();
			gll)
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun Ûtac_solveİ tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun Ûtac_failİ tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
\subsection{Some Useful Values}
ÿTEST_SCHEMAü
x:U;
y:U
ˆ
¹Z
rel	px _,py _, pz _
°
[X]
px _ : ğ X;
py _ : ğ X;
pz _ : ğ X
ˆ

ÿS[X]ü
x:X
÷
px x
ˆ
=SML
val aset = ñ{a,b:X; c:Y | ³(a = b) · (a,b,c)}®;
val (asetd, asetp, asetv) = dest_z_seta aset;
val atuple3 = ñ((p º a),(q º a),(r º b))®;
val notz = ¬¶ x · x = y®;
val trues = string_of_term mk_t;
val notzs = string_of_term notz;
=TEX
\section{TESTS}
\subsection{Concerning Í}
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_Í_rule 1",
	concl o z_Í_rule,
	ñÍ x,y:X;z:Y;p:X | z · p(x = y)®,
	¬µ x':'a ·
	ñ(µ x, y : X; z : Y; p : X | z · p (x = y) = x') 
	±
	(¶ x, y : X; z : Y; p : X | z · p (x = y) = x')
	´
	((Í x, y : X; z : Y; p : X | z · p (x = y)) = x')®®),
	("z_Í_rule 2",
	concl o z_Í_rule,
	ñÍ x:X | f x · p x®,
	¬µ x':'b ·
	ñ(µ x :X | f x · p x = x') 
	±
	(¶ x:X | f x · p x = x')
	´
	((Í x:X | f x · p x) = x')®®)];
=TEX
=SML
store_mt_results mt_run_fail [
	("z_Í_rule 47210",
	z_Í_rule,
	mk_t,
	gen_fail_msg "z_Í_rule" 47210 [trues])];
=TEX
\subsection{Concerning Function Application}
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_app_conv",
	snd o dest_eq o concl o z_app_conv,
	ñ[a,b] p (qºa) º b®,
	ñ[a,b] (Í f_a :U | (q ,f_a)  (p º ğ(a ¸ b)) · f_a)®)];
store_mt_results mt_run_fail [
	("z_app_conv 47210",
	z_app_conv,
	mk_t,
	gen_fail_msg "z_app_conv" 47190 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_app_tac 1",
	tac_res z_app_tac,
	ñ[a,b](pº ğ(a ¸ b)) q = r®,
	ñ[a,b] (µ f_a : U | (q, f_a)  (p º ğ(a ¸ b)) · f_a = r) ± 
		(q, r)  p®),
	("z_app_tac 2",
	tac_res z_app_tac,
	ñ(r º {true,false}) ¤ p (qºa)®,
	ñ (µ f_a : U | ((qºa), (f_aº {true,false}))  p · f_a ¤ r) ± 
		(q, r)  p®),
	("z_app_tac 3",
	tac_res z_app_tac,
	ñ¬p:('a, BOOL) $"Z'T[2]" SET® q®,
	ñ (µ f_a : U | (q, f_a)  ¬p:('a, BOOL) $"Z'T[2]" SET® · f_a = true) ± 
		(q, true)  ¬p:('a, BOOL) $"Z'T[2]" SET®®)];
store_mt_results mt_run_fail [
	("z_app_tac 42002",
	tac_fail z_app_tac,
	([],mk_t),
	gen_fail_msg "z_app_tac" 42002 [])];
=TEX
\subsection{Concerning Ì}
=SML
store_mt_results (mt_runf (op =$)) [
	("z_Ì_conv 1",
	snd o dest_eq o concl o z_Ì_conv,
	ñÌ x,y:X;a:Y | f x · g y a®,
	ñ{x, y : X; a : Y | f x · ((x, y, a), ((g y) a))}®),
	("z_Ì_conv 1b",
	snd o dest_eq o concl o z_Ì_conv,
	ñÌ x:X | f x · g x®,
	ñ{x : X | f x · (x, g x)}®),
	("z_Ì_conv 2",
	snd o dest_eq o concl o z_Ì_conv,
	ñÌ [z:Y;x,y : X| x = y] | g x · f z x®,
	ñ{[z : Y; x, y : X | x = y]
	| g x
	· ((Ê[z : Y; x, y : X | x = y]), ((f z) x))}®),
	("z_Ì_conv 3",
	snd o dest_eq o concl o z_Ì_conv,
	ñÌ [x,y : X | x = y] | g x · f x®,
	ñ{[x, y : X | x = y] | g x · ((Ê[x, y : X | x = y]), (f x))}®)
	];
store_mt_results mt_run_fail [
	("z_Ì_conv 47200",
	z_Ì_conv,
	mk_t,
	gen_fail_msg "z_Ì_conv" 47200 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_Â_rule 1",
	concl o z_Â_rule,
	ñ[a,b](Ì x,y : X; z:Y | x = y · (f z x º b)) (1,2,(gºa))®,
	ñ[a,b](µ x':U
	·  (µ f_a : U | (¶ x, y : X; z : Y
            | x = y
            · ((x, y, z) = (1, 2, (g º a)))
            ± ((f z) x = (f_a º b)))
          · f_a = x')
        ± (¶ x, y : X; z : Y
          | x = y · ((x, y, z) = (1, 2, g))
          ± ((f z) x = x'))
      ´ (Ì x, y : X; z : Y | x = y · (f z) x) (1, 2, g) = x')®),
	("z_Â_rule 2",
	concl o z_Â_rule,
	ñ[a,b] (Ì z : X | f z · (g z º b)) (y º a)®,
	ñ[a,b] (µ x: U · (µ f_a : U
          | (¶ z : X | f z · (z = (y º a)) ± (g z º b = f_a))
          · f_a
          = (x º b))
        ± (¶ z : X | f z · (z = y) ± (g z = x))
      ´ (Ì z : X | f z · g z) y = x)®),
	("z_Â_rule 3",
	concl o z_Â_rule,
	ñ(Ì [x,y : X; z:Y| x = y] | g x · f z x) (x ¦ 1,y ¦ 2,z ¦ g)®,
	ñµ x':U
	· (µ f_a : U
          | (¶ [x, y : X; z : Y | x = y]
            | g x
            · (Ê[x, y : X; z : Y | x = y] = (x ¦ 1, y ¦ 2, z ¦ g))
            ± ((f z) x = f_a))
          · f_a
          = x')
        ± (¶ [x, y : X; z : Y | x = y]
          | g x
          · (Ê[x, y : X; z : Y | x = y] = (x ¦ 1, y ¦ 2, z ¦ g))
          ± ((f z) x = x'))
      ´ (Ì [x, y : X; z : Y | x = y] | g x · (f z) x)
            (x ¦ 1, y ¦ 2, z ¦ g)
        = x'®)
	];

store_mt_results mt_run_fail [
	("z_Â_rule 42008",
	z_Â_rule,
	mk_t,
	gen_fail_msg "z_Â_rule" 42008 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [
	("z_Â_conv 1",
	dest_thm o z_Â_conv,
	 ñ[a,b](Ì x : X | f (xºa) · g x º b) y®,
	([ñ[a,b] f (yºa) º {true,false}®, 
	ñ(yºa)  X®], 
	ñ(Ì x : X | f (xºa) · g x º b) y = g y®)),
	("z_Â_conv 2",
	dest_thm o z_Â_conv,
	ñ[a,b,c] (Ì p : U | f (pºa) · g p (qºb) º c) y®,
	([ñ[a,b] f (yºa) º {true,false}®],
	 ñ(Ì p : U | f (pºa) · g p (qºb) º c) y = (g y) q®)),
	("z_Â_conv 3",
	dest_thm o z_Â_conv,
	ñ(Ì p : U · g p q) y®,
	([],ñ(Ì p : U · (g p) q) y = (g y) q®)),
	("z_Â_conv 4",
	dest_thm o z_Â_conv,
	 ñ[a,b] (Ì x : X | f (xºa) · g x º b) x®,
	([ñ[a,b] f (xºa) º {true,false}®, 
	ñ(xºa)  X®], 
	ñ(Ì x : X | f (xºa) · g xº b) x = g x®))
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("z_Â_conv 42012",
	z_Â_conv,
	mk_t,
	gen_fail_msg "z_Â_conv" 42012 [trues])];
=TEX
\subsection{Set Abstraction}
=SML
store_mt_results (mt_runf (op =$)) [("z__seta_conv 1",
	snd o dest_eq o concl o z__seta_conv,
	ñt  {x:U}®,
	ñ¶ x:U · x = t®),
	("z__seta_conv 2",
	snd o dest_eq o concl o z__seta_conv,
	ñ[X] t  {x:X}®,
	ñ[X] (¶ x:X · x = t)®),
	("z__seta_conv 3",
	snd o dest_eq o concl o z__seta_conv,
	ñ[X,Y] t  {x,y:X; z:Y| p x y z}®,
	ñ[X,Y] (¶ x,y:X; z:Y| p x y z · (x,y,z) = t)®),
	("z__seta_conv 4",
	snd o dest_eq o concl o z__seta_conv,
	ñ[X,Y] t  {x,y:X; z:Y| p x y z · q x y z}®,
	ñ[X,Y] (¶ x,y:X; z:Y | p x y z · q x y z = t)®),
	("z__seta_conv 5",
	snd o dest_eq o concl o z__seta_conv,
	ñ[X,Y] (a,b,c)  {x,y:X; z:Y| p x y z}®,
	ñ[X,Y] (¶ x,y:X; z:Y | p x y z · (x,y,z) = (a,b,c))®),
	("z__seta_conv 6",
	snd o dest_eq o concl o z__seta_conv,
	ñ[X,Y] t  {x,y:X; [r,s:Y | r = s]| p x y r s}®,
	ñ[X,Y] (¶ x, y : X; [r, s : Y | r = s]
	 | p x y r s
	  · (x, y, Ê[r, s : Y | r = s]) = t)®)
	];
=TEX
=SML
store_mt_results mt_run_fail [("z__seta_conv 42001 a",
	z__seta_conv,
	mk_t,
	gen_fail_msg "z__seta_conv" 42001 [trues]),
	("z__seta_conv 42001 b",
	z__seta_conv,
	notz,
	gen_fail_msg "z__seta_conv" 42001 [notzs])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z__seta_conv1 1",
	snd o dest_eq o concl o z__seta_conv1,
	ñt  {x:U}®,
	ñtrue®),
	("z__seta_conv1 2",
	snd o dest_eq o concl o z__seta_conv1,
	ñ[X] t  {x:X}®,
	ñ[X] t  X®),
	("z__seta_conv1 3",
	snd o dest_eq o concl o z__seta_conv1,
	ñ[X,Y] t  {x,y:X; z:Y| p x y z}®,
	ñ[X,Y] ({(t º (X ¸ X ¸ Y)).1, t.2} € X ± 
		t.3  Y) ± p t.1 t.2 t.3®),
	("z__seta_conv1 4",
	snd o dest_eq o concl o z__seta_conv1,
	ñ[X,Y] t  {x,y:X; z:Y| p x y z · q x y z}®,
	ñ[X,Y] (¶ x,y:X; z:Y | p x y z · q x y z = t)®),
	("z__seta_conv1 5",
	snd o dest_eq o concl o z__seta_conv1,
	ñ[X,Y] (a,b,c)  {x,y:X; z:Y| p x y z}®,
	ñ[X,Y] ({a, b} € X ± c  Y) ± p a b c º {true,false}®),
	("z__seta_conv1 6",
	snd o dest_eq o concl o z__seta_conv1,
	ñ[X,Y] (tº (X ¸ X ¸ Y))  {x,y:U; z:U| p x y z}®,
	ñ[X,Y] p (t º (X ¸ X ¸ Y)).1 t.2 t.3 º {true,false}®),
	("z__seta_conv1 7",
	snd o dest_eq o concl o z__seta_conv1,
	ñ[X,Y] t  {x,y:X; [r,s:Y | r = s]| p x y r s}®,
	ñ[X,Y] (¶ x, y : X; [r, s : Y | r = s]
	 | p x y r s
	  · (x, y, Ê[r, s : Y | r = s]) = t)®)
];
=TEX
=SML
store_mt_results mt_run_fail [("z__seta_conv1 42001 a",
	z__seta_conv1,
	mk_t,
	gen_fail_msg "z__seta_conv1" 42001 [trues]),
	("z__seta_conv1 42001 b",
	z__seta_conv1,
	notz,
	gen_fail_msg "z__seta_conv1" 42001 [notzs])];
=TEX
\subsection{Set Display}
Difficult to provoke error 42008.
=SML
store_mt_results (mt_runf (op =$)) [("z__setd_conv1",
	snd o dest_eq o concl o z__setd_conv1,
	mk_z_(ñ2®, ñ{1,2,3}®),
	ñtrue®)];
store_mt_results mt_run_fail [("z__setd_conv1 42009 a",
	z__setd_conv1,
	mk_t,
	gen_fail_msg "z__setd_conv1" 42009 [trues]),
	("z__setd_conv1 42009 b",
	z__setd_conv1,
	notz,
	gen_fail_msg "z__setd_conv1" 42009 [notzs]),
	("z__setd_conv1 42009 c",
	z__setd_conv1,
	ñx  {1,2}®,
	gen_fail_msg "z__setd_conv1" 42009
	   [string_of_term ñx  {1,2}®])
	];
=TEX
\subsection{Tuples}
=SML
store_mt_results (mt_runf (op =$)) [("z_tuple_lang_eq_conv a",
	snd o dest_eq o concl o z_tuple_lang_eq_conv,
	ñ(a,b) = (1,2)®,
	ña = 1 ± b = 2®)];
store_mt_results mt_run_fail [("z_tuple_lang_eq_conv 42003",
	z_tuple_lang_eq_conv,
	mk_t,
	gen_fail_msg "z_tuple_lang_eq_conv" 42003 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_tuple_lang_selection_conv a",
	snd o dest_eq o concl o z_tuple_lang_selection_conv,
	ñ(1,2,3).2®,
	ñ2®)];
store_mt_results mt_run_fail [("z_tuple_lang_selection_conv 47185",
	z_tuple_lang_selection_conv,
	mk_t,
	gen_fail_msg "z_tuple_lang_selection_conv" 47185 [trues]),
	("z_tuple_lang_selection_conv 42006",
	z_tuple_lang_selection_conv,
	mk_z_sel‰t (mk_var("t",type_of ñ(1,2,3)®),2),
	gen_fail_msg "z_tuple_lang_selection_conv" 42006 [
		string_of_term(mk_z_sel‰t (mk_var("t",type_of ñ(1,2,3)®),2))])
	];
=TEX
=SML
let
	val atuple = mk_var("t",type_of ñ(1,2,3)®);
in
store_mt_results (mt_runf (op =$)) [
	("z_tuple_lang_intro_conv a",
	snd o dest_eq o concl o z_tuple_lang_intro_conv,
	ñ(‘atuple®.1,‘atuple®.2,‘atuple®.3)®,
	atuple)]
end;
store_mt_results mt_run_fail [("z_tuple_lang_intro_conv 42005 a",
	z_tuple_lang_intro_conv,
	mk_t,
	gen_fail_msg "z_tuple_lang_intro_conv" 42005 [trues]),
	("z_tuple_lang_intro_conv 42005 b",
	z_tuple_lang_intro_conv,
	ñ(1,2,3)®,
	gen_fail_msg "z_tuple_lang_intro_conv" 42005 [
		string_of_term ñ(1,2,3)®])
,
	("z_tuple_lang_intro_conv 42005 c",
	z_tuple_lang_intro_conv,
	ñ((1,2,3).1,(1,2,3).2)®,
	gen_fail_msg "z_tuple_lang_intro_conv" 42005 [
		string_of_term ñ((1,2,3).1,(1,2,3).2)®])
	];
=TEX
=SML
let
	val atuple = mk_var("t",type_of ñ(1,2,3)®);
in
store_mt_results (mt_runf (op =$)) [("z_tuple_selection_intro_conv",
	snd o dest_eq o concl o z_tuple_selection_intro_conv,
	atuple,
	ñ(‘atuple®.1,‘atuple®.2,‘atuple®.3)®)]
end;
store_mt_results mt_run_fail [("z_tuple_selection_intro_conv 42004",
	z_tuple_selection_intro_conv,
	mk_t,
	gen_fail_msg "z_tuple_selection_intro_conv" 42004 [trues])
	];
=TEX

\section{CARTESIAN PRODUCTS}
=SML
store_mt_results (mt_runf (op =$)) [("z_¸_conv",
	snd o dest_eq o concl o z_¸_conv,
	ñS1 ¸ S2 ¸ ğ S2 ¸ {t‰2}®,
	ñ{t‰1:S1; t‰3:S2; t‰4: ğ S2; t‰5 : {t‰2}·(t‰1,  t‰3, t‰4, t‰5)}®)];
store_mt_results mt_run_fail [("z_¸_conv 47160",
	z_¸_conv,
	mk_t,
	gen_fail_msg "z_¸_conv" 47160 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z__¸_conv",
	snd o dest_eq o concl o z__¸_conv,
	ñ[S1,S2] y  S1 ¸ S2 ¸ ğ S2®,
	ñ[S1,S2] (y º (S1 ¸ S2 ¸ ğ S2)).1  S1 ± y.2  S2 ± y.3  ğ S2®)];
store_mt_results mt_run_fail [("z__¸_conv 42007",
	z__¸_conv,
	mk_t,
	gen_fail_msg "z__¸_conv" 42007 [trues])
	];
=TEX
\section{Extensionality of Sets}
=SML
store_mt_results (mt_runf (op =$)) [("z_sets_ext_conv 1",
	snd o dest_eq o concl o z_sets_ext_conv,
	ñ{1,x1} = {2,x2}®,
	ñµ x3 : U · x3  {1,x1} ¤ x3  {2,x2}®),
	("z_sets_ext_conv 2",
	snd o dest_eq o concl o z_sets_ext_conv,
	ñ{(1,x1)} = {(2,x3)}®,
	ñµ x2 : U; x4 : U · (x2,x4)  {(1,x1)} ¤ (x2,x4)  {(2,x3)}®)];
store_mt_results mt_run_fail [("z_sets_ext_conv 42010 a",
	z_sets_ext_conv,
	mk_t,
	gen_fail_msg "z_sets_ext_conv" 42010 [trues]),
	("z_sets_ext_conv 42010 b",
	z_sets_ext_conv,
	ñtrue ¤ true®,
	gen_fail_msg "z_sets_ext_conv" 42010 [string_of_term ñtrue ¤ true®])
	];
=TEX
\section{Binding Displays}
=SML
store_mt_results (mt_runf (op =$)) [("z_binding_eq_conv",
	snd o dest_eq o concl o z_binding_eq_conv,
	ñÊ S = (x ¦ y)®,
	ñ((Ê S).x = (x ¦ y).x)®)];
store_mt_results mt_run_fail [("z_binding_eq_conv 42013conv",
	z_binding_eq_conv,
	mk_t,
	gen_fail_msg "z_binding_eq_conv" 42013 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_binding_eq_conv1 a",
	snd o dest_eq o concl o z_binding_eq_conv1,
	ñÊ S = (x ¦ y)®,
	ñ((Ê S).x = y)®),
	("z_binding_eq_conv1 b",
	snd o dest_eq o concl o z_binding_eq_conv1,
	ñ(x ¦ y) = Ê S®,
	ñ(y = (Ê S).x)®),
	("z_binding_eq_conv1 c",
	snd o dest_eq o concl o z_binding_eq_conv1,
	ñ(x ¦ y) = (x ¦ z)®,
	ñ(y = z)®)];
store_mt_results mt_run_fail [("z_binding_eq_conv1 42013",
	z_binding_eq_conv1,
	mk_t,
	gen_fail_msg "z_binding_eq_conv1" 42013 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_binding_sel_conv a",
	snd o dest_eq o concl o z_binding_sel_conv,
	ñ(x ¦ y, p ¦ q).x®,
	ñy®),
	("z_binding_sel_conv b",
	snd o dest_eq o concl o z_binding_sel_conv,
	ñ(x ¦ y, p ¦ q).p®,
	¬q:'b®)];
store_mt_results mt_run_fail [("z_binding_sel_conv 42014",
	z_binding_sel_conv,
	mk_t,
	gen_fail_msg "z_binding_sel_conv" 42014 [trues])
	];
=TEX

\section{MISCELLANEOUS}
=SML
store_mt_results (mt_runf (op =$)) [
	("z_defn_simp_rule a",
	concl o z_defn_simp_rule,
	(asm_rule ¬Z'AbbDef ñp  ğ(X ¸ Y) ± (µ q : X ¸ Y · q  p ¤ f q = q.1)®®),
	ñµ q : U ·
	q  p ¤ q  X ¸ Y ± f q = q.1®),
	("z_defn_simp_rule b",
	concl o z_defn_simp_rule,
	(conv_rule 
	(RAND_C(LEFT_C (DECL_INTRO_C pred_dec_conv)))
	(asm_rule ¬Z'AbbDef ñp  ğ(X ¸ Y) ± (µ q : X ¸ Y · q  p ¤ f q = q.1)®®)),
	ñµ q : U· q  p ¤ q  X ¸ Y ± f q = q.1®)];
=TEX

[X,Y]œœœœœœœœœœœœœœœœ
Ü Test : ğ (X ¸ Y)
÷üüüüüüüüüüüüüüüüüü
Ü µ xy : X ¸ Y ·
Ü	xy  Test ¤ (xy = xy) 
ˆüüüüüüüüüüüüüüüüüüüü

=SML
store_mt_results (mt_runf (op =$)) [
	("z_defn_simp_rule c",
	concl o z_defn_simp_rule,
	(get_spec ñTest®),
	(¬µ X:'X SET; Y:'Y SET· 
	ñ[X,Y](µ xy : U · xy  Test[X, Y] ¤ xy  X ¸ Y ± xy = xy)®®))];
=TEX
=SML
store_mt_results mt_run_fail [("z_defn_simp_rule 42011",
	z_defn_simp_rule,
	t_thm,
	gen_fail_msg "z_defn_simp_rule" 42011 [string_of_thm t_thm])
	];
=TEX

\section{PROOF CONTEXTS}
The following is not an exhaustive test of stripping under
the Z set theory proof contexts, but is a good test
of presence and basic intent.
=SML
let 
val example_tm = ñµ x : U; y:U · {1,2} ¸ {3,4} = {(1,3),(1,4),(2,3),(2,4)}®;
fun aux tm = (
push_merge_pcs["z_predicates","'z__set_lang","'z_sets_ext_lang", "'z_tuples_lang", "'z_bindings"];
set_goal([],tm);
a(asm_prove_tac[]);
pop_pc();
pop_thm());
in
store_mt_results (mt_runf (op =$)) [("Z set theory stripping",
	concl o aux,
	example_tm,
	example_tm)]
end;
=TEX
A check for $Â$ reduction:
=SML
store_mt_results (mt_runf (op =$)) [("z__set_lang pc Â",
	concl o rewrite_conv [],
	ñ(Ì x : U · f x) (1, 2)®,
	ñ(Ì x : U · f x) (1, 2) = f (1, 2)®)];
=TEX
\section{CHECK THE THEORY DESIGN}
=SML
use_file "dtd042.tch";
store_mt_results mt_run [("theory design of Z set theory",
	theory_check_success,
	(),
	true)];
=TEX
\section{END OF TESTS}
=SML
(* set_flag("subgoal_package_quiet",false); *)
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results (mt_runf (op =$)) [("",
	tac_res ,
	ñ®,
	ñ®)];
store_mt_results (mt_runf (op =$)) [("",
	snd o dest_eq o concl o  ,
	ñ®,
	ñ®)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];
store_mt_results (mt_runf (op =#)) [("",
	tac_res1 ,
	([ñ®],ñ®),
	([ñ®],ñ®))];
store_mt_results (mt_runf (list_eq(op =#))) [("",
	tac_ress  2,
	([ñ®],ñ®),
	[([ñ®],ñ®),([ñ®],ñ®)])];
store_mt_results mt_runf [
	("",
	tac_solve ,
	([],ñ®),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],ñ®),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];

