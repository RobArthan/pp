=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Z Expressions}
\TPPref{DS/FMU/IED/MDT042}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
rules and tactics for the Z set theory.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2 (14th September 1992)]
Added theory check.
\item [Issue 1.3 (12th October 1992)]
Split library material into \cite{DS/FMU/IED/MDT083}.
\item [Issue 1.8, 1.9 (30th October 1992)]
Reorganising Z theory material.
\item [Issue 1.10 (13th November)]
Removed duplicated tests.
\item [Issue 1.10 (3rd December 1992)]
Parser error corrected.
\item [Issue 1.11 (3rd December 1992)]
Gained $ç\_C$, and $Z\-\_ç\-\_ELIM\-\_C$, handling of literals, sequences, and $ç\-\_Ã\-\_conv$.
\item [Issue 1.13, 7th December 1992] 
Fixing problems from changes to generic formals.
\item [Issue 1.14, 9th December 1992] 
Bug fixing.
\item [Issue 1.15, 10th December 1992] 
Added string literals.
\item[Issue 1.16 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.17 (17th December 1992)]
Enhanced treatment of bindings.
\end{description}
\subsection{Changes Forecast}
None known.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD042}.
\subsection{Introduction}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD042}.
This consists of demonstrating at least the simpler uses of the 
functions in question.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP042} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
The testing could be more rigorous.
\section{TEST CASES}
The functions are tested in their order of presentation in the detailed design.
$ç\_C$, and $Z\-\_ç\-\_ELIM\-\_C$ are tested by their 
use in implementing other functions, especially in 
\cite{DS/FMU/IED/MDT043}.
\section{PREAMBLE}
=SML
open_theory "z_sets"; (* to access ∫ *)
delete_theory "temp" handle _ => ();
new_theory "temp";
use_file "dtd013";
use_file "imp013";
init_mt_results();
(* set_flag("subgoal_package_quiet",true); *)
repeat drop_main_goal;
set_flag("check_is_z",true);
=TEX
=SML
set_flag ("z_type_check_only", false);
set_flag ("z_use_axioms", true);
=TEX
=SML
push_merge_pcs ["z_predicates","'z_ç_set_lang", "'z_tuples_lang"];
=TEX
\subsection{Utilities}
=SML
fun €list_eq› (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
If two terms types are equal, break them apart until they differ.
=SML
fun €differ_where› itm1 itm2 = (
let	fun aux tm1 tm2 (App(f1,x1)) (App(f2,x2)) = (
		Value(force_value(aux f1 f2 (dest_simple_term f1) (dest_simple_term f2)))
		handle _ =>
		aux x1 x2 (dest_simple_term x1) (dest_simple_term x2))
	| aux tm1 tm2 (Const(nm1,ty1)) (Const(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (Var(nm1,ty1)) (Var(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (SimpleÃ(x1,b1)) (SimpleÃ(x2,b2)) = (
		if x1 =$ x2 
		then aux b1 b2 (dest_simple_term b1) (dest_simple_term b2)
		else Value(tm1,tm2))
	| aux tm1 tm2 _ _ = Value(tm1,tm2);
in
	aux itm1 itm2 (dest_simple_term itm1) (dest_simple_term itm2)
end);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun €tac_res› tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun €tac_res› tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun €tac_res1› tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (rasms,gl) = top_goal()
		in
			(drop_main_goal();
			(rasms,gl))
		end);
=TEX
Now a function that returns the multiple goals for the case when a tactic causes multiple goals:
=SML
fun €tac_ress› tac n (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val gll = map (top_labelled_goal o string_of_int)
			(interval 1 n)
		in
			(drop_main_goal();
			gll)
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun €tac_solve› tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun €tac_fail› tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
\subsection{Some Useful Values}
ˇTEST_SCHEMA¸
x:U;
y:U
à
πZ
rel	px _,py _, pz _
∞
ù[X]
px _ :  X;
py _ :  X;
pz _ :  X
à

ˇS[X]¸
x:X
˜
px x
à
=SML
val aset = Ò{a,b:X; c:Y | ≥(a = b) ∑ (a,b,c)}Æ;
val (asetd, asetp, asetv) = dest_z_seta aset;
val atuple3 = Ò((p ∫ a),(q ∫ a),(r ∫ b))Æ;
val notz = ¨∂ x ∑ x = yÆ;
val trues = string_of_term mk_t;
val notzs = string_of_term notz;
=TEX
\section{TESTS}
\subsection{Concerning Õ}
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_Õ_rule 1",
	concl o z_Õ_rule,
	ÒÕ x,y:X;z:Y;p:X | z ∑ p(x = y)Æ,
	¨µ x':'a ∑
	Ò(µ x, y : X; z : Y; p : X | z ∑ p (x = y) = x') 
	±
	(∂ x, y : X; z : Y; p : X | z ∑ p (x = y) = x')
	¥
	((Õ x, y : X; z : Y; p : X | z ∑ p (x = y)) = x')ÆÆ),
	("z_Õ_rule 2",
	concl o z_Õ_rule,
	ÒÕ x:X | f x ∑ p xÆ,
	¨µ x':'b ∑
	Ò(µ x :X | f x ∑ p x = x') 
	±
	(∂ x:X | f x ∑ p x = x')
	¥
	((Õ x:X | f x ∑ p x) = x')ÆÆ)];
=TEX
=SML
store_mt_results mt_run_fail [
	("z_Õ_rule 47210",
	z_Õ_rule,
	mk_t,
	gen_fail_msg "z_Õ_rule" 47210 [trues])];
=TEX
\subsection{Concerning Function Application}
=SML
store_mt_results (mt_runf (op =$)) [(
	"z_app_conv",
	snd o dest_eq o concl o z_app_conv,
	Òp (q∫a)Æ,
	inst [] [(î'aÆ,î'bÆ),(î'bÆ,î'aÆ)]
	Ò(Õ f_a :U | (q ,f_a) ç (p ∫ (a ∏ b)) ∑ f_a)Æ)];
store_mt_results mt_run_fail [
	("z_app_conv 47210",
	z_app_conv,
	mk_t,
	gen_fail_msg "z_app_conv" 47190 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_app_eq_tac 1",
	tac_res z_app_eq_tac,
	(snd(strip_µ Ò[a,b](p∫ (a ∏ b)) q = rÆ)),
	(snd(strip_µ Ò[a,b] (µ f_a : U | (q, f_a) ç (p ∫ (a ∏ b)) ∑ f_a = r) ± 
		(q, r) ç pÆ))),
	("z_app_eq_tac 2",
	tac_res z_app_eq_tac,
	Ò(r ∫ {true,false}) § p (q∫a)Æ,
	Ò (µ f_a : U | ((q∫a), (f_a∫ {true,false})) ç p ∑ f_a § r) ± 
		(q, r) ç pÆ),
	("z_app_eq_tac 3",
	tac_res z_app_eq_tac,
	Ò¨p:('a, BOOL) $"Z'T[2]" SETÆ qÆ,
	Ò (µ f_a : U | (q, f_a) ç ¨p:('a, BOOL) $"Z'T[2]" SETÆ ∑ f_a = true) ± 
		(q, true) ç ¨p:('a, BOOL) $"Z'T[2]" SETÆÆ)];
store_mt_results mt_run_fail [
	("z_app_eq_tac 42002",
	tac_fail z_app_eq_tac,
	([],mk_t),
	gen_fail_msg "z_app_eq_tac" 42002 [])];
=TEX
\subsection{Concerning Ã}
=SML
store_mt_results (mt_runf (op =$)) [
	("z_Ã_conv 1",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ x,y:X;a:Y | f x ∑ g y aÆ,
	Ò{x, y : X; a : Y | f x ∑ ((x, y, a), ((g y) a))}Æ),
	("z_Ã_conv 1b",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ x:X | f x ∑ g xÆ,
	Ò{x : X | f x ∑ (x, g x)}Æ),
	("z_Ã_conv 2",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ [z:Y;x,y : X| x = y] | g x ∑ f z xÆ,
	Ò{[z : Y; x, y : X | x = y]
	| g x
	∑ (( [z : Y; x, y : X | x = y]), ((f z) x))}Æ),
	("z_Ã_conv 3",
	snd o dest_eq o concl o z_Ã_conv,
	ÒÃ [x,y : X | x = y] | g x ∑ f xÆ,
	Ò{[x, y : X | x = y] | g x ∑ (( [x, y : X | x = y]), (f x))}Æ)
	];
store_mt_results mt_run_fail [
	("z_Ã_conv 47200",
	z_Ã_conv,
	mk_t,
	gen_fail_msg "z_Ã_conv" 47200 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_ç_Ã_conv 1",
	snd o dest_eq o concl o z_ç_Ã_conv,
	Òv ç (Ã x,y:X;a:Y | f x ∑ g y a)Æ,
	Òv ç {x, y : X; a : Y | f x ∑ ((x, y, a), ((g y) a))}Æ),
	("z_ç_Ã_conv 1b",
	snd o dest_eq o concl o z_ç_Ã_conv,
	Òv ç (Ã x:X | f x ∑ g x)Æ,
	Òv ç {x : X | f x ∑ (x, g x)}Æ),
	("z_ç_Ã_conv 2",
	snd o dest_eq o concl o z_ç_Ã_conv,
	Òv ç (Ã [z:Y;x,y : X| x = y] | g x ∑ f z x)Æ,
	Òv ç {[z : Y; x, y : X | x = y]
	| g x
	∑ (( [z : Y; x, y : X | x = y]), ((f z) x))}Æ),
	("z_ç_Ã_conv 3",
	snd o dest_eq o concl o z_ç_Ã_conv,
	Òv ç (Ã [x,y : X | x = y] | g x ∑ f x)Æ,
	Òv ç {[x, y : X | x = y] | g x ∑ (( [x, y : X | x = y]), (f x))}Æ)
	];
store_mt_results mt_run_fail [
	("z_ç_Ã_conv 42028",
	z_ç_Ã_conv,
	mk_t,
	gen_fail_msg "ç_C" 42028 [trues]),
	("z_ç_Ã_conv 47200",
	z_ç_Ã_conv,
	Òx ç yÆ,
	gen_fail_msg "z_Ã_conv" 47200 [string_of_term ÒyÆ])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [
	("z_app_Ã_rule 1",
	concl o z_app_Ã_rule,
	Ò(Ã x,y : X; z:Y | x = y ∑ (f z x ∫ b)) (1,2,(g∫a))Æ,
	inst [] [(î'aÆ,î'bÆ),(î'bÆ,î'aÆ)]
	Ò(µ x':U
	∑  (µ f_a : U | (∂ x, y : X; z : Y
            | x = y
            ∑ ((x, y, z) = (1, 2, (g ∫ a)))
            ± ((f z) x = (f_a ∫ b)))
          ∑ f_a = x')
        ± (∂ x, y : X; z : Y
          | x = y ∑ ((x, y, z) = (1, 2, g))
          ± ((f z) x = x'))
      ¥ (Ã x, y : X; z : Y | x = y ∑ (f z) x) (1, 2, g) = x')Æ),
	("z_app_Ã_rule 2",
	concl o z_app_Ã_rule,
	Ò(Ã z : X | f z ∑ (g z ∫ b)) (y ∫ a)Æ,
	inst [] [(î'aÆ,î'bÆ),(î'bÆ,î'aÆ)]
	Ò(µ x: U ∑ (µ f_a : U
          | (∂ z : X | f z ∑ (z = (y ∫ a)) ± (g z ∫ b = f_a))
          ∑ f_a
          = (x ∫ b))
        ± (∂ z : X | f z ∑ (z = y) ± (g z = x))
      ¥ (Ã z : X | f z ∑ g z) y = x)Æ),
	("z_app_Ã_rule 3",
	concl o z_app_Ã_rule,
	Ò(Ã [x,y : X; z:Y| x = y] | g x ∑ f z x) (x ¶ 1,y ¶ 2,z ¶ g)Æ,
	Òµ x':U
	∑ (µ f_a : U
          | (∂ [x, y : X; z : Y | x = y]
            | g x
            ∑ ( [x, y : X; z : Y | x = y] = (x ¶ 1, y ¶ 2, z ¶ g))
            ± ((f z) x = f_a))
          ∑ f_a
          = x')
        ± (∂ [x, y : X; z : Y | x = y]
          | g x
          ∑ ( [x, y : X; z : Y | x = y] = (x ¶ 1, y ¶ 2, z ¶ g))
          ± ((f z) x = x'))
      ¥ (Ã [x, y : X; z : Y | x = y] | g x ∑ (f z) x)
            (x ¶ 1, y ¶ 2, z ¶ g)
        = x'Æ)
	];

store_mt_results mt_run_fail [
	("z_app_Ã_rule 42008",
	z_app_Ã_rule,
	mk_t,
	gen_fail_msg "z_app_Ã_rule" 42008 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [
	("z_¬_conv 1",
	dest_thm o z_¬_conv,
	Ò(Ã x : X | f (x∫a) ∑ g x ∫ b) yÆ,
	([(snd(strip_µ Ò[a,b] f (y∫a) ∫ {true,false}Æ)), 
	(snd(strip_µ Ò[a](y∫a) ç XÆ))], 
	Ò(Ã x : X | f (x∫a) ∑ g x ∫ b) y = g yÆ)),
	("z_¬_conv 2",
	dest_thm o z_¬_conv,
	Ò(Ã p : U | f (p∫a) ∑ g p (q∫b) ∫ c) yÆ,
	([(snd(strip_µ Ò[a,b] f (y∫a) ∫ {true,false}Æ))],
	 Ò(Ã p : U | f (p∫a) ∑ g p (q∫b) ∫ c) y = (g y) qÆ)),
	("z_¬_conv 3",
	dest_thm o z_¬_conv,
	Ò(Ã p : U ∑ g p q) yÆ,
	([],Ò(Ã p : U ∑ (g p) q) y = (g y) qÆ)),
	("z_¬_conv 4",
	dest_thm o z_¬_conv,
	Ò(Ã x : X | f (x∫a) ∑ g x ∫ b) xÆ,
	([(snd(strip_µ Ò[a,b] f (x∫a) ∫ {true,false}Æ)), 
	Ò(x∫a) ç XÆ], 
	Ò(Ã x : X | f (x∫a) ∑ g x∫ b) x = g xÆ))
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("z_¬_conv 42012",
	z_¬_conv,
	mk_t,
	gen_fail_msg "z_¬_conv" 42012 [trues])];
=TEX
\subsection{Set Abstraction}
=SML
store_mt_results (mt_runf (op =$)) [("z_ç_seta_conv 1",
	snd o dest_eq o concl o z_ç_seta_conv,
	Òt ç {x:U}Æ,
	Ò∂ x:U ∑ x = tÆ),
	("z_ç_seta_conv 2",
	snd o dest_eq o concl o z_ç_seta_conv,
	(snd(strip_µ Ò[X] t ç {x:X}Æ)),
	(snd(strip_µ Ò[X] (∂ x:X ∑ x = t)Æ))),
	("z_ç_seta_conv 3",
	snd o dest_eq o concl o z_ç_seta_conv,
	(snd(strip_µ Ò[X,Y] t ç {x,y:X; z:Y| p x y z}Æ)),
	(snd(strip_µ Ò[X,Y] (∂ x,y:X; z:Y| p x y z ∑ (x,y,z) = t)Æ))),
	("z_ç_seta_conv 4",
	snd o dest_eq o concl o z_ç_seta_conv,
	(snd(strip_µ Ò[X,Y] t ç {x,y:X; z:Y| p x y z ∑ q x y z}Æ)),
	(snd(strip_µ Ò[X,Y] (∂ x,y:X; z:Y | p x y z ∑ q x y z = t)Æ))),
	("z_ç_seta_conv 5",
	snd o dest_eq o concl o z_ç_seta_conv,
	(snd(strip_µ Ò[X,Y] (a,b,c) ç {x,y:X; z:Y| p x y z}Æ)),
	(snd(strip_µ Ò[X,Y] (∂ x,y:X; z:Y | p x y z ∑ (x,y,z) = (a,b,c))Æ))),
	("z_ç_seta_conv 6",
	snd o dest_eq o concl o z_ç_seta_conv,
	(snd(strip_µ Ò[X,Y] t ç {x,y:X; [r,s:Y | r = s]| p x y r s}Æ)),
	(snd(strip_µ Ò[X,Y] (∂ x, y : X; [r, s : Y | r = s]
	 | p x y r s
	  ∑ (x, y,  [r, s : Y | r = s]) = t)Æ)))
	];
=TEX
=SML
store_mt_results mt_run_fail [("z_ç_seta_conv 42001 a",
	z_ç_seta_conv,
	mk_t,
	gen_fail_msg "z_ç_seta_conv" 42001 [trues]),
	("z_ç_seta_conv 42001 b",
	z_ç_seta_conv,
	notz,
	gen_fail_msg "z_ç_seta_conv" 42001 [notzs])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_ç_seta_conv1 1",
	snd o dest_eq o concl o z_ç_seta_conv1,
	Òt ç {x:U}Æ,
	ÒtrueÆ),
	("z_ç_seta_conv1 2",
	snd o dest_eq o concl o z_ç_seta_conv1,
	(snd(strip_µ Ò[X] t ç {x:X}Æ)),
	(snd(strip_µ Ò[X] t ç XÆ))),
	("z_ç_seta_conv1 3",
	snd o dest_eq o concl o z_ç_seta_conv1,
	(snd(strip_µ Ò[X,Y] t ç {x,y:X; z:Y| p x y z}Æ)),
	(snd(strip_µ Ò[X,Y] ({(t ∫ (X ∏ X ∏ Y)).1, t.2} Ä X ± 
		t.3 ç Y) ± p t.1 t.2 t.3Æ))),
	("z_ç_seta_conv1 4",
	snd o dest_eq o concl o z_ç_seta_conv1,
	(snd(strip_µ Ò[X,Y] t ç {x,y:X; z:Y| p x y z ∑ q x y z}Æ)),
	(snd(strip_µ Ò[X,Y] (∂ x,y:X; z:Y | p x y z ∑ q x y z = t)Æ))),
	("z_ç_seta_conv1 5",
	snd o dest_eq o concl o z_ç_seta_conv1,
	(snd(strip_µ Ò[X,Y] (a,b,c) ç {x,y:X; z:Y| p x y z}Æ)),
	(snd(strip_µ Ò[X,Y] ({a, b} Ä X ± c ç Y) ± p a b c ∫ {true,false}Æ))),
	("z_ç_seta_conv1 6",
	snd o dest_eq o concl o z_ç_seta_conv1,
	(snd(strip_µ Ò[X,Y] (t∫ (X ∏ X ∏ Y)) ç {x,y:U; z:U| p x y z}Æ)),
	(snd(strip_µ Ò[X,Y] p (t ∫ (X ∏ X ∏ Y)).1 t.2 t.3 ∫ {true,false}Æ))),
	("z_ç_seta_conv1 7",
	snd o dest_eq o concl o z_ç_seta_conv1,
	(snd(strip_µ Ò[X,Y] t ç {x,y:X; [r,s:Y | r = s]| p x y r s}Æ)),
	(snd(strip_µ Ò[X,Y] (∂ x, y : X; [r, s : Y | r = s]
	 | p x y r s
	  ∑ (x, y,  [r, s : Y | r = s]) = t)Æ)))
];
=TEX
=SML
store_mt_results mt_run_fail [("z_ç_seta_conv1 42001 a",
	z_ç_seta_conv1,
	mk_t,
	gen_fail_msg "z_ç_seta_conv1" 42001 [trues]),
	("z_ç_seta_conv1 42001 b",
	z_ç_seta_conv1,
	notz,
	gen_fail_msg "z_ç_seta_conv1" 42001 [notzs])];
=TEX
\subsection{Set Display}
Difficult to provoke error 42008.
=SML
store_mt_results (mt_runf (op =$)) [("z_ç_setd_conv1",
	snd o dest_eq o concl o z_ç_setd_conv1,
	mk_z_ç(Ò2Æ, Ò{1,2,3}Æ),
	ÒtrueÆ)];
store_mt_results mt_run_fail [("z_ç_setd_conv1 42009 a",
	z_ç_setd_conv1,
	mk_t,
	gen_fail_msg "z_ç_setd_conv1" 42009 [trues]),
	("z_ç_setd_conv1 42009 b",
	z_ç_setd_conv1,
	notz,
	gen_fail_msg "z_ç_setd_conv1" 42009 [notzs]),
	("z_ç_setd_conv1 42009 c",
	z_ç_setd_conv1,
	Òx ç {1,2}Æ,
	gen_fail_msg "z_ç_setd_conv1" 42009
	   [string_of_term Òx ç {1,2}Æ])
	];
=TEX
\subsection{Tuples}
=SML
store_mt_results (mt_runf (op =$)) [("z_tuple_lang_eq_conv a",
	snd o dest_eq o concl o z_tuple_lang_eq_conv,
	Ò(a,b) = (1,2)Æ,
	Òa = 1 ± b = 2Æ)];
store_mt_results mt_run_fail [("z_tuple_lang_eq_conv 42003",
	z_tuple_lang_eq_conv,
	mk_t,
	gen_fail_msg "z_tuple_lang_eq_conv" 42003 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_selât_lang_conv a",
	snd o dest_eq o concl o z_selât_lang_conv,
	Ò(1,2,3).2Æ,
	Ò2Æ)];
store_mt_results mt_run_fail [("z_selât_lang_conv 47185",
	z_selât_lang_conv,
	mk_t,
	gen_fail_msg "z_selât_lang_conv" 47185 [trues]),
	("z_selât_lang_conv 42006",
	z_selât_lang_conv,
	mk_z_selât (mk_var("t",type_of Ò(1,2,3)Æ),2),
	gen_fail_msg "z_selât_lang_conv" 42006 [
		string_of_term(mk_z_selât (mk_var("t",type_of Ò(1,2,3)Æ),2))])
	];
=TEX
=SML
let
	val atuple = mk_var("t",type_of Ò(1,2,3)Æ);
in
store_mt_results (mt_runf (op =$)) [
	("z_tuple_lang_intro_conv a",
	snd o dest_eq o concl o z_tuple_lang_intro_conv,
	Ò(ëatupleÆ.1,ëatupleÆ.2,ëatupleÆ.3)Æ,
	atuple)]
end;
store_mt_results mt_run_fail [("z_tuple_lang_intro_conv 42005 a",
	z_tuple_lang_intro_conv,
	mk_t,
	gen_fail_msg "z_tuple_lang_intro_conv" 42005 [trues]),
	("z_tuple_lang_intro_conv 42005 b",
	z_tuple_lang_intro_conv,
	Ò(1,2,3)Æ,
	gen_fail_msg "z_tuple_lang_intro_conv" 42005 [
		string_of_term Ò(1,2,3)Æ])
,
	("z_tuple_lang_intro_conv 42005 c",
	z_tuple_lang_intro_conv,
	Ò((1,2,3).1,(1,2,3).2)Æ,
	gen_fail_msg "z_tuple_lang_intro_conv" 42005 [
		string_of_term Ò((1,2,3).1,(1,2,3).2)Æ])
	];
=TEX
=SML
let
	val atuple = mk_var("t",type_of Ò(1,2,3)Æ);
in
store_mt_results (mt_runf (op =$)) [("z_selât_intro_conv",
	snd o dest_eq o concl o z_selât_intro_conv,
	atuple,
	Ò(ëatupleÆ.1,ëatupleÆ.2,ëatupleÆ.3)Æ)]
end;
store_mt_results mt_run_fail [("z_selât_intro_conv 42004",
	z_selât_intro_conv,
	mk_t,
	gen_fail_msg "z_selât_intro_conv" 42004 [trues])
	];
=TEX

\section{CARTESIAN PRODUCTS}
=SML
store_mt_results (mt_runf (op =$)) [("z_∏_conv",
	snd o dest_eq o concl o z_∏_conv,
	ÒS1 ∏ S2 ∏  S2 ∏ {tâ2}Æ,
	Ò{tâ1:S1; tâ3:S2; tâ4:  S2; tâ5 : {tâ2}∑(tâ1,  tâ3, tâ4, tâ5)}Æ)];
store_mt_results mt_run_fail [("z_∏_conv 47160",
	z_∏_conv,
	mk_t,
	gen_fail_msg "z_∏_conv" 47160 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_ç_∏_conv",
	snd o dest_eq o concl o z_ç_∏_conv,
	(snd(strip_µ Ò[S1,S2] y ç S1 ∏ S2 ∏  S2Æ)),
	(snd(strip_µ Ò[S1,S2] (y ∫ (S1 ∏ S2 ∏  S2)).1 ç S1 ± y.2 ç S2 ± y.3 ç  S2Æ)))];
store_mt_results mt_run_fail [("z_ç_∏_conv 42007",
	z_ç_∏_conv,
	mk_t,
	gen_fail_msg "z_ç_∏_conv" 42007 [trues])
	];
=TEX
\section{Extensionality of Sets}
=SML
store_mt_results (mt_runf (op =$)) [("z_sets_ext_conv 1",
	snd o dest_eq o concl o z_sets_ext_conv,
	Ò{1,x1} = {2,x2}Æ,
	Òµ x3 : U ∑ x3 ç {1,x1} § x3 ç {2,x2}Æ),
	("z_sets_ext_conv 2",
	snd o dest_eq o concl o z_sets_ext_conv,
	Ò{(1,x1)} = {(2,x3)}Æ,
	Òµ x2 : U; x4 : U ∑ (x2,x4) ç {(1,x1)} § (x2,x4) ç {(2,x3)}Æ)];
store_mt_results mt_run_fail [("z_sets_ext_conv 42010 a",
	z_sets_ext_conv,
	mk_t,
	gen_fail_msg "z_sets_ext_conv" 42010 [trues]),
	("z_sets_ext_conv 42010 b",
	z_sets_ext_conv,
	Òtrue § trueÆ,
	gen_fail_msg "z_sets_ext_conv" 42010 [string_of_term Òtrue § trueÆ])
	];
=TEX
\section{Binding Displays}
=SML
store_mt_results (mt_runf (op =$)) [("z_binding_eq_conv",
	snd o dest_eq o concl o z_binding_eq_conv,
	Ò  S = (x ¶ y)Æ,
	Ò((  S).x = (x ¶ y).x)Æ)];
store_mt_results mt_run_fail [("z_binding_eq_conv 42013conv",
	z_binding_eq_conv,
	mk_t,
	gen_fail_msg "z_binding_eq_conv" 42013 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_binding_eq_conv1 a",
	snd o dest_eq o concl o z_binding_eq_conv1,
	Ò  S = (x ¶ y)Æ,
	Ò((  S).x = y)Æ),
	("z_binding_eq_conv1 b",
	snd o dest_eq o concl o z_binding_eq_conv1,
	Ò(x ¶ y) =   SÆ,
	Ò(y = (  S).x)Æ),
	("z_binding_eq_conv1 c",
	snd o dest_eq o concl o z_binding_eq_conv1,
	Ò(x ¶ y) = (x ¶ z)Æ,
	Ò(y = z)Æ)];
store_mt_results mt_run_fail [("z_binding_eq_conv1 42013",
	z_binding_eq_conv1,
	mk_t,
	gen_fail_msg "z_binding_eq_conv1" 42013 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_binding_eq_conv2 a",
	snd o dest_eq o concl o z_binding_eq_conv2,
	Ò(x ¶ z) = (x ¶ y)Æ,
	Ò(z = y)Æ),
	("z_binding_eq_conv2 b",
	snd o dest_eq o concl o z_binding_eq_conv2,
	Ò(x ¶ z, p ¶ 1) = (x ¶ y, p ¶ 2)Æ,
	Ò(1 = 2 ± z = y)Æ)];
store_mt_results mt_run_fail [("z_binding_eq_conv2 42021 a",
	z_binding_eq_conv2,
	mk_t,
	gen_fail_msg "z_binding_eq_conv2" 42021 [trues]),
	("z_binding_eq_conv2 42021 b",
	z_binding_eq_conv2,
	Ò(x ¶ z) = bÆ,
	gen_fail_msg "z_binding_eq_conv2" 42021 [string_of_term Ò(x ¶ z) = bÆ])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_selâs_conv a",
	snd o dest_eq o concl o z_selâs_conv,
	Ò(x ¶ y, p ¶ q).xÆ,
	ÒyÆ),
	("z_selâs_conv b",
	snd o dest_eq o concl o z_selâs_conv,
	Ò(x ¶ y, p ¶ q).pÆ,
	¨q:'bÆ)];
store_mt_results mt_run_fail [("z_selâs_conv 42014",
	z_selâs_conv,
	mk_t,
	gen_fail_msg "z_selâs_conv" 42014 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_bindingd_intro_conv",
	snd o dest_eq o concl o z_bindingd_intro_conv,
	Ò(x ¶ y, p ¶ q)Æ,
	Ò(x ¶ (x ¶ y, p ¶ q).x, p ¶ (x ¶ y, p ¶ q).p)Æ)];
store_mt_results mt_run_fail [("z_bindingd_intro_conv 42017",
	z_bindingd_intro_conv,
	mk_t,
	gen_fail_msg "z_bindingd_intro_conv" 42017 [trues])
	];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_bindingd_elim_conv",
	snd o dest_eq o concl o z_bindingd_elim_conv,
	Ò(x ¶ (x ¶ y, p ¶ q).x, p ¶ (x ¶ y, p ¶ q).p)Æ,
	Ò(x ¶ y, p ¶ q)Æ)];
store_mt_results mt_run_fail [("z_bindingd_elim_conv 42018 a",
	z_bindingd_elim_conv,
	mk_t,
	gen_fail_msg "z_bindingd_elim_conv" 42018 [trues]),
	("z_bindingd_elim_conv 42018 b",
	z_bindingd_elim_conv,
	Ò(x ¶ (x ¶ y, p ¶ q).x, p ¶ (x ¶ y, p ¶ r).p)Æ,
	gen_fail_msg "z_bindingd_elim_conv" 42018 
		[string_of_term Ò(x ¶ (x ¶ y, p ¶ q).x, p ¶ (x ¶ y, p ¶ r).p)Æ])
	];
=TEX
\subsection{String Literals}
=SML
store_mt_results (mt_runf (op =$)) [("z_string_conv a",
	snd o dest_eq o concl o z_string_conv,
	Ò"abc"Æ,
	Òß¨`a`Æ,¨`b`Æ,¨`c`Æ¢Æ),
	("z_string_conv b",
	snd o dest_eq o concl o z_string_conv,
	Ò"" ∫ seq CHARÆ,
	Òß¢ ∫  ""Æ)];
store_mt_results mt_run_fail [("z_string_conv 42015",
	z_string_conv,
	mk_t,
	gen_fail_msg "z_string_conv" 42015 [trues])
	];
store_mt_results (mt_runf (op =$)) [("z_ç_string_conv a",
	snd o dest_eq o concl o z_ç_string_conv,
	Òv ç "abc"Æ,
	Òv ç ß¨`a`Æ,¨`b`Æ,¨`c`Æ¢Æ),
	("z_ç_string_conv b",
	snd o dest_eq o concl o z_ç_string_conv,
	Òv ç ("" ∫ seq CHAR)Æ,
	Òv ç (ß¢ ∫  "")Æ)];
store_mt_results mt_run_fail [
	("z_ç_string_conv 42028",
	z_ç_string_conv,
	mk_t,
	gen_fail_msg "ç_C" 42028 [trues]),
	("z_ç_string_conv 42015",
	z_ç_string_conv,
	Òx ç yÆ,
	gen_fail_msg "z_string_conv" 42015 [string_of_term ÒyÆ])
	];

=TEX
\section{MISCELLANEOUS}
=SML
store_mt_results (mt_runf (op =$)) [
	("z_defn_simp_rule a",
	concl o z_defn_simp_rule,
	(asm_rule ¨Z'AbbDef Òp ç (X ∏ Y) ± (µ q : X ∏ Y ∑ q ç p § f q = q.1)ÆÆ),
	Òµ q : U ∑
	q ç p § q ç X ∏ Y ± f q = q.1Æ),
	("z_defn_simp_rule b",
	concl o z_defn_simp_rule,
	(conv_rule 
	(RAND_C(LEFT_C (Z_DECL_INTRO_C z_pred_dec_conv)))
	(asm_rule ¨Z'AbbDef Òp ç (X ∏ Y) ± (µ q : X ∏ Y ∑ q ç p § f q = q.1)ÆÆ)),
	Òµ q : U∑ q ç p § q ç X ∏ Y ± f q = q.1Æ)];
=TEX

ù[X,Y]úúúúúúúúúúúúúúúú
‹ Test :  (X ∏ Y)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ xy : X ∏ Y ∑
‹	xy ç Test § (xy = xy) 
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
store_mt_results (mt_runf (op =$)) [
	("z_defn_simp_rule c",
	concl o z_defn_simp_rule,
	(get_spec ÒTestÆ),
	Ò[X,Y](µ xy : U ∑ xy ç Test[X, Y] § xy ç X ∏ Y ± xy = xy)Æ)];
=TEX
=SML
store_mt_results mt_run_fail [("z_defn_simp_rule 42011",
	z_defn_simp_rule,
	t_thm,
	gen_fail_msg "z_defn_simp_rule" 42011 [string_of_thm t_thm])
	];
=TEX

\section{PROOF CONTEXTS}
The following is not an exhaustive test of stripping under
the Z set theory proof contexts, but is a good test
of presence and basic intent.
=SML
let 
val example_tm = Òµ x : U; y:U ∑ {1,2} ∏ {3,4} =
	 {(1,3),(1,4),(2,3),(2,4)}Æ;
fun aux tm = (
push_merge_pcs["z_predicates","'z_ç_set_lang","'z_sets_ext_lang", 
	"'z_tuples_lang", "'z_bindings"];
set_goal([],tm);
a(asm_prove_tac[]);
pop_pc();
pop_thm());
in
store_mt_results (mt_runf (op =$)) [("Z set theory stripping",
	concl o aux,
	example_tm,
	example_tm)]
end;
=TEX
A check for $¬$ reduction:
=SML
push_merge_pcs["z_predicates","'z_ç_set_lang","'z_sets_ext_lang", 
	"'z_tuples_lang", "'z_bindings"];
store_mt_results (mt_runf (op =$)) [("z_ç_set_lang pc ¬",
	concl o rewrite_conv [],
	Ò(Ã x : U ∑ f x) (1, 2)Æ,
	Ò(Ã x : U ∑ f x) (1, 2) = f (1, 2)Æ)];
pop_pc();
=TEX
\section{CHECK THE THEORY DESIGN}
=SML
use_file "dtd042.tch";
store_mt_results mt_run [("theory design of Z set theory",
	theory_check_success,
	(),
	true)];
=TEX
\section{END OF TESTS}
=SML
(* set_flag("subgoal_package_quiet",false); *)
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results (mt_runf (op =$)) [("",
	tac_res ,
	ÒÆ,
	ÒÆ)];
store_mt_results (mt_runf (op =$)) [("",
	snd o dest_eq o concl o  ,
	ÒÆ,
	ÒÆ)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];
store_mt_results (mt_runf (op =#)) [("",
	tac_res1 ,
	([ÒÆ],ÒÆ),
	([ÒÆ],ÒÆ))];
store_mt_results (mt_runf (list_eq(op =#))) [("",
	tac_ress  2,
	([ÒÆ],ÒÆ),
	[([ÒÆ],ÒÆ),([ÒÆ],ÒÆ)])];
store_mt_results mt_runf [
	("",
	tac_solve ,
	([],ÒÆ),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],ÒÆ),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];

