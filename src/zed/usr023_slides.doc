=TEX
% usr022.doc   %Z% $Date$ $Revision$ $RCSfile$
% COPYRIGHT (c) International Computers Limited, 1992

\def\SCCSissue{$Revision$
}


% =====================================================================

\begin{slide}{1}

\vfill

\begin{center}

\vfill
\label{intro}
{\bf Proof in Z\\
with\\
{\huge ProofPower}\\}

\vfill

\end{center}

\end{slide}

% =====================================================================

\begin{slide}{2}
\begin{center}

{\bf Course Objectives}

\end{center}
\vfill

\begin{itemize}
\item
to describe the basic principles and concepts underlying ProofPower
\item
to enable the student to write simple specifications and undertake elementary proofs in Z using ProofPower
\item
to enable the student to make effective use of the reference documentation 
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{3}
\begin{center}

{\bf Course Outline}

\end{center}
\vfill

\begin{itemize}
\item
Introduction

{\small
\begin{itemize}
\item
an overview of ProofPower
\item
propositional and predicate calculus proofs in Z
\end{itemize}
}%\small

\item
Specification using ProofPower Z

{\small
\begin{itemize}
\item
Expressions and Predicates
\item
Schema Expressions
\item
Paragraphs
\end{itemize}
}%\small

\item
Proof in Z using ProofPower

{\small
\begin{itemize}
\item
Basics of Proof
\item
Rules, Conversions, Tactics...
\item
Stripping, Rewriting
\item
Induction
\end{itemize}
}%\small

\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{4}
\begin{center}
\bf Schedule
\end{center}
\vfill
\vertbarfalse
{\tiny
=GFT
slide	topic			time

WEDNESDAY 16th September

	BUFFET LUNCH		12:30
	
01	introduction		13:00
20	exercises 1: proof		13:45
28	HOL TYPEs		14:15
33	HOL TERMs		14:35

	COFFEE			15:00

39	Derived syntax for TERMS	15:15
50	Theories			15:35
53	Exercises 2		15:50
54	Declarations/Paragraphs	16:05
59	Exercises 3		16:20
60	Forward Proof		16:45
66	Exercises 4		17:10

THURSDAY 17th September

66	Exercises 4 (cont)		9:00
68	Goal Oriented Proof
	/Rewriting			9:15
71	Exercises 5 & 6		9:30
75	Stripping			10:05
78	Exercises 7		10:20

	COFFEE			10:30
	
79	Induction			11:05
83	Exercises 8		11:20
85	TACTICALs et.al.		11:45
86	Exercises 9		11:55
89	Proof Strategy		12:10
96	Exercises 10		12:30

	BUFFET LUNCH		13:00
=TEX
}%\tiny
\vertbartrue
\vfill
\end{slide}
% =====================================================================

\begin{slide}{5}
\begin{center}

{\bf Course Prerequisites}

\end{center}
\vfill

\begin{itemize}
\item
a working knowledge of Z as a specification language
πZAX
‹  c : ˙
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹
‹ 5 º c º 500
‹
∞
=TEX
\item
elementary set theory
=GFT
Òµa, b, c:  X∑ a ° (b ° c) = (a ° b) ° cÆ;
=TEX
\item
functional programming
=SML
fun	fact 0 = 1
|	fact n = n * (fact (n - 1));
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{6}
\begin{center}

{\bf Using Sunview}
\end{center}
\vfill
{\small
\begin{itemize}
\item
``login'' to user ``rj'' with password ``proofpow'', then type ``sunview''.
\item
To {\bf open} icon: press ``open'' button {\tiny (with cursor on icon)}.
\item
To {\bf close} window: press ``open'' button {\tiny (with cursor in window)}.
\item
To {\bf move} window: {\bf grab} {\tiny a corner} using {\bf middle button} and drag.
\item
To {\bf resize} window: {\bf grab} {\tiny a corner} using {\bf ``control'' and middle button} and drag.
\item
To {\bf select}: {\tiny press} {\bf left button} {\tiny at left of selection} {\bf and middle button} {\tiny at right}.
\item
To select {\bf single line}: triple click with left button.
\item
To {\bf copy and paste}: {\bf select} source, press {\bf copy} and {\tiny (with cursor in destination window)} {\bf paste}.
\item
To display {\bf special characters} (for use by `cut and paste'): type ``palette'' in a shell window (or refer to USR001 for keyboard combinations).
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================
\begin{slide}{7}
\begin{center}

{\bf Using ProofPower}

\end{center}
{\small
\vfill
\begin{itemize}
\item
To load {\bf ProofPower} type ``hol'' in command tool.
\item
To leave type ``quit();'' (or ``save\_and\_quit();'').
\item
MetaLanguage prompt is: ``$:>$''.
\item
ML commands (or top level expressions) are terminated by ``;''.
\item
ML continuation prompt is: ``$:\#$''.
\item
In case of mismatching brackets or quotes you may get stuck with the ``$:\#$'' prompt.
In this case break-in and type ``f'' (for ``fail'').
\item
To {\bf break-in} type Control-and-C.
\item
The ``META'' key referred to in the keyboard layout is any key marked with a diamond (or with `left' or `right' on sun3 keyboards).
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{17}
\begin{center}
\vfill

{\bf Some Proofs are Easy with ProofPower}
\end{center}

\begin{itemize}
\item
propositional tautologies

{\tiny ProofPower proves these automatically, and uses propositional reasoning to simplify non-propositional goals automatically.}

\item
first order predicate calculus

{\tiny Often these will also be automatically provable using resolution.
Where resolution fails, there is a simple systematic approach to proving these results using ProofPower.}

\item
elementary set theory

{\tiny A useful class of results from elementary set theory are automatically provable.}

\item
other classes of results

{\tiny Whenever a new theory is introduced one or more proof contexts may be developed to solve automatically a range of results in that theory.
``Decision procedures'' for such classes of results can be made available via ``prove\_tac''.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================
\begin{slide}{18}
\begin{center}

{\bf Simple Predicate Calculus Proofs}
\end{center}
\vfill
{\small

\begin{itemize}
\item
use the subgoaling package

\item
set the goal

=SML
set_goal([],Ò(µx, y:X∑ P x ¥ R y)
	§ (µv, w:X∑ ≥ P w ≤ R v)Æ);
=TEX
\item
initiate proof by contradiction
=SML
a contr_tac;
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
...
(*  4 *)  Òµ x, y : X ∑ P x ¥ R yÆ
(*  3 *)  Ò{v, w} Ä XÆ
(*  2 *)  ÒP wÆ
(*  1 *)  Ò≥ R vÆ

(* ?Ù *)  ÒfalseÆ
=TEX
\item
instantiate assumptions as required
=SML
a (z_spec_nth_asm_tac 4 Ò(x ¶ w∫X, y ¶ v∫X)Æ);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{19}
\vfill
{\small
=GFT ProofPower output
Tactic produced 0 subgoals:
(* *** Goal "2" *** *)

(*  3 *)  Òµ v w∑ ≥ P w ≤ R vÆ
(*  2 *)  ÒP xÆ
(*  1 *)  Ò≥ R yÆ

(* ?Ù *)  ÒFÆ
=SML
a (list_spec_asm_tac Òµ v w∑ ≥ P w ≤ R vÆ [ÒyÆ,ÒxÆ]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=SML
pop_thm();
=GFT ProofPower output
Now 0 goals on the main goal stack
val it = Ù (µ x y∑ P x ¥ R y)
		§ (µ v w∑ ≥ P w ≤ R v) : THM   
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{20}
\begin{center}
{\bf Exercises 1: Proof}
\end{center}
{\small
\vfill
Set the proof context:
=SML
set_pc "hol1";
=TEX
Set the goal (from the examples supplied):
=GFT
set_goal([],ÒconjectureÆ);
=TEX
Then try the following methods of proof:
\begin{itemize}
\item
Two tactic method using:
=GFT
a contr_tac; (* once *)
a (list_spec_asm_tac [Òt1Æ, Òt2Æ]);
  (* as many as necessary *)
=TEX
\item or
=GFT
a (prove_tac[]); (* once *)
=TEX
\item or
=GFT
a step_strip_tac; (* many times *)
=IGN 
drop_main_goal();
repeat drop_main_goal;
=TEX
\end{itemize}
in case of difficulty, revert to the two tactic method.
\vfill
}%\small
\end{slide}

% =====================================================================
{\tiny
\begin{slide}{21}
\vfill
=IGN bits and pieces
set_goal([],ÒÆ);
a contr_tac;
a strip_tac;
a step_strip_tac;
prove_rule []
;
map (prove_rule [])
;
map (fn t => tac_proof (([],t),(REPEAT step_strip_tac))) ZRM2
;
map (fn t => tac_proof (([],t),prove_tac[])) ZRM3
;
a (list_spec_nth_asm_tac 1 [ÒÆ]);
=TEX
=SML
(* Results from Principia Mathematica *2 *)
val PM2 =[
Ò(* *2.02 *) q ¥ ( p ¥ q)Æ,
Ò(* *2.03 *) (p ¥ ≥ q) ¥ (q ¥ ≥ p)Æ,
Ò(* *2.15 *) (≥ p ¥ q) ¥ (≥ q ¥ p)Æ,
Ò(* *2.16 *) (p ¥ q) ¥ (≥ q ¥ ≥ p)Æ,
Ò(* *2.17 *) (≥ q ¥ ≥ p) ¥ (p ¥ q)Æ,
Ò(* *2.04 *) (p ¥ q ¥ r) ¥ (q ¥ p ¥ r)Æ,
Ò(* *2.05 *) (q ¥ r) ¥ (p ¥ q) ¥ (p ¥ r)Æ,
Ò(* *2.06 *) (p ¥ q) ¥ (q ¥ r) ¥ (p ¥ r)Æ,
Ò(* *2.08 *) p ¥ pÆ,
Ò(* *2.21 *) ≥ p ¥ (p ¥ q)Æ];
=TEX
\vfill
=SML
(* Results from Principia Mathematica *3 *)
val PM3 =[
(* *3.01 *) Òp ± q § ≥(≥ p ≤ ≥ q)Æ,
(* *3.2  *) Òp ¥ q ¥ p ± qÆ,
(* *3.26 *) Òp ± q ¥ pÆ,
(* *3.27 *) Òp ± q ¥ qÆ,
(* *3.3  *) Ò(p ± q ¥ r) ¥ (p ¥ q ¥ r)Æ,
(* *3.31 *) Ò(p ¥ q ¥ r) ¥ (p ± q ¥ r)Æ,
(* *3.35 *) Ò(p ± (p ¥ q)) ¥ qÆ,
(* *3.43 *) Ò(p ¥ q) ± (p ¥ r) ¥ (p ¥ q ± r)Æ,
(* *3.45 *) Ò(p ¥ q) ¥ (p ± r ¥ q ± r)Æ,
(* *3.47 *) Ò(p ¥ r) ± (q ¥ s) ¥ (p ± q ¥ r ± s)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{22}
\vfill
=SML
(* Results from Principia Mathematica *4 *)
val PM4 =[
(* *4.1  *) Òp ¥ q § ≥ q ¥ ≥ pÆ,
(* *4.11 *) Ò(p § q) § (≥ p § ≥ q)Æ,
(* *4.13 *) Òp § ≥≥ pÆ,
(* *4.2  *) Òp § pÆ,
(* *4.21 *) Ò(p § q) § (q § p)Æ,
(* *4.22 *) Ò(p § q) ± (q § r) ¥ (p § r)Æ,
(* *4.24 *) Òp § p ± pÆ,
(* *4.25 *) Òp § p ≤ pÆ,
(* *4.3  *) Òp ± q § q ± pÆ,
(* *4.31 *) Òp ≤ q § q ≤ pÆ,
(* *4.33 *) Ò(p ± q) ± r § p ± (q ± r)Æ,
(* *4.4  *) Òp ± (q ≤ r) § (p ± q) ≤ (p ± r)Æ,
(* *4.41 *) Òp ≤ (q ± r) § (p ≤ q) ± (p ≤ r)Æ,
(* *4.71 *) Ò(p ¥ q) § (p § (p ± q))Æ,
(* *4.73 *) Òq ¥ (p § (p ± q))Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{23}
\vfill
=SML
(* Results from Principia Mathematica *5 *)
val PM5 =[
(* *5.1  *) Òp ± q ¥ (p § q)Æ,
(* *5.32 *) Ò(p ¥ (q § r)) ¥ ((p ± q) § (p ± r))Æ,
(* *5.6  *) Ò(p ± ≥ q ¥ r) ¥ (p ¥ (q ≤ r))Æ];
=TEX
=SML
(* Definitions from Principia Mathematica *9 *)
val PM9 =[
(* *9.01 *) Ò≥ (µx∑ ∆x) § (∂x∑ ≥ ∆x)Æ,
(* *9.02 *) Ò≥ (∂x∑ ∆x) § (µx∑ ≥ ∆x)Æ,
(* *9.03 *) Ò(µx∑ ∆x ≤ p) § (µx∑ ∆x) ≤ pÆ,
(* *9.04 *) Òp ≤ (µx∑ ∆x) § (µx∑ p ≤ ∆x)Æ,
(* *9.05 *) Ò(∂x∑ ∆x ≤ p) § (∂x∑ ∆x) ≤ pÆ,
(* *9.06 *) Òp ≤ (∂x∑ ∆x) § p ≤ (∂x∑ ∆x)Æ];
val PM9b =[
(* *9.07 *) Ò(µx∑ ∆x) ≤ (∂y∑ Ÿy) § (µx∑∂y∑ ∆x ≤ Ÿy)Æ,
(* *9.08 *) Ò(∂y∑ Ÿy) ≤ (µx∑ ∆x) § (µx∑∂y∑ Ÿy ≤ ∆x)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{24}
\vfill
=SML
(* Results from Principia Mathematica *10 *)
val PM10 =[
(* *10.01  *) Ò(∂x∑ ∆x) § ≥ (µy∑ ≥ ∆y)Æ,
(* *10.1   *) Ò(µx∑ ∆x) ¥ ∆yÆ,
(* *10.21  *) Ò(µx∑ p ¥ ∆x) § p ¥ (µy∑ ∆y)Æ,
(* *10.22  *) Ò(µx∑ ∆x ± Ÿx) § (µy∑ ∆y) ± (µz∑ Ÿz)Æ,
(* *10.24  *) Ò(µx∑ ∆x ¥ p) § (∂y∑ ∆y) ¥ pÆ,
(* *10.27  *) Ò(µx∑ ∆x ¥ Ÿx) ¥ ((µy∑ ∆y) ¥ (µz∑ Ÿz))Æ,
(* *10.271 *) Ò(µx∑ ∆x § Ÿx) ¥ ((µy∑ ∆y) § (µz∑ Ÿz))Æ,
(* *10.28  *) Ò(µx∑ ∆x ¥ Ÿx) ¥ ((∂y∑ ∆y) ¥ (∂z∑ Ÿz))Æ,
(* *10.281 *) Ò(µx∑ ∆x § Ÿx) ¥ ((∂y∑ ∆y) § (∂z∑ Ÿz))Æ,
(* *10.35  *) Ò(∂x∑ p ± ∆x) § p ± (∂y∑ ∆y)Æ,
(* *10.42  *) Ò(∂x∑ ∆x) ≤ (∂y∑ Ÿy) § (∂z∑ ∆z ≤ Ÿz)Æ,
(* *10.5   *) Ò(∂x∑ ∆x ± Ÿx) ¥ (∂y∑ ∆y) ± (∂z∑ Ÿz)Æ,
(* *10.51  *) Ò≥(∂x∑ ∆x ± Ÿx) ¥ (µy∑ ∆y ¥ ≥ Ÿy)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{25}
\vfill
=SML
(* Results from Principia Mathematica *11 *)
val PM11 =[
(* *11.1  *) Ò(µx y∑ ∆(x,y)) ¥ ∆(z,w)Æ,
(* *11.2  *) Ò(µx y∑ ∆(x,y)) § µy x∑ ∆(x,y)Æ,
(* *11.3  *) Ò(p ¥ (µx y∑ ∆(x,y)))
		§ (µx y∑ p ¥ ∆(x,y))Æ,
(* *11.32 *) Ò(µx y∑ ∆(x,y) ¥ Ÿ(x,y))
		¥ (µx y∑ ∆(x,y)) ¥ (µx y∑ Ÿ(x,y))Æ,
(* *11.35 *) Ò(µx y∑ ∆(x,y) ¥ p) § (∂x y∑ ∆(x,y)) ¥ pÆ,
(* *11.45 *) Ò(∂x y∑ p ¥ ∆(x,y))
		§ (p ¥ (∂x y∑ ∆(x,y)))Æ,
(* *11.54 *) Ò(∂x y∑ ∆x ± Ÿy) § (∂x∑ ∆x) ± (∂y∑ Ÿy)Æ,
(* *11.55 *) Ò(∂x y∑ ∆x ± Ÿ(x,y))
		§ (∂x∑ ∆x ± (∂y∑ Ÿ(x,y)))Æ,
(* *11.6  *) Ò(∂x∑ (∂y∑ ∆(x,y) ± Ÿy) ± —x)
		§ (∂y∑ (∂x∑ ∆(x,y) ± —x) ± Ÿy)Æ,
(* *11.62 *) Ò(µx y∑ ∆x ± Ÿ(x,y) ¥ —(x,y))
  		§ (µx∑ ∆x ¥ (µy∑ Ÿ(x,y) ¥ —(x,y)))Æ
];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{26}
\vfill
=SML
(* results from ZRM provable by stripping *)
val ZRM1 = [
Òa ¿ a = a ¿ {}Æ,
Òa ¿ {} = a ° aÆ,
Òa ° a = a \ {}Æ,
Òa \ {} = aÆ,
Òa ° {} = a \ aÆ,
Òa \ a = {} \ aÆ,
Ò{} \ a = {}Æ,
Òa ¿ b = b ¿ aÆ,
Òa ° b = b ° aÆ,
Òa ¿ (b ¿ c) = (a ¿ b) ¿ cÆ,
Òa ° (b ° c) = (a ° b) ° cÆ,
Òa ¿ (b ° c) = (a ¿ b) ° (a ¿ c)Æ,
Òa ° (b ¿ c) = (a ° b) ¿ (a ° c)Æ,
Ò(a ° b) ¿ (a \ b) = aÆ,
Ò(a \ b) ° b = {}Æ,
Òa \ (b \ c) = (a \ b) ¿ (a ° c)Æ,
Ò(a \ b) \ c = (a \ (b ¿ c))Æ,
Òa ¿ (b \ c) = (a ¿ b) \ (c \ a)Æ,
Òa ° (b \ c) = (a ° b) \ cÆ,
Ò(a ¿ b) \ c = (a \ c) ¿ (b \ c)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{27}
\vfill
=SML
val ZRM2 = [
Òa \ (b ° c) = (a \ b) ¿ (a \ c)Æ,
Ò≥ x ç {}Æ,
Òa Ä aÆ,
Ò≥ a † aÆ,
Ò{} Ä aÆ,
Òﬁ {} = {}Æ,
Ò• {} = UniverseÆ];
=TEX
\vfill
=SML
(* results from ZRM *)
val ZRM3 = [
Òa Ä b § a ç  bÆ,
Òa Ä b ± b Ä a § a = bÆ,
Ò≥ (a † b ± b † a)Æ,
Òa Ä b ± b Ä c ¥ a Ä cÆ,
Òa † b ± b † c ¥ a † cÆ,
Ò{} † a § ≥ a = {}Æ,
Òﬁ (a ¿ b) = (ﬁ a) ¿ (ﬁ b)Æ,
Ò• (a ¿ b) = (• a) ° (• b)Æ,
Ò a Ä b ¥ ﬁ a Ä ﬁ b Æ,
Ò a Ä b ¥ • b Ä • a Æ];
=TEX
\vfill
\end{slide}

}%\tiny
% =====================================================================

\begin{slide}{28}
\begin{center}

{\bf The HOL Type System}

\end{center}
{\small
\vfill

\begin{itemize}
\item
abstract syntax/computation
=SML
mk_vartype	: string			-> TYPE;  
mk_ctype	: string * TYPE list	-> TYPE;
=TEX
\item
concrete syntax
=GFT BNF
	Type	=	Name	
		|	Typars, Name
		|	Type, InfixName, Type
		| 	`(`, Type, `)`;
	Typars	=	Type
		|	`(`, Type, { `,`, Type }, `)`;
=TEX
{\tiny
Type variables must begin with a prime.\\
Infix status and priority determined by fixity declarations.
}%\tiny
\item
semantics
\begin{itemize}
\item
Types denote non-empty sets of values.
\item
Type variables range over non-empty sets of values.
\item
Type constructors denote functions from\\
tuples of sets to sets.
\end{itemize}
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{29}
\begin{center}

{\bf Examples of Types}

\end{center}
\vfill
{\tiny
=SML
î'aÆ;
		(* parsed type variable *)
val t = mk_vartype "'a";
		(* computed type variable *)
val u = îBOOLÆ;
		(* 0-ary type constructor *)
mk_ctype ("BOOL",[]);
		(* computed 0-ary type construction *)
îÓÆ;
		(* 0-ary type constructor *)
î'a LISTÆ;
		(* polymorphic list type *)
î(Ó) LISTÆ;
		(* lists of natural numbers *)
îÓ ≠ ÓÆ;
		(* infix type constructor *)
mk_ctype ("≠",[îÓÆ,îÓÆ]);
		(* computed function space *)
î ÒËSML:Í tÆ ≠ ÒËSML:Í uÆÆ;
	(* another way of writing ëmk_ctype("≠",[t,u])Æ *)
îÓ ∏ ÓÆ;
		(* pairs of natural numbers *)
îÓ + BOOLÆ;
		(* disjoint union of Ó and BOOL *)
î(Ó, Ó) $∏Æ;
		(* suspending infix status *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{30}
\begin{center}

{\bf Computation with TYPEs (I)\\
recognisers and destructors}
\end{center}
\vfill

\begin{itemize}
\item constructors
=SML
mk_vartype :string		-> TYPE;  
mk_ctype   :string*TYPE list	-> TYPE;
=TEX
\item recognisers
=SML
is_vartype	:TYPE -> bool;  
is_ctype	:TYPE -> bool;
=TEX
\item destructors
=SML
dest_vartype	:TYPE -> string;  
dest_ctype	:TYPE -> string * TYPE list;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{31}
\begin{center}

{\bf Computation with TYPEs (II)\\
sample functions}

\end{center}
\vfill
\begin{itemize}
\item type equality
=SML
op =: : TYPE * TYPE -> bool;
=TEX
\item type variables in a type
=SML
type_tyvars : TYPE -> string list;
=TEX
\item type constructors in a type
=SML
type_tycons : TYPE -> (string * int) list;
=TEX
\item type instantiation
=SML
inst_type : (TYPE * TYPE) list
		-> TYPE -> TYPE;  
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{32}
\begin{center}

{\bf Computation with TYPEs (III)\\
support for pattern matching}
\end{center}
\vfill

{\small
\begin{itemize}
\item DEST\_SIMPLE\_TYPE
=GFT
datatype DEST_SIMPLE_TYPE =
	Vartype of string
|	Ctype of (string * TYPE list);
=TEX
\item generalised destructor
=SML
dest_simple_type: TYPE -> DEST_SIMPLE_TYPE;  
=TEX
\item generalised constructor
=SML
mk_simple_type : DEST_SIMPLE_TYPE -> TYPE;  
=TEX
\item pattern matching recursive functions
=SML
fun type_tyvars2 t = 
 (fn Vartype s	=> [s]
 |   Ctype (s,tl)	=> list_cup (map type_tyvars2 tl))
 (dest_simple_type t);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf HOL Terms}

\end{center}
\vfill
{\small

\begin{itemize}
\item
abstract syntax/computation
=GFT
datatype DEST_SIMPLE_TERM =
		Var	of string * TYPE
	|	Const	of string * TYPE
	|	App	of TERM * TERM
	|	SimpleÃ	of TERM * TERM;

dest_simple_term: TERM -> DEST_SIMPLE_TERM;
mk_simple_term: DEST_SIMPLE_TERM -> TERM;
=TEX
\item
concrete syntax
=GFT BNF
Term	=
		`Ã`, Name, [`:`, Type], `∑`, Term
	|	Term, Term 
	|	Term, InfixName, Term
	|	Term, `:`, Type
	|	Name
	|	`(`, Term, `)`;		
=TEX
{\tiny
Names are treated as variables unless declared as constants.\\
Infix status and priority determined by fixity declarations.
}%\tiny
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{34}
\begin{center}

{\bf Types of Terms}

\end{center}
\vfill
Terms must be well typed.\\
The type of a term is determined by type inference using the following rules:
\begin{itemize}
\item variables
=FRULE 1
˜
˜
Òv:¡Æ : ¡
=TEX
\item constants
=FRULE 1
˜
˜
Òc:¡Æ : ¡
=TEX
\item lambda abstractions
=FRULE 1
˜
t : ¡
˜
ÒÃ x:¬ ∑ tÆ : ¬ ≠ ¡
=TEX
\item applications
=FRULE 1
˜
f : ¡ ≠ ¬; x : ¡
˜
Òf xÆ : ¬
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{35}
\begin{center}

{\bf Types of Terms}

\end{center}
\vfill
{\small
The same rules may be rendered in ML as follows:
\begin{itemize}
=IGN
(* if you execute the following declarations first then
the expressions in the rules below will evaluate *)
val vname = "var";
val vtype = îBOOLÆ;
val cname = "0";
val ctype = îÓÆ;
val term = Ò0Æ;
val ttype = îÓÆ;
val funterm = Òfun : 'a ≠ 'bÆ;
val arg = Òarg : 'aÆ;
=TEX
\item variables
=FRULE 1
˜
˜
type_of (mk_var(vname,vtype)) =: vtype;
=TEX
\item constants
=FRULE 1
˜
˜
type_of (mk_const(cname,ctype)) =: ctype;
=TEX
\item lambda abstractions
=FRULE 1
˜
type_of term =: ttype;
˜
type_of ÒÃ x:'a ∑ ëtermÆÆ =: î'a ≠ ÒËSML:Í ttypeÆÆ;
=TEX
\item applications
=FRULE 1
˜
type_of funterm =: î'a ≠ 'bÆ;
type_of arg =: î'aÆ;
˜
type_of ÒëfuntermÆ ëargÆÆ =: î'bÆ;
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{36}
\begin{center}

{\bf Types of Terms - Examples}

\end{center}
{\small
\vfill
=SML
type_of Òx:ÓÆ		=: îÓÆ;
type_of Òx:'aÆ		=: î'aÆ;
type_of Ò0Æ		=: îÓÆ;
type_of ÒÃx:Ó ∑ x + 1Æ	=: îÓ ≠ ÓÆ;
type_of ÒÃx ∑ x + 1Æ	=: îÓ ≠ ÓÆ;
type_of Ò(Ãx ∑ x + 1) 3Æ	=: îÓÆ;
type_of Ò$+ 1Æ		=: îÓ ≠ ÓÆ;
type_of Ò$+Æ		=: îÓ ≠ Ó ≠ ÓÆ;
type_of ÒTÆ	=: îBOOLÆ;
type_of Ò≥ TÆ	=: îBOOLÆ;
type_of Ò$≥Æ	=: îBOOL ≠ BOOLÆ;
type_of Ò$±Æ	=: îBOOL ≠ BOOL ≠ BOOLÆ;
type_of Ò$µÆ	=: î('a ≠ BOOL) ≠ BOOLÆ;
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{37}
\begin{center}

{\bf Semantics of Terms}

\end{center}
\vfill

\begin{itemize}
\item
{\bf Variables}\\
{\small range over the set denoted by their type.}
\item
{\bf Constants}\\
{\small denote particular values in the set denoted by their type.}
\item
{\bf Lambda Abstractions}\\
{\small denote total functions from the set denoted by the type of the variable to the set denoted by the type of the body.}

{\small The value at point ``p'' is the value of the body when the variable is assigned value ``p''.}
\item
{\bf Applications}\\
{\small denote the value of the function denoted by the first term at the point which is the value denoted by the second term.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{38}
\begin{center}

{\bf Semantics of Terms - Examples}

\end{center}
{\small
\vfill
=SML
¬_conv Ò(Ãx ∑ x + 1) 3Æ;
=GFT Hol Output
val it = Ù (Ã x∑ x + 1) 3 = 3 + 1 : THM   
=SML
rewrite_conv[] Ò(Ãx ∑ x + 1) 3Æ;
=GFT Hol Output
val it = Ù (Ã x∑ x + 1) 3 = 4 : THM   
=SML
»_axiom;
=GFT Hol Output
val it = Ù µ f∑ (Ã x∑ f x) = f : THM   
=SML
ext_thm;
=GFT Hol Output
val it = Ù µ f g∑ f = g § (µ x∑ f x = g x) : THM   
=SML
prove_rule[] Ò∂ x:Ó ∑	43 = xÆ;
prove_rule[] Ò∂ b:BOOL ∑	T = bÆ;
prove_rule[] Òµ x:Ó ∑	x æ 0Æ;
prove_rule[] Òµ b:BOOL ∑	b = T ≤ b = FÆ;
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{39}
\begin{center}

{\bf Derived Syntax - DEST\_TERM}

\end{center}
{\small
\vfill
=GFT
datatype €DEST_TERM› =
   €DVar›		of string * TYPE
|  €DConst›	of string * TYPE
|  €DApp›		of TERM * TERM
|  €DÃ›		of TERM * TERM
|  €DEq›		of TERM * TERM
|  €D¥›		of TERM * TERM
|  €DT›
|  €DF›
|  €D≥›		of TERM
|  €DPair›		of TERM * TERM
|  €D±›		of TERM * TERM
|  €D≤›		of TERM * TERM
|  €D§›		of TERM * TERM
|  €DLet›		of ((TERM * TERM)list * TERM)
|  €DEnumSet›	of TERM list
|  €Dö›		of TYPE
|  €DSetComp›	of TERM * TERM
|  €DList›		of TERM list
|  €DEmptyList›	of TYPE
|  €Dµ›		of TERM * TERM
|  €D∂›		of TERM * TERM
|  €D∂â1›		of TERM * TERM
|  €D≈›		of TERM * TERM
|  €DIf›		of (TERM * TERM * TERM)
|  €DÓ›		of int
|  €DChar›		of string
|  €DString›	of string;
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{40}
\begin{center}
{\bf Derived Syntax}
\end{center}
\vfill

\begin{itemize}
\item
prefix, infix and postfix operators 
\item
binders
\item
pair matching lambda abstractions
\item
conditionals
\item
local definitions
\item
set displays and abstractions
\item
list displays
\item
literals (numeric, character, and string)
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{41}
\begin{center}
{\bf binders}
\end{center}
\vfill
\begin{itemize}
\item
Constants having type: î('a ≠ 'b) ≠ 'cÆ\\
(or any instance of this)\\
may be declared as ``binders''.
\vfill
\item
Normally a ``binder'' is applied to a lambda expression, in which case the $Ã$ is omitted.
\vfill
\item
binder status may be suspended by use of $\$$.
=SML
Ò∂ x∑ x = 4Æ =$ Ò$∂ Ã x∑ x = 4Æ;
=IGN
new_const ("¡", î('a ≠ 'b) ≠ 'cÆ);
declare_binder"¡";
Ò¡ x∑ x = 4Æ =$ Ò$∂ (Ã x∑ x = 4)Æ;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{42}
\begin{center}
{\bf nested paired abstractions}
\end{center}
\vfill
{\small
\begin{itemize}
\item
nested lambda abstractions can be abbreviated as follows:
=SML
ÒÃx:Ó∑Ãy:Ó∑ (x,y)Æ =$ ÒÃ x y:Ó∑ (x,y)Æ;
=TEX
This function takes two natural numbers and returns a pair.
(``,'' is the infix pairing operator.)
\item
functions taking pairs may be written:\\
=SML
rewrite_conv[] Ò(Ã(x,y):Ó ∏ Ó∑ x)=FstÆ;
=GFT ProofPower output
val it = Ù (Ã (x, y)∑ x) = Fst § T : THM   
=TEX
This function takes an argument which is an ordered pair, and returns the first element of the pair.
\item
these effects can be iterated or combined.
=SML
rewrite_conv []
	Ò(Ã(x,y):Ó ∏ Ó; ((v,w),z)∑ x + y + v + w + z)
	(1,2) ((3,4),5)Æ;
=GFT ProofPower output
val it =
	Ù (Ã (x, y) ((v, w), z)∑ x + y + v + w + z)
	(1, 2) ((3, 4), 5) = 15 : THM
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{43}
\begin{center}
{\bf Conditionals}
\end{center}
\vfill
\begin{itemize}
\item
Conditionals may be written:

{\bf if} t1 {\bf then} t2 {\bf else} t3
=SML
rewrite_conv[] Òif T then 0 else 1Æ;
=GFT ProofPower output
val it = Ù (if T then 0 else 1) = 0 : THM   
=TEX
=SML
rewrite_conv[] Òif F then 0 else 1Æ;
=GFT ProofPower output
val it = Ù (if T then 0 else 1) = 1 : THM   
=TEX
=SML
rewrite_conv[] Òif 3>6 then x else yÆ;
=GFT ProofPower output
val it = Ù (if 3 > 6 then x else y) = y : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{44}
\begin{center}
{\bf Let Clauses (I)}
\end{center}
\vfill
\begin{itemize}
\item
Local declarations may be made in the form:

{\bf let} defs {\bf in} term
=SML
rewrite_conv[let_def]Òlet a = "Peter" in a,aÆ;
=GFT ProofPower output
val it = Ù (let a = "Peter" in (a, a))
		= ("Peter", "Peter") : THM   
=TEX
\item
The left hand side of a definition may be a ``varstruct'':
=SML
rewrite_conv[let_def]
	Òlet (x,y) = (1,T) in (y,x)Æ;
=GFT ProofPower output
val it = Ù (let (x, y) = (1, T) in (y, x))
		= (T, 1) : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{45}
\begin{center}
{\bf Let Clauses (II)}
\end{center}
\vfill
\begin{itemize}
\item
The left hand side of a definition may be a function definition:
=SML
rewrite_conv[let_def]Òlet f x = x*x in f 3Æ;
=GFT ProofPower output
val it = Ù (let f x = x * x in f 3)
		= 9 : THM   
=TEX
\item
Multiple definitions may be given in a single let clause.
=SML
rewrite_conv[let_def]
	Òlet a = 1 and b = 2 in (a,b)Æ;
=GFT ProofPower output
val it = Ù (let a = 1 and b = 2 in (a, b))
		= (1, 2) : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{46}
\begin{center}
{\bf Set Displays}
\end{center}
\vfill

{\small
\begin{itemize}
\item
Sets may be entered as terms by enumeration:
=SML
rewrite_conv[]Ò9 ç {1*1; 2*2; 3*3; 4*4}Æ;
=GFT ProofPower Output
val it = Ù 9 ç {1 * 1; 2 * 2; 3 * 3; 4 * 4}
	§ T : THM   
=TEX
=SML
rewrite_conv[]Ò10 ç {1*1; 2*2; 3*3; 4*4}Æ;
=GFT ProofPower Output
val it = Ù 10 ç {1 * 1; 2 * 2; 3 * 3; 4 * 4}
	§ F : THM   
=TEX
\item
Sets may also be entered as set abstractions:
=SML
rewrite_conv[]Ò9 ç {x | x < 12}Æ;
=GFT ProofPower Output
val it = Ù 9 ç {x|x < 12} § T : THM   
=TEX
=SML
rewrite_conv[]Òz ç {(x, y) | x < y}Æ;
=GFT ProofPower Output
val it = Ù z ç {(x, y)|x < y}
	§ Fst z < Snd z : THM   
=TEX
\end{itemize}
\vfill
}%\small

\end{slide}

% =====================================================================

\begin{slide}{47}
\begin{center}
{\bf List Displays}
\end{center}
\vfill
\begin{itemize}
\item
A similar syntax is available for lists:\\
\vfill
=SML
rewrite_conv[append_def]
	Ò[1*1; 2*2; 3*3; 4*4] @ [5*5]Æ;
=GFT ProofPower Output
val it = Ù
	[1 * 1; 2 * 2; 3 * 3; 4 * 4] @ [5 * 5]
	= [1; 4; 9; 16; 25] : THM
=TEX
\vfill
=SML
ÒCons 1 [2;3;4;5]Æ;
=GFT ProofPower Output
val it = Ò[1; 2; 3; 4; 5]Æ : TERM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{48}
\begin{center}
{\bf Literals (I)}
\end{center}
\vfill
\begin{itemize}
\item
Numeric literals consist of a sequence of decimal digits (no sign):
=SML
dest_simple_term Ò123Æ;
=GFT ProofPower output
val it = Const ("123", îÓÆ)
	: DEST_SIMPLE_TERM   
=TEX
\vfill
\item
Character literals consisting of a single character in \verb!`! characters:
=SML
dest_simple_term Ò`¡`Æ;
=GFT ProofPower output
val it = Const ("`¡", îCHARÆ) (* ` *)
	: DEST_SIMPLE_TERM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{49}
\begin{center}
{\bf Literals (II)}
\end{center}
\vfill
{\small
\begin{itemize}
\item
String literals consisting of zero or more characters in ``\verb!"!'' characters:
=SML
dest_simple_term Ò"many characters ¡¬«"Æ;
=GFT ProofPower output
val it = Const ("\"many characters ¡¬«", (* " *)
	îCHAR LISTÆ) : DEST_SIMPLE_TERM
=TEX
% "
\vfill
\item
A string literal denotes a LIST of characters:
=SML
TOP_MAP_C string_conv Ò"characters ¡¬«"Æ;
=GFT ProofPower output
val it = Ù "characters ¡¬«"
    = [`c`; `h`; `a`; `r`; `a`; `c`; `t`; `e`; `r`; `s`;
    ` `; `¡`; `¬`; `«`] : THM
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{50}
\begin{center}
{\bf Theories/Declarations/Definitions\\
Specifications/Paragraphs}
\end{center}
\vfill
\begin{itemize}
\item
Information about specifications is held in the theory database.
\vfill
\item
The information is mainly put in the theories using various declarations, and definitions which are calls to ML functions.
\vfill
\item
Some specifications may be effected using ``paragraphs'' in the object language (HOL).
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Theories}
\end{center}
\vfill
A theory contains the following information:
\begin{itemize}
\item
The theory name and the names of the theories parents and children.
\item
The names and arities of type constructors declared in the theory.
\item
The names and types of constants declared in the theory.
\item
Fixity and aliasing information.
\item
Definitions of constants.
\item
A collection of saved theorems.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{52}
\begin{center}
{\bf Access to Theories}
\end{center}
\vfill
\begin{itemize}
\item
To use a theory it must be ``in context'', this can be achieved be opening the theory or one of its descendents:
=SML
open_theory : string -> unit;
=TEX
\item
To display the contents of a theory:
=SML
print_theory : string -> unit;
=TEX
\item
To get things from the theory:
=SML
get_aliases; get_ancestors; get_axiom; get_axioms;
get_binders; get_children; get_consts; get_defn;
get_defns; get_descendants; get_parents; get_thm;
get_thms; get_spec;
=TEX
\item
To save things in the theory use declarations, definitions, specifications or paragraphs (see below).
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{53}
\begin{center}
{\bf Exercises 2:
HOL Theory Explorations}
\end{center}
\vfill
{\tiny
\begin{itemize}
\item
Find the names of all the theories:
=SML
new_theory"tutorial";
theory_names();
=TEX
\item
Print selected theories, e.g.:
=SML
open_theory"sets";
print_theory"sets";
=TEX
\item
Get the terms from the definitions in a theory, e.g.:
=SML
open_theory "bin_rel";
(map concl o map snd o get_defns) "bin_rel";
=TEX
\item
Now select interesting terms and take them apart using, e.g.:
=SML
dest_simple_term Òµ r s∑ r ´ s = (Dom s · r) ¿ sÆ;
=GFT Hol Output
val it = App (Ò$µÆ, ÒÃ r∑ µ s∑ r ´ s = (Dom s · r) ¿ sÆ) : DEST_SIMPLE_TERM
=SML
dest_simple_term Ò{1;2;3}Æ;
=GFT Hol Output
val it = App (ÒInsert 1Æ, Ò{2; 3}Æ) : DEST_SIMPLE_TERM   
=SML
get_spec ÒInsertÆ;
=GFT Hol Output
val it = Ù µ x y a
  ∑ ≥ x ç {} ± x ç Universe ± (x ç Insert y a § x = y ≤ x ç a) : THM
=TEX
\end{itemize}
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{54}
\begin{center}
{\bf Declarations (I)}
\end{center}

\vfill

\begin{itemize}
\item
theories and parents
=SML
open_theory	: string -> unit;
new_theory	: string -> unit;
new_parent	: string -> unit;
=TEX
\item
types
=SML
new_type
 : string * int -> TYPE;
new_type_defn
 : string list * string * string list * THM -> THM;
declare_type_abbrev
 : string * string list * TYPE -> unit;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{55}
\begin{center}
{\bf Declarations (II)}
\end{center}

\vfill

\begin{itemize}
\item
constants
=SML
new_const
  : string * TYPE -> TERM;
simple_new_defn
  : string list * string * TERM -> THM;
new_spec
  : string list * int * THM -> THM;
const_spec
  : string list * TERM list * TERM -> THM;
=TEX
\item
types and constants
=SML
unlabelled_product_spec;
	(* mainly for use with Z *)
labelled_product_spec;
	(* see paragraphs below *)
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{56}
\begin{center}
{\bf Declarations (III)}
\end{center}

\vfill

Any identifier can be declared:

\begin{itemize}
\item
prefix, infix, postfix (with a priority)
\item
a binder (like ``µ'' and ``∂'')
\end{itemize}
=SML
declare_prefix	: int * string -> unit;
declare_infix	: int * string -> unit;
declare_postfix	: int * string -> unit;
declare_binder	: string -> unit;
get_fixity	: string -> Lex.FIXITY;
declare_nonfix	: string -> unit;
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Paragraphs}
\end{center}
\vfill

Some declarations may be done without resort to the metalanguage:

\begin{itemize}
\item
constant declarations (based on $const\_spec$)
=SML
open_theory "tutorial";
declare_postfix (200, "!");
πHOLCONST
‹
‹ $! : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹		0! = 1
‹±	µn:Ó∑	(n+1)! = n! * (n+1)
∞
=TEX
\item
labelled product declarations
πHOLLABPROD Date¸¸¸¸¸¸¸
‹	day month year:Ó
∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{58}
\begin{center}
{\bf Paragraphs - example}
\end{center}

\vfill

πHOLCONST
‹ length : 'a LIST ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	length [] = 0
‹± µ h t∑
‹	length (Cons h t) = length t + 1
‹
∞
=SML
print_theory "tutorial";
rewrite_conv[get_specÒlengthÆ]
	Òlength [1;2;3;4;5]Æ;
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{59}
\begin{center}
{\bf Exercises 3: Specification}
\end{center}

\vfill

\begin{itemize}
\item
Create a new theory as a child of ``hol''.
=GFT
new_theory "tutorial";
=TEX
\item
Write a specification in HOL of a function to add the elements of a list of numbers.

{\tiny HINT: if your specification goes in as a ``Constspec'' then they system could not prove it consistent, and its probably either wrong or poorly structured.
Try to make it clearly `primitive recursive'.}
\item
Use it to ``evaluate'' the term\\
$Òlist\_sum [1;2;3;4;5]Æ$.
=GFT
rewrite_conv[get_specÒlist_sumÆ]
	Òlist_sum [1;2;3;4;5]Æ;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{60}
\begin{center}
\bf Forward Proof in ProofPower
\end{center}
\vfill
\begin{itemize}
\item
{\bf theorems} - {\small values of type THM computed from {\bf axioms} and {\bf definitions} using {\bf rules} and {\bf conversions}.}
\item
{\bf axioms} - {\small theorems introduced without proof.}
\item
{\bf definitions} - {\small axioms introduced by ``conservative'' mechanisms.}
\item
{\bf rules} - {\small functions which compute theorems.}
\item
{\bf conversions} - {\small rules which prove equations from terms.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{61}
\begin{center}
\bf Theorems
\end{center}
\vfill
{\small
\begin{itemize}
\item
The {\bf HOL logic} is a ``sequent calculus''.
\item
A {\bf sequent} is a ``(TERM list) * TERM''(=SEQ) where each term must have type îBOOLÆ.
\item
The list of TERMs are known as ``assumptions'' the single term is the conclusion of the sequent.
\item
A sequent is valid if whenever the assumptions are all true the conclusion is also true.
\item
A theorem is a sequent which has been derived from axioms and definitions using the rules of the logic.
Theorems are tagged with an indicator of the context in which they were derived.
\item
The sequent part of a theorem may be accessed using:
=SML
dest_thm	: THM -> SEQ;
asms		: THM -> TERM list;
concl		: THM -> TERM;
=TEX
\item
Theorems are displayed without ``quine corners''; they cannot be parsed, they must be proven (or introduced as axioms).
\item
To see the primitive constants and axioms look in theories ``min'', ``log'' and ``init''.
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{62}
\begin{center}
\bf Naming Conventions for Theorems and Rules
\end{center}
\vfill
\begin{itemize}
\item $\_axiom$\\
ML names ending with $\_axiom$ are used for axioms and for functions (e.g. $new\_axiom$) for introducing or accessing axioms.
\item $\_def$ $\_spec$\\
ML name suffixes used for definitions.
\item $\_thm$ $\_clauses$\\
ML name suffixes for theorems.
\item $\_rule$ $\_elim$ $\_intro$\\
used for inference rules.
\item $\_conv$\\
for conversions, rules having type TERM -$>$ THM where the THM is an equation with the TERM as its left hand operand.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{63}
\begin{center}
\bf A Selection of Useful Rules (I)
\end{center}
\vfill
\begin{itemize}
\item assume rule:
=SML
val thm1 = asm_rule Òµx y:Ó∑ x*y > 0Æ;
=GFT ProofPower Output
val thm1 = µ x y∑ x * y > 0
		Ù µ x y∑ x * y > 0 : THM   
=TEX
\item modus ponens
=SML
val thm_a = asm_ruleÒa:BOOLÆ;
val thm_b = asm_ruleÒa¥bÆ;
=GFT ProofPower Output
val thm_a = a Ù a : THM
val thm_b = a ¥ b Ù a ¥ b : THM   
=SML
val thm_c = ¥_elim thm_b thm_a;
=GFT ProofPower Output
val thm_c = a ¥ b, a Ù b : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{64}
\begin{center}
\bf A Selection of Useful Rules (II)
\end{center}
\vfill
\begin{itemize}
\item specialisation
=SML
val thm2 = µ_elim Ò455Æ thm1;
=GFT ProofPower Output
val thm2 = µ x y∑ x * y > 0
		Ù µ y∑ 455 * y > 0 : THM   
=TEX
\item multiple specialisation
=SML
val thm3 = list_µ_elim [Ò455Æ,Ò0Æ] thm1;
=GFT ProofPower Output
val thm3 = µ x y∑ x * y > 0
		Ù 455 * 0 > 0 : THM   
=TEX
\item removing outermost universals
=SML
val thm4 = all_µ_elim thm1;
=GFT ProofPower Output
val thm4 = µ x y∑ x * y > 0 Ù x * y > 0 : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{65}
\begin{center}
\bf A Selection of Useful Rules (III)
\end{center}
\vfill
\begin{itemize}
\item splitting conjunctions
=SML
val thm5 = all_µ_elim plus_order_thm;
=GFT ProofPower output
val thm5 = Ù m + i = i + m
	± (i + m) + n = i + m + n
	± m + i + n = i + m + n : THM
=SML
val thms1 = strip_±_rule thm5;
=GFT ProofPower output
val thms1 = [Ù m + i = i + m,
	Ù (i + m) + n = i + m + n,
	Ù m + i + n = i + m + n] : THM list
=TEX
\item adding universals (I)
=SML
val thm6 = all_µ_intro (nth 2 thms1);
=GFT ProofPower output
val thm6 = Ù µ m i n∑ m + i + n = i + m + n : THM   
=TEX
\item adding universals (II)
=SML
val thm7 = list_µ_intro [ÒiÆ,ÒmÆ,ÒnÆ] (nth 2 thms1);
=GFT ProofPower output
val thm7 = Ù µ i m n∑ m + i + n = i + m + n : THM   
=TEX
\end{itemize}
\vfill
\end{slide}
}%\small
% =====================================================================

\begin{slide}{66}
\begin{center}
\bf Exercises 4: Forward Proof
\end{center}
\vfill
{\small
=IGN
asm_rule
strip_±_rule
¥_elim
µ_elim
all_µ_elim
list_µ_elim
all_µ_intro
list_µ_intro
≥_plus1_thm
º_trans_thm
≥_less_thm
=TEX
\begin{enumerate}
\item
Using $¥\_elim$ and $asm\_rule$ prove:
\begin{enumerate}
\item
$ b¥c, a¥b, a Ù c$
\item
$ a¥b¥c, a, b Ù c$
\end{enumerate}
\item
Using $µ\_elim$ with $≥\_plus1\_thm$ prove:
\begin{enumerate}
\item
$ Ù ≥ 0+1=0 $
\item
$ Ù ≥ x*x+1=0 $
\end{enumerate}
\item
Using $all\_µ\_elim$ with $º\_trans\_thm$ prove:
\begin{enumerate}
\item
$Ù m º i ± i º n ¥ m º n $
\end{enumerate}
\item
Using $list\_µ\_elim$ prove:
\begin{enumerate}
\item (with $≥\_less\_thm$)\\
$Ù ≥ 0 < 1 § 1 º 0$
\item (with $º\_trans\_thm$)\\
Ù µ n∑ 3 º x * x ± x * x º n ¥ 3 º n   
\end{enumerate}
\item
Using $all\_µ\_elim$, $strip\_±\_rule$, $nth$, $all\_µ\_intro$:
\begin{enumerate}
\item (with $º\_clauses$)\\
Ù µ i m n∑ i + m º i + n § m º n
\item (using $list\_µ\_intro$)\\
Ù µ m i n∑ i + m º i + n § m º n
\end{enumerate}
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{67}
\begin{center}
\bf Exercises 4: Solutions
\end{center}
\vfill
\begin{enumerate}
\item -
=SML
(* (a) *)
val ext1_thm1 = asm_rule Òa¥bÆ;
val ext1_thm2 = asm_rule Òb¥cÆ;
val ext1_thm3 = asm_rule Òa:BOOLÆ;
val ext1_thm4 = ¥_elim ext1_thm1 ext1_thm3;
val ext1_thm5 = ¥_elim ext1_thm2 ext1_thm4;
(* (b) *)
val ext2_thm1 =
 ¥_elim (asm_rule Òa¥b¥cÆ)(asm_rule Òa:BOOLÆ);
=TEX
\item -
=SML
(* (a) *)
val ext3_thm1 = µ_elim Ò0Æ ≥_plus1_thm;
(* (b) *)
val ext4_thm1 = µ_elim Òx*xÆ ≥_plus1_thm;
=TEX
\item -
=SML
(* (a) *)
val ext5_thm1 = all_µ_elim º_trans_thm;
=TEX
\item -
=SML
(* (a) *)
val ext6_thm1 = list_µ_elim [Ò0Æ,Ò1Æ] ≥_less_thm;
(* (b) *)
val ext7_thm1 = list_µ_elim [Ò3Æ,Òx*xÆ] º_trans_thm;
=TEX
\item -
=SML
(* (a) *)
val ext8_thm1 = strip_±_rule (all_µ_elim º_clauses);
val ext8_thm2 = all_µ_intro (nth 3 ext8_thm1);
(* (b) *)
val ext8_thm2 = list_µ_intro [ÒmÆ,ÒiÆ,ÒnÆ](nth 3 ext8_thm1);
=TEX
\end{enumerate}
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{68}
\begin{center}
\bf Goal Oriented Proof
\end{center}
\vfill
{\small
\begin{itemize}
\item a GOAL,

is just a sequent, viz:
\begin{itemize}
\item
a list of assumptions (BOOLean TERMs)
\item
a conclusion (also a BOOLean TERM)
\end{itemize}

GOAL = TERM list * TERM = SEQ
\item a PROOF,

is a function which computes a theorem from a list of theorems.

PROOF = THM list -$>$ THM
\item a TACTIC,

is a function which:
\begin{itemize}
\item
takes a GOAL
\item
returns
\begin{itemize}
\item
a list of sub-GOALs
\item
a PROOF which will compute a theorem corresponding to (``achieving'') the input goal from theorems corresponding to the sub-GOALs.
\end{itemize}
\end{itemize}

TACTIC = GOAL -$>$ (GOAL list * PROOF)
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{69}
\begin{center}
\bf Using the Subgoal Package
\end{center}
\vfill
{\small
\begin{itemize}
\item
Getting started:
=SML
set_goal : GOAL -> unit;
push_goal : GOAL -> unit;
push_consistency_goal : TERM -> unit;
=TEX
\item
Moving along:
=SML
apply_tactic : TACTIC -> unit;
a : TACTIC -> unit;
undo : int -> unit;
set_labelled_goal : string -> unit;
lemma_tac : TERM -> TACTIC;
=TEX
\item
Finishing off:
=SML
top_thm : unit -> THM;
pop_thm : unit -> THM;
save_pop_thm : string -> THM;
=TEX
\item
also note:
=SML
save_thm : string * THM -> THM;
list_save_thm
	: string list * THM -> THM;
save_consistency_thm
	: TERM -> THM -> THM;
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{70}
\begin{center}
\bf Rewriting
\end{center}
\vfill

$$ [pure\_] [once\_] [asm\_] rewrite\_ \cases{conv \cr rule \cr tac \cr thm\_tac} $$
	
$ :THM\ list -> \cases{conv (= TERM -> THM)\cr THM -> THM\cr TACTIC\cr } \hfill $

$ :THM -> TACTIC \hfill$
\vfill
{\small
rewrites the term, theorem or goal using:

\vfill

\begin{itemize}
\item
conversions in ``proof context'' (unless {\bf pure})
\item
assumptions (if {\bf asm} but not {\bf conv}) (after context sensitive pre-processing)
\item
theorems in $THM\ list$ (or $THM$) parameter (after context sensitive pre-processing)
\end{itemize}

\vfill

Rewriting continues until no more rewrites are possible (unless {\bf once}).
}%\small

\vfill

\end{slide}

% =====================================================================

\begin{slide}{71}
\begin{center}
\bf Exercises 5:
Rewriting with the Subgoal Package
\end{center}
\vfill
{\small
\begin{enumerate}
\item
set a goal from the examples on set theory, e.g.:
=SML
set_goal([],Òa \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
=TEX
\item
rewrite the goal using the current proof context:
=SML
a (rewrite_tac[]);
=TEX
\item
step back using undo:
=SML
undo 1;
=TEX
\item
now try rewriting without using the proof context:
=GFT
a (pure_rewrite_tac[]);
=TEX
(this should fail)
\end{enumerate}
}%\small
\vfill

\end{slide}

% =====================================================================

\begin{slide}{72}
\begin{center}
\bf Exercises 5 continued
\end{center}
\vfill
{\small
\begin{enumerate}
\setcounter{enumi}{4}
\item
try rewriting one layer at a time:
=SML
a (once_rewrite_tac[]);
=TEX
repeat until it fails.
\item
now try rewriting with specific theorems:
=SML
set_goal([],Òa \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
a (pure_rewrite_tac[sets_ext_clauses]);
a (pure_rewrite_tac[set_dif_def]);
a (pure_rewrite_tac[°_def, ¿_def]);
a (pure_rewrite_tac[set_dif_def]);
=TEX
\item
finish the proof by stripping:
=SML
a (REPEAT strip_tac);
=TEX
\item
extract the theorem
=SML
top_thm();
=TEX
\item repeat the above then try repeating:
=SML
pop_thm();
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{73}
\begin{center}
\bf Exercises 6:
combining forward and backward proof
\end{center}
\vfill
{\small
Prove the following results by rewriting using the goal package:
{\tiny for each example try the previous methods to see how they fail before following the hint
}%\tiny
\begin{enumerate}
\item :
=SML
set_goal([],Òx + y = y + xÆ);
=TEX
\item :
=SML
set_goal([],Òx + y + z = (x + y) + zÆ);
(* hint : try using plus_assoc_thm *)
=TEX
\item :
=SML
set_goal([],Òz + y + x = y + z + xÆ);
(* hint : try using plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Òx + y + z = y + z + xÆ);
(* hint : try using µ_elim with plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Òx + y + z + v = y + v + z + xÆ);
(* hint : try using µ_elim with plus_order_thm *)
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{74}
\begin{center}
\bf Exercises 6: Solutions
\end{center}
\vfill
\begin{enumerate}
\item :
=SML
set_goal([],Òx + y = y + xÆ);
a (rewrite_tac[]);
=TEX
\item :
=SML
set_goal([],Òx + y + z = (x + y) + zÆ);
a (rewrite_tac[plus_assoc_thm]);
=TEX
\item :
=SML
set_goal([],Òz + y + x = y + z + xÆ);
a (rewrite_tac[plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],Òx + y + z = y + z + xÆ);
a (rewrite_tac[µ_elim ÒyÆ plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],Òx + y + z + v = y + v + z + xÆ);
a (rewrite_tac[µ_elim ÒxÆ plus_order_thm]);
=TEX
\end{enumerate}
\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{75}
\begin{center}
\bf Stripping
\end{center}
\vfill
\begin{itemize}
\item
``stripping'' facilities incorporate automatic propositional reasoning and enable domain specific knowledge to be invoked automatically during proof.
\item
$strip\_tac$ processes the conclusion of the current goal
\item
When new assumptions are created, by $strip\_tac$ or otherwise, they are normally stripped before being entered into the assumption list.
\item
Stripping of assumptions is different to stripping of conclusions.  
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{76}
\begin{center}
\bf Stripping Conclusions (concl's)
\end{center}
\vfill
{\small
\begin{enumerate}
\item
apply conclusion stripping conversions from proof context
\item
if no conversion applies then attempt one of the following:
\begin{enumerate}
\item :
=GFT
	.. ?Ù µx∑ P x ===> .. ?Ù P x'
=TEX
\item :
=GFT
	.. ?Ù P1 ± P2 ===>
		.. ?Ù P1 and .. ?Ù P2 (two subgoals)
=TEX
\item :
=GFT
	.. ?Ù P1 ¥ P2 ===>
		strip_asm_tac(P1), .. ?Ù P2
=TEX
\end{enumerate}
\item
then check if:
\begin{enumerate}
\item conclusion of the goal is ÒTÆ
\item conclusion is in the assumptions
\end{enumerate}
if so, prove the result
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{77}
\begin{center}
\bf Stripping Assumptions (asm's)
\end{center}
\vfill
\begin{enumerate}
\item
Repeat the following transformations untill no further changes occur:
apply assumption stripping conversions from proof context
\begin{enumerate}
\item :
apply assumption stripping conversions from proof context
\item :
=GFT
	∂x∑ P x Ù? .. ===> P x' Ù? ..
=TEX
\item :
=GFT
	P1 ≤ P2 Ù? .. ===>
		P1 Ù? .. and P2 Ù? .. (two subgoals)
=TEX
\item :
=GFT
	P1 ± P2 Ù? .. ===>
		P1, P2 Ù? .. (two assumptions)
=TEX
\end{enumerate}
\item
then for each resulting assumption, check if:
\begin{enumerate}
\item assumption = F
\item assumption = concl
\item contradicts an existing assumption
\end{enumerate}
if so, prove the result.
\item
also check if:
\begin{enumerate}
\item assumption = T
\item is same as an existing assumption
\end{enumerate}
if so, discard the assumption.
\end{enumerate}
\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{78}
\begin{center}
\bf Exercises 7: Stripping
\end{center}
\vfill
{\small
\begin{itemize}
\item
Use the examples from Principia Mathematica \& ZRM given earlier, e.g.:
=SML
	set_goal([],Òp ± q ¥ (p § q)Æ);
=TEX
with
\begin{enumerate}
\item :
=SML
	a strip_tac;
=TEX
\item and/or:
=SML
	a step_strip_tac;
=TEX
\end{enumerate}
\item
Observe the steps taken and try to identify the reasons for discharge of subgoals.
\item
Select the weakest ``proof context'':
=SML
	push_pc"initial";
=TEX
then retry the examples (or previous exercises).
\item
When you have finished restore the original proof context by:
=SML
	pop_pc();
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{79}
\begin{center}
\bf Induction
\end{center}
\vfill
Induction priciples can be expressed as theorems in Higher Order Logic, e.g.:
\vfill
{\small
\begin{itemize}
\item $induction\_thm$
=GFT
	Ù µ p∑	p 0	±
	  (µ m∑ p m ¥ p (m + 1))
	¥	(µ n∑ p n) : THM   
=TEX
\item $cov\_induction\_thm$
=GFT
	Ù µ p∑	(µ n∑ (µ m∑ m < n ¥ p m) ¥ p n)
	¥	(µ n∑ p n) : THM   
=TEX
\item $list\_induction\_thm$
=GFT
	Ù µ p∑	p [] ±
	  (µ list∑ p list ¥ (µ x∑ p (Cons x list)))
	¥	(µ list∑ p list) : THM
=TEX
\end{itemize}
}%\small
\vfill
Using $µ\_elim$ and $all\_¬\_rule$ these can be specialised for use in forward proofs.
\vfill
\end{slide}

% =====================================================================

\begin{slide}{80}
\begin{center}
\bf Induction Tactics
\end{center}
\vfill
{\small
Special tactics are available to facilitate the use\\
of induction principles:
\begin{itemize}
\item induction over natural numbers using\\
$induction\_tac$
=FRULE 2
induction_tac ÒxÆ
˜
{ á } t
˜
{ á } t[0/x]; strip{t, á} t[x+1/x]
=TEX
\item induction over natural numbers using\\
$cov\_induction\_tac$
=FRULE 2
cov_induction_tac ÒxÆ
˜
{á} t
˜
strip{Òµm∑ m < x ¥ t[m/x]Æ, á} t
=TEX
\item $list\_induction\_tac$
=FRULE 2
list_induction_tac ÒxÆ
˜
{á} t
˜
{á} t[[]/x]; strip{t, á} t[Cons h x/x]
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{81}
\begin{center}
\bf Induction - Example (I)
\end{center}
\vfill
Prove the associativity of append.
\vfill
{\small
=SML
set_goal([],Òµl1 l2 l3 ∑
	(l1 @ l2) @ l3 = l1 @ (l2 @ l3)Æ);
(* remove universal quantifiers *)
a (REPEAT strip_tac);
=GFT ProofPower output
(* *** Goal "" *** *)

(* ?Ù *)  Ò(l1 @ l2) @ l3 = l1 @ l2 @ l3Æ
=SML
(* induct on Òl1Æ *)
a (list_induction_tac Òl1Æ);
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò(l1 @ l2) @ l3 = l1 @ l2 @ l3Æ

(* ?Ù *)  Òµ x∑ (Cons x l1 @ l2) @ l3
		= Cons x l1 @ l2 @ l3Æ

(* *** Goal "1" *** *)

(* ?Ù *)  Ò([] @ l2) @ l3 = [] @ l2 @ l3Æ
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{82}
\begin{center}
{\bf induction example (II)}
\end{center}
\vfill
{\small
=SML
a (rewrite_tac [append_def]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  Ò(l1 @ l2) @ l3 = l1 @ l2 @ l3Æ

(* ?Ù *)  Òµ x∑ (Cons x l1 @ l2) @ l3
		= Cons x l1 @ l2 @ l3Æ
=TEX
\vfill
=SML
a (asm_rewrite_tac [append_def]);
val append_assoc_thm = pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val append_assoc_thm =
 Ù µ l1 l2 l3∑ (l1 @ l2) @ l3 = l1 @ l2 @ l3 : THM   
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{83}
\begin{center}
\bf Exercises 8: Induction
\end{center}
\vfill
\begin{enumerate}
\item
Appending the empty list has no effect:
=SML
set_goal([], Òµl1 ∑ l1 @ [] = l1Æ);
=TEX
\item
``Reverse'' distributes over ``@'' (sort of):
=SML
set_goal([], Òµl1 l2 ∑
  Rev (l1 @ l2) = (Rev l2) @ (Rev l1)Æ);
=TEX
\item
``Map'' distributes over ``@'':
=SML
set_goal([], Òµf l1 l2 ∑
  Map f (l1 @ l2) = (Map f l1) @ (Map f l2)Æ);
=TEX
\item
``Length'' distributes over ``@'':
=SML
set_goal([], Òµl1 l2∑ Length (l1 @ l2)
	= Length l1 + Length l2Æ);
=TEX
\end{enumerate}
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{84}
\begin{center}
\bf Exercises 8: Solutions
\end{center}
\vfill
=SML
set_goal([],Òµl1 ∑ l1 @ [] = l1Æ);		(* no. 1 *)
a strip_tac;
a (list_induction_tac Òl1Æ
  THEN asm_rewrite_tac [append_def]);
val empty_append_thm = pop_thm();
=TEX
=SML
set_goal([],Òµl1 l2 ∑ Rev (l1 @ l2) =
	(Rev l2) @ (Rev l1)Æ);	(* no. 2 *)
a (REPEAT strip_tac);
a (list_induction_tac Òl1Æ THEN asm_rewrite_tac
  [append_assoc_thm, empty_append_thm,
	append_def, rev_def]);
val rev_distrib_thm = pop_thm();
=TEX
=SML
set_goal([],Òµf l1 l2 ∑ Map f (l1 @ l2) =
	(Map f l1) @ (Map f l2)Æ);	(* no. 3 *)
a (REPEAT strip_tac);
a (list_induction_tac Òl1Æ THEN asm_rewrite_tac
  [map_def, empty_append_thm, append_def]);
val rev_distrib_thm = pop_thm();
=TEX
=SML
set_goal([],Òµl1 l2∑ Length (l1 @ l2) =
	Length l1 + Length l2Æ);	(* no. 4 *)
a (REPEAT strip_tac);
a (list_induction_tac Òl1Æ THEN asm_rewrite_tac
  [append_def, length_def, plus_assoc_thm]);
val length_distrib_thm = pop_thm();
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{85}
\begin{center}
\bf TACTICALs and other -ALs
\end{center}
{\small
\vfill
\begin{itemize}
\item
TACTICALs may be used to combine the available tactics.
\item
Expressions using TACTICALs may be used directly in proofs, e.g.:
=GFT
	a (REPEAT strip_tac);
=TEX
\item
named tactics may be defined using TACTICALs:
=SML
	val repeat_strip_tac = REPEAT strip_tac;
=TEX
\item
TACTICALs may be used to define parameterised tactics:
=SML
	fun list_induct_tac t = REPEAT strip_tac
			THEN list_induction_tac t;
=TEX
\item
tacticals usually have capitalised names ending in ``\_T'', though the most common (e.g. REPEAT, THEN) have aliases omitting the ``\_T''
\item
other higher order functions are available:

conversionals (\_C suffix)\\
THM\_TACTICALs (\_THEN suffix)\\
THM\_TACTICAL combinators (\_TTCL suffix)
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{86}
\begin{center}
\bf commonly used TACTICals
\end{center}
{\small
\vfill
\begin{itemize}
\item
REPEAT - takes a tactic and returns a tactic which repeats that tactic until it fails.

If goal splits occur the repeating continues on all subgoals.

\item

THEN - an infix tactical which composes two tactics together.
The second tactic is applied to all subgoals arising from the first tactic.
If any applications of the operand tactics fail then the resulting tactic fails.

\item

ORELSE - an infix tactical which attempts to apply its first argument, and if this fails applies its second argument.
If both arguments fail then the resulting tactic fails.

\item
TRY\_T - a tactical taking one argument which will do nothing (but succeed!) if it argument tactic fails.

\item
THEN$\_$TRY - variant on THEN which does not fail even if the second tactic fails.

t1 THEN$\_$TRY t2 = t1 THEN (TRY\_T t2)
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{87}
\begin{center}
\bf Exercises 9: TACTICALs
\end{center}
{\small
\vfill
\begin{enumerate}
\item
Write a tactic which does $strip\_tac$ three times.

test it on:
=SML
set_goal([],Ò(a ¥ b ¥ c) ¥ a ¥ b ¥ cÆ);
set_goal([],Ò(a ¥ b) ¥ a ¥ cÆ);
=TEX
\item
Write a tactic which does $strip\_tac$ up to 3 times.

Try it on the same examples.
\item
Write a tactic which takes two arguments:
\begin{itemize}
\item
a term which is a variable
\item
a list of theorems
\end{itemize}
and performs an inductive proof of a theorem concerning lists by:
\begin{itemize}
\item
stripping the goal
\item
inducting on the variable
\item
rewriting with the assumptions and the list of theorems
\end{itemize}

Use it to shorten the earlier proofs about lists.
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================
\begin{slide}{88}
\begin{center}
\bf Exercises 9: Solutions
\end{center}
{\tiny
\vfill
=SML
(* no. 1 *)
val strip3_tac = strip_tac THEN strip_tac THEN strip_tac;
set_goal([],Ò(a ¥ b ¥ c) ¥ a ¥ b ¥ cÆ);
a strip3_tac;
=TEX
\vfill
=SML
(* no. 2 *)
val stripto3_tac = strip_tac THEN_TRY strip_tac
		THEN_TRY strip_tac;
set_goal([],Ò(a ¥ b) ¥ a ¥ cÆ);
a stripto3_tac;
=TEX
\vfill
=SML
(* no. 3 *)
fun list_induct_tac var thl =
	REPEAT strip_tac
	THEN list_induction_tac var
	THEN_TRY asm_rewrite_tac thl;

set_goal([],Òµl1 l2 l3 ∑
  (l1 @ l2) @ l3 = l1 @ (l2 @ l3)Æ);
a (list_induct_tac Òl1:'a LISTÆ [append_def]);
val append_assoc_thm = pop_thm ();

set_goal([], Òµl1:'a LIST ∑ l1 @ [] = l1Æ);
a (list_induct_tac Òl1:'a LISTÆ [append_def]);
val empty_append_thm = pop_thm();
=TEX
=IGN
set_goal([], Òµl1 l2:'a LIST  ∑
  Rev (l1 @ l2) = (Rev l2) @ (Rev l1)Æ);
a (list_induct_tac Òl1:'a LISTÆ
  [append_def, rev_def, append_assoc_thm, empty_append_thm]);
set_goal([], Òµf; l1 l2:'a LIST∑
  Map f (l1 @ l2) = (Map f l1) @ (Map f l2)Æ);
a (list_induct_tac Òl1:'a LISTÆ
  [append_def, map_def, append_assoc_thm, empty_append_thm]);
set_goal([], Òµl1 l2:'a LIST∑ Length (l1 @ l2)
	= Length l1 + Length l2Æ);
a (list_induct_tac Òl1:'a LISTÆ
  [append_def, length_def, append_assoc_thm,
  empty_append_thm, plus_assoc_thm]);
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{89}
\begin{center}
\bf Proof Strategy
\end{center}
\vfill
\begin{itemize}
\item

A large application proof may take several man years of effort to complete.
\vfill

\item

Top level proof strategy for large proofs must be carefully thought out.

{\tiny
The lemmas are best proven separately, stored in the theory, and combined in a top level proof delivering the required result from the major lemmas.
Exploration may be forwards or backwards.
}%\tiny
\vfill

\item

Lemmas of moderate size may be proven using the goal package.

{\tiny
Such a proof would consist of a combination of stripping, rewriting with definitions, assumptions and previously proven results, and other uses of previous results.
}%\tiny
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{90}
\begin{center}
\bf What to do when faced with a Goal\\
-\\
Sanity Checks
\end{center}
\vfill
\begin{itemize}
\item
Decide whether the goal is true, if not, don't try to prove it!
\vfill
\item
Decide whether the conclusion is relevant (are the assumptions inconsistent?).
\vfill
\item
Take the negation of an assumption as conclusion if this would be easier\\
(use $swap\_asm\_concl\_tac$).
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{91}
\begin{center}
\bf What to do when faced with a Goal\\
-\\
Main Choices
\end{center}
\vfill
\begin{itemize}
\item
Prove automatically.\\
(using $prove\_tac$ or $prove\_∂\_tac$).
\item
Transform the conclusion by stripping.
\item
Transform the conclusion by rewriting.
\item
Forward inference from assumptions.
\item
Backward inference from conclusion\\
($bc\_tac$ and induction tactics).
\item
Swap the conclusion with an assumption\\
($swap\_asm\_concl\_tac$).
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{92}
\begin{center}
\bf `Forward Inference' from Assumptions
\end{center}
\vfill
{\small
\begin{itemize}
\item
$lemma\_tac$ may be used for a backward proof of an intermediate result.
\vfill
\item
$list\_spec\_asm\_tac$ may be used to specialise assumptions (and strip results).
\vfill
\item
$asm\_fc\_tac$ and $fc\_tac$ may be used for automatic `forward chaining' from assumptions.
\vfill
\item
Assumptions can be used as a basis for forward proof using $asm\_rule$, or by $GET\_ASM\_T$ et. al.
\vfill
\item
Theorems may be stripped into assumptions using\\
$strip\_asm\_tac$ (or $check\_asm\_tac$).
\vfill
\item
It may be necessary to ``turn round'' an equation, for which $eq\_sym\_conv$ may be used.
\vfill
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{93}
\begin{center}
\bf Uses of $lemma\_tac$ (I)
\end{center}
\vfill
{\small
\begin{itemize}
\item
For proving intermediate results helpful in establishing the main goal.
=GFT SML
set_goal([],Òconc:BOOLÆ);
a (lemma_tac Òlemma:BOOLÆ);
=GFT Hol Output
(* *** Goal "2" *** *)
(*  1 *)  ÒlemmaÆ

(* ?Ù *)  ÒconcÆ

(* *** Goal "1" *** *)
(* ?Ù *)  ÒlemmaÆ
=TEX
\item
Where a mathematician might say:\\
``let v be a value such that P v''.
=GFT SML
set_goal([],Òconc:BOOLÆ);
a (lemma_tac Ò∂v∑ P vÆ);
=GFT Hol Output
(* *** Goal "2" *** *)
(*  1 *)  ÒP vÆ

(* ?Ù *)  ÒconcÆ

(* *** Goal "1" *** *)
(* ?Ù *)  Ò∂ v∑ P vÆ
=TEX

\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{94}
\begin{center}
\bf Uses of $lemma\_tac$ (II)
\end{center}
{\small
\vfill
\begin{itemize}
\item
For doing induction on the value of expressions rather than variables.
\vfill
=GFT SML
set_goal([],Òconc:BOOLÆ);
a (lemma_tac Ò∂v:Ó∑ v = exprÆ
	THEN1 prove_∂_tac);
=GFT Hol Output
(* *** Goal "" *** *)
(*  1 *)  Òv = exprÆ

(* ?Ù *)  ÒconcÆ
=TEX
=GFT SML
a (asm_ante_tac Òv = exprÆ);
=GFT Hol Output
(* *** Goal "" *** *)

(* ?Ù *)  Òv = expr ¥ concÆ
=TEX
\vfill
Now do induction on ÒvÆ.
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{95}
\begin{center}
\bf Processing of ``new'' assumptions
\end{center}
\vfill
{\small

Tactics which create new assumptions (like ``strip\_tac'' and ``lemma\_tac''), normally add these into the assumption list using ``strip\_asm\_tac''.

``strip\_asm\_tac'' is a $THM -> TACTIC$.

Many tactics which create assumptions have corresponding tacticals (in upper case, ending in\\
``\_T'' instead of ``\_tac''), which allow the resulting assumption to be supplied to an arbitrary $THM -> TACTIC$.

e.g. corresponding to ``lemma\_tac'' there is a tactical\\
``LEMMA\_T''.

$lemma\_tac$ is the same as $LEMMA\_T\ strip\_asm\_tac$.

Other $THM -> TACTICS$ include $asm\_tac$, $rewrite\_thm\_tac$, $ante\_tac$.

=GFT SML
set_goal([],Òi + i = 2*iÆ);
a (LEMMA_T Ò2 = 1 + 1Æ pure_rewrite_thm_tac
	THEN1 rewrite_tac[]);
=GFT Hol Output
(* *** Goal "" *** *)
(* ?Ù *)  Òi + i = (1 + 1) * iÆ
=GFT SML
a (rewrite_tac[times_plus_distrib_thm]);
=GFT Hol Output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{96}
\begin{center}
\bf Exercises 10.
\end{center}
{\tiny
\vfill
\begin{description}
\item[1.]
Sometimes it is necessary to manipulate an assumption, e.g. by
rewriting it. $swap\_asm\_concl\_tac$ negates and then interchanges the
conclusion of a goal with an assumption (given as a parameter).
Using $swap\_asm\_concl\_tac$ and tactics you have already seen,
prove that there is no greatest natural number:
=SML
set_goal([], Òµm∑∂n∑ m < nÆ);
=TEX
(Hint: use $contr\_tac$ first).
\item[2.]
Rather than using $contr\_tac$, it is often more natural to prove goals
with existentially quantified conclusions directly. $∂\_tac$ lets you
do this by supplying a term to act as a ``witness''.
Use $∂\_tac$ to give a more natural solution to the previous exercise:
=SML
set_goal([], Òµm∑∂n∑ m < nÆ);
=TEX
\item[3.]
The system currently contains only a few basic results about multiplication,
division and modulo, ($*$, $Div$ and $Mod$).
Look at the end of the listing of theory Ó to see these.
Use them to prove:
=SML
set_goal([], Òµi j∑(i + j) * (i + j) = i*i + 2*i*j + j*jÆ);
=TEX
(Hints: Use $lemma\_tac$ to prove that $2 = 1 + 1$;
then, use the lemma and the theorems supplied about commutativity of $*$
and distributivity of $*$ over $+$
to rewrite the goal taking care to avoid looping.)
\end{description}
}%\tiny
\vfill
\end{slide}

% =====================================================================
\begin{slide}{97}
{\tiny
\begin{description}
\item[4.]
It can happen that an equation is the wrong way round for use as
a rewrite rule. The usual means for dealing with this type of
problem is the conversion $eq\_sym\_conv$. Like other conversions
this may be propagated over a term using the conversionals $MAP\_C$
and $ONCE\_MAP\_C$.
Execute the following lines one at a time to see what happens:
=GFT
eq_sym_conv Ò1 + 1 + 1 = 3Æ;
eq_sym_conv Òµx∑x + x + x = 3*xÆ;
ONCE_MAP_C eq_sym_conv Òµx∑x + x + x = 3*xÆ;
=TEX
A conversion may be converted into a tactic using $conv\_tac$.
Use this and the conversion and conversional you have just experimented
with together with the tactics $swap\_asm\_concl\_tac$
and the theorems $ext\_thm$ and $comb\_s\_def$ to prove the following:
=SML
set_goal([], Òµf:'a≠'b≠'a∑(µx y∑x = f x y) ¥ f = CombKÆ);
=TEX
(Hint: take care to avoid looping rewrites by using the ``once'' rewriting
tactics while you look for the proof.)
\item[5.]
A common way of using a theorem is to 
to strip it into the assumptions. This is done with $strip\_asm\_tac$.
Very often one specialises the theorem with $µ\_elim$ or $list\_µ\_elim$
before stripping it in and sometimes one may wish to use
$rewrite\_rule$ to rewrite it too.
Use the theorem $div\_mod\_unique\_thm$ in this way to prove:
=SML
set_goal([], Òµi j∑0 < i ¥ (i * j) Div i = jÆ);
=TEX
(Hints: rewrite the theorem with a $times\_comm\_thm$ suitably specialised
to identify subterms of the form $i * j$ and $j * i$ into the same form;
use the technique of the previous exercise to avoid a looping rewrite with
the assumption added by $strip\_asm\_tac$).
\end{description}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{98}
{\tiny
\begin{description}
\item[6.]
Execute the following paragraph to define a function ” which maps $i$
to the sum of the first $i$ positive integers:
πHOLCONST
‹	” : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	” 0 = 0
‹ ±	µi∑ ”(i+1) = ” i + (i + 1)
∞
The consistency of this paragraph should be proved automatically.
Check this by using $get\_spec$ to get the defining axiom for ”,
which should have no assumptions.
Prove the following theorem:
=SML
set_goal([], Òµi∑” i = (i*(i + 1)) Div 2Æ);
=TEX
(Hint: use induction to prove a lemma that
$i*(i + 1) = 2\,*\,” i$ and then use the result of the previous exercise;
the lemma is much easier to prove if you turn the equation round and the
inductive step is rather like the proof in exercise 3.)
\item[7.]
Construct a paragraph defining a function $∆$ such that for positive $i$,
$∆ i$ is the $i-th$ element of the Fibonacci sequence,
$1, 1, 2, 3, 5, \ldots$, where each number is the sum of the previous
two. Does the system automatically prove the consistency of your
definition?
\end{description}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{99}
{\tiny
\begin{description}
\item[8.]
If you did the previous exercise, delete the function $f$ you defined
(using $delete\_const$).
Enter the following paragraphs which
define $∆$ using an auxiliary function $«$:
πHOLCONST
‹	« : Ó ≠ (Ó ∏ Ó)
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	« 0 = (0, 1)
‹ ±	µi∑«(i+1) = let (a, b) = « i in (b, a + b)
‹	
∞
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ 	µi∑∆ i = Fst (« i)
‹	
∞
These definitions are proved consistent automatically.
Prove that $∆$ does indeed compute the Fibonacci numbers:
=GFT
set_goal([], Ò
	∆ 0 = 0
±	∆ 1 = 1
±	µi∑∆(i+2) = ∆(i+1) + ∆ i
Æ);
=TEX
(Hints: first rewrite with the definition of $∆$; then prove a lemma
or lemmas showing how $«\,1$ and $«(i+2)$ may be rewritten so that
the definition of $«$ may be used to rewrite them.)

\item[9.]

The approach of the previous exercise has the disadvantage that the
specification was not as abstract as one would like. A cleaner approach
is to use the obvious definition of $∆$, and then prove that it
is consistent using a function $«$ which is only introduced as
a variable during the course of the proof. The tactic
$prove\_∂\_tac$ gives access to the mechanisms that the system
uses in its attempt to prove that paragraphs are consistent.
We demonstrate this technique in this exercise.
\end{description}
}%\tiny
\vfill
\end{slide}

% =====================================================================
\begin{slide}{100}
{\tiny
\begin{description}

\item[9.(cont)]

First of all, delete the function $«$ that you defined in the previous
exercise
(using $delete\_const$, which will also cause $∆$ to be deleted).
=SML
delete_constÒ«Æ;
=TEX
Enter the following paragraph which gives the natural definition of
$∆$:
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	∆ 0 = 0
‹ ±	∆ 1 = 1
‹ ±	µi∑∆(i+2) = ∆(i+1) + ∆ i
∞
Examine the theorem that $get\_spec$ returns for $∆$, it has
a consistency caveat as an assumption.
Discharge this consistency caveat as follows:

First of all go into the subgoaling package using the following command:
=GFT
push_consistency_goalÒ∆Æ;
=TEX
Now set as a lemma the existence of a $«$ as in the previous exercise;
the lemma is proved immediately by $prove\_∂\_tac$ and you can
then use $∂\_tacÒÃi∑Fst(«\,i)Æ$ followed a proof almost identical with the previous
exercise (hint: $rewrite\_tac$ will eliminate the ¬-redexes introduced
when you apply $∂\_tac$). Save the consistency theorem using the
following command:
=GFT
save_consistency_thm Ò∆Æ (pop_thm());
=TEX
If you now examine the theorem that $get\_spec$ returns for $∆$, you
should see that it no longer has an assumption.

{\tiny
(Note: the variable name `∆$'$', created by decorating `∆' is displayed by the pretty printer as $\$\,$``∆$'$'' since it violates the HOL lexical rules for identifiers.
The parser will accept identifiers violating the normal lexical rules if they are presented in this way.)
}%\tiny
\end{description}
}%\small
\vfill
\end{slide}

% =====================================================================
\begin{slide}{101}
\begin{center}
\bf Exercises 10: Solutions
\end{center}
{\tiny
\vfill
=SML
(* no. 1 *)
set_goal([], Òµm∑∂n∑ m < nÆ);
a(contr_tac);
a(list_spec_asm_tacÒµ n∑ ≥ m < nÆ[Òm+1Æ]);
a(swap_asm_concl_tacÒ≥m < m+1Æ);
a(rewrite_tac[]);
val thm1 = pop_thm();
=TEX
=SML
(* no. 2 *)
set_goal([], Òµm∑∂n∑ m < nÆ);
a(REPEAT strip_tac);
a(∂_tacÒm+1Æ);
a(rewrite_tac[]);
val thm2 = pop_thm();
=TEX
=SML
(* no. 3 *)
set_goal([], Òµi j∑(i + j) * (i + j) = i*i + 2*i*j + j*jÆ);
a (REPEAT strip_tac);
a (lemma_tacÒ2 = 1 + 1Æ);
a (rewrite_tac[]);
a (pure_asm_rewrite_tac[times_plus_distrib_thm, plus_assoc_thm]);
a (rewrite_tac[µ_elimÒjÆtimes_comm_thm]);
val thm3 = pop_thm();
=TEX
=SML
(* no. 4 *)
set_goal([], Òµf:'a≠'b≠'a∑(µx y∑x = f x y) ¥ f = CombKÆ);
a (REPEAT strip_tac);
a (rewrite_tac[ext_thm, comb_k_def]);
a (swap_asm_concl_tacÒµ x y∑ x = f x yÆ);
a (conv_tac(ONCE_MAP_C eq_sym_conv));
a (swap_asm_concl_tacÒ≥ f x x' = xÆ THEN asm_rewrite_tac[]);
val thm4 = pop_thm();
=TEX
\vfill
}
\end{slide}

% =====================================================================

\begin{slide}{102}
{\tiny
=SML
(* no. 5 *)
set_goal([], Òµi j∑0 < i ¥ (i * j) Div i = jÆ);
a (REPEAT strip_tac);
a (strip_asm_tac(
	rewrite_rule[µ_elimÒjÆtimes_comm_thm]
	(list_µ_elim[Òi*jÆ, ÒiÆ, ÒjÆ, Ò0Æ] div_mod_unique_thm)));
a (swap_asm_concl_tacÒj = (i * j) Div iÆ THEN
		(conv_tac(ONCE_MAP_C eq_sym_conv)));
a (strip_tac);
val thm5 = pop_thm();
=TEX
=SML
(* no. 6 *)
set_goal([], Òµi∑” i = (i*(i + 1)) Div 2Æ);
a (REPEAT strip_tac);
a (lemma_tacÒi * (i + 1) = 2 * ” iÆ);
a (conv_tac eq_sym_conv);
(* *** Goal "1" *** *)
a (induction_tacÒiÆ THEN
	asm_rewrite_tac
	[get_specÒ”Æ, times_plus_distrib_thm, plus_assoc_thm]);
a (lemma_tacÒ2 = 1 + 1Æ);
(* *** Goal "1.1" *** *)
a (rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (pure_asm_rewrite_tac[times_plus_distrib_thm, plus_assoc_thm1]);
a (rewrite_tac[] THEN rewrite_tac[plus_assoc_thm]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[rewrite_rule[](list_µ_elim[Ò2Æ, Ò” iÆ]thm5)]);
val thm6 = pop_thm();
=TEX
\vfill
}
\end{slide}

% =====================================================================

\begin{slide}{103}
{\tiny
=SML
(* no. 7 *)
=TEX
The obvious way of defining the Fibonacci function is not automatically
proved consistent:
=SML
delete_constÒ∆Æ;
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	∆ 0 = 0
‹ ±	∆ 1 = 1
‹ ±	µi∑∆(i+2) = ∆(i+1) + ∆ i
‹	
∞
=SML
get_specÒ∆Æ;
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{104}
{\tiny
=SML
delete_constÒ∆Æ;
=SML
(* no. 8 *)
πHOLCONST
‹	« : Ó ≠ (Ó ∏ Ó)
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	« 0 = (0, 1)
‹ ±	µi∑«(i+1) = let (a, b) = « i in (b, a + b)
‹	
∞
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ 	µi∑∆ i = Fst (« i)
‹	
∞
=SML
set_goal([], Ò
	∆ 0 = 0
±	∆ 1 = 1
±	µi∑∆(i+2) = ∆(i+1) + ∆ i
Æ);
a (rewrite_tac[get_specÒ∆Æ]);
a (lemma_tacÒ« 1 = «(0 + 1) ± µi∑ «(i + 2) = «((i+1)+1)Æ);
(* *** Goal "1" *** *)
a (rewrite_tac[plus_assoc_thm]);
(* *** Goal "2" *** *)
a (pure_asm_rewrite_tac[get_specÒ«Æ, let_def] THEN rewrite_tac[]);
val thm8 = pop_thm();
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{105}
{\tiny
=SML
(* no. 9 *)
delete_constÒ«Æ;
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	∆ 0 = 0
‹ ±	∆ 1 = 1
‹ ±	µi∑∆(i+2) = ∆(i+1) + ∆ i
∞
=SML
get_specÒ∆Æ;
push_consistency_goalÒ∆Æ;
a (lemma_tacÒ∂«∑
	« 0 = (0, 1)
±	µi∑«(i+1) = let (a, b) = « i in (b, a + b)
Æ);
(* *** Goal "1" *** *)
a (prove_∂_tac);
(* *** Goal "2" *** *)
a (∂_tacÒÃi∑Fst(« i)Æ);
a (rewrite_tac[]);
a (lemma_tacÒ« 1 = «(0 + 1) ± µi∑ «(i + 2) = «((i+1)+1)Æ);
(* *** Goal "2.1" *** *)
a (rewrite_tac[plus_assoc_thm]);
(* *** Goal "2.2" *** *)
a (pure_asm_rewrite_tac[let_def] THEN asm_rewrite_tac[]);
save_consistency_thm Ò∆Æ (pop_thm());
get_specÒ∆Æ;
=TEX
}%\tiny
\vfill
\end{slide}


=IGN
push_pc "hol1";
set_goal([],Òµl1 l2∑ Length (l1 @ l2) = Length l1 + Length l2Æ);
a (REPEAT strip_tac);
a (list_induction_tac Òl1Æ THEN asm_rewrite_tac
  [append_def, length_def, plus_assoc_thm]);
=TEX
πHOLCONST
‹ interleave : 'a LIST ≠ 'a LIST ≠ 'a LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹(µ h1 t1 h2 t2∑
‹	interleave [] [] = []
‹±	interleave [] (Cons h2 t2) = (Cons h2 t2)
‹±	interleave (Cons h1 t1) [] = (Cons h1 t1)
‹± 	interleave (Cons h1 t1) (Cons h2 t2) =
‹	Cons h1 (Cons h2 (interleave t1 t2)))
‹
∞
=SML
rewrite_conv[get_specÒinterleaveÆ]
  Òinterleave[1;2;3;4;5][10;11;12]Æ;
=TEX
\end{document}
