=TEX
% usr023.doc   %Z% $Date$ $Revision$ $RCSfile$
% COPYRIGHT (c) International Computers Limited, 1992

\def\SCCSissue{$Revision$
}

\long\def\ignore#1{}

\ignore{

=SML
open_theory "z_library";
new_theory "usr023";
set_pc "z_language";
=TEX

}%\ignore
\underscoreoff
% =====================================================================

\begin{slide}{1}

\vfill

\begin{center}

\vfill

{\huge Proof in Z}\\
with\\
{\huge \bf ProofPower}\\

\vfill

\end{center}

\end{slide}

% =====================================================================

\begin{slide}{2}
\begin{center}

{\bf Course Objectives}

\end{center}
\vfill

\begin{itemize}
\item
to describe the basic principles and concepts underlying ProofPower support for Z
\item
to enable the student to write simple specifications and undertake elementary proofs in Z using ProofPower
\item
to enable the student to make effective use of the reference documentation for ProofPower-Z
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{3}
\begin{center}

{\bf Course Outline}

\end{center}
\vfill

\begin{itemize}
\item
Introduction to ProofPower-Z

{\small
\begin{itemize}
\item
an overview of Z support in ProofPower
\item
propositional and predicate calculus proofs in Z
\end{itemize}
}%\small

\item
Specification in Z using ProofPower

{\small
\begin{itemize}
\item
Expressions and Predicates
\item
Schema Expressions
\item
Paragraphs
\end{itemize}
}%\small

\item
Proof in Z using ProofPower

{\small
\begin{itemize}
\item
Basics of Proof
\item
Rules, Conversions, Tactics...
\item
Stripping, Rewriting
\item
Induction
\end{itemize}
}%\small

\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{4}
\begin{center}
\bf Schedule
\end{center}
\vfill
\vertbarfalse
{\tiny
=GFT
slide	topic			time

WEDNESDAY 24th March

	BUFFET LUNCH		12:30
	
01	introduction		13:30
20	exercises 1			13:50
28	Predicate Calculus	14:15
20	exercises 2 		14:35

	COFFEE			15:00

33	Expressions			15:15
53	Exercises 2			15:50
54	Schema Expressions	16:05
59	Exercises 3			16:20
50	Theories			15:35
66	Exercises 4		17:10

THURSDAY 25th March

66	Exercises 4 (cont)		9:00
68	Sets and Relations			9:15
71	Exercises 5 & 6		9:30
75	Numbers			10:05
78	Exercises 7		10:20

	COFFEE			10:30
	
79	Induction			11:05
83	Exercises 8		11:20
85	TACTICALs et.al.		11:45
86	Exercises 9		11:55
89	Proof Strategy		12:10
96	Exercises 10		12:30

	BUFFET LUNCH		12:30
=TEX
}%\tiny
\vertbartrue
\vfill
\end{slide}
% =====================================================================

\begin{slide}{5}
\begin{center}

{\bf Course Prerequisites}

\end{center}
\vfill

We assume a working knowledge of:
{\ftlmargin=0.7in \ftrmargin=0.5in
\begin{itemize}
\item
Z as a specification language
{\small
πZ
[NAME, DATE]
∞

=GFT Z
U[X] ¶ X
=TEX

ˇFile¸¸¸¸¸¸¸
‹ people :  NAME;
‹ age : NAME ﬂ DATE
˜¸¸¸¸¸¸¸¸
‹ dom age = people
à¸¸¸¸¸¸¸¸¸¸
=TEX
}%\small
\item
the use of ProofPower with HOL (under sunview)
\end{itemize}
}%\ftlmargin
\vfill
\end{slide}

% =====================================================================

\begin{slide}{7}
\begin{center}
\vfill

{\bf Some Z Proofs are Easy with ProofPower}
\end{center}

\begin{itemize}
\item
propositional tautologies

{\tiny Propositional reasoning in Z is exactly the same as in HOL, fully automatic and well integrated into the normal proof methods.}

\item
first order predicate calculus

{\tiny As in HOL, predicate calculus proofs in Z are either automatic or routine.}

\item
elementary set theory

{\tiny A useful class of results from elementary set theory are automatically provable.}

\item
other classes of results

{\tiny Whenever a new theory is introduced one or more proof contexts may be developed to solve automatically a range of results in that theory.
``Decision procedures'' for such classes of results can be made available via ``prove\_tac''.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{8}
\begin{center}

{\bf Simple Predicate Calculus Proofs}
\end{center}
\vfill
{\small

\begin{itemize}
\item
use the subgoaling package

\item
set the goal

=SML
open_theory"usr023";
set_pc "z_predicates";
set_goal([],Ò (µx, y:X∑ P x ¥ R y)
	§ (µv, w:X∑ ≥ P w ≤ R v)Æ);
=TEX
\item
initiate proof by contradiction
=SML
a contr_tac;
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
...
(*  5 *)  Ò µ x, y : X ∑ P x ¥ R yÆ
(*  4 *)  Ò v ç XÆ
(*  3 *)  Ò w ç XÆ
(*  2 *)  Ò P wÆ
(*  1 *)  Ò ≥ R vÆ

(* ?Ù *)  Ò falseÆ
=TEX
\item
instantiate assumptions as required
=SML
a (z_spec_asm_tac Ò µ x, y : X ∑ P x ¥ R yÆ
	Ò (x ¶ w, y ¶ v)Æ);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{9}
\vfill
{\small
=GFT ProofPower output
Tactic produced 0 subgoals:
(* *** Goal "2" *** *)

(*  5 *)  Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
(*  4 *)  Ò x ç XÆ
(*  3 *)  Ò y ç XÆ
(*  2 *)  Ò P xÆ
(*  1 *)  Ò ≥ R yÆ

(* ?Ù *)  Ò falseÆ
=SML
a (z_spec_asm_tac Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
	Ò (v ¶ y, w ¶ x)Æ);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=SML
pop_thm();
=GFT ProofPower output
Now 0 goals on the main goal stack
val it = Ù (µ x, y : X ∑ P x ¥ R y) §
	(µ v, w : X ∑ ≥ P w ≤ R v) : THM   
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{10}

\begin{center}
{\bf Reasoning in Z with ProofPower}
\end{center}

\vfill

\begin{itemize}
\item
Non-Problems
\item
Proof Automation ``Lifted'' from ProofPower HOL
\item
The Main Problem Area
\item
Futher Proof Automation Needed
\end{itemize}

\vfill

\end{slide}

% =====================================================================

\begin{slide}{10}

\begin{center}
{\bf Reasoning in Z\\
Non-Problems}
\end{center}

\vfill

\begin{itemize}
\item
Axiomatic v. Conservative
\item
Generics
\item
Schema Calculus
\item
Exotic variable binding constructs.
\item
Invisible Variables (schemas as predicates and declarations)
\end{itemize}

\vfill
\end{slide}

% =====================================================================

\begin{slide}{10}

\begin{center}
{\bf Reasoning in Z\\
Facilities lifted from HOL}
\end{center}

\vfill
\begin{itemize}
\item
Propositional Reasoning
\item
Predicate Calculus:
\begin{itemize}
\item
stripping
\item
forward chaining (aka $RES\_TAC$)
\item
resolution (via $prove\_tac$)
\end{itemize}
\item
basic rewriting
\item
basic integer arithmetic
\item
arithmetic computations
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{11}

\begin{center}
{\bf Reasoning in Z\\
KEY PROBLEM AREAS}
\end{center}

\vfill
Ease of Unfolding Definitions
\vfill
Complexity of Underlying Types
\vfill
Methods which contain complexity
\vfill

\end{slide}

% =====================================================================

\begin{slide}{11}

\begin{center}
{\bf Reasoning in Z\\
Types v Sets}
\end{center}

\vfill
{\small

\begin{itemize}
\item
HOL has:

\begin{itemize}
\item a simple decidable type system
\item quantification ranging over types only.
\end{itemize}

Hence unconditional rewriting goes a long way.

\item
Z has:

\begin{itemize}
\item a simple decidable {\it hidden} type system
\item a set relativised surface syntax
\end{itemize}

Hence most rewrites are really conditional, even if superficially unconditional.
=IGN
Languages like PVS, VDM, VERITAS have more complex undecidable type systems including\\ subtyping.
Type checking is more difficult but then unconditional rewriting can be used?
\item
Z has a decidable type system similar to that of HOL, but quantification is set relativised.\\
Predicate calculus proofs are similar to proofs in HOL of comparable propositions, but typical propositions in Z are inherently more complex because of the set relativisation.\\
Unconditional rewriting doesn't go very far, proofs avoided during type-checking have to be undertaken during or prior to rewriting.\\
And functions can legally be applied outside their domains.
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{12}

\begin{center}
{\bf Problems in Unfolding}
\end{center}

\vfill
\begin{itemize}
\item
Consistency Proofs
\item
`set' inference
\item
Conditional Rewriting
\item
Specification Structuring
\end{itemize}

\vfill

\end{slide}

% =====================================================================

\begin{slide}{13}

\begin{center}
{\bf The Z Language - Preliminaries}
\end{center}

\vfill

The following additional schemas are defined to provide examples for the schema-calculus.

\vfill

{\tiny
=SML
open_theory"usr023";
set_pc "z_language";
=TEX
\vfill
ˇFile2¸¸¸¸¸¸¸
‹ people :  NAME;
‹ height : NAME ﬂ ˙
˜¸¸¸¸¸¸¸¸
‹ dom height = people
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFile3¸¸¸¸¸¸¸
‹ people :  NAME
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFileOp¸¸¸¸¸¸¸
‹ File;File'; i?:Ó
à¸¸¸¸¸¸¸¸¸¸
\vfill
}%\tiny

\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Z ``Terms''}
\end{center}
\vfill
{\small
\begin{itemize}
\item
{\bf Z Term Quotations}

Predicates, expressions, and schema expressions may be entered in Z using the Z quotation character ``
=INLINEFT
Ò
=TEX
'', e.g.:
=INLINEFT
 Ò{x:˙ | x>0 ∑ x*x}Æ
=TEX
.
\item
{\bf Extended Z}

ProofPower accepts an extended Z language for convenience in formal proof, provided that the system control flag $standard\_z\_terms$ is set to $false$.

\item
{\bf Standard Z}

Eventually we intend ProofPower to be prepared to check fully against the forthcoming Z standard.

{\tiny
The norm would then be to check specifications against the standard, but permit the extended language for use in proofs.
}%\tiny

\end{itemize}

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower}

\end{center}

\vfill

{\ftlmargin=0.8in 

\begin{itemize}
\item
HOL terms are used to represent Z.

\item
The ``concrete datatype'' {\bf Z\_TERM} reveals\\
the structure of terms representing values in Z.

\item
The function:
=SML
dest_z_term : TERM -> Z_TERM;
=TEX
may be used to disassemble a TERM which represents Z, and
=SML
mk_z_term : Z_TERM -> TERM;
=TEX
may be used to construct a TERM representing a Z construct.
\end{itemize}

}%\ftlmargin

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
declarations}

\end{center}

\vfill
{\tiny
=GFT
datatype	€Z_TERM› =

   €ZLVar›	(* local variable Ò xÆ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 | €ZGVar› 	(* global variable Ò U[DATE]Æ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 		
 | €ZInt› 	(* positive integer literal Ò 34Æ *)
 		of string
 | €ZString›	(* string literal Ò "characters"Æ *)
 		of string
 		
 | €ZDec›		(* declaration, e.g.
   			ëdec_of Ò[x,y:˙]ÆÆ *)
  		of TERM list	(* variables *)
  		* TERM		(* expression *)
 | €ZSchemaDec› 	(* schema reference, e.g.
 			ëdec_of Ò[File!]ÆÆ *)
		of TERM	(*schema expression*)
		* string		(* decoration *)
 | €ZDecl› 	(* declaration list, e.g.
 			ëdecl_of Ò[x,y:˙; File!]ÆÆ *)
		of TERM list	(* declarations *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}
{\bf Local Variables}
\end{center}
\vfill

Used in variable binding constructs (e.g. quantifiers)

Free variables used in proofs of universal assertions, or in using existential assumptions (by `skolemisation').

ProofPower allows `generic' local variables.

\vfill
\begin{center}
{\bf Global Variables (i.e. constants)}
\end{center}
\vfill

These are introduced and constrained by various paragraphs.

Subsequent reasoning relies upon utilisation of predicates explicit or implicit in defining paragraph (see later).

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}
{\bf Integer Literals}
\end{center}

\vfill

Evaluation of arithmetic expressions involving Integer Literals is built into appropriate proof contexts.

\vfill


=SML
rewrite_conv [] Ò543*20Æ;
=GFT ProofPower output
val it = Ù 543 * 20 = 10860 : THM   
=TEX

\vfill

\begin{center}
{\bf String Literals}
\end{center}

\vfill

These are supported by the conversion $z_string_conv$ which converts a string literal into a sequence of HOL character literals:

\vfill

=SML
z_string_conv Ò"string"Æ;
=TEX
=GFT ProofPower output
val it = Ù "string" = 
ß¨`s`Æ, ¨`t`Æ, ¨`r`Æ, ¨`i`Æ, ¨`n`Æ, ¨`g`Æ¢ : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}
{\bf Declarations}
\end{center}

\vfill

Conversion $z_dec_pred_conv$ converts a declaration into its implicit predicate:

\vfill

=SML
val pred2 = z_dec_pred_conv
	(dec_ofÒ[x, y : ˙]Æ);
=GFT ProofPower output
val pred2 = Ù ëdec_ofÒ[x, y : ˙]ÆÆ
	§ {x, y} Ä ˙ : THM   
=TEX

\vfill

\begin{center}
{\bf Declaration Lists}
\end{center}

\vfill

Conversion $z_decl_pred_conv$ converts a declaration list into its implicit predicate:

\vfill

=SML
val pred4 = z_decl_pred_conv
	(decl_ofÒ[x, y : ˙; File!]Æ);
=GFT ProofPower output
val pred4 = Ù ëdecl_ofÒ[x, y : ˙; File!]ÆÆ
  § {x, y} Ä ˙ ± (File!) : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
propositional connectives}

\end{center}
\vfill
{\tiny
=GFT
 | €ZTrue›	(* Ò trueÆ *)
 
 | €ZFalse›	(* Ò falseÆ *)
 
 | €Z≥›	(* negation, e.g. Ò ≥ pÆ *)
 	of TERM	(* predicate *)
 			
 | €Z±›	(* conjunction, e.g. Ò p ± qÆ *)
 	of TERM * TERM	(* predicates *)
 			
 | €Z≤›	(* disjunction, e.g. Ò p ≤ qÆ *)
 	of TERM * TERM	(* predicates *)
 			
 | €Z¥›	(* implication, e.g. Ò p ¥ qÆ *)
 	of TERM * TERM 	(* predicates *)
 			
 | €Z§›	(* bi-implication, e.g. Ò p § qÆ *)
 	of TERM * TERM 	(* predicates *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
quantifiers and relations}

\end{center}
\vfill
{\tiny
=GFT
 | €Z∂›	(* existential quantification, Ò ∂ File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)
 		
 			
 | €Z∂â1›	(* unique existential quantification, Ò ∂â1 File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)

 		
 | €Zµ›	(* universal quantification, Ò µ File | p ∑ qÆ *)
		of TERM		(* declaration *)
		* TERM * TERM	(* predicates *)
		

 | €ZEq›	(* equation, e.g. Ò a = bÆ *)
 		of TERM * TERM	(* expressions *)
 		
 			
 | €Zç›	(* membership, e.g. Ò a ç bÆ *)
		of TERM * TERM	(* expressions *)


 | €ZSchemaPred›	(* schema predicate, e.g.
 			Ò ê (File ')Æ *)
 		of TERM		(* schema expression *)
 		* string		(* decoration *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{63}
\begin{center}
\bf Propositional Reasoning
\end{center}
\vfill
\begin{itemize}
\item assume rule:
=SML
open_theory"usr023";
val thm1 = asm_rule Ò µx, y:Ó∑ x*y > 0Æ;
=GFT ProofPower Output
val thm1 = µ x, y : Ó ∑ x * y > 0
	Ù µ x, y : Ó ∑ x * y > 0 : THM   
=TEX
\item modus ponens
=SML
val thm_a = asm_rule ¨Ò aÆ:BOOLÆ;
val thm_b = asm_rule Ò a¥bÆ;
=GFT ProofPower Output
val thm_a = a Ù a : THM
val thm_b = a ¥ b Ù a ¥ b : THM   
=SML
val thm_c = ¥_elim thm_b thm_a;
=GFT ProofPower Output
val thm_c = a ¥ b, a Ù b : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{64}
\begin{center}
\bf Reasoning with Quantifiers (I)
specialisation
\end{center}
\vfill
\begin{itemize}
\item binding display
=SML
z_µ_elim Ò (x¶455, y¶32)Æ thm1;
=GFT ProofPower Output
val it = µ x, y : Ó ∑ x * y > 0
 Ù {455, 32} Ä Ó ± true ¥ 455 * 32 > 0 : THM
=TEX
\item binding expression
=SML
z_µ_elim Ò exp∫[x,y:Ó]Æ thm1;
=GFT ProofPower Output
val it = µ x, y : Ó ∑ x * y > 0
  Ù {exp.x, exp.y} Ä Ó ± true
  ¥ exp.x * exp.y > 0 : THM
=TEX
\item value expression
=SML
z_µ_elim Ò 45Æ z_Ó_≥_plus1_thm;
=GFT ProofPower Output
val it = Ù 45 ç Ó ± true
	¥ ≥ 45 + 1 = 0 : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{66}
\begin{center}
\bf Tactics for Quantifiers
\end{center}
\vfill
\begin{itemize}
\item
$z_strip_tac$:
{\small
\begin{itemize}
\item
eliminates outer universals in conclusions
\item
skolemises existential assumptions
\item
pushes in outer negations over universal conclusions
\item
pushes in outer negations over existential assumptions
\end{itemize}
}%\small
\item
$z_spec_nth_as_tac$ specialises universal assumptions
\item
$z_∂_tac$ eliminates existential conclusions
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{66}
\begin{center}
\bf Exercises (7.2.3)
Forward Predicate Calculus
\end{center}
\vfill
{\small
=GFT
1. Using z_µ_elim with z_Ó_≥_plus1_thm prove:

	(a)	0 ç Ó ± true ¥ ≥ 0 + 1 = 0
	(b)	x * x ç Ó ± true ¥ ≥ x * x + 1 = 0  
 
2. Using prove_rule with z_º_trans_thm prove:
		i º j ± j º k ¥ i º k : THM

3. Using prove_rule and with z_Ó_≥_plus1_thm
	and z_0_Ó_thm prove:
	(a)	≥ 0 + 1 = 0   
	(b)	x * x ç Ó ¥ ≥ x * x + 1 = 0 
 
4. Using prove_rule prove:
	(a) (with z_≥_less_thm)
		≥ 0 < 1 § 1 º 0
	(b) (with z_º_trans_thm)
		µ n:˙ ∑ 3 º x * x ± x * x º n ¥ 3 º n
	  
5. Using prove_rule prove with z_º_clauses:

		µ i, m, n: ˙ ∑ i + m º i + n § m º n
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{67}
\begin{center}
\bf Solutions (8.2.3)
\end{center}
\vfill
=SML
(* 1(a) *)
val ext1a_thm1 = asm_rule Ò a¥bÆ;
val ext1a_thm2 = asm_rule Ò b¥cÆ;
val ext1a_thm3 = asm_rule Ò a∫{true,false}Æ;
val ext1a_thm4 = ¥_elim ext1a_thm1 ext1a_thm3;
val ext1a_thm5 = ¥_elim ext1a_thm2 ext1a_thm4;
(* 1(b) *)
val ext1b_thm1 =
 ¥_elim (asm_rule Ò a¥b¥cÆ)(asm_rule Ò a∫{true,false}Æ);
val ext1b_thm2 =
 ¥_elim ext1b_thm1(asm_rule Ò b∫{true,false}Æ);
(* 1(c) *)
val ext1c_thm1 = ¥_intro Ò a∫{true,false}Æ ext1b_thm2;
=SML
(* 2(a) *)
val ext2a_thm1 = z_µ_elim Ò 0Æ z_Ó_≥_plus1_thm;
(* 2(b) *)
val ext2b_thm1 = z_µ_elim Ò x*xÆ z_Ó_≥_plus1_thm;
=SML
(* 3 *)
val ext3_thm = prove_rule [z_º_trans_thm]
	Ò i º j ± j º k ¥ i º kÆ ;
=SML
(* 4(a) *)
val ext4a_thm1 = prove_rule [z_Ó_≥_plus1_thm]
	Ò 0 ç Ó ¥ ≥ 0 + 1 = 0Æ;
val ext4a_thm2 = ¥_elim ext4a_thm1 z_0_Ó_thm;
(* 5(a) *)
val ext5_thm = prove_rule[z_º_trans_thm]
	Ò i º j ± j º k ¥ i º kÆ;
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{68}
\begin{center}
{\bf Goal Oriented Proof}
\vfill

Works exactly the same as for HOL.

Make sure you are in a Z theory.

Make sure you have a Z proof context.

Terms should be entered using Z quotes
=INLINEFT
Ò Æ
=TEX
.
\vfill

{\bf Rewriting}
\vfill

Use same facilities as for HOL in appropriate proof contexts.
\vfill
{\bf Stripping}
\vfill

Use same facilities as for HOL in appropriate proof contexts.
\end{center}

\vfill

\end{slide}

% =====================================================================

\begin{slide}{71}
\begin{center}
\bf Exercises (7.2.5)
Rewriting with the Subgoal Package
\end{center}
\vfill
{\small
\begin{enumerate}
\item
set a goal from the examples on set theory, e.g.:
=SML
set_pc "z_sets_ext";
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
=TEX
\item
rewrite the goal using the current proof context:
=SML
a (rewrite_tac[]);
=TEX
\item
step back using undo:
=SML
undo 1;
=TEX
\item
now try rewriting without using the proof context:
=GFT
a (pure_rewrite_tac[]);
=TEX
(this should fail)
\end{enumerate}
}%\small
\vfill

\end{slide}

% =====================================================================

\begin{slide}{72}
\begin{center}
\bf Exercises (7.2.5) continued
\end{center}
\vfill
{\small
\begin{enumerate}
\setcounter{enumi}{4}
\item
try rewriting one layer at a time:
=SML
a (once_rewrite_tac[]);
=TEX
repeat until it fails.
\item
now try rewriting with specific theorems:
=SML
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
a (pure_rewrite_tac[z_sets_ext_clauses]);
a (pure_rewrite_tac[z_set_dif_thm]);
a (pure_rewrite_tac[z_é_thm]);
a (pure_rewrite_tac[z_°_thm, z_¿_thm]);
a (pure_rewrite_tac[z_set_dif_thm]);
=TEX
\item
finish the proof by stripping:
=SML
a (REPEAT z_strip_tac);
=TEX
\item
extract the theorem
=SML
top_thm();
=TEX
\item repeat the above then try repeating:
=SML
pop_thm();
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{73}
\begin{center}
\bf Exercises 6:
combining forward and backward proof
\end{center}
\vfill
{\small
Prove the following results by rewriting using the goal package:
{\tiny for each example try the previous methods to see how they fail before following the hint
}%\tiny
\begin{enumerate}
\item :
=SML
set_pc "z_library";
set_goal([],Ò x + y = y + xÆ);
=TEX
\item :
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
(* hint : try using z_plus_assoc_thm *)
=TEX
\item :
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
(* hint : try using z_plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
(* hint : try using z_µ_elim with plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
(* hint : try using µ_elim with plus_order_thm *)
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{74}
\begin{center}
\bf Exercises 6: Solutions
\end{center}
\vfill
\begin{enumerate}
\item :
=SML
set_pc "z_library";
set_goal([],Ò x + y = y + xÆ);
a (rewrite_tac[]);
=TEX
\item :
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
a (rewrite_tac[z_plus_assoc_thm]);
=TEX
\item :
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
a (rewrite_tac[z_plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
a (rewrite_tac[z_µ_elim Ò(i¶y,j¶z,k¶x)Æ
	z_plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
a (rewrite_tac[z_µ_elim Ò xÆ z_plus_order_thm]);
=TEX
\end{enumerate}
\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{78}
\begin{center}
\bf Exercises 7: Stripping
\end{center}
\vfill
{\small
\begin{itemize}
\item
Use the examples from Principia Mathematica \& ZRM given earlier, e.g.:
=SML
	set_goal([],Ò p ± q ¥ (p § q)Æ);
=TEX
with
\begin{enumerate}
\item :
=SML
	a z_strip_tac;
=TEX
\item and/or:
=SML
	a step_strip_tac;
=TEX
\end{enumerate}
\item
Observe the steps taken and try to identify the reasons for discharge of subgoals.
\item
Select the weakest ``proof context'':
=SML
	push_pc "initial";
=TEX
then retry the examples (or previous exercises).
\item
When you have finished restore the original proof context by:
=SML
	pop_pc();
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
expressions}

\end{center}

\vfill

{\tiny
=GFT
 | €ZApp›	(* function application  Ò f xÆ  *)
 		of TERM * TERM	(* expressions *)
 | €ZÃ›	(* lambda expression Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
 		* TERM	(* expression *)
 | €ZÕ›	(* definite description Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
		* TERM	(* expression *)
 | €Z›	(* power set construction, Ò  ˙Æ *)
 	of TERM		(* expression *)
 | €ZSetd›	(* set display, Ò {1,2,3,4} Æ *)
 	of TYPE		(* HOL type of elements *)
 	* TERM list	(* expressions *)
 | €ZSeta›	(* set abstraction, Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
 	of TERM	(* declaration *)
 	* TERM	(* predicate *)
 	* TERM	(* expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
expressions (continued)}

\end{center}

\vfill

{\tiny
=GFT
 | €ZTuple›	(* tuple, Ò (1,2,3,4) Æ *)
 	of TERM list	(* expressions *)
 | €ZSelât›	(* tuple element selection, Ò (x,y).2Æ *)
 	of TERM	(* expression *)
 	* int		(* element number *)
 | €Z∏›	(* cartesian product, Ò (˙ ∏ Ó) Æ *)
 	of TERM list	(* expressions *)
 | €ZBinding› (* binding Ò (people ¶ {}, age ¶ {}) Æ *)
 	of (	string	(* component name *)
 		* TERM	(* component value *)
 		) list
 | €Z ›	(* theta term Ò  File' Æ *)
 	of TERM	(* schema expression *)
 	* string	(* decoration *)
 | €ZSelâs›	(* binding component selection Ò (a ¶ 1, b ¶ "4").b Æ *)
 	of TERM	(* expression *)
 	* string	(* component name *)
 | €Zâs›	(* horizontal schema expression
 		Ò [x:˙ | x>0] Æ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
 | €Zß¢›	(* sequence display Ò ß1,2,3¢ Æ *)
 	of TYPE	(* type of elements *)
 	* TERM list	(* values of elements *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (I)}

\end{center}

\vfill

{\tiny
=GFT
 | €Z≥âs›	(* schema negation Ò(≥ File)∫UÆ *)
		of TERM (* schema expression *)
 | €Z±âs›	(* schema conjunction Ò(File ± File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z≤âs›	(* schema disjunction Ò(File ≤ File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z¥âs›	(* schema implication Ò(File ¥ File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z§âs›	(* schema equivalence Ò(File § File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z∂âs›	(* schema existential
 		Ò(∂ File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
 | €Z∂â1âs›	(* schema unique existential
 		Ò(∂â1 File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
 | €Zµâs›	(* schema universal
 		Ò(µ File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (II)}

\end{center}

\vfill

{\tiny
=GFT
 | €ZDecorâs› (* decoration Ò File ''Æ *)
 		of TERM	(* schema expression *)
 		* string	(* decoration *)
 | €ZPreâs›	(* pre-condition Ò pre FileOpÆ *)
 		of TERM	(* schema expression *)
 | €ZHideâs›	(* schema hiding Ò FileOp \âs (age, i?)Æ  *)
 		of TERM	(* schema expression *)
 		* string list	(* component names *)
 | €ZRenameâs› (* schema renaming
 			ÒFile [aged/age, input/i?]Æ *)
 		of TERM	(* schema expression *)
 		* (string * string) list	(* rename list *)
 | €Z˘âs›	(* schema projection ÒFileOp ˘âs FileÆ*)
 		of TERM * TERM	(* schema expressions *)
 | Zªâs	(* schema composition ÒÑFile ªâs ÑFileÆ *)
 		of TERM * TERM	(* schema expressions *)
 | €ZÑâs›	(* delta operation ÒÑFileÆ *)
 		of TERM	(* schema expression *)
 | €Zòâs›	(* ò operation ÒòFileÆ *)
 		of TERM	(* schema expression *)
;
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================
{\small
% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Function Application}

\end{center}

\vfill

Applications of lambda abstractions can be eliminated by (conditional) ¬-conversion.

=SML
z_¬_conv Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower outputval
val it = P a, a ç X Ù
	(Ã x : X | P x ∑ f x) a = f a : THM   
=TEX
\vfill

Other applications may be eliminated in favour of definite descriptions.

=SML
z_app_conv Ò f aÆ;
=GFT ProofPower output
val it = Ù f a = Õ f_a : U
	| (a, f_a) ç f ∑ f_a : THM   
=TEX

More commonly function applications will be eliminated by rewriting with their definitions.

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}

\begin{center}

{\bf Schema Predicates}

\end{center}

\vfill

These may be eliminated in favour of membership statements by rewriting with $z'schema\_pred\_def$:

\vfill
=SML
pure_rewrite_conv[z'schema_pred_def]Ò ([x:X])' ± trueÆ;
=TEX
=GFT ProofPower outputval
val it = Ù [x : X] ± true §
	(x ¶ x) ç [x : X] ± true : THM   
=TEX
\vfill
=SML
rewrite_conv[z'schema_pred_def]Ò ([x:X])' ± trueÆ;
=TEX
=GFT ProofPower outputval
val it = Ù (([x : X])') ± true § x' ç X : THM   
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}

\begin{center}

{\bf Lambda Abstraction}

\end{center}

\vfill

For extensional reasoning:

=SML
rewrite_conv [] Òz ç (Ã x:X | P x ∑ f x)Æ;
=TEX
=GFT ProofPower outputval
val it = Ù z ç Ã x : X | P x ∑ f x §
	z.1 ç X ± P z.1 ± f z.1 = z.2 : THM   
=TEX

Lambda abstractions may be transformed into set abstractions.

=SML
z_Ã_conv Ò Ã x:X | P x ∑ f xÆ;
=GFT ProofPower outputval
val it = Ù Ã x : X | P x ∑ f x =
	{x : X | P x ∑ (x, f x)} : THM   
=TEX

\vfill

\begin{center}

{\bf Definite Description}

\end{center}

\vfill
=SML
z_Õ_rule Ò Õ x:X | P ∑ yÆ;
=GFT ProofPower output
val it = Ù µ x' : U
    ∑ (µ x : X | P ∑ y = x')
    ± (∂ x : X | P ∑ y = x')
      ¥ (Õ x : X | P ∑ y) = x' : THM
=TEX
\vfill

\ignore{

=SML
z_app_Ã_rule Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower output
val it = Ù µ x' : U
    ∑ (µ f_a : U |
		∂ x : X | P x ∑ x = a
		± f x = f_a ∑ f_a = x')
    ± (∂ x : X | P x ∑ x = a ± f x = x')
    ¥ (Ã x : X | P x ∑ f x) a = x' : THM
=TEX

}%\ignore

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Power Set Constructor}

\end{center}

\vfill

=SML	
z_ç__conv Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y §
	(µ x1 : U ∑ x1 ç z ¥ x1 ç y) : THM   
=TEX

=GFT Sadly Not in Language-Only Reasoning
rewrite_conv[] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § z Ä y : THM   
=TEX
\ignore{	
pc_rule1 "z_sets_ext"
rewrite_conv[] Ò z ç  yÆ;
}%\ignore

\vfill

=GFT Sadly Not in Language-Only Reasoning
rewrite_conv[z_Ä_thm] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y
	§ (µ x : U ∑ x ç z ¥ x ç y) : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Set Displays}

\end{center}

\vfill

\ignore{	
=SML
open_theory"usr023";

set_merge_pcs ["z_sets_alg", "'z_bindings",
	"'z_ç_rel", "'z_tuples", "'z_ç_fun"];
set_pc"z_language";
=TEX
}%\ignore

{\small
\begin{itemize}
\item
sets may be entered as terms by enumeration:
=SML
rewrite_conv [] Ò 5 ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù 5 ç {1, 2, 3, 4, 5} § true : THM
=TEX
=SML
rewrite_conv [] Ò 6 ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù 6 ç {1, 2, 3, 4, 5}
 § 6 = 1 ≤ 6 = 2 ≤ 6 = 3 ≤ 6 = 4 ≤ 6 = 5 : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Set Abstractions}

\end{center}

\vfill
{\small
\begin{itemize}
\item
sets may also be entered as set abstractions:
=SML
rewrite_conv[] Ò 9 ç {x:Ó | x < 12}Æ;
=GFT ProofPower output
val it =
Ù 9 ç {x : Ó | x < 12} § 9 ç Ó ± 9 < 12 : THM   
=SML
pc_rule1 "z_sets_alg"
rewrite_conv[]Ò z ç {x, y:Ó | x < y}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y}
	§ (z.1 ç Ó ± z.2 ç Ó) ± z.1 < z.2 : THM   
=TEX
=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y ∑ x * y - x}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y ∑ x * y - x}
    § (∂ x, y : Ó | x < y ∑ x * y - x = z) : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

{\small
\begin{slide}{33}
\begin{center}

{\bf Tuples}

\end{center}

\vfill

=SML
rewrite_conv[] Ò (x,y) = (a,b)Æ;
=GFT ProofPower output
val it = Ù (x, y) = (a, b)
	§ x = a ± y = b : THM   
=TEX

\vfill

=SML
rewrite_conv[] Ò (x,y).1Æ;
=GFT ProofPower output
val it = Ù (x, y).1 = x : THM   
=TEX

\vfill

\begin{center}

{\bf Bindings}

\end{center}

\vfill

=SML
rewrite_conv[]
	Ò (x ¶ a, y ¶ b) = (y ¶ d, x ¶ c)Æ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) = (x ¶ c, y ¶ d)
	§ a = c ± b = d : THM   
=TEX

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Cartesian Products}

\end{center}

\vfill
=SML
rewrite_conv[] Ò (a, b) ç (x ∏ y)Æ;
=GFT ProofPower output
val it = Ù (a, b) ç x ∏ y
	§ a ç x ± b ç y : THM   
=TEX

=SML
rewrite_conv[z_sets_ext_thm]
	Ò (x ∏ y) = (a ∏ b)Æ;
=GFT ProofPower output
it = Ù x ∏ y = a ∏ b
	§	(µ z : U ∑ z.1 ç x ± z.2 ç y
    		§ z.1 ç a ± z.2 ç b) : THM
=TEX
\vfill

\begin{center}

{\bf Theta Terms}

\end{center}
\vfill

=SML
z_ _conv Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' =
  (age ¶ age', people ¶ people') : THM   
=SML
rewrite_conv[z' _def] Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' =
  (age ¶ age', people ¶ people') : THM   
=TEX
\vfill

\end{slide}


% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Negation}
\end{center}

\vfill
Return to theory where we defined schema $File$:

=SML
open_theory "usr023";
set_pc "z_language";
=TEX
=SML
rewrite_conv[]Òz ç (≥ File)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (≥ File) § ≥ z ç File : THM   
=TEX

\vfill

\begin{center}
{\bf Schema Conjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ± File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ± File2) §
 (age ¶ z.age, people ¶ z.people) ç File ±
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Disjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ≤ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ≤ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ≤
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Implication}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ¥ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ¥ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ¥
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill


\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Equivalence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File § File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File § File2) §
 (age ¶ z.age, people ¶ z.people) ç File §
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Existential}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂ File3 | people = {} ∑ File2) §
 (∂ x1 : U ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Unique Existence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂â1 File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂â1 File3 | people = {} ∑ File2) §
 (∂â1 x1 : U ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\begin{center}
{\bf Schema Universal}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (µ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (µ File3 | people = {} ∑ File2) §
 (µ x1 : U
 ∑ (people ¶ x1.people) ç File3 ± x1.people = {}
   ¥ (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schemas}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç [x:˙;y:Ó]Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç [x : ˙; y : Ó]
	§ z.x ç ˙ ± z.y ç Ó : THM   
=TEX

\vfill

\begin{center}
{\bf Decoration}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç File ''Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File'')	§
 (age ¶ z.age'', people ¶ z.people'') ç File : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Pre-Condition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (pre FileOp)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (pre FileOp) §
 z ç	[age : U; i? : U; people : U
	| ∂ age' : U; people' : U ∑ FileOp] : THM
=TEX

\vfill

\begin{center}
{\bf Schema Hiding}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age)) §
	z ç [people : U | ∂ age : U ∑ File] : THM
=TEX

\vfill
=SML
rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age))
    § (∂ age : U ∑
    	(age ¶ age, people ¶ z.people) ç File) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Renaming}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç File[aged/age]Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File [aged/age]) §
	(age ¶ z.aged, people ¶ z.people) ç File : THM
=TEX

\vfill

\begin{center}
{\bf Schema Projection}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ˘âs File)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ˘âs File)
    § z ç ((FileOp ± File) \âs (age', i?, people')) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Composition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § z
      ç [age : U; i? : U; people : U; age' : U; people' : U
        | ∂ x1 : U; x2 : U
          ∑ (age ¶ age, age' ¶ x1, i? ¶ i?,
          		people ¶ people, people' ¶ x2)
              ç FileOp
            ± (age ¶ x1, age' ¶ age', i? ¶ i?, people ¶ x2,
                  people' ¶ people')
              ç FileOp] : THM
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Delta}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (ÑFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (Ñ File) §
	z ç [File; File'] : THM   
=TEX

\vfill
\begin{center}
{\bf Delta}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (òFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (ò File) §
	z ç [File; File' |  File =  File'] : THM   
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================

\ignore{
(* spiveys defn :
ˇS¸¸¸¸¸¸¸
‹ a,b,a':Ó
à¸¸¸¸¸¸¸¸¸¸
ˇT¸¸¸¸¸¸¸
‹ a,b,b':Ó
à¸¸¸¸¸¸¸¸¸¸
ˇState¸¸¸¸¸¸¸
‹ a:Ó
à¸¸¸¸¸¸¸¸¸¸

ÒScompT = (∂ State'' ∑
	(∂ State' ∑ [S |  State' =  State''])±
	(∂ State ∑ [T |  State =  State'']))Æ; (*  *)

}%\ignore

=TEX

% =====================================================================

\begin{slide}{50}
\begin{center}
{\bf Z Paragraphs}
\end{center}
\vfill
\begin{itemize}
\item
Fixity declarations
\item
Given sets
\item
Abbreviation definitions
\item
Schema boxes
\item
Axiomatic descriptions
\item
Generics
\item
Free types
\item
Constraints
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Z Paragraphs\\
Paragraph Processing Modes and Flags}
\end{center}
\vfill
{\small
There are several different modes of processing Z paragraphs which are controlled by flags.

\begin{itemize}
\item
{\bf Type-checking Mode}

If the flag $z\_type\_check\_only$ is set to $true$ then only type checking of Z paragrpahs is performed.

{\tiny
This makes the response faster, and permits greater flexibility in amending paragraphs.
This mode is suitable for use while developing specifications prior to undertaking any proof work.
}

\item
{\bf Axiomatic Mode}
 
If the flag $z\_use\_axioms$ is set to true (and\\
$z\_type\_check\_only$ is set to $false$) then axiomatic descriptions and free-type descriptions are introduced using axioms.


\item
{\bf Conservative Mode}

If both the above flags is set $false$ then all Z axiomatic descriptions are introduced using the ProofPower\\
$new\_specification$ facility, i.e. by conservative extension.

{\tiny
Consistency proof obligations, unless discharged automatically, will have to be discharged by the user.

In a future release it is hoped that free-types will also be supported by conservative extension.
}%\tiny

\end{itemize}

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\vfill
{\small
=SML
open_theory "usr023"; 
set_pc "z_sets_alg";
=TEX
\begin{center}
{\bf Fixity Declarations}
\end{center}
\ftlmargin 0.5in
Fixity delcarations may be provided for:
\begin{itemize}
\item
functions
πZ
fun 10 twice _
∞
πZ
fun  slice ... from _ to _ 
∞
\item
generics
πZ
gen _ swap _
∞
\item
relations
πZ
rel  _ is_even 
∞
\end{itemize}

\vfill

The optional numeric value is a priority.

`\_' is a space for a parameter\\
`...' is a space for a sequence of parameters (with sequence brackets elided)

Fixity clauses can only be deleted by deleting the theory they are contained in.

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Given Sets}
\end{center}

\vfill

πZ
[G1, G2]
∞

\vfill

=SML
val G1_def = z_get_spec ÒG1Æ;
=GFT ProofPower output
val G1_def = Ù G1 = U : THM   
=TEX

\vfill

=SML
rewrite_conv [G1_def] Òx ç G1Æ;
=GFT ProofPower output
val it = Ù x ç G1 § true : THM   
=TEX

\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Abbreviation Definitions}
\end{center}

{\small
\vfill
=SML
val _ = set_flag("z_type_check_only", false);
=TEX

πZ
X swap Y ¶ Y ∏ X 
∞

\vfill

=SML
val swap_def = z_get_spec Ò(_swap_)Æ;
=GFT ProofPower Output
val swap_def =
Ù [X, Y](X swap Y = Y ∏ X) : THM   
=TEX

\vfill

=SML
rewrite_conv [swap_def] Ò˙ swap ÓÆ;
=TEX
=GFT ProofPower Output
val it = Ù ˙ swap Ó = Ó ∏ ˙ : THM   
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Schema Boxes}
\end{center}
\vfill
{\small
ˇSch¸¸¸¸¸¸¸¸¸¸¸¸
‹	x, y : ˙;
‹	z : Ó
˜¸¸¸¸¸¸¸¸¸
‹	x = y ≤ y = z
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
val sch_def = z_get_spec ÒSchÆ;
=GFT ProofPower Output
val sch_def = Ù Sch =
  [x, y : ˙; z : Ó | x = y ≤ y = z] : THM   
=TEX
=SML
rewrite_conv [sch_def (*, z'schema_pred_def*)]
 Òµ x,y:˙; z:Ó ∑ Sch ≤ disjoint ß{x},{y},{z}¢Æ;
=TEX
=GFT ProofPower Output
val it = Ù (µ x, y : ˙; z : Ó ∑ Sch
		≤ disjoint ß{x}, {y}, {z}¢)
    § (µ x, y : ˙; z : Ó
      ∑ [x, y : ˙; z : Ó | x = y ≤ y = z]
      	≤ disjoint ß{x}, {y}, {z}¢) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Generic Schema Boxes}
\end{center}
\vfill
{\small
ˇDSUBS[X]¸¸¸¸¸¸¸¸¸¸¸
‹	set1, set2:  X
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	set1 ° set2 = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
=SML
val dsubs_def = z_get_spec ÒDSUBSÆ;
=GFT ProofPower Output
val dsubs_def = Ù [X](DSUBS[X] =
  [set1, set2 :  X | set1 ° set2 = {}]) : THM
=TEX
\vfill
=SML
rewrite_conv [dsubs_def (*, z'schema_pred_def*)]
 Òµ DSUBS[Ó] ∑ set1 Ä Ó ± set2 Ä ÓÆ;
=GFT ProofPower Output
val it = Ù (µ (DSUBS[Ó]) ∑ set1 Ä Ó ± set2 Ä Ó)
	§ (µ [set1, set2 :  Ó | set1 ° set2 = {}] ∑
		set1 Ä Ó ± set2 Ä Ó) : THM
=TEX
\vfill
\ignore{
set_goal([],Òµ DSUBS[Ó] ∑ set1 Ä Ó ± set2 Ä ÓÆ);
a (z_strip_tac THEN rewrite_tac [dsubs_def,z'schema_pred_def]);
a (conv_tac (MAP_C z_ç_h_schema_conv1));
 THEN REPEAT strip_tac);
=TEX
=GFT ProofPower Output
val it = Ù (µ (DSUBS[Ó]) ∑ set1 Ä Ó ± set2 Ä Ó)
    § (µ [set1, set2 :  Ó | set1 ° set2 = {}] ∑
    		set1 Ä Ó ± set2 Ä Ó) : THM
=TEX
}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Axiomatic Descriptions}
\end{center}
\vfill
{\small
πZAX
‹	twice _ : ˙ ≠ ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	µi : ˙ ∑ twice i = 2*i
∞
\vfill
=SML
val twice_def = z_get_spec Ò(twice_)Æ;
=GFT ProofPower Output
val twice_def = Ù (twice _) ç ˙ ≠ ˙
	± (µ i : ˙ ∑ twice i = 2 * i) : THM   
=TEX
\vfill
\ignore{
=SML
set_flag("use_file_non_stop_mode",true);
=TEX
}
=SML
rewrite_conv[twice_def] Òtwice 4Æ;
=GFT ProofPower Output
Exception- Fail * no rewriting occurred
=TEX
\ignore{
=SML
set_flag("use_file_non_stop_mode",false);
=TEX
}
\vfill
=SML
set_goal([],Òµ n:˙ ∑ twice n = 2*nÆ);
a (REPEAT z_strip_tac);
=GFT ProofPower Output
(* *** Goal "" *** *)
(*  1 *)  Òn ç ˙Æ
(* ?Ù *)  Òtwice n = 2 * nÆ
=TEX
\vfill
=SML
a (fc_tac [twice_def]);
=GFT ProofPower Output
Current and main goal achieved
=TEX
\ignore{
πZAX
‹	_ is_even : ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	( _ is_even) = ran (twice _)
∞

πZAX
‹	fact : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	fact 0 = 1;
‹	µn:Ó∑	fact (n+1) = fact n * (n+1)
∞
}%\ignore
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Generic Axiomatics}
\end{center}
\vfill
{\small
ù[X,Y,Z]úúúúúúúúúúúúúúúúúúúúúúúú
‹ select ... from _ : (X ™ Y) ∏ (Y ™ Z) ≠ (Y ™ Z)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ indexed_set:(X ™ Y); relation:(Y ™ Z) ∑
‹ (select ... from _) (indexed_set, relation)
‹ = (ran indexed_set) Ú relation
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\vfill
=SML
val select_from_def = Ù [X, Y, Z](
 (select ... from _)[X, Y, Z]
  ç (X ™ Y) ∏ (Y ™ Z) ≠ Y ™ Z
 ± (µ indexed_set : X ™ Y; relation : Y ™ Z∑
 (select ... from _)[X, Y, Z] (indexed_set, relation)
    = ran indexed_set Ú relation)) : THM
=TEX
\vfill
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Free Types}
\end{center}
\vfill

{\small
πZ
TREE ::= tip | fork (Ó ∏ TREE ∏ TREE)
∞
\vfill

=SML
val tree_def = z_get_spec ÒTREEÆ;
=GFT ProofPower Output
val tree_def = Ù TREE = U : THM   
=TEX

\vfill

=SML
val tip_def = z_get_spec ÒtipÆ;
=GFT ProofPower Output
val tip_def = Ù (tip ç TREE
 ± fork ç Ó ∏ TREE ∏ TREE ‡ TREE)
 ± disjoint ß{tip}, ran fork¢
 ± (µ W :  TREE | {tip} ¿ fork ® Ó ∏ W ∏ W © Ä W∑
	TREE Ä W) : THM
=TEX


}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Mutually Recursive Free Types}
\end{center}
\vfill

{\small

πZ
TYPE ::= Tvar G1 | Tcon (G1 ∏ seq TERM)
&
TERM ::= Con (G1 ∏ TYPE) | App (TERM ∏ TERM)
∞
πZ
 tip Ω fork(2, tip, tip) ±
 tip ç TREE ±
 cycle(1, (1,2), (1, 2, 3))
 	ç (˙ ∏ ˙ ∏ ˙) ∏ ˙ ∏ (˙ ∏ ˙)
∞

\vfill

=SML
val tvar_def = z_get_spec ÒTvarÆ;
=GFT ProofPower Output
val tvar_def = Ù (Tvar ç G1 ‡ TYPE
    ± Tcon ç G1 ∏ (seq TERM) ‡ TYPE
    ± Con ç G1 ∏ TYPE ‡ TERM
    ± App ç TERM ∏ TERM ‡ TERM)
    ± (disjoint ßran Tvar, ran Tcon¢
    ± (µ W :  TYPE
      | Tvar ® G1 © ¿ Tcon ® G1 ∏ (seq TERM) © Ä W
      ∑ TYPE Ä W))
    ± disjoint ßran Con, ran App¢
    ± (µ W :  TERM
      | Con ® G1 ∏ TYPE © ¿ App ® W ∏ W © Ä W
      ∑ TERM Ä W) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Constraints}
\end{center}
\vfill

{\small

πZ
[X] ((∂f : X ‡ G1 ∑ true)
	§ (∂f : X ‡ G2 ∑ true))
∞

\vfill

=SML
val c1 = get_axiom "-" "Constraint 1";
=GFT ProofPower output
val c1 = Ù [X]((∂ f : X ‡ G1 ∑ true) §
		(∂ f : X ‡ G2 ∑ true)) : THM   
=TEX

\vfill

πZ
 {1} swap {ß1¢} = {ß1¢} ∏ {1}
 	± Sch Ω [x, y, z : ˙] 
∞

\vfill

πZ
 tip Ω fork(2, tip, tip) ±
 tip ç TREE ±
 cycle(1, (1,2), (1, 2, 3))
 	ç (˙ ∏ ˙ ∏ ˙) ∏ ˙ ∏ (˙ ∏ ˙)
∞

\vfill

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Theories}
\end{center}
\vfill
Z Theories contain the following information:
\begin{itemize}
\item
The theory name and the names of the theories parents and children.
\item
The names of types (given sets) declared in the theory.
\item
The names and types of `global variables' declared in the theory.
\item
Fixity information.
\item
Axioms or specifications corresponding to the paragraphs of the Z specification introduced in this theory.
\item
A collection of saved theorems.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{59}
\begin{center}
{\bf Exercises 3: Specification}
\end{center}

\vfill

\begin{itemize}
\item
Create a new theory as a child of ``hol''.
=GFT
new_theory "usr023";
=TEX
\item
Write a specification in Z of a function to add the elements of a sequence of numbers.

{\tiny HINT: if your specification goes in as a ``Constspec'' then they system could not prove it consistent, and its probably either wrong or poorly structured.
Try to make it clearly `primitive recursive'.}
\item
Use it to ``evaluate'' the term\\
=INLINEFT
Ò list_sum ß1,2,3,4,5¢Æ
=TEX
.
=GFT
rewrite_conv[get_specÒ list_sumÆ]
	Ò list_sum ß1,2,3,4,5¢Æ;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{79}
\begin{center}
\bf Induction
\end{center}
\vfill
Induction principles for Z can be expressed as mixed language theorems in Higher Order Logic and Z e.g.:
\vfill
{\small
\begin{itemize}
=TEX
\item $z\_Ó\_induction\_thm$
=GFT
Ù µ p
  ∑ p Ò 0Æ
  ± (µ i∑ i ç Ò ÓÆ ± p i ¥ p Ò i + 1Æ)
  ¥ (µ m∑ m ç Ò ÓÆ ¥ p m) : THM
=TEX
\item $z\_˙\_induction\_thm$
=GFT
 Ù µ p
  ∑ p Ò 1Æ
  ± (µ i∑ p i ¥ p Ò ~ iÆ)
  ± (µ i j∑ p i ± p j ¥ p Ò i + jÆ)
  ¥ (µ m∑ p m) : THM
=TEX
\end{itemize}
}%\small
\vfill
$µ\_elim$ and $all\_¬\_rule$ may be used to specialise these for use in forward proofs.
\vfill
\end{slide}

% =====================================================================

\begin{slide}{80}
\begin{center}
\bf Induction Tactics
\end{center}
\vfill
{\small
Special tactics are available to facilitate the use\\
of induction principles:
\begin{itemize}
\item induction over natural numbers using\\
$z\_Ó\_induction\_tac$
=FRULE 2
z_Ó_induction_tac Ò xÆ
˜
{ á } x ç Ó ¥ t 
˜
{ á } t[0/x] ;
strip{t, á} t[x+1/x]
=TEX
\item induction over integers using\\
$z\_˙\_induction\_tac$
=FRULE 2
z_˙_induction_tac Ò xÆ
˜
{ á } t 
˜
{ á } t[1/x];
strip{t[i/x], á} t[~i/x];
strip{t[i/x] ± t[j/x], á} t[i+j/x]
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{81}
\begin{center}
\bf Induction - Example (I)
\end{center}
\vfill
=SML
set_goal ([], Òx ç Ó ¥ x + y æ yÆ);
a (z_Ó_induction_tac);
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò0 º iÆ

(* ?Ù *)  Ò(i + 1) + y æ yÆ


(* *** Goal "1" *** *)

(* ?Ù *)  Ò0 + y æ yÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{81}
\begin{center}
\bf Induction - Example (II)
\end{center}
\vfill
=SML
set_goal ([], Òx + y æ yÆ);
a (z_˙_induction_tac ÒxÆ);
=GFT ProofPower output
(* *** Goal "3" *** *)
(*  2 *)  Ò0 º iÆ
(*  1 *)  Ò0 º jÆ

(* ?Ù *)  Ò(i + j) + y æ yÆ

(* *** Goal "2" *** *)
(*  1 *)  Ò0 º iÆ

(* ?Ù *)  Ò~ i + y æ yÆ

(* *** Goal "1" *** *)
(* ?Ù *)  Ò1 + y æ yÆ
=TEX
\vfill
\end{slide}
