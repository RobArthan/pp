=TEX
% usr023.doc   %Z% $Date$ $Revision$ $RCSfile$
% COPYRIGHT (c) International Computers Limited, 1992

\def\SCCSissue{$Revision$
}

\long\def\ignore#1{}

\ignore{

=SML
open_theory "z_library";
new_theory "usr023";
set_pc "z_library";
=TEX

}%\ignore

\underscoreoff
% =====================================================================

\begin{slide}{}
\setcounter{slide}{1}
\vfill
\begin{center}

\vfill

{\huge Proof in Z}\\
with\\
{\huge \bf ProofPower}\\

\vfill

\end{center}

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{2}
\begin{center}

{\bf Course Objectives}

\end{center}
\vfill

\begin{itemize}
\item
to describe the basic principles and concepts underlying ProofPower support for Z
\item
to enable the student to write simple specifications and undertake elementary proofs in Z using ProofPower
\item
to enable the student to make effective use of the reference documentation for ProofPower-Z
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{3}
\begin{center}

{\bf Course Outline}

\end{center}
\vfill

\begin{itemize}
\item
Introduction to ProofPower-Z

\item
The Z Predicate Calculus

\item
Expressions

\item
Schema Expressions

\item
Paragraphs and Theories

\item
The Z ToolKit

\item
Case Study

\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{4}
\begin{center}
\bf ProofPower Z Tutorial Schedule
\end{center}
\vfill
\vertbarfalse
{\tiny
=GFT
slide	topic			time

WEDNESDAY 24th March

	BUFFET LUNCH		12:30
	
01	introduction		13:30
			exercises	13:55
30	Predicate Calculus		14:15
44			exercises 	14:35

	COFFEE			15:00

45	Rewriting & Chaining		15:15
46			exercises	15:25
50	Expressions		15:50
			exercises	16:10
70	Schema Expressions		16:40
			exercises	17:00
	Close			17:30

THURSDAY 25th March

90	Paragraphs & Theories	09:00
			exercises	09:20
120	The Z ToolKit		09:45
			exercises	10:05

	COFFEE			10:30
	
130	A little refinement		10:45

140	A Security Proof		11:30

	BUFFET LUNCH		12:30
=TEX
}%\tiny
\vertbartrue
\vfill
\end{slide}
% =====================================================================

\begin{slide}{}
\setcounter{slide}{5}
\begin{center}

{\bf Course Prerequisites}

\end{center}
\vfill

We assume a working knowledge of:
{\ftlmargin=0.7in \ftrmargin=0.5in
\begin{itemize}
\item
Z as a specification language
{\small
πZ
[NAME, DATE]
∞

=GFT Z
U[X] ¶ X
=TEX

ˇFile¸¸¸¸¸¸¸
‹ people :  NAME;
‹ age : NAME ﬂ DATE
˜¸¸¸¸¸¸¸¸
‹ dom age = people
à¸¸¸¸¸¸¸¸¸¸
=TEX
}%\small
\item
the use of ProofPower with HOL (under sunview)
\end{itemize}
}%\ftlmargin
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{10}
\begin{center}
{\bf Reasoning in Z with ProofPower}
\end{center}

\vfill

\begin{itemize}
\item
Non-Problems
\item
Proof Automation ``Lifted'' from ProofPower HOL
\item
The Main Problem Area
\item
Futher Proof Automation Needed
\end{itemize}

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{11}
\begin{center}
{\bf Reasoning in Z\\
Non-Problems}
\end{center}

\vfill

\begin{itemize}
\item
Axiomatic v. Conservative
\item
Generics
\item
Schema Calculus
\item
Exotic variable binding constructs.
\item
Invisible Variables (schemas as predicates and declarations)
\end{itemize}

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{12}
\begin{center}
{\bf Reasoning in Z\\
Facilities lifted from HOL}
\end{center}

\vfill
\begin{itemize}
\item
Propositional Reasoning
\item
Predicate Calculus:
\begin{itemize}
\item
stripping
\item
forward chaining (aka $RES\_TAC$)
\item
resolution (via $prove\_tac$)
\end{itemize}
\item
basic rewriting
\item
basic integer arithmetic
\item
arithmetic computations
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{13}
\begin{center}
{\bf Reasoning in Z\\
KEY PROBLEM AREAS}
\end{center}

\vfill
Ease of Unfolding Definitions
\vfill
Complexity of Underlying Types
\vfill
Methods which contain complexity
\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{14}
\begin{center}
{\bf Reasoning in Z\\
Types v Sets}
\end{center}

\vfill
{\small

\begin{itemize}
\item
HOL has:
\vfill

\begin{itemize}
\item a simple decidable type system
\item quantification ranging over types only.
\end{itemize}

Hence unconditional rewriting goes a long way.
\vfill

\item
Z has:
\vfill

\begin{itemize}
\item a simple decidable {\it hidden} type system
\item a set relativised surface syntax
\end{itemize}

Hence most rewrites are really conditional, even if superficially unconditional.
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{15}
\begin{center}
{\bf Problems in Unfolding}
\end{center}

\vfill
\begin{itemize}
\item
Consistency Proofs
\item
`set' inference
\item
Conditional Rewriting
\item
Specification Structuring
\end{itemize}

\vfill

\end{slide}

% =====================================================================


\begin{slide}{}
\setcounter{slide}{20}
\begin{center}
\vfill

{\bf Some Z Proofs are Easy with ProofPower}
\end{center}

\begin{itemize}
\item
propositional tautologies

{\tiny Propositional reasoning in Z is exactly the same as in HOL, fully automatic and well integrated into the normal proof methods.}

\item
first order predicate calculus

{\tiny As in HOL, predicate calculus proofs in Z are either automatic or routine.}

\item
elementary set theory

{\tiny A useful class of results from elementary set theory are automatically provable.}

\item
other classes of results

{\tiny Whenever a new theory is introduced one or more proof contexts may be developed to solve automatically a range of results in that theory.
``Decision procedures'' for such classes of results can be made available via ``prove\_tac''.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================


\begin{slide}{}
\setcounter{slide}{21}
\begin{center}

{\bf Simple Predicate Calculus Proofs}
\end{center}
\vfill
{\small

\begin{itemize}
\item
use the subgoaling package

\item
set the goal

=SML
open_theory"usr023";
set_pc "z_predicates";
set_goal([],Ò (µx, y:X∑ P x ¥ R y)
	§ (µv, w:X∑ ≥ P w ≤ R v)Æ);
=TEX
\item
initiate proof by contradiction
=SML
a contr_tac;
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
...
(*  5 *)  Ò µ x, y : X ∑ P x ¥ R yÆ
(*  4 *)  Ò v ç XÆ
(*  3 *)  Ò w ç XÆ
(*  2 *)  Ò P wÆ
(*  1 *)  Ò ≥ R vÆ

(* ?Ù *)  Ò falseÆ
=TEX
\item
instantiate assumptions as required
=SML
a (z_spec_asm_tac Ò µ x, y : X ∑ P x ¥ R yÆ
	Ò (x ¶ w, y ¶ v)Æ);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

{\small
\begin{slide}{}
\setcounter{slide}{22}
vfill
=GFT ProofPower output
Tactic produced 0 subgoals:
(* *** Goal "2" *** *)

(*  5 *)  Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
(*  4 *)  Ò x ç XÆ
(*  3 *)  Ò y ç XÆ
(*  2 *)  Ò P xÆ
(*  1 *)  Ò ≥ R yÆ

(* ?Ù *)  Ò falseÆ
=SML
a (z_spec_asm_tac Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
	Ò (v ¶ y, w ¶ x)Æ);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=SML
pop_thm();
=GFT ProofPower output
Now 0 goals on the main goal stack
val it = Ù (µ x, y : X ∑ P x ¥ R y) §
	(µ v, w : X ∑ ≥ P w ≤ R v) : THM   
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{29}
\begin{center}
{\bf Exercises - 7.1.4}
\end{center}

\vfill
\begin{itemize}
\item
Turn to section 7.1.4 of the ProofPower Z tutorial (usr011).
\item
Enter ProofPower by typing:
=GFT UNIX shell command
pp -d ztutorial
=TEX
\item
setup as follows (cut and paste):
=GFT SML
open_theory "z_exercises_1";
set_pc "z_library";
=TEX
\item
Chose an example and set the goal using $setlg$:
=GFT SML
setlg "*9.01" PM9;
=TEX
\item
Prove it using the two tactic method.\\
(but use $z_spec_asm_tac$ instead of $list_spec_asm_tac$)

\item
save the result in the theory (save_pop_thm "*9.01")
\end{itemize}

\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{}
\setcounter{slide}{30}
\begin{center}
{\bf The Z Language - Preliminaries}
\end{center}

\vfill

The following additional schemas are defined to provide examples for the schema-calculus.

\vfill

{\tiny
=SML
open_theory"usr023";
set_pc "z_library";
=TEX
\vfill
ˇFile2¸¸¸¸¸¸¸
‹ people :  NAME;
‹ height : NAME ﬂ ˙
˜¸¸¸¸¸¸¸¸
‹ dom height = people
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFile3¸¸¸¸¸¸¸
‹ people :  NAME
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFileOp¸¸¸¸¸¸¸
‹ File;File'; i?:Ó
à¸¸¸¸¸¸¸¸¸¸
\vfill
}%\tiny

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{31}
\begin{center}

{\bf The Z Language in ProofPower}

\end{center}

\vfill

{\ftlmargin=0.8in 

\begin{itemize}
\item
HOL terms are used to represent Z.

\item
The ``concrete datatype'' {\bf Z\_TERM} reveals\\
the structure of terms representing values in Z.

\item
The function:
=SML
dest_z_term : TERM -> Z_TERM;
=TEX
may be used to disassemble a TERM which represents Z, and
=SML
mk_z_term : Z_TERM -> TERM;
=TEX
may be used to construct a TERM representing a Z construct.
\end{itemize}

}%\ftlmargin

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{32}
\begin{center}
{\bf Z Language Quotation}
\end{center}
\vfill
\begin{itemize}
\item
{\bf Z Term Quotations}

{\small
Predicates, expressions, and schema expressions may be entered in Z using the Z quotation character ``
=INLINEFT
Ò
=TEX
'', e.g.:
=INLINEFT
 Ò{x:˙ | x>0 ∑ x*x}Æ
=TEX
.
}%\small

\vfill

\item
{\bf Extended Z}

{\small
ProofPower accepts an extended Z language for convenience in formal proof, provided that the system control flag $standard\_z\_terms$ is set to $false$.
}%\small

\vfill

\item
{\bf Standard Z}

{\small
Eventually we intend ProofPower to be prepared to check fully against the forthcoming Z standard.
}%\small

{\tiny
The norm would then be to check specifications against the standard, but permit the extended language for use in proofs.
}%\tiny

\end{itemize}

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{33}
\begin{center}

{\bf Special Extensions}

\end{center}

\vfill

\begin{itemize}

\item U
=GFT Z
U[X] ¶ X
=TEX
may be used to avoid explicit typing, or to ensure quantification over entire types rather than sets.

\vfill

\item
$∫$, which type checks like $ç$ (and means the same thing).
When used infix $∫$ and its right hand operand are discarded.
It may therefore be used to force the type of an expression without otherwise changing its value.

\vfill

\item
$ê$ which take a single operand and creates a context in which a predicate is required.
ê is discarded after parsing and type-checking.

\end{itemize}

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{34}
\begin{center}

{\bf The Z Language in ProofPower\\
declarations}

\end{center}

\vfill
{\tiny
=GFT
datatype	€Z_TERM› =

   €ZLVar›	(* local variable Ò xÆ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 | €ZGVar› 	(* global variable Ò U[DATE]Æ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 		
 | €ZInt› 	(* positive integer literal Ò 34Æ *)
 		of string
 | €ZString›	(* string literal Ò "characters"Æ *)
 		of string
 		
 | €ZDec›		(* declaration, e.g.
   			ëdec_of Ò[x,y:˙]ÆÆ *)
  		of TERM list	(* variables *)
  		* TERM		(* expression *)
 | €ZSchemaDec› 	(* schema reference, e.g.
 			ëdec_of Ò[File!]ÆÆ *)
		of TERM	(*schema expression*)
		* string		(* decoration *)
 | €ZDecl› 	(* declaration list, e.g.
 			ëdecl_of Ò[x,y:˙; File!]ÆÆ *)
		of TERM list	(* declarations *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{35}
\begin{center}
{\bf Local Variables}
\end{center}
\vfill

Used in variable binding constructs (e.g. quantifiers)

Free variables used in proofs of universal assertions, or in using existential assumptions (by `skolemisation').

ProofPower allows `generic' local variables.

\vfill
\begin{center}
{\bf Global Variables (i.e. constants)}
\end{center}
\vfill

These are introduced and constrained by various paragraphs.

Subsequent reasoning relies upon utilisation of predicates explicit or implicit in defining paragraph (see later).

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{36}
\begin{center}
{\bf Integer Literals}
\end{center}

\vfill

Evaluation of arithmetic expressions involving Integer Literals is built into appropriate proof contexts.

\vfill


=SML
rewrite_conv [] Ò543*20Æ;
=GFT ProofPower output
val it = Ù 543 * 20 = 10860 : THM   
=TEX

\vfill

\begin{center}
{\bf String Literals}
\end{center}

\vfill

These are supported by the conversion $z_string_conv$ which converts a string literal into a sequence of HOL character literals:

\vfill

=SML
z_string_conv Ò"string"Æ;
=TEX
=GFT ProofPower output
val it = Ù "string" = 
ß¨`s`Æ, ¨`t`Æ, ¨`r`Æ, ¨`i`Æ, ¨`n`Æ, ¨`g`Æ¢ : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{37}
\begin{center}
{\bf Declarations}
\end{center}

\vfill

Conversion $z_dec_pred_conv$ converts a declaration into its implicit predicate:

\vfill

=SML
val pred2 = z_dec_pred_conv
	(dec_ofÒ[x, y : ˙]Æ);
=GFT ProofPower output
val pred2 = Ù ëdec_ofÒ[x, y : ˙]ÆÆ
	§ {x, y} Ä ˙ : THM   
=TEX

\vfill

\begin{center}
{\bf Declaration Lists}
\end{center}

\vfill

Conversion $z_decl_pred_conv$ converts a declaration list into its implicit predicate:

\vfill

=SML
val pred4 = z_decl_pred_conv
	(decl_ofÒ[x, y : ˙; File!]Æ);
=GFT ProofPower output
val pred4 = Ù ëdecl_ofÒ[x, y : ˙; File!]ÆÆ
  § {x, y} Ä ˙ ± (File!) : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{38}
\begin{center}

{\bf The Z Language in ProofPower\\
propositional connectives}

\end{center}
\vfill
{\tiny
=GFT
 | €ZTrue›	(* Ò trueÆ *)
 
 | €ZFalse›	(* Ò falseÆ *)
 
 | €Z≥›	(* negation, e.g. Ò ≥ pÆ *)
 	of TERM	(* predicate *)
 			
 | €Z±›	(* conjunction, e.g. Ò p ± qÆ *)
 	of TERM * TERM	(* predicates *)
 			
 | €Z≤›	(* disjunction, e.g. Ò p ≤ qÆ *)
 	of TERM * TERM	(* predicates *)
 			
 | €Z¥›	(* implication, e.g. Ò p ¥ qÆ *)
 	of TERM * TERM 	(* predicates *)
 			
 | €Z§›	(* bi-implication, e.g. Ò p § qÆ *)
 	of TERM * TERM 	(* predicates *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{}
\setcounter{slide}{39}
\begin{center}
\bf Propositional Reasoning
\end{center}
\vfill
\begin{itemize}
\item assume rule:
=SML
open_theory "usr023";
val thm1 = asm_rule Ò µx, y:Ó∑ x*y > 0Æ;
=GFT ProofPower Output
val thm1 = µ x, y : Ó ∑ x * y > 0
	Ù µ x, y : Ó ∑ x * y > 0 : THM   
=TEX
\item modus ponens
=SML
val thm_a = asm_rule Ò a ∫ BOOLÆ;
val thm_b = asm_rule Ò a¥bÆ;
=GFT ProofPower Output
val thm_a = a Ù a : THM
val thm_b = a ¥ b Ù a ¥ b : THM   
=SML
val thm_c = ¥_elim thm_b thm_a;
=GFT ProofPower Output
val thm_c = a ¥ b, a Ù b : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{40}
\begin{center}

{\bf The Z Language in ProofPower\\
quantifiers and relations}

\end{center}
\vfill
{\tiny
=GFT
 | €ZEq›	(* equation, e.g. Ò a = bÆ *)
 		of TERM * TERM	(* expressions *)
 		
 			
 | €Zç›	(* membership, e.g. Ò a ç bÆ *)
		of TERM * TERM	(* expressions *)


 | €ZSchemaPred›	(* schema predicate, e.g.
 			Ò ê (File ')Æ *)
 		of TERM		(* schema expression *)
 		* string		(* decoration *)

 | €Z∂›	(* existential quantification, Ò ∂ File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)
 		
 			
 | €Z∂â1›	(* unique existential quantification, Ò ∂â1 File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)

 		
 | €Zµ›	(* universal quantification, Ò µ File | p ∑ qÆ *)
		of TERM		(* declaration *)
		* TERM * TERM	(* predicates *)
		
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{41}
\begin{center}
\bf Reasoning with Quantifiers
specialisation
\end{center}
\vfill
\begin{itemize}
\item binding display
=SML
z_µ_elim Ò (x¶455, y¶32)Æ thm1;
=GFT ProofPower Output
val it = µ x, y : Ó ∑ x * y > 0
 Ù {455, 32} Ä Ó ± true ¥ 455 * 32 > 0 : THM
=TEX
\item binding expression
=SML
z_µ_elim Ò exp∫[x,y:Ó]Æ thm1;
=GFT ProofPower Output
val it = µ x, y : Ó ∑ x * y > 0
  Ù {exp.x, exp.y} Ä Ó ± true
  ¥ exp.x * exp.y > 0 : THM
=TEX
\item value expression
=SML
z_µ_elim Ò 45Æ z_Ó_≥_plus1_thm;
=GFT ProofPower Output
val it = Ù 45 ç Ó ± true
	¥ ≥ 45 + 1 = 0 : THM   
=TEX
\end{itemize}
\vfill
\end{slide}


}%\small

% =====================================================================

\begin{slide}{}
\setcounter{slide}{42}
\begin{center}
{\bf Goal Oriented Proof}
\vfill

Works exactly the same as for HOL.

Make sure you are in a Z theory.

Make sure you have a Z proof context.

Terms should be entered using Z quotes
=INLINEFT
Ò Æ
=TEX
.
\vfill
\end{center}

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{43}
\begin{center}
\bf Tactics for Quantifiers
\end{center}
\vfill
\begin{itemize}
\item
$z_strip_tac$:
{\small
\begin{itemize}
\item
eliminates outer universals in conclusions
\item
skolemises existential assumptions
\item
pushes in outer negations over universal conclusions
\item
pushes in outer negations over existential assumptions
\end{itemize}
}%\small
\item
$z_spec_nth_asm_tac$:

specialises universal assumptions
\item
$z_∂_tac$

eliminates existential conclusions
\end{itemize}
\vfill
\end{slide}

% =====================================================================
{\small
\begin{slide}{}
\setcounter{slide}{44}
\begin{center}
\bf Exercises (7.1.3)
Forward Predicate Calculus
\end{center}
\vfill
=GFT
1. Using z_µ_elim with z_Ó_≥_plus1_thm prove:

	(a)	0 ç Ó ± true ¥ ≥ 0 + 1 = 0
	(b)	x * x ç Ó ± true ¥ ≥ x * x + 1 = 0  
 
2. Using prove_rule with z_º_trans_thm prove:
		i º j ± j º k ¥ i º k : THM

3. Using prove_rule and with z_Ó_≥_plus1_thm
	and z_0_Ó_thm prove:
	(a)	≥ 0 + 1 = 0   
	(b)	x * x ç Ó ¥ ≥ x * x + 1 = 0 
 
4. Using prove_rule prove:
	(a) (with z_≥_less_thm)
		≥ 0 < 1 § 1 º 0
	(b) (with z_º_trans_thm)
		µ n:˙ ∑ 3 º x * x ± x * x º n ¥ 3 º n
	  
5. Using prove_rule prove with z_º_clauses:

		µ i, m, n: ˙ ∑ i + m º i + n § m º n
=TEX
\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{}
\setcounter{slide}{45}
\begin{center}
{\bf Rewriting}
\vfill

Use same facilities as for HOL in appropriate proof contexts.

Most rewrites arising from axiomatic descriptions are effectively conditional, and the conditions must be discharged to achieve the rewrite.

Forward chaining is often an appropriate way to achieve such conditional rewriting. 

\vfill
{\bf Chaining}
\vfill

In appropriate proof contexts forward chaining facilities with $all$ in name work and stay in Z.
Other variants are liable to introduce hol universals.
\vfill
\end{center}

\end{slide}

% =====================================================================

{\small
\begin{slide}{}
\setcounter{slide}{46}
\begin{center}
{\bf Rewriting by Chaining - example}
\end{center}
\vfill
$z_abs_thm$ is :
=GFT
Ù µ i : Ó ∑ abs i = i ± abs ~ i = i
=TEX
Which, because quantified over $Ó$, is effectively a $conditional$ rewrite.

To prove:
=SML
set_goal([],Òa ç Ó ¥
     (abs a)*(abs ~a) = a*aÆ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
(*  1 *)  Ò0 º aÆ

(* ?Ù *)  Òabs a * abs ~ a = a * aÆ
=TEX
\end{slide}
}%\small

% =====================================================================

{\small
\begin{slide}{}
\setcounter{slide}{47}

Now use forward chaining to establish unconditional equations:
=SML
a (all_fc_tac [z_abs_thm]);
=GFT ProofPower output
(*  3 *)  Ò0 º aÆ
(*  2 *)  Òabs a = aÆ
(*  1 *)  Òabs ~ a = aÆ

(* ?Ù *)  Òabs a * abs ~ a = a * aÆ
=TEX
Then rewrite with these equations:
=SML
a (asm_rewrite_tac[]);
pop_thm();
=TEX
(which solves the goal)
\end{slide}
}%\small

% =====================================================================

\begin{slide}{}
\setcounter{slide}{48}
Exercises:
\begin{itemize}
\begin{center}
\bf Exercises (7.1.5.1) Rewriting with the Subgoal Package
\end{center}
\vfill
{\small
\begin{enumerate}
\item
set a goal from the examples on set theory, e.g.:
=SML
set_pc "z_sets_ext";
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
=TEX
\item
rewrite the goal using the current proof context:
=SML
a (rewrite_tac[]);
=TEX
\item
step back using undo:
=SML
undo 1;
=TEX
\item
now try rewriting without using the proof context:
=GFT
a (pure_rewrite_tac[]);
=TEX
(this should fail)
\end{enumerate}
}%\small
\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{49}
\begin{center}
\bf Exercises (7.1.5.1) continued
\end{center}
\vfill
{\small
\begin{enumerate}
\setcounter{enumi}{4}
\item
try rewriting one layer at a time:
=SML
a (once_rewrite_tac[]);
=TEX
repeat until it fails.
\item
now try rewriting with specific theorems:
=SML
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
a (pure_rewrite_tac[z_sets_ext_clauses]);
a (pure_rewrite_tac[z_set_dif_thm]);
a (pure_rewrite_tac[z_é_thm]);
a (pure_rewrite_tac[z_°_thm, z_¿_thm]);
a (pure_rewrite_tac[z_set_dif_thm]);
=TEX
\item
finish the proof by stripping:
=SML
a (REPEAT z_strip_tac);
=TEX
\item
extract the theorem
=SML
top_thm();
=TEX
\item repeat the above then try repeating:
=SML
pop_thm();
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{50}
\begin{center}
\bf Exercises (7.1.5.2):
combining forward and backward proof
\end{center}
\vfill
{\small
Prove the following results by rewriting using the goal package:
{\tiny for each example try the previous methods to see how they fail before following the hint
}%\tiny
\begin{enumerate}
\item :
=SML
set_pc "z_library";
set_goal([],Ò x + y = y + xÆ);
=TEX
\item :
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
(* hint : try using z_plus_assoc_thm *)
=TEX
\item :
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
(* hint : try using z_plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
(* hint : try using z_µ_elim with plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
(* hint : try using µ_elim with plus_order_thm *)
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{51}
\begin{center}
\bf Exercises (7.1.6): Stripping
\end{center}
\vfill
{\small
\begin{itemize}
\item
Use the examples from Principia Mathematica given earlier, e.g.:
=SML
	set_goal([],Ò p ± q ¥ (p § q)Æ);
=TEX
with
\begin{enumerate}
\item :
=SML
	a z_strip_tac;
=TEX
\item and/or:
=SML
	a step_strip_tac;
=TEX
\end{enumerate}
\item
Observe the steps taken and try to identify the reasons for discharge of subgoals.
\item
Select the weakest ``proof context'':
=SML
	push_pc "initial";
=TEX
then retry the examples (or previous exercises).
\item
When you have finished restore the original proof context by:
=SML
	pop_pc();
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{50}
\begin{center}

{\bf The Z Language in ProofPower\\
expressions}

\end{center}

\vfill

{\tiny
=GFT
 | €ZApp›	(* function application  Ò f xÆ  *)
 		of TERM * TERM	(* expressions *)
 | €ZÃ›	(* lambda expression Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
 		* TERM	(* expression *)
 | €ZÕ›	(* definite description Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
		* TERM	(* expression *)
 | €Z›	(* power set construction, Ò  ˙Æ *)
 	of TERM		(* expression *)
 | €ZSetd›	(* set display, Ò {1,2,3,4} Æ *)
 	of TYPE		(* HOL type of elements *)
 	* TERM list	(* expressions *)
 | €ZSeta›	(* set abstraction, Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
 	of TERM	(* declaration *)
 	* TERM	(* predicate *)
 	* TERM	(* expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{51}
\begin{center}

{\bf The Z Language in ProofPower\\
expressions (continued)}

\end{center}

\vfill

{\tiny
=GFT
 | €ZTuple›	(* tuple displays, Ò (1,2,3,4) Æ *)
 	of TERM list	(* expressions *)
 | €ZSelât›	(* tuple element selection, Ò (x,y).2Æ *)
 	of TERM	(* expression *)
 	* int		(* element number *)
 | €Z∏›	(* cartesian product, Ò (˙ ∏ Ó) Æ *)
 	of TERM list	(* expressions *)
 | €ZBinding› (* binding displays Ò (people ¶ {}, age ¶ {}) Æ *)
 	of (	string	(* component name *)
 		* TERM	(* component value *)
 		) list
 | €Z ›	(* theta term Ò  File' Æ *)
 	of TERM	(* schema expression *)
 	* string	(* decoration *)
 | €ZSelâs›	(* binding component selection Ò (a ¶ 1, b ¶ "4").b Æ *)
 	of TERM	(* expression *)
 	* string	(* component name *)
 | €Zâs›	(* horizontal schema expression
 		Ò [x:˙ | x>0] Æ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
 | €Zß¢›	(* sequence display Ò ß1,2,3¢ Æ *)
 	of TYPE	(* type of elements *)
 	* TERM list	(* values of elements *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================
{\small
% =====================================================================

\begin{slide}{}
\setcounter{slide}{52}
\begin{center}

{\bf Function Application (I)}

\end{center}

\vfill

Applications of lambda abstractions can be eliminated by (conditional) ¬-conversion.

=SML
z_¬_conv Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower outputval
val it = P a, a ç X Ù
	(Ã x : X | P x ∑ f x) a = f a : THM   
=TEX
\vfill

Other applications may be eliminated in favour of definite descriptions.

=SML
z_app_conv Ò f aÆ;
=GFT ProofPower output
val it = Ù f a = Õ f_a : U
	| (a, f_a) ç f ∑ f_a : THM   
=TEX

More commonly function applications will be eliminated by rewriting with their definitions.

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{53}
\begin{center}

{\bf Function Application (II)}

\end{center}

\vfill
For low level reasoning $z_app_eq_tac$ is useful:
=SML
set_goal([],Ò f a = vÆ);
a z_app_eq_tac;
=GFT ProofPower output
...
(* ?Ù *) Ò(µ f_a : U | (a, f_a) ç f ∑ f_a = v)
  ± (a, v) ç fÆ
...
=TEX
Here the first conjunct expresses the requirement that $f$ is functional at $a$.

If f is known to be a function this fact may be used more directly with the assistance of the theorem $z_fun_app_clauses$:
=GFT
val z_fun_app_clauses =
  Ù µ f : U; x : U; y : U; X : U; Y : U
    ∑ (f ç X ﬂ Y
          ≤ f ç X ˛ Y
          ≤ f ç X œ Y
          ≤ f ç X ≠ Y
          ≤ f ç X ‡ Y
          ≤ f ç X Ô Y
          ≤ f ç X è Y)
        ± (x, y) ç f
      ¥ f x = y : THM
=TEX

Which is most conveniently appplied using forward chaining.
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{}
\setcounter{slide}{54}
\begin{center}

{\bf Function Application (III)}

\end{center}

\vfill
=SML
drop_main_goal();
set_goal([], Òf ç Ó Ô ˙ ¥
    (4, ~45) ç f ¥ f 4 = ~45Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
(*  2 *)  Òf ç Ó Ô ˙Æ
(*  1 *)  Ò(4, ~ 45) ç fÆ

(* ?Ù *)  Òf 4 = ~ 45Æ
=TEX
\vfill
=SML
a (all_fc_tac [z_fun_app_clauses]);
pop_thm();
=TEX
\vfill
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\vfill

Often it is necessary to establish that a function application is a member of a set.

The theorem $z_fun_ç_clauses$ is of assistance in such cases:
=GFT
val z_fun_ç_clauses = Ù
 µ f : U; x : U; X : U; Y : U
 ∑ ((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
    ± x ç X ¥ f x ç Y)
 ± ((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
     ± x ç dom f ¥ f x ç Y) : THM
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{55}
\begin{center}
{\bf Function Application (IV)}
\end{center}
This too is best applied using forward chaining:
=SML
set_goal([],
 Ò[X](µ b: bag X∑ count[X] b ç X ≠ Ó)Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
(*  1 *)  Òb ç bag XÆ

(* ?Ù *)  Òcount[X] b ç X ≠ ÓÆ
=TEX
We need the information from the declaration of $count$:
=SML
a (strip_asm_tac (z_gen_pred_elim
   [ÒXÆ] (z_get_spec ÒcountÆ)));
=GFT ProofPower output
(*  3 *)  Òb ç bag XÆ
(*  2 *)  Òcount[X] ç bag X è X ≠ ÓÆ
...
(* ?Ù *)  Òcount[X] b ç X ≠ ÓÆ
=TEX
Now we can forward chain:
=SML
a (all_fc_tac [z_fun_ç_clauses]);
save_pop_thm "bag_lemma1";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{}
\setcounter{slide}{56}
\begin{center}

{\bf Schema Predicates}

\end{center}

\vfill

These may be eliminated in favour of membership statements by rewriting with $z'schema\_pred\_def$:

\vfill
=SML
pure_rewrite_conv[z'schema_pred_def]Ò ([x:X])' ± trueÆ;
=TEX
=GFT ProofPower outputval
val it = Ù [x : X] ± true §
	(x ¶ x) ç [x : X] ± true : THM   
=TEX
\vfill
=SML
rewrite_conv[z'schema_pred_def]Ò ([x:X])' ± trueÆ;
=TEX
=GFT ProofPower outputval
val it = Ù (([x : X])') ± true § x' ç X : THM   
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{57}
\begin{center}

{\bf Lambda Abstraction}

\end{center}

\vfill

For extensional reasoning:

=SML
rewrite_conv [] Òz ç (Ã x:X | P x ∑ f x)Æ;
=TEX
=GFT ProofPower outputval
val it = Ù z ç Ã x : X | P x ∑ f x §
	z.1 ç X ± P z.1 ± f z.1 = z.2 : THM   
=TEX

Lambda abstractions may be transformed into set abstractions.

=SML
z_Ã_conv Ò Ã x:X | P x ∑ f xÆ;
=GFT ProofPower outputval
val it = Ù Ã x : X | P x ∑ f x =
	{x : X | P x ∑ (x, f x)} : THM   
=TEX

\vfill

\begin{center}

{\bf Definite Description}

\end{center}

\vfill
=SML
z_Õ_rule Ò Õ x:X | P ∑ yÆ;
=GFT ProofPower output
val it = Ù µ x' : U
    ∑ (µ x : X | P ∑ y = x')
    ± (∂ x : X | P ∑ y = x')
      ¥ (Õ x : X | P ∑ y) = x' : THM
=TEX
\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{58}
\begin{center}

{\bf The Power Set Constructor}

\end{center}

\vfill

=SML	
z_ç__conv Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y §
	(µ x1 : U ∑ x1 ç z ¥ x1 ç y) : THM   
=TEX

=GFT Sadly Not in Language-Only Reasoning
rewrite_conv[] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § z Ä y : THM   
=TEX
\ignore{	
pc_rule1 "z_sets_ext"
rewrite_conv[] Ò z ç  yÆ;
}%\ignore

\vfill

=GFT Sadly Not in Language-Only Reasoning
rewrite_conv[z_Ä_thm] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y
	§ (µ x : U ∑ x ç z ¥ x ç y) : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{59}
\begin{center}

{\bf Set Displays}

\end{center}

\vfill

\ignore{	
=SML
open_theory"usr023";
set_pc "z_language";
=TEX
}%\ignore

{\small
\begin{itemize}
\item
sets may be entered as terms by enumeration:
=SML
rewrite_conv [] Ò 5 ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù 5 ç {1, 2, 3, 4, 5} § true : THM
=TEX
=SML
rewrite_conv [] Ò x ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù x ç {1, 2, 3, 4, 5} §
 x = 1 ≤ x = 2 ≤ x = 3 ≤ x = 4 ≤ x = 5 : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{60}
\begin{center}

{\bf Set Abstractions}

\end{center}

\vfill
{\small
\begin{itemize}
\item
sets may also be entered as set abstractions:
=SML
rewrite_conv[] Ò 9 ç {x:Ó | x < 12}Æ;
=GFT ProofPower output
val it =
Ù 9 ç {x : Ó | x < 12} § 9 ç Ó ± 9 < 12 : THM   
=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y}
 § {z.1, z.2} Ä Ó ± z.1 < z.2 : THM   
=TEX
=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y ∑ x * y - x}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y ∑ x * y - x}
    § (∂ x, y : Ó | x < y ∑ x * y - x = z) : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

{\small
\begin{slide}{}
\setcounter{slide}{61}
\begin{center}

{\bf Tuples}

\end{center}

\vfill

=SML
rewrite_conv[] Ò (x,y) = (a,b)Æ;
=GFT ProofPower output
val it = Ù (x, y) = (a, b)
	§ x = a ± y = b : THM   
=TEX

\vfill

=SML
rewrite_conv[] Ò (x,y).1Æ;
=GFT ProofPower output
val it = Ù (x, y).1 = x : THM   
=TEX

\vfill

\begin{center}

{\bf Bindings}

\end{center}

\vfill

=SML
rewrite_conv[]
	Ò (x ¶ a, y ¶ b) = (y ¶ d, x ¶ c)Æ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) = (x ¶ c, y ¶ d)
	§ a = c ± b = d : THM   
=TEX

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{62}
\begin{center}

{\bf Cartesian Products}

\end{center}

\vfill
=SML
rewrite_conv[] Ò (a, b) ç (x ∏ y)Æ;
=GFT ProofPower output
val it = Ù (a, b) ç x ∏ y
	§ a ç x ± b ç y : THM   
=TEX

=SML
rewrite_conv[z_sets_ext_thm]
	Ò (x ∏ y) = (a ∏ b)Æ;
=GFT ProofPower output
it = Ù x ∏ y = a ∏ b
	§	(µ z : U ∑ z.1 ç x ± z.2 ç y
    		§ z.1 ç a ± z.2 ç b) : THM
=TEX
\vfill

\begin{center}

{\bf Theta Terms}

\end{center}
\vfill

=SML
z_ _conv Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' =
  (age ¶ age', people ¶ people') : THM   
=SML
rewrite_conv[z' _def] Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' =
  (age ¶ age', people ¶ people') : THM   
=TEX
\vfill

\end{slide}


% =====================================================================

\begin{slide}{}
\setcounter{slide}{70}
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (I)}

\end{center}

\vfill

{\tiny
=GFT
 | €Z≥âs›	(* schema negation Ò(≥ File)∫UÆ *)
		of TERM (* schema expression *)
 | €Z±âs›	(* schema conjunction Ò(File ± File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z≤âs›	(* schema disjunction Ò(File ≤ File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z¥âs›	(* schema implication Ò(File ¥ File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z§âs›	(* schema equivalence Ò(File § File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z∂âs›	(* schema existential
 		Ò(∂ File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
 | €Z∂â1âs›	(* schema unique existential
 		Ò(∂â1 File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
 | €Zµâs›	(* schema universal
 		Ò(µ File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{71}
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (II)}

\end{center}

\vfill

{\tiny
=GFT
 | €ZDecorâs› (* decoration Ò File ''Æ *)
 		of TERM	(* schema expression *)
 		* string	(* decoration *)
 | €ZPreâs›	(* pre-condition Ò pre FileOpÆ *)
 		of TERM	(* schema expression *)
 | €ZHideâs›	(* schema hiding Ò FileOp \âs (age, i?)Æ  *)
 		of TERM	(* schema expression *)
 		* string list	(* component names *)
 | €ZRenameâs› (* schema renaming
 			ÒFile [aged/age, input/i?]Æ *)
 		of TERM	(* schema expression *)
 		* (string * string) list	(* rename list *)
 | €Z˘âs›	(* schema projection ÒFileOp ˘âs FileÆ*)
 		of TERM * TERM	(* schema expressions *)
 | Zªâs	(* schema composition ÒÑFile ªâs ÑFileÆ *)
 		of TERM * TERM	(* schema expressions *)
 | €ZÑâs›	(* delta operation ÒÑFileÆ *)
 		of TERM	(* schema expression *)
 | €Zòâs›	(* ò operation ÒòFileÆ *)
 		of TERM	(* schema expression *)
;
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================
\begin{slide}{}
\setcounter{slide}{72}
\begin{center}
{\bf Schema Negation}
\end{center}

\vfill
Return to theory where we defined schema $File$:

=SML
open_theory "usr023";
set_pc "z_language";
=TEX
=SML
rewrite_conv[]Òz ç (≥ File)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (≥ File) § ≥ z ç File : THM   
=TEX

\vfill

\begin{center}
{\bf Schema Conjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ± File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ± File2) §
 (age ¶ z.age, people ¶ z.people) ç File ±
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}
\setcounter{slide}{73}
\begin{center}
{\bf Schema Disjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ≤ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ≤ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ≤
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Implication}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ¥ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ¥ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ¥
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill


\end{slide}
% =====================================================================
\begin{slide}{}
\setcounter{slide}{74}
\begin{center}
{\bf Schema Equivalence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File § File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File § File2) §
 (age ¶ z.age, people ¶ z.people) ç File §
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Existential}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂ File3 | people = {} ∑ File2) §
 (∂ x1 : U ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}
\setcounter{slide}{75}
\begin{center}
{\bf Schema Unique Existence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂â1 File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂â1 File3 | people = {} ∑ File2) §
 (∂â1 x1 : U ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\begin{center}
{\bf Schema Universal}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (µ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (µ File3 | people = {} ∑ File2) §
 (µ x1 : U
 ∑ (people ¶ x1.people) ç File3 ± x1.people = {}
   ¥ (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}
\setcounter{slide}{76}
\begin{center}
{\bf Schemas}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç [x:˙;y:Ó]Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç [x : ˙; y : Ó]
	§ z.x ç ˙ ± z.y ç Ó : THM   
=TEX

\vfill

\begin{center}
{\bf Decoration}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç File ''Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File'')	§
 (age ¶ z.age'', people ¶ z.people'') ç File : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}
\setcounter{slide}{77}

\begin{center}
{\bf Pre-Condition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (pre FileOp)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (pre FileOp) §
 z ç	[age : U; i? : U; people : U
	| ∂ age' : U; people' : U ∑ FileOp] : THM
=TEX

\vfill

\begin{center}
{\bf Schema Hiding}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age)) §
	z ç [people : U | ∂ age : U ∑ File] : THM
=TEX

\vfill
=SML
rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age))
    § (∂ age : U ∑
    	(age ¶ age, people ¶ z.people) ç File) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}
\setcounter{slide}{78}

\begin{center}
{\bf Schema Renaming}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç File[aged/age]Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File [aged/age]) §
	(age ¶ z.aged, people ¶ z.people) ç File : THM
=TEX

\vfill

\begin{center}
{\bf Schema Projection}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ˘âs File)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ˘âs File)
    § z ç ((FileOp ± File) \âs (age', i?, people')) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}
\setcounter{slide}{79}

\begin{center}
{\bf Schema Composition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § z
      ç [age : U; i? : U; people : U; age' : U; people' : U
        | ∂ x1 : U; x2 : U
          ∑ (age ¶ age, age' ¶ x1, i? ¶ i?,
          		people ¶ people, people' ¶ x2)
              ç FileOp
            ± (age ¶ x1, age' ¶ age', i? ¶ i?, people ¶ x2,
                  people' ¶ people')
              ç FileOp] : THM
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================
\begin{slide}{}
\setcounter{slide}{80}

\begin{center}
{\bf Delta}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (ÑFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (Ñ File) §
	z ç [File; File'] : THM   
=TEX

\vfill
\begin{center}
{\bf Xi}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (òFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (ò File) §
	z ç [File; File' |  File =  File'] : THM   
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================

\begin{slide}{}
\setcounter{slide}{90}
\begin{center}
{\bf Z Paragraphs}
\end{center}
\vfill
\begin{itemize}
\item
Fixity declarations
\item
Given sets
\item
Abbreviation definitions
\item
Schema boxes
\item
Axiomatic descriptions
\item
Generics
\item
Free types
\item
Constraints
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{91}
\begin{center}
{\bf Z Paragraphs\\
Paragraph Processing Modes and Flags}
\end{center}
\vfill
{\small
There are several different modes of processing Z paragraphs which are controlled by flags.

\begin{itemize}
\item
{\bf Type-checking Mode}

If the flag $z\_type\_check\_only$ is set to $true$ then only type checking of Z paragrpahs is performed.

{\tiny
This makes the response faster, and permits greater flexibility in amending paragraphs.
This mode is suitable for use while developing specifications prior to undertaking any proof work.
}

\item
{\bf Axiomatic Mode}
 
If the flag $z\_use\_axioms$ is set to true (and\\
$z\_type\_check\_only$ is set to $false$) then axiomatic descriptions and free-type descriptions are introduced using axioms.


\item
{\bf Conservative Mode}

If both the above flags is set $false$ then all Z axiomatic descriptions are introduced using the ProofPower\\
$new\_specification$ facility, i.e. by conservative extension.

{\tiny
Consistency proof obligations, unless discharged automatically, will have to be discharged by the user.

In a future release it is hoped that free-types will also be supported by conservative extension.
}%\tiny

\end{itemize}

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{92}
\vfill
{\small
=SML
open_theory "usr023"; 
set_pc "z_library";
=TEX
\begin{center}
{\bf Fixity Declarations}
\end{center}
\ftlmargin 0.5in
Fixity delcarations may be provided for:
\begin{itemize}
\item
functions
πZ
fun 10 twice _
∞
πZ
fun  select ... from _
∞
\item
generics
πZ
gen _ swap _
∞
\item
relations
πZ
rel  _ is_even 
∞
\end{itemize}

\vfill

The optional numeric value is a priority.

`\_' is a space for a parameter\\
`...' is a space for a sequence of parameters (with sequence brackets elided)

Fixity clauses can only be deleted by deleting the theory they are contained in.

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{93}
\begin{center}
{\bf Given Sets}
\end{center}

\vfill

πZ
[G1, G2]
∞

\vfill

=SML
val G1_def = z_get_spec ÒG1Æ;
=GFT ProofPower output
val G1_def = Ù G1 = U : THM   
=TEX

\vfill

=SML
rewrite_conv [G1_def] Òx ç G1Æ;
=GFT ProofPower output
val it = Ù x ç G1 § true : THM   
=TEX

\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{94}
\begin{center}
{\bf Abbreviation Definitions}
\end{center}

{\small
\vfill
=SML
val _ = set_flag("z_type_check_only", false);
=TEX

πZ
X swap Y ¶ Y ∏ X 
∞

\vfill

=SML
val swap_def = z_get_spec Ò(_swap_)Æ;
=GFT ProofPower Output
val swap_def =
Ù [X, Y](X swap Y = Y ∏ X) : THM   
=TEX

\vfill

=SML
rewrite_conv [swap_def] Ò˙ swap ÓÆ;
=TEX
=GFT ProofPower Output
val it = Ù ˙ swap Ó = Ó ∏ ˙ : THM   
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{95}
\begin{center}
{\bf Schema Boxes}
\end{center}
\vfill
{\small
ˇSch¸¸¸¸¸¸¸¸¸¸¸¸
‹	x, y : ˙;
‹	z : Ó
˜¸¸¸¸¸¸¸¸¸
‹	x = y ≤ y = z
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
val sch_def = z_get_spec ÒSchÆ;
=GFT ProofPower Output
val sch_def = Ù Sch =
  [x, y : ˙; z : Ó | x = y ≤ y = z] : THM   
=TEX
=SML
rewrite_conv [sch_def]
 Òµ x,y:˙; z:Ó ∑ Sch ≤ disjoint ß{x},{y},{z}¢Æ;
=TEX
=GFT ProofPower Output
val it = Ù (µ x, y : ˙; z : Ó ∑ Sch
		≤ disjoint ß{x}, {y}, {z}¢)
    § (µ x, y : ˙; z : Ó
      ∑ [x, y : ˙; z : Ó | x = y ≤ y = z]
      	≤ disjoint ß{x}, {y}, {z}¢) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{96}
\begin{center}
{\bf Generic Schema Boxes}
\end{center}
\vfill
{\small
ˇDSUBS[X]¸¸¸¸¸¸¸¸¸¸¸
‹	set1, set2:  X
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	set1 ° set2 = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
=SML
val dsubs_def = z_get_spec ÒDSUBSÆ;
=GFT ProofPower Output
val dsubs_def = Ù [X](DSUBS[X] =
  [set1, set2 :  X | set1 ° set2 = {}]) : THM
=TEX
\vfill
=SML
rewrite_conv [dsubs_def (*, z'schema_pred_def*)]
 Òµ DSUBS[Ó] ∑ set1 Ä Ó ± set2 Ä ÓÆ;
=GFT ProofPower Output
val it = Ù (µ (DSUBS[Ó]) ∑ set1 Ä Ó ± set2 Ä Ó)
	§ (µ [set1, set2 :  Ó | set1 ° set2 = {}] ∑
		set1 Ä Ó ± set2 Ä Ó) : THM
=TEX
\vfill

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{97}
\begin{center}
{\bf Axiomatic Descriptions}
\end{center}
\vfill
{\small
πZAX
‹	twice _ : ˙ ≠ ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	µi : ˙ ∑ twice i = 2*i
∞
\vfill
=SML
val twice_def = z_get_spec Ò(twice_)Æ;
=GFT ProofPower Output
val twice_def = Ù (twice _) ç ˙ ≠ ˙
	± (µ i : ˙ ∑ twice i = 2 * i) : THM   
=TEX
\vfill
\ignore{
=SML
set_flag("use_file_non_stop_mode",true);
=TEX
}
=SML
rewrite_conv[twice_def] Òtwice 4Æ;
=GFT ProofPower Output
Exception- Fail * no rewriting occurred
=TEX
\ignore{
=SML
set_flag("use_file_non_stop_mode",false);
=TEX
}
\vfill
=SML
set_goal([],Òµ n:˙ ∑ twice n = 2*nÆ);
a (REPEAT z_strip_tac);
=GFT ProofPower Output
(* *** Goal "" *** *)
(*  1 *)  Òn ç ˙Æ
(* ?Ù *)  Òtwice n = 2 * nÆ
=TEX
\vfill
=SML
a (fc_tac [twice_def]);
=GFT ProofPower Output
Current and main goal achieved
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{98}
\begin{center}
{\bf Generic Axiomatics}
\end{center}
\vfill
{\small
ù[X,Y,Z]úúúúúúúúúúúúúúúúúúúúúúúú
‹ select ... from _ : (X ™ Y) ∏ (Y ™ Z) ≠ (Y ™ Z)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ indexed_set:(X ™ Y); relation:(Y ™ Z) ∑
‹ (select ... from _) (indexed_set, relation)
‹ = (ran indexed_set) Ú relation
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\vfill
=GFT ProofPower output
val select_from_def = Ù [X, Y, Z](
 (select ... from _)[X, Y, Z]
  ç (X ™ Y) ∏ (Y ™ Z) ≠ Y ™ Z
 ± (µ indexed_set : X ™ Y; relation : Y ™ Z∑
 (select ... from _)[X, Y, Z] (indexed_set, relation)
    = ran indexed_set Ú relation)) : THM
=TEX
\vfill
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{99}
\begin{center}
{\bf Free Types}
\end{center}
\vfill

{\small
πZ
TREE ::= tip | fork (Ó ∏ TREE ∏ TREE)
∞
\vfill

=SML
val tree_def = z_get_spec ÒTREEÆ;
=GFT ProofPower Output
val tree_def = Ù TREE = U : THM   
=TEX

\vfill

=SML
val tip_def = z_get_spec ÒtipÆ;
=GFT ProofPower Output
val tip_def = Ù (tip ç TREE
 ± fork ç Ó ∏ TREE ∏ TREE ‡ TREE)
 ± disjoint ß{tip}, ran fork¢
 ± (µ W :  TREE | {tip} ¿ fork ® Ó ∏ W ∏ W © Ä W∑
	TREE Ä W) : THM
=TEX


}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{100}
\begin{center}
{\bf Mutually Recursive Free Types}
\end{center}
\vfill

{\small

πZ
TYPE ::= Tvar G1 | Tcon (G1 ∏ seq TERM)
&
TERM ::= Con (G1 ∏ TYPE) | App (TERM ∏ TERM)
∞

\vfill

=SML
val tvar_def = z_get_spec ÒTvarÆ;
=GFT ProofPower Output
val tvar_def = Ù (Tvar ç G1 ‡ TYPE
    ± Tcon ç G1 ∏ (seq TERM) ‡ TYPE
    ± Con ç G1 ∏ TYPE ‡ TERM
    ± App ç TERM ∏ TERM ‡ TERM)
    ± (disjoint ßran Tvar, ran Tcon¢
    ± (µ W :  TYPE
      | Tvar ® G1 © ¿ Tcon ® G1 ∏ (seq TERM) © Ä W
      ∑ TYPE Ä W))
    ± disjoint ßran Con, ran App¢
    ± (µ W :  TERM
      | Con ® G1 ∏ TYPE © ¿ App ® W ∏ W © Ä W
      ∑ TERM Ä W) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{101}
\begin{center}
{\bf Constraints}
\end{center}
\vfill

{\small

πZ
[X] ((∂f : X ‡ G1 ∑ true)
	§ (∂f : X ‡ G2 ∑ true))
∞

\vfill

=SML
val c1 = get_axiom "-" "Constraint 1";
=GFT ProofPower output
val c1 = Ù [X]((∂ f : X ‡ G1 ∑ true) §
		(∂ f : X ‡ G2 ∑ true)) : THM   
=TEX

\vfill

πZ
 {1} swap {ß1¢} = {ß1¢} ∏ {1}
 	± Sch Ω [x, y, z : ˙] 
∞

\vfill

πZ
 tip Ω fork(2, tip, tip) ±
 tip ç TREE
∞

\vfill

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{110}
\begin{center}
{\bf Theories}
\end{center}
\vfill
Z Theories contain the following information:
\begin{itemize}
\item
The theory name and the names of the theories parents and children.
\item
The names of types (given sets) declared in the theory.
\item
The names and types of `global variables' declared in the theory.
\item
Fixity information.
\item
Axioms or specifications corresponding to the paragraphs of the Z specification introduced in this theory.
\item
A collection of saved theorems.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{120}
\begin{center}
\bf Induction
\end{center}
\vfill
Induction principles for Z can be expressed as mixed language theorems in Higher Order Logic and Z e.g.:
\vfill
{\small
\begin{itemize}
=TEX
\item $z\_Ó\_induction\_thm$
=GFT
Ù µ p
  ∑ p Ò 0Æ
  ± (µ i∑ i ç Ò ÓÆ ± p i ¥ p Ò i + 1Æ)
  ¥ (µ m∑ m ç Ò ÓÆ ¥ p m) : THM
=TEX
\item $z\_˙\_induction\_thm$
=GFT
 Ù µ p
  ∑ p Ò 1Æ
  ± (µ i∑ p i ¥ p Ò ~ iÆ)
  ± (µ i j∑ p i ± p j ¥ p Ò i + jÆ)
  ¥ (µ m∑ p m) : THM
=TEX
\end{itemize}
}%\small
\vfill
$µ\_elim$ and $all\_¬\_rule$ may be used to specialise these for use in forward proofs.
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{121}
\begin{center}
\bf Induction Tactics
\end{center}
\vfill
{\small
Special tactics are available to facilitate the use\\
of induction principles:
\begin{itemize}
\item induction over natural numbers using\\
$z\_Ó\_induction\_tac$
=FRULE 2
z_Ó_induction_tac Ò xÆ
˜
{ á } x ç Ó ¥ t 
˜
{ á } t[0/x] ;
strip{t, á} t[x+1/x]
=TEX
\item induction over integers using\\
$z\_˙\_induction\_tac$
=FRULE 2
z_˙_induction_tac Ò xÆ
˜
{ á } t 
˜
{ á } t[1/x];
strip{t[i/x], á} t[~i/x];
strip{t[i/x] ± t[j/x], á} t[i+j/x]
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{122}
\begin{center}
\bf Induction - Example (I)
\end{center}
\vfill
=SML
set_goal ([], Òx ç Ó ¥ x + y æ yÆ);
a (z_Ó_induction_tac);
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò0 º iÆ

(* ?Ù *)  Ò(i + 1) + y æ yÆ


(* *** Goal "1" *** *)

(* ?Ù *)  Ò0 + y æ yÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{123}
\begin{center}
\bf Induction - Example (II)
\end{center}
\vfill
=SML
set_goal ([], Òx + y æ yÆ);
a (z_˙_induction_tac ÒxÆ);
=GFT ProofPower output
(* *** Goal "3" *** *)
(*  2 *)  Ò0 º iÆ
(*  1 *)  Ò0 º jÆ

(* ?Ù *)  Ò(i + j) + y æ yÆ

(* *** Goal "2" *** *)
(*  1 *)  Ò0 º iÆ

(* ?Ù *)  Ò~ i + y æ yÆ

(* *** Goal "1" *** *)
(* ?Ù *)  Ò1 + y æ yÆ
=TEX
\vfill
\end{slide}


% =====================================================================
{\small

\begin{slide}{}
\setcounter{slide}{130}
\begin{center}
{\bf CASE STUDY - Confidentiality}
\end{center}
\vfill
=SML
open_theory"z_library";
new_theory€"usr023C"›;
set_pc "z_library";
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
=TEX
\vfill
πZ
‹	[€DATA›]
∞
\vfill
ˇ€STATE›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	classified_data :Ó ﬂ DATA
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇ€OPERATION›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSTATE; 
‹	€clear?› : Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{131}

ˇ€READ›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	OPERATION;
‹	€class?›	:Ó;
‹	€data!›	: DATA
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	class? ç dom classified_data;
‹	class? º clear?;
‹	data! = classified_data class?;
‹	classified_data' = classified_data
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇ€COMPUTE›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  OPERATION;
‹  €class?›	:Ó;
‹  €computation?›	:(Ó ﬂ DATA) ≠ DATA
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  class? ç dom classified_data;
‹  class? æ clear?;
‹  classified_data'
‹  =  classified_data ´ {class? Ì 
‹      computation? ((0 .. clear?) Ú classified_data)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill

\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{132}
\begin{center}
{\bf Pre-Condition Proofs}
\end{center}
\vfill
=SML
set_goal ([], Òpre OPERATION §
 classified_data ç Ó ﬂ DATA ± 0 º clear?Æ);
=TEX
\vfill
=SML
a (rewrite_tac (map z_get_spec
	[ÒOPERATIONÆ, ÒSTATEÆ]));
=TEX
\vfill
=GFT ProofPower output
...
(* ?Ù *)  Ò(∂ classified_data' : U
    ∑ (classified_data ç Ó ﬂ DATA
      ± classified_data' ç Ó ﬂ DATA)
    ± 0 º clear?)
 § classified_data ç Ó ﬂ DATA ± 0 º clear?Æ
...
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{133}
=SML
a (REPEAT z_strip_tac
   THEN_TRY asm_rewrite_tac[]);
=TEX
\vfill
=GFT ProofPower output
...
(*  2 *)  Òclassified_data ç Ó ﬂ DATAÆ
(*  1 *)  Ò0 º clear?Æ

(* ?Ù *)  Ò∂ classified_data' : U ∑
	classified_data' ç Ó ﬂ DATAÆ
...
=TEX
\vfill
=SML
a (z_∂_tac Ò{}Æ THEN
  PC_T1 "z_library_ext" rewrite_tac[]);
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{134}
\begin{center}
{\bf An Algorithmic Refinement}
\end{center}
\vfill
ˇ€BADREAD›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	OPERATION;
‹	€class?›	:Ó;
‹	€data!›	: DATA
˜¸¸¸¸¸¸¸¸¸¸¸
‹	READ ≤
‹ 	(class? > clear?;
‹	data! = classified_data class?;
‹	classified_data' = classified_data)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
=SML
set_goal([],
 Ò(pre READ ¥ pre BADREAD)
 ± (pre READ ± BADREAD ¥ READ)Æ);
 
a (rewrite_tac (map z_get_spec
 [ÒBADREADÆ, ÒREADÆ, ÒOPERATIONÆ, ÒSTATEÆ]));
 
a (REPEAT z_strip_tac THEN rename_tac[]
 THEN asm_rewrite_tac[]);
=TEX
\vfill
\end{slide}
}%\small

% =====================================================================

{\tiny
\begin{slide}{}
\setcounter{slide}{135}
=GFT ProofPower output
...
(*  9 *)  Òclassified_data ç Ó ﬂ DATAÆ
(*  8 *)  Òclassified_data' ç Ó ﬂ DATAÆ
(*  7 *)  Ò0 º clear?Æ
(*  6 *)  Ò0 º class?Æ
(*  5 *)  Òdata! ç DATAÆ
(*  4 *)  Òclass? ç dom classified_dataÆ
(*  3 *)  Òclass? º clear?Æ
(*  2 *)  Òdata! = classified_data class?Æ
(*  1 *)  Òclassified_data' = classified_dataÆ

(* ?Ù *)  Ò∂ classified_data'' : U; data!' : U
 ∑ (classified_data'' ç Ó ﬂ DATA
   ± data!' ç DATA)
 ± ((classified_data'' ç Ó ﬂ DATA
      ± data!' ç DATA)
    ± data!' = classified_data class?
    ± classified_data'' = classified_data
   ≤ clear? < class?
    ± data!' = classified_data class?
    ± classified_data'' = classified_data)Æ
...
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{136}
=SML
a (z_∂_tac Ò
   (classified_data'' ¶ classified_data,
   data!' ¶ classified_data class?)Æ
 THEN asm_rewrite_tac[]);
=GFT ProofPower output
...
(*  9 *)  Òclassified_data ç Ó ﬂ DATAÆ
...
(*  4 *)  Òclass? ç dom classified_dataÆ
...
(* ?Ù *)  Òclassified_data class? ç DATA
             ± (classified_data class? ç DATA ≤ clear? < class?)Æ
             ...
=TEX
\vfill
=GFT
Ù µ f : U; x : U; X : U; Y : U
    ∑ ((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
       ± x ç X ¥ f x ç Y)
    ± ((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
       ± x ç dom f ¥ f x ç Y) : THM
=TEX
\vfill
=SML
a (all_fc_tac [z_fun_ç_clauses]
	THEN REPEAT strip_tac);
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

{\small
\begin{slide}{}
\setcounter{slide}{140}
\begin{center}
{\bf Base Types}
\end{center}
\vfill
=SML
open_theory "usr023C";
=TEX
\vfill
πZ
‹  [€IN›,€OUT›]
∞
\vfill
πZ
‹  €STATE2› ¶ Ó ﬂ DATA
∞
\vfill
πZ
‹  €SYSTEM› ¶ (Ó ∏ IN ∏ STATE2)
		≠ (STATE2 ∏ OUT)
∞
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{141}
\begin{center}
{\bf Critical Property}
\end{center}
\vfill
πZAX
‹  €out_secure› :  SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µsys:SYSTEM∑ sys ç out_secure §
‹
‹  (µ clear:Ó; inp:IN; s,s':STATE2
‹  | (0 ..  clear) Ú s = (0 ..  clear) Ú s'
‹  ∑ second (sys (clear, inp, s))
‹    = second (sys (clear, inp, s')))
∞
\vfill
πZAX
‹  €state_secure› :  SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µsys:SYSTEM∑ sys ç state_secure §
‹
‹  (µclass, clear:Ó; inp:IN; s,s':STATE2
‹  | ((0 ..  class) Ú s) = ((0 ..  class) Ú s')
‹  ∑ (0 ..  class) Ú (first (sys (clear, inp, s)))
‹    = (0 ..  class) Ú (first (sys (clear, inp, s'))))
∞
\vfill
πZAX
‹  €secure› :  SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µsys:SYSTEM∑ sys ç secure §
‹  sys ç state_secure ± sys ç out_secure
∞
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{142}
\begin{center}
{\bf Secure Architecture}
\end{center}
\vfill
πZ
  €APPLICATION› ¶ (IN ∏ STATE2)
                    ≠ (STATE2 ∏ OUT)
∞
\vfill
πZ
‹  €KERNEL› ¶ APPLICATION ≠ SYSTEM
∞
\vfill
πZAX
‹  €construction› : APPLICATION ∏ KERNEL ≠ SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µappl:APPLICATION; kernel:KERNEL∑
‹    construction (appl, kernel) = kernel appl
∞
\vfill
πZAX
‹  €secure_kernel› :  KERNEL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µ kernel:KERNEL∑ kernel ç secure_kernel §
‹    (µappl:APPLICATION∑
‹      (construction (appl, kernel)) ç secure)
∞
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{143}
\begin{center}
{\bf Architectural Correctness}
\end{center}
\vfill

=SML 
set_goal([],Òµkernel:KERNEL;appl:APPLICATION∑
  kernel ç secure_kernel ¥
  (construction (appl,kernel)) ç secureÆ);
=TEX
\vfill
=SML
val €secure_kernel_sim› = z_defn_simp_rule
           (z_get_specÒsecure_kernelÆ);
=TEX
\vfill
=GFT ProofPower output
val secure_kernel_sim = Ù µ kernel : U ∑
 kernel ç secure_kernel §
 kernel ç KERNEL
 ± (µ appl : APPLICATION ∑
    construction (appl, kernel) ç secure) : THM
=TEX
\vfill
=SML 
a (rewrite_tac[secure_kernel_sim]);
=GFT ProofPower output
(* ?Ù *)  Òµ kernel : KERNEL; appl : APPLICATION
 ∑ kernel ç KERNEL
 ± (µ appl : APPLICATION
    ∑ construction (appl, kernel) ç secure)
      ¥ construction (appl, kernel) ç secureÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{144}
=SML 
a (REPEAT strip_tac);
=TEX
\vfill
=GFT ProofPower output
(*  3 *)  Òkernel ç KERNELÆ
(*  2 *)  Òappl ç APPLICATIONÆ
(*  1 *)  Òµ appl : APPLICATION ∑
             construction (appl, kernel) ç secureÆ

(* ?Ù *)  Òconstruction (appl, kernel) ç secureÆ
=TEX
\vfill
=SML 
a (all_asm_fc_tac[]);
=TEX
\vfill
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{145}
\begin{center}
{\bf A Secure Kernel}
\end{center}
\vfill
πZAX
‹ €kernel_implementation› : KERNEL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ clear:Ó; inp:IN;
‹   state:STATE2; appl:APPLICATION ∑
‹
‹ kernel_implementation appl (clear, inp, state) = 
‹
‹ (  state ´ ((0  ..  (clear-1)) ·
‹        (first (appl (inp, (0  ..  clear) Ú state)))),
‹	second (appl (inp, (0  ..  clear) Ú state)) )
∞

\vfill
\end{slide}
}%\small


% =====================================================================

{\tiny
\begin{slide}{}
\setcounter{slide}{146}
\begin{center}
{\bf Arithmetic Lemmas}
\end{center}
\vfill
=SML
set_pc "z_library_ext";
=TEX
\vfill
=SML
set_goal ([], Òµ x, y : ˙ ∑ x º y ¥ (0 .. x) Ä (0 .. y)Æ);
a (rewrite_tac[z_get_spec Ò(_.._)Æ]
  THEN REPEAT strip_tac);
a (all_fc_tac[z_º_trans_thm]);
val €le_dots_lemma1› = save_pop_thm "le_dots_lemma1";
=TEX
\vfill
=SML
set_goal ([], Òµ x, y : ˙ ∑ ≥ x º y ¥ (0 .. y) Ä (0 .. (x - 1))Æ);
a (rewrite_tac[z_get_spec Ò(_.._)Æ]
  THEN REPEAT strip_tac);
a (all_fc_tac[z_º_less_trans_thm]);
a (POP_ASM_T (ante_tac o pure_once_rewrite_rule
                           [z_get_specÒ(_<_)Æ]));
a (once_rewrite_tac[z_º_º_0_thm]);
a (rewrite_tac[z_µ_elim Ò~ xÆ z_plus_order_thm, z_minus_thm]);
val €le_dots_lemma2› = save_pop_thm "le_dots_lemma2";
=TEX
\vfill
=SML
val €∏_fc_thm› = prove_rule []
  Ò (µ v:U; w:U; V:U; W:U ∑
  v ç V ± w ç W ¥ (v,w) ç (V ∏ W))Æ;
=TEX
\vfill
\end{slide}

% =====================================================================


\begin{slide}{}
\setcounter{slide}{147}
\begin{center}
{\bf Kernel Security Proof}
\end{center}
\vfill
=SML
set_pc "z_sets_alg";
set_goal([],Òkernel_implementation ç secure_kernelÆ);
=GFT ProofPower output
(* ?Ù *)  Òkernel_implementation ç secure_kernelÆ
=TEX

=SML
val €specs› = map (z_defn_simp_rule o z_get_spec)
  [Òsecure_kernelÆ, ÒsecureÆ, Òstate_secureÆ, Òout_secureÆ];
=SML 
a (	rewrite_tac specs
	THEN REPEAT strip_tac);
=TEX
\vfill
=GFT ProofPower output
Tactic produced 6 subgoals:

(* *** Goal "6" *** *)
(*  6 *)  Òappl ç APPLICATIONÆ
(*  5 *)  Òclear ç ÓÆ
(*  4 *)  Òinp ç INÆ
(*  3 *)  Òs ç STATE2Æ
(*  2 *)  Òs' ç STATE2Æ
(*  1 *)  Ò(0 .. clear) Ú s = (0 .. clear) Ú s'Æ

(* ?Ù *)
  Ò(construction (appl, kernel_implementation) (clear, inp, s)).2
 = (construction (appl, kernel_implementation) (clear, inp, s')).2Æ
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{148}
\begin{center}
{\bf A Secure Kernel}
\end{center}
\vfill
=GFT
...
(* *** Goal "4" *** *)
(*  7 *)  Òappl ç APPLICATIONÆ
(*  6 *)  Òclass ç ÓÆ
(*  5 *)  Òclear ç ÓÆ
(*  4 *)  Òinp ç INÆ
(*  3 *)  Òs ç STATE2Æ
(*  2 *)  Òs' ç STATE2Æ
(*  1 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ

(* ?Ù *)  Ò(0 .. class)
                 Ú (construction (appl, kernel_implementation)
                       (clear, inp, s)).1
             = (0 .. class)
                 Ú (construction (appl, kernel_implementation)
                       (clear, inp, s')).1Æ
=TEX
=GFT ProofPower output
...
(* *** Goal "2" *** *)
(*  1 *)  Òappl ç APPLICATIONÆ

(* ?Ù *)  Òconstruction (appl, kernel_implementation) ç SYSTEMÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{149}
=GFT ProofPower output
...
(* *** Goal "1" *** *)
(* ?Ù *)  Òkernel_implementation ç KERNELÆ

The subgoal 2 duplicates goals labelled 3, 5
The subgoal 3 duplicates goals labelled 2, 5
=TEX
=SML
val [€condec›, €conpred›] = strip_±_rule (z_get_spec ÒconstructionÆ);
val [€kidec›, €kipred›] =
      strip_±_rule (z_get_spec Òkernel_implementationÆ);
=GFT ProofPower output
val condec = Ù construction ç
     APPLICATION ∏ KERNEL ≠ SYSTEM : THM
val conpred =
   Ù µ appl : APPLICATION; kernel : KERNEL
       ∑ construction (appl, kernel) = kernel appl : THM

val kidec = Ù kernel_implementation ç KERNEL : THM
val kipred =
...
=TEX
=SML
a (strip_asm_tac kidec);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:
=TEX
\vfill
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{150}
=GFT ProofPower output
(*  1 *)  Òappl ç APPLICATIONÆ

(* ?Ù *)  Òconstruction (appl, kernel_implementation) ç SYSTEMÆ
...
=SML
a (asm_tac kidec THEN asm_tac condec);
a (LEMMA_T
 Ò(appl, kernel_implementation) ç (APPLICATION ∏ KERNEL)Æ
 asm_tac
 THEN1 contr_tac);
=GFT ProofPower output
...
(* 2 *) Òconstruction ç APPLICATION ∏ KERNEL ≠ SYSTEMÆ
(* 1 *) Ò(appl, kernel_implementation) ç APPLICATION ∏ KERNELÆ

(* ?Ù *) Òconstruction (appl, kernel_implementation) ç SYSTEMÆ
...
=SML
a (all_fc_tac [z_fun_ç_clauses]);
=TEX
This discharges the current subgoal.
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:
...
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{151}

=GFT ProofPower output
(*  7 *)  Òappl ç APPLICATIONÆ
...
(*  4 *)  Òinp ç INÆ
...
(*  1 *)  Ò(0 .. class Ú s) = (0 .. class Ú s')Æ

(* ?Ù *) 
  Ò(0 .. class Ú (construction
                    (appl, kernel_implementation)
                       (clear, inp, s)).1)
 = (0 .. class Ú (construction
                    (appl, kernel_implementation)
                       (clear, inp, s')).1)Æ
=TEX
\vfill
=SML
a (strip_asm_tac kidec);
a (ALL_FC_T asm_rewrite_tac [kipred, conpred]);
=GFT ProofPower output
...
(*  8 *)  Òappl ç APPLICATIONÆ
...
(*  2 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
(*  1 *)  Òkernel_implementation ç KERNELÆ

(* ?Ù *)
  Ò(0 .. class) Ú (s ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s)).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
...
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{152}
=SML 
a (cases_tac Òclear º classÆ);
=TEX
\vfill
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "4.2" *** *)
(*  9 *)  Òappl ç APPLICATIONÆ
...
(*  3 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
(*  2 *)  Òkernel_implementation ç KERNELÆ
(*  1 *)  Ò≥ clear º classÆ

(* ?Ù *)
  Ò(0 .. class) Ú (s ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s)).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
a (fc_tac [rewrite_rule[z_get_specÒ˙Æ]
  le_dots_lemma1]);
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{153}
=GFT ProofPower output
...
(* 10 *)  Òappl ç APPLICATIONÆ
...
(*  4 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
(*  3 *)  Òkernel_implementation ç KERNELÆ
(*  2 *)  Òclear º classÆ
(*  1 *)  Ò0 .. clear Ä 0 .. classÆ

(* ?Ù *)
  Ò(0 .. class) Ú (s ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
val set_lemma_1 = pc_rule1 "z_rel_ext" prove_rule []
  Òµ A, B : U; x, x' : U ∑
  A Ä B ¥ (B Ú x) = (B Ú x') ¥ (A Ú x) = (A Ú x')Æ;
a (ALL_FC_T asm_rewrite_tac[set_lemma_1]);
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{154}
=GFT ProofPower output
...
(* 10 *)  Òappl ç APPLICATIONÆ
...
(*  4 *)  Ò(0 .. class Ú s) = (0 .. class Ú s')Æ
...
(*  3 *)  Òkernel_implementation ç KERNELÆ
(*  2 *)  Òclear º classÆ
(*  1 *)  Ò0 .. clear Ä 0 .. classÆ

(* ?Ù *)  
 Ò(0 .. class) Ú (s ´ (0 .. clear - 1) ·
                  (appl (inp, (0 .. clear) Ú s')).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
val set_lemma_2 = pc_rule1 "z_rel_ext" prove_rule[]
 Òµ A : U; x, x', y : U ∑
  A Ú x = A Ú x' ¥ A Ú (x ´ y) = A Ú (x' ´ y)Æ;
a(ALL_FC_T asm_rewrite_tac[set_lemma_2]);
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{155}
\begin{center}
{\bf state secure - second case}
\end{center}

=GFT ProofPower output
(* *** Goal "4.2" *** *)
(*  9 *)  Òappl ç APPLICATIONÆ
...
(*  3 *)  Ò(0 .. class Ú s) = (0 .. class Ú s')Æ
(*  2 *)  Òkernel_implementation ç KERNELÆ
(*  1 *)  Ò≥ (clear º class)Æ

(* ?Ù *)
 Ò (0 .. class) Ú (s ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s)).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
(* *** Goal "4.2" *** *)
val set_lemma_3 = pc_rule1 "z_rel_ext" prove_rule[]
  Òµ A,B:U; x,x':U; st,st':U ∑
  A Ú x = A Ú x' ¥ (A Ä B)
  ¥ A Ú (x ´ (B · st)) = A Ú (x' ´ (B · st'))Æ;
a (FC_T (MAP_EVERY ante_tac)
  [rewrite_rule[z_get_specÒ˙Æ]le_dots_lemma2]
  THEN asm_ante_tac Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
  THEN rewrite_tac [set_lemma_3]);
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{}
\setcounter{slide}{156}
\begin{center}
{\bf The out\_secure Subgoal}
\end{center}

=GFT ProofPower output
(* *** Goal "6" *** *)
(*  6 *)  Òappl ç APPLICATIONÆ
(*  5 *)  Òclear ç ÓÆ
(*  4 *)  Òinp ç INÆ
(*  3 *)  Òs ç STATEÆ
(*  2 *)  Òs' ç STATEÆ
(*  1 *)  Ò(0 .. clear) Ú s = (0 .. clear) Ú s'Æ


(* ?Ù *)
  Ò(construction (appl, kernel_implementation) (clear, inp, s)).2
 = (construction (appl, kernel_implementation) (clear, inp, s')).2Æ
=TEX
\vfill
=SML
a (MAP_EVERY asm_tac [condec, kidec] THEN
  ALL_FC_T asm_rewrite_tac [conpred, kipred]);
=TEX
\vfill
=SML 
val €kernel_secure_thm› = save_thm ("kernel_secure1", pop_thm());
=GFT ProofPower output
val kernel_secure_thm = 
     Ù kernel_implementation ç secure_kernel : THM   
=TEX
\vfill
\end{slide}
}%\tiny

