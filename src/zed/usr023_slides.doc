=IGN
********************************************************************************
usr023_slides.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************

=TEX
% usr023_slides.doc   $Date: 2005/09/21 11:39:16 $ $Revision: 1.25 $ $RCSfile: usr023_slides.doc,v $
% COPYRIGHT (c) Lemma 1 Ltd.

\def\SCCSissue{$Revision: 1.25 $
}


\long\def\ignore#1{}

\newcounter{slidenum}
\setcounter{slidenum}{-1}
\def\Slide{%
\addtocounter{slidenum}{1}
\begin{slide}{\arabic{slidenum}}}

\underscoreoff
\ftlmargin=0.5in
% =====================================================================

\Slide
\vfill
\begin{center}

\vfill

{\huge Proof in Z}\\
with\\
{\huge \bf ProofPower}\\

\vfill

\end{center}

\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Course Objectives}

\end{center}
\vfill

\begin{itemize}
\item
to describe the basic principles and concepts underlying ProofPower support for Z
\item
to enable the student to write simple specifications and undertake elementary proofs in Z using ProofPower
\item
to enable the student to make effective use of the reference documentation for ProofPower-Z
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Course Outline}

\end{center}
\vfill

\begin{itemize}
\item
Introduction to ProofPower-Z

\item
The Z Predicate Calculus

\item
Expressions

\item
Schema Expressions

\item
Paragraphs and Theories

\item
The Z ToolKit

\item
Case Study

\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Course Prerequisites}

\end{center}
\vfill

We assume a working knowledge of:
\begin{itemize}
\vfill
\item
Z as a specification language
\vfill
\item
the use of ProofPower with HOL
\end{itemize}
\vfill
{\small
{\ftlmargin=0.7in \ftrmargin=0.5in
=SML
open_theory "z_library";
new_theory "usr023";
new_parent(hd (get_cache_theories()));
set_pc "z_library";
=TEX
\vfill
πZ
[NAME, DATE]
∞
\vfill
=GFT Z
É[X] ¶ X
=TEX
}%\ftlmargin
}%\small
\vfill
\end{slide}

% =====================================================================

{\ftlmargin=0.7in \ftrmargin=0.5in
\Slide
\begin{center}
{\bf Sample Schemas}
\end{center}
{\small
\vfill
ˇFile¸¸¸¸¸¸¸
‹ people :  NAME;
‹ age : NAME ﬂ DATE
˜¸¸¸¸¸¸¸¸
‹ dom age = people
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFile2¸¸¸¸¸¸¸
‹ people :  NAME;
‹ height : NAME ﬂ ˙
˜¸¸¸¸¸¸¸¸
‹ dom height = people
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFile3¸¸¸¸¸¸¸
‹ people :  NAME
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFileOp¸¸¸¸¸¸¸
‹ File;File'; i?:Ó
à¸¸¸¸¸¸¸¸¸¸
}%\small
\vfill
\end{slide}
}%\ftlmargin

% =====================================================================

\Slide
\begin{center}
{\bf Useful Files}
\end{center}

\begin{itemize}
\item
usr023.dvi - these transparencies for use with previewer.
\item
usr023_slides.doc - transparencies source file.
\item
zed_course_work.doc - exercise ``work book''.
\item
zed_course_answers.doc - solutions to exercises.
\item
sun4example_zed.db - ProofPower database with material loaded in ready to do the exercises.
\end{itemize}

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Reasoning in Z with ProofPower\\
Facilities `lifted' from HOL}
\end{center}

\vfill
\begin{itemize}
\item
Propositional Reasoning
\item
Predicate Calculus:
\begin{itemize}
\item
stripping
\item
forward chaining
\item
resolution (via $prove_tac$)
\end{itemize}
\item
basic rewriting
\item
basic integer arithmetic
\item
arithmetic computations
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Reasoning in Z\\
Areas for Future Enhancement}
\end{center}

\vfill
Function Application
\vfill
`set' inference
\vfill
Conditional Rewriting
\vfill
Consistency Proofs
\vfill
Performance Improvements
\vfill
Ease of Unfolding Definitions
\vfill
Methods which contain complexity
\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}
\vfill

{\bf Some Z Proofs are Easy with ProofPower}
\end{center}

\begin{itemize}
\item
propositional tautologies

{\tiny Propositional reasoning in Z is exactly the same as in HOL, fully automatic and well integrated into the normal proof methods.}

\item
first order predicate calculus

{\tiny As in HOL, predicate calculus proofs in Z are either automatic or routine.}

\item
elementary set theory

{\tiny A useful class of results from elementary set theory are automatically provable.}

\item
other classes of results

{\tiny Whenever a new theory is introduced one or more proof contexts may be developed to solve automatically a range of results in that theory.
``Decision procedures'' for such classes of results can be made available via ``prove_tac''.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================


\Slide
\begin{center}

{\bf Simple Predicate Calculus Proofs}
\end{center}
\vfill
{\small

\begin{itemize}
\item
use the subgoaling package

\item
set the goal

=SML
open_theory"usr023";
set_pc "z_library";
set_goal([],Ò (µx, y:X∑ P x ¥ R y)
	§ (µv, w:X∑ ≥ P w ≤ R v)Æ);
=TEX
\item
initiate proof by contradiction
=SML
a contr_tac;
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
...
(*  5 *)  Ò µ x, y : X ∑ P x ¥ R yÆ
(*  4 *)  Ò v ç XÆ
(*  3 *)  Ò w ç XÆ
(*  2 *)  Ò P wÆ
(*  1 *)  Ò ≥ R vÆ

(* ?Ù *)  Ò falseÆ
=TEX
\item
instantiate assumptions as required
=SML
a (z_spec_asm_tac Ò µ x, y : X ∑ P x ¥ R yÆ
	Ò (x ¶ w, y ¶ v)Æ);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

{\small
\Slide
\vfill
=GFT ProofPower output
Tactic produced 0 subgoals:
(* *** Goal "2" *** *)

(*  5 *)  Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
(*  4 *)  Ò x ç XÆ
(*  3 *)  Ò y ç XÆ
(*  2 *)  Ò P xÆ
(*  1 *)  Ò ≥ R yÆ

(* ?Ù *)  Ò falseÆ
=SML
a (z_spec_asm_tac Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
	Ò (v ¶ y, w ¶ x)Æ);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=SML
pop_thm();
=GFT ProofPower output
Now 0 goals on the main goal stack
val it = Ù (µ x, y : X ∑ P x ¥ R y) §
	(µ v, w : X ∑ ≥ P w ≤ R v) : THM   
=TEX
\vfill
\end{slide}
}%\small

% =====================================================================

\Slide
\begin{center}
{\bf Exercises: 1}
\end{center}

\vfill
Log in;

start Motif Window manager (using {\tt openwin} command);

Select ``Z Course'' from the Root Menu;

Find Exercises 1 in zed_course_work.doc;

Execute the preliminary commands just before the Exercises;

Work through the the exercises recording your solutions in
zed_course_work.doc.

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf The Z Language in ProofPower}

\end{center}

\vfill

{\ftlmargin=0.8in 

\begin{itemize}
\item
HOL terms are used to represent Z.

\item
The ``concrete datatype'' {\bf Z_TERM} reveals\\
the structure of terms representing values in Z.

\item
The function:
=SML
dest_z_term : TERM -> Z_TERM;
=TEX
may be used to disassemble a TERM which represents Z, and
=SML
mk_z_term : Z_TERM -> TERM;
=TEX
may be used to construct a TERM representing a Z construct.
\end{itemize}

}%\ftlmargin

\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Z Language Quotation}
\end{center}
\vfill
\begin{itemize}
\item
{\bf Z Term Quotations}

{\small
Predicates, expressions, and schema expressions may be entered in Z using the Z quotation character ``
=INLINEFT
Ò
=TEX
'', e.g.:
=INLINEFT
 Ò{x:˙ | x>0 ∑ x*x}Æ
=TEX
.
}%\small

\vfill

\item
{\bf Extended Z}

{\small
ProofPower accepts an extended Z language for convenience in formal proof, provided that the system control flag $standard_z_terms$ is set to $false$.
}%\small

\vfill

\item
{\bf Standard Z}

{\small
Eventually we intend ProofPower to be prepared to check fully against the forthcoming Z standard.
}%\small

{\tiny
The norm would then be to check specifications against the standard, but permit the extended language for use in proofs.
}%\tiny

\end{itemize}

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Special Extensions}

\end{center}

\vfill

\begin{itemize}

\item É
=GFT Z
É[X] ¶ X
=TEX
may be used to avoid explicit typing, or to ensure quantification over entire types rather than sets.

\vfill

\item
$∫$, which type checks like $ç$ (and means the same thing).
When used infix $∫$ and its right hand operand are discarded.
It may therefore be used to force the type of an expression without otherwise changing its value.

\vfill

\item
$ê$ which take a single operand and creates a context in which a predicate is required.
ê is discarded after parsing and type-checking.

\end{itemize}

\vfill
\end{slide}

% =====================================================================

\ftlmargin=0in
\Slide
\begin{center}

{\bf The Z Language in ProofPower\\
declarations}

\end{center}

\vfill
{\tiny
=GFT
datatype	€Z_TERM› =

   €ZLVar›	(* local variable Ò xÆ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 | €ZGVar› 	(* global variable Ò É[DATE]Æ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 
 | €ZInt› 	(* positive integer literal Ò 34Æ *)
 		of string
 | €ZString›	(* string literal Ò "characters"Æ *)
 		of string
 
 | €ZDec›		(* declaration, e.g.
   			ëdec_of Ò[x,y:˙]ÆÆ *)
  		of TERM list	(* variables *)
  		* TERM		(* expression *)
 | €ZSchemaDec› 	(* schema reference, e.g.
 			ëdec_of Ò[File!]ÆÆ *)
		of TERM	(*schema expression*)
		* string		(* decoration *)
 | €ZDecl› 	(* declaration list, e.g.
 			ëdecl_of Ò[x,y:˙; File!]ÆÆ *)
		of TERM list	(* declarations *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Local Variables}
\end{center}
\vfill

Used in variable binding constructs (e.g. quantifiers)

Free variables used in proofs of universal assertions, or in using existential assumptions (by `skolemisation').

ProofPower allows `generic' local variables.

\vfill
\begin{center}
{\bf Global Variables (i.e. constants)}
\end{center}
\vfill

These are introduced and constrained by various paragraphs.

Subsequent reasoning relies upon utilisation of predicates explicit or implicit in defining paragraph (see later).

\vfill

\end{slide}

% =====================================================================

\ftlmargin=0.5in
\Slide
\begin{center}
{\bf Integer Literals}
\end{center}

\vfill

Evaluation of arithmetic expressions involving Integer Literals is built into appropriate proof contexts.

\vfill


=SML
rewrite_conv [] Ò543*20Æ;
=GFT ProofPower output
val it = Ù 543 * 20 = 10860 : THM   
=TEX

\vfill

\begin{center}
{\bf String Literals}
\end{center}

\vfill

These are supported by the conversion $z_string_conv$ which converts a string literal into a sequence of HOL character literals:

\vfill

=SML
z_string_conv Ò"string"Æ;
=TEX
=GFT ProofPower output
val it = Ù "string" = 
ß¨`s`Æ, ¨`t`Æ, ¨`r`Æ, ¨`i`Æ, ¨`n`Æ, ¨`g`Æ¢ : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Declarations}
\end{center}

\vfill

Conversion $z_dec_pred_conv$ converts a declaration into its implicit predicate:

\vfill

=SML
val pred2 = z_dec_pred_conv
	(dec_ofÒ[x, y : ˙]Æ);
=GFT ProofPower output
val pred2 = Ù ëdec_ofÒ[x, y : ˙]ÆÆ
	§ {x, y} Ä ˙ : THM   
=TEX

\vfill

\begin{center}
{\bf Declaration Lists}
\end{center}

\vfill

Conversion $z_decl_pred_conv$ converts a declaration list into its implicit predicate:

\vfill

=SML
val pred4 = z_decl_pred_conv
	(decl_ofÒ[x, y : ˙; File!]Æ);
=GFT ProofPower output
val pred4 = Ù ëdecl_ofÒ[x, y : ˙; File!]ÆÆ
  § {x, y} Ä ˙ ± (File!) : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf The Z Language in ProofPower\\
propositional connectives}

\end{center}
\vfill
{\tiny
=GFT
 | €ZTrue›	(* Ò trueÆ *)
 
 | €ZFalse›	(* Ò falseÆ *)
 
 | €Z≥›	(* negation, e.g. Ò ≥ pÆ *)
 	of TERM	(* predicate *)
 
 | €Z±›	(* conjunction, e.g. Ò p ± qÆ *)
 	of TERM * TERM	(* predicates *)
 
 | €Z≤›	(* disjunction, e.g. Ò p ≤ qÆ *)
 	of TERM * TERM	(* predicates *)
 
 | €Z¥›	(* implication, e.g. Ò p ¥ qÆ *)
 	of TERM * TERM 	(* predicates *)
 
 | €Z§›	(* bi-implication, e.g. Ò p § qÆ *)
 	of TERM * TERM 	(* predicates *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Propositional Reasoning
\end{center}
\vfill
{\small
\begin{itemize}
\item assume rule:
=SML
open_theory "usr023";
val thm1 = asm_rule Ò µx, y:Ó∑ x*y > 0Æ;
=GFT ProofPower Output
val thm1 = µ x, y : Ó ∑ x * y > 0
	Ù µ x, y : Ó ∑ x * y > 0 : THM   
=TEX
\item modus ponens
=SML
val thm_a = asm_rule Ò a ∫ ñÆ;
val thm_b = asm_rule Ò a¥bÆ;
=GFT ProofPower Output
val thm_a = a Ù a : THM
val thm_b = a ¥ b Ù a ¥ b : THM   
=SML
val thm_c = ¥_elim thm_b thm_a;
=GFT ProofPower Output
val thm_c = a ¥ b, a Ù b : THM   
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\ftlmargin=0in
\Slide
\begin{center}

{\bf The Z Language in ProofPower\\
quantifiers and relations}

\end{center}
\vfill
{\tiny
=GFT
 | €ZEq›	(* equation, e.g. Ò a = bÆ *)
 		of TERM * TERM	(* expressions *)
 
 
 | €Zç›	(* membership, e.g. Ò a ç bÆ *)
		of TERM * TERM	(* expressions *)


 | €ZSchemaPred›	(* schema predicate, e.g.
 			Ò ê (File ')Æ *)
 		of TERM		(* schema expression *)
 		* string		(* decoration *)

 | €Z∂›	(* existential quantification, Ò ∂ File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)
 
 
 | €Z∂â1›	(* unique existential quantification, Ò ∂â1 File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)

 
 | €Zµ›	(* universal quantification, Ò µ File | p ∑ qÆ *)
		of TERM		(* declaration *)
		* TERM * TERM	(* predicates *)

=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\ftlmargin=0.5in
\Slide
\begin{center}

{\bf Schema Predicates}

\end{center}

\vfill

These are be eliminated in favour of membership statements when rewriting with $z_library$:

\vfill
=SML
once_rewrite_conv[]Ò ê(([x:X])')Æ;
=TEX
=GFT ProofPower outputval
val it = Ù (([x : X])') §
       (x ¶ x') ç [x : X] : THM   
=TEX
\vfill
The proof context $z_library$ which will also eliminate the resulting horizontal schema.
\vfill
=SML
rewrite_conv[]Ò ê(([x:X])')Æ;
=TEX
\vfill
=GFT ProofPower outputval
val it = Ù (([x : X])') §
           x' ç X : THM   
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Reasoning with Quantifiers\\ 
Specialisation (I)
\end{center}
\vfill
\begin{itemize}
\item most commonly a binding display is used
=SML
z_µ_elim Ò (x¶455, y¶32)Æ thm1;
=GFT ProofPower Output
val it = µ x, y : Ó ∑ x * y > 0
 Ù {455, 32} Ä Ó ± true ¥
            455 * 32 > 0 : THM
=TEX
\item any binding expression is acceptable
=SML
z_µ_elim Ò exp∫[x,y:Ó]Æ thm1;
=GFT ProofPower Output
val it = µ x, y : Ó ∑ x * y > 0
  Ù {exp.x, exp.y} Ä Ó ± true
      ¥ exp.x * exp.y > 0 : THM
=TEX
\end{itemize}
\vfill
The signatures of the bindings must match the signature of the declaration exactly.
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Reasoning with Quantifiers 
Specialisation (II)
\end{center}
\vfill
\begin{itemize}
\item where the signature of the declaration contains only a single name an expression which has the same type as that name may be offered:
=SML
z_µ_elim Ò 45Æ z_Ó_≥_plus1_thm;
=GFT ProofPower Output
val it = Ù 45 ç Ó ± true
	¥ ≥ 45 + 1 = 0 : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Goal Oriented Proof}
\end{center}
\vfill
{\small
\begin{itemize}
\item
Works exactly the same as for HOL.
\item
Make sure you are in a Z theory.
\item
Make sure you have a Z proof context.
\item
Terms should be entered using Z quotes
=INLINEFT
Ò Æ
=TEX
.
\end{itemize}
}%\small
\vfill
\begin{center}
\bf Tactics for Quantifiers
\end{center}
\vfill
\begin{itemize}
\item
$z_strip_tac$:
{\small
\begin{itemize}
\item
eliminates outer universals in conclusions
\item
skolemises existential assumptions
\item
pushes in outer negations over universal conclusions
\item
pushes in outer negations over existential assumptions
\end{itemize}
}%\small
\item
$z_spec_nth_asm_tac$:

specialises universal assumptions
\item
$z_∂_tac$

eliminates existential conclusions
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Rewriting}
\vfill

Use same facilities as for HOL in appropriate proof contexts.

Most rewrites arising from axiomatic descriptions are effectively conditional, and the conditions must be discharged to achieve the rewrite.

Forward chaining is often an appropriate way to achieve such conditional rewriting. 

\vfill
{\bf Chaining}
\vfill

In appropriate proof contexts forward chaining facilities with $all$ in name work and stay in Z.
Other variants are liable to introduce hol universals.
\vfill
\end{center}

\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Rewriting by Chaining - example}
\end{center}
\vfill
{\small
$z_abs_thm$ is :
=GFT
Ù µ i : Ó ∑ abs i = i ± abs ~ i = i
=TEX
Which, because quantified over $Ó$, is effectively a $conditional$ rewrite.
\vfill
The proof of:
\vfill
=SML
set_goal([],Òµ a : Ó ∑ (abs a)*(abs ~a) = a*aÆ);
=TEX
is therefore complicated by the need to establish the necessary conditions for rewriting with $z_abs_thm$.
\vfill

First we strip the goal:
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
(*  1 *)  Ò0 º aÆ

(* ?Ù *)  Òabs a * abs ~ a = a * aÆ
=TEX
Which places the necessary information in the assumptions.
}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Rewriting by Chaining - example continued}
\end{center}
\vfill
{\small

Then we use forward chaining to establish unconditional equations:
\vfill
=SML
a (all_fc_tac [z_abs_thm]);
=GFT ProofPower output
(*  3 *)  Ò0 º aÆ
(*  2 *)  Òabs a = aÆ
(*  1 *)  Òabs ~ a = aÆ

(* ?Ù *)  Òabs a * abs ~ a = a * aÆ
=TEX
\vfill
Then rewrite with these equations:
\vfill
=SML
a (asm_rewrite_tac[]);
pop_thm();
=TEX
(which solves the goal)
\vfill
}%\small
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Exercises 2: Predicate Calculus
\end{center}

\vfill
Try Exercises 2 in zed_course_work.doc.
\vfill
Hints and further exercises may be found in section 7.1 of
the Z Tutorial Manual.
\vfill

\end{slide}


% =====================================================================

\ftlmargin=0in
\Slide
\begin{center}

{\bf The Z Language in ProofPower\\
expressions}

\end{center}

\vfill

{\tiny
=GFT
 | €ZApp›	(* function application  Ò f xÆ  *)
 		of TERM * TERM	(* expressions *)
 | €ZÃ›	(* lambda expression Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
 		* TERM	(* expression *)
 | €ZÕ›	(* definite description Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
		* TERM	(* expression *)
 | €ZLet›	(* let expression Ò let x ¶ 9 ∑ (x, x+x) Æ *)
 		of (string * TERM) list	(* local definitions *)
 		* TERM	(* expression *)
 | €Z›	(* power set construction, Ò  ˙Æ *)
 	of TERM		(* expression *)
 | €ZSetd›	(* set display, Ò {1,2,3,4} Æ *)
 	of TYPE		(* HOL type of elements *)
 	* TERM list	(* expressions *)
 | €ZSeta›	(* set abstraction, Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
 	of TERM	(* declaration *)
 	* TERM	(* predicate *)
 	* TERM	(* expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf The Z Language in ProofPower\\
expressions (continued)}

\end{center}

\vfill

{\tiny
=GFT
 | €ZTuple›	(* tuple displays, Ò (1,2,3,4) Æ *)
 	of TERM list	(* expressions *)
 | €ZSelât›	(* tuple element selection, Ò (x,y).2Æ *)
 	of TERM	(* expression *)
 	* int		(* element number *)
 | €Z∏›	(* cartesian product, Ò (˙ ∏ Ó) Æ *)
 	of TERM list	(* expressions *)
 | €ZBinding› (* binding displays Ò (people ¶ {}, age ¶ {}) Æ *)
 	of (	string	(* component name *)
 		* TERM	(* component value *)
 		) list
 | €Z ›	(* theta term Ò  File' Æ *)
 	of TERM	(* schema expression *)
 	* string	(* decoration *)
 | €ZSelâs›	(* binding component selection Ò (a ¶ 1, b ¶ "4").b Æ *)
 	of TERM	(* expression *)
 	* string	(* component name *)
 | €Zâs›	(* horizontal schema expression
 		Ò [x:˙ | x>0] Æ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
 | €Zß¢›	(* sequence display Ò ß1,2,3¢ Æ *)
 	of TYPE	(* type of elements *)
 	* TERM list	(* values of elements *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================
\ftlmargin=0.5in
{\small
% =====================================================================

\Slide
\begin{center}

{\bf Function Application (I)}

\end{center}

{\small
\vfill

Applications of lambda abstractions can be eliminated by (conditional) ¬-conversion.

=SML
z_¬_conv Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower outputval
val it = P a, a ç X Ù
	(Ã x : X | P x ∑ f x) a = f a : THM   
=TEX
\vfill

Other applications may be eliminated in favour of definite descriptions.

=SML
z_app_conv Ò f aÆ;
=GFT ProofPower output
val it = Ù f a = Õ f_a : É
	| (a, f_a) ç f ∑ f_a : THM   
=TEX

More commonly function applications will be eliminated by rewriting with their definitions.

}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Function Application (II)}

\end{center}

\vfill
For low level reasoning $z_app_eq_tac$ is useful:
=SML
set_goal([],Ò f a = vÆ);
a z_app_eq_tac;
=GFT ProofPower output
...
(* ?Ù *) Ò(µ f_a : É | (a, f_a) ç f ∑ f_a = v)
  ± (a, v) ç fÆ
...
=TEX
Here the first conjunct expresses the requirement that $f$ is functional at $a$.

If f is known to be a function this fact may be used more directly with the assistance of the theorem $z_fun_app_clauses$:
=GFT
val z_fun_app_clauses =
  Ù µ f : É; x : É; y : É; X : É; Y : É
    ∑ (f ç X ﬂ Y
          ≤ f ç X ˛ Y
          ≤ f ç X œ Y
          ≤ f ç X ≠ Y
          ≤ f ç X ‡ Y
          ≤ f ç X Ô Y
          ≤ f ç X è Y)
        ± (x, y) ç f
      ¥ f x = y : THM
=TEX

Which is most conveniently appplied using forward chaining.
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Function Application (III)}

\end{center}

{\tiny
\vfill
=SML
drop_main_goal();
set_goal([], Òf ç Ó Ô ˙ ¥
    (4, ~45) ç f ¥ f 4 = ~45Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
(*  2 *)  Òf ç Ó Ô ˙Æ
(*  1 *)  Ò(4, ~ 45) ç fÆ

(* ?Ù *)  Òf 4 = ~ 45Æ
=TEX
\vfill
=SML
a (all_fc_tac [z_fun_app_clauses]);
pop_thm();
=TEX
\vfill
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\vfill

Often it is necessary to establish that a function application is a member of a set.

The theorem $z_fun_ç_clauses$ is of assistance in such cases:
=GFT
val z_fun_ç_clauses = Ù
 µ f : É; x : É; X : É; Y : É
 ∑ ((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
    ± x ç X ¥ f x ç Y)
 ± ((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
     ± x ç dom f ¥ f x ç Y) : THM
=TEX
\vfill
}%\tiny
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Function Application (IV)}
\end{center}
This too is best applied using forward chaining:
=SML
set_goal([],
 Ò[X](µ b: bag X∑ count[X] b ç X ≠ Ó)Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
(*  1 *)  Òb ç bag XÆ

(* ?Ù *)  Òcount[X] b ç X ≠ ÓÆ
=TEX
We need the information from the declaration of $count$:
=SML
a (strip_asm_tac (z_gen_pred_elim
   [ÒXÆ] (z_get_spec ÒcountÆ)));
=GFT ProofPower output
(*  3 *)  Òb ç bag XÆ
(*  2 *)  Òcount[X] ç bag X è X ≠ ÓÆ
...
(* ?Ù *)  Òcount[X] b ç X ≠ ÓÆ
=TEX
Now we can forward chain:
=SML
a (all_fc_tac [z_fun_ç_clauses]);
val bag_lemma1 = pop_thm ();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Lambda Abstraction}

\end{center}

\vfill

For extensional reasoning:

=SML
rewrite_conv [] Òz ç (Ã x:X | P x ∑ f x)Æ;
=TEX
=GFT ProofPower outputval
val it = Ù z ç Ã x : X | P x ∑ f x §
	z.1 ç X ± P z.1 ± f z.1 = z.2 : THM   
=TEX

Lambda abstractions may be transformed into set abstractions.

=SML
z_Ã_conv Ò Ã x:X | P x ∑ f xÆ;
=GFT ProofPower outputval
val it = Ù Ã x : X | P x ∑ f x =
	{x : X | P x ∑ (x, f x)} : THM   
=TEX

\vfill
\end{slide}

% =====================================================================

\Slide
\vfill

\begin{center}

{\bf Definite Description}

\end{center}

\vfill
=SML
z_Õ_rule Ò Õ x:X | P ∑ y Æ;
=GFT ProofPower output
val it = Ù µ x' : É
    ∑ (µ x : X | P ∑ y = x')
    ± (∂ x : X | P ∑ y = x')
      ¥ (Õ x : X | P ∑ y) = x' : THM
=TEX
\vfill

\begin{center}

{\bf Let Expression}

\end{center}

\vfill
=SML
z_let_conv Ò let x ¶ 9 ∑ (x, x + x) Æ;
=GFT ProofPower output
val it = Ù
	(let x ¶ 9 ∑ (x, x + x)) = (9, 9 + 9) : THM
=TEX
\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf The Power Set Constructor}

\end{center}

\vfill

=SML
z_ç__conv Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y §
	(µ x1 : É ∑ x1 ç z ¥ x1 ç y) : THM   
=TEX

\vfill

=SML
rewrite_conv[] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § z Ä y : THM   
=TEX

\vfill

=SML
rewrite_conv[z_Ä_thm] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y
	§ (µ x : É ∑ x ç z ¥ x ç y) : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Set Displays}

\end{center}

\vfill

{\small
\begin{itemize}
\item
sets may be entered as terms by enumeration:
=SML
rewrite_conv [] Ò 5 ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù 5 ç {1, 2, 3, 4, 5} § true : THM
=TEX

\vfill

=SML
rewrite_conv [] Ò x ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù x ç {1, 2, 3, 4, 5} §
 x = 1 ≤ x = 2 ≤ x = 3 ≤ x = 4 ≤ x = 5 : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Set Abstractions}

\end{center}

\vfill
{\small
\begin{itemize}
\item
sets may also be entered as set abstractions:
=SML
rewrite_conv[] Ò 9 ç {x:Ó | x < 12}Æ;
=GFT ProofPower output
val it =
Ù 9 ç {x : Ó | x < 12} § 9 ç Ó ± 9 < 12 : THM   
=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y}
 § {z.1, z.2} Ä Ó ± z.1 < z.2 : THM   
=TEX
=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y ∑ x * y - x}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y ∑ x * y - x}
    § (∂ x, y : Ó | x < y ∑ x * y - x = z) : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

{\small
\Slide
\begin{center}

{\bf Tuples}

\end{center}

\vfill

=SML
rewrite_conv[] Ò (x,y) = (a,b)Æ;
=GFT ProofPower output
val it = Ù (x, y) = (a, b)
	§ x = a ± y = b : THM   
=TEX

\vfill

=SML
rewrite_conv[] Ò (x,y).1Æ;
=GFT ProofPower output
val it = Ù (x, y).1 = x : THM   
=TEX

\vfill

\begin{center}

{\bf Bindings}

\end{center}

\vfill

=SML
rewrite_conv[]
	Ò (x ¶ a, y ¶ b) = (y ¶ d, x ¶ c)Æ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) = (x ¶ c, y ¶ d)
	§ a = c ± b = d : THM   
=TEX

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf Cartesian Products}

\end{center}

\vfill
=SML
rewrite_conv[] Ò (a, b) ç (x ∏ y)Æ;
=GFT ProofPower output
val it = Ù (a, b) ç x ∏ y
	§ a ç x ± b ç y : THM   
=TEX

=SML
rewrite_conv[z_sets_ext_thm]
	Ò (x ∏ y) = (a ∏ b)Æ;
=GFT ProofPower output
it = Ù x ∏ y = a ∏ b
	§	(µ z : É ∑ z.1 ç x ± z.2 ç y
    		§ z.1 ç a ± z.2 ç b) : THM
=TEX
\vfill

\begin{center}

{\bf Theta Terms}

\end{center}
\vfill

=SML
z_ _conv Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' =
  (age ¶ age', people ¶ people') : THM   
=SML
rewrite_conv[z' _def] Ò  File'Æ;
=GFT ProofPower output
val it = Ù  File' =
  (age ¶ age', people ¶ people') : THM   
=TEX
\vfill

\end{slide}


% =====================================================================

\Slide
\begin{center}

{\bf Binding Component Selection}

\end{center}

\vfill
Projection from binding displays is built in to proof context $z_language$.
\vfill

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM   
=TEX
\vfill

Projection from theta terms is also built in to proof context $z_language$.
\vfill
=SML
rewrite_conv[] Ò ( File').ageÆ;
=GFT ProofPower output
val it = Ù ( File').age = age' : THM   
=TEX
\vfill

\end{slide}


% =====================================================================

\Slide
\begin{center}

{\bf Horizontal Schemas}

\end{center}

\vfill
=SML
rewrite_conv[]Òz ç [x:˙;y:Ó]Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç [x : ˙; y : Ó]
	§ z.x ç ˙ ± z.y ç Ó : THM   
=TEX
\vfill
=SML
rewrite_conv[]Ò(x ¶ a, y ¶ b) ç [x:˙;y:Ó]Æ;
=TEX

=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) ç [x : ˙; y : Ó]
	§ a ç ˙ ± b ç Ó : THM   
=TEX

\vfill

\begin{center}
{\bf Sequence Displays}
\end{center}

\vfill

=SML
z_ß¢_conv Òßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù ßa, b, c¢ = {(1, a), (2, b), (3, c)} : THM   
=TEX

\vfill
=SML
once_rewrite_conv[]Òz ç ßa,b,c¢Æ;
=TEX

=GFT ProofPower output
val it = Ù z ç ßa, b, c¢ §
	z ç {(1, a), (2, b), (3, c)} : THM   
=TEX
\vfill

\end{slide}


% =====================================================================

\Slide

{\normalsize
\begin{center}
{\bf Exercises 3: Expressions}
\end{center}

\vfill
Try Exercises 3 in zed_course_work.doc.
\vfill
Hints and further exercises may be found in section 7.2.1  of
the Z Tutorial Manual.
\vfill
}%\normalsize
\end{slide}

% =====================================================================

\ftlmargin=0in
\Slide
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (I)}

\end{center}

\vfill

{\tiny
=GFT
 | €Z≥âs›	(* schema negation Ò(≥ File)∫ÉÆ *)
		of TERM (* schema expression *)
 | €Z±âs›	(* schema conjunction Ò(File ± File2)∫ÉÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z≤âs›	(* schema disjunction Ò(File ≤ File2)∫ÉÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z¥âs›	(* schema implication Ò(File ¥ File2)∫ÉÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z§âs›	(* schema equivalence Ò(File § File2)∫ÉÆ *)
		of TERM * TERM (* schema expressions *)
 | €Z∂âs›	(* schema existential
 		Ò(∂ File3 | people = {} ∑ File2)∫ÉÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
 | €Z∂â1âs›	(* schema unique existential
 		Ò(∂â1 File3 | people = {} ∑ File2)∫ÉÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
 | €Zµâs›	(* schema universal
 		Ò(µ File3 | people = {} ∑ File2)∫ÉÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (II)}

\end{center}

\vfill

{\tiny
=GFT
 | €ZDecorâs› (* decoration Ò File ''Æ *)
 		of TERM	(* schema expression *)
 		* string	(* decoration *)
 | €ZPreâs›	(* pre-condition Ò pre FileOpÆ *)
 		of TERM	(* schema expression *)
 | €ZHideâs›	(* schema hiding Ò FileOp \âs (age, i?)Æ  *)
 		of TERM	(* schema expression *)
 		* string list	(* component names *)
 | €ZRenameâs› (* schema renaming
 			ÒFile [aged/age, input/i?]Æ *)
 		of TERM	(* schema expression *)
 		* (string * string) list	(* rename list *)
 | €Z˘âs›	(* schema projection ÒFileOp ˘âs FileÆ*)
 		of TERM * TERM	(* schema expressions *)
 | Zªâs	(* schema composition ÒÑFile ªâs ÑFileÆ *)
 		of TERM * TERM	(* schema expressions *)
 | €ZÑâs›	(* delta operation ÒÑFileÆ *)
 		of TERM	(* schema expression *)
 | €Zòâs›	(* ò operation ÒòFileÆ *)
 		of TERM	(* schema expression *)
;
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================
\Slide
\begin{center}
{\bf Schema Negation}
\end{center}

\vfill
Return to theory where we defined schema $File$:

=SML
open_theory "usr023";
set_pc "z_language";
=TEX
=SML
rewrite_conv[]Òz ç (≥ File)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (≥ File) § ≥ z ç File : THM   
=TEX

\vfill

\begin{center}
{\bf Schema Conjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ± File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ± File2) §
 (age ¶ z.age, people ¶ z.people) ç File ±
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\Slide
\begin{center}
{\bf Schema Disjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ≤ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ≤ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ≤
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Implication}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ¥ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ¥ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ¥
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill


\end{slide}
% =====================================================================
\Slide
\begin{center}
{\bf Schema Equivalence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File § File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File § File2) §
 (age ¶ z.age, people ¶ z.people) ç File §
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Existential}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂ File3 | people = {} ∑ File2) §
 (∂ x1 : É ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\Slide
\begin{center}
{\bf Schema Unique Existence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂â1 File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂â1 File3 | people = {} ∑ File2) §
 (∂â1 x1 : É ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\begin{center}
{\bf Schema Universal}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (µ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (µ File3 | people = {} ∑ File2) §
 (µ x1 : É
 ∑ (people ¶ x1.people) ç File3 ± x1.people = {}
   ¥ (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\Slide

\begin{center}
{\bf Decoration}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç File ''Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File'')	§
 (age ¶ z.age'', people ¶ z.people'') ç File : THM
=TEX

\vfill

\begin{center}
{\bf Pre-Condition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (pre FileOp)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (pre FileOp) §
 z ç	[age : É; i? : É; people : É
	| ∂ age' : É; people' : É ∑ FileOp] : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\Slide


\begin{center}
{\bf Schema Hiding}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age)) §
	z ç [people : É | ∂ age : É ∑ File] : THM
=TEX

\vfill
=SML
rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age))
    § (∂ age : É ∑
    	(age ¶ age, people ¶ z.people) ç File) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\Slide

\begin{center}
{\bf Schema Renaming}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç File[aged/age]Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File [aged/age]) §
	(age ¶ z.aged, people ¶ z.people) ç File : THM
=TEX

\vfill

\begin{center}
{\bf Schema Projection}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ˘âs File)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ˘âs File)
    § z ç ((FileOp ± File) \âs (age', i?, people')) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\Slide

\begin{center}
{\bf Schema Composition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § z
      ç [age : É; i? : É; people : É; age' : É; people' : É
        | ∂ x1 : É; x2 : É
          ∑ (age ¶ age, age' ¶ x1, i? ¶ i?,
          		people ¶ people, people' ¶ x2)
              ç FileOp
            ± (age ¶ x1, age' ¶ age', i? ¶ i?, people ¶ x2,
                  people' ¶ people')
              ç FileOp] : THM
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================
\Slide

\begin{center}
{\bf Delta}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (ÑFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (Ñ File) §
	z ç [File; File'] : THM   
=TEX

\vfill
\begin{center}
{\bf Xi}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (òFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (ò File) §
	z ç [File; File' |  File =  File'] : THM   
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================

\ftlmargin=0in
\Slide
\begin{center}
{\bf Exercises 4: Schema Expressions}
\end{center}
\vfill
Try Exercises 4 in zed_course_work.doc.
\vfill
Hints and further exercises may be found in sections 7.2.2 and 7.2.3  of
the Z Tutorial Manual.
\vfill
The exercises show that these operators behave in similiar ways to the predicate calculus versions, and that reasoning is largely automatic.
\vfill
Entering the goals is tricky because the parser prefers the predicate calculus interpretation of the connectives.
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Z Paragraphs}
\end{center}
\vfill
\begin{itemize}
\item
Fixity declarations
\item
Given sets
\item
Abbreviation definitions
\item
Schema boxes
\item
Axiomatic descriptions
\item
Generics
\item
Free types
\item
Constraints
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Z Paragraphs\\
Paragraph Processing Modes and Flags}
\end{center}
\vfill
{\small
There are several different modes of processing Z paragraphs which are controlled by flags.

\begin{itemize}
\item
{\bf Type-checking Mode}

If the flag $z_type_check_only$ is set to $true$ then only type checking of Z paragrpahs is performed.

{\tiny
This makes the response faster, and permits greater flexibility in amending paragraphs.
This mode is suitable for use while developing specifications prior to undertaking any proof work.
}

\item
{\bf Axiomatic Mode}
 
If the flag $z_use_axioms$ is set to true (and\\
$z_type_check_only$ is set to $false$) then axiomatic descriptions and free-type descriptions are introduced using axioms.


\item
{\bf Conservative Mode}

If both the above flags is set $false$ then all Z axiomatic descriptions are introduced using the ProofPower\\
$new_specification$ facility, i.e. by conservative extension.

{\tiny
Consistency proof obligations, unless discharged automatically, will have to be discharged by the user.

In a future release it is hoped that free-types will also be supported by conservative extension.
}%\tiny

\end{itemize}

}%\small
\vfill
\end{slide}

% =====================================================================

\ignore{
=SML
open_theory "usr023"; 
set_pc "z_library";
=TEX
}%\ignore

\Slide
\vfill
\begin{center}
{\bf Fixity Declarations}
\end{center}
Fixity declarations may be provided for:
\vfill
{\small
\begin{itemize}
\item
functions
πZ
fun 10 twice _
∞
πZ
fun  select ... from _
∞
\item
generics
πZ
gen _ swap _
∞
\item
relations
πZ
rel  _ is_even 
∞
\end{itemize}

\vfill

The optional numeric value is a priority.

`_' is a space for a parameter\\
`...' is a space for a sequence of parameters (with sequence brackets elided)

Fixity clauses can only be deleted by deleting the theory they are contained in.

}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Given Sets}
\end{center}

\vfill

πZ
[G1, G2]
∞

\vfill

=SML
val G1_def = z_get_spec ÒG1Æ;
=GFT ProofPower output
val G1_def = Ù G1 = É : THM   
=TEX

\vfill

=SML
rewrite_conv [G1_def] Òx ç G1Æ;
=GFT ProofPower output
val it = Ù x ç G1 § true : THM   
=TEX

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Abbreviation Definitions}
\end{center}

{\small
\vfill
=SML
val _ = set_flag("z_type_check_only", false);
=TEX

πZ
X swap Y ¶ Y ∏ X 
∞

\vfill

=SML
val swap_def = z_get_spec Ò(_ swap _)Æ;
=GFT ProofPower Output
val swap_def =
Ù [X, Y](X swap Y = Y ∏ X) : THM   
=TEX

\vfill

=SML
rewrite_conv [swap_def] Ò˙ swap ÓÆ;
=TEX
=GFT ProofPower Output
val it = Ù ˙ swap Ó = Ó ∏ ˙ : THM   
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Schema Boxes}
\end{center}
\vfill
{\small
ˇSch¸¸¸¸¸¸¸¸¸¸¸¸
‹	x, y : ˙;
‹	z : Ó
˜¸¸¸¸¸¸¸¸¸
‹	x = y ≤ y = z
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
val sch_def = z_get_spec ÒSchÆ;
=GFT ProofPower Output
val sch_def = Ù Sch =
  [x, y : ˙; z : Ó | x = y ≤ y = z] : THM   
=TEX
=SML
rewrite_conv [sch_def]
 Òµ x,y:˙; z:Ó ∑ Sch ≤ disjoint ß{x},{y},{z}¢Æ;
=TEX
=GFT ProofPower Output
val it = Ù (µ x, y : ˙; z : Ó ∑ Sch
		≤ disjoint ß{x}, {y}, {z}¢)
    § (µ x, y : ˙; z : Ó
      ∑ [x, y : ˙; z : Ó | x = y ≤ y = z]
      	≤ disjoint ß{x}, {y}, {z}¢) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Generic Schema Boxes}
\end{center}
\vfill
{\small
ˇDSUBS[X]¸¸¸¸¸¸¸¸¸¸¸
‹	set1, set2:  X
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	set1 ° set2 = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
=SML
val dsubs_def = z_get_spec ÒDSUBSÆ;
=GFT ProofPower Output
val dsubs_def = Ù [X](DSUBS[X] =
  [set1, set2 :  X | set1 ° set2 = {}]) : THM
=TEX
\vfill
=SML
rewrite_conv [dsubs_def]
       Òµ DSUBS[Ó] ∑ set1 Ä Ó ± set2 Ä ÓÆ;
=GFT ProofPower Output
val it = Ù (µ (DSUBS[Ó]) ∑ set1 Ä Ó ± set2 Ä Ó)
	§ (µ [set1, set2 :  Ó | set1 ° set2 = {}] ∑
		set1 Ä Ó ± set2 Ä Ó) : THM
=TEX
\vfill

}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Axiomatic Descriptions}
\end{center}
\vfill
{\small
πZAX
‹	twice _ : ˙ ≠ ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	µi : ˙ ∑ twice i = 2*i
∞
\vfill
=SML
val twice_def = z_get_spec Ò(twice _)Æ;
=GFT ProofPower Output
val twice_def = Ù (twice _) ç ˙ ≠ ˙
	± (µ i : ˙ ∑ twice i = 2 * i) : THM   
=TEX
\vfill
\ignore{
=SML
set_flag("use_file_non_stop_mode",true);
=TEX
}
=SML
rewrite_conv[twice_def] Òtwice 4Æ;
=GFT ProofPower Output
Exception- Fail * no rewriting occurred
=TEX
\ignore{
=SML
set_flag("use_file_non_stop_mode",false);
=TEX
}
\vfill
=SML
set_goal([],Òµ n:˙ ∑ twice n = 2*nÆ);
a (REPEAT z_strip_tac);
=GFT ProofPower Output
(* *** Goal "" *** *)
(*  1 *)  Òn ç ˙Æ
(* ?Ù *)  Òtwice n = 2 * nÆ
=TEX
\vfill
=SML
a (fc_tac [twice_def]);
=GFT ProofPower Output
Current and main goal achieved
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Generic Axiomatics}
\end{center}
\vfill
{\small
ù[X,Y,Z]úúúúúúúúúúúúúúúúúúúúúúúú
‹ select ... from _ : (X ™ Y) ∏ (Y ™ Z) ≠ (Y ™ Z)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ indexed_set:(X ™ Y); relation:(Y ™ Z) ∑
‹
‹     (select ... from _) (indexed_set, relation)
‹     = (ran indexed_set) Ú relation
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

\vfill
=GFT ProofPower output
val select_from_def = Ù [X, Y, Z](
 (select ... from _)[X, Y, Z]
    ç (X ™ Y) ∏ (Y ™ Z) ≠ Y ™ Z
 ±
 (µ indexed_set : X ™ Y; relation : Y ™ Z∑
     (select ... from _)[X, Y, Z] (indexed_set, relation)
     = ran indexed_set Ú relation)) : THM
=TEX
\vfill
}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Free Types}
\end{center}
\vfill

{\small
πZ
TREE ::= tip | fork (Ó ∏ TREE ∏ TREE)
∞
\vfill

=SML
val tree_def = z_get_spec ÒTREEÆ;
=GFT ProofPower Output
val tree_def = Ù TREE = É : THM   
=TEX

\vfill

=SML
val tip_def = z_get_spec ÒtipÆ;
=GFT ProofPower Output
val tip_def = Ù (
   tip ç TREE
 ± fork ç Ó ∏ TREE ∏ TREE ‡ TREE)
 
 ± disjoint ß{tip}, ran fork¢
 
 ± (µ W :  TREE |
   {tip} ¿ fork ® Ó ∏ W ∏ W © Ä W∑
	TREE Ä W) : THM
=TEX


}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Mutually Recursive Free Types}
\end{center}
\vfill

{\small

πZ
TYPE ::= Tvar G1 | Tcon (G1 ∏ seq TERM)
&
TERM ::= Con (G1 ∏ TYPE) | App (TERM ∏ TERM)
∞

\vfill

=SML
val tvar_def = z_get_spec ÒTvarÆ;
=GFT ProofPower Output
val tvar_def = Ù (
      Tvar ç G1 ‡ TYPE
    ± Tcon ç G1 ∏ (seq TERM) ‡ TYPE
    ± Con ç G1 ∏ TYPE ‡ TERM
    ± App ç TERM ∏ TERM ‡ TERM)
    
    ± (disjoint ßran Tvar, ran Tcon¢
    
    ± (µ W :  TYPE
      | Tvar ® G1 © ¿ Tcon ® G1 ∏ (seq TERM) © Ä W
      ∑ TYPE Ä W))
      
    ± disjoint ßran Con, ran App¢
    
    ± (µ W :  TERM
      | Con ® G1 ∏ TYPE © ¿ App ® W ∏ W © Ä W
      ∑ TERM Ä W) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Constraints}
\end{center}
\vfill

{\small

πZ
[X] ((∂f : X ‡ G1 ∑ true)
	§ (∂f : X ‡ G2 ∑ true))
∞

\vfill

=SML
val c1 = get_axiom "-" "Constraint 1";
=GFT ProofPower output
val c1 = Ù [X]((∂ f : X ‡ G1 ∑ true) §
		(∂ f : X ‡ G2 ∑ true)) : THM   
=TEX

\vfill

πZ
 {1} swap {ß1¢} = {ß1¢} ∏ {1}
 	± Sch Ω [x, y, z : ˙] 
∞

\vfill

πZ
 tip Ω fork(2, tip, tip) ±
 tip ç TREE
∞

\vfill

}%\small
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Theories}
\end{center}
\vfill
Z Theories contain the following information:
\begin{itemize}
\item
The theory name and the names of the theories parents and children.
\item
The names of types (given sets) declared in the theory.
\item
The names and types of `global variables' declared in the theory.
\item
Fixity information.
\item
Axioms or specifications corresponding to the paragraphs of the Z specification introduced in this theory.
\item
A collection of saved theorems.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Access to Z Theories}
\end{center}
\vfill
\begin{itemize}
\item
To use a theory it must be ``in context'', this can be achieved be opening the theory or one of its descendents:
=SML
open_theory : string -> unit;
=TEX
\item
To display the contents of a theory:
=SML
z_print_theory : string -> unit;
=TEX
\item
To get things from the theory:
{\small
=SML
get_aliases; get_ancestors; get_axiom; get_axioms;
get_children; get_consts; get_defn;
get_defns; get_descendants; get_parents; get_thm;
get_thms; z_get_spec;
=TEX
}%\small
\item
To save things in the theory use Z paragraphs.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
{\bf Exercises 5:  Paragraphs and Theories}
\end{center}
\vfill
Try Exercises 5 in zed_course_work.doc.
\vfill
Hints and further exercises may be found in section 7.3  of
the Z Tutorial Manual.
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf The Z ToolKit
\end{center}
\vfill
{\small
Available as a set of six theories.
\vfill
To get the Z ToolKit in context make $z_library$ a parent.
\vfill
The theories are:
\vfill
\begin{itemize}
\item $z_sets$
\item $z_relations$
\item $z_functions$
\item $z_numbers$
\item $z_sequences$
\item $z_bags$
\end{itemize}
\vfill
These definitions have been entered in axiomatic mode.
\vfill
}%\small
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Sets and Relations
\end{center}
\vfill
\begin{itemize}
\item
Recommended proof context: $z_rel_ext$.
\vfill
\item
High rate of automatic proof of lemmas in these theories.
\vfill
\item
Automatic proof fails if actual generic parameters are supplied.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

{\tiny

\Slide

{\normalsize
\begin{center}
\bf A Sample Proof About Sets (I)
\end{center}

\vfill

=SML
set_pc "z_library_ext";
set_goal([],Òa ° (b \ c) = (a ° b) \ cÆ);
a z_strip_tac;
=TEX
}%\normalsize

\vfill

=GFT ProofPower output
(* ?Ù *)  Òµ x1 : É ∑ x1 ç a ° (b \ c) § x1 ç a ° b \ cÆ
=SML
a z_strip_tac;
=GFT ProofPower output
(* ?Ù *)  Òx1 ç É ± true ¥ (x1 ç a ° (b \ c) § x1 ç a ° b \ c)Æ
=TEX
\vfill
continuing only using $z_strip_tac$ as follows:
\vfill
=GFT ProofPower output
(* ?Ù *)  Òx1 ç a ° (b \ c) § x1 ç a ° b \ cÆ
=TEX
\vfill
=GFT ProofPower output
(* ?Ù *)  Ò(x1 ç a ° (b \ c) ¥ x1 ç a ° b \ c)
             ± (x1 ç a ° b \ c ¥ x1 ç a ° (b \ c))Æ
=TEX
\vfill
=GFT ProofPower output
(* *** Goal "2" *** *)
(* ?Ù *)  Òx1 ç a ° b \ c ¥ x1 ç a ° (b \ c)Æ

(* *** Goal "1" *** *)
(* ?Ù *)  Òx1 ç a ° (b \ c) ¥ x1 ç a ° b \ cÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide

{\normalsize
\begin{center}
\bf A Sample Proof About Sets (II)
\end{center}
}%\normalsize

\vfill
=GFT ProofPower output
(*  3 *)  Òx1 ç aÆ
(*  2 *)  Òx1 ç bÆ
(*  1 *)  Ò≥ x1 ç cÆ

(* ?Ù *)  Òx1 ç a ° b \ cÆ
=TEX
\vfill
=GFT ProofPower output
...
(* ?Ù *)  Òx1 ç a ° b ± x1 é cÆ
=TEX
\vfill

=GFT ProofPower output
(* *** Goal "1.2" *** *)
...
(* ?Ù *)  Òx1 é cÆ

(* *** Goal "1.1" *** *)
...
(* ?Ù *)  Òx1 ç a ° bÆ
=TEX
\vfill
=GFT ProofPower output
(* *** Goal "1.1" *** *)
...
(* ?Ù *)  Òx1 ç a ± x1 ç bÆ
=TEX
\vfill

=GFT ProofPower output
(* *** Goal "1.1.2" *** *)
(* ?Ù *)  Òx1 ç bÆ

(* *** Goal "1.1.1" *** *)
(* ?Ù *)  Òx1 ç aÆ
=TEX
\vfill
\end{slide}

% =====================================================================


\Slide

{\normalsize
\begin{center}
\bf A Sample Proof About Sets (III)
\end{center}
}%\normalsize

\vfill
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:
(* *** Goal "1.1.2" *** *)
...
=TEX
\vfill

=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "1.2" *** *)
...
=TEX
=GFT ProofPower output
...
(* ?Ù *)  Ò≥ x1 ç cÆ
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(* ?Ù *)  Òx1 ç a ° b \ c ¥ x1 ç a ° (b \ c)Æ
...
=TEX
Goal 2 being similar to goal 1 we complete its proof in one step:
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\vfill
\end{slide}
}%\tiny

% =====================================================================

\Slide
\begin{center}
\bf A Sample Proof About Relations (I)
\end{center}
\vfill
=SML
set_goal([], ÒP ª (Q ª R) = (P ª Q) ª RÆ);
a contr_tac;
=TEX
{\tiny
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  4 *)  Ò(x1, y') ç PÆ
(*  3 *)  Ò(y', y) ç QÆ
(*  2 *)  Ò(y, x2) ç RSchedule
(*  1 *)  Òµ y : É ∑ ≥ ((x1, y) ç P ± (y, x2) ç Q ª R)Æ

(* ?Ù *)  ÒfalseÆ


(* *** Goal "1" *** *)

(*  4 *)  Ò(x1, y) ç PÆ
(*  3 *)  Ò(y, y') ç QÆ
(*  2 *)  Ò(y', x2) ç RÆ
(*  1 *)  Òµ y : É ∑ ≥ ((x1, y) ç P ª Q ± (y, x2) ç R)Æ

(* ?Ù *)  ÒfalseÆ
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf A Sample Proof About Relations (II)
\end{center}
\vfill
{\small
=SML
a (all_asm_fc_tac[]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:
...
=SML
a (all_asm_fc_tac[]);
pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
val it = Ù P ª Q ª R = (P ª Q) ª R : THM   
...
=TEX
}%\small

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Functions
\end{center}
\vfill
\begin{itemize}
\item
Automatic proof not very effective.
\item
Recommended proof contexts: ?
\begin{itemize}
\item
Use $z_fun_ext$ for extensional low level reasoning (expands out function arrows).
\item
Use $z_library$ for non-extensional reasoning.
\item
For extensional reasoning avoiding expansion of function arrows merge $'z_fun_alg$ into $z_rel_ext$.
\item
Use $z_fun_??_clauses$ where appropriate instead of expanding function arrows.
\end{itemize}
\item
Much further development expected.
\end{itemize}

\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Numbers
\end{center}
\vfill
\begin{itemize}
\item
Use proof context $z_library$.
\item
Theory well populated with results.
\item
Induction tactics available.
\item
Linear arithmetic not yet available.
\item
Theory of $\#$ not yet developed.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Induction
\end{center}
\vfill
Induction principles for Z can be expressed as mixed language theorems in Higher Order Logic and Z e.g.:
\vfill
{\small
\begin{itemize}
=TEX
\item $z_Ó_induction_thm$
=GFT
Ù µ p
  ∑ p Ò 0Æ
  ± (µ i∑ i ç Ò ÓÆ ± p i ¥ p Ò i + 1Æ)
  ¥ (µ m∑ m ç Ò ÓÆ ¥ p m) : THM
=TEX
\item $z_˙_induction_thm$
=GFT
 Ù µ p
  ∑ p Ò 1Æ
  ± (µ i∑ p i ¥ p Ò ~ iÆ)
  ± (µ i j∑ p i ± p j ¥ p Ò i + jÆ)
  ¥ (µ m∑ p m) : THM
=TEX
\end{itemize}
}%\small
\vfill
$µ_elim$ and $all_¬_rule$ may be used to specialise these for use in forward proofs.
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Induction Tactics
\end{center}
\vfill
Special tactics are available to facilitate the use\\
of induction principles:
\begin{itemize}
\item induction over natural numbers using\\
$z_Ó_induction_tac$
{\small
=FRULE 2
z_Ó_induction_tac Ò xÆ
˜
{ á } x ç Ó ¥ t 
˜
{ á } t[0/x] ;
strip{t, á} t[x+1/x]
=TEX
}%\small
\item induction over integers using\\
$z_˙_induction_tac$
{\small
=FRULE 2
z_˙_induction_tac Ò xÆ
˜
{ á } t 
˜
{ á } t[1/x];
strip{t[i/x], á} t[~i/x];
strip{t[i/x] ± t[j/x], á} t[i+j/x]
=TEX
}%\small
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Induction - Example (I)
\end{center}
\vfill
=SML
set_goal ([], Òx ç Ó ¥ x + y æ yÆ);
a (z_Ó_induction_tac);
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò0 º iÆ

(* ?Ù *)  Ò(i + 1) + y æ yÆ


(* *** Goal "1" *** *)

(* ?Ù *)  Ò0 + y æ yÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Induction - Example (II)
\end{center}
\vfill
=SML
set_goal ([], Òx * x æ 0Æ);
a (z_˙_induction_tac ÒxÆ);
=GFT ProofPower output
(* *** Goal "3" *** *)
(*  2 *)  Ò0 º i * iÆ
(*  1 *)  Ò0 º j * jÆ

(* ?Ù *)  Ò(i + j) * (i + j) æ 0Æ

(* *** Goal "2" *** *)
(*  1 *)  Ò0 º i * iÆ

(* ?Ù *)  Ò~ i * ~ i æ 0Æ

(* *** Goal "1" *** *)
(* ?Ù *)  Ò1 * 1 æ 0Æ
=TEX
\vfill
\end{slide}

% =====================================================================

{\small
\Slide
=SML
set_goal([],Òµ x, y : ˙ ∑
        x º y ¥ 0 .. x Ä 0 .. yÆ);
a(rewrite_tac[z_get_spec Ò(_ .. _)Æ]
 THEN REPEAT strip_tac);
=GFT ProofPower output
...
(*  3 *)  Òx º yÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º xÆ

(* ?Ù *)  Òx1 º yÆ
=TEX
=SML
z_º_trans_thm;
=GFT ProofPower output
val it = Ù µ i, j, k : É
      | i º j ± j º k ∑ i º k : THM   
=SML
a(all_fc_tac[z_º_trans_thm]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=SML
set_pc "z_library_ext";
set_goal([],Òµ x, y : ˙ ∑ ≥ x º y ¥
                0 .. y Ä 0 .. x - 1Æ);
a(rewrite_tac[z_get_spec Ò(_ .. _)Æ]
 THEN REPEAT strip_tac);
=GFT ProofPower output
...
(*  3 *)  Òy < xÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º yÆ

(* ?Ù *)  Òx1 º x + ~ 1Æ
=TEX
=SML
a(all_fc_tac[z_º_less_trans_thm]);
=GFT ProofPower output
(*  4 *)  Òy < xÆ
(*  3 *)  Ò0 º x1Æ
(*  2 *)  Òx1 º yÆ
(*  1 *)  Òx1 < xÆ

(* ?Ù *)  Òx1 º x + ~ 1Æ
=TEX
=SML
a(POP_ASM_T (ante_tac o
pure_once_rewrite_rule[z_get_specÒ(_ < _)Æ]));
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=GFT ProofPower output
(*  3 *)  Òy < xÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º yÆ

(* ?Ù *)  Òx1 + 1 º x ¥ x1 º x + ~ 1Æ
=SML
a(once_rewrite_tac[z_º_º_0_thm]);
=GFT ProofPower output
(*  3 *)  Òy < xÆ
(*  2 *)  Ò0 º x1Æ
(*  1 *)  Òx1 º yÆ

(* ?Ù *)  Ò(x1 + 1) + ~ x º 0 ¥
                 x1 + ~ (x + ~ 1) º 0Æ
=SML
a(rewrite_tac[z_µ_elim Ò~ xÆ z_plus_order_thm,
                  z_minus_thm]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\vfill
\end{slide}
}%\small

% =====================================================================

\Slide
\begin{center}
\bf Sequences and Bags
\end{center}
\begin{itemize}
\item
All definitions present.
\item
Theories otherwise undeveloped.
\item
Theory of $\#$ required before development of this theory.
\item
If necessary, pro-tem, we recommend adding induction principles and other required results for reasoning in this theory as ``constraints''.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\Slide
\begin{center}
\bf Exercises 6: Z ToolKit
\end{center}
\vfill
Try Exercises 6 in zed_course_work.doc.
\vfill
Hints and further exercises may be found in section 7.4  of
the Z Tutorial Manual.

\begin{itemize}
\vfill
\item
7.4.1 Sets

(easy)
\vfill
\item
7.4.2 Relations

(start easy and get harder\\
solutions to last set incomplete)
\vfill
\item
7.4.3 Functions

(no so easy, some solutions missing)
\vfill
\item
7.4.4  Numbers and Finiteness

(middling to hard)
\end{itemize}
\vfill
\end{slide}

% =====================================================================
{\small

\Slide
{\normalsize
\begin{center}
{\bf CASE STUDY - Confidentiality}
\end{center}
}%\normalsize
\vfill
=SML
open_theory"usr023";
new_theory€"usr023C"›;
set_pc "z_library";
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
=TEX
\vfill
πZ
‹	[€DATA›]
∞
\vfill
ˇ€STATE›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	classified_data :Ó ﬂ DATA
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇ€OPERATION›¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑSTATE; 
‹	€clear?› : Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
\end{slide}

% =====================================================================

\Slide

ˇ€READ›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	OPERATION;
‹	€class?›	:Ó;
‹	€data!›	: DATA
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	class? ç dom classified_data;
‹	class? º clear?;
‹	data! = classified_data class?;
‹	classified_data' = classified_data
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇ€COMPUTE›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  OPERATION;
‹  €class?›	:Ó;
‹  €computation?›	:(Ó ﬂ DATA) ≠ DATA
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  class? ç dom classified_data;
‹  class? æ clear?;
‹  classified_data'
‹  =  classified_data ´ {class? Ì 
‹      computation? ((0 .. clear?) Ú classified_data)}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill

\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Pre-Condition Proofs}
\end{center}
}%\normalsize
\vfill
=SML
set_goal ([], Òpre OPERATION §
 classified_data ç Ó ﬂ DATA ± 0 º clear?Æ);
=TEX
\vfill
=SML
a (rewrite_tac (map z_get_spec
	[ÒOPERATIONÆ, ÒSTATEÆ]));
=TEX
\vfill
=GFT ProofPower output
...
(* ?Ù *)  Ò(∂ classified_data' : É
    ∑ (classified_data ç Ó ﬂ DATA
      ± classified_data' ç Ó ﬂ DATA)
    ± 0 º clear?)
 § classified_data ç Ó ﬂ DATA ± 0 º clear?Æ
...
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=SML
a (REPEAT z_strip_tac
   THEN_TRY asm_rewrite_tac[]);
=TEX
\vfill
=GFT ProofPower output
...
(*  2 *)  Òclassified_data ç Ó ﬂ DATAÆ
(*  1 *)  Ò0 º clear?Æ

(* ?Ù *)  Ò∂ classified_data' : É ∑
	classified_data' ç Ó ﬂ DATAÆ
...
=TEX
\vfill
=SML
a (z_∂_tac Ò{}Æ THEN
  PC_T1 "z_library_ext" rewrite_tac[]);
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf An Algorithmic Refinement}
\end{center}
}%\normalsize
\vfill
ˇ€BADREAD›¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	OPERATION;
‹	€class?›	:Ó;
‹	€data!›	: DATA
˜¸¸¸¸¸¸¸¸¸¸¸
‹	READ ≤
‹ 	(class? > clear?;
‹	data! = classified_data class?;
‹	classified_data' = classified_data)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
=SML
set_goal([],
 Ò(pre READ ¥ pre BADREAD)
 ± (pre READ ± BADREAD ¥ READ)Æ);
 
a (rewrite_tac (map z_get_spec
 [ÒBADREADÆ, ÒREADÆ, ÒOPERATIONÆ, ÒSTATEÆ]));
 
a (REPEAT z_strip_tac THEN rename_tac[]
 THEN asm_rewrite_tac[]);
=TEX
\vfill
\end{slide}
}%\small

% =====================================================================

{\tiny
\Slide
=GFT ProofPower output
...
(*  9 *)  Òclassified_data ç Ó ﬂ DATAÆ
(*  8 *)  Òclassified_data' ç Ó ﬂ DATAÆ
(*  7 *)  Ò0 º clear?Æ
(*  6 *)  Ò0 º class?Æ
(*  5 *)  Òdata! ç DATAÆ
(*  4 *)  Òclass? ç dom classified_dataÆ
(*  3 *)  Òclass? º clear?Æ
(*  2 *)  Òdata! = classified_data class?Æ
(*  1 *)  Òclassified_data' = classified_dataÆ

(* ?Ù *)  Ò∂ classified_data'' : É; data!' : É
 ∑ (classified_data'' ç Ó ﬂ DATA
   ± data!' ç DATA)
 ± ((classified_data'' ç Ó ﬂ DATA
      ± data!' ç DATA)
    ± data!' = classified_data class?
    ± classified_data'' = classified_data
   ≤ clear? < class?
    ± data!' = classified_data class?
    ± classified_data'' = classified_data)Æ
...
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=SML
a (z_∂_tac Ò
   (classified_data'' ¶ classified_data,
   data!' ¶ classified_data class?)Æ
 THEN asm_rewrite_tac[]);
=GFT ProofPower output
...
(*  9 *)  Òclassified_data ç Ó ﬂ DATAÆ
...
(*  4 *)  Òclass? ç dom classified_dataÆ
...
(* ?Ù *)  Òclassified_data class? ç DATA
             ± (classified_data class? ç DATA ≤ clear? < class?)Æ
...
=TEX
\vfill
=GFT
Ù µ f : É; x : É; X : É; Y : É
    ∑ ((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y)
       ± x ç X ¥ f x ç Y)
    ± ((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y)
       ± x ç dom f ¥ f x ç Y) : THM
=TEX
\vfill
=SML
a (all_fc_tac [z_fun_ç_clauses]
	THEN REPEAT strip_tac);
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

{\small
\Slide
{\normalsize
\begin{center}
{\bf Base Types}
\end{center}
}%\normalsize
\vfill
=SML
open_theory "usr023C";
=TEX
\vfill
πZ
‹  [€IN›,€OUT›]
∞
\vfill
πZ
‹  €STATE2› ¶ Ó ﬂ DATA
∞
\vfill
πZ
‹  €SYSTEM› ¶ (Ó ∏ IN ∏ STATE2)
		≠ (STATE2 ∏ OUT)
∞
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Critical Property}
\end{center}
}%\normalsize
\vfill
πZAX
‹  €out_secure› :  SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µsys:SYSTEM∑ sys ç out_secure §
‹
‹  (µ clear:Ó; inp:IN; s,s':STATE2
‹  | (0 ..  clear) Ú s = (0 ..  clear) Ú s'
‹  ∑ second (sys (clear, inp, s))
‹    = second (sys (clear, inp, s')))
∞
\vfill
πZAX
‹  €state_secure› :  SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µsys:SYSTEM∑ sys ç state_secure §
‹
‹  (µclass, clear:Ó; inp:IN; s,s':STATE2
‹  | ((0 ..  class) Ú s) = ((0 ..  class) Ú s')
‹  ∑ (0 ..  class) Ú (first (sys (clear, inp, s)))
‹    = (0 ..  class) Ú (first (sys (clear, inp, s'))))
∞
\vfill
πZAX
‹  €secure› :  SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µsys:SYSTEM∑ sys ç secure §
‹  sys ç state_secure ± sys ç out_secure
∞
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Secure Architecture}
\end{center}
}%\normalsize
\vfill
πZ
  €APPLICATION› ¶ (IN ∏ STATE2)
                    ≠ (STATE2 ∏ OUT)
∞
\vfill
πZ
‹  €KERNEL› ¶ APPLICATION ≠ SYSTEM
∞
\vfill
πZAX
‹  €construction› : APPLICATION ∏ KERNEL ≠ SYSTEM
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µappl:APPLICATION; kernel:KERNEL∑
‹    construction (appl, kernel) = kernel appl
∞
\vfill
πZAX
‹  €secure_kernel› :  KERNEL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹  µ kernel:KERNEL∑ kernel ç secure_kernel §
‹    (µappl:APPLICATION∑
‹      (construction (appl, kernel)) ç secure)
∞
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Architectural Correctness}
\end{center}
}%\normalsize
\vfill

=SML 
set_goal([],Òµkernel:KERNEL;appl:APPLICATION∑
  kernel ç secure_kernel ¥
  (construction (appl,kernel)) ç secureÆ);
=TEX
\vfill
=SML
val €secure_kernel_sim› = z_defn_simp_rule
           (z_get_specÒsecure_kernelÆ);
=TEX
\vfill
=GFT ProofPower output
val secure_kernel_sim = Ù µ kernel : É ∑
 kernel ç secure_kernel §
 kernel ç KERNEL
 ± (µ appl : APPLICATION ∑
    construction (appl, kernel) ç secure) : THM
=TEX
\vfill
=SML 
a (rewrite_tac[secure_kernel_sim]);
=GFT ProofPower output
(* ?Ù *)  Òµ kernel : KERNEL; appl : APPLICATION
 ∑ kernel ç KERNEL
 ± (µ appl : APPLICATION
    ∑ construction (appl, kernel) ç secure)
      ¥ construction (appl, kernel) ç secureÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=SML 
a (REPEAT strip_tac);
=TEX
\vfill
=GFT ProofPower output
(*  3 *)  Òkernel ç KERNELÆ
(*  2 *)  Òappl ç APPLICATIONÆ
(*  1 *)  Òµ appl : APPLICATION ∑
             construction (appl, kernel) ç secureÆ

(* ?Ù *)  Òconstruction (appl, kernel) ç secureÆ
=TEX
\vfill
=SML 
a (all_asm_fc_tac[]);
=TEX
\vfill
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf A Secure Kernel}
\end{center}
}%\normalsize
\vfill
πZAX
‹ €kernel_implementation› : KERNEL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ clear:Ó; inp:IN;
‹   state:STATE2; appl:APPLICATION ∑
‹
‹ kernel_implementation appl (clear, inp, state) = 
‹
‹ (  state ´ ((0  ..  (clear-1)) ·
‹        (first (appl (inp, (0  ..  clear) Ú state)))),
‹	second (appl (inp, (0  ..  clear) Ú state)) )
∞

\vfill
\end{slide}
}%\small


% =====================================================================

{\tiny
\Slide
{\normalsize
\begin{center}
{\bf Arithmetic Lemmas}
\end{center}
}%\normalsize
\vfill
=SML
set_pc "z_library_ext";
=TEX
\vfill
=SML
set_goal ([], Òµ x, y : ˙ ∑ x º y ¥ (0 .. x) Ä (0 .. y)Æ);
a (rewrite_tac[z_get_spec Ò(_ .. _)Æ]
  THEN REPEAT strip_tac);
a (all_fc_tac[z_º_trans_thm]);
val €le_dots_lemma1› = pop_thm ();
=TEX
\vfill
=SML
set_goal ([], Òµ x, y : ˙ ∑ ≥ x º y ¥ (0 .. y) Ä (0 .. (x - 1))Æ);
a (rewrite_tac[z_get_spec Ò(_ .. _)Æ]
  THEN REPEAT strip_tac);
a (all_fc_tac[z_º_less_trans_thm]);
a (POP_ASM_T (ante_tac o pure_once_rewrite_rule
                           [z_get_specÒ(_ < _)Æ]));
a (once_rewrite_tac[z_º_º_0_thm]);
a (rewrite_tac[z_µ_elim Ò~ xÆ z_plus_order_thm, z_minus_thm]);
val €le_dots_lemma2› = pop_thm();
=TEX
\vfill
=SML
val €∏_fc_thm› = prove_rule []
  Ò (µ v:É; w:É; V:É; W:É ∑
  v ç V ± w ç W ¥ (v,w) ç (V ∏ W))Æ;
=TEX
\vfill
\end{slide}

% =====================================================================


\Slide
{\normalsize
\begin{center}
{\bf Kernel Security Proof}
\end{center}
}%\normalsize
\vfill
=SML
set_pc "z_sets_alg";
set_goal([],Òkernel_implementation ç secure_kernelÆ);
=GFT ProofPower output
(* ?Ù *)  Òkernel_implementation ç secure_kernelÆ
=TEX

=SML
val €specs› = map (z_defn_simp_rule o z_get_spec)
  [Òsecure_kernelÆ, ÒsecureÆ, Òstate_secureÆ, Òout_secureÆ];
=SML 
a (	rewrite_tac specs
	THEN REPEAT strip_tac);
=TEX
\vfill
=GFT ProofPower output
Tactic produced 6 subgoals:

(* *** Goal "6" *** *)
(*  6 *)  Òappl ç APPLICATIONÆ
(*  5 *)  Òclear ç ÓÆ
(*  4 *)  Òinp ç INÆ
(*  3 *)  Òs ç STATE2Æ
(*  2 *)  Òs' ç STATE2Æ
(*  1 *)  Ò(0 .. clear) Ú s = (0 .. clear) Ú s'Æ

(* ?Ù *)
  Ò(construction (appl, kernel_implementation) (clear, inp, s)).2
 = (construction (appl, kernel_implementation) (clear, inp, s')).2Æ
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf A Secure Kernel}
\end{center}
}%\normalsize
\vfill
=GFT
...
(* *** Goal "4" *** *)
(*  7 *)  Òappl ç APPLICATIONÆ
(*  6 *)  Òclass ç ÓÆ
(*  5 *)  Òclear ç ÓÆ
(*  4 *)  Òinp ç INÆ
(*  3 *)  Òs ç STATE2Æ
(*  2 *)  Òs' ç STATE2Æ
(*  1 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ

(* ?Ù *)  Ò(0 .. class)
                 Ú (construction (appl, kernel_implementation)
                       (clear, inp, s)).1
             = (0 .. class)
                 Ú (construction (appl, kernel_implementation)
                       (clear, inp, s')).1Æ
=TEX
=GFT ProofPower output
...
(* *** Goal "2" *** *)
(*  1 *)  Òappl ç APPLICATIONÆ

(* ?Ù *)  Òconstruction (appl, kernel_implementation) ç SYSTEMÆ
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=GFT ProofPower output
...
(* *** Goal "1" *** *)
(* ?Ù *)  Òkernel_implementation ç KERNELÆ

The subgoal 2 duplicates goals labelled 3, 5
The subgoal 3 duplicates goals labelled 2, 5
=TEX
=SML
val [condec, conpred] = strip_±_rule (z_get_spec ÒconstructionÆ);
val [kidec, kipred] =
      strip_±_rule (z_get_spec Òkernel_implementationÆ);
=GFT ProofPower output
val condec = Ù construction ç
     APPLICATION ∏ KERNEL ≠ SYSTEM : THM
val conpred =
   Ù µ appl : APPLICATION; kernel : KERNEL
       ∑ construction (appl, kernel) = kernel appl : THM

val kidec = Ù kernel_implementation ç KERNEL : THM
val kipred =
...
=TEX
=SML
a (strip_asm_tac kidec);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:
=TEX
\vfill
\vfill
\end{slide}

% =====================================================================

\Slide
=GFT ProofPower output
(*  1 *)  Òappl ç APPLICATIONÆ

(* ?Ù *)  Òconstruction (appl, kernel_implementation) ç SYSTEMÆ
...
=SML
a (asm_tac kidec THEN asm_tac condec);
a (LEMMA_T
 Ò(appl, kernel_implementation) ç (APPLICATION ∏ KERNEL)Æ
 asm_tac
 THEN1 contr_tac);
=GFT ProofPower output
...
(* 2 *) Òconstruction ç APPLICATION ∏ KERNEL ≠ SYSTEMÆ
(* 1 *) Ò(appl, kernel_implementation) ç APPLICATION ∏ KERNELÆ

(* ?Ù *) Òconstruction (appl, kernel_implementation) ç SYSTEMÆ
...
=SML
a (all_fc_tac [z_fun_ç_clauses]);
=TEX
This discharges the current subgoal.
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:
...
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide

=GFT ProofPower output
(*  7 *)  Òappl ç APPLICATIONÆ
...
(*  4 *)  Òinp ç INÆ
...
(*  1 *)  Ò(0 .. class Ú s) = (0 .. class Ú s')Æ

(* ?Ù *) 
  Ò(0 .. class Ú (construction
                    (appl, kernel_implementation)
                       (clear, inp, s)).1)
 = (0 .. class Ú (construction
                    (appl, kernel_implementation)
                       (clear, inp, s')).1)Æ
=TEX
\vfill
=SML
a (strip_asm_tac kidec);
a (ALL_FC_T asm_rewrite_tac [kipred, conpred]);
=GFT ProofPower output
...
(*  8 *)  Òappl ç APPLICATIONÆ
...
(*  2 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
(*  1 *)  Òkernel_implementation ç KERNELÆ

(* ?Ù *)
  Ò(0 .. class) Ú (s ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s)).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
...
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\small

\vfill
If $Òclear º classÆ$ then:

\begin{center}

 $Ò(0 .. clear) Ä (0 .. class)Æ$
 
\end{center}
and, given:
\begin{center}

 $Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ$

\end{center}
we can conclude that:
\begin{center}

 $Ò(0 .. clear) Ú s = (0 .. clear) Ú s'Æ$

\end{center}

This fact may be used to rewrite the goal, changing the second occurence of $s$ to $s'$.
The resulting goal will be provable using:
\begin{center}

$Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ$

\end{center}
once more, with the theorem:
\begin{center}

$Òx Ú z = x Ú z' ¥ x Ú (z ´ y) = x Ú (z' ´ y)Æ$

\end{center}

\vfill

If $Ò≥ clear º classÆ$ then:
\begin{center}

 $Ò0 .. class Ä 0 .. (clear - 1)Æ$
 
\end{center}
and the theorem:
\begin{center}

$Ò(A Ä B) ¥ (A Ú z) = (A Ú z')$\\
$¥ (A Ú (z ´ (B · s))) = (A Ú (z' ´ (B · s')))Æ$

\end{center}


suffices to prove the subgoal.
\vfill

}%\small

\end{slide}

% =====================================================================

\Slide
=SML 
a (cases_tac Òclear º classÆ);
=TEX
\vfill
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "4.1" *** *)
(*  9 *)  Òappl ç APPLICATIONÆ
...
(*  3 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
(*  2 *)  Òkernel_implementation ç KERNELÆ
(*  1 *)  Ò clear º classÆ

(* ?Ù *)
  Ò(0 .. class) Ú (s ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s)).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
a (fc_tac [rewrite_rule[z_get_specÒ˙Æ]
  le_dots_lemma1]);
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=GFT ProofPower output
...
(* 10 *)  Òappl ç APPLICATIONÆ
...
(*  4 *)  Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
(*  3 *)  Òkernel_implementation ç KERNELÆ
(*  2 *)  Òclear º classÆ
(*  1 *)  Ò0 .. clear Ä 0 .. classÆ

(* ?Ù *)  Ò(0 .. class) Ú (s ´ (0 .. clear - 1)
              · (appl (inp, (0 .. clear) Ú s)).1)
         = (0 .. class) Ú (s' ´ (0 .. clear - 1)
              · (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
val set_lemma_1 = pc_rule1 "z_rel_ext" prove_rule []
  Òµ A, B : É; x, x' : É ∑
  A Ä B ¥ (B Ú x) = (B Ú x') ¥ (A Ú x) = (A Ú x')Æ;
a (ALL_FC_T asm_rewrite_tac[set_lemma_1]);
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
=GFT ProofPower output
...
(* 10 *)  Òappl ç APPLICATIONÆ
...
(*  4 *)  Ò(0 .. class Ú s) = (0 .. class Ú s')Æ
...
(*  3 *)  Òkernel_implementation ç KERNELÆ
(*  2 *)  Òclear º classÆ
(*  1 *)  Ò0 .. clear Ä 0 .. classÆ

(* ?Ù *)  
 Ò(0 .. class) Ú (s ´ (0 .. clear - 1) ·
                  (appl (inp, (0 .. clear) Ú s')).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
val set_lemma_2 = pc_rule1 "z_rel_ext" prove_rule[]
 Òµ A : É; x, x', y : É ∑
  A Ú x = A Ú x' ¥ A Ú (x ´ y) = A Ú (x' ´ y)Æ;
a(ALL_FC_T asm_rewrite_tac[set_lemma_2]);
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf state secure - second case}
\end{center}
}%\normalsize

=GFT ProofPower output
(* *** Goal "4.2" *** *)
(*  9 *)  Òappl ç APPLICATIONÆ
...
(*  3 *)  Ò(0 .. class Ú s) = (0 .. class Ú s')Æ
(*  2 *)  Òkernel_implementation ç KERNELÆ
(*  1 *)  Ò≥ (clear º class)Æ

(* ?Ù *)
 Ò (0 .. class) Ú (s ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s)).1)
 = (0 .. class) Ú (s' ´ (0 .. clear - 1) ·
                   (appl (inp, (0 .. clear) Ú s')).1)Æ
=TEX
\vfill
=SML
(* *** Goal "4.2" *** *)
val set_lemma_3 = pc_rule1 "z_rel_ext" prove_rule[]
  Òµ A,B:É; x,x':É; st,st':É ∑
  A Ú x = A Ú x' ¥ (A Ä B)
  ¥ A Ú (x ´ (B · st)) = A Ú (x' ´ (B · st'))Æ;
a (FC_T (MAP_EVERY ante_tac)
  [rewrite_rule[z_get_specÒ˙Æ]le_dots_lemma2]
  THEN asm_ante_tac Ò(0 .. class) Ú s = (0 .. class) Ú s'Æ
  THEN rewrite_tac [set_lemma_3]);
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf The out_secure Subgoal}
\end{center}
}%\normalsize

=GFT ProofPower output
(* *** Goal "6" *** *)
(*  6 *)  Òappl ç APPLICATIONÆ
(*  5 *)  Òclear ç ÓÆ
(*  4 *)  Òinp ç INÆ
(*  3 *)  Òs ç STATEÆ
(*  2 *)  Òs' ç STATEÆ
(*  1 *)  Ò(0 .. clear) Ú s = (0 .. clear) Ú s'Æ


(* ?Ù *)
  Ò(construction (appl, kernel_implementation) (clear, inp, s)).2
 = (construction (appl, kernel_implementation) (clear, inp, s')).2Æ
=TEX
\vfill
=SML
a (MAP_EVERY asm_tac [condec, kidec] THEN
  ALL_FC_T asm_rewrite_tac [conpred, kipred]);
=TEX
\vfill
=SML 
val €kernel_secure_thm› = pop_thm();
=GFT ProofPower output
val kernel_secure_thm = 
     Ù kernel_implementation ç secure_kernel : THM   
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf A Vending Machine}
\end{center}
}%\normalsize
\small


\vfill

=IGN
open_theory"z_library";
new_theory"usr023";

=SML
repeat drop_main_goal;
open_theory "usr023";
new_theory "usr023V";
set_flags [
	("z_type_check_only", false),
	("z_use_axioms", true)
	   ];
=TEX

\vfill
πZAX
‹	price :Ó
∞
\vfill
ˇVMSTATE¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stock, takings :Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇVM_operation¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ÑVMSTATE;
‹	cash_tendered?, cash_refunded! :Ó;
‹	bars_delivered! :Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Vending Machine Operation Pre-conditions}
\end{center}
}%\normalsize
\small
\vfill
ˇexact_cash¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? :Ó
˜¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? = price
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇinsufficient_cash¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? :Ó
˜¸¸¸¸¸¸¸¸¸¸
‹	cash_tendered? < price
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇsome_stock¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	stock :Ó
˜¸¸¸¸¸¸¸¸¸¸
‹	stock > 0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Vending Machine Operations}
\end{center}
}%\normalsize
\small
\vfill
ˇVM_sale¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ VM_operation
˜¸¸¸¸¸¸¸¸¸¸
‹ stock' = stock - 1;
‹ bars_delivered! = 1;
‹ cash_refunded! = cash_tendered? - price;
‹ takings' = takings + price
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
ˇVM_nosale¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ VM_operation
˜¸¸¸¸¸¸¸¸¸¸
‹ stock' = stock;
‹ bars_delivered! = 0;
‹ cash_refunded! = cash_tendered?;
‹ takings' = takings
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill

πZ
‹ VM1 ¶ exact_cash ± some_stock ± VM_sale
∞
\vfill

πZ
‹ VM2 ¶ insufficient_cash ± VM_nosale
∞
\vfill

πZ
‹ VM3 ¶ VM1 ≤ VM2
∞
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Exercises 7 : Vending Machine}
\end{center}
}%\normalsize
\small
Turn to Exercises 7 in zed_course_work.doc
\vfill
\begin{enumerate}
\item
Prove that the schema VM3 is non-empty. i.e., prove:

=GFT
∂ VM3 ∑ true
=TEX

\tiny
Hints:
\begin{enumerate}
\item
Set the proof context to work with set extensionality by using:
=GFT
set_pc "z_library_ext";
=TEX
\item
Prove this by contradiction using $contr\_tac$.
\item
Try specialising VM3 with a suitable witness.
\item
Does your witness provide values for $cash\_tendered?$, $stock$, $stock'$, $takings$, $takings'$, $cash\_refunded!$

and $bars\_delivered!$ ?
\item
Is the conclusion $false$?

If so, try using $swap\_asm\_concl\_tac$ to help simplify the goal.
\item
Try rewriting with the all the definitions.
\item
Does your goal contain a disjunct, $0 º price$ ?

If so try $strip_asm_tac\   price$ and rewriting with the assumptions.

\end{enumerate}

\end{enumerate}
\vfill
\end{slide}


% =====================================================================
\Slide

{\normalsize
\begin{center}
{\bf Exercises 7 (cont.) : VM Refinement Proof}
\end{center}
}%\normalsize
\small

This exercise is concerned with proving that VM3 is a refinement of VM1. This is a two stage proof.   
\vfill
\begin{enumerate}
\setcounter{enumi}{1}
\item
It is useful to prove a lemma that stating that the pre-conditions $insufficient\_cash$ and $exact\_cash$ are disjoint. i.e., prove:
=GFT
≥ (insufficient_cash ± exact_cash)
=TEX
{\tiny
Hints:
\begin{enumerate}
\item
Set the proof context to work with set extensionality by using:
=GFT
set_pc "z_library_ext";
=TEX
\item
Try rewriting with all the definitions.
\item
If the goal contains inequalities, try rewriting with the specification of $<$.
e.g., use $z\_get\_spec$. (Avoid looping by using $pure\_rewrite\_tac$.)
\item
$z\_minus\_thm$ and $plus\_assoc\_thm$ may be useful to normalize any arithmetic expressions.
\item
Repeatedly stripping the goal might be too aggressive; try stripping it in steps, looking for likely opportunities for rewriting with the assumptions.
\end{enumerate}}%\tiny
\item
Show that $VM3$ is a refinement of $VM1$. i.e., prove
=GFT
(pre VM1 ¥ pre VM3) ± (pre VM1 ± VM3 ¥ VM1)
=TEX
{\tiny
Hints:
\begin{enumerate}
\item
Try rewriting with some of the top-level definitions; the goal can be proved without rewriting will all the definitions!
\item
The lemma proved in part 1 of this exercise will be useful.
\item
If you're stuck, try stripping the goal and seeing what you get.
\end{enumerate}}%\tiny

\end{enumerate}
\vfill
\end{slide}

% =====================================================================

\Slide

{\normalsize
\begin{center}
{\bf Exercises 7 : Solutions}
\end{center}
}%
\tiny
\vfill
For convenience we bind the various specifications to ML variables:
=SML
val [	price, VMSTATE, VM_operation,
	exact_cash, insufficient_cash, some_stock,
	VM_sale, VM_nosale, VM1, VM2, VM3 ]
    = map z_get_spec [ ÒpriceÆ, ÒVMSTATEÆ, ÒVM_operationÆ,
	Òexact_cashÆ, Òinsufficient_cashÆ, Òsome_stockÆ,
	ÒVM_saleÆ, ÒVM_nosaleÆ, ÒVM1Æ, ÒVM2Æ, ÒVM3Æ ];
=TEX
\vfill
=SML
set_pc "z_library_ext";
set_goal([], Ò∂ VM3 ∑ trueÆ);
a(contr_tac);
a(z_spec_asm_tac Òµ VM3 ∑ falseÆ
	Ò(	cash_tendered? ¶ price,
		stock ¶ 1, stock' ¶ 0,
		takings ¶ 0, takings' ¶ price,
		cash_refunded! ¶ 0,
		bars_delivered! ¶ 1)Æ);
a(swap_asm_concl_tac
 Ò≥ (bars_delivered! ¶ 1, cash_refunded! ¶ 0, cash_tendered? ¶ price,
          stock ¶ 1, stock' ¶ 0, takings ¶ 0, takings' ¶ price)
          ç VM3Æ);
=TEX
\vfill
\end{slide}

% =====================================================================
\Slide

{\normalsize
\begin{center}
{\bf Exercises 7 : Solutions (cont.)}
\end{center}
}%\normalsize
\tiny
\vfill
=GFT Proofpower output
(* *** Goal "" *** *)

(*  1 *)  Òµ VM3 ∑ falseÆ

(* ?Ù *)  Ò(bars_delivered! ¶ 1, cash_refunded! ¶ 0,
		cash_tendered? ¶ price, stock ¶ 1, stock' ¶ 0,
		takings ¶ 0, takings' ¶ price)
             ç VM3Æ
=TEX
\vfill
=SML
a(rewrite_tac[VM1, VM3,
	exact_cash, 
	some_stock, VM_sale, VM_operation, VMSTATE]);
a(strip_asm_tac price);
a(asm_rewrite_tac[]);
val VM3_non_empty = pop_thm ();
=TEX
\vfill
\end{slide}
% =====================================================================
\Slide

{\normalsize
\begin{center}
{\bf Exercises 7 : Solutions (cont.)}
\end{center}
}%\normalsize
\tiny
\vfill
=SML
set_goal([], Ò≥ (insufficient_cash ± exact_cash)Æ);
a (rewrite_tac [insufficient_cash, exact_cash]);
=GFT ProofPower output
(* ?Ù *)  Ò≥
           ((0 º cash_tendered?
               ± cash_tendered? < price)
               ± 0 º cash_tendered?
               ± cash_tendered? = price)Æ
=TEX
\vfill
=SML
a (pure_rewrite_tac [z_get_spec Ò(_ < _)Æ]);
a (rewrite_tac [z_plus_assoc_thm1]);
a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
a (REPEAT_N 3 z_strip_tac);
a (asm_rewrite_tac[]);
val cash_lemma = pop_thm ();
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide

{\normalsize
\begin{center}
{\bf Exercises 7 : Solutions (cont.)}
\end{center}
}%\normalsize
\tiny

\vfill
To prove the refinement, the previous lemma is useful.
\vfill
=SML
set_goal([], Ò (pre VM1 ¥ pre VM3) ± (pre VM1 ± VM3 ¥ VM1)Æ);
a (rewrite_tac [VM1, VM2, VM3]);
=TEX
\vfill
=GFT ProofPower output
(* ?Ù *)  Ò(
 (∂ bars_delivered! : É;
    cash_refunded! : É;
    stock' : É;
    takings' : É
  ∑ exact_cash ± some_stock ± VM_sale)
  ¥ (∂ bars_delivered! : É;
       cash_refunded! : É;
       stock' : É;
       takings' : É
      ∑ exact_cash ± some_stock ± VM_sale
        ≤ insufficient_cash ± VM_nosale))
 ± ((∂ bars_delivered! : É;
       cash_refunded! : É;
       stock' : É;
       takings' : É
      ∑ exact_cash ± some_stock ± VM_sale)
    ± (exact_cash ± some_stock ± VM_sale
        ≤ insufficient_cash ± VM_nosale)
    ¥ exact_cash ± some_stock ± VM_sale)Æ
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Exercises 7 : Solutions (cont.)}
\end{center}
}%\normalsize
\tiny
\vfill
=SML
a (strip_asm_tac cash_lemma
   THEN asm_rewrite_tac[]);
=TEX
\vfill
=GFT ProofPower output
(*  1 *)  Ò≥ insufficient_cashÆ

(* ?Ù *)  Ò(∂ bars_delivered! : É;
                   cash_refunded! : É;
                   stock' : É;
                   takings' : É
                 ∑ exact_cash ± some_stock ± VM_sale)
               ± exact_cash
               ± some_stock
               ± VM_sale
             ¥ exact_cash ± some_stock ± VM_saleÆ
=TEX
\vfill
=SML
a (REPEAT z_strip_tac);
val VM3_refines_VM1 = pop_thm ();
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide

{\normalsize
\begin{center}
{\bf Vending Machine Correctness Property}
\end{center}
}%\normalsize
\small
\vfill

Next we express the requirement that a vending machine does not undercharge:

\vfill

πZAX
‹	VM_ok :   VM_operation
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ µ vm :  VM_operation∑
‹ vm ç VM_ok §
‹  (µ VM_operation ∑ vm ¥
‹   takings' - takings æ price * (stock - stock'))
∞
\vfill

\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Exercises 8 : Correctness Proof}
\end{center}
}%\normalsize
\small
\vfill
\begin{enumerate}
\item
Prove that the Vending Machine VM3 does not undercharge. i.e., prove:
=GFT
VM3 ç VM_ok
=TEX

Hints:

\begin{enumerate}
\item
Set the proof context to work with set extensionality by using:
=GFT
set_pc "z_library_ext";
=TEX
\item
You will probably need to rewrite the goal with all the definitions.
\item
Try stripping the goal.
\item
Do you think that the conclusion is true by dint of arithmetic reasoning?

If so, you might want to try rewriting with theorems such as $z\_minus\_thm$ and/or $z\_plus\_assoc1\_thm$.
\item
$z\_plus\_order\_thm$ may also be useful. You will need to specialise this to some appropriate values if you are going to rewrite with it.
\end{enumerate}

\end{enumerate}
\vfill
\end{slide}

% =====================================================================

\Slide

{\normalsize
\begin{center}
{\bf Exercises 8 : Solutions}
\end{center}
}%\normalsize
\tiny
\vfill

Before using the definition of VM\_ok we convert it into an unconditional rewrite.
\vfill
=SML
val VM_ok = z_defn_simp_rule (z_get_spec ÒVM_okÆ);
=GFT ProofPower output
val VM_ok = Ù µ vm : É
    ∑ vm ç VM_ok
      § vm ç  VM_operation
        ± (µ VM_operation
          ∑ vm ¥ takings' - takings æ price * (stock - stock')) : THM
=TEX
\vfill

We now prove that VM3 is a VM_ok.
\vfill
=SML
set_pc"z_library_ext";

set_goal([], ÒVM3 ç VM_okÆ);
a (rewrite_tac [VM1,VM2,VM3,VM_ok,VM_sale,VM_nosale,
		VM_operation,VMSTATE]);
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide

{\normalsize
\begin{center}
{\bf Exercises 8 : Solutions (cont.)}
\end{center}
}%\normalsize
\tiny
\vfill


=SML
a(REPEAT z_strip_tac THEN asm_rewrite_tac[]);
=TEX
\vfill

Which considerably simplified the problem:
\vfill

=GFT ProofPower output
...
(*  2 *)  Òcash_refunded! = cash_tendered? + ~ priceÆ
(*  1 *)  Òtakings' = takings + priceÆ

(* ?Ù *)  Òprice * (stock + ~ (stock + ~ 1)) º
                       (takings + price) + ~ takingsÆ
...
=TEX
To solve this arithmetic problem, we simplify the lhs of the inequality by
1. pushing in the minus sign

and

2. associating the additions to the left

\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Exercises 8 : Solutions (cont.)}
\end{center}
}%\normalsize
\tiny
\vfill
=SML
a (rewrite_tac [z_minus_thm, z_plus_assoc_thm1]);
=TEX
\vfill
which gives the conclusion:
=GFT Proofpower output
(* ?Ù *)  Òprice º (takings + price) + ~ takingsÆ
=TEX
\vfill
To solve this problem we move
=INLINEFT
Ò~ takingsÆ
=TEX
\ left to place it next to $takings$.

For this we specialise $z_plus_order_thm$:

=SML
z_plus_order_thm;
=GFT ProofPower output
val it = Ù µ i : É
    ∑ µ j, k : É
      ∑ j + i = i + j
      ± (i + j) + k = i + j + k
      ± j + i + k = i + j + k : THM
=TEX
\vfill
\end{slide}

% =====================================================================

\Slide
{\normalsize
\begin{center}
{\bf Exercises 8 : Solutions (cont.)}
\end{center}
}%\normalsize
\tiny
\vfill
=SML
z_µ_elim Ò~ takingsÆ z_plus_order_thm;
=TEX
\vfill
=GFT ProofPower output
val it = Ù ~ takings ç É ± true
    ¥ (µ j, k : É
      ∑ j + ~ takings = ~ takings + j
        ± (~ takings + j) + k = ~ takings + j + k
        ± j + ~ takings + k = ~ takings + j + k) : THM
=TEX
\vfill
=SML
a (rewrite_tac [z_µ_elim Ò~ takingsÆ z_plus_order_thm]);
a (rewrite_tac [z_plus_assoc_thm1]);
=TEX
\vfill
=SML
val VM3_ok_thm = pop_thm();
=TEX

\vfill
\end{slide}
