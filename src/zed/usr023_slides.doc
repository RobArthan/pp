=TEX
% usr023.doc   %Z% $Date$ $Revision$ $RCSfile$
% COPYRIGHT (c) International Computers Limited, 1992

=IGN
doctex usr023_slides ; slitex usr023
=TEX

\def\SCCSissue{$Revision$
}

\long\def\ignore#1{}

\ignore{

=SML
fun summarize_mt_results _ = "No summary provided for usr023_slides.doc";
open_theory"z_bags";
new_theory"tutorial";
=TEX

}%\ignore

% =====================================================================

\begin{slide}{1}

\vfill

\begin{center}

\vfill

{\huge Proof in Z}\\
with\\
{\huge \bf ProofPower}\\

\vfill

\end{center}

\end{slide}

% =====================================================================

\begin{slide}{2}
\begin{center}

{\bf Course Objectives}

\end{center}
\vfill

\begin{itemize}
\item
to describe the basic principles and concepts underlying ProofPower support for Z
\item
to enable the student to write simple specifications and undertake elementary proofs in Z using ProofPower
\item
to enable the student to make effective use of the reference documentation for ProofPower-Z
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{3}
\begin{center}

{\bf Course Outline}

\end{center}
\vfill

\begin{itemize}
\item
Introduction to ProofPower-Z

{\small
\begin{itemize}
\item
an overview of Z support in ProofPower
\item
propositional and predicate calculus proofs in Z
\end{itemize}
}%\small

\item
Specification in Z using ProofPower

{\small
\begin{itemize}
\item
Expressions and Predicates
\item
Schema Expressions
\item
Paragraphs
\end{itemize}
}%\small

\item
Proof in Z using ProofPower

{\small
\begin{itemize}
\item
Basics of Proof
\item
Rules, Conversions, Tactics...
\item
Stripping, Rewriting
\item
Induction
\end{itemize}
}%\small

\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{4}
\begin{center}
\bf Schedule
\end{center}
\vfill
\vertbarfalse
{\tiny
=GFT
slide	topic			time

THURSDAY 7th January

	BUFFET LUNCH		12:30
	
01	introduction		13:30
20	exercises 1: proof		13:45
28	Predicates		14:15
33	Expressions		14:35
33	Schema Expressions		14:35

	COFFEE			15:00

50	Theories			15:35
53	Exercises 2		15:50
54	Paragraphs		16:05
59	Exercises 3		16:20
60	Forward Proof		16:45
66	Exercises 4		17:10

FRIDAY 8th January

66	Exercises 4 (cont)		9:00
68	Goal Oriented Proof
	/Rewriting			9:15
71	Exercises 5 & 6		9:30
75	Stripping			10:05
78	Exercises 7		10:20

	COFFEE			10:30
	
79	Induction			11:05
83	Exercises 8		11:20
85	TACTICALs et.al.		11:45
86	Exercises 9		11:55
89	Proof Strategy		12:10
96	Exercises 10		12:30

	BUFFET LUNCH		12:30
=TEX
}%\tiny
\vertbartrue
\vfill
\end{slide}
% =====================================================================

\begin{slide}{5}
\begin{center}

{\bf Course Prerequisites}

\end{center}
\vfill

We assume a working knowledge of:
{\ftlmargin=0.7in \ftrmargin=0.5in
\begin{itemize}
\item
Z as a specification language
{\small
πZ
[NAME, DATE]
∞

πZ
V[X] ¶ X
∞

ˇFile¸¸¸¸¸¸¸
‹ people :  NAME;
‹ age : NAME ﬂ DATE
˜¸¸¸¸¸¸¸¸
‹ dom age = people
à¸¸¸¸¸¸¸¸¸¸
=TEX
}%\small
\item
the use of ProofPower with HOL (under sunview)
\end{itemize}
}%\ftlmargin
\vfill
\end{slide}

% =====================================================================

\begin{slide}{17}
\begin{center}
\vfill

{\bf Some Z Proofs are Easy with ProofPower}
\end{center}

\begin{itemize}
\item
propositional tautologies

{\tiny Propositional reasoning in Z is exactly the same as in HOL, fully automatic and well integrated into the normal proof methods.}

\item
first order predicate calculus

{\tiny As in HOL, predicate calculus proofs in Z are either automatic or routine.}

\item
elementary set theory

{\tiny A useful class of results from elementary set theory are automatically provable.}

\item
other classes of results

{\tiny Whenever a new theory is introduced one or more proof contexts may be developed to solve automatically a range of results in that theory.
``Decision procedures'' for such classes of results can be made available via ``prove\_tac''.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{18}
\begin{center}

{\bf Simple Predicate Calculus Proofs}
\end{center}
\vfill
{\small

\begin{itemize}
\item
use the subgoaling package

\item
set the goal

=SML
open_theory"z_bags";
set_pc "z_predicates";
set_goal([],Ò (µx, y:X∑ P x ¥ R y)
	§ (µv, w:X∑ ≥ P w ≤ R v)Æ);
=TEX
\item
initiate proof by contradiction
=SML
a contr_tac;
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
...
(*  5 *)  Ò µ x, y : X ∑ P x ¥ R yÆ
(*  4 *)  Ò v ç XÆ
(*  3 *)  Ò w ç XÆ
(*  2 *)  Ò P wÆ
(*  1 *)  Ò ≥ R vÆ

(* ?Ù *)  Ò falseÆ
=TEX
\item
instantiate assumptions as required
=SML
a (z_spec_asm_tac Ò µ x, y : X ∑ P x ¥ R yÆ
	Ò (x ¶ w, y ¶ v)Æ);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{19}
\vfill
{\small
=GFT ProofPower output
Tactic produced 0 subgoals:
(* *** Goal "2" *** *)

(*  5 *)  Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
(*  4 *)  Ò x ç XÆ
(*  3 *)  Ò y ç XÆ
(*  2 *)  Ò P xÆ
(*  1 *)  Ò ≥ R yÆ

(* ?Ù *)  Ò falseÆ
=SML
a (z_spec_asm_tac Ò µ v, w : X ∑ ≥ P w ≤ R vÆ
	Ò (v ¶ y, w ¶ x)Æ);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=SML
pop_thm();
=GFT ProofPower output
Now 0 goals on the main goal stack
val it = Ù (µ x, y : X ∑ P x ¥ R y) §
	(µ v, w : X ∑ ≥ P w ≤ R v) : THM   
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{}

\begin{center}
{\bf The Z Language - Preliminaries}
\end{center}

\vfill

The following schemas are defined to provide examples for the schema-calculus.

\vfill

{\tiny
=SML
open_theory"z_bags";
new_theory"schema-calculus";
set_pc "z_language";
=TEX
\vfill
πZ
[NAME,DATE]
∞
\vfill
ˇFile¸¸¸¸¸¸¸
‹ people :  NAME;
‹ age : NAME ﬂ DATE
˜¸¸¸¸¸¸¸¸
‹ dom age = people
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFile2¸¸¸¸¸¸¸
‹ people :  NAME;
‹ height : NAME ﬂ ˙
˜¸¸¸¸¸¸¸¸
‹ dom height = people
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFile3¸¸¸¸¸¸¸
‹ people :  NAME
à¸¸¸¸¸¸¸¸¸¸
\vfill
ˇFileOp¸¸¸¸¸¸¸
‹ File;File'; i?:Ó
à¸¸¸¸¸¸¸¸¸¸
\vfill
}%\tiny

\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Z ``Terms''}
\end{center}
\vfill
{\small
\begin{itemize}
\item
{\bf Z Term Quotations}

Predicates, expressions, and schema expressions may be entered in Z using the Z quotation character ``
=INLINEFT
Ò
=TEX
'', e.g.:
=INLINEFT
 Ò{x:˙ | x>0 ∑ x*x}Æ
=TEX
.
\item
{\bf Extended Z}

ProofPower accepts an extended Z language for convenience in formal proof, provided that the system control flag $standard\_z\_terms$ is set to $false$.

\item
{\bf Standard Z}

Eventually we intend ProofPower to be prepared to check fully against the forthcoming Z standard.

{\tiny
The norm would then be to check specifications against the standard, but permit the extended language for use in proofs.
}%\tiny

\end{itemize}

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower}

\end{center}

\vfill

{\ftlmargin=0.8in 

\begin{itemize}
\item
HOL terms are used to represent Z.

\item
The ``concrete datatype'' {\bf Z\_TERM} reveals\\
the structure of terms representing values in Z.

\item
The function:
=SML
dest_z_term : TERM -> Z_TERM;
=TEX
may be used to disassemble a TERM which represents Z, and
=SML
mk_z_term : Z_TERM -> TERM;
=TEX
may be used to construct a TERM representing a Z construct.
\end{itemize}

}%\ftlmargin

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
declarations}

\end{center}

\vfill
{\small
=GFT
datatype	€Z_TERM› =

   €ZDec›		(* declaration, e.g.
   			ëdec_of Ò[x,y:˙]ÆÆ *)
  		of TERM list	(* variables *)
  		* TERM		(* expression *)
  		
  			
 | €ZSchemaDec› 	(* schema reference, e.g.
 			ëdec_of Ò[File!]ÆÆ *)
		of TERM	(*schema expression*)
		* string		(* decoration *)
		
			
 | €ZDecl› 	(* declaration list, e.g.
 			ëdecl_of Ò[x,y:˙; File!]ÆÆ *)
		of TERM list	(* declarations *)
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
propositional connectives}

\end{center}
\vfill
{\tiny
=GFT
 | €ZTrue›	(* Ò trueÆ *)
 
 | €ZFalse›	(* Ò falseÆ *)
 
 | €Z≥›	(* negation, e.g. Ò ≥ pÆ *)
 	of TERM	(* predicate *)
 			
 | €Z±›	(* conjunction, e.g. Ò p ± qÆ *)
 	of TERM * TERM	(* predicates *)
 			
 | €Z≤›	(* disjunction, e.g. Ò p ≤ qÆ *)
 	of TERM * TERM	(* predicates *)
 			
 | €Z¥›	(* implication, e.g. Ò p ¥ qÆ *)
 	of TERM * TERM 	(* predicates *)
 			
 | €Z§›	(* bi-implication, e.g. Ò p § qÆ *)
 	of TERM * TERM 	(* predicates *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
quantifiers and relations}

\end{center}
\vfill
{\tiny
=GFT
 | €Z∂›	(* existential quantification, Ò ∂ File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)
 		
 			
 | €Z∂â1›	(* unique existential quantification, Ò ∂â1 File | p ∑ qÆ *)
 		of TERM		(* declaration *)
 		* TERM * TERM	(* predicates *)

 		
 | €Zµ›	(* universal quantification, Ò µ File | p ∑ qÆ *)
		of TERM		(* declaration *)
		* TERM * TERM	(* predicates *)
		

 | €ZEq›	(* equation, e.g. Ò a = bÆ *)
 		of TERM * TERM	(* expressions *)
 		
 			
 | €Zç›	(* membership, e.g. Ò a ç bÆ *)
		of TERM * TERM	(* expressions *)


 | €ZSchemaPred›	(* schema predicate, e.g.
 			Ò ê (File ')Æ *)
 		of TERM		(* schema expression *)
 		* string		(* decoration *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
expressions}

\end{center}

\vfill

{\tiny
=GFT
 | €ZLVar›	(* local variable Ò xÆ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 		
 | €ZGVar› 	(* global variable Ò U[DATE]Æ *)
 		of string	(* variable name *)
 		* TYPE	(* HOL type of variable *)
 		* TERM list	(* generic parameters *)
 		
 | €ZInt› 	(* positive integer literal Ò 34Æ *)
 		of string
 		
 | €ZString›	(* string literal Ò "characters"Æ *)
 		of string
 		
 | €ZApp›	(* function application  Ò f xÆ  *)
 		of TERM * TERM	(* expressions *)
 		
 | €ZÃ›	(* lambda expression Ò Ã x:Ó | x > 3 ∑ x * x Æ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
 		* TERM	(* expression *)
 		
 | €ZÕ›	(* definite description Ò Õ x:Ó | x * x = 4 ∑ xÆ *)
 		of TERM	(* declaration *)
 		* TERM	(* predicate *)
		* TERM	(* expression *)
 		
 | €Z›	(* power set construction, Ò  ˙Æ *)
 	of TERM		(* expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
expressions (continued)}

\end{center}

\vfill

{\tiny
=GFT
 | €ZSetd›	(* set display, Ò {1,2,3,4} Æ *)
 	of TYPE		(* HOL type of elements *)
 	* TERM list	(* expressions *)
 		
 | €ZSeta›	(* set abstraction, Ò {x:˙ | 1ºxº4 ∑ x*x} Æ*)
 	of TERM	(* declaration *)
 	* TERM	(* predicate *)
 	* TERM	(* expression *)
 		
 | €ZTuple›	(* tuple, Ò (1,2,3,4) Æ *)
 	of TERM list	(* expressions *)
 		
 | €ZSelât›	(* tuple element selection, Ò (x,y).2Æ *)
 	of TERM	(* expression *)
 	* int		(* element number *)
 		
 | €Z∏›	(* cartesian product, Ò (˙ ∏ Ó) Æ *)
 	of TERM list	(* expressions *)
 		
 | €ZBinding› (* binding Ò (people ¶ {}, age ¶ {}) Æ *)
 	of (	string	(* component name *)
 		* TERM	(* component value *)
 		) list
 		
 | €ZSelâs›	(* binding component selection Ò (a ¶ 1, b ¶ "4").b Æ *)
 	of TERM	(* expression *)
 	* string	(* component name *)
 		
 | €Z ›	(* theta term Ò  File' Æ *)
 	of TERM	(* schema expression *)
 	* string	(* decoration *)
 		
 | €Zß¢›	(* sequence display Ò ß1,2,3¢ Æ *)
 	of TYPE	(* type of elements *)
 	* TERM list	(* values of elements *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (I)}

\end{center}

\vfill

{\tiny
=GFT
 | €Z≥âs›	(* schema negation Ò(≥ File)∫UÆ *)
		of TERM (* schema expression *)
			
 | €Z±âs›	(* schema conjunction Ò(File ± File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
			
 | €Z≤âs›	(* schema disjunction Ò(File ≤ File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
			
 | €Z¥âs›	(* schema implication Ò(File ¥ File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
			
 | €Z§âs›	(* schema equivalence Ò(File § File2)∫UÆ *)
		of TERM * TERM (* schema expressions *)
			
 | €Z∂âs›	(* schema existential
 		Ò(∂ File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
			
 | €Z∂â1âs›	(* schema unique existential
 		Ò(∂â1 File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
			
 | €Zµâs›	(* schema universal
 		Ò(µ File3 | people = {} ∑ File2)∫UÆ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		* TERM	(* schema expression *)
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Z Language in ProofPower\\
schema expressions (II)}

\end{center}

\vfill

{\tiny
=GFT
 | €Zâs›	(* horizontal schema expression
 		Ò [x:˙ | x>0] Æ *)
		of TERM	(* declaration *)
		* TERM	(* predicate *)
		
 | €ZDecorâs› (* decoration Ò File ''Æ *)
 		of TERM	(* schema expression *)
 		* string	(* decoration *)
 		
 | €ZPreâs›	(* pre-condition Ò pre FileOpÆ *)
 		of TERM	(* schema expression *)
 		
 | €ZHideâs›	(* schema hiding Ò FileOp \âs (age, i?)Æ  *)
 		of TERM	(* schema expression *)
 		* string list	(* component names *)
 		
 | €ZRenameâs› (* schema renaming
 			ÒFile [aged/age, input/i?]Æ *)
 		of TERM	(* schema expression *)
 		* (string * string) list	(* rename list *)
 		
 | €Z˘âs›	(* schema projection ÒFileOp ˘âs FileÆ*)
 		of TERM * TERM	(* schema expressions *)
=TEX
=GFT
 | Zªâs	(* schema composition ÒÑFile ªâs ÑFileÆ *)
 		of TERM * TERM	(* schema expressions *)
 		
 | €ZÑâs›	(* delta operation ÒÑFileÆ *)
 		of TERM	(* schema expression *)
 		
 | €Zòâs›	(* ò operation ÒòFileÆ *)
 		of TERM	(* schema expression *)
;
=TEX
}%\tiny

\vfill
\end{slide}

% =====================================================================
{\small
% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Function Application}

\end{center}

\vfill

Applications of lambda abstractions can be eliminated by (conditional) ¬-conversion.

=SML
z_¬_conv Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower outputval
val it = P a, a ç X Ù
	(Ã x : X | P x ∑ f x) a = f a : THM   
=TEX
\vfill

Other applications may be eliminated in favour of definite descriptions.

=SML
z_app_conv Ò f aÆ;
=GFT ProofPower output
val it = Ù f a = Õ f_a : U
	| (a, f_a) ç f ∑ f_a : THM   
=TEX

More commonly function applications will be eliminated by rewriting with their definitions.

\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}

\begin{center}

{\bf Schema Predicates}

\end{center}

\vfill

These may be eliminated in favour of membership statements by rewriting with $z'schemapred\_def$:

\vfill
=SML
pure_rewrite_conv[z'schemapred_def]Ò ([x:X])'±trueÆ;
=TEX
=GFT ProofPower outputval
val it = Ù [x : X] ± true §
	(x ¶ x) ç [x : X] ± true : THM   
=TEX
\vfill
=SML
rewrite_conv[z'schemapred_def]Ò [x:X]±trueÆ;
=TEX
=GFT ProofPower outputval
val it = Ù [x : X] ± true § x ç X : THM   
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{33}

\begin{center}

{\bf Lambda Abstraction}

\end{center}

\vfill

For extensional reasoning:

=SML
rewrite_conv [] Òz ç (Ã x:X | P x ∑ f x)Æ;
=TEX
=GFT ProofPower outputval
val it = Ù z ç Ã x : X | P x ∑ f x §
	z.1 ç X ± P z.1 ± f z.1 = z.2 : THM   
=TEX

Lambda abstractions may be transformed into set abstractions.

=SML
z_Ã_conv Ò Ã x:X | P x ∑ f xÆ;
=GFT ProofPower outputval
val it = Ù Ã x : X | P x ∑ f x =
	{x : X | P x ∑ (x, f x)} : THM   
=TEX

\vfill

\begin{center}

{\bf Definite Description}

\end{center}

\vfill
=SML
z_Õ_rule Ò Õ x:X | P ∑ yÆ;
=GFT ProofPower output
val it = Ù µ x'
  ∑ Ò µ x : X | P ∑ y = x'Æ
  ± Ò ∂ x : X | P ∑ y = x'Æ
  ¥ Ò Õ x : X | P ∑ yÆ = x' : THM
=TEX
\vfill

\ignore{

=SML
z_¬_rule Ò (Ã x:X | P x ∑ f x) aÆ;
=GFT ProofPower output
val it = Ù µ x' : U
    ∑ (µ f_a : U |
		∂ x : X | P x ∑ x = a
		± f x = f_a ∑ f_a = x')
    ± (∂ x : X | P x ∑ x = a ± f x = x')
    ¥ (Ã x : X | P x ∑ f x) a = x' : THM
=TEX

}%\ignore

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf The Power Set Constructor}

\end{center}

\vfill

=SML	
z_ç__conv Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § (µ x1 : U ∑ x1 ç z ¥ x1 ç y) : THM   
=TEX

=SML	
rewrite_conv[] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y § z Ä y : THM   
=TEX
\ignore{	
pc_rule1 "z_sets_ext"
rewrite_conv[] Ò z ç  yÆ;
}%\ignore

\vfill

=SML	
rewrite_conv[z_Ä_thm] Ò z ç  yÆ;
=GFT ProofPower output
val it = Ù z ç  y
	§ (µ x : U ∑ x ç z ¥ x ç y) : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Set Displays}

\end{center}

\vfill

\ignore{	
=SML
open_theory"z_bags";

set_merge_pcs ["z_sets_alg", "'z_bindings",
	"'z_ç_rel", "'z_tuples", "'z_ç_fun"];
=TEX
}%\ignore

{\small
\begin{itemize}
\item
sets may be entered as terms by enumeration:
=SML
rewrite_conv [] Ò 5 ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù 5 ç {1, 2, 3, 4, 5} § true : THM
=TEX
=SML
rewrite_conv [] Ò 6 ç {1,2,3,4,5}Æ;
=GFT ProofPower output
val it = Ù 6 ç {1, 2, 3, 4, 5}
 § 6 = 1 ≤ 6 = 2 ≤ 6 = 3 ≤ 6 = 4 ≤ 6 = 5 : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Set Abstractions}

\end{center}

\vfill
{\small
\begin{itemize}
\item
sets may also be entered as set abstractions:
=SML
rewrite_conv[] Ò 9 ç {x:Ó | x < 12}Æ;
=GFT ProofPower output
val it =
Ù 9 ç {x : Ó | x < 12} § 9 ç Ó ± 9 < 12 : THM   
=SML
pc_rule1 "z_sets_alg"
rewrite_conv[]Ò z ç {x, y:Ó | x < y}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y}
	§ (z.1 ç Ó ± z.2 ç Ó) ± z.1 < z.2 : THM   
=TEX
=SML
rewrite_conv[]Ò z ç {x, y:Ó | x < y ∑ x * y - x}Æ;
=GFT ProofPower Output
val it = Ù z ç {x, y : Ó | x < y ∑ x * y - x}
    § (∂ x, y : Ó | x < y ∑ x * y - x = z) : THM
=TEX
\end{itemize}
}%\small

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Tuples}

\end{center}

\vfill

=SML
rewrite_conv[] Ò (x,y) = (a,b)Æ;
=GFT ProofPower output
val it = Ù (x, y) = (a, b)
	§ x = a ± y = b : THM   
=TEX

\vfill

=SML
rewrite_conv[] Ò (x,y).1Æ;
=GFT ProofPower output
val it = Ù (x, y).1 = x : THM   
=TEX

\vfill

\begin{center}

{\bf Bindings}

\end{center}

\vfill

=SML
rewrite_conv[]
	Ò (x ¶ a, y ¶ b) = (y ¶ d, x ¶ c)Æ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b) = (x ¶ c, y ¶ d)
	§ a = c ± b = d : THM   
=TEX

=SML
rewrite_conv[] Ò (x ¶ a, y ¶ b).yÆ;
=GFT ProofPower output
val it = Ù (x ¶ a, y ¶ b).y = b : THM   
=TEX

\vfill

\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf Cartesian Products}

\end{center}

\vfill
=SML
rewrite_conv[] Ò (a, b) ç (x ∏ y)Æ;
=GFT ProofPower output
val it = Ù (a, b) ç x ∏ y
	§ a ç x ± b ç y : THM   
=TEX

=SML
rewrite_conv[z_sets_ext_thm]
	Ò (x ∏ y) = (a ∏ b)Æ;
=GFT ProofPower output
it = Ù x ∏ y = a ∏ b
	§	(µ z : U ∑ z.1 ç x ± z.2 ç y
    		§ z.1 ç a ± z.2 ç b) : THM
=TEX
\vfill

\begin{center}

{\bf Theta Terms}

\end{center}
\vfill

=SML
rewrite_conv[z' _def] Ò  ([x:X; y:Y])'Æ;
=GFT ProofPower output
val it = Ù  [x : X; y : Y]'
	= (x ¶ x', y ¶ y') : THM   
=SML
z_ _conv Ò  ([x:X; y:Y])'Æ;
=GFT ProofPower output
val it = Ù  [x : X; y : Y]'
	= (x ¶ x', y ¶ y') : THM   
=TEX
\vfill

\end{slide}


% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Negation}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (≥ File)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (≥ File) § ≥ z ç File : THM   
=TEX

\vfill

\begin{center}
{\bf Schema Conjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ± File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ± File2) §
 (age ¶ z.age, people ¶ z.people) ç File ±
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Disjunction}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ≤ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ≤ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ≤
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Implication}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File ¥ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File ¥ File2) §
 (age ¶ z.age, people ¶ z.people) ç File ¥
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill


\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Equivalence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (File § File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File § File2) §
 (age ¶ z.age, people ¶ z.people) ç File §
 (height ¶ z.height, people ¶ z.people) ç File2 : THM
=TEX

\vfill

\begin{center}
{\bf Schema Existential}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂ File3 | people = {} ∑ File2) §
 (∂ x1 : U ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Unique Existence}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (∂â1 File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (∂â1 File3 | people = {} ∑ File2) §
 (∂â1 x1 : U ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\begin{center}
{\bf Schema Universal}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç (µ File3 | people = {} ∑ File2)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (µ File3 | people = {} ∑ File2) §
 (µ x1 : U ∑
   ((people ¶ x1.people) ç File3
   ± x1.people = {})
   ± (height ¶ z.height, people ¶ x1.people) ç File2)
   : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schemas}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç [x:˙;y:Ó]Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç [x : ˙; y : Ó]
	§ z.x ç ˙ ± z.y ç Ó : THM   
=TEX

\vfill

\begin{center}
{\bf Decoration}
\end{center}

\vfill

=SML
rewrite_conv[]Òz ç File ''Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File'')	§
 (age ¶ z.age'', people ¶ z.people'') ç File : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Pre-Condition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (pre FileOp)Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (pre FileOp) §
 z ç	[age : U; i? : U; people : U
	| ∂ age' : U; people' : U ∑ FileOp] : THM
=TEX

\vfill

\begin{center}
{\bf Schema Hiding}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age)) §
	z ç [people : U | ∂ age : U ∑ File] : THM
=TEX

\vfill
=SML
rewrite_conv[]Òz ç (File \âs (age))Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File \âs (age))
    § (∂ age : U ∑
    	(age ¶ age, people ¶ z.people) ç File) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Renaming}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç File[aged/age]Æ;
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (File [aged/age]) §
	(age ¶ z.aged, people ¶ z.people) ç File : THM
=TEX

\vfill

\begin{center}
{\bf Schema Projection}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ˘âs File)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ˘âs File)
    § z ç ((FileOp ± File) \âs (age', i?, people')) : THM
=TEX

\vfill

\end{slide}
% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Schema Composition}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (FileOp ªâs FileOp)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (FileOp ªâs FileOp)
    § z
      ç (∂ [age : U; people : U]''
        ∑ (∂ [age : U; people : U]'
            ∑ [FileOp; [age''' : U; people''' : U]''
              |  [age''' : U; people''' : U]'
                =  [age''' : U; people''' : U]''])
          ± (∂ [age' : U; people' : U]
            ∑ [FileOp; [age''' : U; people''' : U]''
              |  [age''' : U; people''' : U]
                =  [age''' : U; people''' : U]''])) : THM
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================
\begin{slide}{}

\begin{center}
{\bf Delta}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (ÑFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (Ñ File) §
	z ç [File; File'] : THM   
=TEX

\vfill
\begin{center}
{\bf Delta}
\end{center}

\vfill

=SML
once_rewrite_conv[]Òz ç (òFile)Æ; (*  *)
=TEX

\vfill

=GFT ProofPower output
val it = Ù z ç (ò File) §
	z ç [File; File' |  File =  File'] : THM   
=TEX

\vfill

\end{slide}

}%\small

% =====================================================================

\ignore{
(* spiveys defn :
ˇS¸¸¸¸¸¸¸
‹ a,b,a':Ó
à¸¸¸¸¸¸¸¸¸¸
ˇT¸¸¸¸¸¸¸
‹ a,b,b':Ó
à¸¸¸¸¸¸¸¸¸¸
ˇState¸¸¸¸¸¸¸
‹ a:Ó
à¸¸¸¸¸¸¸¸¸¸

ÒScompT = (∂ State'' ∑
	(∂ State' ∑ [S |  State' =  State''])±
	(∂ State ∑ [T |  State =  State'']))Æ; (*  *)

}%\ignore

=TEX
% =====================================================================

\begin{slide}{50}
\begin{center}
{\bf Z Paragraphs}
\end{center}
\vfill
\begin{itemize}
\item
Fixity declarations
\item
Given sets
\item
Abbreviation definitions
\item
Schema boxes
\item
Axiomatic descriptions
\item
Generics
\item
Free types
\item
Constraints
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Z Paragraphs\\
Paragraph Processing Modes and Flags}
\end{center}
\vfill
{\small
There are several different modes of processing Z paragraphs which are controlled by flags.

\begin{itemize}
\item
{\bf Type-checking Mode}

If the flag $z\_type\_check\_only$ is set to $true$ then only type checking of Z paragrpahs is performed.

{\tiny
This makes the response faster, and permits greater flexibility in amending paragraphs.
This mode is suitable for use while developing specifications prior to undertaking any proof work.
}

\item
{\bf Axiomatic Mode}
 
If the flag $z\_use\_axioms$ is set to true (and\\
$z\_type\_check\_only$ is set to $false$) then axiomatic descriptions and free-type descriptions are introduced using axioms.


\item
{\bf Conservative Mode}

If both the above flags is set $false$ then all Z axiomatic descriptions are introduced using the ProofPower\\
$new\_specification$ facility, i.e. by conservative extension.

{\tiny
Consistency proof obligations, unless discharged automatically, will have to be discharged by the user.

In a future release it is hoped that free-types will also be supported by conservative extension.
}%\tiny

\end{itemize}

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\vfill
{\small
=SML
open_theory "z_bags"; 
new_theory "paragraphs";
set_pc "z_sets_alg";
=TEX
\begin{center}
{\bf Fixity Declarations}
\end{center}
\ftlmargin 0.5in
Fixity delcarations may be provided for:
\begin{itemize}
\item
functions
πZ
fun 10 twice _
∞
πZ
fun  slice ... from _ to _ 
∞
\item
generics
πZ
gen _ swap _
∞
\item
relations
πZ
rel  _ is_even 
∞
\end{itemize}

\vfill

The optional numeric value is a priority.

`\_' is a space for a parameter\\
`...' is a space for a sequence of parameters (with sequence brackets elided)

Fixity clauses can only be deleted by deleting the theory they are contained in.

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Given Sets}
\end{center}

\vfill

πZ
[G1, G2]
∞

\vfill

=SML
val G1_def = z_get_spec ÒG1Æ;
=GFT ProofPower output
val G1_def = Ù G1 = U : THM   
=TEX

\vfill

=SML
rewrite_conv [G1_def] Òx ç G1Æ;
=GFT ProofPower output
val it = Ù x ç G1 § true : THM   
=TEX

\vfill

\begin{center}
{\bf Abbreviation Definition}
\end{center}

{\small
\vfill

πZ
X swap Y ¶ Y ∏ X 
∞

\vfill

=SML
val swap_def = z_get_spec Ò(_swap_)Æ;
=GFT ProofPower Output
val swap_def =
Ù [X, Y](X swap Y = Y ∏ X) : THM   
=TEX

\vfill

=SML
rewrite_conv [swap_def] Ò˙ swap ÓÆ;
=TEX
=GFT ProofPower Output
val it = Ù ˙ swap Ó = Ó ∏ ˙ : THM   
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Schema Boxes}
\end{center}
\vfill
{\small
ˇSch¸¸¸¸¸¸¸¸¸¸¸¸
‹	x, y : ˙;
‹	z : Ó
˜¸¸¸¸¸¸¸¸¸
‹	x = y ≤ y = z
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
val sch_def = z_get_spec ÒSchÆ;
=GFT ProofPower Output
val sch_def = Ù Sch =
  [x, y : ˙; z : Ó | x = y ≤ y = z] : THM   
=TEX
=SML
rewrite_conv [sch_def (*, z'schemapred_def*)]
 Òµ x,y:˙; z:Ó ∑ Sch ≤ disjoint ß{x},{y},{z}¢Æ;
=TEX
=GFT ProofPower Output
val it = Ù (µ x, y : ˙; z : Ó ∑ Sch
		≤ disjoint ß{x}, {y}, {z}¢)
    § (µ x, y : ˙; z : Ó
      ∑ [x, y : ˙; z : Ó | x = y ≤ y = z]
      	≤ disjoint ß{x}, {y}, {z}¢) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Generic Schema Boxes}
\end{center}
\vfill
{\small
ˇDSUBS[X]¸¸¸¸¸¸¸¸¸¸¸
‹	set1, set2:  X
˜¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	set1 ° set2 = {}
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
=SML
val dsubs_def = z_get_spec ÒDSUBSÆ;
=GFT ProofPower Output
val dsubs_def = Ù [X](DSUBS[X] =
  [set1, set2 :  X | set1 ° set2 = {}]) : THM
=TEX
\vfill
=SML
rewrite_conv [dsubs_def (*, z'schemapred_def*)]
 Òµ DSUBS[Ó] ∑ set1 Ä Ó ± set2 Ä ÓÆ;
=GFT ProofPower Output
val it = Ù (µ (DSUBS[Ó]) ∑ set1 Ä Ó ± set2 Ä Ó)
	§ (µ [set1, set2 :  Ó | set1 ° set2 = {}] ∑
		set1 Ä Ó ± set2 Ä Ó) : THM
=TEX
\vfill
\ignore{
set_goal([],Òµ DSUBS[Ó] ∑ set1 Ä Ó ± set2 Ä ÓÆ);
a (z_strip_tac THEN rewrite_tac [dsubs_def,z'schemapred_def]);
a (conv_tac (MAP_C z_ç_horiz_schema_conv));
 THEN REPEAT strip_tac);
=TEX
=GFT ProofPower Output
val it = Ù (µ (DSUBS[Ó]) ∑ set1 Ä Ó ± set2 Ä Ó)
    § (µ [set1, set2 :  Ó | set1 ° set2 = {}] ∑
    		set1 Ä Ó ± set2 Ä Ó) : THM
=TEX
}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Axiomatic Descriptions}
\end{center}
\vfill
{\small
πZAX
‹	twice _ : ˙ ≠ ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	µi : ˙ ∑ twice i = 2*i
∞
\vfill
=SML
val twice_def = z_get_spec Ò(twice_)Æ;
=GFT ProofPower Output
val twice_def = Ù (twice _) ç ˙ ≠ ˙
	± (µ i : ˙ ∑ twice i = 2 * i) : THM   
=TEX
\vfill
=SML
rewrite_conv[twice_def] Òtwice 4Æ;
=GFT ProofPower Output
Exception- Fail * no rewriting occurred
  [rewrite_conv.26001] * raised
=TEX
\vfill
=SML
set_goal([],Òµ n:˙ ∑ twice n = 2*nÆ);
a (REPEAT z_strip_tac);
=GFT ProofPower Output
(* *** Goal "" *** *)

(*  1 *)  Òn ç ˙Æ

(* ?Ù *)  Òtwice n = 2 * nÆ
=TEX
\vfill
=SML
a (fc_tac [twice_def]);
=GFT ProofPower Output
Current and main goal achieved
=TEX
\ignore{
πZAX
‹	_ is_even : ˙
˜¸¸¸¸¸¸¸¸¸¸¸
‹	( _ is_even) = ran (twice _)
∞

πZAX
‹	fact : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	fact 0 = 1;
‹	µn:Ó∑	fact (n+1) = fact n * (n+1)
∞
}%\ignore
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Generic Axiomatics}
\end{center}
\vfill
{\small
ù[X]úúúúúúúúúúúúúúúúúúúúúúúúúúú
‹ slice ... from _ to _ : ((seq X) ∏ Ó ∏ Ó) ≠ seq X
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ l,r:Ó; s: seq X ∑
‹	(slice ... from _ to _) (s,l,r) = (l .. r) Ú s
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\vfill
=SML
val slice_from_to_def =
  z_get_spec Ò(slice ... from _ to _)Æ;
=GFT ProofPower Output
val slice_from_to_def = Ù
 [X]((slice ... from _ to _)[X]
 		ç (seq X) ∏ Ó ∏ Ó ≠ seq X
 ± (µ l, r : Ó; s : seq X ∑
 	(slice ... from _ to _)[X] (s, l, r)
 	= (l .. r) Ú s)) : THM
=TEX
\vfill
\ignore{
=SML
set_goal([],Òµ n:˙; x,y,n:Ó | ßn¢ ç seq U ∑
	slice n from x to y = ßn¢Æ);
a (REPEAT z_strip_tac);
a (ALL_FC_T rewrite_tac [slice_from_to_def]);
=TEX
ù[A, B, C]úúúúúúúúúúúúúúúúúúúúúúúú
‹	cycle : A ∏ B ∏ C ≠ C ∏ A ∏ B
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µx : A; y : B; z : C∑ cycle(x, y, z) = (z, x, y)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ù[X]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ length : seq X ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	length ß¢ = 0;
‹	µ h:X; t: seq X∑
‹	length (ßh¢ Î t) = length t + 1
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Free Types}
\end{center}
\vfill

{\small
πZ
TREE ::= tip | fork (Ó ∏ TREE ∏ TREE)
∞
\vfill

=SML
val tree_def = z_get_spec ÒTREEÆ;
=GFT ProofPower Output
val tree_def = Ù TREE = U : THM   
=TEX

\vfill

=SML
val tip_def = z_get_spec ÒtipÆ;
=GFT ProofPower Output
val tip_def = Ù (tip ç TREE
 ± fork ç Ó ∏ TREE ∏ TREE ‡ TREE)
 ± disjoint ß{tip}, ran fork¢
 ± (µ W :  TREE | {tip} ¿ fork ® Ó ∏ W ∏ W © Ä W∑
	TREE Ä W) : THM
=TEX


}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Mutually Recursive Free Types}
\end{center}
\vfill

{\small

πZ
TYPE ::= Tvar G1 | Tcon (G1 ∏ seq TERM)
&
TERM ::= Con (G1 ∏ TYPE) | App (TERM ∏ TERM)
∞
πZ
 tip Ω fork(2, tip, tip) ±
 tip ç TREE ±
 cycle(1, (1,2), (1, 2, 3))
 	ç (˙ ∏ ˙ ∏ ˙) ∏ ˙ ∏ (˙ ∏ ˙)
∞

\vfill

=SML
val tvar_def = z_get_spec ÒTvarÆ;
=GFT ProofPower Output
val tvar_def = Ù (Tvar ç G1 ‡ TYPE
    ± Tcon ç G1 ∏ (seq TERM) ‡ TYPE
    ± Con ç G1 ∏ TYPE ‡ TERM
    ± App ç TERM ∏ TERM ‡ TERM)
    ± (disjoint ßran Tvar, ran Tcon¢
    ± (µ W :  TYPE
      | Tvar ® G1 © ¿ Tcon ® G1 ∏ (seq TERM) © Ä W
      ∑ TYPE Ä W))
    ± disjoint ßran Con, ran App¢
    ± (µ W :  TERM
      | Con ® G1 ∏ TYPE © ¿ App ® W ∏ W © Ä W
      ∑ TERM Ä W) : THM
=TEX

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Constraints}
\end{center}
\vfill

{\small

πZ
[X] ((∂f : X ‡ G1 ∑ true)
	§ (∂f : X ‡ G2 ∑ true))
∞

\vfill

=SML
val c1 = get_axiom "-" "Constraint 1";
=GFT ProofPower output
val c1 = Ù [X]((∂ f : X ‡ G1 ∑ true) §
		(∂ f : X ‡ G2 ∑ true)) : THM   
=TEX

\vfill

πZ
 {1} swap {ß1¢} = {ß1¢} ∏ {1}
 	± Sch Ω [x, y, z : ˙] 
∞

\vfill

πZ
 tip Ω fork(2, tip, tip) ±
 tip ç TREE ±
 cycle(1, (1,2), (1, 2, 3))
 	ç (˙ ∏ ˙ ∏ ˙) ∏ ˙ ∏ (˙ ∏ ˙)
∞

\vfill

}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Theories}
\end{center}
\vfill
Z Theories contain the following information:
\begin{itemize}
\item
The theory name and the names of the theories parents and children.
\item
The names of types (given sets) declared in the theory.
\item
The names and types of `global variables' declared in the theory.
\item
Fixity information.
\item
Axioms or specifications corresponding to the paragraphs of the Z specification introduced in this theory.
\item
A collection of saved theorems.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{59}
\begin{center}
{\bf Exercises 3: Specification}
\end{center}

\vfill

\begin{itemize}
\item
Create a new theory as a child of ``hol''.
=GFT
new_theory "tutorial";
=TEX
\item
Write a specification in Z of a function to add the elements of a sequence of numbers.

{\tiny HINT: if your specification goes in as a ``Constspec'' then they system could not prove it consistent, and its probably either wrong or poorly structured.
Try to make it clearly `primitive recursive'.}
\item
Use it to ``evaluate'' the term\\
=INLINEFT
Ò list_sum ß1,2,3,4,5¢Æ
=TEX
.
=GFT
rewrite_conv[get_specÒ list_sumÆ]
	Ò list_sum ß1,2,3,4,5Æ;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{63}
\begin{center}
\bf A Selection of Useful Rules (I)
\end{center}
\vfill
\begin{itemize}
\item assume rule:
=SML
open_theory"z_numbers";
val thm1 = asm_rule Ò µx, y:Ó∑ x*y > 0Æ;
=GFT ProofPower Output
val thm1 = µ x, y : Ó ∑ x * y > 0
	Ù µ x, y : Ó ∑ x * y > 0 : THM   
=TEX
\item modus ponens
=SML
val thm_a = asm_rule ¨Ò aÆ:BOOLÆ;
val thm_b = asm_rule Ò a¥bÆ;
=GFT ProofPower Output
val thm_a = a Ù a : THM
val thm_b = a ¥ b Ù a ¥ b : THM   
=SML
val thm_c = ¥_elim thm_b thm_a;
=GFT ProofPower Output
val thm_c = a ¥ b, a Ù b : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{64}
\begin{center}
\bf A Selection of Useful Rules (II)
\end{center}
\vfill
\begin{itemize}
\item specialisation
=SML
val thm2 = z_µ_elim Ò (x¶455, y¶32)Æ thm1;
=GFT ProofPower Output
val thm2 = µ x, y : Ó ∑ x * y > 0
 Ù {455, 32} Ä Ó ± true ¥ 455 * 32 > 0 : THM
=TEX
\item removing outermost universals
=SML
val thm4 = z_all_µ_elim z_all_µ_intro  thm1;
=GFT ProofPower Output
val thm4 = µ x y∑ x * y > 0 Ù x * y > 0 : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{65}
\begin{center}
\bf A Selection of Useful Rules (III)
\end{center}
\vfill
\begin{itemize}
\item splitting conjunctions
=SML
val thm5 = z_µ_elim Ò (i¶(i∫˙))Æ z_plus_order_thm;
=GFT ProofPower output
val thm5 = Ù i ç U ± true
    ¥ (µ j, k : U
      ∑ j + i = i + j
      ± (i + j) + k = i + j + k
      ± j + i + k = i + j + k) : THM
\item adding universals
=SML
val thm6 = z_µ_intro thm5;
=GFT ProofPower output
val thm6 = Ù µ i : U
    ∑ µ j, k : U
      ∑ j + i = i + j
      ± (i + j) + k = i + j + k
      ± j + i + k = i + j + k : THM
=TEX
\end{itemize}
\vfill
\end{slide}
}%\small
% =====================================================================

\begin{slide}{66}
\begin{center}
\bf Exercises 4: Forward Proof
\end{center}
\vfill
{\small
=IGN
asm_rule
strip_±_rule
¥_elim
z_µ_elim
all_µ_elim
list_µ_elim
all_µ_intro
list_µ_intro
z_Ó_≥_plus1_thm
º_trans_thm
≥_less_thm
=SML
(*
1. Using ¥_elim, asm_rule and ¥_intro prove:
	(a)	b¥c, a¥b, a Ù c
	(b)	a¥b¥c, a, b Ù c
	(c)	a¥b¥c, b Ù a¥c
	
2. Using z_µ_elim with z_Ó_≥_plus1_thm prove:
	(a)	0 ç Ó ± true ¥ ≥ 0 + 1 = 0   
	(b)	x * x ç Ó ± true ¥ ≥ x * x + 1 = 0  
	 
3. Using prove_rule with z_º_trans_thm prove:
		i º j ± j º k ¥ i º k : THM
		
4. Using prove_rule and with z_Ó_≥_plus1_thm
	and z_0_Ó_thm prove:
	(a)	≥ 0 + 1 = 0   
	(b)	x * x ç Ó ¥ ≥ x * x + 1 = 0 
	 
5. Using ?list_µ_elim prove:
	(a) (with z_≥_less_thm)
		≥ 0 < 1 § 1 º 0
	(b)(with º_trans_thm)
		µ n∑ 3 º x * x ± x * x º n ¥ 3 º n
		  
6. Using all_µ_elim, strip_±_rule, nth, all_µ_intro:
	(a)(with º_clauses)
		µ i m n∑ i + m º i + n § m º n
	(b)(using list_µ_intro)
		µ m i n∑ i + m º i + n § m º n
*)
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{67}
\begin{center}
\bf Exercises 4: Solutions
\end{center}
\vfill
=SML
(* 1(a) *)
val ext1a_thm1 = asm_rule Ò a¥bÆ;
val ext1a_thm2 = asm_rule Ò b¥cÆ;
val ext1a_thm3 = asm_rule Ò a∫{true,false}Æ;
val ext1a_thm4 = ¥_elim ext1a_thm1 ext1a_thm3;
val ext1a_thm5 = ¥_elim ext1a_thm2 ext1a_thm4;
(* 1(b) *)
val ext1b_thm1 =
 ¥_elim (asm_rule Ò a¥b¥cÆ)(asm_rule Ò a∫{true,false}Æ);
val ext1b_thm2 =
 ¥_elim ext1b_thm1(asm_rule Ò b∫{true,false}Æ);
(* 1(c) *)
val ext1c_thm1 = ¥_intro Ò a∫{true,false}Æ ext1b_thm2;
=SML
(* 2(a) *)
val ext2a_thm1 = z_µ_elim Ò 0Æ z_Ó_≥_plus1_thm;
(* 2(b) *)
val ext2b_thm1 = z_µ_elim Ò x*xÆ z_Ó_≥_plus1_thm;

(* 3 *)
val ext3_thm = prove_rule [z_º_trans_thm]
	Ò i º j ± j º k ¥ i º kÆ ;
=SML
(* 4(a) *)
val ext4a_thm1 = prove_rule [z_Ó_≥_plus1_thm]
	Ò 0 ç Ó ¥ ≥ 0 + 1 = 0Æ;
val ext4a_thm2 = ¥_elim ext3a_thm1 z_0_Ó_thm;
(* 5(a) *)
val ext5_thm = prove_rule[z_º_trans_thm]
	Ò i º j ± j º k ¥ i º kÆ;
=TEX
\ignore{
=SML
(* (a) *)
val ext6_thm1 = list_µ_elim [Ò 0Æ,Ò 1Æ] z_≥_less_thm;
(* (b) *)
val ext7_thm1 = list_µ_elim [Ò 3Æ,Ò x*xÆ] º_trans_thm;
=TEX
=SML
(* (a) *)
val ext8_thm1 = strip_±_rule (all_µ_elim z_º_clauses);
val ext8_thm2 = all_µ_intro (nth 3 ext8_thm1);
(* (b) *)
val ext8_thm2 = list_µ_intro [Ò mÆ,Ò iÆ,Ò nÆ]
	(nth 3 ext8_thm1);
=TEX
}
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{68}
\begin{center}
\bf Goal Oriented Proof
\vfill
Works exactly the same as for HOL.

Make sure you are in a Z theory.

Make sure you have a Z proof context.

Terms should be entered using Z quotes
=INLINEFT
Ò Æ
=TEX
.

\bf Rewriting

Use same facilities as for HOL in appropriate proof contexts.

\bf Stripping

Use same facilities as for HOL in appropriate proof contexts.
\end{center}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{71}
\begin{center}
\bf Exercises 5:
Rewriting with the Subgoal Package
\end{center}
\vfill
{\small
\begin{enumerate}
\item
set a goal from the examples on set theory, e.g.:
=SML
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
=TEX
\item
rewrite the goal using the current proof context:
=SML
a (rewrite_tac[]);
=TEX
\item
step back using undo:
=SML
undo 1;
=TEX
\item
now try rewriting without using the proof context:
=GFT
a (pure_rewrite_tac[]);
=TEX
(this should fail)
\end{enumerate}
}%\small
\vfill

\end{slide}

% =====================================================================

\begin{slide}{72}
\begin{center}
\bf Exercises 5 continued
\end{center}
\vfill
{\small
\begin{enumerate}
\setcounter{enumi}{4}
\item
try rewriting one layer at a time:
=SML
a (once_rewrite_tac[]);
=TEX
repeat until it fails.
\item
now try rewriting with specific theorems:
=SML
set_goal([],Ò a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
a (pure_rewrite_tac[sets_ext_clauses]);
a (pure_rewrite_tac[set_dif_def]);
a (pure_rewrite_tac[°_def, ¿_def]);
a (pure_rewrite_tac[set_dif_def]);
=TEX
\item
finish the proof by stripping:
=SML
a (REPEAT strip_tac);
=TEX
\item
extract the theorem
=SML
top_thm();
=TEX
\item repeat the above then try repeating:
=SML
pop_thm();
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{73}
\begin{center}
\bf Exercises 6:
combining forward and backward proof
\end{center}
\vfill
{\small
Prove the following results by rewriting using the goal package:
{\tiny for each example try the previous methods to see how they fail before following the hint
}%\tiny
\begin{enumerate}
\item :
=SML
set_goal([],Ò x + y = y + xÆ);
=TEX
\item :
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
(* hint : try using plus_assoc_thm *)
=TEX
\item :
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
(* hint : try using plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
(* hint : try using µ_elim with plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
(* hint : try using µ_elim with plus_order_thm *)
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{74}
\begin{center}
\bf Exercises 6: Solutions
\end{center}
\vfill
\begin{enumerate}
\item :
=SML
set_goal([],Ò x + y = y + xÆ);
a (rewrite_tac[]);
=TEX
\item :
=SML
set_goal([],Ò x + y + z = (x + y) + zÆ);
a (rewrite_tac[plus_assoc_thm]);
=TEX
\item :
=SML
set_goal([],Ò z + y + x = y + z + xÆ);
a (rewrite_tac[plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],Ò x + y + z = y + z + xÆ);
a (rewrite_tac[µ_elim Ò yÆ plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],Ò x + y + z + v = y + v + z + xÆ);
a (rewrite_tac[µ_elim Ò xÆ plus_order_thm]);
=TEX
\end{enumerate}
\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{78}
\begin{center}
\bf Exercises 7: Stripping
\end{center}
\vfill
{\small
\begin{itemize}
\item
Use the examples from Principia Mathematica \& ZRM given earlier, e.g.:
=SML
	set_goal([],Ò p ± q ¥ (p § q)Æ);
=TEX
with
\begin{enumerate}
\item :
=SML
	a strip_tac;
=TEX
\item and/or:
=SML
	a step_strip_tac;
=TEX
\end{enumerate}
\item
Observe the steps taken and try to identify the reasons for discharge of subgoals.
\item
Select the weakest ``proof context'':
=SML
	push_pc "initial";
=TEX
then retry the examples (or previous exercises).
\item
When you have finished restore the original proof context by:
=SML
	pop_pc();
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{79}
\begin{center}
\bf Induction
\end{center}
\vfill
Induction principles for Z can be expressed as mixed language theorems in Higher Order Logic and Z e.g.:
\vfill
{\small
\begin{itemize}
=TEX
\item $z\_Ó\_induction\_thm$
=GFT
Ù µ p
  ∑ p Ò 0Æ
  ± (µ i∑ i ç Ò ÓÆ ± p i ¥ p Ò i + 1Æ)
  ¥ (µ m∑ m ç Ò ÓÆ ¥ p m) : THM
=TEX
\item $z\_˙\_induction\_thm$
=GFT
 Ù µ p
  ∑ p Ò 1Æ
  ± (µ i∑ p i ¥ p Ò ~ iÆ)
  ± (µ i j∑ p i ± p j ¥ p Ò i + jÆ)
  ¥ (µ m∑ p m) : THM
=TEX
\end{itemize}
}%\small
\vfill
$µ\_elim$ and $all\_¬\_rule$ may be used to specialise these for use in forward proofs.
\vfill
\end{slide}

% =====================================================================

\begin{slide}{80}
\begin{center}
\bf Induction Tactics
\end{center}
\vfill
{\small
Special tactics are available to facilitate the use\\
of induction principles:
\begin{itemize}
\item induction over natural numbers using\\
$z\_Ó\_induction\_tac$
=FRULE 2
z_Ó_induction_tac Ò xÆ
˜
{ á } t
˜
{ á } t[0/x];
strip{t, á} t[x+1/x]
=TEX
\item induction over integers using\\
$z\_˙\_induction\_tac$
=FRULE 2
z_˙_induction_tac Ò xÆ
˜

˜

=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================
\ignore{

\begin{slide}{81}
\begin{center}
\bf Induction - Example (I)
\end{center}
\vfill
Prove the associativity of append.
\vfill
{\small
=SML
set_goal([],Ò µl1 l2 l3 ∑
	(l1 @ l2) @ l3 = l1 @ (l2 @ l3)Æ);
(* remove universal quantifiers *)
a (REPEAT strip_tac);
=GFT ProofPower output
(* *** Goal "" *** *)

(* ?Ù *)  Ò (l1 @ l2) @ l3 = l1 @ l2 @ l3Æ
=SML
(* induct on Ò l1Æ *)
a (list_induction_tac Ò l1Æ);
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  Ò (l1 @ l2) @ l3 = l1 @ l2 @ l3Æ

(* ?Ù *)  Ò µ x∑ (Cons x l1 @ l2) @ l3
		= Cons x l1 @ l2 @ l3Æ

(* *** Goal "1" *** *)

(* ?Ù *)  Ò ([] @ l2) @ l3 = [] @ l2 @ l3Æ
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{82}
\begin{center}
{\bf induction example (II)}
\end{center}
\vfill
{\small
=SML
a (rewrite_tac [append_def]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  Ò (l1 @ l2) @ l3 = l1 @ l2 @ l3Æ

(* ?Ù *)  Ò µ x∑ (Cons x l1 @ l2) @ l3
		= Cons x l1 @ l2 @ l3Æ
=TEX
\vfill
=SML
a (asm_rewrite_tac [append_def]);
val append_assoc_thm = pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val append_assoc_thm =
 Ù µ l1 l2 l3∑ (l1 @ l2) @ l3 = l1 @ l2 @ l3 : THM   
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{83}
\begin{center}
\bf Exercises 8: Induction
\end{center}
\vfill
\begin{enumerate}
\item
Appending the empty list has no effect:
=SML
set_goal([], Ò µl1 ∑ l1 @ [] = l1Æ);
=TEX
\item
``Reverse'' distributes over ``@'' (sort of):
=SML
set_goal([], Ò µl1 l2 ∑
  Rev (l1 @ l2) = (Rev l2) @ (Rev l1)Æ);
=TEX
\item
``Map'' distributes over ``@'':
=SML
set_goal([], Ò µf l1 l2 ∑
  Map f (l1 @ l2) = (Map f l1) @ (Map f l2)Æ);
=TEX
\item
``Length'' distributes over ``@'':
=SML
set_goal([], Ò µl1 l2∑ Length (l1 @ l2)
	= Length l1 + Length l2Æ);
=TEX
\end{enumerate}
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{84}
\begin{center}
\bf Exercises 8: Solutions
\end{center}
\vfill
=SML
set_goal([],Ò µl1 ∑ l1 @ [] = l1Æ);		(* no. 1 *)
a strip_tac;
a (list_induction_tac Ò l1Æ
  THEN asm_rewrite_tac [append_def]);
val empty_append_thm = pop_thm();
=TEX
=SML
set_goal([],Ò µl1 l2 ∑ Rev (l1 @ l2) =
	(Rev l2) @ (Rev l1)Æ);	(* no. 2 *)
a (REPEAT strip_tac);
a (list_induction_tac Ò l1Æ THEN asm_rewrite_tac
  [append_assoc_thm, empty_append_thm,
	append_def, rev_def]);
val rev_distrib_thm = pop_thm();
=TEX
=SML
set_goal([],Ò µf l1 l2 ∑ Map f (l1 @ l2) =
	(Map f l1) @ (Map f l2)Æ);	(* no. 3 *)
a (REPEAT strip_tac);
a (list_induction_tac Ò l1Æ THEN asm_rewrite_tac
  [map_def, empty_append_thm, append_def]);
val rev_distrib_thm = pop_thm();
=TEX
=SML
set_goal([],Ò µl1 l2∑ Length (l1 @ l2) =
	Length l1 + Length l2Æ);	(* no. 4 *)
a (REPEAT strip_tac);
a (list_induction_tac Ò l1Æ THEN asm_rewrite_tac
  [append_def, length_def, plus_assoc_thm]);
val length_distrib_thm = pop_thm();
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{85}
\begin{center}
\bf TACTICALs and other -ALs
\end{center}
{\small
\vfill
\begin{itemize}
\item
TACTICALs may be used to combine the available tactics.
\item
Expressions using TACTICALs may be used directly in proofs, e.g.:
=GFT
	a (REPEAT strip_tac);
=TEX
\item
named tactics may be defined using TACTICALs:
=SML
	val repeat_strip_tac = REPEAT strip_tac;
=TEX
\item
TACTICALs may be used to define parameterised tactics:
=SML
	fun list_induct_tac t = REPEAT strip_tac
			THEN list_induction_tac t;
=TEX
\item
tacticals usually have capitalised names ending in ``\_T'', though the most common (e.g. REPEAT, THEN) have aliases omitting the ``\_T''
\item
other higher order functions are available:

conversionals (\_C suffix)\\
THM\_TACTICALs (\_THEN suffix)\\
THM\_TACTICAL combinators (\_TTCL suffix)
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{86}
\begin{center}
\bf commonly used TACTICals
\end{center}
{\small
\vfill
\begin{itemize}
\item
REPEAT - takes a tactic and returns a tactic which repeats that tactic until it fails.

If goal splits occur the repeating continues on all subgoals.

\item

THEN - an infix tactical which composes two tactics together.
The second tactic is applied to all subgoals arising from the first tactic.
If any applications of the operand tactics fail then the resulting tactic fails.

\item

ORELSE - an infix tactical which attempts to apply its first argument, and if this fails applies its second argument.
If both arguments fail then the resulting tactic fails.

\item
TRY\_T - a tactical taking one argument which will do nothing (but succeed!) if it argument tactic fails.

\item
THEN$\_$TRY - variant on THEN which does not fail even if the second tactic fails.

t1 THEN$\_$TRY t2 = t1 THEN (TRY\_T t2)
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{87}
\begin{center}
\bf Exercises 9: TACTICALs
\end{center}
{\small
\vfill
\begin{enumerate}
\item
Write a tactic which does $strip\_tac$ three times.

test it on:
=SML
set_goal([],Ò (a ¥ b ¥ c) ¥ a ¥ b ¥ cÆ);
set_goal([],Ò (a ¥ b) ¥ a ¥ cÆ);
=TEX
\item
Write a tactic which does $strip\_tac$ up to 3 times.

Try it on the same examples.
\item
Write a tactic which takes two arguments:
\begin{itemize}
\item
a term which is a variable
\item
a list of theorems
\end{itemize}
and performs an inductive proof of a theorem concerning lists by:
\begin{itemize}
\item
stripping the goal
\item
inducting on the variable
\item
rewriting with the assumptions and the list of theorems
\end{itemize}

Use it to shorten the earlier proofs about lists.
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================
\begin{slide}{88}
\begin{center}
\bf Exercises 9: Solutions
\end{center}
{\tiny
\vfill
=SML
(* no. 1 *)
val strip3_tac = strip_tac THEN strip_tac THEN strip_tac;
set_goal([],Ò (a ¥ b ¥ c) ¥ a ¥ b ¥ cÆ);
a strip3_tac;
=TEX
\vfill
=SML
(* no. 2 *)
val stripto3_tac = strip_tac THEN_TRY strip_tac
		THEN_TRY strip_tac;
set_goal([],Ò (a ¥ b) ¥ a ¥ cÆ);
a stripto3_tac;
=TEX
\vfill
=SML
(* no. 3 *)
fun list_induct_tac var thl =
	REPEAT strip_tac
	THEN list_induction_tac var
	THEN_TRY asm_rewrite_tac thl;

set_goal([],Ò µl1 l2 l3 ∑
  (l1 @ l2) @ l3 = l1 @ (l2 @ l3)Æ);
a (list_induct_tac Ò l1:'a LISTÆ [append_def]);
val append_assoc_thm = pop_thm ();

set_goal([], Ò µl1:'a LIST ∑ l1 @ [] = l1Æ);
a (list_induct_tac Ò l1:'a LISTÆ [append_def]);
val empty_append_thm = pop_thm();
=TEX
=IGN
set_goal([], Ò µl1 l2:'a LIST  ∑
  Rev (l1 @ l2) = (Rev l2) @ (Rev l1)Æ);
a (list_induct_tac Ò l1:'a LISTÆ
  [append_def, rev_def, append_assoc_thm, empty_append_thm]);
set_goal([], Ò µf; l1 l2:'a LIST∑
  Map f (l1 @ l2) = (Map f l1) @ (Map f l2)Æ);
a (list_induct_tac Ò l1:'a LISTÆ
  [append_def, map_def, append_assoc_thm, empty_append_thm]);
set_goal([], Ò µl1 l2:'a LIST∑ Length (l1 @ l2)
	= Length l1 + Length l2Æ);
a (list_induct_tac Ò l1:'a LISTÆ
  [append_def, length_def, append_assoc_thm,
  empty_append_thm, plus_assoc_thm]);
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{89}
\begin{center}
\bf Proof Strategy
\end{center}
\vfill
\begin{itemize}
\item

A large application proof may take several man years of effort to complete.
\vfill

\item

Top level proof strategy for large proofs must be carefully thought out.

{\tiny
The lemmas are best proven separately, stored in the theory, and combined in a top level proof delivering the required result from the major lemmas.
Exploration may be forwards or backwards.
}%\tiny
\vfill

\item

Lemmas of moderate size may be proven using the goal package.

{\tiny
Such a proof would consist of a combination of stripping, rewriting with definitions, assumptions and previously proven results, and other uses of previous results.
}%\tiny
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{90}
\begin{center}
\bf What to do when faced with a Goal\\
-\\
Sanity Checks
\end{center}
\vfill
\begin{itemize}
\item
Decide whether the goal is true, if not, don't try to prove it!
\vfill
\item
Decide whether the conclusion is relevant (are the assumptions inconsistent?).
\vfill
\item
Take the negation of an assumption as conclusion if this would be easier\\
(use $swap\_asm\_concl\_tac$).
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{91}
\begin{center}
\bf What to do when faced with a Goal\\
-\\
Main Choices
\end{center}
\vfill
\begin{itemize}
\item
Prove automatically.\\
(using $prove\_tac$ or $prove\_∂\_tac$).
\item
Transform the conclusion by stripping.
\item
Transform the conclusion by rewriting.
\item
Forward inference from assumptions.
\item
Backward inference from conclusion\\
($bc\_tac$ and induction tactics).
\item
Swap the conclusion with an assumption\\
($swap\_asm\_concl\_tac$).
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{92}
\begin{center}
\bf `Forward Inference' from Assumptions
\end{center}
\vfill
{\small
\begin{itemize}
\item
$lemma\_tac$ may be used for a backward proof of an intermediate result.
\vfill
\item
$list\_spec\_asm\_tac$ may be used to specialise assumptions (and strip results).
\vfill
\item
$asm\_fc\_tac$ and $fc\_tac$ may be used for automatic `forward chaining' from assumptions.
\vfill
\item
Assumptions can be used as a basis for forward proof using $asm\_rule$, or by $GET\_ASM\_T$ et. al.
\vfill
\item
Theorems may be stripped into assumptions using\\
$strip\_asm\_tac$ (or $check\_asm\_tac$).
\vfill
\item
It may be necessary to ``turn round'' an equation, for which $eq\_sym\_conv$ may be used.
\vfill
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{93}
\begin{center}
\bf Uses of $lemma\_tac$ (I)
\end{center}
\vfill
{\small
\begin{itemize}
\item
For proving intermediate results helpful in establishing the main goal.
=GFT SML
set_goal([],Ò conc:BOOLÆ);
a (lemma_tac Ò lemma:BOOLÆ);
=GFT Hol Output
(* *** Goal "2" *** *)
(*  1 *)  Ò lemmaÆ

(* ?Ù *)  Ò concÆ

(* *** Goal "1" *** *)
(* ?Ù *)  Ò lemmaÆ
=TEX
\item
Where a mathematician might say:\\
``let v be a value such that P v''.
=GFT SML
set_goal([],Ò conc:BOOLÆ);
a (lemma_tac Ò ∂v∑ P vÆ);
=GFT Hol Output
(* *** Goal "2" *** *)
(*  1 *)  Ò P vÆ

(* ?Ù *)  Ò concÆ

(* *** Goal "1" *** *)
(* ?Ù *)  Ò ∂ v∑ P vÆ
=TEX

\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{94}
\begin{center}
\bf Uses of $lemma\_tac$ (II)
\end{center}
{\small
\vfill
\begin{itemize}
\item
For doing induction on the value of expressions rather than variables.
\vfill
=GFT SML
set_goal([],Ò conc:BOOLÆ);
a (lemma_tac Ò ∂v:Ó∑ v = exprÆ
	THEN1 prove_∂_tac);
=GFT Hol Output
(* *** Goal "" *** *)
(*  1 *)  Ò v = exprÆ

(* ?Ù *)  Ò concÆ
=TEX
=GFT SML
a (asm_ante_tac Ò v = exprÆ);
=GFT Hol Output
(* *** Goal "" *** *)

(* ?Ù *)  Ò v = expr ¥ concÆ
=TEX
\vfill
Now do induction on Ò vÆ.
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{95}
\begin{center}
\bf Processing of ``new'' assumptions
\end{center}
\vfill
{\small

Tactics which create new assumptions (like ``strip\_tac'' and ``lemma\_tac''), normally add these into the assumption list using ``strip\_asm\_tac''.

``strip\_asm\_tac'' is a $THM -> TACTIC$.

Many tactics which create assumptions have corresponding tacticals (in upper case, ending in\\
``\_T'' instead of ``\_tac''), which allow the resulting assumption to be supplied to an arbitrary $THM -> TACTIC$.

e.g. corresponding to ``lemma\_tac'' there is a tactical\\
``LEMMA\_T''.

$lemma\_tac$ is the same as $LEMMA\_T\ strip\_asm\_tac$.

Other $THM -> TACTICS$ include $asm\_tac$, $rewrite\_thm\_tac$, $ante\_tac$.

=GFT SML
set_goal([],Ò i + i = 2*iÆ);
a (LEMMA_T Ò 2 = 1 + 1Æ pure_rewrite_thm_tac
	THEN1 rewrite_tac[]);
=GFT Hol Output
(* *** Goal "" *** *)
(* ?Ù *)  Ò i + i = (1 + 1) * iÆ
=GFT SML
a (rewrite_tac[times_plus_distrib_thm]);
=GFT Hol Output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{96}
\begin{center}
\bf Exercises 10.
\end{center}
{\tiny
\vfill
\begin{description}
\item[1.]
Sometimes it is necessary to manipulate an assumption, e.g. by
rewriting it. $swap\_asm\_concl\_tac$ negates and then interchanges the
conclusion of a goal with an assumption (given as a parameter).
Using $swap\_asm\_concl\_tac$ and tactics you have already seen,
prove that there is no greatest natural number:
=SML
set_goal([], Ò µm∑∂n∑ m < nÆ);
=TEX
(Hint: use $contr\_tac$ first).
\item[2.]
Rather than using $contr\_tac$, it is often more natural to prove goals
with existentially quantified conclusions directly. $∂\_tac$ lets you
do this by supplying a term to act as a ``witness''.
Use $∂\_tac$ to give a more natural solution to the previous exercise:
=SML
set_goal([], Ò µm∑∂n∑ m < nÆ);
=TEX
\item[3.]
The system currently contains only a few basic results about multiplication,
division and modulo, ($*$, $Div$ and $Mod$).
Look at the end of the listing of theory Ó to see these.
Use them to prove:
=SML
set_goal([], Ò µi j∑(i + j) * (i + j) = i*i + 2*i*j + j*jÆ);
=TEX
(Hints: Use $lemma\_tac$ to prove that $2 = 1 + 1$;
then, use the lemma and the theorems supplied about commutativity of $*$
and distributivity of $*$ over $+$
to rewrite the goal taking care to avoid looping.)
\end{description}
}%\tiny
\vfill
\end{slide}

% =====================================================================
\begin{slide}{97}
{\tiny
\begin{description}
\item[4.]
It can happen that an equation is the wrong way round for use as
a rewrite rule. The usual means for dealing with this type of
problem is the conversion $eq\_sym\_conv$. Like other conversions
this may be propagated over a term using the conversionals $MAP\_C$
and $ONCE\_MAP\_C$.
Execute the following lines one at a time to see what happens:
=GFT
eq_sym_conv Ò 1 + 1 + 1 = 3Æ;
eq_sym_conv Ò µx∑x + x + x = 3*xÆ;
ONCE_MAP_C eq_sym_conv Ò µx∑x + x + x = 3*xÆ;
=TEX
A conversion may be converted into a tactic using $conv\_tac$.
Use this and the conversion and conversional you have just experimented
with together with the tactics $swap\_asm\_concl\_tac$
and the theorems $ext\_thm$ and $comb\_s\_def$ to prove the following:
=SML
set_goal([], Ò µf:'a≠'b≠'a∑(µx y∑x = f x y) ¥ f = CombKÆ);
=TEX
(Hint: take care to avoid looping rewrites by using the ``once'' rewriting
tactics while you look for the proof.)
\item[5.]
A common way of using a theorem is to 
to strip it into the assumptions. This is done with $strip\_asm\_tac$.
Very often one specialises the theorem with $µ\_elim$ or $list\_µ\_elim$
before stripping it in and sometimes one may wish to use
$rewrite\_rule$ to rewrite it too.
Use the theorem $div\_mod\_unique\_thm$ in this way to prove:
=SML
set_goal([], Ò µi j∑0 < i ¥ (i * j) Div i = jÆ);
=TEX
(Hints: rewrite the theorem with a $times\_comm\_thm$ suitably specialised
to identify subterms of the form $i * j$ and $j * i$ into the same form;
use the technique of the previous exercise to avoid a looping rewrite with
the assumption added by $strip\_asm\_tac$).
\end{description}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{98}
{\tiny
\begin{description}
\item[6.]
Execute the following paragraph to define a function ” which maps $i$
to the sum of the first $i$ positive integers:
πHOLCONST
‹	” : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	” 0 = 0
‹ ±	µi∑ ”(i+1) = ” i + (i + 1)
∞
The consistency of this paragraph should be proved automatically.
Check this by using $get\_spec$ to get the defining axiom for ”,
which should have no assumptions.
Prove the following theorem:
=SML
set_goal([], Ò µi∑” i = (i*(i + 1)) Div 2Æ);
=TEX
(Hint: use induction to prove a lemma that
$i*(i + 1) = 2\,*\,” i$ and then use the result of the previous exercise;
the lemma is much easier to prove if you turn the equation round and the
inductive step is rather like the proof in exercise 3.)
\item[7.]
Construct a paragraph defining a function $∆$ such that for positive $i$,
$∆ i$ is the $i-th$ element of the Fibonacci sequence,
$1, 1, 2, 3, 5, \ldots$, where each number is the sum of the previous
two. Does the system automatically prove the consistency of your
definition?
\end{description}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{99}
{\tiny
\begin{description}
\item[8.]
If you did the previous exercise, delete the function $f$ you defined
(using $delete\_const$).
Enter the following paragraphs which
define $∆$ using an auxiliary function $«$:
πHOLCONST
‹	« : Ó ≠ (Ó ∏ Ó)
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	« 0 = (0, 1)
‹ ±	µi∑«(i+1) = let (a, b) = « i in (b, a + b)
‹	
∞
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ 	µi∑∆ i = Fst (« i)
‹	
∞
These definitions are proved consistent automatically.
Prove that $∆$ does indeed compute the Fibonacci numbers:
=GFT
set_goal([], Ò 
	∆ 0 = 0
±	∆ 1 = 1
±	µi∑∆(i+2) = ∆(i+1) + ∆ i
Æ);
=TEX
(Hints: first rewrite with the definition of $∆$; then prove a lemma
or lemmas showing how $«\,1$ and $«(i+2)$ may be rewritten so that
the definition of $«$ may be used to rewrite them.)

\item[9.]

The approach of the previous exercise has the disadvantage that the
specification was not as abstract as one would like. A cleaner approach
is to use the obvious definition of $∆$, and then prove that it
is consistent using a function $«$ which is only introduced as
a variable during the course of the proof. The tactic
$prove\_∂\_tac$ gives access to the mechanisms that the system
uses in its attempt to prove that paragraphs are consistent.
We demonstrate this technique in this exercise.
\end{description}
}%\tiny
\vfill
\end{slide}

% =====================================================================
\begin{slide}{100}
{\tiny
\begin{description}

\item[9.(cont)]

First of all, delete the function $«$ that you defined in the previous
exercise
(using $delete\_const$, which will also cause $∆$ to be deleted).
=SML
delete_constÒ «Æ;
=TEX
Enter the following paragraph which gives the natural definition of
$∆$:
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	∆ 0 = 0
‹ ±	∆ 1 = 1
‹ ±	µi∑∆(i+2) = ∆(i+1) + ∆ i
∞
Examine the theorem that $get\_spec$ returns for $∆$, it has
a consistency caveat as an assumption.
Discharge this consistency caveat as follows:

First of all go into the subgoaling package using the following command:
=GFT
push_consistency_goalÒ ∆Æ;
=TEX
Now set as a lemma the existence of a $«$ as in the previous exercise;
the lemma is proved immediately by $prove\_∂\_tac$ and you can
then use $∂\_tacÒ Ãi∑Fst(«\,i)Æ$ followed a proof almost identical with the previous
exercise (hint: $rewrite\_tac$ will eliminate the ¬-redexes introduced
when you apply $∂\_tac$). Save the consistency theorem using the
following command:
=GFT
save_consistency_thm Ò ∆Æ (pop_thm());
=TEX
If you now examine the theorem that $get\_spec$ returns for $∆$, you
should see that it no longer has an assumption.

{\tiny
(Note: the variable name `∆$'$', created by decorating `∆' is displayed by the pretty printer as $\$\,$``∆$'$'' since it violates the HOL lexical rules for identifiers.
The parser will accept identifiers violating the normal lexical rules if they are presented in this way.)
}%\tiny
\end{description}
}%\small
\vfill
\end{slide}

% =====================================================================
\begin{slide}{101}
\begin{center}
\bf Exercises 10: Solutions
\end{center}
{\tiny
\vfill
=SML
(* no. 1 *)
set_goal([], Ò µm∑∂n∑ m < nÆ);
a(contr_tac);
a(list_spec_asm_tacÒ µ n∑ ≥ m < nÆ[Ò m+1Æ]);
a(swap_asm_concl_tacÒ ≥m < m+1Æ);
a(rewrite_tac[]);
val thm1 = pop_thm();
=TEX
=SML
(* no. 2 *)
set_goal([], Ò µm∑∂n∑ m < nÆ);
a(REPEAT strip_tac);
a(∂_tacÒ m+1Æ);
a(rewrite_tac[]);
val thm2 = pop_thm();
=TEX
=SML
(* no. 3 *)
set_goal([], Ò µi j∑(i + j) * (i + j) = i*i + 2*i*j + j*jÆ);
a (REPEAT strip_tac);
a (lemma_tacÒ 2 = 1 + 1Æ);
a (rewrite_tac[]);
a (pure_asm_rewrite_tac[times_plus_distrib_thm, plus_assoc_thm]);
a (rewrite_tac[µ_elimÒ jÆtimes_comm_thm]);
val thm3 = pop_thm();
=TEX
=SML
(* no. 4 *)
set_goal([], Ò µf:'a≠'b≠'a∑(µx y∑x = f x y) ¥ f = CombKÆ);
a (REPEAT strip_tac);
a (rewrite_tac[ext_thm, comb_k_def]);
a (swap_asm_concl_tacÒ µ x y∑ x = f x yÆ);
a (conv_tac(ONCE_MAP_C eq_sym_conv));
a (swap_asm_concl_tacÒ ≥ f x x' = xÆ THEN asm_rewrite_tac[]);
val thm4 = pop_thm();
=TEX
\vfill
}
\end{slide}

% =====================================================================

\begin{slide}{102}
{\tiny
=SML
(* no. 5 *)
set_goal([], Ò µi j∑0 < i ¥ (i * j) Div i = jÆ);
a (REPEAT strip_tac);
a (strip_asm_tac(
	rewrite_rule[µ_elimÒ jÆtimes_comm_thm]
	(list_µ_elim[Ò i*jÆ, Ò iÆ, Ò jÆ, Ò 0Æ] div_mod_unique_thm)));
a (swap_asm_concl_tacÒ j = (i * j) Div iÆ THEN
		(conv_tac(ONCE_MAP_C eq_sym_conv)));
a (strip_tac);
val thm5 = pop_thm();
=TEX
=SML
(* no. 6 *)
set_goal([], Ò µi∑” i = (i*(i + 1)) Div 2Æ);
a (REPEAT strip_tac);
a (lemma_tacÒ i * (i + 1) = 2 * ” iÆ);
a (conv_tac eq_sym_conv);
(* *** Goal "1" *** *)
a (induction_tacÒ iÆ THEN
	asm_rewrite_tac
	[get_specÒ ”Æ, times_plus_distrib_thm, plus_assoc_thm]);
a (lemma_tacÒ 2 = 1 + 1Æ);
(* *** Goal "1.1" *** *)
a (rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (pure_asm_rewrite_tac[times_plus_distrib_thm, plus_assoc_thm1]);
a (rewrite_tac[] THEN rewrite_tac[plus_assoc_thm]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[rewrite_rule[](list_µ_elim[Ò 2Æ, Ò ” iÆ]thm5)]);
val thm6 = pop_thm();
=TEX
\vfill
}
\end{slide}

% =====================================================================

\begin{slide}{103}
{\tiny
=SML
(* no. 7 *)
=TEX
The obvious way of defining the Fibonacci function is not automatically
proved consistent:
=SML
delete_constÒ ∆Æ;
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	∆ 0 = 0
‹ ±	∆ 1 = 1
‹ ±	µi∑∆(i+2) = ∆(i+1) + ∆ i
‹	
∞
=SML
get_specÒ ∆Æ;
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{104}
{\tiny
=SML
delete_constÒ ∆Æ;
=SML
(* no. 8 *)
πHOLCONST
‹	« : Ó ≠ (Ó ∏ Ó)
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	« 0 = (0, 1)
‹ ±	µi∑«(i+1) = let (a, b) = « i in (b, a + b)
‹	
∞
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹ 	µi∑∆ i = Fst (« i)
‹	
∞
=SML
set_goal([], Ò 
	∆ 0 = 0
±	∆ 1 = 1
±	µi∑∆(i+2) = ∆(i+1) + ∆ i
Æ);
a (rewrite_tac[get_specÒ ∆Æ]);
a (lemma_tacÒ « 1 = «(0 + 1) ± µi∑ «(i + 2) = «((i+1)+1)Æ);
(* *** Goal "1" *** *)
a (rewrite_tac[plus_assoc_thm]);
(* *** Goal "2" *** *)
a (pure_asm_rewrite_tac[get_specÒ «Æ, let_def] THEN rewrite_tac[]);
val thm8 = pop_thm();
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{105}
{\tiny
=SML
(* no. 9 *)
delete_constÒ «Æ;
πHOLCONST
‹	∆ : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸
‹	∆ 0 = 0
‹ ±	∆ 1 = 1
‹ ±	µi∑∆(i+2) = ∆(i+1) + ∆ i
∞
=SML
get_specÒ ∆Æ;
push_consistency_goalÒ ∆Æ;
a (lemma_tacÒ ∂«∑
	« 0 = (0, 1)
±	µi∑«(i+1) = let (a, b) = « i in (b, a + b)
Æ);
(* *** Goal "1" *** *)
a (prove_∂_tac);
(* *** Goal "2" *** *)
a (∂_tacÒ Ãi∑Fst(« i)Æ);
a (rewrite_tac[]);
a (lemma_tacÒ « 1 = «(0 + 1) ± µi∑ «(i + 2) = «((i+1)+1)Æ);
(* *** Goal "2.1" *** *)
a (rewrite_tac[plus_assoc_thm]);
(* *** Goal "2.2" *** *)
a (pure_asm_rewrite_tac[let_def] THEN asm_rewrite_tac[]);
save_consistency_thm Ò ∆Æ (pop_thm());
get_specÒ ∆Æ;
=TEX
}%\tiny
\vfill
\end{slide}


=IGN
push_pc "hol1";
set_goal([],Ò µl1 l2∑ Length (l1 @ l2) = Length l1 + Length l2Æ);
a (REPEAT strip_tac);
a (list_induction_tac Ò l1Æ THEN asm_rewrite_tac
  [append_def, length_def, plus_assoc_thm]);
=TEX
πHOLCONST
‹ interleave : 'a LIST ≠ 'a LIST ≠ 'a LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹(µ h1 t1 h2 t2∑
‹	interleave [] [] = []
‹±	interleave [] (Cons h2 t2) = (Cons h2 t2)
‹±	interleave (Cons h1 t1) [] = (Cons h1 t1)
‹± 	interleave (Cons h1 t1) (Cons h2 t2) =
‹	Cons h1 (Cons h2 (interleave t1 t2)))
‹
∞
=SML
rewrite_conv[get_specÒ interleaveÆ]
  Ò interleave[1;2;3;4;5][10;11;12]Æ;
=TEX
}%\ignore
\end{document}
