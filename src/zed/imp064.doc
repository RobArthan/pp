% imp064.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp064.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Implementation of the Z Pretty Printer}
\TPPref{DS/FMU/IED/IMP064}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp064.dvi
doctex imp064
texdvi imp064
bibtex imp064
doctex imp064 ; texdvi imp064
doctex imp064 ; texdvi imp064 ; bibtex imp064
dvipage imp064 &


docsml imp064
use_file "imp064.sml";

lasp -s imp064.doc > zz1
lasp -s -u imp064.OKwords imp064.doc > zz1

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the
	Z~pretty printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\underscoreoff

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[\FormatDate{$Date$%
}, issue \SCCSissue~]
	Initial drafts.
%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]


\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the pretty printer for the Z proof support
system.  The detailed level design for this document
in~\cite{DS/FMU/IED/DTD064}.

%********************************************************************

\subsection{Introduction}

%--------------------------------------------------------------------

\subsubsection{Purpose and Background}

%--------------------------------------------------------------------

\subsubsection{Dependencies}

%--------------------------------------------------------------------

\subsubsection{Interface}

%--------------------------------------------------------------------

\subsubsection{Algorithms}

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}
%\subsubsection{Terminology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\section{STRUCTURE} \label{StartStructure}

=SML
structure €ZPrettyPrinter› : ZPrettyPrinter = struct
=TEX

=SML
open PrettyPrinterSupport;
infix gt_prec;

open ZUserInterfaceSupport;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{UTILITIES}

=SML
fun €show_comma_list_of_strings› (addstring : string -> unit)
		(space : int * int -> unit) (strs : string list) : unit = (
let
	fun aux nil = ()
	| aux (t1::nil) = addstring t1
	| aux (t1::more) = (
		addstring t1;
		addstring ",";
		space(1, 0);
		aux more
	)
in
	aux strs
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PRECEDANCES}

Rather than place lots of numeric precedance codes in the code we
declare several precedance codes here.  Syntax rules refer to
productions from the Z~grammar of~\cite{DS/FMU/IED/DTD061}.
These declarations are given in order with the loosly
binding first and most tightly binding at the end.

=SML
val pc_sch0_quant : PREC_CONTEXT = PcNormal(0, 10, false);
=TEX

=IGN
val pc_sch1 : PREC_CONTEXT = PcNormal(10, 0, false);
val pc_sch1_text : PREC_CONTEXT = PcNormal(10, 10, false);
=TEX

=SML
val pc_sch1_ref : PREC_CONTEXT = PcNormal(20, 15, false);
val pc_sch1_≥ : PREC_CONTEXT = PcNormal(20, 20, false);
val pc_sch1_pre : PREC_CONTEXT = PcNormal(20, 30, false);
val pc_sch1_± : PREC_CONTEXT = PcNormal(20, 40, false);
val pc_sch1_≤ : PREC_CONTEXT = PcNormal(20, 50, false);
val pc_sch1_¥ : PREC_CONTEXT = PcNormal(20, 60, true);
val pc_sch1_§ : PREC_CONTEXT = PcNormal(20, 70, false);
val pc_sch1_˘ : PREC_CONTEXT = PcNormal(20, 80, false);
val pc_sch1_hide : PREC_CONTEXT = PcNormal(20, 90, false);
val pc_sch1_ª : PREC_CONTEXT = PcNormal(20, 100, false);
=TEX

=SML
val pc_pred0 : PREC_CONTEXT = PcNormal(100, 0, false);
=TEX

=IGN
val pc_pred1 : PREC_CONTEXT = PcNormal(110, 0, false);
=TEX

Symbols in syntax rule $Pred2$ (which is $Predicate-1$
in~\cite{Spivey89}) need their own precedance group.  Note that the
implication is right associative, the other infixes are left
associative

=IGN
val pc_pred2 : PREC_CONTEXT = PcNormal(120, 0, false);
=TEX

Relational operators have their own numeric precedance with a range of,
effectively, plus or minus infinity.

=SML
val pc_pred2_rel : PREC_CONTEXT = PcNormal(118, 0, false);
=TEX

=SML
val pc_pred2_eq : PREC_CONTEXT = PcNormal(120, 10, false);
val pc_pred2_ç : PREC_CONTEXT = pc_pred2_eq;
val pc_pred2_≥ : PREC_CONTEXT = PcNormal(120, 30, false);
val pc_pred2_± : PREC_CONTEXT = PcNormal(120, 40, false);
val pc_pred2_≤ : PREC_CONTEXT = PcNormal(120, 50, false);
val pc_pred2_¥ : PREC_CONTEXT = PcNormal(120, 60, true);
val pc_pred2_§ : PREC_CONTEXT = PcNormal(120, 70, false);
=TEX

=IGN
val pc_expr0_in_gen : PREC_CONTEXT = PcNormal(200, 20, false);
=TEX

=SML
val pc_expr0_Ã_Õ : PREC_CONTEXT = PcNormal(200, 10, false);
val pc_expr0_∏ : PREC_CONTEXT = PcNormal(200, 30, false);
=TEX

Syntax rule $Expr0$ captures the fancy fix generic operators which
have their own numeric precedance with a range of,
effectively, plus or minus infinity.

=SML
fun pc_expr0_gen (p:int) : PREC_CONTEXT = PcNormal(203, p, false);
=TEX

Syntax rule $Expr1$ captures the fancy fix function operators plus it is used by
some other productions.  Have two precedance values:  one for its
direct recursive uses (i.e., where $Expr1$ calls $Expr1$); the other
for its other uses.
Fancy fix function operators have their own numeric precedance with a
range of, effectively, plus or minus infinity.

=SML
fun pc_expr1_in_fun (p:int) : PREC_CONTEXT = PcNormal(206, p, false);
=TEX

=SML
val pc_expr1_ : PREC_CONTEXT = PcNormal(210, 20, false);
=TEX

=SML
val pc_expr2 : PREC_CONTEXT = PcNormal(220, 0, false);
val pc_expr2_lhs : PREC_CONTEXT = PcNormal(220, 10, false);
val pc_expr2_rhs : PREC_CONTEXT = PcNormal(220, 20, false);
=TEX

=SML
val pc_expr3_gvar : PREC_CONTEXT = PcNormal(230, 10, false);
val pc_expr3_schref : PREC_CONTEXT = PcNormal(230, 20, false);
val pc_expr3_sel : PREC_CONTEXT = PcNormal(230, 30, false);
=TEX

=IGN
val pc_expr4 : PREC_CONTEXT = PcNormal(240, 0, false);
=TEX

=SML
val pc_schema_name : PREC_CONTEXT = PcNormal(300, 0, false);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{BRACKET GENERATION}

We have many small sections of code which need to enclose something
in round brackets if the precedances require.  Function $bracket$
does this for us.

=SML
fun €bracket› (cur_env:PP_ENV, enclosed_prec:PREC_CONTEXT,
		block:bool, how: PP_ENV -> unit) : PFUN_ANS = (
let
	val PpEnv{pe_prec=enclosing_prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_endb=endb, ...} = cur_env;

	val br = enclosing_prec gt_prec enclosed_prec;

	val inner_prec = if br then PcLowest else enclosed_prec;

	val bl = block orelse br;
in
	if br then addstring "(" (*=)=*) else ();
	if bl then beginb(2, true) else ();

	how (set_prec inner_prec cur_env);

	if bl then endb() else ();
	if br then (*=(=*) addstring ")" else ();

	PfOk
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PRINTING AUXILIARY FUNCTIONS}
\subsection{Names}
=SML
fun €make_z_name› (name : string) : string = (
	case explode name of
		"z" :: "'" :: (more as(_ :: _)) => implode more
	|	_ => name
);
=TEX
\subsection{Simple Infix, Prefix and Postfix Operators}

Function $Z_fun_app$ deals with the functionale application of
constants.  The first term $orig_tm$ is the constant, the string
$alias$ and type $ty$ are from its destroyed form after aliases are
found.  The term list $args$ holds the arguments that the constant is
applied to.  The original term may be recreated by $list_mk_app$
applied to the term and the term list.

=SML
fun €do_prefix› (oper: string, tm:TERM) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;
in
	addstring oper;
	space(1, 0);
	beginb(2, true);
	main_term_pp cur_env tm;
	endb()
end
);
=TEX

=SML
fun €do_infix› (oper: string, (l:TERM, r:TERM)) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
in
	main_term_pp cur_env l;
	space(1, 0);
	addstring oper;
	addstring " ";
	main_term_pp cur_env r
end
);
=TEX

=SML
fun €do_binder› (oper: string, (t1:TERM, t2:TERM, t3:TERM))
		(cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
in
	addstring oper;
	addstring " ";
	main_term_pp cur_env t1;
	space(1, 0);
	addstring "| ";
	main_term_pp cur_env t2;
	space(1, 0);
	addstring "∑ ";
	main_term_pp cur_env t3
end
);
=TEX

\subsection{Lists of Terms}

There are several variations on lists.

Some lists (typically those separated by commas or semicolons)
have the separator plus a space token come between value.
Others lists have the space token before the separator.

=SML
fun €do_list› (after:bool, sep:string, tms:TERM list) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;

	fun aux nil = ()
	| aux (t1::nil) = main_term_pp cur_env t1
	| aux (t1::more) = (
		main_term_pp cur_env t1;
		if after then () else space(1, 0);
		addstring sep;
		if after then space(1, 0) else ();
		aux more
	)
	;
in
	aux tms
end
);
=TEX

=SML
fun €do_wrapped_list› (opener:string, sep:string, closer:string, tms:TERM list)
		(cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
in
	addstring opener;
	do_list(true, sep, tms) cur_env;
	addstring closer
end
);
=TEX

\subsection{Delta Schemas}

=SML
fun €do_Ñ_ò› (cur_env:PP_ENV, name:string, tm:TERM) : PFUN_ANS = (
	bracket(cur_env, pc_sch1_ref, false,
		fn e => (do_prefix(name, tm) (set_prec pc_schema_name e))
	)
);
=TEX

\section{FANCY-FIX TERMS}

=SML
datatype €Z_PIECE›
	=	€zp_term›	of TERM * PREC_CONTEXT
	|	€zp_string›	of string * ZFIXITY
	;
=TEX

\subsection{Creation of the Pieces to Print}

=SML
fun €format_fancy_fix›
	(class:CLASS)
	(tmpl : TEMPLATE)
	(args : TERM list)
	: Z_PIECE list OPT = (
let
	val ids = rev(tmpl_ids tmpl class);

	val rids = rev ids;

	fun aux1 names tms = (
		fold	(fn ((n, t), prev) => (zp_string n) :: (zp_term(t, PcLowest)) :: prev)
			(combine names tms)
			nil
	);

	fun aux2 names tms = (
		fold	(fn ((t, n), prev) => (zp_term(t, PcLowest)) :: (zp_string n) :: prev)
			(combine tms names)
			nil
	);
in
	Value(	case tmpl
		of TmplNon _ => (zp_string(hd ids)) :: (aux2 (tl ids) args)
		| TmplIn _ => (zp_term(hd args, PcLowest)) :: (aux1 ids (tl args))
		| TmplPre _ => aux1 ids args
		| TmplPost _ => aux2 ids args
	)
end
handle Fail _ => Nil
);
=TEX

\subsection{Identifying the Template}

In determining whether a Z~identifier has some fancy fix form we make
several consistency checks, these aim to ensure that the text printed
is compatible with the various symbol table information and so the
parser can read back the text to generate the same term.

(Following is wrong. It should chop decoration off the end of the name.)
=SML
fun €get_template_info›(holname:string) : (TEMPLATE * CLASS * STUB list) OPT = (
let
	val name = make_z_name holname;
	val tmpl = template_of_string name handle Fail _ => TmplNon(name, Nil);
	val fst_tmpl_name = first_tmpl_id tmpl;
in
	if name = fst_tmpl_name
	then
		Nil
	else
		case get_zfixity_info fst_tmpl_name
		of Value((_, class), [tmpl2]) =>
			if tmpl = tmpl2
			then
				Value(tmpl, class, tmpl_stubs tmpl)
			else
				Nil
		| _ => Nil
end
);
=TEX

\subsection{Printing the Pieces}

=SML
local
	fun get_p(zp_term(_, p)) = p
	| get_p(zp_string(_, (ff, cl))) = (
		let
			val clp =	case cl
					of (ZClFun p) => pc_expr1_in_fun p
					| ZClRel => pc_pred2_rel
					| (ZClGen p) => pc_expr0_gen p
		in
			case ff
			of ZFFBeginOp		=> PcHighest
			| ZFFEndOp		=> PcHighest
			| ZFFInOp		=> clp
			| ZFFPostBeginOp	=> clp
			| ZFFThenOp		=> PcLowest
			| ZFFPostOp		=> clp
			| ZFFPreEndOp		=> clp
			| ZFFPreOp		=> clp
		end
	);

	fun aux(p, prev) = if p gt_prec prev then prev else p;
in

fun €analyse_prec› (pieces:Z_PIECE list) : PREC_CONTEXT =(
	fold aux (map get_p pieces) PcLowest
);

end;
=TEX

=SML
fun €set_end_precs› (tm_prec:PREC_CONTEXT) (pieces:Z_PIECE list) : Z_PIECE list = (
let
	fun aux((zp_term(t, _))::more) = (zp_term(t, tm_prec)) :: more
	| aux((h as zp_string _)::more) = h :: (aux more)
	| aux nil = nil
	;
in
	aux(rev(aux(rev pieces)))
end
);
=TEX
The spacing below is just wrong (you will get irrelevant space before
and after beginops and endops
=SML
fun €print_pieces› (cur_env:PP_ENV) (pieces:Z_PIECE list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;

	val tm_prec:PREC_CONTEXT = analyse_prec pieces;
	val pieces1:Z_PIECE list = set_end_precs tm_prec pieces;
in
	bracket(cur_env, tm_prec, false,
		fn e => (map(	fn zp_term(t, p) => main_term_pp (set_prec p e) t
				| zp_string(s, _) => (
					space(1,2); addstring s; space(1,2)
				)) pieces1
			; ()
			)
	)
end
);
=TEX

\subsection{Dealing with Functional Applications}

=SML
fun €get_fancy_fix›(name:string, (* ty:TYPE, hd_term:TERM, *) arg_tm:TERM) : Z_PIECE list OPT = (
	case get_template_info name
	of Nil => Nil
	| Value(tmpl, class, stubs) => (
		if length stubs = 1
		then
			format_fancy_fix class tmpl [arg_tm]
		else
			let
				val args = dest_z_tuple arg_tm (* may fail *);
			in
				if length args = length stubs
				then
					format_fancy_fix class tmpl args
				else
					Nil
			end handle Fail _ => Nil
	)
);
=TEX
=SML
local
val €u› = mk_z_gvar("U", î'1 SETÆ, [mk_const("z'Totality", î'1 SETÆ)]);
in
fun €is_u› tm = (term_match tm u; true) handle Fail _ => false;
end;

fun €get_fancy_fix1›(tm:TERM, arg_tm:TERM) : Z_PIECE list OPT = (
	case dest_z_term tm of
		Zgvar (name, _, args) => (
			if	all args is_u
			then	get_fancy_fix (name, arg_tm)
			else	Nil
	) |	Zlvar (name, _, args) => (
			if	all args is_u
			then	get_fancy_fix (name, arg_tm)
			else	Nil
	) |	_ => Nil
);
=SML
fun €do_Z_app› (cur_env:PP_ENV) (hd_term:TERM, arg_tm:TERM) : PFUN_ANS = (
let
	val PpEnv{pe_space=space, ...} = cur_env;
in
	case get_fancy_fix1(hd_term, arg_tm)
	of Nil => bracket(cur_env, pc_expr2, false,
			fn e => (
				main_term_pp (set_prec pc_expr2_lhs e) hd_term;
				space(1, 2);
				main_term_pp (set_prec pc_expr2_rhs e) arg_tm
			)
		)
	| Value pieces => print_pieces cur_env pieces
end
);
=TEX

\subsection{Dealing with Generics}

=SML
fun €do_generic› (cur_env:PP_ENV) (name:string, _:TYPE, tms:TERM list) : PFUN_ANS = (
	case 
		case get_template_info name
		of Nil => Nil
		| Value(tmpl, class, stubs) => (
			if length tms = length stubs
			andalso all tms is_u
			then
				format_fancy_fix class tmpl tms
			else
				Nil
		)
	of Value pieces => print_pieces cur_env pieces
	| Nil => bracket(cur_env, pc_expr3_gvar, false,
		fn e => (
			let val PpEnv {pe_addstring = addstring, ...} = cur_env;
			in	addstring name;
				do_wrapped_list("[", ",", "]", tms) e
			end
		))
);
=TEX

\subsection{Dealing with Relations}
=SML
fun €do_relation› (cur_env:PP_ENV, (l:TERM, r:TERM)) : PFUN_ANS = (
	case	get_fancy_fix1 (r, l)
	of Value pieces => print_pieces cur_env pieces
	| Nil => bracket(cur_env, pc_pred2_ç, false, do_infix("ç", (l, r)))
);
=TEX

\section{APPLICATION OF CONSTANT OR VARIABLE}

=SML
fun €Z_fun_app› (cur_env:PP_ENV) (orig_tm:TERM) (alias:string)
		(ty:TYPE) (args:TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p = main_term_pp (set_prec p cur_env);
in
	case basic_dest_z_term(orig_tm, args)
	of BdzNotZ _ => PfNotPossible
	| BdzFail{BdzFArgc=c, ...}  => PfFewer c
	| BdzOk dzt => (
		case dzt
=TEX

The next part of this function is a big case clause with one branch for each
of the forms of Z~term.  These branch are spread over several blocks of
Standard~ML code, the function finishes in section~\ref{EndZFunApp}
on page~\pageref{EndZFunApp}.

\subsection{Declarations}

In theory the three constructors $Zdec$, $Zdecsexp$ and $Zdecl$ occur
only in related groups where the (destroyed) terms of the $Zdecl$ can
only be $Zdec$ or $Zdecsexp$. {} Correspondingly, the only place where
a ($mk_z_TERM$ applied to a) $Zdec$ or $Zdecsexp$ occurs is is a
$Zdecl$.

=SML
of Zdec(tms, dec_ty) => (
	beginb(2, false);
	beginb(0, false);
	do_list(true, ",", tms) cur_env;
	endb();
	space(1, 2);
	addstring ": ";
	main_term_pp cur_env dec_ty;
	endb();
	PfOk
)
| Zdecsexp(decl, decor) => (
	main_term_pp cur_env decl;
	addstring decor;
	PfOk
)
| Zdecl tms => (
	let
		fun aux nil = ()
		| aux (t1::nil) = main_term_pp cur_env t1
		| aux (t1::more) = (
			main_term_pp cur_env t1;
			addstring ";";
			space(1, 0);
			aux more
		)
		;
	in
		beginb(2, true);
		aux tms;
		endb()
	end;
	PfOk
)
=TEX

\subsection{Predicates}

=SML
| Zeq tms => bracket(cur_env, pc_pred2_eq, false, do_infix("=", tms))
| Zç lr => do_relation(cur_env, lr)
| Ztrue => (addstring "true"; PfOk)
| Zfalse => (addstring "false"; PfOk)
| Z≥ tm => bracket(cur_env, pc_pred2_≥, false, do_prefix("≥", tm))
| Z± tms => bracket(cur_env, pc_pred2_±, false, do_infix("±", tms))
| Z≤ tms => bracket(cur_env, pc_pred2_≤, false, do_infix("≤", tms))
| Z¥ tms => bracket(cur_env, pc_pred2_¥, false, do_infix("¥", tms))
| Z§ tms => bracket(cur_env, pc_pred2_§, false, do_infix("§", tms))
| Z∂ tms => bracket(cur_env, pc_pred0, true, do_binder("∂", tms))
| Z∂â1 tms => bracket(cur_env, pc_pred0, true, do_binder("∂â1", tms))
| Zµ tms => bracket(cur_env, pc_pred0, true, do_binder("µ", tms))
=TEX

Constructor $Zpredsexp$ is for a schema used as a predicate.

=SML
| Zpredsexp(decl, decor) => bracket(cur_env, pc_expr3_schref, false,
	fn e => (
		main_term_pp e decl;
		addstring decor
	)
)
=TEX

\subsection{Variables}

Local variables, $Zlvar$, do not expect anything in the list, but if
we get something then try and print something.

=SML
| Zlvar(name, var_ty, nil) => (
	addstring name;
	PfOk
)
| Zlvar(name, var_ty, tms) => (
	addstring name;
	do_wrapped_list("?[?", ",", "?]?", tms);
	PfOk
)
=TEX

Global variables, $Zgvar$, have their generic parameters in the list

=SML
| Zgvar(name, var_ty, nil) => (
	addstring (make_z_name name);
	PfOk
)
| Zgvar name_args => do_generic cur_env name_args
=TEX

=SML
| Zint n => (
	addstring n;
	PfOk
)
=TEX
Now a simplistic treatment for $ZString$
(which might have ``interesting'' contents):
=SML
| ZString s => (addstring "\"";
	addstring s;
	addstring "\"";
	PfOk
)
=TEX
\subsection{Lists, Sets, Etc.}

=SML
| Zß¢(_:TYPE, tms) => bracket(cur_env, PcHighest, true,
	do_wrapped_list("ß", ",", "¢", tms)
)
| Zsetd(_:TYPE, tms) => bracket(cur_env, PcHighest, true,
	do_wrapped_list("{", ",", "}", tms)
)
| Zseta(t1, t2, t3) => bracket(cur_env, PcHighest, true,
	fn e => (
		addstring "{";
		main_term_pp (set_prec PcLowest e) t1;
		space(1, 2);
		addstring "| ";
		main_term_pp (set_prec PcLowest e) t2;
		space(1, 2);
		addstring "∑ ";
		main_term_pp (set_prec PcLowest e) t3;
		addstring "}"
	)
)
| Z tm => bracket(cur_env, pc_expr1_, false, do_prefix("", tm))
| Ztuple tms => bracket(cur_env, PcHighest, false, do_wrapped_list("(", ",", ")", tms))
| Z∏ tms => bracket(cur_env, pc_expr0_∏, true, do_list(false, "∏", tms))
=TEX

=SML
| Z (tm, "") => bracket(cur_env, pc_schema_name, false,
	fn e => (
		addstring " ";
		main_term_pp e tm
	)
)
| Z (tm, decor) => bracket(cur_env, pc_schema_name, false,
	fn e => (
		addstring " ";
		main_term_pp e tm;
		addstring decor
	)
)
| Zsel(tm, sel) => bracket(cur_env, pc_expr3_sel, false,
	fn e => (
		main_term_pp e tm;
		addstring ".";  (* full stop "." for selection *)
		addstring sel
	)
)
=TEX

Applications, here we must think about templates for fancy-fix
operator invocations.

=SML
| Zapp tms => do_Z_app cur_env tms
| ZÃ tms => bracket(cur_env, pc_expr0_Ã_Õ, true, do_binder("Ã", tms))
| ZÕ tms => bracket(cur_env, pc_expr0_Ã_Õ, true, do_binder("Õ", tms))
=TEX

\subsection{Schema Expressions}

Horizontal schemas.

=SML
| Zâs(tm1, tm2) => (
	let
		val new_env = set_prec PcLowest cur_env;
	in
		addstring "[";
		main_term_pp new_env tm1;
		space(1, 2);
		addstring "| ";
		main_term_pp new_env tm2;
		addstring "]";
		PfOk
	end
)
=TEX

Useage of a schema, with optional decoration.

=SML
| Zdecâs(tm, decor) => bracket(cur_env, pc_schema_name, false,
	fn e => (
		main_term_pp e tm;
		addstring decor
	)
)
=TEX

=SML
| Zpreâs tms => bracket(cur_env, pc_sch1_pre, false, do_prefix("pre", tms))
| Z≥âs tms => bracket(cur_env, pc_sch1_≥, false, do_prefix("≥", tms))
| Z±âs tms => bracket(cur_env, pc_sch1_±, false, do_infix("±", tms))
| Z≤âs tms => bracket(cur_env, pc_sch1_≤, false, do_infix("≤", tms))
| Z¥âs tms => bracket(cur_env, pc_sch1_¥, false, do_infix("¥", tms))
| Z§âs tms => bracket(cur_env, pc_sch1_§, false, do_infix("§", tms))
| Z˘âs tms => bracket(cur_env, pc_sch1_˘, false, do_infix("˘", tms))
| Z∂âs tms => bracket(cur_env, pc_sch0_quant, true, do_binder("∂", tms))
| Z∂â1âs tms => bracket(cur_env, pc_sch0_quant, true, do_binder("∂â1", tms))
| Zµâs tms => bracket(cur_env, pc_sch0_quant, true, do_binder("µ", tms))
| Zªâs tms => bracket(cur_env, pc_sch1_ª, false, do_infix("ª", tms))
=TEX
=SML
| Zhideâs(tm, strs) => bracket(cur_env, pc_sch1_hide, false,
	fn e => (
		main_term_pp e tm;
		space(1, 2);
		addstring "\\ (";
		show_comma_list_of_strings addstring space strs;
		addstring ")"
	)
)
=TEX

=SML
| ZÑâs tm => do_Ñ_ò(cur_env, "Ñ", tm)
| Zòâs tm => do_Ñ_ò(cur_env, "ò", tm)
=TEX

According to the grammar in~\cite{Spivey1992} renaming is just an
optional component of a schema reference, we therefore use the same
precedance.

=SML
| ZRenameâs (tm, ididl) => (
	let
		fun pr_2ids(i1, i2) = (addstring i1; addstring "/"; addstring i2);

		fun pr_comma_2ids ids = (addstring ","; space(1, 2); pr_2ids ids)
	in
		bracket(cur_env, pc_sch1_ref, false,
			fn e => (
				main_term_pp e tm;
				space(1, 2);
				addstring "[";
				case ididl
				of ids::nil => pr_2ids ids
				| ids::more => (pr_2ids ids; map pr_comma_2ids more; ())
				| nil => ();
				addstring "]"
			)
		)
	end
)
=TEX

\subsection{Bindings}

=SML
| Zbinding binders => (
	let
		val new_env = set_prec PcLowest cur_env;

		fun aux1(s, t) = (
			beginb(2, true);
			addstring s;
			addstring " ¶";
			space(1, 2);
			main_term_pp new_env t;
			endb()
		);

		fun aux2 b = (
			addstring ",";
			space(1, 2);
			aux1 b
		);
	in
		beginb(2, false);
		addstring "(";
		case binders
		of b :: nil => aux1 b
		| b :: more => (
			aux1 b;
			map aux2 more;
			()
		)
		| nil => ();
		addstring ")";
		endb();
		PfOk
	end
)
=TEX

\subsection{End of Function} \label{EndZFunApp}

=SML
		(* end of case dzt *)
	)
	(* end of case basic_dest_z_term ... *)
end (* of let in fun Z_fun_app *)
) (* of fun Z_fun_app *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ISOLATED CONSTANT OR VARIABLE}

The term value is the constant or variable, the string and type are
from its destroyed form after aliases are found.

=SML
fun €Z_do_const_var› (cur_env:PP_ENV) (orig_tm:TERM) (alias:string)
		(ty:TYPE) : PFUN_ANS = (
	Z_fun_app cur_env orig_tm alias ty nil
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\subsection{LAMBDA AND APPLICATION TERMS}

Isolated `$mk_Ã$' and `$mk_app$' terms are not expected in Z.

=SML
fun €Z_do_Ã› (_:PP_ENV) (_:TERM) (_:TERM) : PFUN_ANS = PfNotPossible;

fun €Z_do_app› (_:PP_ENV) (_:TERM) (_:TERM list) : PFUN_ANS = PfNotPossible;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\section{FINALE}

%********************************************************************

\subsection{Install the Z Printing Functions}

=SML
val side_effect =
set_printers("Z",
	(Z_do_Ã, Z_do_app, Z_do_const_var, Z_fun_app,
		Z_fun_app, Z_do_const_var));
=TEX

%********************************************************************

\subsection{End of Structure}

=SML
end (* of structure ZPrettyPrinter *);
=TEX


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

%\twocolumn[\section{INDEX}] \label{Index}
\section{INDEX}

\footnotesize
\printindex

\onecolumn

\end{document}


