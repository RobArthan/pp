% imp064.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp064.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Implementation of the Z Pretty Printer}
\TPPref{DS/FMU/IED/IMP064}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp064.dvi
doctex imp064
texdvi imp064
bibtex imp064
doctex imp064 ; texdvi imp064
doctex imp064 ; texdvi imp064 ; bibtex imp064
dvipage imp064 &


docsml imp064
use_file "imp064.sml";

lasp -s imp064.doc > zz1
lasp -s -u imp064.OKwords imp064.doc > zz1

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the
	Z~pretty printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\underscoreoff

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[Issues 1.1 to 1.12 ]
	Initial drafts.

\item[\FormatDate{$Date$%
}, issue \SCCSissue~]
	Bring precedences into line with~\cite{DS/FMU/IED/DEF007}.
	Omit references to $Totality$ and $U[Totality]$ as generic arguments.
	Omit the `$|true$' in schema texts.
	Output correct Z term quotation symbol.

%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]


\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the pretty printer for the Z proof support
system.  The detailed level design for this document
in~\cite{DS/FMU/IED/DTD064}.

%********************************************************************

\subsection{Introduction}

%--------------------------------------------------------------------

\subsubsection{Purpose and Background}

%--------------------------------------------------------------------

\subsubsection{Dependencies}

%--------------------------------------------------------------------

\subsubsection{Interface}

%--------------------------------------------------------------------

\subsubsection{Algorithms}

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}
%\subsubsection{Terminology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\section{STRUCTURE} \label{StartStructure}

=SML
structure €ZPrettyPrinter› : ZPrettyPrinter = struct
=TEX

=SML
open PrettyPrinterSupport ZTypesAndTermsSupport;
infix gt_prec;

open ZUserInterfaceSupport;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{UTILITIES}

=SML
fun €show_comma_list_of_strings› (addstring : string -> unit)
		(space : int * int -> unit) (strs : string list) : unit = (
let
	fun aux [] = ()
	| aux (t1::[]) = addstring t1
	| aux (t1::more) = (
		addstring t1;
		addstring ",";
		space(1, 0);
		aux more
	)
in
	aux strs
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PRECEDENCES}

Rather than place lots of numeric precedence codes in the code we
declare several precedence codes here.  Syntax rules refer to
productions from the Z~grammar of~\cite{DS/FMU/IED/DEF007}.
Precedence value names are based upon the names of syntax
rules from~\cite{DS/FMU/IED/DEF007}.
These declarations are given in order with the loosely
binding first and most tightly binding at the end.

=SML
val pc_sch0_quant : PREC_CONTEXT = PcNormal(0, 10, false);
=TEX

All schema infix operators are left associative.

=SML
val pc_sch2_± : PREC_CONTEXT = PcNormal(20, 40, false);
val pc_sch2_≤ : PREC_CONTEXT = PcNormal(20, 50, false);
val pc_sch2_¥ : PREC_CONTEXT = PcNormal(20, 60, true);
val pc_sch2_§ : PREC_CONTEXT = PcNormal(20, 70, false);
val pc_sch2_˘ : PREC_CONTEXT = PcNormal(20, 80, false);
val pc_sch2_ª : PREC_CONTEXT = PcNormal(20, 100, false);

val pc_sch3_pre : PREC_CONTEXT = PcNormal(30, 0, false);
val pc_sch4_ref : PREC_CONTEXT = PcNormal(40, 0, false);
val pc_sch4_hide : PREC_CONTEXT = PcNormal(40, 10, false);
=TEX

=SML
val pc_pred1 : PREC_CONTEXT = PcNormal(100, 0, false);
val pc_pred1_quant : PREC_CONTEXT = PcNormal(100, 10, false);
=TEX

=SML
val pc_pred2_§ : PREC_CONTEXT = PcNormal(150, 10, false);
val pc_pred2_¥ : PREC_CONTEXT = PcNormal(150, 20, true);
val pc_pred2_≤ : PREC_CONTEXT = PcNormal(150, 30, false);
val pc_pred2_± : PREC_CONTEXT = PcNormal(150, 40, false);

val pc_pred3_≥ : PREC_CONTEXT = PcNormal(150, 50, false);

val pc_pred4_eq : PREC_CONTEXT = PcNormal(150, 60, false);
val pc_pred4_ç : PREC_CONTEXT = PcNormal(150, 70, false);
=TEX

Relational operators have their own numeric precedence with a range of,
effectively, plus or minus infinity.

=SML
val pc_pred4_rel : PREC_CONTEXT = PcNormal(150, 80, false);
=TEX

=SML
val pc_expr0_Ã_Õ : PREC_CONTEXT = PcNormal(200, 10, false);
=TEX

Syntax rule $Expr1$ captures the fancy fix generic and function operators which each
have their own numeric precedence with a range of,
effectively, plus or minus infinity.

=SML
fun pc_expr1_gen (p:int) : PREC_CONTEXT = PcNormal(203, p, false);
fun pc_expr1_in_fun (p:int) : PREC_CONTEXT = PcNormal(206, p, false);
=TEX

=SML
val pc_expr1_∏ : PREC_CONTEXT = PcNormal(210, 10, false);

val pc_expr2_ : PREC_CONTEXT = PcNormal(210, 20, false);
=TEX

=SML
val pc_expr3 : PREC_CONTEXT = PcNormal(220, 0, false);
val pc_expr3_lhs : PREC_CONTEXT = pc_expr3;
val pc_expr3_rhs : PREC_CONTEXT = PcNormal(220, 20, false);
val pc_expr3_  : PREC_CONTEXT = PcNormal(220, 30, false);
=TEX

=SML
val pc_expr4 : PREC_CONTEXT = PcNormal(230, 0, false);
val pc_expr4_gvar : PREC_CONTEXT = PcNormal(230, 10, false);
val pc_expr4_schref : PREC_CONTEXT = PcNormal(230, 20, false);
val pc_expr4_sel : PREC_CONTEXT = PcNormal(230, 30, false);
=TEX

=SML
val pc_decoration : PREC_CONTEXT = PcNormal(300, 0, false);
val pc_schema_name : PREC_CONTEXT = PcNormal(300, 10, false);
val pc_dec_name : PREC_CONTEXT = PcNormal(300, 20, false);
val pc_dec_var_name : PREC_CONTEXT = PcNormal(300, 30, false);
val pc_var_name : PREC_CONTEXT = PcNormal(300, 40, false);
=TEX

=SML
val pc_force_brackets : PREC_CONTEXT = PcVeryLow(0, 0, false);
=TEX

Need some further functions for manipulating precedences.
Function $set_prec_flag$ is used when assessing the associativity
of infix operators.

=SML
fun €set_prec_flag› (PcNormal(a, b, _) : PREC_CONTEXT, flag:bool)
	= PcNormal(a, b, flag)
| set_prec_flag (PcVeryLow(a, b, _), flag) = PcVeryLow(a, b, flag)
| set_prec_flag (x, _) = x
;
=TEX

Function $similar_prec$ determines whether precedences are equal when
the boolean associativity flag is ignored.

=SML
local
	fun aux ((l1, l2, _), (r1, r2, _)) =
		l1 = r1 andalso l2 = r2;

	fun	aux2 (PcHighest, PcHighest)	= true
	|	aux2 (PcNormal l, PcNormal r)	= aux (l, r)
	|	aux2 (PcLowest, PcLowest)	= true
	|	aux2 (PcVeryLow l, PcVeryLow r)	= aux (l, r)
	|	aux2 (_, _)			= false;
in
	fun €similar_prec› (lr : PREC_CONTEXT * PREC_CONTEXT) : bool =
		aux2 lr;
end
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{BRACKET GENERATION}

We have many small sections of code which need to enclose something
in round brackets if the precedences require.  Function $bracket$
does this for us.

Argument $block$ indicates whether an Oppen block is required or may be
omitted, if brackets are inserted then a block is always generated.
Argument $how$ is a function that does the actual printing of the
enclosed text.

The precedence of the enclosed text is not $PcLowest$ as might be
expected between the brackets.  This is because we are providing the
precedence enclosure for any complex expression.  If the enclosed text
requires special treatment of the precedences within itself then the
$how$ function must set the precedences appropraitely.

=SML
fun €bracket› (cur_env:PP_ENV, enclosed_prec:PREC_CONTEXT,
		block:bool, how: PP_ENV -> unit) : PFUN_ANS = (
let
	val PpEnv{pe_prec=enclosing_prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_endb=endb, ...} = cur_env;

	val br = enclosing_prec gt_prec enclosed_prec;

	val bl = block orelse br;
in
	if br then addstring "(" (*=)=*) else ();
	if bl then beginb(2, true) else ();

	how (set_prec enclosed_prec cur_env);

	if bl then endb() else ();
	if br then (*=(=*) addstring ")" else ();

	PfOk
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{AUXILIARY PRINTING FUNCTIONS}

\subsection{Names}

=SML
fun €do_dec_var_name› (cur_env:PP_ENV, name:string, enclosed_prec:PREC_CONTEXT) : PFUN_ANS = (
	let
		val PpEnv{pe_addstring=addstring, ...} = cur_env;

		val (n, _) = unpack_ident name;
	in
		if (n = first_tmpl_id(template_of_string n)) handle Fail _ => true
		then(	addstring name;
			PfOk
		)else	bracket(cur_env, enclosed_prec, false, fn e => addstring name)
	end
);
=TEX

\subsection{Simple Infix, Prefix and Postfix Operators}

No precedence change is needed for prefix operators.

=SML
fun €do_prefix› (oper: string, tm:TERM) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;
in
	addstring oper;
	space(1, 0);
	beginb(2, true);
	main_term_pp cur_env tm;
	endb()
end
);
=TEX

=SML
fun €do_infix› (cur_env:PP_ENV, oper: string, (l:TERM, r:TERM),
		left_assoc:bool, op_prec:PREC_CONTEXT) : PFUN_ANS = (
let
	val PpEnv{pe_prec=enclosing_prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_endb=endb,
		pe_space=space, ...} = cur_env;

	val pc_op_prec = set_prec_flag(op_prec, true);

	val (pc_op_prec_left, pc_op_prec_right) =
		if left_assoc
		then (pc_op_prec, set_prec_flag(op_prec, false))
		else (set_prec_flag(op_prec, false), pc_op_prec);

	val br = enclosing_prec gt_prec pc_op_prec;

	val bl = not(similar_prec(enclosing_prec, pc_op_prec));
in
	if br then addstring "(" (*=)=*) else ();
	if bl then beginb(2, true) else ();

	main_term_pp (set_prec pc_op_prec_left cur_env) l;
	space(1, 0);
	addstring oper;
	addstring " ";
	main_term_pp (set_prec pc_op_prec_left cur_env) r;

	if bl then endb() else ();
	if br then (*=(=*) addstring ")" else ();

	PfOk
end
);
=TEX
\subsection{Lists of Terms}

There are several variations on lists.

Some lists (typically those separated by commas or semicolons)
have the separator plus a space token come between value.
Others lists have the space token before the separator.

=SML
fun €do_list› (after:bool, sep:string, tms:TERM list) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;

	fun aux [] = ()
	| aux (t1::[]) = main_term_pp cur_env t1
	| aux (t1::more) = (
		main_term_pp cur_env t1;
		if after then () else space(1, 0);
		addstring sep;
		if after then space(1, 0) else ();
		aux more
	)
	;
in
	aux tms
end
);
=TEX

=SML
fun €do_wrapped_list› (opener:string, sep:string, closer:string, tms:TERM list)
		(cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
in
	addstring opener;
	do_list(true, sep, tms) (set_prec PcLowest cur_env);
	addstring closer
end
);
=TEX
\section{Declarations}
We have to be careful to check out all the constituents of a declaration
before printing it or the enclosing construct.
Note that a declaration on its own is not reparseable ---
the parser of \cite{DS/FMU/IED/DTD061} does not provide a quotation form for
declarations.
The protocol to be followed in functions printing constructs containing
declarations is as follows. First call
=INLINEFT
make_a_dec_list
=TEX
; if this returns $Nil$, the declaration is invalid, so do not attempt
to print the enclosing construct as Z; otherwise, it returns 
=INLINEFT
Value ts
=TEX
, say, print $ts$ with
=INLINEFT
do_decl
=TEX
.

The check to be made on the declaration is that it is a non-empty
list of things which are either schemas-as-declarations or variable
declarations in which the variables are Z local variables (i.e. HOL variables).
=SML
datatype €A_DEC› = €Colon› of TERM list * TERM | €Schema› of TERM * string;
local
	exception €NotADecl›;
	fun €ok_vars› ([] : TERM list) : unit = ()
	|   ok_vars (t :: more) = (
		(case dest_z_term t of
			ZLVar _ => t
		|	ZGVar _ => t
		|	_ => raise NotADecl);
		ok_vars more
	);
	fun €make_a_dec› (t : TERM) : A_DEC = (
		case dest_z_term t of
			ZSchemaDec ts => Schema ts
		|	ZDec (ts, t) => Colon ((ok_vars ts; ts), t)
		|	_ => raise NotADecl
	);
=TEX
=SML
in
fun €make_a_dec_list› (t : TERM) : (A_DEC list) OPT = (
	case dest_z_term t of
		ZDecl [] => Nil
	|	ZDecl ts => (Value (map make_a_dec ts) handle NotADecl => Nil)
	|	_ => Nil
);
fun €do_decl› (decl : A_DEC list) 
		(cur_env:PP_ENV) : unit = (
	let	val PpEnv{pe_prec=prec, pe_addstring=addstring,
			pe_beginb=beginb, pe_space=space, pe_endb=endb, ...}
			= cur_env;
		fun print_a_dec (Schema (s, "")) = (
			main_term_pp cur_env s; ()
		) | print_a_dec (Schema (s, decor)) = (
			main_term_pp (set_prec pc_decoration cur_env) s;
			addstring decor
		) | print_a_dec (Colon (ts, t)) = (
			beginb(2, false);
			beginb(0, false);
			do_list(true, ",", ts) (set_prec pc_dec_name cur_env);
			endb();
			space(1, 2);
			addstring ": ";
			main_term_pp cur_env t;
			endb()
		);
		fun print_a_dec_list [] = ()
		|   print_a_dec_list [t] = print_a_dec t
		|   print_a_dec_list (t::more) = (
			print_a_dec t;
			addstring ";";
			space(1, 0);
			print_a_dec_list more
		);
	in	beginb(2, true);
		print_a_dec_list decl;
		endb()
	end
);
end;
=TEX
\section{Characteristic Tuples}
When processing set abstractions, we wish to be able to test whether
the term after the ∑ is equal to the characteristic tuple of the
declaration (in which case it can be elided). The following makes the test:
=SML
fun €is_chartuple› (tm : TERM) (decs : A_DEC list) : bool = (
let	fun chk (tm :: tms) (Colon(v :: vs, t) :: decl) = (
		tm =$ v andalso chk tms (Colon(vs, t) :: decl)
	) | chk tms (Colon([], _) :: decl) = (chk tms decl
	) | chk (tm :: tms) (Schema (s, d) :: decl) = (
		let	val (t, e) = dest_z_  tm;
		in	t =$ s andalso e = d andalso chk tms decl
		end
	) | chk [] [] = (true
	) | chk _ _ = false;
	val tms = (dest_z_tuple tm) handle Fail _ => [tm];
in	chk tms decs
end
);
=TEX
\section{Binders}
All of the cases where forms like HOL
binders are used in~\cite{DS/FMU/IED/DEF007} have
a BNF syntax of the form below.  Thus they are all directly recursive
(the indirection in the case of $Expr0$ which renames $Expr$ can be
ignored) and so the precedences of the enclosing and enclosed text (the
$xxx$ below) are the same.  If this changes then function $do_binder$
will need an extra argument for the enclosed precedence.

=GFT BNF
xxx	=	...
	|	Quant, SchemaText, `∑`, xxx
	...;
=TEX

=SML
local
fun €do_binder_aux› (oper: string, ds:A_DEC list, t2:TERM, t3:TERM)
		(cur_env:PP_ENV) : unit = (
let	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
	val new_env = set_prec PcLowest cur_env;
in	addstring oper;
	addstring " ";
	do_decl ds new_env;
	if is_z_true t2
	then	()
	else	(space(1, 0);
		addstring "| ";
		main_term_pp new_env t2
	);
	space(1, 0);
	addstring "∑ ";
	main_term_pp new_env t3
end
);
in
fun €do_binder› (oper: string, (t1:TERM, t2:TERM, t3:TERM), pc : PREC_CONTEXT)
		(cur_env:PP_ENV) : PFUN_ANS = (
	case make_a_dec_list t1 of
		Value ds => (
			bracket(cur_env, pc, true, do_binder_aux(oper, ds, t2, t3));
			PfOk
	) |	Nil => PfNotPossible
);
end;
=TEX

=TEX

\subsection{Delta Schemas}

=SML
fun €do_schema_prefix› (cur_env:PP_ENV, name:string, tm:TERM) : PFUN_ANS = (
	bracket(cur_env, pc_sch3_pre, false,
		fn e => (do_prefix(name, tm) (set_prec pc_schema_name e))
	)
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{FANCY-FIX TERMS}

A fancy fix expression is viewed as a list of terms and strings.  The
terms are the subexpresions or arguments of the fancy fix expression,
the strings are the parts of the identifier.  The goal is to take an
identifier and its arguments and reformat them as a list of values of
data type $Z_PIECE$ which contains the necessary terms and strings.
Most of the functions involved in fancy fix formatting manipulate a
optional list of these values, where an empty list is not expected, it
would represent some sort of internal error.  The $Nil$ value is used
to show that a routine has been unable to perform its part of the
formatting and so the expression cannot be shown in a fancy fix form.

=SML
datatype €Z_PIECE›
	=	€zp_term›	of TERM * PREC_CONTEXT
	|	€zp_string›	of string * ZFIXITY
	;
=TEX

After the pieces have been assembled we must decide upon how to format
them.  This involves deciding (1)~where to output spaces; (2)~which
spaces may be line breaks; (3)~where Oppen begin and end tokens are
placed within the text; (4)~what sort of Oppen begin tokens are
wanted.  To hold the results of these decisions we need another data
structure.  Function $make_print_tokens$ makes the necessary decisions
by converting lists of $Z_PIECE$s into $PRINT_TOKEN$s.

=SML
datatype €PRINT_TOKEN›
	=	€pt_term›	of TERM * PREC_CONTEXT
	|	€pt_string›	of string
	|	€pt_space›	of int * int
	|	€pt_beginb›	of int * bool
	|	€pt_endb›
	;
=TEX

%********************************************************************

\subsection{Creation of the Pieces to Print}

Function $format_fancy_fix$ basically merges its $tmpl$ and $args$
arguments to form a single list which comprises the pieces of the fancy
fix expression ready for printing.  If the merge is successful then the
pretty printer can commit itself to printing the original term in fancy
fix form, which is done in function $print_pieces$.  An unsuccessful
merge is indicated by returning a $Nil$ value.

This function is closly based upon a function of the same name
from ``Z User Interface Support'~\cite{DS/FMU/IED/IMP079}.

=SML
fun €format_fancy_fix›
	(class:CLASS)
	(tmpl : TEMPLATE)
	(decor : string)
	(args : TERM list)
	: Z_PIECE list OPT = (
let
	val rids = rev(tmpl_ids tmpl class);

	val ids = rev(case rids of (i, f) :: t => (i^decor, f) :: t | _ => rids);

	fun aux1 names tms = (
		fold	(fn ((n, t), prev) => (zp_string n) :: (zp_term(t, PcLowest)) :: prev)
			(combine names tms)
			[]
	);

	fun aux2 names tms = (
		fold	(fn ((t, n), prev) => (zp_term(t, PcLowest)) :: (zp_string n) :: prev)
			(combine tms names)
			[]
	);
in
	Value(	case tmpl
		of TmplNon _ => (zp_string(hd ids)) :: (aux2 (tl ids) args)
		| TmplIn _ => (zp_term(hd args, PcLowest)) :: (aux1 ids (tl args))
		| TmplPre _ => aux1 ids args
		| TmplPost _ => aux2 ids args
	)
end
handle Fail _ => Nil
);
=TEX

%********************************************************************

\subsection{Identifying the Template}

In determining whether a Z~identifier has some fancy fix form we make
several consistency checks, these aim to ensure that the text printed
is compatible with the various symbol table information and so the
parser can read back the text to generate the same term.

The $name$ argument here has already had any leading ``{\tt z'}''
and trailing decoration discarded.

=SML
fun €get_template_info›(name:string) : (TEMPLATE * CLASS * STUB list) OPT = (
let
	val tmpl = template_of_string name handle Fail _ => TmplNon(name, Nil);
	val fst_tmpl_name = first_tmpl_id tmpl;
in
	if name = fst_tmpl_name
	then
		Nil
	else
		case get_zfixity_info fst_tmpl_name
		of Value((_, class), [tmpl2]) =>
			if tmpl = tmpl2
			then
				Value(tmpl, class, tmpl_stubs tmpl)
			else
				Nil
		| _ => Nil
end
);
=TEX

%********************************************************************

\subsection{Printing the Pieces}

Some analysis and modification must be done to the $Z_PIECE$s before
printing.

Function $analyse_prec$ determines the precedence of the pieces of the
term.  This is the enclosed precedence of the term which will be used
as the right hand argument of $gt_prec$ when the need for brackets is
being determined.

=SML
local
	fun class_p(ZClFun p) = pc_expr1_in_fun p
	| class_p ZClRel = pc_pred4_rel
	| class_p(ZClGen p) = pc_expr1_gen p
	;

	fun get_p(zp_term(_, p)) = p
	| get_p(zp_string(_, (ff, cl))) = (
		case ff
		of ZFFBeginOp		=> PcLowest
		| ZFFEndOp		=> PcLowest
		| ZFFInOp		=> class_p cl
		| ZFFPostBeginOp	=> class_p cl
		| ZFFThenOp		=> PcLowest
		| ZFFPostOp		=> class_p cl
		| ZFFPreEndOp		=> class_p cl
		| ZFFPreOp		=> class_p cl
	);

	fun aux(p, prev) = if p gt_prec prev then prev else p;
in

fun €analyse_prec› (pieces:Z_PIECE list) : PREC_CONTEXT =(
	fold aux (map get_p pieces) PcLowest
);

end;
=TEX

Function $set_end_precs$ sets the precedences of the first and last
terms of the $Z_PIECE$s to the given value.

=SML
fun €set_end_precs› (tm_prec:PREC_CONTEXT) (pieces:Z_PIECE list) : Z_PIECE list = (
let
	fun aux((zp_term(t, _))::more) = (zp_term(t, tm_prec)) :: more
	| aux((h as zp_string _)::more) = h :: (aux more)
	| aux [] = []
	;
in
	aux(rev(aux(rev pieces)))
end
);
=TEX

Function $make_print_tokens$ decides how to format various types of
fancy fix expression.  There are special cases for the three main
forms, namely infix, postfix and prefix.  Note the enclosing text
is responsible for adding Oppen begin and end tokens at the ends.

=SML
local
	val hsp = pt_string " ";
	val ssp = pt_space(1, 2);

	fun aux [] = []
	| aux (zp_term t1 :: zp_string(s1, _) :: []) =
		ssp :: pt_term t1 :: hsp :: pt_string s1 :: []
	| aux (zp_string(s1, _) :: []) = hsp :: pt_string s1 :: []
	| aux (zp_term t1 :: []) = ssp :: pt_term t1 :: []
	| aux (zp_string(s1, _) :: more) = hsp :: pt_string s1 :: hsp :: aux more
	| aux (zp_term t1 :: more) = ssp :: pt_term t1 :: ssp :: aux more
	;
in

fun €make_print_tokens› (pieces:Z_PIECE list) : PRINT_TOKEN list = (
	case pieces
	of (zp_term t1 :: zp_string(s1, _) :: zp_term t2 :: []) => (
		(* Infix *)
		pt_term t1 :: ssp :: pt_string s1 :: hsp :: pt_term t2 :: []
		)
	| (zp_term t1 :: zp_string(s1, _) :: []) => (
		(* Postfix *)
		pt_term t1 :: hsp :: pt_string s1 :: []
		)
	| (zp_string(s1, _) :: zp_term t2 :: []) => (
		(* Prefix *)
		pt_string s1 :: hsp :: pt_term t2 :: []
		)
	| (zp_term t1 :: more) => (
		pt_term t1 :: aux more
		)
	| (zp_string(s1, _) :: more) => (
		pt_string s1 :: aux more
		)
	| [] => []
);

end;
=TEX

Finally, function $print_pieces$ combines the various modifiers and
prints out the fancy fix expresion.  Note that whilst this
function returns a value of type $PFUN_ANS$ it may only return the
value $PfOk$ (which is done by function $bracket$ here) because at
this stage in the processing it is been decided that the expression
will be printed in a fancy fix fashion.

=SML
fun €print_pieces› (cur_env:PP_ENV) (pieces:Z_PIECE list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;

	val tm_prec = analyse_prec pieces;
	val pieces1 = make_print_tokens(set_end_precs tm_prec pieces);
in
	bracket(cur_env, tm_prec, true,
		fn e => (map(	fn pt_term(t, p) => main_term_pp (set_prec p e) t
				| pt_string s => addstring s
				| pt_space ss => space ss
				| pt_beginb ss => beginb ss
				| pt_endb => endb()
				)
				pieces1
			; ()
			)
	)
end
);
=TEX

%********************************************************************

\subsection{Dealing with Functional Applications}

=SML
fun €get_fancy_fix›(fullname:string, arg_tm:TERM, ch_class:CLASS -> bool) : Z_PIECE list OPT = (
let
	val (name, decor) = unpack_ident fullname;
in
	case get_template_info name
	of Nil => Nil
	| Value(tmpl, class, stubs) => (
		if ch_class class
		then
		if length stubs = 1
		then
			format_fancy_fix class tmpl decor [arg_tm]
		else
			let
				val args = dest_z_tuple arg_tm (* may fail *);
			in
				if length args = length stubs
				then
					format_fancy_fix class tmpl decor args
				else
					Nil
			end handle Fail _ => Nil
		else
			Nil
	)
end
);
=TEX
=SML
local
val €u› = mk_z_gvar("U", î'1 SETÆ, [mk_const("Totality", î'1 SETÆ)]);
in
fun €is_u› tm = (term_match tm u; true) handle Fail _ => false;
end;

fun €get_fancy_fix1›(tm:TERM, arg_tm:TERM, ch_class:CLASS -> bool) : Z_PIECE list OPT = (
	(
	case dest_z_term tm of
		ZGVar (name, _, args) => (
			if	all args is_u
			then	get_fancy_fix (name, arg_tm, ch_class)
			else	Nil
	) |	ZLVar (name, _, args) => (
			if	all args is_u
			then	get_fancy_fix (name, arg_tm, ch_class)
			else	Nil
	) |	_ => Nil
	) handle Fail _ => Nil
);
=TEX
=SML
fun €do_Z_app› (cur_env:PP_ENV) (hd_term:TERM, arg_tm:TERM) : PFUN_ANS = (
let
	val PpEnv{pe_space=space, ...} = cur_env;
in
	case get_fancy_fix1(hd_term, arg_tm, fun_true)
	of Nil => bracket(cur_env, pc_expr3, true,
			fn e => (
				main_term_pp (set_prec pc_expr3_lhs e) hd_term;
				space(1, 2);
				main_term_pp (set_prec pc_expr3_rhs e) arg_tm
			)
		)
	| Value pieces => print_pieces cur_env pieces
end
);
=TEX

%********************************************************************

\subsection{Dealing with Generics}

=SML
fun €do_generic› (cur_env:PP_ENV) (fullname:string, _:TYPE, tms:TERM list)
		: PFUN_ANS = (
let
	val (name, decor) = unpack_ident fullname;
	val not_all_u = not(all tms is_u);
in
	case
		case get_template_info name
		of Nil => Nil
		| Value(tmpl, class, stubs) => (
			if length tms = length stubs
			andalso not_all_u
			then
				format_fancy_fix class tmpl decor tms
			else
				Nil
		)
	of Value pieces => print_pieces cur_env pieces
	| Nil => bracket(cur_env, pc_expr4_gvar, true,
		fn e => (
			do_dec_var_name(set_prec pc_var_name cur_env, name, pc_dec_var_name);
			if not_all_u
			then do_wrapped_list("[", ",", "]", tms) e
			else ()
		))
end
);
=TEX

%********************************************************************

\subsection{Dealing with Relations}
=SML
fun €do_relation› (cur_env:PP_ENV, lr as (l:TERM, r:TERM)) : PFUN_ANS = (
let
	fun is_rel_class ZClRel = true | is_rel_class _ = false;
in
	case	get_fancy_fix1 (r, l, is_rel_class)
	of Value pieces => print_pieces cur_env pieces
	| Nil => do_infix(cur_env, "ç", lr, true, pc_pred4_ç)
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{APPLICATION OF CONSTANT OR VARIABLE}

Function $Z_fun_app$ deals with the functional application of
constants.  The first term $orig_tm$ is the constant, the string
$alias$ and type $ty$ are from its destroyed form after aliases are
found.  The term list $args$ holds the arguments that the constant is
applied to.  The original term may be recreated by $list_mk_app$
applied to the term and the term list.

=SML
fun €Z_fun_app› (cur_env:PP_ENV) (orig_tm:TERM) (alias:string)
		(ty:TYPE) (args:TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p = main_term_pp (set_prec p cur_env);
in
	case basic_dest_z_term(orig_tm, args)
	of BdzNotZ _ => PfNotPossible
	| BdzFail{BdzFArgc=c, ...}  => PfFewer c
	| BdzOk dzt => (
		case dzt
=TEX

The next part of this function is a big case clause with one branch for each
of the forms of Z~term.  These branch are spread over several blocks of
Standard~ML code, the function finishes in section~\ref{EndZFunApp}
on page~\pageref{EndZFunApp}.

\subsection{Declarations}

In theory the three constructors $ZDec$, $ZSchemaDec$ and $ZDecl$ occur
only in related groups where the (destroyed) terms of the $ZDecl$ can
only be $ZDec$ or $ZSchemaDec$. {} Correspondingly, the only place where
a ($mk_z_TERM$ applied to a) $ZDec$ or a $ZSchemaDec$ occurs is is a
$ZDecl$.

\subsection{Predicates}

=SML
of ZEq tms => do_infix(cur_env, "=", tms, false, pc_pred4_eq)
| Zç lr => do_relation(cur_env, lr)
| ZTrue => (addstring "true"; PfOk)
| ZFalse => (addstring "false"; PfOk)
| Z≥ tm => bracket(cur_env, pc_pred3_≥, false, do_prefix("≥", tm))
| Z± tms => do_infix(cur_env, "±", tms, false, pc_pred2_±)
| Z≤ tms => do_infix(cur_env, "≤", tms, false, pc_pred2_≤)
| Z¥ tms => do_infix(cur_env, "¥", tms, false, pc_pred2_¥)
| Z§ tms => do_infix(cur_env, "§", tms, false, pc_pred2_§)
| Z∂ tms => do_binder("∂", tms, pc_pred1_quant) cur_env
| Z∂â1 tms => do_binder("∂â1", tms, pc_pred1_quant) cur_env
| Zµ tms => do_binder("µ", tms, pc_pred1_quant) cur_env
=TEX

Constructor $ZSchemaPred$ is for a schema used as a predicate.

=SML
| ZSchemaPred(decl, "") => bracket(cur_env, pc_expr4_schref, false,
	fn e => (
		main_term_pp e decl
	)
)
| ZSchemaPred(decl, decor) => bracket(cur_env, pc_force_brackets, false,
	fn e => (
		main_term_pp e decl;
		addstring decor
	)
)
=TEX

\subsection{Variables}

Local variables, $ZLVar$. These aren't Z if there are generic parameters

=SML
| ZLVar(name, var_ty, []) => (
	do_dec_var_name(cur_env, name, pc_dec_var_name)
)
| ZLVar(name, var_ty, tms) => (
	PfNotPossible
)
=TEX

Global variables, $ZGVar$, have their generic parameters in the list.
In the special case of generic $U$ with parameter $Totality$ the
generic parameter is suppressed.

=SML
| ZGVar (name_args as (name, var_ty, args)) => (
	if is_nil args orelse ((is_u(mk_z_gvar name_args)) handle Fail _ => false)
	then	do_dec_var_name(cur_env, name, pc_dec_var_name)
	else	do_generic cur_env name_args
)
=TEX

=SML
| ZInt n => (
	addstring n;
	PfOk
)
=TEX
Now a simplistic treatment for $ZString$
(which might have ``interesting'' contents):
=SML
| ZString s => (addstring "\"";
	addstring s;
	addstring "\"";
	PfOk
)
=TEX
\subsection{Lists, Sets, Etc.}

We could compare the $t1$ and $t3$ arguments of the $ZSeta$ and if
equivalent then suppress the $t3$ part.  However, the equivalence test is
not easy.

=SML
| Zß¢(_:TYPE, tms) => bracket(cur_env, PcHighest, true,
	do_wrapped_list("ß", ",", "¢", tms)
)
| ZSetd(_:TYPE, tms) => bracket(cur_env, PcHighest, true,
	do_wrapped_list("{", ",", "}", tms)
)
| ZSeta(t1, t2, t3) => (
	let	val new_env = set_prec PcLowest cur_env;
	in	case make_a_dec_list t1 of
		Value ds => (
			addstring "{";
			do_decl ds new_env;
			if is_z_true t2
			then ()
			else (	space(1, 2);
				addstring "| ";
				main_term_pp new_env t2
			);
			if	is_chartuple t3 ds
			then	()
			else	(space(1, 2);
				addstring "∑ ";
				main_term_pp new_env t3);
			addstring "}";
			PfOk
	) |	Nil => PfNotPossible
	end
)
| Z tm => bracket(cur_env, pc_expr2_, false, do_prefix("", tm))
| ZTuple tms => bracket(cur_env, PcHighest, true, do_wrapped_list("(", ",", ")", tms))
| Z∏ tms => bracket(cur_env, pc_expr1_∏, true, do_list(false, "∏ ", tms))
=TEX

=SML
| Z (tm, decor) => bracket(cur_env, pc_expr3_ , true,
	fn e => (
		addstring " ";
		main_term_pp (set_prec pc_expr4 e) tm;
		if decor = "" then () else addstring decor
	)
)
| ZSelâs(tm, sel) => bracket(cur_env, pc_expr4_sel, true,
	fn e => (
		main_term_pp e tm;
		addstring ".";  (* full stop "." for selection *)
		addstring sel
	)
)| ZSelât(tm, i) => bracket(cur_env, pc_expr4_sel, true,
	fn e => (
		main_term_pp e tm;
		addstring ".";  (* full stop "." for selection *)
		addstring (string_of_int i)
	)
)
=TEX

Applications, here we must think about templates for fancy-fix
operator invocations.

=SML
| ZApp tms => do_Z_app cur_env tms
| ZÃ tms => do_binder("Ã", tms, pc_expr0_Ã_Õ) cur_env
| ZÕ tms => do_binder("Õ", tms, pc_expr0_Ã_Õ) cur_env
=TEX

\subsection{Schema Expressions}

Horizontal schemas.

=SML
| Zâs(tm1, tm2) => (
	let	val new_env = set_prec PcLowest cur_env;
	in	case make_a_dec_list tm1 of
		Value ds => (
			addstring "[";
			do_decl ds new_env;
			if is_z_true tm2
			then ()
			else(
				space(1, 2);
				addstring "| ";
				main_term_pp new_env tm2
			);
			addstring "]";
			PfOk
		) |	Nil => PfNotPossible
	end
)
=TEX

Usage of a schema, with optional decoration.

=SML
| ZDecorâs(tm, "") => bracket(cur_env, pc_schema_name, true,
	fn e => (
		main_term_pp e tm
	)
)
| ZDecorâs(tm, decor) => (
	main_term_pp (set_prec pc_decoration cur_env) tm;
	addstring decor;
	PfOk
)
=TEX

=SML
| ZPreâs tm => do_schema_prefix(cur_env, "pre", tm)
| Z≥âs tm => do_schema_prefix(cur_env, "≥", tm)
| Z±âs tms => do_infix(cur_env, "±", tms, true, pc_sch2_±)
| Z≤âs tms => do_infix(cur_env, "≤", tms, true, pc_sch2_≤)
| Z¥âs tms => do_infix(cur_env, "¥", tms, true, pc_sch2_¥)
| Z§âs tms => do_infix(cur_env, "§", tms, true, pc_sch2_§)
| Z˘âs tms => do_infix(cur_env, "˘âs", tms, true, pc_sch2_˘)
| Z∂âs tms => do_binder("∂", tms, pc_sch0_quant) cur_env
| Z∂â1âs tms => do_binder("∂â1", tms, pc_sch0_quant) cur_env
| Zµâs tms => do_binder("µ", tms, pc_sch0_quant) cur_env
| Zªâs tms => do_infix(cur_env, "ªâs", tms, true, pc_sch2_ª)
=TEX

=SML
| ZHideâs(tm, strs) => bracket(cur_env, pc_sch4_hide, true,
	fn e => (
		main_term_pp e tm;
		space(1, 2);
		addstring "\\âs (";
		show_comma_list_of_strings addstring space strs;
		addstring ")"
	)
)
=TEX

=SML
| ZÑâs tm => do_schema_prefix(cur_env, "Ñ", tm)
| Zòâs tm => do_schema_prefix(cur_env, "ò", tm)
=TEX

According to the grammar in~\cite{Spivey92} renaming is just an
optional component of a schema reference, we therefore use the same
precedence.

=SML
| ZRenameâs (tm, ididl) => (
	let
		val new_env = set_prec pc_dec_name cur_env;

		fun pr_2ids(i1, i2) = (
			do_dec_var_name(new_env, i1, pc_dec_var_name);
			addstring "/";
			do_dec_var_name(new_env, i2, pc_dec_var_name);
			()
		);

		fun pr_comma_2ids ids = (addstring ","; space(1, 2); pr_2ids ids)
	in
		bracket(cur_env, pc_sch4_ref, true,
			fn e => (
				main_term_pp e tm;
				space(1, 2);
				addstring "[";
				case ididl
				of ids::[] => pr_2ids ids
				| ids::more => (pr_2ids ids; map pr_comma_2ids more; ())
				| [] => ();
				addstring "]"
			)
		)
	end
)
=TEX

\subsection{Bindings}

=SML
| ZBinding binders => (
	let
		val new_env = set_prec PcLowest cur_env;

		fun aux1(s, t) = (
			beginb(2, true);
			do_dec_var_name(new_env, s, pc_dec_var_name);
			addstring " ¶";
			space(1, 2);
			main_term_pp new_env t;
			endb()
		);

		fun aux2 b = (
			addstring ",";
			space(1, 2);
			aux1 b
		);
	in
		beginb(2, false);
		addstring "(";
		case binders
		of b :: [] => aux1 b
		| b :: more => (
			aux1 b;
			map aux2 more;
			()
		)
		| [] => ();
		addstring ")";
		endb();
		PfOk
	end
)
=TEX

\subsection{End of Function} \label{EndZFunApp}

=SML
| _	=> PfNotPossible
		(* end of case dzt *)
	)
	(* end of case basic_dest_z_term ... *)
end (* of let in fun Z_fun_app *)
handle Fail _ => PfNotPossible
) (* of fun Z_fun_app *);
=TEX

Functional application of constants and variables are treated the same
here in the Z printer.  However, they functions pased the pretty
printer support~\cite{DS/FMU/IED/DTD031} must have different
signatures.

=SML
fun €Z_var_app› (cur_env:PP_ENV) (orig_tm:TERM) (orig_name:string) (alias:string)
		(ty:TYPE) (args:TERM list) : PFUN_ANS = (
	Z_fun_app cur_env orig_tm alias ty args
);
=TEX


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ISOLATED CONSTANT OR VARIABLE}

The term value is the constant or variable, the string and type are
from its destroyed form after aliases are found.

=SML
fun €Z_do_const_var› (cur_env:PP_ENV) (orig_tm:TERM) (alias:string)
		(ty:TYPE) : PFUN_ANS = (
	Z_fun_app cur_env orig_tm alias ty []
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\subsection{LAMBDA AND APPLICATION TERMS}

Isolated `$mk_Ã$' and `$mk_app$' terms are not expected in Z.

=SML
fun €Z_do_Ã› (_:PP_ENV) (_:TERM) (_:TERM) : PFUN_ANS = PfNotPossible;

fun €Z_do_app› (_:PP_ENV) (_:TERM) (_:TERM list) : PFUN_ANS = PfNotPossible;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\section{FINALE}

%********************************************************************

\subsection{Install the Z Printing Functions}

=SML
val side_effect =
set_printers("Z",
	(Z_do_Ã, Z_do_app, Z_do_const_var, Z_var_app,
		Z_fun_app, Z_do_const_var));

val side_effect =
	set_start_quote("Z", "Ò" (*=Æ=*) );
=TEX

%********************************************************************

\subsection{End of Structure}

=SML
end (* of structure ZPrettyPrinter *);
=TEX


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

\newpage
%\twocolumn[\section{INDEX}] \label{Index}
\section{INDEX}

\footnotesize
\printindex

\onecolumn

\end{document}
