% imp064.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp064.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Implementation of the Z Pretty Printer}
\TPPref{DS/FMU/IED/IMP064}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp064.dvi
doctex imp064
texdvi imp064
bibtex imp064
doctex imp064 ; texdvi imp064
doctex imp064 ; texdvi imp064 ; bibtex imp064
dvipage imp064 &


docsml imp064
use_file "imp064.sml";

lasp -s imp064.doc > zz1
lasp -s -u imp064.OKwords imp064.doc > zz1

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the
	Z~pretty printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\underscoreoff

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[\FormatDate{$Date$%
}, issue \SCCSissue~]
	Initial drafts.
%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]


\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the pretty printer for the Z proof support
system.  The detailed level design for this document
in~\cite{DS/FMU/IED/DTD064}.

%********************************************************************

\subsection{Introduction}

%--------------------------------------------------------------------

\subsubsection{Purpose and Background}

%--------------------------------------------------------------------

\subsubsection{Dependencies}

%--------------------------------------------------------------------

\subsubsection{Interface}

%--------------------------------------------------------------------

\subsubsection{Algorithms}

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}
%\subsubsection{Terminology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\section{STRUCTURE} \label{StartStructure}

=SML
structure €ZPrettyPrinter› : ZPrettyPrinter = struct
=TEX

=SML
open PrettyPrinterSupport;
infix gt_prec;

open ZUserInterfaceSupport;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{UTILITIES}

=SML
fun €show_comma_list_of_strings› (addstring : string -> unit)
		(space : int * int -> unit) (strs : string list) : unit = (
let
	fun aux nil = ()
	| aux (t1::nil) = addstring t1
	| aux (t1::more) = (
		addstring t1;
		addstring ",";
		space(1, 0);
		aux more
	)
in
	aux strs
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PRECEDANCES}

Rather than place lots of numeric precedance codes in the code we
declare several precedance codes here.  Syntax rules refer to
productions from the Z~grammar of~\cite{DS/FMU/IED/DTD061}.
These declarations are given in order with the loosly
binding first and most tightly binding at the end.

=SML
val pc_sch0_quant : PREC_CONTEXT = PcNormal(0, 10, false);
=TEX

=IGN
val pc_sch1 : PREC_CONTEXT = PcNormal(10, 0, false);
val pc_sch1_text : PREC_CONTEXT = PcNormal(10, 10, false);
=TEX

=SML
val pc_sch1_ref : PREC_CONTEXT = PcNormal(20, 15, false);
val pc_sch1_≥ : PREC_CONTEXT = PcNormal(20, 20, false);
val pc_sch1_pre : PREC_CONTEXT = PcNormal(20, 30, false);
val pc_sch1_± : PREC_CONTEXT = PcNormal(20, 40, false);
val pc_sch1_≤ : PREC_CONTEXT = PcNormal(20, 50, false);
val pc_sch1_¥ : PREC_CONTEXT = PcNormal(20, 60, true);
val pc_sch1_§ : PREC_CONTEXT = PcNormal(20, 70, false);
val pc_sch1_˘ : PREC_CONTEXT = PcNormal(20, 80, false);
val pc_sch1_hide : PREC_CONTEXT = PcNormal(20, 90, false);
val pc_sch1_ª : PREC_CONTEXT = PcNormal(20, 100, false);
=TEX

=SML
val pc_pred0 : PREC_CONTEXT = PcNormal(100, 0, false);
=TEX

=IGN
val pc_pred1 : PREC_CONTEXT = PcNormal(110, 0, false);
=TEX

Symbols in syntax rule $Pred2$ (which is $Predicate-1$
in~\cite{Spivey89}) need their own precedance group.  Note that the
implication is right associative, the other infixes are left
associative

=IGN
val pc_pred2 : PREC_CONTEXT = PcNormal(120, 0, false);
=TEX

Relational operators have their own numeric precedance with a range of,
effectively, plus or minus infinity.

=SML
val pc_pred2_rel : PREC_CONTEXT = PcNormal(118, 0, false);
=TEX

=SML
val pc_pred2_eq : PREC_CONTEXT = PcNormal(120, 10, false);
val pc_pred2_ç : PREC_CONTEXT = pc_pred2_eq;
val pc_pred2_≥ : PREC_CONTEXT = PcNormal(120, 30, false);
val pc_pred2_± : PREC_CONTEXT = PcNormal(120, 40, false);
val pc_pred2_≤ : PREC_CONTEXT = PcNormal(120, 50, false);
val pc_pred2_¥ : PREC_CONTEXT = PcNormal(120, 60, true);
val pc_pred2_§ : PREC_CONTEXT = PcNormal(120, 70, false);
=TEX

=IGN
val pc_expr0_in_gen : PREC_CONTEXT = PcNormal(200, 20, false);
=TEX

=SML
val pc_expr0_Ã_Õ : PREC_CONTEXT = PcNormal(200, 10, false);
val pc_expr0_∏ : PREC_CONTEXT = PcNormal(200, 30, false);
=TEX

Syntax rule $Expr0$ captures the fancy fix generic operators which
have their own numeric precedance with a range of,
effectively, plus or minus infinity.

=SML
fun pc_expr0_gen (p:int) : PREC_CONTEXT = PcNormal(203, p, false);
=TEX

Syntax rule $Expr1$ captures the fancy fix function operators plus it is used by
some other productions.  Have two precedance values:  one for its
direct recursive uses (i.e., where $Expr1$ calls $Expr1$); the other
for its other uses.
Fancy fix function operators have their own numeric precedance with a
range of, effectively, plus or minus infinity.

=SML
fun pc_expr1_in_fun (p:int) : PREC_CONTEXT = PcNormal(206, p, false);
=TEX

=SML
val pc_expr1_ : PREC_CONTEXT = PcNormal(210, 20, false);
=TEX

=SML
val pc_expr2 : PREC_CONTEXT = PcNormal(220, 0, false);
val pc_expr2_lhs : PREC_CONTEXT = PcNormal(220, 10, false);
val pc_expr2_rhs : PREC_CONTEXT = PcNormal(220, 20, false);
=TEX

=SML
val pc_expr3_gvar : PREC_CONTEXT = PcNormal(230, 10, false);
val pc_expr3_schref : PREC_CONTEXT = PcNormal(230, 20, false);
val pc_expr3_sel : PREC_CONTEXT = PcNormal(230, 30, false);
=TEX

=IGN
val pc_expr4 : PREC_CONTEXT = PcNormal(240, 0, false);
=TEX

=SML
val pc_schema_name : PREC_CONTEXT = PcNormal(300, 0, false);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{BRACKET GENERATION}

We have many small sections of code which need to enclose something
in round brackets if the precedances require.  Function $bracket$
does this for us.

=SML
fun €bracket› (cur_env:PP_ENV, enclosed_prec:PREC_CONTEXT,
		block:bool, how: PP_ENV -> unit) : PFUN_ANS = (
let
	val PpEnv{pe_prec=enclosing_prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_endb=endb, ...} = cur_env;

	val br = enclosing_prec gt_prec enclosed_prec;

	val inner_prec = if br then PcLowest else enclosed_prec;

	val bl = block orelse br;
in
	if br then addstring "(" (*=)=*) else ();
	if bl then beginb(2, true) else ();

	how (set_prec inner_prec cur_env);

	if bl then endb() else ();
	if br then (*=(=*) addstring ")" else ();

	PfOk
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{AUXILIARY PRINTING FUNCTIONS}

\subsection{Names}

Function $chop_z_name$ splits a Z name into three pieces.  A leading
``{\tt z'}'' is discarded.  The value returned has the body of the name
and the decoration if any.

=SML
local
	fun aux((ch as "?") :: more, prev) = aux(more, ch::prev)
	| aux((ch as "!") :: more, prev) = aux(more, ch::prev)
	| aux((ch as "'") :: more, prev) = aux(more, ch::prev)
	| aux(more, nil) = (implode(rev more), Nil)
	| aux(more, prev) = (implode(rev more), (Value o implode o rev) prev)
	;
in

fun €chop_z_name› (name : string) : string * string OPT = (
	case explode name of
		"z" :: "'" :: (more as(_ :: _)) =>
			aux (rev more, nil)
	|	ename => aux (rev ename, nil)
);

end;
=TEX

\subsection{Simple Infix, Prefix and Postfix Operators}

Function $Z_fun_app$ deals with the functionale application of
constants.  The first term $orig_tm$ is the constant, the string
$alias$ and type $ty$ are from its destroyed form after aliases are
found.  The term list $args$ holds the arguments that the constant is
applied to.  The original term may be recreated by $list_mk_app$
applied to the term and the term list.

=SML
fun €do_prefix› (oper: string, tm:TERM) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;
in
	addstring oper;
	space(1, 0);
	beginb(2, true);
	main_term_pp cur_env tm;
	endb()
end
);
=TEX

=SML
fun €do_infix› (oper: string, (l:TERM, r:TERM)) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
in
	main_term_pp cur_env l;
	space(1, 0);
	addstring oper;
	addstring " ";
	main_term_pp cur_env r
end
);
=TEX

=SML
fun €do_binder› (oper: string, (t1:TERM, t2:TERM, t3:TERM))
		(cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
in
	addstring oper;
	addstring " ";
	main_term_pp cur_env t1;
	space(1, 0);
	addstring "| ";
	main_term_pp cur_env t2;
	space(1, 0);
	addstring "∑ ";
	main_term_pp cur_env t3
end
);
=TEX

\subsection{Lists of Terms}

There are several variations on lists.

Some lists (typically those separated by commas or semicolons)
have the separator plus a space token come between value.
Others lists have the space token before the separator.

=SML
fun €do_list› (after:bool, sep:string, tms:TERM list) (cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;

	fun aux nil = ()
	| aux (t1::nil) = main_term_pp cur_env t1
	| aux (t1::more) = (
		main_term_pp cur_env t1;
		if after then () else space(1, 0);
		addstring sep;
		if after then space(1, 0) else ();
		aux more
	)
	;
in
	aux tms
end
);
=TEX

=SML
fun €do_wrapped_list› (opener:string, sep:string, closer:string, tms:TERM list)
		(cur_env:PP_ENV) : unit = (
let
	val PpEnv{pe_addstring=addstring, pe_space=space, ...} = cur_env;
in
	addstring opener;
	do_list(true, sep, tms) cur_env;
	addstring closer
end
);
=TEX

\subsection{Delta Schemas}

=SML
fun €do_Ñ_ò› (cur_env:PP_ENV, name:string, tm:TERM) : PFUN_ANS = (
	bracket(cur_env, pc_sch1_ref, false,
		fn e => (do_prefix(name, tm) (set_prec pc_schema_name e))
	)
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{FANCY-FIX TERMS}

A fancy fix expression is viewed as a list of terms and strings.  The
terms are the subexpresions or arguments of the fancy fix expression,
the strings are the parts of the identifier.  The goal is to take an
identifier and its arguments and reformat them as a list of values of
data type $Z_PIECE$ which contains the necessary terms and strings.
Most of the functions involved in fancy fix formatting manipulate a
optional list of these values, where an empty list is not expected, it
would represent some sort of internal error.  The $Nil$ value is used
to show that a routine has been unable to perform its part of the
formatting and so the expression cannot be shown in a fancy fix form.

=SML
datatype €Z_PIECE›
	=	€zp_term›	of TERM * PREC_CONTEXT
	|	€zp_string›	of string * ZFIXITY
	;
=TEX

After the pieces have been assembled we must decide upon how to format
them.  This involves deciding (1)~where to output spaces; (2)~which
spaces may be line breaks; (3)~where Oppen begin and end tokens are
placed within the text; (4)~what sort of Oppen begin tokens are
wanted.  To hold the results of these decisions we need another data
structure.  Function $make_print_tokens$ makes the necessary decisions
by converting lists of $Z_PIECE$s into $PRINT_TOKEN$s.

=SML
datatype €PRINT_TOKEN›
	=	€pt_term›	of TERM * PREC_CONTEXT
	|	€pt_string›	of string
	|	€pt_space›	of int * int
	|	€pt_beginb›	of int * bool
	|	€pt_endb›
	;
=TEX

%********************************************************************

\subsection{Creation of the Pieces to Print}

Function $format_fancy_fix$ basically merges its $tmpl$ and $args$
arguments to form a single list which comprises the pieces of the fancy
fix expression ready for printing.  If the merge is successful then the
pretty printer can commit itself to printing the original term in fancy
fix form, which is done in function $print_pieces$.  An unsuccessful
merge is indicated by returning a $Nil$ value.

This function is closly based upon a function of the same name
from ``Z User Interface Support'~\cite{DS/FMU/IED/IMP079}.

=SML
fun €format_fancy_fix›
	(class:CLASS)
	(tmpl : TEMPLATE)
	(decor : string OPT)
	(args : TERM list)
	: Z_PIECE list OPT = (
let
	val rids = rev(tmpl_ids tmpl class);

	val ids = rev(case (rids, decor) of ((i, f) :: t, Value d) => (i^d, f) :: t | _ => rids);

	fun aux1 names tms = (
		fold	(fn ((n, t), prev) => (zp_string n) :: (zp_term(t, PcLowest)) :: prev)
			(combine names tms)
			nil
	);

	fun aux2 names tms = (
		fold	(fn ((t, n), prev) => (zp_term(t, PcLowest)) :: (zp_string n) :: prev)
			(combine tms names)
			nil
	);
in
	Value(	case tmpl
		of TmplNon _ => (zp_string(hd ids)) :: (aux2 (tl ids) args)
		| TmplIn _ => (zp_term(hd args, PcLowest)) :: (aux1 ids (tl args))
		| TmplPre _ => aux1 ids args
		| TmplPost _ => aux2 ids args
	)
end
handle Fail _ => Nil
);
=TEX

%********************************************************************

\subsection{Identifying the Template}

In determining whether a Z~identifier has some fancy fix form we make
several consistency checks, these aim to ensure that the text printed
is compatible with the various symbol table information and so the
parser can read back the text to generate the same term.

The $name$ argument here has already had any leading ``{\tt z'}''
and trailing decoration discarded.

=SML
fun €get_template_info›(name:string) : (TEMPLATE * CLASS * STUB list) OPT = (
let
	val tmpl = template_of_string name handle Fail _ => TmplNon(name, Nil);
	val fst_tmpl_name = first_tmpl_id tmpl;
in
	if name = fst_tmpl_name
	then
		Nil
	else
		case get_zfixity_info fst_tmpl_name
		of Value((_, class), [tmpl2]) =>
			if tmpl = tmpl2
			then
				Value(tmpl, class, tmpl_stubs tmpl)
			else
				Nil
		| _ => Nil
end
);
=TEX

%********************************************************************

\subsection{Printing the Pieces}

Some analysis and modification must be done to the $Z_PIECE$s before
printing.

Function $analyse_prec$ determines the precedance of the pieces of the
term.  This is the enclosed precedance of the term which will be used
as the right hand argument of $gt_prec$ when the need for brackets is
being determined.

=SML
local
	fun class_p(ZClFun p) = pc_expr1_in_fun p
	| class_p ZClRel = pc_pred2_rel
	| class_p(ZClGen p) = pc_expr0_gen p
	;

	fun get_p(zp_term(_, p)) = p
	| get_p(zp_string(_, (ff, cl))) = (
		case ff
		of ZFFBeginOp		=> PcLowest
		| ZFFEndOp		=> PcLowest
		| ZFFInOp		=> class_p cl
		| ZFFPostBeginOp	=> class_p cl
		| ZFFThenOp		=> PcLowest
		| ZFFPostOp		=> class_p cl
		| ZFFPreEndOp		=> class_p cl
		| ZFFPreOp		=> class_p cl
	);

	fun aux(p, prev) = if p gt_prec prev then prev else p;
in

fun €analyse_prec› (pieces:Z_PIECE list) : PREC_CONTEXT =(
	fold aux (map get_p pieces) PcLowest
);

end;
=TEX

Function $set_end_precs$ sets the precedances of the first and last
terms of the $Z_PIECE$s to the given value.

=SML
fun €set_end_precs› (tm_prec:PREC_CONTEXT) (pieces:Z_PIECE list) : Z_PIECE list = (
let
	fun aux((zp_term(t, _))::more) = (zp_term(t, tm_prec)) :: more
	| aux((h as zp_string _)::more) = h :: (aux more)
	| aux nil = nil
	;
in
	aux(rev(aux(rev pieces)))
end
);
=TEX

Function $make_print_tokens$ decides how to format various types of
fancy fix expression.  There are special cases for the three main
forms, namely infix, postfix and prefix.  Note the enclosing text
is responsible for adding Oppen begin and end tokens at the ends.

=SML
local
	val hsp = pt_string " ";
	val ssp = pt_space(1, 2);

	fun aux nil = nil
	| aux (zp_term t1 :: zp_string(s1, _) :: nil) =
		ssp :: pt_term t1 :: hsp :: pt_string s1 :: nil
	| aux (zp_string(s1, _) :: nil) = hsp :: pt_string s1 :: nil
	| aux (zp_term t1 :: nil) = ssp :: pt_term t1 :: nil
	| aux (zp_string(s1, _) :: more) = hsp :: pt_string s1 :: hsp :: aux more
	| aux (zp_term t1 :: more) = ssp :: pt_term t1 :: ssp :: aux more
	;
in

fun €make_print_tokens› (pieces:Z_PIECE list) : PRINT_TOKEN list = (
	case pieces
	of (zp_term t1 :: zp_string(s1, _) :: zp_term t2 :: nil) => (
		(* Infix *)
		pt_term t1 :: ssp :: pt_string s1 :: hsp :: pt_term t2 :: nil
		)
	| (zp_term t1 :: zp_string(s1, _) :: nil) => (
		(* Postfix *)
		pt_term t1 :: hsp :: pt_string s1 :: nil
		)
	| (zp_string(s1, _) :: zp_term t2 :: nil) => (
		(* Prefix *)
		pt_string s1 :: hsp :: pt_term t2 :: nil
		)
	| (zp_term t1 :: more) => (
		pt_term t1 :: aux more
		)
	| (zp_string(s1, _) :: more) => (
		pt_string s1 :: aux more
		)
	| nil => nil
);

end;
=TEX

Finally, function $print_pieces$ combines the various modifiers and
prints out the fancy fix expresion.  Note that whilst this
function returns a value of type $PFUN_ANS$ it may only return the
value $PfOk$ (which is done by function $bracket$ here) because at
this stage in the processing it is been decided that the expression
will be printed in a fancy fix fashion.

=SML
fun €print_pieces› (cur_env:PP_ENV) (pieces:Z_PIECE list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;

	val tm_prec = analyse_prec pieces;
	val pieces1 = make_print_tokens(set_end_precs tm_prec pieces);
in
	bracket(cur_env, tm_prec, true,
		fn e => (map(	fn pt_term(t, p) => main_term_pp (set_prec p e) t
				| pt_string s => addstring s
				| pt_space ss => space ss
				| pt_beginb ss => beginb ss
				| pt_endb => endb()
				)
				pieces1
			; ()
			)
	)
end
);
=TEX

%********************************************************************

\subsection{Dealing with Functional Applications}

=SML
fun €get_fancy_fix›(fullname:string, arg_tm:TERM) : Z_PIECE list OPT = (
let
	val (name, decor) = chop_z_name fullname;
in
	case get_template_info name
	of Nil => Nil
	| Value(tmpl, class, stubs) => (
		if length stubs = 1
		then
			format_fancy_fix class tmpl decor [arg_tm]
		else
			let
				val args = dest_z_tuple arg_tm (* may fail *);
			in
				if length args = length stubs
				then
					format_fancy_fix class tmpl decor args
				else
					Nil
			end handle Fail _ => Nil
	)
end
);
=TEX
=SML
local
val €u› = mk_z_gvar("U", î'1 SETÆ, [mk_const("z'Totality", î'1 SETÆ)]);
in
fun €is_u› tm = (term_match tm u; true) handle Fail _ => false;
end;

fun €get_fancy_fix1›(tm:TERM, arg_tm:TERM) : Z_PIECE list OPT = (
	case dest_z_term tm of
		Zgvar (name, _, args) => (
			if	all args is_u
			then	get_fancy_fix (name, arg_tm)
			else	Nil
	) |	Zlvar (name, _, args) => (
			if	all args is_u
			then	get_fancy_fix (name, arg_tm)
			else	Nil
	) |	_ => Nil
);
=SML
fun €do_Z_app› (cur_env:PP_ENV) (hd_term:TERM, arg_tm:TERM) : PFUN_ANS = (
let
	val PpEnv{pe_space=space, ...} = cur_env;
in
	case get_fancy_fix1(hd_term, arg_tm)
	of Nil => bracket(cur_env, pc_expr2, true,
			fn e => (
				main_term_pp (set_prec pc_expr2_lhs e) hd_term;
				space(1, 2);
				main_term_pp (set_prec pc_expr2_rhs e) arg_tm
			)
		)
	| Value pieces => print_pieces cur_env pieces
end
);
=TEX

%********************************************************************

\subsection{Dealing with Generics}

=SML
fun €do_generic› (cur_env:PP_ENV) (fullname:string, _:TYPE, tms:TERM list)
		: PFUN_ANS = (
let
	val (name, decor) = chop_z_name fullname;
in
	case
		case get_template_info name
		of Nil => Nil
		| Value(tmpl, class, stubs) => (
			if length tms = length stubs
			andalso all tms is_u
			then
				format_fancy_fix class tmpl decor tms
			else
				Nil
		)
	of Value pieces => print_pieces cur_env pieces
	| Nil => bracket(cur_env, pc_expr3_gvar, true,
		fn e => (
			let val PpEnv {pe_addstring = addstring, ...} = cur_env;
			in	addstring name;
				do_wrapped_list("[", ",", "]", tms) e
			end
		))
end
);
=TEX

%********************************************************************

\subsection{Dealing with Relations}
=SML
fun €do_relation› (cur_env:PP_ENV, (l:TERM, r:TERM)) : PFUN_ANS = (
	case	get_fancy_fix1 (r, l)
	of Value pieces => print_pieces cur_env pieces
	| Nil => bracket(cur_env, pc_pred2_ç, false, do_infix("ç", (l, r)))
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{APPLICATION OF CONSTANT OR VARIABLE}

=SML
fun €Z_fun_app› (cur_env:PP_ENV) (orig_tm:TERM) (alias:string)
		(ty:TYPE) (args:TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring,
		pe_beginb=beginb, pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p = main_term_pp (set_prec p cur_env);
in
	case basic_dest_z_term(orig_tm, args)
	of BdzNotZ _ => PfNotPossible
	| BdzFail{BdzFArgc=c, ...}  => PfFewer c
	| BdzOk dzt => (
		case dzt
=TEX

The next part of this function is a big case clause with one branch for each
of the forms of Z~term.  These branch are spread over several blocks of
Standard~ML code, the function finishes in section~\ref{EndZFunApp}
on page~\pageref{EndZFunApp}.

\subsection{Declarations}

In theory the three constructors $Zdec$, $Zdecsexp$ and $Zdecl$ occur
only in related groups where the (destroyed) terms of the $Zdecl$ can
only be $Zdec$ or $Zdecsexp$. {} Correspondingly, the only place where
a ($mk_z_TERM$ applied to a) $Zdec$ or $Zdecsexp$ occurs is is a
$Zdecl$.

=SML
of Zdec(tms, dec_ty) => (
	beginb(2, false);
	beginb(0, false);
	do_list(true, ",", tms) cur_env;
	endb();
	space(1, 2);
	addstring ": ";
	main_term_pp cur_env dec_ty;
	endb();
	PfOk
)
=TEX
=SML
| Zdecsexp(decl, decor) => (
	main_term_pp cur_env decl;
	addstring decor;
	PfOk
)
=TEX
=SML
| Zdecl tms => (
	let
		fun aux nil = ()
		| aux (t1::nil) = main_term_pp cur_env t1
		| aux (t1::more) = (
			main_term_pp cur_env t1;
			addstring ";";
			space(1, 0);
			aux more
		)
		;
	in
		beginb(2, true);
		aux tms;
		endb()
	end;
	PfOk
)
=TEX

\subsection{Predicates}

=SML
| Zeq tms => bracket(cur_env, pc_pred2_eq, false, do_infix("=", tms))
| Zç lr => do_relation(cur_env, lr)
| Ztrue => (addstring "true"; PfOk)
| Zfalse => (addstring "false"; PfOk)
| Z≥ tm => bracket(cur_env, pc_pred2_≥, false, do_prefix("≥", tm))
| Z± tms => bracket(cur_env, pc_pred2_±, false, do_infix("±", tms))
| Z≤ tms => bracket(cur_env, pc_pred2_≤, false, do_infix("≤", tms))
| Z¥ tms => bracket(cur_env, pc_pred2_¥, false, do_infix("¥", tms))
| Z§ tms => bracket(cur_env, pc_pred2_§, false, do_infix("§", tms))
| Z∂ tms => bracket(cur_env, pc_pred0, true, do_binder("∂", tms))
| Z∂â1 tms => bracket(cur_env, pc_pred0, true, do_binder("∂â1", tms))
| Zµ tms => bracket(cur_env, pc_pred0, true, do_binder("µ", tms))
=TEX

Constructor $Zpredsexp$ is for a schema used as a predicate.

=SML
| Zpredsexp(decl, decor) => bracket(cur_env, pc_expr3_schref, false,
	fn e => (
		main_term_pp e decl;
		addstring decor
	)
)
=TEX

\subsection{Variables}

Local variables, $Zlvar$, do not expect anything in the list, but if
we get something then try and print something.

=SML
| Zlvar(name, var_ty, nil) => (
	addstring name;
	PfOk
)
| Zlvar(name, var_ty, tms) => (
	addstring name;
	do_wrapped_list("?[?", ",", "?]?", tms);
	PfOk
)
=TEX

Global variables, $Zgvar$, have their generic parameters in the list

=SML
| Zgvar(name, var_ty, nil) => (
	addstring(
		case chop_z_name name
		of (n, Value d) => n ^ d
		| (n, Nil) => n);
	PfOk
)
| Zgvar name_args => do_generic cur_env name_args
=TEX

=SML
| Zint n => (
	addstring n;
	PfOk
)
=TEX
Now a simplistic treatment for $ZString$
(which might have ``interesting'' contents):
=SML
| ZString s => (addstring "\"";
	addstring s;
	addstring "\"";
	PfOk
)
=TEX
\subsection{Lists, Sets, Etc.}

=SML
| Zß¢(_:TYPE, tms) => bracket(cur_env, PcHighest, true,
	do_wrapped_list("ß", ",", "¢", tms)
)
| Zsetd(_:TYPE, tms) => bracket(cur_env, PcHighest, true,
	do_wrapped_list("{", ",", "}", tms)
)
| Zseta(t1, t2, t3) => bracket(cur_env, PcHighest, true,
	fn e => (
		addstring "{";
		main_term_pp (set_prec PcLowest e) t1;
		space(1, 2);
		addstring "| ";
		main_term_pp (set_prec PcLowest e) t2;
		space(1, 2);
		addstring "∑ ";
		main_term_pp (set_prec PcLowest e) t3;
		addstring "}"
	)
)
| Z tm => bracket(cur_env, pc_expr1_, false, do_prefix("", tm))
| Ztuple tms => bracket(cur_env, PcHighest, true, do_wrapped_list("(", ",", ")", tms))
| Z∏ tms => bracket(cur_env, pc_expr0_∏, true, do_list(false, "∏", tms))
=TEX

=SML
| Z (tm, "") => bracket(cur_env, pc_schema_name, true,
	fn e => (
		addstring " ";
		main_term_pp e tm
	)
)
| Z (tm, decor) => bracket(cur_env, pc_schema_name, true,
	fn e => (
		addstring " ";
		main_term_pp e tm;
		addstring decor
	)
)
| Zsel(tm, sel) => bracket(cur_env, pc_expr3_sel, true,
	fn e => (
		main_term_pp e tm;
		addstring ".";  (* full stop "." for selection *)
		addstring sel
	)
)
=TEX

Applications, here we must think about templates for fancy-fix
operator invocations.

=SML
| Zapp tms => do_Z_app cur_env tms
| ZÃ tms => bracket(cur_env, pc_expr0_Ã_Õ, true, do_binder("Ã", tms))
| ZÕ tms => bracket(cur_env, pc_expr0_Ã_Õ, true, do_binder("Õ", tms))
=TEX

\subsection{Schema Expressions}

Horizontal schemas.

=SML
| Zâs(tm1, tm2) => (
	let
		val new_env = set_prec PcLowest cur_env;
	in
		addstring "[";
		main_term_pp new_env tm1;
		space(1, 2);
		addstring "| ";
		main_term_pp new_env tm2;
		addstring "]";
		PfOk
	end
)
=TEX

Useage of a schema, with optional decoration.

=SML
| Zdecâs(tm, decor) => bracket(cur_env, pc_schema_name, true,
	fn e => (
		main_term_pp e tm;
		addstring decor
	)
)
=TEX

=SML
| Zpreâs tms => bracket(cur_env, pc_sch1_pre, false, do_prefix("pre", tms))
| Z≥âs tms => bracket(cur_env, pc_sch1_≥, false, do_prefix("≥", tms))
| Z±âs tms => bracket(cur_env, pc_sch1_±, false, do_infix("±", tms))
| Z≤âs tms => bracket(cur_env, pc_sch1_≤, false, do_infix("≤", tms))
| Z¥âs tms => bracket(cur_env, pc_sch1_¥, false, do_infix("¥", tms))
| Z§âs tms => bracket(cur_env, pc_sch1_§, false, do_infix("§", tms))
| Z˘âs tms => bracket(cur_env, pc_sch1_˘, false, do_infix("˘", tms))
| Z∂âs tms => bracket(cur_env, pc_sch0_quant, true, do_binder("∂", tms))
| Z∂â1âs tms => bracket(cur_env, pc_sch0_quant, true, do_binder("∂â1", tms))
| Zµâs tms => bracket(cur_env, pc_sch0_quant, true, do_binder("µ", tms))
| Zªâs tms => bracket(cur_env, pc_sch1_ª, false, do_infix("ª", tms))
=TEX
=SML
| Zhideâs(tm, strs) => bracket(cur_env, pc_sch1_hide, true,
	fn e => (
		main_term_pp e tm;
		space(1, 2);
		addstring "\\ (";
		show_comma_list_of_strings addstring space strs;
		addstring ")"
	)
)
=TEX

=SML
| ZÑâs tm => do_Ñ_ò(cur_env, "Ñ", tm)
| Zòâs tm => do_Ñ_ò(cur_env, "ò", tm)
=TEX

According to the grammar in~\cite{Spivey92} renaming is just an
optional component of a schema reference, we therefore use the same
precedance.

=SML
| ZRenameâs (tm, ididl) => (
	let
		fun pr_2ids(i1, i2) = (addstring i1; addstring "/"; addstring i2);

		fun pr_comma_2ids ids = (addstring ","; space(1, 2); pr_2ids ids)
	in
		bracket(cur_env, pc_sch1_ref, true,
			fn e => (
				main_term_pp e tm;
				space(1, 2);
				addstring "[";
				case ididl
				of ids::nil => pr_2ids ids
				| ids::more => (pr_2ids ids; map pr_comma_2ids more; ())
				| nil => ();
				addstring "]"
			)
		)
	end
)
=TEX

\subsection{Bindings}

=SML
| Zbinding binders => (
	let
		val new_env = set_prec PcLowest cur_env;

		fun aux1(s, t) = (
			beginb(2, true);
			addstring s;
			addstring " ¶";
			space(1, 2);
			main_term_pp new_env t;
			endb()
		);

		fun aux2 b = (
			addstring ",";
			space(1, 2);
			aux1 b
		);
	in
		beginb(2, false);
		addstring "(";
		case binders
		of b :: nil => aux1 b
		| b :: more => (
			aux1 b;
			map aux2 more;
			()
		)
		| nil => ();
		addstring ")";
		endb();
		PfOk
	end
)
=TEX

\subsection{End of Function} \label{EndZFunApp}

=SML
		(* end of case dzt *)
	)
	(* end of case basic_dest_z_term ... *)
end (* of let in fun Z_fun_app *)
) (* of fun Z_fun_app *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ISOLATED CONSTANT OR VARIABLE}

The term value is the constant or variable, the string and type are
from its destroyed form after aliases are found.

=SML
fun €Z_do_const_var› (cur_env:PP_ENV) (orig_tm:TERM) (alias:string)
		(ty:TYPE) : PFUN_ANS = (
	Z_fun_app cur_env orig_tm alias ty nil
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\subsection{LAMBDA AND APPLICATION TERMS}

Isolated `$mk_Ã$' and `$mk_app$' terms are not expected in Z.

=SML
fun €Z_do_Ã› (_:PP_ENV) (_:TERM) (_:TERM) : PFUN_ANS = PfNotPossible;

fun €Z_do_app› (_:PP_ENV) (_:TERM) (_:TERM list) : PFUN_ANS = PfNotPossible;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newpage
\section{FINALE}

%********************************************************************

\subsection{Install the Z Printing Functions}

=SML
val side_effect =
set_printers("Z",
	(Z_do_Ã, Z_do_app, Z_do_const_var, Z_fun_app,
		Z_fun_app, Z_do_const_var));
=TEX

%********************************************************************

\subsection{End of Structure}

=SML
end (* of structure ZPrettyPrinter *);
=TEX


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

%\twocolumn[\section{INDEX}] \label{Index}
\section{INDEX}

\footnotesize
\printindex

\onecolumn

\end{document}


