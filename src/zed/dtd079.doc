=IGN
********************************************************************************
dtd079.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% dtd079.doc   %Z% $Date: 2006/04/20 09:15:43 $ $Revision: 1.24 $ $RCSfile: dtd079.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Z User Interface Support}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD079}  %% Mandatory field
\def\SCCSversion{$Revision: 1.24 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/04/20 09:15:43 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
Z User Interface Support module.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.3~(\FormatDate{92/06/18
})]
First draft.
\item [Issue 1.10~(\FormatDate{%92/08/06%%
})]
Reworded error message 79001 (which is sometimes used in circumstances where
it is not certain in which theory the problem arose).
Order of result of $tmpl\_ids$ now defined.
Added $format\_z\_type$ and $z\_type\_of$ to the signature.
\item [Issue 1.12]
Changed treatment of term quotations.
\item [Issue 1.13]
Corrected narrative.
\item [Issue 1.14]
Update for SML'97.
\item [Issue 1.15] Update for new INTEGER type.
\item [Issue 1.16] local declarations removed for Poly/ML port.
\item [Issue 1.17] Support for left associative operators.
\item[Issue 1.18] Copyright and banner updates for open source release.
\item[Issue 1.19] PPZed-specific updates for open source release
\item[Issue 1.20] Corrected {\LaTeX} errors.
\item[Issue 1.21] Added new kinds of stub in templates.
Changed comments on the types into type abbreviations.
\item[Issue 1.22] Option to require distinguishing subscripts on all schema operations.
\item[Issue 1.23] Now support decoration of fancyfix identifiers.
\item[Issue 1.24] Added support for floating point literals
\item[Issue 1.25] {\em string\_of\_float} renamed as {\em z\_string\_of\_float}.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the Z User Interface Support module.
The high level design for this material is given in \cite{DS/FMU/IED/HLD018}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD018}.
\subsection{Dependencies}
This module depends on the {\ProductHOL} facilities of \cite{DS/FMU/IED/DTD012}.
\subsubsection{Possible Enhancements}
Support for the user to delete fixity declarations has not been provided.
\subsubsection{Deficiencies}
None known.
\section{PREAMBLE}
=DOC
signature ÛZUserInterfaceSupportÝ = sig
=DESCRIBE
This is the signature of a structure which provides various services
to the Z User Interface.
This structure contains certain private functions which are invoked as one
navigates around the theory database.
These private functions may give rise to error 79001 if the
theory database user data has been corrupted (e.g. by explicit and incorrect use
of lower level interfaces). The most straightforward way of clearing this
corruption is to delete the theory and reload the specification.

The comment messages 79002 and 79010 are printed
out when $new\_parent$ has been used to introduce
an ancestor theory containing a fixity paragraph which is incompatible
with the current context or when one opens a theory which has ancestors containing
incompatible fixity paragraphs.
This condition is not fatal, however it
will not be possible to use the Z parser to enter one of the
incompatible names.
=FAILURE
79001	A Z fixity entry, apparently from theory ?0, is corrupt
79002	A Z fixity entry from theory ?0 could not be loaded (?1)
79010	The template ?0 clashes with the template ?1 which is already in scope
=ENDDOC
\section{INTERFACE}
\subsection{Data Types}
{\tiny\makeatletter\def\HOLindex@font{\fam\bffam}\makeatother
=DOC
type ÛIDÝ		= string;
type ÛDECORÝ		= string;
type ÛPRECÝ		= int;
datatype ÛASSOCÝ = ÛLeftAssocÝ | ÛRightAssocÝ;
datatype ÛCLASSÝ	=	ÛZClFunÝ of int * ASSOC
			|	ÛZClRelÝ
			|	ÛZClGenÝ of int * ASSOC;
datatype ÛFANCYFIXÝ	=	ÛZFFBeginOpÝ
			|	ÛZFFEndOpÝ
			|	ÛZFFInOpÝ
			|	ÛZFFPostBeginOpÝ
			|	ÛZFFThenOpÝ
			|	ÛZFFPostOpÝ
			|	ÛZFFPreEndOpÝ
			|	ÛZFFPreOpÝ;
type ÛZFIXITYÝ 		= FANCYFIX * CLASS;
datatype ÛZ_LOG_IN_OPÝ	= ZLogInOp± of bool
			| ZLogInOp² of bool
			| ZLogInOp´ of bool
			| ZLogInOp¤ of bool
			| ZLogInOpSemi;
datatype ÛSCH_IN_OPÝ	= ÛPipeÝ | ÛFilterÝ | ÛCompÝ;
datatype ÛSCH_PRE_OPÝ	= ÛPreÝ | ÛDeltaÝ | ÛXiÝ;
datatype ÛZ_QUANTÝ	= ZQuantµ of bool
			| ZQuant¶ of bool
			| ZQuant¶‰1 of bool;
=DESCRIBE
These types are used by the Z parser and type inferrer to represent
various aspects of the Z syntax.
=ENDDOC
=DOC
datatype ÛSTUBÝ		= 	ÛStubUSÝ		(* _ *)
			|	ÛStubEllÝ		(* ... *)
			|	ÛStubUSQÝ		(* _? *)
			|	ÛStubUSEÝ		(* _! *);

type ÛCOREÝ		=	ID * ((STUB * ID) list * (STUB * ID)) OPT;

datatype ÛTEMPLATEÝ	=	ÛTmplNonÝ of	CORE
					(* id, {stub, id} *)
			|	ÛTmplInÝ of	(STUB * CORE * STUB)
					(* stub, id, {stub, id}, stub *)	
			|	ÛTmplPreÝ of	(CORE * STUB)
					(* id, {stub, id}, stub *)
			|	ÛTmplPostÝ of	(STUB * CORE)
=DESCRIBE
The type $TEMPLATE$ is used by the Z parser and type inferrer to represent
Z names
=ENDDOC
=DOC
datatype ÛPREDÝ	= ÛPredQuantifierÝ of Z_QUANT * DECL * (PRED OPT) * PRED
			| ÛPredLetÝ of EQ_DEF list * PRED
			| ÛPredLogInOpÝ of PRED * Z_LOG_IN_OP * PRED
			| ÛPredNotÝ of bool * PRED
			| ÛPredSchInOpÝ of PRED * SCH_IN_OP * PRED
			| ÛPredSchPreOpÝ of SCH_PRE_OP * PRED
			| ÛPredSchemaHidingÝ of PRED * (PRED list)
			| ÛPredMuÝ of DECL * (PRED OPT) * (PRED OPT)
			| ÛPredLambdaÝ of DECL * (PRED OPT) * (PRED OPT)
			| ÛPredFancyFixÝ of TEMPLATE * DECOR * ((PRED list) list)
			| ÛPredCrossProductÝ of PRED list
			| ÛPredPowÝ of PRED
			| ÛPredApplicationÝ of PRED * PRED
			| ÛPredThetaÝ of PRED
			| ÛPredSelectionÝ of PRED * PRED
			| ÛPredIdDecÝ of ID * DECOR
			| ÛPredQuotationÝ of TERM
			| ÛPredPlaceHolderÝ of STUB
			| ÛPredNumberÝ of INTEGER
			| ÛPredStringÝ of string
			| ÛPredFloatÝ of INTEGER * INTEGER * INTEGER
			| ÛPredTupleÝ of PRED list
			| ÛPredBindingÝ of EQ_DEF list
			| ÛPredSetDisplayÝ of PRED list
			| ÛPredSeqDisplayÝ of PRED list
			| ÛPredSetCompÝ of DECL * (PRED OPT) * (PRED OPT)
			| ÛPredHorizSchemaÝ of  DECL * (PRED OPT)
			| ÛPredGenInstÝ of PRED list
			| ÛPredRenameListÝ of (PRED * PRED) list
			| ÛPredBracketedÝ of PRED * DECOR
withtype ÛDECLÝ		= (PRED list * PRED OPT) list
and ÛEQ_DEFÝ		= PRED * PRED;

=DESCRIBE
These types is used by the Z parser and type inferrer to represent
various aspects of the Z syntax.
=ENDDOC
=DOC
type ÛFIXITYÝ		= CLASS * (TEMPLATE list);
type ÛGENERAL_TERMÝ	= PRED * (PRED OPT);
datatype ÛABB_DEFÝ	= ÛADEqDefÝ of EQ_DEF
			| ÛADSchemaBoxÝ of PRED * DECL * (PRED OPT);
type ÛFREE_TYPE_DEFÝ	= (PRED * (PRED list)) list;
type ÛAX_BOXÝ		= (PRED list) * DECL * (PRED OPT);
type ÛCONJECTUREÝ		= (ID OPT) * PRED	;
datatype ÛPARAGRAPHÝ	= ÛParFixityÝ of FIXITY
			| ÛParGeneralTermÝ of GENERAL_TERM
			| ÛParAbbDefÝ of ABB_DEF
			| ÛParFreeTypeDefÝ of FREE_TYPE_DEF
			| ÛParAxBoxÝ of AX_BOX
			| ÛParConjectureÝ of CONJECTURE;
=DESCRIBE
These types are used by the Z parser and type inferrer to represent
various aspects of the Z syntax.
=ENDDOC
=DOC
type ÛIDENTÝ		= TEMPLATE * DECOR;
datatype ÛZ_TMÝ	=	ÛZTm§¢Ý of Unification.EXTYPE OPT * Z_TM list
		|	ÛZTmSetdÝ of Unification.EXTYPE OPT * Z_TM list
		|	ÛZTmSeta1Ý of Z_SCH_TEXT
		|	ÛZTmSeta2Ý of Z_SCH_TEXT * Z_TM
		|	ÛZTmðÝ of Z_TM
		|	ÛZTmTupleÝ of Z_TM list
		|	ÛZTmBindingÝ of Z_EQ_DEF list
		|	ÛZTm¸Ý of Z_TM list
		|	ÛZTmÊÝ of Z_TM * DECOR
		|	ÛZTmSel‰BÝ of Z_TM * IDENT
		|	ÛZTmSel‰TÝ of Z_TM * int
		|	ÛZTmAppÝ of Z_TM * Z_TM
		|	ÛZTmFancyAppÝ of IDENT * Z_TM
		|	ÛZTmÌÝ of Z_SCH_TEXT * Z_TM
		|	ÛZTmÍ1Ý of Z_SCH_TEXT
		|	ÛZTmÍ2Ý of Z_SCH_TEXT * Z_TM
		|	ÛZTmTruthÝ of bool
		|	ÛZTm³‰FÝ of Z_TM
		|	ÛZTmLogInOpÝ‰F of Z_LOG_IN_OP * Z_TM * Z_TM
		|	ÛZTmSchemaPredÝ of Z_TM
		|	ÛZTmQuant‰FÝ of Z_QUANT * Z_SCH_TEXT * Z_TM
		|	ÛZTmHorizSchemaÝ of Z_SCH_TEXT
		|	ÛZTmDecorÝ of Z_TM * DECOR
		|	ÛZTmPreÝ of Z_TM
		|	ÛZTm³‰SÝ of Z_TM
		|	ÛZTmLogInOp‰SÝ of Z_LOG_IN_OP * Z_TM * Z_TM
		|	ÛZTmùÝ of Z_TM * Z_TM
		|	ÛZTmHideÝ of Z_TM * IDENT list
		|	ÛZTmQuant‰SÝ of Z_QUANT * Z_SCH_TEXT * Z_TM
		|	ÛZTm„Ý of Z_TM
		|	ÛZTm˜Ý of Z_TM
		|	ÛZTmEqÝ of Z_TM * Z_TM
		|	ÛZTmÝ of Z_TM * Z_TM
		|	ÛZTm»Ý of Z_TM * Z_TM
		|	ÛZTmPipeÝ of Z_TM * Z_TM
		|	ÛZTmúÝ of INTEGER
		|	ÛZTmStringÝ of string
		|	ÛZTmFloatÝ of INTEGER * INTEGER * INTEGER
		|	ÛZTmLVarÝ of IDENT * Unification.EXTYPE OPT * Z_TM list
		|	ÛZTmGVarÝ of IDENT * Unification.EXTYPE OPT * Z_TM list
		|	ÛZTmLetÝ of Z_EQ_DEF list * Z_TM
		|	ÛZTmRenameÝ of Z_TM * ((IDENT * IDENT) list) 
		|	ÛZTmBracketedÝ of Z_TM
		|	ÛZTmQuotationÝ of TERM * Unification.EXTYPE OPT
and ÛZ_DECÝ	=	ÛZDDecÝ of IDENT list * Z_TM * Unification.EXTYPE OPT
		|	ÛZDSchemaDecÝ of Z_TM * Unification.EXTYPE OPT
withtype ÛZ_SCH_TEXTÝ 	= Z_DEC list * Z_TM OPT * Unification.EXTYPE OPT
and ÛZ_EQ_DEFÝ 		= IDENT * Z_TM;
=DESCRIBE
These types are used by the Z parser and type inferrer to represent
various aspects of the Z syntax.
=ENDDOC
=DOC
datatype ÛZ_PARAÝ
	= ÛZParaFixityÝ of FIXITY
	| ÛZParaAbbDefÝ of IDENT * IDENT list * Z_TM * Unification.EXTYPE OPT
	| ÛZParaSchBoxÝ of IDENT * IDENT list * Z_SCH_TEXT * Unification.EXTYPE OPT
	| ÛZParaAxDesÝ of IDENT list * Z_SCH_TEXT * (((IDENT * Unification.EXTYPE) list) OPT)
	| ÛZParaFreeTypeÝ of (IDENT * (IDENT * Unification.EXTYPE OPT * Z_TM OPT) list) list
	| ÛZParaGivenSetÝ of IDENT list * ((IDENT list * Z_TM) OPT)
	| ÛZParaConstraintÝ of IDENT list * Z_TM
	| ÛZParaConjectureÝ of IDENT OPT * IDENT list * Z_TM
	| ÛZParaTermÝ of IDENT list * Z_TM * Unification.EXTYPE OPT;
=DESCRIBE
These types are used by the Z parser and type inferrer to represent
various aspects of the Z syntax.
=ENDDOC
} % end of \scriptsize
\subsection{Template Functions}
=DOC
val	Ûfirst_tmpl_idÝ : TEMPLATE -> ID
=DESCRIBE
Given a template this function returns the first identifier in it.
The result may then be used in a call of $get\_zfixity\_info$ to
access the relevant information from the corresponding fixity paragraph.
=ENDDOC
=DOC
val	Ûtmpl_idsÝ : TEMPLATE -> CLASS -> (ID * ZFIXITY) list
=DESCRIBE
Given a template this function returns
the corresponding list of name-$ZFIXITY$ pairs. The list is in
the same order as the ids in the template.
=ENDDOC
=DOC
val	Ûtmpl_stubsÝ : TEMPLATE -> STUB list
=DESCRIBE
Given a template this function returns
the corresponding list of stubs. The list is in in the
order of appearance in the template.
=ENDDOC
=DOC
val	Ûstring_of_templateÝ : TEMPLATE -> string
val	Ûtemplate_of_stringÝ : string -> TEMPLATE
=DESCRIBE
$string\_of\_template$ and $template\_of\_string$ are used to encode (resp. decode)
templates as strings.
=ENDDOC
=DOC
val	Ûstring_of_identÝ : IDENT -> string
=DESCRIBE
The function $string\_of\_ident$ makes a string from an identifier.
=ENDDOC
=DOC
val	Ûz_string_of_floatÝ : INTEGER * INTEGER * INTEGER -> string
=DESCRIBE
The function $z\_string\_of\_float$ converts three integers $(x, p, e)$ representing the real number $x\times10^{e-p}$ into a string denoting the corresponding floating point literal.
If $x < 0$ or $p < 1$, the string takes the form of an HOL quotation (since the Z parser will always produce floating point literals with $x \ge 0$ and $p \ge 1$).
=ENDDOC
\subsection{Fixity}
=DOC
val	Ûset_zfixity_infoÝ : CLASS * TEMPLATE list -> unit
=DESCRIBE
This is the interface for use by the Z paragraph processor when a fixity
paragraph is encountered. After checking that the fixity paragraph
obeys the syntactic rules, it enters a record of the fixity
paragraph in the current theory and updates the cache of fixity
information used by $get\_zfixity\_info$.

=FAILURE
79010	The template ?0 clashes with the template ?1 which is already in scope
79011	A Z fixity entry associated with the template ?0 is corrupt
79012	?0 in the template ?1 clashes with its use in the template ?2 which is
	already in scope
=ENDDOC
=DOC
val	Ûget_zfixity_infoÝ : ID -> (ZFIXITY * TEMPLATE list) OPT
=DESCRIBE
This is the interface for use by the parser and type inferrer when
the fixity information associated with a name is required.
The information is extracted from a cache which is updated
by the functions $set\_zfixity\_info$ and $delete\_zfixity\_info$
and also when the current theory changes or a new parent is added.
=ENDDOC
=DOC
val	Ûdelete_zfixity_infoÝ : CLASS * TEMPLATE -> unit
=DESCRIBE
This is the interface for use by the Z paragraph processor when the
effect of a fixity paragraph is to be deleted.
=FAILURE
79013	There is no fixity entry for ?1 ?0 in the current theory
=ENDDOC
=DOC
val	Ûget_zfixity_infosÝ : string -> (CLASS * TEMPLATE) list
=DESCRIBE
This is the interface for use by the theory lister to extract the fixity
information for a Z theory. The argument is the name of the theory.
=FAILURE
79014	There is no theory called ?0
=ENDDOC
\subsection{Flag for the Parser and Pretty-Printer}
=DOC
	(* Ûsubscript_z_schema_opsÝ  - boolean flag declared by new_flag, default: false *)
	val Ûsubscript_z_schema_opsÝ : unit -> bool
=DESCRIBE
{\ProductZ} supports a non-standard extension allowing schema operators that overload logical operators to be distinguished with a subscript ``s''.

The flag determines whether this feature is enforced or not: if the flag has its default value of false, schema operators may be given a subscript, but unsubscripted forms will be interpreted as schema operators according to the context, as in ISO Standard Z;
if the flag is true, the forms without a subscript will not be interpreted as schema operators.
The form with a subscript is only used in pretty-printing if the flag is true.

The function is used in the parser and pretty-printer to access the value of the flag.
=ENDDOC

\subsection{Formatting Functions}
=DOC
val Ûformat_classÝ : CLASS -> string;
val Ûformat_declÝ : DECL -> string;
val Ûformat_eq_defÝ : EQ_DEF -> string;
val Ûformat_fixityÝ : FIXITY -> string;
val Ûformat_identÝ : IDENT -> string;
val Ûformat_paragraphÝ : PARAGRAPH -> string;
val Ûformat_predÝ : PRED -> string;
val Ûformat_quantÝ : Z_QUANT -> string;
val Ûformat_templateÝ : TEMPLATE -> string;
val Ûformat_z_in_opÝ : Z_LOG_IN_OP -> string;
val Ûformat_z_decÝ : Z_DEC -> string;
val Ûformat_z_paraÝ : Z_PARA -> string;
val Ûformat_z_schtextÝ : Z_SCH_TEXT -> string;
val Ûformat_z_tmÝ : Z_TM -> string;
val Ûformat_z_typeÝ : TYPE -> string;
val Ûz_type_ofÝ : TERM -> string;
=DESCRIBE
These functions are used by the Z parser and type inferrer to format
fragments of the data types they use to represent Z syntax for inclusion
in diagnostic messages.

=ENDDOC
\section{EPILOGUE}
=SML
end (* of signature ZUserInterfaceSupport *);
=TEX
\section{TEST POLICY}
The tests should follow the standards and guidelines laid down in
\cite{DS/FMU/IED/PLN008}.
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}


