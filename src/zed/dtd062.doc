=TEX
% TQtemplatetex
\documentstyle[hol1,11pt,TQ]{article}
%
%	The following environment is used to
%	display information required to compose error
%	messages.
%
\newenvironment{designnote}{\paragraph{Design Note}\small\it\parindent 10pt
\bgroup}{\egroup}

\makeindex
% The following macro is used to insert temporary notes
% in the document.
\def\TempNote#1{{\tiny#1}}
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Type Inferrer}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD062}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}                    %% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{HOL, Z}
\TPPauthor{D.J.~King&WIN01}
%\TPPauthors{R.D.~Arthan&WIN01\\D.J.~King&WIN01\\G.T.~Scullard&MAN05}
\TPPauthorisation{R.D.~Arthan & FMU Manager}
\TPPabstract{This document is the detailed design for
a type inferrer for HOL/Z. It describes the type inference
rules, and defines the functions which apply the rules.}
\TPPdistribution{\parbox[t]{4.0in}{%
Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List} \tableofcontents
\subsection{Document Cross References}\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion (18 February 1992)] First Draft.
\end{description}
\subsection{Changes Forecast}
None Known.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This is the design for a type inferrer for HOL/Z as required by
\cite{DS/FMU/IED/HLD018}. It is produced in accordance with
the quality plan \cite{DS/FMU/IED/PLN008}. The
implementation of the type inferrer is in \cite{DS/FMU/IED/IMP062}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
The Z type inferrer comprises a selection of functions
which are intended to be called directly by the parser during
the process of parsing Z paragraphs and Z terms.

Each of the functions returns a data structure comprising
a type inferred term and its type,
or else error information. If a term fails to type check
correctly, the parser is responsible for reporting the error
to the user.
\subsubsection{Dependencies}
The type inferrer makes use of the unification algorithm
described in \cite{DS/FMU/IED/DTD014}.
\subsubsection{Interface}
The interface to the Z type inferrer is intended to be
used only by the Z parser.
\subsubsection{Algorithms}
The heuristics for determining error messages are described
in \ref{ErrorHandling}.
The unification algorithm \cite{DS/FMU/IED/DTD014} is used
in type inference.
\subsubsection{Possible Enhancements}
None Known.
\subsubsection{Deficiencies}
None.

\section{PREAMBLE}

The signature for Z type inference is dispersed through
this document. In the documentation box, only the
signature header is provided, and two error messages.
The first error message appears in the last line of
an type checking
error message. The second appears in the first line of
an error message.

Since the user is not intended to use
the functions provided in Z type inference directly, the
help information informs the user that this is the
case, and refers him to this document, which is intended
to fully explain the interface and purpose of each
function provided.

=DOC
signature ÛZTypeInferenceÝ = sig
=DESCRIBE
The type inference rules are for use by the Z parser only.
See document reference DS/FMU/IED/DTD062 for further information.
=FAILURE
62000	Type error
62001	Type error in ñ?0®
=ENDDOC

\section{DATA STRUCTURES FOR Z PARAGRAPHS AND TERMS}

The data structure for representing Z terms as a tree is
presented in this section. The form of the
data structure is determined largely by the grammar of
Z defined in \cite{DS/FMU/IED/DEF007}.

=SML
type ÛDECORÝ;
type ÛIDENTÝ;
type ÛZOPCLASSÝ;
type ÛZSCHTEXTÝ;
type ÛZEXPRÝ;
type ÛZDECÝ;
type ÛZTMÝ;
=TEX

\section{ERROR HANDLING}\label{ErrorHandling}

The error handling environment is a mechanism by which
the type inferrer can communicate to the parser details
of an incorrectly typed term. The type of the environment
is declared as follows:

=SML
type ÛZTI_ERRORÝ;
=TEX

The details of this environment depend upon more
detailed knowledge of the errors which can be generated. This
will become available when the implementation document has
been written.

\section{TYPE INFERENCE RULES}

The data structure which the type inferrer returns is
as follows:
=SML
datatype ÛZTI_RESULTÝ = ÛZInferredÝ of (ZEXPR * Unification.EXTYPE) OPT
		|	ÛZTypeErrorÝ of ZTI_ERROR;
=TEX

For a correctly typed term, the term is returned with its
extended type. For an incorrectly typed term, an
error environment is returned.

In sections \ref{SeqDisplay} to \ref{LastSection}, the
typing rules are defined. However, since
the type inferrer is only intended to be used by the parser,
and not by the user directly, documentation boxes are
not provided for each of the interfaces. They are
collected together and the signature for them
is provided at the end of the document.


\subsection{Sequence Display}\label{SeqDisplay}

=SMLLABELLED Signature
val Ûzti_seqÝ : ZEXPR -> ZTI_RESULT
=TEX

=FRULE 1 Rule
unifiable[ty1, ..., tyk]
÷
E ô t1::ty1; ...; E ô tk::tyk
÷
E ô §t1, ..., tk¢ :: ð(ú¸ ty1)
=TEX

=FRULE 1 Rule
÷
÷
E ô §¢ :: ð(ú ¸ ?new)
=TEX

=DESCRIBE
The rule for type inferring  types in a non-empty
list is as follows:

First, the types $ty1 \ldots tyk$, of the sub-terms
are inferred
(using the same environment $E$ for each one).
The types are then unified (using $list\_unify$),
and the HOL type corresponding to the Z type $ð(ú¸ ty1)$
is computed.

The result is the term constructed from the
type checked sub-terms and the type we have just computed.
The substitution arising from the unification is modified
as a side effect.

The case of an empty list display is described by the second rule. 
To type check an empty list 
a new type unknown is invented. The result
is that type,
with an empty list display. The
substitution is unchanged by this rule.

The elements of the sequence which have already had their
types inferred are required, together with the element
(and its type) which caused a unification error.

\paragraph{Error Messages}~
=EXAMPLE
ñ§1,2,(3,4),5¢®;
Type error in ñ§1,2,(3,4),5¢®
Each element in a sequence must have the same type
Type ñú® inferred for the following elements:
   ñ1®
   ñ2® 
   ñ5®
Type ñú¸ú® inferred for the following element:
   ñ(3,4)®
=TEX
\paragraph{Error Codes}~
=FAILURE
62011	Each element in a sequence must have the same type

62012	Type ñ?0® inferred for the following element?1:
6201	   ñ?0®
=TEX

\subsection{Set Display}
=SMLLABELLED Signature
val Ûzti_setdÝ : ZEXPR -> ZTI_RESULT
=TEX
=FRULE 1 Rule
unifiable[ty1, ..., tyk]
÷
E ô t1 :: ty1; ...; E ô tk :: tyk
÷
E ô {t1, ..., tk} :: ð ty1
=TEX

=FRULE 1 Rule
÷
÷
E ô {} :: ð ?new
=TEX

=DESCRIBE
The elements of the set neet to be available individually
for individual inspection to identify which error message
should be used.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ{1,2,(3,4),5}®;
Type error in ñ{1,2,(3,4),5}®
Each element in a set display must have the same type
Type ñú® inferred for the following elements:
   ñ1®
   ñ2® 
   ñ5®
Type ñú¸ú® inferred for the following element:
   ñ(3,4)®
=TEX
\paragraph{Error Codes}~
=FAILURE
62021	Each element in a set display must have the same type
=TEX

\subsection{Set Abstraction}
=SMLLABELLED Signature
val Ûzti_seta1Ý : ZSCHTEXT -> ZTI_RESULT
val Ûzti_seta2Ý : (ZSCHTEXT * ZEXPR) -> ZTI_RESULT
=TEX

=FRULE 1 Rule
÷
E « env(D|P) ô chartuple(D|P) :: ty
÷
E ô {D|P} :: ð ty
=TEX

=FRULE 1 Rule
÷
E « env(D|P) ô t :: ty
÷
E ô {D|P·t} :: ð ty
=TEX
=DESCRIBE
We write $chartuple(D|P)$  for the characteristic tuple,
and $env(D|P)$ for the environment,
which arise from the type checked schema text $D|P$.

\paragraph{Error Messages}~
None.

\subsection{Powerset}
=SMLLABELLED Signature
val Ûzti_powerÝ : ZEXPR -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t1 :: (ty1)ð
÷
E ô ð t1 :: ((ty1)ð)ð
=TEX
=DESCRIBE
\paragraph{Error Messages}~
None.

\subsection{Tuple Display}
=SMLLABELLED Signature
val Ûzti_tupleÝ : ZEXPR list -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t1 :: ty1; ...; E ô tk :: tyk
÷
E ô (t1, ..., tk) :: ty1 ¸ ... ¸ tyk
=TEX
=DESCRIBE
An empty or one element tuple display indicates a
design error in the parser.
\paragraph{Error Messages}~
None.

\subsection{Product}
=SMLLABELLED Signature
val Ûzti_prodÝ : ZEXPR list -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t1 :: ð ty1; ...; E ô tk :: ð tyk
÷
E ô t1 ¸ ... ¸ tk :: ð(ty1 ¸ ... ¸ tyk)
=TEX
=DESCRIBE
\paragraph{Error Messages}~
None.

\subsection{Theta}
=SMLLABELLED Signature
val Ûzti_thetaÝ : (ZEXPR * DECOR) -> ZTI_RESULT
=TEX

=FRULE 1 Rule
÷
E ô t1 :: ð ty
÷
E ô Êt1 :: ty
=TEX

=DESCRIBE
The operand of a $Ê$-term must be a schema
type. Although we could try to continue if the type
is not known, we signal an error for uniformity with
other schema operators.

% ÁÂÇÄÅÚÈÊÉËÌÍÎØoÐÒÓÔÕÆÑÙ×
% AB‡„EZHŠIKŒMN˜OR“T•†™—

\paragraph{Error Messages}~
=EXAMPLE
ñÊ 1®;
Type error in ñÊ 1®
The operand of a Ê-term must be a schema
The type inferred was:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
62071	The operand of a Ê-term must be a schema
62072	The type inferred was:
62073	   ñ?0:?1®
=TEX

\subsection{Selection}
=SMLLABELLED Signature
val Ûzti_selÝ : (ZEXPR * IDENT) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t :: [ ..., f í ty, ..., ]
÷
E ô t.f :: ty
=TEX
=DESCRIBE
That is to say, the type inferred for $t$ must be a
manifest binding type with a field of the
appropriate name.
\paragraph{Error Messages}~
The examples that follow
require the following two definitions.

¹IZ
X ¦ [a, b : ú | a < b ]
°
¹IZ
Y == seq ú
°
=EXAMPLE
ñY.a®;
Type error in ñY.a®
The selector must be preceded by a schema
The type inferred was:
   ñY:seq ú® 

ñX.c®;
Type error in ñX.c®
The selected component must be present in the schema
The types inferred were:
   ñX:[a, b : ú | a < b ]®
   ñc:'a®
=TEX
\paragraph{Error Codes}~
=FAILURE
62081	The selector must be preceded by a schema
62082	The selected component must be present in the schema
=TEX

\subsection{Application}
=SMLLABELLED Signature
val Ûzti_appÝ : (ZEXPR * ZEXPR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
unifiable(ty1, ð(ty2¸?new))
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1 t2 :: ?new
=TEX

=FRULE 1 Rule
unifiable(ty1, ty2)
÷
E ô t1 :: ð ty1; E ô t2 :: ty2
÷
E ô t1 t2 :: bool
=TEX

=DESCRIBE
There are two rules for this construct. The first one
corresponds to ordinary application and is attempted first.

\TempNote{We need a note here about binary relations and unary functions being indistinguishable sometimes.}
\TempNote{%
Dave: don't forget to do the $apply\_SUBS$ in this
rule and in any other cases where the result
type has been involved in
unification. Otherwise you don't pass enough
information back up. Cf. $ti\_comb$ in the HOL type inferrer.}

If the unification for the first rule fails, then the
application may be the application of a predicate to
its argument (the second rule).

If the above cases fail, the application may be a generic constant applied to its generic actuals.
In this case, we wish to return just the function part (which should be a Ztvar with no generic actuals), with its generic actuals filled in from the type inferred argument.

\paragraph{Error Messages}~
=EXAMPLE
ñ1 1®;
Type error in ñ1 1®;
The operator must have type Ó ­ Ô
Cannot apply ñ1:ú®
          to ñ1:ú®
=TEX
=EXAMPLE
ñ head 1 ®;
Type error in ñ head 1 ®
The operator and the operand have incompatible types
Cannot apply ñhead:seq‰1 X ­ X®
          to ¬1:ú®
=TEX
=EXAMPLE
ñ1={1}®;
Type error in ñ1={1}®
The operands of ñ=® must have the same type
The types infered were:
   ñhead:seq‰1 X ­ X®
   ¬1:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62091	The operator must have type Ó ­ Ô
62092	The operator and the operand have incompatible types
62092	The operands of ñ$=® must have the same type
62095	Cannot apply ñ?0:?1®
62096	          to ñ?0:?1®
=TEX

\subsection{Ì-abstraction}
=SMLLABELLED Signature
val Ûzti_lamÝ : (ZSCHTEXT * ZEXPR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E « env(D|P) ô chartuple(D|P) :: ty1; E « env(D|P) ô t :: ty2;
÷
E ô ÌD|P·t :: ð(ty1¸ty2)
=DESCRIBE
\paragraph{Error Messages}~
None.
\subsection{Definite Description}
=SMLLABELLED Signature
val Ûzti_mu1Ý : ZSCHTEXT -> ZTI_RESULT
val Ûzti_mu2Ý : (ZSCHTEXT * ZEXPR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E « env(D|P) ô chartuple(D|P) :: ty;
÷
E ô ÍD|P :: ty
=TEX

=FRULE 1 Rule
÷
E « env(D|P) ô t :: ty;
÷
E ô ÍD|P·t :: ty
=TEX
=DESCRIBE

\subsection{Schema Text as a Term}
=SMLLABELLED Signature
val Ûzti_schemaÝ : ZSCHTEXT -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E  ô x1 :: ty1; ... E  ô xk :: tyk
÷
E ô [D|P] :: ð [ x1 í ty1, ..., xk í tyk ]
=TEX
=DESCRIBE
(where the $x_i$ are the variables declared by the
schema as computed by $ti\_ZSCHTEXT$. The types are
obtained from the environment returned by $ti\_ZSCHTEXT$.)

\subsection{Decoration}
=SMLLABELLED Signature
val Ûzti_decÝ : (ZEXPR * DECOR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t :: ð [ x1 í ty1, ..., xk í tyk ]
÷
E ô t' :: ð [ x1' í ty1, ..., xk' í tyk ]
=TEX
=DESCRIBE
Thus the term operand must be a manifest schema type and
the result is the decorated schema type.

\subsection{Precondition}
=SMLLABELLED Signature
val Ûzti_preÝ : ZEXPR -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t :: ð [ x1 í ty1, ..., xk í tyk ]
÷
E ô pre t :: ð [ xi1 í ty1, ..., xim í tyk ]
=TEX
=DESCRIBE
Here the ${i_j}$ are the indices of the non-result
variables.
Note the term operand must be a manifest schema type.
=TEX

\subsection{Negation}
=SMLLABELLED Signature
val Ûzti_negÝ : ZEXPR -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t :: ty
÷
E ô ³ t :: ty
=TEX
=DESCRIBE

\subsection{Propositional Calculus}
=SMLLABELLED Signature
val Ûzti_unknownÝ : (ZEXPR * ZEXPR) -> ZTI_RESULT
=FRULE 1 Rule
compatible(bty1, bty2)
÷
E ô t1 :: ð bty1
E ô t2 :: ð bty2
÷
E ô t1 dy t2 :: ð(bty1 « bty2)
=TEX
=FRULE 1 Rule
÷
E ô t1 :: bool
E ô t2 :: bool
÷
E ô t1 dy t2 :: bool
=TEX

=FRULE 1 Rule
÷
E ô t1 :: ð [ x1 í ty1, ..., xk í tyk ]
E ô t2 :: bool
÷
E ô t1 dy t2 :: bool
=TEX
=FRULE 1 Rule
÷
E ô t1 :: bool
E ô t2 :: ð [ x1 í ty1, ..., xk í tyk ]
÷
E ô t1 dy t2 :: bool
=TEX
=DESCRIBE
The rules for conjunction, disjunction, bi-equivalence
and implication are the same.
$dy$ is one of `±', `²', `¤' or `´', and
$compatible$ is supposed to represent a test that
its two operands are compatible binding types.

To implement these rules we first type infer the operands.
If they both have manifest schema types we can perform
the compatibility test (unifying types of common components
as we go) and things are straightforward.
If they both have manifest boolean types all is well.
If one type is a manifest schema type and the other
is a manifest boolean type we enclose the schema operand
in a schema-as-term construct ($Ztschema$) if it is not
already enclosed in one (because in this case it must
really be a schema-as-predicate).
If the types do not fit any of these cases we flag an error.
=TEX

\subsection{Projection}
=SMLLABELLED Signature
val Ûzti_proÝ : (ZEXPR * ZEXPR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
compatible(bty1, bty2)
÷
E ô t1 :: ð bty1; E ô t2 :: ð bty2
÷
E ô t1 ù t2 :: ð bty2
=TEX
=DESCRIBE
We insist that the types of the sub-terms be manifest
schema types.
=TEX

\subsection{Hiding}
=SMLLABELLED Signature
val Ûzti_hideÝ : (ZEXPR * IDENT list) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t :: ð [ x1 í ty1, ..., xk í tyk ]
÷
E ô t1 \ (y1, ..., yk) :: ð [ xi1 í ty1, ..., xim í tyk ]
=TEX
=DESCRIBE
We insist that the type of the sub-term be a manifest
schema type. The $i_j$ are the indices for those $x_{i_j}$
which are not in $\{y1, \ldots, yk\}$.

\subsection{Quantification}
=SMLLABELLED Signature
val Ûzti_uniÝ : (ZSCHTEXT * ZEXPR) -> ZTI_RESULT
val Ûzti_unexiÝ : (ZSCHTEXT * ZEXPR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
includes(bty2, bty1)
÷
E ô [D|P] :: ð bty1
E ô t :: ð bty2
÷
E ô Q D|P·t :: ð (bty2 \ bty1)
=TEX
=FRULE 1 Rule
÷
E ô [D|P] :: ð  [ x1 í ty1, ..., xk í tyk ]
E « env(D|P) ô t :: bool
÷
E ô Q D|P·t :: bool
=TEX
=DESCRIBE
We have two rules here corresponding to schema quantification
and to predicate quantification.
Here $Q$ is one of `$µ$', `$¶$' or `$¶‰1$'. $includes$ is intended
to be a function which checks that one manifest binding type includes
all the components of another unifying component
types as it goes.
=TEX

\subsection{„ and ˜}
=SMLLABELLED Signature
val Ûzti_delÝ : ZEXPR -> ZTI_RESULT
val Ûzti_xiÝ : ZEXPR -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
E ô t :: ð [ x1 í ty1, ..., xk í tyk ]
÷
E ô G t :: ð [ x1 í ty1, ..., xk í tyk, x1' í ty1, ..., xk' í tyk ]
=TEX
=DESCRIBE
Here $G$ is one of $„$ or $˜$.
The operand type must be a manifest schema type.
\subsection{Schema Composition}
The type rule for these monsters is discussed in
\cite{DS/FMU/IED/ZED002}. Clearly both terms must
have manifest schema types.

The embedded function $f$ checks that the primed components of the first schema and the unprimed ones of the second correspond and are unifiable.  It returns a list of these components and the substitution resulting from the unifications. 
=TEX

\subsection{Predicates}
=SMLLABELLED Signature
val Ûzti_eqÝ : (ZEXPR * ZEXPR) -> ZTI_RESULT
val Ûzti_memÝ : (ZEXPR * ZEXPR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
÷
÷
E ô true :: bool
=TEX
=FRULE 1 Rule
÷
÷
E ô false :: bool
=TEX
=FRULE 1 Rule
unifiable(ty1, ty2)
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1 = t2 :: bool
=TEX
=FRULE 1 Rule
unifiable(ð ty1, ty2)
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1  t2 :: bool
=TEX
=DESCRIBE

\subsection{Type Constraints}\label{LastSection}
=SMLLABELLED Signature
val Ûzti_constrainedÝ : (ZEXPR * ZEXPR) -> ZTI_RESULT
=TEX
=FRULE 1 Rule
unifiable(ð ty1, ty2)
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1 º t2 :: ty1
=TEX
=FRULE 1 Rule
÷
E ô t1 :: ty1; E ô t2 :: ð bool
÷
E ô t1 º t2 :: bool
=TEX
=DESCRIBE
There are two cases, where the user may wish to impose a type constraint.
The first and most obvious is when the term must belong to some set (the term on the right of the º):
Moreover when the term returned when a typed term is encountered
should comprise the left hand operand.

The second case is where a schema text is being used as a predicate.
The type checker might be able to deduce this in some cases, but in others it is necessary to constrain the term to $bool$.

=TEX
\section{EPILOGUE}
=SML
end (* of signature *);
=TEX

\pagebreak

\twocolumn[\section{INDEX}]
{	\footnotesize
	\printindex
}
\onecolumn

\end{document}

=IGN
val Ûzti_seqÝ : ZEXPR -> ZTI_RESULT
