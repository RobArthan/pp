=TEX
% TQtemplatetex
\documentstyle[hol1,11pt,TQ]{article}
%
%	The following environment is used to
%	display information required to compose error
%	messages.
%
\newenvironment{designnote}{\paragraph{Design Note}\small\it\parindent 10pt
\bgroup}{\egroup}

\makeindex
% The following macro is used to insert temporary notes
% in the document.
\def\TempNote#1{{\tiny#1}}
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Type Inferrer}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD062}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}                    %% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{HOL, Z}
\TPPauthor{D.J.~King&WIN01}
%\TPPauthors{R.D.~Arthan&WIN01\\D.J.~King&WIN01\\G.T.~Scullard&MAN05}
\TPPauthorisation{R.D.~Arthan & FMU Manager}
\TPPabstract{This document is the detailed design for
a type inferrer for HOL/Z. It describes the type inference
rules, and defines the data structure to
which the rules apply.}
\TPPdistribution{\parbox[t]{4.0in}{%
Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List} \tableofcontents
\subsection{Document Cross References}\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion (27 February 1992)] First Draft.
\end{description}
\subsection{Changes Forecast}
None Known.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This is the detailed design for a type inferrer for HOL/Z,
responding to the high level design for the Z user
interface \cite{DS/FMU/IED/HLD018}.
The implementation of this design is contained in
\cite{DS/FMU/IED/IMP062}.

\subsection{Introduction}

This document is organised as follows. The signature
declaration for the Z type inference module is introduced
at the end of the document.

In section \ref{InfRules}, the inference rules
are introduced and each is desribed in a fixed format:
\begin{description}
\item[Value Constructor]
The name and type of the value constructor describes the part of the
abstract syntax to which 
the inference rule applies.
\item[Inference Rule(s)]
The type inference rules for each construct are expressed
in conventional notation.
\item[Description]
A description of the rules is provided, and any
issues relating to implementation are documented.
\item[Error Messages]
Example error messages which might be generated if application
of a particular rule fails, are shown as guidance to the
implementor.
\item[Error Codes]
The error codes, which correspond to parameterized
fragments of example error messages, are provided (They
are located deliberately in close proximity to their
respective examples to increase maintainability). This
subsection comprises another part of the
Standard ML literal script.
\end{description}

\subsubsection{Purpose and Background}

The type inferrer's job is to ensure that each of
these rules are obeyed in the process
of type checking a Z specification comprising
Z paragraphs interspersed with Z text.
A Correctly typed Z paragraph results
in either an indication of success (in {\bf Type Check
Only Mode}), or a helpful error message, returned
to the caller with the intention of the caller
reporting the error to the user.

\subsubsection{Dependencies}
The signature for the Z type inferrer requires
the signature for unification
described in \cite{DS/FMU/IED/DTD014}.

\subsubsection{Interface}
The interface to the Z type inferrer is intended to be
called only by the Z paragraph handling
routines, and is defined in the
signature $ZTypeInference$ introduced in section \ref{Signature}. 

\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None.

\section{DESIGN ISSUES}

\subsection{Interfaces Provided}

A function is required which takes a Z paragraph, type
checks the paragraph and returns error information
if type checking error was detected, or a type-checked
Z paragraph together with a substitution function, mapping
type unknowns to actual extended types. The substitution
function is intended for use by the term generator.

There is an additional requirement for type checking
a limited variety of Z paragraphs connected by the ``\&''
symbol. This necessitates that the environment containing
the types of variables inferred be available to
the inferrer when checking the next paragraph.

\subsection{Error Handling}\label{ErrorHandling}

A key aspect of the success of the type inferrer is
the quality of error messages which are generated.
The type inferrer reports helpful messages which
are specific to the particular of inference rule which failed.
Error messages inserts are fragments of Z which should ideally
be easily understandable by the user.
It is the case that there are a variety of Z constructs
whose Z type written down, is very large. An approach to
this problem is to enable the type inferrer to look at
the type specified in the signatures of the component part
or parts of the term, and use this type in presenting
diagnostic fragments of Z.

When application of a typing rule fails, then
error information is returned. The details of this
information depend upon the particular inference rule.
A data type representing this information is
provided. This type is equated (in the implementation)
with an actual data structure which is private to the
implementation of the type inferrer.

\subsubsection{Format of Error Messages}

It is desirable that type checking error messages
are consistent regarding style and format. Therefore all
error messages generated comprise the following components:

\begin{enumerate}
\item
the term being constructed when the error was detected
\item
a summary of the inference rule which was being applied
\item
the types of the manipulana which were being used in applying
the rule
\end{enumerate}

See section ({\bf Error Messages} of \ref{FirstRule}) for
an example of an error message following this format.

\subsection{Standard Versus Extended Z}

Facilities for checking a specification against the
standard Z language \cite{DS/FMU/IED/DEF007} and
against extended Z are required.

The formal contents of a Z specification is
divided into two distinct categories for type
checking purposes.

Firstly, there is the Z which describes the specification
using Z paragraphs. The user is most likely to want to
check this against the standard Z language.

Secondly, there are fragments of Z which constitute
terms for use in proof scripts (e.g., goals, specializations), which are enclosed between the symbols `ñ' and `®'.
It is less likely that the user will want to check
this against the standard Z language, but will want
to check it against extended Z.

\section{ERROR MESSAGES}

=FAILURE
62000	Type error
62001	Type error in ñ?0®
62002	Type error in Z paragraph
62900	   ñ?0:?1®
62901	   ñ?0®
62902	Type ñ?0® inferred for the following element?1:
62903	The following type was inferred:
62904	The following types were inferred:
62910	The following sub-term is not a set
62911	The following sub-term is not a sequence
62912	The following sub-term is not a predicate
62913	The following sub-term is not a schema
62914	The following sub-term is not a binding
62915	The following sub-term is not a tuple
62916	The following identifier appears more than once
62917	The following identifiers appear more than once
62920	Encountered schemas which are incompatible
62921	The incompatibilities are as follows:
62922	In ñ?0®,
62923	Attempt to quantify over components not present in the schema
62924	In the declaration,
62925	In the current scope,
62950	The argument must have length greater than zero
62951	Unexpected stub or end of string found
62952	Unexpected trailing characters found
62953	Strange value returned from dest_z_name
62954	Type is not a binding type
62955	Type is not a tuple
62980	Free variables are not permitted in Standard Z specifications
62981	The following variable is free:
=TEX

\section{INFERRING TYPES IN Z DECLARATIONS}

The algorithm for type inferring Z declarations is as follows:

1. Type infer all the schemas as declarations using the input environment. This
gives the names and types of each component in all the schemas.

2. Grow the environment with all these components together with all the
declarative instances on the left hand side of normal declarations, noting
any incompatibilities that arise.

3. Type infer the right hand side of each of the normal declarations using
the extended environment.


The following inference rule applies to typed declarations.
=FRULE 1 Rule
÷
E « {x‰1 í ?1, ..., x‰n í ?n} ô Ó :: ð Ó
÷
E ô x‰1, ..., x‰n : ð Ó
=TEX
=DESCRIBE
The type on the right hand side of the declaration must be a set of something,
$ð Ó$. The type of the $Ó$ is
type-inferred in an environment in which the declarative instances on the left hand side
are in scope. This ensures conformance with the Z mapping described in
\cite{DS/FMU/IED/ZED002} and \cite{DS/FMU/IED/ZED003}.



The following rule applies to schemes as declarations.

=FRULE 1 Rule
÷
÷
E ô S : ð [x1; ... ; xn]
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ([x : 1])®;
Type error in ñ([x : 1])®
In a declaration of the form ña : X®, ñX® must be a set
=TEX
=EXAMPLE
ñ([A])®;
Type error in ñ([A])®
In a declaration of the form ñX®, ñX® must be a schema
=TEX

\paragraph{Error Codes}~

=FAILURE
62501	In a declaration of the form ña : X®, ñX® must be a set
62503	In a declaration of the form ñX®, ñX® must be a schema
62504	In a schema as a predicate ñS®, the components of S must be
62505	   compatible with the corresponding variables in scope
62506	In a declaration of a variable ñx®, all occurrences of ñx®
62507	   must be compatible
=TEX

\section{INFERRING TYPES IN Z SCHEMAS}\label{tischematext}

=FAILURE
62502	In a schema of the form ñ[D | P]®, P must be a predicate
=TEX


\section{INFERRING TYPES IN Z TERMS}\label{InfRules}

In sections \ref{FirstRule} to \ref{LastRule}, the
typing rules are defined.



\subsection{Sequence Display}\label{FirstRule}


=GFTSHOW Value Constructor
ZTm§¢ of EXTYPE OPT * Z_TM list
=TEX

=FRULE 1 Rule
unifiable[Ó‰1, ..., Ó‰n]
÷
E ô x‰1::Ó‰1; ...; E ô x‰n::Ó‰n
÷
E ô §x‰1, ..., x‰n¢ :: ð(ú ¸ Ó‰1)
=TEX

=FRULE 1 Rule
÷
÷
E ô §¢ :: ð(ú ¸ Ó‰?)
=TEX

=DESCRIBE
The rule for type inferring  types in a non-empty
list is as follows:

First, the types $ty1 \ldots tyk$, of the sub-terms
are inferred
(using the same environment $E$ for each one).
The types are then unified,
and the HOL type corresponding to the Z type $ð(ú¸ ty1)$
is computed.

The result is the term constructed from the
type checked sub-terms and the type we have just computed.
The substitution arising from the unification is modified
as a side effect.

The case of an empty list display is described by the second rule. 
To type check an empty list 
a new type unknown is invented. The result
is that type,
with an empty list display. The
substitution is unchanged by this rule.

\paragraph{Error Messages}~
=EXAMPLE
ñ§1,2,(3,4),5¢®;
Type error in ñ§1,2,(3,4),5¢®
Each element in a sequence must have the same type
Type ñú® inferred for the following elements:
   ñ1®
   ñ2® 
   ñ5®
Type ñú¸ú® inferred for the following element:
   ñ(3,4)®
=TEX
\paragraph{Error Codes}~

=FAILURE
62011	Each element in a sequence must have the same type
=TEX



\subsection{Set Display}

=GFTSHOW Value Constructor
|ZTmSetd of EXTYPE OPT * Z_TM list
=TEX
=FRULE 1 Rule
unifiable[Ó‰1, ..., Ó‰n]
÷
E ô x1 :: Ó‰1; ...; E ô x‰n :: Ó‰n
÷
E ô {x‰1, ..., x‰n} :: ð Ó‰1
=TEX

=FRULE 1 Rule
÷
÷
E ô {} :: ð Ó‰?
=TEX

=DESCRIBE
The types of each element in a set display must be
unifyable to some type, $ty$. The type of a set display is then
$ð ty$. If it is found that the elements are not unifiable, then
the error information produced lists each of the types
inferred, and the elements in the set corresponding to those
types. The elements are listed in lexicographic order.
This is the same as to be found in error reporting
for sequence display.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ{1,2,(3,4),5}®;
Type error in ñ{1,2,(3,4),5}®
Each element in a set must have the same type
Type ñú® inferred for the following elements:
   ñ1®
   ñ2® 
   ñ5®
Type ñú¸ú® inferred for the following element:
   ñ(3,4)®
=TEX
\paragraph{Error Codes}~
=FAILURE
62021	Each element in a set display must have the same type
=TEX



\subsection{Set Abstraction}

=GFTSHOW Value Constructor
|ZTmSeta1 of Z_SCH_TEXT
|ZTmSeta2 of Z_SCH_TEXT * Z_TM
=TEX

=FRULE 1 Rule
÷
E « env(D | P) ô chartuple(D | P) :: Ó
÷
E ô {D | P} :: ð Ó
=TEX

=FRULE 1 Rule
÷
E « env(D | P) ô x :: Ó
÷
E ô {D | P · x} :: ð Ó
=TEX
=DESCRIBE
We write $chartuple(D | P)$  for the characteristic tuple,
and $env(D | P)$ for the environment,
which arise from the type checked schema text $D | P$.

In a set abstration of the form ${D | P}$, the type of the
abstraction is the characteristic tuple of the schema text,
$D | P$.

In an abstration of the form ${D | P · x}$, the type of the
abstration is the type of $x$, inferred in an environment where the
declarations in $D$ are in scope.


\paragraph{Error Messages}~
=EXAMPLE
ñ{x | 0}®;
Type error in ñ{x | 0}®
In a term of the form  ñ{D | P}®, P must be a predicate
The following sub-term is not a predicate:
   ñ0:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62031	In a term of the form  ñ{D | P}®, P must be a predicate
62032	In a term of the form  ñ{D | P · S}®, P must be a predicate
=TEX



\subsection{Powerset}

=GFTSHOW Value Constructor
|ZTmð of Z_TM
=TEX
=FRULE 1 Rule
÷
E ô x :: ð Ó
÷
E ô ð x :: ð ð Ó
=TEX
=DESCRIBE
The type of a powerset of some $x$ is the powerset of the powerset of
the type of $x$.

\paragraph{Error Messages}~
=EXAMPLE
ñð 1®;
Type error in ñð 1®
In a term of the form ñð X®, X must be a set
The following sub-term is not a set:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62041	In a term of the form ñð X®, X must be a set
=TEX



\subsection{Tuple Display}

=GFTSHOW Value Constructor
|ZTmTuple of Z_TM list
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: Ó‰1; ...; E ô x‰n :: Ó‰n
÷
E ô (x‰1, ..., x‰n) :: Ó‰1 ¸ ... ¸ Ó‰n
=TEX
=DESCRIBE
The type of a tuple is
a product type where each type corresponds to the
type of each element in the tuple.

\paragraph{Error Messages}~
There are no error conditions associated with this construct.



\subsection{Product}

=GFTSHOW Value Constructor
|ZTm¸ of Z_TM list
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: ð Ó‰1; ...; E ô x‰n :: ð Ó‰n
÷
E ô x‰1 ¸ ... ¸ x‰n :: ð(Ó‰1 ¸ ... ¸ Ó‰n)
=TEX
=DESCRIBE
Each type in the product type must be a set. The type of
the product type is its powerset.
Those elements in the product type which are not sets
are reported in the error message.

\paragraph{Error Messages}~
=EXAMPLE
ñú¸1®;
Type error in ñú¸1®
In ñS‰1 ¸ ... ¸ S‰n®, S‰1 to S‰n must be sets
Type ñú® inferred for the following elements:
   ñ1®
=TEX
\paragraph{Error Codes}~
=FAILURE
62061	In ñS‰1 ¸ ... ¸ S‰n®, S‰1 to S‰n must be sets
=TEX



\subsection{Theta}

=GFTSHOW Value Constructor
|ZTmÊ of Z_TM * DECOR
=TEX

=FRULE 1 Rule
÷
E ô x :: [x‰1 : Ó‰1; ...; x‰n : Ó‰n]
÷
E ô Ê x :: binding [x‰1 : Ó‰1; ...; x‰n : Ó‰n]
=TEX

=DESCRIBE
The argument of a theta expression must be a schema (i.e., a set
of bindings), and the
resultant type of the expression is a binding from one of the set
denoted by the schema. 

\paragraph{Error Messages}~
=EXAMPLE
ñÊ 1®;
Type error in ñÊ 1®
In a term of the form ñÊ S®, S must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62071	In a term of the form ñÊ S®, S must be a schema
=TEX


\subsection{Tuple Selection}

=GFTSHOW Value Constructor
|ZTmSel‰T of Z_TM * int
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: Ó‰1; ...; E ô x‰n :: Ó‰n
÷
E ô (x‰1, ..., x‰n).i :: Ó‰i
=TEX
=DESCRIBE
In a tuple selection where the $i'th$ element of the
tuple is selected, then the type of the tuple selection
is the type of the $i'th$ element in the tuple (where the
first element is numbered $1$.
The operand must be a tuple.
If an out-of-range element is selected, then an
error is reported.

=EXAMPLE
ñ(20,30,40).4®
Type error in ñ(20,30,40).4®
In ñ(x‰1, ..., x‰n).i®, ñi® must be in the range ñ1 .. n®
The selector ñ4® is not in the range ñ1 .. 3®

ñ(Ê [x : X]).1®;
Type error in ñ(Ê [x : X]).1®
In a term of the form ñT.number®, T must be a tuple
The following sub-term is not a tuple:
   ñ(Ê [x : X])®
=TEX

\paragraph{Error Codes}~
=FAILURE
62086	In ñ(x‰1, ..., x‰n).i®, ñi® must be in the range ñ1 .. n®
62087	The selector ñ?0® is not in the range ñ1 .. ?0®
62088	In a term of the form ñT.number®, T must be a tuple
=TEX



\subsection{Binding Selection}

=GFTSHOW Value Constructor
|ZTmSel‰B of Z_TM * IDENT
=TEX
=FRULE 1 Rule
÷
E ô t ::  binding [x‰1 : Ó‰1; ...; x‰n : Ó‰n ]
÷
E ô t.x‰i :: Ó‰i
=TEX
=DESCRIBE
In a binding selection, the type of the first component
must be a binding type (which incidentally can only be formed using
a theta expression). The selector must be a component
in the binding.
The resultant type is that of the type of the selected
component.

\paragraph{Error Messages}~

=EXAMPLE
ñ(Ê [x : X]).c®;
Type error in ñ(Ê S).c®
The selected component must be present in the binding
    The component ñc®
is not present in ñ(Ê S)®
=TEX
=EXAMPLE
ñ1.c®;
Type error in ñ1.c®
In a term of the form ñB.c®, B must be a binding
The following sub-term is not a binding:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62081	The selected component must be present in the binding
62082	    The component ñ?0®
62083	is not present in ñ?0®
62084	In a term of the form ñB.c®, B must be a binding
=TEX


\subsection{Application}

=GFTSHOW Value Constructor
|ZTmApp of Z_TM * Z_TM
|ZTmFancyApp of IDENT * Z_TM
=TEX

=FRULE 1 Rule
unifiable(Ó‰1, ð(Ó‰2 ¸ Ó‰?))
÷
E ô x‰1 :: Ó‰1; E ô x‰2 :: Ó‰2
÷
E ô x‰1 x‰2 :: Ó‰?
=TEX

=FRULE 1 Rule
÷
E ô x‰1 :: ð Ó; E ô x‰2 :: Ó
÷
E ô x‰1 x‰2 :: bool
=TEX

=DESCRIBE
The typing rules for application and for fancy-fix application are almost
the same. In fancy-fix application where the first argument is an identifier, the
type inferrer has to look up in the environment the type of the identifier.
Type inference then proceeds as for normal function application.

There are two typing rules for application, as shown above. The first
requires the argument to be in the domain of the operator. The resulting
type is unknown and will be resolved by the context of the application.

The second rule is a functional way of writing set membership. The set
followed by an argument yields true if the argument is present in the set. Otherwise
it yields false.

\paragraph{Error Messages}~
=EXAMPLE
ñ1 1®;
Type error in ñ1 1®
In ñf a® where ña:X®, ñf® must have type ñð(X ¸ ?)® or ñð X®
Cannot apply ñ1:ú®
          to ñ1:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62091	In ñf a® where ña:X®, ñf® must have type ñð(X ¸ ?)® or ñð X®
62092	Cannot apply ñ?0:?1®
62093	          to ñ?0:?1®
=TEX



\subsection{Ì-abstraction}\label{tilambda}

=GFTSHOW Value Constructor
|ZTmÌ of Z_SCH_TEXT * Z_TM
=TEX
=FRULE 1 Rule
÷
E « env(D | P) ô chartuple(D | P) :: Ó‰1; E « env(D | P) ô x :: Ó‰2;
÷
E ô Ì D | P · x :: ð(Ó‰1 ¸ Ó‰2)
=DESCRIBE
The sub-term $D | P$ is type inferred as a schema text, and therefore
error messages relating to failed type inference for schema texts
may be generated from applying this rule. 
The type of a lambda abstration is the powerset of product type of the
characteristic tuple of the formed schema text, and the type of the
sub-term $t$.

\paragraph{Error Messages}~
See section \ref{tischematext}.


\subsection{Definite Description}

=GFTSHOW Value Constructor
|ZTmÍ1 of Z_SCH_TEXT
=TEX
=FRULE 1 Rule
÷
E « env (D | P) ô chartuple (D | P) :: Ó;
÷
E ô Í D | P :: Ó
=TEX

=GFTSHOW Value Constructor
|ZTmÍ2 of Z_SCH_TEXT * Z_TM

=FRULE 1 Rule
÷
E « env (D | P) ô x :: Ó;
÷
E ô Í D | P · x :: Ó
=TEX
=DESCRIBE
See description for lambda abstraction (section \ref{tilambda}).
\paragraph{Error Messages}~
See section \ref{tischematext}.


\subsection{Truth}

=GFTSHOW Value Constructor
|ZTmTruth of bool
=DESCRIBE
The parser should not generate terms constructed with the constructor
$ZTmTruth$ since truth and falsity are communicated as local variables, whic
the type inferrer recognises and converts them into $ZTmTruth ...$ as
appropriate.

\subsection{Predicate Negation}

=GFTSHOW Value Constructor
|ZTm³‰F of Z_TM
=TEX
=FRULE 1 Rule
÷
E ô x :: ð [y‰1 : Ó‰1; ...; y‰n : Ó‰n]
÷
E ô ³ x :: bool
=TEX
=FRULE 1 Rule
÷
E ô x :: bool
÷
E ô ³  x :: bool
=TEX
=DESCRIBE
The argument must be a predicate (represented by having a type of BOOL),
and its negation is also a predicate.

\paragraph{Error Messages}~
=EXAMPLE
ñ³ 1®;
Type error in ñ³ 1®
In a term of the form ñ³ P®, P must be a predicate
The following sub-term is not a predicate:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62151	In a term of the form ñ³ P®, P must be a predicate
=TEX


\subsection{Logical Infix Operators for Predicates}


=GFTSHOW Value Constructor
|ZTmLogInOp‰F of Z_IN_OP * Z_TM * Z_TM
=TEX

=FRULE 1 Rule
÷
E ô x‰1 :: bool;E ô x‰2 :: bool
÷
E ô x‰1 — x‰2 :: bool
=TEX

=FRULE 1 Rule
÷
E ô x‰1 :: ð [ y‰1 : Ó‰1; ...; y‰n : Ó‰n ]
E « {y‰1 í Ó‰1, ..., y‰n í Ó‰n} ô x‰2 :: bool
÷
E « {y‰1 í Ó‰1, ..., y‰n í Ó‰n} ô x‰1 — x‰2 :: bool
=TEX

=FRULE 1 Rule
÷
E ô x‰1 :: ð [y‰1 : Ó‰1; ...; y‰m : Ó‰m]
E « {y‰1 í Ó‰1, ..., y‰n í Ó‰n} ô x‰2 :: ð [z‰1 : Ô‰1; ...; z‰n : Ô‰n]
÷
E « {y‰1 í Ó‰1, ..., y‰n í Ó‰n, z‰1 í Ô‰1, ..., z‰n í Ô‰n} ô x‰1 — x‰2 :: bool
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: bool
E ô x‰2 :: ð [ y‰1 : Ó‰1; ...; y‰n : Ó‰n ]
÷
E « {y‰1 í Ó‰1, ..., y‰n í Ó‰n} ô x‰1 — x‰2 :: bool
=TEX
=DESCRIBE
The rules for conjunction, disjunction, bi-equivalence
and implication, and predicate composition are the same.
$—$ is one of `±', `²', `¤', `´' or ";".

If either or both of the operands are schemas, then the appropriate
operand(s) are coerced to be predicates (using the constructor
$ZTmSchemaPred$). The arguments are then both boolean, and the resulting
typs is boolean.

If either of the operands are neither schemas nor predicates, then an
error is raised.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ña ± 1®;
Type error in ña ± 1®
In a term of the form ñp ± q®, p and q must be predicates
The following sub-term is not a predicate:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62161	In a term of the form ñp ?0 q®, p and q must be predicates
=TEX
=SEEALSO
Logical Infix Operators for Schemas (Section \ref{loginopschemas}).
=TEX


\subsection{Predicate Quantification}

=GFTSHOW Value Constructor
|ZTmQuant‰F of Z_QUANT * Z_SCH_TEXT * Z_TM
=TEX
=FRULE 1 Rule
÷
E « env (D | P) ô x :: ð [y‰1 : Ó‰1; ...; y‰n : Ó‰n]
÷
E ô Q D | P · x :: bool
=TEX
=FRULE 1 Rule
÷
E « env (D | P) ô x :: bool
÷
E ô Q D | P · x :: bool
=TEX
=DESCRIBE
Here $Q$ is one of `$µ$', `$¶$' or `$¶‰1$'. If $x$ is a schema, then
it is coerced to be boolean using the constructor $ZTmSchemaPred$.  $x$ is
then type-inferred in an environment in which the variables of $D$ are
in scope. The type of the quantified term is a predicate. This is the first rule.

If $x$ is a predicate, then no coercion is required
and the rule is similar to that for schemas.

=TEX
\paragraph{Error Messages}~

=EXAMPLE
ñµ x : X | true · x®;
Type error in ñµ x : X | true · x®
In an expression of the form ñ?0 D | P · x®, ñx® must be a predicate
The following sub-term is not a predicate:
   ñx:X®
=TEX

=FAILURE
62162	In an expression of the form ñ?0 D | P · x®, ñx® must be a predicate
=TEX



\subsection{Schemas as Predicates}

=GFTSHOW Value Constructor
|ZTmSchemaPred of Z_TM
=TEX
Schemas as predicates constructed with the above value constructor
are rejected by the type inferrer. Such things are only created
by the type inferrer.
=DESCRIBE
\paragraph{Error Messages}~
None.

\subsection{Horizontal Schemas}

=GFTSHOW Value Constructor
|ZTmHorizSchema of Z_SCH_TEXT
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: Ó‰1; ...; E  ô x‰n :: Ó‰n
÷
E ô [x‰1 : Ó‰1; ...; x‰n : Ó‰n] :: ð [x‰1 : Ó‰1; ...; x‰n : Ó‰n]
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: Ó‰1; ... E  ô x‰n :: Ó‰n
E ô y : bool
÷
E ô [x‰1 : Ó‰1; ... x‰n : Ó‰n | y] :: ð [x‰1 : Ó‰1; ...; x‰n : Ó‰n]
=TEX
=DESCRIBE
\paragraph{Error Messages}~
See section \ref{tischematext}


\subsection{Decoration}

=GFTSHOW Value Constructor
|ZTmDecor of Z_TM * DECOR
=TEX
=FRULE 1 Rule
÷
E ô x :: ð [y‰1 : Ó‰1; ...; y‰n : Ó‰n]
÷
E ô x' :: ð [y‰1' : Ó‰1; ...; y‰n' : Ó‰n]
=TEX
=DESCRIBE
\paragraph{Error Messages}~
=EXAMPLE
ñ1'®;
Type error in ñ1'®
Only schemas may be decorated
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62131	Only schemas may be decorated
=TEX



\subsection{Precondition}

=GFTSHOW Value Constructor
|ZTmPre of Z_TM
=TEX
=FRULE 1 Rule
÷
E ô w :: ð [x‰1' : Ó‰1; ...; x‰i' : Ó‰i; y‰1! : Ô‰1; ...; y‰j! : Ô‰j;
		z‰1 : Õ‰1; ...; z‰k : Õ‰k]
		
÷
E ô pre w :: ð [z‰1 : Õ‰1; ...; z‰k : Õ‰k]
=TEX
=DESCRIBE
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñpre 1®;
Type error in ñpre 1®
In a schema expression of the form ñpre S®, ñS® must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62141	In a schema expression of the form ñpre S®, ñS® must be a schema
=TEX



\subsection{Schema Negation}
=GFTSHOW Value Constructor
|ZTm³‰S of Z_TM
=TEX
=FRULE 1 Rule
÷
E ô x :: ð [y‰1 : Ó‰1; ...; y‰n : Ó‰n]
÷
E ô ³ x :: ð [y‰1 : Ó‰1; ...; y‰n : Ó‰n]
=TEX
=DESCRIBE
\paragraph{Error Messages}~

=EXAMPLE
ñ³ 1®;
Type error in ñ³ 1®
In a schema expression of the form ñ³ S®, S must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
=TEX
=FAILURE
62142	In a schema expression of the form ñ³ S®, S must be a schema
=TEX



\subsection{Logical Infix Operators for Schemas}\label{loginopschemas}

=GFTSHOW Value Constructor
|ZTmLogInOp‰S of Z_IN_OP * Z_TM * Z_TM
=FRULE 1 Rule
no Ó‰i = Ô‰j or Ó‰i = Õ‰j
÷
E ô w‰1 :: ð [x‰1 : Ó‰1; ...; x‰k : Ó‰k; y‰1 : Ô‰1; ...; y‰m : Ô‰m]

E ô w‰2 :: ð [x‰1 : Ó‰1; ...; x‰k : Ó‰k; z‰1 : Õ‰1; ...; z‰n : Õ‰n]
÷
E ô w‰1 — x‰2 :: ð [x‰1 : Ó‰1; ...; x‰i : Ó‰i; y‰1 : Ô‰1; ...; y‰m : Ô‰m;
			z‰1 : Õ‰1; ...; z‰n : Õ‰n]
=TEX

The rules for conjunction, disjunction, bi-equivalence
and implication are the same.
$dy$ is one of `±', `²', `¤' or `´', and
$compatible$ is supposed to represent a test that
its two operands are compatible binding types.

To implement these rules we first type infer the operands.
If they both have manifest schema types we can perform
the compatibility test (unifying types of common components
as we go) and things are straightforward.
If they both have manifest boolean types all is well.
If one type is a manifest schema type and the other
is a manifest boolean type we enclose the schema operand
in a schema-as-term construct ($ZTmschema$) if it is not
already enclosed in one (because in this case it must
really be a schema-as-predicate).
If the types do not fit any of these cases we flag an error.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ña ± 1®;
Type error in ña ± 1®
In a term of the form ñP ± Q®, P and Q must be predicates
The following sub-term is not a predicate:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~

=FAILURE
62167	In an expression of the form ñS ?0 T®, S and T must be schemas
62168	In an expression of the form ñS ?0 T®, S and T must be compatible schemas
=TEX


\subsection{Schema Projection}

=GFTSHOW Value Constructor
|ZTmù of Z_TM * Z_TM
=TEX
=FRULE 1 Rule
no Ó‰i = Ô‰j or Ó‰i = Õ‰j
÷
E ô w‰1 :: ð [x‰1 : Ó‰1; ...; x‰k : Ó‰k; y‰1 : Ô‰1; ...; y‰m : Ô‰m]
E ô w‰2 :: ð [x‰1 : Ó‰1; ...; x‰k : Ó‰k; z‰1 : Õ‰1; ...; z‰n : Õ‰n]
÷
E ô w‰1 ù w‰2 :: ð [x‰1 : Ó‰1; ...; x‰k : Ó‰k; z‰1 : Õ‰1; ...; z‰n : Õ‰n]
=TEX
=DESCRIBE
We insist that the types of the sub-terms be manifest
schema types.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ[x : X] ù 1®;
Type error in ñ[x : X] ù 1®
In a term of the form ñS ù T®, S and T must be schemas
The following sub-term is not a schema:
   ñ1:ú®
=TEX
=EXAMPLE
ñ[x, y : X] ù [x : Y]®;
Type error in ñ[x, y : X] ù [x : Y]®
In a term of the form ñS ù T®, S and T must be compatible schemas
The incompatibilities are as follows:
In ñ[x, y : X]®:
   ñx:X®
In ñ[x : Y]®:
   ñx:Y®

=TEX
\paragraph{Error Codes}~

=FAILURE
62171	In a term of the form ñS ù T®, S and T must be schemas
62172	In a term of the form ñS ù T®, S and T must be compatible schemas
=TEX

\subsection{Schema Hiding}

=GFTSHOW Value Constructor
|ZTmHide of (Z_TM * IDENT list)
=TEX
=FRULE 1 Rule
no Ó‰i = Ô‰j
÷
E ô w :: ð [x‰1 : Ó‰1; ...; x‰k : Ó‰k; y‰1 : Ô‰1; ...; y‰m : Ô‰m]
÷
E ô w \ (x‰1, x‰k) :: ð [y‰1 : Ô‰1; ...; y‰m : Ô‰m]
=TEX
=DESCRIBE
\paragraph{Error Messages}~
¹IZ
S = [a, b : ú | a > b]
°
=EXAMPLE
ñ1\(x,y)®;
Type error in ñ1\(x,y)®
In the schema expression ñS \ (x‰1,...,x‰n)®, ñS® must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62181	In the schema expression ñS \ (x‰1, ..., x‰n)®, ñS® must be a schema
=TEX



\subsection{Schema Quantification}

=GFTSHOW Value Constructor
|ZTmQuant‰S of Z_QUANT * Z_SCH_TEXT * Z_TM
=FRULE 1 Rule
no Ó‰i = Ô‰j
÷
E ô [D | P] :: ð [y‰1 : Ó‰1; ...; y‰m : Ó‰m]
E ô x :: ð [y‰1 : Ó‰1; ...; y‰m : Ó‰m; z‰1 : Ô‰1; ...; z‰n : Ô‰n]
÷
E ô Q D | P · t :: ð [z‰1 : Ô‰1; ...; z‰n : Ô‰n]
=TEX
=DESCRIBE
We have two rules here corresponding to schema quantification
and to predicate quantification.
Here $Q$ is one of `$µ$', `$¶$' or `$¶‰1$'. $includes$ is intended
to be a function which checks that one manifest binding type includes
all the components of another unifying component
types as it goes.
=TEX
\paragraph{Error Messages}~

=FAILURE
62191	In a schema expression of the form ñ?0 D | P · S®, ñS® must be a schema
62192	In a schema expression of the form ñ?0 D | P · S®,
62193	   the charateristic tuple of ñD | P® must be compatible with ñS®
62195	   the quantification must be over the components of ñS® 
62196	The following are not components of ñ?0®:
=TEX



\subsection{„ and ˜}

=GFTSHOW Value Constructor
|ZTm„ of Z_TM
|ZTm˜ of Z_TM
=TEX
=FRULE 1 Rule
÷
E ô x :: ð [ y‰1 : Ó‰1; ...; y‰n : Ó‰n ]
÷
E ô „ x :: ð [ y‰1 : Ó‰1; ...; y‰n : Ó‰n; y‰1' : Ó‰1; ...; y‰n' : Ó‰n ]
=TEX
=FRULE 1 Rule
÷
E ô x :: ð [ y‰1 : Ó‰1; ...; y‰n : Ó‰n ]
÷
E ô ˜ x :: ð [ y‰1 : Ó‰1; ...; y‰n : Ó‰n; y‰1' : Ó‰1; ...; y‰n' : Ó‰n ]
=TEX
=DESCRIBE
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ„ 1®;
Type error in ñ„ 1®
In ñ„ S®, ñS® must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX

=EXAMPLE
ñ˜ 1®;
Type error in ñ˜ 1®
In ñ˜ S®, ñS® must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX

\paragraph{Error Codes}~


=FAILURE
62200	In ñ„ S®, ñS® must be a schema
62201	In ñ˜ S®, ñS® must be a schema
=TEX

\subsection{Set Membership and Equality}
=GFTSHOW Value Constructor
|ZTmEq of Z_TM * Z_TM
|ZTm of Z_TM * Z_TM
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: Ó; E ô x‰2 :: Ó
÷
E ô x‰1 = x‰2 :: bool
=TEX
=FRULE 1 Rule
÷
E ô x‰1 :: Ó; E ô x‰2 :: ð Ó
÷
E ô x‰1  x‰2 :: bool
=TEX
=DESCRIBE
\paragraph{Error Messages}~
=EXAMPLE
ñ1  1®;
Type error in ñ1  1®
In a term of the form ña  X®, X must be a set
The following sub-term is not a set:
   ñ1:ú®
=TEX
=EXAMPLE
ñ§1,2,3¢  {1, 2, 3}®;
Type error in ñ§1,2,3¢  {1, 2, 3}®
In a term of the form ña  X®, the type of X must be ð(a)
The type inferred was:
   ñ§1,2,3¢:seq ú®
=TEX

=EXAMPLE
ñ§1,2,3¢ = 1®;
Type error in ñ§1,2,3¢ = 1®
The operands of ñ$=® must have the same type
The types inferred were:
   ñ§1,2,3¢:seq ú®
   ñ1:ú®
=TEX

\paragraph{Error Codes}~

=FAILURE
62251	The operands of ñ$=® must have the same type
62252	In a term of the form ña  X®, X must be a set
62253	In a term of the form ña  X® where ña:Ó®, ñX® must subsume ñÓ®
=TEX

\subsection{Schema Composition}

=GFTSHOW Value Constructor
|ZTm» of Z_TM * Z_TM
=TEX
=FRULE 1 Rule
no Ó‰i = Ô‰j, Ó‰i = Õ‰j or Ó‰i = Ø‰j
÷
E ô t‰1 :: ð [w‰1' : Ó‰1; ...; w‰j' : Ó‰j; x‰1 : Ô‰1; ...; x‰k : Ô‰k;
		y‰1 : Õ‰1; ...; y‰m : Õ‰m]
E ô t‰2 :: ð [w‰1 : Ó‰1; ...; w‰j : Ó‰j;  x‰1 : Ô‰1; ...; x‰k : Ô‰k;
		z‰1 : Ø‰1; ...; z‰n : Ø‰n]
÷
E ô t‰1 » t‰2 :: ð [x‰1 : Ô‰1; ...; x‰k : Ô‰k; y‰1 : Õ‰1; ...; y‰m : Õ‰m;
		 z‰1 : Ø‰1; ...; z‰n : Ø‰n]
=TEX

The type rule for these monsters is discussed in
\cite{DS/FMU/IED/ZED002}. Clearly both terms must
have manifest schema types.

The embedded function $f$ checks that the primed components of the first schema and the unprimed ones of the second correspond and are unifiable.  It returns a list of these components and the substitution resulting from the unifications. 
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ[X, Y] [x' : Y] » [x : X]®;
Type error in ñ[X] [x' : Y] » [x : X]®
In a schema expression ñS » T®, the primed components of ñS®
   must be compatible with the corresponding components of ñT®
The other components of ñS® and ñT® must be compatible
The incompatibilities are as follows:
In ñ[x' : Y]®,
   ñx':Y®
In ñ[x : X]®,
   ñx:X®
=TEX

=EXAMPLE
ñ[X] 1 » [x : X]®;
Type error in ñ[X] 1 » [x : X]®
In a schema expression ñS » T®, ñS® and ñT® must be schemas
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62280	In a schema expression ñS » T®, ñS® and ñT® must be schemas
62281	In a schema expression ñS » T®, the primed components of ñS®
62282	   must be compatible with the corresponding components of ñT®
62283	The other components of ñS® and ñT® must be compatible
=TEX


\subsection{Schema Piping}

=FRULE 1 Rule
no Ó‰i = Ô‰j, Ó‰i = Õ‰j or Ó‰i = Ø‰j
÷
E ô t‰1 :: ð [w‰1! : Ó‰1; ...; w‰j! : Ó‰j; x‰1 : Ô‰1; ...; x‰k : Ô‰k;
		y‰1 : Õ‰1; ...; y‰m : Õ‰m]
E ô t‰2 :: ð [w‰1? : Ó‰1; ...; w‰j? : Ó‰j;  x‰1 : Ô‰1; ...; x‰k : Ô‰k;
		z‰1 : Ø‰1; ...; z‰n : Ø‰n]
÷
E ô t‰1 >> t‰2 :: ð [x‰1 : Ô‰1; ...; x‰k : Ô‰k; y‰1 : Õ‰1; ...; y‰m : Õ‰m;
		 z‰1 : Ø‰1; ...; z‰n : Ø‰n]
=TEX



=GFTSHOW Value Constructor
|ZTmPipe of Z_TM * Z_TM
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ[X] [x!  : X] >> [x? : Y]®;
Type error in ñ[X] [x!  : X] >> [x? : Y]®
In a schema expression ñS >> T®, the output components of ñS®
   must be compatible with the input components of ñT®
The other components of ñS® and ñT® must be compatible
The incompatibilities are as follows:
In ñ[x! : Y]®,
   ñx!:Y®
In ñ[x? : X]®,
   ñx?:X®
=TEX

=EXAMPLE
ñ[X] 1 >> [x : X]®;
Type error in ñ[X] 1 >> [x : X]®
In a schema expression ñS >> T®, ñS® and ñT® must be schemas
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62290	In a schema expression ñS >> T®, ñS® and ñT® must be schemas
62291	In a schema expression ñS >> T®, the output components of ñS®
62292	   must be compatible with the input components of ñT®
62293	The other components of ñS® and ñT® must be compatible
=TEX


\subsection{Integers and String Quotation}

=GFTSHOW Value Constructor
|ZTmú of int
|ZTmString of string
=FRULE 1 Rule
÷
÷
E ô x :: ú
=TEX
=FRULE 1 Rule
÷
÷
E ô x :: CHAR LIST
=DESCRIBE
=TEX
\paragraph{Error Messages}~
None.



\subsection{Type Constraints}

=GFTSHOW Value Constructor
|ZTmConstrained of Z_TM * Z_TM
=TEX
=FRULE 1 Rule
unifiable(ð ty1, ty2)
÷
E ô x‰1 :: Ó; E ô x‰2 :: ð Ó
÷
E ô x‰1 º x‰2 :: ð Ó
=TEX
=DESCRIBE
This is used when the term must belong to some set (the term on the right of the º):
Moreover when the term returned when a typed term is encountered
should comprise the left hand operand.

\paragraph{Error Messages}~
=EXAMPLE
ñ§1,2¢ º ú®;
Type error in ñ§1,2¢ º ú®
In ñtºÓ®, Ó must be an instance of the type of ñt®
Cannot constrain ñ§1,2¢:seq ú®
              to ñú®
=TEX

\paragraph{Error Codes}~

=FAILURE
62261	In ñt:Ó®, Ó must be an instance of the type of ñt®
62262	Cannot constrain ñ?0:?1®
62263	              to ñ?0®
=TEX



\subsection{Local Variables}

=GFTSHOW Value Constructor
|ZTmLVar of IDENT * Z_TM list
=FRULE 1 Rule
=TEX
=DESCRIBE
=TEX



\subsection{Global Variables}

=GFTSHOW Value Constructor
|ZTmGVar of (IDENT * Z_TM list)
=FRULE 1 Rule
=TEX
=DESCRIBE
=TEX



\subsection{Let Expressions}

=GFTSHOW Value Constructor
|ZTmLet of Z_EQ_DEF list * Z_TM
=TEX
=FRULE 1 Rule
÷
E ô y‰1 :: Ó‰1; ...; y‰n :: Ó‰n
E « {x‰1 í Ó‰1, ..., x‰n í Ó‰n} ô z :: Ô
÷
E ô let x‰1 ¦ y‰1, ..., x‰n ¦ y‰n · z :: Ô
=TEX
=DESCRIBE
=SML
; (* end of datatype Z_TM definition *)
=TEX



\subsection{Renaming}

=GFTSHOW Value Constructor
|ZTmRename of ZTM * ((IDENT * IDENT) list)
=FRULE 1 Rule
no Ó‰i is in Ô‰i
÷
E ô w [x‰1 : Ó‰1; ...; x‰m : Ó‰m; y‰1 : Ô‰1; ...; y‰n : Ô‰n]
÷
E ô w [z‰1/x‰1, ..., z‰m/x‰m] :: ð [z‰1 : Ó‰1; ...; z‰m : Ó‰m;
				y‰1 :: Ô‰1, ... y‰n :: Ô‰n]
=TEX
=DESCRIBE
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ1 [a/b, c/d]®;
Type error in ñ1 [a/b, c/d]®
In the expression ñS [x‰1/y‰1, ..., x‰n/y‰n®, ñS® must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX

=EXAMPLE
ñ[a : X] [a/a, b/a]®;
Type error in ñ[a : X] [a/a, b/a]®
In a schema expression ñS [x‰1/y‰1, ..., x‰n/y‰n®
   no ñx‰i® must appear more than once
The following identifier appears more than once
   ña®
=TEX

\paragraph{Error Codes}~

=FAILURE
62271	In an expression ñS [x‰1/y‰1, ..., x‰n/y‰n®, ñS® must be a schema
62272	In a schema expression ñS [x‰1/y‰1, ..., x‰n/y‰n®,
62273	   no ñx‰i® must appear more than once
=TEX



\subsection{Bracketed Terms}

=GFTSHOW Value Constructor
|ZTmBracketed of ZTM
=FRULE 1 Rule
÷
E ô x :: Ó
÷
E ô (x) :: Ó
=TEX
=DESCRIBE

\subsection{Term Quotation}

=GFTSHOW Value Constructor
|ZTmQuotation of TERM
=FRULE 1 Rule
÷
÷
E ô htm :: type_of (htm)
=DESCRIBE
=TEX
\paragraph{Error Messages}~
None.
=TEX

\section{INFERRING TYPES IN Z PARAGRAPHS}


\subsection{Abbreviation Definitions}
=GFTSHOW Value Constructor
|ZParaAbbDef of IDENT * IDENT list * Z_TM * EXTYPE OPT
|ZParaSchBox of IDENT * IDENT list * Z_SCH_TEXT * EXTYPE OPT
=FRULE 1 Rule
÷
E « {x‰1 í ð x‰1, ... x‰n í ð x‰n} ô w :: Ó
÷
E ô v [x‰1, ... x‰n] ¦ w :: Ó
define {v :: Ó}
=TEX
=DESCRIBE
Note also schbox is described by this rule.


\subsection{Axiomatic Descriptions}
=GFTSHOW Value Constructor
|ZParaAxDes of IDENT list * Z_SCH_TEXT * (((IDENT * EXTYPE) list) OPT)
=FRULE 1 Rule
÷
E « {x‰1 í ð x‰1, ... x‰m í P x‰m} ô [y‰1 : Ó‰1; ...; y‰n : Ó‰n | p] :: bool
÷
E ô [x‰1, ... x‰m] [y‰1 : Ó‰1; ...; y‰n : Ó‰n | p] :: bool
define {y‰1 :: Ó‰1; ...; y‰n :: Ó‰n}
=TEX
=DESCRIBE

\subsection{Free Type Definitions}
=GFTSHOW Value Constructor
|ZParaFreeType of (IDENT * (IDENT * Z_TM OPT) list) list
=FRULE 1 Rule
÷
E ô z‰1 :: Ó‰1; ...; z‰n :: Ó‰n
÷
E ô w ::= x‰1 | ... | x‰m | y‰1 §§z‰1¢¢ | ... | y‰n §§z‰n¢¢
define {w :: ð w}
define {x‰1 :: w, ..., x‰m :: w}
define {y‰1 :: Ó‰1 à w, ..., y‰n :: Ó‰n à w}
=TEX
=DESCRIBE

\subsection{Given Sets}
=GFTSHOW Value Constructor
|ZParaGivenSet of IDENT list * ((IDENT list * Z_TM) OPT)
=FRULE 1 Rule
÷
÷
[x‰1, ..., x‰n]
define {x‰1 :: ð x‰1, ..., x‰n :: ð x‰n}
=TEX
=FRULE 1 Rule
÷
E « {x‰1 í ð x‰1, ..., x‰n í P x‰n} ô w :: bool
÷
E ô [x‰1, ..., x‰n] & w :: Ó
define {x‰1 :: ð x‰1, ... x‰n :: ð x‰n}
=TEX
=DESCRIBE
\paragraph{Error Codes}~
=FAILURE
62801	In a given set paragraph of the form ¹Z [S‰1, ..., S‰n] & P °,
62802	   ñP® must be a predicate
=TEX

\subsection{Constraints}
=GFTSHOW Value Constructor
|ZParaConstraint of IDENT list * Z_TM
=FRULE 1 Rule
÷
E « {x‰1 í ð x‰1, ..., x‰n í ð x‰n} ô w :: bool
÷
E ô [x‰1, ..., x‰n] w :: bool
=TEX
=DESCRIBE
=FAILURE
62803	In a constraint paragraph ¹Z P °, ñP® must be a predicate
=TEX

\subsection{Conjectures}
=GFTSHOW Value Constructor
|ZParaConjecture of IDENT OPT * IDENT list * Z_TM
=FRULE 1 Rule
[X‰1, ... X‰k] & a :: ty
unifiable (ty, bool)
÷
E « {x‰1 í ð x‰1, ..., x‰n í ð x‰n} ô w :: bool
÷
E ô [x‰1, ..., x‰n] ?ô w :: bool
=TEX
=DESCRIBE
=FAILURE
62804	In a conjecture paragraph ¹Z ?ô P °, ñP® must be a predicate
=TEX


\subsection{Terms}
=GFTSHOW Value Constructor
|ZParaTerm of IDENT list * Z_TM * EXTYPE OPT;
=FRULE 1 Rule
÷
E « {x‰1 í ð x‰1, ..., x‰n í ð x‰n} ô w :: Ó
÷
E ô [x‰1, ..., x‰n] w :: Ó
=TEX

\subsection{Fixity Paragraphs}
=GFTSHOW Value Constructor
|ZParaFixity of FIXITY
=TEX



\section{SIGNATURE FOR Z TYPE INFERENCE}


=DOC
signature ÛZTypeInferenceÝ = sig
local
	open Unification ZUserInterfaceSupport;
in
	type ÛZ_ERROR_INFOÝ;
	datatype ÛZ_INFERREDÝ =
			ÛZInferredÝ of Z_PARA
		|	ÛZTypeErrorÝ of Z_ERROR_INFO;
	val Ûtype_check_z_paraÝ : {standard : bool} -> Z_PARA -> Z_INFERRED;
	val Ûprint_z_errorÝ : Z_ERROR_INFO -> 'a;
	val Ûtype_of_z_extypeÝ : EXTYPE -> TYPE;
	val Ûmake_chartupleÝ : Z_SCH_TEXT -> (Z_TM * EXTYPE);
end (* of local ... in *);
end (* signature ZTypeInference *);
=DESCRIBE

The data type $ERROR\_INFO$ is used to communicate error information
raised during type inference to the Z paragraph processor so that the
latter may print diagnostics to the user.

The function $print\_z\_error$ is intended to be called
via the Z paragraph processor to print type checking diagnostics.
The function raises the exception ``Fail'' with the error
code 62000.

=SEEALSO
=FAILURE
62998	DESIGN ERROR IN Z TYPE INFERRER (?0)
62999	DESIGN ERROR IN Z TYPE INFERRER
=ENDDOC



\pagebreak

\twocolumn[\section{INDEX}]
{	\footnotesize
	\printindex
}
\onecolumn

\end{document}
