=TEX
% TQtemplatetex
\documentstyle[hol1,11pt,TQ]{article}
%
%	The following environment is used to
%	display information required to compose error
%	messages.
%
\newenvironment{designnote}{\paragraph{Design Note}\small\it\parindent 10pt
\bgroup}{\egroup}

\makeindex
% The following macro is used to insert temporary notes
% in the document.
\def\TempNote#1{{\tiny#1}}
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for the Z Type Inferrer}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD062}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}                    %% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{HOL, Z}
\TPPauthor{D.J.~King&WIN01}
%\TPPauthors{R.D.~Arthan&WIN01\\D.J.~King&WIN01\\G.T.~Scullard&MAN05}
\TPPauthorisation{R.D.~Arthan & FMU Manager}
\TPPabstract{This document is the detailed design for
a type inferrer for HOL/Z. It describes the type inference
rules, and defines the data structure to
which the rules apply.}
\TPPdistribution{\parbox[t]{4.0in}{%
Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List} \tableofcontents
\subsection{Document Cross References}\bibliographystyle{fmu}
\bibliography{fmu}
\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion (27 February 1992)] First Draft.
\end{description}
\subsection{Changes Forecast}
None Known.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This is the detailed design for a type inferrer for HOL/Z,
responding to the high level design for the Z user
interface \cite{DS/FMU/IED/HLD018}.
The
implementation of this design is contained in
\cite{DS/FMU/IED/IMP062}.

\subsection{Introduction}
This document is organised as follows. The signature
declaration for the Z type inference module is introduced
at the beginning of the document, and constituents of the
signature are introduced at the appropriate points in the
discussion of type inference.
Next the data structure for representing Z terms
is described. This is used to communicate between the
Z parser, the Z type inferrer and the Z term generator
(when not using HOL/Z in {\bf Type Check Only Mode}).
An approach for error handling is then described in
section \ref{ErrorHandling}.

In section \ref{DataTypeZTM}, the inference rules
are introduced and each is desribed in a fixed format:
\begin{description}
\item[Value Constructor]
The value constructor describes the part of the
data type for Z terms to which 
the inference rule applies. It comprises part
of the Standard ML literal script produced when processing
the document with the command $docsml$ (see \cite{DS/FMU/IED/USR001}).
\item[Inference Rule(s)]
The type inference rules for each construct are expressed
in conventional notation.
\item[Description]
A description of the rules is provided, and any
issues relating to implementation are documented.
\item[Error Messages]
Example error messages which might be generated if application
of a particular rule fails, are shown as guidance to the
implementor.
\item[Error Codes]
The error codes, which correspond to parameterized
fragments of example error messages, are provided (They
are located deliberately in close proximity to their
respective examples to increase maintainability). This
subsection comprises another part of the
Standard ML literal script.
\end{description}

\subsubsection{Purpose and Background}

The type inferrer's job is to ensure that each of
these rules are obeyed in the process
of type checking a Z specification comprising
Z paragraphs interspersed with Z text.
A Correctly typed Z paragraph results
in either an indication of success (in {\bf Type Check
Only Mode}), or a helpful error message, returned
to the caller with the intention of the caller
reporting the error to the user.

\subsubsection{Dependencies}
The type inferrer makes use of the unification algorithm
described in \cite{DS/FMU/IED/DTD014}.
\subsubsection{Interface}
The interface to the Z type inferrer is intended to be
called only by the Z paragraph handling
routines, and is defined in the
signature $ZTypeInference$ introduced in section
\ref{Signature}. 
\subsubsection{Possible Enhancements}
%\begin{enumerate}
%\item
%\end{enumerate}
None known.
\subsubsection{Deficiencies}
None.

\section{THE SIGNATURE}\label{Signature}

The signature for Z type inference is dispersed through
this document.

Since the user is not intended to use
the functions provided in Z type inference directly, the
help information informs the user that this is the
case, and refers him to this document, which is intended
to fully explain the interface and purpose of the type
inferrer.

=DOC
signature ÛZTypeInferenceİ = sig
local
	open Unification;
in
=DESCRIBE
The type inference rules are for use by the Z parser only.
See document reference DS/FMU/IED/DTD062 for further information.
=ENDDOC

\section{DESIGN ISSUES}

\subsection{Interfaces Provided}

A function is required which takes a Z paragraph, type
checks the paragraph and returns error information
if type checking error was detected, or a type-checked
Z paragraph together with a substitution function, mapping
type unknowns to actual extended types. The substitution
function is intended for use by the term generator.

There is an additional requirement for type checking
a limited variety of Z paragraphs connected by the ``\&''
symbol. This necessitates that the environment containing
the types of variables inferred be available to
the inferrer when checking the next paragraph.

\subsection{Error Handling}\label{ErrorHandling}

A key aspect of the success of the type inferrer is
the quality of error messages which are generated.
The type inferrer reports helpful messages which
are specific to the particular of inference rule which failed.
Error messages inserts are fragments of Z which should ideally
be easily understandable by the user.
It is the case that there are a variety of Z constructs
whose Z type written down, is very large. An approach to
this problem is to enable the type inferrer to look at
the type specified in the signatures of the component part
or parts of the term, and use this type in presenting
diagnostic fragments of Z.

When application of a typing rule fails, then
error information is returned. The details of this
information depend upon the particular inference rule.
A data type representing this information is
provided. This type is equated (in the implementation)
with an actual data structure which is private to the
implementation of the type inferrer.

=DOC
type ÛERROR_INFOİ;

val Ûprint_zerrorİ : ERROR_INFO -> 'a;
=DESCRIBE
The data type $ERROR\_INFO$ is used to communicate error information
raised during type inference to the Z parser interface, so that the
latter may print diagnostics to the user.
The function $print\_zerror$ is intended to be called
by the Z parser interface to print type checking diagnostics.
The function raises the exception ``Fail'' with the error
code 62000.
=FAILURE
62000	Type error
62001	Type error in ñ?0®
=ENDDOC

\subsubsection{Format of Error Messages}

It is desirable that type checking error messages
are consistent regarding style and format. Therefore all
error messages generated comprise the following components:

\begin{enumerate}
\item
the term being constructed when the error was detected
\item
a summary of the inference rule which was being applied
\item
the types of the manipulana which were being used in applying
the rule
\end{enumerate}

See section ({\bf Error Messages} of \ref{FirstRule}) for
an example of an error message following this format.

\subsection{Standard Versus Extended Z}

Facilities for checking a specification against the
standard Z language \cite{DS/FMU/IED/DEF007} and
against extended Z are required.

The formal contents of a Z specification is
divided into two distinct categories for type
checking purposes.

Firstly, there is the Z which describes the specification
using Z paragraphs. The user is most likely to want to
check this against the standard Z language.

Secondly, there are fragments of Z which constitute
terms for use in proof scripts (e.g., goals, specializations), which are enclosed between the symbols `ñ' and `®'.
It is less likely that the user will want to check
this against the standard Z language, but will want
to check it against extended Z.

Two flags are introduced to implement these
envisaged requirements:

\begin{description}

\item[check\_paras\_with\_extended\_z]
for specifying that paragraphs should be checked with
extended Z (i.e., all Z constructs which are not
delimited by the symbols `ñ' and `®').

\item[check\_terms\_with\_extended\_z]
for specifying that Z terms should be checked with
extended Z (i.e., those Z constructs which are
delimited by the symbols `ñ' and `®').

\end{description}

=DOC
(* Ûcheck_paras_with_extended_zİ  - boolean flag declared by new_flag, default: false *)
=DESCRIBE
If this flag is set, all Z paragraphs will be
type checked
against extended Z. Otherwise, they will be type
checked against standard Z. The default setting is false.
=ENDDOC

=DOC
(* Ûcheck_terms_with_extended_zİ  - boolean flag declared by new_flag, default: true *)
=DESCRIBE
If this flag is set,  all terms enclosed
between `ñ' and `®' will be type checked against extended Z.
Otherwise, they will be type checked against standard Z.
The default setting is true.
=ENDDOC

\section{DATA STRUCTURE FOR Z TERMS}\label{DataTypeZTM}

The data structure for representing Z terms as a tree is
presented in this section. The form of the
data structure is determined largely by the grammar of
Z defined in \cite{DS/FMU/IED/DEF007}.

=DOC
type ÛDECORİ			(* = string *);
type ÛIDENTİ			(* = string*DECOR *);
type ÛZSCHTEXTİ		(* = ZDEC list * ZTM *);

datatype ÛZTMİ =		(* see ref. DS/FMU/IED/DTD062 *)
=DESCRIBE
The type DECOR represents the type of Z decorations.
The type IDENT represents a name (or a word in Spivey-speak)
with a possibly zero length decoration.
A schema text, comprising a list of declarations and
a predicate is denoted by the type, ZSCHTEXT.
A Z term, represented by ZTM, is one of either a Z expression,
a schema expression or a predicate. The type is recursive
and is used to communicate Z terms from the Z parser to
the type inferrer, and the term generator. The value
constructors of the type ZTM are to be found in ref.
DS/FMU/IED/DTD062.
=SEEALSO
ZDEC
=ENDDOC

In sections \ref{FirstRule} to \ref{LastRule}, the
typing rules are defined. However, since
the type inferrer is only intended to be used by the parser,
interface and not by the user directly, documentation boxes are
not provided for each of the interfaces.

\subsection{Sequence Display}\label{FirstRule}

=SMLLABELLED Value Constructor
ÛZt§¢İ of EXTYPE OPT * ZTM list
=TEX

=FRULE 1 Rule
unifiable[ty1, ..., tyk]
÷
E ô t1::ty1; ...; E ô tk::tyk
÷
E ô §t1, ..., tk¢ :: ğ(ú ¸ ty1)
=TEX

=FRULE 1 Rule
÷
÷
E ô §¢ :: ğ(ú ¸ ?new)
=TEX

=DESCRIBE
The rule for type inferring  types in a non-empty
list is as follows:

First, the types $ty1 \ldots tyk$, of the sub-terms
are inferred
(using the same environment $E$ for each one).
The types are then unified,
and the HOL type corresponding to the Z type $ğ(ú¸ ty1)$
is computed.

The result is the term constructed from the
type checked sub-terms and the type we have just computed.
The substitution arising from the unification is modified
as a side effect.

The case of an empty list display is described by the second rule. 
To type check an empty list 
a new type unknown is invented. The result
is that type,
with an empty list display. The
substitution is unchanged by this rule.

\paragraph{Error Messages}~
=EXAMPLE
ñ§1,2,(3,4),5¢®;
Type error in ñ§1,2,(3,4),5¢®
Each element in a sequence must have the same type
Type ñú® inferred for the following elements:
   ñ1®
   ñ2® 
   ñ5®
Type ñú¸ú® inferred for the following element:
   ñ(3,4)®
=TEX
\paragraph{Error Codes}~

Error message $62011$ is parameterized
by either a string which can be either ``sequence'' 
or ``set''. Message $62012$ has a second parameter;
for occasions when the number of elements to be displayed
is greater than one, the message requires pluralizationism.
=FAILURE
62011	Each element in a ?0 must have the same type
62012	Type ñ?0® inferred for the following element?1:
62013	   ñ?0®
=TEX

\subsection{Set Display}
=SMLLABELLED Value Constructor
|ÛZtsetdİ of EXTYPE OPT * ZTM list
=TEX
=FRULE 1 Rule
unifiable[ty1, ..., tyk]
÷
E ô t1 :: ty1; ...; E ô tk :: tyk
÷
E ô {t1, ..., tk} :: ğ ty1
=TEX

=FRULE 1 Rule
÷
÷
E ô {} :: ğ ?new
=TEX

=DESCRIBE
The types of each element in a set display must be
unifyable to some type, $ty$. The type of a set display is then
$ğ ty$. If it is found that the elements are not unifyable, then
the error information produced lists each of the types
inferred, and the elements in the set corresponding to those
types. The elements are listed in lexicographic order.
This is the same as to be found in sequence and bag display.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñ{1,2,(3,4),5}®;
Type error in ñ{1,2,(3,4),5}®
Each element in a set display must have the same type
Type ñú® inferred for the following elements:
   ñ1®
   ñ2® 
   ñ5®
Type ñú¸ú® inferred for the following element:
   ñ(3,4)®
=TEX
\paragraph{Error Codes}~
See error messages for sequence display.
=TEX

\subsection{Set Abstraction}
=SMLLABELLED Value Constructor
|ÛZtseta1İ of ZSCHTEXT
|ÛZtseta2İ of ZSCHTEXT * ZTM
=TEX

=FRULE 1 Rule
÷
E « env(D|P) ô chartuple(D|P) :: ty
÷
E ô {D|P} :: ğ ty
=TEX

=FRULE 1 Rule
÷
E « env(D|P) ô t :: ty
÷
E ô {D|P·t} :: ğ ty
=TEX
=DESCRIBE
We write $chartuple(D|P)$  for the characteristic tuple,
and $env(D|P)$ for the environment,
which arise from the type checked schema text $D|P$.

\paragraph{Error Messages}~
=EXAMPLE
ñ{x | 0}®;
Type error in ñ{x | 0}®
In a term of the form  ñ{D | P}®, P must be a predicate
The following sub-term is not a predicate:
   ñ0:ú®
=TEX
\paragraph{Error Codes}~
Error message $62032$ has a parameter which can be either
``predicate'', ``schema'' or ``set''.
=FAILURE
62031	In a term of the form  ñ{D|P}®, P must be a predicate
62032	The following sub-term is not a ?0:
62033	   ñ?0:?1®
62034	In a term of the form  ñ{D|P·S}®, P must be a predicate
=TEX

\subsection{Powerset}
=SMLLABELLED Value Constructor
|ÛZtğİ of ZTM
=TEX
=FRULE 1 Rule
÷
E ô t1 :: (ty1)ğ
÷
E ô ğ t1 :: ((ty1)ğ)ğ
=TEX
=DESCRIBE
\paragraph{Error Messages}~
=EXAMPLE
ñğ 1®;
Type error in ñğ 1®
In a term of the form ñğ X®, X must be a set
The following sub-term is not a set:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62041	In a term of the form ñğ X®, X must be a set
=TEX

\subsection{Tuple Display}
=SMLLABELLED Value Constructor
|ÛZttupleİ of ZTM list
=TEX
=FRULE 1 Rule
÷
E ô t1 :: ty1; ...; E ô tk :: tyk
÷
E ô (t1, ..., tk) :: ty1 ¸ ... ¸ tyk
=TEX
=DESCRIBE
An empty tuple display indicates a
design error in the parser.
\paragraph{Error Messages}~
None.

\subsection{Product}
=SMLLABELLED Value Constructor
|ÛZt¸İ of ZTM list
=TEX
=FRULE 1 Rule
÷
E ô t1 :: ğ ty1; ...; E ô tk :: ğ tyk
÷
E ô t1 ¸ ... ¸ tk :: ğ(ty1 ¸ ... ¸ tyk)
=TEX
=DESCRIBE
\paragraph{Error Messages}~
=EXAMPLE
ñú¸1®;
Type error in ñú¸1®
In ñS‰1¸ ... ¸S‰n®, S‰1 to S‰n must be sets
Type ñú® inferred for the following elements:
   ñ1®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62012$ and $62013$ respectively.

=FAILURE
62061	In ñS‰1¸ ... ¸S‰n®, S‰1 to S‰n must be sets
=TEX

\subsection{Theta}
=SMLLABELLED Value Constructor
|ÛZtÊİ of ZTM * DECOR
=TEX

=FRULE 1 Rule
÷
E ô t1 :: ğ ty
÷
E ô Êt1 :: ty
=TEX

=DESCRIBE
The operand of a $Ê$-term must be a schema
type. Although we could try to continue if the type
is not known, we signal an error for uniformity with
other schema operators.

% ÁÂÇÄÅÚÈÊÉËÌÍÎØoĞÒÓÔÕÆÑÙ×
% AB‡„EZHŠIKŒMN˜OR“T•†™—

\paragraph{Error Messages}~
=EXAMPLE
ñÊ 1®;
Type error in ñÊ 1®
In a term of the form ñÊ S®, S must be a schema
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62071	In a term of the form ñÊ S®, S must be a schema
=TEX

\subsection{Selection}
=SMLLABELLED Value Constructor
|ÛZtselİ of ZTM * IDENT
=TEX
=FRULE 1 Rule
÷
E ô t :: [ ..., f : ty, ..., ]
÷
E ô t.f :: ty
=TEX
=DESCRIBE
That is to say, the type inferred for $t$ must be a
manifest binding type with a field of the
appropriate name.
\paragraph{Error Messages}~
The examples that follow
require the following two definitions.

¹IZ
S ¦ [a, b : ú | a < b ]
°

=EXAMPLE
ñ(Ê S).c®;
Type error in ñ(Ê S).c®
The selected component must be present in the binding
    The component ñc®
is not present in ñ(Ê S)®
=TEX
=EXAMPLE
ñ1.c®;
Type error in ñ1.c®
In a term of the form ñB.c®, B must be a binding
The following sub-term is not a binding:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62081	The selected component must be present in the binding
62082	    The component ñ?0®
62083	is not present in ñ?0®
62084	In a term of the form ñB.c®, B must be a binding
=TEX

\subsection{Application}
=SMLLABELLED Value Constructor
|ÛZtappİ of ZTM * ZTM
=TEX
=FRULE 1 Rule
unifiable(ty1, ğ(ty2¸?new))
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1 t2 :: ?new
=TEX

=FRULE 1 Rule
unifiable(ty1, ty2)
÷
E ô t1 :: ğ ty1; E ô t2 :: ty2
÷
E ô t1 t2 :: bool
=TEX

=DESCRIBE
There are two rules for this construct. The first one
corresponds to ordinary application and is attempted first.

If the unification for the first rule fails, then the
application may be the application of a predicate to
its argument (the second rule).

If the above cases fail, the application may be a generic constant applied to its generic actuals.
In this case, we wish to return just the function part (which should be a Ztvar with no generic actuals), with its generic actuals filled in from the type inferred argument.

\paragraph{Error Messages}~
=EXAMPLE
ñ1 1®;
Type error in ñ1 1®;
The operator must have type Ó ­ Ô
Cannot apply ñ1:ú®
          to ñ1:ú®
=TEX
=EXAMPLE
ñ head 1 ®;
Type error in ñ head 1 ®
The operator and the operand have incompatible types
Cannot apply ñhead:seq‰1 X ­ X®
          to ñ1:ú®
=TEX
=EXAMPLE
ñ1={1}®;
Type error in ñ1={1}®
The operands of ñ=® must have the same type
The types infered were:
   ñhead:seq‰1 X ­ X®
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62091	The operator must have type Ó ­ Ô
62092	The operator and the operand have incompatible types
62093	The operands of ñ$=® must have the same type
62094	Cannot apply ñ?0:?1®
62095	          to ñ?0:?1®
=TEX

\subsection{Ì-abstraction}
=SMLLABELLED Value Constructor
|ÛZtÌİ of ZSCHTEXT * ZTM
=TEX
=FRULE 1 Rule
÷
E « env(D|P) ô chartuple(D|P) :: ty1; E « env(D|P) ô t :: ty2;
÷
E ô ÌD|P·t :: ğ(ty1¸ty2)
=DESCRIBE
\paragraph{Error Messages}~
None.

\subsection{Definite Description}
=SMLLABELLED Value Constructor
|ÛZtÍ1İ of ZSCHTEXT
|ÛZtÍ2İ of ZSCHTEXT * ZTM
=TEX
=FRULE 1 Rule
÷
E « env(D|P) ô chartuple(D|P) :: ty;
÷
E ô ÍD|P :: ty
=TEX

=FRULE 1 Rule
÷
E « env(D|P) ô t :: ty;
÷
E ô ÍD|P·t :: ty
=TEX
=DESCRIBE
\paragraph{Error Messages}~
None.

\subsection{Schema Text as a Term}
=SMLLABELLED Value Constructor
|ÛZtschemaİ of ZSCHTEXT
=TEX
=FRULE 1 Rule
÷
E  ô x1 :: ty1; ... E  ô xk :: tyk
÷
E ô [D|P] :: ğ [ x1 : ty1, ..., xk : tyk ]
=TEX
=DESCRIBE
(where the $x_i$ are the variables declared by the
schema as computed by $ti\_ZSCHTEXT$. The types are
obtained from the environment returned by $ti\_ZSCHTEXT$.)
\paragraph{Error Messages}~
None.

\subsection{Decoration}
=SMLLABELLED Value Constructor
|ÛZtdecİ of ZTM * DECOR
=TEX
=FRULE 1 Rule
÷
E ô t :: ğ [ x1 : ty1, ..., xk : tyk ]
÷
E ô t' :: ğ [ x1' : ty1, ..., xk' : tyk ]
=TEX
=DESCRIBE
Thus the term operand must be a manifest schema type and
the result is the decorated schema type.
\paragraph{Error Messages}~
=EXAMPLE
ñ1'®;
Type error in ñ1'®
Only schemas may be decorated
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62131	Only schemas may be decorated
=TEX

\subsection{Precondition}
=SMLLABELLED Value Constructor
|ÛZtpreİ of ZTM
=TEX
=FRULE 1 Rule
÷
E ô t :: ğ [ x1 : ty1, ..., xk : tyk ]
÷
E ô pre t :: ğ [ xi1 : ty1, ..., xim : tyk ]
=TEX
=DESCRIBE
Here the ${i_j}$ are the indices of the non-result
variables.
Note the term operand must be a manifest schema type.
=TEX
\paragraph{Error Messages}~
None.
\subsection{Negation}
=SMLLABELLED Value Constructor
|ÛZt³İ of ZTM
=TEX
=FRULE 1 Rule
÷
E ô t :: ty
÷
E ô ³ t :: ty
=TEX
=DESCRIBE
\paragraph{Error Messages}~
=EXAMPLE
ñ³ 1®;
Type error in ñ³ 1®
In a term of the form ñ³ p®, p must be a predicate
The following sub-term is not a predicate:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62151	In a term of the form ñ³ P®, P must be a predicate
=TEX

\subsection{Propositional Calculus}
=SMLLABELLED Value Constructor
|ÛZt±İ of ZTM * ZTM
|ÛZt²İ of ZTM * ZTM
|ÛZt´İ of ZTM * ZTM
|ÛZt¤İ of ZTM * ZTM
=FRULE 1 Rule
compatible(bty1, bty2)
÷
E ô t1 :: ğ bty1
E ô t2 :: ğ bty2
÷
E ô t1 dy t2 :: ğ(bty1 « bty2)
=TEX
=FRULE 1 Rule
÷
E ô t1 :: bool
E ô t2 :: bool
÷
E ô t1 dy t2 :: bool
=TEX

=FRULE 1 Rule
÷
E ô t1 :: ğ [ x1 : ty1, ..., xk : tyk ]
E ô t2 :: bool
÷
E ô t1 dy t2 :: bool
=TEX
=FRULE 1 Rule
÷
E ô t1 :: bool
E ô t2 :: ğ [ x1 : ty1, ..., xk : tyk ]
÷
E ô t1 dy t2 :: bool
=TEX
=DESCRIBE
The rules for conjunction, disjunction, bi-equivalence
and implication are the same.
$dy$ is one of `±', `²', `¤' or `´', and
$compatible$ is supposed to represent a test that
its two operands are compatible binding types.

To implement these rules we first type infer the operands.
If they both have manifest schema types we can perform
the compatibility test (unifying types of common components
as we go) and things are straightforward.
If they both have manifest boolean types all is well.
If one type is a manifest schema type and the other
is a manifest boolean type we enclose the schema operand
in a schema-as-term construct ($Ztschema$) if it is not
already enclosed in one (because in this case it must
really be a schema-as-predicate).
If the types do not fit any of these cases we flag an error.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ña ± 1®;
Type error in ña ± 1®
In a term of the form ñP ± Q®, P and Q must be predicates
The following sub-term is not a predicate:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62161	In a term of the form ñP ?0 Q®, P and Q must be predicates
=TEX

\subsection{Projection}
=SMLLABELLED Value Constructor
|ÛZtùİ of ZTM * ZTM
=TEX
=FRULE 1 Rule
compatible(bty1, bty2)
÷
E ô t1 :: ğ bty1; E ô t2 :: ğ bty2
÷
E ô t1 ù t2 :: ğ bty2
=TEX
=DESCRIBE
We insist that the types of the sub-terms be manifest
schema types.
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñS ù 1®;
Type error in ñS ù 1®
In a term of the form ñS ù T®, S and T must be schemas
The following sub-term is not a schema:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
Lines 3 and 4 of the error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62171	In a term of the form ñS ù T®, S and T must be schemas
=TEX

\subsection{Hiding}
=SMLLABELLED Value Constructor
|ÛZthideİ of (ZTM * IDENT list)
=TEX
=FRULE 1 Rule
÷
E ô t :: ğ [ x1 : ty1, ..., xk : tyk ]
÷
E ô t1 \ (y1, ..., yk) :: ğ [ xi1 : ty1, ..., xim : tyk ]
=TEX
=DESCRIBE
We insist that the type of the sub-term be a manifest
schema type. The $i_j$ are the indices for those $x_{i_j}$
which are not in $\{y1, \ldots, yk\}$.
\paragraph{Error Messages}~
¹IZ
S = [a, b : ú | a > b]
°
=EXAMPLE
ñS\(a,b,c)®;
Type error in ñS\(a,b,c)®
In ñS\(x‰1,...,x‰n)®, (x‰1,...,x‰n) must be components of S
The component
   ñc®
is not present in ñS®
=TEX
\paragraph{Error Codes}~
=FAILURE
62181	In ñS \ (x‰1,...,x‰n)®, (x‰1,...,x‰n) must be components of S
62182	The component
62183	   ñ?0®
62184	is not present in ñ?0®
=TEX

\subsection{Quantification}
=SMLLABELLED Value Constructor
|ÛZtµİ of ZSCHTEXT * ZTM
|ÛZt¶İ of ZSCHTEXT * ZTM
|ÛZt¶‰1İ of ZSCHTEXT * ZTM
=TEX
=FRULE 1 Rule
includes(bty2, bty1)
÷
E ô [D|P] :: ğ bty1
E ô t :: ğ bty2
÷
E ô Q D|P·t :: ğ (bty2 \ bty1)
=TEX
=FRULE 1 Rule
÷
E ô [D|P] :: ğ  [ x1 : ty1, ..., xk : tyk ]
E « env(D|P) ô t :: bool
÷
E ô Q D|P·t :: bool
=TEX
=DESCRIBE
We have two rules here corresponding to schema quantification
and to predicate quantification.
Here $Q$ is one of `$µ$', `$¶$' or `$¶‰1$'. $includes$ is intended
to be a function which checks that one manifest binding type includes
all the components of another unifying component
types as it goes.
=TEX
\paragraph{Error Messages}~
None.

\subsection{„ and ˜}
=SMLLABELLED Value Constructor
|ÛZt„İ of ZTM
|ÛZt˜İ of ZTM
=TEX
=FRULE 1 Rule
÷
E ô t :: ğ [ x1 : ty1, ..., xk : tyk ]
÷
E ô G t :: ğ [ x1 : ty1, ..., xk : tyk, x1' : ty1, ..., xk' : tyk ]
=TEX
=DESCRIBE
Here $G$ is one of $„$ or $˜$.
The operand type must be a manifest schema type.
=TEX
\paragraph{Error Messages}~
None.

\subsection{Schema Composition}

=SMLLABELLED Value Constructor
|ÛZt»İ of ZTM * ZTM
=TEX

The type rule for these monsters is discussed in
\cite{DS/FMU/IED/ZED002}. Clearly both terms must
have manifest schema types.

The embedded function $f$ checks that the primed components of the first schema and the unprimed ones of the second correspond and are unifiable.  It returns a list of these components and the substitution resulting from the unifications. 
=TEX
\paragraph{Error Messages}~
None.

\subsection{Schema Piping}

=SMLLABELLED Value Constructor
|ÛZtpipeİ of ZTM * ZTM
=TEX
\paragraph{Error Messages}~
None.

\subsection{Integers}

=SMLLABELLED Value Constructor
|ÛZtúİ of int
=TEX
\paragraph{Error Messages}~
None.

\subsection{Bags}

=SMLLABELLED Value Constructor
|ÛZtûıİ of EXTYPE OPT * ZTM list
=TEX

=FRULE 1 Rule
unifiable[ty1, ..., tyk]
÷
E ô t1::ty1; ...; E ô tk::tyk
÷
E ô ût1, ..., tkı :: ğ(ty1 ¸ ú)
=TEX

=FRULE 1 Rule
÷
÷
E ô ûı
 :: ğ(?new ¸ ú)
=TEX
\paragraph{Error Messages}~
=EXAMPLE
ñû1,2,(3,4),5ı®;
Type error in ñû1,2,(3,4),5ı®
Each element in a bag must have the same type
Type ñú® inferred for the following elements:
   ñ1®
   ñ2® 
   ñ5®
Type ñú¸ú® inferred for the following element:
   ñ(3,4)®
=TEX
\paragraph{Error Codes}~
See error messages for sequence displays.
=SEEALSO
Sequence Display
=TEX


\subsection{Predicates}
=SMLLABELLED Value Constructor
|ÛZttrueİ
|ÛZtfalseİ
|ÛZteqİ of ZTM * ZTM
|ÛZtİ of ZTM * ZTM
=TEX
=FRULE 1 Rule
÷
÷
E ô true :: bool
=TEX
=FRULE 1 Rule
÷
÷
E ô false :: bool
=TEX
=FRULE 1 Rule
unifiable(ty1, ty2)
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1 = t2 :: bool
=TEX
=FRULE 1 Rule
unifiable(ğ ty1, ty2)
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1  t2 :: bool
=TEX
=DESCRIBE
\paragraph{Error Messages}~
=EXAMPLE
ñ1  1®;
Type error in ñ1  1®
In a term of the form ña  X®, X must be a set
The following sub-term is not a set:
   ñ1:ú®
=TEX
=EXAMPLE
ñ§1,2,3¢  {1, 2, 3}®;
Type error in ñ§1,2,3¢  {1, 2, 3}®
In a term of the form ña  X®, the type of X must be ğ(a)
The type inferred was:
   ñ§1,2,3¢:seq ú®
=TEX

=EXAMPLE
ñ§1,2,3¢ = 1®;
Type error in ñ§1,2,3¢ = 1®
The operands of ñ$=® must have the same type
The types inferred were:
   ñ§1,2,3¢:seq ú®
   ñ1:ú®
=TEX

\paragraph{Error Codes}~
Lines 3 and 4 of the first error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62251	The operands of ñ$=® must have the same type
62252	In a term of the form ña  X®, X must be a set
62253	In a term of the form ña  X®, the type of X must be ğ(a)
62254	The type inferred was:
62255	The types inferred were:
=TEX

\subsection{Type Constraints}
=SMLLABELLED Value Constructor
|ÛZtconstrainedİ of (ZTM * ZTM)
=TEX
=FRULE 1 Rule
unifiable(ğ ty1, ty2)
÷
E ô t1 :: ty1; E ô t2 :: ty2
÷
E ô t1 º t2 :: ty1
=TEX
=FRULE 1 Rule
÷
E ô t1 :: ty1; E ô t2 :: ğ bool
÷
E ô t1 º t2 :: bool
=TEX
=DESCRIBE
There are two cases, where the user may wish to impose a type constraint.
The first and most obvious is when the term must belong to some set (the term on the right of the º):
Moreover when the term returned when a typed term is encountered
should comprise the left hand operand.

The second case is where a schema text is being used as a predicate.
The type checker might be able to deduce this in some cases, but in others it is necessary to constrain the term to $bool$.

\paragraph{Error Messages}~
=EXAMPLE
ñ§1,2¢ º ú®;
Type error in ñ§1,2¢ º ú®
In ñtºÓ®, Ó must be an instance of the type of ñt®
Cannot constrain ñ§1,2¢:seq ú®
              to ñú®
=TEX

\paragraph{Error Codes}~
Lines 3 and 4 of the first error message example above are
provided by error messages $62032$ and $62033$ respectively.

=FAILURE
62261	In ñt:Ó®, Ó must be an instance of the type of ñt®
62262	Cannot constrain ñ?0:?1®
62263	              to ñ?0®
=TEX


\subsection{Local Variables}
=SMLLABELLED Value Constructor
|ÛZtlvarİ of (IDENT *EXTYPE OPT * ZTM list)
=TEX
=DESCRIBE

\subsection{Global Variables}
=SMLLABELLED Value Constructor
|ÛZtgvarİ of (IDENT * EXTYPE OPT * ZTM list)
=TEX
=DESCRIBE
=SML
; (* end of datatype ZTM definition *)
=TEX
\subsection{Let Expressions}

TBS.

\subsection{Where Expressions}\label{LastRule}

TBS.

\section{DATA STRUCTURE FOR Z DECLARATIONS}

=DOC
datatype ÛZDECİ =	ÛZdDecİ of IDENT list * ZTM
		|	ÛZdDecsexpİ of ZTM * DECOR;
=DESCRIBE
=SEEALSO
ZTM, ZSCHTEXT, IDENT, DECOR
=ENDDOC

\paragraph{Error Messages}~
=EXAMPLE
ñ[a : 1]®;
Type error in ñ[a : 1®®
In a declaration of the form ña:Ó®, Ó must be a set
The following sub-term is not a set
   ñ1:ú®
=TEX
=EXAMPLE
ñ[a : ú | 1]®;
Type error in ñ[a : ú | 1]®
In a schema of the form ñ[D|P]®, P must be a predicate 
The type inferred was:
   ñ1:ú®
=TEX
\paragraph{Error Codes}~
=FAILURE
62501	In a declaration of the form ña:Ó®, Ó must be a set
62502	In a schema of the form ñ[D|P]®, P must be a predicate
=TEX

\section{Z TYPE INFERENCE INTERFACE}

=DOC
datatype ÛZPARAGRAPHİ
		=	ÛAbbDefİ of IDENT * IDENT list * ZTM
		|	ÛAxDesİ of IDENT list * ZSCHTEXT
		|	ÛFreeTypeİ of IDENT * (IDENT * ZTM) list
		|	ÛGivenSetİ of IDENT list
		|	ÛConstraintİ of ZTM
		|	ÛConjectureİ of ZTM
		|	ÛZTermİ of ZTM;

type ÛZENVİ 	(* = IDENT -> (bool * EXTYPE) *);

datatype ÛZINFERREDİ =	ÛInferredİ of ZPARAGRAPH * ZENV * SUBS
		|	ÛTypeErrorİ of ERROR_INFO;

val Ûinit_zenvİ : IDENT list -> ZENV;
val Ûtype_check_zparagraphİ : ZENV -> ZPARAGRAPH -> ZINFERRED

=DESCRIBE
For a correctly typed term, the term is returned with its
extended type. For an incorrectly typed term, error
information is returned.
=FAILURE
62998	DESIGN ERROR IN Z TYPE INFERRER (?0)
62999	DESIGN ERROR IN Z TYPE INFERRER
=SEEALSO
ZDEC, ZTM, ZSCHTEXT, IDENT, DECOR, print\_zerror, init\_zenv
=ENDDOC

\section{EPILOGUE}
=SML
end (* of local ... in *)
end (* of signature *);
=TEX

\pagebreak

\twocolumn[\section{INDEX}]
{	\footnotesize
	\printindex
}
\onecolumn

\end{document}
