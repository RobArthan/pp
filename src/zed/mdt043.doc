=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Z Language Schema Calculus}
\TPPref{DS/FMU/IED/MDT043}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
Z Language Schema Calculus and their proof support.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1,1.2]
First version.
\item[Issue 1.3 (2nd November 1992)]
Changes due to parser changes for $Ò(S[U])'Æ$ in a declaration.
\end{description}
\subsection{Changes Forecast}
None known.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD043}.
\subsection{Introduction}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD043}.
This consists of demonstrating at least the simpler uses of the 
functions in question.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP043} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
Do nothing file.
\section{TEST CASES}
The functions are tested in their order of presentation in the detailed design.
\section{PREAMBLE}
=SML
open_theory "z_sets";
delete_theory "temp" handle _ => ();
new_theory "temp";
use_file "dtd013";
use_file "imp013";
init_mt_results();
(* set_flag("subgoal_package_quiet",true); *)
repeat drop_main_goal;
set_flag("check_is_z",true);
=TEX

\subsection{Utilities}
=SML
fun €list_eq› (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
If two terms types are equal, break them apart until they differ.
=SML
fun €differ_where› itm1 itm2 = (
let	fun aux tm1 tm2 (App(f1,x1)) (App(f2,x2)) = (
		Value(force_value(aux f1 f2 (dest_simple_term f1) (dest_simple_term f2)))
		handle _ =>
		aux x1 x2 (dest_simple_term x1) (dest_simple_term x2))
	| aux tm1 tm2 (Const(nm1,ty1)) (Const(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (Var(nm1,ty1)) (Var(nm2,ty2)) = (
		if nm1 = nm2 andalso ty1 =: ty2
		then Nil
		else Value(tm1,tm2))
	| aux tm1 tm2 (SimpleÃ(x1,b1)) (SimpleÃ(x2,b2)) = (
		if x1 =$ x2 
		then aux b1 b2 (dest_simple_term b1) (dest_simple_term b2)
		else Value(tm1,tm2))
	| aux tm1 tm2 _ _ = Value(tm1,tm2);
in
	aux itm1 itm2 (dest_simple_term itm1) (dest_simple_term itm2)
end);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun €tac_res› tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun €tac_res› tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun €tac_res1› tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (rasms,gl) = top_goal()
		in
			(drop_main_goal();
			(rasms,gl))
		end);
=TEX
Now a function that returns the multiple goals for the case when a tactic causes multiple goals:
=SML
fun €tac_ress› tac n (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val gll = map (top_labelled_goal o string_of_int)
			(interval 1 n)
		in
			(drop_main_goal();
			gll)
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun €tac_solve› tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun €tac_fail› tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
\subsection{Some Useful Values}
ˇTEST_SCHEMA¸
x:U;
y:U
à
πZ
rel	px _,py _, pz _
∞
ù[X]
px _ :  X;
py _ :  X;
pz _ :  X
à

ˇS[X]¸
x:X
˜
px x
à
ˇDS[X]¸
x:X;
x':X
˜
px x ± px x'
à

=SML
val aset = Ò{a,b:X; c:Y | a Ω b ∑ (a,b,c)}Æ;
val (asetd, asetp, asetv) = dest_z_seta aset;
val atuple3 = Ò((p ∫ a),(q ∫ a),(r ∫ b))Æ;
val notz = ¨∂ x ∑ x = yÆ;
val trues = string_of_term mk_t;
val notzs = string_of_term notz;
=TEX
\section{TESTS}
=TEX
\subsection{Horizontal Schemas}
=SML
store_mt_results (mt_runf (op =$)) [("z_ç_horiz_schema_conv",
	snd o dest_eq o concl o z_ç_horiz_schema_conv,
	Ò[X] y ç [z:X; S[X]; (S[X])'| x = z]Æ,
	Ò[X] (∂ z : X; S[X]; (S[X])' | x = z ∑  [z : X; S[X]; (S[X])'] = y)Æ)];
store_mt_results mt_run_fail [("z_ç_horiz_schema_conv 43003",
	z_ç_horiz_schema_conv,
	mk_t,
	gen_fail_msg "z_ç_horiz_schema_conv" 43003 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_ç_horiz_schema_conv1",
	snd o dest_eq o concl o z_ç_horiz_schema_conv1,
	Ò[X] y ç [z:X; S[X]; ((S[X])')| x = z]Æ,
	Ò[X] ((y∫[z:X; S[X]; ((S[X])')]).z ç X ± 
		(x ¶ y.x) ç S[X] ± 
		(x' ¶ y.x') ç (S[X])') 
	± y.x = y.zÆ)];
store_mt_results mt_run_fail [("z_ç_horiz_schema_conv1 43003",
	z_ç_horiz_schema_conv1,
	mk_t,
	gen_fail_msg "z_ç_horiz_schema_conv1" 43003 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_horiz_schema_conv",
	snd o dest_eq o concl o z_horiz_schema_conv,
	Ò[X] [z:X; S[X]; (S[X])'| x = z]Æ,
	Ò[X] {z : X; S[X]; (S[X])' | x = z ∑  [z : X; S[X]; (S[X])']}Æ)];
store_mt_results mt_run_fail [("z_horiz_schema_conv 43004",
	z_horiz_schema_conv,
	mk_t,
	gen_fail_msg "z_horiz_schema_conv" 43004 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_norm_horiz_schema_conv",
	snd o dest_eq o concl o z_norm_horiz_schema_conv,
	Ò[X,Y] [x,y1:X; z: Y; p,q : U; r : U; S[X]; ((S[X])') | x1 = x]Æ,
	inst [] [(î'aÆ,î'bÆ), (î'bÆ,î'cÆ)]
	Ò[X,Y] [p : U; q : U; r : U; x : U; x' : U; y1 : U; z : U
      | (({x, y1} Ä X) ± z ç Y ± S[X] ± (S[X])') ± x1 = x]Æ)];
store_mt_results mt_run_fail [("z_norm_horiz_schema_conv 43004",
	z_norm_horiz_schema_conv,
	mk_t,
	gen_fail_msg "z_norm_horiz_schema_conv" 43004 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_horiz_schema_pred_conv a",
	snd o dest_eq o concl o z_horiz_schema_pred_conv,
	(mk_z_predsexp( Ò[X][z:X; S[X]; ((S[X])')| x = z]Æ,"")),
	Ò[X] (z ç X
      ± (x ¶ x) ç S[X]
      ± (x' ¶ x') ç (S[X])')
      ± (x ¶ x, x' ¶ x', z ¶ z).x = (x ¶ x, x' ¶ x', z ¶ z).z Æ),
	("z_horiz_schema_pred_conv b",
	snd o dest_eq o concl o z_horiz_schema_pred_conv,
	(mk_z_predsexp( Ò[zz,z:X; S; (S')| x = z]Æ,"'")),
	Ò(({z', zz'} Ä X)
      ± (x ¶ x') ç S
      ± (x' ¶ x'') ç S')
      ± (x ¶ x', x' ¶ x'', z ¶ zz', zz ¶ z').x
        = (x ¶ x', x' ¶ x'', z ¶ zz', zz ¶ z').zÆ),
	("z_horiz_schema_pred_conv c",
	snd o dest_eq o concl o z_horiz_schema_pred_conv,
	(mk_z_predsexp( mk_z_decâs(Ò[z:X; S; (S')| x = z]Æ,"'"),"")),
	Ò(z' ç X
      ± (x ¶ x') ç S
      ± (x' ¶ x'') ç S')
      ± (x ¶ x', x' ¶ x'', z ¶ z').x = (x ¶ x', x' ¶ x'', z ¶ z').zÆ)
];
store_mt_results mt_run_fail [("z_horiz_schema_pred_conv 43012",
	z_horiz_schema_pred_conv,
	mk_t,
	gen_fail_msg "z_horiz_schema_pred_conv" 43012 [trues])];
=TEX
\subsection{Schema References}
=SML
store_mt_results (mt_runf (op =$)) [("z_schema_ref_conv a",
	snd o dest_eq o concl o z_schema_ref_conv,
	ÒSÆ,
	Ò[x : U | px x]Æ),
	("z_schema_ref_conv b",
	snd o dest_eq o concl o z_schema_ref_conv,
	ÒS[V]Æ,
	Ò[x : V | px x]Æ)];
let
	val rubbish = mk_z_gvar("rubbish",type_ofÒSÆ,[]);
in
store_mt_results mt_run_fail [("z_schema_ref_conv 43011",
	z_schema_ref_conv,
	mk_t,
	gen_fail_msg "z_schema_ref_conv" 43011 [trues]),
	("z_schema_ref_conv 43013",
	z_schema_ref_conv,
	rubbish,
	gen_fail_msg "z_schema_ref_conv" 43013 [string_of_term rubbish])]
end;
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_schema_ref_pred_conv a",
	snd o dest_eq o concl o z_schema_ref_pred_conv,
	(mk_z_predsexp( ÒSÆ,"")),
	Òx ç U ± (px (x ¶ x).x)Æ),
	("z_schema_ref_pred_conv b",
	snd o dest_eq o concl o z_schema_ref_pred_conv,
	(mk_z_predsexp( ÒSÆ,"'")),
	Òx' ç U ± (px (x ¶ x').x)Æ),
	("z_schema_ref_pred_conv c",
	snd o dest_eq o concl o z_schema_ref_pred_conv,
	(mk_z_predsexp( mk_z_decâs(ÒSÆ,"'"),"")),
	Òx' ç U ± (px (x ¶ x').x)Æ)];
store_mt_results mt_run_fail [("z_schema_ref_pred_conv 43008",
	z_schema_ref_pred_conv,
	mk_t,
	gen_fail_msg "z_schema_ref_pred_conv" 43008 [trues])];
=TEX
\subsection{Operators on Schemas}
=SML
store_mt_results (mt_runf (op =$)) [("z_ _ç_schema_conv",
	snd o dest_eq o concl o z_ _ç_schema_conv,
	Ò S ç SÆ,
	mk_z_decsexp(ÒSÆ,""))];
store_mt_results mt_run_fail [("z_ _ç_schema_conv 43002",
	z_ _ç_schema_conv,
	mk_t,
	gen_fail_msg "z_ _ç_schema_conv" 43002 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_ _ç_schema_intro_conv a",
	snd o dest_eq o concl o z_ _ç_schema_intro_conv,
	(mk_z_predsexp( ÒSÆ,"")),
	Ò S ç SÆ),
	("z_ _ç_schema_intro_conv b",
	snd o dest_eq o concl o z_ _ç_schema_intro_conv,
	(mk_z_predsexp( ÒSÆ,"'")),
	Ò S' ç SÆ),
	("z_ _ç_schema_intro_conv c",
	snd o dest_eq o concl o z_ _ç_schema_intro_conv,
	(mk_z_predsexp( mk_z_decâs(Ò[X] S[X]Æ,"'"),"")),
	Ò[X] ëmk_z_ (Ò[X] (S[X])'Æ,"")Æ ç ((S[X])')Æ)];
store_mt_results mt_run_fail [("z_ _ç_schema_intro_conv 43014",
	z_ _ç_schema_intro_conv,
	mk_t,
	gen_fail_msg "z_ _ç_schema_intro_conv" 43014 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_ _conv",
	snd o dest_eq o concl o z_ _conv,
	Ò  DSÆ,
	Ò[a] (x ¶ (x ∫ a), x' ¶ (x' ∫ a))Æ)];
store_mt_results mt_run_fail [("z_ _conv 43010",
	z_ _conv,
	mk_t,
	gen_fail_msg "z_ _conv" 43010 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_ç_decâs_conv",
	snd o dest_eq o concl o z_ç_decâs_conv,
	Ò[X] p ç ë(mk_z_decâs(Ò[X] [z:X; S[X]; (S[X])'| x = z]Æ,"'"))ÆÆ,
	Ò[X] (x ¶ (p ∫ [x',x'':X; z':X]).x', x' ¶ p.x'', z ¶ p.z') ç [z : X; S[X]; (S[X])' | x = z]Æ)];
store_mt_results mt_run_fail [("z_ç_decâs_conv 43015",
	z_ç_decâs_conv,
	mk_t,
	gen_fail_msg "z_ç_decâs_conv" 43015 [trues])];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("z_preâs_conv",
	snd o dest_eq o concl o z_preâs_conv,
	Ò[X](pre (DS[X]))Æ,
	mk_z_âs (mk_z_decl[mk_z_dec([Ò[X] x ∫ XÆ], inst[][(î'XÆ,î'aÆ)]ÒUÆ)],
	mk_z_∂(mk_z_decl[mk_z_dec([Ò[X] x' ∫ XÆ], inst[][(î'XÆ,î'aÆ)]ÒUÆ)],
		mk_t,
		mk_z_predsexp(Ò[X] DS[X]Æ,"")))
		)];

store_mt_results mt_run_fail [("z_preâs_conv 43007",
	z_preâs_conv,
	mk_t,
	gen_fail_msg "z_preâs_conv" 43007 [trues]),
	("z_preâs_conv 43009",
	z_preâs_conv,
	mk_z_preâs ÒSÆ,
	gen_fail_msg "z_preâs_conv" 43009 [string_of_term (mk_z_preâs ÒSÆ)])];
=TEX
\section{PROOF CONTEXTS}
=SML
diag_string("'z_schemas NOT YET IMPLEMENTED ");
=TEX
\section{END OF TESTS}
=SML
(* set_flag("subgoal_package_quiet",false); *)
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results (mt_runf (op =$)) [("",
	tac_res ,
	ÒÆ,
	ÒÆ)];
store_mt_results (mt_runf (op =$)) [("",
	snd o dest_eq o concl o  ,
	ÒÆ,
	ÒÆ)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];
store_mt_results (mt_runf (op =#)) [("",
	tac_res1 ,
	([ÒÆ],ÒÆ),
	([ÒÆ],ÒÆ))];
store_mt_results (mt_runf (list_eq(op =#))) [("",
	tac_ress  2,
	([ÒÆ],ÒÆ),
	[([ÒÆ],ÒÆ),([ÒÆ],ÒÆ)])];
store_mt_results mt_runf [
	("",
	tac_solve ,
	([],ÒÆ),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],ÒÆ),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];

