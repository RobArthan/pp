=IGN
********************************************************************************
imp085.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp085.doc   ‚Ñ§ $Date: 2003/07/16 15:20:12 $ $Revision: 1.10 $ $RCSfile: imp085.doc,v $
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Implementation of the Z Library Functions}

\def\AbstractText{This document contains the implementation of the Z Library Functions and their proof support.}

\def\Reference{DS/FMU/IED/IMP085}

\def\Author{D.J. King}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: % TQtemplate.tex
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
\def\Hide#1{}
%% LaTeX2e port: \def\Bool{``$\it{:}bool\,$''}
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{FST PROJECT}  %% Mandatory field
%% LaTeX2e port: %\TPPvolume{}
%% LaTeX2e port: %\TPPpart{}
%% LaTeX2e port: \TPPtitle{Implementation of the Z Library Functions}  %% Mandatory field
%% LaTeX2e port: \TPPref{DS/FMU/IED/IMP085}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{$Revision: 1.10 $%
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{\FormatDate{$Date: 2003/07/16 15:20:12 $%
%% LaTeX2e port: }}
%% LaTeX2e port: \TPPstatus{Draft}			%% Mandatory field
%% LaTeX2e port: \TPPtype{Specification}
%% LaTeX2e port: \TPPkeywords{HOL}
%% LaTeX2e port: \TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%% LaTeX2e port: %\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%% LaTeX2e port: \TPPauthorisation{R.D.~Arthan & FST Team Leader}
%% LaTeX2e port: \TPPabstract{This document contains the implementation of
%% LaTeX2e port: the Z Library Functions and their proof support.}
%% LaTeX2e port: %\TPPabstractB{}
%% LaTeX2e port: %\TPPabstractC{}
%% LaTeX2e port: %\TPPabstractD{}
%% LaTeX2e port: %\TPPabstractE{}
%% LaTeX2e port: %\TPPabstractF{}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port:       Library}}
%% LaTeX2e port: 
%% LaTeX2e port: %\TPPclass{CLASSIFICATION}
%% LaTeX2e port: %\def\TPPheadlhs{}
%% LaTeX2e port: %\def\TPPheadcentre{}
%% LaTeX2e port: %def\TPPheadrhs{}
%% LaTeX2e port: %\def\TPPfootlhs{}
%% LaTeX2e port: %\def\TPPfootcentre{}
%% LaTeX2e port: %\def\TPPfootrhs{}
%% LaTeX2e port: 
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \TPPsetsizes
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: 
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: 
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: 
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (1992/10/28) (22nd October 1992)]
First version, derived from 078 and 083.
\item [Issue 1.2 (1992/11/12), 12th November 1992]
Changes as a consequence of changes in dependences.
\item[Issue 1.4 (1992/12/11) (11th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.5 (1993/02/10)-1.6 (1993/02/12) (8th-12th February 1993)]
Rearranging proof contexts.
\item[Issue 1.8 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.9 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.10 (2003/07/16)] Cured theorems that used to have free variables.
\item[Issue 1.11 (2004/01/19)] The Z universal set is now called ùïå.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

\item[2015/04/17]
Ported PPZed to Lemma 1 document template.

\item[2025/03/05]
Added theorem for pushing function application through a conditional.
%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library functions
given in \cite{DS/FMU/IED/DTD085}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD085}.
\subsection{Dependencies}
The mathematical toolkit for Z Library functions is introduced within the structure
$ZFunctions$ which is constrained by the signature of the same name, specified
in \cite{DS/FMU/IED/DTD085}.

\subsection{Interface}
The interface for the structure is defined by the signature $ZFunctions$
(see\cite{DS/FMU/IED/DTD085}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{THE STRUCTURE $ZFunctions$}
\section{PREAMBLE}
Structure done in two parts.
=SML
structure ‚¶èZFunctions‚¶é : ZFunctions = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory ‚¶è"z_functions"‚¶é;
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples","'z_‚àà_rel"];
val _ = set_flag("z_type_check_only",false);
=TEX
Get the definitions out:

=SML
	val z_‚Üí_def = get_spec ‚ì©(_ ‚Üí _)‚åù;
	val z_‚á∏_def = get_spec ‚ì©(_ ‚á∏ _)‚åù;
	val z_‚§î_def = get_spec ‚ì©(_ ‚§î _)‚åù;
	val z_‚Ü£_def = get_spec ‚ì©(_ ‚Ü£ _)‚åù;
	val z_‚§Ä_def = get_spec ‚ì©(_ ‚§Ä _)‚åù;
	val z_‚Ü†_def = get_spec ‚ì©(_ ‚Ü† _)‚åù;
	val z_‚§ñ_def = get_spec ‚ì©(_ ‚§ñ _)‚åù;
=TEX
=SML
val ‚¶èUa‚¶é = ‚ì©ùïå‚åù; (* type = 'a SET *)
val ‚¶èUb‚¶é = inst [] [(‚ì£'b‚åù,‚ì£'a‚åù)] Ua;
=TEX
=SML
val dummy = push_merge_pcs ["z_sets_ext", "'z_tuples"];
local
	val spec = (rewrite_rule[] z_‚á∏_def);
	val s1 = rewrite_conv [spec] ‚ì©f ‚àà (X ‚á∏ Y)‚åù;
in
val ‚¶èz_‚á∏_thm‚¶é = save_thm("z_‚á∏_thm",
 	pure_rewrite_rule[z_‚Ü¶_thm]
	(all_z_‚àÄ_intro s1));
end;
val dummy = pop_pc();
=TEX
=SML
val ‚¶èz_‚á∏_thm1‚¶é = save_thm("z_‚á∏_thm1",(
push_goal([],
	‚ì©‚àÄ f : ùïå; X : ùïå; Y : ùïå
          ‚¶Å f ‚àà (X ‚á∏ Y)
            ‚áî (f ‚àà (X ‚Üî Y)
              ‚àß (‚àÄ x : ùïå; y1, y2 : ùïå |
		x ‚àà X ‚àß y1 ‚àà Y ‚àß y2 ‚àà Y
                ‚¶Å (x, y1) ‚àà f ‚àß (x, y2) ‚àà f ‚áí y1 = y2))‚åù);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z_‚àà_rel"];
a(rewrite_tac[z_‚á∏_thm]);
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(asm_fc_tac[]);
(* *** Goal "5" *** *)
a(asm_fc_tac[]);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[]);
pop_pc();
pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]z_‚Üí_def);
	val s1 = rewrite_conv [spec] ‚ì©f ‚àà (X ‚Üí Y)‚åù;
	val s3 = (
push_goal([],‚ì©f ‚àà (X ‚Üí Y) ‚áî f ‚àà (X ‚á∏ Y) ‚àß dom f = X‚åù);
push_merge_pcs ["z_sets_ext", "'z_tuples","'z_‚àà_rel"];
a(rewrite_tac[z_‚á∏_thm, s1, z_dom_thm, z_‚Ü¶_thm]);
a(REPEAT strip_tac THEN_TRY_T(SOLVED_T (all_asm_fc_tac[])));
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 ‚ì©x‚åù);
a(z_spec_nth_asm_tac 1 ‚ì©y1‚åù);
a(z_spec_nth_asm_tac 2 ‚ì©y2‚åù);
a(all_var_elim_asm_tac THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ‚ì©x1‚åù);
a(z_‚àÉ_tac ‚ì©y‚åù);
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ‚ì©x‚åù);
(* *** Goal "3.1" *** *)
a(asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(z_‚àÉ‚ãé1_tac ‚ì©y‚åù);
a(z_spec_nth_asm_tac 5 ‚ì©(x1 ‚âú x, x2 ‚âú y)‚åù);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 ‚ì©(x ‚âú x, y1 ‚âú y', y2 ‚âú y)‚åù);
pop_pc();
pop_thm());
in
val ‚¶èz_‚Üí_thm‚¶é = save_thm("z_‚Üí_thm", all_z_‚àÄ_intro s3);
end;
=TEX
=SML
val _ = push_merge_pcs ["z_sets_alg", "'z_tuples"];
local
	val spec = (rewrite_rule[]z_‚§î_def);
	val s1 = rewrite_conv [spec] ‚ì©f ‚àà (X ‚§î Y)‚åù;
	val s3 = prove_rule[s1] ‚ì©‚àÄ f: ùïå;
	X: ùïå; Y: ùïå‚¶Å
	f ‚àà X ‚§î Y
      ‚áî f ‚àà X ‚á∏ Y ‚àß (‚àÄ x1, x2 : ùïå |
		x1 ‚àà dom f ‚àß x2 ‚àà dom f ‚¶Å f x1 = f x2 ‚áí x1 = x2)‚åù;
in
val ‚¶èz_‚§î_thm‚¶é = save_thm("z_‚§î_thm", s3);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_‚Ü£_def);
	val s1 = rewrite_conv [spec, z_‚à©_thm, z_‚§î_thm] ‚ì©f ‚àà (X ‚Ü£ Y)‚åù;
	val s2 = (
push_goal([], ‚ì©f ‚àà (X ‚Ü£ Y) ‚áî f ‚àà (X ‚Üí Y) ‚àß
	(‚àÄ x1, x2 :ùïå |
		x1 ‚àà dom f ‚àß x2 ‚àà dom f ‚¶Å f x1 = f x2 ‚áí x1 = x2)‚åù);
a(rewrite_tac[s1, z_‚Üí_thm]);
a(taut_tac);
pop_thm());
in
val ‚¶èz_‚Ü£_thm‚¶é = save_thm("z_‚Ü£_thm", all_z_‚àÄ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_‚§Ä_def);
	val s1 = rewrite_conv [spec] ‚ì©f ‚àà (X ‚§Ä Y)‚åù;
in
val ‚¶èz_‚§Ä_thm‚¶é = save_thm("z_‚§Ä_thm", all_z_‚àÄ_intro s1);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_‚Ü†_def);
	val s1 = rewrite_conv [spec, z_‚à©_thm, z_‚§Ä_thm] ‚ì©f ‚àà (X ‚Ü† Y)‚åù;
	val s2 = (
push_goal([],
	‚ì©f ‚àà (X ‚Ü† Y) ‚áî f ‚àà (X ‚Üí Y) ‚àß ran f = Y‚åù);
a(rewrite_tac[s1, z_‚Üí_thm]);
a(taut_tac);
pop_thm());
in
val ‚¶èz_‚Ü†_thm‚¶é = save_thm("z_‚Ü†_thm", all_z_‚àÄ_intro s2);
end;
=TEX
=SML
local
	val spec = (rewrite_rule[]z_‚§ñ_def);
	val s1 = rewrite_conv [spec, z_‚à©_thm, z_‚Ü†_thm, z_‚Ü£_thm] ‚ì©f ‚àà (X ‚§ñ Y)‚åù;
	val s2 = (prove_rule[s1]
	‚ì©f ‚àà (X ‚§ñ Y) ‚áî f ‚àà (X ‚Üí Y) ‚àß ran f = Y ‚àß
	   (‚àÄ x1, x2 : ùïå | x1 ‚àà dom f ‚àß x2 ‚àà dom f ‚¶Å
	    f x1 = f x2 ‚áí x1 = x2)‚åù);
in
val ‚¶èz_‚§ñ_thm‚¶é = save_thm("z_‚§ñ_thm", all_z_‚àÄ_intro s2);
end;
val _ = pop_pc();
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
local
	val cnv1 = simple_eq_match_conv1 (
		conv_rule z_‚àÄ_elim_conv1 z_sets_ext_thm);
in
fun ‚¶èmake_‚àà_rule‚¶é thm = all_‚àÄ_intro
	(conv_rule z_‚àÄ_elim_conv1
	(conv_rule cnv1
	(all_‚àÄ_elim
	(conv_rule(TRY_C z_‚àÄ_elim_conv1) thm))));
end;
=TEX
=SML
fun ‚¶èmake_pair_trio_rule‚¶é thm = (
let	val s1 = all_‚àÄ_intro
		(conv_rule (MAP_C z_sel‚ãét_conv)
		(‚àÄ_elim ‚ì©(p1,p2)‚åù
		(all_‚àÄ_intro
		(all_‚àÄ_elim
		(conv_rule z_‚àÄ_elim_conv1 thm)))));
	val s2 = all_‚àÄ_intro
		(conv_rule (MAP_C z_sel‚ãét_conv)
		(‚àÄ_elim ‚ì©(p1 ‚Ü¶ p2)‚åù (all_‚àÄ_intro
		(all_‚àÄ_elim
		(conv_rule z_‚àÄ_elim_conv1 thm)))));
in
	list_‚àß_intro [thm, s1, s2]
end);
=TEX
=SML
val ‚¶è‚àà_operator_clauses2‚¶é = [
	z_‚§Ä_thm, z_‚Ü†_thm, z_‚§ñ_thm,
	z_‚§î_thm, z_‚Ü£_thm, z_‚á∏_thm1, z_‚Üí_thm];
=TEX
=SML
fun ‚¶èthms_to_eqn_cxt‚¶é (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX
\subsection{Treatment of Membership of Functions}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_‚àà_fun" handle Fail _ => ();
val _ = new_pc "'z_‚àà_fun";
val _ = set_rw_eqn_cxt []"'z_‚àà_fun";
val _ = add_rw_thms
	([]
	@ ‚àà_operator_clauses2) "'z_‚àà_fun";

val pos = (thms_to_eqn_cxt ‚àà_operator_clauses2)
	@ [];
val neg = map (mk_¬¨ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_‚àà_fun";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_‚àà_fun";
val _ = set_rw_canons [] "'z_‚àà_fun";
val _ = set_pr_tac z_basic_prove_tac "'z_‚àà_fun";
val _ = set_pr_conv z_basic_prove_conv "'z_‚àà_fun";
val _ = set_cs_‚àÉ_convs [] "'z_‚àà_fun";
val _ = set_‚àÉ_vs_thms [] "'z_‚àà_fun";
val _ = commit_pc "'z_‚àà_fun";

=TEX
\section{ADDITIONAL WORK}
This material relies on the just created proof contexts.
=SML
val ‚¶èz_ext_pcs‚¶é = ["z_sets_ext", "'z_‚àà_rel", "'z_‚àà_fun", "'z_tuples"];
val ‚¶èz_‚Üí_app_thm‚¶é = (
push_merge_pcs z_ext_pcs;
set_goal([],‚ì©‚àÄ X:ùïå; Y:ùïå;
	f: ùïå; x:ùïå‚¶Å
	f ‚àà X ‚Üí Y ‚àß x ‚àà X ‚áí f x ‚àà Y ‚àß (x, f x) ‚àà f‚åù);
a(z_strip_tac THEN z_strip_tac THEN z_strip_tac);
a(z_spec_nth_asm_tac 2 ‚ì©x‚åù);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ‚ì©f x = y‚åù);
(* *** Goal "2.1" *** *)
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 6  ‚ì©(x1 ‚âú x, x2 ‚âú f_a)‚åù);
a(z_spec_nth_asm_tac 7  ‚ì©(x1 ‚âú x, x2 ‚âú y)‚åù);
a(asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(z_spec_nth_asm_tac 6 ‚ì©(x1 ‚âú x, x2 ‚âú y)‚åù);
pop_pc();
save_thm ("z_‚Üí_app_thm",pop_thm()));
=TEX
=SML
val _ = set_merge_pcs ["z_sets_alg", "'z_‚àà_rel", "'z_‚àà_fun", "'z_tuples"];
=TEX
=SML
local
val s1 = conv_rule z_para_pred_conv z_first_def;
val s2 = ‚àß_left_elim (list_‚àÄ_elim[Ua,Ub] s1);
val s3 = s2;
val s4 = z_‚àÄ_elim ‚ì©(X ‚âú ((ùïå ‚¶Ç ‚Ñô a) √ó (ùïå ‚¶Ç ‚Ñô b)),
		Y ‚âú (ùïå ‚¶Ç ‚Ñô a), f ‚âú first[(ùïå ‚¶Ç ‚Ñô a),(ùïå ‚¶Ç ‚Ñô b)],
		x ‚âú (x ‚¶Ç (a √ó b)))‚åù z_‚Üí_app_thm;
val s5 = pure_rewrite_rule [s3] s4;
val s6 = rewrite_rule[]  s5;
val s7 = all_‚àÄ_intro s6;
val s8 = z_‚àÄ_elim ‚ì©(X ‚âú ((ùïå ‚¶Ç ‚Ñô a) √ó (ùïå ‚¶Ç ‚Ñô b)),
		Y ‚âú (ùïå ‚¶Ç ‚Ñô b), f ‚âú second[(ùïå ‚¶Ç ‚Ñô a),(ùïå ‚¶Ç ‚Ñô b)],
		x ‚âú (x ‚¶Ç (a √ó b)))‚åù z_‚Üí_app_thm;
val s9 = pure_rewrite_rule [s3] s8;
val s10 = rewrite_rule[]  s9;
val s11 = all_‚àÄ_intro s10;
in
val ‚¶èz_‚àà_first_thm‚¶é = (
set_goal([],‚ì©‚àÄ x : ùïå ‚¶Å x ‚àà first ‚áî x.1.1 = x.2‚åù);
push_merge_pcs z_ext_pcs;
a(REPEAT z_strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(‚àß_left_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_sel‚ãét_intro_conv)));
a(strip_asm_tac(‚àÄ_elim ‚ì©x.1‚åù s7));
a(z_spec_nth_asm_tac 4  ‚ì©(x ‚âú x.1, y1 ‚âú x.1.1, y2 ‚âú x.2)‚åù);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_sel‚ãét_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s7]);
save_thm("z_‚àà_first_thm",pop_thm()));

val ‚¶èz_‚àà_second_thm‚¶é = (
set_goal([],‚ì©‚àÄ x : ùïå ‚¶Å x ‚àà second ‚áî x.1.2 = x.2‚åù);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(‚àß_right_elim s3));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule(LEFT_C z_sel‚ãét_intro_conv)));
a(strip_asm_tac(‚àÄ_elim ‚ì©x.1‚åù s11));
a(z_spec_nth_asm_tac 4  ‚ì©(x ‚âú x.1, y1 ‚âú x.1.2, y2 ‚âú x.2)‚åù);
(* *** Goal "2" *** *)
a(conv_tac(LEFT_C (z_sel‚ãét_intro_conv)));
a(POP_ASM_T(pure_rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[s11]);
pop_pc();
save_thm("z_‚àà_second_thm",pop_thm()));
end;
=TEX
=SML
val  ‚¶èz_‚Üí_app_‚àà_rel_thm‚¶é = save_thm("z_‚Üí_app_‚àà_rel_thm", (
push_goal([], ‚ì©‚àÄX: ùïå; Y : ùïå‚¶Å‚àÄf : X ‚Üí Y; x : X‚¶Å(x, f x) ‚àà f‚åù);
a(REPEAT strip_tac);
a(all_fc_tac[z_‚Üí_app_thm]);
pop_thm()
));
=TEX
=SML
val  ‚¶èz_‚Üí_app_eq_‚áî_‚àà_rel_thm‚¶é = save_thm("z_‚Üí_app_eq_‚áî_‚àà_rel_thm", (
push_goal([], ‚ì©‚àÄX: ùïå; Y : ùïå‚¶Å‚àÄf : X ‚Üí Y; x : X; z : ùïå‚¶Åf x = z ‚áî (x, z) ‚àà f‚åù);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(all_fc_tac[z_‚Üí_app_‚àà_rel_thm]);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN MERGE_PCS_T1 z_ext_pcs REPEAT strip_tac);
a(z_app_eq_tac);
a(REPEAT strip_tac);
a(MERGE_PCS_T1 z_ext_pcs all_asm_fc_tac[] THEN all_asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val  ‚¶èz_‚Üí_‚àà_rel_‚áî_app_eq_thm‚¶é = save_thm("z_‚Üí_‚àà_rel_‚áî_app_eq_thm", (
push_goal([], ‚ì©‚àÄX: ùïå; Y : ùïå‚¶Å‚àÄf : X ‚Üí Y; x : X; z : ùïå‚¶Å(x, z) ‚àà f ‚áî f x = z‚åù);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN accept_tac z_‚Üí_app_eq_‚áî_‚àà_rel_thm);
pop_thm()
));
=TEX
\subsection{Simplification}
=SML
val _ = push_merge_pcs ["z_sets_ext", "'z_‚àà_rel", "'z_‚àà_fun", "'z_tuples"];

val ‚¶èz_‚á∏_clauses‚¶é = save_thm("z_‚á∏_clauses", (
	prove_rule [] ‚ì©‚àÄ Y:ùïå ‚¶Å
	{} ‚á∏ Y = {{}} ‚àß
	Y ‚á∏ {} = {{}}‚åù));
=TEX
=SML
val ‚¶èz_‚Üí_clauses‚¶é = save_thm("z_‚Üí_clauses", (
set_goal( [], ‚ì©‚àÄ Y:ùïå ‚¶Å
	{} ‚Üí Y = {{}} ‚àß
	Y ‚Üí {} = {x: ùïå | x = {} ‚àß Y = {}}‚åù);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(‚áí_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val ‚¶èz_‚§î_clauses‚¶é = save_thm("z_‚§î_clauses",
	prove_rule [] ‚ì©‚àÄ Y:ùïå ‚¶Å
	{} ‚§î Y = {{}} ‚àß
	Y ‚§î {} = {{}}‚åù);
=TEX
=SML
val ‚¶èz_‚Ü£_clauses‚¶é = save_thm("z_‚Ü£_clauses", (
set_goal( [], ‚ì©‚àÄ Y:ùïå ‚¶Å
	{} ‚Ü£ Y = {{}} ‚àß
	Y ‚Ü£ {} = {x:ùïå| x = {} ‚àß Y = {}}‚åù);
a(prove_tac[]);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(‚áí_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val ‚¶èz_‚§Ä_clauses‚¶é = save_thm("z_‚§Ä_clauses", (
set_goal( [], ‚ì©‚àÄ Y:ùïå ‚¶Å
	{} ‚§Ä Y = {x:ùïå| x = {} ‚àß Y = {}} ‚àß
	Y ‚§Ä {} = {{}}‚åù);
a(prove_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(‚áí_T rewrite_thm_tac);
pop_thm()
));

=TEX
=SML
val ‚¶èz_‚Ü†_clauses‚¶é = save_thm("z_‚Ü†_clauses", (
set_goal( [], ‚ì©‚àÄ Y:ùïå ‚¶Å
	{} ‚Ü† Y = {x:ùïå| x = {} ‚àß Y = {}} ‚àß
	Y ‚Ü† {} = {x:ùïå| x = {} ‚àß Y = {}}‚åù);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(‚áí_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(‚áí_T rewrite_thm_tac);
pop_thm()
));
=TEX
=SML
val ‚¶èz_‚§ñ_clauses‚¶é = save_thm("z_‚§ñ_clauses", (
set_goal( [], ‚ì©‚àÄ Y:ùïå ‚¶Å
	{} ‚§ñ Y = {x:ùïå| x = {} ‚àß Y = {}} ‚àß
	Y ‚§ñ {} = {x:ùïå| x = {} ‚àß Y = {}}‚åù);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
a(‚áí_T rewrite_thm_tac);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(‚áí_T rewrite_thm_tac);
pop_thm()
));

val _ = pop_pc();
=TEX
=SML
fun ‚¶èmaybe_strip‚¶é (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else fail "" 0 []
);
local
	val setty = type_of ‚ì©{}‚åù;
in
fun ‚¶èadd_‚àà‚¶é ((index,cnv)::rest) = (
	(let val tyms = type_match (type_of index) setty @ [(‚ì£'a‚åù,‚ì£'a‚åù)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		((mk_z_‚àà(x,index), ‚àà_C cnv) :: (index,cnv) :: add_‚àà rest)
	end)
	handle (Fail _) =>
	((index,cnv) :: add_‚àà rest)
) | add_‚àà [] = [];
end;

val z_fun_alg_eqn_cxt = add_‚àà(thms_to_eqn_cxt [z_‚á∏_clauses, z_‚Üí_clauses, z_‚§î_clauses,
	z_‚Ü£_clauses, z_‚Ü†_clauses, z_‚§Ä_clauses, z_‚§ñ_clauses]);

val z_fun_alg_eqn_cxt_for_strip = mapfilter maybe_strip z_fun_alg_eqn_cxt;


val _ = delete_pc "'z_fun_alg" handle Fail _ => ();
val _ = new_pc "'z_fun_alg";
val _ = set_rw_eqn_cxt z_fun_alg_eqn_cxt"'z_fun_alg";
val _ = add_rw_thms ([]) "'z_fun_alg";

val pos = z_fun_alg_eqn_cxt_for_strip;
val neg = map (mk_¬¨ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_fun_alg";
val _ = set_rw_canons [] "'z_fun_alg";
val _ = set_pr_tac z_basic_prove_tac "'z_fun_alg";
val _ = set_pr_conv z_basic_prove_conv "'z_fun_alg";
val _ = set_cs_‚àÉ_convs [] "'z_fun_alg";
val _ = set_‚àÉ_vs_thms [] "'z_fun_alg";
val _ = commit_pc "'z_fun_alg";

=TEX
=SML
val _ = delete_pc "z_fun_ext" handle Fail _ => ();
val _ = new_pc "z_fun_ext";
val _ = merge_pcs ["z_rel_ext","'z_fun_alg",
	"'z_‚àà_fun"] "z_fun_ext";
val _ = commit_pc "z_fun_ext";
=TEX
\subsection{Type Inference By Theorems}
=SML
val _ = push_pc "z_fun_ext";
=TEX
We use $z_spec_nth_asm_tac$ for speed, $all\_asm\_fc\_tac$
still works (?).
=SML
val ‚¶èz_fun_app_clauses‚¶é = save_thm("z_fun_app_clauses", (
set_goal([],‚ì©‚àÄ f:ùïå; x:ùïå;y:ùïå; X:ùïå;Y:ùïå ‚¶Å
	(f ‚àà X ‚á∏ Y ‚à® f ‚àà X ‚§î Y ‚à® f ‚àà X ‚§Ä Y ‚à®
	 f ‚àà X ‚Üí Y ‚à® f ‚àà X ‚Ü£ Y ‚à® f ‚àà X ‚Ü† Y ‚à® f ‚àà X ‚§ñ Y)
	‚àß (x,y) ‚àà f
	‚áí f x = y‚åù);
a(REPEAT strip_tac THEN all_asm_fc_tac[] THEN z_app_eq_tac
	THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 6 ‚ì©(x ‚âú x, y1 ‚âú f_a, y2 ‚âú y)‚åù);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 7 ‚ì©(x ‚âú x, y1 ‚âú f_a, y2 ‚âú y)‚åù);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 7 ‚ì©(x ‚âú x, y1 ‚âú f_a, y2 ‚âú y)‚åù);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 7 ‚ì©(x ‚âú x, y1 ‚âú f_a, y2 ‚âú y)‚åù);
(* *** Goal "5" *** *)
a(z_spec_nth_asm_tac 8 ‚ì©(x ‚âú x, y1 ‚âú f_a, y2 ‚âú y)‚åù);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 8 ‚ì©(x ‚âú x, y1 ‚âú f_a, y2 ‚âú y)‚åù);
(* *** Goal "7" *** *)
a(z_spec_nth_asm_tac 9 ‚ì©(x ‚âú x, y1 ‚âú f_a, y2 ‚âú y)‚åù);

pop_thm()));
=TEX
=SML
val ‚¶èz_fun_‚àà_clauses‚¶é = save_thm("z_fun_‚àà_clauses", (
set_goal([],‚ì©‚àÄ f:ùïå; x:ùïå; X:ùïå;Y:ùïå ‚¶Å
	((f ‚àà X ‚Üí Y ‚à® f ‚àà X ‚Ü£ Y ‚à® f ‚àà X ‚Ü† Y ‚à® f ‚àà X ‚§ñ Y)
	‚àß x ‚àà X
	‚áí f x ‚àà Y)
	‚àß
	((f ‚àà X ‚á∏ Y ‚à® f ‚àà X ‚§î Y ‚à® f ‚àà X ‚§Ä Y)
	‚àß x ‚àà dom f
	‚áí f x ‚àà Y)‚åù);
a(PC_T1 "z_sets_alg" rewrite_tac[z_dom_thm] THEN
	REPEAT (PC_T "z_sets_alg" strip_tac) THEN
	GET_NTH_ASM_T 2 strip_asm_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 1 ‚ì©x‚åù);
(* *** Goal "1.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ‚ì©x‚åù);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ‚ì©x‚åù);
(* *** Goal "3.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "4" *** *)
a(z_spec_nth_asm_tac 3 ‚ì©x‚åù);
(* *** Goal "4.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
(* *** Goal "7" *** *)
a(all_asm_fc_tac[]);
a(all_asm_fc_tac[z_fun_app_clauses]);
a(all_var_elim_asm_tac1);
pop_thm()));
=TEX
=SML
val ‚¶èz_fun_dom_clauses‚¶é = save_thm("z_fun_dom_clauses", (
set_goal([],‚ì©‚àÄ f:ùïå; X:ùïå;Y:ùïå ‚¶Å
	((f ‚àà X ‚á∏ Y ‚à® f ‚àà X ‚§î Y ‚à® f ‚àà X ‚§Ä Y)
	‚áí dom f ‚äÜ X)
 	‚àß
	((f ‚àà X ‚Üí Y ‚à® f ‚àà X ‚Ü£ Y ‚à® f ‚àà X ‚Ü† Y ‚à® f ‚àà X ‚§ñ Y)
	‚áí dom f = X)‚åù);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(z_spec_nth_asm_tac 2 ‚ì©x1‚åù);
(* *** Goal "5.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 3 ‚ì©x1‚åù THEN all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(z_spec_nth_asm_tac 3 ‚ì©x1‚åù);
(* *** Goal "7.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "7.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "8" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "9" *** *)
a(z_spec_nth_asm_tac 3 ‚ì©x1‚åù);
(* *** Goal "9.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "9.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "10" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "11" *** *)
a(z_spec_nth_asm_tac 4 ‚ì©x1‚åù);
(* *** Goal "11.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "11.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);

pop_thm()));
=TEX
=SML
val ‚¶èz_fun_ran_clauses‚¶é = save_thm("z_fun_ran_clauses", (
set_goal([],‚ì©‚àÄ f:ùïå; X:ùïå;Y:ùïå ‚¶Å
	((f ‚àà X ‚Üí Y ‚à® f ‚àà X ‚á∏ Y ‚à® f ‚àà X ‚§î Y ‚à® f ‚àà X ‚Ü£ Y)
	‚áí ran f ‚äÜ Y)
	‚àß
	((f ‚àà X ‚§Ä Y ‚à® f ‚àà X ‚Ü† Y ‚à® f ‚àà X ‚§ñ Y)
	‚áí ran f = Y)‚åù);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(z_spec_nth_asm_tac 2 ‚ì©x1‚åù);
(* *** Goal "6.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "8" *** *)
a(z_spec_nth_asm_tac 2 ‚ì©x1‚åù);
(* *** Goal "8.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "8.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "9" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "10" *** *)
a(z_spec_nth_asm_tac 3 ‚ì©x1‚åù);
(* *** Goal "10.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "10.2" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
pop_thm()));
=TEX
=SML
val ‚¶èz_fun_app_if_thm‚¶é : THM = (
set_goal([], ‚ì©‚àÄf : ùïå; c : ùïå; x, y : ùïå‚¶Å
	f(if c then x else y) = if c then f x else f y‚åù);
a(REPEAT strip_tac);
a(cases_tac ‚ì©c‚åù THEN asm_rewrite_tac[]);
save_pop_thm "z_fun_app_if_thm"
);
=TEX
=SML
val _ = pop_pc();
=TEX
\section{EPILOG}
=SML
end (* of structure ZFunctions *);
open ZFunctions;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}

