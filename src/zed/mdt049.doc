=IGN
********************************************************************************
mdt049.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  %Z% $Revision: 1.21 $ $RCSfile: mdt049.doc,v $ $Date: 2011/07/11 11:44:45 $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Paragraphs}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT049}  %% Mandatory field
\def\SCCSversion{$Revision: 1.21 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2011/07/11 11:44:45 $
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Z paragraph processor described in the document
DS/FMU/IED/DTD065.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.2]
First draft.
\item[Issue 1.3 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.

\item[Issue 1.4 (7th May 1994)]
Set the proof context to $z\_predicates$ - to enable the tests to run without having run other module tests prior to these.
\item[Issue 1.5 (31st October 1994)]
Tests for storage of conjecture in the theory database added.
\item[Issue 1.6]
Specific tests for bug fixes added.
\item[Issue 1.7]
Typos.
\item[Issue 1.8]
Changes to match version 1.43 of implementation document.
\item[Issue 1.9]
Ignored warnings where necessary.
\item[Issue 1.10]
Tests treatment of mutually recursive free types.
\item[Issue 1.11]
Tests for changed effect of flags.
\item[Issue 1.12]
Changed to always use a new cache theory.
\item[Issue 1.13] Copyright and banner updates for open source release.
\item[Issue 1.14] PPZed-specific updates for open source release
\item[Issue 1.15] Allowed for the paragraph processor leaving cache theory handling to
the semantic constant generators.
\item[Issue 1.16] The Z universal set is now called ƒ.
\item[Issue 1.17] Modified some fixity paragraphs to check new syntax.
\item[Issue 1.18] Type constructors for given sets are now in Z namespace and the treatment of given sets with constraints has been corrected.
Adapted tests to allow for new type constructor names and to test given sets with constraints.
\item[Issue 1.19] Allowed for changes to {\em force\_get\_cache\_theory}.
\item[Issue 1.20] Allowed for changes to lexical rules for underscores.
\item[Issue 1.21] Added tests for empty schemas in paragraphs.
\item[Issue 1.22] Allowed for changes to HOL error messages.
\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the Z paragraph processor as specified in \cite{DS/FMU/IED/DTD049}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Z theory lister
as defined in \cite{DS/FMU/IED/DTD049} and implemented
in \cite{DS/FMU/IED/IMP049}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
The tests require the theory $z\_sequences$ defined in \cite{DS/FMU/IED/DTD078}
to be present (and, as a consequence they can and do expect all of the
rest of the user interface and much of the proof support to be in place).

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

None known.

\section{TEST CASES}
\begin{description}
\item[Paragraphs.1]
Checks all paragraph forms in type-check only mode
\item[Paragraphs.2]
Checks all paragraph forms in axiomatic proof mode
\item[Paragraphs.3]
Checks all paragraph forms in conservative proof mode
\item[Paragraphs.4]
Error cases for paragraph forms in all three modes.
\item[Paragraphs.5]
Term processing --- correct operation
\item[Paragraphs.6]
Term processing --- error cases
\item[Paragraphs.7]
Spot checks on some specific features which the ``systematic'' coverage
of the other groups did not check out in detail.
\item[Paragraphs.8]
Specific tests for bug fixes and enhancements
\end{description}

Mutually recursive free types are only tested in groups 1 and 2 because they are handled axiomatically even in conservative mode.

Because of the dependencies mentioned above, an attempt is made to protect
the tests against the case when errors during a system build mean that
these dependences are unsatisfied. However, this is in itself hard to test! 
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
val my_z_other_recogniser = ref z_other_recogniser;
val my_z_genbox_recogniser = ref z_genbox_recogniser;
val my_z_axbox_recogniser = ref z_axbox_recogniser;
val my_z_term_recogniser = ref  z_term_recogniser;
val my_open_theory = ref open_theory;
val my_new_theory = ref new_theory;

fun z_other_recogniser x = ! my_z_other_recogniser x;
fun z_genbox_recogniser x = ! my_z_genbox_recogniser x;
fun z_axbox_recogniser x = ! my_z_axbox_recogniser x;
fun z_term_recogniser x = !  my_z_term_recogniser x;
fun open_theory x = !  my_open_theory x;
fun new_theory x = !  my_new_theory x;


val z_sequence_ok = (open_theory "z_sequences"; true) handle (Fail _) => false;
if z_sequence_ok
then ()
else (
	my_z_other_recogniser := (fn _ => ());
	my_z_genbox_recogniser := (fn _ => ());
	my_z_axbox_recogniser := (fn _ => ());
	my_open_theory := (fn _ => ());
	my_new_theory := (fn _ => ());
	my_z_term_recogniser := (fn _ => mk_t)
);
(set_cache_theories ((get_cache_theories()) less "mdt049_cache" 
	less "mdt049_tco"); ());
force_delete_theory "mdt049_cache" handle _ => ();
(mapfilter lock_theory (get_cache_theories()); ());
(new_theory"mdt049_cache";
	set_cache_theories ("mdt049_cache":: get_cache_theories()); ());
=TEX
\section{THE TESTS}
\subsection{Group 1}
This group checks all paragraph forms in type-check only mode
=SML
set_flag("z_type_check_only", true);
open_theory"z_sequences";
set_pc "z_predicates";
force_delete_theory "mdt049_tco" handle _ => ();
new_theory"mdt049_tco";
=TEX
¹Z
fun 10 twice _
°
¹Z
gen _ swap _
°
¹Z
rel  (_ is_even)
°
¹Z
X swap Y ¦ Y ¸ X 
°
ÿSch1
ˆ
ÿSch2
÷
	false
ˆ
ÿSch3
	x, y, z : ú
÷
	x = y ² y = z
ˆ
¹ZAX
	twice _ : ú ­ ú
÷
	µi : ú · twice i = 2*i
°
¹ZAX
	_ is_even : ðú
÷
	( _ is_even) = ran (twice _)
°
[A, B, C]
	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷
	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆ
¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°
¹Z
Ü YIN ::= YinSeed | Yin (YANG)
Ü &
Ü YANG ::= YangSeed | Yang (YIN)
°
¹Z
[G1, G2]
°
¹Z
[G3, G4] & (µx, y : G3· x = y) ± (¶x, y : G4·³x = y)
°
[A, B, C]
ˆ
[X]
÷
 (¶f : X à G1 · true) ¤ (¶f : X à G2 · true)
ˆ
¹Z
[X] ((¶f : X à G1 · true) ¤ (¶f : X à G2 · true))
°
¹ZAX
°
¹ZAX
÷
 {1} swap {§1¢} = {§1¢} ¸ {1} ± Sch3 ½ [x, y, z : ú]
°
¹Z
 {1} swap {§1¢} = {§1¢} ¸ {1} ± Sch3 ½ [x, y, z : ú] 
°
¹ZAX
÷
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))  (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú) ±
 Yang(YinSeed) ½ YangSeed  YANG ±
 Yin(YangSeed) ½ YinSeed  YIN
°
¹Z
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))  (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú) ±
 Yang(YinSeed) ½ YangSeed  YANG ±
 Yin(YangSeed) ½ YinSeed  YIN
°
¹Z
Ü ?ô tip ½ fork(2, tip, tip)
°
=SML
fun name_of c = (
	let	val (n, _, _) = dest_z_gvar c;
	in	 n
	end
);
=TEX
We don't look very hard at the results, since we wouldn't have got here
if much had gone wrong, because we have arranged to have an application of
each one of the global variables from each form of paragraph in a subsequent
paragraph.
=SML
store_mt_results_show mt_run [
	("mdt049.1", map name_of o rev o get_consts, "-",
		["_ swap _", "Sch1", "Sch2", "Sch3", "twice _", "_ is_even", "cycle", "TREE", "tip", "fork",
"YIN", "YANG", "YinSeed", "Yin", "YangSeed", "Yang", "G1", "G2", "G3", "G4"])
];
=TEX
This should not cause our cache theory to become a parent:
=SML
store_mt_results_show mt_run [
	("mdt049.1.cache", (fn ps => "mdt049_cache" mem ps),
		get_parents "-", false)
];
=TEX

\subsection{Group 2}
This group checks all paragraph forms in axiomatic mode
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
open_theory"z_sequences";
force_delete_theory "mdt049_ax" handle _ => ();
new_theory"mdt049_ax";
=TEX
=SML
¹Z
fun 10 twice _
°
¹Z
gen (_ swap _)
°
¹Z
rel  _ is_even 
°
¹Z
X swap Y ¦ Y ¸ X 
°
ÿSch1
ˆ
ÿSch2
÷
	false
ˆ
ÿSch3
	x, y, z : ú
÷
	x = y ² y = z
ˆ
¹ZAX
	twice _ : ú ­ ú
÷
	µi : ú · twice i = 2*i
°
[A, B, C]
	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷
	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆ
¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°
¹Z
Ü YIN ::= YinSeed | Yin (YANG)
Ü &
Ü YANG ::= YangSeed | Yang (YIN)
°
¹Z
[G1, G2]
°
¹Z
[G3, G4] & (µx, y : G3· x = y) ± (¶x, y : G4·³x = y)
°
[A, B, C]
ˆ
[X]
÷
 (¶f : X à G1 · true) ¤ (¶f : X à G2 · true)
ˆ
¹Z
[X] ((¶f : X à G1 · true) ¤ (¶f : X à G2 · true))
°
=SML
(*
set_flag("z_allow_free_vars_in_axioms",true);
get_axiom "-" "Constraint 1";
*)
¹ZAX
°
¹ZAX
÷
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))  (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú) ±
 Yang(YinSeed) ½ YangSeed  YANG ±
 Yin(YangSeed) ½ YinSeed  YIN
°
¹Z
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))  (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú) ±
 Yang(YinSeed) ½ YangSeed  YANG ±
 Yin(YangSeed) ½ YinSeed  YIN
°
¹Z
Ü ?ô tip ½ fork(2, tip, tip)
°
=SML
store_mt_results_show mt_run [
	("mdt049.2.1", map name_of o rev o get_consts, "-",
		["_ swap _", "Sch1", "Sch2", "Sch3", "twice _", "cycle", "TREE", "tip", "fork",
"YIN", "YANG", "YinSeed", "Yin", "YangSeed", "Yang", "G1", "G2", "G3", "G4"])
];
=TEX
Now we check that the axioms/definitions are correct.
First check the conclusions of the results of $z\_get\_spec$ on one
of everything.
=SML
val g1_spec = ñG1 = ƒ®;
val tree_type_spec = ñTREE = ƒ®;
val tree_cons_spec = ñ(tip  TREE
    ± fork  î ¸ TREE ¸ TREE à TREE)
    ± disjoint §{tip}, ran fork¢
    ± (µ W : ð TREE | {tip} À fork ¨ î ¸ W ¸ W © € W · TREE € W)®;
val yin_spec = ñYIN = ƒ®;
val yang_spec = ñYANG = ƒ®;
val yin_yang_cons_spec = ñ(YinSeed  YIN
    ± Yin  YANG à YIN
    ± YangSeed  YANG
    ± Yang  YIN à YANG)
    ± disjoint §{YinSeed}, ran Yin¢
    ± disjoint §{YangSeed}, ran Yang¢
    ± (µ W1 : ð YIN; W2 : ð YANG
      | {YinSeed} À Yin ¨ W2 © € W1 ± {YangSeed} À Yang ¨ W1 © € W2
      · YIN € W1 ± YANG € W2)®;
val twice_spec = ñ(twice _)  ú ­ ú ± (µ i : ú · twice i = 2 * i)®;
val swap_spec = ¬µ X : 'X SET; Y : 'Y SET· ñX swap Y = Y ¸ X®®;
val sch1_spec = ñSch1 = []®;
val sch2_spec = ñSch2 = [ | false]®;
val sch3_spec = ñSch3 = [x, y, z : ú | x = y ² y = z]®;
val cycle_spec = ¬
	µ A : 'A SET; B : 'B SET; C : 'C SET
  · ñcycle[A, B, C]  A ¸ B ¸ C ­ C ¸ A ¸ B
      ± (µ x : A; y : B; z : C · cycle[A, B, C] (x, y, z) = (z, x, y))®®;
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.2.2.1", snd o dest_thm o z_get_spec, ñG1®, g1_spec),
	("mdt049.2.2.2", snd o dest_thm o z_get_spec, ñTREE®, tree_type_spec),
	("mdt049.2.2.3", snd o dest_thm o z_get_spec, ñtip®, tree_cons_spec),
	("mdt049.2.2.4", snd o dest_thm o z_get_spec, ñfork®, tree_cons_spec),
	("mdt049.2.2.5", snd o dest_thm o z_get_spec, ñ(twice _)®, twice_spec),
	("mdt049.2.2.6", snd o dest_thm o z_get_spec, ñ(_ swap _)®, swap_spec),
	("mdt049.2.2.7", snd o dest_thm o z_get_spec, ñcycle®, cycle_spec),
	("mdt049.2.2.8", snd o dest_thm o z_get_spec, ñSch1®, sch1_spec),
	("mdt049.2.2.9", snd o dest_thm o z_get_spec, ñSch2®, sch2_spec),
	("mdt049.2.2.10", snd o dest_thm o z_get_spec, ñSch3®, sch3_spec),
	("mdt049.2.2.11", snd o dest_thm o z_get_spec, ñYIN®, yin_spec),
	("mdt049.2.2.12", snd o dest_thm o z_get_spec, ñYANG®, yang_spec),
	("mdt049.2.2.13", snd o dest_thm o z_get_spec, ñYin®, yin_yang_cons_spec)
];
=TEX
Now check the assumptions of the results of $z\_get\_spec$ on one
of everything.
=SML
store_mt_results_show mt_run [
	("mdt049.2.3.1", is_nil o fst o dest_thm o z_get_spec, ñG1®, true),
	("mdt049.2.3.2", is_nil o fst o dest_thm o z_get_spec, ñTREE®, true),
	("mdt049.2.3.3", is_nil o fst o dest_thm o z_get_spec, ñtip®, true),
	("mdt049.2.3.4", is_nil o fst o dest_thm o z_get_spec, ñfork®, true),
	("mdt049.2.3.5", is_nil o fst o dest_thm o z_get_spec, ñ(twice _)®, true),
	("mdt049.2.3.6", is_nil o fst o dest_thm o z_get_spec, ñ(_ swap _)®, true),
	("mdt049.2.3.7", is_nil o fst o dest_thm o z_get_spec, ñcycle®, true),
	("mdt049.2.3.8", is_nil o fst o dest_thm o z_get_spec, ñSch1®, true),
	("mdt049.2.3.9", is_nil o fst o dest_thm o z_get_spec, ñSch2®, true),
	("mdt049.2.3.10", is_nil o fst o dest_thm o z_get_spec, ñSch3®, true),
	("mdt049.2.3.11", is_nil o fst o dest_thm o z_get_spec, ñYIN®, true),
	("mdt049.2.3.12", is_nil o fst o dest_thm o z_get_spec, ñYANG®, true),
	("mdt049.2.3.13", is_nil o fst o dest_thm o z_get_spec, ñYin®, true)
];
=TEX
Check the conjecture:
=SML
store_mt_results_show (mt_runf (op =$))[
	("mdt049.2.4.1", get_conjecture"-", "Conjecture 1", ñtip ½ fork(2, tip, tip)®)
];
=TEX
Finally, the check constraints.
=SML
val constraintA = ¬µ (A : 'A SET) (B : 'B SET) (C : 'C SET) · ñtrue®®;
val constraintB = ñtrue®;
val constraintC = ¬µX : 'X SET·
	ñ(¶f : X à G1 · true) ¤ (¶f : X à G2 · true)®®;
val constraintD = ñ
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))  (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú) ±
 Yang(YinSeed) ½ YangSeed  YANG ±
 Yin(YangSeed) ½ YinSeed  YIN
®;

store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.2.5.1",
	snd o dest_thm o  get_axiom"-", "Constraint 1", constraintA),
	("mdt049.2.5.2",
	snd o dest_thm o  get_axiom"-", "Constraint 2", constraintC),
	("mdt049.2.5.3",
	snd o dest_thm o  get_axiom"-", "Constraint 3", constraintC),
	("mdt049.2.5.4",
	snd o dest_thm o  get_axiom"-", "Constraint 4", constraintB),
	("mdt049.2.5.5",
	snd o dest_thm o  get_axiom"-", "Constraint 5", constraintD),
	("mdt049.2.5.6",
	snd o dest_thm o  get_axiom"-", "Constraint 6", constraintD)
];
=TEX
This should cause our cache theory to become a parent:
=SML
store_mt_results_show mt_run [
	("mdt049.2.cache", (fn ps => "mdt049_cache" mem ps),
		get_parents "-", true)
];
=TEX
\subsection{Group 3}
This group checks all paragraph forms in conservative mode
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", false);
open_theory"z_sequences";
force_delete_theory "mdt049_cons" handle _ => ();
new_theory"mdt049_cons";
=TEX
We check out the paragraph forms which can be done conservatively first:
=SML
¹Z
fun 10 twice _
°
¹Z
gen _ swap _
°
¹Z
X swap Y ¦ Y ¸ X 
°
ÿSch1
ˆ
ÿSch2
÷
	false
ˆ
ÿSch3
	x, y, z : ú
÷
	x = y ² y = z
ˆ
¹ZAX
	twice _ : ú ­ ú
÷
	µi : ú · twice i = 2*i
°
[A, B, C]
	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷
	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆ
¹Z
[G1, G2]
°
¹Z
Ü CONJmdt049 ?ô twice 1 = 2
°
=SML
store_mt_results_show mt_run [
	("mdt049.3.1", is_nil o get_axioms, "-", true)
];
=TEX
Now add in examples of the forms which have to be done axiomatically:
¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°
¹Z
[G3, G4] & (µx, y : G3· x = y) ± (¶x, y : G4·³x = y)
°
[A, B, C]
ˆ
[X]
÷
 (¶f : X à G1 · true) ¤ (¶f : X à G2 · true)
ˆ
¹Z
[X] ((¶f : X à G1 · true) ¤ (¶f : X à G2 · true))
°

=TEX
Now we check that the definitions are correct.
First, check the conclusions of the results of $z\_get\_spec$ on each global
variable.
=SML
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.3.2.1", snd o dest_thm o z_get_spec, ñG1®, g1_spec),
	("mdt049.3.2.2", snd o dest_thm o z_get_spec, ñTREE®, tree_type_spec),
	("mdt049.3.2.3", snd o dest_thm o z_get_spec, ñtip®, tree_cons_spec),
	("mdt049.3.2.4", snd o dest_thm o z_get_spec, ñfork®, tree_cons_spec),
	("mdt049.3.2.5", snd o dest_thm o z_get_spec, ñ(twice _)®, twice_spec),
	("mdt049.3.2.6", snd o dest_thm o z_get_spec, ñ(_ swap _)®, swap_spec),
	("mdt049.3.2.7", snd o dest_thm o z_get_spec, ñcycle®, cycle_spec),
	("mdt049.3.2.8", snd o dest_thm o z_get_spec, ñSch1®, sch1_spec),
	("mdt049.3.2.9", snd o dest_thm o z_get_spec, ñSch2®, sch2_spec),
	("mdt049.3.2.10", snd o dest_thm o z_get_spec, ñSch3®, sch3_spec)
];
=TEX
Now check that proving the consistency of $twice$ has the expected effect:
=SML
store_mt_results_show mt_run [
	("mdt049.3.3.1", not o is_nil o fst o dest_thm o z_get_spec, ñ(twice _)®, true)
];
=TEX
=SML
if not z_sequence_ok
then ()
else (
push_pc"z_predicates";
push_consistency_goalñ(twice _)®;
a(¶_tacñ{i, j : ú | j = 2 * i}®);
a(rewrite_tac[]);
a(conv_tac (LEFT_C (Z_DECL_C z_dec_pred_conv)));
a(once_rewrite_tac[taut_rule¬µa b·a ± b ¤ a ± (a ´ b)®]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_get_specñú®]);
push_merge_pcs ["z_sets_ext", "'z__rel", "'z__fun", "'z_tuples"];
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(PC_T1"prop_eq"asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(z_¶_tacñ2*x1® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
pop_pc();
push_pc "z_sets_alg";
a(all_fc_tac[z_­_app_thm] THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
save_consistency_thm ñ(twice _)® (pop_thm()); ()
);
=TEX
=SML
store_mt_results_show (mt_runf (op ~=#)) [
	("mdt049.3.3.2", dest_thm o z_get_spec, ñ(twice _)®, ([], twice_spec))
];
=TEX
Check the conjecture:
=SML
store_mt_results_show (mt_runf (op =$))[
	("mdt049.3.4.1", get_conjecture"-", "CONJmdt049", ñtwice 1 = 2®)
];
=TEX
This should cause our cache theory to become a parent:
=SML
store_mt_results_show mt_run [
	("mdt049.3.cache", (fn ps => "mdt049_cache" mem ps),
		get_parents "-", true)
];
=TEX
\subsection{Group 4}
This group checks error cases.
=TEX
4.1: Error 49001:
=SML
val ex_4_1 = (ñ x ::= y ®; fail "mdt049" 0 []) handle ex => ex;
=TEX
4.2: Error 49005
=SML
open_theory"z_numbers";
val ex_4_2 = (
¹Z
 X ::= Y
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.3: Error 49003
=SML
open_theory"mdt049_ax";
val ex_4_3 = (
¹ZAX
TREE : ú
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.4: Error 49002
=SML
new_type("z'APPLE", 0);
val ex_4_4 = (
¹Z
 APPLE ::= fruit
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.5: Error 62000 (caused by use of free variables in a paragraph)
=SML
val ex_4_5 = (
¹Z
 banana ¦ orange
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.6: Error 62000 (caused by use of nested quotation in a paragraph)
=SML
set_flag("standard_z_paras", true);
val ex_4_6 = (
¹Z
 pomegranate ¦ ¬T®
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=SML
fun r ex = raise ex;
store_mt_results_show mt_run_fail [
	("mdt049.4.1", r, ex_4_1,
		gen_fail_msg "z_term_recogniser" 49001 []),
	("mdt049.4.2", r, ex_4_2,
		gen_fail_msg "z_other_recogniser" 49005 [string_of_termñ(disjoint _)®]),
	("mdt049.4.3", r, ex_4_3,
		gen_fail_msg "z_axbox_recogniser" 49003 ["TREE"]),
	("mdt049.4.4", r, ex_4_4,
		gen_fail_msg "z_other_recogniser" 49002 ["APPLE"]),
	("mdt049.4.5", r, ex_4_5,
		gen_fail_msg "Z-Parser" 62000 []),
	("mdt049.4.6", r, ex_4_6,
		gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
\subsection{Group 5}
Term processing --- correct operation.
Note that the type inferrer, parser and term generator have their
own tests, so what is done here is just to make some spot checks
to indicate whether they have been called correctly.
=SML
set_flag("standard_z_terms", false);
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.5.1", Combinators.I, ñX®, ¬X®),
	("mdt049.5.2", Combinators.I, ñ[X] X = X®, ¬µ X : 'X SET· X = X®),
	("mdt049.5.3", Combinators.I, ñ[X, Y] X = X®,
			¬µ X : 'X SET; Y : 'Y SET· X = X®),
	("mdt049.5.4", Combinators.I, ñ(f 1)º ú®, mk_z_app(ñfº (ú ­ ú)®, ñ1®)),
	("mdt049.5.5", Combinators.I, ññ(f 1)®º ú®, mk_z_app(ñfº (ú ­ ú)®, ñ1®)),
	("mdt049.5.6", Combinators.I, ñ(X)®, ¬X:BOOL®)
];
=TEX
\subsection{Group 6}
Term processing --- error cases. The thing to check is that the
standard v. extended flag is being toggled correctly. We have already
seen that free variables etc. are acceptable when extended Z is allowed.
=SML
set_flag("standard_z_terms", true);
=TEX
6.1: Error 62000 (caused by use of cast)
=SML
val ex_6_1 = (ñ banana º orange®; fail "mdt049" 0 []) handle ex => ex;
=TEX
6.2: Error 62000 (caused by use of nested quotation)
=SML
val ex_6_2 = (ñ pomegranate = ¬T®®; fail "mdt049" 0 []) handle ex => ex;
=SML
store_mt_results_show mt_run_fail [
	("mdt049.6.1", r, ex_6_1,
		gen_fail_msg "Z-Parser" 62000 []),
	("mdt049.6.2", r, ex_6_2,
		gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
\subsection{Group 7}
This group checks miscellaneous features which the other groups did not.
It is divided into several blocks.

Block 1: Redefinition in type-check-only mode.
=SML
val old_iw = set_flag("ignore_warnings", true);
set_flag("z_type_check_only", true);
open_theory"mdt049_tco";
¹Z
TREE ¦ 99
°
=SML
set_flag("ignore_warnings", old_iw);
open Sort;
val s = sort string_order;
store_mt_results_show mt_run [
	("mdt049.7.1.1", s o map name_of o rev o get_consts, "-",
		s ["_ swap _", "Sch1", "Sch2", "Sch3", "twice _", "_ is_even", "cycle", "TREE",
			"tip", "fork", "G1", "G2", "G3", "G4",
		"YIN", "YANG", "Yin", "Yang", "YinSeed", "YangSeed"])
];
store_mt_results_show (mt_runf (op =:))[
	("mdt049.7.1.2", type_of, ñTREE®, ”ú®)
];
=TEX
Because ``mdt048$\_$cache'' has clashes with the current theory,
and all the other potential cache theories have been locked, if we demand
a cache theory now, it should fail.
=SML
store_mt_results_show mt_run_fail [
	("mdt049.7.cache", force_get_cache_theory, (),
		 gen_fail_msg "force_get_cache_theory" 59008 ["mdt049_tco"])
];
=TEX
Block 2: Check that partial theory updates don't occur in axiomatic mode
when some of the variables defined by an axiomatic description are invalid.
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
open_theory"mdt049_ax";
¹ZAX
	ABC : ú;
	DEF : ú
°
=SML
val names = map name_of (get_consts"-");
val types = map (fst o dest_ctype) (get_types "-");
val _ = (
¹ZAX
	IJK : ú;
	ABC : ú;
	DEF : ú;
	LMN : ú
°
=SML
()) handle Fail _ => ();
=SML
store_mt_results_show mt_run [
	("mdt049.7.2.1", map name_of o get_consts, "-", names),
	("mdt049.7.2.2", map (fst o dest_ctype) o get_types, "-", types)
];
=TEX
Block 3: Axiomatic descriptions with more than one global variable behave
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", false);
open_theory"mdt049_cons";
¹ZAX
	IJK : ú;
	ABC : ú;
	DEF : ú;
	LMN : ú
÷
	IJK = DEF ± ABC ½ LMN
°
=SML
val ijk_spec = ñ(IJK  ú ± ABC  ú ± DEF  ú ± LMN  ú) ± IJK = DEF ± ABC ½ LMN®;
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.7.3.1", snd o dest_thm o z_get_spec, ñIJK®, ijk_spec),
	("mdt049.7.3.2", snd o dest_thm o z_get_spec, ñABC®, ijk_spec),
	("mdt049.7.3.3", snd o dest_thm o z_get_spec, ñDEF®, ijk_spec),
	("mdt049.7.3.4", snd o dest_thm o z_get_spec, ñLMN®, ijk_spec)
];
=TEX
\subsection{Group 8}
This group checks bug fixes.
It is divided into several blocks.

Block 1: Bug 175 (the fix is actually in IMP062, which relies
on these tests for the paragraphs).
=SML
val old_szp = set_flag("standard_z_paras", true);
val old_zua = set_flag("z_use_axioms", true);
force_delete_theory"mdt049_part8" handle Fail _ => ();
open_theory"z_numbers";
force_delete_theory "mdt049_part8" handle _ => ();
new_theory"mdt049_part8";
ÿ S175 üüüüüüüüüüü
Ü Y175 : î
÷üüüüüü
Ü Y175 = 7
ˆüüüüüüüüüüüüüü
=SML
fun go_8_1 () = 
¹ZAX
Ü X175 : ú
÷üüüüüü
Ü S175
°
=SML
store_mt_results_show mt_run_fail [
	("mdt049.8.1", go_8_1, (),
		gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
Block 2: Fix/enhancement of treatment of mutually recursive free types.
The old treatment was designed to give too weak an axiom anyway
and the implementation failed to convert all the free variables of
the defining property into globals properly.
Since it required a redesign basic tests for the main functionality
are given in groups 1 and 2.
Here we check out the treatment of the bound variables in the
induction principle.
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
force_delete_theory"mdt049_part8_2" handle Fail _ => ();
open_theory"z_sequences";
new_theory"mdt049_part8_2";
¹Z
Ü W1 ::= w1_1 | w1_2 W2 | w1_3 W3
Ü &
Ü W2 ::= w2_1 W1 | w2_2 | w2_3 W3
Ü &
Ü W3 ::= w3_1 W1 | w3_2 W3 | w3_3
°
=TEX
=SML
fun check_8_2 () = (
	let val vs =
		(map fst o term_vars o snd o dest_thm o z_get_spec)ñw1_1®;
	in	not (any ["W1", "W2", "W3"] (fn t => t mem vs))
	end
);
=TEX
=SML
store_mt_results_show mt_run[
	("mdt049.8.2", check_8_2, (), true)
];
=TEX
\subsection{Group 9}
This group checks error cases in paragraphs formed from pre-existing
HOL code, using $update\_theory\_db\_with\_parainfo$.
As this function is also used by the Z Parser we do not check its correct operation.
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
set_flag("z_allow_free_vars_in_axioms",false);
open_theory"z_sequences";
force_delete_theory "mdt049_pre" handle _ => ();
new_theory"mdt049_pre";
open ZParagraphs;
=TEX
Failures are meant to tidy up after themselves.
=SML
fun empty_theory (thy : string) = 
	is_nil(get_thms thy) andalso is_nil(get_axioms thy)
	andalso is_nil(get_defns thy) andalso is_nil(get_types thy)
	andalso is_nil(get_consts thy) andalso is_nil(get_conjectures thy);
=TEX
=SML
fun fail_update (p : PARAINFO) = (
	(update_theory_db_with_parainfo p; fail "mdt049" 0 []) 
	handle ex => ex
);
=TEX
=IGN
val ex_??? = fail_update(FixityInfo(ZUserInterfaceSupport.ZClFun(0-10),[]));
ex_???();
(* doesn't seem to fail *)
=TEX
9.1: Error 6062:
=SML
val ex_9_1 = fail_update(AbbDefInfo ("ex_9_1",["p"], ñx + y®));
empty_theory"-";
=TEX
9.2: Error 6062:
=SML
val ex_9_2 = fail_update(SchBoxInfo ("ex_9_2", ["X", "Y"], ñx = y®));
empty_theory"-";
=TEX
9.3: Error 49006:
=SML
val ex_9_3 = fail_update(AxDesInfo (["ex_9_3"], ñx = y®, Nil, [dest_var ñp®]));
empty_theory"-";
=TEX
9.4: Error 49006:
=SML
val ex_9_4 = fail_update(FreeTypeInfo (
	[("ex_9_4a", [("x", Value ñî®),("y", Value ñð X®)])]));
empty_theory"-";
=TEX
9.5: Error 49006:
=SML
val ex_9_5 = fail_update(GivenSetInfo (["ex_9_5"], Value (["x", "y"], ñ x = fv_9_5®)));
empty_theory"-";
=TEX
9.6: Error 49006:
=SML
val ex_9_6 = fail_update(ConstraintInfo (["ex_9_6"] , ñx = y®));
empty_theory"-";
=TEX
9.7: Error 49006:
=SML
val ex_9_7 = fail_update(ConjectureInfo (Value "ex_9_7", ["X"], ñx = y®));
empty_theory"-";
=TEX
9.7: Error 49006:
=SML
val ex_9_7 = fail_update(ConjectureInfo (Value "ex_9_7", ["X"], ñx = y®));
empty_theory"-";
=TEX
=SML
fun r ex = raise ex;
store_mt_results mt_run_fail [
("mdt049.9.1", r, ex_9_1,
	gen_fail_msg "const_spec" 46014 [
	"¬¶ z'ex_9_1· ñ¬Z'AbbDef (µ p· z'ex_9_1 ñ(p)® = ñx + y®)®®®", "s", "y, x"]),
("mdt049.9.2", r, ex_9_2,
	gen_fail_msg "const_spec" 46014 [ 
	"¬¶ z'ex_9_2· ñ¬Z'SchBox (µ X Y· z'ex_9_2 ñ(X, Y)® ¤ x = y)®®®", "s", "y, x"]),
("mdt049.9.3", r, ex_9_3,
	gen_fail_msg "update_theory_db_with_parainfo" 49006 ["p", 
	"y, x"]),
("mdt049.9.4", r, ex_9_4,
	gen_fail_msg "update_theory_db_with_parainfo" 49006 ["x, y", 
	"X"]),
("mdt049.9.5", r, ex_9_5,
	gen_fail_msg "update_theory_db_with_parainfo" 49006 ["ex_9_5", 
	"fv_9_5"]),
("mdt049.9.6", r, ex_9_6,
	gen_fail_msg "update_theory_db_with_parainfo" 49006 ["Constraint 1", 
	"y, x"]),
("mdt049.9.7", r, ex_9_7,
	gen_fail_msg "update_theory_db_with_parainfo" 49006 ["ex_9_7", 
	"y, x"])
];
=TEX
=TEX
9.9: Make sure that the theory remains empty:
=SML
store_mt_results mt_run [("mdt049.9.9", empty_theory, "-", true)];
=TEX
9.10: Check the allow-free-variables flag works OK for programmer's interface:
=SML
set_flag("z_allow_free_vars_in_axioms",true);
val was = set_flag("ignore_warnings",true);
store_mt_results mt_run [
	("mdt049.9.10", update_theory_db_with_parainfo,
		(AxDesInfo (["ex_9_10"], ñx = y®, Nil, [dest_var ñq®])),	())];
set_flag("z_allow_free_vars_in_axioms",false);
val was = set_flag("ignore_warnings",was);
=TEX
=TEX
9.11: Check the allow-free-variables flag works OK for end-user interface:
=SML
set_flag("z_allow_free_vars_in_axioms",false);
val was = set_flag("ignore_warnings",true);
fun test9_11_1() =
¹Z
Ü FT ::= Con1 | Con2 (ðX)
°
=SML
store_mt_results mt_run_fail [
("mdt049.9.11.1", test9_11_1, (),
	gen_fail_msg "Z-Parser" 62000 [])];
set_flag("z_allow_free_vars_in_axioms",true);
store_mt_results mt_run [("mdt049.9.11.2", test9_11_1, (), ())];
set_flag("z_allow_free_vars_in_axioms",false);
val was = set_flag("ignore_warnings",was);
=TEX

\section{SUMMARY OF RESULTS}

=SML
if z_sequence_ok
then
diag_string(summarize_mt_results())
else
(diag_string "*** mdt049 requires the theory z_sequences ***";
diag_string "*** mdt049 was not able to test the Z theory lister ***");
=TEX

\end{document}
open_theory"z_numbers";
