%  mdt049.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Paragraphs}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT049}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Z paragraph processor described in the document
DS/FMU/IED/DTD065.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.2]
First draft.
\item[Issue 1.3 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.

\item[Issue 1.4 (7th May 1994)]
Set the proof context to $z\_predicates$ - to enable the tests to run without having run other module tests prior to these.

\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the Z paragraph processor as specified in \cite{DS/FMU/IED/DTD049}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Z theory lister
as defined in \cite{DS/FMU/IED/DTD049} and implemented
in \cite{DS/FMU/IED/IMP049}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
The tests require the theory $z\_sequences$ defined in \cite{DS/FMU/IED/DTD078}
to be present (and, as a consequence they can and do expect all of the
rest of the user interface and much of the proof support to be in place).

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

None known.

\section{TEST CASES}
\begin{description}
\item[Paragraphs.1]
Checks all paragraph forms in type-check only mode
\item[Paragraphs.2]
Checks all paragraph forms in axiomatic proof mode
\item[Paragraphs.3]
Checks all paragraph forms in conservative proof mode
\item[Paragraphs.4]
Error cases for paragraph forms in all three modes.
\item[Paragraphs.5]
Term processing --- correct operation
\item[Paragraphs.6]
Term processing --- error cases
\item[Paragraphs.7]
Spot checks on some specific features which the ``systematic'' coverage
of the other groups did not check out in detail.
\end{description}

Because of the dependencies mentioned above, an attempt is made to protect
the tests against the case when errors during a system build mean that
these dependences are unsatisfied. However, this is in itself hard to test! 
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
val my_z_other_recogniser = ref z_other_recogniser;
val my_z_genbox_recogniser = ref z_genbox_recogniser;
val my_z_axbox_recogniser = ref z_axbox_recogniser;
val my_z_term_recogniser = ref  z_term_recogniser;
val my_open_theory = ref open_theory;
val my_new_theory = ref new_theory;

fun z_other_recogniser x = ! my_z_other_recogniser x;
fun z_genbox_recogniser x = ! my_z_genbox_recogniser x;
fun z_axbox_recogniser x = ! my_z_axbox_recogniser x;
fun z_term_recogniser x = !  my_z_term_recogniser x;
fun open_theory x = !  my_open_theory x;
fun new_theory x = !  my_new_theory x;


val z_sequence_ok = (open_theory "z_sequences"; true) handle (Fail _) => false;
if z_sequence_ok
then ()
else (
	my_z_other_recogniser := (fn _ => ());
	my_z_genbox_recogniser := (fn _ => ());
	my_z_axbox_recogniser := (fn _ => ());
	my_open_theory := (fn _ => ());
	my_new_theory := (fn _ => ());
	my_z_term_recogniser := (fn _ => mk_t)
);
=TEX
\section{THE TESTS}
\subsection{Group 1}
This group checks all paragraph forms in type-check only mode
=SML
set_flag("z_type_check_only", true);
open_theory"z_sequences";
set_pc "z_predicates";
new_theory"mdt049_tco";
=TEX
¹Z
fun 10 twice _
°
¹Z
gen _ swap _
°
¹Z
rel  _ is_even 
°
¹Z
X swap Y ¦ Y ¸ X 
°
ÿSch
	x, y, z : ú
÷
	x = y ² y = z
ˆ
¹ZAX
	twice _ : ú ­ ú
÷
	µi : ú · twice i = 2*i
°
¹ZAX
	_ is_even : ğú
÷
	( _ is_even) = ran (twice _)
°
[A, B, C]
	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷
	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆ
¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°
¹Z
[G1, G2]
°
¹Z
[X] ((¶f : X à G1 · true) ¤ (¶f : X à G2 · true))
°
¹Z
 {1} swap {§1¢} = {§1¢} ¸ {1} ± Sch ½ [x, y, z : ú] 
°
¹Z
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))  (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú)
°
=SML
fun name_of c = (
	let	val (n, _, _) = dest_z_gvar c;
	in	 n
	end
);
=TEX
We don't look very hard at the results, since we wouldn't have got here
if much had gone wrong, because we have arranged to have an application of
each one of the global variables from each form of paragraph in a subsequent
paragraph.
=SML
store_mt_results_show mt_run [
	("mdt049.1", map name_of o rev o get_consts, "-",
		["_ swap _", "Sch", "twice _", "_ is_even", "cycle", "TREE",
			"tip", "fork", "G1", "G2"])
];
=TEX
\subsection{Group 2}
This group checks all paragraph forms in axiomatic mode
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
open_theory"z_sequences";
new_theory"mdt049_ax";
=TEX
=SML
¹Z
fun 10 twice _
°
¹Z
gen _ swap _
°
¹Z
rel  _ is_even 
°
¹Z
X swap Y ¦ Y ¸ X 
°
ÿSch
	x, y, z : ú
÷
	x = y ² y = z
ˆ
¹ZAX
	twice _ : ú ­ ú
÷
	µi : ú · twice i = 2*i
°
[A, B, C]
	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷
	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆ
¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°
¹Z
[G1, G2]
°
¹Z
[X] ((¶f : X à G1 · true) ¤ (¶f : X à G2 · true))
°
¹Z
 tip ½ fork(2, tip, tip) ±
 tip  TREE ±
 cycle(1, (1,2), (1, 2, 3))  (ú ¸ ú ¸ ú) ¸ ú ¸ (ú ¸ ú)
°
=SML
store_mt_results_show mt_run [
	("mdt049.2.1", map name_of o rev o get_consts, "-",
		["_ swap _", "Sch", "twice _", "cycle", "TREE", "tip", "fork", "G1", "G2"])
];
=TEX
Now we check that the axioms/definitions are correct.
First check the conclusions of the results of $z\_get\_spec$ on one
of everything.
=SML
val g1_spec = ñG1 = U®;
val tree_type_spec = ñTREE = U®;
val tree_cons_spec = ñ(tip  TREE
    ± fork  î ¸ TREE ¸ TREE à TREE)
    ± disjoint §{tip}, ran fork¢
    ± (µ W : ğ TREE | {tip} À fork ¨ î ¸ W ¸ W © € W · TREE € W)®;
val twice_spec = ñ(twice _)  ú ­ ú ± (µ i : ú · twice i = 2 * i)®;
val swap_spec = ¬µ X : 'X SET; Y : 'Y SET· ñX swap Y = Y ¸ X®®;
val sch_spec = ñSch = [x, y, z : ú | x = y ² y = z]®;
val cycle_spec = ¬
	µ A : 'A SET; B : 'B SET; C : 'C SET
  · ñcycle[A, B, C]  A ¸ B ¸ C ­ C ¸ A ¸ B
      ± (µ x : A; y : B; z : C · cycle[A, B, C] (x, y, z) = (z, x, y))®®;
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.2.2.1", snd o dest_thm o z_get_spec, ñG1®, g1_spec),
	("mdt049.2.2.2", snd o dest_thm o z_get_spec, ñTREE®, tree_type_spec),
	("mdt049.2.2.3", snd o dest_thm o z_get_spec, ñtip®, tree_cons_spec),
	("mdt049.2.2.4", snd o dest_thm o z_get_spec, ñfork®, tree_cons_spec),
	("mdt049.2.2.5", snd o dest_thm o z_get_spec, ñ(twice _)®, twice_spec),
	("mdt049.2.2.6", snd o dest_thm o z_get_spec, ñ(_swap_)®, swap_spec),
	("mdt049.2.2.7", snd o dest_thm o z_get_spec, ñcycle®, cycle_spec),
	("mdt049.2.2.8", snd o dest_thm o z_get_spec, ñSch®, sch_spec)
];
=TEX
Now check the assumptions of the results of $z\_get\_spec$ on one
of everything.
=SML
store_mt_results_show mt_run [
	("mdt049.2.3.1", is_nil o fst o dest_thm o z_get_spec, ñG1®, true),
	("mdt049.2.3.2", is_nil o fst o dest_thm o z_get_spec, ñTREE®, true),
	("mdt049.2.3.3", is_nil o fst o dest_thm o z_get_spec, ñtip®, true),
	("mdt049.2.3.4", is_nil o fst o dest_thm o z_get_spec, ñfork®, true),
	("mdt049.2.3.5", is_nil o fst o dest_thm o z_get_spec, ñ(twice _)®, true),
	("mdt049.2.3.6", is_nil o fst o dest_thm o z_get_spec, ñSch®, true)
];
=TEX
Finally, check a constraint.
=SML
val constraint1 = ¬µX : 'X SET·
	ñ(¶f : X à G1 · true) ¤ (¶f : X à G2 · true)®®;
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.2.4.1",
	snd o dest_thm o  get_axiom"-", "Constraint 1", constraint1)
];
=TEX
\subsection{Group 3}
This group checks all paragraph forms in conservative mode
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", false);
open_theory"z_sequences";
new_theory"mdt049_cons";
=TEX
We check out the paragraph forms which can be done conservatively first:
=SML
¹Z
fun 10 twice _
°
¹Z
gen _ swap _
°
¹Z
X swap Y ¦ Y ¸ X 
°
ÿSch
	x, y, z : ú
÷
	x = y ² y = z
ˆ
¹ZAX
	twice _ : ú ­ ú
÷
	µi : ú · twice i = 2*i
°
[A, B, C]
	cycle : A ¸ B ¸ C ­ C ¸ A ¸ B
÷
	µx : A; y : B; z : C· cycle(x, y, z) = (z, x, y)
ˆ
¹Z
[G1, G2]
°
=SML
store_mt_results_show mt_run [
	("mdt049.3.1", is_nil o get_axioms, "-", true)
];
=TEX
Now add in examples of the forms which have to be done axiomatically:
¹Z
TREE ::= tip | fork (î ¸ TREE ¸ TREE)
°
¹Z
[X] ((¶f : X à G1 · true) ¤ (¶f : X à G2 · true))
°

=TEX
Now we check that the definitions are correct.
First, check the conclusions of the results of $z\_get\_spec$ on each global
variable.
=SML
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.3.2.1", snd o dest_thm o z_get_spec, ñG1®, g1_spec),
	("mdt049.3.2.2", snd o dest_thm o z_get_spec, ñTREE®, tree_type_spec),
	("mdt049.3.2.3", snd o dest_thm o z_get_spec, ñtip®, tree_cons_spec),
	("mdt049.3.2.4", snd o dest_thm o z_get_spec, ñfork®, tree_cons_spec),
	("mdt049.3.2.5", snd o dest_thm o z_get_spec, ñ(twice _)®, twice_spec),
	("mdt049.3.2.6", snd o dest_thm o z_get_spec, ñ(_swap_)®, swap_spec),
	("mdt049.3.2.7", snd o dest_thm o z_get_spec, ñcycle®, cycle_spec),
	("mdt049.3.2.8", snd o dest_thm o z_get_spec, ñSch®, sch_spec)
];
=TEX
Now check that proving the consistency of $twice$ has the expected effect:
=SML
store_mt_results_show mt_run [
	("mdt049.3.3.1", not o is_nil o fst o dest_thm o z_get_spec, ñ(twice _)®, true)
];
=TEX
=SML
if not z_sequence_ok
then ()
else (
push_pc"z_predicates";
push_consistency_goalñ(twice_)®;
a(¶_tacñ{i, j : ú | j = 2 * i}®);
a(rewrite_tac[]);
a(conv_tac (LEFT_C (Z_DECL_C z_dec_pred_conv)));
a(once_rewrite_tac[taut_rule¬µa b·a ± b ¤ a ± (a ´ b)®]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[z_get_specñú®]);
push_merge_pcs ["z_sets_ext", "'z__rel", "'z__fun", "'z_tuples"];
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(PC_T1"prop_eq"asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(z_¶_tacñ2*x1® THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
pop_pc();
push_pc "z_sets_alg";
a(all_fc_tac[z_­_app_thm] THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
save_consistency_thm ñ(twice_)® (pop_thm()); ()
);
=TEX
=SML
store_mt_results_show (mt_runf (op ~=#)) [
	("mdt049.3.3.2", dest_thm o z_get_spec, ñ(twice _)®, ([], twice_spec))
];
=TEX
\subsection{Group 4}
This group checks error cases.
=TEX
4.1: Error 49001:
=SML
val ex_4_1 = (ñ x ::= y ®; fail "mdt049" 0 []) handle ex => ex;
=TEX
4.2: Error 49005
=SML
open_theory"z_numbers";
val ex_4_2 = (
¹Z
 X ::= Y
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.3: Error 49003
=SML
open_theory"mdt049_ax";
val ex_4_3 = (
¹ZAX
TREE : ú
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.4: Error 49002
=SML
new_type("APPLE", 0);
val ex_4_4 = (
¹Z
 APPLE ::= fruit
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.5: Error 62000 (caused by use of free variables in a paragraph)
=SML
val ex_4_5 = (
¹Z
 banana ¦ orange
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=TEX
4.6: Error 62000 (caused by use of nested quotation in a paragraph)
=SML
set_flag("standard_z_paras", true);
val ex_4_6 = (
¹Z
 pomegranate ¦ ¬T®
°
=SML
fail "mdt049" 0 []) handle ex => ex;
=SML
fun r ex = raise ex;
store_mt_results_show mt_run_fail [
	("mdt049.4.1", r, ex_4_1,
		gen_fail_msg "z_term_recogniser" 49001 []),
	("mdt049.4.2", r, ex_4_2,
		gen_fail_msg "z_other_recogniser" 49005 [string_of_termñ(disjoint_)®]),
	("mdt049.4.3", r, ex_4_3,
		gen_fail_msg "z_axbox_recogniser" 49003 ["TREE"]),
	("mdt049.4.4", r, ex_4_4,
		gen_fail_msg "z_other_recogniser" 49002 ["APPLE"]),
	("mdt049.4.5", r, ex_4_5,
		gen_fail_msg "Z-Parser" 62000 []),
	("mdt049.4.6", r, ex_4_6,
		gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
\subsection{Group 5}
Term processing --- correct operation.
Note that the type inferrer, parser and term generator have their
own tests, so what is done here is just to make some spot checks
to indicate whether they have been called correctly.
=SML
set_flag("standard_z_terms", false);
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.5.1", Combinators.I, ñX®, ¬X®),
	("mdt049.5.2", Combinators.I, ñ[X] X = X®, ¬µ X : 'X SET· X = X®),
	("mdt049.5.3", Combinators.I, ñ[X, Y] X = X®,
			¬µ X : 'X SET; Y : 'Y SET· X = X®),
	("mdt049.5.4", Combinators.I, ñ(f 1)º ú®, mk_z_app(ñfº (ú ­ ú)®, ñ1®)),
	("mdt049.5.5", Combinators.I, ññ(f 1)®º ú®, mk_z_app(ñfº (ú ­ ú)®, ñ1®)),
	("mdt049.5.6", Combinators.I, ñ(X)®, ¬X:BOOL®)
];
=TEX
\subsection{Group 6}
Term processing --- error cases. The thing to check is that the
standard v. extended flag is being toggled correctly. We have already
seen that free variables etc. are acceptable when extended Z is allowed.
=SML
set_flag("standard_z_terms", true);
=TEX
6.1: Error 62000 (caused by use of cast)
=SML
val ex_6_1 = (ñ banana º orange®; fail "mdt049" 0 []) handle ex => ex;
=TEX
6.2: Error 62000 (caused by use of nested quotation)
=SML
val ex_6_2 = (ñ pomegranate = ¬T®®; fail "mdt049" 0 []) handle ex => ex;
=SML
store_mt_results_show mt_run_fail [
	("mdt049.6.1", r, ex_6_1,
		gen_fail_msg "Z-Parser" 62000 []),
	("mdt049.6.2", r, ex_6_2,
		gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
\subsection{Group 7}
This group checks miscellaneous features which the other groups did not.
It is divided into several blocks.

Block 1: Redefinition in type-check-only mode.
=SML
val old_iw = set_flag("ignore_warnings", true);
set_flag("z_type_check_only", true);
open_theory"mdt049_tco";
¹Z
TREE ¦ 99
°
=SML
set_flag("ignore_warnings", old_iw);
open Sort;
val s = sort string_order;
store_mt_results_show mt_run [
	("mdt049.7.1.1", s o map name_of o rev o get_consts, "-",
		s ["_ swap _", "Sch", "twice _", "_ is_even", "cycle", "TREE",
			"tip", "fork", "G1", "G2"])
];
store_mt_results_show (mt_runf (op =:))[
	("mdt049.7.1.2", type_of, ñTREE®, ”ú®)
];
=TEX
Block 2: Check that partial theory updates don't occur in axiomatic mode
when some of the variables defined by an axiomatic description are invalid.
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", true);
open_theory"mdt049_ax";
¹ZAX
	ABC : ú;
	DEF : ú
°
=SML
val names = map name_of (get_consts"-");
val types = map (fst o dest_ctype) (get_types "-");
val _ = (
¹ZAX
	IJK : ú;
	ABC : ú;
	DEF : ú;
	LMN : ú
°
=SML
()) handle Fail _ => ();
=SML
store_mt_results_show mt_run [
	("mdt049.7.2.1", map name_of o get_consts, "-", names),
	("mdt049.7.2.2", map (fst o dest_ctype) o get_types, "-", types)
];
=TEX
Block 3: Axiomatic descriptions with more than one global variable behave
=SML
set_flag("z_type_check_only", false);
set_flag("z_use_axioms", false);
open_theory"mdt049_cons";
¹ZAX
	IJK : ú;
	ABC : ú;
	DEF : ú;
	LMN : ú
÷
	IJK = DEF ± ABC ½ LMN
°
=SML
val ijk_spec = ñ(IJK  ú ± ABC  ú ± DEF  ú ± LMN  ú) ± IJK = DEF ± ABC ½ LMN®;
store_mt_results_show (mt_runf (op ~=$)) [
	("mdt049.7.3.1", snd o dest_thm o z_get_spec, ñIJK®, ijk_spec),
	("mdt049.7.3.2", snd o dest_thm o z_get_spec, ñABC®, ijk_spec),
	("mdt049.7.3.3", snd o dest_thm o z_get_spec, ñDEF®, ijk_spec),
	("mdt049.7.3.4", snd o dest_thm o z_get_spec, ñLMN®, ijk_spec)
];
=TEX
\section{SUMMARY OF RESULTS}

=SML
if z_sequence_ok
then
diag_string(summarize_mt_results())
else
(diag_string "*** mdt049 requires the theory z_sequences ***";
diag_string "*** mdt049 was not able to test the Z theory lister ***");
=TEX

\end{document}
open_theory"z_numbers";
