%  %Z% $Date: 1997/07/28 13:03:10 $ $Revision: 1.12 $ $RCSfile: dtd107.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Z Finiteness and Sequences}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD107}  %% Mandatory field
\def\SCCSversion{$Revision: 1.12 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 1997/07/28 13:03:10 $%
}}
%\TPPstatus{Draft}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team Leader}
\TPPabstract{This document contains the detailed design of
the theories $z\_functions1$, $z\_numbers1$, and $z\_sequences1$ and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Project Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1, 1.2 (15th January 1995)]
First versions, derived from wrk056.
\item[Issue 1.3 (24th January 1995)]
Corrected duplicate namings.
\item[Issue 1.4 (20th February 1996)]
Added $abs$, $mod$ and $div$ theorems.
\item[Issue 1.5]
Added material about $´$.
\item [Issue 1.6]
Added material about $succ$.
\item [Issues 1.8-1.10]
Added $z\_size\_dot\_dot\_conv$.
\item [Issue 1.11]
Documented sequence induction.
\item [Issue 1.12]
Documented finite set induction.
\item [Issue 1.13]
Added material on sequence displays.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design of
the theories $z\_functions1$, $z\_numbers1$, and $z\_sequences1$ and their proof support, parts
of the mathematical toolkit for HOL/Z.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD017}.
\subsection{Dependencies}
Loading this document and its implementation requires that
\cite{DS/FMU/IED/IMP088} has been loaded.
\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.
\section{ZFunctions1}
\subsection{PROLOGUE FOR ZFunctions1}

=SML
open_theory"z_functions";
force_delete_theory"z_functions1" handle Fail _ => ();
force_delete_theory"z_numbers1" handle Fail _ => ();
force_delete_theory"z_sequences1" handle Fail _ => ();
new_theory"z_functions1";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZFunctions1}
=DOC
signature €ZFunctions1› = sig
=DESCRIBE
This provides additional proof support for the Z library functions.
It creates the theory $z\_functions1$.
=ENDDOC
=THDOC
req_name €"z_functions1"› (Value "z_functions");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_functions1$ contains various theorems about functions.
It is created in structure $ZFunctions1$.
=ENDDOC

=THDOC
req_thm(€"z_Ú_≠_thm"›,([], Ò[Y, Z](µX:U; f:Y ≠ Z∑ X Ä Y 
	¥ 	(X Ú f) ç X ≠ (ran (X Ú f)))Æ));
req_thm(€"z_ran_Ú_thm"›,([], Ò[Y, Z](µX:U; f:Y ≠ Z∑
	ran(X Ú f) = ran f \ {y : U | µx : U | (x, y) ç f ∑ ≥x ç X})Æ));
req_thm(€"z_ç_≠_thm"›,([], Ò(µX:U; Y:U∑ µ f:X ≠ Y; x:U; y:U | (x, y) ç f ∑ 
	x ç X ± y ç Y)Æ));
req_thm(€"z_≠_ran_eq_Ô_thm"›,([], Ò(µA:U; B : U∑ (∂f : A ≠ B∑ ran f = B) 
	§ 	(∂f : A Ô B∑ true))Æ));
req_thm(€"z_‡_ran_eq_è_thm"›,([], Ò(µA:U; B : U∑ (∂f : A ‡ B∑ ran f = B) 
	§ 	(∂f : A è B∑ true))Æ));
req_thm(€"z_ran_mono_thm"›,([], ÒµX:U; Y, Z:U; f:U | f ç X ≠ Y ± ran f Ä Z ∑ 
	f ç X ≠ ZÆ));
req_thm(€"z_ﬂ_thm2"›,([], ÒµA:U; B:U; f:U∑ f ç  A ﬂ B 
	§ 	f ç dom f ≠ B ± dom f Ä AÆ));
req_thm(€"z_Ô_thm1"›,([], ÒµA:U; B:U; f:U∑ f ç A Ô B 
	§ f ç A ≠ B ± B Ä ran fÆ));
req_thm(€"z_˛_thm1"›,([], Ò [X, Y]
	(X ˛ Y =
	{f : X ﬂ Y | µ x1, x2 : U; y:U∑ (x1, y) ç f ± (x2, y) ç f¥ x1 = x2})Æ));
req_thm(€"z_≠_dom_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	f ç dom f ≠ BÆ));
req_thm(€"z_‡_thm1"›,([], ÒµA:U; B:U; f:U∑
		f ç A ‡ B
	§	f ç A ≠ B ± (µx, y:U; z:U∑ (x, z) ç f ± (y, z) ç f ¥ x = y)Æ));
req_thm(€"z_¿_™_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
			f ç A ™ B ± g ç C ™ D
		¥	f ¿ g ç (A ¿ C) ™ (B ¿ D)Æ));
req_thm(€"z_ran_¿_thm"›,([], Òµf:U; g:U∑ran (f ¿ g) = ran f ¿ ran gÆ));
req_thm(€"z_¿_≠_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A ≠ B ± g ç C ≠ D ± A ° C = {}
	¥	f ¿ g ç (A ¿ C) ≠ (B ¿ D)Æ));
req_thm(€"z_¿_‡_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A ‡ B ± g ç C ‡ D ± A ° C = {} ± B ° D = {}
	¥	f ¿ g ç (A ¿ C) ‡ (B ¿ D)Æ));
req_thm(€"z_¿_Ô_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A Ô B ± g ç C Ô D ± A ° C = {}
	¥	f ¿ g ç (A ¿ C) Ô (B ¿ D)Æ));
req_thm(€"z_¿_è_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A è B ± g ç C è D ± A ° C = {} ± B ° D = {}
	¥	f ¿ g ç (A ¿ C) è (B ¿ D)Æ));
=ENDDOC

=THDOC
req_thm(€"z_o_≠_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A ≠ B ± g ç B ≠ C
	¥	g o f ç A ≠ CÆ));
req_thm(€"z_o_Ô_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A Ô B ± g ç B Ô C
	¥	g o f ç A Ô CÆ));
req_thm(€"z_o_‡_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A ‡ B ± g ç B ‡ C
	¥	g o f ç A ‡ CÆ));
req_thm(€"z_o_è_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A è B ± g ç B è C
	¥	g o f ç A è CÆ));
req_thm(€"z_rel_inv_è_thm"›,([], ÒµA:U; B:U; f:U∑ 
		f ç A è B  ¥ f Á~Í ç B è AÆ));
req_thm(€"z_id_thm1"›,([], ÒµX:U; x, y:U∑ (x, y) ç id X § x ç X ± x = yÆ));
req_thm(€"z_id_è_thm"›,([], ÒµX:U∑ id X ç X è XÆ));
req_thm(€"z_simple_swap_è_thm"›,([], Òµx, y:U∑ {(x, y), (y, x)} ç {x, y} è {x, y}Æ));
req_thm(€"z_swap_è_thm"›,([], ÒµX:U∑ µx, y:X∑ ∂g : X è X∑ (x, y) ç g ± (y, x) ç gÆ));
req_thm(€"z_è_trans_thm"›,([], ÒµX:U∑ µx, y:X∑ ∂g : X è X∑ (x, y) ç gÆ));
req_thm(€"z_dom_f_™_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ™ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ™ fÆ));
req_thm(€"z_dom_f_≠_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ≠ fÆ));
req_thm(€"z_dom_f_Ô_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f Ô fÆ));
req_thm(€"z_dom_f_‡_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ‡ fÆ));
=ENDDOC

=THDOC
req_thm(€"z_dom_f_è_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f è fÆ));
req_thm(€"z_°_™_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X ™ Y ∑
		(f ° g) ç dom (f ° g) ™ ran(f ° g)Æ));
req_thm(€"z_™_ran_thm"›,([], ÒµX:U; f:U ∑ f ç X ™ ran f § f ç X ™ UÆ));
req_thm(€"z_≠_ran_thm"›,([], ÒµX:U; f:U ∑ f ç X ≠ ran f § f ç X ≠ UÆ));
req_thm(€"z_°_≠_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X ≠ Y ∑
		(f ° g) ç dom (f ° g) ≠ ran(f ° g)Æ));
req_thm(€"z_°_‡_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X ‡ Y ∑
		(f ° g) ç dom (f ° g) ‡ ran(f ° g)Æ));
req_thm(€"z_Ô_ran_thm"›,([], ÒµX:U; Y:U; f:U | f ç X ≠ Y ∑ 
		f ç dom f Ô ran fÆ));
req_thm(€"z_°_Ô_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X Ô Y ∑
		(f ° g) ç dom (f ° g) Ô ran(f ° g)Æ));
req_thm(€"z_°_è_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X è Y ∑
		(f ° g) ç dom (f ° g) è ran(f ° g)Æ));

req_thm(€"z_≠_diff_singleton_thm"›,([], ÒµX:U; Y:U∑ µ f:X ≠ Y; x:U; y:U∑ 
	(x, y) ç f ¥
	(f \ {(x, y)}) ç (X \ {x}) ≠ Y Æ));
req_thm(€"z_è_diff_singleton_thm"›,([], ÒµX:U; Y:U∑ µ f:X è Y; x:X; y:Y∑ 
	(x, y) ç f ¥
	(f \ {(x, y)}) ç (X \ {x}) è (Y \ {y})Æ));
req_thm(€"z_singleton_app_thm"›,([], Òµx : U; y: U∑ {(x, y)} x = yÆ));
req_thm(€"z_empty_Ô_thm"›,([], ÒµX: U∑ (∂f: {} Ô X∑ true) § X = {}Æ));
req_thm(€"z_≠_empty_thm"›,([], ÒµX: U∑ (∂f: X ≠ {}∑ true) § X = {}Æ));
=DESCRIBE

=ENDDOC

=THDOC
req_thm(€"z_´_Ì_app_thm"›, 
	([], Ò(µf : U; x : U; y : U ∑ (f ´ {x Ì y}) x = y)Æ));
req_thm(€"z_´_Ì_app_thm1"›, 
	([], Ò[X, Y](µf : X ≠ Y; x2 : X; x1 : U; y : U | 
	≥ x2 = x1 ∑
	(f ´ {x1 Ì y}) x2 = f x2)Æ));
req_thm(€"z_dom_´_Ì_thm"›, 
	([], Òµf : U; x : U; y : U ∑
	dom(f ´ {x Ì y}) = dom f ¿ {x}Æ));
req_thm(€"z_´_Ì_ç_≠_thm"›, 
	([], Ò[X, Y](µf : X ≠ Y; x : X; y : Y ∑
	f ´ {x Ì y} ç X ≠ Y)Æ));
=DESCRIBE

=ENDDOC

\subsubsection{Theorems of the Theory}

=DOC
val €z_Ú_≠_thm› : THM;				val €z_ran_Ú_thm› : THM;
val €z_ç_≠_thm› : THM;				val €z_≠_ran_eq_Ô_thm› : THM;
val €z_‡_ran_eq_è_thm› : THM;			val €z_ran_mono_thm› : THM;
val €z_ﬂ_thm2› : THM;				val €z_Ô_thm1› : THM;
val €z_˛_thm1› : THM;				val €z_≠_dom_thm› : THM;
val €z_‡_thm1› : THM;				val €z_¿_™_thm› : THM;
val €z_ran_¿_thm› : THM;				val €z_¿_≠_thm› : THM;
val €z_¿_‡_thm› : THM;				val €z_¿_Ô_thm› : THM;
val €z_¿_è_thm› : THM;				val €z_o_≠_thm› : THM;
val €z_o_Ô_thm› : THM;				val €z_o_‡_thm› : THM;
val €z_o_è_thm› : THM;				val €z_rel_inv_è_thm› : THM;
val €z_id_thm1› : THM;				val €z_id_è_thm› : THM;
val €z_simple_swap_è_thm› : THM;		val €z_swap_è_thm› : THM;
val €z_è_trans_thm› : THM;			val €z_dom_f_™_f_thm› : THM;
val €z_dom_f_≠_f_thm› : THM;			val €z_dom_f_Ô_f_thm› : THM;
val €z_dom_f_‡_f_thm› : THM;			val €z_dom_f_è_f_thm› : THM;
val €z_°_™_thm› : THM;				val €z_™_ran_thm› : THM;
val €z_≠_ran_thm› : THM;				val €z_°_≠_thm› : THM;
val €z_°_‡_thm› : THM;				val €z_Ô_ran_thm› : THM;
val €z_°_Ô_thm› : THM;				val €z_°_è_thm› : THM;
val €z_≠_diff_singleton_thm› : THM;		val €z_è_diff_singleton_thm› : THM;
val €z_singleton_app_thm› : THM;			val €z_empty_Ô_thm› : THM;
val €z_≠_empty_thm› : THM;				val €z_´_Ì_app_thm› : THM;
val €z_´_Ì_app_thm1› : THM;				val €z_dom_´_Ì_thm› : THM;
val €z_´_Ì_ç_≠_thm› : THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_functions1$.
=ENDDOC

\subsection{EPILOGUE OF ZFunctions1}
=SML
end; (* of signature ZFunctions1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX
=THSML
summarize_td_results ();
val z_functions1_success = theory_check_success ();
initialise_td_results();
=TEX
\section{ZNumbers1}
\subsection{PROLOGUE FOR ZNumbers1}
=SML
open_theory"z_functions1";
delete_theory"z_numbers1" handle Fail _ => ();
new_theory"z_numbers1";
new_parent"z_numbers";
new_parent"z_arithmetic_tools";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZNumbers1}
=DOC
signature €ZNumbers1› = sig
=DESCRIBE
This provides additional proof support for the Z library functions.
It creates the theory $z\_functions1$.
=ENDDOC
=THDOC
req_name €"z_numbers1"› (Value "z_numbers");
req_parent "z_arithmetic_tools";
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_numbers1$ contains various theorems about numbers.
It is created in structure $ZNumbers1$.
=ENDDOC

=THDOC
req_thm(€"z_dot_dot_clauses"›,([], Òµi, i1, i2, j1, j2:U∑
	(i ç i1 .. i2 § i1 º i º i2)
±	(i1 .. i2 = {} § i2 < i1)
±	(i1 .. i2 Ä j1 .. j2 § i2 < i1 ≤ (j1 º i1 ± i2 º j2))Æ));
req_thm(€"z_dot_dot_plus_thm"›,([], Òµn, i1, i2 : U∑
	{i : i1 .. i2 ∑ i + n} = i1 + n .. i2 + nÆ));
req_thm(€"z_less_cases_thm"›,([], Òµi, j:U∑ i < j ≤ i = j ≤ j < iÆ));
req_thm(€"z_º_º_plus1_thm"›,([], Òµi, j:U∑ i º j º i + 1 § j = i ≤ j = i + 1Æ));
req_thm(€"z_dot_dot_diff_thm"›,([], Òµi:Ó∑ (1 .. i + 1) \ {i + 1} = 1 .. iÆ));
req_thm(€"z_dot_dot_¿_thm"›,([], Òµi:Ó∑ (1 .. i) ¿ {i + 1} = 1 .. i + 1Æ));
req_thm(€"z_dot_dot_°_thm"›,([], Òµi:Ó∑ (1 .. i) ° {i + 1} = {}Æ));
req_thm(€"z_empty_Ê_thm"›,([], Ò[X]({} ç Ê X)Æ));
req_thm(€"z_Ê_¿_singleton_thm"›,([], Ò[X](µx : X; a : Ê X∑ (a ¿ {x}) ç Ê X)Æ));
req_thm(€"z_Ê_thm1"›,([], Ò[X](Ê X = •{u :   X| {} ç u 
	± (µ x:X; a:u∑ (a ¿ {x}) ç u)})Æ));
req_thm(€"z_Ê_induction_thm"›,([], ¨µ X p ∑
		p Ò{}Æ
	±	(µ x a∑ p ÒaÆ ± Òa ç Ê XÆ ± Òx ç XÆ ± Ò≥x ç aÆ ¥ p Òa ¿ {x}Æ)
      ¥ (µ a∑ Òa ç Ê XÆ ¥ p a)Æ));
req_thm(€"z_Ê__thm"›,([], Ò[X](Ê X =  X ° (Ê_))Æ));
req_thm(€"z_Ê_size_thm"›,([], ÒµA:U; f:U; n:Ó| f ç 1 .. n è A∑ A ç (Ê _) ± # A = nÆ));
req_thm(€"z_size_empty_thm"›,([], Ò({} ∫  X) ç (Ê_) ± # ({} ∫  X) = 0Æ));
req_thm(€"z_size_singleton_thm"›,([], Òµx : U∑ {x} ç (Ê_) ± # {x} = 1Æ));
req_thm(€"z_size_dot_dot_thm"›,([], Òµn:Ó∑ 1 .. n ç (Ê _) ± # (1 .. n) = nÆ));
req_thm(€"z_size_ü_thm"›,([], ÒµX:U; Y:U; f:U | f ç X ü Y ∑ f ç (Ê_) 
	± #f = #(dom f)Æ));
req_thm(€"z_size_seq_thm"›,([], ÒµX:U; f:U; n : Ó | f ç 1 .. n ≠ X ∑ #f = nÆ));
req_thm(€"z_size_¿_singleton_thm"›,([], Òµa : (Ê_); x: U | ≥x ç a ∑ 
	# (a ¿ {x}) = #a + 1Æ));
req_thm(€"z_Ê_°_thm"›,([], Òµa, b : U | a ç (Ê_) ≤ b ç (Ê_) ∑ (a ° b) ç (Ê_)Æ));
req_thm(€"z_Ê_diff_thm"›,([], Òµa, b : U | a ç (Ê_) ∑ (a \ b) ç (Ê_)Æ));
req_thm(€"z_size_¿_thm"›,([], Òµa, b : (Ê_)∑ (a ¿ b) ç (Ê_) 
	± # (a ¿ b) + #(a ° b) = #a + #bÆ));
req_thm(€"z_ﬁ_Ê_thm"›,([], Òµu : Ê(Ê_)∑ ﬁu ç (Ê_)Æ));
req_thm(€"z_size_diff_thm"›,([], Òµ a : (Ê _); b: U ∑ a \ b ç (Ê _) 
	±  # (a \ b) + # (a ° b) = # aÆ));
req_thm(€"z_size_Ó_thm"›,([], Òµa : (Ê_) ∑ # a ç ÓÆ));
req_thm(€"z_size_mono_thm"›,([], Òµa : (Ê_); b: U | b Ä a ∑ #b º #aÆ));
req_thm(€"z_size_¿_º_thm"›,([], Òµa, b : (Ê_)  ∑ #(a ¿ b) º #a + #bÆ));
req_thm(€"z_size_0_thm"›,([], Òµa : (Ê_) ∑ # a = 0 § a = {}Æ));
req_thm(€"z_size_1_thm"›,([], Òµa : (Ê_) ∑ # a = 1 § (∂x:U∑ a = {x})Æ));
=ENDDOC

=THDOC
req_thm(€"z_size_º_1_thm"›,([], Òµa : (Ê_) | # a º 1 ∑ a = {} ≤ (∂x:U∑a = {x})Æ));
req_thm(€"z_size_dot_dot_thm1"›,([], Òµi,j : ˙ ∑ i .. j ç (Ê_) ±
		(i º j ¥ # (i .. j) = (j + ~ i) + 1) ±
		(j < i ¥ # (i .. j) = 0)Æ));
req_thm(€"z_pigeon_hole_thm"›,([], Òµu : Ê (Ê_) | # (ﬁu) > # u ∑ ∂a:u∑ #a > 1Æ));
req_thm(€"z_div_thm"›,([], Òµ i,j,k : ˙ | ≥j = 0 ∑ (i div j = k) § 
		(∂ m : ˙ ∑ i = k * j + m ± 0 º m ± m < abs j)Æ));
req_thm(€"z_mod_thm"›,([], Òµ i,j,k : ˙ | ≥j = 0 ∑ (i mod j = k) § 
		(∂ d : ˙ ∑ i = d * j + k ± 0 º k ± k < abs j)Æ));
req_thm(€"z_abs_pos_thm"›,([], Òµ i:˙| 0 < i ∑ abs i = i ± abs ~ i = iÆ));
req_thm(€"z_abs_neg_thm"›,([], Òµ i:˙| i < 0 ∑ abs i = ~i ± abs ~ i = ~iÆ));
req_thm(€"z_abs_º_times_thm"›,([], Òµ i,j:˙| ≥ i = 0 ± ≥ j = 0 ∑ abs j º abs (i * j)Æ));
req_thm(€"z_abs_0_less_thm"›,([], Òµ i:˙| ≥ i = 0 ∑ 0 < abs iÆ));
req_thm(€"z_0_less_times_thm"›,([], Òµ i,j : ˙ ∑ 
	0 < i * j § (0 < i ± 0 < j) ≤ (i < 0 ± j < 0)Æ));
req_thm(€"z_times_less_0_thm"›,([], Òµ i,j : ˙  ∑ 
	i * j < 0 § (0 < i ± j < 0) ≤ (i < 0 ± 0 < j)Æ));
=DESCRIBE

=ENDDOC

=THDOC
req_thm(€"z_ç_succ_thm"›,([], ¨µ i j ∑
	Ò(i, j) ç succ § (0 º i) ± (j = i + 1)ÆÆ));
req_thm(€"z_succÁ0Í_thm"›,([], Òsucc Á 0 Í  = id ˙Æ));
req_thm(€"z_succÁnÍ_thm"›,
	([], Òµ n : ˙ | 1 º n ∑ succ Á n Í  = {m : Ó ∑ (m Ì m + n)}Æ));
req_thm(€"z_succÁminus_nÍ_thm"›,([], Òµ n : Ó | 1 º n ∑ succ Á ~ n Í  = {m : Ó  ∑ (m + n Ì m)}Æ));
=DESCRIBE
Some additional material on $succ$.
=ENDDOC
=DOC
val €z_Ê_induction_tac› : TERM -> TACTIC;
=DESCRIBE
An induction tactic for Z finite sets.  To prove
=INLINEFT
s ç Ê A ¥ t
=TEX
, it suffices to prove
=INLINEFT
t[{}/s]
=TEX
\ and to prove
=INLINEFT
t[s ¿ {x}/s]
=TEX
\ on the
assumptions $t$,
=INLINEFT
s ç Ê A
=TEX
,
=INLINEFT
x ç A
=TEX
\ and
=INLINEFT
≥x ç s
=TEX
.  The term argument must be a variable
of the same type as a Z set and must appear free in the conclusion of the goal.
It must also appear once, and only once, in an
assumption of the form
=INLINEFT
s ç Ê A
=TEX
.
=FRULE 2 Tactic
z_Ê_induction_tac ÒsÆ
˜
{ á, s ç Ê A} t[s]
˜
{ á } t[{}/s] ;
strip {t, s ç Ê A, x ç A, ≥x ç s, á} t[s ¿ {x}/s]
=TEX
=ENDDOC

=DOC
val €z_size_dot_dot_conv› : CONV;
=DESCRIBE
This conversion will calculate the size of a range between two integer 
literals, including the empty range case when the end of the range is less than the start.
=EXAMPLE
z_size_dot_dot_conv Òsize (1 .. 5) Æ gives
	Ù size (1 .. 5) = 5

z_size_dot_dot_conv Òsize (10 .. 1) Æ gives
	Ù size (10 .. 1) = 0
=TEX
=FAILURE
107001	?0 is not of the form Òsize(a .. b)Æ where ÒaÆ and ÒbÆ are integer literals
=ENDDOC

\subsubsection{Theorems of the Theory}

=DOC
val €z_dot_dot_clauses› : THM;			val €z_dot_dot_plus_thm› : THM;
val €z_less_cases_thm› : THM;			val €z_º_º_plus1_thm› : THM;
val €z_dot_dot_diff_thm› : THM;			val €z_dot_dot_¿_thm› : THM;
val €z_dot_dot_°_thm› : THM;			val €z_empty_Ê_thm› : THM;
val €z_Ê_¿_singleton_thm› : THM;			val €z_Ê_thm1› : THM;
val €z_Ê_induction_thm› : THM;			val €z_Ê_size_thm› : THM;
val €z_size_empty_thm› : THM;			val €z_size_singleton_thm› : THM;
val €z_size_dot_dot_thm› : THM;			val €z_size_ü_thm› : THM;
val €z_size_seq_thm› : THM;				val €z_size_¿_singleton_thm› : THM;
val €z_Ê_°_thm› : THM;				val €z_Ê_diff_thm› : THM;
val €z_size_¿_thm› : THM;				val €z_ﬁ_Ê_thm› : THM;
val €z_size_diff_thm› : THM;			val €z_size_Ó_thm› : THM;
val €z_size_mono_thm› : THM;			val €z_size_¿_º_thm› : THM;
val €z_size_0_thm› : THM;				val €z_size_1_thm› : THM;
val €z_size_º_1_thm› : THM;			val €z_size_dot_dot_thm1› : THM;
val €z_pigeon_hole_thm› : THM;			val €z_Ê__thm› : THM;
val €z_div_thm› : THM;				val €z_mod_thm› : THM;
val €z_abs_pos_thm› : THM;				val €z_abs_neg_thm› : THM;
val €z_abs_º_times_thm› : THM;			val €z_abs_0_less_thm› : THM;
val €z_0_less_times_thm› : THM;			val €z_times_less_0_thm› : THM;
val €z_ç_succ_thm› :THM;			val €z_succÁ0Í_thm› :THM;
val €z_succÁnÍ_thm› :THM;			val €z_succÁminus_nÍ_thm› :THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_numbers1$.
=ENDDOC

\subsection{EPILOGUE OF ZNumbers1}
=SML
end; (* of signature ZNumbers1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX
=THSML
summarize_td_results ();
val z_numbers1_success = theory_check_success ();
initialise_td_results();
=TEX
\section{ZSequences1}
\subsection{PROLOGUE FOR ZSequences1}
=SML
open_theory"z_numbers1";
delete_theory"z_sequences1" handle Fail _ => ();
new_theory"z_sequences1";
new_parent "z_sequences";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZSequences1}
=DOC
signature €ZSequences1› = sig
=DESCRIBE
This provides additional proof support for the Z library sequences.
It creates the theory $z\_sequences1$.
=ENDDOC
=THDOC
req_name €"z_sequences1"› (Value "z_sequences");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_sequences1$ contains various theorems about functions.
It is created in structure $ZSequences1$.
=ENDDOC

=THDOC
req_thm(€"z_seq_thm"›,([], ÒµX:U∑ seq X = ﬁ{n : Ó∑ 1 .. n ≠ X}Æ));
req_thm(€"z_prim_seq_induction_thm"›,([], ¨µ X p ∑
		p Ò{}Æ
	±	(µ x n s∑
			Òx ç XÆ ± Òn ç ÓÆ ± Òs ç 1 .. n ≠ XÆ ± p ÒsÆ
		¥	p Òs ¿ {(n + 1, x)}Æ)
      ¥ (µ s∑ Òs ç (seq X)Æ ¥ p s)Æ));
req_thm(€"z_seq_thm1"›,([], ÒµX:U; n:U∑ seq X = {s:U | ∂n: Ó∑ s ç 1 .. n ≠ X}Æ));
req_thm(€"z_size_seq_thm1"›,([], ÒµX:U; n:Ó∑ s ç seq X ± #s = n § s ç 1 .. n ≠ XÆ));
req_thm(€"z_size_seq_thm2"›,([], Òµn:Ó; s : (seq _)∑ #s = n § dom s = 1 .. nÆ));
req_thm(€"z_size_seq_Ó_thm"›,([], Òµs : (seq _)∑ #s ç ÓÆ));
req_thm(€"z_singleton_seq_thm"›,([], Òµx : U∑
	ßx¢ ç (seq _) ± dom ßx¢ = {1} ± ran ßx¢ = {x} ± ßx¢ 1 = xÆ));
req_thm(€"z_seq_u_thm"›,([], ÒµX:U∑ µ s:seq X∑s ç (seq _)Æ));
req_thm(€"z_Î_thm"›,([], ÒµX, Y:U∑ µ s:seq X; t:seq Y∑
	s Î t  = s ¿ {n : dom t ∑ n + # s Ì t n}Æ));
req_thm(€"z_Î_ç_seq_thm"›,([], ÒµX, Y:U∑ µ s:seq X; t:seq Y∑s Î t ç (seq _)Æ));
req_thm(€"z_Î_ç_seq_thm1"›,([], Òµ s : (seq _); t : (seq _) ∑ s Î t ç (seq _)Æ));
req_thm(€"z_Î_def_thm"›,([], Òµi : U; t : (seq _)∑
		{n : dom t ∑ n + i Ì t n}
	=	{n : U; x : U | (n, x) ç t ∑ (n + i, x)}Æ));
req_thm(€"z_Î_singleton_thm"›,([], Ò[X](µs : seq X; x: X∑ s Î ßx¢ = s ¿ {(#s + 1, x)})Æ));
req_thm(€"z_Î_singleton_thm1"›,([], Òµ s : (seq _); x : U ∑ s Î ßx¢ = s ¿ {(# s + 1, x)}Æ));
req_thm(€"z_ß¢_thm"›,([], Òß¢ = {}Æ));
req_thm(€"z_ß¢_seq_thm"›,([], ÒµX:U∑ ß¢ ç seq XÆ));
req_thm(€"z_seq_induction_thm"›,([], ¨µ X p ∑
		p Òß¢Æ
	±	(µ x s∑
			Òx ç XÆ ± Òs ç seq XÆ ± p ÒsÆ
		¥	p Òs Î ßx¢Æ)
      ¥ (µ s∑ Òs ç (seq X)Æ ¥ p s)Æ));
req_thm(€"z_Î_ß¢_thm"›,([], Òµ X : U
    ∑ µ s : seq X ∑
		s Î ß¢ = sÆ));
req_thm(€"z_ß¢_Î_thm"›,([], Òµ X : U
    ∑ µ s : seq X ∑
		ß¢ Î s = sÆ));
req_thm(€"z_dom_seq_thm"›,([], Òµ s : (seq _) ∑ dom s = 1 .. #sÆ));
=ENDDOC

=THDOC
req_thm(€"z_dom_Î_thm"›,([], Òµ s : (seq _); t : (seq _) ∑ dom(s Î t) = 1 .. (#s + #t)Æ));
req_thm(€"z_size_Î_thm"›,([], Òµ s, t : (seq _); x:U ∑#(s Î t) = #s + #tÆ));
req_thm(€"z_size_singleton_seq_thm"›,([], Òµ x:U ∑#ßx¢ = 1Æ));
req_thm(€"z_seq_cases_thm"›,([], Òµ s : (seq _)∑
		s = ß¢ ≤ (∂s1 : (seq _); x:U∑ s = s1 Î ßx¢)Æ));
req_thm(€"z_≥_Î_empty_thm"›,([], Òµ s : (seq _); x:U∑ ≥s Î ßx¢ = ß¢Æ));
req_thm(€"z_Î_one_one_thm"›,([], Òµ s : (seq _); t : (seq _); x, y:U ∑
		s Î ßx¢ = t Î ßy¢ § s = t ± x = yÆ));
req_thm(€"z_Î_assoc_thm"›,([], Òµ s1, s2, s3 : (seq _)∑ (s1 Î s2) Î s3 = s1 Î (s2 Î s3)Æ));
=DESCRIBE

=ENDDOC

=THDOC
req_thm("z_num_list_thm", ([], ¨µ l n∑
	Ò¨Z'NumList (l, n)ÆÆ =
	Ò{i : U; x : U | (i, x) ç ¨$"Z'ß¢" lÆ ∑ (i + ¨Z'Int nÆ, x)}ÆÆ));
req_thm("z_seqd_ç_seq_thm", ([], ¨µ l∑ Ò¨$"Z'ß¢" lÆÆ ç Ò(seq _)ÆÆ));
req_thm("z_seqd_Î_thm", ([], ¨µ a l∑ Ò¨$"Z'ß¢" (Cons a l)ÆÆ = Òßa¢ Î ¨$"Z'ß¢" lÆÆÆ));
req_thm("z_seqd_Î_rw_thm", ([], ¨µ a b l∑
	Ò¨$"Z'ß¢" (Cons a (Cons b l))ÆÆ = Òßa¢ Î ßb¢ Î ¨$"Z'ß¢" lÆÆÆ));
req_thm("z_ç_seq_app_eq_thm", ([], Òµ s : (seq _); m : U; x : U ∑ (m, x) ç s ¥ s m = xÆ));
req_thm("z_ç_seqd_app_eq_thm", ([], ¨µ l m x∑ Ò(m, x)Æ ç Ò¨$"Z'ß¢" lÆÆ ¥ Ò¨$"Z'ß¢" lÆ mÆ = xÆ));
req_thm("z_size_seqd_thm", ([], ¨
	Ò#ß¢ = 0Æ
±	µa :'a; l∑Ò#¨$"Z'ß¢" (Cons a l)ÆÆ = Ò1 + #¨$"Z'ß¢" lÆÆÆ));
req_thm("z_size_seqd_length_thm", ([], ¨µ l∑ Ò# ¨$"Z'ß¢" lÆÆ = Ò¨Z'Int (Length l)ÆÆÆ));
req_thm("z_dom_seqd_thm", ([], ¨µ l∑ Òdom ¨$"Z'ß¢" lÆÆ = Ò1 .. # ¨$"Z'ß¢" lÆÆÆ));
req_thm("z_ran_seqd_thm", ([], ¨µ l∑ Òran ¨$"Z'ß¢" lÆÆ = Ò¨Z'Setd lÆÆÆ));
req_thm("z_seqd_Î_ß¢_clauses", ([], ¨µ l∑
		Ò¨$"Z'ß¢" lÆ Î ß¢Æ = Ò¨$"Z'ß¢" lÆÆ
	±	Òß¢ Î ¨$"Z'ß¢" lÆÆ = Ò¨$"Z'ß¢" lÆÆÆ));
=DESCRIBE

=ENDDOC

\subsubsection{Theorems of the Theory}

=DOC
val €z_seq_thm› : THM;				val €z_prim_seq_induction_thm› : THM;
val €z_seq_thm1› : THM;				val €z_size_seq_thm1› : THM;
val €z_size_seq_thm2› : THM;			val €z_size_seq_Ó_thm› : THM;
val €z_singleton_seq_thm› : THM;			val €z_seq_u_thm› : THM;
val €z_Î_thm› : THM;				val €z_Î_ç_seq_thm› : THM;
val €z_Î_ç_seq_thm1› : THM;			val €z_Î_def_thm› : THM;
val €z_Î_singleton_thm› : THM;			val €z_Î_singleton_thm1› : THM;
val €z_ß¢_thm› : THM;				val €z_ß¢_seq_thm› : THM;
val €z_seq_induction_thm› : THM;			val €z_Î_ß¢_thm› : THM;
val €z_ß¢_Î_thm› : THM;				val €z_dom_seq_thm› : THM;
val €z_dom_Î_thm› : THM;				val €z_size_Î_thm› : THM;
val €z_size_singleton_seq_thm› : THM;		val €z_seq_cases_thm› : THM;
val €z_≥_Î_empty_thm› : THM;			val €z_Î_one_one_thm› : THM;
val €z_Î_assoc_thm› : THM;				val €z_num_list_thm› : THM;
val €z_seqd_ç_seq_thm› : THM;			val €z_seqd_Î_thm› : THM;
val €z_ç_seqd_app_eq_thm› : THM;			val €z_seqd_Î_rw_thm› : THM;
val €z_ç_seq_app_eq_thm› : THM;			val €z_size_seqd_thm› : THM;
val €z_size_seqd_length_thm› : THM;			val €z_dom_seqd_thm› : THM;
val €z_ran_seqd_thm› : THM;			val €z_seqd_Î_ß¢_clauses› : THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_sequences1$.
=ENDDOC

=DOC
val €z_seq_induction_tac› : TERM -> TACTIC;
=DESCRIBE
An induction tactic for Z sequences.  To prove
=INLINEFT
s ç seq A ¥ t
=TEX
, it suffices to prove
=INLINEFT
t[ß¢/s]
=TEX
\ and to prove
=INLINEFT
t[s Î ßx¢/s]
=TEX
\ on the
assumptions $t$,
=INLINEFT
s ç seq A
=TEX
\ and
=INLINEFT
x ç A
=TEX
.  The term argument must be a variable
of the same type as a Z sequence and must appear free in the conclusion of the goal.
It must also appear once, and only once, in an
assumption of the form
=INLINEFT
s ç seq A
=TEX
.
=FRULE 2 Tactic
z_seq_induction_tac ÒsÆ
˜
{ á, s ç seq A} t[s]
˜
{ á } t[ß¢/s] ;
strip {t, s ç seq A, x ç A, á} t[s Î ßx¢/s]
=TEX
=ENDDOC
=DOC
	val €z_seqd_app_conv› : CONV;
	val €z_size_seqd_conv› : CONV;
=DESCRIBE
Conversions for sequence displays.

=INLINEFT
z_seqd_app_conv
=TEX
\ applies to terms of the form $s m$, where $s$ is a sequence display and $m$ is
a numeric literal.

=INLINEFT
z_size_seqd_conv
=DESCRIBE
=TEX
\ applies to terms of the form $\# s$, where $s$ is a sequence display.

=FAILURE
107011	?0 is not of the form ¨ßt1, ...¢ mÆ
107012	?0 is not a positive integer literal
107013	?0 is not a valid index for the sequence ?1
107021	?0 is not of the form ¨#ßt1, ...¢Æ
=ENDDOC

\subsection{EPILOGUE OF ZSequences1}
=SML
end; (* of signature ZSequences1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=THSML
summarize_td_results ();
val z_sequences1_success = theory_check_success ();
=TEX
\section{TEST POLICY}
The module tests for these modules are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


