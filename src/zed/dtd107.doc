%  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Z Finiteness and Sequences}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD085}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Draft}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Team Leader}
\TPPabstract{This document contains the detailed design of
the theories $z\_functions1$, $z\_numbers1$, and $z\_sequences1$ and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Project Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1, 1.2 (15th January 1995)]
First versions, derived from wrk056.
\item[Issue 1.3 (24th January 1995)]
Corrected duplicate namings.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design of
the theories $z\_functions1$, $z\_numbers1$, and $z\_sequences1$ and their proof support, parts
of the mathematical toolkit for HOL/Z.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD017}.
\subsection{Dependencies}
Loading this document and its implementation requires that
\cite{DS/FMU/IED/IMP088} has been loaded.
\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.
\section{ZFunctions1}
\subsection{PROLOGUE FOR ZFunctions1}

=SML
open_theory"z_functions";
delete_theory"z_sequences1" handle Fail _ => ();
delete_theory"z_numbers1" handle Fail _ => ();
delete_theory"z_functions1" handle Fail _ => ();
new_theory"z_functions1";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZFunctions1}
=DOC
signature €ZFunctions1› = sig
=DESCRIBE
This provides additional proof support for the Z library functions.
It creates the theory $z\_functions1$.
=ENDDOC
=THDOC
req_name €"z_functions1"› (Value "z_functions");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_functions1$ contains various theorems about functions.
It is created in structure $ZFunctions1$.
=ENDDOC

=THDOC
req_thm(€"z_Ú_≠_thm"›,([], Ò[Y, Z](µX:U; f:Y ≠ Z∑ X Ä Y ¥ (X Ú f) ç X ≠ (ran (X Ú f)))Æ));
req_thm(€"z_ran_Ú_thm"›,([], Ò[Y, Z](µX:U; f:Y ≠ Z∑
	ran(X Ú f) = ran f \ {y : U | µx : U | (x, y) ç f ∑ ≥x ç X})Æ));
req_thm(€"z_ç_≠_thm"›,([], Ò(µX:U; Y:U∑ µ f:X ≠ Y; x:U; y:U | (x, y) ç f ∑ x ç X ± y ç Y)Æ));
req_thm(€"z_≠_ran_eq_Ô_thm"›,([], Ò(µA:U; B : U∑ (∂f : A ≠ B∑ ran f = B) § (∂f : A Ô B∑ true))Æ));
req_thm(€"z_‡_ran_eq_è_thm"›,([], Ò(µA:U; B : U∑ (∂f : A ‡ B∑ ran f = B) § (∂f : A è B∑ true))Æ));
req_thm(€"z_ran_mono_thm"›,([], ÒµX:U; Y, Z:U; f:U | f ç X ≠ Y ± ran f Ä Z ∑ f ç X ≠ ZÆ));
req_thm(€"z_ﬂ_thm2"›,([], ÒµA:U; B:U; f:U∑ f ç  A ﬂ B § f ç dom f ≠ B ± dom f Ä AÆ));
req_thm(€"z_Ô_thm1"›,([], ÒµA:U; B:U; f:U∑ f ç A Ô B § f ç A ≠ B ± B Ä ran fÆ));
req_thm(€"z_˛_thm1"›,([], Ò [X, Y]
	(X ˛ Y =
	{f : X ﬂ Y | µ x1, x2 : U; y:U∑ (x1, y) ç f ± (x2, y) ç f¥ x1 = x2})Æ));
req_thm(€"z_≠_dom_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	f ç dom f ≠ BÆ));
req_thm(€"z_‡_thm1"›,([], ÒµA:U; B:U; f:U∑
		f ç A ‡ B
	§	f ç A ≠ B ± (µx, y:U; z:U∑ (x, z) ç f ± (y, z) ç f ¥ x = y)Æ));
req_thm(€"z_¿_™_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
			f ç A ™ B ± g ç C ™ D
		¥	f ¿ g ç (A ¿ C) ™ (B ¿ D)Æ));
req_thm(€"z_ran_¿_thm"›,([], Òµf:U; g:U∑ran (f ¿ g) = ran f ¿ ran gÆ));
req_thm(€"z_¿_≠_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A ≠ B ± g ç C ≠ D ± A ° C = {}
	¥	f ¿ g ç (A ¿ C) ≠ (B ¿ D)Æ));
req_thm(€"z_¿_‡_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A ‡ B ± g ç C ‡ D ± A ° C = {} ± B ° D = {}
	¥	f ¿ g ç (A ¿ C) ‡ (B ¿ D)Æ));
req_thm(€"z_¿_Ô_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A Ô B ± g ç C Ô D ± A ° C = {}
	¥	f ¿ g ç (A ¿ C) Ô (B ¿ D)Æ));
req_thm(€"z_¿_è_thm"›,([], ÒµA:U; B:U; C:U; D:U; f:U; g:U∑ 
		f ç A è B ± g ç C è D ± A ° C = {} ± B ° D = {}
	¥	f ¿ g ç (A ¿ C) è (B ¿ D)Æ));
req_thm(€"z_o_≠_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A ≠ B ± g ç B ≠ C
	¥	g o f ç A ≠ CÆ));
req_thm(€"z_o_Ô_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A Ô B ± g ç B Ô C
	¥	g o f ç A Ô CÆ));
req_thm(€"z_o_‡_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A ‡ B ± g ç B ‡ C
	¥	g o f ç A ‡ CÆ));
req_thm(€"z_o_è_thm"›,([], ÒµA:U; B:U; C:U; f:U; g:U∑ 
		f ç A è B ± g ç B è C
	¥	g o f ç A è CÆ));
req_thm(€"z_rel_inv_è_thm"›,([], ÒµA:U; B:U; f:U∑ 
		f ç A è B  ¥ f Á~Í ç B è AÆ));
req_thm(€"z_id_thm1"›,([], ÒµX:U; x, y:U∑ (x, y) ç id X § x ç X ± x = yÆ));
req_thm(€"z_id_è_thm"›,([], ÒµX:U∑ id X ç X è XÆ));
req_thm(€"z_simple_swap_è_thm"›,([], Òµx, y:U∑ {(x, y), (y, x)} ç {x, y} è {x, y}Æ));
req_thm(€"z_swap_è_thm"›,([], ÒµX:U∑ µx, y:X∑ ∂g : X è X∑ (x, y) ç g ± (y, x) ç gÆ));
req_thm(€"z_è_trans_thm"›,([], ÒµX:U∑ µx, y:X∑ ∂g : X è X∑ (x, y) ç gÆ));
req_thm(€"z_dom_f_™_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ™ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ™ fÆ));
req_thm(€"z_dom_f_≠_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ≠ fÆ));
req_thm(€"z_dom_f_Ô_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f Ô fÆ));
req_thm(€"z_dom_f_‡_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ‡ fÆ));
req_thm(€"z_dom_f_è_f_thm"›,([], ÒµA:U; B:U; f:U∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f è fÆ));
req_thm(€"z_°_™_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X ™ Y ∑
		(f ° g) ç dom (f ° g) ™ ran(f ° g)Æ));
req_thm(€"z_™_ran_thm"›,([], ÒµX:U; f:U ∑ f ç X ™ ran f § f ç X ™ UÆ));
req_thm(€"z_≠_ran_thm"›,([], ÒµX:U; f:U ∑ f ç X ≠ ran f § f ç X ≠ UÆ));
req_thm(€"z_°_≠_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X ≠ Y ∑
		(f ° g) ç dom (f ° g) ≠ ran(f ° g)Æ));
req_thm(€"z_°_‡_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X ‡ Y ∑
		(f ° g) ç dom (f ° g) ‡ ran(f ° g)Æ));
req_thm(€"z_Ô_ran_thm"›,([], ÒµX:U; Y:U; f:U | f ç X ≠ Y ∑ f ç dom f Ô ran fÆ));
req_thm(€"z_°_Ô_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X Ô Y ∑
		(f ° g) ç dom (f ° g) Ô ran(f ° g)Æ));
req_thm(€"z_°_è_thm"›,([], ÒµX:U; Y:U; f, g:U | f ç X è Y ∑
		(f ° g) ç dom (f ° g) è ran(f ° g)Æ));

req_thm(€"z_≠_diff_singleton_thm"›,([], ÒµX:U; Y:U∑ µ f:X ≠ Y; x:U; y:U∑ (x, y) ç f ¥
	(f \ {(x, y)}) ç (X \ {x}) ≠ Y Æ));
req_thm(€"z_è_diff_singleton_thm"›,([], ÒµX:U; Y:U∑ µ f:X è Y; x:X; y:Y∑ (x, y) ç f ¥
	(f \ {(x, y)}) ç (X \ {x}) è (Y \ {y})Æ));
req_thm(€"z_singleton_app_thm"›,([], Òµx : U; y: U∑ {(x, y)} x = yÆ));
req_thm(€"z_empty_Ô_thm"›,([], ÒµX: U∑ (∂f: {} Ô X∑ true) § X = {}Æ));
req_thm(€"z_≠_empty_thm"›,([], ÒµX: U∑ (∂f: X ≠ {}∑ true) § X = {}Æ));
=DESCRIBE

=ENDDOC


\subsubsection{Theorems of the Theory}

=DOC
val €z_Ú_≠_thm› : THM;			val €z_ran_Ú_thm› : THM;
val €z_ç_≠_thm› : THM;			val €z_≠_ran_eq_Ô_thm› : THM;
val €z_‡_ran_eq_è_thm› : THM;			val €z_ran_mono_thm› : THM;
val €z_ﬂ_thm2› : THM;			val €z_Ô_thm1› : THM;
val €z_˛_thm1› : THM;			val €z_≠_dom_thm› : THM;
val €z_‡_thm1› : THM;			val €z_¿_™_thm› : THM;
val €z_ran_¿_thm› : THM;			val €z_¿_≠_thm› : THM;
val €z_¿_‡_thm› : THM;			val €z_¿_Ô_thm› : THM;
val €z_¿_è_thm› : THM;			val €z_o_≠_thm› : THM;
val €z_o_Ô_thm› : THM;			val €z_o_‡_thm› : THM;
val €z_o_è_thm› : THM;			val €z_rel_inv_è_thm› : THM;
val €z_id_thm1› : THM;			val €z_id_è_thm› : THM;
val €z_simple_swap_è_thm› : THM;			val €z_swap_è_thm› : THM;
val €z_è_trans_thm› : THM;			val €z_dom_f_™_f_thm› : THM;
val €z_dom_f_≠_f_thm› : THM;			val €z_dom_f_Ô_f_thm› : THM;
val €z_dom_f_‡_f_thm› : THM;			val €z_dom_f_è_f_thm› : THM;
val €z_°_™_thm› : THM;			val €z_™_ran_thm› : THM;
val €z_≠_ran_thm› : THM;			val €z_°_≠_thm› : THM;
val €z_°_‡_thm› : THM;			val €z_Ô_ran_thm› : THM;
val €z_°_Ô_thm› : THM;			val €z_°_è_thm› : THM;
val €z_≠_diff_singleton_thm› : THM;
val €z_è_diff_singleton_thm› : THM;	val €z_singleton_app_thm› : THM;
val €z_empty_Ô_thm› : THM;			val €z_≠_empty_thm› : THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_functions1$.
=ENDDOC

\subsection{EPILOGUE OF ZFunctions1}
=SML
end; (* of signature ZFunctions1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX
=THSML
summarize_td_results ();
val z_functions1_success = theory_check_success ();
initialise_td_results();
=TEX
\section{ZNumbers1}
\subsection{PROLGUE FOR ZNumbers1}
=SML
open_theory"z_functions1";
delete_theory"z_numbers1" handle Fail _ => ();
new_theory"z_numbers1";
new_parent"z_numbers";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZNumbers1}
=DOC
signature €ZNumbers1› = sig
=DESCRIBE
This provides additional proof support for the Z library functions.
It creates the theory $z\_functions1$.
=ENDDOC
=THDOC
req_name €"z_numbers1"› (Value "z_numbers");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_numbers1$ contains various theorems about numbers.
It is created in structure $ZNumbers1$.
=ENDDOC

=THDOC
req_thm(€"z_dot_dot_clauses"›,([], Òµi, i1, i2, j1, j2:U∑
	(i ç i1 .. i2 § i1 º i º i2)
±	(i1 .. i2 = {} § i2 < i1)
±	(i1 .. i2 Ä j1 .. j2 § i2 < i1 ≤ (j1 º i1 ± i2 º j2))Æ));
req_thm(€"z_dot_dot_plus_thm"›,([], Òµn, i1, i2 : U∑
	{i : i1 .. i2 ∑ i + n} = i1 + n .. i2 + nÆ));
req_thm(€"z_less_cases_thm"›,([], Òµi, j:U∑ i < j ≤ i = j ≤ j < iÆ));
req_thm(€"z_º_º_plus1_thm"›,([], Òµi, j:U∑ i º j º i + 1 § j = i ≤ j = i + 1Æ));
req_thm(€"z_dot_dot_diff_thm"›,([], Òµi:Ó∑ (1 .. i + 1) \ {i + 1} = 1 .. iÆ));
req_thm(€"z_dot_dot_¿_thm"›,([], Òµi:Ó∑ (1 .. i) ¿ {i + 1} = 1 .. i + 1Æ));
req_thm(€"z_dot_dot_°_thm"›,([], Òµi:Ó∑ (1 .. i) ° {i + 1} = {}Æ));
req_thm(€"z_empty_Ê_thm"›,([], Ò[X]({} ç Ê X)Æ));
req_thm(€"z_Ê_¿_singleton_thm"›,([], Ò[X](µx : X; a : Ê X∑ (a ¿ {x}) ç Ê X)Æ));
req_thm(€"z_Ê_thm1"›,([], Ò[X](Ê X = •{u :   X| {} ç u ± (µ x:X; a:u∑ (a ¿ {x}) ç u)})Æ));
req_thm(€"z_Ê_induction_thm"›,([], ¨µ X p ∑
		p Ò{}Æ
	±	(µ x a∑ p ÒaÆ ± Òa ç Ê XÆ ± Òx ç XÆ ± Ò≥x ç aÆ ¥ p Òa ¿ {x}Æ)
      ¥ (µ a∑ Òa ç Ê XÆ ¥ p a)Æ));
req_thm(€"z_Ê__thm"›,([], Ò[X](Ê X =  X ° (Ê_))Æ));
req_thm(€"z_Ê_size_thm"›,([], ÒµA:U; f:U; n:Ó| f ç 1 .. n è A∑ A ç (Ê _) ± # A = nÆ));
req_thm(€"z_size_empty_thm"›,([], Ò({} ∫  X) ç (Ê_) ± # ({} ∫  X) = 0Æ));
req_thm(€"z_size_singleton_thm"›,([], Òµx : U∑ {x} ç (Ê_) ± # {x} = 1Æ));
req_thm(€"z_size_dot_dot_thm"›,([], Òµn:Ó∑ 1 .. n ç (Ê _) ± # (1 .. n) = nÆ));
req_thm(€"z_size_ü_thm"›,([], ÒµX:U; Y:U; f:U | f ç X ü Y ∑ f ç (Ê_) ± #f = #(dom f)Æ));
req_thm(€"z_size_seq_thm"›,([], ÒµX:U; f:U; n : Ó | f ç 1 .. n ≠ X ∑ #f = nÆ));
req_thm(€"z_size_¿_singleton_thm"›,([], Òµa : (Ê_); x: U | ≥x ç a ∑ # (a ¿ {x}) = #a + 1Æ));
req_thm(€"z_Ê_°_thm"›,([], Òµa, b : U | a ç (Ê_) ≤ b ç (Ê_) ∑ (a ° b) ç (Ê_)Æ));
req_thm(€"z_Ê_diff_thm"›,([], Òµa, b : U | a ç (Ê_) ∑ (a \ b) ç (Ê_)Æ));
req_thm(€"z_size_¿_thm"›,([], Òµa, b : (Ê_)∑ (a ¿ b) ç (Ê_) ± # (a ¿ b) + #(a ° b) = #a + #bÆ));
req_thm(€"z_ﬁ_Ê_thm"›,([], Òµu : Ê(Ê_)∑ ﬁu ç (Ê_)Æ));
req_thm(€"z_size_diff_thm"›,([], Òµ a : (Ê _); b: U ∑ a \ b ç (Ê _) ±  # (a \ b) + # (a ° b) = # aÆ));
req_thm(€"z_size_Ó_thm"›,([], Òµa : (Ê_) ∑ # a ç ÓÆ));
req_thm(€"z_size_mono_thm"›,([], Òµa : (Ê_); b: U | b Ä a ∑ #b º #aÆ));
req_thm(€"z_size_¿_º_thm"›,([], Òµa, b : (Ê_)  ∑ #(a ¿ b) º #a + #bÆ));
req_thm(€"z_size_0_thm"›,([], Òµa : (Ê_) ∑ # a = 0 § a = {}Æ));
req_thm(€"z_size_1_thm"›,([], Òµa : (Ê_) ∑ # a = 1 § (∂x:U∑ a = {x})Æ));
req_thm(€"z_size_º_1_thm"›,([], Òµa : (Ê_) | # a º 1 ∑ a = {} ≤ (∂x:U∑a = {x})Æ));
req_thm(€"z_size_dot_dot_thm1"›,([], Òµi,j : ˙ ∑ i .. j ç (Ê_) ±
		(i º j ¥ # (i .. j) = (j + ~ i) + 1) ±
		(j < i ¥ # (i .. j) = 0)Æ));
req_thm(€"z_pigeon_hole_thm1"›,([], Òµu : Ê (Ê_) | (µa:u∑ #a º 1) ∑ # (ﬁu) º # uÆ));
req_thm(€"z_pigeon_hole_thm"›,([], Òµu : Ê (Ê_) | # (ﬁu) > # u ∑ ∂a:u∑ #a > 1Æ));
=DESCRIBE

=ENDDOC

=DOC
val €z_Ê_induction_tac› : TERM -> TACTIC;
=DESCRIBE
???
=ENDDOC

\subsubsection{Theorems of the Theory}

=DOC
val €z_dot_dot_clauses› : THM;			val €z_dot_dot_plus_thm› : THM;
val €z_less_cases_thm› : THM;			val €z_º_º_plus1_thm› : THM;
val €z_dot_dot_diff_thm› : THM;			val €z_dot_dot_¿_thm› : THM;
val €z_dot_dot_°_thm› : THM;			val €z_empty_Ê_thm› : THM;
val €z_Ê_¿_singleton_thm› : THM;			val €z_Ê_thm1› : THM;
val €z_Ê_induction_thm› : THM;			val €z_Ê_size_thm› : THM;
val €z_size_empty_thm› : THM;			val €z_size_singleton_thm› : THM;
val €z_size_dot_dot_thm› : THM;			val €z_size_ü_thm› : THM;
val €z_size_seq_thm› : THM;			val €z_size_¿_singleton_thm› : THM;
val €z_Ê_°_thm› : THM;			val €z_Ê_diff_thm› : THM;
val €z_size_¿_thm› : THM;			val €z_ﬁ_Ê_thm› : THM;
val €z_size_diff_thm› : THM;			val €z_size_Ó_thm› : THM;
val €z_size_mono_thm› : THM;			val €z_size_¿_º_thm› : THM;
val €z_size_0_thm› : THM;			val €z_size_1_thm› : THM;
val €z_size_º_1_thm› : THM;			val €z_size_dot_dot_thm1› : THM;
val €z_pigeon_hole_thm1› : THM;		val €z_pigeon_hole_thm› : THM;
val €z_Ê__thm› : THM;		
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_numbers1$.
=ENDDOC

\subsection{EPILOGUE OF ZNumbers1}
=SML
end; (* of signature ZNumbers1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX
=THSML
summarize_td_results ();
val z_numbers1_success = theory_check_success ();
initialise_td_results();
=TEX
\section{ZSequences1}
\subsection{PROLOGUE FOR ZSequences1}
=SML
open_theory"z_numbers1";
delete_theory"z_sequences1" handle Fail _ => ();
new_theory"z_sequences1";
new_parent "z_sequences";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZSequences1}
=DOC
signature €ZSequences1› = sig
=DESCRIBE
This provides additional proof support for the Z library sequences.
It creates the theory $z\_sequences1$.
=ENDDOC
=THDOC
req_name €"z_sequences1"› (Value "z_sequences");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_sequences1$ contains various theorems about functions.
It is created in structure $ZSequences1$.
=ENDDOC

=THDOC
req_thm(€"z_seq_thm"›,([], ÒµX:U∑ seq X = ﬁ{n : Ó∑ 1 .. n ≠ X}Æ));
req_thm(€"z_prim_seq_induction_thm"›,([], ¨µ X p ∑
		p Ò{}Æ
	±	(µ x n s∑
			Òx ç XÆ ± Òn ç ÓÆ ± Òs ç 1 .. n ≠ XÆ ± p ÒsÆ
		¥	p Òs ¿ {(n + 1, x)}Æ)
      ¥ (µ s∑ Òs ç (seq X)Æ ¥ p s)Æ));
req_thm(€"z_seq_thm1"›,([], ÒµX:U; n:U∑ seq X = {s:U | ∂n: Ó∑ s ç 1 .. n ≠ X}Æ));
req_thm(€"z_size_seq_thm1"›,([], ÒµX:U; n:Ó∑ s ç seq X ± #s = n § s ç 1 .. n ≠ XÆ));
req_thm(€"z_size_seq_thm2"›,([], Òµn:Ó; s : (seq _)∑ #s = n § dom s = 1 .. nÆ));
req_thm(€"z_size_seq_Ó_thm"›,([], Òµs : (seq _)∑ #s ç ÓÆ));
req_thm(€"z_singleton_seq_thm"›,([], Òµx : U∑
	ßx¢ ç (seq _) ± dom ßx¢ = {1} ± ran ßx¢ = {x} ± ßx¢ 1 = xÆ));
req_thm(€"z_seq_u_thm"›,([], ÒµX:U∑ µ s:seq X∑s ç (seq _)Æ));
req_thm(€"z_Î_thm"›,([], ÒµX, Y:U∑ µ s:seq X; t:seq Y∑s Î t  = s ¿ {n : dom t ∑ n + # s Ì t n}Æ));
req_thm(€"z_Î_ç_seq_thm"›,([], ÒµX, Y:U∑ µ s:seq X; t:seq Y∑s Î t ç (seq _)Æ));
req_thm(€"z_Î_ç_seq_thm1"›,([], Òµ s : (seq _); t : (seq _) ∑ s Î t ç (seq _)Æ));
req_thm(€"z_Î_def_thm"›,([], Òµi : U; t : (seq _)∑
		{n : dom t ∑ n + i Ì t n}
	=	{n : U; x : U | (n, x) ç t ∑ (n + i, x)}Æ));
req_thm(€"z_Î_singleton_thm"›,([], Ò[X](µs : seq X; x: X∑ s Î ßx¢ = s ¿ {(#s + 1, x)})Æ));
req_thm(€"z_Î_singleton_thm1"›,([], Òµ s : (seq _); x : U ∑ s Î ßx¢ = s ¿ {(# s + 1, x)}Æ));
req_thm(€"z_ß¢_thm"›,([], Òß¢ = {}Æ));
req_thm(€"z_ß¢_seq_thm"›,([], ÒµX:U∑ ß¢ ç seq XÆ));
req_thm(€"z_seq_induction_thm"›,([], ¨µ X p ∑
		p Òß¢Æ
	±	(µ x s∑
			Òx ç XÆ ± Òs ç seq XÆ ± p ÒsÆ
		¥	p Òs Î ßx¢Æ)
      ¥ (µ s∑ Òs ç (seq X)Æ ¥ p s)Æ));
req_thm(€"z_Î_ß¢_thm"›,([], Òµ X : U
    ∑ µ s : seq X ∑
		s Î ß¢ = sÆ));
req_thm(€"z_ß¢_Î_thm"›,([], Òµ X : U
    ∑ µ s : seq X ∑
		ß¢ Î s = sÆ));
req_thm(€"z_dom_seq_thm"›,([], Òµ s : (seq _) ∑ dom s = 1 .. #sÆ));
req_thm(€"z_dom_Î_thm"›,([], Òµ s : (seq _); t : (seq _) ∑ dom(s Î t) = 1 .. (#s + #t)Æ));
req_thm(€"z_size_Î_thm"›,([], Òµ s, t : (seq _); x:U ∑#(s Î t) = #s + #tÆ));
req_thm(€"z_size_singleton_seq_thm"›,([], Òµ x:U ∑#ßx¢ = 1Æ));
req_thm(€"z_seq_cases_thm"›,([], Òµ s : (seq _)∑
		s = ß¢ ≤ (∂s1 : (seq _); x:U∑ s = s1 Î ßx¢)Æ));
req_thm(€"z_≥_Î_empty_thm"›,([], Òµ s : (seq _); x:U∑ ≥s Î ßx¢ = ß¢Æ));
req_thm(€"z_Î_one_one_thm"›,([], Òµ s : (seq _); t : (seq _); x, y:U ∑
		s Î ßx¢ = t Î ßy¢ § s = t ± x = yÆ));
req_thm(€"z_Î_assoc_thm"›,([], Òµ s1, s2, s3 : (seq _)∑ (s1 Î s2) Î s3 = s1 Î (s2 Î s3)Æ));
=DESCRIBE

=ENDDOC


\subsubsection{Theorems of the Theory}

=DOC
val €z_seq_thm› : THM;			val €z_prim_seq_induction_thm› : THM;
val €z_seq_thm1› : THM;			val €z_size_seq_thm1› : THM;
val €z_size_seq_thm2› : THM;			val €z_size_seq_Ó_thm› : THM;
val €z_singleton_seq_thm› : THM;			val €z_seq_u_thm› : THM;
val €z_Î_thm› : THM;			val €z_Î_ç_seq_thm› : THM;
val €z_Î_ç_seq_thm1› : THM;			val €z_Î_def_thm› : THM;
val €z_Î_singleton_thm› : THM;			val €z_Î_singleton_thm1› : THM;
val €z_ß¢_thm› : THM;			val €z_ß¢_seq_thm› : THM;
val €z_seq_induction_thm› : THM;			val €z_Î_ß¢_thm› : THM;
val €z_ß¢_Î_thm› : THM;			val €z_dom_seq_thm› : THM;
val €z_dom_Î_thm› : THM;			val €z_size_Î_thm› : THM;
val €z_size_singleton_seq_thm› : THM;			val €z_seq_cases_thm› : THM;
val €z_≥_Î_empty_thm› : THM;			val €z_Î_one_one_thm› : THM;
val €z_Î_assoc_thm› : THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_sequences1$.
=ENDDOC

=DOC
val €z_seq_induction_tac› : TERM -> TACTIC;
=DESCRIBE
???
=ENDDOC

\subsection{EPILOGUE OF ZSequences1}
=SML
end; (* of signature ZSequences1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=THSML
summarize_td_results ();
val z_sequences1_success = theory_check_success ();
=TEX
\section{TEST POLICY}
The module tests for these modules are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


