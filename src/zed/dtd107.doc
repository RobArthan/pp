=IGN
********************************************************************************
dtd107.doc: this file is part of the PPZed system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  %Z% $Date: 2006/02/02 20:54:05 $ $Revision: 1.26 $ $RCSfile: dtd107.doc,v $
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Detailed Design: Z Finiteness and Sequences}

\def\AbstractText{This document contains the detailed design of the theories $z\_functions1$, $z\_numbers1$, and $z\_sequences1$ and their proof support.}

\def\Reference{DS/FMU/IED/DTD107}

\def\Author{K. Blackburn}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: % TQtemplate.tex
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
\def\Hide#1{}
%% LaTeX2e port: \def\Bool{``$\it{:}bool\,$''}
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{FST PROJECT}  %% Mandatory field
%% LaTeX2e port: %\TPPvolume{}
%% LaTeX2e port: %\TPPpart{}
%% LaTeX2e port: \TPPtitle{Detailed Design: Z Finiteness and Sequences}  %% Mandatory field
%% LaTeX2e port: \TPPref{DS/FMU/IED/DTD107}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{$Revision: 1.26 $%
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{\FormatDate{$Date: 2006/02/02 20:54:05 $%
%% LaTeX2e port: }}
%% LaTeX2e port: %\TPPstatus{Draft}
%% LaTeX2e port: \TPPstatus{Draft}
%% LaTeX2e port: \TPPtype{Specification}
%% LaTeX2e port: \TPPkeywords{HOL}
%% LaTeX2e port: \TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%% LaTeX2e port: %\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%% LaTeX2e port: \TPPauthorisation{R.D.~Arthan & HAT Team Leader}
%% LaTeX2e port: \TPPabstract{This document contains the detailed design of
%% LaTeX2e port: the theories $z\_functions1$, $z\_numbers1$, and $z\_sequences1$ and their proof support.}
%% LaTeX2e port: %\TPPabstractB{}
%% LaTeX2e port: %\TPPabstractC{}
%% LaTeX2e port: %\TPPabstractD{}
%% LaTeX2e port: %\TPPabstractE{}
%% LaTeX2e port: %\TPPabstractF{}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port:       Project Library}}
%% LaTeX2e port: 
%% LaTeX2e port: %\TPPclass{CLASSIFICATION}
%% LaTeX2e port: %\def\TPPheadlhs{}
%% LaTeX2e port: %\def\TPPheadcentre{}
%% LaTeX2e port: %def\TPPheadrhs{}
%% LaTeX2e port: %\def\TPPfootlhs{}
%% LaTeX2e port: %\def\TPPfootcentre{}
%% LaTeX2e port: %\def\TPPfootrhs{}
%% LaTeX2e port: 
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \TPPsetsizes
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: 
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: 
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: 
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (1996/01/16), 1.2 (1996/01/19) (15th January 1995)]
First versions, derived from wrk056.
\item[Issue 1.3 (1996/01/24) (24th January 1995)]
Corrected duplicate namings.
\item[Issue 1.4 (1996/02/22) (20th February 1996)]
Added $abs$, $mod$ and $div$ theorems.
\item[Issue 1.5 (1996/03/13)]
Added material about $´$.
\item [Issue 1.6 (1996/03/21)]
Added material about $succ$.
\item [Issues 1.8 (1996/03/26)-1.10 (1996/03/27)]
Added $z\_size\_dot\_dot\_conv$.
\item [Issue 1.11 (1996/03/29)]
Documented sequence induction.
\item [Issue 1.12 (1997/07/28)]
Documented finite set induction.
\item [Issue 1.13 (2001/07/05)]
Added material on sequence displays.
\item[Issue 1.14 (2002/07/10)]
Added new induction tactic and some theorems for sequences;
added new error messages for induction tactics.
\item[Issue 1.15 (2002/07/10)]
{\LaTeX} tidy-up.
\item[Issue 1.16 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.17 (2002/10/17)] PPZed-specific updates for open source release
\item[Issue 1.18 (2003/04/17)] Corrected examples of {\it z\_size\_dot\_dot\_conv}.
\item[Issues 1.19 (2003/04/28), 1.20 (2003/04/28)] {\it z\_size\_seq\_thm1} had a free variable that is now universally quantified.
\item[Issue 1.21 (2003/04/30)] Added conversion for equality of sequence displays.
\item[Issue 1.22 (2004/01/19)] The Z universal set is now called É.
\item[Issue 1.23 (2004/02/02)] Addressed comments on USR030 from QinetiQ.
\item[Issue 1.24 (2005/02/26)] Precedences and associativity of toolkit operators now follow \cite{ISO02}.
\item[Issue 1.25 (2005/08/03)] Added new theorems from mutilated chessboard proof.
\item[Issue 1.26 (2006/02/02)] Functional composition is now called ``Ö''.
\item[Issue 1.27 (2007/05/28)] Added {\em z\_dot\_dot\_conv}.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

\item[2015/04/17]
Ported PPZed to Lemma 1 document template.

\item[2018/09/21]
Added
=INLINEFT
z_string_eq_conv
=TEX
.

%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design of
the theories $z\_functions1$, $z\_numbers1$, and $z\_sequences1$ and their proof support, parts
of the mathematical toolkit for HOL/Z.
The high level design for this material is given in \cite{DS/FMU/IED/HLD017}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD017}.
\subsection{Dependencies}
Loading this document and its implementation requires that
\cite{DS/FMU/IED/IMP088} has been loaded.
\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.
\section{ZFunctions1}
\subsection{PROLOGUE FOR ZFunctions1}

=SML
open_theory"z_functions";
force_delete_theory"z_functions1" handle Fail _ => ();
force_delete_theory"z_numbers1" handle Fail _ => ();
force_delete_theory"z_sequences1" handle Fail _ => ();
new_theory"z_functions1";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZFunctions1}
=DOC
signature €ZFunctions1› = sig
=DESCRIBE
This provides additional proof support for the Z library functions.
It creates the theory $z\_functions1$.
=ENDDOC
=THDOC
req_name €"z_functions1"› (Value "z_functions");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_functions1$ contains various theorems about functions.
It is created in structure $ZFunctions1$.
=ENDDOC

=THDOC
req_thm(€"z_Ú_≠_thm"›,([], Ò[Y, Z](µX:É; f:Y ≠ Z∑ X Ä Y
	¥ 	(X Ú f) ç X ≠ (ran (X Ú f)))Æ));
req_thm(€"z_ran_Ú_thm"›,([], Ò[Y, Z](µX:É; f:Y ≠ Z∑
	ran(X Ú f) = ran f \ {y : É | µx : É | (x, y) ç f ∑ ≥x ç X})Æ));
req_thm(€"z_ç_≠_thm"›,([], Ò(µX:É; Y:É∑ µ f:X ≠ Y; x:É; y:É | (x, y) ç f ∑
	x ç X ± y ç Y)Æ));
req_thm(€"z_≠_ran_eq_Ô_thm"›,([], Ò(µA:É; B : É∑ (∂f : A ≠ B∑ ran f = B)
	§ 	(∂f : A Ô B∑ true))Æ));
req_thm(€"z_‡_ran_eq_è_thm"›,([], Ò(µA:É; B : É∑ (∂f : A ‡ B∑ ran f = B)
	§ 	(∂f : A è B∑ true))Æ));
req_thm(€"z_ran_mono_thm"›,([], ÒµX:É; Y, Z:É; f:É | f ç X ≠ Y ± ran f Ä Z ∑
	f ç X ≠ ZÆ));
req_thm(€"z_ﬂ_thm2"›,([], ÒµA:É; B:É; f:É∑ f ç  A ﬂ B
	§ 	f ç dom f ≠ B ± dom f Ä AÆ));
req_thm(€"z_Ô_thm1"›,([], ÒµA:É; B:É; f:É∑ f ç A Ô B
	§ f ç A ≠ B ± B Ä ran fÆ));
req_thm(€"z_˛_thm1"›,([], Ò [X, Y]
	(X ˛ Y =
	{f : X ﬂ Y | µ x1, x2 : É; y:É∑ (x1, y) ç f ± (x2, y) ç f¥ x1 = x2})Æ));
req_thm(€"z_≠_dom_thm"›,([], ÒµA:É; B:É; f:É∑
		f ç A ≠ B
	¥	f ç dom f ≠ BÆ));
req_thm(€"z_‡_thm1"›,([], ÒµA:É; B:É; f:É∑
		f ç A ‡ B
	§	f ç A ≠ B ± (µx, y:É; z:É∑ (x, z) ç f ± (y, z) ç f ¥ x = y)Æ));
req_thm(€"z_¿_™_thm"›,([], ÒµA:É; B:É; C:É; D:É; f:É; g:É∑
			f ç A ™ B ± g ç C ™ D
		¥	f ¿ g ç (A ¿ C) ™ (B ¿ D)Æ));
req_thm(€"z_ran_¿_thm"›,([], Òµf:É; g:É∑ran (f ¿ g) = ran f ¿ ran gÆ));
req_thm(€"z_¿_≠_thm"›,([], ÒµA:É; B:É; C:É; D:É; f:É; g:É∑
		f ç A ≠ B ± g ç C ≠ D ± A ° C = {}
	¥	f ¿ g ç (A ¿ C) ≠ (B ¿ D)Æ));
req_thm(€"z_¿_‡_thm"›,([], ÒµA:É; B:É; C:É; D:É; f:É; g:É∑
		f ç A ‡ B ± g ç C ‡ D ± A ° C = {} ± B ° D = {}
	¥	f ¿ g ç (A ¿ C) ‡ (B ¿ D)Æ));
req_thm(€"z_¿_Ô_thm"›,([], ÒµA:É; B:É; C:É; D:É; f:É; g:É∑
		f ç A Ô B ± g ç C Ô D ± A ° C = {}
	¥	f ¿ g ç (A ¿ C) Ô (B ¿ D)Æ));
req_thm(€"z_¿_è_thm"›,([], ÒµA:É; B:É; C:É; D:É; f:É; g:É∑
		f ç A è B ± g ç C è D ± A ° C = {} ± B ° D = {}
	¥	f ¿ g ç (A ¿ C) è (B ¿ D)Æ));
=ENDDOC

=THDOC
req_thm(€"z_Ö_≠_thm"›,([], ÒµA:É; B:É; C:É; f:É; g:É∑
		f ç A ≠ B ± g ç B ≠ C
	¥	g Ö f ç A ≠ CÆ));
req_thm(€"z_Ö_Ô_thm"›,([], ÒµA:É; B:É; C:É; f:É; g:É∑
		f ç A Ô B ± g ç B Ô C
	¥	g Ö f ç A Ô CÆ));
req_thm(€"z_Ö_‡_thm"›,([], ÒµA:É; B:É; C:É; f:É; g:É∑
		f ç A ‡ B ± g ç B ‡ C
	¥	g Ö f ç A ‡ CÆ));
req_thm(€"z_Ö_è_thm"›,([], ÒµA:É; B:É; C:É; f:É; g:É∑
		f ç A è B ± g ç B è C
	¥	g Ö f ç A è CÆ));
req_thm(€"z_rel_inv_è_thm"›,([], ÒµA:É; B:É; f:É∑
		f ç A è B  ¥ f Á~Í ç B è AÆ));
req_thm(€"z_id_thm1"›,([], ÒµX:É; x, y:É∑ (x, y) ç id X § x ç X ± x = yÆ));
req_thm(€"z_id_è_thm"›,([], ÒµX:É∑ id X ç X è XÆ));
req_thm(€"z_simple_swap_è_thm"›,([], Òµx, y:É∑ {(x, y), (y, x)} ç {x, y} è {x, y}Æ));
req_thm(€"z_swap_è_thm"›,([], ÒµX:É∑ µx, y:X∑ ∂g : X è X∑ (x, y) ç g ± (y, x) ç gÆ));
req_thm(€"z_è_trans_thm"›,([], ÒµX:É∑ µx, y:X∑ ∂g : X è X∑ (x, y) ç gÆ));
req_thm(€"z_dom_f_™_f_thm"›,([], ÒµA:É; B:É; f:É∑
		f ç A ™ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ™ fÆ));
req_thm(€"z_dom_f_≠_f_thm"›,([], ÒµA:É; B:É; f:É∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ≠ fÆ));
req_thm(€"z_dom_f_Ô_f_thm"›,([], ÒµA:É; B:É; f:É∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f Ô fÆ));
req_thm(€"z_dom_f_‡_f_thm"›,([], ÒµA:É; B:É; f:É∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f ‡ fÆ));
=ENDDOC

=THDOC
req_thm(€"z_dom_f_è_f_thm"›,([], ÒµA:É; B:É; f:É∑
		f ç A ≠ B
	¥	{x : A; y : B | (x, y) ç f∑ (x, (x, y)) } ç dom f è fÆ));
req_thm(€"z_°_™_thm"›,([], ÒµX:É; Y:É; f, g:É | f ç X ™ Y ∑
		(f ° g) ç dom (f ° g) ™ ran(f ° g)Æ));
req_thm(€"z_™_ran_thm"›,([], ÒµX:É; f:É ∑ f ç X ™ ran f § f ç X ™ ÉÆ));
req_thm(€"z_≠_ran_thm"›,([], ÒµX:É; f:É ∑ f ç X ≠ ran f § f ç X ≠ ÉÆ));
req_thm(€"z_°_≠_thm"›,([], ÒµX:É; Y:É; f, g:É | f ç X ≠ Y ∑
		(f ° g) ç dom (f ° g) ≠ ran(f ° g)Æ));
req_thm(€"z_°_‡_thm"›,([], ÒµX:É; Y:É; f, g:É | f ç X ‡ Y ∑
		(f ° g) ç dom (f ° g) ‡ ran(f ° g)Æ));
req_thm(€"z_Ô_ran_thm"›,([], ÒµX:É; Y:É; f:É | f ç X ≠ Y ∑
		f ç dom f Ô ran fÆ));
req_thm(€"z_°_Ô_thm"›,([], ÒµX:É; Y:É; f, g:É | f ç X Ô Y ∑
		(f ° g) ç dom (f ° g) Ô ran(f ° g)Æ));
req_thm(€"z_°_è_thm"›,([], ÒµX:É; Y:É; f, g:É | f ç X è Y ∑
		(f ° g) ç dom (f ° g) è ran(f ° g)Æ));

req_thm(€"z_≠_diff_singleton_thm"›,([], ÒµX:É; Y:É∑ µ f:X ≠ Y; x:É; y:É∑
	(x, y) ç f ¥
	(f \ {(x, y)}) ç (X \ {x}) ≠ Y Æ));
req_thm(€"z_è_diff_singleton_thm"›,([], ÒµX:É; Y:É∑ µ f:X è Y; x:X; y:Y∑
	(x, y) ç f ¥
	(f \ {(x, y)}) ç (X \ {x}) è (Y \ {y})Æ));
req_thm(€"z_singleton_app_thm"›,([], Òµx : É; y: É∑ {(x, y)} x = yÆ));
req_thm(€"z_empty_Ô_thm"›,([], ÒµX: É∑ (∂f: {} Ô X∑ true) § X = {}Æ));
req_thm(€"z_≠_empty_thm"›,([], ÒµX: É∑ (∂f: X ≠ {}∑ true) § X = {}Æ));
=DESCRIBE

=ENDDOC

=THDOC
req_thm(€"z_´_Ì_app_thm"›,
	([], Ò(µf : É; x : É; y : É ∑ (f ´ {x Ì y}) x = y)Æ));
req_thm(€"z_´_Ì_app_thm1"›,
	([], Ò[X, Y](µf : X ≠ Y; x2 : X; x1 : É; y : É |
	≥ x2 = x1 ∑
	(f ´ {x1 Ì y}) x2 = f x2)Æ));
req_thm(€"z_dom_´_Ì_thm"›,
	([], Òµf : É; x : É; y : É ∑
	dom(f ´ {x Ì y}) = dom f ¿ {x}Æ));
req_thm(€"z_´_Ì_ç_≠_thm"›,
	([], Ò[X, Y](µf : X ≠ Y; x : X; y : Y ∑
	f ´ {x Ì y} ç X ≠ Y)Æ));
=DESCRIBE

=ENDDOC

\subsubsection{Theorems of the Theory}

=DOC
val €z_Ú_≠_thm› : THM;				val €z_ran_Ú_thm› : THM;
val €z_ç_≠_thm› : THM;				val €z_≠_ran_eq_Ô_thm› : THM;
val €z_‡_ran_eq_è_thm› : THM;			val €z_ran_mono_thm› : THM;
val €z_ﬂ_thm2› : THM;				val €z_Ô_thm1› : THM;
val €z_˛_thm1› : THM;				val €z_≠_dom_thm› : THM;
val €z_‡_thm1› : THM;				val €z_¿_™_thm› : THM;
val €z_ran_¿_thm› : THM;				val €z_¿_≠_thm› : THM;
val €z_¿_‡_thm› : THM;				val €z_¿_Ô_thm› : THM;
val €z_¿_è_thm› : THM;				val €z_Ö_≠_thm› : THM;
val €z_Ö_Ô_thm› : THM;				val €z_Ö_‡_thm› : THM;
val €z_Ö_è_thm› : THM;				val €z_rel_inv_è_thm› : THM;
val €z_id_thm1› : THM;				val €z_id_è_thm› : THM;
val €z_simple_swap_è_thm› : THM;		val €z_swap_è_thm› : THM;
val €z_è_trans_thm› : THM;			val €z_dom_f_™_f_thm› : THM;
val €z_dom_f_≠_f_thm› : THM;			val €z_dom_f_Ô_f_thm› : THM;
val €z_dom_f_‡_f_thm› : THM;			val €z_dom_f_è_f_thm› : THM;
val €z_°_™_thm› : THM;				val €z_™_ran_thm› : THM;
val €z_≠_ran_thm› : THM;				val €z_°_≠_thm› : THM;
val €z_°_‡_thm› : THM;				val €z_Ô_ran_thm› : THM;
val €z_°_Ô_thm› : THM;				val €z_°_è_thm› : THM;
val €z_≠_diff_singleton_thm› : THM;		val €z_è_diff_singleton_thm› : THM;
val €z_singleton_app_thm› : THM;			val €z_empty_Ô_thm› : THM;
val €z_≠_empty_thm› : THM;			val €z_´_Ì_app_thm› : THM;
val €z_´_Ì_app_thm1› : THM;			val €z_dom_´_Ì_thm› : THM;
val €z_´_Ì_ç_≠_thm› : THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_functions1$.
=ENDDOC

\subsection{EPILOGUE OF ZFunctions1}
=SML
end; (* of signature ZFunctions1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX
=THSML
summarize_td_results ();
val z_functions1_success = theory_check_success ();
initialise_td_results();
=TEX
\section{ZNumbers1}
\subsection{PROLOGUE FOR ZNumbers1}
=SML
open_theory"z_functions1";
delete_theory"z_numbers1" handle Fail _ => ();
new_theory"z_numbers1";
new_parent"z_numbers";
new_parent"z_arithmetic_tools";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZNumbers1}
=DOC
signature €ZNumbers1› = sig
=DESCRIBE
This provides additional proof support for the Z library functions.
It creates the theory $z\_functions1$.
=ENDDOC
=THDOC
req_name €"z_numbers1"› (Value "z_numbers");
req_parent "z_arithmetic_tools";
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_numbers1$ contains various theorems about numbers.
It is created in structure $ZNumbers1$.
=ENDDOC

=THDOC
req_thm(€"z_dot_dot_clauses"›,([], Òµi, i1, i2, j1, j2:É∑
	(i ç i1 .. i2 § i1 º i º i2)
±	(i1 .. i2 = {} § i2 < i1)
±	(i1 .. i2 Ä j1 .. j2 § i2 < i1 ≤ (j1 º i1 ± i2 º j2))Æ));
req_thm(€"z_dot_dot_plus_thm"›,([], Òµn, i1, i2 : É∑
	{i : i1 .. i2 ∑ i + n} = i1 + n .. i2 + nÆ));
req_thm(€"z_less_cases_thm"›,([], Òµi, j:É∑ i < j ≤ i = j ≤ j < iÆ));
req_thm(€"z_º_º_plus1_thm"›,([], Òµi, j:É∑ i º j º i + 1 § j = i ≤ j = i + 1Æ));
req_thm(€"z_dot_dot_diff_thm"›,([], Òµi:Ó∑ (1 .. i + 1) \ {i + 1} = 1 .. iÆ));
req_thm(€"z_dot_dot_¿_thm"›,([], Òµi:Ó∑ (1 .. i) ¿ {i + 1} = 1 .. i + 1Æ));
req_thm(€"z_dot_dot_°_thm"›,([], Òµi:Ó∑ (1 .. i) ° {i + 1} = {}Æ));
req_thm(€"z_empty_Ê_thm"›,([], Ò[X]({} ç Ê X)Æ));
req_thm(€"z_Ê_¿_singleton_thm"›,([], Ò[X](µx : X; a : Ê X∑ (a ¿ {x}) ç Ê X)Æ));
req_thm(€"z_Ê_thm1"›,([], Ò[X](Ê X = •{u :   X| {} ç u
	± (µ x:X; a:u∑ (a ¿ {x}) ç u)})Æ));
req_thm(€"z_Ê_induction_thm"›,([], ¨µ X p ∑
		p Ò{}Æ
	±	(µ x a∑ p ÒaÆ ± Òa ç Ê XÆ ± Òx ç XÆ ± Ò≥x ç aÆ ¥ p Òa ¿ {x}Æ)
      ¥ (µ a∑ Òa ç Ê XÆ ¥ p a)Æ));
req_thm(€"z_Ê__thm"›,([], Ò[X](Ê X =  X ° (Ê_))Æ));
req_thm(€"z_Ê_size_thm"›,([], ÒµA:É; f:É; n:Ó| f ç 1 .. n è A∑ A ç (Ê _) ± # A = nÆ));
req_thm(€"z_Ê_size_thm1"›,([], Òµa: (Ê_) ∑ ∂f:1 .. #a è a ∑trueÆ));
req_thm(€"z_Ä_Ê_thm"›,([], Òµa:(Ê_); b: É | b Ä a ∑ b ç (Ê_)Æ));
req_thm(€"z_size_empty_thm"›,([], Ò({} ∫  X) ç (Ê_) ± # ({} ∫  X) = 0Æ));
req_thm(€"z_size_singleton_thm"›,([], Òµx : É∑ {x} ç (Ê_) ± # {x} = 1Æ));
req_thm(€"z_size_dot_dot_thm"›,([], Òµn:Ó∑ 1 .. n ç (Ê _) ± # (1 .. n) = nÆ));
req_thm(€"z_size_ü_thm"›,([], ÒµX:É; Y:É; f:É | f ç X ü Y ∑ f ç (Ê_)
	± #f = #(dom f)Æ));
req_thm(€"z_size_seq_thm"›,([], ÒµX:É; f:É; n : Ó | f ç 1 .. n ≠ X ∑ #f = nÆ));
req_thm(€"z_size_¿_singleton_thm"›,([], Òµa : (Ê_); x: É | ≥x ç a ∑
	# (a ¿ {x}) = #a + 1Æ));
req_thm(€"z_Ê_°_thm"›,([], Òµa, b : É | a ç (Ê_) ≤ b ç (Ê_) ∑ (a ° b) ç (Ê_)Æ));
req_thm(€"z_Ê_diff_thm"›,([], Òµa, b : É | a ç (Ê_) ∑ (a \ b) ç (Ê_)Æ));
req_thm(€"z_size_¿_thm"›,([], Òµa, b : (Ê_)∑ (a ¿ b) ç (Ê_)
	± # (a ¿ b) + #(a ° b) = #a + #bÆ));
req_thm(€"z_ﬁ_Ê_thm"›,([], Òµu : Ê(Ê_)∑ ﬁu ç (Ê_)Æ));
req_thm(€"z_size_diff_thm"›,([], Òµ a : (Ê _); b: É ∑ a \ b ç (Ê _)
	±  # (a \ b) + # (a ° b) = # aÆ));
=ENDDOC

=THDOC
req_thm(€"z_size_Ó_thm"›,([], Òµa : (Ê_) ∑ # a ç ÓÆ));
req_thm(€"z_size_mono_thm"›,([], Òµa : (Ê_); b: É | b Ä a ∑ #b º #aÆ));
req_thm(€"z_size_¿_º_thm"›,([], Òµa, b : (Ê_)  ∑ #(a ¿ b) º #a + #bÆ));
req_thm(€"z_size_eq_thm"›,([], Òµa, b:(Ê_) | a Ä b ± #a = #b ∑ a = bÆ));
req_thm(€"z_size_0_thm"›,([], Òµa : (Ê_) ∑ # a = 0 § a = {}Æ));
req_thm(€"z_size_1_thm"›,([], Òµa : (Ê_) ∑ # a = 1 § (∂x:É∑ a = {x})Æ));
req_thm(€"z_size_2_thm"›,([], Òµa:(Ê_) ∑ #a = 2 § (∂x, y:É∑≥x = y ± a = {x, y})Æ));
req_thm(€"z_size_pair_thm"›,([], Òµx, y:É | ≥x = y ∑ {x, y} ç (Ê_) ± #{x, y} = 2Æ));
req_thm(€"z_size_∏_thm"›,([], Òµa : (Ê_); b:(Ê_) ∑ a ∏ b ç (Ê_) ± #(a ∏ b) = #a * #bÆ));
=ENDDOC

=THDOC
req_thm(€"z_size_º_1_thm"›,([], Òµa : (Ê_) | # a º 1 ∑ a = {} ≤ (∂x:É∑a = {x})Æ));
req_thm(€"z_size_dot_dot_thm1"›,([], Òµi,j : ˙ ∑ i .. j ç (Ê_) ±
		(i º j ¥ # (i .. j) = (j + ~ i) + 1) ±
		(j < i ¥ # (i .. j) = 0)Æ));
req_thm(€"z_pigeon_hole_thm"›,([], Òµu : Ê (Ê_) | # (ﬁu) > # u ∑ ∂a:u∑ #a > 1Æ));
req_thm(€"z_div_thm"›,([], Òµ i,j,k : ˙ | ≥j = 0 ∑ (i div j = k) §
		(∂ m : ˙ ∑ i = k * j + m ± 0 º m ± m < abs j)Æ));
req_thm(€"z_mod_thm"›,([], Òµ i,j,k : ˙ | ≥j = 0 ∑ (i mod j = k) §
		(∂ d : ˙ ∑ i = d * j + k ± 0 º k ± k < abs j)Æ));
req_thm(€"z_abs_pos_thm"›,([], Òµ i:˙| 0 < i ∑ abs i = i ± abs ~ i = iÆ));
req_thm(€"z_abs_neg_thm"›,([], Òµ i:˙| i < 0 ∑ abs i = ~i ± abs ~ i = ~iÆ));
req_thm(€"z_abs_º_times_thm"›,([], Òµ i,j:˙| ≥ i = 0 ± ≥ j = 0 ∑ abs j º abs (i * j)Æ));
req_thm(€"z_abs_0_less_thm"›,([], Òµ i:˙| ≥ i = 0 ∑ 0 < abs iÆ));
req_thm(€"z_0_less_times_thm"›,([], Òµ i,j : ˙ ∑
	0 < i * j § (0 < i ± 0 < j) ≤ (i < 0 ± j < 0)Æ));
req_thm(€"z_times_less_0_thm"›,([], Òµ i,j : ˙  ∑
	i * j < 0 § (0 < i ± j < 0) ≤ (i < 0 ± 0 < j)Æ));
=DESCRIBE

=ENDDOC

=THDOC
req_thm(€"z_ç_succ_thm"›,([], ¨µ i j ∑
	Ò(i, j) ç succ § (0 º i) ± (j = i + 1)ÆÆ));
req_thm(€"z_succÁ0Í_thm"›,([], Òsucc Á 0 Í  = id ˙Æ));
req_thm(€"z_succÁnÍ_thm"›,
	([], Òµ n : ˙ | 1 º n ∑ succ Á n Í  = {m : Ó ∑ (m Ì m + n)}Æ));
req_thm(€"z_succÁminus_nÍ_thm"›,([], Òµ n : Ó | 1 º n ∑ succ Á ~ n Í  = {m : Ó  ∑ (m + n Ì m)}Æ));
=DESCRIBE
Some additional material on $succ$.
=ENDDOC
=DOC
val €z_Ê_induction_tac› : TERM -> TACTIC;
=DESCRIBE
An induction tactic for Z finite sets.  To prove
=INLINEFT
s ç Ê A ¥ t
=TEX
, it suffices to prove
=INLINEFT
t[{}/s]
=TEX
\ and to prove
=INLINEFT
t[s ¿ {x}/s]
=TEX
\ on the
assumptions $t$,
=INLINEFT
s ç Ê A
=TEX
,
=INLINEFT
x ç A
=TEX
\ and
=INLINEFT
≥x ç s
=TEX
.  The term argument must be a variable
of the same type as a Z set and must appear free in the conclusion of the goal.
It must also appear once, and only once, in an
assumption of the form
=INLINEFT
s ç Ê A
=TEX
.
=FRULE 2 Tactic
z_Ê_induction_tac ÒsÆ
˜
{ á, s ç Ê A} t[s]
˜
{ á } t[{}/s] ;
strip {t, s ç Ê A, x ç A, ≥x ç s, á} t[s ¿ {x}/s]
=TEX
=FAILURE
107033	A term of the form Òs ç Ê AÆ where s is the induction variable
	could not be found in the assumptions
=ENDDOC

=DOC
val €z_size_dot_dot_conv› : CONV;
=DESCRIBE
This conversion will calculate the size of a range between two integer
literals, including the empty range case when the end of the range is less than the start.
=EXAMPLE
z_size_dot_dot_conv Ò# (1 .. 5) Æ gives
	Ù # (1 .. 5) = 5

z_size_dot_dot_conv Ò# (10 .. 1) Æ gives
	Ù # (10 .. 1) = 0
=TEX
=FAILURE
107001	?0 is not of the form Ò#(a .. b)Æ where ÒaÆ and ÒbÆ are integer literals
=ENDDOC
=DOC
val €z_dot_dot_conv› : CONV;
=DESCRIBE
This conversion expands a range between two integer
literals into a set display:
=EXAMPLE
z_dot_dot_conv Ò1 .. 5Æ gives
	Ù 1 .. 5 = {1, 2, 3, 4, 5}
=TEX
=FAILURE
107002	?0 is not of the form Òa .. bÆ where ÒaÆ and ÒbÆ are integer literals
=ENDDOC

\subsubsection{Theorems of the Theory}

=DOC
val €z_dot_dot_clauses› : THM;			val €z_dot_dot_plus_thm› : THM;
val €z_less_cases_thm› : THM;			val €z_º_º_plus1_thm› : THM;
val €z_dot_dot_diff_thm› : THM;			val €z_dot_dot_¿_thm› : THM;
val €z_dot_dot_°_thm› : THM;			val €z_empty_Ê_thm› : THM;
val €z_Ê_¿_singleton_thm› : THM;			val €z_Ê_thm1› : THM;
val €z_Ê_induction_thm› : THM;			val €z_Ê_size_thm› : THM;
val €z_Ê_size_thm1› : THM;				val €z_Ä_Ê_thm› : THM;
val €z_size_empty_thm› : THM;			val €z_size_singleton_thm› : THM;
val €z_size_dot_dot_thm› : THM;			val €z_size_ü_thm› : THM;
val €z_size_seq_thm› : THM;				val €z_size_¿_singleton_thm› : THM;
val €z_Ê_°_thm› : THM;				val €z_Ê_diff_thm› : THM;
val €z_size_¿_thm› : THM;				val €z_ﬁ_Ê_thm› : THM;
val €z_size_diff_thm› : THM;			val €z_size_Ó_thm› : THM;
val €z_size_mono_thm› : THM;			val €z_size_¿_º_thm› : THM;
val €z_size_eq_thm› : THM;				val €z_size_0_thm› : THM;
val €z_size_1_thm› : THM;				val €z_size_2_thm› : THM;
val €z_size_pair_thm› : THM;			val €z_size_∏_thm› : THM;
val €z_size_º_1_thm› : THM;			val €z_size_dot_dot_thm1› : THM;
val €z_pigeon_hole_thm› : THM;			val €z_Ê__thm› : THM;
val €z_div_thm› : THM;				val €z_mod_thm› : THM;
val €z_abs_pos_thm› : THM;				val €z_abs_neg_thm› : THM;
val €z_abs_º_times_thm› : THM;			val €z_abs_0_less_thm› : THM;
val €z_0_less_times_thm› : THM;			val €z_times_less_0_thm› : THM;
val €z_ç_succ_thm› :THM;				val €z_succÁ0Í_thm› :THM;
val €z_succÁnÍ_thm› :THM;				val €z_succÁminus_nÍ_thm› :THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_numbers1$.
=ENDDOC

\subsection{EPILOGUE OF ZNumbers1}
=SML
end; (* of signature ZNumbers1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=TEX
=THSML
summarize_td_results ();
val z_numbers1_success = theory_check_success ();
initialise_td_results();
=TEX
\section{ZSequences1}
\subsection{PROLOGUE FOR ZSequences1}
=SML
open_theory"z_numbers1";
delete_theory"z_sequences1" handle Fail _ => ();
new_theory"z_sequences1";
new_parent "z_sequences";
push_pc "z_fun_ext";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
=TEX
\subsection{START OF STRUCTURE ZSequences1}
=DOC
signature €ZSequences1› = sig
=DESCRIBE
This provides additional proof support for the Z library sequences.
It creates the theory $z\_sequences1$.
=ENDDOC
=THDOC
req_name €"z_sequences1"› (Value "z_sequences");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_sequences1$ contains various theorems about functions.
It is created in structure $ZSequences1$.
=ENDDOC

=THDOC
req_thm(€"z_seq_thm"›,([], ÒµX:É∑ seq X = ﬁ{n : Ó∑ 1 .. n ≠ X}Æ));
req_thm(€"z_prim_seq_induction_thm"›,([], ¨µ X p ∑
		p Ò{}Æ
	±	(µ x n s∑
			Òx ç XÆ ± Òn ç ÓÆ ± Òs ç 1 .. n ≠ XÆ ± p ÒsÆ
		¥	p Òs ¿ {(n + 1, x)}Æ)
      ¥ (µ s∑ Òs ç (seq X)Æ ¥ p s)Æ));
req_thm(€"z_seq_thm1"›,([], ÒµX:É; n:É∑ seq X = {s:É | ∂n: Ó∑ s ç 1 .. n ≠ X}Æ));
req_thm(€"z_size_seq_thm1"›,([], ÒµX:É; s:É; n:Ó∑ s ç seq X ± #s = n § s ç 1 .. n ≠ XÆ));
req_thm(€"z_size_seq_thm2"›,([], Òµn:Ó; s : (seq _)∑ #s = n § dom s = 1 .. nÆ));
req_thm(€"z_size_seq_Ó_thm"›,([], Òµs : (seq _)∑ #s ç ÓÆ));
req_thm(€"z_singleton_seq_thm"›,([], Òµx : É∑
	ßx¢ ç (seq _) ± dom ßx¢ = {1} ± ran ßx¢ = {x} ± ßx¢ 1 = xÆ));
req_thm(€"z_seq_u_thm"›,([], ÒµX:É∑ µ s:seq X∑s ç (seq _)Æ));
req_thm(€"z_Î_thm"›,([], ÒµX, Y:É∑ µ s:seq X; t:seq Y∑
	s Î t  = s ¿ {n : dom t ∑ n + # s Ì t n}Æ));
req_thm(€"z_Î_ç_seq_thm"›,([], ÒµX, Y:É∑ µ s:seq X; t:seq Y∑s Î t ç (seq _)Æ));
req_thm(€"z_Î_ç_seq_thm1"›,([], Òµ s : (seq _); t : (seq _) ∑ s Î t ç (seq _)Æ));
req_thm(€"z_Î_def_thm"›,([], Òµi : É; t : (seq _)∑
		{n : dom t ∑ n + i Ì t n}
	=	{n : É; x : É | (n, x) ç t ∑ (n + i, x)}Æ));
req_thm(€"z_Î_singleton_thm"›,([], Ò[X](µs : seq X; x: X∑ s Î ßx¢ = s ¿ {(#s + 1, x)})Æ));
req_thm(€"z_Î_singleton_thm1"›,([], Òµ s : (seq _); x : É ∑ s Î ßx¢ = s ¿ {(# s + 1, x)}Æ));
req_thm(€"z_ß¢_thm"›,([], Òß¢ = {}Æ));
req_thm(€"z_ß¢_seq_thm"›,([], ÒµX:É∑ ß¢ ç seq XÆ));
req_thm(€"z_seq_induction_thm"›,([], ¨µ X p ∑
		p Òß¢Æ
	±	(µ x s∑
			Òx ç XÆ ± Òs ç seq XÆ ± p ÒsÆ
		¥	p Òs Î ßx¢Æ)
      ¥ (µ s∑ Òs ç (seq X)Æ ¥ p s)Æ));
req_thm(€"z_Î_ß¢_thm"›,([], Òµ X : É
    ∑ µ s : seq X ∑
		s Î ß¢ = sÆ));
req_thm(€"z_ß¢_Î_thm"›,([], Òµ X : É
    ∑ µ s : seq X ∑
		ß¢ Î s = sÆ));
req_thm(€"z_dom_seq_thm"›,([], Òµ s : (seq _) ∑ dom s = 1 .. #sÆ));
req_thm(€"z_seq_seq_x_thm"›,([], Òµ X : É; s : (seq _) ∑ s ç seq X § ran s Ä XÆ));
req_thm(€"z_singleton_seq_x_thm"›,([], Òµ X : É ∑ µ x : É ∑ ßx¢ ç seq X § x ç XÆ));
req_thm(€"z_Î_seq_x_thm"›,([], Òµ X : É; s1, s2 : (seq _) ∑ s1 Î s2 ç seq X § s1 ç seq X ± s2 ç seq XÆ));
=DESCRIBE

=ENDDOC

=THDOC
req_thm(€"z_dom_Î_thm"›,([], Òµ s : (seq _); t : (seq _) ∑ dom(s Î t) = 1 .. (#s + #t)Æ));
req_thm(€"z_size_Î_thm"›,([], Òµ s, t : (seq _); x:É ∑#(s Î t) = #s + #tÆ));
req_thm(€"z_size_singleton_seq_thm"›,([], Òµ x:É ∑#ßx¢ = 1Æ));
req_thm(€"z_seq_cases_thm"›,([], Òµ s : (seq _)∑
		s = ß¢ ≤ (∂s1 : (seq _); x:É∑ s = s1 Î ßx¢)Æ));
req_thm(€"z_≥_Î_empty_thm"›,([], Òµ s : (seq _); x:É∑ ≥s Î ßx¢ = ß¢Æ));
req_thm(€"z_Î_one_one_thm"›,([], Òµ s : (seq _); t : (seq _); x, y:É ∑
		s Î ßx¢ = t Î ßy¢ § s = t ± x = yÆ));
req_thm(€"z_Î_assoc_thm"›,([], Òµ s1, s2, s3 : (seq _)∑ (s1 Î s2) Î s3 = s1 Î (s2 Î s3)Æ));
req_thm(€"z_Î_assoc_thm1"›,([], Òµ s1, s2, s3 : (seq _)∑ s1 Î (s2 Î s3) = (s1 Î s2) Î s3Æ));
=DESCRIBE

=ENDDOC
=THDOC
req_thm(€"z_seq_induction_thm1"›,([], ¨µ X p ∑
		p Òß¢Æ
	±	(µ x s∑
			Òx ç XÆ ± Òs ç seq XÆ ± p ÒsÆ
		¥	p Òßx¢ Î sÆ)
      ¥ (µ s∑ Òs ç (seq X)Æ ¥ p s)Æ));
=ENDDOC

=THDOC
req_thm("z_num_list_thm", ([], ¨µ l n∑
	Ò¨Z'NumList (l, n)ÆÆ =
	Ò{i : É; x : É | (i, x) ç ¨$"Z'ß¢" lÆ ∑ (i + ¨Z'Int nÆ, x)}ÆÆ));
req_thm("z_seqd_ç_seq_thm", ([], ¨µ l∑ Ò¨$"Z'ß¢" lÆÆ ç Ò(seq _)ÆÆ));
req_thm("z_seqd_Î_thm", ([], ¨µ a l∑ Ò¨$"Z'ß¢" (Cons a l)ÆÆ = Òßa¢ Î ¨$"Z'ß¢" lÆÆÆ));
req_thm("z_seqd_Î_rw_thm", ([], ¨µ a b l∑
	Ò¨$"Z'ß¢" (Cons a (Cons b l))ÆÆ = Òßa¢ Î (ßb¢ Î ¨$"Z'ß¢" lÆ)ÆÆ));
req_thm("z_ç_seq_app_eq_thm", ([], Òµ s : (seq _); m : É; x : É ∑ (m, x) ç s ¥ s m = xÆ));
req_thm("z_ç_seqd_app_eq_thm", ([], ¨µ l m x∑ Ò(m, x)Æ ç Ò¨$"Z'ß¢" lÆÆ ¥ Ò¨$"Z'ß¢" lÆ mÆ = xÆ));
req_thm("z_size_seqd_thm", ([], ¨
	Ò#ß¢ = 0Æ
±	µa :'a; l∑Ò#¨$"Z'ß¢" (Cons a l)ÆÆ = Ò1 + #¨$"Z'ß¢" lÆÆÆ));
req_thm("z_size_seqd_length_thm", ([], ¨µ l∑ Ò# ¨$"Z'ß¢" lÆÆ = Ò¨Z'Int (Length l)ÆÆÆ));
req_thm("z_dom_seqd_thm", ([], ¨µ l∑ Òdom ¨$"Z'ß¢" lÆÆ = Ò1 .. # ¨$"Z'ß¢" lÆÆÆ));
req_thm("z_ran_seqd_thm", ([], ¨µ l∑ Òran ¨$"Z'ß¢" lÆÆ = Ò¨Z'Setd lÆÆÆ));
req_thm("z_seqd_Î_ß¢_clauses", ([], ¨µ l∑
		Ò¨$"Z'ß¢" lÆ Î ß¢Æ = Ò¨$"Z'ß¢" lÆÆ
	±	Òß¢ Î ¨$"Z'ß¢" lÆÆ = Ò¨$"Z'ß¢" lÆÆÆ));
req_thm("z_seqd_eq_thm", ([], ¨µ x y l1 l2∑
	$"Z'ß¢" (Cons x l1) = $"Z'ß¢" (Cons y l2) § x = y ± $"Z'ß¢" l1 = $"Z'ß¢" l2Æ));
=DESCRIBE

=ENDDOC

\subsubsection{Theorems of the Theory}

=DOC
val €z_≥_Î_empty_thm› : THM;		val €z_dom_Î_thm› : THM;
val €z_dom_seqd_thm› : THM;		val €z_dom_seq_thm› : THM;
val €z_Î_assoc_thm1› : THM;		val €z_Î_assoc_thm› : THM;
val €z_Î_def_thm› : THM;			val €z_Î_one_one_thm› : THM;
val €z_Î_ç_seq_thm1› : THM;		val €z_Î_ç_seq_thm› : THM;
val €z_Î_seq_x_thm› : THM;		val €z_Î_singleton_thm1› : THM;
val €z_Î_singleton_thm› : THM;		val €z_ß¢_Î_thm› : THM;
val €z_Î_ß¢_thm› : THM;			val €z_Î_thm› : THM;
val €z_prim_seq_induction_thm› : THM;	val €z_ran_seqd_thm› : THM;
val €z_ç_seq_app_eq_thm› : THM;		val €z_seq_cases_thm› : THM;
val €z_ç_seqd_app_eq_thm› : THM;	val €z_seqd_Î_ß¢_clauses› : THM;
val €z_seqd_Î_rw_thm› : THM;		val €z_seqd_Î_thm› : THM;
val €z_seqd_ç_seq_thm› : THM;		val €z_seq_induction_thm1› : THM;
val €z_seq_induction_thm› : THM;		val €z_seq_seq_x_thm› : THM;
val €z_seq_thm1› : THM;			val €z_ß¢_seq_thm› : THM;
val €z_seq_thm› : THM;			val €z_seq_u_thm› : THM;
val €z_singleton_seq_thm› : THM;		val €z_singleton_seq_x_thm› : THM;
val €z_size_Î_thm› : THM;			val €z_size_seqd_length_thm› : THM;
val €z_size_seqd_thm› : THM;		val €z_size_seq_Ó_thm› : THM;
val €z_size_seq_thm1› : THM;		val €z_size_seq_thm2› : THM;
val €z_size_singleton_seq_thm› : THM;	val €z_ß¢_thm› : THM;
val €z_seqd_eq_thm› : THM;
=DESCRIBE
These are the ML bindings of the theorems in the theory $z\_sequences1$.
=ENDDOC

=DOC
val €z_seq_induction_tac› : TERM -> TACTIC;
val €z_seq_induction_tac1› : TERM -> TACTIC;
=DESCRIBE
Induction tactics for Z sequences.  To prove
=INLINEFT
s ç seq A ¥ t
=TEX
, it suffices to prove
=INLINEFT
t[ß¢/s]
=TEX
\ and to prove
=INLINEFT
t[s Î ßx¢/s]
=TEX
(or
=INLINEFT
t[ßx¢ Î s/s]
=TEX
)
\ on the
assumptions $t$,
=INLINEFT
s ç seq A
=TEX
\ and
=INLINEFT
x ç A
=TEX
.  The term argument must be a variable
of the same type as a Z sequence and must appear free in the conclusion of the goal.
It must also appear once, and only once, in an
assumption of the form
=INLINEFT
s ç seq A
=TEX
.
=FRULE 2 Tactic
z_seq_induction_tac ÒsÆ
˜
{ á, s ç seq A} t[s]
˜
{ á } t[ß¢/s] ;
strip {t, s ç seq A, x ç A, á} t[s Î ßx¢/s]
=TEX
=FRULE 2 Tactic
z_seq_induction_tac1 ÒsÆ
˜
{ á, s ç seq A} t[s]
˜
{ á } t[ß¢/s] ;
strip {t, s ç seq A, x ç A, á} t[ßx¢ Î s/s]
=TEX
=FAILURE
107031	A term of the form Òs ç seq AÆ where s is the induction variable
	could not be found in the assumptions
107032	?0 is not a variable
=ENDDOC
=DOC
	val €z_seqd_app_conv› : CONV;
	val €z_size_seqd_conv› : CONV;
	val €z_seqd_eq_conv› : CONV;
=DESCRIBE
Conversions for sequence displays.

=INLINEFT
z_seqd_app_conv
=TEX
\ applies to terms of the form $s m$, where $s$ is a sequence display and $m$ is
a numeric literal.

=INLINEFT
z_size_seqd_conv
=DESCRIBE
=TEX
\ applies to terms of the form $\# s$, where $s$ is a sequence display.

=INLINEFT
z_seqd_eq_conv
=DESCRIBE
=TEX
\ applies to terms of the form $s_1 = s_2$, where $s_1$ and $s_2$ are sequence displays.

=FAILURE
107011	?0 is not of the form ¨ßt1, ...¢ mÆ
107012	?0 is not a positive integer literal
107013	?0 is not a valid index for the sequence ?1
107020	?0 is not of the form ¨ßt1, ...¢ = ßu1, ...¢Æ
107021	?0 is not of the form ¨#ßt1, ...¢Æ
=ENDDOC

=DOC
val €z_string_eq_conv› : CONV;
=DESCRIBE
$z\_string\_eq\_conv$ proves theorems of the form:
=GFT
	Ù b = c § t
=TEX
Where $¨bÆ$ and $¨cÆ$ are string literals and where $¨tÆ$ is either
$ÒtrueÆ$ or $ÒfalseÆ$.
=FAILURE
107030	?0 is not of the form: Òb = cÆ where b and c are Z string literals.
=ENDDOC

\subsection{EPILOGUE OF ZSequences1}
=SML
end; (* of signature ZSequences1 *)
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
=THSML
summarize_td_results ();
val z_sequences1_success = theory_check_success ();
=TEX
\section{TEST POLICY}
The module tests for these modules are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


