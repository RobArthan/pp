=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Language Expressions}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP042}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z Language set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First versions.
\item [Issues 1.4 (15th September 1992)]
Changes to reflect  issue 1.6 of detailed design.
\item [Issues 1.5 (29th September 1992)]
Changes after comments, removal of HOL universals where
appropriate.
\item [Issues 1.7 (12th October 1992)]
Modified $z\_•\\ﬁ_thm$.
\item [Issues 1.8 (12th October 1992)]
Moved Library material to \cite{DS/FMU/IED/IMP083}.
\item [Issue 1.9 (26th October 1992)]
Changes after comments - rearrangement of material
amongst 041, 042 and 043. 
\item [Issue 1.10 (10th November 1992)]
Changes to reflect changes in issue 1.18 of dtd041.
Changes to $z\-\_ç\-\_seta\-\_conv$.
\item [Issue 1.13 (17th November 1992)]
Fixed bug in Z bindings proof context.
\item[Issue 1.14 (2nd December 1992)]
Improved $U$ simplification.
\item [Issue 1.15,1.16 (3rd December 1992)]
Gained $ç\_C$, and $Z\-\_ç\-\_ELIM\-\_C$, handling of sequences and $ç\_Ã\_conv$.
\item [Issue 1.17 (9th December 1992)]
Added string literals.
\item[Issue 1.18 (10th December 1992)]
Global rename from wrk038.doc issue 1.9.
\item[Issue 1.19 (14th December 1992)]
Fix bug in $z\_string\_conv$.
\item[Issue 1.20 (17th December 1992)]
Extending treatment of bindings.
\item[Issue 1.21 (20th January 1993)]
Removed mention of $z\_strip\_tac$.
\item[Issue 1.22 (21th January 1993)]
Bug fix.
\item[Issue 1.25 (25th January 1993)]
Tinkering.
\item[Issue 1.26 (25th January 1993)]
Tiny bug fix.
\item[Issue 1.27 (2nd February 1993)]
Fixed proof context bug in ``$'$z$\_$binding''.
\item[Issue 1.28 (5th February 1993)]
Rearranging proof contexts.
\item[Issue 1.29/1.30 (11th/2th February 1993)]
Improved $z\_¬\_conv$.
\item[Issue 1.31 (17th March 1993)]
Improved performance of
=GFT
z_selâs_conv
=TEX
\ (in response to bug 116).
\item[Issue 1.32 (17th December 1993)]
Fixed bug in z\_ß¢\_conv.  It now doesn't fail if the operand is empty.
\item[Issue 1.33 ]
Fixed bug 184 and related problems.
\item[Issue 1.34 ]
Corrected $z\_sets\_ext\_conv$.
\item[Issue 1.36 (25th April 1997)]
Fixing $Z\_ç_ELIM\_C$.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) set theory, tuples and cartesian products.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD042}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the set theory, tuples and cartesian products of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD042}.
\subsubsection{Deficiencies}
$z\_∏\_conv$ is comparatively slow compared to like functions.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure €ZExpressions› : ZExpressions = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = force_delete_theory"imp042" handle Fail _ => ();
val _ = open_theory €"z_language_ps"›;
val _ =
	if	get_current_theory_status() <> TSNormal
	then	new_theory "imp042"
	else	();
val _ = set_pc "z_predicates";
val _ = set_flag("z_type_check_only",false);
=TEX

\section{THE CODE}
\subsection{Utilities}
A precaution, lost outside of structure:
=SML
fun €save_thm›(a,b) = KernelInterface.save_thm(a, check_is_z_thm "save_thm" b)
	handle (Fail _) =>
	(let val thm = get_thm "z_language_ps" a;
	in
		if thm =|- b
		then b
		else fail "save_thm" 0 []
	end);

fun €list_save_thm›(a,b) = KernelInterface.list_save_thm(a, check_is_z_thm "list_save_thm" b)
	handle (Fail _) =>
	(let val thm = get_thm "z_language_ps" (hd a);
	in
		if thm =|- b
		then b
		else fail "save_thm" 0 []
	end);
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
=TEX
Protected $¡$ conversion:
=SML
fun €prot_¡_conv› (nm:string) : CONV = 
	simple_¡_conv nm ORELSE_C (fn tm =>
	if is_simple_Ã tm
	then (let	val newnm = string_variant(map (fst o dest_var) (frees tm)) nm;
	in
		simple_¡_conv newnm tm
	end)
	else fail_conv tm);
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
=SML
fun €LAST_SIMPLE_∂_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_∂ (snd(dest_simple_∂ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_∂_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (prot_¡_conv nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (prot_¡_conv nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX
Change a free variable name:
=SML
fun €change_name_rule› from_nm to_nm thm = (
let	val fvs = map dest_var (frees(concl thm));
	val ty = lassoc3 fvs from_nm;
in
	simple_µ_elim (mk_var(to_nm, ty))
	(simple_µ_intro (mk_var(from_nm, ty)) thm)
end);
=TEX

\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val _ = Ò(d ¶ d, p ¶ p, t ¶ t, v ¶ v)Æ;
val _ = Ò(d ¶ d, p ¶ p, v ¶ v)Æ;
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
=SML
fun €all_undisch_rule› (thm:THM) : THM = (
	if is_¥(concl thm)
	then all_undisch_rule (undisch_rule thm)
	else thm
);
=TEX
\subsection{New Names}
Return a ``pleasant'' name, so far unused in a term.
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if ord nm = ordx
		then nm
		else fail "" 0 []);
	fun lgive_n_name lst = (
	let	fun nextn n = (let val poss = "x" ^ string_of_int n
			in
			if poss mem lst
			then nextn (n+1)
			else poss
			end);
	in
		nextn 1
	end);
in
fun €give_n_name› (tm:TERM) : string = (
let	val names = mapfilter xnames (term_vars tm);
in
	lgive_n_name names
end)
end;
=TEX
\subsection{Conversionals for ç}

\section{THE IMPLEMENTATION}

\subsection{Definite Description}
=FRULE 1 Conversion
ante_∂_¥_conv
¨(∂ x ∑ p[x]) ¥ yÆ
˜
˜
Ù ((∂ x ∑ p[x]) ¥ y) § µ x ∑ p[x] ¥ y
=TEX
=SML
val €ante_∂_¥_thm›  = (
push_goal ([],¨µ p q ∑ (($∂ p) ¥ q) § µ x ∑ p x ¥ qÆ);
push_pc "hol1";
a(REPEAT µ_tac);
a(pure_once_rewrite_tac[prove_rule[]¨p = (Ã y ∑ p y)Æ]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (ante_tac o rewrite_rule[]));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[]));
a(asm_fc_tac[]);
pop_pc();
pop_thm());

val €ante_∂_¥_conv› : CONV = (fn tm =>
let	val (∂p,q) = dest_¥ tm;
	val xnm = fst(dest_var(fst(dest_simple_∂ ∂p)));
	val p = snd(dest_app ∂p);
	val s1 = list_µ_elim[p,q] ante_∂_¥_thm;
	val s2 = conv_rule(RIGHT_C(RAND_C(prot_¡_conv xnm
		THEN_C SIMPLE_Ã_C(LEFT_C simple_¬_conv)))) s1;
in
	eq_trans_rule (refl_conv tm) s2
end);
=TEX
=SML
fun (seq_ante_∂_¥_conv:CONV) (tm:TERM) = ((
	(ante_∂_¥_conv THEN_C BINDER_C seq_ante_∂_¥_conv)
	ORELSE_C id_conv)
	tm
);
=GFT Example
ante_∂_¥_conv ¨(∂ x y z ∑ f x y z) ¥ gÆ;
seq_ante_∂_¥_conv ¨(∂ x y z ∑ f x y z) ¥ gÆ;

=TEX
=INLINEFT
¨$"Z'Õ"Æ
=TEX
{} is a sort of marker function for Z $Õ$ constructions.
=SML
val €z'Õ_thm› = (
push_goal([],¨µ s x ∑ (µ y ∑ y ç s ¥ y = x) ± (x ç s) ¥ ($"Z'Õ" s = x)Æ);
push_pc "hol1";
a(REPEAT strip_tac);
a(LEMMA_T ¨s = {x}Æ (fn x => rewrite_tac [z'Õ_def,x]));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
pop_pc();
pop_thm());
=TEX
=SML
val €hd_last_µ_conv› : CONV = (fn tm =>
let 	val (hdv,bdy) = dest_simple_µ tm;
	val (vs,bdy') = strip_simple_µ bdy;
in
	µ_reorder_conv (list_mk_µ((vs @ [hdv]), bdy')) tm
end);
=TEX
=SML
local

val thm1 = (
push_goal([],¨µ a b c d ∑ 
	(µ y ∑ (a ± b ± (c = y)) ¥ (y = d)) §
	(a ± b ¥ (c = d))Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim ¨cÆ));
(* *** Goal "2" *** *)
a(POP_ASM_T(asm_rewrite_thm_tac o eq_sym_rule));
pop_thm());

	val cnv1 = simple_eq_match_conv1 thm1; 
in
fun €z_Õ_rule› (tm : TERM) :THM = (
let	val (d,p,v) = dest_z_Õ tm
		handle complaint =>
		pass_on complaint "dest_z_Õ" "z_Õ_rule";
	val vars =  map (fst o dest_var)
		(list_variant(map mk_var (term_vars tm))
		(map (fn x => mk_var(x,BOOL))["x","x","y"]));
	val var_x = hd (tl vars);
	val var_x1 = hd vars;
	val var_y = hd (tl(tl vars));
	val spec = conv_rule (BINDER_C(RIGHT_C(RAND_C(RAND_C
		(prot_¡_conv var_x))))) (Õ_gen_semantic_const tm);
	val s1 = simple_eq_match_conv1 spec tm;
	val s2 = conv_rule (RIGHT_C(RAND_C(BINDER_C
		(ALL_SIMPLE_∂_C(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		((RAND_C (fn _ => ¬red_thm)) THEN_C d_dpv_proj_conv),
		((RAND_C (fn _ => ¬red_thm)) THEN_C p_dpv_proj_conv),
		(LEFT_C((RAND_C (fn _ => ¬red_thm))THEN_C v_dpv_proj_conv))] tm
		end))))) s1;
	val was_sig = fst(strip_Ã(snd(dest_app tm)));
	val s3 = conv_rule (RIGHT_C(RAND_C(BINDER_C
		(seq_binder_simple_¡_conv was_sig)))) s2;
	val new_set = snd(dest_app(snd(dest_eq (concl s3))));
	val z'Õ_thm' = conv_rule (BINDER_C
		(RAND_C (prot_¡_conv var_x1 THEN_C
		SIMPLE_Ã_C (LEFT_C(LEFT_C(RAND_C(prot_¡_conv var_y))))))) 
			z'Õ_thm;
	val s4 = conv_rule (BINDER_C(RIGHT_C(LEFT_C(
		fn tm => (if tm =$ snd(dest_eq (concl s3))
			then eq_sym_rule s3
			else term_fail "z_Õ_rule" 0 [])))))
		(µ_elim new_set z'Õ_thm');
	val s5 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(BINDER_C((LEFT_C
				simple_ç_comp_conv)
			THEN_C seq_ante_∂_¥_conv)),
			simple_ç_comp_conv THEN_C z_∂_intro_conv1)))) s4;
	val s6 = conv_rule(BINDER_C(LEFT_C(LEFT_C(
		hd_last_µ_conv THEN_C
		LAST_SIMPLE_µ_C cnv1 THEN_C
		z_µ_intro_conv1)
		))) s5;
	val s7 = conv_rule (TRY_C z_µ_intro_conv) s6;
in
	check_is_z_thm "z_Õ_rule" s7
end);
end;
=TEX
=GFT Example
z_Õ_rule ÒÕ x,y:X;z:Y;p:X | z ∑ x = yÆ;
z_Õ_rule ÒÕ x,y:X;z:Y;p:X | z ∑ p(x = y)Æ;
=TEX

\subsection{Functional Application}
=SML
local
val _ = push_pc "hol1";
val thm1 = simple_eq_match_conv1 z'app_def Òf aÆ;
val thm2 = all_µ_intro(
		rewrite_rule[] (
		µ_elim ¨{f_a:'b|Ò(¨a:'aÆ,¨f_a:'bÆ) ç fÆ}Æ 
		z'Õ_thm));
val thm3 = (push_goal([],Ò(µ f_a:U | (a, f_a) ç f ∑ f_a = x) ±
	(a,x) ç f
	¥
	(f a = x)Æ);
a(REPEAT strip_tac);
a(rewrite_tac[thm1]);
a(strip_asm_tac(list_µ_elim[¨aÆ,¨fÆ,¨xÆ] thm2));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule z_µ_elim_conv1));
a(asm_fc_tac[]);
pop_thm());
val _ = pop_pc();		
in
val €z_app_thm› = save_thm("z_app_thm", all_z_µ_intro thm3);
end;

=SML
local
	val thm1 = conv_rule z_µ_elim_conv1 z_app_thm;
in
fun €local_z_app_rule› tm = (
let	val (f,a) = dest_z_app tm;
	val vs = map mk_var(term_vars tm);
	val x' = variant vs (mk_var("x",type_of tm));
in
	simple_µ_intro x' (list_µ_elim [a,f,x'] thm1)
end);
end;
=TEX
=SML
local
	val thm1 = taut_rule ¨µ x ∑ x § (x § T)Æ;
	val thm2 = conv_rule z_µ_elim_conv1 z_app_thm;
	val cnv1 = simple_eq_match_conv1 thm1;
in
fun (€z_app_eq_tac› : TACTIC) ((asms,conc):GOAL) = (
	if not(is_z_eq conc orelse is_z_§ conc) andalso is_z_app conc
	then (conv_tac cnv1 THEN z_app_eq_tac)(asms,conc)
	else
let	val (fa,v) = dest_z_eq conc
		handle complaint as (Fail _) =>
		(dest_z_§ conc
		handle complaint as (Fail _) =>
		(divert complaint "dest_z_§" "z_app_eq_tac" 42002 []));
in
	CHECK_IS_Z_T "z_app_eq_tac"
	(if is_z_app fa
	then (let val (f,a) = dest_z_app fa;
		in
		¥_thm_tac (list_µ_elim [a,f,v] thm2)
	end)
	else if is_z_app v
	then (let val (f,a) = dest_z_app v;
		val v = fa
	in
		¥_thm_tac (conv_rule(RIGHT_C eq_sym_conv)
			(list_µ_elim [a,f,v] thm2))
	end)
	else fail "z_app_eq_tac" 42002 [])(asms,conc)
end);
end;
=GFT Example
set_goal([],Òp 1 = 2Æ);
a(z_app_eq_tac);
set_goal([],Ò2 = p 1Æ);
a(z_app_eq_tac);
set_goal([],Ò¨r:(˙, BOOL) $"Z'T[2]" SETÆ 1Æ);
a(z_app_eq_tac);
drop_main_goal();
=TEX
=SML
=SML
local
val a_z_app_thm = (
push_goal([],¨µ (f:('a, 'b) $"Z'T[2]" SET) (a:'a) ∑ 
	Òf a = (Õ f_a :U | (a,f_a) ç f ∑ f_a)ÆÆ);
push_pc "hol1";
a(REPEAT µ_tac);
let val (lhs,rhs) = dest_eq(snd(top_goal()));
in
a(rewrite_tac[dpv_proj_thm, get_spec lhs, get_spec rhs])
end;
a(conv_tac (ONCE_MAP_C z_decl_pred_conv));
a(conv_tac (ONCE_MAP_C z_ç_u_conv));
a(rewrite_tac[]);
a(conv_tac (ONCE_MAP_C prove_∂_conv));
a(rewrite_tac[]);
pop_pc();
pop_thm());
in
val €z_app_conv› :CONV = simple_eq_match_conv1 a_z_app_thm
	ORELSE_C (fn tm => term_fail "z_app_conv" 47190 [tm]);
end;
=TEX
=GFT Example
z_app_conv Ò1 + 2Æ;
=TEX

\subsection{Concerning Ã}
=SML
local
val x = mk_var("x",type_of Ò(x,y)Æ);
in
val €p1_q2_thm› = all_µ_intro(
push_goal([],Ò((p = ëxÆ.1) ± (q = ëxÆ.2)) § ((p,q) = ëxÆ)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_specÒ(x,y)Æ]);
(* *** Goal "2" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_specÒ(x,y)Æ]);
(* *** Goal "3" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_specÒ(x,y)Æ]);
pop_thm());
end;
=TEX
=SML
local

	val z'Ã_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		((fn tm => 
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv),
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv)
		] tm
		end)
		THEN_C RIGHT_C(RAND_C (simple_eq_match_conv1 p1_q2_thm))));

	val z'seta_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		(fn tm => 
		let val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dpv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dpv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dpv_proj_conv)
		] tm
		end
		));
in
val €z_Ã_conv› : CONV = (fn tm =>
let	val (d,p,v) = dest_z_Ã tm
		handle complaint =>
		pass_on complaint "dest_z_Ã" "z_Ã_conv";
	val was_sig = fst(strip_Ã(snd(dest_app tm)));
	val s1 = Ã_gen_semantic_const tm;
	val s2 = simple_eq_match_conv1 s1 tm;
	val s3 = conv_rule (RIGHT_C z'Ã_conv1) s2;
	val s4 = conv_rule (RIGHT_C(BINDER_C 
		(seq_binder_simple_¡_conv was_sig))) s3;
	val v' = fst(dest_eq(snd(dest_±(snd(dest_±(snd(strip_∂
		(snd(dest_set_comp(snd(dest_eq(concl s4))))))))))));
	val tar_tm = mk_z_seta(d,p,v');
	val s5 = seta_gen_semantic_const tar_tm;
	val s6 = simple_eq_match_conv1 s5 tar_tm;
	val s7 = conv_rule(RIGHT_C z'seta_conv1) s6;
	val s8 = conv_rule (RIGHT_C(BINDER_C 
		(seq_binder_simple_¡_conv was_sig))) s7;
	val s9 = eq_trans_rule s4 (eq_sym_rule s8);
in
	check_is_z_thm "z_Ã_conv" s9
end);
end;
=TEX
=GFT Example
z_Ã_conv ÒÃ x,y:X;a:Y | f x ∑ g y aÆ;
z_Ã_conv Ò(Ã [z:Y;x,y : X| x = y] | g x ∑ f z x)Æ;
z_Ã_conv Ò(Ã [x,y : X | x = y] | g x ∑ f x)Æ;
=TEX
Replace a single HOL universal by a single Z universal,
no declarations, etc, present.
=SML
local
	val thm1 = all_µ_intro(set_goal([], Òx § (((y ç U) ± true) ¥ x)Æ);
		a(conv_tac (MAP_C z_ç_u_conv));
		a(PC_T1 "hol" rewrite_tac[]);
		pop_thm());
in
fun €z_µ_intro_1_var› thm = (
let	val (x,bdy) = dest_µ(concl thm);
	val s1 = simple_µ_elim x thm;
	val s2 = §_mp_rule (list_µ_elim[concl s1,x] thm1) s1;
in
	z_µ_intro1 s2
end);
end;
=IGN
z_µ_intro_1_var (asm_rule ¨µ x ∑ (x = Ò3Æ) ¥ (x = Ò4Æ)Æ);
=SML
local
	val z'Ã_conv1 = ALL_SIMPLE_∂_C
		(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_1_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_2_proj_conv
		] tm
		end)
		THEN_C z_∂_intro_conv1;
in
fun €z_app_Ã_rule› (tm :TERM):THM  = (
let	val (lam,arg) = dest_z_app tm
		handle complaint =>
		divert complaint "dest_z_app" "z_app_Ã_rule" 42008 
			[fn () => string_of_term tm];
	val (d,p,v) = dest_z_Ã lam
		handle complaint =>
		divert complaint "dest_z_Ã" "z_app_Ã_rule" 42008 
			[fn () => string_of_term tm];
	val was_sig = fst(strip_Ã(snd(dest_app lam)));
	val s1 = (local_z_app_rule tm);
	val s2 = Ã_gen_semantic_const lam;
	val cnv1 = RIGHT_C (simple_eq_match_conv1 s2) THEN_C
		simple_ç_comp_conv THEN_C 
		seq_binder_simple_¡_conv was_sig THEN_C
		z'Ã_conv1;
	val s3 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(RAND_C(BINDER_C(LEFT_C cnv1))),
		cnv1)))) s1;
	val s4 = z_µ_intro_1_var s3;
in
	check_is_z_thm "z_app_Ã_rule" s4
end);
end;
=GFT Example
z_app_Ã_rule Ò(Ã x,y : X; z:Y | x = y ∑ f z x) (1,2,g)Æ;
z_app_Ã_rule Ò(Ã x : X | f x ∑ g x) yÆ;
z_app_Ã_rule Ò(Ã [x,y : X; z:Y| x = y] | g x ∑ f z x) (x ¶ 1,y ¶ 2,z ¶ g)Æ;
z_app_Ã_rule Ò(Ã x : X ∑ y) xÆ;
z_app_Ã_rule Ò(Ã x : X ∑ y) zÆ;
z_app_Ã_rule Ò(Ã x : X ∑( µ z : U ∑ f x y z)) zÆ;
=TEX
=SML
local
	val ¥_thm = taut_rule¨µ x ∑ x ¥ xÆ;

	fun local_rule thm gl = (
	let 	val (a,b) = dest_¥ gl;
		val (x,bdy) = dest_eq(concl thm);
		val ithm = simple_µ_elim b ¥_thm;
	in
		subst_rule[(eq_sym_rule thm,x)] gl ithm
	end);
	val eq_cnv1 = simple_eq_match_conv1 (prove_rule [] ¨µ x ∑ (x = x) § TÆ);
	val ±_cnv1 = simple_eq_match_conv1 (prove_rule [] ¨µ x ∑T ±  x § xÆ);

	val rwc = RIGHT_C(RIGHT_C(LEFT_C eq_cnv1 THEN_C ±_cnv1));
	val rw_tac2_thm = tac_proof(([],
		¨µ t∑ ≥ (F ± t) ± ≥ (t ± F) ±
		(µ x∑ x = x § T) ± (F ¥ t) ±
		(≥ T § F) ± (≥ F § T)Æ),
		rewrite_tac[]);
	val rw_rule = prim_rewrite_rule empty_net
		initial_rw_canon
		TOP_MAP_C
		[]
		[rw_tac2_thm, ≥_§_thm];
	val rw_tac2 = (prim_rewrite_tac	
		(make_net(flat(map (cthm_eqn_cxt initial_rw_canon)
			[rw_tac2_thm])))
		initial_rw_canon 
		TOP_MAP_C
		[]);
in
fun local_simple_∂_equation_conv witness tm = (
let	val (x,bdy) = dest_simple_∂ tm;
	val (xnm,xty) = dest_var x;
	val new_term = var_subst [(witness,x)] bdy;
	val new_term_rw = rwc new_term;
	val new_term' = snd(dest_eq(concl new_term_rw));
	val thm = tac_proof(([],mk_§(tm,new_term')),
		§_T2 (fn thm =>
		t_tac ORELSE
		conv_tac(fn ag => eq_sym_rule new_term_rw)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @ frees new_term) x;
			in
			CASES_T2 (mk_eq(x',witness))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				thm1,
				((rw_rule thm1) handle (Fail _) => t_thm),
				≥_eq_sym_rule thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac witness THEN accept_tac 
			(§_mp_rule (eq_sym_rule new_term_rw) thm)
		));
in
	eq_trans_rule (refl_conv tm) thm
end);
end;
=TEX
=SML
local
	val z'Ã_conv1 = BINDER_C
		(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_1_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_2_proj_conv
		] tm
		end);
val cnv2_cnvs = map simple_eq_match_conv1 [
	(tac_proof(([],
		¨µ a b c d e ∑ 
		(a ± b ± c ± (d = e) ¥ (e = d)) § TÆ),
		REPEAT strip_tac THEN asm_rewrite_tac[])),
	(tac_proof(([],
		¨µ a b d e ∑ 
		(a ± b ± (d = e) ¥ (e = d)) § TÆ),
		REPEAT strip_tac THEN asm_rewrite_tac[]))];

val cnv2 = hd cnv2_cnvs ORELSE_C (hd(tl cnv2_cnvs));

val cnv3 = simple_eq_match_conv1 (prove_rule[]¨(µ x ∑ T) § TÆ);
val cnv4 = simple_eq_match_conv1 (prove_rule[]¨µ x ∑ (T ± x) § xÆ);
val cnv5_thms = [eq_rewrite_thm, ±_rewrite_thm];

val cnv5a = (pure_rewrite_conv cnv5_thms);
val cnv5b_thms = [taut_rule ¨µ x ∑ ((T ± T) ¥ x) § xÆ,
	taut_rule ¨µ x y ∑ ((T ± y) ¥ x) § (y ¥ x)Æ,
	taut_rule ¨µ x y ∑ ((y ± T) ¥ x) § (y ¥ x)Æ,
	taut_rule ¨µ x y z ∑ ((y ± z) ¥ x) § (z ¥ y ¥ x)Æ,
	taut_rule ¨µ x ∑ (T ¥ x) § xÆ];

val cnv5b = (prim_rewrite_conv empty_net initial_rw_canon
		(Combinators.I) [] cnv5b_thms);

val cnv5 = (LEFT_C (TRY_C cnv5a)) THEN_C(TRY_C cnv5b);
val Ã1_def = get_spec Ò(Ã p:U∑q)Æ;
val Ã1_conv = simple_eq_match_conv1 Ã1_def;
in
fun €z_¬_conv› (tm :TERM):THM  = (
let	val (lam,arg) = dest_z_app tm;
	val (d,p,v) = dest_z_Ã lam;
	val was_sig = fst(strip_Ã(snd(dest_app lam)));
	val d' = dest_z_decl d;
	val dummy = if (length d' <> 1) orelse (not(is_z_dec (hd d'))) orelse 
			length(fst(dest_z_dec (hd d'))) <> 1
		then term_fail "z_¬_conv" 42012 [tm]
		else ();
	val (singx,aset) = (hd ** Combinators.I) (dest_z_dec (hd d'));
	val s1 = (local_z_app_rule tm);
	val cnv1 = RIGHT_C Ã1_conv THEN_C
		simple_ç_comp_conv THEN_C 
		seq_binder_simple_¡_conv was_sig THEN_C
		z'Ã_conv1;
	val s3 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(RAND_C(BINDER_C(LEFT_C cnv1))),
		cnv1)))) s1;
	val resu = var_subst[(arg,singx)] v;
	val s4 = simple_µ_elim resu s3;
	val ciz = set_flag("check_is_z",false);
	val s5 = (conv_rule(LEFT_C(APP_C(
		RAND_C (z_µ_elim_conv2 THEN_C
		BINDER_C(LEFT_C(RIGHT_C (local_simple_∂_equation_conv arg))
		THEN_C cnv2)
		THEN_C cnv3),
		(local_simple_∂_equation_conv arg) THEN_C 
			((LEFT_C (Z_DECL_C (z_dec_pred_conv THEN_TRY_C z_ç_u_conv)))
		ORELSE_C (Z_DECL_C (z_dec_pred_conv THEN_TRY_C z_ç_u_conv))))
		THEN_C cnv4)) s4)
		handle complaint =>
		(set_flag("check_is_z",ciz); reraise complaint "z_¬_conv");	
	val ciz' = set_flag("check_is_z",ciz);
	val s6 = all_undisch_rule(conv_rule cnv5 s5);
in
	check_is_z_thm "z_¬_conv" (eq_trans_rule (refl_conv tm) s6)
end
handle complaint =>
list_divert complaint "z_¬_conv" [
	("dest_z_app", 42012, [fn () => string_of_term tm]),
	("dest_z_Ã", 42012, [fn () => string_of_term tm])]
);
end;
=TEX
=GFT Example
z_¬_conv Ò(Ã x : X | f x ∑ g x) yÆ;
z_¬_conv Ò(Ã p : U | f p ∑ g p q) yÆ;
z_¬_conv Ò(Ã p : U  ∑ g p q) yÆ;
z_¬_conv Ò(Ã p : U  ∑ p = y) yÆ;
z_¬_conv Ò(Ã p : U  ∑ y = p) yÆ;
z_¬_conv Ò(Ã p : U  | (true ± f p) ∑ ê(true ± (y = p))) yÆ;
z_¬_conv Ò(Ã x : X ∑ y) zÆ;
z_¬_conv Ò(Ã x : X ∑ y) xÆ;
=TEX

\subsection{Sets}
=SML
val €z_sets_ext_thm› : THM = save_thm ("z_sets_ext_thm",
	all_z_µ_intro(
push_goal([],Ò(x = y) § (µz: U ∑ ((z ç x) § (z ç y)))Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T (ante_tac o conv_rule z_µ_elim_conv1));
a(PC_T1 "hol1" rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €z_ç__thm1› : THM = save_thm("z_ç__thm1", all_z_µ_intro(
push_goal([],Ò(t ç  u) § (µz: U ∑ ((z ç t) ¥ (z ç u)))Æ);
a(rewrite_tac[z'app_def, z'_def]);
a(PC_T1 "hol1" rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
pop_thm()));
local
	val z'seta_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		(fn tm => 
		let val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dpv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dpv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dpv_proj_conv)
		] tm
		end
		));
in
val €z_ç_seta_conv› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
	val was_sig = fst(strip_Ã(snd(dest_app s)));
	val (d,p,t) = dest_z_seta s;
	val spec = seta_gen_semantic_const s;
	val s1 = (RAND_C 
		((simple_eq_match_conv1 spec) THEN_C
		z'seta_conv1) THEN_C
		simple_ç_comp_conv) tm;
	val s2 = conv_rule (RIGHT_C 
		((seq_binder_simple_¡_conv was_sig)
		THEN_C z_∂_intro_conv1)) s1;
in
	check_is_z_conv_result "z_ç_seta_conv"
		(eq_trans_rule (refl_conv tm) s2)
end
handle complaint =>
list_divert complaint "z_ç_seta_conv"
	[("eq_trans_rule",42001,[fn () => string_of_term tm]),
	("dest_z_ç",42001,[fn () => string_of_term tm]),
	("dest_z_seta",42001,[fn () => string_of_term tm])]);
end;
=IGN
z_ç_seta_conv Òp ç {x:X∑(x,x)}Æ;
z_ç_seta_conv Ò(1,2) ç {x:X;y:Y∑(x,y)}Æ;
=TEX
=SML
local
	val thm1 = (
	push_goal([],¨µ (x:'a)∑ Ò(x ç {} § false)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm2 = (
	push_goal([],¨µ (x:'a) (h:'a) ∑ Ò(x ç {h} § x = h)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm3 = (
	push_goal([],¨µ (x:'a) (h:'a) (t:'a LIST) ∑ 
	Ò(x ç  ¨Z'Setd (Cons h t)Æ) § (x = h ≤ x ç ¨Z'Setd tÆ)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	a(REPEAT strip_tac);
	pop_thm());

	val cnv1 = simple_eq_match_conv1 thm1;
	val cnv2 = simple_eq_match_conv1 thm2;
	val cnv3 = simple_eq_match_conv1 thm3;
	fun cnv4 tm = (cnv2 ORELSE_C
		(cnv3 THEN_C RIGHT_C cnv4)
		ORELSE_C (fn tm => term_fail "z_ç_setd_conv"
			42008 [tm])) tm;
	val thm5 = pc_rule1 "hol1" prove_rule[] ¨µ x y ∑ ((x = x) ≤ y) § TÆ;
	val cnv5 = simple_eq_match_conv1 thm5;
	val thm6 = taut_rule ¨µ x ∑ (x ≤ T) § TÆ;
	val cnv6 = simple_eq_match_conv1 thm6;
	val thm7 = pc_rule1 "hol1" prove_rule [] ¨µ x ∑ (x =x) § TÆ;
	val cnv7 = simple_eq_match_conv1 thm7;
	fun cnv8 tm = (
	let	val (p,q) = dest_≤ tm;
		val (x1,h) = dest_eq p;
	in
		if x1 ~=$ h
		then cnv5 tm
		else (RIGHT_C cnv8 THEN_C cnv6) tm
	end
	handle (Fail _) =>
	cnv7 tm);

in
val €z_ç_setd_conv1› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
	val (_,tml) = dest_z_setd s;
	val dummy = if x term_mem tml
		then ()
		else term_fail "z_ç_setd_conv1" 42009 [tm];
	val s1 = cnv4 tm
		handle complaint =>
		pass_on complaint "z_ç_setd_conv" "z_ç_setd_conv1";
	val s2 = conv_rule (RIGHT_C cnv8) s1;
in
	check_is_z_conv_result "z_ç_setd_conv1" 
	s2
end
handle complaint =>
list_divert complaint "z_ç_setd_conv1"
	[("dest_z_ç",42009,[fn () => string_of_term tm]),
	("dest_z_setd",42009,[fn () => string_of_term tm])]);
end;


=IGN
z_ç_setd_conv Ò3 ç {2,3,4}Æ;
z_ç_setd_conv Ò3 ç {4}Æ;
z_ç_setd_conv Ò3 ç {}Æ;
z_ç_setd_conv1 Ò3 ç {2,3,4}Æ;
z_ç_setd_conv1 Ò3 ç {3}Æ;
=TEX
=SML
val _ = delete_pc "'build_z_sets" handle (Fail _) => ();
val _ = new_pc "'build_z_sets";
val _ = set_rw_eqn_cxt 
	[(Òx ç ¨y (Ã z ∑ w):'a SETÆÆ,z_ç_seta_conv),
	 (Òx ç ¨Z'Seta[0] y:'a SETÆÆ,z_ç_seta_conv),
	 (¨(Ã x ∑ y) zÆ,simple_¬_conv),
	 (Òx ç ¨Z'Setd yÆÆ,z_ç_setd_conv1)] "'build_z_sets";
val _ = add_rw_thms [µ_rewrite_thm] "'build_z_sets";
val _ = set_pr_tac z_basic_prove_tac "'build_z_sets";
val _ = set_pr_conv z_basic_prove_conv "'build_z_sets";
=TEX
=SML
fun €tt_to_∂_vs›  (ty : TYPE) : (string * (TERM list * THM)) = (
let	val (abs,cons) = get_tuple_info ty;
	val def_thm = get_spec (hd cons);
	val abs_nm = fst(dest_const abs);
in
	(abs_nm,(cons, def_thm))
end);
=TEX
=SML
val _ =set_∂_vs_thms [tt_to_∂_vs î'X SET $"Z'T[1]"Æ] "'build_z_sets";

val _ = set_merge_pcs ["z_predicates","'build_z_sets"];
=TEX
\section{TUPLES}
=SML
local
	fun aux thm [] [] = thm
	| aux thm (a::x)(b::y) = aux (mk_app_rule thm (asm_rule (mk_z_eq (a, b)))) x y
	| aux _ _ _ = error "z_tuple_lang_eq_conv" 0 [];
	
	fun aux1 tm [] [] = tm
	| aux1 tm (a::x)(b::y) = aux1 (mk_z_±(mk_z_eq (a,b), tm)) x y
	|aux1 _ _ _ = error "z_tuple_lang_eq_conv" 0 [];
in
val €z_tuple_lang_eq_conv› : CONV = (fn tm =>
let	val (lhs,rhs) = dest_z_eq tm
		handle (Fail _) =>
		term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val s0 = if is_z_tuple lhs andalso is_z_tuple rhs
		then refl_conv tm
		else term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val tm' = snd(dest_eq(concl s0));
	val (lhs,rhs) = dest_z_eq tm';
	val dummy = if is_z_tuple lhs andalso is_z_tuple rhs
		then ()
		else term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val spec = tuple_gen_semantic_const lhs;
	val proj_thms = map all_µ_intro
		(rev(tl(rev(strip_±_rule(all_µ_elim spec)))));
	val (tcons,tproj) = get_tuple_info (type_of lhs);
	val lhs_bits = dest_z_tuple lhs;
	val rhs_bits = dest_z_tuple rhs;
	val tcons' = fst(strip_app lhs);
	val ty_insts = fst(term_match tcons' tcons);
	val s1 = aux (refl_conv tcons') lhs_bits rhs_bits;
	val rlhs_bits = rev lhs_bits;
	val rrhs_bits = rev rhs_bits;
	val res = aux1 (mk_z_eq(hd rlhs_bits, hd rrhs_bits))
		(tl rlhs_bits) (tl rrhs_bits);
	val s2 = strip_±_rule (asm_rule res);
	val s3 = fold (uncurry prove_asm_rule) s2 s1;
	val s4 = asm_rule tm';
	val s5 = map (fn (x,xthm) => 
		conv_rule(APP_C(RAND_C(simple_eq_match_conv1 xthm),
			simple_eq_match_conv1 xthm))
		(app_fun_rule (inst [] ty_insts x) s4)) 
		(combine tproj proj_thms);
	val s6 = list_±_intro s5;
	val s7 = §_intro(all_¥_intro s6) (all_¥_intro s3);
in
	check_is_z_conv_result "z_tuple_lang_eq_conv" 
	(eq_trans_rule s0 s7)
end);
end;
=TEX
=IGN
z_tuple_lang_eq_conv Ò(1,2,3) = (p,q,r)Æ;
=SML
val €z_selât_lang_conv› : CONV = (fn tm =>
let	val (bdy,n) = dest_z_selât tm
		handle complaint =>
		pass_on complaint "dest_z_selât" "z_selât_lang_conv";
	val eg_tm = (mk_z_tuple o map (curry mk_var "x") o
			dest_z_tuple_type o type_of) bdy
		handle Fail _ => term_fail "z_selât_lang_conv" 42006 [tm];
	val spec = tuple_gen_semantic_const eg_tm;
	val s0 = (if is_z_tuple bdy
		then refl_conv tm
		else term_fail "z_selât_lang_conv" 42006 [tm]);
	val tm' = snd(dest_eq(concl s0));
	val (bdy,n) = dest_z_selât tm'; 
	val xi = dest_z_tuple bdy;
	val proj_thm = nth (n-1) 
		(strip_±_rule(list_µ_elim (bdy :: xi) spec));
in
	check_is_z_conv_result "z_selât_lang_conv"
	(eq_trans_rule s0 proj_thm)
end);
=TEX
=IGN
z_selât_lang_conv Ò(1,2,3,4).2Æ;
=SML
val €z_tuple_lang_intro_conv› : CONV = (fn tm =>
let	val s0 = if is_z_tuple tm
		then refl_conv tm
		else term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val tm' = snd(dest_eq(concl s0));
	val xi = dest_z_tuple tm'
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val tuple= fst(dest_z_selât(hd xi))
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val spec = all_µ_elim (µ_elim tuple (tuple_gen_semantic_const tm'))
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val cthm = hd(rev(strip_±_rule spec));
in
		check_is_z_conv_result "z_tuple_lang_intro_conv"
		(eq_trans_rule s0 cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_lang_intro_conv" 42005
			[fn () => string_of_term tm])
end);
=TEX
=IGN
z_tuple_lang_intro_conv Ò((1,2,3).1,(1,2,3).2,(1,2,3).3)Æ;
=SML
val €z_selât_intro_conv› : CONV = (fn tm =>
let	val eg_tm = (mk_z_tuple o map (curry mk_var "x") o
			dest_z_tuple_type o type_of) tm
		handle (Fail _) =>
		term_fail "z_selât_intro_conv" 42004 [tm];
	val spec = all_µ_elim (µ_elim tm (tuple_gen_semantic_const eg_tm));
	val cthm = eq_sym_rule(hd(rev(strip_±_rule spec)));
in
		check_is_z_conv_result "z_selât_intro_conv"
		(eq_trans_rule (refl_conv tm) cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_lang_intro_conv" 42004
			[fn () => string_of_term tm])
end);
=TEX
=IGN
z_selât_intro_conv Ò(1,2,3)Æ;
=TEX
 
\section{CARTESIAN PRODUCTS}

=SML
local
	fun aux count 0 avoid = []
	| aux count n avoid = 
=SMLLITERAL
		if ("tâ" ^ string_of_int count) mem avoid
		then aux (count + 1) n avoid
		else ("tâ" ^ string_of_int count) :: aux (count + 1) (n-1) avoid;
=SML
	val t_±_thm = taut_rule ¨µ x ∑ T ± x § xÆ;
	val cnv1 :CONV = simple_eq_match_conv1
	(conv_rule z_µ_elim_conv1 z_sets_ext_thm);

in
=TEX
=SML
val €z_∏_conv› : CONV = (fn tm =>
let	val si = dest_z_∏ tm
		handle complaint =>
		pass_on complaint "dest_z_∏" "z_∏_conv";
	val spec = list_µ_elim si (∏_gen_semantic_const tm);
	val tis = aux 1 (length si) (map fst(term_vars tm));
	val elem_tys = map (fn x => hd(snd(dest_ctype(type_of x)))) si;
	val ti = map mk_var (combine tis elem_tys);
	val ti_decs = map (fn (x,y) => mk_z_dec([x],y)) (combine ti si);
	val res = mk_z_seta(mk_z_decl ti_decs,
		mk_t,
		mk_z_tuple ti);
	val dummy = seta_gen_semantic_const res;
=TEX
=SML
	val dummy = set_flag("check_is_z",false);
	val s1 = tac_proof(([],mk_z_eq(tm,res)),
		conv_tac(cnv1 THEN_C z_µ_elim_conv1) THEN
		simple_µ_tac THEN
		(fn (asms,conc) => let	 val t = fst(dest_z_ç(snd(dest_z_§ conc)))
			val lthm = z_selât_intro_conv t;
		in
		conv_tac(APP_C(RAND_C(LEFT_C(fn _ => lthm)),
			LEFT_C(fn _ => lthm))) (asms,conc)
		end)
		THEN conv_tac (APP_C(RAND_C
			(RIGHT_C (fn _ => spec) THEN_C
			ç_comp_conv),
			z_ç_seta_conv))
		THEN conv_tac (APP_C(RAND_C
			(±_C(LEFT_C z_selât_lang_conv)),
			z_∂_elim_conv2 THEN_C
			ALL_SIMPLE_∂_C 
			(LEFT_C z_decl_pred_conv THEN_C
			RIGHT_C(
			simple_eq_match_conv1 t_±_thm THEN_C
			 z_tuple_lang_eq_conv) )
			THEN_C basic_prove_∂_conv))
	THEN taut_tac);
	val dummy = set_flag("check_is_z",dummy);
in
	check_is_z_conv_result "z_∏_conv" s1
end)
end;
=IGN
z_∏_conv ÒX ∏ Y ∏  YÆ;
=SML
val €z_ç_∏_conv› : CONV = (fn tm =>
let	val (t,ct) = dest_z_ç tm
		handle (Fail _) =>
		term_fail  "z_ç_∏_conv" 42007 [tm];
	val si = dest_z_∏ ct
		handle (Fail _) =>
		term_fail  "z_ç_∏_conv" 42007 [tm];
	val spec = list_µ_elim si (∏_gen_semantic_const ct);
	val s1 = (RIGHT_C(fn _ => spec) THEN_C ç_comp_conv) tm;
	val s2 = conv_rule(RIGHT_C (±_C 
		(TRY_C(LEFT_C z_selât_lang_conv)))) s1;
in
	check_is_z_conv_result "z_ç_∏_conv" 
	(eq_trans_rule (refl_conv tm) s2)
end);
=IGN
z_ç_∏_conv Ò(1,2,3) ç  X ∏ X ∏ XÆ;
z_ç_∏_conv Òx ç  X ∏ X ∏ XÆ;
=TEX
\subsection{Out of Place}
The following is necessary for $z\_sets\_ext\_conv$,
but is out of its proper section.
=SML
val €z_bindingd_intro_conv› : CONV = (fn tm =>
let	val spec = all_µ_elim (µ_elim tm (binding_gen_semantic_const tm))
		handle (Fail _) =>
		term_fail "z_bindingd_intro_conv" 42017 [tm];
	val cthm = eq_sym_rule(hd(rev(strip_±_rule spec)));
in
		check_is_z_conv_result "z_bindingd_intro_conv"
		(eq_trans_rule (refl_conv tm) cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_bindingd_intro_conv" 42004
			[fn () => string_of_term tm])
end);
=IGN
z_bindingd_intro_conv Ò(x ¶ 1, y ¶ 2)Æ;
=TEX

\subsection{Extensionality of Sets II}
=TEX
The following returns four ``bits'' derived from a type
that may have nested bindings or tuples at the outer level,
and a term which is a source of variable names to avoid.
Returned is a theorem that explodes a variable $x$ 
into a construct formed by selecting from $x$,
a construct of the form as the RHS of the above, but formed from
$x1$, $x2$, ...,
the $x_i$ as a list,
and $x$ itself.
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if (ord nm = ordx) handle Ord => true
		then nm
		else fail "" 0 []);
	fun give_n_names nn lst = (
	let	fun nextn n = (let val poss = "x" ^ string_of_int n
			in
			if poss mem lst
			then nextn (n+1)
			else (n,poss)
			end);
		fun nextnm 0 m = []
		| nextnm n m = (let val (ind,next) = nextn m
			in
			(next :: nextnm (n-1) (ind+1))
			end)
	in
		nextnm nn 1
	end);

	fun explode_tm (tm : TERM) : THM = (
	(case dest_z_type (type_of tm) of
	ZSchemaType _ => z_bindingd_intro_conv THEN_C (RANDS_C explode_tm)
	| ZTupleType _ => z_selât_intro_conv THEN_C (RANDS_C explode_tm)
	| _ => refl_conv)
	tm
	);

	fun exploded_bits tm = (
	case dest_z_term1 tm of (* was dest_z_term KB *)
	ZTuple bits => flat(map exploded_bits bits)
	| ZBinding bits1 => flat (map (exploded_bits o snd) bits1)
	| _ => [tm]
	);
	val Ua = ÒUÆ;
	fun uf ty = inst [] [(ty, î'aÆ)] Ua;

in
fun €give_new_bits› (ty:TYPE) (tm:TERM) = (
let	val names = (mapfilter xnames (term_vars tm));
	val x = mk_var(string_variant names "x", ty);
	val explode_x_thm = explode_tm x;
	val exploded = (snd(dest_eq(concl explode_x_thm)));
	val explode_bits_x = exploded_bits exploded;
	val xi_names = give_n_names (length explode_bits_x) names;
	val xi = map (fn (nm,tm) => mk_var(nm,type_of tm))
		 (combine xi_names explode_bits_x);
	val construct = subst (combine xi explode_bits_x) exploded;
in
	(explode_x_thm, construct, xi, explode_bits_x, x)
end);
end;
=TEX
val tm = Ò{1,2,3} = {3,2,1}Æ;
=SML
local
	val sets_ext_thm = pc_rule1 "'sets_ext" rewrite_conv[] ¨p:'a SET = qÆ;
	val sym_sets_ext_thm = all_µ_intro(eq_sym_rule sets_ext_thm);
	fun lmatch_order (to_order : TERM list) (orig_order : TERM list)
		(new_order : TERM list) (trm : TERM) = (
	let	fun aux (to_x :: to_rest : TERM list) 
			(o_x :: o_rest : TERM list)
			(tm : TERM) 
			(x : TERM) = (
			if (x =$ o_x)
			then to_x
			else aux to_rest o_rest tm x
		) | aux _ _ tm _ = fail "z_sets_ext_conv" 42010 [fn () => string_of_term tm];
	in
		map (aux to_order orig_order trm) new_order
	end);
=TEX
=SML
in
val €z_sets_ext_conv› : CONV = (fn tm =>
let	val (v,w) = dest_z_eq tm
		handle complaint =>
		divert complaint "dest_z_eq" "z_sets_ext_conv"
			42010 [fn () => string_of_term tm];
	val vty = type_of v;
	val elem_ty = case dest_ctype vty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "z_sets_ext_conv" 42010 [tm];
	val (explode_x_thm, construct, xs, explode_bits_x, x) =
		give_new_bits elem_ty tm;
	val s1 = asm_rule tm;
	val s2 = app_fun_rule
		(mk_app( (mk_const("ç",
			mk_≠_type(elem_ty,
			mk_≠_type(vty,BOOL)))),
			construct)) 
		s1;
	val s3 = z_µ_intro xs s2;
	val s4 = asm_rule (concl s3);
	val s6 = conv_rule z_µ_elim_conv1 s4;
		(* note that the above may put simple µ list in different order *)
	val ordered_explode_bits_x = lmatch_order explode_bits_x xs 
		(fst(strip_µ (concl s6))) tm;
	val s7 = list_µ_elim ordered_explode_bits_x s6;
	val s8 = conv_rule(RANDS_C (LEFT_C (fn _ => eq_sym_rule explode_x_thm))) s7;
	val s9 = simple_µ_intro x s8;
	val s10 = list_µ_elim[v,w] sym_sets_ext_thm;
	val s11 = §_mp_rule s10 s9;
	val s12 = §_intro (all_¥_intro s3) (all_¥_intro s11);	
	val res = eq_trans_rule (refl_conv tm) s12;
=TEX
=SML
in
	check_is_z_conv_result "z_sets_ext_conv" res
end);
end; 
=IGN
z_sets_ext_conv Ò{1,2,3} = {3,2,1}Æ;
z_sets_ext_conv Ò{(1,2),(2,3)} = {(2,3),(1,2)}Æ;
z_sets_ext_conv Ò{(1,p,2,x2,x),(2,q,3,x2,x)} = {(2,q,3,x2,x),(1,p,2,x2,x)}Æ;
=TEX
=SML
local
	val cnv1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z_ç__thm1);
	fun cnv2 nm = cnv1 THEN_C 
			z_µ_elim_conv2 THEN_C
			RAND_C(simple_¡_conv nm) THEN_C
			z_µ_intro_conv1;
	val thm1 = taut_rule ¨µ x y ∑ x ¥ ((y ± T) ¥ x)Æ;
	val thm2 = prove_rule[] ¨µ x y ∑ x ¥ ((y ç ÒUÆ ± T) ¥ x)Æ;
=TEX
=SML
in
val €z_ç__conv› : CONV = (fn tm =>
let	val (v,pw) = dest_z_ç tm
		handle complaint =>
		divert complaint "dest_z_ç" "z_ç__conv"
			42016 [fn () => string_of_term tm];
	val w = dest_z_ pw
		handle complaint =>
		divert complaint "dest_z_" "z_ç__conv"
			42016 [fn () => string_of_term tm];
	val wty = type_of w;
	val elem_ty = case dest_ctype wty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "z_ç__conv" 42010 [tm];
	val s1 = cnv1 tm;
	val tm' = snd(dest_eq(concl s1));
	val (explode_x_thm, construct, xs, explode_bits_x, x) =
		give_new_bits elem_ty tm';
	val s2 = asm_rule tm';
	val s3 = simple_µ_elim construct(
			conv_rule z_µ_elim_conv1 s2);
	val s4 = z_µ_intro xs (¥_intro mk_t s3);
	val s5 = asm_rule (concl s4);
	val s6 = conv_rule z_µ_elim_conv1 s5;
	val s7 = list_µ_elim explode_bits_x s6;
	val s8 = conv_rule(RANDS_C (LEFT_C (fn _ => eq_sym_rule explode_x_thm))) s7;
	val s9 = z_µ_intro [x] (¥_intro mk_t s8);
	val s10 = §_intro (all_¥_intro s4) (all_¥_intro s9);
	val s11 = eq_trans_rule s1 s10;
in
	check_is_z_conv_result "z_ç__conv" s11
end);
end; 
=IGN
z_ç__conv Òp ç  qÆ;
z_ç__conv Òp ç  (x ∏ y)Æ;
z_ç__conv Òp ç  ( u)Æ;
z_ç__conv Òp ç  [a : (X ∏ Y);b:X]Æ;

=TEX
=SML
local
	val thm1 = (set_goal([],¨µ x y∑ Òx ç  y § x Ä yÆÆ);
		a(REPEAT µ_tac THEN 
			conv_tac(ONCE_MAP_C z_ç__conv) THEN
			rewrite_tac[get_spec ¨$"z'_ Ä _"Æ,
		get_spec ¨$"Z'T[1]1"Æ, get_spec ¨$"Z'T[2]1"Æ]);
		a(PC_T1 "hol1" rewrite_tac[]);
		a(conv_tac(ONCE_MAP_C z_selât_lang_conv));
		a(rewrite_tac[]);
		a(prove_tac[]);
		pop_thm());
	val cnv1 = simple_eq_match_conv1 thm1;
in
val €z_setd_ç__conv› : CONV = (fn tm =>
let	val s1 = (cnv1 THEN_C z_setd_Ä_conv) tm
		handle (Fail _) =>
		term_fail "z_setd_ç__conv" 42019 [tm];
in
	check_is_z_conv_result "z_setd_ç__conv" s1
end);
end;
=TEX
\section{BINDINGS}
The following is necessary because we may have, e.g., a variable
of a given binding type:
=SML
fun €const_of_binding_type› (ty : TYPE) : TERM = ( 
let	val (tyname,tys) = (dest_ctype ty);
	val (tcname,tysname,_) = dest_z_name tyname;
	val dummy = if length tysname <> 1 orelse tcname <> "Z'S"
		then fail "const_of_binding_type" 0 []
		else ();
	val cons_of_ty = ZTypesAndTermsSupport.bind_cterm 
		(combine (hd tysname) tys);
in
	cons_of_ty
end);
=SML
val €z_binding_eq_conv› : CONV = (fn tm => (
let	val (b1,b2) = dest_z_eq tm;
	val aconst = const_of_binding_type (type_of b1);
	val spec = binding_gen_semantic_const aconst
		handle (Fail _) => 
		( diag_string "binding_gen_semantic_const fail - z_binding_eq_conv";
		get_spec aconst);
	val (bcons,bproj) = get_binding_info (type_of b1);
	val ty_insts = type_match (type_of b1) (type_of(fst(dest_µ(concl spec))));
	val bproj' = map (inst[] ty_insts) bproj;
	val s1 = asm_rule tm;
	val s1s = map (fn x => app_fun_rule  x s1) bproj';
	val s2 = list_±_intro s1s;
	val s3s = strip_±_rule(asm_rule(list_mk_± (map concl s1s)));
	val s4 = fold (fn (x,y) =>  mk_app_rule y x) (rev s3s)
		(refl_conv (inst [] ty_insts bcons));
	val s5 = all_µ_intro(hd(rev(strip_±_rule(all_µ_elim spec))));
	val s6 = conv_rule(LEFT_C (simple_eq_match_conv1 s5)
		THEN_C RIGHT_C (simple_eq_match_conv1 s5)) s4;
	val s7 = §_intro (all_¥_intro s2) (all_¥_intro s6);
in
	check_is_z_conv_result "z_binding_eq_conv" 
	(eq_trans_rule (refl_conv tm) s7)
end)
handle complaint =>
list_divert complaint "z_binding_eq_conv"
	[("const_of_binding_type", 42013, [fn () => string_of_term tm]),
	("dest_z_eq", 42013, [fn () => string_of_term tm]),
	("get_spec", 42013, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=IGN
z_binding_eq_conv Ò  S = (x ¶ y)Æ;
=TEX
=SML
val €z_binding_eq_conv1› : CONV = (fn tm => (
let	val (b1,b2) = dest_z_eq tm;
	val aconst = const_of_binding_type (type_of b1);
	val spec = binding_gen_semantic_const aconst
		handle (Fail _) => 
		(diag_string "binding_gen_semantic_const fail - z_binding_eq_conv1";
		get_spec aconst);
	val (bcons,bproj) = get_binding_info (type_of b1);
	val ty_insts = type_match (type_of b1) (type_of(fst(dest_µ(concl spec))));
	val bproj' = map (inst[] ty_insts) bproj;
	val s1 = asm_rule tm;
	val s1s = map (fn x => app_fun_rule  x s1) bproj';
	val s2 = list_±_intro s1s;
	val s3s = strip_±_rule(asm_rule(list_mk_± (map concl s1s)));
	val s4 = fold (fn (x,y) =>  mk_app_rule y x) (rev s3s)
		(refl_conv (inst [] ty_insts bcons));
	val s5 = all_µ_intro(hd(rev(strip_±_rule(all_µ_elim spec))));
	val s5a = simple_eq_match_conv1 s5;
	val s6 = conv_rule(LEFT_C s5a THEN_C RIGHT_C s5a) s4;
	val s7 = §_intro (all_¥_intro s2) (all_¥_intro s6);
in
(check_is_z_conv_result "z_binding_eq_conv1" 
(case (is_z_binding b1, is_z_binding b2) of
(false, false) => (eq_trans_rule (refl_conv tm) s7)
| (true, false) => (
let	val b1args = map snd(dest_z_binding b1);
	val proj_thms = rev(tl(rev
		(strip_±_rule(list_µ_elim (b1 :: b1args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn thm => LEFT_C (fn _ => thm)) proj_thms))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end)
| (false, true) => (
let	val b2args = map snd(dest_z_binding b2);
	val proj_thms = rev(tl(rev
		(strip_±_rule(list_µ_elim (b2 :: b2args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn thm => RIGHT_C (fn _ => thm)) proj_thms))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end)
| (true, true) => (
let	val b1args = map snd(dest_z_binding b1);
	val proj_thms1 = rev(tl(rev
		(strip_±_rule(list_µ_elim (b1 :: b1args)(inst_type_rule ty_insts spec)))));
	val b2args = map snd(dest_z_binding b2);
	val proj_thms2 = rev(tl(rev
		(strip_±_rule(list_µ_elim (b2 :: b2args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn (thm1,thm2) => 
		LEFT_C (fn _ => thm1) THEN_C
		RIGHT_C (fn _ => thm2)) 
		(combine proj_thms1 proj_thms2)))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end)
))
end
)
handle complaint =>
list_divert complaint "z_binding_eq_conv1"
	[("dest_z_eq", 42013, [fn () => string_of_term tm]),
	("get_spec", 42013, [fn () => string_of_term tm]),
	("const_of_binding_type", 42013, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=IGN
z_binding_eq_conv1 Ò(x ¶ 1, y ¶ 2, z ¶ 3) = (y ¶ 2, x ¶ 1, z ¶ 3)Æ;
=TEX
=SML
val €z_binding_eq_conv2› : CONV = (fn tm => (
let	val (b1,b2) = dest_z_eq tm;
	val dummy = if is_z_binding b1 andalso is_z_binding b2
		then ()
		else term_fail "z_binding_eq_conv2" 42021 [tm];
	val aconst = const_of_binding_type (type_of b1);
	val spec = binding_gen_semantic_const aconst
		handle (Fail _) => 
		( diag_string "binding_gen_semantic_const fail - z_binding_eq_conv2";
		get_spec aconst);
	val (bcons,bproj) = get_binding_info (type_of b1);
	val ty_insts = type_match (type_of b1) (type_of(fst(dest_µ(concl spec))));
	val bproj' = map (inst[] ty_insts) bproj;
	val s1 = asm_rule tm;
	val s1s = map (fn x => app_fun_rule x s1) bproj';
	val s2 = list_±_intro s1s;
	val s3s = strip_±_rule(asm_rule(list_mk_± (map concl s1s)));
	val s4 = fold (fn (x,y) =>  mk_app_rule y x) (rev s3s)
		(refl_conv (inst [] ty_insts bcons));
	val s5 = all_µ_intro(hd(rev(strip_±_rule(all_µ_elim spec))));
	val s6 = conv_rule(LEFT_C (simple_eq_match_conv1 s5)
		THEN_C RIGHT_C (simple_eq_match_conv1 s5)) s4;
	val s7 = §_intro (all_¥_intro s2) (all_¥_intro s6);
	val b1args = map snd(dest_z_binding b1);
	val proj_thms1 = rev(tl(rev
		(strip_±_rule(list_µ_elim (b1 :: b1args)(inst_type_rule ty_insts spec)))));
	val b2args = map snd(dest_z_binding b2);
	val proj_thms2 = rev(tl(rev
		(strip_±_rule(list_µ_elim (b2 :: b2args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn (thm1,thm2) => 
		LEFT_C (fn _ => thm1) THEN_C
		RIGHT_C (fn _ => thm2)) 
		(combine proj_thms1 proj_thms2)))) s7;
in
	check_is_z_conv_result "z_binding_eq_conv2" 
	(eq_trans_rule (refl_conv tm) s8)
end)
handle complaint =>
list_divert complaint "z_binding_eq_conv2"
	[("const_of_binding_type", 42021, [fn () => string_of_term tm]),
	("dest_z_eq", 42021, [fn () => string_of_term tm]),
	("get_spec", 42021, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=IGN
z_binding_eq_conv2 Ò(x ¶ z,x1 ¶ z1) = (x ¶ y,x1 ¶ y1)Æ;
=TEX
=SML
val  €z_selâs_conv› : CONV = (fn tm => (
let	val (b,s) = dest_z_selâs tm;
	val bits = dest_z_binding b;
	val spec = binding_gen_semantic_const b
		handle (Fail _) =>
		(diag_string "binding_gen_semantic_const fail - z_selâs_conv";
		get_spec b);
	val cmps = tl(fst(strip_simple_µ(concl spec)));
	val thm1 = all_simple_µ_elim spec;
	fun get_conjunct th = (
		let	val (_, ths) = 
				dest_z_selâs(fst(dest_eq(fst(dest_±(concl th)))));
		in	if ths = s
			then ±_left_elim th
			else get_conjunct (±_right_elim th)
		end
	);
	val thm2 = get_conjunct thm1
		handle Fail _ => term_fail "z_selâs_conv" 43000 [];
	val cmpvals = map snd bits;
	val cmpvaltys = map type_of cmpvals
	val tym = combine cmpvaltys (map type_of cmps);
	val instcmps = map mk_var (combine (map (fst o dest_var) cmps) cmpvaltys);
	val tmm = combine cmpvals instcmps;
in
	check_is_z_conv_result "z_selâs_conv"
	(eq_trans_rule (refl_conv tm)
	(inst_term_rule tmm (inst_type_rule tym thm2)))
end
)
handle complaint =>
list_divert complaint "z_selâs_conv"
	[("dest_z_selâs", 42014, [fn () => string_of_term tm]),
	("dest_z_binding", 42014, [fn () => string_of_term tm]),
	("get_spec", 42014, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])]
);
=IGN
z_selâs_conv Ò(x ¶ 1, y ¶ 2, z ¶ 3).yÆ;
=TEX
=SML
val €z_bindingd_elim_conv› : CONV = (fn tm =>
let	val xi = dest_z_binding tm
		handle (Fail _) =>
		term_fail "z_bindingd_elim_conv" 42018 [tm];
	val bind= fst(dest_z_selâs(snd(hd xi)))
		handle (Fail _) =>
		term_fail "z_bindingd_elim_conv" 42018 [tm];
	val rspec = binding_gen_semantic_const tm;
	val spec = all_µ_elim (µ_elim bind rspec)
		handle (Fail _) =>
		term_fail "z_bindingd_elim_conv" 42018 [tm];
	val cthm = hd(rev(strip_±_rule spec));
in
		check_is_z_conv_result "z_bindingd_elim_conv"
		(eq_trans_rule (refl_conv tm) cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_bindingd_elim_conv" 42018
			[fn () => string_of_term tm])
end);
=IGN
z_bindingd_elim_conv Ò(x ¶ ¨b:(˙, ˙) $"Z'S[x,y]"Æ.x, y ¶ b.y)Æ;
z_bindingd_elim_conv Ò(x ¶ ¨b:(˙, ˙) $"Z'S[x,y]"Æ.x, y ¶ c)Æ; (* fails *)
=TEX

\section{SET ABSTRACTIONS REVISITED}
=SML
local
	val cnv1 = ALL_SIMPLE_∂_C (±_C (TRY_C z_ç_u_conv));
	val cnv2 = pure_rewrite_conv[
		pc_rule1 "hol1" prove_rule[]¨µ t ∑ (∂ x ∑ t) § tÆ,
		taut_rule ¨µ x ∑ x ± T § xÆ,
		taut_rule ¨µ x ∑ T ± x § xÆ];
in
val €z_ç_seta_conv1› : CONV = (fn tm =>
let	val dummy = set_flag("check_is_z",false);
	val s1 = z_ç_seta_conv tm
		handle complaint =>
		pass_on complaint "z_ç_seta_conv" "z_ç_seta_conv1";
	val rhs = snd(dest_eq(concl s1));
	val (d,p,v_eq_t) = dest_z_∂ rhs;
	val (v,t) = dest_eq v_eq_t;
	val res = (
	if not (is_z_tuple v orelse is_var v) 
	then s1
	else ((
let	val s2 = (z_∂_elim_conv THEN_TRY_C 
		ALL_SIMPLE_∂_C (RIGHT_C (RIGHT_C 
		((RIGHT_C (COND_C is_z_tuple id_conv z_selât_intro_conv))
		THEN_C z_tuple_lang_eq_conv)))) rhs;
	val s3 = conv_rule (RIGHT_C(TRY_C cnv1 THEN_TRY_C cnv2
			THEN_C REPEAT_C 
			(LAST_SIMPLE_∂_C simple_∂_equation_conv))) s2;
	val s4 = eq_trans_rule s1 s3;
in
	if is_∂(snd(dest_eq(concl s4)))
	then s1
	else s4
end
)
handle (Fail _) => s1));
	val dummy = set_flag("check_is_z",dummy);
in
	check_is_z_conv_result "z_ç_seta_conv1" res
end);
end;
=IGN
let	val s = Ò{x,y : X; p:Y; [z :U]}Æ
in
z_ç_seta_conv1 Òt ç ësÆÆ
end;
z_ç_seta_conv1 Òp ç {x:X∑(x,x)}Æ;
z_ç_seta_conv1 Òp ç {x:X}Æ;
z_ç_seta_conv1 Ò(1,2) ç {x:X;y:Y∑(x,y)}Æ;
z_ç_seta_conv1 Òt ç {x:X;y:Y∑(x,y)}Æ;
z_ç_seta_conv1 Òt ç {x,y:X;z:Y∑(z,x,y)}Æ;
=TEX
\section{MISCELLANEOUS}
=SML
local
	val taut_thm = all_µ_intro
		(taut_rule¨((a ¥ b) ± ((b ± T) ¥ ( a § c ))) = (a § (b ± c))Æ);
	val c1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z_ç__thm1);
	val c2 = simple_eq_match_conv1 taut_thm;
in
fun  €z_defn_simp_rule› (ithm : THM) : THM = ((
let	val qthm = conv_rule (TRY_C z_para_pred_conv) ithm;
	val (vs,_) = strip_simple_µ(concl qthm);
	val thm = all_µ_elim qthm;
	val tm = concl thm;
	val (tm1,tm2) = dest_± tm;
	val thm1 = conv_rule
		(c1 THEN_C z_µ_elim_conv1)
		(±_left_elim thm);
	val thm2 = ±_right_elim thm;
	val (d,p,v) = dest_z_µ(concl thm2);
	val dvar = hd(fst(dest_z_dec(hd(dest_z_decl d))));
	val thm'' = ±_intro(µ_elim dvar thm1)
			(z_µ_elim dvar thm2);
in 
	check_is_z_thm "z_defn_simp_rule"
	(list_simple_µ_intro vs
	(z_µ_intro [dvar] (conv_rule c2 thm'')))
end)
handle complaint =>
list_divert complaint "z_defn_simp_rule"
	[("dest_±", 42011, [fn () => string_of_thm ithm]),
	("simple_eq_match_conv1", 42011, [fn () => string_of_thm ithm]),
	("dest_z_decl", 42011, [fn () => string_of_thm ithm]),
	("dest_z_dec", 42011, [fn () => string_of_thm ithm]),
	("z_µ_elim", 42011, [fn () => string_of_thm ithm])]);
end;
=TEX
=IGN
z_defn_simp_rule 
	(asm_rule ¨Z'AbbDef Òp ç (X ∏ Y) ± (µ q : X ∏ Y ∑ q ç p § first q = q.1)ÆÆ);
z_defn_simp_rule
	(conv_rule 
	(RAND_C(LEFT_C (Z_DECL_INTRO_C z_pred_dec_conv)))
(asm_rule ¨Z'AbbDef Òp ç (X ∏ Y) ± (µ q : X ∏ Y ∑ q ç p 
	§ first q = q.1)ÆÆ));
=TEX
\subsection{Sequence Displays}
=SML
local
	val cnv1 = simple_eq_match_conv1 z'ß¢_def;
	val cnv2 = pure_once_rewrite_conv[ z'num_list_def];
	fun cnv3 tm = (cnv2 THEN_TRY_C 
		(LEFT_C((RAND_C(RIGHT_C plus_conv))
			THEN_C cnv3)
		THEN_C
		(RIGHT_C(LEFT_C(LEFT_C(RAND_C plus_conv)))))) tm;
	val cnv4 = simple_eq_match_conv1
		(eq_sym_rule(±_left_elim z'setd_def));
	val cnv5 = simple_eq_match_conv1
		(conv_rule(ONCE_MAP_C eq_sym_conv)
		(±_right_elim z'setd_def));
	fun cnv6 tm = ((LEFT_C (cnv6 ORELSE_C cnv4) THEN_C cnv5)
		ORELSE_C cnv4) tm;
in
val €z_ß¢_conv› :CONV = (fn tm =>
let	val s1 = (cnv1 THEN_C cnv3 THEN_C cnv6) tm;
in
	check_is_z_conv_result "z_ß¢_conv" s1
end);
end;
=TEX
\subsection{Conversionals}
=SML
local
	val c1 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ (x = x) § TÆ);
	val c2 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ T ± x § xÆ);
	val c3 = simple_eq_match_conv1 (prove_rule []¨µ x ∑ x ± T § xÆ);
	val ¥_thm = tac_proof(([],¨µ x ∑ x ¥ xÆ),REPEAT strip_tac);
	fun local_rule thm gl = (
	let 	val (a,b) = dest_¥ gl;
		val (x,bdy) = dest_eq(concl thm);
		val ithm = simple_µ_elim b ¥_thm;
	in
		subst_rule[(eq_sym_rule thm,x)] gl ithm
	end);
	val rw_tac2_thm = tac_proof(([],
		¨µ t∑ ≥ (F ± t) ± ≥ (t ± F) ±
		((∂ x ∑ F) § F) ± ≥(µ x ∑ F) ±
		(µ x∑ x = x § T) ± (F ¥ t) ±
		(≥ T § F) ± (≥ F § T)Æ),
		PC_T1 "hol1" rewrite_tac[]);
	val rw_tac2 = (prim_rewrite_tac	
		(make_net(flat(map (cthm_eqn_cxt initial_rw_canon)
			[rw_tac2_thm])))
		initial_rw_canon 
		TOP_MAP_C
		[]);
in
fun €local_prove_∂_conv› (wit : TERM) : CONV = (fn tm =>
let	val (x,bdy) = dest_simple_∂ tm;
	val res = var_subst [(wit,x)] bdy;
	val s1 = ALL_SIMPLE_∂_C (RIGHT_C(RIGHT_C 
		(c1 ORELSE_C (LEFT_C c1 THEN_C c2)))) res;
	val new_term = snd(dest_eq(concl s1));
	val s2 = tac_proof(([],mk_eq(tm, new_term)),
		§_T2
		(fn thm =>
		t_tac ORELSE
		conv_tac(fn ag => eq_sym_rule s1)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @
				frees (concl s1)) x;
			in
			CASES_T2 (mk_eq(x',wit))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac wit THEN accept_tac 
			(§_mp_rule (eq_sym_rule s1) thm)
		));
in
	s2
end);
end;
=TEX
=SML
fun €ç_C› (cnv:CONV) : CONV = (fn tm =>
	if is_bin_op "ç" tm
	then RAND_C cnv tm
	else term_fail "ç_C" 42028 [tm]
);
=TEX 
=SML
local
	val Ua = ÒUÆ;
	fun uf ty = inst [] [(ty, î'aÆ)] Ua;
	fun mk_u_dec tm = mk_z_dec([tm], mk_u(mk_z_power_type(type_of tm)));
	fun mk_u_decl tml = mk_z_decl(map mk_u_dec tml);
	val thm1 = prove_rule [] ¨µ x ∑ (x = x) § TÆ;
	fun lmatch_order (to_order : TERM list) (orig_order : TERM list)
		(new_order : TERM list) (trm : TERM) = (
	let	fun aux (to_x :: to_rest : TERM list) 
			(o_x :: o_rest : TERM list)
			(x : TERM) = (
			if (x =$ o_x)
			then to_x
			else aux to_rest o_rest x
		) | aux _ _ _ = fail "Z_ç_ELIM_C" 42027 [fn () => string_of_term trm];
	in
		map (aux to_order orig_order) new_order
	end);
=TEX
=SML
in
fun €Z_ç_ELIM_C›  (cnv:CONV) : CONV = (fn tm =>
let	val vty = type_of tm;
	val elem_ty = case dest_ctype vty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "Z_ç_ELIM_C" 42027 [tm];
	val (explode_x_thm, construct, xi, explode_bits_x, x) = give_new_bits elem_ty tm;
	val tm' = mk_z_ç(construct,tm);
	val s1 = cnv tm';
	val tm_as_set = mk_z_seta(mk_u_decl xi, tm', construct);
	val s2 = tac_proof(([],mk_eq(tm,tm_as_set)),
		conv_tac z_sets_ext_conv THEN
		(fn (asm,conc) => (
		let val xi2 = map (hd o fst o dest_z_dec)
			(dest_z_decl(#1(dest_z_µ conc)));
		in
		z_µ_tac THEN
		¥_T (fn _ => id_tac) THEN
		conv_tac(RIGHT_C (z_ç_seta_conv THEN_C z_∂_elim_conv1)) THEN 
		§_T2 
		(fn thm =>
		(fn (asm1, conc1) =>
		let val xi3 = lmatch_order xi2 xi (fst(strip_∂ (conc1))) tm;
		in
		((MAP_EVERY simple_∂_tac xi3 THEN
			±_tac THEN_LIST [
				accept_tac thm,
				pure_rewrite_tac [thm1]])  
		 (asm1, conc1)
		)
		end))
		(fn thm => 
		(REPEAT_TTCL SIMPLE_∂_THEN) ante_tac thm
		THEN ¥_T(fn thm' =>
		let val thma = ±_left_elim thm';
			val thmb = ±_right_elim thm';
		in
			conv_tac(LEFT_C(fn _ => eq_sym_rule thmb))
			THEN accept_tac thma
		end
		))
		end)(asm,conc)));
	val s3 = conv_rule(RIGHT_C(RAND_C(ALL_SIMPLE_Ã_C(LEFT_C 
		(simple_eq_match_conv1 s1))))) s2;
in
	eq_trans_rule (refl_conv tm) s3
end);
end;
=TEX

Now we can do:
=SML
val €z_ç_Ã_conv› :CONV = ç_C z_Ã_conv;
val €z_ç_ß¢_conv› :CONV = ç_C z_ß¢_conv;
=TEX
\subsection{Strings}
=SML
local
	val cnv1 = RATOR_C(simple_eq_match_conv1 z'string_def);
	fun cnv2 tm = (string_conv THEN_TRY_C(RIGHT_C cnv2)) tm;
in
val €z_string_conv› : CONV = (fn tm =>
	(cnv1 THEN_C (RAND_C cnv2)) tm
	handle (Fail _) =>
	term_fail "z_string_conv" 42015 [tm]
);
end;
val €z_ç_string_conv› :CONV = ç_C z_string_conv;

=TEX

\section{PROOF CONTEXTS}
\subsection{Utilities}
=SML
fun €limited_z_¬_conv› tm = (
let	val res = z_¬_conv tm
in
	if is_nil(asms res)
	then res
	else term_fail "limited_z_¬_conv" 0 [tm]
end);
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	
\subsection{Treatment of Membership of Sets in Z Language}
In designing discrimination net indices we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_set_lang" handle Fail _ => ();
val _ = new_pc "'z_ç_set_lang";
val _ = set_rw_eqn_cxt [(Òx ç ¨y (Ã w:'c ∑ z):'b SETÆÆ,z_ç_seta_conv1),
	(Òx ç ¨Z'Seta[0] y:'a SETÆÆ,z_ç_seta_conv1),
	(Òx ç ¨y (Cons (p:'b) q):'b SETÆÆ,z_ç_setd_conv),
	(Òx ç ¨y Nil:'b SETÆÆ,z_ç_setd_conv),
	(Òx ç ¨y (Ã p ∑ q)ÆÆ,z_ç_Ã_conv),
	(Òx ç ¨y zÆÆ,z_ç_ß¢_conv),
	(Ò(Ã x : U | true ∑ y) zÆ,limited_z_¬_conv)]
		"'z_ç_set_lang";
val _ = add_rw_thms [] "'z_ç_set_lang";

val pos = (thms_to_eqn_cxt [])
	@ [(Òx ç ¨y (Ã w ∑ z):'b SETÆÆ,z_ç_seta_conv1),
	(Òx ç ¨y (Ã p ∑ q)ÆÆ,z_ç_Ã_conv),
	(Òx ç ¨Z'Seta[0] y:'a SETÆÆ,z_ç_seta_conv1),
	(Òx ç ¨y (Cons (p:'b) q):'b SETÆÆ,z_ç_setd_conv),
	(Òx ç ¨y zÆÆ,z_ç_ß¢_conv),
	(Òx ç (Ã x : U ∑ y) zÆ, ç_C limited_z_¬_conv),
	(Òx ç ¨y Nil:'b SETÆÆ,z_ç_setd_conv)];
val neg = map (mk_≥ ** RAND_C) pos;
val neither = [(Ò(Ã x : U ∑ y) zÆ, limited_z_¬_conv)];
val _ = set_st_eqn_cxt (pos @ neg @ neither) "'z_ç_set_lang";
val _ = set_sc_eqn_cxt (pos @ neg @ neither) "'z_ç_set_lang";
val _ = set_rw_canons [] "'z_ç_set_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_set_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_set_lang";
val _ = set_cs_∂_convs [] "'z_ç_set_lang";
val _ = set_∂_vs_thms [] "'z_ç_set_lang";
val _ = commit_pc "'z_ç_set_lang";
=TEX
\subsection{Extensionality Treatment of Sets}
=SML
val _ = delete_pc "'z_sets_ext_lang" handle Fail _ => ();
val _ = new_pc "'z_sets_ext_lang";
val _ = set_rw_eqn_cxt [
	(Ò¨Z'Setd xÆ ç  yÆ,z_setd_ç__conv),
	(Òx ç  yÆ,z_ç__conv),
	(Òx = yÆ,z_sets_ext_conv)]
	"'z_sets_ext_lang";
val _ = add_rw_thms 
	[] "'z_sets_ext_lang";

val pos = [
	(Òx ç  yÆ,z_ç__conv),
	(Ò¨Z'Setd xÆ ç  yÆ,z_setd_ç__conv),
	(Òx = yÆ,z_sets_ext_conv)]
	@ thms_to_eqn_cxt [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_ext_lang";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_ext_lang";
val _ = set_rw_canons [] "'z_sets_ext_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_ext_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_ext_lang";
val _ = set_cs_∂_convs [] "'z_sets_ext_lang";
val _ = set_∂_vs_thms [] "'z_sets_ext_lang";
val _ = commit_pc "'z_sets_ext_lang";
=TEX
=SML
val _ = delete_pc "'build_z_sets";
=TEX
\subsection{Treatment of Tuples and Cartesian Products}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_tuples_lang" handle Fail _ => ();
val _ = new_pc "'z_tuples_lang";
val _ = set_rw_eqn_cxt [(Òx ç ¨y (z:'c):'b SETÆÆ,z_ç_∏_conv),
	(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_lang_eq_conv),
	(¨f(a1 a2 a3)Æ,z_selât_lang_conv)
	]"'z_tuples_lang";

val pos = [(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_lang_eq_conv),
	  (Òx ç ¨y (z:'c):'b SETÆÆ,z_ç_∏_conv),
	  (¨f(a1 a2 a3):BOOLÆ,z_selât_lang_conv),
	  (Òx ç ¨f(a1 a2 a3)ÆÆ,ç_C z_selât_lang_conv)
	];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_tuples_lang";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_tuples_lang";
val _ = set_rw_canons [] "'z_tuples_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_tuples_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_tuples_lang";
val _ = set_cs_∂_convs [] "'z_tuples_lang";
val _ = set_∂_vs_thms [] "'z_tuples_lang";
val _ = commit_pc "'z_tuples_lang";
=TEX
\subsection{Treatment of Bindings}
=SML
val _ = delete_pc "'z_bindings" handle Fail _ => ();
val _ = new_pc "'z_bindings";
val _ = set_rw_eqn_cxt [(¨f a = g bÆ,z_binding_eq_conv2),
	(¨f(g x)Æ,z_selâs_conv)
	]"'z_bindings";

val pos = [(¨f a = g bÆ,z_binding_eq_conv2),
	(¨f(g x):BOOLÆ,z_selâs_conv),
	(Òy ç ¨f(g x)ÆÆ,ç_C z_selâs_conv)];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_bindings";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_bindings";
val _ = set_rw_canons [] "'z_bindings";
val _ = set_pr_tac z_basic_prove_tac "'z_bindings";
val _ = set_pr_conv z_basic_prove_conv "'z_bindings";
val _ = set_cs_∂_convs [] "'z_bindings";
val _ = set_∂_vs_thms [] "'z_bindings";
val _ = commit_pc "'z_bindings";
=TEX
\section{FURTHER WORK}
=SML
val €z_ç_app_thm› = (
push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_sets_ext_lang"];
set_goal([],Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ a ç f_x ± (x, f_x) ç f ± 
	(µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ a ç f xÆ);
a(REPEAT strip_tac);
a(lemma_tac Òf_x = ¨fÆ ¨xÆÆ);
(* *** Goal "1" *** *)
a(z_app_eq_tac);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_prove_tac[]);
pop_pc();
save_thm("z_ç_app_thm",(pop_thm())));
=TEX
=SML
val €z_app_ç_thm› = (
push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_sets_ext_lang"];
set_goal([],Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ f_x ç a ± (x, f_x) ç f ± 
	(µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ f x ç aÆ);
a(REPEAT strip_tac);
a(lemma_tac Òf_x = ¨fÆ ¨xÆÆ);
(* *** Goal "1" *** *)
a(z_app_eq_tac);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
pop_pc();
save_thm("z_app_ç_thm",(pop_thm())));
=TEX
\section{EPILOGUE}
=SML
end; (* of structure ZExpressions *)
open ZExpressions;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
