=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP042}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1,1.2] 
First versions.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) set theory, tuples and cartesian products.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD042}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the set theory, tuples and cartesian products of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD042}.
\subsubsection{Deficiencies}
$z\_∏\_conv$ is comparatively slow compared to like functions.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure €ZSetTheory› : ZSetTheory = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory "z_predicate_calculus";
val _ = delete_theory "z_set_theory" handle Fail _ => ();
val _ = new_theory "z_set_theory";
val _ = set_pc "z_predicates";
val _ = set_flag("z_type_check_only",false);
=TEX

\section{THE CODE}
\subsection{Utilities}
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
val €Ub› = inst [] [(î'bÆ,î'aÆ)] Ua;
val €Uc› = inst [] [(î'cÆ,î'aÆ)] Ua;
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_¡_conv1 nm :CONV= (fn tm =>
		(simple_¡_conv nm
		ORELSE_C
		simple_¡_conv1 (nm ^ get_variant_suffix())) tm);
in
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_¡_conv1 nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_¡_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
end;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX

\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
\section{THE IMPLEMENTATION}
=SML
val €z_sets_ext_thm› : THM = all_µ_intro(
push_goal([],Ò(x = y) = (µz: U ∑ ((z ç x) § (z ç y)))Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(PC_T1 "hol1" asm_rewrite_tac[]);
pop_thm());
=TEX
=SML
val €z__thm› : THM = all_µ_intro(
push_goal([],Ò(t ç  u) = (µz: U ∑ ((z ç t) ¥ (z ç u)))Æ);
a(rewrite_tac[get_spec Ò xÆ, get_spec ¨ xÆ]);
a(PC_T1 "hol1" rewrite_tac[]);
a(REPEAT strip_tac);
a(asm_fc_tac[]);
pop_thm());
=TEX
=SML
local
	val z'seta_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		(fn tm => 
		let val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dpv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dpv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dpv_proj_conv)
		] tm
		end
		));
in
val €z_ç_seta_conv› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
	val was_sig = fst(strip_Ã(snd(dest_app s)));
	val (d,p,t) = dest_z_seta s;
	val spc = get_spec s;
	val s1 = (RAND_C 
		((simple_eq_match_conv1 spc) THEN_C
		z'seta_conv1) THEN_C
		simple_ç_comp_conv) tm;
	val s2 = conv_rule (RIGHT_C 
		((seq_binder_simple_¡_conv was_sig)
		THEN_C z_∂_intro_conv)) s1;
in
	check_is_z_conv_result "z_ç_seta_conv" s2
end
handle complaint =>
list_divert complaint "z_ç_seta_conv"
	[("dest_z_ç",42001,[fn () => string_of_term tm]),
	("dest_z_seta",42001,[fn () => string_of_term tm])]);
end;
=GFT Example
z_ç_seta_conv Òp ç {x:X∑(x,x)}Æ;
z_ç_seta_conv Ò(1,2) ç {x:X;y:Y∑(x,y)}Æ;
=TEX
=SML
local
	val thm1 = (
	push_goal([],¨µ (x:'a)∑ Ò(x ç {} § false)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm2 = (
	push_goal([],¨µ (x:'a) (h:'a) ∑ Ò(x ç {h} § x = h)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm3 = (
	push_goal([],¨µ (x:'a) (h:'a) (t:'a LIST) ∑ 
	Ò(x ç  ¨Z'Setd (Cons h t)Æ) § (x = h ≤ x ç ¨Z'Setd tÆ)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	a(REPEAT strip_tac);
	pop_thm());

	val cnv1 = simple_eq_match_conv1 thm1;
	val cnv2 = simple_eq_match_conv1 thm2;
	val cnv3 = simple_eq_match_conv1 thm3;
	fun cnv4 tm = (cnv2 ORELSE_C
		(cnv3 THEN_C RIGHT_C cnv4)
		ORELSE_C (fn tm => term_fail "z_ç_setd_conv"
			42008 [tm])) tm;
	val thm5 = prove_rule[] ¨µ x y ∑ ((x = x) ≤ y) § TÆ;
	val cnv5 = simple_eq_match_conv1 thm5;
	val thm6 = taut_rule ¨µ x ∑ (x ≤ T) § TÆ;
	val cnv6 = simple_eq_match_conv1 thm6;
	val thm7 = prove_rule [] ¨µ x ∑ (x =x) § TÆ;
	val cnv7 = simple_eq_match_conv1 thm7;
	fun cnv8 tm = (
	let	val (p,q) = dest_≤ tm;
		val (x1,h) = dest_eq p;
	in
		if x1 ~=$ h
		then cnv5 tm
		else (RIGHT_C cnv8 THEN_C cnv6) tm
	end
	handle (Fail _) =>
	cnv7 tm);

in
val €z_ç_setd_conv› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
	val (_,tml) = dest_z_setd s;
in
	check_is_z_conv_result "z_ç_setd_conv" 
	(case tml of
	[] => cnv1 tm
	| [_] => cnv2 tm
	| _ => cnv4 tm)
end
handle complaint =>
list_divert complaint "z_ç_setd_conv"
	[("dest_z_ç",42002,[fn () => string_of_term tm]),
	("dest_z_setd",42002,[fn () => string_of_term tm])]);

val €z_ç_setd_conv1› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
	val (_,tml) = dest_z_setd s;
	val dummy = if x term_mem tml
		then ()
		else term_fail "z_ç_setd_conv1" 42009 [tm];
	val s1 = cnv4 tm
		handle complaint =>
		pass_on complaint "z_ç_setd_conv" "z_ç_setd_conv1";
	val s2 = conv_rule (RIGHT_C cnv8) s1;
in
	check_is_z_conv_result "z_ç_setd_conv1" 
	s2
end
handle complaint =>
list_divert complaint "z_ç_setd_conv1"
	[("dest_z_ç",42009,[fn () => string_of_term tm]),
	("dest_z_setd",42009,[fn () => string_of_term tm])]);
end;


=GFT Examples
z_ç_setd_conv Ò3 ç {2,3,4}Æ;
z_ç_setd_conv Ò3 ç {4}Æ;
z_ç_setd_conv Ò3 ç {}Æ;
z_ç_setd_conv1 Ò3 ç {2,3,4}Æ;
z_ç_setd_conv1 Ò3 ç {3}Æ;
=TEX
=SML
val _ = delete_pc "'build_z_sets" handle (Fail _) => ();
val _ = new_pc "'build_z_sets";
val _ = set_rw_eqn_cxt 
	[(Òx ç ¨y (Ã z ∑ w):'a SETÆÆ,z_ç_seta_conv),
	 (Òx ç ¨Z'Seta[0] y:'a SETÆÆ,z_ç_seta_conv),
	 (¨(Ã x ∑ y) zÆ,simple_¬_conv),
	 (Òx ç ¨Z'Setd yÆÆ,z_ç_setd_conv1)] "'build_z_sets";
val _ = add_rw_thms [µ_rewrite_thm] "'build_z_sets";
=TEX
=SML
fun €tt_to_∂_vs›  (ty : TYPE) : (string * (TERM list * THM)) = (
let	val (abs,cons) = get_tuple_info ty;
	val def_thm = get_spec (hd cons);
	val abs_nm = fst(dest_const abs);
in
	(abs_nm,(cons, def_thm))
end);
=TEX
=SML
val _ =set_∂_vs_thms [tt_to_∂_vs î'X SET $"Z'T[1]"Æ] "'build_z_sets";

val _ = set_merge_pcs ["z_predicates","'build_z_sets"];
=TEX
\subsection{Set Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua](conv_rule z_defn_conv
		(get_spec ¨$"z'_ Ω _"Æ)));
in
val €z_Ω_thm› = save_thm("z_Ω_thm",
	conv_rule z_µ_elim_conv1
	(nth 1 (strip_±_rule spec)));
val €z_é_thm› = save_thm("z_é_thm",
	conv_rule z_µ_elim_conv1
	(nth 2 (strip_±_rule spec)));
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'ö"Æ;
a(rewrite_tac[z_sets_ext_thm]);
a(∂_tac ¨Ã x:'b ∑ Ò{x:U|false}ÆÆ);
a(rewrite_tac[]);
save_consistency_thm ¨$"z'ö"Æ (pop_thm()));
=TEX
=SML
local
	val spec = rewrite_rule[z_sets_ext_thm]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ¨$"z'ö"Æ)));
	val s1 = (conv_rule z_µ_elim_conv1 spec);
in
val €z_ö_thm› = save_thm("z_ö_thm",s1);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ¨$"z'_ Ä _"Æ)));
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_Ä_thm› = save_thm("z_Ä_thm",
	all_µ_intro (±_left_elim s1));
val €z_†_thm› = save_thm("z_†_thm",
	all_µ_intro (±_right_elim s1));
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'â1 _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'â1 _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ¨$"z'â1 _"Æ)));
in
val €z_â1_thm› = save_thm("z_â1_thm",
	spec);
end;
=TEX
=SML
local
	val spec = rewrite_rule[z_sets_ext_thm]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ¨$"z'_ ¿ _"Æ)));
	val s1 = list_µ_elim[¨s:'a SETÆ,¨t:'a SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
	val s2 = conv_rule(MAP_C(z_∂_elim_conv1 THEN_C prove_∂_conv)) s1;
	val s3 = conv_rule(MAP_C(z_µ_elim_conv1)) s2;
in
val €z_¿_thm› = save_thm("z_¿_thm",
	all_µ_intro(all_µ_elim(nth 0 (strip_±_rule s3))));
val €z_°_thm› = save_thm("z_°_thm",
	all_µ_intro(all_µ_elim(nth 1 (strip_±_rule s3))));
val €z_set_dif_thm› = save_thm("z_set_dif_thm",
	all_µ_intro(all_µ_elim(nth 2 (strip_±_rule s3))));
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ¨$"z'ﬁ"Æ)));
	val s1 = list_µ_elim[¨a:'a SET SETÆ]
		(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
	val s2 = rewrite_rule[z_sets_ext_thm] s1;
	val s3 = conv_rule(MAP_C(z_∂_elim_conv1 THEN_C prove_∂_conv)) s2;
	val s4 = conv_rule(MAP_C(z_µ_elim_conv1)) s3;
in
val €z_ﬁ_thm› = save_thm("z_ﬁ_thm",
	all_µ_intro(all_µ_elim(nth 0 (strip_±_rule s4))));
val €z_•_thm› = save_thm("z_•_thm",
	all_µ_intro(all_µ_elim(nth 1 (strip_±_rule s4))));
end;
=TEX
\section{TUPLES}
The following is misplaced, but required ``now''.
=SML
local
	val spec = (rewrite_rule[]
		(get_spec Ò(x ™ y)Æ));
in
val €z_™_thm› = save_thm("z_™_thm",spec);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'_ Ì _"Æ)));
in
val €z_Ì_thm› = save_thm("z_Ì_thm",
	conv_rule z_µ_elim_conv1
	(nth 1 (strip_±_rule spec)));
end;
=TEX
=SML
val €z_Ì_conv› : CONV = simple_eq_match_conv1 z_Ì_thm;
=TEX
=SML
local
	fun aux thm [] [] = thm
	| aux thm (a::x)(b::y) = aux (mk_app_rule thm (asm_rule (mk_z_eq (a, b)))) x y
	| aux _ _ _ = error "z_tuple_eq_conv" 0 [];
	
	fun aux1 tm [] [] = tm
	| aux1 tm (a::x)(b::y) = aux1 (mk_z_±(mk_z_eq (a,b), tm)) x y
	|aux1 _ _ _ = error "z_tuple_eq_conv" 0 [];
in
val €z_tuple_eq_conv› : CONV = (fn tm =>
let	val (lhs,rhs) = dest_z_eq tm
		handle (Fail _) =>
		term_fail "z_tuple_eq_conv" 42003 [tm];
	val s0 = (if is_z_tuple lhs andalso is_z_tuple rhs
		then refl_conv tm
		else 
		((LEFT_C z_Ì_conv AND_OR_C RIGHT_C z_Ì_conv)
		tm))
		handle (Fail _) =>
		term_fail "z_tuple_eq_conv" 42003 [tm];
	val tm' = snd(dest_eq(concl s0));
	val (lhs,rhs) = dest_z_eq tm';
	val dummy = if is_z_tuple lhs andalso is_z_tuple rhs
		then ()
		else term_fail "z_tuple_eq_conv" 42003 [tm];
	val spec = get_spec lhs;
	val proj_thms = map all_µ_intro
		(rev(tl(rev(strip_±_rule(all_µ_elim spec)))));
	val (tcons,tproj) = get_tuple_info (type_of lhs);
	val lhs_bits = dest_z_tuple lhs;
	val rhs_bits = dest_z_tuple rhs;
	val tcons' = fst(strip_app lhs);
	val ty_insts = fst(term_match tcons' tcons);
	val s1 = aux (refl_conv tcons') lhs_bits rhs_bits;
	val rlhs_bits = rev lhs_bits;
	val rrhs_bits = rev rhs_bits;
	val res = aux1 (mk_z_eq(hd rlhs_bits, hd rrhs_bits))
		(tl rlhs_bits) (tl rrhs_bits);
	val s2 = strip_±_rule (asm_rule res);
	val s3 = fold (uncurry prove_asm_rule) s2 s1;
	val s4 = asm_rule tm';
	val s5 = map (fn (x,xthm) => 
		conv_rule(APP_C(RAND_C(simple_eq_match_conv1 xthm),
			simple_eq_match_conv1 xthm))
		(app_fun_rule (inst [] ty_insts x) s4)) 
		(combine tproj proj_thms);
	val s6 = list_±_intro s5;
	val s7 = §_intro(all_¥_intro s6) (all_¥_intro s3);
in
	check_is_z_thm "z_tuple_eq_conv" 
	(eq_trans_rule s0 s7)
end);
end;
=TEX
=SML
val €z_tuple_selection_conv› : CONV = (fn tm =>
let	val (bdy,n) = dest_z_selât tm
		handle complaint =>
		pass_on complaint "dest_z_selât" "z_tuple_selection_conv";
	val spec = get_spec tm;
	val s0 = (if is_z_tuple bdy
		then refl_conv tm
		else (RAND_C z_Ì_conv) tm)
		handle (Fail _) =>
		term_fail "z_tuple_selection_conv" 42006 [tm];
	val tm' = snd(dest_eq(concl s0));
	val (bdy,n) = dest_z_selât tm'; 
	val xi = dest_z_tuple bdy;
	val proj_thm = nth (n-1) 
		(strip_±_rule(list_µ_elim (bdy :: xi) spec));
in
	check_is_z_thm "z_tuple_selection_conv"
	(eq_trans_rule s0 proj_thm)
end);
=TEX
=SML
val €z_tuple_intro_conv› : CONV = (fn tm =>
let	val s0 = if is_z_tuple tm
		then refl_conv tm
		else (z_Ì_conv ORELSE_C
		(fn _ => term_fail "z_tuple_intro_conv" 42005 [tm])) tm;
	val tm' = snd(dest_eq(concl s0));
	val xi = dest_z_tuple tm'
		handle (Fail _) =>
		term_fail "z_tuple_intro_conv" 42005 [tm];
	val tuple= fst(dest_z_selât(hd xi))
		handle (Fail _) =>
		term_fail "z_tuple_intro_conv" 42005 [tm];
	val spec = all_µ_elim (µ_elim tuple (get_spec tm'))		handle (Fail _) =>
		term_fail "z_tuple_intro_conv" 42005 [tm];
	val cthm = hd(rev(strip_±_rule spec));
in
		check_is_z_thm "z_tuple_intro_conv"
		(eq_trans_rule s0 cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_intro_conv" 42005
			[fn () => string_of_term tm])
end);
=TEX
=SML
val €z_tuple_selection_intro_conv› : CONV = (fn tm =>
let	val (tcons,tprojs) = get_tuple_info (type_of tm)
		handle (Fail _) =>
		term_fail "z_tuple_selection_intro_conv" 42004 [tm];
	val spec = all_µ_elim (µ_elim tm (get_spec tcons));
	val cthm = eq_sym_rule(hd(rev(strip_±_rule spec)));
in
		check_is_z_thm "z_tuple_selection_intro_conv"
		(eq_trans_rule (refl_conv tm) cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_intro_conv" 42004
			[fn () => string_of_term tm])
end);
=TEX
\subsection{Tuple Theorems From the Z Mathematical Toolkit}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'first"Æ)));
	val s1 = all_µ_elim(conv_rule z_µ_elim_conv1
		(nth 1 (strip_±_rule spec)));
in
val €z_first_thm› = save_thm("z_first_thm",
	all_µ_intro(±_left_elim s1));
val €z_second_thm› = save_thm("z_second_thm",
	all_µ_intro(±_right_elim s1));
end;
=TEX
=SML
local
val xtuple = Ò(¨x:('a, 'b) $"Z'T[2]"Æ.1,¨x:('a, 'b) $"Z'T[2]"Æ.2)Æ;
val s1 = z_tuple_intro_conv xtuple;
val s2 = list_µ_elim [Ò¨x:('a, 'b) $"Z'T[2]"Æ.1Æ,
	Ò¨x:('a, 'b) $"Z'T[2]"Æ.2Æ] z_first_thm;
val s3 = list_µ_elim [Ò¨x:('a, 'b) $"Z'T[2]"Æ.1Æ,
	Ò¨x:('a, 'b) $"Z'T[2]"Æ.2Æ] z_second_thm;
val s4 = pure_rewrite_rule [s1] s2;
val s5 = pure_rewrite_rule [s1] s3;
val s6 = pure_rewrite_rule[eq_sym_rule s4, eq_sym_rule s5] s1;
in
val €z_first_second_thm› = save_thm("z_first_second_thm",
	all_µ_intro s6);
end;
=TEX
\section{CARTESIAN PRODUCTS}
=SML
local
	fun aux count 0 avoid = []
	| aux count n avoid = 
		if ("tâ" ^ string_of_int count) mem avoid
		then aux (count + 1) n avoid
		else ("tâ" ^ string_of_int count) :: aux (count + 1) (n-1) avoid;
	val t_±_thm = taut_rule ¨µ x ∑ T ± x § xÆ;
in
val €z_∏_conv› : CONV = (fn tm =>
let	val si = dest_z_∏ tm
		handle complaint =>
		pass_on complaint "dest_z_∏" "z_∏_conv";
	val spec = list_µ_elim si (get_spec tm);
	val tis = aux 1 (length si) (map fst(term_vars tm));
	val elem_tys = map (fn x => hd(snd(dest_ctype(type_of x)))) si;
	val ti = map mk_var (combine tis elem_tys);
	val ti_decs = map (fn (x,y) => mk_z_dec([x],y)) (combine ti si);
	val res = mk_z_seta(mk_z_decl ti_decs,
		mk_t,
		mk_z_tuple ti);
	val dummy = seta_gen_semantic_const res;
	val (tcons,tprojs) = get_tuple_info(hd(snd(dest_ctype(type_of tm))));
	val s1 = tac_proof(([],mk_z_eq(tm,res)),
		conv_tac(simple_eq_match_conv z_sets_ext_thm
			THEN_C z_µ_elim_conv1) THEN
		simple_µ_tac THEN
		(fn (asms,conc) => let	 val t = fst(dest_z_ç(snd(dest_z_§ conc)))
			val lthm = z_tuple_selection_intro_conv t;
		in
		conv_tac(APP_C(RAND_C(LEFT_C(fn _ => lthm)),
			LEFT_C(fn _ => lthm))) (asms,conc)
		end)
		THEN conv_tac (APP_C(RAND_C
			(RIGHT_C (fn _ => spec) THEN_C
			ç_comp_conv),
			z_ç_seta_conv))
		THEN conv_tac (APP_C(RAND_C
			(±_C(LEFT_C z_tuple_selection_conv)),
			z_∂_elim_conv THEN_C
			ALL_SIMPLE_∂_C 
			(LEFT_C (DECL_C dec_pred_conv) THEN_C
			RIGHT_C(
			simple_eq_match_conv1 t_±_thm THEN_C
			 z_tuple_eq_conv) )
			THEN_C basic_prove_∂_conv))
	THEN taut_tac)
in
	check_is_z_thm "z_∏_conv" s1
end)
end;
=TEX	
=SML
val €z_ç_∏_conv› : CONV = (fn tm =>
let	val (t,ct) = dest_z_ç tm
		handle (Fail _) =>
		term_fail  "z_ç_∏_conv" 42007 [tm];
	val si = dest_z_∏ ct
		handle (Fail _) =>
		term_fail  "z_ç_∏_conv" 42007 [tm];
	val spec = list_µ_elim si (get_spec ct);
	val s1 = (RIGHT_C(fn _ => spec) THEN_C ç_comp_conv) tm;
in
	check_is_z_thm "z_ç_∏_conv" 
	(eq_trans_rule (refl_conv tm) s1)
end);
=TEX
\section{RELATIONS}
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'dom"Æ)));
	val s1 = conv_rule z_µ_elim_conv1(±_right_elim spec);
	val s2 = rewrite_rule [z_sets_ext_thm] s1;
	val s3 = conv_rule (ONCE_MAP_C (z_∂_elim_conv1 THEN_C
			prove_∂_conv THEN_C
			z_∂_intro_conv1)) s2;
	val s4 = all_µ_elim s3;
in
val €z_dom_thm› = save_thm("z_dom_thm",
	all_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1(±_left_elim s4))));
val €z_ran_thm› = save_thm("z_ran_thm",
	all_µ_intro(all_µ_elim(conv_rule z_µ_elim_conv1(±_right_elim s4))));
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'id _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'id _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'id _"Æ));
in
val €z_id_thm› = save_thm("z_id_thm",spec);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub,Uc]
		(rewrite_rule[]
		(get_spec ¨$"z'_ ª _"Æ)));
	val s1 = conv_rule z_µ_elim_conv1(±_right_elim spec);
	val s2 = rewrite_rule [z_sets_ext_thm]
		(±_right_elim(all_µ_elim s1));
	val s3 = µ_elim Ò(p,q)Æ (conv_rule z_µ_elim_conv1 s2);
	val s4 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (LEFT_C (rewrite_conv [z_Ì_thm]) THEN_C
			z_tuple_eq_conv))
		THEN_C prove_∂_conv
		THEN_C z_∂_intro_conv1)) s3;
in
val €z_ª_thm› = save_thm("z_ª_thm",
	all_µ_intro(±_left_elim(all_µ_elim s1)));
val €z_o_thm› = save_thm("z_o_thm",
	all_µ_intro s4);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'_ Ú _"Æ)));
	val s1 = conv_rule(ONCE_MAP_C z_µ_elim_conv1)
		(rewrite_rule[z_sets_ext_thm]
		(conv_rule(ONCE_MAP_C z_µ_elim_conv1)
		(±_right_elim spec)));
	val s2 = ±_left_elim s1;
	val s3 = all_µ_elim(µ_elim Ò(p,q)Æ(all_µ_intro(all_µ_elim s2)));
	val s4 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (LEFT_C (rewrite_conv [z_Ì_thm]) THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s3;
	val s5 = ±_right_elim s1;
	val s6 = conv_rule (BINDER_C(RAND_C(simple_¡_conv "S"))) s5;
	val s7 = all_µ_elim(µ_elim Ò(p,q)Æ(all_µ_intro(all_µ_elim s6)));
	val s8 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (LEFT_C (rewrite_conv [z_Ì_thm]) THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s7;

in
val €z_Ú_thm› = save_thm("z_Ú_thm",
	all_µ_intro s4);
val €z_í_thm› = save_thm("z_í_thm",
	all_µ_intro s8);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'_ · _"Æ)));
	val s1 = conv_rule(ONCE_MAP_C z_µ_elim_conv1)
		(rewrite_rule[z_sets_ext_thm]
		(conv_rule(ONCE_MAP_C z_µ_elim_conv1)
		(±_right_elim spec)));
	val s2 = ±_left_elim s1;
	val s3 = all_µ_elim(µ_elim Ò(p,q)Æ(all_µ_intro(all_µ_elim s2)));
	val s4 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (LEFT_C (rewrite_conv [z_Ì_thm]) THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s3;
	val s5 = ±_right_elim s1;
	val s6 = conv_rule (BINDER_C(RAND_C(simple_¡_conv "S"))) s5;
	val s7 = all_µ_elim(µ_elim Ò(p,q)Æ(all_µ_intro(all_µ_elim s6)));
	val s8 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (LEFT_C (rewrite_conv [z_Ì_thm]) THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s7;

in
val €z_·_thm› = save_thm("z_·_thm",
	all_µ_intro s4);
val €z_Å_thm› = save_thm("z_Å_thm",
	all_µ_intro s8);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'_ Á~Í"Æ)));
	val s1 = all_µ_elim(conv_rule z_µ_elim_conv1 
		(±_right_elim spec));
	val s2 = µ_elimÒ(p,q)Æ
		(conv_rule z_µ_elim_conv1
		(rewrite_rule[z_sets_ext_thm] s1));
	val s3 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		ALL_SIMPLE_∂_C(
		RIGHT_C (LEFT_C (rewrite_conv [z_Ì_thm]) THEN_C
			z_tuple_eq_conv))
		THEN_C (MAP_C prove_∂_conv))) s2;
in
val €z_rel_inv_thm› = save_thm("z_rel_inv_thm",
	all_µ_intro s3);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'_ ® _ ©"Æ)));
	val s1 = all_µ_elim(conv_rule z_µ_elim_conv1 
		(±_right_elim spec));
	val s2 = (µ_elim ¨p:'bÆ
		(conv_rule z_µ_elim_conv1
		(rewrite_rule[z_sets_ext_thm] s1)));
	val s3 = conv_rule (RIGHT_C 
		(z_∂_elim_conv1 THEN_C 
		prove_∂_conv)) s2;
	val ±_t_±_thm = taut_rule¨µ x y∑ x ± y § x ± T ± yÆ;
	val s4 = conv_rule (RIGHT_C (BINDER_C(LEFT_C
		(DECL_INTRO_C pred_dec_conv) THEN_C 
		simple_eq_match_conv1 ±_t_±_thm)
		THEN_C z_∂_intro_conv)) s3;
in
val €z_rel_image_thm› = save_thm("z_rel_image_thm",
	all_µ_intro s4);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ¨$"z'_ Á+Í"Æ)));
	val s1 = all_µ_elim(conv_rule z_µ_elim_conv1 
		(±_right_elim spec));
in
val €z_trans_closure_thm› = save_thm("z_trans_closure_thm",
	all_µ_intro(±_left_elim s1));
val €z_reflex_trans_closure_thm› = 
	save_thm("z_reflex_trans_closure_thm",
		all_µ_intro(±_right_elim s1));
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'_ ﬂ _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'_ ﬂ _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'_ ﬂ _"Æ));
	val s1 = rewrite_conv [spec] Òf ç (X ﬂ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
in
val €z_ﬂ_thm› = save_thm("z_ﬂ_thm", all_µ_intro s2);
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'_ ≠ _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'_ ≠ _"Æ(pop_thm()));
=TEX
=SML

local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'_ ≠ _"Æ));
	val s1 = rewrite_conv [spec] Òf ç (X ≠ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
	val s3 = (
push_goal([],Òf ç (X ≠ Y) § f ç (X ﬂ Y) ± dom f = XÆ);
a(rewrite_tac[z_ﬂ_thm, s2, z_dom_thm, z_sets_ext_thm, z_Ì_thm]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(z_spec_nth_asm_tac 5 ÒxÆ);
a(DROP_NTH_ASM_T 6 (fn thm => 
	let val s1 = 
	conv_rule (ONCE_MAP_C z_ç_setd_conv THEN_C z_µ_elim_conv1)
	(rewrite_rule [z_Ä_thm] thm)
	in
	strip_asm_tac(rewrite_rule[](simple_µ_elim ¨yâ1Æ s1)) THEN
	strip_asm_tac(rewrite_rule[](simple_µ_elim ¨yâ2Æ s1))
	end));
a(z_spec_nth_asm_tac 3 ¨yâ1Æ);
a(z_spec_nth_asm_tac 4 ¨yâ2Æ);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[z__thm,z_™_thm]));
a(spec_nth_asm_tac 1 Ò(z,y)Æ);
a(POP_ASM_T(strip_asm_tac o conv_rule z_ç_∏_conv));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o conv_rule(MAP_C z_tuple_selection_conv)));
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 2 ¨zÆ);
a(z_∂_tac ¨yÆ);
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "4.1" *** *)
a(spec_nth_asm_tac 2 ¨yÆ);
(* *** Goal "4.2" *** *)
a(z_∂_tac ¨yÆ);
a(DROP_NTH_ASM_T 5 (strip_asm_tac o 
	conv_rule(ONCE_MAP_C z_ç_∏_conv) o 
	rewrite_rule [z_™_thm, z__thm]));
a(DROP_NTH_ASM_T 1 (strip_asm_tac o
	conv_rule(ONCE_MAP_C z_tuple_selection_conv) o
	µ_elim Ò(x,y)Æ));
a(REPEAT strip_tac);
a(z_spec_nth_asm_tac 7 Ò(x ¶ ¨xÆ, yâ1 ¶ ¨y'Æ, yâ2 ¶ ¨yÆ)Æ);
a(POP_ASM_T (strip_asm_tac o 
	conv_rule (ONCE_MAP_C z_ç_setd_conv) o
	rewrite_rule[z_Ä_thm]));
(* *** Goal "4.2.1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
pop_thm());
in
val €z_≠_thm› = save_thm("z_≠_thm", all_µ_intro s3);
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'_ ˛ _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'_ ˛ _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'_ ˛ _"Æ));
	val s1 = rewrite_conv [spec] Òf ç (X ˛ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
in
val €z_˛_thm› = save_thm("z_˛_thm",all_µ_intro s2);
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'_ ‡ _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'_ ‡ _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'_ ‡ _"Æ));
	val s1 = rewrite_conv [spec, z_°_thm, z_˛_thm] Òf ç (X ‡ Y)Æ;
	val s2 = (
push_goal([], Òf ç (X ‡ Y) § f ç (X ≠ Y) ±
	(µ xâ1, xâ2 : dom[U, U] f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_‡_thm› = save_thm("z_‡_thm", all_µ_intro s2);
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'_ œ _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'_ œ _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'_ œ _"Æ));
	val s1 = rewrite_conv [spec] Òf ç (X œ Y)Æ;
	val s2 = conv_rule (RIGHT_C
		(z_∂_elim_conv THEN_C prove_∂_conv
		THEN_C LEFT_C (DECL_C dec_pred_conv))) s1;
in
val €z_œ_thm› = save_thm("z_œ_thm", all_µ_intro s2);
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'_ Ô _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'_ Ô _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'_ Ô _"Æ));
	val s1 = rewrite_conv [spec, z_°_thm, z_œ_thm] Òf ç (X Ô Y)Æ;
	val s2 = (
push_goal([],
	Òf ç (X Ô Y) § f ç (X ≠ Y) ± ran f = YÆ);
a(rewrite_tac[s1, z_≠_thm]);
a(taut_tac);
pop_thm());
in
val €z_Ô_thm› = save_thm("z_Ô_thm", all_µ_intro s2);
end;
=TEX
=SML
val side = (
push_consistency_goal ¨$"z'_ è _"Æ;
a(rewrite_tac[]);
a(prove_∂_tac);
save_consistency_thm ¨$"z'_ è _"Æ(pop_thm()));
=TEX
=SML
local
	val spec = (rewrite_rule[]
		(get_spec ¨$"z'_ è _"Æ));
	val s1 = rewrite_conv [spec, z_°_thm, z_Ô_thm, z_‡_thm] Òf ç (X è Y)Æ;
	val s2 = (
push_goal([],
	Òf ç (X è Y) § f ç (X ≠ Y) ± ran f = Y ± 
	   (µ xâ1, xâ2 : dom f ∑ f xâ1 = f xâ2 ¥ xâ1 = xâ2)Æ);
a(rewrite_tac[s1]);
a(taut_tac);
pop_thm());
in
val €z_è_thm› = save_thm("z_è_thm", all_µ_intro s2);
end;
=TEX
=SML
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua,Ub]
		(rewrite_rule[]
		(get_spec ¨$"z'_ ´ _"Æ)));
in
val €z_´_thm› = save_thm("z_´_thm",
	conv_rule z_µ_elim_conv1
	(nth 1 (strip_±_rule spec)));
end;
=TEX

\section{PROOF CONTEXTS}
\subsection{Utilities}
The following is in recognition of the problems of
using Z generated constants with discrimination nets.
=SML
fun €make_ç_rule› thm = all_µ_intro
	(conv_rule z_µ_elim_conv1
	(conv_rule (simple_eq_match_conv1 z_sets_ext_thm)
	(all_µ_elim thm)));
=TEX
=SML
val €ç_operator_clauses› = [
	make_ç_rule z_´_thm, z_œ_thm, z_Ô_thm, z_è_thm,
	z_˛_thm, z_‡_thm, z_ﬂ_thm, z_≠_thm,
	make_ç_rule z_trans_closure_thm,
	make_ç_rule z_reflex_trans_closure_thm,
	z_rel_image_thm, z_·_thm, z_Å_thm, z_Ú_thm,
	z_í_thm, z_o_thm, make_ç_rule z_ª_thm, 
	make_ç_rule z_id_thm, z_ran_thm, z_dom_thm,
	make_ç_rule z_™_thm, z_ﬁ_thm, z_•_thm,
	z_¿_thm, z_°_thm, z_set_dif_thm, 
	make_ç_rule z_â1_thm, z_ö_thm, z__thm]
=TEX
And, spuriously for the name,
=SML
	@ [z_é_thm, z_Ω_thm];
=TEX 
=SML
val €z_local_ç_conv› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
in
	(case dest_z_term s of
	ZSeta _ => z_ç_seta_conv
	| ZSetd _ => z_ç_setd_conv 
	| Z∏ _ => z_ç_∏_conv
	| _ => fail_conv)
	tm
end);
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt initial_rw_canon) thms)
);
=TEX	
=IGN
¨µ x y ∑ Òµ z : y ∑ z ç x § f[x, y, z]ÆÆ
 ˜
¨µ x y z ∑ Òx Ä y ¥ z ç x § z ç y ± f[x, y, z]ÆÆ

perhaps, if aware of, e.g. Òx ç  yÆ
=TEX
\subsection{Algebraic Treatment of Sets}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_sets_alg" handle Fail _ => ();
val _ = new_pc "'z_sets_alg";
val _ = set_rw_eqn_cxt [(Òx ç ¨y (z:'c):'b SETÆÆ,z_local_ç_conv), 
	(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_eq_conv),
	(¨f(a1 a2 a3)Æ,z_tuple_selection_conv),
	(¨f (a1 a2) (b1 b2)Æ,z_tuple_intro_conv)
	]"'z_sets_alg";
val _ = add_rw_thms 
	([z_first_second_thm, z_second_thm, z_first_thm]
	@ ç_operator_clauses) "'z_sets_alg";

val pos = (thms_to_eqn_cxt ç_operator_clauses)
	@ [(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_eq_conv),
	   (Òx ç ¨y (z:'c):'b SETÆÆ,z_local_ç_conv)];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_alg";
val _ = set_rw_canons [] "'z_sets_alg";
val _ = set_pr_tac basic_prove_tac "'z_sets_alg";
val _ = set_pr_conv basic_prove_conv "'z_sets_alg";
val _ = set_cs_∂_convs [] "'z_sets_alg";
val _ = set_∂_vs_thms [] "'z_sets_alg";
val _ = set_merge_pcs ["z_predicates","'z_sets_alg"];
=TEX
\subsection{Extensionality Treatment of Sets}
=SML
val _ = delete_pc "'z_sets_ext" handle Fail _ => ();
val _ = new_pc "'z_sets_ext";
val _ = set_rw_eqn_cxt []"'z_sets_ext";
val _ = add_rw_thms 
	[z_sets_ext_thm, z_Ä_thm, z_†_thm] "'z_sets_ext";

val pos = thms_to_eqn_cxt [z_sets_ext_thm, z_Ä_thm, z_†_thm];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_ext";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_ext";
val _ = set_rw_canons [] "'z_sets_ext";
val _ = set_pr_tac basic_prove_tac "'z_sets_ext";
val _ = set_pr_conv basic_prove_conv "'z_sets_ext";
val _ = set_cs_∂_convs [] "'z_sets_ext";
val _ = set_∂_vs_thms [] "'z_sets_ext";
=TEX
=IGN
set_merge_pcs["z_predicates","'z_sets_alg","'z_sets_ext"];
push_goal([],ÒA Ω ö ¥ (• A) \ S = • {T1 : A ∑ T1 \ S}Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¨z'Æ);
a(z_spec_nth_asm_tac 6 ¨T1Æ);
(* *** Goal "2" *** *)
a(z_spec_nth_asm_tac 2 ÒS' \ SÆ);
a(z_spec_nth_asm_tac 1 ¨S'Æ);
(* *** Goal "3" *** *)
a(z_spec_nth_asm_tac 1 Òz \ SÆ);
a(z_spec_nth_asm_tac 1 ¨zÆ);
pop_thm();
=TEX
\section{EPILOGUE}
=SML
end; (* of structure ZSetTheory *)
open ZSetTheory;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ¨$"z'"Æ)));
in
val €z__thm› = save_thm("z__thm",
	conv_rule z_µ_elim_conv1
	(nth  (strip_±_rule spec)));
end;

