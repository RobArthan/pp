=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Language Set Theory}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP042}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z Language set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First versions.
\item [Issues 1.4 (15th September 1992)]
Changes to reflect  issue 1.6 of detailed design.
\item [Issues 1.5 (29th September 1992)]
Changes after comments, removal of HOL universals where
appropriate.
\item [Issues 1.7 (12th October 1992)]
Modified $z\_¥\\Þ_thm$.
\item [Issues 1.8 (12th October 1992)]
Moved Library material to \cite{DS/FMU/IED/IMP083}.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) set theory, tuples and cartesian products.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD042}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the set theory, tuples and cartesian products of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD042}.
\subsubsection{Deficiencies}
$z\_¸\_conv$ is comparatively slow compared to like functions.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure ÛZSetTheoryÝ : ZSetTheory = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory Û"z_set_theory"Ý;
val _ = set_pc "z_predicates";
val _ = set_flag("z_type_check_only",false);
=TEX

\section{THE CODE}
\subsection{Utilities}
A precaution, lost outside of structure:
=SML
fun Ûsave_thmÝ(a,b) = KernelInterface.save_thm(a, check_is_z_thm "save_thm" b);
fun Ûlist_save_thmÝ(a,b) = KernelInterface.list_save_thm(a, check_is_z_thm "list_save_thm" b);
=SML
fun Ûlist_eqÝ (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val ÛUaÝ = ñU®; (* type = 'a SET *)
val ÛUbÝ = inst [] [(”'b®,”'a®)] Ua;
val ÛUcÝ = inst [] [(”'c®,”'a®)] Ua;
=TEX
\subsubsection{Conversionals}
Apply through all $Ì$'s.
=SML
fun (ÛALL_SIMPLE_Ì_CÝ (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ì_C (ALL_SIMPLE_Ì_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun ÛLAST_SIMPLE_µ_CÝ (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun ÛDIAG_CÝ (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun Û±_CÝ (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¬op a1 (op a2 (op a3 ...))®
÷
÷
ô (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = ô a1 = a1'
cnv2 a2 = ô a2 = a2'
cnv3 a3 = ô a3 = a3'
 ...
=TEX
=SML
fun ÛLIST_OP_CÝ [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
local
	fun simple_Á_conv1 nm :CONV= (fn tm =>
		(simple_Á_conv nm
		ORELSE_C
		simple_Á_conv1 (nm ^ get_variant_suffix())) tm);
in
fun Ûseq_binder_simple_Á_convÝ [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (simple_Á_conv1 nm)
end
) | seq_binder_simple_Á_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (simple_Á_conv1 nm)) THEN_C BINDER_C (seq_binder_simple_Á_conv x)
end
) | seq_binder_simple_Á_conv [] = id_conv;
end;
=TEX
=SML
fun (Ûseq_simple_Â_convÝ:CONV) (tm:TERM) = (
	(simple_Â_conv
	ORELSE_C 
	(RATOR_C seq_simple_Â_conv THEN_C simple_Â_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_Â_conv" 27008 [tm1]))
	tm
);
=TEX
Change a free variable name:
=SML
fun Ûchange_name_ruleÝ from_nm to_nm thm = (
let	val fvs = map dest_var (frees(concl thm));
	val ty = lassoc3 fvs from_nm;
in
	simple_µ_elim (mk_var(to_nm, ty))
	(simple_µ_intro (mk_var(from_nm, ty)) thm)
end);
=TEX

\subsubsection{Projection Conversions}
=SML
val Ûdpvt_proj_thmÝ:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¬$"Z'S[d,p,t,v]v"®))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (Ûd_dptv_proj_convÝ,Ûp_dptv_proj_convÝ,
		Ût_dptv_proj_convÝ, Ûv_dptv_proj_convÝ) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val Ûdpv_proj_thmÝ:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¬$"Z'S[d,p,v]v"®))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val Ûd_dpv_proj_convÝ = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val Ûp_dpv_proj_convÝ = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val Ûv_dpv_proj_convÝ = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specñ(x,y).1®));
in
val Ûtuple2_1_proj_convÝ = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val Ûtuple2_2_proj_convÝ = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
\section{THE IMPLEMENTATION}
=SML
val Ûz_sets_ext_thmÝ : THM = save_thm ("z_sets_ext_thm",
	all_z_µ_intro(
push_goal([],ñ(x = y) = (µz: U · ((z  x) ¤ (z  y)))®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T (ante_tac o conv_rule z_µ_elim_conv1));
a(PC_T1 "hol1" rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûz_ð_thmÝ : THM = save_thm("z_ð_thm", all_z_µ_intro(
push_goal([],ñ(t  ð u) = (µz: U · ((z  t) ´ (z  u)))®);
a(rewrite_tac[get_spec ñð x®, get_spec ¬$"Z'ð"®]);
a(PC_T1 "hol1" rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
pop_thm()));
=TEX
=SML
local
	val z'seta_conv1 = BINDER_C(ALL_SIMPLE_¶_C
		(fn tm => 
		let val Âred = snd(dest_app(fst(dest_± tm)));
			val Âred_thm = seq_simple_Â_conv Âred
		in
		LIST_OP_C [
		RAND_C (fn _ => Âred_thm) THEN_C d_dpv_proj_conv,
		RAND_C (fn _ => Âred_thm) THEN_C p_dpv_proj_conv,
		LEFT_C(RAND_C (fn _ => Âred_thm) THEN_C v_dpv_proj_conv)
		] tm
		end
		));
in
val Ûz__seta_convÝ : CONV = (fn tm =>
let	val (x,s) = dest_z_ tm;
	val was_sig = fst(strip_Ì(snd(dest_app s)));
	val (d,p,t) = dest_z_seta s;
	val spec = seta_gen_semantic_const s;
	val s1 = (RAND_C 
		((simple_eq_match_conv1 spec) THEN_C
		z'seta_conv1) THEN_C
		simple__comp_conv) tm;
	val s2 = conv_rule (RIGHT_C 
		((seq_binder_simple_Á_conv was_sig)
		THEN_C z_¶_intro_conv)) s1;
in
	check_is_z_conv_result "z__seta_conv" s2
end
handle complaint =>
list_divert complaint "z__seta_conv"
	[("dest_z_",42001,[fn () => string_of_term tm]),
	("dest_z_seta",42001,[fn () => string_of_term tm])]);
end;
=IGN
z__seta_conv ñp  {x:X·(x,x)}®;
z__seta_conv ñ(1,2)  {x:X;y:Y·(x,y)}®;
=TEX
=SML
local
	val thm1 = (
	push_goal([],¬µ (x:'a)· ñ(x  {} ¤ false)®®);
	a(rewrite_tac[get_spec ñ{}®] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm2 = (
	push_goal([],¬µ (x:'a) (h:'a) · ñ(x  {h} ¤ x = h)®®);
	a(rewrite_tac[get_spec ñ{}®] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm3 = (
	push_goal([],¬µ (x:'a) (h:'a) (t:'a LIST) · 
	ñ(x   ¬Z'Setd (Cons h t)®) ¤ (x = h ² x  ¬Z'Setd t®)®®);
	a(rewrite_tac[get_spec ñ{}®] THEN
	PC_T1 "hol1" rewrite_tac[]);
	a(REPEAT strip_tac);
	pop_thm());

	val cnv1 = simple_eq_match_conv1 thm1;
	val cnv2 = simple_eq_match_conv1 thm2;
	val cnv3 = simple_eq_match_conv1 thm3;
	fun cnv4 tm = (cnv2 ORELSE_C
		(cnv3 THEN_C RIGHT_C cnv4)
		ORELSE_C (fn tm => term_fail "z__setd_conv"
			42008 [tm])) tm;
	val thm5 = pc_rule1 "hol1" prove_rule[] ¬µ x y · ((x = x) ² y) ¤ T®;
	val cnv5 = simple_eq_match_conv1 thm5;
	val thm6 = taut_rule ¬µ x · (x ² T) ¤ T®;
	val cnv6 = simple_eq_match_conv1 thm6;
	val thm7 = pc_rule1 "hol1" prove_rule [] ¬µ x · (x =x) ¤ T®;
	val cnv7 = simple_eq_match_conv1 thm7;
	fun cnv8 tm = (
	let	val (p,q) = dest_² tm;
		val (x1,h) = dest_eq p;
	in
		if x1 ~=$ h
		then cnv5 tm
		else (RIGHT_C cnv8 THEN_C cnv6) tm
	end
	handle (Fail _) =>
	cnv7 tm);

in
val Ûz__setd_conv1Ý : CONV = (fn tm =>
let	val (x,s) = dest_z_ tm;
	val (_,tml) = dest_z_setd s;
	val dummy = if x term_mem tml
		then ()
		else term_fail "z__setd_conv1" 42009 [tm];
	val s1 = cnv4 tm
		handle complaint =>
		pass_on complaint "z__setd_conv" "z__setd_conv1";
	val s2 = conv_rule (RIGHT_C cnv8) s1;
in
	check_is_z_conv_result "z__setd_conv1" 
	s2
end
handle complaint =>
list_divert complaint "z__setd_conv1"
	[("dest_z_",42009,[fn () => string_of_term tm]),
	("dest_z_setd",42009,[fn () => string_of_term tm])]);
end;


=IGN
z__setd_conv ñ3  {2,3,4}®;
z__setd_conv ñ3  {4}®;
z__setd_conv ñ3  {}®;
z__setd_conv1 ñ3  {2,3,4}®;
z__setd_conv1 ñ3  {3}®;
=TEX
=SML
val _ = delete_pc "'build_z_sets" handle (Fail _) => ();
val _ = new_pc "'build_z_sets";
val _ = set_rw_eqn_cxt 
	[(ñx  ¬y (Ì z · w):'a SET®®,z__seta_conv),
	 (ñx  ¬Z'Seta[0] y:'a SET®®,z__seta_conv),
	 (¬(Ì x · y) z®,simple_Â_conv),
	 (ñx  ¬Z'Setd y®®,z__setd_conv1)] "'build_z_sets";
val _ = add_rw_thms [µ_rewrite_thm] "'build_z_sets";
val _ = set_pr_conv z_basic_prove_conv "'build_z_sets";
=TEX
=SML
fun Ûtt_to_¶_vsÝ  (ty : TYPE) : (string * (TERM list * THM)) = (
let	val (abs,cons) = get_tuple_info ty;
	val def_thm = get_spec (hd cons);
	val abs_nm = fst(dest_const abs);
in
	(abs_nm,(cons, def_thm))
end);
=TEX
=SML
val _ =set_¶_vs_thms [tt_to_¶_vs ”'X SET $"Z'T[1]"®] "'build_z_sets";

val _ = set_merge_pcs ["z_predicates","'build_z_sets"];
=TEX
\section{TUPLES}
=SML
local
	fun aux thm [] [] = thm
	| aux thm (a::x)(b::y) = aux (mk_app_rule thm (asm_rule (mk_z_eq (a, b)))) x y
	| aux _ _ _ = error "z_tuple_lang_eq_conv" 0 [];
	
	fun aux1 tm [] [] = tm
	| aux1 tm (a::x)(b::y) = aux1 (mk_z_±(mk_z_eq (a,b), tm)) x y
	|aux1 _ _ _ = error "z_tuple_lang_eq_conv" 0 [];
in
val Ûz_tuple_lang_eq_convÝ : CONV = (fn tm =>
let	val (lhs,rhs) = dest_z_eq tm
		handle (Fail _) =>
		term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val s0 = if is_z_tuple lhs andalso is_z_tuple rhs
		then refl_conv tm
		else term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val tm' = snd(dest_eq(concl s0));
	val (lhs,rhs) = dest_z_eq tm';
	val dummy = if is_z_tuple lhs andalso is_z_tuple rhs
		then ()
		else term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val spec = get_spec lhs;
	val proj_thms = map all_µ_intro
		(rev(tl(rev(strip_±_rule(all_µ_elim spec)))));
	val (tcons,tproj) = get_tuple_info (type_of lhs);
	val lhs_bits = dest_z_tuple lhs;
	val rhs_bits = dest_z_tuple rhs;
	val tcons' = fst(strip_app lhs);
	val ty_insts = fst(term_match tcons' tcons);
	val s1 = aux (refl_conv tcons') lhs_bits rhs_bits;
	val rlhs_bits = rev lhs_bits;
	val rrhs_bits = rev rhs_bits;
	val res = aux1 (mk_z_eq(hd rlhs_bits, hd rrhs_bits))
		(tl rlhs_bits) (tl rrhs_bits);
	val s2 = strip_±_rule (asm_rule res);
	val s3 = fold (uncurry prove_asm_rule) s2 s1;
	val s4 = asm_rule tm';
	val s5 = map (fn (x,xthm) => 
		conv_rule(APP_C(RAND_C(simple_eq_match_conv1 xthm),
			simple_eq_match_conv1 xthm))
		(app_fun_rule (inst [] ty_insts x) s4)) 
		(combine tproj proj_thms);
	val s6 = list_±_intro s5;
	val s7 = ¤_intro(all_´_intro s6) (all_´_intro s3);
in
	check_is_z_conv_result "z_tuple_lang_eq_conv" 
	(eq_trans_rule s0 s7)
end);
end;
=TEX
=IGN
z_tuple_lang_eq_conv ñ(1,2,3) = (p,q,r)®;
=SML
val Ûz_tuple_lang_selection_convÝ : CONV = (fn tm =>
let	val (bdy,n) = dest_z_sel‰t tm
		handle complaint =>
		pass_on complaint "dest_z_sel‰t" "z_tuple_lang_selection_conv";
	val spec = get_spec tm;
	val s0 = (if is_z_tuple bdy
		then refl_conv tm
		else term_fail "z_tuple_lang_selection_conv" 42006 [tm]);
	val tm' = snd(dest_eq(concl s0));
	val (bdy,n) = dest_z_sel‰t tm'; 
	val xi = dest_z_tuple bdy;
	val proj_thm = nth (n-1) 
		(strip_±_rule(list_µ_elim (bdy :: xi) spec));
in
	check_is_z_conv_result "z_tuple_lang_selection_conv"
	(eq_trans_rule s0 proj_thm)
end);
=TEX
=IGN
z_tuple_lang_selection_conv ñ(1,2,3,4).2®;
=SML
val Ûz_tuple_lang_intro_convÝ : CONV = (fn tm =>
let	val s0 = if is_z_tuple tm
		then refl_conv tm
		else term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val tm' = snd(dest_eq(concl s0));
	val xi = dest_z_tuple tm'
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val tuple= fst(dest_z_sel‰t(hd xi))
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val spec = all_µ_elim (µ_elim tuple (get_spec tm'))
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val cthm = hd(rev(strip_±_rule spec));
in
		check_is_z_conv_result "z_tuple_lang_intro_conv"
		(eq_trans_rule s0 cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_lang_intro_conv" 42005
			[fn () => string_of_term tm])
end);
=TEX
=IGN
z_tuple_lang_intro_conv ñ((1,2,3).1,(1,2,3).2,(1,2,3).3)®;
=SML
val Ûz_tuple_selection_intro_convÝ : CONV = (fn tm =>
let	val (tcons,tprojs) = get_tuple_info (type_of tm)
		handle (Fail _) =>
		term_fail "z_tuple_selection_intro_conv" 42004 [tm];
	val spec = all_µ_elim (µ_elim tm (get_spec tcons));
	val cthm = eq_sym_rule(hd(rev(strip_±_rule spec)));
in
		check_is_z_conv_result "z_tuple_selection_intro_conv"
		(eq_trans_rule (refl_conv tm) cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_lang_intro_conv" 42004
			[fn () => string_of_term tm])
end);
=TEX
=IGN
z_tuple_selection_intro_conv ñ(1,2,3)®;
=TEX

\section{CARTESIAN PRODUCTS}

=SML
local
	fun aux count 0 avoid = []
	| aux count n avoid = 
=SMLLITERAL
		if ("t‰" ^ string_of_int count) mem avoid
		then aux (count + 1) n avoid
		else ("t‰" ^ string_of_int count) :: aux (count + 1) (n-1) avoid;
=SML
	val t_±_thm = taut_rule ¬µ x · T ± x ¤ x®;
	val cnv1 :CONV = simple_eq_match_conv1
	(conv_rule z_µ_elim_conv1 z_sets_ext_thm);

in
=TEX
=SML
val Ûz_¸_convÝ : CONV = (fn tm =>
let	val si = dest_z_¸ tm
		handle complaint =>
		pass_on complaint "dest_z_¸" "z_¸_conv";
	val spec = list_µ_elim si (get_spec tm);
	val tis = aux 1 (length si) (map fst(term_vars tm));
	val elem_tys = map (fn x => hd(snd(dest_ctype(type_of x)))) si;
	val ti = map mk_var (combine tis elem_tys);
	val ti_decs = map (fn (x,y) => mk_z_dec([x],y)) (combine ti si);
	val res = mk_z_seta(mk_z_decl ti_decs,
		mk_t,
		mk_z_tuple ti);
	val dummy = seta_gen_semantic_const res;
	val (tcons,tprojs) = get_tuple_info(hd(snd(dest_ctype(type_of tm))));
=TEX
=SML
	val s1 = tac_proof(([],mk_z_eq(tm,res)),
		conv_tac(cnv1 THEN_C z_µ_elim_conv1) THEN
		simple_µ_tac THEN
		(fn (asms,conc) => let	 val t = fst(dest_z_(snd(dest_z_¤ conc)))
			val lthm = z_tuple_selection_intro_conv t;
		in
		conv_tac(APP_C(RAND_C(LEFT_C(fn _ => lthm)),
			LEFT_C(fn _ => lthm))) (asms,conc)
		end)
		THEN conv_tac (APP_C(RAND_C
			(RIGHT_C (fn _ => spec) THEN_C
			_comp_conv),
			z__seta_conv))
		THEN conv_tac (APP_C(RAND_C
			(±_C(LEFT_C z_tuple_lang_selection_conv)),
			z_¶_elim_conv THEN_C
			ALL_SIMPLE_¶_C 
			(LEFT_C (DECL_C dec_pred_conv) THEN_C
			RIGHT_C(
			simple_eq_match_conv1 t_±_thm THEN_C
			 z_tuple_lang_eq_conv) )
			THEN_C basic_prove_¶_conv))
	THEN taut_tac)
in
	check_is_z_conv_result "z_¸_conv" s1
end)
end;
=IGN
z_¸_conv ñX ¸ Y ¸ ð Y®;
=SML
val Ûz__¸_convÝ : CONV = (fn tm =>
let	val (t,ct) = dest_z_ tm
		handle (Fail _) =>
		term_fail  "z__¸_conv" 42007 [tm];
	val si = dest_z_¸ ct
		handle (Fail _) =>
		term_fail  "z__¸_conv" 42007 [tm];
	val spec = list_µ_elim si (get_spec ct);
	val s1 = (RIGHT_C(fn _ => spec) THEN_C _comp_conv) tm;
	val s2 = conv_rule(RIGHT_C (±_C 
		(TRY_C(LEFT_C z_tuple_lang_selection_conv)))) s1;
in
	check_is_z_conv_result "z__¸_conv" 
	(eq_trans_rule (refl_conv tm) s2)
end);
=IGN
z__¸_conv ñ(1,2,3)   X ¸ X ¸ X®;
z__¸_conv ñx   X ¸ X ¸ X®;
=TEX
\subsection{Extensionality of Sets II}
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if ord nm = ordx
		then nm
		else fail "" 0 []);
	fun give_n_names nn lst = (
=SMLLITERAL
	let	fun nextn n = (let val poss = "x‰" ^ string_of_int n
=SML
			in
			if poss mem lst
			then nextn (n+1)
			else (n,poss)
			end);
		fun nextnm 0 m = []
		| nextnm n m = (let val (ind,next) = nextn m
			in
			(next :: nextnm (n-1) (ind+1))
			end)
	in
		nextnm nn 1
	end);
	val cnv1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z_sets_ext_thm);
	fun cnv2 nm = cnv1 THEN_C 
			z_µ_elim_conv THEN_C
			RAND_C(simple_Á_conv nm) THEN_C
			z_µ_intro_conv;
	val Ua = ñU®;
	fun uf ty = inst [] [(ty, ”'a®)] Ua;
	val sets_ext_thm = pc_rule1 "'sets_ext" rewrite_conv[] ¬p:'a SET = q®;
	val sym_sets_ext_thm = all_µ_intro(eq_sym_rule sets_ext_thm);
=TEX
=SML
in
val Ûz_sets_ext_convÝ : CONV = (fn tm =>
let	val (v,w) = dest_z_eq tm
		handle complaint =>
		divert complaint "dest_z_eq" "z_sets_ext_conv"
			42010 [fn () => string_of_term tm];
	val vty = type_of v;
	val elem_ty = case dest_ctype vty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "z_sets_ext_conv" 42010 [tm];
	val names = (mapfilter xnames (term_vars v)) cup (mapfilter xnames (term_vars w));
	val res =
	case dest_simple_type elem_ty of
	Ctype (nm,args) => ((case dest_z_name nm of
		("Z'T",[[ns]],Nil) => (
		let 	val n = nat_of_string ns;
			val xs =map mk_var
				(combine
				(give_n_names n names)
				args);
			val xs_decl = mk_z_decl
				(map (fn x => mk_z_dec([x],uf(type_of x))) xs);
			val xs_tuple = mk_z_tuple xs;
			val conc_gl = mk_z_µ(xs_decl,
				mk_t, mk_z_¤(
				mk_z_(xs_tuple, v),
				mk_z_(xs_tuple, w)));
			val s1 = asm_rule tm;
			val s2 = app_fun_rule
				(mk_app( (mk_const("",
				mk_­_type(type_of xs_tuple,
				mk_­_type(vty,BOOL)))),
				xs_tuple)) s1;
			val s3 = z_µ_intro1 xs s2;
			val s4 = asm_rule (concl s3);
			val xv = variant (frees (concl s3)) (mk_var("x",type_of xs_tuple));
			val s5 = z_tuple_selection_intro_conv xv;
			val xparts = dest_z_tuple(snd(dest_eq(concl s5)));
			val s6 = conv_rule z_µ_elim_conv1 s4;
			val s7 = list_µ_elim xparts s6;
			val s8 = conv_rule(RANDS_C (LEFT_C (fn _ => eq_sym_rule s5))) s7;
			val s9 = simple_µ_intro xv s8;
			val s10 = list_µ_elim[v,w] sym_sets_ext_thm;
			val s11 = ¤_mp_rule s10 s9;
			val s12 = ¤_intro (all_´_intro s3) (all_´_intro s11);	
		in
			eq_trans_rule (refl_conv tm) s12
		end)
=TEX
=SML
		| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
		handle (Fail _) =>
		(let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
	| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end)
in
	check_is_z_conv_result "z_sets_ext_conv" res
end);
end; 
=IGN
z_sets_ext_conv ñ{1,2,3} = {3,2,1}®;
z_sets_ext_conv ñ{(1,2),(2,3)} = {(2,3),(1,2)}®;
z_sets_ext_conv ñ{(1,p,2,x‰2,x),(2,q,3,x‰2,x)} = {(2,q,3,x‰2,x),(1,p,2,x‰2,x)}®;
=TEX
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if ord nm = ordx
		then nm
		else fail "" 0 []);
	fun give_n_names nn lst = (
=SMLLITERAL
	let	fun nextn n = (let val poss = "x‰" ^ string_of_int n
=SML
			in
			if poss mem lst
			then nextn (n+1)
			else (n,poss)
			end);
		fun nextnm 0 m = []
		| nextnm n m = (let val (ind,next) = nextn m
			in
			(next :: nextnm (n-1) (ind+1))
			end)
	in
		nextnm nn 1
	end);
	val cnv1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z_ð_thm);
	fun cnv2 nm = cnv1 THEN_C 
			z_µ_elim_conv THEN_C
			RAND_C(simple_Á_conv nm) THEN_C
			z_µ_intro_conv;
	val Ua = ñU®;
	fun uf ty = inst [] [(ty, ”'a®)] Ua;
	val thm1 = taut_rule ¬µ x y · x ´ ((y ± T) ´ x)®;
	val thm2 = prove_rule[] ¬µ x y · x ´ ((y  ñU® ± T) ´ x)®;
=TEX
=SML
in
val Ûz__ð_convÝ : CONV = (fn tm =>
let	val (v,pw) = dest_z_ tm
		handle complaint =>
		divert complaint "dest_z_" "z__ð_conv"
			42016 [fn () => string_of_term tm];
	val w = dest_z_ð pw
		handle complaint =>
		divert complaint "dest_z_ð" "z__ð_conv"
			42016 [fn () => string_of_term tm];
	val wty = type_of w;
	val elem_ty = case dest_ctype wty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "z__ð_conv" 42010 [tm];
	val names = (mapfilter xnames (term_vars v)) cup (mapfilter xnames (term_vars w));
	val res =
	case dest_simple_type elem_ty of
	Ctype (nm,args) => ((case dest_z_name nm of
		("Z'T",[[ns]],Nil) => (
		let 	val n = nat_of_string ns;
			val xs =map mk_var
				(combine
				(give_n_names n names)
				args);
			val xs_decl = mk_z_decl
				(map (fn x => mk_z_dec([x],uf(type_of x))) xs);
			val xs_tuple = mk_z_tuple xs;
			val conc_gl = mk_z_µ(xs_decl,
				mk_t, mk_z_´(
				mk_z_(xs_tuple, v),
				mk_z_(xs_tuple, w)));
			val s1 = cnv1 tm;
			val tm' = snd(dest_eq(concl s1));
			val s2 = asm_rule tm';
			val s3 = simple_µ_elim xs_tuple(
				conv_rule z_µ_elim_conv1 s2);
			val s4 = list_simple_µ_elim [concl s3, xs_decl] thm1;
			val s5 = ´_elim s4 s3;
			val s6 = conv_rule z_µ_intro_conv 
				(list_µ_intro xs s5);
=TEX
Now back the other way:
=SML
			val s7 = asm_rule (concl s6);
			val xv = variant (frees (concl s7)) (mk_var("x",type_of xs_tuple));
			val s8 = z_tuple_selection_intro_conv xv;
			val xparts = dest_z_tuple(snd(dest_eq(concl s8)));
			val s9 = conv_rule z_µ_elim_conv1 s7;
			val s10 = list_µ_elim xparts s9;
			val s11 = conv_rule(RANDS_C (LEFT_C (fn _ => eq_sym_rule s8))) s10;			
			val s12 =  ´_elim (list_µ_elim [concl s11, xv] thm2) s11;
			val s13 = z_µ_intro s12;
			val s14 = ¤_intro (all_´_intro s6) (all_´_intro s13);	
		in
			eq_trans_rule (refl_conv tm) 
				(eq_trans_rule s1 s14)
		end)
=TEX
=SML
		| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
		handle (Fail _) =>
		(let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
	| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end)
in
	check_is_z_conv_result "z__ð_conv" res
end);
end; 
=IGN
z__ð_conv ñp  ð q®;
z__ð_conv ñp  ð (x ¸ y)®;
z__ð_conv ñp  ð (ð u)®;
=TEX
\section{MISCELLANEOUS}
=SML
local
	val taut_thm = all_µ_intro
		(taut_rule¬((a ´ b) ± ((b ± T) ´ ( a ¤ c ))) = (a ¤ (b ± c))®);
	val c1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z_ð_thm);
	val c2 = simple_eq_match_conv1 taut_thm;
in
fun  Ûz_defn_simp_ruleÝ (ithm : THM) : THM = ((
let	val thm = conv_rule (TRY_C z_defn_conv THEN_C
		TRY_C(LEFT_C (DECL_C dec_pred_conv))) ithm;
	val tm = concl thm;
	val (tm1,tm2) = dest_± tm;
	val thm1 = conv_rule
		(c1 THEN_C z_µ_elim_conv1)
		(±_left_elim thm);
	val thm2 = ±_right_elim thm;
	val (d,p,v) = dest_z_µ(concl thm2);
	val dvar = hd(fst(dest_z_dec(hd(dest_z_decl d))));
	val thm'' = ±_intro(µ_elim dvar thm1)
			(z_µ_elim dvar thm2);
in 
	check_is_z_thm "z_defn_simp_rule"
	(z_µ_intro1 [dvar] (conv_rule c2 thm''))
end)
handle complaint =>
list_divert complaint "z_defn_simp_rule"
	[("dest_±", 42011, [fn () => string_of_thm ithm]),
	("simple_eq_match_conv1", 42011, [fn () => string_of_thm ithm]),
	("dest_z_decl", 42011, [fn () => string_of_thm ithm]),
	("dest_z_dec", 42011, [fn () => string_of_thm ithm]),
	("z_µ_elim", 42011, [fn () => string_of_thm ithm])]);
end;
=TEX
=IGN
z_defn_simp_rule 
	(asm_rule ¬Z'AbbDef ñp  ð(X ¸ Y) ± (µ q : X ¸ Y · q  p ¤ first q = q.1)®®);
z_defn_simp_rule
	(conv_rule 
	(RAND_C(LEFT_C (DECL_INTRO_C pred_dec_conv)))
(asm_rule ¬Z'AbbDef ñp  ð(X ¸ Y) ± (µ q : X ¸ Y · q  p ¤ first q = q.1)®®));
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
=SML
fun Ûlimited_z_Â_convÝ tm = (
let	val res = z_Â_conv tm
in
	if is_nil(asms res)
	then res
	else term_fail "limited_z_Â_conv" 0 [tm]
end);
=TEX
=SML
fun Ûthms_to_eqn_cxtÝ (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	
\subsection{Treatment of Membership of Sets in Z Language}
In designing discrimination net indices we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z__set_lang" handle Fail _ => ();
val _ = new_pc "'z__set_lang";
val _ = set_rw_eqn_cxt [(ñx  ¬y (Ì w:'c · z):'b SET®®,z__seta_conv),
	(ñx  ¬Z'Seta[0] y:'a SET®®,z__seta_conv),
	(ñx  ¬y (Cons (p:'b) q):'b SET®®,z__setd_conv),
	(ñx  ¬y Nil:'b SET®®,z__setd_conv),
	(ñ(Ì x : U | true · y) z®,limited_z_Â_conv)]
		"'z__set_lang";
val _ = add_rw_thms [] "'z__set_lang";

val pos = (thms_to_eqn_cxt [])
	@ [(ñx  ¬y (Ì w · z):'b SET®®,z__seta_conv),
	(ñx  ¬Z'Seta[0] y:'a SET®®,z__seta_conv),
	(ñx  ¬y (Cons (p:'b) q):'b SET®®,z__setd_conv),
	(ñx  ¬y Nil:'b SET®®,z__setd_conv)];
val neg = map (mk_³ ** RAND_C) pos;
val neither = [(ñ(Ì x : U · y) z®, limited_z_Â_conv)];
val _ = set_st_eqn_cxt (pos @ neg @ neither) "'z__set_lang";
val _ = set_sc_eqn_cxt (pos @ neg @ neither) "'z__set_lang";
val _ = set_rw_canons [] "'z__set_lang";
val _ = set_pr_tac z_basic_prove_tac "'z__set_lang";
val _ = set_pr_conv z_basic_prove_conv "'z__set_lang";
val _ = set_cs_¶_convs [] "'z__set_lang";
val _ = set_¶_vs_thms [] "'z__set_lang";
=TEX
\subsection{Extensionality Treatment of Sets}
=SML
val _ = delete_pc "'z_sets_ext_lang" handle Fail _ => ();
val _ = new_pc "'z_sets_ext_lang";
val _ = set_rw_eqn_cxt [(ñ¬Z'Setd x® € y®,z_setd_€_conv),
	(ñx  ð y®,z__ð_conv),
	(ñx = y®,z_sets_ext_conv)]
	"'z_sets_ext_lang";
val _ = add_rw_thms 
	[] "'z_sets_ext_lang";

val pos = [(ñ¬Z'Setd x® € y®,z_setd_€_conv),
	(ñx  ð y®,z__ð_conv),
	(ñx = y®,z_sets_ext_conv)]
	@ thms_to_eqn_cxt [];
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_ext_lang";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_ext_lang";
val _ = set_rw_canons [] "'z_sets_ext_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_ext_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_ext_lang";
val _ = set_cs_¶_convs [] "'z_sets_ext_lang";
val _ = set_¶_vs_thms [] "'z_sets_ext_lang";
=TEX
=SML
val _ = delete_pc "'build_z_sets";
=TEX
\subsection{Treatment of Tuples and Cartesian Products}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_tuples_lang" handle Fail _ => ();
val _ = new_pc "'z_tuples_lang";
val _ = set_rw_eqn_cxt [(ñx  ¬y (z:'c):'b SET®®,z__¸_conv),
	(¬a1 a2 a3 = b1 b2 b3®,z_tuple_lang_eq_conv),
	(¬f(a1 a2 a3)®,z_tuple_lang_selection_conv),
	(¬f (a1 a2) (b1 b2)®,z_tuple_lang_intro_conv)
	]"'z_tuples_lang";

val pos = [(¬a1 a2 a3 = b1 b2 b3®,z_tuple_lang_eq_conv),
	  (ñx  ¬y (z:'c):'b SET®®,z__¸_conv)];
val neg = map (mk_³ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_tuples_lang";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_tuples_lang";
val _ = set_rw_canons [] "'z_tuples_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_tuples_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_tuples_lang";
val _ = set_cs_¶_convs [] "'z_tuples_lang";
val _ = set_¶_vs_thms [] "'z_tuples_lang";
=TEX
\section{FURTHER WORK}
=SML
val Ûz__app_thmÝ = (
push_merge_pcs ["z_predicates","'z__set_lang",
	"'z_decl","'z_sets_ext_lang"];
set_goal([],ñµ a:U; x:U; f: U·
	(¶ f_x : U · a  f_x ± (x, f_x)  f ± (µ f_x1 :U · (x, f_x1)  f ´ f_x1 = f_x)) ´ a  f x®);
a(REPEAT strip_tac);
a(lemma_tac ñf_x = ¬f® ¬x®®);
(* *** Goal "1" *** *)
a(z_app_tac);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_prove_tac[]);
pop_pc();
save_thm("z__app_thm",(pop_thm())));
=TEX
=SML
val Ûz_app__thmÝ = (
push_merge_pcs ["z_predicates","'z__set_lang",
	"'z_decl","'z_sets_ext_lang"];
set_goal([],ñµ a:U; x:U; f: U·
	(¶ f_x : U · f_x  a ± (x, f_x)  f ± (µ f_x1 :U · (x, f_x1)  f ´ f_x1 = f_x)) ´ f x  a®);
a(REPEAT strip_tac);
a(lemma_tac ñf_x = ¬f® ¬x®®);
(* *** Goal "1" *** *)
a(z_app_tac);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
pop_pc();
save_thm("z_app__thm",(pop_thm())));
=TEX
\section{EPILOGUE}
=SML
end; (* of structure ZSetTheory *)
open ZSetTheory;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
local
	val cnv1 = simple_eq_match_conv1 (get_spec ¬$"Z'Í"®);
in
val Ûz_Í_convÝ : CONV = (fn tm =>
let	val (d,p,v) = dest_z_Í tm;
	val s1 = simple_eq_match_conv1 (get_spec tm) tm;
	val s2 = conv_rule (RIGHT_C(RAND_C(BINDER_C
		(ALL_SIMPLE_¶_C(fn tm =>
		let	val Âred = snd(dest_app(fst(dest_± tm)));
			val Âred_thm = seq_simple_Â_conv Âred
		in
		LIST_OP_C [
		((RAND_C (fn _ => Âred_thm)) THEN_C d_dpv_proj_conv),
		((RAND_C (fn _ => Âred_thm)) THEN_C p_dpv_proj_conv),
		(LEFT_C((RAND_C (fn _ => Âred_thm))THEN_C v_dpv_proj_conv))] tm
		end))))) s1;
in
	s2
end);
end;


local
	val spec = rewrite_rule[]
		(list_µ_elim[Ua]
		(rewrite_rule[]
		(get_spec ñ()®)));
in
val Ûz_thmÝ = save_thm("z_thm",
	conv_rule z_µ_elim_conv1
	(nth  (strip_±_rule spec)));
end;
