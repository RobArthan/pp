=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Language Expressions}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP042}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the derived rules of inference, conversions and tactics for the ProofPower Z Language set theory, tuples and cartesian products.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First versions.
\item [Issues 1.4 (15th September 1992)]
Changes to reflect  issue 1.6 of detailed design.
\item [Issues 1.5 (29th September 1992)]
Changes after comments, removal of HOL universals where
appropriate.
\item [Issues 1.7 (12th October 1992)]
Modified $z\_•\\ﬁ_thm$.
\item [Issues 1.8 (12th October 1992)]
Moved Library material to \cite{DS/FMU/IED/IMP083}.
\item [Issue 1.9 (26th October 1992)]
Changes after comments - rearrangement of material
amongst 041, 042 and 043. 

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a implementation for the 
derived rules of inference, conversions and tactics for
the ProofPower Z (see \cite{DS/FMU/IED/HLD015}) set theory, tuples and cartesian products.
This is called for in \cite{DS/FMU/IED/HLD016}.
The design is
given in \cite{DS/FMU/IED/DTD042}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the 
initial set of rules, conversions and tactics for the set theory, tuples and cartesian products of the ProofPower Z.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD042}.
\subsubsection{Deficiencies}
$z\_∏\_conv$ is comparatively slow compared to like functions.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure €ZExpressions› : ZExpressions = struct
=TEX
=SML
open ZGeneratedConstants;
val lthy = get_current_theory_name();
val _ = open_theory €"z_language_ps"›;
val _ = set_pc "z_predicates";
val _ = set_flag("z_type_check_only",false);
=TEX

\section{THE CODE}
\subsection{Utilities}
A precaution, lost outside of structure:
=SML
fun €save_thm›(a,b) = KernelInterface.save_thm(a, check_is_z_thm "save_thm" b);
fun €list_save_thm›(a,b) = KernelInterface.list_save_thm(a, check_is_z_thm "list_save_thm" b);
=SML
fun €list_eq› (eq : 'a * 'a -> bool) (a :: x) (b :: y) = 
	eq(a,b) andalso list_eq eq x y
| list_eq _ [] [] = true
| list_eq _ _ _ = false;
=TEX
Some universes:
=SML
val €Ua› = ÒUÆ; (* type = 'a SET *)
=TEX
Protected $¡$ conversion:
=SML
fun €prot_¡_conv› (nm:string) : CONV = 
	simple_¡_conv nm ORELSE_C (fn tm =>
	if is_simple_Ã tm
	then (let	val newnm = string_variant(map (fst o dest_var) (frees tm)) nm;
	in
		simple_¡_conv newnm tm
	end)
	else fail_conv tm);
=TEX
\subsubsection{Conversionals}
Apply through all $Ã$'s.
=SML
fun (€ALL_SIMPLE_Ã_C› (cnv:CONV) : CONV) tm = 
	(SIMPLE_Ã_C (ALL_SIMPLE_Ã_C cnv)
	ORELSE_C cnv) tm;
=TEX
Apply to the last $µ$ in a sequence.
=SML
fun €LAST_SIMPLE_µ_C› (conv:CONV): CONV = (fn tm =>
	if is_simple_µ (snd(dest_simple_µ tm))
	then (SIMPLE_BINDER_C (LAST_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
Diagnostic Conversional:
=SML
fun €DIAG_C› (caller:string) (conv:CONV):CONV = (fn tm =>
	(diag_string(caller ^ " " ^ string_of_term tm);
	conv tm)
);
=TEX
Apply a conversion to all conjuncts:
=SML
fun €±_C› (cnv:CONV) :CONV = (fn tm =>
	if is_± tm
	then APP_C(RAND_C(±_C cnv),±_C cnv) tm
	else cnv tm
);
=TEX
Apply a list of conversions, on to each argument of a nested
sequence of operators:
=FRULE 1 Conversional
LIST_OP_C
[cnv1,cnv2,cnv3,...]
¨op a1 (op a2 (op a3 ...))Æ
˜
˜
Ù (op a1 (op a2 (op a3 ...))) =
   op a1' (op a2' (op a3' ...))
=TEX
where
=GFT
cnv1 a1 = Ù a1 = a1'
cnv2 a2 = Ù a2 = a2'
cnv3 a3 = Ù a3 = a3'
 ...
=TEX
=SML
fun €LIST_OP_C› [cnv] = cnv
| LIST_OP_C ((cnv:: cnvl):CONV list) :CONV = 
	APP_C(RAND_C cnv, LIST_OP_C cnvl)
| LIST_OP_C [] = fail "LIST_±_C" 0 [];
=TEX
Rename a sequence of quantified variables:
=SML
fun €seq_binder_simple_¡_conv› [a]:CONV  = (
let	val nm = fst(dest_var a);
in
	RAND_C (prot_¡_conv nm)
end
) | seq_binder_simple_¡_conv (a::x) = (
let	val nm = fst(dest_var a);
in
	(RAND_C (prot_¡_conv nm)) THEN_C BINDER_C (seq_binder_simple_¡_conv x)
end
) | seq_binder_simple_¡_conv [] = id_conv;
=TEX
=SML
fun (€seq_simple_¬_conv›:CONV) (tm:TERM) = (
	(simple_¬_conv
	ORELSE_C 
	(RATOR_C seq_simple_¬_conv THEN_C simple_¬_conv)
	ORELSE_C
	(fn tm1 => term_fail "seq_simple_¬_conv" 27008 [tm1]))
	tm
);
=TEX
Change a free variable name:
=SML
fun €change_name_rule› from_nm to_nm thm = (
let	val fvs = map dest_var (frees(concl thm));
	val ty = lassoc3 fvs from_nm;
in
	simple_µ_elim (mk_var(to_nm, ty))
	(simple_µ_intro (mk_var(from_nm, ty)) thm)
end);
=TEX

\subsubsection{Projection Conversions}
=SML
val €dpvt_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,t,v]v"Æ))
		to 3));
local
	val cnjs = strip_±_rule(all_µ_elim dpvt_proj_thm);
in
	val (€d_dptv_proj_conv›,€p_dptv_proj_conv›,
		€t_dptv_proj_conv›, €v_dptv_proj_conv›) = 
		case (map (fn t => simple_eq_match_conv
			(all_µ_intro t)) cnjs) of
		[a,b,c,d] => (a,b,c,d)
		| _ => fail "" 0 [];
end;
=TEX
=SML
val €dpv_proj_thm›:THM = all_µ_intro(list_±_intro
	(strip_±_rule (all_µ_elim (get_spec ¨$"Z'S[d,p,v]v"Æ))
		to 2));
local
	val cnjs = strip_±_rule(all_µ_elim dpv_proj_thm);
in
	val €d_dpv_proj_conv› = simple_eq_match_conv1 
		(all_µ_intro (hd cnjs));
	val €p_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl cnjs)));
	val €v_dpv_proj_conv› = simple_eq_match_conv1
		(all_µ_intro (hd (tl (tl cnjs))));
end;
=TEX
=SML
local
	val cnjs = strip_±_rule(all_µ_elim (get_specÒ(x,y).1Æ));
in
val €tuple2_1_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd cnjs));
val €tuple2_2_proj_conv› = simple_eq_match_conv1 (all_µ_intro (hd (tl cnjs)));
;
end;
=TEX
=SML
fun €all_undisch_rule› (thm:THM) : THM = (
	if is_¥(concl thm)
	then all_undisch_rule (undisch_rule thm)
	else thm
);
=TEX
\section{THE IMPLEMENTATION}
\subsection{Definite Description}
=FRULE 1 Conversion
ante_∂_¥_conv
¨(∂ x ∑ p[x]) ¥ yÆ
˜
˜
Ù ((∂ x ∑ p[x]) ¥ y) § µ x ∑ p[x] ¥ y
=TEX
=SML
val €ante_∂_¥_thm›  = (
push_goal ([],¨µ p q ∑ (($∂ p) ¥ q) § µ x ∑ p x ¥ qÆ);
push_pc "hol1";
a(REPEAT µ_tac);
a(pure_once_rewrite_tac[prove_rule[]¨p = (Ã y ∑ p y)Æ]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (ante_tac o rewrite_rule[]));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (asm_tac o rewrite_rule[]));
a(asm_fc_tac[]);
pop_pc();
pop_thm());

val €ante_∂_¥_conv› : CONV = (fn tm =>
let	val (∂p,q) = dest_¥ tm;
	val xnm = fst(dest_var(fst(dest_simple_∂ ∂p)));
	val p = snd(dest_app ∂p);
	val s1 = list_µ_elim[p,q] ante_∂_¥_thm;
	val s2 = conv_rule(RIGHT_C(RAND_C(prot_¡_conv xnm
		THEN_C SIMPLE_Ã_C(LEFT_C simple_¬_conv)))) s1;
in
	eq_trans_rule (refl_conv tm) s2
end);
=TEX
=SML
fun (seq_ante_∂_¥_conv:CONV) (tm:TERM) = ((
	(ante_∂_¥_conv THEN_C BINDER_C seq_ante_∂_¥_conv)
	ORELSE_C id_conv)
	tm
);
=GFT Example
ante_∂_¥_conv ¨(∂ x y z ∑ f x y z) ¥ gÆ;
seq_ante_∂_¥_conv ¨(∂ x y z ∑ f x y z) ¥ gÆ;

=TEX
=INLINEFT
¨$"Z'Õ"Æ
=TEX
{} is a sort of marker function for Z $Õ$ constructions.
=SML
val €z'Õ_thm› = (
push_goal([],¨µ s x ∑ (µ y ∑ y ç s ¥ y = x) ± (x ç s) ¥ ($"Z'Õ" s = x)Æ);
push_pc "hol1";
a(REPEAT strip_tac);
a(LEMMA_T ¨s = {x}Æ (fn x => rewrite_tac [z'Õ_def,x]));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
pop_pc();
pop_thm());
=TEX
=SML
val €hd_last_µ_conv› : CONV = (fn tm =>
let 	val (hdv,bdy) = dest_simple_µ tm;
	val (vs,bdy') = strip_simple_µ bdy;
in
	µ_reorder_conv (list_mk_µ((vs @ [hdv]), bdy')) tm
end);
=TEX
=SML
local

val thm1 = (
push_goal([],¨µ a b c d ∑ 
	(µ y ∑ (a ± b ± (c = y)) ¥ (y = d)) §
	(a ± b ¥ (c = d))Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o µ_elim ¨cÆ));
(* *** Goal "2" *** *)
a(POP_ASM_T(asm_rewrite_thm_tac o eq_sym_rule));
pop_thm());

	val cnv1 = simple_eq_match_conv1 thm1; 
in
fun €z_Õ_rule› (tm : TERM) :THM = (
let	val (d,p,v) = dest_z_Õ tm
		handle complaint =>
		pass_on complaint "dest_z_Õ" "z_Õ_rule";
	val vars =  map (fst o dest_var)
		(list_variant(map mk_var (term_vars tm))
		(map (fn x => mk_var(x,BOOL))["x","x","y"]));
	val var_x = hd (tl vars);
	val var_x1 = hd vars;
	val var_y = hd (tl(tl vars));
	val spec = conv_rule (BINDER_C(RIGHT_C(RAND_C(RAND_C
		(prot_¡_conv var_x))))) (get_spec tm);
	val s1 = simple_eq_match_conv1 spec tm;
	val s2 = conv_rule (RIGHT_C(RAND_C(BINDER_C
		(ALL_SIMPLE_∂_C(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		((RAND_C (fn _ => ¬red_thm)) THEN_C d_dpv_proj_conv),
		((RAND_C (fn _ => ¬red_thm)) THEN_C p_dpv_proj_conv),
		(LEFT_C((RAND_C (fn _ => ¬red_thm))THEN_C v_dpv_proj_conv))] tm
		end))))) s1;
	val was_sig = fst(strip_Ã(snd(dest_app tm)));
	val s3 = conv_rule (RIGHT_C(RAND_C(BINDER_C
		(seq_binder_simple_¡_conv was_sig)))) s2;
	val new_set = snd(dest_app(snd(dest_eq (concl s3))));
	val z'Õ_thm' = conv_rule (BINDER_C
		(RAND_C (prot_¡_conv var_x1 THEN_C
		SIMPLE_Ã_C (LEFT_C(LEFT_C(RAND_C(prot_¡_conv var_y))))))) 
			z'Õ_thm;
	val s4 = conv_rule (BINDER_C(RIGHT_C(LEFT_C(
		fn tm => (if tm =$ snd(dest_eq (concl s3))
			then eq_sym_rule s3
			else term_fail "z_Õ_rule" 0 [])))))
		(µ_elim new_set z'Õ_thm');
	val s5 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(BINDER_C((LEFT_C
				simple_ç_comp_conv)
			THEN_C seq_ante_∂_¥_conv)),
			simple_ç_comp_conv THEN_C z_∂_intro_conv)))) s4;
	val s6 = conv_rule(BINDER_C(LEFT_C(LEFT_C(
		hd_last_µ_conv THEN_C
		LAST_SIMPLE_µ_C cnv1 THEN_C
		z_µ_intro_conv)
		))) s5;
in
	check_is_z_thm "z_Õ_rule" s6
end);
end;
=TEX
=GFT Example
z_Õ_rule ÒÕ x,y:X;z:Y;p:X | z ∑ x = yÆ;
z_Õ_rule ÒÕ x,y:X;z:Y;p:X | z ∑ p(x = y)Æ;
=TEX

\subsection{Functional Application}
=SML
local
val _ = push_pc "hol1";
val thm1 = simple_eq_match_conv1 z'app_def Òf aÆ;
val thm2 = all_µ_intro(
		rewrite_rule[] (
		µ_elim ¨{f_a:'b|Ò(¨a:'aÆ,¨f_a:'bÆ) ç fÆ}Æ 
		z'Õ_thm));
val thm3 = (push_goal([],Ò(µ f_a:U | (a, f_a) ç f ∑ f_a = x) ±
	(a,x) ç f
	¥
	(f a = x)Æ);
a(REPEAT strip_tac);
a(rewrite_tac[thm1]);
a(strip_asm_tac(list_µ_elim[¨aÆ,¨fÆ,¨xÆ] thm2));
a(DROP_NTH_ASM_T 4 (strip_asm_tac o conv_rule z_µ_elim_conv1));
a(asm_fc_tac[]);
pop_thm());
val _ = pop_pc();		
in
val €z_app_thm› = save_thm("z_app_thm", all_z_µ_intro thm3);
end;

=SML
local
	val thm1 = conv_rule z_µ_elim_conv1 z_app_thm;
in
fun €local_z_app_rule› tm = (
let	val (f,a) = dest_z_app tm;
	val vs = map mk_var(term_vars tm);
	val x' = variant vs (mk_var("x",type_of tm));
in
	simple_µ_intro x' (list_µ_elim [a,f,x'] thm1)
end);
end;
=TEX
=SML
local
	val thm1 = taut_rule ¨µ x ∑ x § (x § T)Æ;
	val thm2 = conv_rule z_µ_elim_conv1 z_app_thm;
	val cnv1 = simple_eq_match_conv1 thm1;
in
fun (€z_app_tac› : TACTIC) ((asms,conc):GOAL) = (
	if not(is_z_eq conc orelse is_z_§ conc) andalso is_z_app conc
	then (conv_tac cnv1 THEN z_app_tac)(asms,conc)
	else
let	val (fa,v) = dest_z_eq conc
		handle complaint as (Fail _) =>
		(dest_z_§ conc
		handle complaint as (Fail _) =>
		(divert complaint "dest_z_§" "z_app_tac" 42002 []));
in
	CHECK_IS_Z_T "z_app_tac"
	(if is_z_app fa
	then (let val (f,a) = dest_z_app fa;
		in
		¥_thm_tac (list_µ_elim [a,f,v] thm2)
	end)
	else if is_z_app v
	then (let val (f,a) = dest_z_app v;
		val v = fa
	in
		¥_thm_tac (conv_rule(RIGHT_C eq_sym_conv)
			(list_µ_elim [a,f,v] thm2))
	end)
	else fail "z_app_tac" 42002 [])(asms,conc)
end);
end;
=GFT Example
set_goal([],Òp 1 = 2Æ);
a(z_app_tac);
set_goal([],Ò2 = p 1Æ);
a(z_app_tac);
set_goal([],Ò¨r:(˙, BOOL) $"Z'T[2]" SETÆ 1Æ);
a(z_app_tac);
drop_main_goal();
=TEX
=SML
=SML
local
val a_z_app_thm = (
push_goal([],¨µ (f:('a, 'b) $"Z'T[2]" SET) (a:'a) ∑ 
	Òf a = (Õ f_a :U | (a,f_a) ç f ∑ f_a)ÆÆ);
push_pc "hol1";
a(REPEAT µ_tac);
let val (lhs,rhs) = dest_eq(snd(top_goal()));
in
a(rewrite_tac[dpv_proj_thm, get_spec lhs, get_spec rhs])
end;
a(conv_tac (ONCE_MAP_C (DECL_C dec_pred_conv)));
a(conv_tac (ONCE_MAP_C ç_u_lang_conv));
a(rewrite_tac[]);
a(conv_tac (ONCE_MAP_C prove_∂_conv));
a(rewrite_tac[]);
pop_pc();
pop_thm());
in
val €z_app_conv› :CONV = simple_eq_match_conv1 a_z_app_thm
	ORELSE_C (fn tm => term_fail "z_app_conv" 47190 [tm]);
end;
=TEX
=GFT Example
z_app_conv Ò1 + 2Æ;
=TEX

\subsection{Concerning Ã}
=SML
local
val x = mk_var("x",type_of Ò(x,y)Æ);
in
val €p1_q2_thm› = all_µ_intro(
push_goal([],Ò((p = ëxÆ.1) ± (q = ëxÆ.2)) = ((p,q) = ëxÆ)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_specÒ(x,y)Æ]);
(* *** Goal "2" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_specÒ(x,y)Æ]);
(* *** Goal "3" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_specÒ(x,y)Æ]);
pop_thm());
end;
=TEX
=SML
local

	val z'Ã_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		((fn tm => 
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv),
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv)
		] tm
		end)
		THEN_C RIGHT_C(RAND_C (simple_eq_match_conv1 p1_q2_thm))));

	val z'seta_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		(fn tm => 
		let val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dpv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dpv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dpv_proj_conv)
		] tm
		end
		));
in
val €z_Ã_conv› : CONV = (fn tm =>
let	val (d,p,v) = dest_z_Ã tm
		handle complaint =>
		pass_on complaint "dest_z_Ã" "z_Ã_conv";
	val was_sig = fst(strip_Ã(snd(dest_app tm)));
	val s1 = get_spec tm;
	val s2 = simple_eq_match_conv1 s1 tm;
	val s3 = conv_rule (RIGHT_C z'Ã_conv1) s2;
	val s4 = conv_rule (RIGHT_C(BINDER_C 
		(seq_binder_simple_¡_conv was_sig))) s3;
	val v' = fst(dest_eq(snd(dest_±(snd(dest_±(snd(strip_∂
		(snd(dest_set_comp(snd(dest_eq(concl s4))))))))))));
	val tar_tm = mk_z_seta(d,p,v');
	val s5 = seta_gen_semantic_const tar_tm;
	val s6 = simple_eq_match_conv1 s5 tar_tm;
	val s7 = conv_rule(RIGHT_C z'seta_conv1) s6;
	val s8 = conv_rule (RIGHT_C(BINDER_C 
		(seq_binder_simple_¡_conv was_sig))) s7;
	val s9 = eq_trans_rule s4 (eq_sym_rule s8);
in
	check_is_z_thm "z_Ã_conv" s9
end);
end;
=TEX
=GFT Example
z_Ã_conv ÒÃ x,y:X;a:Y | f x ∑ g y aÆ;
z_Ã_conv Ò(Ã [z:Y;x,y : X| x = y] | g x ∑ f z x)Æ;
z_Ã_conv Ò(Ã [x,y : X | x = y] | g x ∑ f x)Æ;
=TEX
Replace a single HOL universal by a single Z universal,
no declarations, etc, present.
=SML
local
	val thm1 = all_µ_intro(set_goal([], Òx § (((y ç U) ± true) ¥ x)Æ);
		a(conv_tac (MAP_C ç_u_lang_conv));
		a(PC_T1 "hol" rewrite_tac[]);
		pop_thm());
in
fun €z_µ_intro_1_var› thm = (
let	val (x,bdy) = dest_µ(concl thm);
	val s1 = simple_µ_elim x thm;
	val s2 = §_mp_rule (list_µ_elim[concl s1,x] thm1) s1;
in
	z_µ_intro s2
end);
end;
=IGN
z_µ_intro_1_var (asm_rule ¨µ x ∑ (x = Ò3Æ) ¥ (x = Ò4Æ)Æ);
=SML
local
	val z'Ã_conv1 = ALL_SIMPLE_∂_C
		(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_1_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_2_proj_conv
		] tm
		end)
		THEN_C z_∂_intro_conv;
in
fun €z_¬_rule› (tm :TERM):THM  = (
let	val (lam,arg) = dest_z_app tm
		handle complaint =>
		divert complaint "dest_z_app" "z_¬_rule" 42008 
			[fn () => string_of_term tm];
	val (d,p,v) = dest_z_Ã lam
		handle complaint =>
		divert complaint "dest_z_Ã" "z_¬_rule" 42008 
			[fn () => string_of_term tm];
	val was_sig = fst(strip_Ã(snd(dest_app lam)));
	val s1 = (local_z_app_rule tm);
	val s2 = get_spec lam;
	val cnv1 = RIGHT_C (simple_eq_match_conv1 s2) THEN_C
		simple_ç_comp_conv THEN_C 
		seq_binder_simple_¡_conv was_sig THEN_C
		z'Ã_conv1;
	val s3 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(RAND_C(BINDER_C(LEFT_C cnv1))),
		cnv1)))) s1;
	val s4 = z_µ_intro_1_var s3;
in
	check_is_z_thm "z_¬_rule" s4
end);
end;
=GFT Example
z_¬_rule Ò(Ã x,y : X; z:Y | x = y ∑ f z x) (1,2,g)Æ;
z_¬_rule Ò(Ã x : X | f x ∑ g x) yÆ;
z_¬_rule Ò(Ã [x,y : X; z:Y| x = y] | g x ∑ f z x) (x ¶ 1,y ¶ 2,z ¶ g)Æ;
z_¬_rule Ò(Ã x : X ∑ y) xÆ;
z_¬_rule Ò(Ã x : X ∑ y) zÆ;
z_¬_rule Ò(Ã x : X ∑( µ z : U ∑ f x y z)) zÆ;
=TEX
=SML
local
	val ¥_thm = taut_rule¨µ x ∑ x ¥ xÆ;

	fun local_rule thm gl = (
	let 	val (a,b) = dest_¥ gl;
		val (x,bdy) = dest_eq(concl thm);
		val ithm = simple_µ_elim b ¥_thm;
	in
		subst_rule[(eq_sym_rule thm,x)] gl ithm
	end);
	val rwc = prim_rewrite_conv empty_net
		initial_rw_canon
		TOP_MAP_C
		[]
		[±_rewrite_thm, eq_rewrite_thm];
	val rw_tac2_thm = tac_proof(([],
		¨µ t∑ ≥ (F ± t) ± ≥ (t ± F) ±
		(µ x∑ x = x § T) ± (F ¥ t) ±
		(≥ T § F) ± (≥ F § T)Æ),
		rewrite_tac[]);
	val rw_rule = prim_rewrite_rule empty_net
		initial_rw_canon
		TOP_MAP_C
		[]
		[rw_tac2_thm, ≥_§_thm];
	val rw_tac2 = (prim_rewrite_tac	
		(make_net(flat(map (cthm_eqn_cxt initial_rw_canon)
			[rw_tac2_thm])))
		initial_rw_canon 
		TOP_MAP_C
		[]);
in
fun local_simple_∂_equation_conv witness tm = (
let	val (x,bdy) = dest_simple_∂ tm;
	val (xnm,xty) = dest_var x;
	val new_term = var_subst [(witness,x)] bdy;
	val new_term_rw = rwc new_term;
	val new_term' = snd(dest_eq(concl new_term_rw));
	val thm = tac_proof(([],mk_§(tm,new_term')),
		§_T2 (fn thm =>
		t_tac ORELSE
		conv_tac(fn ag => eq_sym_rule new_term_rw)
		THEN
		SIMPLE_∂_THEN ante_tac thm
		THEN (
			let val x' = variant (frees(concl thm) @ frees new_term) x;
			in
			CASES_T2 (mk_eq(x',witness))
			(fn thm1 => fn (seqasms,gl) =>
			accept_tac (local_rule thm1 gl)(seqasms,gl))
			(fn thm1 => rw_tac2[
				thm1,
				((rw_rule thm1) handle (Fail _) => t_thm),
				≥_eq_sym_rule thm1])
			end)			
		)
		(fn thm =>
		simple_∂_tac witness THEN accept_tac 
			(§_mp_rule (eq_sym_rule new_term_rw) thm)
		))
in
	eq_trans_rule (refl_conv tm) thm
end);
end;
=TEX
=SML
local
	val z'Ã_conv1 = BINDER_C
		(fn tm =>
		let	val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dptv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dptv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C t_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_1_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dptv_proj_conv) THEN_C
		RIGHT_C tuple2_2_proj_conv
		] tm
		end);

val cnv2 = simple_eq_match_conv1 (tac_proof(([],
		¨µ a b c d e ∑ 
		(a ± b ± c ± (d = e) ¥ (e = d)) § TÆ),
		REPEAT strip_tac THEN asm_rewrite_tac[]))
	ORELSE_C
	simple_eq_match_conv1 (tac_proof(([],
		¨µ a b d e ∑ 
		(a ± b ± (d = e) ¥ (e = d)) § TÆ),
		REPEAT strip_tac THEN asm_rewrite_tac[]));
val cnv3 = simple_eq_match_conv1 (prove_rule[]¨(µ x ∑ T) § TÆ);
val cnv4 = simple_eq_match_conv1 (prove_rule[]¨µ x ∑ (T ± x) § xÆ);
val cnv5 = simple_eq_match_conv1 (taut_rule ¨µ x ∑ ((T ± T) ¥ x) § xÆ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x y ∑ ((T ± y) ¥ x) § (y ¥ x)Æ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x y ∑ ((y ± T) ¥ x) § (y ¥ x)Æ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x y z ∑ ((y ± z) ¥ x) § (z ¥ y ¥ x)Æ)
	ORELSE_C
	simple_eq_match_conv1 (taut_rule ¨µ x ∑ (T ¥ x) § xÆ)
	ORELSE_C 
	id_conv;
in
=TEX
=SML
fun €z_¬_conv› (tm :TERM):THM  = (
let	val (lam,arg) = dest_z_app tm;
	val (d,p,v) = dest_z_Ã lam;
	val was_sig = fst(strip_Ã(snd(dest_app lam)));
	val d' = dest_z_decl d;
	val dummy = if (length d' <> 1) orelse (not(is_z_dec (hd d'))) orelse 
			length(fst(dest_z_dec (hd d'))) <> 1
		then term_fail "z_¬_conv" 42012 [tm]
		else ();
	val (singx,aset) = (hd ** Combinators.I) (dest_z_dec (hd d'));
	val s1 = (local_z_app_rule tm);
	val s2 = get_spec lam;
	val cnv1 = RIGHT_C (simple_eq_match_conv1 s2) THEN_C
		simple_ç_comp_conv THEN_C 
		seq_binder_simple_¡_conv was_sig THEN_C
		z'Ã_conv1;
	val s3 = conv_rule(BINDER_C(LEFT_C(
		APP_C(RAND_C(RAND_C(BINDER_C(LEFT_C cnv1))),
		cnv1)))) s1;
	val resu = var_subst[(arg,singx)] v;
	val s4 = simple_µ_elim resu s3;
	val s5 = conv_rule(LEFT_C(APP_C(
		RAND_C (z_µ_elim_conv THEN_C
		BINDER_C(LEFT_C(RIGHT_C (local_simple_∂_equation_conv arg))
		THEN_C cnv2)
		THEN_C cnv3),
		(local_simple_∂_equation_conv arg) THEN_C 
			((LEFT_C (DECL_C (dec_pred_conv THEN_TRY_C ç_u_lang_conv)))
		ORELSE_C (DECL_C (dec_pred_conv THEN_TRY_C ç_u_lang_conv))))
		THEN_C cnv4)) s4;
	val s6 = all_undisch_rule(conv_rule cnv5 s5);
in
	check_is_z_thm "z_¬_conv" s6
end
handle complaint =>
list_divert complaint "z_¬_conv" [
	("dest_z_app", 42012, [fn () => string_of_term tm]),
	("dest_z_Ã", 42012, [fn () => string_of_term tm])]
);
end;
=TEX
=GFT Example
z_¬_conv Ò(Ã x : X | f x ∑ g x) yÆ;
z_¬_conv Ò(Ã p : U | f p ∑ g p q) yÆ;
z_¬_conv Ò(Ã p : U  ∑ g p q) yÆ;
z_¬_conv Ò(Ã x : X ∑ y) zÆ;
z_¬_conv Ò(Ã x : X ∑ y) xÆ;
=TEX

\subsection{Sets}
=SML
val €z_sets_ext_thm› : THM = save_thm ("z_sets_ext_thm",
	all_z_µ_intro(
push_goal([],Ò(x = y) = (µz: U ∑ ((z ç x) § (z ç y)))Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T (ante_tac o conv_rule z_µ_elim_conv1));
a(PC_T1 "hol1" rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €z__thm› : THM = save_thm("z__thm", all_z_µ_intro(
push_goal([],Ò(t ç  u) = (µz: U ∑ ((z ç t) ¥ (z ç u)))Æ);
a(rewrite_tac[z'app_def, z'_def]);
a(PC_T1 "hol1" rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
pop_thm()));
=TEX
=SML
local
	val z'seta_conv1 = BINDER_C(ALL_SIMPLE_∂_C
		(fn tm => 
		let val ¬red = snd(dest_app(fst(dest_± tm)));
			val ¬red_thm = seq_simple_¬_conv ¬red
		in
		LIST_OP_C [
		RAND_C (fn _ => ¬red_thm) THEN_C d_dpv_proj_conv,
		RAND_C (fn _ => ¬red_thm) THEN_C p_dpv_proj_conv,
		LEFT_C(RAND_C (fn _ => ¬red_thm) THEN_C v_dpv_proj_conv)
		] tm
		end
		));
in
val €z_ç_seta_conv› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
	val was_sig = fst(strip_Ã(snd(dest_app s)));
	val (d,p,t) = dest_z_seta s;
	val spec = seta_gen_semantic_const s;
	val s1 = (RAND_C 
		((simple_eq_match_conv1 spec) THEN_C
		z'seta_conv1) THEN_C
		simple_ç_comp_conv) tm;
	val s2 = conv_rule (RIGHT_C 
		((seq_binder_simple_¡_conv was_sig)
		THEN_C z_∂_intro_conv)) s1;
in
	check_is_z_conv_result "z_ç_seta_conv" s2
end
handle complaint =>
list_divert complaint "z_ç_seta_conv"
	[("dest_z_ç",42001,[fn () => string_of_term tm]),
	("dest_z_seta",42001,[fn () => string_of_term tm])]);
end;
=IGN
z_ç_seta_conv Òp ç {x:X∑(x,x)}Æ;
z_ç_seta_conv Ò(1,2) ç {x:X;y:Y∑(x,y)}Æ;
=TEX
=SML
local
	val thm1 = (
	push_goal([],¨µ (x:'a)∑ Ò(x ç {} § false)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm2 = (
	push_goal([],¨µ (x:'a) (h:'a) ∑ Ò(x ç {h} § x = h)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	pop_thm());
	val thm3 = (
	push_goal([],¨µ (x:'a) (h:'a) (t:'a LIST) ∑ 
	Ò(x ç  ¨Z'Setd (Cons h t)Æ) § (x = h ≤ x ç ¨Z'Setd tÆ)ÆÆ);
	a(rewrite_tac[get_spec Ò{}Æ] THEN
	PC_T1 "hol1" rewrite_tac[]);
	a(REPEAT strip_tac);
	pop_thm());

	val cnv1 = simple_eq_match_conv1 thm1;
	val cnv2 = simple_eq_match_conv1 thm2;
	val cnv3 = simple_eq_match_conv1 thm3;
	fun cnv4 tm = (cnv2 ORELSE_C
		(cnv3 THEN_C RIGHT_C cnv4)
		ORELSE_C (fn tm => term_fail "z_ç_setd_conv"
			42008 [tm])) tm;
	val thm5 = pc_rule1 "hol1" prove_rule[] ¨µ x y ∑ ((x = x) ≤ y) § TÆ;
	val cnv5 = simple_eq_match_conv1 thm5;
	val thm6 = taut_rule ¨µ x ∑ (x ≤ T) § TÆ;
	val cnv6 = simple_eq_match_conv1 thm6;
	val thm7 = pc_rule1 "hol1" prove_rule [] ¨µ x ∑ (x =x) § TÆ;
	val cnv7 = simple_eq_match_conv1 thm7;
	fun cnv8 tm = (
	let	val (p,q) = dest_≤ tm;
		val (x1,h) = dest_eq p;
	in
		if x1 ~=$ h
		then cnv5 tm
		else (RIGHT_C cnv8 THEN_C cnv6) tm
	end
	handle (Fail _) =>
	cnv7 tm);

in
val €z_ç_setd_conv1› : CONV = (fn tm =>
let	val (x,s) = dest_z_ç tm;
	val (_,tml) = dest_z_setd s;
	val dummy = if x term_mem tml
		then ()
		else term_fail "z_ç_setd_conv1" 42009 [tm];
	val s1 = cnv4 tm
		handle complaint =>
		pass_on complaint "z_ç_setd_conv" "z_ç_setd_conv1";
	val s2 = conv_rule (RIGHT_C cnv8) s1;
in
	check_is_z_conv_result "z_ç_setd_conv1" 
	s2
end
handle complaint =>
list_divert complaint "z_ç_setd_conv1"
	[("dest_z_ç",42009,[fn () => string_of_term tm]),
	("dest_z_setd",42009,[fn () => string_of_term tm])]);
end;


=IGN
z_ç_setd_conv Ò3 ç {2,3,4}Æ;
z_ç_setd_conv Ò3 ç {4}Æ;
z_ç_setd_conv Ò3 ç {}Æ;
z_ç_setd_conv1 Ò3 ç {2,3,4}Æ;
z_ç_setd_conv1 Ò3 ç {3}Æ;
=TEX
=SML
val _ = delete_pc "'build_z_sets" handle (Fail _) => ();
val _ = new_pc "'build_z_sets";
val _ = set_rw_eqn_cxt 
	[(Òx ç ¨y (Ã z ∑ w):'a SETÆÆ,z_ç_seta_conv),
	 (Òx ç ¨Z'Seta[0] y:'a SETÆÆ,z_ç_seta_conv),
	 (¨(Ã x ∑ y) zÆ,simple_¬_conv),
	 (Òx ç ¨Z'Setd yÆÆ,z_ç_setd_conv1)] "'build_z_sets";
val _ = add_rw_thms [µ_rewrite_thm] "'build_z_sets";
val _ = set_pr_conv z_basic_prove_conv "'build_z_sets";
=TEX
=SML
fun €tt_to_∂_vs›  (ty : TYPE) : (string * (TERM list * THM)) = (
let	val (abs,cons) = get_tuple_info ty;
	val def_thm = get_spec (hd cons);
	val abs_nm = fst(dest_const abs);
in
	(abs_nm,(cons, def_thm))
end);
=TEX
=SML
val _ =set_∂_vs_thms [tt_to_∂_vs î'X SET $"Z'T[1]"Æ] "'build_z_sets";

val _ = set_merge_pcs ["z_predicates","'build_z_sets"];
=TEX
\section{TUPLES}
=SML
local
	fun aux thm [] [] = thm
	| aux thm (a::x)(b::y) = aux (mk_app_rule thm (asm_rule (mk_z_eq (a, b)))) x y
	| aux _ _ _ = error "z_tuple_lang_eq_conv" 0 [];
	
	fun aux1 tm [] [] = tm
	| aux1 tm (a::x)(b::y) = aux1 (mk_z_±(mk_z_eq (a,b), tm)) x y
	|aux1 _ _ _ = error "z_tuple_lang_eq_conv" 0 [];
in
val €z_tuple_lang_eq_conv› : CONV = (fn tm =>
let	val (lhs,rhs) = dest_z_eq tm
		handle (Fail _) =>
		term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val s0 = if is_z_tuple lhs andalso is_z_tuple rhs
		then refl_conv tm
		else term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val tm' = snd(dest_eq(concl s0));
	val (lhs,rhs) = dest_z_eq tm';
	val dummy = if is_z_tuple lhs andalso is_z_tuple rhs
		then ()
		else term_fail "z_tuple_lang_eq_conv" 42003 [tm];
	val spec = get_spec lhs;
	val proj_thms = map all_µ_intro
		(rev(tl(rev(strip_±_rule(all_µ_elim spec)))));
	val (tcons,tproj) = get_tuple_info (type_of lhs);
	val lhs_bits = dest_z_tuple lhs;
	val rhs_bits = dest_z_tuple rhs;
	val tcons' = fst(strip_app lhs);
	val ty_insts = fst(term_match tcons' tcons);
	val s1 = aux (refl_conv tcons') lhs_bits rhs_bits;
	val rlhs_bits = rev lhs_bits;
	val rrhs_bits = rev rhs_bits;
	val res = aux1 (mk_z_eq(hd rlhs_bits, hd rrhs_bits))
		(tl rlhs_bits) (tl rrhs_bits);
	val s2 = strip_±_rule (asm_rule res);
	val s3 = fold (uncurry prove_asm_rule) s2 s1;
	val s4 = asm_rule tm';
	val s5 = map (fn (x,xthm) => 
		conv_rule(APP_C(RAND_C(simple_eq_match_conv1 xthm),
			simple_eq_match_conv1 xthm))
		(app_fun_rule (inst [] ty_insts x) s4)) 
		(combine tproj proj_thms);
	val s6 = list_±_intro s5;
	val s7 = §_intro(all_¥_intro s6) (all_¥_intro s3);
in
	check_is_z_conv_result "z_tuple_lang_eq_conv" 
	(eq_trans_rule s0 s7)
end);
end;
=TEX
=IGN
z_tuple_lang_eq_conv Ò(1,2,3) = (p,q,r)Æ;
=SML
val €z_tuple_lang_selection_conv› : CONV = (fn tm =>
let	val (bdy,n) = dest_z_selât tm
		handle complaint =>
		pass_on complaint "dest_z_selât" "z_tuple_lang_selection_conv";
	val spec = get_spec tm;
	val s0 = (if is_z_tuple bdy
		then refl_conv tm
		else term_fail "z_tuple_lang_selection_conv" 42006 [tm]);
	val tm' = snd(dest_eq(concl s0));
	val (bdy,n) = dest_z_selât tm'; 
	val xi = dest_z_tuple bdy;
	val proj_thm = nth (n-1) 
		(strip_±_rule(list_µ_elim (bdy :: xi) spec));
in
	check_is_z_conv_result "z_tuple_lang_selection_conv"
	(eq_trans_rule s0 proj_thm)
end);
=TEX
=IGN
z_tuple_lang_selection_conv Ò(1,2,3,4).2Æ;
=SML
val €z_tuple_lang_intro_conv› : CONV = (fn tm =>
let	val s0 = if is_z_tuple tm
		then refl_conv tm
		else term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val tm' = snd(dest_eq(concl s0));
	val xi = dest_z_tuple tm'
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val tuple= fst(dest_z_selât(hd xi))
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val spec = all_µ_elim (µ_elim tuple (get_spec tm'))
		handle (Fail _) =>
		term_fail "z_tuple_lang_intro_conv" 42005 [tm];
	val cthm = hd(rev(strip_±_rule spec));
in
		check_is_z_conv_result "z_tuple_lang_intro_conv"
		(eq_trans_rule s0 cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_lang_intro_conv" 42005
			[fn () => string_of_term tm])
end);
=TEX
=IGN
z_tuple_lang_intro_conv Ò((1,2,3).1,(1,2,3).2,(1,2,3).3)Æ;
=SML
val €z_tuple_selection_intro_conv› : CONV = (fn tm =>
let	val (tcons,tprojs) = get_tuple_info (type_of tm)
		handle (Fail _) =>
		term_fail "z_tuple_selection_intro_conv" 42004 [tm];
	val spec = all_µ_elim (µ_elim tm (get_spec tcons));
	val cthm = eq_sym_rule(hd(rev(strip_±_rule spec)));
in
		check_is_z_conv_result "z_tuple_selection_intro_conv"
		(eq_trans_rule (refl_conv tm) cthm
		handle complaint =>
		divert complaint "eq_trans_rule" "z_tuple_lang_intro_conv" 42004
			[fn () => string_of_term tm])
end);
=TEX
=IGN
z_tuple_selection_intro_conv Ò(1,2,3)Æ;
=TEX

\section{CARTESIAN PRODUCTS}

=SML
local
	fun aux count 0 avoid = []
	| aux count n avoid = 
=SMLLITERAL
		if ("tâ" ^ string_of_int count) mem avoid
		then aux (count + 1) n avoid
		else ("tâ" ^ string_of_int count) :: aux (count + 1) (n-1) avoid;
=SML
	val t_±_thm = taut_rule ¨µ x ∑ T ± x § xÆ;
	val cnv1 :CONV = simple_eq_match_conv1
	(conv_rule z_µ_elim_conv1 z_sets_ext_thm);

in
=TEX
=SML
val €z_∏_conv› : CONV = (fn tm =>
let	val si = dest_z_∏ tm
		handle complaint =>
		pass_on complaint "dest_z_∏" "z_∏_conv";
	val spec = list_µ_elim si (get_spec tm);
	val tis = aux 1 (length si) (map fst(term_vars tm));
	val elem_tys = map (fn x => hd(snd(dest_ctype(type_of x)))) si;
	val ti = map mk_var (combine tis elem_tys);
	val ti_decs = map (fn (x,y) => mk_z_dec([x],y)) (combine ti si);
	val res = mk_z_seta(mk_z_decl ti_decs,
		mk_t,
		mk_z_tuple ti);
	val dummy = seta_gen_semantic_const res;
	val (tcons,tprojs) = get_tuple_info(hd(snd(dest_ctype(type_of tm))));
=TEX
=SML
	val s1 = tac_proof(([],mk_z_eq(tm,res)),
		conv_tac(cnv1 THEN_C z_µ_elim_conv1) THEN
		simple_µ_tac THEN
		(fn (asms,conc) => let	 val t = fst(dest_z_ç(snd(dest_z_§ conc)))
			val lthm = z_tuple_selection_intro_conv t;
		in
		conv_tac(APP_C(RAND_C(LEFT_C(fn _ => lthm)),
			LEFT_C(fn _ => lthm))) (asms,conc)
		end)
		THEN conv_tac (APP_C(RAND_C
			(RIGHT_C (fn _ => spec) THEN_C
			ç_comp_conv),
			z_ç_seta_conv))
		THEN conv_tac (APP_C(RAND_C
			(±_C(LEFT_C z_tuple_lang_selection_conv)),
			z_∂_elim_conv THEN_C
			ALL_SIMPLE_∂_C 
			(LEFT_C (DECL_C dec_pred_conv) THEN_C
			RIGHT_C(
			simple_eq_match_conv1 t_±_thm THEN_C
			 z_tuple_lang_eq_conv) )
			THEN_C basic_prove_∂_conv))
	THEN taut_tac)
in
	check_is_z_conv_result "z_∏_conv" s1
end)
end;
=IGN
z_∏_conv ÒX ∏ Y ∏  YÆ;
=SML
val €z_ç_∏_conv› : CONV = (fn tm =>
let	val (t,ct) = dest_z_ç tm
		handle (Fail _) =>
		term_fail  "z_ç_∏_conv" 42007 [tm];
	val si = dest_z_∏ ct
		handle (Fail _) =>
		term_fail  "z_ç_∏_conv" 42007 [tm];
	val spec = list_µ_elim si (get_spec ct);
	val s1 = (RIGHT_C(fn _ => spec) THEN_C ç_comp_conv) tm;
	val s2 = conv_rule(RIGHT_C (±_C 
		(TRY_C(LEFT_C z_tuple_lang_selection_conv)))) s1;
in
	check_is_z_conv_result "z_ç_∏_conv" 
	(eq_trans_rule (refl_conv tm) s2)
end);
=IGN
z_ç_∏_conv Ò(1,2,3) ç  X ∏ X ∏ XÆ;
z_ç_∏_conv Òx ç  X ∏ X ∏ XÆ;
=TEX
\subsection{Extensionality of Sets II}
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if ord nm = ordx
		then nm
		else fail "" 0 []);
	fun give_n_names nn lst = (
=SMLLITERAL
	let	fun nextn n = (let val poss = "xâ" ^ string_of_int n
=SML
			in
			if poss mem lst
			then nextn (n+1)
			else (n,poss)
			end);
		fun nextnm 0 m = []
		| nextnm n m = (let val (ind,next) = nextn m
			in
			(next :: nextnm (n-1) (ind+1))
			end)
	in
		nextnm nn 1
	end);
	val cnv1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z_sets_ext_thm);
	fun cnv2 nm = cnv1 THEN_C 
			z_µ_elim_conv THEN_C
			RAND_C(simple_¡_conv nm) THEN_C
			z_µ_intro_conv;
	fun uf ty = inst [] [(ty, î'aÆ)] Ua;
	val sets_ext_thm = pc_rule1 "'sets_ext" rewrite_conv[] ¨p:'a SET = qÆ;
	val sym_sets_ext_thm = all_µ_intro(eq_sym_rule sets_ext_thm);
=TEX
=SML
in
val €z_sets_ext_conv› : CONV = (fn tm =>
let	val (v,w) = dest_z_eq tm
		handle complaint =>
		divert complaint "dest_z_eq" "z_sets_ext_conv"
			42010 [fn () => string_of_term tm];
	val vty = type_of v;
	val elem_ty = case dest_ctype vty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "z_sets_ext_conv" 42010 [tm];
	val names = (mapfilter xnames (term_vars v)) cup (mapfilter xnames (term_vars w));
	val res =
	case dest_simple_type elem_ty of
	Ctype (nm,args) => ((case dest_z_name nm of
		("Z'T",[[ns]],Nil) => (
		let 	val n = nat_of_string ns;
			val xs =map mk_var
				(combine
				(give_n_names n names)
				args);
			val xs_decl = mk_z_decl
				(map (fn x => mk_z_dec([x],uf(type_of x))) xs);
			val xs_tuple = mk_z_tuple xs;
			val conc_gl = mk_z_µ(xs_decl,
				mk_t, mk_z_§(
				mk_z_ç(xs_tuple, v),
				mk_z_ç(xs_tuple, w)));
			val s1 = asm_rule tm;
			val s2 = app_fun_rule
				(mk_app( (mk_const("ç",
				mk_≠_type(type_of xs_tuple,
				mk_≠_type(vty,BOOL)))),
				xs_tuple)) s1;
			val s3 = z_µ_intro1 xs s2;
			val s4 = asm_rule (concl s3);
			val xv = variant (frees (concl s3)) (mk_var("x",type_of xs_tuple));
			val s5 = z_tuple_selection_intro_conv xv;
			val xparts = dest_z_tuple(snd(dest_eq(concl s5)));
			val s6 = conv_rule z_µ_elim_conv1 s4;
			val s7 = list_µ_elim xparts s6;
			val s8 = conv_rule(RANDS_C (LEFT_C (fn _ => eq_sym_rule s5))) s7;
			val s9 = simple_µ_intro xv s8;
			val s10 = list_µ_elim[v,w] sym_sets_ext_thm;
			val s11 = §_mp_rule s10 s9;
			val s12 = §_intro (all_¥_intro s3) (all_¥_intro s11);	
		in
			eq_trans_rule (refl_conv tm) s12
		end)
=TEX
=SML
		| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
		handle (Fail _) =>
		(let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
	| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end)
in
	check_is_z_conv_result "z_sets_ext_conv" res
end);
end; 
=IGN
z_sets_ext_conv Ò{1,2,3} = {3,2,1}Æ;
z_sets_ext_conv Ò{(1,2),(2,3)} = {(2,3),(1,2)}Æ;
z_sets_ext_conv Ò{(1,p,2,xâ2,x),(2,q,3,xâ2,x)} = {(2,q,3,xâ2,x),(1,p,2,xâ2,x)}Æ;
=TEX
=SML
local
	val ordx = ord"x";
	fun xnames (nm,ty) = (if ord nm = ordx
		then nm
		else fail "" 0 []);
	fun give_n_names nn lst = (
=SMLLITERAL
	let	fun nextn n = (let val poss = "xâ" ^ string_of_int n
=SML
			in
			if poss mem lst
			then nextn (n+1)
			else (n,poss)
			end);
		fun nextnm 0 m = []
		| nextnm n m = (let val (ind,next) = nextn m
			in
			(next :: nextnm (n-1) (ind+1))
			end)
	in
		nextnm nn 1
	end);
	val cnv1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z__thm);
	fun cnv2 nm = cnv1 THEN_C 
			z_µ_elim_conv THEN_C
			RAND_C(simple_¡_conv nm) THEN_C
			z_µ_intro_conv;
	fun uf ty = inst [] [(ty, î'aÆ)] Ua;
	val thm1 = taut_rule ¨µ x y ∑ x ¥ ((y ± T) ¥ x)Æ;
	val thm2 = prove_rule[] ¨µ x y ∑ x ¥ ((y ç ÒUÆ ± T) ¥ x)Æ;
=TEX
=SML
in
val €z_ç__conv› : CONV = (fn tm =>
let	val (v,pw) = dest_z_ç tm
		handle complaint =>
		divert complaint "dest_z_ç" "z_ç__conv"
			42016 [fn () => string_of_term tm];
	val w = dest_z_ pw
		handle complaint =>
		divert complaint "dest_z_" "z_ç__conv"
			42016 [fn () => string_of_term tm];
	val wty = type_of w;
	val elem_ty = case dest_ctype wty of
		("SET",[elem_ty]) => elem_ty
		| _ => term_fail "z_ç__conv" 42010 [tm];
	val names = (mapfilter xnames (term_vars v)) cup (mapfilter xnames (term_vars w));
	val res =
	case dest_simple_type elem_ty of
	Ctype (nm,args) => ((case dest_z_name nm of
		("Z'T",[[ns]],Nil) => (
		let 	val n = nat_of_string ns;
			val xs =map mk_var
				(combine
				(give_n_names n names)
				args);
			val xs_decl = mk_z_decl
				(map (fn x => mk_z_dec([x],uf(type_of x))) xs);
			val xs_tuple = mk_z_tuple xs;
			val conc_gl = mk_z_µ(xs_decl,
				mk_t, mk_z_¥(
				mk_z_ç(xs_tuple, v),
				mk_z_ç(xs_tuple, w)));
			val s1 = cnv1 tm;
			val tm' = snd(dest_eq(concl s1));
			val s2 = asm_rule tm';
			val s3 = simple_µ_elim xs_tuple(
				conv_rule z_µ_elim_conv1 s2);
			val s4 = list_simple_µ_elim [concl s3, xs_decl] thm1;
			val s5 = ¥_elim s4 s3;
			val s6 = conv_rule z_µ_intro_conv 
				(list_µ_intro xs s5);
=TEX
Now back the other way:
=SML
			val s7 = asm_rule (concl s6);
			val xv = variant (frees (concl s7)) (mk_var("x",type_of xs_tuple));
			val s8 = z_tuple_selection_intro_conv xv;
			val xparts = dest_z_tuple(snd(dest_eq(concl s8)));
			val s9 = conv_rule z_µ_elim_conv1 s7;
			val s10 = list_µ_elim xparts s9;
			val s11 = conv_rule(RANDS_C (LEFT_C (fn _ => eq_sym_rule s8))) s10;			
			val s12 =  ¥_elim (list_µ_elim [concl s11, xv] thm2) s11;
			val s13 = z_µ_intro s12;
			val s14 = §_intro (all_¥_intro s6) (all_¥_intro s13);	
		in
			eq_trans_rule (refl_conv tm) 
				(eq_trans_rule s1 s14)
		end)
=TEX
=SML
		| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
		handle (Fail _) =>
		(let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end))
	| _ => (let val nm = hd(give_n_names 1 names)
		in
			cnv2 nm tm
		end)
in
	check_is_z_conv_result "z_ç__conv" res
end);
end; 
=IGN
z_ç__conv Òp ç  qÆ;
z_ç__conv Òp ç  (x ∏ y)Æ;
z_ç__conv Òp ç  ( u)Æ;
=TEX
\section{BINDINGS}
The following is necessary because we may have, e.g., a variable
of a given binding type:
=SML
fun €const_of_binding_type› (ty : TYPE) : TERM = ( 
let	val (tyname,tys) = (dest_ctype ty);
	val (tcname,tysname,_) = dest_z_name tyname;
	val dummy = if length tysname <> 1 orelse tcname <> "Z'S"
		then fail "const_of_binding_type" 0 []
		else ();
	val cons_of_ty = ZTypesAndTermsSupport.bind_cterm 
		(combine (hd tysname) tys);
in
	cons_of_ty
end);
=SML
val €z_binding_eq_conv› : CONV = (fn tm => (
let	val (b1,b2) = dest_z_eq tm;
	val aconst = const_of_binding_type (type_of b1);
	val spec = binding_gen_semantic_const aconst
		handle (Fail _) => 
		( diag_string "binding_gen_semantic_const fail - z_binding_eq_conv";
		get_spec aconst);
	val (bcons,bproj) = get_binding_info (type_of b1);
	val ty_insts = type_match (type_of b1) (type_of(fst(dest_µ(concl spec))));
	val bproj' = map (inst[] ty_insts) bproj;
	val s1 = asm_rule tm;
	val s1s = map (fn x => app_fun_rule  x s1) bproj';
	val s2 = list_±_intro s1s;
	val s3s = strip_±_rule(asm_rule(list_mk_± (map concl s1s)));
	val s4 = fold (fn (x,y) =>  mk_app_rule y x) (rev s3s)
		(refl_conv (inst [] ty_insts bcons));
	val s5 = all_µ_intro(hd(rev(strip_±_rule(all_µ_elim spec))));
	val s6 = conv_rule(LEFT_C (simple_eq_match_conv1 s5)
		THEN_C RIGHT_C (simple_eq_match_conv1 s5)) s4;
	val s7 = §_intro (all_¥_intro s2) (all_¥_intro s6);
in
	check_is_z_conv_result "z_binding_eq_conv" 
	(eq_trans_rule (refl_conv tm) s7)
end)
handle complaint =>
list_divert complaint "z_binding_eq_conv"
	[("const_of_binding_type", 42013, [fn () => string_of_term tm]),
	("dest_z_eq", 42013, [fn () => string_of_term tm]),
	("get_spec", 42013, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=IGN
z_binding_eq_conv Ò  S = (x ¶ y)Æ;
=TEX
=SML
val €z_binding_eq_conv1› : CONV = (fn tm => (
let	val (b1,b2) = dest_z_eq tm;
	val aconst = const_of_binding_type (type_of b1);
	val spec = binding_gen_semantic_const aconst
		handle (Fail _) => 
		(diag_string "binding_gen_semantic_const fail - z_binding_eq_conv1";
		get_spec aconst);
	val (bcons,bproj) = get_binding_info (type_of b1);
	val ty_insts = type_match (type_of b1) (type_of(fst(dest_µ(concl spec))));
	val bproj' = map (inst[] ty_insts) bproj;
	val s1 = asm_rule tm;
	val s1s = map (fn x => app_fun_rule  x s1) bproj';
	val s2 = list_±_intro s1s;
	val s3s = strip_±_rule(asm_rule(list_mk_± (map concl s1s)));
	val s4 = fold (fn (x,y) =>  mk_app_rule y x) (rev s3s)
		(refl_conv (inst [] ty_insts bcons));
	val s5 = all_µ_intro(hd(rev(strip_±_rule(all_µ_elim spec))));
	val s6 = conv_rule(LEFT_C (simple_eq_match_conv1 s5)
		THEN_C RIGHT_C (simple_eq_match_conv1 s5)) s4;
	val s7 = §_intro (all_¥_intro s2) (all_¥_intro s6);
in
(check_is_z_conv_result "z_binding_eq_conv1" 
(case (is_z_binding b1, is_z_binding b2) of
(false, false) => (eq_trans_rule (refl_conv tm) s7)
| (true, false) => (
let	val b1args = map snd(dest_z_binding b1);
	val proj_thms = rev(tl(rev
		(strip_±_rule(list_µ_elim (b1 :: b1args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn thm => LEFT_C (fn _ => thm)) proj_thms))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end)
| (false, true) => (
let	val b2args = map snd(dest_z_binding b2);
	val proj_thms = rev(tl(rev
		(strip_±_rule(list_µ_elim (b2 :: b2args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn thm => RIGHT_C (fn _ => thm)) proj_thms))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end)
| (true, true) => (
let	val b1args = map snd(dest_z_binding b1);
	val proj_thms1 = rev(tl(rev
		(strip_±_rule(list_µ_elim (b1 :: b1args)(inst_type_rule ty_insts spec)))));
	val b2args = map snd(dest_z_binding b2);
	val proj_thms2 = rev(tl(rev
		(strip_±_rule(list_µ_elim (b2 :: b2args)(inst_type_rule ty_insts spec)))));
	val s8 = conv_rule (RIGHT_C(LIST_OP_C
		(map (fn (thm1,thm2) => 
		LEFT_C (fn _ => thm1) THEN_C
		RIGHT_C (fn _ => thm2)) 
		(combine proj_thms1 proj_thms2)))) s7;
in
	(eq_trans_rule (refl_conv tm) s8)
end)
))
end
)
handle complaint =>
list_divert complaint "z_binding_eq_conv1"
	[("dest_z_eq", 42013, [fn () => string_of_term tm]),
	("get_spec", 42013, [fn () => string_of_term tm]),
	("const_of_binding_type", 42013, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=IGN
z_binding_eq_conv1 Ò(x ¶ 1, y ¶ 2, z ¶ 3) = (y ¶ 2, x ¶ 1, z ¶ 3)Æ;
=TEX
=SML
val  €z_binding_sel_conv› : CONV = (fn tm => (
let	val (b,s) = dest_z_selâs tm;
	val bits = dest_z_binding b;
	val spec = binding_gen_semantic_const b
		handle (Fail _) =>
		(diag_string "binding_gen_semantic_const fail - z_binding_sel_conv";
		get_spec b);
	val spec' = list_µ_elim (b :: map snd bits) spec;
	val ss = strip_±_rule spec';
in
	check_is_z_conv_result "z_binding_sel_conv"
	(eq_trans_rule (refl_conv tm)
	(find ss (fn thm => (snd(dest_z_selâs(fst(dest_eq(concl thm)))) = s))))
end
)
handle complaint =>
list_divert complaint "z_binding_sel_conv"
	[("dest_z_selâs", 42014, [fn () => string_of_term tm]),
	("dest_z_binding", 42014, [fn () => string_of_term tm]),
	("get_spec", 42014, [fn () => string_of_term tm]),
	("eq_trans_rule", 43000, [fn () => string_of_term tm])])
;
=IGN
z_binding_sel_conv Ò(x ¶ 1, y ¶ 2, z ¶ 3).yÆ;
=TEX

\section{MISCELLANEOUS}
=SML
local
	val taut_thm = all_µ_intro
		(taut_rule¨((a ¥ b) ± ((b ± T) ¥ ( a § c ))) = (a § (b ± c))Æ);
	val c1 = simple_eq_match_conv1 (conv_rule z_µ_elim_conv1 z__thm);
	val c2 = simple_eq_match_conv1 taut_thm;
in
fun  €z_defn_simp_rule› (ithm : THM) : THM = ((
let	val qthm = conv_rule (TRY_C z_defn_conv THEN_TRY_C
		ALL_SIMPLE_µ_C(
		LEFT_C (DECL_C dec_pred_conv))) ithm;
	val (vs,_) = strip_simple_µ(concl qthm);
	val thm = all_µ_elim qthm;
	val tm = concl thm;
	val (tm1,tm2) = dest_± tm;
	val thm1 = conv_rule
		(c1 THEN_C z_µ_elim_conv1)
		(±_left_elim thm);
	val thm2 = ±_right_elim thm;
	val (d,p,v) = dest_z_µ(concl thm2);
	val dvar = hd(fst(dest_z_dec(hd(dest_z_decl d))));
	val thm'' = ±_intro(µ_elim dvar thm1)
			(z_µ_elim dvar thm2);
in 
	check_is_z_thm "z_defn_simp_rule"
	(list_simple_µ_intro vs
	(z_µ_intro1 [dvar] (conv_rule c2 thm'')))
end)
handle complaint =>
list_divert complaint "z_defn_simp_rule"
	[("dest_±", 42011, [fn () => string_of_thm ithm]),
	("simple_eq_match_conv1", 42011, [fn () => string_of_thm ithm]),
	("dest_z_decl", 42011, [fn () => string_of_thm ithm]),
	("dest_z_dec", 42011, [fn () => string_of_thm ithm]),
	("z_µ_elim", 42011, [fn () => string_of_thm ithm])]);
end;
=TEX
=IGN
z_defn_simp_rule 
	(asm_rule ¨Z'AbbDef Òp ç (X ∏ Y) ± (µ q : X ∏ Y ∑ q ç p § first q = q.1)ÆÆ);
z_defn_simp_rule
	(conv_rule 
	(RAND_C(LEFT_C (DECL_INTRO_C pred_dec_conv)))
(asm_rule ¨Z'AbbDef Òp ç (X ∏ Y) ± (µ q : X ∏ Y ∑ q ç p § first q = q.1)ÆÆ));
=TEX
\section{PROOF CONTEXTS}
\subsection{Utilities}
=SML
fun €limited_z_¬_conv› tm = (
let	val res = z_¬_conv tm
in
	if is_nil(asms res)
	then res
	else term_fail "limited_z_¬_conv" 0 [tm]
end);
=TEX
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms)
);
=TEX	
\subsection{Treatment of Membership of Sets in Z Language}
In designing discrimination net indices we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_ç_set_lang" handle Fail _ => ();
val _ = new_pc "'z_ç_set_lang";
val _ = set_rw_eqn_cxt [(Òx ç ¨y (Ã w:'c ∑ z):'b SETÆÆ,z_ç_seta_conv),
	(Òx ç ¨Z'Seta[0] y:'a SETÆÆ,z_ç_seta_conv),
	(Òx ç ¨y (Cons (p:'b) q):'b SETÆÆ,z_ç_setd_conv),
	(Òx ç ¨y Nil:'b SETÆÆ,z_ç_setd_conv),
	(Ò(Ã x : U | true ∑ y) zÆ,limited_z_¬_conv)]
		"'z_ç_set_lang";
val _ = add_rw_thms [] "'z_ç_set_lang";

val pos = (thms_to_eqn_cxt [])
	@ [(Òx ç ¨y (Ã w ∑ z):'b SETÆÆ,z_ç_seta_conv),
	(Òx ç ¨Z'Seta[0] y:'a SETÆÆ,z_ç_seta_conv),
	(Òx ç ¨y (Cons (p:'b) q):'b SETÆÆ,z_ç_setd_conv),
	(Òx ç ¨y Nil:'b SETÆÆ,z_ç_setd_conv)];
val neg = map (mk_≥ ** RAND_C) pos;
val neither = [(Ò(Ã x : U ∑ y) zÆ, limited_z_¬_conv)];
val _ = set_st_eqn_cxt (pos @ neg @ neither) "'z_ç_set_lang";
val _ = set_sc_eqn_cxt (pos @ neg @ neither) "'z_ç_set_lang";
val _ = set_rw_canons [] "'z_ç_set_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_ç_set_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_ç_set_lang";
val _ = set_cs_∂_convs [] "'z_ç_set_lang";
val _ = set_∂_vs_thms [] "'z_ç_set_lang";
=TEX
\subsection{Extensionality Treatment of Sets}
=SML
val _ = delete_pc "'z_sets_ext_lang" handle Fail _ => ();
val _ = new_pc "'z_sets_ext_lang";
val _ = set_rw_eqn_cxt [(Ò¨Z'Setd xÆ Ä yÆ,z_setd_Ä_conv),
	(Òx ç  yÆ,z_ç__conv),
	(Òx = yÆ,z_sets_ext_conv)]
	"'z_sets_ext_lang";
val _ = add_rw_thms 
	[] "'z_sets_ext_lang";

val pos = [(Ò¨Z'Setd xÆ Ä yÆ,z_setd_Ä_conv),
	(Òx ç  yÆ,z_ç__conv),
	(Òx = yÆ,z_sets_ext_conv)]
	@ thms_to_eqn_cxt [];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_sets_ext_lang";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_sets_ext_lang";
val _ = set_rw_canons [] "'z_sets_ext_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_sets_ext_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_sets_ext_lang";
val _ = set_cs_∂_convs [] "'z_sets_ext_lang";
val _ = set_∂_vs_thms [] "'z_sets_ext_lang";
=TEX
=SML
val _ = delete_pc "'build_z_sets";
=TEX
\subsection{Treatment of Tuples and Cartesian Products}
In designing discrimination net indexes we are careful
to use the knowledge that a tuple must have at least 2 elements.
=SML
val _ = delete_pc "'z_tuples_lang" handle Fail _ => ();
val _ = new_pc "'z_tuples_lang";
val _ = set_rw_eqn_cxt [(Òx ç ¨y (z:'c):'b SETÆÆ,z_ç_∏_conv),
	(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_lang_eq_conv),
	(¨f(a1 a2 a3)Æ,z_tuple_lang_selection_conv),
	(¨f (a1 a2) (b1 b2)Æ,z_tuple_lang_intro_conv)
	]"'z_tuples_lang";

val pos = [(¨a1 a2 a3 = b1 b2 b3Æ,z_tuple_lang_eq_conv),
	  (Òx ç ¨y (z:'c):'b SETÆÆ,z_ç_∏_conv)];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_tuples_lang";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_tuples_lang";
val _ = set_rw_canons [] "'z_tuples_lang";
val _ = set_pr_tac z_basic_prove_tac "'z_tuples_lang";
val _ = set_pr_conv z_basic_prove_conv "'z_tuples_lang";
val _ = set_cs_∂_convs [] "'z_tuples_lang";
val _ = set_∂_vs_thms [] "'z_tuples_lang";
=TEX
\subsection{Treatment of Bindings}
=SML
val local_binding_eq_conv : CONV = (fn tm =>
let	val (a,b) = dest_eq tm;
in
	if is_z_binding a andalso is_z_binding b
	then z_binding_eq_conv1 tm
	else fail_conv tm
end);

val _ = delete_pc "'z_bindings" handle Fail _ => ();
val _ = new_pc "'z_bindings";
val _ = set_rw_eqn_cxt [(Òf a = g bÆ,local_binding_eq_conv),
	(¨f(g x)Æ,z_binding_sel_conv)
	]"'z_bindings";

val pos = [(Òf a = g bÆ,local_binding_eq_conv)];
val neg = map (mk_≥ ** RAND_C) pos;

val _ = set_st_eqn_cxt (pos @ neg) "'z_bindings";
val _ = set_sc_eqn_cxt (pos @ neg) "'z_bindings";
val _ = set_rw_canons [] "'z_bindings";
val _ = set_pr_tac z_basic_prove_tac "'z_bindings";
val _ = set_pr_conv z_basic_prove_conv "'z_bindings";
val _ = set_cs_∂_convs [] "'z_bindings";
val _ = set_∂_vs_thms [] "'z_bindings";
=TEX
\section{FURTHER WORK}
=SML
val €z_ç_app_thm› = (
push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_decl","'z_sets_ext_lang"];
set_goal([],Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ a ç f_x ± (x, f_x) ç f ± (µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ a ç f xÆ);
a(REPEAT strip_tac);
a(lemma_tac Òf_x = ¨fÆ ¨xÆÆ);
(* *** Goal "1" *** *)
a(z_app_tac);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(asm_prove_tac[]);
pop_pc();
save_thm("z_ç_app_thm",(pop_thm())));
=TEX
=SML
val €z_app_ç_thm› = (
push_merge_pcs ["z_predicates","'z_ç_set_lang",
	"'z_decl","'z_sets_ext_lang"];
set_goal([],Òµ a:U; x:U; f: U∑
	(∂ f_x : U ∑ f_x ç a ± (x, f_x) ç f ± (µ f_x1 :U ∑ (x, f_x1) ç f ¥ f_x1 = f_x)) ¥ f x ç aÆ);
a(REPEAT strip_tac);
a(lemma_tac Òf_x = ¨fÆ ¨xÆÆ);
(* *** Goal "1" *** *)
a(z_app_tac);
a(asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
pop_pc();
save_thm("z_app_ç_thm",(pop_thm())));
=TEX
\section{EPILOGUE}
=SML
end; (* of structure ZExpressions *)
open ZExpressions;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
