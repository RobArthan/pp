% imp061.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Parser}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP061}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01 \\ R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
parser for HOL/Z.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{DS/FMU/IED/DTD061}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD061}.

\subsection{Dependencies}
The parser is dependent on the Z lexical analyser, \cite{DS/FMU/IED/DTD060}, 
and on the HOL symbol table, \cite{DS/FMU/IED/DTD020}.
\subsection{Possible Enhancements}
The error messages could be improved by using a hand-coded function to
print out the parsing stack.
\subsection{Deficiencies}
The parser accepts a slightly larger language than that specified in
\cite{DS/FMU/IED/DEF007} in that it allows infix, prefix and
postfix syntax and type constraints in local function definitions.
It also allows antiquotation in local definitions and bound variable
declarations.

The error report for errors in varstructs and local definitions
does not indicate the position of the error as accurately as one might
like. The error marker appears immediately after the $let$-term or
abstraction (or similar) containing the error. To fix this would require
quite a lot of work (one would probably have to label the $TM$s with
token numbers so that the code which makes the checks when the
entire containing phrase has been recognised
could calculate where the error in the input arose from).
As the second line of the error report does print out the rogue construct
in full, the situation as is is not intolerable.
\section{PREAMBLE}
SML
structure ÛZParserÝ : ZParser = struct
=TEX
We need to include the SLRP driver code at this point:
=TEX
=SML
open ZLex;
=INCLUDE
imp018.sml
=SML
open SlrpDriver;
=TEX
\section{DATA TYPES}
We require data types to represent the result of a context-free parse
using the grammar of \cite{DS/FMU/IED/DTD061}. The result is used to
generate a value of type $ZTM$ as required by the type inferrer.

The following types are used for identifiers and decoration:
=SML
type ÛIDÝ			= string;
type ÛDECORÝ		= string;
=TEX
We represent precedences using 
the integers:
=SML
type ÛPRECÝ		= int;
=TEX
The following types are used for the templates which
record information about fancy-fix operators:
=SML
datatype ÛSTUBÝ		= 	ÛStubUSÝ		(* _ *)
			|	ÛStubEllÝ		(* ... *);

type ÛCOREÝ		=	ID * ((STUB * ID) list * (STUB * ID)) OPT;

datatype ÛTEMPLATEÝ	=	ÛTmplNonÝ of	CORE
					(* id, {stub, id} *)
			|	ÛTmplInÝ of	(STUB * CORE * STUB)
					(* stub, id, {stub, id}, stub *)	
			|	ÛTmplPreÝ of	(CORE * STUB)
					(* id, {stub, id}, stub *)
			|	ÛTmplPostÝ of	(STUB * CORE)
					(* {stub, id}, stub, id *);
=TEX
Logical and schema operators are represented using the following
data types:
=SML
datatype ÛLOG_IN_OPÝ	= ÛAndÝ | ÛOrÝ | ÛImpliesÝ | ÛIffÝ;

datatype ÛSCH_IN_OPÝ	= ÛPipeÝ | ÛFilterÝ | ÛCompÝ;

datatype ÛSCH_PRE_OPÝ	= ÛPreÝ | ÛDeltaÝ | ÛXiÝ;

datatype ÛQUANTÝ	= ÛForAllÝ | ÛExistsÝ | ÛExistsUniqueÝ;
=TEX
Most of the complexity of the parsing process arises in the treatment of
predicates, schemas and expressions. These are all mapped onto the
data type $PRED$. The type contains a constructor corresponding to
each of the alternatives for $Pred$, $Pred1$, $Pred2$, $Pred3$,
$Schema2$, $Schema3$, $Schema4$, $Expr0$, $Expr1$, $Expr2$, $Expr3$
and $Expr4$, with the exceptions that (i) no constructor is required
for alternatives comprising a single non-terminal, and (ii) in most cases
where one alternative may be obtained from another by omitting part of it,
the data type has a single constructor with optional components in its
operand type.
=SML
datatype ÛPREDÝ		= ÛPredSemiÝ of PRED * PRED
			| ÛPredQuantifierÝ of QUANT * DECL * (PRED OPT) * PRED
			| ÛPredLetÝ of EQ_DEF list * PRED
			| ÛPredLogInOpÝ of PRED * LOG_IN_OP * PRED
			| ÛPredNotÝ of PRED
			| ÛPredSchInOpÝ of PRED * SCH_IN_OP * PRED
			| ÛPredSchPreOpÝ of SCH_PRE_OP * PRED
			| ÛPredSchemaHidingÝ of PRED * (PRED list)
			| ÛPredMuÝ of DECL * (PRED OPT) * (PRED OPT)
			| ÛPredLambdaÝ of DECL * (PRED OPT) * (PRED OPT)
			| ÛPredFancyFixÝ of TEMPLATE * DECOR * ((PRED list) list)
			| ÛPredCrossProductÝ of PRED list
			| ÛPredPowÝ of PRED
			| ÛPredApplicationÝ of PRED * PRED
			| ÛPredThetaÝ of PRED
			| ÛPredSelectionÝ of PRED * PRED
			| ÛPredIdDecÝ of ID * DECOR
			| ÛPredQuotationÝ of TERM
			| ÛPredPlaceHolderÝ of STUB
			| ÛPredNumberÝ of int
			| ÛPredStringÝ of string
			| ÛPredTupleÝ of PRED list
			| ÛPredSetDisplayÝ of PRED list
			| ÛPredSeqDisplayÝ of PRED list
			| ÛPredSetCompÝ of DECL * (PRED OPT) * (PRED OPT)
			| ÛPredHorizSchemaÝ of  DECL * (PRED OPT)
			| ÛPredGenInstÝ of PRED list
			| ÛPredRenameListÝ of (PRED * PRED) list
			| ÛPredBracketedÝ of PRED * DECOR
			| ÛPredErrorÝ of PRED
=TEX
The above definition uses the following type abbreviations which correspond
to the non-terminals $Decl$ and $EqDef$ in the grammar. Note that
a declaration is much simpler here than in the grammar (which is
complicated by a need to single out declarations consisting of a single
schema expression as a special case).
=SML
withtype ÛDECLÝ		= (PRED list * PRED OPT) list
and ÛEQ_DEFÝ		= PRED * PRED;
=TEX
The following type abbreviations and data types correspond to the
various sorts of paragraph:
=SML
type ÛFIXITYÝ		= CLASS * (TEMPLATE list);

type ÛGENERAL_TERMÝ	= PRED * (PRED OPT);

datatype ÛABB_DEFÝ	= ÛADEqDefÝ of EQ_DEF
			| ÛADSchemaBoxÝ of PRED * DECL * (PRED OPT);

type ÛFREE_TYPE_DEFÝ	= (PRED * (PRED list)) list;

type ÛAX_BOXÝ		= (PRED list) * DECL * (PRED OPT);

type ÛCONJECTUREÝ		= (ID OPT) * PRED;
=TEX
The overall result of a context-free parse of a single Z paragraph
is then represented by the following data type:
=SML
datatype ÛPARAGRAPHÝ	= ÛParFixityÝ of FIXITY
			| ÛParGeneralTermÝ of GENERAL_TERM
			| ÛParAbbDefÝ of ABB_DEF
			| ÛParFreeTypeDefÝ of FREE_TYPE_DEF
			| ÛParAxBoxÝ of AX_BOX
			| ÛParConjectureÝ of CONJECTURE;
=TEX
The partially parsed input as held on the parsing stack is of the
type $PP$, for which we use an additional type abbreviation for the
values obtained by reducing the second alternative for the
non-terminal $CoreExpr$.
=SML
type ÛCORE_EXPRÝ		= PRED list * ((ID * (PRED list))list);

datatype ÛPPÝ		= PPParagraph of PARAGRAPH
			| PPTemplates of TEMPLATE list
			| PPTemplate of TEMPLATE
			| PPEqDef of EQ_DEF
			| PPEqDefs of EQ_DEF list
			| PPPred of PRED
			| PPDecl of DECL
			| PPCoreExpr of CORE_EXPR
			| PPSomeExprs of PRED list
			| PPIdDec of (ID * DECOR);
=TEX
\section{TEMPLATE FUNCTIONS}
We need various functions for operating on templates.
These are collected together in this section.

=TEX
We maintain a dictionary mapping names onto templates and
the $ZFIXITY$s. (This should actually be loaded from the theory
database.)
=TEX
=SML
val tmpl_ref : (ID * ZFIXITY * TEMPLATE) list ref = ref [];
=TEX
Given a template the following function returns
the corresponding list of name-$ZFIXITY$ pairs. The list is in no
particular order.
=SML
fun tmpl_ids (tmpl : TEMPLATE) (cl : CLASS): (ID * ZFIXITY) list = (
	let	val aux = map (fn (_, id) => (id, (ZFFThenOp, cl)));
	in	case tmpl of
		TmplNon (id, Nil) => (
			raise SYNTAX_ERROR
		) |	TmplNon (id1, Value (stids, (_, id2))) =>(
			(id1, (ZFFBeginOp, cl)) :: (id2, (ZFFEndOp, cl)) :: aux stids
		) |	TmplIn (_, (id, Nil), _) => (
			[(id, (ZFFInOp, cl))]
		) |	TmplIn (_, (id1, Value (stids, (_, id2))), _) => (
			(id1, (ZFFPostBeginOp, cl)) :: (id2, (ZFFPreEndOp, cl)) :: aux stids
		) |	TmplPre ((id, Nil), _) => (
			[(id, (ZFFPreOp, cl))]
		) |	TmplPre ((id1, Value (stids, (_, id2))), _) => (
			(id1, (ZFFBeginOp, cl)) :: (id2, (ZFFPreEndOp, cl)) :: aux stids
		) |	TmplPost (_, (id, Nil)) =>(
			[(id, (ZFFPostOp, cl))]
		) |	TmplPost (_, (id1, Value (stids, (_, id2)))) => (
			(id1, (ZFFPostBeginOp, cl)) :: (id2, (ZFFEndOp, cl)) :: aux stids
		)
	end
);
=TEX
=SML
fun Ûdeclare_templateÝ ((cl, tmpl) : CLASS * TEMPLATE) :  unit  = (
	let	fun mapper (id, zfix) = (
			tmpl_ref :=  (id, zfix, tmpl)::(!tmpl_ref)
		);
	in
		map mapper (tmpl_ids tmpl cl); ()
	end
);
=TEX
=SML
fun Ûget_templateÝ (id : ID) : (TEMPLATE * ZFIXITY) list = (
	let	val tmps = (!tmpl_ref) drop (fn (id',_,_) => id<>id');
	in
		map (fn (_, zfix, tmpl)=> (tmpl, zfix)) tmps  
	end
);
=TEX
\section{DIAGNOSTICS}
If errors are detected during the transformation to $ZTM$, then values
of type $PARAGRAPH$ etc. have to be printed in the diagnostic report.
The following functions are used to do this:
=TEX
=SML
fun Ûformat_stubÝ StubUS = " _ "
|    format_stub StubEll = " ... ";
=TEX
=SML
fun Ûformat_coreÝ ( (first, Value (middle, last)) : CORE ) : string = (
	let	fun format_stub_id (stub, id) = (
			format_stub stub ^ id
		);
	in		first
		^	format_list format_stub_id middle ""
		^	format_stub_id last
	end
) | format_core ( (first, Nil) ) = first;
=TEX
=SML
fun Ûformat_templateÝ ((TmplNon core) : TEMPLATE) : string =
	" " ^ format_core core ^ " "
|   format_template (TmplIn (st1, core, st2)) =
	format_stub st1 ^ format_core core ^ format_stub st2
|   format_template (TmplPre (core, st)) =
	format_core core ^ format_stub st
|   format_template (TmplPost (st, core)) =
	format_stub st ^ format_core core;
=TEX
=SML
fun Ûformat_log_in_opÝ (And : LOG_IN_OP) : string = "±"
|   format_log_in_op (Or : LOG_IN_OP) = "²"
|   format_log_in_op (Implies : LOG_IN_OP) = "´"
|   format_log_in_op (Iff : LOG_IN_OP) = "¤";
=TEX
=SML
fun Ûformat_sch_in_opÝ (Pipe : SCH_IN_OP) = ">>"
|   format_sch_in_op (Filter : SCH_IN_OP) = "ù"
|   format_sch_in_op (Comp : SCH_IN_OP) = "»";
=TEX
=SML
fun Ûformat_sch_pre_opÝ (Pre : SCH_PRE_OP) = "pre"
|   format_sch_pre_op (Delta : SCH_PRE_OP) = ""
|   format_sch_pre_op (Xi : SCH_PRE_OP) = "";
=TEX
=SML
fun Ûformat_quantÝ (ForAll : QUANT) = "µ"
|   format_quant (Exists : QUANT) = "¶"
|   format_quant (ExistsUnique : QUANT) = "¶1";
=TEX
=SML
fun Ûformat_fancy_fixÝ
	(format_item : 'a -> string)
	(tmpl : TEMPLATE)
	(decor : DECOR)
	(items : 'a list) = (
	let	
		val rids = rev (map fst (tmpl_ids tmpl ZClRel));
		val ids = rev (hd rids ^ decor :: tl rids);
		fun aux1 ns its = (
			(format_list
			Combinators.I
			(map (fn (a,b) => a ^ " " ^ b)(combine ns (map format_item its)))
			" ")
		);
		fun aux2 ns its = (
			(format_list
			Combinators.I
			(map (fn (a,b) => a ^ " " ^ b)(combine (map format_item its) ns))
			" ")
		);
	in	case tmpl of
			TmplNon _ => (
				hd ids ^ aux2 (tl ids) items
		) |	TmplIn _ => (
				format_item (hd items)  ^ aux1 ids (tl items)
		) |	TmplPre _ => (
				aux1 ids items
		) |	TmplPost _ => (
				aux2 ids items
		)
	end
	handle (Fail _) => raise PARSER_ERROR "invalid call of format_fancy_fix"
);
=TEX
=SML
fun Ûformat_predÝ (pred : PRED) : string = (
	case pred of
		PredSemi (pred1, pred2) => format_pred pred1 ^ "; " ^ format_pred pred2
	|	PredQuantifier (q, decl, Value pred1, pred2) =>
			format_quant q ^ format_decl decl ^ " | " ^ format_pred pred1 ^ " · " ^ format_pred pred2
	|	PredQuantifier (q, decl, Nil, pred2) =>
			format_quant q ^ format_decl decl ^ " · " ^ format_pred pred2
	|	PredLet (eqdefs, pred) =>
			format_list format_eq_def eqdefs "," ^ format_pred pred
	|	PredLogInOp (pred1, rator, pred2) =>
			format_pred pred1 ^ format_log_in_op rator ^ format_pred pred2
	|	PredNot pred => "³ " ^ format_pred pred
	|	PredSchInOp (pred1, rator, pred2) =>
			format_pred pred1 ^ format_sch_in_op rator ^ format_pred pred2
	|	PredSchPreOp (rator, pred) =>
			format_sch_pre_op rator ^ format_pred pred
	|	PredSchemaHiding (pred, preds) =>
			format_pred pred ^ "\\[" ^ format_list format_pred preds ", " ^ "]"
	|	PredMu body => "Í " ^ format_decl_bar_pred_dot_pred body
	|	PredLambda body => "Ì " ^ format_decl_bar_pred_dot_pred body
	|	PredFancyFix (tmpl, decor, args) =>
			format_fancy_fix
			(fn ps => format_list format_pred ps ", ")
			 tmpl decor args
	|	PredCrossProduct preds => format_list format_pred preds " ¸ "
	|	PredPow pred => "ð " ^ format_pred pred
	|	PredApplication (pred1, pred2) =>  format_pred pred1 ^ " " ^ format_pred pred2
	|	PredTheta pred => "Ê " ^ format_pred pred
	|	PredSelection (pred1, pred2) =>  format_pred pred1 ^ "." ^ format_pred pred2
	|	PredIdDec (id, decor) => id ^ " " ^ decor
	|	PredQuotation _ => "<term-quotation>"
	|	PredPlaceHolder st => format_stub st
	|	PredNumber n => string_of_int n
	|	PredString s => "\"" ^ s ^ "\""
	|	PredTuple preds => "(" ^ format_list format_pred preds ", " ^ ")"
	|	PredSetDisplay preds  => "{" ^ format_list format_pred preds ", " ^ "}"
	|	PredSeqDisplay preds  => "§" ^ format_list format_pred preds ", " ^ "¢"
	|	PredSetComp body => "{" ^ format_decl_bar_pred_dot_pred body ^ "}"
	|	PredHorizSchema (decl, predopt) =>
			"[" ^ format_decl_bar_pred_dot_pred(decl, predopt, Nil) ^ "]"
	|	PredGenInst preds => "[" ^ format_list format_pred preds ", " ^ "]"
	|	PredRenameList renames =>
			"["
		^	format_list
			(fn (pred1, pred2) => format_pred pred1 ^ " / " ^ format_pred pred2)
			renames
			", "
		^	"]"
	|	PredBracketed (pred, decor) => "(" ^ format_pred pred ^ ")" ^ decor
	|	PredError pred => "<?>" ^ format_pred pred
)
and Ûformat_declÝ (decs : DECL) : string = (
	let	fun format_dec (preds, Nil) =  format_list format_pred preds ", "
		|   format_dec (preds, Value pred2) =
			format_list format_pred preds ", "
			 ^ " : " ^ format_pred pred2;
	in	format_list format_dec decs "; "
	end
)
=TEX
=SML
and Ûformat_eq_defÝ ((pred1, pred2) : EQ_DEF) : string = (
	format_pred pred1 ^ " ¦ " ^ format_pred pred2
)
=TEX
=SML
and Ûformat_decl_bar_pred_dot_predÝ
	(body : DECL * (PRED OPT) * (PRED OPT))
	: string = (
	case body of
		(decl, Value pred1, Value pred2) =>
			format_decl decl ^ " | " ^ format_pred pred1 ^ " · " ^ format_pred pred2
	|	(decl, Nil, Value pred) =>
			format_decl decl ^ " · " ^ format_pred pred
	|	(decl, Value pred, Nil) =>
			format_decl decl ^ " | " ^ format_pred pred
	|	(decl, Nil, Nil) =>
			format_decl decl
);
=TEX
=SML
fun Ûformat_classÝ ((ZClFun n) : CLASS) : string = "fun " ^ string_of_int n
|   format_class  (ZClGen n) = "gen " ^ string_of_int n
|   format_class  (ZClRel) = "rel";
=TEX
=SML
fun Ûformat_fixityÝ ((cl, tmpls) : FIXITY) : string = (
	format_class cl ^ " " ^ format_list format_template tmpls ", "
);
=TEX
=SML
fun Ûformat_general_termÝ ((pred1, Value pred2) : GENERAL_TERM) : string = (
	format_pred pred1 ^ " & " ^ format_pred pred2
) | format_general_term (pred1, Nil) = format_pred pred1;
=TEX
=SML
fun Ûformat_abb_defÝ (ADEqDef eqdef : ABB_DEF) : string = format_eq_def eqdef
=SMLLITERAL
|   format_abb_def (ADSchemaBox (pred1, decl, Value pred2)) = (
	"  " ^ format_pred pred1 ^ "ü" ^ format_decl decl ^ " ÷ " ^ format_pred pred2 ^ " "
) | format_abb_def (ADSchemaBox (pred, decl, Nil)) = (
	"ÿ " ^ format_pred pred ^ " ü " ^ format_decl decl ^ " "
);
=TEX
=SML
fun Ûformat_free_type_defÝ (ftd : FREE_TYPE_DEF) : string = (
	let	fun aux (pred, preds) = (
			format_pred pred ^ " ::= " ^
			format_list format_pred preds " | "
		);
	in 	format_list aux ftd " & "
	end
);
=TEX
=SML
fun Ûformat_ax_boxÝ ((preds as _::_, decl, Value pred) : AX_BOX) : string = (
=SMLLITERAL
	"[ " ^ format_list format_pred preds ", " ^ " ] " ^
	format_decl decl ^ " ÷ " ^ format_pred pred ^ " "
) | format_ax_box ([], decl, Value pred) = (
	"¹ZAX"  ^ format_decl decl ^ " ÷ " ^ format_pred pred ^ " "
) | format_ax_box ((preds as _::_, decl, Nil) : AX_BOX) = (
	"[ " ^ format_list format_pred preds ", " ^ " ] " ^
	format_decl decl ^ " "
) |  format_ax_box ([], decl, Nil) = (
	"¹ZAX"  ^ format_decl decl ^ " "
);
=TEX
=SML
fun Ûformat_conjectureÝ ((Value id, pred) : CONJECTURE) : string = (
	id ^ " ô " ^ format_pred pred
) | format_conjecture (Nil, pred) = (
	"ô " ^ format_pred pred
);
=TEX
=SML
fun Ûformat_paragraphÝ (para : PARAGRAPH) : string = (
	case para of
		ParFixity f => format_fixity f
	|	ParGeneralTerm gt => format_general_term gt
	|	ParAbbDef ad => format_abb_def ad
	|	ParFreeTypeDef ftd => format_free_type_def ftd
	|	ParAxBox ab => format_ax_box ab
	|	ParConjecture c => format_conjecture c
);
=TEX
=SML
fun Ûformat_core_exprÝ ((preds, idpreds) : CORE_EXPR) : string = (
	let	fun aux (id, ps) = (
			id ^ " " ^ format_list format_pred ps ", "
		);
	in	format_list format_pred preds ", " ^ format_list aux idpreds " "
	end
);
=TEX
=SML
fun Ûformat_ppÝ (pp : PP) : string = (
	case pp of
		PPParagraph para => format_paragraph para
	|	PPTemplates tmpls => format_list format_template tmpls ", "
	|	PPTemplate tmpl => format_template tmpl
	|	PPEqDef eqdef => format_eq_def eqdef
	|	PPEqDefs eqdefs => format_list format_eq_def eqdefs ", "
	|	PPPred pred => format_pred pred
	|	PPDecl decl => format_decl decl
	|	PPCoreExpr ce =>  format_core_expr ce
	|	PPSomeExprs es => format_list format_pred es ", "
	|	PPIdDec (id, dec) => id ^ dec
);
=TEX
\section{LEXICAL CLASSES}
The following data type represents the lexical classes which are the
terminals of the grammar:
=SML
datatype Z_LEX_CLASS	= Ampersand
			| Quotation
			| Ax
			| BBoldP
			| BackSlash
			| Bar
			| Bars
			| BeginOp
			| Colon
			| ColonsEq
			| Comma
			| Cross
			| Decor
			| Dot
			| EndOp
			| Eos
			| EqHat
			| FixityClass
			| Id
			| InOp
			| Is
			| LBrace
			| LBrk
			| LSeqBrk
			| LSqBrk
			| Let
			| LogInOp
			| MuLambda
			| Not
			| Number
			| PostBeginOp
			| PostOp
			| PreEndOp
			| PreOp
			| Quant
			| RBrace
			| RBrk
			| RSeqBrk
			| RSqBrk
			| Sch
			| SchInOp
			| SchPreOp
			| Semi
			| Slash
			| Spot
			| St
			| String
			| Stub
			| ThenOp
			| Theta
			| TurnStile
			| UnderBar;
=TEX
There are two classification functions: $classify2$ for use in processing
fixity paragraphs and $classify$ for use everywhere else.
=SML
fun Ûclassify1Ý  (tok : ZTOKEN) : Z_LEX_CLASS = (
	case tok of
		ZTAqTm _	=>	Quotation
	|	ZTId "_"	=> 	Stub
	|	ZTId _		=> 	Id
	|	ZTBeginOp _	=> 	BeginOp
	|	ZTEndOp _	=> 	EndOp
	|	ZTInOp _	=>	InOp
	|	ZTPostBeginOp _ =>	PostBeginOp
	|	ZTThenOp _	=> 	ThenOp
	|	ZTPostOp _	=>	PostOp
	|	ZTPreEndOp _	=>	PreEndOp
	|	ZTPreOp _	=>	PreOp
	|	ZTDecor _	=>	Decor
	|	ZTChar	_	=>	raise PARSER_ERROR "unexpected token"
	|	ZTString _	=>	String
	|	ZTNumber _	=>	Number
	|	ZTAx		=>	Ax
	|	ZTSch		=>	Sch
	|	ZTEnd		=>	raise PARSER_ERROR "unexpected token"
	|	ZTOpen		=>	raise PARSER_ERROR "unexpected token"
	|	ZTIs		=>	Is
	|	ZTSt		=>	St
	|	ZTBar		=>	Bar
	|	ZTAmpersand	=>	Ampersand
	|	ZTÌ		=>	MuLambda
	|	ZTÍ		=>	MuLambda
	|	ZTµ		=>	Quant
	|	ZT¶		=>	Quant
	|	ZT¶1		=>	Quant
	|	ZT³		=>	Not
	|	ZT±		=>	LogInOp
	|	ZT²		=>	LogInOp
	|	ZT¤		=>	LogInOp
	|	ZT´		=>	LogInOp
	|	ZTPre		=>	SchPreOp
	|	ZT		=>	SchPreOp
	|	ZT		=>	SchPreOp
	|	ZTPipe		=>	SchInOp
	|	ZTù		=>	SchInOp
	|	ZT»		=>	SchInOp
	|	ZTLet		=>	Let
	|	ZTFun		=>	FixityClass
	|	ZTGen		=>	FixityClass
	|	ZTRel		=>	FixityClass
	|	ZTLbrace	=>	LBrace
	|	ZTRbrace	=>	RBrace
	|	ZTLbrack	=>	LBrk
	|	ZTRbrack	=>	RBrk
	|	ZTLsqbrack	=>	LSqBrk
	|	ZTRsqbrack	=>	RSqBrk
	|	ZT§		=>	LSeqBrk
	|	ZT¢		=>	RSeqBrk
	|	ZTComma		=>	Comma
	|	ZTDots		=>	Stub
	|	ZTDot		=>	Dot
	|	ZTSlash		=>	Slash
	|	ZTBSlash	=>	BackSlash
	|	ZTFreeTyDef	=>	ColonsEq
	|	ZTColon		=>	Colon
	|	ZTSemi		=>	Semi
	|	ZTVert		=>	Bar
	|	ZTConjecture	=>	TurnStile
	|	ZT¦		=>	EqHat
	|	ZT·		=>	Spot
	|	ZT¸		=>	Cross
	|	ZTÊ		=>	Theta
	|	ZTEos		=>	Eos
);
=TEX
=SML
fun Ûclassify2Ý  (tok : ZTOKEN) : Z_LEX_CLASS = (
	case tok of
		ZTId _ => Id
	|	_ => classify1 tok
);
=TEX
\section{ERROR HANDLING}
=SML
fun Ûformat_z_tokenÝ  (tok : ZTOKEN) : string = (
=SML
	case tok of
		ZTAqTm _	=>	"<term-quotation>"
	|	ZTId s		=> 	s
	|	ZTBeginOp (s,_)	=> 	s
	|	ZTEndOp (s,_)	=> 	s
	|	ZTInOp (s,_)	=>	s
	|	ZTPostBeginOp (s,_) =>	s
	|	ZTThenOp (s,_)	=> 	s
	|	ZTPostOp (s,_)	=>	s
	|	ZTPreEndOp (s,_)=>	s
	|	ZTPreOp (s,_)	=>	s
	|	ZTDecor s	=>	s
	|	ZTChar s	=>	"<unexpected token: " ^ s ^ ">"
	|	ZTString s	=>	"\"" ^ s ^ "\""
	|	ZTNumber n	=>	string_of_int n
	|	ZTAx		=>	"¹ZAX"
	|	ZTSch		=>	"ÿ"
	|	ZTEnd		=>	"<unexpected token: ZTEnd>"
	|	ZTOpen		=>	"<unexpected token: ZTOpen>"
	|	ZTIs		=>	"<Is>"
	|	ZTSt		=>	"÷"
	|	ZTBar		=>	"Ü"
	|	ZTAmpersand	=>	"&"
	|	ZTÌ		=>	"Ì"
	|	ZTÍ		=>	"Í"
	|	ZTµ		=>	"µ"
	|	ZT¶		=>	"¶"
	|	ZT¶1		=>	"¶1"
	|	ZT³		=>	"³"
	|	ZT±		=>	"±"
	|	ZT²		=>	"²"
	|	ZT¤		=>	"¤"
	|	ZT´		=>	"´"
	|	ZTPre		=>	"pre"
	|	ZT		=>	""
	|	ZT		=>	""
	|	ZTPipe		=>	">>"
	|	ZTù		=>	"ù"
	|	ZT»		=>	"»"
	|	ZTLet		=>	"let"
	|	ZTFun		=>	"fun"
	|	ZTGen		=>	"gen"
	|	ZTRel		=>	"rel"
	|	ZTLbrace	=>	"{"
	|	ZTRbrace	=>	"}"
	|	ZTLbrack	=>	"("
	|	ZTRbrack	=>	")"
	|	ZTLsqbrack	=>	"["
	|	ZTRsqbrack	=>	"]"
	|	ZT§		=>	"§"
	|	ZT¢		=>	"¢"
	|	ZTComma		=>	","
	|	ZTDots		=>	"..."
	|	ZTDot		=>	"."
	|	ZTSlash		=>	"/"
	|	ZTBSlash	=>	"\\"
	|	ZTFreeTyDef	=>	"::="
	|	ZTColon		=>	":"
	|	ZTSemi		=>	";"
	|	ZTVert		=>	"|"
	|	ZTConjecture	=>	"ô"
	|	ZT¦		=>	"¦"
	|	ZT·		=>	"·"
	|	ZT¸		=>	"¸"
	|	ZTÊ		=>	"Ê"
	|	ZTEos		=>	"<end-of-input>"
);
=TEX
=SML
fun Ûformat_parse_stackÝ (stk : (ZTOKEN, Z_LEX_CLASS, PP)INPUT_STACK) : string = (
	let	fun aux (Parsed pp) = format_pp pp
		|   aux (Token (tok, _)) = format_z_token tok;
	in	format_list aux stk " "
	end
);
=TEX
$red\_error$ is for use during context-free parsing when a user-error is detected.
The first two arguments give the two inserts for message 61001.
The other two parameters give the message to print after the 61001 lines.
After the diagnostic print-out the function fails with message 61000
and area "Z-Parser".
=SML
fun Ûred_errorÝ
	(okpart : (ZTOKEN, Z_LEX_CLASS, PP)INPUT_STACK)
	(badpart : (ZTOKEN, Z_LEX_CLASS, PP)INPUT_STACK)
	(msg : int)
	(inserts : string list) : 'a = (
	diag_string (get_error_message
			61001
			[format_parse_stack okpart,  format_parse_stack badpart]);
	diag_string (get_error_message msg inserts);
	fail "Z-Parser" 61000 []
);
=TEX
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun Ûstack_errorÝ (insert : string)
	(stk : (ZTOKEN, Z_LEX_CLASS, PP)INPUT_STACK) : 'a = (
	diag_string("Internal error in Z-parser: stack print:" ^
		PolyML.makestring stk);
	error "Z-Parser"  19005 [fn() => insert]
);
=TEX
\section{REDUCTION FUNCTIONS}
As with the HOL parser, adding type constraints to the reductions functions
would be both unhelpful and very time-consuming and so in this section
we deliberately suspend that aspect of the coding standards of
\cite{DS/FMU/IED/PLN007}.

We give the reduction functions in the order of their appearance
in the grammar of \cite{DS/FMU/IED/DTD061}. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.
=TEX
=SML
fun Ûred_acceptÝ (Parsed x) _ = (x
) | red_accept x1 stk = stack_error "red_accept" (x1::stk);
=TEX
=SML
val Ûred_fixityÝ = red_accept;
val Ûred_general_termÝ = red_accept;
val Ûred_abb_defÝ = red_accept;
val Ûred_free_type_defÝ = red_accept;
val Ûred_ax_boxÝ = red_accept;
val Ûred_conjectureÝ = red_accept;
=TEX
=SML
fun Ûred_templatesÝ (Token (tk, _)) (Parsed (PPTemplates tmpls)) stk = (
	PPParagraph
	(case tk of
		ZTFun => ParFixity(ZClFun 0, tmpls)
	|	ZTGen => ParFixity(ZClGen 0, tmpls)
	|	ZTRel => ParFixity(ZClRel, tmpls)
	|	_ => raise PARSER_ERROR "red_templates")
) | red_templates x1 x2 stk = stack_error "red_templates(2)" (x1::x2::stk);
=TEX
=SML
fun Ûred_prec_templatesÝ (Token (tk, c1)) (Token (ZTNumber p, c2))
	(Parsed (PPTemplates tmpls)) stk = (
	PPParagraph
	(case tk of
		ZTFun => ParFixity(ZClFun p, tmpls)
	|	ZTGen => ParFixity(ZClGen p, tmpls)
	|	ZTRel =>
			red_error
			((Token (tk, c1)) :: stk) [Token (ZTNumber p, c2)]
			61010 []
	|	other => raise PARSER_ERROR "red_prec_templates")
) | red_prec_templates x1 x2 x3 stk = stack_error "red_prec_templates(2)" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_acceptÝ (Parsed pp) _ = (pp
) | red_accept x1 stk = stack_error "red_accept" (x1::stk);
=TEX
=SML
val Ûred_templateÝ = red_accept;
=TEX
=SML
fun Ûred_template_templatesÝ
	(Parsed(PPTemplates [tmpl])) _ (Parsed(PPTemplates tmpls)) _ = (
	PPTemplates (tmpl :: tmpls)
) | red_template_templates x1 x2 x3 stk = stack_error "red_template_templates" (x1::x2::x3::stk);
=TEX
=TEX
=SML
val Ûred_stub_idsÝ = red_accept;
=TEX
=SML
val Ûred_id_stubsÝ = red_accept;
=TEX
=SML
fun dest_stub (ZTDots : ZTOKEN) = StubUS
|   dest_stub (ZTId "_") = StubEll
|   dest_stub stk = raise PARSER_ERROR "dest_stub";
=TEX
=SML
fun Ûred_stub_idÝ (Token(st, _)) (Token((ZTId nm), _)) _ = (
	PPTemplates[TmplPost(dest_stub st, (nm, Nil))]
) | red_stub_id x1 x2 stk = stack_error "red_stub_id" (x1::x2::stk);
=TEX
=SML
fun Ûred_stub_id_stubÝ
	(Token(st1, _))
	(Token(ZTId nm, _))
	(Token(st2, _)) _ = (
	PPTemplates[TmplIn(dest_stub st1, (nm, Nil), dest_stub st2)]
) |   red_stub_id_stub x1 x2 x3 stk = stack_error "red_stub_id_stub" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_stub_id_stub_idsÝ (Token(st1, _)) (Token((ZTId nm), _))
		(Parsed(PPTemplates[(TmplIn(st2, (nm2, Nil), st3))])) _ = (
	PPTemplates[TmplIn(dest_stub st1, (nm, Value([], (st2, nm2))), st3)]
) | red_stub_id_stub_ids (Token(st1, _)) (Token((ZTId nm1), _))
		(Parsed(PPTemplates[(TmplIn(st2, (nm2, Value (stids, stid)), st3))])) _ = (
	PPTemplates[TmplIn(dest_stub st1, (nm1, Value((st2, nm2) :: stids, stid)), st3)]
) | red_stub_id_stub_ids (Token(st1, _)) (Token((ZTId nm1), _))
		(Parsed(PPTemplates[(TmplPost(st2, (nm2, Nil)))])) _ = (
	PPTemplates[TmplPost(dest_stub st1, (nm1, Value([], (st2, nm2))))]
) | red_stub_id_stub_ids (Token(st1, _)) (Token((ZTId nm1), _))
		(Parsed(PPTemplates[(TmplPost(st2, (nm2, Value (stids, stid))))])) _ = (
	PPTemplates[TmplPost(dest_stub st1, (nm1, Value((st2, nm2) :: stids, stid)))]
) | red_stub_id_stub_ids x1 x2 x3 stk = stack_error "red_stub_id_stub_ids" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_id_stubÝ (Token((ZTId nm), _)) (Token(st, _)) _ =  (
	PPTemplates[TmplPre((nm, Nil), dest_stub st)]
) | red_id_stub x1 x2 stk = stack_error "red_id_stub" (x1::x2::stk);
=TEX
=SML
fun Ûred_id_stub_idÝ (Token((ZTId nm1), _)) (Token(st, _)) (Token((ZTId nm2), _)) _ = (
	PPTemplates[TmplNon((nm1, Value([], (dest_stub st, nm2))))]
) | red_id_stub_id x1 x2 x3 stk = stack_error "red_id_stub_id" (x1::x2::x3::stk);
=TEX
=SML
fun red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplPre((nm2, Nil), st2))])) _ = (
	PPTemplates[TmplPre((nm1, Value([], (dest_stub st1, nm2))), st2)]
) | red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplPre((nm2, Value(stids, stid)), st2))])) _ = (
	PPTemplates[TmplPre((nm1, Value((dest_stub st1, nm2) :: stids, stid)), st2)]
) | red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplNon((nm2, Nil)))])) _ = (
	PPTemplates[TmplNon(nm1, Value([], (dest_stub st1, nm2)))]
) | red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplNon((nm2, Value(stids, stid))))])) _ = (
	PPTemplates[TmplNon(nm1, Value((dest_stub st1, nm2) :: stids, stid))]
) | red_id_stub_id_stubs x1 x2 x3 stk = stack_error "red_id_stub_id_stubs" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_predÝ (Parsed (PPPred p)) _ = (
	PPParagraph(ParGeneralTerm (p, Nil))
) | red_pred x1 stk = stack_error "red_pred" (x1::stk);
=TEX
=SML
fun Ûred_pred_constraintÝ (Parsed (PPPred p1)) _ (Parsed (PPPred p2)) _ = (
	PPParagraph(ParGeneralTerm (p1, Value p2))
) | red_pred_constraint x1 x2 x3 stk = stack_error "red_pred_constraint" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_eq_defÝ (Parsed (PPEqDef d)) _ = (
	PPParagraph(ParAbbDef(ADEqDef d))
) | red_eq_def x1 stk = stack_error "red_eq_def" (x1::stk);
=TEX
=SML
fun Ûred_schemaÝ
	_ (Parsed (PPPred s))
	_ (Parsed (PPDecl d))
	_ (Parsed (PPPred p)) _ = (
	PPParagraph(ParAbbDef(ADSchemaBox(s, d, Value p)))
) | red_schema x1 x2 x3 x4 x5 x6 stk = stack_error "red_schema" (x1::x2::x3::x4::x5::x6::stk);
=TEX
=SML
fun Ûred_schema_no_predÝ
	_ (Parsed (PPPred s))
	_ (Parsed (PPDecl d)) _ = (
	PPParagraph(ParAbbDef(ADSchemaBox(s, d, Nil)))
) | red_schema_no_pred x1 x2 x3 x4 stk = stack_error "red_schema_no_pred" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_deflhs_predÝ (Parsed (PPPred d)) _ (Parsed (PPPred p)) _ = (
	PPEqDef(d, p)
) | red_deflhs_pred x1 x2 x3 stk = stack_error "red_deflhs_pred" (x1::x2::x3::stk);
=TEX
=SML
val Ûred_expr1_as_def_lhsÝ = red_accept;
=TEX
=SML
fun Ûred_a_free_typeÝ (Parsed (PPPred t)) _ (Parsed (PPSomeExprs bs)) _ = (
	PPParagraph(ParFreeTypeDef[(t, bs)])
) | red_a_free_type x1 x2 x3 stk = stack_error "red_a_free_type" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_free_typesÝ
	(Parsed (PPPred t)) _
	(Parsed (PPSomeExprs bs)) _
	(Parsed (PPParagraph(ParFreeTypeDef fts))) _ = (
	PPParagraph(ParFreeTypeDef((t, bs) :: fts))
) | red_free_types x1 x2 x3 x4 x5 stk = stack_error "red_free_types" (x1::x2::x3::x4::x5::stk);
=TEX
=SML
fun Ûred_accept_pred_as_list Ý (Parsed (PPPred p)) _ = (
	PPSomeExprs [p]
) | red_accept_pred_as_list x1 stk = stack_error "red_accept_pred_as_list" (x1::stk);
=TEX
=SML
val Ûred_pred_as_branchÝ = red_accept_pred_as_list;
=TEX
The following auxiliary is not itself ever used directly as a reduction
function (since constructs giving rise to predicate lists in the abstract
syntax have a variety of styles for separating the predicates)
=SML
fun Ûadd_pred_to_list_auxÝ (Parsed (PPPred p)) (Parsed (PPSomeExprs ps)) stk = (
	PPSomeExprs (p :: ps)
) | add_pred_to_list_aux x1 x2 stk = stack_error "add_pred_to_list_aux" (x1::x2::stk);
=TEX
=SML
fun Ûred_branchesÝ pp _ pb stk  = (
	add_pred_to_list_aux pp pb stk
);
=TEX
=SML
fun Ûred_ax_box_no_predÝ _ (Parsed (PPDecl d)) _ = (
	PPParagraph(ParAxBox([], d, Nil))
) | red_ax_box_no_pred x1 x2 stk = stack_error "red_ax_box_no_pred" (x1::x2::stk);
=TEX
=SML
fun Ûred_gen_ax_box_no_predÝ 
	_ _ (Parsed (PPSomeExprs ps))
	_ _ (Parsed (PPDecl d)) _ = (
	PPParagraph(ParAxBox(ps, d, Nil))
) | red_gen_ax_box_no_pred x1 x2 x3 x4 x5 x6 stk = stack_error "red_gen_ax_box_no_pred" (x1::x2::x3::x4::x5::x6::stk);
=TEX
=SML
fun Ûred_ax_box_predÝ 
	_ (Parsed (PPDecl d))
	_ (Parsed (PPPred p)) _ = (
	PPParagraph(ParAxBox([], d, Value p))
) | red_ax_box_pred x1 x2 x3 x4 stk = stack_error "red_ax_box_pred" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_gen_ax_boxÝ 
	_ _ (Parsed (PPSomeExprs ps))
	_ _ (Parsed (PPDecl d))
	_ (Parsed (PPPred p)) _ = (
	PPParagraph(ParAxBox(ps, d, Value p))
) | red_gen_ax_box x1 x2 x3 x4 x5 x6 x7 x8  stk = stack_error "red_gen_ax_box" (x1::x2::x3::x4::x5::x6::x7::x8::stk);
=TEX
=SML
fun Ûred_no_id_conjectureÝ _ (Parsed(PPPred p)) _ = (
	PPParagraph(ParConjecture(Nil, p))
) | red_no_id_conjecture x1 x2 stk = stack_error "red_no_id_conjecture" (x1::x2::stk);
=TEX
=SML
fun Ûred_id_conjectureÝ (Token(ZTId i, _)) _ (Parsed(PPPred p)) _ = (
	PPParagraph(ParConjecture(Value i, p))
) | red_id_conjecture x1 x2 x3 stk = stack_error "red_id_conjecture" (x1::x2::x3::stk);
=TEX
=SML
val Ûred_pred1_as_predÝ = red_accept;
=TEX
=SML
fun Ûred_pred_semi_predÝ (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred (PredSemi (p1, p2))
) | red_pred_semi_pred x1 x2 x3 stk = stack_error "red_pred_semi_pred" (x1::x2::x3::stk);
=TEX
=SML
val Ûred_pred2_as_pred1Ý = red_accept;
=TEX
=SML
fun Ûquant_auxÝ (Token (ZTµ, _)) = ForAll
|   quant_aux (Token (ZT¶, _)) = Exists
|   quant_aux (Token (ZT¶1, _)) = ExistsUnique
|   quant_aux stk = raise PARSER_ERROR "quant_aux";
=TEX
=SML
fun Ûred_quantÝ
	q (Parsed(PPDecl d))
	_ (Parsed(PPPred p1))
	_ (Parsed(PPPred p2)) _ = (
	PPPred(PredQuantifier(quant_aux q, d, Value p1, p2))
) | red_quant x1 x2 x3 x4 x5 x6 stk = stack_error "red_quant" (x1::x2::x3::x4::x5::x6::stk);
=TEX
=SML
fun Ûred_quant_no_barÝ
	q (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ = (
	PPPred(PredQuantifier(quant_aux q, d, Nil, p))
) | red_quant_no_bar x1 x2 x3 x4 stk = stack_error "red_quant_no_bar" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_letÝ _ (Parsed(PPEqDefs e)) _ (Parsed(PPPred p)) _ = (
	PPPred(PredLet(e, p))
) | red_let x1 x2 x3 x4 stk = stack_error "red_let" (x1::x2::x3::x4::stk);
=TEX
=SML
val Ûred_pred3_as_pred2Ý = red_accept;
=TEX
=SML
fun Ûlog_in_op_auxÝ (Token (ZT±, _)) = And
|   log_in_op_aux (Token (ZT², _)) = Or
|   log_in_op_aux (Token (ZT´, _)) = Implies
|   log_in_op_aux (Token (ZT¤, _)) = Iff
|   log_in_op_aux stk = raise PARSER_ERROR "log_in_op_aux";
=TEX
=SML
fun Ûred_log_in_opÝ (Parsed(PPPred p1)) lop (Parsed(PPPred p2)) _ = (
	PPPred (PredLogInOp (p1, log_in_op_aux lop, p2))
) | red_log_in_op x1 x2 x3 stk = stack_error "red_log_in_op" (x1::x2::x3::stk);
=TEX
=SML
val Ûred_schema2_as_pred3Ý = red_accept;
=TEX
=SML
fun Ûred_negÝ _ (Parsed(PPPred p)) _ = (
	PPPred(PredNot p)
) | red_neg x1 x2 stk = stack_error "red_neg" (x1::x2::stk);
=TEX
=SML
val Ûred_schema3_as_schema2Ý = red_accept;
=TEX
=SML
fun Ûsch_in_op_auxÝ (Token (ZTPipe, _)) = Pipe
|   sch_in_op_aux (Token (ZTù, _)) = Filter
|   sch_in_op_aux (Token (ZT», _)) = Comp
|   sch_in_op_aux _ = raise PARSER_ERROR "sch_in_op_aux";
=TEX
=SML
fun Ûred_sch_in_opÝ (Parsed(PPPred p1)) sop (Parsed(PPPred p2)) _ = (
	PPPred (PredSchInOp (p1, sch_in_op_aux sop, p2))
) | red_sch_in_op x1 x2 x3 stk = stack_error "red_sch_in_op" (x1::x2::x3::stk);
=TEX
=SML
val Ûred_schema4_as_schema3Ý = red_accept;
=TEX
=SML
fun Ûsch_pre_op_auxÝ (Token (ZTPre, _)) = Pre
|   sch_pre_op_aux (Token (ZT, _)) = Delta
|   sch_pre_op_aux (Token (ZT, _)) = Xi
|   sch_pre_op_aux _ = raise PARSER_ERROR "sch_pre_op_aux";
=TEX
=SML
fun Ûred_sch_pre_opÝ pop (Parsed(PPPred p)) _ = (
	PPPred (PredSchPreOp (sch_pre_op_aux pop, p))
) | red_sch_pre_op x1 x2 stk = stack_error "red_sch_pre_op" (x1::x2::stk);
=TEX
=SML
val Ûred_expr0_as_schema4Ý = red_accept;
=TEX
=SML
fun Ûred_schema_hidingÝ (Parsed(PPPred p)) _ _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred (PredSchemaHiding (p, ps))
) | red_schema_hiding x1 x2 x3 x4 x5 stk = stack_error "red_schema_hiding" (x1::x2::x3::x4::x5::stk);
=TEX
=SML
fun Ûred_rename_listÝ _ (Parsed r) _ _ = (
	r
) | red_rename_list x1 x2 x3 stk = stack_error "red_rename_list" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_renameÝ (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred (PredRenameList[(p1, p2)])
) | red_rename x1 x2 x3 stk = stack_error "red_rename" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_renamesÝ
	(Parsed(PPPred p1)) _
	(Parsed(PPPred p2)) _
	(Parsed(PPPred(PredRenameList rs))) _ = (
	PPPred (PredRenameList((p1, p2)::rs))
) | red_renames x1 x2 x3 x4 x5 stk = stack_error "red_renames" (x1::x2::x3::x4::x5::stk);
=TEX
As a minor efficiency improvement we accumulate declarations backwards
and reverse the list when the entire declaration has been recognised:
=SML
fun Ûred_decl_minus_predÝ (Parsed(PPDecl rd)) _ = (
	PPDecl (rev rd)
) | red_decl_minus_pred x1 stk = stack_error "red_decl_minus_pred" (x1::stk);
=TEX
=SML
fun Ûred_pred1_as_declÝ
	(Parsed(PPSomeExprs es)) _ = (
	PPDecl [(es, Nil)]
) | red_pred1_as_decl x1 stk = stack_error "red_pred1_as_decl" (x1::stk);
=TEX
=SML
fun Ûred_decl_semi_var_decs_pred1Ý
	(Parsed(PPDecl rd))
	(Parsed(PPSomeExprs es)) _
	(Parsed(PPPred p)) _ = (
	PPDecl ((es, Value p) :: rd)
) | red_decl_semi_var_decs_pred1 x1 x2 x3 x4 stk = stack_error "red_decl_semi_var_decs_pred1" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_decl_semi_pred1Ý
	(Parsed(PPDecl rd))
	(Parsed(PPSomeExprs es)) _ = (
	PPDecl ((es, Nil) :: rd)
) | red_decl_semi_pred1 x1 x2 stk = stack_error "red_decl_semi_pred1" (x1::x2::stk);
=TEX
=SML
fun Ûred_var_decs_pred1Ý
	(Parsed(PPSomeExprs es)) _
	(Parsed(PPPred p)) _ = (
	PPDecl [(es, Value p)]
) | red_var_decs_pred1 x1 x2 x3 stk = stack_error "red_var_decs_pred1" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_var_decs_pred1_semiÝ x1 x2 x3 _ stk = (
	red_var_decs_pred1 x1 x2 x3 stk
);
=TEX
=SML
fun Ûred_pred1_as_decl_semiÝ (Parsed(PPSomeExprs es)) _ _ = (
		PPDecl [(es, Nil)]
) | red_pred1_as_decl_semi x1 x2 stk = stack_error "red_pred1_as_decl_semi" (x1::x2::stk);
=TEX
=SML
=SML
fun Ûred_decl_semi_var_decs_pred1_semiÝ x1 x2 x3 x4 _ stk= (
	red_decl_semi_var_decs_pred1 x1 x2 x3 x4 stk
);
=TEX
=SML
fun Ûred_decl_semi_pred1_semiÝ x1 x2 _ stk = (
	red_decl_semi_pred1 x1 x2 stk
);
=TEX
=SML
val Ûred_expr1_as_expr0Ý = red_accept;
=TEX
=SML
fun Ûmu_lambda_auxÝ (Token (ZTÍ, _)) = PredMu
|   mu_lambda_aux (Token (ZTÌ, _)) = PredLambda
|   mu_lambda_aux _ = raise PARSER_ERROR "mu_lambda_aux";;
=TEX
=SML
fun Ûred_mu_lambda_no_predÝ
	mu_lambda
	(Parsed(PPDecl dec)) _
	(Parsed(PPPred p)) _ = (
	 PPPred(mu_lambda_aux mu_lambda (dec, Nil, Value p))
) | red_mu_lambda_no_pred x1 x2 x3 x4 stk = stack_error "red_mu_lambda_no_pred" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_mu_lambdaÝ
	mu_lambda
	(Parsed(PPDecl dec)) _
	(Parsed(PPPred p1)) _
	(Parsed(PPPred p2)) _ = (
	 PPPred(mu_lambda_aux mu_lambda (dec, Value p1, Value p2))
) | red_mu_lambda x1 x2 x3 x4 x5 x6 stk = stack_error "red_mu_lambda" (x1::x2::x3::x4::x5::x6::stk);
=TEX
=SML
fun Ûred_eq_def_as_eq_defsÝ (Parsed(PPEqDef ed)) _ = (
	PPEqDefs [ed]
) | red_eq_def_as_eq_defs x1 stk = stack_error "red_eq_def_as_eq_defs" (x1::stk);
=TEX
=SML
fun Ûred_eq_defsÝ (Parsed(PPEqDef ed)) _ (Parsed(PPEqDefs eds)) _ = (
	PPEqDefs (ed :: eds)
) | red_eq_defs x1 x2 x3 stk = stack_error "red_eq_defs" (x1::x2::x3::stk);
=TEX
=SML
val Ûred_expr2_as_expr1Ý = red_accept;
=TEX
This phase fills in all stubs in templates as underscores. It is left to
the second phase to check the templates and fill in the correct stubs.
=SML
fun Ûred_pre_opÝ (Token (ZTPreOp (i,_), _)) (Parsed(PPPred p)) _ = (
	PPPred(PredFancyFix(TmplPre((i,Nil), StubUS), "", [[p]]))
) | red_pre_op x1 x2 stk = stack_error "red_pre_op" (x1::x2::stk);
=TEX
=SML
fun Ûred_post_opÝ (Parsed(PPPred p)) (Token (ZTPostOp (i,_), _)) _ = (
	PPPred(PredFancyFix(TmplPost(StubUS, (i,Nil)), "", [[p]]))
) | red_post_op x1 x2 stk = stack_error "red_post_op" (x1::x2::stk);
=TEX
=SML
=TEX
=SML
fun Ûred_in_opÝ (Parsed(PPPred p1)) (Token (ZTInOp (i,_), _))
		(Parsed(PPPred p2)) _ = (
	PPPred(PredFancyFix(TmplIn(StubUS, (i,Nil), StubUS), "", [[p1], [p2]]))
) | red_in_op x1 x2 x3 stk = stack_error "red_in_op" (x1::x2::x3::stk);
=TEX
=SML
fun Ûcore_auxÝ (i1 : ID) ((arg1, rest) : CORE_EXPR) (i2 : ID)
	: CORE * ((PRED list) list) = (
	(	(i1, Value (map (fn (i, _) => (StubUS, i)) rest, (StubUS, i2))),
		arg1 :: map (fn (_, arg) => arg)  rest)
);
=TEX
=SML
fun Ûred_bo_ce_eoÝ (Token (ZTBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce)) (Token (ZTEndOp (e,_), _)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplNon c, "", args))
	end
) | red_bo_ce_eo x1 x2 x3 stk = stack_error "red_bo_ce_eo" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_bo_ce_peoÝ (Token (ZTBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce))
		(Token (ZTPreEndOp (e,_), _))
		(Parsed(PPPred p)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplPre(c, StubUS), "", args @ [[p]]))
	end
) | red_bo_ce_peo x1 x2 x3 x4 stk = stack_error "red_bo_ce_peo" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_pbo_ce_eoÝ (Parsed(PPPred p))
		(Token (ZTPostBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce))
		(Token (ZTEndOp (e,_), _)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplPost(StubUS, c), "", [p] :: args))
	end
) | red_pbo_ce_eo x1 x2 x3 x4 stk = stack_error "red_pbo_ce_eo" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_pbo_ce_peoÝ (Parsed(PPPred p1))
		(Token (ZTPostBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce))
		(Token (ZTPreEndOp (e,_), _))
		(Parsed(PPPred p2)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplIn(StubUS, c, StubUS), "", [p1]::args@[[p2]]))
	end
) | red_pbo_ce_peo x1 x2 x3 x4 x5 stk = stack_error "red_pbo_ce_peo" (x1::x2::x3::x4::x5::stk);
=TEX
=SML
fun Ûred_crossÝ (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred(PredCrossProduct(
		case (p1, p2) of
			(PredCrossProduct ps1, PredCrossProduct ps2) => ps1 @ ps2
		|	(PredCrossProduct ps1, _) => ps1 @ [p2]
		|	(_, PredCrossProduct ps2) => p1 :: ps2
		|	(_, _) => [p1, p2]))
) | red_cross x1 x2 x3 stk = stack_error "red_cross" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_exprsÝ (Parsed (PPSomeExprs ps)) _ = (
	PPCoreExpr(ps, [])
) | red_exprs x1 stk = stack_error "red_exprs" (x1::stk);
=TEX
=SML
fun Ûred_es_to_ceÝ
		(Parsed (PPSomeExprs ps))
		(Token (ZTThenOp (e,_), _))
		(Parsed (PPCoreExpr (a, r))) _ = (
	PPCoreExpr(ps, (e, a) :: r)
) | red_es_to_ce x1 x2 x3 stk = stack_error "red_es_to_ce" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_no_exprsÝ _ = (
	PPSomeExprs []
);
=TEX
=SML
val Ûred_some_exprsÝ = red_accept;
=TEX
=SML
val Ûred_pred1_as_some_exprsÝ = red_accept_pred_as_list;
=TEX
=SML
fun Ûred_pred1_comma_some_exprsÝ p _ ps stk = (
	add_pred_to_list_aux p ps stk
);
=TEX
=SML
val Ûred_expr3_as_expr2Ý = red_accept;
=TEX
=SML
fun Ûred_powÝ _ (Parsed (PPPred p)) _ = (
	PPPred(PredPow p)
) | red_pow x1 x2 stk = stack_error "red_pow" (x1::x2::stk);
=TEX
=SML
val Ûred_expr4_as_expr3Ý = red_accept;
=TEX
=SML
fun Ûred_expr3_expr4Ý (Parsed(PPPred p1)) (Parsed(PPPred p2)) _ = (
	PPPred(PredApplication(p1, p2))
) | red_expr3_expr4 x1 x2 stk = stack_error "red_expr3_expr4" (x1::x2::stk);
=TEX
=SML
fun Ûred_thetaÝ _ (Parsed(PPPred p)) _ = (
	PPPred(PredTheta p)
) | red_theta x1 x2 stk = stack_error "red_theta" (x1::x2::stk);
=TEX
=SML
fun Ûred_expr3_dot_expr4Ý (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred(PredSelection(p1, p2))
) | red_expr3_dot_expr4 x1 x2 x3 stk = stack_error "red_expr3_dot_expr4" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_id_dec_as_expÝ (Parsed(PPIdDec id)) _ = (
	PPPred(PredIdDec id)
) | red_id_dec_as_exp x1 stk = stack_error "red_id_dec_as_exp" (x1::stk);
=TEX
=SML
fun Ûred_quotationÝ (Token(ZTAqTm tm, _)) _ = (
	PPPred(PredQuotation tm)
) | red_quotation x1 stk = stack_error "red_quotation" (x1::stk);
=TEX
=SML
fun Ûstub_auxÝ (Token (ZTId "_", _)) = StubUS
|   stub_aux (Token (ZTDots, _)) = StubEll
|   stub_aux _ = raise PARSER_ERROR "stub_aux";
=TEX
=SML
fun Ûred_stubÝ tk _ = (
	PPPred(PredPlaceHolder(stub_aux tk))
);
=TEX
=SML
fun Ûred_numberÝ (Token (ZTNumber n, _)) _ = (
	PPPred(PredNumber n)
) | red_number x1 stk = stack_error "red_number" (x1::stk);
=TEX
=SML
fun Ûred_stringÝ (Token (ZTString s, _)) _ = (
	PPPred(PredString s)
) | red_string x1 stk = stack_error "red_string" (x1::stk);
=TEX
=SML
fun Ûred_tupleÝ _ (Parsed(PPPred p)) _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredTuple(p :: ps))
) | red_tuple x1 x2 x3 x4 x5 stk = stack_error "red_tuple" (x1::x2::x3::x4::x5::stk);
=TEX
=SML
fun Ûred_set_displayÝ _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredSetDisplay ps)
) | red_set_display x1 x2 x3 stk = stack_error "red_set_display" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_sequence_brkÝ _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredSeqDisplay ps)
) | red_sequence_brk x1 x2 x3 stk = stack_error "red_sequence_brk" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_set_comp_no_spotÝ
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ _ = (
	PPPred(PredSetComp(d, Value p, Nil))
) | red_set_comp_no_spot x1 x2 x3 x4 x5 stk = stack_error "red_set_comp_no_spot" (x1::x2::x3::x4::x5::stk);
=TEX
=SML
fun Ûred_set_comp_no_predÝ
	_ (Parsed(PPDecl d)) _ _ = (
	PPPred(PredSetComp(d, Nil, Nil))
) | red_set_comp_no_pred x1 x2 x3 stk = stack_error "red_set_comp_no_pred" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_set_compÝ
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p1))
	_ (Parsed(PPPred p2)) _ _ = (
	PPPred(PredSetComp(d, Value p1, Value p2))
) | red_set_comp x1 x2 x3 x4 x5 x6 x7 stk = stack_error "red_set_comp" (x1::x2::x3::x4::x5::x6::x7::stk);
=TEX
=SML
fun Ûred_set_comp_no_barÝ
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ _ = (
	PPPred(PredSetComp(d, Nil, Value p))
) | red_set_comp_no_bar x1 x2 x3 x4 x5 stk = stack_error "red_set_comp_no_bar" (x1::x2::x3::x4::x5::stk);
=TEX
=SML
fun Ûred_horiz_schemaÝ
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ _ = (
	PPPred(PredHorizSchema(d, Value p))
) | red_horiz_schema x1 x2 x3 x4 x5 stk = stack_error "red_horiz_schema" (x1::x2::x3::x4::x5::stk);
=TEX
=SML
fun Ûred_horiz_schema_no_predÝ
	_ (Parsed(PPDecl d)) _ _ = (
	PPPred(PredHorizSchema(d, Nil))
) | red_horiz_schema_no_pred x1 x2 x3 stk = stack_error "red_horiz_schema_no_pred" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_gen_instÝ _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredGenInst ps)
) | red_gen_inst x1 x2 x3 stk = stack_error "red_gen_inst" (x1::x2::x3::stk);
=TEX
=SML
val Ûred_rename_list_as_exprÝ = red_accept;
=TEX
=SML
fun Ûred_brk_predÝ _ (Parsed(PPPred p)) _ _ = (
	PPPred(PredBracketed (p, ""))
) | red_brk_pred x1 x2 x3 stk = stack_error "red_brk_pred" (x1::x2::x3::stk);
=TEX
=SML
fun Ûred_pred_decorÝ _ (Parsed(PPPred p)) _ (Token (ZTDecor d, _)) _ = (
	PPPred(PredBracketed (p, d))
) | red_pred_decor x1 x2 x3 x4 stk = stack_error "red_pred_decor" (x1::x2::x3::x4::stk);
=TEX
=SML
fun Ûred_idÝ (Token (ZTId i, _)) _ = (
	PPIdDec (i, "")
) | red_id x1 stk = stack_error "red_id" (x1::stk);
=TEX
=SML
fun Ûred_id_decÝ (Token (ZTId i, _)) (Token (ZTDecor d, _)) _ = (
	PPIdDec (i, d)
) | red_id_dec x1 x2 stk = stack_error "red_id_dec" (x1::x2::stk);
=TEX
\section{CONFLICT RESOLUTION}
The simple conflict resolution technique is adequate, i.e. just
using $siple\_resolver$ from \cite{DS/FMU/IED/DTD017}. To do this
we just need to define a function to compare the precedence of
two fancyfix operators. We have to bear in mind the various
rules of \cite{DS/FMU/IED/DEF007}.

There are 22 shift/reduce conflicts to attend to. We can reconcile
this with the grammar of \cite{DS/FMU/IED/DTD061} as shown in the
following table (in which we use the names of the reduction functions,
with the leading $red\_$ dropped
to identify the alternatives in the productions):

\begin{tabular}{|l|l|l|l|}\hline
Alternative & No. of Conflicts & First Token & Second Token(s) \\\hline
$log\_in\_op$	& 1	& $LogInOp$	& $LogInOp$ \\\hline
$sch\_in\_op$	& 1	& $SchInOp$	& $SchInOp$ \\\hline
$pre\_op$	& 4	& $PreOp$	& $Cross$, $PostBeginOp$, $InOp$, $PostOp$\\\hline
$in\_op$	& 4	& $InOp$	& $Cross$, $PostBeginOp$, $InOp$, $PostOp$\\\hline
$bo\_ce\_peo$	& 4	& $PreEndOp$	& $Cross$, $PostBeginOp$, $InOp$, $PostOp$\\\hline
$pbo\_ce\_peo$	& 4	& $PreEndOp$	& $Cross$, $PostBeginOp$, $InOp$, $PostOp$\\\hline
$cross$		& 4	& $Cross$	& $Cross$, $PostBeginOp$, $InOp$, $PostOp$\\\hline
\end{tabular}

We encode the precedence using pairs of integers so that we can implement
the three-tiered rules given for the fancy-fix forms (in which all the
$rel$s have (equal) lowest precedence and all the $gen$s have lower
precedence than $Cross$ which has lower precedence than all the $fun$s).
The second component of the pair is 0 in the case of
$LogInOp$ and $SchInOp$. The following table describes the two components
of the pair:

\begin{tabular}{|l|l|l|}\hline
Symbol		& $fst$ & $snd$ \\\hline
$LogInOp$	& 0	& $¤ í 0$, $´ í 1$, $² í 2$, $± í 3$\\\hline
$SchInOp$	& 1	& $» í 0$, $ù í 1$, ${>}{>} í 2$ \\\hline
$rel$		& 2	& 0 (only relevant in extended Z) \\\hline
$gen$		& 3	& user-defined \\\hline
$Cross$		& 4	& 0 \\\hline
$fun$		& 5 	& user-defined \\\hline
\end{tabular}

Given a token, the following function computes the precedence pair:
=SML
local
fun  Ûgive_class_precÝ (cl : CLASS) : (int * int) = (
	case cl of
		(ZClFun prc) => (5, prc)
	|	(ZClGen prc) => (3, prc)
	|	ZClRel => (2, 0)
);
in
fun Ûgive_precÝ  (tok : ZTOKEN) : (int * int) = (
	case tok of
		ZTInOp (_, cl)		=>	give_class_prec cl
	|	ZTPostBeginOp (_, cl)	=>	give_class_prec cl
	|	ZTPostOp (_, cl)	=>	give_class_prec cl
	|	ZTPreEndOp (_, cl)	=>	give_class_prec cl
	|	ZTPreOp (_, cl)		=>	give_class_prec cl
	|	ZT¸			=>	(4, 0)
	|	ZT±			=>	(0, 3)
	|	ZT²			=>	(0, 2)
	|	ZT´			=>	(0, 1)
	|	ZT¤			=>	(0, 0)
	|	ZTPipe			=>	(1, 2)
	|	ZTù			=>	(1, 1)
	|	ZT»			=>	(1, 0)
	|	_			=>	(0, 0)
);
end;
=TEX
The following function compares two token-class pairs and gives the appropriate
resolution as required by the function $simple\_resolver$.
Note that we currently take all operators as right-associative if
their precedences are equal.
=SML
fun Ûz_resolverÝ
	(((toka, _), (tokb, _)) : (ZTOKEN * Z_LEX_CLASS) * (ZTOKEN * Z_LEX_CLASS))
	: RESOLUTION = (
	let	val (a1, a2) = give_prec toka;
		val (b1, b2) = give_prec tokb
	in	if a1 < b1 orelse (a1 = b1 andalso a2 <=  b2)
		then DoShift
		else DoReduce
	end
);
=TEX
\section{READER FUNCTION}
The following function is used to ``read'' a token off a list of same:
=SML
fun ÛzreaderÝ (ip : ZTOKEN list) : ZTOKEN * (ZTOKEN list) = (
	case ip of
		(h :: more) => (h, more)
	|	[] => (ZTEos, [])
);
=TEX
\section{SYNTAX ERROR HANDLING}
The following function produces t
=SML
val ÛzerrorÝ : (ZTOKEN, Z_LEX_CLASS, PP, 'd) ERROR_ROUTINE = (fn (tok, stk, _, _) => (
	diag_string (get_error_message 61001 [format_parse_stack stk,
				format_z_token tok]);
	diag_string (get_error_message 61003 [format_z_token tok,
				format_stack format_z_token stk]);
	raise SYNTAX_ERROR
));
=TEX
\section{PHASE 1}
=SML
fun Ûphase_1Ý (ip : ZTOKEN list) : PP = (
	let	val classify = (
			if not(is_nil ip)
				andalso classify1 (hd ip) = FixityClass 
			then	classify2
			else	classify1
		);
		val res = (Value(slrp'gen_parser
					(simple_resolver z_resolver) classify1
					zerror
					zreader ip))
			handle	SYNTAX_ERROR => Nil
			|	PARSER_ERROR msg => (
					error "Z-Parser" 61007 [fn()=>msg]
				);
	in	case res of
			Value thing => thing
		|	Nil => fail "Z-Parser" 61000 []
	end
);
=TEX
\section{EPILOGUE}
SML
end (* of structure Parser *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
=IGN
val sd = let open PrettyNames in add_new_symbols [
	([	"StartZGeneric"],	Value "", Starting(specific_quotation, "")),
	([	"StartZSchema"],	Value "ÿ", Starting(specific_quotation, "")),
	([	"EndZBox"],		Value "", Ending ""),
	([	"StartZTerm"],	Value "ñ", Starting(specific_quotation, ""))
] end;

open Lex;
fun Ûz_term_recogniserÝ (start:string, lang:string, value:INPUT list, finish:string) = (
let	val side_effect =
		if	(* is_same_symbol(start, "StartZTerm")
			andalso	is_same_symbol(finish, ">")
			andalso	 *) (lang = "")
		then	()
		else
			fail "z_term_recogniser" 49010 [
				fn () => start,
				fn () => lang,
				fn () => finish];
	val tokens = zlex value;
	val parsed = phase_1 tokens;
in	parsed 
end);

ñx®;
ñx y®;
ñ(x)®;
ñ(x y)®;
ñ[x]®;
ñx [y]®;
ñ[y|z]®;
ñx [y|z]®;
ñx [y:Y|z]®;
ñfun 10 _+_®;
ñ[a,b,c]®;
ñ[a,b,c:A]®;
ñ[a,b,c:A| x ± y ² z]®;


	(* pred_semi_pred *)
ña ; b®;
ña ; b ; c®;
	(* quant *)
ñµx:Y|Q x·P x®;
ñµx:Y·P x®;



°
