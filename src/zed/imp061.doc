% imp061.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Z Parser}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP061}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01 \\ R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
parser for HOL/Z.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{DS/FMU/IED/DTD061}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD061}.

\subsection{Dependencies}
The parser is dependent on the Z lexical analyser, \cite{DS/FMU/IED/DTD060}, 
and on the HOL symbol table, \cite{DS/FMU/IED/DTD020}.
\subsection{Possible Enhancements}
The error messages could be improved by using a hand-coded function to
print out the parsing stack.
\subsection{Deficiencies}
The parser accepts a slightly larger language than that specified in
\cite{DS/FMU/IED/DEF007} in that it allows infix, prefix and
postfix syntax and type constraints in local function definitions.
It also allows antiquotation in local definitions and bound variable
declarations.

The error report for errors in varstructs and local definitions
does not indicate the position of the error as accurately as one might
like. The error marker appears immediately after the $let$-term or
abstraction (or similar) containing the error. To fix this would require
quite a lot of work (one would probably have to label the $TM$s with
token numbers so that the code which makes the checks when the
entire containing phrase has been recognised
could calculate where the error in the input arose from).
As the second line of the error report does print out the rogue construct
in full, the situation as is is not intolerable.
\section{PREAMBLE}
SML
structure €ZParser› : ZParser = struct
=TEX
We need to include the SLRP driver code at this point:
=TEX
=SML
open ZLex;
=INCLUDE
imp018.sml
=SML
open SlrpDriver;
=TEX
\section{DATA TYPES}
We require data types to represent the result of a context-free parse
using the grammar of \cite{DS/FMU/IED/DTD061}. The result is used to
generate a value of type $ZTM$ as required by the type inferrer.

The following types are used for identifiers and decoration:
=SML
type €ID›			= string;
type €DECOR›		= string;
=TEX
We represent precedences using 
the integers:
=SML
type €PREC›		= int;
=TEX
The following types are used for the templates which
record information about fancy-fix operators:
=SML
datatype €STUB›		= 	€StubUS›		(* _ *)
			|	€StubEll›		(* ... *);

type €CORE›		=	ID * ((STUB * ID) list * (STUB * ID)) OPT;

datatype €TEMPLATE›	=	€TmplNon› of	CORE
					(* id, {stub, id} *)
			|	€TmplIn› of	(STUB * CORE * STUB)
					(* stub, id, {stub, id}, stub *)	
			|	€TmplPre› of	(CORE * STUB)
					(* id, {stub, id}, stub *)
			|	€TmplPost› of	(STUB * CORE)
					(* {stub, id}, stub, id *);
=TEX
Logical and schema operators are represented using the following
data types:
=SML
datatype €LOG_IN_OP›	= €And› | €Or› | €Implies› | €Iff›;

datatype €SCH_IN_OP›	= €Pipe› | €Filter› | €Comp›;

datatype €SCH_PRE_OP›	= €Pre› | €Delta› | €Xi›;

datatype €QUANT›	= €ForAll› | €Exists› | €ExistsUnique›;
=TEX
Most of the complexity of the parsing process arises in the treatment of
predicates, schemas and expressions. These are all mapped onto the
data type $PRED$. The type contains a constructor corresponding to
each of the alternatives for $Pred$, $Pred1$, $Pred2$, $Pred3$,
$Schema2$, $Schema3$, $Schema4$, $Expr0$, $Expr1$, $Expr2$, $Expr3$
and $Expr4$, with the exceptions that (i) no constructor is required
for alternatives comprising a single non-terminal, and (ii) in most cases
where one alternative may be obtained from another by omitting part of it,
the data type has a single constructor with optional components in its
operand type.
=SML
datatype €PRED›		= €PredSemi› of PRED * PRED
			| €PredQuantifier› of QUANT * DECL * (PRED OPT) * PRED
			| €PredLet› of EQ_DEF list * PRED
			| €PredLogInOp› of PRED * LOG_IN_OP * PRED
			| €PredNot› of PRED
			| €PredSchInOp› of PRED * SCH_IN_OP * PRED
			| €PredSchPreOp› of SCH_PRE_OP * PRED
			| €PredSchemaHiding› of PRED * (PRED list)
			| €PredMu› of DECL * (PRED OPT) * (PRED OPT)
			| €PredLambda› of DECL * (PRED OPT) * (PRED OPT)
			| €PredFancyFix› of TEMPLATE * DECOR * ((PRED list) list)
			| €PredCrossProduct› of PRED list
			| €PredPow› of PRED
			| €PredApplication› of PRED * PRED
			| €PredTheta› of PRED
			| €PredSelection› of PRED * PRED
			| €PredIdDec› of ID * DECOR
			| €PredQuotation› of TERM
			| €PredPlaceHolder› of STUB
			| €PredNumber› of int
			| €PredString› of string
			| €PredTuple› of PRED list
			| €PredSetDisplay› of PRED list
			| €PredSeqDisplay› of PRED list
			| €PredSetComp› of DECL * (PRED OPT) * (PRED OPT)
			| €PredHorizSchema› of  DECL * (PRED OPT)
			| €PredGenInst› of PRED list
			| €PredRenameList› of (PRED * PRED) list
			| €PredBracketed› of PRED * DECOR
			| €PredError› of PRED
=TEX
The above definition uses the following type abbreviations which correspond
to the non-terminals $Decl$ and $EqDef$ in the grammar. Note that
a declaration is much simpler here than in the grammar (which is
complicated by a need to single out declarations consisting of a single
schema expression as a special case).
=SML
withtype €DECL›		= (PRED list * PRED OPT) list
and €EQ_DEF›		= PRED * PRED;
=TEX
The following type abbreviations and data types correspond to the
various sorts of paragraph:
=SML
type €FIXITY›		= CLASS * (TEMPLATE list);

type €GENERAL_TERM›	= PRED * (PRED OPT);

datatype €ABB_DEF›	= €ADEqDef› of EQ_DEF
			| €ADSchemaBox› of PRED * DECL * (PRED OPT);

type €FREE_TYPE_DEF›	= (PRED * (PRED list)) list;

type €AX_BOX›		= (PRED list) * DECL * (PRED OPT);

type €CONJECTURE›		= (ID OPT) * PRED;
=TEX
The overall result of a context-free parse of a single Z paragraph
is then represented by the following data type:
=SML
datatype €PARAGRAPH›	= €ParFixity› of FIXITY
			| €ParGeneralTerm› of GENERAL_TERM
			| €ParAbbDef› of ABB_DEF
			| €ParFreeTypeDef› of FREE_TYPE_DEF
			| €ParAxBox› of AX_BOX
			| €ParConjecture› of CONJECTURE;
=TEX
The partially parsed input as held on the parsing stack is of the
type $PP$, for which we use an additional type abbreviation for the
values obtained by reducing the second alternative for the
non-terminal $CoreExpr$.
=SML
type €CORE_EXPR›		= PRED list * ((ID * (PRED list))list);

datatype €PP›		= PPParagraph of PARAGRAPH
			| PPTemplates of TEMPLATE list
			| PPTemplate of TEMPLATE
			| PPEqDef of EQ_DEF
			| PPEqDefs of EQ_DEF list
			| PPPred of PRED
			| PPDecl of DECL
			| PPCoreExpr of CORE_EXPR
			| PPSomeExprs of PRED list
			| PPIdDec of (ID * DECOR);
=TEX
\section{TEMPLATE FUNCTIONS}
We need various functions for operating on templates.
These are collected together in this section.

=TEX
We maintain a dictionary mapping names onto templates and
the $ZFIXITY$s. (This should actually be loaded from the theory
database.)
=TEX
=SML
val tmpl_ref : (ID * ZFIXITY * TEMPLATE) list ref = ref [];
=TEX
Given a template the following function returns
the corresponding list of name-$ZFIXITY$ pairs. The list is in no
particular order.
=SML
fun tmpl_ids (tmpl : TEMPLATE) (cl : CLASS): (ID * ZFIXITY) list = (
	let	val aux = map (fn (_, id) => (id, (ZFFThenOp, cl)));
	in	case tmpl of
		TmplNon (id, Nil) => (
			raise SYNTAX_ERROR
		) |	TmplNon (id1, Value (stids, (_, id2))) =>(
			(id1, (ZFFBeginOp, cl)) :: (id2, (ZFFEndOp, cl)) :: aux stids
		) |	TmplIn (_, (id, Nil), _) => (
			[(id, (ZFFInOp, cl))]
		) |	TmplIn (_, (id1, Value (stids, (_, id2))), _) => (
			(id1, (ZFFPostBeginOp, cl)) :: (id2, (ZFFPreEndOp, cl)) :: aux stids
		) |	TmplPre ((id, Nil), _) => (
			[(id, (ZFFPreOp, cl))]
		) |	TmplPre ((id1, Value (stids, (_, id2))), _) => (
			(id1, (ZFFBeginOp, cl)) :: (id2, (ZFFPreEndOp, cl)) :: aux stids
		) |	TmplPost (_, (id, Nil)) =>(
			[(id, (ZFFPostOp, cl))]
		) |	TmplPost (_, (id1, Value (stids, (_, id2)))) => (
			(id1, (ZFFPostBeginOp, cl)) :: (id2, (ZFFEndOp, cl)) :: aux stids
		)
	end
);
=TEX
=SML
fun €declare_template› ((cl, tmpl) : CLASS * TEMPLATE) :  unit  = (
	let	fun mapper (id, zfix) = (
			tmpl_ref :=  (id, zfix, tmpl)::(!tmpl_ref)
		);
	in
		map mapper (tmpl_ids tmpl cl); ()
	end
);
=TEX
=SML
fun €get_template› (id : ID) : (TEMPLATE * ZFIXITY) list = (
	let	val tmps = (!tmpl_ref) drop (fn (id',_,_) => id<>id');
	in
		map (fn (_, zfix, tmpl)=> (tmpl, zfix)) tmps  
	end
);
=TEX
\section{DIAGNOSTICS}
If errors are detected during the transformation to $ZTM$, then values
of type $PARAGRAPH$ etc. have to be printed in the diagnostic report.
The following functions are used to do this:
=TEX
=SML
fun €format_stub› StubUS = " _ "
|    format_stub StubEll = " ... ";
=TEX
=SML
fun €format_core› ( (first, Value (middle, last)) : CORE ) : string = (
	let	fun format_stub_id (stub, id) = (
			format_stub stub ^ id
		);
	in		first
		^	format_list format_stub_id middle ""
		^	format_stub_id last
	end
) | format_core ( (first, Nil) ) = first;
=TEX
=SML
fun €format_template› ((TmplNon core) : TEMPLATE) : string =
	" " ^ format_core core ^ " "
|   format_template (TmplIn (st1, core, st2)) =
	format_stub st1 ^ format_core core ^ format_stub st2
|   format_template (TmplPre (core, st)) =
	format_core core ^ format_stub st
|   format_template (TmplPost (st, core)) =
	format_stub st ^ format_core core;
=TEX
=SML
fun €format_log_in_op› (And : LOG_IN_OP) : string = "±"
|   format_log_in_op (Or : LOG_IN_OP) = "≤"
|   format_log_in_op (Implies : LOG_IN_OP) = "¥"
|   format_log_in_op (Iff : LOG_IN_OP) = "§";
=TEX
=SML
fun €format_sch_in_op› (Pipe : SCH_IN_OP) = ">>"
|   format_sch_in_op (Filter : SCH_IN_OP) = "˘"
|   format_sch_in_op (Comp : SCH_IN_OP) = "ª";
=TEX
=SML
fun €format_sch_pre_op› (Pre : SCH_PRE_OP) = "pre"
|   format_sch_pre_op (Delta : SCH_PRE_OP) = "Ñ"
|   format_sch_pre_op (Xi : SCH_PRE_OP) = "ò";
=TEX
=SML
fun €format_quant› (ForAll : QUANT) = "µ"
|   format_quant (Exists : QUANT) = "∂"
|   format_quant (ExistsUnique : QUANT) = "∂â1";
=TEX
=SML
fun €format_fancy_fix›
	(format_item : 'a -> string)
	(tmpl : TEMPLATE)
	(decor : DECOR)
	(items : 'a list) = (
	let	
		val rids = rev (map fst (tmpl_ids tmpl ZClRel));
		val ids = rev (hd rids ^ decor :: tl rids);
		fun aux1 ns its = (
			(format_list
			Combinators.I
			(map (fn (a,b) => a ^ " " ^ b)(combine ns (map format_item its)))
			" ")
		);
		fun aux2 ns its = (
			(format_list
			Combinators.I
			(map (fn (a,b) => a ^ " " ^ b)(combine (map format_item its) ns))
			" ")
		);
	in	case tmpl of
			TmplNon _ => (
				hd ids ^ aux2 (tl ids) items
		) |	TmplIn _ => (
				format_item (hd items)  ^ aux1 ids (tl items)
		) |	TmplPre _ => (
				aux1 ids items
		) |	TmplPost _ => (
				aux2 ids items
		)
	end
	handle (Fail _) => raise PARSER_ERROR "invalid call of format_fancy_fix"
);
=TEX
=SML
fun €format_pred› (pred : PRED) : string = (
	case pred of
		PredSemi (pred1, pred2) => format_pred pred1 ^ "; " ^ format_pred pred2
	|	PredQuantifier (q, decl, Value pred1, pred2) =>
			format_quant q ^ format_decl decl ^ " | " ^ format_pred pred1 ^ " ∑ " ^ format_pred pred2
	|	PredQuantifier (q, decl, Nil, pred2) =>
			format_quant q ^ format_decl decl ^ " ∑ " ^ format_pred pred2
	|	PredLet (eqdefs, pred) =>
			format_list format_eq_def eqdefs "," ^ format_pred pred
	|	PredLogInOp (pred1, rator, pred2) =>
			format_pred pred1 ^ format_log_in_op rator ^ format_pred pred2
	|	PredNot pred => "≥ " ^ format_pred pred
	|	PredSchInOp (pred1, rator, pred2) =>
			format_pred pred1 ^ format_sch_in_op rator ^ format_pred pred2
	|	PredSchPreOp (rator, pred) =>
			format_sch_pre_op rator ^ format_pred pred
	|	PredSchemaHiding (pred, preds) =>
			format_pred pred ^ "\\[" ^ format_list format_pred preds ", " ^ "]"
	|	PredMu body => "Õ " ^ format_decl_bar_pred_dot_pred body
	|	PredLambda body => "Ã " ^ format_decl_bar_pred_dot_pred body
	|	PredFancyFix (tmpl, decor, args) =>
			format_fancy_fix
			(fn ps => format_list format_pred ps ", ")
			 tmpl decor args
	|	PredCrossProduct preds => format_list format_pred preds " ∏ "
	|	PredPow pred => " " ^ format_pred pred
	|	PredApplication (pred1, pred2) =>  format_pred pred1 ^ " " ^ format_pred pred2
	|	PredTheta pred => "  " ^ format_pred pred
	|	PredSelection (pred1, pred2) =>  format_pred pred1 ^ "." ^ format_pred pred2
	|	PredIdDec (id, decor) => id ^ " " ^ decor
	|	PredQuotation _ => "<term-quotation>"
	|	PredPlaceHolder st => format_stub st
	|	PredNumber n => string_of_int n
	|	PredString s => "\"" ^ s ^ "\""
	|	PredTuple preds => "(" ^ format_list format_pred preds ", " ^ ")"
	|	PredSetDisplay preds  => "{" ^ format_list format_pred preds ", " ^ "}"
	|	PredSeqDisplay preds  => "ß" ^ format_list format_pred preds ", " ^ "¢"
	|	PredSetComp body => "{" ^ format_decl_bar_pred_dot_pred body ^ "}"
	|	PredHorizSchema (decl, predopt) =>
			"[" ^ format_decl_bar_pred_dot_pred(decl, predopt, Nil) ^ "]"
	|	PredGenInst preds => "[" ^ format_list format_pred preds ", " ^ "]"
	|	PredRenameList renames =>
			"["
		^	format_list
			(fn (pred1, pred2) => format_pred pred1 ^ " / " ^ format_pred pred2)
			renames
			", "
		^	"]"
	|	PredBracketed (pred, decor) => "(" ^ format_pred pred ^ ")" ^ decor
	|	PredError pred => "<?>" ^ format_pred pred
)
and €format_decl› (decs : DECL) : string = (
	let	fun format_dec (preds, Nil) =  format_list format_pred preds ", "
		|   format_dec (preds, Value pred2) =
			format_list format_pred preds ", "
			 ^ " : " ^ format_pred pred2;
	in	format_list format_dec decs "; "
	end
)
=TEX
=SML
and €format_eq_def› ((pred1, pred2) : EQ_DEF) : string = (
	format_pred pred1 ^ " ¶ " ^ format_pred pred2
)
=TEX
=SML
and €format_decl_bar_pred_dot_pred›
	(body : DECL * (PRED OPT) * (PRED OPT))
	: string = (
	case body of
		(decl, Value pred1, Value pred2) =>
			format_decl decl ^ " | " ^ format_pred pred1 ^ " ∑ " ^ format_pred pred2
	|	(decl, Nil, Value pred) =>
			format_decl decl ^ " ∑ " ^ format_pred pred
	|	(decl, Value pred, Nil) =>
			format_decl decl ^ " | " ^ format_pred pred
	|	(decl, Nil, Nil) =>
			format_decl decl
);
=TEX
=SML
fun €format_class› ((ZClFun n) : CLASS) : string = "fun " ^ string_of_int n
|   format_class  (ZClGen n) = "gen " ^ string_of_int n
|   format_class  (ZClRel) = "rel";
=TEX
=SML
fun €format_fixity› ((cl, tmpls) : FIXITY) : string = (
	format_class cl ^ " " ^ format_list format_template tmpls ", "
);
=TEX
=SML
fun €format_general_term› ((pred1, Value pred2) : GENERAL_TERM) : string = (
	format_pred pred1 ^ " & " ^ format_pred pred2
) | format_general_term (pred1, Nil) = format_pred pred1;
=TEX
=SML
fun €format_abb_def› (ADEqDef eqdef : ABB_DEF) : string = format_eq_def eqdef
=SMLLITERAL
|   format_abb_def (ADSchemaBox (pred1, decl, Value pred2)) = (
	"  " ^ format_pred pred1 ^ "¸" ^ format_decl decl ^ " ˜ " ^ format_pred pred2 ^ " à"
) | format_abb_def (ADSchemaBox (pred, decl, Nil)) = (
	"ˇ " ^ format_pred pred ^ " ¸ " ^ format_decl decl ^ " à"
);
=TEX
=SML
fun €format_free_type_def› (ftd : FREE_TYPE_DEF) : string = (
	let	fun aux (pred, preds) = (
			format_pred pred ^ " ::= " ^
			format_list format_pred preds " | "
		);
	in 	format_list aux ftd " & "
	end
);
=TEX
=SML
fun €format_ax_box› ((preds as _::_, decl, Value pred) : AX_BOX) : string = (
=SMLLITERAL
	"ù[ " ^ format_list format_pred preds ", " ^ " ]ú " ^
	format_decl decl ^ " ˜ " ^ format_pred pred ^ " à"
) | format_ax_box ([], decl, Value pred) = (
	"πZAX"  ^ format_decl decl ^ " ˜ " ^ format_pred pred ^ " à"
) | format_ax_box ((preds as _::_, decl, Nil) : AX_BOX) = (
	"ù[ " ^ format_list format_pred preds ", " ^ " ]ú " ^
	format_decl decl ^ " à"
) |  format_ax_box ([], decl, Nil) = (
	"πZAX"  ^ format_decl decl ^ " à"
);
=TEX
=SML
fun €format_conjecture› ((Value id, pred) : CONJECTURE) : string = (
	id ^ " Ù " ^ format_pred pred
) | format_conjecture (Nil, pred) = (
	"Ù " ^ format_pred pred
);
=TEX
=SML
fun €format_paragraph› (para : PARAGRAPH) : string = (
	case para of
		ParFixity f => format_fixity f
	|	ParGeneralTerm gt => format_general_term gt
	|	ParAbbDef ad => format_abb_def ad
	|	ParFreeTypeDef ftd => format_free_type_def ftd
	|	ParAxBox ab => format_ax_box ab
	|	ParConjecture c => format_conjecture c
);
=TEX
=SML
fun €format_core_expr› ((preds, idpreds) : CORE_EXPR) : string = (
	let	fun aux (id, ps) = (
			id ^ " " ^ format_list format_pred ps ", "
		);
	in	format_list format_pred preds ", " ^ format_list aux idpreds " "
	end
);
=TEX
=SML
fun €format_pp› (pp : PP) : string = (
	case pp of
		PPParagraph para => format_paragraph para
	|	PPTemplates tmpls => format_list format_template tmpls ", "
	|	PPTemplate tmpl => format_template tmpl
	|	PPEqDef eqdef => format_eq_def eqdef
	|	PPEqDefs eqdefs => format_list format_eq_def eqdefs ", "
	|	PPPred pred => format_pred pred
	|	PPDecl decl => format_decl decl
	|	PPCoreExpr ce =>  format_core_expr ce
	|	PPSomeExprs es => format_list format_pred es ", "
	|	PPIdDec (id, dec) => id ^ dec
);
=TEX
\section{LEXICAL CLASSES}
The following data type represents the lexical classes which are the
terminals of the grammar:
=SML
datatype Z_LEX_CLASS	= Ampersand
			| Quotation
			| Ax
			| BBoldP
			| BackSlash
			| Bar
			| Bars
			| BeginOp
			| Colon
			| ColonsEq
			| Comma
			| Cross
			| Decor
			| Dot
			| EndOp
			| Eos
			| EqHat
			| FixityClass
			| Id
			| InOp
			| Is
			| LBrace
			| LBrk
			| LSeqBrk
			| LSqBrk
			| Let
			| LogInOp
			| MuLambda
			| Not
			| Number
			| PostBeginOp
			| PostOp
			| PreEndOp
			| PreOp
			| Quant
			| RBrace
			| RBrk
			| RSeqBrk
			| RSqBrk
			| Sch
			| SchInOp
			| SchPreOp
			| Semi
			| Slash
			| Spot
			| St
			| String
			| Stub
			| ThenOp
			| Theta
			| TurnStile
			| UnderBar;
=TEX
There are two classification functions: $classify2$ for use in processing
fixity paragraphs and $classify$ for use everywhere else.
=SML
fun €classify1›  (tok : ZTOKEN) : Z_LEX_CLASS = (
	case tok of
		ZTAqTm _	=>	Quotation
	|	ZTId "_"	=> 	Stub
	|	ZTId _		=> 	Id
	|	ZTBeginOp _	=> 	BeginOp
	|	ZTEndOp _	=> 	EndOp
	|	ZTInOp _	=>	InOp
	|	ZTPostBeginOp _ =>	PostBeginOp
	|	ZTThenOp _	=> 	ThenOp
	|	ZTPostOp _	=>	PostOp
	|	ZTPreEndOp _	=>	PreEndOp
	|	ZTPreOp _	=>	PreOp
	|	ZTDecor _	=>	Decor
	|	ZTChar	_	=>	raise PARSER_ERROR "unexpected token"
	|	ZTString _	=>	String
	|	ZTNumber _	=>	Number
	|	ZTAx		=>	Ax
	|	ZTSch		=>	Sch
	|	ZTEnd		=>	raise PARSER_ERROR "unexpected token"
	|	ZTOpen		=>	raise PARSER_ERROR "unexpected token"
	|	ZTIs		=>	Is
	|	ZTSt		=>	St
	|	ZTBar		=>	Bar
	|	ZTAmpersand	=>	Ampersand
	|	ZTÃ		=>	MuLambda
	|	ZTÕ		=>	MuLambda
	|	ZTµ		=>	Quant
	|	ZT∂		=>	Quant
	|	ZT∂â1		=>	Quant
	|	ZT≥		=>	Not
	|	ZT±		=>	LogInOp
	|	ZT≤		=>	LogInOp
	|	ZT§		=>	LogInOp
	|	ZT¥		=>	LogInOp
	|	ZTPre		=>	SchPreOp
	|	ZTÑ		=>	SchPreOp
	|	ZTò		=>	SchPreOp
	|	ZTPipe		=>	SchInOp
	|	ZT˘		=>	SchInOp
	|	ZTª		=>	SchInOp
	|	ZTLet		=>	Let
	|	ZTFun		=>	FixityClass
	|	ZTGen		=>	FixityClass
	|	ZTRel		=>	FixityClass
	|	ZTLbrace	=>	LBrace
	|	ZTRbrace	=>	RBrace
	|	ZTLbrack	=>	LBrk
	|	ZTRbrack	=>	RBrk
	|	ZTLsqbrack	=>	LSqBrk
	|	ZTRsqbrack	=>	RSqBrk
	|	ZTß		=>	LSeqBrk
	|	ZT¢		=>	RSeqBrk
	|	ZTComma		=>	Comma
	|	ZTDots		=>	Stub
	|	ZTDot		=>	Dot
	|	ZTSlash		=>	Slash
	|	ZTBSlash	=>	BackSlash
	|	ZTFreeTyDef	=>	ColonsEq
	|	ZTColon		=>	Colon
	|	ZTSemi		=>	Semi
	|	ZTVert		=>	Bar
	|	ZTConjecture	=>	TurnStile
	|	ZT¶		=>	EqHat
	|	ZT∑		=>	Spot
	|	ZT∏		=>	Cross
	|	ZT 		=>	Theta
	|	ZTEos		=>	Eos
);
=TEX
=SML
fun €classify2›  (tok : ZTOKEN) : Z_LEX_CLASS = (
	case tok of
		ZTId _ => Id
	|	_ => classify1 tok
);
=TEX
\section{ERROR HANDLING}
=SML
fun €format_z_token›  (tok : ZTOKEN) : string = (
=SML
	case tok of
		ZTAqTm _	=>	"<term-quotation>"
	|	ZTId s		=> 	s
	|	ZTBeginOp (s,_)	=> 	s
	|	ZTEndOp (s,_)	=> 	s
	|	ZTInOp (s,_)	=>	s
	|	ZTPostBeginOp (s,_) =>	s
	|	ZTThenOp (s,_)	=> 	s
	|	ZTPostOp (s,_)	=>	s
	|	ZTPreEndOp (s,_)=>	s
	|	ZTPreOp (s,_)	=>	s
	|	ZTDecor s	=>	s
	|	ZTChar s	=>	"<unexpected token: " ^ s ^ ">"
	|	ZTString s	=>	"\"" ^ s ^ "\""
	|	ZTNumber n	=>	string_of_int n
	|	ZTAx		=>	"πZAX"
	|	ZTSch		=>	"ˇ"
	|	ZTEnd		=>	"<unexpected token: ZTEnd>"
	|	ZTOpen		=>	"<unexpected token: ZTOpen>"
	|	ZTIs		=>	"<Is>"
	|	ZTSt		=>	"˜"
	|	ZTBar		=>	"‹"
	|	ZTAmpersand	=>	"&"
	|	ZTÃ		=>	"Ã"
	|	ZTÕ		=>	"Õ"
	|	ZTµ		=>	"µ"
	|	ZT∂		=>	"∂"
	|	ZT∂â1		=>	"∂â1"
	|	ZT≥		=>	"≥"
	|	ZT±		=>	"±"
	|	ZT≤		=>	"≤"
	|	ZT§		=>	"§"
	|	ZT¥		=>	"¥"
	|	ZTPre		=>	"pre"
	|	ZTÑ		=>	"Ñ"
	|	ZTò		=>	"ò"
	|	ZTPipe		=>	">>"
	|	ZT˘		=>	"˘"
	|	ZTª		=>	"ª"
	|	ZTLet		=>	"let"
	|	ZTFun		=>	"fun"
	|	ZTGen		=>	"gen"
	|	ZTRel		=>	"rel"
	|	ZTLbrace	=>	"{"
	|	ZTRbrace	=>	"}"
	|	ZTLbrack	=>	"("
	|	ZTRbrack	=>	")"
	|	ZTLsqbrack	=>	"["
	|	ZTRsqbrack	=>	"]"
	|	ZTß		=>	"ß"
	|	ZT¢		=>	"¢"
	|	ZTComma		=>	","
	|	ZTDots		=>	"..."
	|	ZTDot		=>	"."
	|	ZTSlash		=>	"/"
	|	ZTBSlash	=>	"\\"
	|	ZTFreeTyDef	=>	"::="
	|	ZTColon		=>	":"
	|	ZTSemi		=>	";"
	|	ZTVert		=>	"|"
	|	ZTConjecture	=>	"Ù"
	|	ZT¶		=>	"¶"
	|	ZT∑		=>	"∑"
	|	ZT∏		=>	"∏"
	|	ZT 		=>	" "
	|	ZTEos		=>	"<end-of-input>"
);
=TEX
=SML
fun €format_parse_stack› (stk : (ZTOKEN, Z_LEX_CLASS, PP)INPUT_STACK) : string = (
	let	fun aux (Parsed pp) = format_pp pp
		|   aux (Token (tok, _)) = format_z_token tok;
	in	format_list aux stk " "
	end
);
=TEX
$red\_error$ is for use during context-free parsing when a user-error is detected.
The first two arguments give the two inserts for message 61001.
The other two parameters give the message to print after the 61001 lines.
After the diagnostic print-out the function fails with message 61000
and area "Z-Parser".
=SML
fun €red_error›
	(okpart : (ZTOKEN, Z_LEX_CLASS, PP)INPUT_STACK)
	(badpart : (ZTOKEN, Z_LEX_CLASS, PP)INPUT_STACK)
	(msg : int)
	(inserts : string list) : 'a = (
	diag_string (get_error_message
			61001
			[format_parse_stack okpart,  format_parse_stack badpart]);
	diag_string (get_error_message msg inserts);
	fail "Z-Parser" 61000 []
);
=TEX
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun €stack_error› (insert : string) : 'a = (
	error "Z-Parser"  19005 [fn() => insert]
);
=TEX
\section{REDUCTION FUNCTIONS}
As with the HOL parser, adding type constraints to the reductions functions
would be both unhelpful and very time-consuming and so in this section
we deliberately suspend that aspect of the coding standards of
\cite{DS/FMU/IED/PLN007}.

We give the reduction functions in the order of their appearance
in the grammar of \cite{DS/FMU/IED/DTD061}. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.
=TEX
=SML
fun €red_accept› (Parsed x) _ = (x
) | red_accept _ _ = stack_error "red_accept";
=TEX
=SML
val €red_fixity› = red_accept;
val €red_general_term› = red_accept;
val €red_abb_def› = red_accept;
val €red_free_type_def› = red_accept;
val €red_ax_box› = red_accept;
val €red_conjecture› = red_accept;
=TEX
=SML
fun €red_templates› (Token (tk, _)) (Parsed (PPTemplates tmpls)) _ = (
	PPParagraph
	(case tk of
		ZTFun => ParFixity(ZClFun 0, tmpls)
	|	ZTGen => ParFixity(ZClGen 0, tmpls)
	|	ZTRel => ParFixity(ZClRel, tmpls)
	|	_ => stack_error "red_templates(1)")
) | red_templates _ _ _ = stack_error "red_templates(2)";
=TEX
=SML
fun €red_prec_templates› (Token (tk, c1)) (Token (ZTNumber p, c2))
	(Parsed (PPTemplates tmpls)) stk = (
	PPParagraph
	(case tk of
		ZTFun => ParFixity(ZClFun p, tmpls)
	|	ZTGen => ParFixity(ZClGen p, tmpls)
	|	ZTRel =>
			red_error
			((Token (tk, c1)) :: stk) [Token (ZTNumber p, c2)]
			61010 []
	|	_ => stack_error "red_prec_templates(1)")
) | red_prec_templates _ _ _ _ = stack_error "red_prec_templates(2)";
=TEX
=SML
fun €red_accept› (Parsed pp) _ = (pp
) | red_accept _ _ = stack_error "red_accept";
=TEX
=SML
val €red_template› = red_accept;
=TEX
=SML
fun €red_template_templates›
	(Parsed(PPTemplates [tmpl])) _ (Parsed(PPTemplates tmpls)) _ = (
	PPTemplates (tmpl :: tmpls)
) | red_template_templates _ _ _ _ = stack_error "red_template_templates";
=TEX
=TEX
=SML
val €red_stub_ids› = red_accept;
=TEX
=SML
val €red_id_stubs› = red_accept;
=TEX
=SML
fun dest_stub (ZTDots : ZTOKEN) = StubUS
|   dest_stub (ZTId "_") = StubEll
|   dest_stub _ = stack_error "dest_stub";
=TEX
=SML
fun €red_stub_id› (Token(st, _)) (Token((ZTId nm), _)) _ = (
	PPTemplates[TmplPost(dest_stub st, (nm, Nil))]
) | red_stub_id _ _ _ = stack_error "red_stub_id";
=TEX
=SML
fun €red_stub_id_stub›
	(Token(st1, _))
	(Token(ZTId nm, _))
	(Token(st2, _)) _ =
	PPTemplates[TmplIn(dest_stub st1, (nm, Nil), dest_stub st2)]
|   red_stub_id_stub _ _ _ _ = stack_error "red_stub_id_stub";
=TEX
=SML
fun €red_stub_id_stub_ids› (Token(st1, _)) (Token((ZTId nm), _))
		(Parsed(PPTemplates[(TmplIn(st2, (nm2, Nil), st3))])) _ = (
	PPTemplates[TmplIn(dest_stub st1, (nm, Value([], (st2, nm2))), st3)]
) | red_stub_id_stub_ids (Token(st1, _)) (Token((ZTId nm1), _))
		(Parsed(PPTemplates[(TmplIn(st2, (nm2, Value (stids, stid)), st3))])) _ = (
	PPTemplates[TmplIn(dest_stub st1, (nm1, Value((st2, nm2) :: stids, stid)), st3)]
) | red_stub_id_stub_ids (Token(st1, _)) (Token((ZTId nm1), _))
		(Parsed(PPTemplates[(TmplPost(st2, (nm2, Nil)))])) _ = (
	PPTemplates[TmplPost(dest_stub st1, (nm1, Value([], (st2, nm2))))]
) | red_stub_id_stub_ids (Token(st1, _)) (Token((ZTId nm1), _))
		(Parsed(PPTemplates[(TmplPost(st2, (nm2, Value (stids, stid))))])) _ = (
	PPTemplates[TmplPost(dest_stub st1, (nm1, Value((st2, nm2) :: stids, stid)))]
) | red_stub_id_stub_ids _ _ _ _ = stack_error "red_stub_id_stub_ids";
=TEX
=SML
fun €red_id_stub› (Token((ZTId nm), _)) (Token(st, _)) _ =  (
	PPTemplates[TmplPre((nm, Nil), dest_stub st)]
) | red_id_stub _ _ _ = stack_error "red_id_stub";
=TEX
=SML
fun €red_id_stub_id› (Token((ZTId nm1), _)) (Token(st, _)) (Token((ZTId nm2), _)) _ = (
	PPTemplates[TmplNon((nm1, Value([], (dest_stub st, nm2))))]
) | red_id_stub_id _ _ _ _ = stack_error "red_id_stub_id";
=TEX
=SML
fun red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplPre((nm2, Nil), st2))])) _ = (
	PPTemplates[TmplPre((nm1, Value([], (dest_stub st1, nm2))), st2)]
) | red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplPre((nm2, Value(stids, stid)), st2))])) _ = (
	PPTemplates[TmplPre((nm1, Value((dest_stub st1, nm2) :: stids, stid)), st2)]
) | red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplNon((nm2, Nil)))])) _ = (
	PPTemplates[TmplNon(nm1, Value([], (dest_stub st1, nm2)))]
) | red_id_stub_id_stubs (Token((ZTId nm1), _)) (Token(st1, _))
		(Parsed(PPTemplates[(TmplNon((nm2, Value(stids, stid))))])) _ = (
	PPTemplates[TmplNon(nm1, Value((dest_stub st1, nm2) :: stids, stid))]
) | red_id_stub_id_stubs _ _ _ _ = stack_error "red_id_stub_id_stubs";
=TEX
=SML
fun €red_pred› (Parsed (PPPred p)) _ = (
	PPParagraph(ParGeneralTerm (p, Nil))
) | red_pred _ _ = stack_error "red_pred";
=TEX
=SML
fun €red_pred_constraint› (Parsed (PPPred p1)) _ (Parsed (PPPred p2)) _ = (
	PPParagraph(ParGeneralTerm (p1, Value p2))
) | red_pred_constraint _ _ _ _ = stack_error "red_pred_constraint";
=TEX
=SML
fun €red_eq_def› (Parsed (PPEqDef d)) _ = (
	PPParagraph(ParAbbDef(ADEqDef d))
) | red_eq_def _ _ = stack_error "red_eq_def";
=TEX
=SML
fun €red_schema›
	_ (Parsed (PPPred s))
	_ (Parsed (PPDecl d))
	_ (Parsed (PPPred p)) _ = (
	PPParagraph(ParAbbDef(ADSchemaBox(s, d, Value p)))
) | red_schema _ _ _ _ _ _ _ = stack_error "red_schema";
=TEX
=SML
fun €red_schema_no_pred›
	_ (Parsed (PPPred s))
	_ (Parsed (PPDecl d)) _= (
	PPParagraph(ParAbbDef(ADSchemaBox(s, d, Nil)))
) | red_schema_no_pred _ _ _ _ _ = stack_error "red_schema_no_pred";
=TEX
=SML
fun €red_deflhs_pred› (Parsed (PPPred d)) _ (Parsed (PPPred p)) _ = (
	PPEqDef(d, p)
) | red_deflhs_pred _ _ _ _ = stack_error "red_deflhs_pred";
=TEX
=SML
val €red_expr1_as_def_lhs› = red_accept;
=TEX
=SML
fun €red_a_free_type› (Parsed (PPPred t)) _ (Parsed (PPSomeExprs bs)) _ = (
	PPParagraph(ParFreeTypeDef[(t, bs)])
) | red_a_free_type _ _ _ _ = stack_error "red_a_free_type";
=TEX
=SML
fun €red_free_types›
	(Parsed (PPPred t)) _
	(Parsed (PPSomeExprs bs)) _
	(Parsed (PPParagraph(ParFreeTypeDef fts))) _ = (
	PPParagraph(ParFreeTypeDef((t, bs) :: fts))
) | red_free_types _ _ _ _ _ _ = stack_error "red_free_types";
=TEX
=SML
fun €red_accept_pred_as_list › (Parsed (PPPred p)) _ = (
	PPSomeExprs [p]
) | red_accept_pred_as_list _ _ = stack_error "red_accept_pred_as_list";
=TEX
=SML
val €red_pred_as_branch› = red_accept_pred_as_list;
=TEX
The following auxiliary is not itself ever used directly as a reduction
function (since constructs giving rise to predicate lists in the abstract
syntax have a variety of styles for separating the predicates)
=SML
fun €add_pred_to_list_aux› (Parsed (PPPred p)) (Parsed (PPSomeExprs ps)) = (
	PPSomeExprs (p :: ps)
) | add_pred_to_list_aux _ _ = stack_error "add_pred_to_list_aux";
=TEX
=SML
fun €red_branches› pp _ pb _  = (
	add_pred_to_list_aux pp pb
);
=TEX
=SML
fun €red_ax_box_no_pred› _ (Parsed (PPDecl d)) _ = (
	PPParagraph(ParAxBox([], d, Nil))
) | red_ax_box_no_pred _ _ _ = stack_error "red_ax_box_no_pred";
=TEX
=SML
fun €red_gen_ax_box_no_pred› 
	_ _ (Parsed (PPSomeExprs ps))
	_ _ (Parsed (PPDecl d)) _ = (
	PPParagraph(ParAxBox(ps, d, Nil))
) | red_gen_ax_box_no_pred _ _ _ _ _ _ _ = stack_error "red_gen_ax_box_no_pred";
=TEX
=SML
fun €red_ax_box_pred› 
	_ (Parsed (PPDecl d))
	_ (Parsed (PPPred p)) _ = (
	PPParagraph(ParAxBox([], d, Value p))
) | red_ax_box_pred _ _ _ _ _= stack_error "red_ax_box_pred";
=TEX
=SML
fun €red_gen_ax_box› 
	_ _ (Parsed (PPSomeExprs ps))
	_ _ (Parsed (PPDecl d))
	_ (Parsed (PPPred p)) _ = (
	PPParagraph(ParAxBox(ps, d, Value p))
) | red_gen_ax_box _ _ _ _ _ _ _ _ _ = stack_error "red_gen_ax_box";
=TEX
=SML
fun €red_no_id_conjecture› _ (Parsed(PPPred p)) _ = (
	PPParagraph(ParConjecture(Nil, p))
) | red_no_id_conjecture _ _ _ = stack_error "red_no_id_conjecture";
=TEX
=SML
fun €red_id_conjecture› (Token(ZTId i, _)) _ (Parsed(PPPred p)) _ = (
	PPParagraph(ParConjecture(Value i, p))
) | red_id_conjecture _ _ _ _ = stack_error "red_id_conjecture";
=TEX
=SML
val €red_pred1_as_pred› = red_accept;
=TEX
=SML
fun €red_pred_semi_pred› (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred (PredSemi (p1, p2))
) | red_pred_semi_pred _ _ _ _ = stack_error "red_pred_semi_pred";
=TEX
=SML
val €red_pred2_as_pred1› = red_accept;
=TEX
=SML
fun €quant_aux› (Token (ZTµ, _)) = ForAll
|   quant_aux (Token (ZT∂, _)) = Exists
|   quant_aux (Token (ZT∂â1, _)) = ExistsUnique
|   quant_aux _ = stack_error "quant_aux";
=TEX
=SML
fun €red_quant›
	q (Parsed(PPDecl d))
	_ (Parsed(PPPred p1))
	_ (Parsed(PPPred p2)) _ = (
	PPPred(PredQuantifier(quant_aux q, d, Value p1, p2))
) | red_quant _ _ _ _ _ _ _ = stack_error "red_quant";
=TEX
=SML
fun €red_quant_no_bar›
	q (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ = (
	PPPred(PredQuantifier(quant_aux q, d, Nil, p))
) | red_quant_no_bar _ _ _ _ _ = stack_error "red_quant_no_bar";
=TEX
=SML
fun €red_let› _  (Parsed(PPEqDefs e)) _ (Parsed(PPPred p)) _ = (
	PPPred(PredLet(e, p))
) | red_let _ _ _ _ _ = stack_error "red_let";
=TEX
=SML
val €red_pred3_as_pred2› = red_accept;
=TEX
=SML
fun €log_in_op_aux› (Token (ZT±, _)) = And
|   log_in_op_aux (Token (ZT≤, _)) = Or
|   log_in_op_aux (Token (ZT¥, _)) = Implies
|   log_in_op_aux (Token (ZT§, _)) = Iff
|   log_in_op_aux _ = stack_error "log_in_op_aux";
=TEX
=SML
fun €red_log_in_op› (Parsed(PPPred p1)) lop (Parsed(PPPred p2)) _ = (
	PPPred (PredLogInOp (p1, log_in_op_aux lop, p2))
) | red_log_in_op _ _ _ _ = stack_error "red_log_in_op";
=TEX
=SML
val €red_schema2_as_pred3› = red_accept;
=TEX
=SML
fun €red_neg› _ (Parsed(PPPred p)) _ = (
	PPPred(PredNot p)
) | red_neg _ _ _  = stack_error "red_neg";
=TEX
=SML
val €red_schema3_as_schema2› = red_accept;
=TEX
=SML
fun €sch_in_op_aux› (Token (ZTPipe, _)) = Pipe
|   sch_in_op_aux (Token (ZT˘, _)) = Filter
|   sch_in_op_aux (Token (ZTª, _)) = Comp
|   sch_in_op_aux _ = stack_error "sch_in_op_aux";
=TEX
=SML
fun €red_sch_in_op› (Parsed(PPPred p1)) sop (Parsed(PPPred p2)) _ = (
	PPPred (PredSchInOp (p1, sch_in_op_aux sop, p2))
) | red_sch_in_op _ _ _ _ = stack_error "red_sch_in_op";
=TEX
=SML
val €red_schema4_as_schema3› = red_accept;
=TEX
=SML
fun €sch_pre_op_aux› (Token (ZTPre, _)) = Pre
|   sch_pre_op_aux (Token (ZTÑ, _)) = Delta
|   sch_pre_op_aux (Token (ZTò, _)) = Xi
|   sch_pre_op_aux _ = stack_error "sch_pre_op_aux";
=TEX
=SML
fun €red_sch_pre_op› pop (Parsed(PPPred p)) _ = (
	PPPred (PredSchPreOp (sch_pre_op_aux pop, p))
) | red_sch_pre_op _ _ _ = stack_error "red_sch_pre_op";
=TEX
=SML
val €red_expr0_as_schema4› = red_accept;
=TEX
=SML
fun €red_schema_hiding› (Parsed(PPPred p)) _ _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred (PredSchemaHiding (p, ps))
) | red_schema_hiding _ _ _ _ _ _ = stack_error "red_schema_hiding";
=TEX
=SML
fun €red_rename_list› _ (Parsed r) _ _= (
	r
) | red_rename_list _ _ _ _ = stack_error "red_rename_list";
=TEX
=SML
fun €red_rename› (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred (PredRenameList[(p1, p2)])
) | red_rename _ _ _ _ = stack_error "red_rename";
=TEX
=SML
fun €red_renames›
	(Parsed(PPPred p1)) _
	(Parsed(PPPred p2)) _
	(Parsed(PPPred(PredRenameList rs))) _ = (
	PPPred (PredRenameList((p1, p2)::rs))
) | red_renames _ _ _ _ _ _= stack_error "red_renames";
=TEX
As a minor efficiency improvement we accumulate declarations backwards
and reverse the list when the entire declaration has been recognised:
=SML
fun €red_decl_minus_pred› (Parsed(PPDecl rd)) _ = (
	PPDecl (rev rd)
) | red_decl_minus_pred _ _ = stack_error "red_decl_minus_pred";
=TEX
=SML
val €red_pred1_as_decl› = red_accept;
=TEX
=SML
fun €red_decl_semi_var_decs_pred1›
	(Parsed(PPDecl rd))
	(Parsed(PPSomeExprs es)) _
	(Parsed(PPPred p)) _ = (
	PPDecl ((es, Value p) :: rd)
) | red_decl_semi_var_decs_pred1 _ _ _ _ _ = stack_error "red_decl_semi_var_decs_pred1";
=TEX
=SML
fun €red_decl_semi_pred1›
	(Parsed(PPDecl rd))
	(Parsed(PPSomeExprs es)) _ = (
	PPDecl ((es, Nil) :: rd)
) | red_decl_semi_pred1 _ _ _ = stack_error "red_decl_semi_pred1";
=TEX
=SML
fun €red_var_decs_pred1›
	(Parsed(PPSomeExprs es)) _
	(Parsed(PPPred p)) _ = (
	PPDecl [(es, Value p)]
) | red_var_decs_pred1 _ _ _ _ = stack_error "red_var_decs_pred1";
=TEX
=SML
fun €red_var_decs_pred1_semi› x1 x2 x3 _ stk = (
	red_var_decs_pred1 x1 x2 x3 stk
);
=TEX
=SML
fun €red_pred1_as_decl_semi› (Parsed(PPSomeExprs es)) _ _ = (
		PPDecl [(es, Nil)]
) | red_pred1_as_decl_semi _ _ _ = stack_error "red_pred1_as_decl_semi";
=TEX
=SML
=SML
fun €red_decl_semi_var_decs_pred1_semi› x1 x2 x3 x4 _ stk= (
	red_decl_semi_var_decs_pred1 x1 x2 x3 x4 stk
);
=TEX
=SML
fun €red_decl_semi_pred1_semi› x1 x2 _ stk = (
	red_decl_semi_pred1 x1 x2 stk
);
=TEX
=SML
val €red_expr1_as_expr0› = red_accept;
=TEX
=SML
fun €mu_lambda_aux› (Token (ZTÕ, _)) = PredMu
|   mu_lambda_aux (Token (ZTÃ, _)) = PredLambda
|   mu_lambda_aux _ = stack_error "mu_lambda_aux";;
=TEX
=SML
fun €red_mu_lambda_no_pred›
	mu_lambda
	(Parsed(PPDecl dec)) _
	(Parsed(PPPred p)) _ = (
	 PPPred(mu_lambda_aux mu_lambda (dec, Nil, Value p))
) | red_mu_lambda_no_pred _ _ _ _ _ = stack_error "red_mu_lambda_no_pred";
=TEX
=SML
fun €red_mu_lambda›
	mu_lambda
	(Parsed(PPDecl dec)) _
	(Parsed(PPPred p1)) _
	(Parsed(PPPred p2)) _ = (
	 PPPred(mu_lambda_aux mu_lambda (dec, Value p1, Value p2))
) | red_mu_lambda _ _ _ _ _ _ _ = stack_error "red_mu_lambda";
=TEX
=SML
fun €red_eq_def_as_eq_defs› (Parsed(PPEqDef ed)) _ = (
	PPEqDefs [ed]
) | red_eq_def_as_eq_defs _ _ = stack_error "red_eq_def_as_eq_defs";
=TEX
=SML
fun €red_eq_defs› (Parsed(PPEqDef ed)) _ (Parsed(PPEqDefs eds)) _ = (
	PPEqDefs (ed :: eds)
) | red_eq_defs _ _ _ _ = stack_error "red_eq_defs";
=TEX
=SML
val €red_expr2_as_expr1› = red_accept;
=TEX
This phase fills in all stubs in templates as underscores. It is left to
the second phase to check the templates and fill in the correct stubs.
=SML
fun €red_pre_op› (Token (ZTPreOp (i,_), _)) (Parsed(PPPred p)) _ = (
	PPPred(PredFancyFix(TmplPre((i,Nil), StubUS), "", [[p]]))
) | red_pre_op _ _ _ = stack_error "red_pre_op";
=TEX
=SML
fun €red_post_op› (Parsed(PPPred p)) (Token (ZTPostOp (i,_), _)) _ = (
	PPPred(PredFancyFix(TmplPost(StubUS, (i,Nil)), "", [[p]]))
) | red_post_op _ _ _ = stack_error "red_post_op";
=TEX
=SML
=TEX
=SML
fun €red_in_op› (Parsed(PPPred p1)) (Token (ZTInOp (i,_), _))
		(Parsed(PPPred p2)) _ = (
	PPPred(PredFancyFix(TmplIn(StubUS, (i,Nil), StubUS), "", [[p1], [p2]]))
) | red_in_op _ _ _ _ = stack_error "red_in_op";
=TEX
=SML
fun €core_aux› (i1 : ID) ((arg1, rest) : CORE_EXPR) (i2 : ID)
	: CORE * ((PRED list) list) = (
	(	(i1, Value (map (fn (i, _) => (StubUS, i)) rest, (StubUS, i2))),
		arg1 :: map (fn (_, arg) => arg)  rest)
);
=TEX
=SML
fun €red_bo_ce_eo› (Token (ZTBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce)) (Token (ZTEndOp (e,_), _)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplNon c, "", args))
	end
) | red_bo_ce_eo _ _ _ _ = stack_error "red_bo_ce_eo";
=TEX
=SML
fun €red_bo_ce_peo› (Token (ZTBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce))
		(Token (ZTPreEndOp (e,_), _))
		(Parsed(PPPred p)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplPre(c, StubUS), "", args @ [[p]]))
	end
) | red_bo_ce_peo _ _ _ _ _ = stack_error "red_bo_ce_peo";
=TEX
=SML
fun €red_pbo_ce_eo› (Parsed(PPPred p))
		(Token (ZTPostBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce))
		(Token (ZTEndOp (e,_), _)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplPost(StubUS, c), "", [p] :: args))
	end
) | red_pbo_ce_eo _ _ _ _ _ = stack_error "red_pbo_ce_eo";
=TEX
=SML
fun €red_pbo_ce_peo› (Parsed(PPPred p1))
		(Token (ZTPostBeginOp (b,_), _))
		(Parsed(PPCoreExpr ce))
		(Token (ZTPreEndOp (e,_), _))
		(Parsed(PPPred p2)) _ = (
	let	val (c, args) = core_aux b ce e;
	in	PPPred(PredFancyFix(TmplIn(StubUS, c, StubUS), "", [p1]::args@[[p2]]))
	end
) | red_pbo_ce_peo _ _ _ _ _ _ = stack_error "red_pbo_ce_peo";
=TEX
=SML
fun €red_cross› (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred(PredCrossProduct(
		case (p1, p2) of
			(PredCrossProduct ps1, PredCrossProduct ps2) => ps1 @ ps2
		|	(PredCrossProduct ps1, _) => ps1 @ [p2]
		|	(_, PredCrossProduct ps2) => p1 :: ps2
		|	(_, _) => [p1, p2]))
) | red_cross _ _ _ _ = stack_error "red_cross";
=TEX
=SML
fun €red_exprs› (Parsed (PPSomeExprs ps)) _ = (
	PPCoreExpr(ps, [])
) | red_exprs _ _ = stack_error "red_exprs";
=TEX
=SML
fun €red_es_to_ce›
		(Parsed (PPSomeExprs ps))
		(Token (ZTThenOp (e,_), _))
		(Parsed (PPCoreExpr (a, r))) _ = (
	PPCoreExpr(ps, (e, a) :: r)
) | red_es_to_ce _ _ _ _ = stack_error "red_es_to_ce";
=TEX
=SML
fun €red_no_exprs› _ = (
	PPSomeExprs []
);
=TEX
=SML
val €red_some_exprs› = red_accept;
=TEX
=SML
val €red_pred1_as_some_exprs› = red_accept_pred_as_list;
=TEX
=SML
fun €red_pred1_comma_some_exprs› p _ ps _ = (
	add_pred_to_list_aux p ps
);
=TEX
=SML
val €red_expr3_as_expr2› = red_accept;
=TEX
=SML
fun €red_pow› _ (Parsed (PPPred p)) _ = (
	PPPred(PredPow p)
) | red_pow _ _ _ = stack_error "red_pow";
=TEX
=SML
val €red_expr4_as_expr3› = red_accept;
=TEX
=SML
fun €red_expr3_expr4› (Parsed(PPPred p1)) (Parsed(PPPred p2)) _ = (
	PPPred(PredApplication(p1, p2))
) | red_expr3_expr4 _ _ _ = stack_error "red_expr3_expr4";
=TEX
=SML
fun €red_theta› _ (Parsed(PPPred p)) _ = (
	PPPred(PredTheta p)
) | red_theta _ _ _ = stack_error "red_theta";
=TEX
=SML
fun €red_expr3_dot_expr4› (Parsed(PPPred p1)) _ (Parsed(PPPred p2)) _ = (
	PPPred(PredSelection(p1, p2))
) | red_expr3_dot_expr4 _ _ _ _ = stack_error "red_expr3_dot_expr4";
=TEX
=SML
fun €red_id_dec_as_exp› (Parsed(PPIdDec id)) _ = (
	PPPred(PredIdDec id)
) | red_id_dec_as_exp _ _ = stack_error "red_id_dec_as_exp";
=TEX
=SML
fun €red_quotation› (Token(ZTAqTm tm, _)) _  = (
	PPPred(PredQuotation tm)
) | red_quotation _ _ = stack_error "red_quotation";
=TEX
=SML
fun €stub_aux› (Token (ZTId "_", _)) = StubUS
|   stub_aux (Token (ZTDots, _)) = StubEll
|   stub_aux _ = stack_error "stub_aux";
=TEX
=SML
fun €red_stub› tk _ = (
	PPPred(PredPlaceHolder(stub_aux tk))
);
=TEX
=SML
fun €red_number› (Token (ZTNumber n, _)) _  = (
	PPPred(PredNumber n)
) | red_number _ _ = stack_error "red_number";
=TEX
=SML
fun €red_string› (Token (ZTString s, _)) _  = (
	PPPred(PredString s)
) | red_string _ _ = stack_error "red_string";
=TEX
=SML
fun €red_tuple› _ (Parsed(PPPred p)) _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredTuple(p :: ps))
) | red_tuple _ _ _ _ _ _ = stack_error "red_tuple";
=TEX
=SML
fun €red_set_display› _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredSetDisplay ps)
) | red_set_display _ _ _ _ = stack_error "red_set_display";
=TEX
=SML
fun €red_sequence_brk› _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredSeqDisplay ps)
) | red_sequence_brk _ _ _ _ = stack_error "red_sequence_brk";
=TEX
=SML
fun €red_set_comp_no_spot›
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ _ = (
	PPPred(PredSetComp(d, Value p, Nil))
) | red_set_comp_no_spot _ _ _ _ _ _ = stack_error "red_set_comp_no_spot";
=TEX
=SML
fun €red_set_comp_no_pred›
	_ (Parsed(PPDecl d)) _ _ = (
	PPPred(PredSetComp(d, Nil, Nil))
) | red_set_comp_no_pred _ _ _ _ = stack_error "red_set_comp_no_pred";
=TEX
=SML
fun €red_set_comp›
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p1))
	_ (Parsed(PPPred p2)) _ _ = (
	PPPred(PredSetComp(d, Value p1, Value p2))
) | red_set_comp _ _ _ _ _ _ _ _ = stack_error "red_set_comp";
=TEX
=SML
fun €red_set_comp_no_bar›
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ _ = (
	PPPred(PredSetComp(d, Nil, Value p))
) | red_set_comp_no_bar _ _ _ _ _ _ = stack_error "red_set_comp_no_bar";
=TEX
=SML
fun €red_horiz_schema›
	_ (Parsed(PPDecl d))
	_ (Parsed(PPPred p)) _ _ = (
	PPPred(PredHorizSchema(d, Value p))
) | red_horiz_schema _ _ _ _ _ _ = stack_error "red_horiz_schema";
=TEX
=SML
fun €red_horiz_schema_no_pred›
	_ (Parsed(PPDecl d)) _ _ = (
	PPPred(PredHorizSchema(d, Nil))
) | red_horiz_schema_no_pred _ _ _ _ = stack_error "red_horiz_schema_no_pred";
=TEX
=SML
fun €red_gen_inst› _ (Parsed(PPSomeExprs ps)) _ _ = (
	PPPred(PredGenInst ps)
) | red_gen_inst _ _ _ _ = stack_error "red_gen_inst";
=TEX
=SML
val €red_rename_list_as_expr› = red_accept;
=TEX
=SML
fun €red_brk_pred› _ (Parsed(PPPred p)) _ _ = (
	PPPred(PredBracketed (p, ""))
) | red_brk_pred _ _ _ _ = stack_error "red_brk_pred";
=TEX
=SML
fun €red_pred_decor› _ (Parsed(PPPred p)) _ (Token (ZTDecor d, _)) _ = (
	PPPred(PredBracketed (p, d))
) | red_pred_decor _ _ _ _ _ = stack_error "red_pred_decor";
=TEX
=SML
fun €red_id› (Token (ZTId i, _)) _ = (
	PPIdDec (i, "")
) | red_id _ _ = stack_error "red_id";
=TEX
=SML
fun €red_id_dec› (Token (ZTId i, _)) (Token (ZTDecor d, _)) _ = (
	PPIdDec (i, d)
) | red_id_dec _ _ _ = stack_error "red_id_dec";
=TEX

=TEX
\section{EPILOGUE}
SML
end (* of structure Parser *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
=IGN


ÒxÆ;
Òx yÆ;
Ò(x)Æ;
Ò(x y)Æ;
Ò[x]Æ;
Òx [y]Æ;
Ò[y|z]Æ;
Òx [y|z]Æ;
Òfun 10 3Æ;
Ò[a,b,c]Æ;



∞
