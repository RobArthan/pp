=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Z Abstract Machine}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Z Abstract Machine}
\TPPref{DS/FMU/IED/???}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the constructor, discriminator and destructor functions corresponding to the primitive constructors of Z.
The formal specification of these is found in \cite{DS/FMU/IED/ZED002} and \cite{DS/FMU/IED/ZED003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives a detailed design, in the form of signatures and informal descriptions,  of the functions mentioned above.
Additional functions, which are used in other parts of the Z system, may also be included here for convenience.
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{?} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intecepted and reported as helpfully as possible.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{SIGNATURE}
=DOC
signature ‚ZAbstractMachine· = sig
=DESCRIBE
The Z Abstract Machine functions are packaged into this signature.
=ENDDOC
\section{DATATYPE FOR Z TERMS}
The following datatype is a simplification of the abstract datatypes found in \cite{DS/FMU/IED/ZED002}, in which recursion has been removed and the distinction between declarations, predicates and terms ignored.
It is used by the generalised mapping functions $mk\_Z\_TERM$, $is\_Z\_TERM$ and $dest\_Z\_TERM$ (q.v.).
=SML
datatype	‚ZTERM· = 	Zdec of TERM list * TERM
		|		Zdecsexp of TERM * string
		|		Zdecl of TERM list
		|		Zeq of TERM * TERM
		|		Zù of TERM * TERM
		|		Ztrue
		|		Zfalse
		|		Zå of TERM
		|		ZÄ of TERM * TERM
		|		ZÅ of TERM * TERM
		|		Zä of TERM * TERM
		|		ZÇ of TERM * TERM
		|		ZÑ of TERM * TERM * TERM
		|		Z¿ of TERM * TERM * TERM
		|		ZÉ of TERM * TERM * TERM
		|		Zpredsexp of TERM * string
		|		Zlvar of string * TYPE * TERM list
		|		Zgvar of string * TYPE * TERM list
		|		Zæø of TYPE * TERM list
		|		Z{} of TYPE * TERM list
		|		Z{é} of TERM * TERM * TERM
		|		Zë of TERM
		|		Ztuple of TERM list
		|		Zâ of TERM list
		|		Z≠ of TERM * string
		|		Zsel of TERM * string
		|		Zcomb of TERM * TERM
		|		Zç of TERM * TERM * TERM
		|		Zá of TERM * TERM * TERM
		|		Z’ of TERM * TERM
		|		Zdec’ of TERM * string
		|		Zpre’ of TERM
		|		Zå’ of TERM
		|		ZÄ’ of TERM * TERM
		|		ZÅ’ of TERM * TERM
		|		Zä’ of TERM * TERM
		|		ZÇ’ of TERM * TERM
		|		Z¡’ of TERM * TERM
		|		Zƒ’ of TERM * string list
		|		ZÑ’ of TERM * TERM * TERM
		|		Z¿’ of TERM * TERM * TERM
		|		ZÉ’ of TERM * TERM * TERM
		|		ZÒ’ of TERM
		|		ZÚ’ of TERM
		|		ZØ’ of TERM * TERM;
=TEX
\section{Z TYPES}
The following sections describe the constructor, discriminator and destructor functions for each of the five Z type constructors.
\subsection{Given Sets}
=DOC
val ‚mk_ZgivenT· : string -> TYPE;
val ‚is_ZgivenT· : TYPE -> bool;
val ‚dest_ZgivenT· : TYPE -> string
=DESCRIBE
The type of given sets.
=FAILURE
001	?0 is not a given type
=ENDDOC
\subsection{Generic Variables}
=DOC
val ‚mk_ZvarT· : string -> TYPE;
val ‚is_ZvarT· : TYPE -> bool;
val ‚dest_ZvarT· : TYPE -> string;
=DESCRIBE
The type of generic parameters.
=FAILURE
002	?0 is not a type variable
=ENDDOC
\subsection{Set Types}
=DOC
val ‚mk_ZpowerT· : TYPE -> TYPE;
val ‚is_ZpowerT· : TYPE -> bool;
val ‚dest_ZpowerT· : TYPE -> TYPE;
=DESCRIBE
Set type constructor.
ÛDefinition
mk_ZpowerT ty = ë ty
Ê
=FAILURE
003	?0 is not a set type
=ENDDOC
\subsection{Cartesian Product Types}
=DOC
val ‚mk_ZtupleT· : TYPE list -> TYPE;
val ‚is_ZtupleT· : TYPE -> bool;
val ‚dest_ZtupleT· : TYPE -> TYPE list;
=DESCRIBE
Cartesian product type constructor.
ÛDefinition
mk_ZtupleT [ty1,...,tyn] = ty1 â ... â tyn
Ê
=FAILURE
004	?0 is not a tuple type
=ENDDOC
\subsection{Binding Types}
=DOC
val ‚mk_ZschemaT· : (string * TYPE) list -> TYPE;
val ‚is_ZschemaT· : TYPE -> bool;
val ‚dest_ZschemaT· : TYPE -> (string * TYPE) list;
=DESCRIBE
Binding type constructor.
ÛDefinition
mk_ZschemaT [(c1,ty1),...,(cn,tyn)] = æ| c1:ty1 ; ... ; cn:tyn |ø
Ê
=FAILURE
005	?0 is not a schema type
=ENDDOC
\section{Z TERMS}
The following describes the constructor, discriminator and destructor functions for Z terms.
In each case, the description is for the constructor function; the destructor is simply the inverse and the discriminator returns true if its argument was made using the appropriate constructor, false otherwise.96z
\subsection{Declarations}
=DOC
val ‚mk_Zdec· : TERM list * TERM -> TERM;
val ‚is_Zdec· : TERM -> bool;
val ‚dest_Zdec· : TERM -> TERM * TERM;
=DESCRIBE
Makes a simple declaration of one or more variables of the same type for use in the declaration part of a schema text.
ÛDefinition
mk_Zdec([v1,...,vn],S) = v1,...vn : S
Ê
Where the $v_i$ and the members of $set$ must have the same type.
=USES
May only be used to make arguments for $mk\_Zdecl$.
=FAILURE
006	?0 is not simple declaration
=ENDDOC
=DOC
val ‚mk_Zdecsexp· : TERM * string -> TERM;
val ‚is_Zdecsexp· : TERM -> bool;
val ‚dest_Zdecsexp· : TERM -> TERM * string;
=DESCRIBE
Makes a declaration of the components of a schema (the first argument), systematically decorated with the second argument.
=USES
May only be used to make arguments for $mk\_Zdecl$.
=FAILURE
007	?0 is not a schema as declaration
=ENDDOC
=DOC
val ‚mk_Zdecl· : TERM list -> TERM;
val ‚is_Zdecl· : TERM -> bool;
val ‚dest_Zdecl· : TERM -> TERM list;
=DESCRIBE
Makes the declaration part of a schema text.  Its arguments must be made using $mk\_Zdec$ or $mk\_Zdecsexp$.
ÛDefinition
mk_Zdecl [t1,...,tn] = t1;...;tn
Ê
=FAILURE
008	?0 is not declaration
=ENDDOC
\subsection{Terms}
=DOC
val ‚mk_Zlvar· : string * TYPE * TERM list -> TERM;
val ‚is_Zlvar· : TERM -> bool;
val ‚dest_Zlvar· : TERM -> string * TYPE * TERM list;
=DESCRIBE
The constructor for local variables.
If the third argument is the empty list, this function is the same as the HOL $mk\_var$ function, otherwise a generic variable is created, the third argument being the generic actual parameters. 
=FAILURE
009	?0 is not a local variable
=ENDDOC
=DOC
val ‚mk_Zgvar· : string * TYPE * TERM list -> TERM;
val ‚is_Zgvar· : TERM -> bool;
val ‚dest_Zgvar· : TERM -> string * TYPE * TERM list;
=DESCRIBE
The constructor for global variables.
If the third argument is the empty list, this function is the same as the HOL $mk\_const$ function, otherwise a generic constant is created, the third argument being the generic actual parameters. 
=FAILURE
010	?0 is not a global variable
=ENDDOC
=DOC
val ‚mk_Zæø· : TYPE * TERM list -> TERM;
val ‚is_Zæø· : TERM -> bool;
val ‚dest_Zæø· : TERM -> TYPE * TERM list;
=DESCRIBE
The constructor for finite sequences.
The result is the sequence made from the terms in the second argument, each of whose types must be the same as the first argument.
ÛDefinition
mk_Zæø(ty,[t1,...,tn]) = æt1,...,tnø
Ê
Where the $t_i$ all have type $ty$.
=FAILURE
011	?0 is not a sequence display
=ENDDOC
=DOC
val ‚mk_Z{}· : TYPE * TERM list -> TERM;
val ‚is_Z{}· : TERM -> bool;
val ‚dest_Z{}· : TERM -> TYPE * TERM list;
=DESCRIBE
The constructor for finite set displays.
The result is the set made from the terms in the second argument, each of whose types must be the same as the first argument.
ÛDefinition
mk_Z{}(ty,[t1,...,tn]) = {t1,...,tn}
Ê
Where the $t_i$ all have type $ty$.
=FAILURE
012	?0 is not a set display
=ENDDOC
=DOC
val ‚mk_Z{é}· : TERM * TERM * TERM -> TERM;
val ‚is_Z{é}· : TERM -> bool;
val ‚dest_Z{é}· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for set comprehension.
The three arguments represent the declaration, predicate and body parts of the set comprehension and so must have the appropriate types.
In particular, the first argument must be made using $mk\_Zdecl$.
ÛDefinition
mk_Z{é}(d,p,v) = {d | p é v}
Ê
=FAILURE
013	?0 is not a set comprehension
=ENDDOC
=DOC
val ‚mk_Zë· : TERM -> TERM;
val ‚is_Zë· : TERM -> bool;
val ‚dest_Zë· : TERM -> TERM;
=DESCRIBE
The powerset constructor.
ÛDefinition
mk_Zë t = ë t
Ê
=FAILURE
014	?0 is not a powerset
=ENDDOC
=DOC
val ‚mk_Ztuple· : TERM list -> TERM;
val ‚is_Ztuple· : TERM -> bool;
val ‚dest_Ztuple· : TERM -> TERM list;
=DESCRIBE
The tuple constructor.
ÛDefinition
mk_Ztuple [t1,...,tn] = (t1,...,tn)
Ê
=FAILURE
015	?0 is not a tuple
=ENDDOC
=DOC
val ‚mk_Zâ· : TERM list -> TERM;
val ‚is_Zâ· : TERM -> bool;
val ‚dest_Zâ· : TERM -> TERM list;
=DESCRIBE
The cartesian product constructor.
ÛDefinition
mk_Zâ [t1,...,tn] = (t1 â ... â tn)
Ê
=FAILURE
016	?0 is not a cartesian product
=ENDDOC
=DOC
val ‚mk_Z≠· : TERM * string -> TERM;
val ‚is_Z≠· : TERM -> bool;
val ‚dest_Z≠· : TERM -> TERM * string;
=DESCRIBE
The theta term constructor.
The first argument must be a schema, the second is an optional decoration.
ÛDefinition
mk_Z≠(S,"'") = ≠S'
Ê
=FAILURE
017	?0 is not a theta term
=ENDDOC
=DOC
val ‚mk_Zsel· : TERM * string -> TERM;
val ‚is_Zsel· : TERM -> bool;
val ‚dest_Zsel· : TERM -> TERM * string;
=DESCRIBE
Selection of a component from a binding.
The type of the first argument must be a binding and the second argument must be a component of that type.
ÛDefinition
mk_Zsel(S,"c") = S.c
Ê
=FAILURE
018	?0 is not a selection
=ENDDOC
=DOC
val ‚mk_Zcomb· : TERM * TERM -> TERM;
val ‚is_Zcomb· : TERM -> bool;
val ‚dest_Zcomb· : TERM -> TERM * TERM;
=DESCRIBE
Z function application.
The first argument must be a set of pairs, the second must have the same type as the first elements of the pairs.
ÛDefinition
mk_Zcomb(f,a) = (f a)
Ê
=FAILURE
019	?0 is not a function application
=ENDDOC
=DOC
val ‚mk_Zç· : TERM * TERM * TERM -> TERM;
val ‚is_Zç· : TERM -> bool;
val ‚dest_Zç· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The lambda constructor.
The arguments are a declaration (constructed using $mk\_Zdecl$ q.v.), a predicate and the body of the abstraction.
ÛDefinition
mk_Zç(d,p,v) = çd|pév
Ê
=FAILURE
020	?0 is not a lambda abstraction
=ENDDOC
=DOC
val ‚mk_Zá· : TERM * TERM * TERM -> TERM;
val ‚is_Zá· : TERM -> bool;
val ‚dest_Zá· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The definite description constructor.
The arguments are a declaration (constructed using $mk\_Zdecl$ q.v.), a predicate and the body of the definite description.
ÛDefinition
mk_Zá(d,p,v) = ád|pév
Ê
=FAILURE
021	?0 is not a mu term
=ENDDOC
\subsection{Predicates}
=DOC
val ‚mk_Zeq· : TERM * TERM -> TERM;
val ‚is_Zeq· : TERM -> bool;
val ‚dest_Zeq· : TERM -> TERM * TERM;
=DESCRIBE
Equality.
For the moment this is the same as HOL equality, but this is likely to change in the future.
Both arguments must be of the same type.
ÛDefinition
mk_Zeq(a,b) = (a = b)
Ê
=FAILURE
022	?0 is not an equality
=ENDDOC
=DOC
val ‚mk_Zù· : TERM * TERM -> TERM;
val ‚is_Zù· : TERM -> bool;
val ‚dest_Zù· : TERM -> TERM * TERM;
=DESCRIBE
Set membership.
The second argument must be a set, whose members have the same type as the first argument.
ÛDefinition
mk_Zù(a,b) = (a ù b)
Ê
=FAILURE
023	?0 is not a set membership
=ENDDOC
=DOC
val ‚mk_Ztrue· : TERM;
val ‚is_Ztrue· : TERM -> bool;
=DESCRIBE
The Z constant $true$.
It is the same as the HOL constant $T$.
=ENDDOC
=DOC
val ‚mk_Zfalse· : TERM;
val ‚is_Zfalse· : TERM -> bool;
=DESCRIBE
The Z constant $false$.
It is the same as the HOL constant $F$.
=ENDDOC
=DOC
val ‚mk_Zå· : TERM -> TERM;
val ‚is_Zå· : TERM -> bool;
val ‚dest_Zå· : TERM -> TERM;
=FAILURE
024	?0 is not a negation
=DESCRIBE
Negation; the same as HOL $å$.
Its argument must be $bool$ type.
=ENDDOC
=DOC
val ‚mk_ZÄ· : TERM * TERM -> TERM;
val ‚is_ZÄ· : TERM -> bool;
val ‚dest_ZÄ· : TERM -> TERM * TERM;
=DESCRIBE
Conjunction; the same as HOL $Ä$.
Its arguments must be $bool$ type.
=FAILURE
025	?0 is not a conjunction
=ENDDOC
=DOC
val ‚mk_ZÅ· : TERM * TERM -> TERM;
val ‚is_ZÅ· : TERM -> bool;
val ‚dest_ZÅ· : TERM -> TERM * TERM;
=DESCRIBE
Disjunction; the same as HOL $Å$.
Its arguments must be $bool$ type.
=FAILURE
026	?0 is not a disjunction
=ENDDOC
=DOC
val ‚mk_Zä· : TERM * TERM -> TERM;
val ‚is_Zä· : TERM -> bool;
val ‚dest_Zä· : TERM -> TERM * TERM;
=DESCRIBE
Implication; the same as HOL $ä$.
Its arguments must be $bool$ type.
=FAILURE
027	?0 is not an implication
=ENDDOC
=DOC
val ‚mk_ZÇ· : TERM * TERM -> TERM;
val ‚is_ZÇ· : TERM -> bool;
val ‚dest_ZÇ· : TERM -> TERM * TERM;
=DESCRIBE
If and only if; the same as HOL $Ç$.
Its argument must be $bool$ type.
=FAILURE
028	?0 is not if and only if
=ENDDOC
=DOC
val ‚mk_ZÑ· : TERM * TERM * TERM -> TERM;
val ‚is_ZÑ· : TERM -> bool;
val ‚dest_ZÑ· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for existential quantification.
Its arguments must be a declaration (constructed with $mk\_Zdecl$) and two predicates.
ÛDefinition
mk_ZÑ(d,p,v) = Ñd|pév
Ê
=FAILURE
029	?0 is not an existential quantification
=ENDDOC
=DOC
val ‚mk_Z¿· : TERM * TERM * TERM -> TERM;
val ‚is_Z¿· : TERM -> bool;
val ‚dest_Z¿· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for unique existential quantification.
Its arguments must be a declaration (constructed with $mk\_Zdecl$) and two predicates.
ÛDefinition
mk_Z¿(d,p,v) = ¿d|pév
Ê
=FAILURE
030	?0 is not a unique existential quantification
=ENDDOC
=DOC
val ‚mk_ZÉ· : TERM * TERM * TERM -> TERM;
val ‚is_ZÉ· : TERM -> bool;
val ‚dest_ZÉ· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for universal quantification.
Its arguments must be a declaration (constructed with $mk\_Zdecl$) and two predicates.
ÛDefinition
mk_ZÉ(d,p,v) = Éd|pév
Ê
=FAILURE
031	?0 is not a universal quantification
=ENDDOC
=DOC
val ‚mk_Zpredsexp· : TERM * string -> TERM;
val ‚is_Zpredsexp· : TERM -> bool;
val ‚dest_Zpredsexp· : TERM -> TERM * string;
=DESCRIBE
The schema as predicate constructor.
The first argument must be a schema, the second is an optional decoration.
=FAILURE
032	?0 is not a schema as predicate expression
=ENDDOC
\subsection{Schema Calculus}
=DOC
val ‚mk_Z’· : TERM * TERM -> TERM;
val ‚is_Z’· : TERM -> bool;
val ‚dest_Z’· : TERM -> TERM * TERM;
=DESCRIBE
The schema constructor.
The first argument is a declaration constructed using $mk\_Zdecl$, the second is a predicate.
ÛDefinition
mk_Z’(d,p) = [d | p]
Ê
=FAILURE
033	?0 is not a schema
=ENDDOC
=DOC
val ‚mk_Zdec’· : TERM * string -> TERM;
val ‚is_Zdec’· : TERM -> bool;
val ‚dest_Zdec’· : TERM -> TERM * string;
=DESCRIBE
The constructor for systematic decoration of schemas.
The first argument must be a schema, the second a decoration.
ÛExample
mk_Zdec’([a,b,c:X | a = b],"'") = [a',b',c':X | a' = b']
Ê
=FAILURE
034	?0 is not a decorated schema
=ENDDOC
=DOC
val ‚mk_Zpre’· : TERM -> TERM;
val ‚is_Zpre’· : TERM -> bool;
val ‚dest_Zpre’· : TERM -> TERM;
=DESCRIBE
The schema precondition constructor.
The argument must be a schema.
ÛDefinition
mk_Zpre’ S = pre S
Ê
=FAILURE
035	?0 is not a schema precondition
=ENDDOC
=DOC
val ‚mk_Zå’· : TERM -> TERM;
val ‚is_Zå’· : TERM -> bool;
val ‚dest_Zå’· : TERM -> TERM;
=DESCRIBE
The schema negation constructor.
The argument must be a schema.
ÛDefinition
mk_Zå’ S = åS
Ê
=FAILURE
036	?0 is not a schema negation
=ENDDOC
=DOC
val ‚mk_ZÄ’· : TERM * TERM -> TERM;
val ‚is_ZÄ’· : TERM -> bool;
val ‚dest_ZÄ’· : TERM -> TERM * TERM;
=DESCRIBE
The schema conjunction constructor.
Both arguments must be schemas.
ÛDefinition
mk_ZÄ’(R,S) = R Ä S
Ê
=FAILURE
037	?0 is not a schema conjunction
=ENDDOC
=DOC
val ‚mk_ZÅ’· : TERM * TERM -> TERM;
val ‚is_ZÅ’· : TERM -> bool;
val ‚dest_ZÅ’· : TERM -> TERM * TERM;
=DESCRIBE
The schema disjunction constructor.
Both arguments must be schemas.
ÛDefinition
mk_ZÅ’(R,S) = R Å S
Ê
=FAILURE
038	?0 is not a schema disjunction
=ENDDOC
=DOC
val ‚mk_Zä’· : TERM * TERM -> TERM;
val ‚is_Zä’· : TERM -> bool;
val ‚dest_Zä’· : TERM -> TERM * TERM;
=DESCRIBE
The schema implication constructor.
Both arguments must be schemas.
ÛDefinition
mk_Zä’(R,S) = R ä S
Ê
=FAILURE
039	?0 is not a schema implication
=ENDDOC
=DOC
val ‚mk_ZÇ’· : TERM * TERM -> TERM;
val ‚is_ZÇ’· : TERM -> bool;
val ‚dest_ZÇ’· : TERM -> TERM * TERM;
=DESCRIBE
The schema equivalence constructor.
Both arguments must be schemas.
ÛDefinition
mk_ZÇ’(R,S) = R Ç S
Ê
=FAILURE
040	?0 is not a schema if and only if
=ENDDOC
=DOC
val ‚mk_Z¡’· : TERM * TERM -> TERM;
val ‚is_Z¡’· : TERM -> bool;
val ‚dest_Z¡’· : TERM -> TERM * TERM;
=DESCRIBE
The schema projection constructor.
Both arguments must be schemas.
ÛDefinition
mk_Z¡’(R,S) = R ¡ S
Ê
=FAILURE
041	?0 is not schema projection
=ENDDOC
=DOC
val ‚mk_Zƒ’· : TERM * string list -> TERM;
val ‚is_Zƒ’· : TERM -> bool;
val ‚dest_Zƒ’· : TERM -> TERM * string list;
=DESCRIBE
The schema hiding constructor.
The first argument must be a schema, the second is a list of components to be hidden.
ÛDefinition
mk_Zƒ’(S,[c1,...cn]) = S ƒ (c1,...,cn)
Ê
=FAILURE
042	?0 is not schema hiding
=ENDDOC
=DOC
val ‚mk_ZÑ’· : TERM * TERM * TERM -> TERM;
val ‚is_ZÑ’· : TERM -> bool;
val ‚dest_ZÑ’· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The schema existential quantifier constructor.
The arguments must be a declaration (constructed using $mk\_Zdecl$), a predicate and a schema.
ÛDefinition
mk_ZÑ’(d,p,S) = Ñd | p é S
Ê
=FAILURE
043	?0 is not schema existential
=ENDDOC
=DOC
val ‚mk_Z¿’· : TERM * TERM * TERM -> TERM;
val ‚is_Z¿’· : TERM -> bool;
val ‚dest_Z¿’· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The schema unique existential quantifier constructor.
The arguments must be a declaration (constructed using $mk\_Zdecl$), a predicate and a schema.
ÛDefinition
mk_Z¿’(d,p,S) = ¿d | p é S
Ê
=FAILURE
044	?0 is not schema unique existential
=ENDDOC
=DOC
val ‚mk_ZÉ’· : TERM * TERM * TERM -> TERM;
val ‚is_ZÉ’· : TERM -> bool;
val ‚dest_ZÉ’· : TERM -> TERM * TERM * TERM;
=DESCRIBE
The schema universal quantifier constructor.
The arguments must be a declaration (constructed using $mk\_Zdecl$), a predicate and a schema.
ÛDefinition
mk_ZÉ’(d,p,S) = Éd | p é S
Ê
=FAILURE
045	?0 is not schema universal
=ENDDOC
=DOC
val ‚mk_ZÒ’· : TERM -> TERM;
val ‚is_ZÒ’· : TERM -> bool;
val ‚dest_ZÒ’· : TERM -> TERM;
=DESCRIBE
The delta constructor.
Its argument must be a schema.
ÛDefinition
mk_ZÒ’ S = ÒS
Ê
=FAILURE
046	?0 is not delta
=ENDDOC
=DOC
val ‚mk_ZÚ’· : TERM -> TERM;
val ‚is_ZÚ’· : TERM -> bool;
val ‚dest_ZÚ’· : TERM -> TERM;
=DESCRIBE
The xi constructor.
Its argument must be a schema.
ÛDefinition
mk_ZÚ’ S = ÚS
Ê
=FAILURE
047	?0 is not xi
=ENDDOC
=DOC
val ‚mk_ZØ’· : TERM * TERM -> TERM;
val ‚is_ZØ’· : TERM -> bool;
val ‚dest_ZØ’· : TERM -> TERM * TERM;
=DESCRIBE
The sequential composition constructor.
Its arguments must both be schemas.
ÛDefinition
mk_ZØ’(R,S) = R Ø S
Ê
=FAILURE
048	?0 is not schema composition
=ENDDOC
\section{GENERALISED MAPPING FUNCTIONS}
These functions map HOL terms representing Z terms to and from the intermediate datatype $ZTERM$ q.v.
=DOC
val mk_ZTERM : ZTERM -> TERM;
=DESCRIBE
Given any $ZTERM$, $mk\_ZTERM$ calls the appropriate abstract machine $mk\_$ function.
=ENDDOC
=DOC
val is_ZTERM : TERM -> bool;
=DESCRIBE
Tests if a given HOL term is valid Z.
=USES
Recursively in well-formedness checks.
=ENDDOC
=DOC
val dest_ZTERM : TERM -> ZTERM;
=DESCRIBE
Converts a HOL term, which represents a valid Z term, to the appropriate ZTERM.
=USES
Recursively in the pretty printer.
=FAILURE
999	?0 is not valid Z.
=ENDDOC
\section{END OF SIGNATURE}
=SML
end (* end of ZAbstractMachine signature *);
=TEX
\section{HOL REPRESENTATIONS OF Z TYPES AND TERMS}
\subsection{Types}
\subsubsection{Given Types}
A Z given type is represented in HOL as a 0-ary type of the same name.
ÛDefinition
mk_ZgivenT str = ()str
Ê
\subsubsection{Generic Types}
The types of Z generic variables are represented as HOL type variables of the same name.
ÛDefinition
mk_vartT str = *str
Ê
\subsubsection{Set Types}
A Z set type is represented by the unary HOL type ë.
ÛDefinition
mk_ZpowerT ty = (ty)ë
Ê
\subsubsection{Tuple Types}
A Z tuple type is represented in the same way as a binding (see below) whose components are numeric.
ÛDefinition
mk_ZtupleT [ty1,...,tyk] = (ty1,...,tyk)S_æ1©...©kø
Ê
\subsubsection{Schema Types}
The type of a Z binding is represented in HOL as an n-ary type constructor, whose name is derived from the components of the binding.
ÛDefinition
mk_ZschemaT [("c1",ty1),...,("ck",tyk)] = (ty1,...,tyk)S_æc1©...©ckø
Ê
Note that bindings which differ only in the order of their components map to identical types.
\subsection{Terms}
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
