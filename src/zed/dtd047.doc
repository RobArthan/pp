=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Z Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Z Types and Terms}
\TPPref{DS/FMU/IED/DTD047}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.T.Scullard & MAN05}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\TPPdate{\FormatDate{$Date$
}})]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the constructor, discriminator and destructor functions corresponding to the primitive constructors of Z.
The formal specification of these is found in \cite{DS/FMU/IED/ZED002} and \cite{DS/FMU/IED/ZED003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives a detailed design, in the form of signatures and informal descriptions,  of the functions mentioned above.
Additional functions, which are used in other parts of the Z system, may also be included here for convenience.
\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
For performance reasons, the arguments of the various constructors below are not checked for well-formedness or suitability and
it will therefore be possible, indeed easy, to construct terms which are not legal in our extended Z syntax.
Such terms will be identified by the pretty printer \cite{?} and will normally, though not necessarily, be errors.
Of course, where the term construction fails due to some error detected in the underlying HOL or ML, it is intecepted and reported as helpfully as possible.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{SIGNATURE}
=DOC
signature ÛZTypesAndTermsÝ = sig
=DESCRIBE
The Z Abstract Machine functions are packaged into this signature.
=ENDDOC
\section{DATATYPE FOR Z TYPES}
=DOC
datatype	ÛZTYPEÝ = 	ZgivenT of string
		|		ZvarT of string
		|		ZpowerT of TYPE
		|		ZtupleT of TYPE list
		|		ZschemaT of (string * TYPE) list;
=DESCRIBE
This datatype is a representation of the abstract datatype found in \cite{DS/FMU/IED/ZED002}.
It is used by the generalised mapping functions $mk\_ZTYPE$, $is\_ZTYPE$ and $dest\_ZTYPE$ (q.v.).
=ENDDOC
\section{DATATYPE FOR Z TERMS}
\ftlinepenalty=0
=DOC
datatype	ÛZTERMÝ = 	Zdec of TERM list * TERM
		|		Zdecsexp of TERM * string
		|		Zdecl of TERM list
		|		Zeq of TERM * TERM
		|		Z of TERM * TERM
		|		Ztrue
		|		Zfalse
		|		Z³ of TERM
		|		Z± of TERM * TERM
		|		Z² of TERM * TERM
		|		Z´ of TERM * TERM
		|		Z¤ of TERM * TERM
		|		Z¶ of TERM * TERM * TERM
		|		Z¶%down%1 of TERM * TERM * TERM
		|		Zµ of TERM * TERM * TERM
		|		Zpredsexp of TERM * string
		|		Zlvar of string * TYPE * TERM list
		|		Zgvar of string * TYPE * TERM list
		|		Zint of string
		|		Z§¢ of TYPE * TERM list
		|		Zsetd of TYPE * TERM list
		|		Zseta of TERM * TERM * TERM
		|		Zð of TERM
		|		ZT of TERM list
		|		Z¸ of TERM list
		|		ZÊ of TERM * string
		|		Zsel of TERM * string
		|		Zapp of TERM * TERM
		|		ZÌ of TERM * TERM * TERM
		|		ZÍ of TERM * TERM * TERM
		|		Z%down%s of TERM * TERM
		|		Zdec%down%s of TERM * string
		|		Zpre%down%s of TERM
		|		Z³%down%s of TERM
		|		Z±%down%s of TERM * TERM
		|		Z²%down%s of TERM * TERM
		|		Z´%down%s of TERM * TERM
		|		Z¤%down%s of TERM * TERM
		|		Zù%down%s of TERM * TERM
		|		Zhide%down%s of TERM * string list
		|		Z¶%down%s of TERM * TERM * TERM
		|		Z¶%down%1%down%s of TERM * TERM * TERM
		|		Zµ%down%s of TERM * TERM * TERM
		|		Z„%down%s of TERM
		|		Z˜%down%s of TERM
		|		Z»%down%s of TERM * TERM;
=DESCRIBE
This datatype is a simplification of the abstract datatypes found in \cite{DS/FMU/IED/ZED002}, in which recursion has been removed and the distinction between declarations, predicates and terms ignored.
It is used by the generalised mapping functions $mk\_ZTERM$, $is\_ZTERM$ and $dest\_ZTERM$ (q.v.).
=ENDDOC
\section{NAME DESTRUCTION}
=DOC
val Ûdest_Z_nameÝ : string -> string * string list list;
=DESCRIBE
Analyses the names of Z semantic constants, returning the basic name and lists of embedded component names.
=FAILURE
47000	?0 is a badly formed Z constant name
=ENDDOC
\section{Z TYPES}
The following sections describe the constructor, discriminator and destructor functions for each of the five Z type constructors.
\subsection{Given Sets}
=DOC
val Ûmk_ZgivenTÝ : string -> TYPE;
val Ûis_ZgivenTÝ : TYPE -> bool;
val Ûdest_ZgivenTÝ : TYPE -> string
=DESCRIBE
The type of given sets.
=FAILURE
47010	?0 is not a given type
=ENDDOC
\subsection{Generic Variables}
=DOC
val Ûmk_ZvarTÝ : string -> TYPE;
val Ûis_ZvarTÝ : TYPE -> bool;
val Ûdest_ZvarTÝ : TYPE -> string;
=DESCRIBE
The type of generic parameters.
=FAILURE
47020	?0 is not a type variable
=ENDDOC
\subsection{Set Types}
=DOC
val Ûmk_ZpowerTÝ : TYPE -> TYPE;
val Ûis_ZpowerTÝ : TYPE -> bool;
val Ûdest_ZpowerTÝ : TYPE -> TYPE;
=DESCRIBE
Set type constructor.
=GFT Definition
mk_ZpowerT ty = ð ty
=TEX
=FAILURE
47030	?0 is not a set type
=ENDDOC
\subsection{Cartesian Product Types}
=DOC
val Ûmk_ZtupleTÝ : TYPE list -> TYPE;
val Ûis_ZtupleTÝ : TYPE -> bool;
val Ûdest_ZtupleTÝ : TYPE -> TYPE list;
=DESCRIBE
Cartesian product type constructor.
=GFT Definition
mk_ZtupleT [ty1,...,tyn] = ty1 ¸ ... ¸ tyn
=TEX
=FAILURE
47040	?0 is not a tuple type
=ENDDOC
\subsection{Binding Types}
=DOC
val Ûmk_ZschemaTÝ : (string * TYPE) list -> TYPE;
val Ûis_ZschemaTÝ : TYPE -> bool;
val Ûdest_ZschemaTÝ : TYPE -> (string * TYPE) list;
=DESCRIBE
Binding type constructor.
=GFT Definition
mk_ZschemaT [(c1,ty1),...,(cn,tyn)] = §| c1:ty1 ; ... ; cn:tyn |¢
=TEX
=FAILURE
47050	?0 is not a binding type
=ENDDOC
\section{Z TERMS}
The following describes the constructor, discriminator and destructor functions for Z terms.
In each case, the description is for the constructor function; the destructor is simply the inverse and the discriminator returns true if its argument was made using the appropriate constructor, false otherwise.
\subsection{Declarations}
=DOC
val Ûmk_ZdecÝ : TERM list * TERM -> TERM;
val Ûis_ZdecÝ : TERM -> bool;
val Ûdest_ZdecÝ : TERM -> TERM list * TERM;
=DESCRIBE
Makes a simple declaration of one or more variables of the same type for use in the declaration part of a schema text.
=GFT Definition
mk_Zdec([v1,...,vn],S) = v1,...vn : S
=TEX
Where the $v_i$ and the members of $set$ must have the same type.
=USES
May only be used to make arguments for $mk\_Zdecl$.
=FAILURE
47060	?0 is not a set
3012	?0 and ?1 do not have the same types
3017	An empty list argument is not allowed
47061	?0 is not a simple Z declaration
=ENDDOC
=DOC
val Ûmk_ZdecsexpÝ : TERM * string -> TERM;
val Ûis_ZdecsexpÝ : TERM -> bool;
val Ûdest_ZdecsexpÝ : TERM -> TERM * string;
=DESCRIBE
Makes a declaration of the components of a schema (the first argument), systematically decorated with the second argument.
=USES
May only be used to make arguments for $mk\_Zdecl$.
=FAILURE
47070	?0 is not a schema
47071	?0 is not a schema as declaration
=ENDDOC
=DOC
val Ûmk_ZdeclÝ : TERM list -> TERM;
val Ûis_ZdeclÝ : TERM -> bool;
val Ûdest_ZdeclÝ : TERM -> TERM list;
=DESCRIBE
Makes the declaration part of a schema text.  Its arguments must be made using $mk\_Zdec$ or $mk\_Zdecsexp$.
=GFT Definition
mk_Zdecl [t1,...,tn] = t1;...;tn
=TEX
=FAILURE
47080	?0 is not a declaration
3012	?0 and ?1 do not have the same types
3017	An empty list argument is not allowed
=ENDDOC
\subsection{Terms}
=DOC
val Ûmk_ZlvarÝ : string * TYPE * TERM list -> TERM;
val Ûis_ZlvarÝ : TERM -> bool;
val Ûdest_ZlvarÝ : TERM -> string * TYPE * TERM list;
=DESCRIBE
The constructor for local variables.
If the third argument is the empty list, this function is the same as the HOL $mk\_var$ function, otherwise a generic variable is created, the third argument being the generic actual parameters. 
=FAILURE
47090	?0 is not a local variable
=ENDDOC
=DOC
val Ûmk_ZgvarÝ : string * TYPE * TERM list -> TERM;
val Ûis_ZgvarÝ : TERM -> bool;
val Ûdest_ZgvarÝ : TERM -> string * TYPE * TERM list;
=DESCRIBE
The constructor for global variables.
If the third argument is the empty list, this function is the same as the HOL $mk\_const$ function, otherwise a generic constant is created, the third argument being the generic actual parameters. 
=FAILURE
47100	?0 is not a global variable
=ENDDOC
=DOC
val Ûmk_ZintÝ : string -> TERM;
val Ûis_ZintÝ : TERM -> bool;
val Ûdest_ZintÝ : TERM -> string;
=DESCRIBE
The constructor for integer literals.
The argument should be a numeral, the result is the corresponding positive integer.
=FAILURE
47105	?0 is not an integer
=ENDDOC
=DOC
val Ûmk_Z§¢Ý : TYPE * TERM list -> TERM;
val Ûis_Z§¢Ý : TERM -> bool;
val Ûdest_Z§¢Ý : TERM -> TYPE * TERM list;
=DESCRIBE
The constructor for finite sequences.
The result is the sequence made from the terms in the second argument, each of whose types must be the same as the first argument.
=GFT Definition
mk_Z§¢(ty,[t1,...,tn]) = §t1,...,tn¢
=TEX
Where the $t_i$ all have type $ty$.
=FAILURE
47110	?0 is not a sequence display
=ENDDOC
=DOC
val Ûmk_ZsetdÝ : TYPE * TERM list -> TERM;
val Ûis_ZsetdÝ : TERM -> bool;
val Ûdest_ZsetdÝ : TERM -> TYPE * TERM list;
=DESCRIBE
The constructor for finite set displays.
The result is the set made from the terms in the second argument, each of whose types must be the same as the first argument.
=GFT Definition
mk_Zsetd(ty,[t1,...,tn]) = {t1,...,tn}
=TEX
Where the $t_i$ all have type $ty$.
=FAILURE
47120	?0 is not a set display
=ENDDOC
=DOC
val Ûmk_ZsetaÝ : TERM * TERM * TERM -> TERM;
val Ûis_ZsetaÝ : TERM -> bool;
val Ûdest_ZsetaÝ : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for set comprehension.
The three arguments represent the declaration, predicate and body parts of the set comprehension and so must have the appropriate types.
In particular, the first argument must be made using $mk\_Zdecl$.
=GFT Definition
mk_Zseta(d,p,v) = {d | p · v}
=TEX
=FAILURE
47130	?0 is not a set comprehension
=ENDDOC
=DOC
val Ûmk_ZðÝ : TERM -> TERM;
val Ûis_ZðÝ : TERM -> bool;
val Ûdest_ZðÝ : TERM -> TERM;
=DESCRIBE
The powerset constructor.
=GFT Definition
mk_Zð t = ð t
=TEX
=FAILURE
47140	?0 is not a powerset
=ENDDOC
=DOC
val Ûmk_ZtupleÝ : TERM list -> TERM;
val Ûis_ZtupleÝ : TERM -> bool;
val Ûdest_ZtupleÝ : TERM -> TERM list;
=DESCRIBE
The tuple constructor.
=GFT Definition
mk_Ztuple [t1,...,tn] = (t1,...,tn)
=TEX
=FAILURE
47150	?0 is not a tuple
=ENDDOC
=DOC
val Ûmk_Z¸Ý : TERM list -> TERM;
val Ûis_Z¸Ý : TERM -> bool;
val Ûdest_Z¸Ý : TERM -> TERM list;
=DESCRIBE
The cartesian product constructor.
=GFT Definition
mk_Z¸ [t1,...,tn] = (t1 ¸ ... ¸ tn)
=TEX
=FAILURE
47160	?0 is not a cartesian product
=ENDDOC
=DOC
val Ûmk_ZÊÝ : TERM * string -> TERM;
val Ûis_ZÊÝ : TERM -> bool;
val Ûdest_ZÊÝ : TERM -> TERM * string;
=DESCRIBE
The theta term constructor.
The first argument must be a schema, the second is an optional decoration.
=GFT Definition
mk_ZÊ(S,"'") = ÊS'
=TEX
=FAILURE
47170	?0 is not a theta term
=ENDDOC
=DOC
val Ûmk_ZselÝ : TERM * string -> TERM;
val Ûis_ZselÝ : TERM -> bool;
val Ûdest_ZselÝ : TERM -> TERM * string;
=DESCRIBE
Selection of a component from a binding.
The type of the first argument must be a binding and the second argument must be a component of that type.
=GFT Definition
mk_Zsel(S,"c") = S.c
=TEX
=FAILURE
47180	?0 is not a selection
=ENDDOC
=DOC
val Ûmk_ZappÝ : TERM * TERM -> TERM;
val Ûis_ZappÝ : TERM -> bool;
val Ûdest_ZappÝ : TERM -> TERM * TERM;
=DESCRIBE
Z function application.
The first argument must be a set of pairs, the second must have the same type as the first elements of the pairs.
=GFT Definition
mk_Zapp(f,a) = (f a)
=TEX
=FAILURE
47190	?0 is not a function application
=ENDDOC
=DOC
val Ûmk_ZÌÝ : TERM * TERM * TERM -> TERM;
val Ûis_ZÌÝ : TERM -> bool;
val Ûdest_ZÌÝ : TERM -> TERM * TERM * TERM;
=DESCRIBE
The lambda constructor.
The arguments are a declaration (constructed using $mk\_Zdecl$ q.v.), a predicate and the body of the abstraction.
=GFT Definition
mk_ZÌ(d,p,v) = Ìd|p·v
=TEX
=FAILURE
47200	?0 is not a lambda abstraction
47201	?0, ?1 and ?2 are inconsistent.
=ENDDOC
=DOC
val Ûmk_ZÍÝ : TERM * TERM * TERM -> TERM;
val Ûis_ZÍÝ : TERM -> bool;
val Ûdest_ZÍÝ : TERM -> TERM * TERM * TERM;
=DESCRIBE
The definite description constructor.
The arguments are a declaration (constructed using $mk\_Zdecl$ q.v.), a predicate and the body of the definite description.
=GFT Definition
mk_ZÍ(d,p,v) = Íd|p·v
=TEX
=FAILURE
47210	?0 is not a mu term
=ENDDOC
\subsection{Predicates}
=DOC
val Ûmk_ZeqÝ : TERM * TERM -> TERM;
val Ûis_ZeqÝ : TERM -> bool;
val Ûdest_ZeqÝ : TERM -> TERM * TERM;
=DESCRIBE
Equality.
For the moment this is the same as HOL equality, but this is likely to change in the future.
Both arguments must be of the same type.
=GFT Definition
mk_Zeq(a,b) = (a = b)
=TEX
=FAILURE
3012	?0 and ?1 do not have the same types
47220	?0 is not an equality
=ENDDOC
=DOC
val Ûmk_ZÝ : TERM * TERM -> TERM;
val Ûis_ZÝ : TERM -> bool;
val Ûdest_ZÝ : TERM -> TERM * TERM;
=DESCRIBE
Set membership.
The second argument must be a set, whose members have the same type as the first argument.
=GFT Definition
mk_Z(a,b) = (a  b)
=TEX
=FAILURE
47230	?0 is not a set membership
=ENDDOC
=DOC
val Ûmk_ZtrueÝ : TERM;
val Ûis_ZtrueÝ : TERM -> bool;
=DESCRIBE
The Z constant $true$.
It is the same as the HOL constant $T$.
=ENDDOC
=DOC
val Ûmk_ZfalseÝ : TERM;
val Ûis_ZfalseÝ : TERM -> bool;
=DESCRIBE
The Z constant $false$.
It is the same as the HOL constant $F$.
=ENDDOC
=DOC
val Ûmk_Z³Ý : TERM -> TERM;
val Ûis_Z³Ý : TERM -> bool;
val Ûdest_Z³Ý : TERM -> TERM;
=FAILURE
3031	?0 is not of type ¬:BOOL®
47240	?0 is not a negation
=DESCRIBE
Negation; the same as HOL $³$.
Its argument must be $bool$ type.
=ENDDOC
=DOC
val Ûmk_Z±Ý : TERM * TERM -> TERM;
val Ûis_Z±Ý : TERM -> bool;
val Ûdest_Z±Ý : TERM -> TERM * TERM;
=DESCRIBE
Conjunction; the same as HOL $±$.
Its arguments must be $bool$ type.
=FAILURE
3015	?1 is not of type ¬:BOOL®
3031	?0 is not of type ¬:BOOL®
47250	?0 is not a conjunction
=ENDDOC
=DOC
val Ûmk_Z²Ý : TERM * TERM -> TERM;
val Ûis_Z²Ý : TERM -> bool;
val Ûdest_Z²Ý : TERM -> TERM * TERM;
=DESCRIBE
Disjunction; the same as HOL $²$.
Its arguments must be $bool$ type.
=FAILURE
3015	?1 is not of type ¬:BOOL®
3031	?0 is not of type ¬:BOOL®
47260	?0 is not a disjunction
=ENDDOC
=DOC
val Ûmk_Z´Ý : TERM * TERM -> TERM;
val Ûis_Z´Ý : TERM -> bool;
val Ûdest_Z´Ý : TERM -> TERM * TERM;
=DESCRIBE
Implication; the same as HOL $´$.
Its arguments must be $bool$ type.
=FAILURE
3015	?1 is not of type ¬:BOOL®
3031	?0 is not of type ¬:BOOL®
47270	?0 is not an implication
=ENDDOC
=DOC
val Ûmk_Z¤Ý : TERM * TERM -> TERM;
val Ûis_Z¤Ý : TERM -> bool;
val Ûdest_Z¤Ý : TERM -> TERM * TERM;
=DESCRIBE
If and only if; the same as HOL $¤$.
Its argument must be $bool$ type.
=FAILURE
3015	?1 is not of type ¬:BOOL®
3031	?0 is not of type ¬:BOOL®
47280	?0 is not if and only if
=ENDDOC
=DOC
val Ûmk_Z¶Ý : TERM * TERM * TERM -> TERM;
val Ûis_Z¶Ý : TERM -> bool;
val Ûdest_Z¶Ý : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for existential quantification.
Its arguments must be a declaration (constructed with $mk\_Zdecl$) and two predicates.
=GFT Definition
mk_Z¶(d,p,v) = ¶d|p·v
=TEX
=FAILURE
47080	?0 is not a declaration
47290	?0 is not an existential quantification
=ENDDOC
=DOC
val Ûmk_Z¶%down%1Ý : TERM * TERM * TERM -> TERM;
val Ûis_Z¶%down%1Ý : TERM -> bool;
val Ûdest_Z¶%down%1Ý : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for unique existential quantification.
Its arguments must be a declaration (constructed with $mk\_Zdecl$) and two predicates.
=GFT Definition
mk_Z¶%down%1(d,p,v) = ¶%down%1 d|p·v
=TEX
=FAILURE
47080	?0 is not a declaration
47300	?0 is not a unique existential quantification
=ENDDOC
=DOC
val Ûmk_ZµÝ : TERM * TERM * TERM -> TERM;
val Ûis_ZµÝ : TERM -> bool;
val Ûdest_ZµÝ : TERM -> TERM * TERM * TERM;
=DESCRIBE
The constructor for universal quantification.
Its arguments must be a declaration (constructed with $mk\_Zdecl$) and two predicates.
=GFT Definition
mk_Zµ(d,p,v) = µd|p·v
=TEX
=FAILURE
47080	?0 is not a declaration
47310	?0 is not a universal quantification
=ENDDOC
=DOC
val Ûmk_ZpredsexpÝ : TERM * string -> TERM;
val Ûis_ZpredsexpÝ : TERM -> bool;
val Ûdest_ZpredsexpÝ : TERM -> TERM * string;
=DESCRIBE
The schema as predicate constructor.
The first argument must be a schema, the second is an optional decoration.
=FAILURE
47070	?0 is not a schema
47320	?0 is not a schema as predicate expression
=ENDDOC
\subsection{Schema Calculus}
=DOC
val Ûmk_Z%down%sÝ : TERM * TERM -> TERM;
val Ûis_Z%down%sÝ : TERM -> bool;
val Ûdest_Z%down%sÝ : TERM -> TERM * TERM;
=DESCRIBE
The schema constructor.
The first argument is a declaration constructed using $mk\_Zdecl$, the second is a predicate.
=GFT Definition
mk_Z%down%s(d,p) = [d | p]
=TEX
=FAILURE
47070	?0 is not a schema
=ENDDOC
=DOC
val Ûmk_Zdec%down%sÝ : TERM * string -> TERM;
val Ûis_Zdec%down%sÝ : TERM -> bool;
val Ûdest_Zdec%down%sÝ : TERM -> TERM * string;
=DESCRIBE
The constructor for systematic decoration of schemas.
The first argument must be a schema, the second a decoration.
=GFT Example
mk_Zdec%down%s([a,b,c:X | a = b],"'") = [a',b',c':X | a' = b']
=TEX
=FAILURE
47340	?0 is not a decorated schema
=ENDDOC
=DOC
val Ûmk_Zpre%down%sÝ : TERM -> TERM;
val Ûis_Zpre%down%sÝ : TERM -> bool;
val Ûdest_Zpre%down%sÝ : TERM -> TERM;
=DESCRIBE
The schema precondition constructor.
The argument must be a schema.
=GFT Definition
mk_Zpre%down%s S = pre S
=TEX
=FAILURE
47350	?0 is not a schema precondition
=ENDDOC
=DOC
val Ûmk_Z³%down%sÝ : TERM -> TERM;
val Ûis_Z³%down%sÝ : TERM -> bool;
val Ûdest_Z³%down%sÝ : TERM -> TERM;
=DESCRIBE
The schema negation constructor.
The argument must be a schema.
=GFT Definition
mk_Z³%down%s S = ³S
=TEX
=FAILURE
47360	?0 is not a schema negation
=ENDDOC
=DOC
val Ûmk_Z±%down%sÝ : TERM * TERM -> TERM;
val Ûis_Z±%down%sÝ : TERM -> bool;
val Ûdest_Z±%down%sÝ : TERM -> TERM * TERM;
=DESCRIBE
The schema conjunction constructor.
Both arguments must be schemas.
=GFT Definition
mk_Z±%down%s(R,S) = R ± S
=TEX
=FAILURE
47370	?0 is not a schema conjunction
=ENDDOC
=DOC
val Ûmk_Z²%down%sÝ : TERM * TERM -> TERM;
val Ûis_Z²%down%sÝ : TERM -> bool;
val Ûdest_Z²%down%sÝ : TERM -> TERM * TERM;
=DESCRIBE
The schema disjunction constructor.
Both arguments must be schemas.
=GFT Definition
mk_Z²%down%s(R,S) = R ² S
=TEX
=FAILURE
47380	?0 is not a schema disjunction
=ENDDOC
=DOC
val Ûmk_Z´%down%sÝ : TERM * TERM -> TERM;
val Ûis_Z´%down%sÝ : TERM -> bool;
val Ûdest_Z´%down%sÝ : TERM -> TERM * TERM;
=DESCRIBE
The schema implication constructor.
Both arguments must be schemas.
=GFT Definition
mk_Z´%down%s(R,S) = R ´ S
=TEX
=FAILURE
47390	?0 is not a schema implication
=ENDDOC
=DOC
val Ûmk_Z¤%down%sÝ : TERM * TERM -> TERM;
val Ûis_Z¤%down%sÝ : TERM -> bool;
val Ûdest_Z¤%down%sÝ : TERM -> TERM * TERM;
=DESCRIBE
The schema equivalence constructor.
Both arguments must be schemas.
=GFT Definition
mk_Z¤%down%s(R,S) = R ¤ S
=TEX
=FAILURE
47400	?0 is not a schema if and only if
=ENDDOC
=DOC
val Ûmk_Zù%down%sÝ : TERM * TERM -> TERM;
val Ûis_Zù%down%sÝ : TERM -> bool;
val Ûdest_Zù%down%sÝ : TERM -> TERM * TERM;
=DESCRIBE
The schema projection constructor.
Both arguments must be schemas.
=GFT Definition
mk_Zù%down%s(R,S) = R ù S
=TEX
=FAILURE
47410	?0 is not schema projection
=ENDDOC
=DOC
val Ûmk_Zhide%down%sÝ : TERM * string list -> TERM;
val Ûis_Zhide%down%sÝ : TERM -> bool;
val Ûdest_Zhide%down%sÝ : TERM -> TERM * string list;
=DESCRIBE
The schema hiding constructor.
The first argument must be a schema, the second is a list of components to be hidden.
=GFT Definition
mk_Zhide%down%s(S,[c1,...cn]) = S \ (c1,...,cn)
=TEX
=FAILURE
47420	?0 is not schema hiding
=ENDDOC
=DOC
val Ûmk_Z¶%down%sÝ : TERM * TERM * TERM -> TERM;
val Ûis_Z¶%down%sÝ : TERM -> bool;
val Ûdest_Z¶%down%sÝ : TERM -> TERM * TERM * TERM;
=DESCRIBE
The schema existential quantifier constructor.
The arguments must be a declaration (constructed using $mk\_Zdecl$), a predicate and a schema.
=GFT Definition
mk_Z¶%down%s(d,p,S) = ¶d | p · S
=TEX
=FAILURE
47430	?0 is not schema existential
=ENDDOC
=DOC
val Ûmk_Z¶%down%1%down%sÝ : TERM * TERM * TERM -> TERM;
val Ûis_Z¶%down%1%down%sÝ : TERM -> bool;
val Ûdest_Z¶%down%1%down%sÝ : TERM -> TERM * TERM * TERM;
=DESCRIBE
The schema unique existential quantifier constructor.
The arguments must be a declaration (constructed using $mk\_Zdecl$), a predicate and a schema.
=GFT Definition
mk_Z¶%down%1%down%s(d,p,S) = ¶%down%1 d | p · S
=TEX
=FAILURE
47440	?0 is not schema unique existential
=ENDDOC
=DOC
val Ûmk_Zµ%down%sÝ : TERM * TERM * TERM -> TERM;
val Ûis_Zµ%down%sÝ : TERM -> bool;
val Ûdest_Zµ%down%sÝ : TERM -> TERM * TERM * TERM;
=DESCRIBE
The schema universal quantifier constructor.
The arguments must be a declaration (constructed using $mk\_Zdecl$), a predicate and a schema.
=GFT Definition
mk_Zµ%down%s(d,p,S) = µd | p · S
=TEX
=FAILURE
47450	?0 is not schema universal
=ENDDOC
=DOC
val Ûmk_Z„%down%sÝ : TERM -> TERM;
val Ûis_Z„%down%sÝ : TERM -> bool;
val Ûdest_Z„%down%sÝ : TERM -> TERM;
=DESCRIBE
The delta constructor.
Its argument must be a schema.
=GFT Definition
mk_Z„%down%s S = „S
=TEX
=FAILURE
47460	?0 is not delta
=ENDDOC
=DOC
val Ûmk_Z˜%down%sÝ : TERM -> TERM;
val Ûis_Z˜%down%sÝ : TERM -> bool;
val Ûdest_Z˜%down%sÝ : TERM -> TERM;
=DESCRIBE
The xi constructor.
Its argument must be a schema.
=GFT Definition
mk_Z˜%down%s S = ˜S
=TEX
=FAILURE
47470	?0 is not xi
=ENDDOC
=DOC
val Ûmk_Z»%down%sÝ : TERM * TERM -> TERM;
val Ûis_Z»%down%sÝ : TERM -> bool;
val Ûdest_Z»%down%sÝ : TERM -> TERM * TERM;
=DESCRIBE
The sequential composition constructor.
Its arguments must both be schemas.
=GFT Definition
mk_Z»%down%s(R,S) = R » S
=TEX
=FAILURE
47480	?0 is not a schema composition
=ENDDOC
\section{GENERAL MAPPING FUNCTIONS}
These functions map HOL types and terms which represent valid Z types and terms to and from the intermediate datatypes $ZTYPE$ and $ZTERM$ q.v.
=DOC
val mk_ZTYPE : ZTYPE -> TYPE;
=DESCRIBE
Given any $ZTYPE$, $mk\_ZTYPE$ calls the appropriate abstract machine $mk\_$ function.
=ENDDOC
=DOC
val is_ZTYPE : TYPE -> bool;
=DESCRIBE
Tests if a given HOL type represents a valid Z type.
=USES
Recursively in well-formedness checks.
=ENDDOC
=DOC
val dest_ZTYPE : TYPE -> ZTYPE;
=DESCRIBE
Converts a HOL type, which represents a valid Z type, to the appropriate ZTYPE.
=USES
Recursively in the pretty printer.
=FAILURE
47800	?0 does not represent a Z type.
=ENDDOC
=DOC
val mk_ZTERM : ZTERM -> TERM;
=DESCRIBE
Given any $ZTERM$, $mk\_ZTERM$ calls the appropriate abstract machine $mk\_$ function.
=ENDDOC
=DOC
val is_ZTERM : TERM -> bool;
=DESCRIBE
Tests if a given HOL term is valid Z.
=USES
Recursively in well-formedness checks.
=ENDDOC
=DOC
val dest_ZTERM : TERM -> ZTERM;
=DESCRIBE
Converts a HOL term, which represents a valid Z term, to the appropriate ZTERM.
=USES
Recursively in the pretty printer.
=FAILURE
47900	?0 does not represent a Z term.
47901	?0 is not a valid package.
47910	?0 is not a valid simple declaration.
47911	?0 is not a valid schema declaration.
47912	?0 is not a valid declaration.
47920	?0 is not a valid existential quantification.
47921	?0 is not a valid unique existential quantification.
47922	?0 is not a valid universal quantification.
47923	?0 is not a valid schema as predicate.
47930	?0 is not a valid sequence display.
47931	?0 is not a valid set display.
47932	?0 is not a valid set comprehension.
47933	?0 is not a valid theta term.
47934	?0 is not a valid function application.
47935	?0 is not a valid lambda abstraction.
47936	?0 is not a valid definite description.
47940	?0 is not a valid schema.
47941	?0 is not a valid schema existential quantification.
47942	?0 is not a valid schema unique existential quantification.
47943	?0 is not a valid schema universal quantification.
=ENDDOC
\section{END OF SIGNATURE}
=SML
end (* end of ZTypesAndTerms signature *);
=TEX
\section{HOL REPRESENTATIONS OF Z TYPES AND TERMS}
\subsection{Types}
\subsubsection{Given Types}
A Z given type is represented in HOL as a 0-ary type of the same name.
=GFT Definition
mk_ZgivenT str = ()str
=TEX
\subsubsection{Generic Types}
The types of Z generic variables are represented as HOL type variables of the same name.
=GFT Definition
mk_vartT str = *str
=TEX
\subsubsection{Set Types}
A Z set type is represented by the unary HOL type ð.
=GFT Definition
mk_ZpowerT ty = (ty)ð
=TEX
\subsubsection{Tuple Types}
A Z tuple type is represented by the corresponding HOL tuple type.
=GFT Definition
mk_ZtupleT [ty1,...,tyk] = (ty1,...,tyk)Tn
=TEX
\subsubsection{Schema Types}
The type of a Z binding is represented in HOL as an n-ary type constructor, whose name is derived from the components of the binding.
=GFT Definition
mk_ZschemaT [("c1",ty1),...,("ck",tyk)] = (ty1,...,tyk)S_[c1,...,ck]
=TEX
Note that bindings which differ only in the order of their components map to identical types.
\subsection{Terms}
\section{Temporary Error Message}
=DOC
=FAILURE
47999	Not yet implemented
=ENDDOC
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


