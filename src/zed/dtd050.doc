% @(#) @(#)dtd050.doc	1.15 8/10/92 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Z Constant Generation}
\TPPref{DS/FMU/IED/DTD050}  %% Mandatory field
\def\SCCSversion{1.15 %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{92/08/10 %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
\TPPauthors{G.M.Prout&WIN01\\D.J.King&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the detailed design of the definition of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First draft versions.
\item [Issue 1.4]
$get\_mode$ and $set\_mode$ replaced by a boolean flag.
\item [Issue 1.5]Changed to new fonts.
\item [Issue 1.9 (20th July 1992)]
Added schema renaming definition mechanism.
Replaces uses of $\% down\%$.
\item [Issue \SCCSversion~(\FormatDate{92/08/10%
}] Added support for binding display.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The design is
implemented in \cite{DS/FMU/IED/IMP050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
In the Z Proof Support Subsystem, two types of constants have been identified:
\begin{enumerate}
\item
 Constants defined as primitive  in the system, see \cite{DS/FMU/IED/DTD052}.
\item 
Constants that belong to infinite families and thus cannot be defined as primitive. 
\end{enumerate}
This document gives the detailed design for the generation of constants of type (2). 
These constants are defined dynamically on initial introduction. The mechanism employed for storing the Z constants
will depend on whether or not 
defining theorems are to be stored for these constants. 
This choice will be controlled
by a boolean flag $defining\_theorem$.

The mechanism employed for
storing defining theorems for the generated types  will be a 
call to $labelled\_product\_spec$ of \cite{DS/FMU/IED/DTD059} and for storing defining theorems for the 
generated constants will be 
a call to $const\_spec$ of \cite{DS/FMU/IED/DTD012}.

A detailed discussion of data storage of dynamically generated constants may be found in \cite{DS/FMU/IED/HLD017}.
Defining theorems be stored in a theory $z\_language$ at the top of the zed hierarchy.

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
=IGN
\subsubsection{Deficiencies}

\section{Z CONSTANT DEFINITION GENERATION}\label{ZCONST}
Z constants that belong to infinite families are defined dynamically on initial introduction. 

The first time generated semantic constant is encountered
its definition, and those of any associated types,
will be dynamically generated and stored.


For each abstract machine interface for creating HOL terms representing the Z abstract syntax,
which is not an individual semantic constant (as defined in \cite{DS/FMU/IED/DTD052}), there
is an interface to the semantic constant generator. These are introduced below.

A sample definition is given for each of the Z constants that are dynamically generated in the specification of
the mapping in \cite{DS/FMU/IED/ZED002}.

\section{THE SIGNATURE}
=DOC
signature ÛZGeneratedConstantsÝ = sig
=DESCRIBE
The functions which define the dynamically generated Z semantic constants are packaged into this signature.
=FAILURE
50001	Argument to constant generator function is inappropriate 
50002	Empty declarations are not supported in this version
50003	Design Error in generated semantic constant module (?0)
=ENDDOC

\section{NUMERICALLY INDEXED FAMILIES}
=DOC
val Ûget_binding_infoÝ : TYPE -> TERM * TERM list;
val Ûget_tuple_infoÝ : TYPE -> TERM * TERM list;
=DESCRIBE
=ENDDOC
\section{NUMERICALLY INDEXED FAMILIES}
=DOC
val Ûtuple_gen_semantic_constÝ : TERM -> THM;
val Ûseta_gen_semantic_constÝ : TERM -> THM;
val ÛÌ_gen_semantic_constÝ : TERM -> THM;
val Û¸_gen_semantic_constÝ : TERM -> THM;
val ÛÍ_gen_semantic_constÝ : TERM -> THM;
val Ûbinding_gen_semantic_constÝ : TERM -> THM;
val Û¶‰1_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\section{COMPONENT INDEXED FAMILIES I}

=DOC
val Ûschema_gen_semantic_constÝ : TERM -> THM;
val Ûpre‰s_gen_semantic_constÝ : TERM -> THM;
val Û„‰s_gen_semantic_constÝ : TERM -> THM;
val Û˜‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\section{COMPONENT INDEXED FAMILIES II}

=DOC
val Ûdec‰s_gen_semantic_constÝ : TERM -> THM;
val Ûdyop‰s_gen_semantic_constÝ : TERM -> THM;
val Ûù‰s_gen_semantic_constÝ : TERM -> THM;
val Ûhide‰s_gen_semantic_constÝ : TERM -> THM;
val Ûquant‰s_gen_semantic_constÝ : TERM -> THM;
val Û»‰s_gen_semantic_constÝ : TERM -> THM;
val Ûrename‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\section{EPILOGUE}
=SML
end (* of signature ZGeneratedConstants *);
=TEX

\section{CONST\_SPEC VERSUS SIMPLE\_NEW\_DEFINITION}

\subsection{Aim}
The aim of these experiments is to assess the relative merits of
using $const\_spec$ to introduce defining theorems for semantic constants, thus
increasing flexibility in the way that these theorems can be expressed, or using
$simple\_new\_definition$ which only permits definitions expressed as equations,
but performs faster than $const\_spec$.

\subsection{Method}

For the input, a definition of the form ¬f x = a® where ¬a® contains an occurrence of ¬x®,
is made using $const\_spec$. This is repeated several times, each definition varying
in the type of ¬x®. The total cpu time used, and the elapsed time are recorded
for these definitions.

The experiment is then repeated but the definitions of ¬f®
each take the form ¬Ì x · a®
where ¬a® contains an occurrence of ¬x®, and calling $simple\_new\_definition$.
The cpu and elapsed times for this are recorded and compared against those for
$const\_spec$.

\subsection{Input Data}


=GFT
push_pc "basic_hol";

open_theory"z_language";
delete_theory"performance" handle _ => ();
new_theory"performance";
=TEX
The input data is based upon the first 10 semantic constants for set abstraction.
The following constitutes the input data for calls to $simple\_new\_defn$. 
=GFT SML Input
val def1_1 = ¬(Ì pack · {x |¶ a1
	· $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x})®;
val def1_2 = ¬(Ì pack · {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x})®;
val def1_3 = ¬(Ì pack · {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x})®;
val def1_4 = ¬(Ì pack · {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x})®;
val def1_5 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x})®;
val def1_6 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x})®;
val def1_7 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x})®;
val def1_8 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x})®;
val def1_9 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x})®;
val def1_10 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x})®;


val x1 = (["seta1"],"seta1",def1_1);
val x2 = (["seta2"],"seta2",def1_2);
val x3 = (["seta3"],"seta3",def1_3);
val x4 = (["seta4"],"seta4",def1_4);
val x5 = (["seta5"],"seta5",def1_5);
val x6 = (["seta6"],"seta6",def1_6);
val x7 = (["seta7"],"seta7",def1_7);
val x8 = (["seta8"],"seta8",def1_8);
val x9 = (["seta9"],"seta9",def1_9);
val x10 = (["seta10"],"seta10",def1_10);
=TEX
The following constitutes the input data for calls to $const\_spec$. 
=GFT SML Input
val cs1_1 = ¬µ pack · seta1' pack = {x |¶ a1 · $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x}®;
val cs1_2 = ¬µ pack · seta2' pack = {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x}®;
val cs1_3 = ¬µ pack · seta3' pack = {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x}®;
val cs1_4 = ¬µ pack · seta4' pack = {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x}®;
val cs1_5 = ¬µ pack · seta5' pack = {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x}®;
val cs1_6 = ¬µ pack · seta6' pack = {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x}®;
val cs1_7 = ¬µ pack · seta7' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x}®;
val cs1_8 = ¬µ pack · seta8' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x}®;
val cs1_9 = ¬µ pack · seta9' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x}®;
val cs1_10 = ¬µ pack · seta10' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x}®;

val y1 = (["seta1'"], frees cs1_1, cs1_1);
val y2 = (["seta2'"], frees cs1_2, cs1_2);
val y3 = (["seta3'"], frees cs1_3, cs1_3);
val y4 = (["seta4'"], frees cs1_4, cs1_4);
val y5 = (["seta5'"], frees cs1_5, cs1_5);
val y6 = (["seta6'"], frees cs1_6, cs1_6);
val y7 = (["seta7'"], frees cs1_7, cs1_7);
val y8 = (["seta8'"], frees cs1_8, cs1_8);
val y9 = (["seta9'"], frees cs1_9, cs1_9);
val y10 = (["seta10'"], frees cs1_10, cs1_10);
=TEX

The following Standard ML code maps the appropriate functions over the
test data and returns the results.

=GFT SML Input
"simple_new_defn ...";
PolyML.timing true;
val _ = map simple_new_defn [x1, x2, x3, x4, x5, x6, x7, x8, x9, x10];
PolyML.timing false;
"Const_spec ...";
PolyML.timing true;
val _ = map const_spec [y1, y2, y3, y4, y5, y6, y7, y8, y9, y10];
PolyML.timing false;
=TEX


\subsection{Results}


The results recorded for a Sun 3/60 (12Mb) are as follows:

\begin{tabular}{|l|l|}\hline
&elapsed time (s)\\\hline
simple\_new\_defn&12.1\\
&13.1 \\
&12.2 \\
&\\\hline
const\_spec&376.9 \\
&371.1 \\
\hline
\end{tabular}

=TEX
\subsection{Conclusion}

The results for $const\_spec$ are comparatively poor.
Due to the strong requirement for loose definitions
for some of the generated semantic constants, it is
recommended that improvements be made to $const\_spec$
to permit its use in the generated semantic constants
module.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}



