% dtd050.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Z Constant Generation}
\TPPref{DS/FMU/IED/DTD050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
%\TPPauthors{G.T.Scullard&WIN01\\G.M.Prout&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the detailed design of the definition of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First draft versions.
\item [Issue 1.4] (\TPPdate{\FormatDate{$Date$
}})
$get\_mode$ and $set\_mode$ replaced by a boolean flag.
\item [Issue 1.5] (\TPPdate{\FormatDate{$Date$
}})
Changed to new fonts.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The design is
implemented in \cite{DS/FMU/IED/IMP050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
In the Z Proof Support Subsystem, two types of constants have been identified:
\begin{enumerate}
\item
 Constants defined as primitive  in the system, see \cite{DS/FMU/IED/DTD052}.
\item 
Constants that belong to infinite families and thus cannot be defined as primitive. 
\end{enumerate}
This document gives the detailed design for the generation of constants of type (2). 
These constants are defined dynamically on initial introduction. The mechanism employed for storing the Z constants
will depend on whether or not 
defining theorems are to be stored for these constants. 
This choice will be controlled
by a boolean flag $defining\_theorem$.

If $defining\_theorem$ is false, the Z constants and any required associated types will be stored  using $new\_type$ and $new\_const$
 of  \cite{DS/FMU/IED/DTD012}.

If $defining\_theorem$ is true, definitions for the Z 
constants and any required associated types will be stored.
 The mechanism employed for
storing defining theorems for the generated types  will be a 
call to $labelled\_product\_spec$ of \cite{DS/FMU/IED/DTD059} and for storing defining theorems for the 
generated constants will be 
a call to $const\_spec$ of \cite{DS/FMU/IED/DTD012}.


A detailed discussion of data storage of dynamically generated constants may be found in \cite{DS/FMU/IED/HLD017}, although at this stage
the issue of where to store dynamically generated Z 
constants has not been resolved. It is anticipated that
 defining theorems be stored in a theory (Z?) at the top of the user hierarchy, and constants and types without defining theorems
be stored temporarily in the user's current theory.

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
=IGN
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=TEX
\section{SIGNATURE}
=DOC
signature ÛZGeneratedConstantsÝ = sig
=DESCRIBE
The functions which define the dynamically generated Z semantic constants are packaged into this signature.
=ENDDOC
\subsection{Storing Z Constants}

\subsection{Binding Types}
=DOC
val Ûbinding_type_specÝ : TYPE -> unit;
val Ûget_binding_infoÝ : TYPE -> TERM * TERM list;

=DESCRIBE
For each finite set of identifiers a polymorphic type constructor is required 
which is the type of bindings which bind values to just the identifiers in the set. 
Each of these type constructors has a unique name formed by
 appending to the 
prefix ``$Z'mk\_S$'' the alphabetically ordered list of identifiers. 
The function  $binding\_type\_spec$ first checks for the existence of the binding type. If the type does not exist, if $defining\_theorem$ is true, then its definition 
is generated  along with the polymorphic definitions of the
 binding constructor and the 
binding projections. If $defining\_theorem$ is false, then
the binding type and its constructor and projections will be
put in place  by $new\_type$ and $new\_const$.

The function $get\_binding\_info$ returns
 the polymorphic  names of the binding constructor  and 
list of binding projections if they exist; it fails otherwise.
 
An example of a binding type is $('a, 'b)Z'S[a,b]$. The application of $binding\_type\_spec$ determines whether or not the type 
$Z'S[a,b]$ already exists. If not, the type $Z'S[a,b]$ and  the polymorphic constants $Z'mk\_S[a,b]$ (the binding constructor)
 $Z'S[a,b]a$ and $Z'S[a,b]b$ (the binding  projections)
are generated.
The application of $get\_binding\_info$ 
to the binding type $('a, 'b)Z'S[a,b]$ yields the  binding constructor $Z'mk\_S[a,b]$ 
and list of binding  projections 
$[Z'S[a,b]a, Z'S[a,b]b]$. If $defining\_theorem$ is true,
 the type definition generated would be:
=GFT
ô ¶ f:('a, 'b)Z'S[a,b] ­ 'a ¸ 'b · TypeDefn (Ìx:'a ¸ 'b · T)f
=TEX

and the definition of the binding constructor  and binding projections would be:
=GFT HOL Constant
Z'mk_S[a,b]: 'a ­ 'b ­ ('a,'b)Z'S[a,b]
Z'S[a,b]a:('a,'b)Z'S[a,b] ­ 'a
Z'S[a,b]b:('a,'b)Z'S[a,b] ­ 'b
÷
µ t x1 x2·
Z'S[a,b]a (Z'mk_S[a,b] x1 x2) = x1 ± Z'S[a,b]b (Z'mk_S[a,b] x1 x2) = x2
±
Z'mk_S[a,b] (Z'S[a,b]a t) (Z'S[a,b]b t) = t
=TEX
The definition of the binding type would be saved  under the key $Z'S[a,b]$, and the defining theorem
 for
the binding constructor  and binding projections
 under the keys $Z'mk\_S[a,b]$, $Z'S[a,b]a$ and $Z'S[a,b]b$.
The functions $binding\_type\_spec$ and $get\_binding\_info$ are used by all the functions in 
section \ref{ZCONST} which define the Z semantic constants.
=FAILURE
47050	?0 is not a Z binding type
50001	There is no binding type called ?0 
=ENDDOC
 
The function $labelled\_product\_spec$ described in \cite{DS/FMU/IED/DTD059} is called to generate the defining theorems for the binding type and for its associated constants.

\subsection{Tuple Types}
=DOC
val Ûtuple_type_specÝ : TYPE -> unit ;
val Ûget_tuple_infoÝ : TYPE -> TERM ;
=DESCRIBE
Each tuple type constructor has a unique name formed by
 appending the 
prefix ``$Z'mk\_T$'' to a singleton list containing the arity of the tuple. 
The function  $tuple\_type\_spec$ first checks for the existence of the tuple type. If the type does not exist, if $defining\_theorem$ is true, then its definition 
is generated  along with the polymorphic definitions of the
 tuple constructor and the 
tuple projections. If $defining\_theorem$ is false, then
the tuple type and its constructor and projections will be
put in place  by $new\_type$ and $new\_const$.

The function $get\_tuple\_info$ returns
 the polymorphic  names of the tuple constructor  and 
list of tuple projections if they exist; it fails otherwise.
 
An example of a tuple type is $('1, '2, '3)Z'T[3]$. The application of $tuple\_type\_spec$ determines whether or not the type 
$Z'T[3]$ already exists. If not, the type $Z'T[3]$ and  the polymorphic constants $Z'mk\_T[3]$ (the tuple constructor)
$Z'T[3]1$, $Z'T[3]2$ and $Z'T[3]3$ (the tuple  projections)
are generated.
The application of $get\_tuple\_info$ 
to the tuple type $('1, '2, '3)Z'T[3]$ yields the  
tuple constructor $Z'mk\_T[3]$ and list of tuple  projections 
$[Z'T[3]1, Z'T[3]2], Z'T[3]3]$. If $defining\_theorem$ is
 true, the type definition generated would be:
=GFT
ô ¶ f:('1, '2, '3)Z'T[3] ­ '1 ¸ '2 ¸ '3·  TypeDefn (Ìx:'1 ¸ '2 ¸ '3 · T)f
=TEX


and the definition of the tuple constructor and tuple projections  would be:
=GFT HOL Constant
Z'mk_T[3]: '1 ­ '2 ­ '3 ­ ('1,'2,'3)ZT'[3]
Z'T[3]1: ('1,'2,'3)ZT'[3] ­ '1 
Z'T[3]2: ('1,'2,'3)ZT'[3] ­ '2
Z'T[3]3: ('1,'2,'3)ZT'[3] ­ '3 
	
÷
µ t x1 x2 x3·
  Z'T[3]1 (Z'mk_T[3] x1 x2 x3) = x1 
± Z'T[3]2 (Z'mk_T[3] x1 x2 x3) = x2
± Z'T[3]3 (Z'mk_T[3] x1 x2 x3) = x3 
± Z'mk_T[3] (Z'T[3]1 t) (Z'T[3]2 t) (Z'T[3]3 t) = t
=TEX
The definition of the tuple type would be saved 
 under the key $Z'T[3]$, and the defining theorem
for the tuple constructor and tuple projections
 under the keys $Z'mk\_T[3]$, $Z'T[3]1$, $Z'T[3]2$ and
 $Z'T[3]3$.

=FAILURE
47040	?0 is not a Z tuple type
50002	There is no tuple type called ?0 
=ENDDOC
 
The function $labelled\_product\_spec$ described in \cite{DS/FMU/IED/DTD059} is called to generate the defining theorems for the tuple type and for its associated constants.

\subsection{Retrieving Definitions of Constructors and Projections}
=DOC
val Ûget_constructor_defnÝ : TYPE -> THM;
val Ûget_projections_defnÝ : TYPE -> THM list;
=DESCRIBE
These functions  take a binding type (or a tuple type) and return information from the 
appropriate conjunct of the definition of 
the binding constructor (or tuple constructor) and binding projections (or tuple projections). This is achieved by first calling $binding\_type\_spec$ (or $tuple\_type\_spec$), which generates the definition where necessary, and then retrieving that definition. If $defining\_theorem$ were false when the type was introduced, no definitions would have been generated
 and the functions fail.
In the examples given above, the theorems returned for 
the binding constants would be:
=GFT
ô µ t · Z'mk_S[a,b] (Z'S[a,b]a t) (Z'S[a,b]b t) = t
=TEX
and
=GFT
[ô µ x1 x2 · Z'S[a,b]a(Z'mk_S[a,b](x1 x2)) = x1,
ô µ x1 x2 · Z'S[a,b]b(Z'mk_S[a,b](x1 x2)) = x2] 
=TEX
The theorems returned for 
the tuple constants would be:
=GFT
ô µ t · Z'mk_T[3] (Z'T[3]1 t) (Z'T[3]2 t)(Z'T[3]3 t) = t
=TEX
and
=GFT
[ô µ x1 x2 x3 · Z'T[3]1(Z'mk_T[3](x1 x2 x3)) = x1,
ô µ x1 x2  x3· Z'T[3]2(Z'mk_T[3](x1 x2 x3)) = x2,
ô µ x1 x2  x3· Z'T[3]3(Z'mk_T[3](x1 x2 x3)) = x3] 
=TEX

	
=FAILURE
50003	?0 is not a binding type or a tuple type
50004	The binding constructor for ?0 has not been defined
50005	The binding projections for ?0 have not been defined
50006	The tuple constructor for ?0 has not been defined
50007	The tuple projections for ?0 have not been defined
=ENDDOC
	
\section{Z CONSTANT DEFINITION GENERATION}\label{ZCONST}
Z constants that belong to infinite families are defined dynamically on initial introduction. Whether or not they have defining theorems associated with them depends on the boolean flag $defining\_theorem$. If $defining\_theorem$ is false, then the first time such a constant is introduced, it will be stored  as a 
polymorphic constant with no defining theorem. Any undefined associated types will also be stored with no defining theorems.
If the flag
$defining\_theorem$ is true, then the first time such a constant is introduced its definition, and those of any associated types, will be dynamically generated and stored.


For each abstract machine interface for creating HOL terms representing the Z abstract syntax,
which is not an individual semantic constant (as defined in \cite{DS/FMU/IED/DTD052}), there
is an interface to the semantic constant generator. These are introduced below.

A sample definition is given for each of the Z constants that are dynamically generated. In the following, 
$Z'absð$ is the set abstraction function of \cite{DS/FMU/IED/DTD052}.


\subsubsection{Set Comprehension}

=DOC
val Ûseta_const_specÝ : TERM -> THM;

=EXAMPLE
=FAILURE
50100	argument to constant generator function is inappropriate 
=ENDDOC

\subsubsection{Cartesian Product}
=TEX

\subsubsection{Lambda Abstraction}

=TEX
\subsubsection{Definite Description}
\section{END OF SIGNATURE}


=SML
end (* end of ZGeneratedConstants signature *);
=TEX


\subsection{Constants for Schema Calculus}
\subsubsection{Schema Constructor}
=GFT HOL Constant
ÛZ'%down%s[a,b]Ý	: ('a ­ 'b ­ (BOOL,BOOL)Z'S[d,p]) ­ (('a,'b)Z'S[a,b])ð
÷
µp:('a ­ 'b ­ (BOOL,BOOL)Z'S[d,p])·
(Z'%down%s[a,b] p
	=	Z'absð(Ìx:('a,'b)Z'S[a,b]·
			let	t = p  x.a  x.b
			in	t.d  ±  t.p))

=TEX
\subsubsection{Schema Decoration}

=GFT HOL Constant
ÛZ'dec%down%s[a,b,c][!]Ý : ('a,'b,'c) Z'S[a,b,c]ð ­ ('a,'b,'c)Z'S[a!,b!,c!]ð
÷
µp:('a ­ 'b ­ 'c ­ (BOOL,BOOL)Z'S[d,p]) ·
	Z'dec%down%s[a,b,c][!](Z'%down%s[a,b,c] p) = Z'%down%s[a!,b!,c!] p	
=TEX

\subsubsection{Schema Precondition}
=GFT HOL Constant
ÛZ'pre%down%s[a',b]Ý:(('a','b)Z'S[a',b])ð ­ (('b)Z'S[b])ð
÷
µs:(('a','b)Z'S[a',b])ð ·
	Z'pre%down%s[a',b] s = [b:'b|¶a':'a'· s]
=TEX
\subsubsection{Schema Dyadic operators}
The schema dyadic operators are ±, ², ´ and ¤. 
A sample definition for $Z'±_s$:
=GFT HOL Constant
ÛZ'±%down%s[a,b][b,c]Ý:(('a,'b)Z'S[a,b])ð ­ (('b,'c)Z'S[b,c])ð  ­ (('a,'b,'c)Z'S[a,b,c])ð
÷
µsc1:(('a,'b)Z'S[a,b])ð; sc2:(('b,'c)Z'S[b,c])ð·
	Z'±%down%s[a,b][b,c] sc1 sc2 = [a:'a; b:'b; c:'c | sc1 ± sc2]
=TEX
\subsubsection{Schema Projection}
=GFT HOL Constant
ÛZ'ù%down%s[a,b][b,c]Ý:(('a,'b)Z'S[a,b])ð ­ (('b,'c)Z'S[b,c])ð  ­ (('b,'c)Z'S[b,c])ð
÷
µsc1:(('a,'b)Z'S[a,b])ð; sc2:(('b,'c)Z'S[b,c])ð·
	Z'ù%down%s[a,b][b,c] sc1 sc2 = (sc1 ± sc2) \ (a)
=TEX
\subsubsection{Schema Hiding}
=GFT HOL Constant
ÛZ'\%down%s[a,b][b]Ý:(('a,'b)Z'S[a,b])ð ­ (('a)Z'S[a])ð
÷
µsc:(('a,'b)Z'S[a,b])ð·
	Z'\%down%s[a,b][b] sc = [a:'a | ¶b:'b· sc]
=TEX
\subsubsection{Schema Existential Quantification}
=GFT HOL Constant
ÛZ'¶%down%s[a,b][c,d]Ý	:
	('a ­ 'b ­ (BOOL,BOOL)Z'S[d,p]) ­ (('a,'b,'c,'d)Z'S[a,b,c,d])ð ­ (('c,'d)Z'S[c,d])ð
÷
µp:('a ­ 'b ­ (BOOL,BOOL)Z'S[d,p]);q:(('a,'b,'c,'d)Z'S[a,b,c,d])ð·
(Z'¶%down%s[a,b][c,d] p q
	= 	Z'absð(Ìx:Z'S[c,d]· ¶y:Z'S[a,b]·
			let	t = p  y.a  y.b
			in	t.d  ±  t.p
				± (Z'mk_S[a,b,c,d]  y.a  y.b  x.c  x.d)  q))
=TEX
\subsubsection{Schema Unique Existential Quantification}
=GFT HOL Constant
ÛZ'¶%down%1%down%s[a,b][c,d]Ý	:
	('a ­ 'b ­ (BOOL,BOOL)Z'S[d,p]) ­ (('a,'b,'c,'d)Z'S[a,b,c,d])ð ­ (('c,'d)Z'S[c,d])ð
÷
(Z'¶%down%1%down%s[a,b][c,d] p q
	= 	Z'absð(Ìx:Z'S[c,d]· ¶‰1y:Z'S[a,b]·
			let	t = p  y.a  y.b
			in	t.d  ±  t.p
				± (Z'S[a,b,c,d]  y.a  y.b  x.c  x.d)  q))
=TEX
\subsubsection{Schema Universal Quantification}
=GFT HOL Constant
ÛZ'µ%down%s[a,b][c,d]Ý	:
	('a ­ 'b ­ (BOOL,BOOL)Z'S[d,p]) ­ (('a,'b,'c,'d)Z'S[a,b,c,d])ð ­ (('c,'d)Z'S[c,d])ð
÷
(Z'µ%down%s[a,b][c,d] p q
	=	Z'absð(Ìx:Z'S[c,d]· µy:Z'S[a,b]·
			let	t = p  y.a  y.b
			in	t.d  ±  t.p
				´ (Z'S[a,b,c,d] y.a y.b x.c x.d)  q))
=TEX
\subsubsection{Delta Constructor}
=GFT HOL Constant
ÛZ'„%down%sÝ	:
÷


=TEX
\subsubsection{Xi Constructor}
=GFT HOL Constant
ÛZ'˜%down%sÝ	:
÷


=TEX

\subsubsection{Schema Composition}
=GFT HOL Constant
ÛZ'»%down%sÝ	:
÷


=TEX


\subsection{Other Constants}
\subsubsection{Existential Quantification}


\subsubsection{Unique Existential Quantification}


\subsubsection{Universal Quantification}
\appendix{CONST\_SPEC VERSUS SIMPLE\_NEW\_DEFINITION}

\subsection{Aim}
The aim of these experiments is to assess the relative merits of
using $const\_spec$ to introduce defining theorems for semantic constants, thus
increasing flexibility in the way that these theorems can be expressed, or using
$simple\_new\_definition$ which only permits definitions expressed as equations,
but performs faster than $const\_spec$.

\subsection{Method}

For the input, a definition of the form ¬f x = a® where ¬a® contains an occurrence of ¬x®,
is made using $const\_spec$. This is repeated several times, each definition varying
in the type of ¬x®. The total cpu time used, and the elapsed time are recorded
for these definitions.

The experiment is then repeated but the definitions of ¬f®
each take the form ¬Ì x · a®
where ¬a® contains an occurrence of ¬x®, and calling $simple\_new\_definition$.
The cpu and elapsed times for this are recorded and compared against those for
$const_spec$.

\subsection{Input Data}


=GFT
push_pc "basic_hol";

open_theory"z_language";
delete_theory"performance" handle _ => ();
new_theory"performance";
=TEX
The input data is based upon the first 10 semantic constants for set abstraction.
The following constitutes the input data for calls to $simple\_new\_defn$. 
=GFT SML Input
val def1_1 = ¬(Ì pack · {x |¶ a1
	· $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x})®;
val def1_2 = ¬(Ì pack · {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x})®;
val def1_3 = ¬(Ì pack · {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x})®;
val def1_4 = ¬(Ì pack · {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x})®;
val def1_5 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x})®;
val def1_6 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x})®;
val def1_7 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x})®;
val def1_8 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x})®;
val def1_9 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x})®;
val def1_10 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x})®;


val x1 = (["seta1"],"seta1",def1_1);
val x2 = (["seta2"],"seta2",def1_2);
val x3 = (["seta3"],"seta3",def1_3);
val x4 = (["seta4"],"seta4",def1_4);
val x5 = (["seta5"],"seta5",def1_5);
val x6 = (["seta6"],"seta6",def1_6);
val x7 = (["seta7"],"seta7",def1_7);
val x8 = (["seta8"],"seta8",def1_8);
val x9 = (["seta9"],"seta9",def1_9);
val x10 = (["seta10"],"seta10",def1_10);
=TEX
The following constitutes the input data for calls to $const\_spec$. 
=GFT SML Input
val cs1_1 = ¬µ pack · seta1' pack = {x |¶ a1 · $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x}®;
val cs1_2 = ¬µ pack · seta2' pack = {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x}®;
val cs1_3 = ¬µ pack · seta3' pack = {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x}®;
val cs1_4 = ¬µ pack · seta4' pack = {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x}®;
val cs1_5 = ¬µ pack · seta5' pack = {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x}®;
val cs1_6 = ¬µ pack · seta6' pack = {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x}®;
val cs1_7 = ¬µ pack · seta7' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x}®;
val cs1_8 = ¬µ pack · seta8' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x}®;
val cs1_9 = ¬µ pack · seta9' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x}®;
val cs1_10 = ¬µ pack · seta10' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x}®;

val y1 = (["seta1'"], frees cs1_1, cs1_1);
val y2 = (["seta2'"], frees cs1_2, cs1_2);
val y3 = (["seta3'"], frees cs1_3, cs1_3);
val y4 = (["seta4'"], frees cs1_4, cs1_4);
val y5 = (["seta5'"], frees cs1_5, cs1_5);
val y6 = (["seta6'"], frees cs1_6, cs1_6);
val y7 = (["seta7'"], frees cs1_7, cs1_7);
val y8 = (["seta8'"], frees cs1_8, cs1_8);
val y9 = (["seta9'"], frees cs1_9, cs1_9);
val y10 = (["seta10'"], frees cs1_10, cs1_10);
=TEX

The following Standard ML code maps the appropriate functions over the
test data and returns the results.

=GFT SML Input
"simple_new_defn ...";
PolyML.timing true;
val _ = map simple_new_defn [x1, x2, x3, x4, x5, x6, x7, x8, x9, x10];
PolyML.timing false;
"Const_spec ...";
PolyML.timing true;
val _ = map const_spec [y1, y2, y3, y4, y5, y6, y7, y8, y9, y10];
PolyML.timing false;
=TEX


\subsection{Results}


The results recorded for a Sun 3/60 (12Mb) are as follows:

			elapsed time (s)
simple_new_defn			12.1
				13.1
				12.2

const_spec			376.9
				371.1

const_spec
\subsection{Conclusion}


=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}



