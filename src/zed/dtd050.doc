=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Z Constant Generation}
\TPPref{DS/FMU/IED/DTD050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
%\TPPauthors{G.T.Scullard&WIN01\\G.M.Prout&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the detailed design of the definition of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First draft versions.
\item [Issue 1.4] (\TPPdate{\FormatDate{$Date$
}})
$get\_mode$ and $set\_mode$ replaced by a boolean flag.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The design is
implemented in \cite{DS/FMU/IED/IMP050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
In the Z Proof Support Subsystem, two types of constants have been identified:
\begin{enumerate}
\item
 Constants defined as primitive  in the system, see \cite{DS/FMU/IED/DTD052}.
\item 
Constants that belong to infinite families and thus cannot be defined as primitive. 
\end{enumerate}
This document gives the detailed design for the generation of constants of type (2). 
These constants are defined dynamically on initial introduction. The mechanism employed for storing the Z constants
will depend on whether or not 
defining theorems are to be stored for these constants. 
This choice will be controlled
by a boolean flag $defining\_theorem$.

If $defining\_theorem$ is false, the Z constants and any required associated types will be stored  using $new\_type$ and $new\_const$
 of  \cite{DS/FMU/IED/DTD012}.

If $defining\_theorem$ is true, definitions for the Z 
constants and any required associated types will be stored.
 The mechanism employed for
storing defining theorems for the generated types  will be a 
call to $labelled\_product\_spec$ of \cite{DS/FMU/IED/DTD059} and for storing defining theorems for the 
generated constants will be 
a call to $const\_spec$ of \cite{DS/FMU/IED/DTD012}.


A detailed discussion of data storage of dynamically generated constants may be found in \cite{DS/FMU/IED/HLD017}, although at this stage
the issue of where to store dynamically generated Z 
constants has not been resolved. It is anticipated that
 defining theorems be stored in a theory (Z?) at the top of the user hierarchy, and constants and types without defining theorems
be stored temporarily in the user's current theory.

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
=IGN
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=TEX
=TEX
\section{SIGNATURE}
=DOC
signature ‚ZConstants· = sig
=DESCRIBE
The functions which define the dynamically generated Z semantic constants are packaged into this signature.
=ENDDOC
\subsection{Storing Z Constants}
=DOC
(* ‚defining_theorem· - boolean flag declared by new_flag *)
=DESCRIBE
Causes  defining theorems to be stored for
the constant and any associated types (if true).  
If $defining\_theorem$ is false then constants are put in place using $new\_const$ and types using $new\_type$.
This should be maintained via the functions of structure $SystemControl$.
=ENDDOC



\subsection{Binding Types}
=DOC
val ‚binding_type_spec· : TYPE -> unit;
val ‚get_binding_info· : TYPE -> TERM * TERM list;

=DESCRIBE
For each finite set of identifiers a polymorphic type constructor is required 
which is the type of bindings which bind values to just the identifiers in the set. 
Each of these type constructors has a unique name formed by
 appending to the 
prefix ``$Z'mk\_S$'' the alphabetically ordered list of identifiers. 
The function  $binding\_type\_spec$ first checks for the existence of the binding type. If the type does not exist, if $defining\_theorem$ is true, then its definition 
is generated  along with the polymorphic definitions of the
 binding constructor and the 
binding projections. If $defining\_theorem$ is false, then
the binding type and its constructor and projections will be
put in place  by $new\_type$ and $new\_const$.

The function $get\_binding\_info$ returns
 the polymorphic  names of the binding constructor  and 
list of binding projections if they exist; it fails otherwise.
 
An example of a binding type is $('a, 'b)Z'S[a,b]$. The application of $binding\_type\_spec$ determines whether or not the type 
$Z'S[a,b]$ already exists. If not, the type $Z'S[a,b]$ and  the polymorphic constants $Z'mk\_S[a,b]$ (the binding constructor)
 $Z'S[a,b]a$ and $Z'S[a,b]b$ (the binding  projections)
are generated.
The application of $get\_binding\_info$ 
to the binding type $('a, 'b)Z'S[a,b]$ yields the  binding constructor $Z'mk\_S[a,b]$ 
and list of binding  projections 
$[Z'S[a,b]a, Z'S[a,b]b]$. If $defining\_theorem$ is true,
 the type definition generated would be:
Û
Ö Ñ f:('a, 'b)Z'S[a,b] ã 'a â 'b é TypeDefn (çx:'a â 'b é T)f
Ê

and the definition of the binding constructor  and binding projections would be:
ÛHOL Constant
Z'mk_S[a,b]: 'a ã 'b ã ('a,'b)Z'S[a,b]
Z'S[a,b]a:('a,'b)Z'S[a,b] ã 'a
Z'S[a,b]b:('a,'b)Z'S[a,b] ã 'b
…
É t x1 x2é
Z'S[a,b]a (Z'mk_S[a,b] x1 x2) = x1 Ä Z'S[a,b]b (Z'mk_S[a,b] x1 x2) = x2
Ä
Z'mk_S[a,b] (Z'S[a,b]a t) (Z'S[a,b]b t) = t
Ê
The definition of the binding type would be saved  under the key $Z'S[a,b]$, and the defining theorem
 for
the binding constructor  and binding projections
 under the keys $Z'mk\_S[a,b]$, $Z'S[a,b]a$ and $Z'S[a,b]b$.
The functions $binding\_type\_spec$ and $get\_binding\_info$ are used by all the functions in 
section \ref{ZCONST} which define the Z semantic constants.
=FAILURE
47050	?0 is not a binding type
50001	There is no binding type called ?0 
=ENDDOC
 
The function $labelled\_product\_spec$ described in \cite{DS/FMU/IED/DTD059} is called to generate the defining theorems for the binding type and for its associated constants.

\subsection{Tuple Types}
=DOC
val ‚tuple_type_spec· : TYPE -> unit ;
val ‚get_tuple_info· : TYPE -> TERM ;
=DESCRIBE
Each tuple type constructor has a unique name formed by
 appending the 
prefix ``$Z'mk\_T$'' to a singleton list containing the arity of the tuple. 
The function  $tuple\_type\_spec$ first checks for the existence of the tuple type. If the type does not exist, if $defining\_theorem$ is true, then its definition 
is generated  along with the polymorphic definitions of the
 tuple constructor and the 
tuple projections. If $defining\_theorem$ is false, then
the tuple type and its constructor and projections will be
put in place  by $new\_type$ and $new\_const$.

The function $get\_tuple\_info$ returns
 the polymorphic  names of the tuple constructor  and 
list of tuple projections if they exist; it fails otherwise.
 
An example of a tuple type is $('1, '2, '3)Z'T[3]$. The application of $tuple\_type\_spec$ determines whether or not the type 
$Z'T[3]$ already exists. If not, the type $Z'T[3]$ and  the polymorphic constants $Z'mk\_T[3]$ (the tuple constructor)
$Z'T[3]1$, $Z'T[3]2$ and $Z'T[3]3$ (the tuple  projections)
are generated.
The application of $get\_tuple\_info$ 
to the tuple type $('1, '2, '3)Z'T[3]$ yields the  
tuple constructor $Z'mk\_T[3]$ and list of tuple  projections 
$[Z'T[3]1, Z'T[3]2], Z'T[3]3]$. If $defining\_theorem$ is
 true, the type definition generated would be:
Û
Ö Ñ f:('1, '2, '3)Z'T[3] ã '1 â '2 â '3é  TypeDefn (çx:'1 â '2 â '3 é T)f
Ê


and the definition of the tuple constructor and tuple projections  would be:
ÛHOL Constant
Z'mk_T[3]: '1 ã '2 ã '3 ã ('1,'2,'3)ZT'[3]
Z'T[3]1: ('1,'2,'3)ZT'[3] ã '1 
Z'T[3]2: ('1,'2,'3)ZT'[3] ã '2
Z'T[3]3: ('1,'2,'3)ZT'[3] ã '3 
	
…
É t x1 x2 x3é
  Z'T[3]1 (Z'mk_T[3] x1 x2 x3) = x1 
Ä Z'T[3]2 (Z'mk_T[3] x1 x2 x3) = x2
Ä Z'T[3]3 (Z'mk_T[3] x1 x2 x3) = x3 
Ä Z'mk_T[3] (Z'T[3]1 t) (Z'T[3]2 t) (Z'T[3]3 t) = t
Ê
The definition of the tuple type would be saved 
 under the key $Z'T[3]$, and the defining theorem
for the tuple constructor and tuple projections
 under the keys $Z'mk\_T[3]$, $Z'T[3]1$, $Z'T[3]2$ and
 $Z'T[3]3$.

=FAILURE
47040	?0 is not a tuple type
50002	There is no tuple type called ?0 
=ENDDOC
 
The function $labelled\_product\_spec$ described in \cite{DS/FMU/IED/DTD059} is called to generate the defining theorems for the tuple type and for its associated constants.

\subsection{Retrieving Definitions of Constructors and Projections}
=DOC
val ‚get_constructor_defn· : TYPE -> THM;
val ‚get_projections_defn· : TYPE -> THM list;
=DESCRIBE
These functions  take a binding type (or a tuple type) and return information from the 
appropriate conjunct of the definition of 
the binding constructor (or tuple constructor) and binding projections (or tuple projections). This is achieved by first calling $binding\_type\_spec$ (or $tuple\_type\_spec$), which generates the definition where necessary, and then retrieving that definition. If $defining\_theorem$ were false when the type was introduced, no definitions would have been generated
 and the functions fail.
In the examples given above, the theorems returned for 
the binding constants would be:
Û
Ö É t é Z'mk_S[a,b] (Z'S[a,b]a t) (Z'S[a,b]b t) = t
Ê
and
Û
[Ö É x1 x2 é Z'S[a,b]a(Z'mk_S[a,b](x1 x2)) = x1,
Ö É x1 x2 é Z'S[a,b]b(Z'mk_S[a,b](x1 x2)) = x2] 
Ê
The theorems returned for 
the tuple constants would be:
Û
Ö É t é Z'mk_T[3] (Z'T[3]1 t) (Z'T[3]2 t)(Z'T[3]3 t) = t
Ê
and
Û
[Ö É x1 x2 x3 é Z'T[3]1(Z'mk_T[3](x1 x2 x3)) = x1,
Ö É x1 x2  x3é Z'T[3]2(Z'mk_T[3](x1 x2 x3)) = x2,
Ö É x1 x2  x3é Z'T[3]3(Z'mk_T[3](x1 x2 x3)) = x3] 
Ê

	
=FAILURE
50003	?0 is not a binding type or a tuple type
50004	The binding constructor for ?0 has not been defined
50005	The binding projections for ?0 have not been defined
50006	The tuple constructor for ?0 has not been defined
50007	The tuple projections for ?0 have not been defined
=ENDDOC
	
\section{Z CONSTANT DEFINITION GENERATION}\label{ZCONST}
Z constants that belong to infinite families are defined dynamically on initial introduction. Whether or not they have defining theorems associated with them depends on the boolean flag $defining\_theorem$. If $defining\_theorem$ is false, then the first time such a constant is introduced, it will be stored  as a 
polymorphic constant with no defining theorem. Any undefined associated types will also be stored with no defining theorems.
If the flag
$defining\_theorem$ is true, then the first time such a constant is introduced its definition, and those of any associated types, will be dynamically generated and stored. 
=DOC
val ‚types_in_zcon_spec· : TYPE -> unit;
=DESCRIBE
This function recurses through the polymorphic type of a term  
which is one of the infinite families of Z constants,
defining any new types
encountered. The functions $binding\_type\_spec$ and $tuple\_type\_spec$
are called to enter the new types  (and their constructors and projections) into the theory.
=FAILURE
50008	?0 is not the type of a Z constant
=ENDDOC

=DOC
val ‚name_to_termpr· : string -> TERM * TERM;
=DESCRIBE
$name\_to\_termpr$ $znam$ takes the name  of a 
Z schema constant,  and returns a pair consisting of
the corresponding polymorphic constant and its polymorphic defining term. 
=FAILURE
47000	?0 is a badly formed Z constant name
=ENDDOC


=DOC
val ‚z_const_spec· : string -> unit;
=DESCRIBE
$z\_const\_spec$ $znam$ first checks for the existence of the Z constant  named $znam$.  If the constant does not exist,
if $defining\_theorem$ is true, then its polymorphic definition, and polymorhic definitions of any new constants introduced by the defining term, will be generated using $const\_spec$, see \cite{DS/FMU/IED/DTD046}. The definition  would be saved under the key $znam$.
If $defining\_theorem$ is false, $new\_const$ is called to
 store the polymorphic constant $znam$ in the 
current theory.  Where a new constant is generated, all necessary new types (and their constructors and projections) are put in place by a call to $types\_in\_zcon\_spec$. 
=FAILURE
47000	?0 is a badly formed Z constant name
50008	?0 is not the type of a Z constant
=ENDDOC

=DOC
val ‚get_z_const_defn· : TERM -> THM;
=DESCRIBE
 The function $get\_z\_const\_defn$ $zcon$ returns the type instantiated defining theorem for the Z constant  
$zcon$.  
This is achieved by first calling $z\_const\_spec$, which generates the definition where necessary, 
and then retrieving that definition. Examples of the defining theorems are given in DS/FMU/IED/DTD050.
If $defining\_theorem$ were false when the constant was introduced, no definitions would have been generated  by $z\_const\_spec$ and the function fails.
=FAILURE
3009	?0 is not a constant
47000	?0 is a badly formed Z constant name
50009	The Z constant ?0 has not been defined
=ENDDOC
\section{END OF SIGNATURE}
=SML
end (* end of ZConstants signature *);
=TEX

\section{EXAMPLE DEFINITIONS OF Z CONSTANTS}
A sample definition is given for each of the Z constants that are dynamically generated. In the following, 
$Z'absë$ is the set abstraction function of \cite{DS/FMU/IED/DTD052}.
\subsection{Constants for Schema Calculus}
\subsubsection{Schema Constructor}
ÛHOL Constant
‚Z'%down%s[a,b]·	: ('a ã 'b ã (BOOL,BOOL)Z'S[d,p]) ã (('a,'b)Z'S[a,b])ë
…
Ép:('a ã 'b ã (BOOL,BOOL)Z'S[d,p])é
(Z'%down%s[a,b] p
	=	Z'absë(çx:('a,'b)Z'S[a,b]é
			let	t = p  x.a  x.b
			in	t.d  Ä  t.p))

Ê
\subsubsection{Schema Decoration}

ÛHOL Constant
‚Z'dec%down%s[a,b,c][!]· : ('a,'b,'c) Z'S[a,b,c]ë ã ('a,'b,'c)Z'S[a!,b!,c!]ë
…
Ép:('a ã 'b ã 'c ã (BOOL,BOOL)Z'S[d,p]) é
	Z'dec%down%s[a,b,c][!](Z'%down%s[a,b,c] p) = Z'%down%s[a!,b!,c!] p	
Ê

\subsubsection{Schema Precondition}
ÛHOL Constant
‚Z'pre%down%s[a',b]·:(('a','b)Z'S[a',b])ë ã (('b)Z'S[b])ë
…
És:(('a','b)Z'S[a',b])ë é
	Z'pre%down%s[a',b] s = [b:'b|Ña':'a'é s]
Ê
\subsubsection{Schema Dyadic operators}
The schema dyadic operators are Ä, Å, ä and Ç. 
A sample definition for $Z'Ä_s$:
ÛHOL Constant
‚Z'Ä%down%s[a,b][b,c]·:(('a,'b)Z'S[a,b])ë ã (('b,'c)Z'S[b,c])ë  ã (('a,'b,'c)Z'S[a,b,c])ë
…
Ésc1:(('a,'b)Z'S[a,b])ë; sc2:(('b,'c)Z'S[b,c])ëé
	Z'Ä%down%s[a,b][b,c] sc1 sc2 = [a:'a; b:'b; c:'c | sc1 Ä sc2]
Ê
\subsubsection{Schema Projection}
ÛHOL Constant
‚Z'¡%down%s[a,b][b,c]·:(('a,'b)Z'S[a,b])ë ã (('b,'c)Z'S[b,c])ë  ã (('b,'c)Z'S[b,c])ë
…
Ésc1:(('a,'b)Z'S[a,b])ë; sc2:(('b,'c)Z'S[b,c])ëé
	Z'¡%down%s[a,b][b,c] sc1 sc2 = (sc1 Ä sc2) ƒ (a)
Ê
\subsubsection{Schema Hiding}
ÛHOL Constant
‚Z'ƒ%down%s[a,b][b]·:(('a,'b)Z'S[a,b])ë ã (('a)Z'S[a])ë
…
Ésc:(('a,'b)Z'S[a,b])ëé
	Z'ƒ%down%s[a,b][b] sc = [a:'a | Ñb:'bé sc]
Ê
\subsubsection{Schema Existential Quantification}
ÛHOL Constant
‚Z'Ñ%down%s[a,b][c,d]·	:
	('a ã 'b ã (BOOL,BOOL)Z'S[d,p]) ã (('a,'b,'c,'d)Z'S[a,b,c,d])ë ã (('c,'d)Z'S[c,d])ë
…
Ép:('a ã 'b ã (BOOL,BOOL)Z'S[d,p]);q:(('a,'b,'c,'d)Z'S[a,b,c,d])ëé
(Z'Ñ%down%s[a,b][c,d] p q
	= 	Z'absë(çx:Z'S[c,d]é Ñy:Z'S[a,b]é
			let	t = p  y.a  y.b
			in	t.d  Ä  t.p
				Ä (Z'mk_S[a,b,c,d]  y.a  y.b  x.c  x.d) ù q))
Ê
\subsubsection{Schema Unique Existential Quantification}
ÛHOL Constant
‚Z'Ñ%down%1%down%s[a,b][c,d]·	:
	('a ã 'b ã (BOOL,BOOL)Z'S[d,p]) ã (('a,'b,'c,'d)Z'S[a,b,c,d])ë ã (('c,'d)Z'S[c,d])ë
…
(Z'Ñ%down%1%down%s[a,b][c,d] p q
	= 	Z'absë(çx:Z'S[c,d]é ¿y:Z'S[a,b]é
			let	t = p  y.a  y.b
			in	t.d  Ä  t.p
				Ä (Z'S[a,b,c,d]  y.a  y.b  x.c  x.d) ù q))
Ê
\subsubsection{Schema Universal Quantification}
ÛHOL Constant
‚Z'É%down%s[a,b][c,d]·	:
	('a ã 'b ã (BOOL,BOOL)Z'S[d,p]) ã (('a,'b,'c,'d)Z'S[a,b,c,d])ë ã (('c,'d)Z'S[c,d])ë
…
(Z'É%down%s[a,b][c,d] p q
	=	Z'absë(çx:Z'S[c,d]é Éy:Z'S[a,b]é
			let	t = p  y.a  y.b
			in	t.d  Ä  t.p
				ä (Z'S[a,b,c,d] y.a y.b x.c x.d) ù q))
Ê
\subsubsection{Delta Constructor}
ÛHOL Constant
‚Z'Ò%down%s·	:
…


Ê
\subsubsection{Xi Constructor}
ÛHOL Constant
‚Z'Ú%down%s·	:
…


Ê

\subsubsection{Schema Composition}
ÛHOL Constant
‚Z'Ø%down%s·	:
…


Ê


\subsection{Other Constants}
\subsubsection{Set Comprehension}
ÛHOL Constant
‚Z'seta[2]·	:
	('1 ã '2 ã (BOOL,BOOL,'v)Z'S[d,p,v]) ã ('v)ë
…
(Z'seta[2] p
	=	Z'absë(çx:'vé Ñ(y:'1) (z:'2)é
			let 	t = p y z 
			in	t.d Ä t.p Ä (t.v = x))
Ê
=IGN
Í
	zconst_spec : TERM -> THM
…
É setatm | 
	setaty = ª%down%SML (type_of setatm)º
	Ä
	
	é
	 zconst_spec tm = (Z'absë:(ªvº ã BOOL) ã (ªvº)ë)
	(ç x é 
À
=TEX

\subsubsection{Cartesian Product}
ÛHOL Constant
‚Z'â[2]·	:'1 ë ã '2 ë ã ('1,'2)Z'T[2] ë
…
Z'â[2] x y  
	=	
		Z'absë(çt:('1,'2)Z'T[2]é 
			Z'T[2]1 t ù x 
			Ä 
			Z'T[2]2 t ù y)
Ê

\subsubsection{Lambda Abstraction}

ÛHOL Constant
‚Z'ç[2]·	:
	('1 ã '2 ã (BOOL,BOOL,'t,'v)Z'S[d,p,t,v]) ã (('t,'v)Z'T[2])ë
…
(Z'ç[2] p
	=	Z'absë(çx:('t,'v)Z'S[1,2]é Ñ(y:'1) (z:'2)é
			let	t = p y z
			in	t.d Ä t.p Ä (t.t = x.1 Ä t.v = x.2))
Ê
\subsubsection{Definite Description}
Note that Z'á is the primitive definite description constant described in \cite{DS/FMU/IED/DTD052}.
ÛHOL Constant
‚Z'á[2]·		:
	('1 ã '2 ã (BOOL,BOOL,'v)Z'S[d,p,v]) ã 'v
…
(Z'á[2] p
	=	Z'á(çx:'vé Ñ(y:'1) (z:'2)é
			let	t = p y z
			in	t.d Ä t.p Ä (t.v = x)))
Ê
\subsubsection{Existential Quantification}


\subsubsection{Unique Existential Quantification}


\subsubsection{Universal Quantification}
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

