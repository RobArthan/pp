% %Z% $Id$ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Z Constant Generation}
\TPPref{DS/FMU/IED/DTD050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{G.M.Prout&WIN01}  %% Mandatory field
\TPPauthors{G.M.Prout&WIN01\\D.J.King&WIN01 }
\TPPauthorisation{R.B.Jones & Project Manager}
\TPPabstract{This document contains the detailed design of the definition of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First draft versions.
\item [Issue 1.4]
$get\_mode$ and $set\_mode$ replaced by a boolean flag.
\item [Issue 1.5]Changed to new fonts.
\item [Issue 1.9 (20th July 1992)]
Added schema renaming definition mechanism.
Replaces uses of $\% down\%$.
\item [Issue \SCCSversion~(\FormatDate{$Date$%
}] Added support for binding display.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
Z constant generation mechanism for
the Z Proof Support System (see \cite{DS/FMU/IED/HLD015}).
This is called for in \cite{DS/FMU/IED/HLD017}.
The design is
implemented in \cite{DS/FMU/IED/IMP050}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
In the Z Proof Support Subsystem, two types of constants have been identified:
\begin{enumerate}
\item
 Constants defined as primitive  in the system, see \cite{DS/FMU/IED/DTD052}.
\item 
Constants that belong to infinite families and thus cannot be defined as primitive. 
\end{enumerate}
This document gives the detailed design for the generation of constants of type (2). 
These constants are defined dynamically on initial introduction. The mechanism employed for storing the Z constants
will depend on whether or not 
defining theorems are to be stored for these constants. 
This choice will be controlled
by a boolean flag $defining\_theorem$.

If $defining\_theorem$ is false, the Z constants and any required associated types will be stored  using $new\_type$ and $new\_const$
 of  \cite{DS/FMU/IED/DTD012}.

If $defining\_theorem$ is true, definitions for the Z 
constants and any required associated types will be stored.
 The mechanism employed for
storing defining theorems for the generated types  will be a 
call to $labelled\_product\_spec$ of \cite{DS/FMU/IED/DTD059} and for storing defining theorems for the 
generated constants will be 
a call to $const\_spec$ of \cite{DS/FMU/IED/DTD012}.


A detailed discussion of data storage of dynamically generated constants may be found in \cite{DS/FMU/IED/HLD017}, although at this stage
the issue of where to store dynamically generated Z 
constants has not been resolved. It is anticipated that
 defining theorems be stored in a theory (Z?) at the top of the user hierarchy, and constants and types without defining theorems
be stored temporarily in the user's current theory.

\subsubsection{Dependencies}
The functions in this document are dependent on the Release 1 HOL System.
=IGN
\subsubsection{Deficiencies}
\section{ERROR REPORTING}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=TEX

\section{Z CONSTANT DEFINITION GENERATION}\label{ZCONST}
Z constants that belong to infinite families are defined dynamically on initial introduction. 
Whether or not they have defining theorems associated with them depends on the boolean flag $defining\-\_theorem$. 
If $defining\-\_theorem$ is false, then the first time such a constant is introduced, it will be stored  as a 
polymorphic constant with no defining theorem. Any undefined associated types will also be stored with no defining theorems.
If the flag
$defining\_theorem$ is true, then the first time such a constant is introduced its definition, and those of any associated types, will be dynamically generated and stored.


For each abstract machine interface for creating HOL terms representing the Z abstract syntax,
which is not an individual semantic constant (as defined in \cite{DS/FMU/IED/DTD052}), there
is an interface to the semantic constant generator. These are introduced below.

A sample definition is given for each of the Z constants that are dynamically generated. In the following, 
$Z'Absð$ is the set abstraction function of \cite{DS/FMU/IED/DTD052}.

=DOC
signature ÛZGeneratedConstantsÝ = sig
=DESCRIBE
The functions which define the dynamically generated Z semantic constants are packaged into this signature.
=FAILURE
50100	argument to constant generator function is inappropriate 
=ENDDOC

\subsection{Tuples}

=DOC
val Ûtuple_gen_semantic_constÝ : TERM -> unit;
=DESCRIBE
=ENDDOC

\subsection{Set Abstraction}

=DOC
val Ûseta_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Ì Abstraction}
=DOC
val ÛÌ_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Cartesian Product}
=DOC
val Û¸_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC


\subsubsection{Definite Description}

=DOC
val ÛÍ_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC


\subsubsection{Binding Display}
=DOC
val Ûbinding_gen_semantic_constÝ : TERM -> THM;
=EXAMPLE
=FAILURE
50111	?0 is not a Z binding display constant 
=ENDDOC
}


\subsection{Constants for Schema Calculus}
\subsubsection{Schema Constructor}
=DOC
val Ûschema_gen_semantic_constÝ : TERM -> THM;
=EXAMPLE
=FAILURE
50111	?0 is not a Z binding display constant 
=ENDDOC

\subsubsection{Schema Decoration}
=DOC
val Ûdec‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Schema Precondition}
=DOC
val Ûpre‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC
=TEX
\subsubsection{Schema Dyadic operators}
=DOC
val Ûdyop‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC


The schema dyadic operators are ±, ², ´ and ¤. 
=TEX
\subsubsection{Schema Projection}
=DOC
val Ûù‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Schema Hiding}
=DOC
val Ûhide‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Schema Quantification}
=DOC
val Ûquant‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Delta Constructor}

=DOC
val Û„‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Xi Constructor}
=DOC
val Û˜‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Schema Composition}
=DOC
val Û»‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
=ENDDOC

\subsubsection{Schema Renaming}
=DOC
val Ûrename‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
For each finite set of identifiers and renaming lists a polymorphic constant is required,
which implements the renaming.

The function  $rename‰s\_gen\_semantic\_const$ takes as argument
a Z renaming term,
e.g. 
=INLINEFT
ñS [x/a,y/c]®
=TEX
. 
This term is represented in HOL as an application of a renaming
constant to something of schema type.
The function first checks for the existence of the renaming constant. 
If the constant does not exist, then if $defining\_theorem$ is true, then its definition 
is generated and returned. If $defining\_theorem$ is false, then
the constant will be
put in place by $new\_const$, and 
=INLINEFT
ô T
=TEX
 is returned.
If the constant already exists then the defining theorem, if found, will be returned, and otherwise 
=INLINEFT
ô T
=TEX
.
 
An example of a renaming constant is 
=INLINEFT
Z'Rename‰s[a,b][x|a,y|c]
=TEX
{}. 

The application of $rename‰s\_gen\_semantic\_const$ determines whether or not the constant already exists. If not, the polymorphic constant is generated, perhaps with a definition.
If $defining\_theorem$ is true,
 the constant definition generated would be:
=GFT HOL Constant
Û$"Z'Rename‰s[a,b][x|a,y|c]"Ý :(('x,'b)$"Z'S[a,b]") SET ­ (('b,'x)$"Z'S[b,x]") SET
÷
µ S : (('x,'b)$"Z'S[a,b]") SET ·
$"Z'Rename‰s[a,b][x|a,y|c]" S =
	{ s | 
	¶ s' · s'  S ± s = $"Z'Mk_S"[b,x] ($"Z'S[b,x]b" s') ($"Z'S[b,x]a" s')}
=TEX
Notice that
\begin{itemize}
\item
As the alphabetic order of ``a'' and ``b'' is different from
``x'' and ``b'' the schema constructors arguments are reversed.
\item
The redundant renaming plays no part in the definition.
\item
If there are no used renamings then the renaming constant
is easily proven to be the identity function, by the
definition from $get\-\_constructor\-\_defn$.
\end{itemize}

This definition would be saved under the key ``$Z'Rename‰s[a,b][x|a,y|c]$'',
and returned as the result of the function.
=FAILURE
47461	?0 is not a Z schema renaming
=ENDDOC
 

\section{END OF SIGNATURE }
=SML
end (* end of ZGeneratedConstants signature *);
=TEX

\appendix{CONST\_SPEC VERSUS SIMPLE\_NEW\_DEFINITION}

\subsection{Aim}
The aim of these experiments is to assess the relative merits of
using $const\_spec$ to introduce defining theorems for semantic constants, thus
increasing flexibility in the way that these theorems can be expressed, or using
$simple\_new\_definition$ which only permits definitions expressed as equations,
but performs faster than $const\_spec$.

\subsection{Method}

For the input, a definition of the form ¬f x = a® where ¬a® contains an occurrence of ¬x®,
is made using $const\_spec$. This is repeated several times, each definition varying
in the type of ¬x®. The total cpu time used, and the elapsed time are recorded
for these definitions.

The experiment is then repeated but the definitions of ¬f®
each take the form ¬Ì x · a®
where ¬a® contains an occurrence of ¬x®, and calling $simple\_new\_definition$.
The cpu and elapsed times for this are recorded and compared against those for
$const_spec$.

\subsection{Input Data}


=GFT
push_pc "basic_hol";

open_theory"z_language";
delete_theory"performance" handle _ => ();
new_theory"performance";
=TEX
The input data is based upon the first 10 semantic constants for set abstraction.
The following constitutes the input data for calls to $simple\_new\_defn$. 
=GFT SML Input
val def1_1 = ¬(Ì pack · {x |¶ a1
	· $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x})®;
val def1_2 = ¬(Ì pack · {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x})®;
val def1_3 = ¬(Ì pack · {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x})®;
val def1_4 = ¬(Ì pack · {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x})®;
val def1_5 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x})®;
val def1_6 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x})®;
val def1_7 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x})®;
val def1_8 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x})®;
val def1_9 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x})®;
val def1_10 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x})®;


val x1 = (["seta1"],"seta1",def1_1);
val x2 = (["seta2"],"seta2",def1_2);
val x3 = (["seta3"],"seta3",def1_3);
val x4 = (["seta4"],"seta4",def1_4);
val x5 = (["seta5"],"seta5",def1_5);
val x6 = (["seta6"],"seta6",def1_6);
val x7 = (["seta7"],"seta7",def1_7);
val x8 = (["seta8"],"seta8",def1_8);
val x9 = (["seta9"],"seta9",def1_9);
val x10 = (["seta10"],"seta10",def1_10);
=TEX
The following constitutes the input data for calls to $const\_spec$. 
=GFT SML Input
val cs1_1 = ¬µ pack · seta1' pack = {x |¶ a1 · $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x}®;
val cs1_2 = ¬µ pack · seta2' pack = {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x}®;
val cs1_3 = ¬µ pack · seta3' pack = {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x}®;
val cs1_4 = ¬µ pack · seta4' pack = {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x}®;
val cs1_5 = ¬µ pack · seta5' pack = {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x}®;
val cs1_6 = ¬µ pack · seta6' pack = {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x}®;
val cs1_7 = ¬µ pack · seta7' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x}®;
val cs1_8 = ¬µ pack · seta8' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x}®;
val cs1_9 = ¬µ pack · seta9' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x}®;
val cs1_10 = ¬µ pack · seta10' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x}®;

val y1 = (["seta1'"], frees cs1_1, cs1_1);
val y2 = (["seta2'"], frees cs1_2, cs1_2);
val y3 = (["seta3'"], frees cs1_3, cs1_3);
val y4 = (["seta4'"], frees cs1_4, cs1_4);
val y5 = (["seta5'"], frees cs1_5, cs1_5);
val y6 = (["seta6'"], frees cs1_6, cs1_6);
val y7 = (["seta7'"], frees cs1_7, cs1_7);
val y8 = (["seta8'"], frees cs1_8, cs1_8);
val y9 = (["seta9'"], frees cs1_9, cs1_9);
val y10 = (["seta10'"], frees cs1_10, cs1_10);
=TEX

The following Standard ML code maps the appropriate functions over the
test data and returns the results.

=GFT SML Input
"simple_new_defn ...";
PolyML.timing true;
val _ = map simple_new_defn [x1, x2, x3, x4, x5, x6, x7, x8, x9, x10];
PolyML.timing false;
"Const_spec ...";
PolyML.timing true;
val _ = map const_spec [y1, y2, y3, y4, y5, y6, y7, y8, y9, y10];
PolyML.timing false;
=TEX


\subsection{Results}


The results recorded for a Sun 3/60 (12Mb) are as follows:
=TEX
\begin{tabular}{|l|l|}\hline
&elapsed time (s)\\\hline
simple_new_defn&12.1\\
&13.1 \\
&12.2 \\
\hline\\
const_spec&376.9 \\
&371.1 \\

const_spec&
\hline
\end{tabular}

=TEX
\subsection{Conclusion}


=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}



