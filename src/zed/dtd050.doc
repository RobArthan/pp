% dtd050.doc %Z% $Date$ $Revision$ $RCSfile$ 
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Z Constant Generation}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Z Constant Generation}
\TPPref{DS/FMU/IED/DTD050}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{}  %% Mandatory field
\TPPauthors{D.J.~King&WIN01\\~G.M.Prout&WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design of the definition of constants generated by the Z Abstract Syntax in the  Z Proof Support System.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 - 1.3] 
First draft versions.
\item [Issue 1.4]
$get\_mode$ and $set\_mode$ replaced by a boolean flag.
\item [Issue 1.5]Changed to new fonts.
\item [Issue 1.9 (20th July 1992)]
Added schema renaming definition mechanism.
Replaces uses of $\% down\%$.
\item [Issue 1.10 (20th July 1992)] Added support for binding display.
\item [Issue 1.18 (24 August 1992)] Provided a description of
the functionality and the design for Z generated semantic constants.
\item [Issue 1.19 (15th October 1992)]
Improved message 50001.
\item[Issue 1.20 (8th January 1993)]
Fixed error handling bug in $hide‰s\_gen\_semantic\_const$.
\item[Issue 1.21 (8th January 1993)]
Added errors 50005, 50006.
\item[Issue 1.23 (19th January 1993)]
Added error 50007.
\item[Issue 1.24 (7th May 1994)]
Added $binding\_type\_spec$ and $tuple\_type\_spec$ to the signature.
Also added a new function $gen\_z\_semantic\_types$ which generates the types required for supporting semantic constants.
\item[Issue 1.25 (12th January 1996)]
Changed scope to indicate called for by HLD017.
\end{description}
\subsection{Changes Forecast}
The generated definitions will be subject to review during the
process of developing the Z proof support system. It may
be that the definitions which are generated are hard to
reason with, or that they incur an unacceptable performance
overhead in their use.

\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
Z constant generation mechanism for generated constants and
definitions for semantic constants which belong to infinite
families. This document has been produced in response to
\cite{DS/FMU/IED/HLD017}. The definitions which created by
the semantic constant definition functions are described in
\cite{DS/FMU/IED/ZED002}.

The design is
implemented in \cite{DS/FMU/IED/IMP050}, and the tests for
this module can be found in \cite{DS/FMU/IED/MDT050}.

\subsection{Introduction}

\subsubsection{Purpose and Background}
In the Z Proof Support Subsystem, two types of constants have been identified:
\begin{enumerate}
\item
 Individual semantic constants, see \cite{DS/FMU/IED/DTD052}.
\item 
Generated semantic constants: those which
belong to infinite families and hence need to be generated as
necessary. 
\end{enumerate}
This document gives the detailed design for the second
of these types. 

Two supporting functions are also provided by the module and
are present in the signature. These functions are fundamental
to the operation of constant generation and are called by
the semantic constant generation functions. The two functions
are also useful to the proof support system and are therefore
visible. They are $get\_binding\_info$ and $get\_tuple\_info$.

This document also reports an experiment carried out to
identify the optimal way of introducing new definitions into
the theory database. The conclusion of the experiment was
that the implementation of $const\_spec$ needed to be
improved with respect to performance. This has now
been done. The report is provided for the reader's entertainment
and edification. Its recommendations are now of historical
interest.

\subsubsection{Dependencies}

The functions in this document are dependent on many
features of the Release 1 HOL System.

The mechanism employed for
storing defining theorems for the generated types  will be a 
call to $labelled\_product\_spec$ of \cite{DS/FMU/IED/DTD059} and for storing defining theorems for the 
generated constants will be 
a call to $const\_spec$ of \cite{DS/FMU/IED/DTD012}.

\subsubsection{Deficiencies}

None known.


\section{THE SIGNATURE}

=DOC
signature ÛZGeneratedConstantsÝ = sig
=DESCRIBE
This is the signature for the Z Semantic Constant Generator
module.
=ENDDOC

\section{TUPLE AND PROJECTION FUNCTIONS}

These functions are provided in the signature for use
by the proof support system for Z.

=DOC
val Ûget_binding_infoÝ : TYPE -> TERM * TERM list;
=DESCRIBE
$get\_binding\_info$ takes a type which is a binding type,
e.g. $”('a, 'b)\$"Z'S[a,b]"®$, and returns a pair, the first of
which is the binding constructor, e.g. $¬\$"Z'Mk\_S[a,b]"®$ and
the second is a list of binding  projections, e.g.,
$[¬\$"Z'S[a,b]a"®, ¬\$"Z'S[a,b]b"®]$. The constructor and the
projection functions are related according to a family of
theorems which are introduced by the semantic constant
generator functions as required.
=USES
This interface is intended to be used by the Z proof support
modules.
=ENDDOC

=DOC
val Ûget_tuple_infoÝ : TYPE -> TERM * TERM list;
=DESCRIBE
$get\_tuple\_info$ takes a type which is a tuple type,
e.g. $”('a, 'b)\$"Z'T[2]"®$, and returns a pair, the first of
which is the tuple constructor, e.g. $¬\$"Z'Mk\_T[2]"®$ and
the second is a list of binding  projections, e.g.,
$[¬\$"Z'T[2]1"®, ¬\$"Z'T[2]2]"®$. The constructor and the
projection functions are related according to a family of
theorems which are introduced by the semantic constant
generator functions as required.
=USES
This interface is intended to be used by the Z proof support
modules.
=ENDDOC

=DOC
val Ûbinding_type_specÝ : TYPE -> THM;
=DESCRIBE
This function take a binding type, e.g., of the form $”(ú, ú) \$"Z'S[a,b]®"$. It introduces the type into the current cache theory if required, and proceeds to formulate the constructor and the projections for instances of this type, e.g.,
=GFT Example
ô ¬µ t x1 x2
  · ñ(a ¦ x1, b ¦ x2).a® = x1
      ± ñ(a ¦ x1, b ¦ x2).b® = x2
      ± ñ(a ¦ t.a, b ¦ t.b)® = t®
=ENDDOC

=DOC
val Ûtuple_type_specÝ : TYPE -> THM;
=DESCRIBE
This function take a tuple type, e.g., of the form $”(ú, ú) \$"Z'T[2]®"$. It introduces the type into the current cache theory if required, and proceeds to formulate the constructor and the projections for instances of this type, e.g.,
=GFT Example
ô ¬µ t x1 x2
  · ñ(x1, x2).1® = x1 ± ñ(x1, x2).2® = x2 ± ñ(t.1, t.2)® = t®
=ENDDOC

=DOC
val Ûgen_z_semantic_typesÝ : TYPE -> TYPE;
=DESCRIBE
This function recurses through the argument looking for tuple type and binding type constructors. Those found are introduced into the current cache theory if they are not already in scope. The value returned by this function is identical to its input.
=ENDDOC

\section{CONSTANT GENERATION FUNCTIONS}

Functions are required which introduce constants and
definitions to meet the ontological expections
of the mapping. The constants
required are members of infinite families. It is only
possible therefore to introduce a subset of these constants.
The rationale taken is that they are to be generated as required
by the user.

The first time a Z term is presented to the system whose
mapping in HOL requires one of these constants, the
call to the semantic constant generator causes the introduction
of the constant and its definition to be entered into the
cache theory for Z. Subsequent entries of same Z Term or
another which requires the same constants do not causes the
constant generator function to update the cache theory. Thus
the response times for subsequent uses of the term
are noticably shorter.

Semantic constants correspond to a Z construct such as
a set abstraction or a lambda abstraction. The name of the
constant indicates the sort of Z construct which requires it,
for example, names of
constants representing Z set abstraction are
formed from "Z'Seta" and an index, those of Z cross product
are formed from "Z'¸". Further examples can be seen from
examining the tables in sections \ref{num} to \ref{lab2}
inclusive.

The families fall into three general kinds,
numerically indexed, indexed by a single list of components and
indexed by two lists of components (generally speaking, although
they may be two lists of anything).


\subsection{Numerically-Indexed Families}\label{num}

The first are those constants which are indexed by a number
e.g., $Z'Ì[2]$, $Z'Seta[6]$. The identifying
number for these constants is generally
indicative of the number of arguments, or number of elements
in a Z declaration for the Z construct which introduces
the constant. For example $Z'Ì[2]$ represents a Z lambda
abstraction over two variables, e.g., $[X] (Ì a b :X · X)$.
So, names are comprised of an indicator of the part of the
mapping to which the constant relates, together with an index.

The table below illustrates the relationship between
names of semantic constants and the generator functions which
introduce the constants and their defining theorems into the
cache theory.

\begin{tabular}{|l|l|l|}\hline
Name&Generator Function&Example \\\hline
$Z'Seta$&$seta\_gen\_semantic\_const$&$Z'Seta[2]$ \\
$Z'Ì$&$Ì\_gen\_semantic\_const$&$Z'Ì[2]$ \\
$Z'¸$&$¸\_gen\_semantic\_const$&$Z'¸[2]$ \\
$Z'Í$&$Í\_gen\_semantic\_const$&$Z'Í[2]$ \\
$Z'¶‰1$&$¶‰1\_gen\_semantic\_const$&$Z'¶‰1[2]$ \\\hline
\end{tabular}

\subsection{Component-Indexed Families I}

The second family comprises constants whose names are
derived from a single list of names. These constants
tend to represent schemas, and the list of names correspond
to the components of the schema. e.g., $¬Z'„‰s[a,b,c]®$
represents a constant encapsulating the Z delta convention
associated with a schema with three components.

Note that the constant is polymorphic with respect to the
components. The type of $¬Z'„‰s[a,b,c]®$ contains
type variables associated with each of the components. Thus,
any future requirement of a constant with this name, no matter
what the type of the components of the schema, can be met
with the constant. This is the case for all generated
semantic constants.

The table below illustrates the relationship between
names of semantic constants and the generator functions
for the component-indexed family with 1 list as an index.

\begin{tabular}{|l|l|l|}\hline
Name&Description&Example \\\hline
$Z'‰s$&$schema\_gen\_semantic\_const$&$Z'‰s[a,b]$ \\
$Z'Pre‰s$&$pre‰s\_gen\_semantic\_const$&$Z'Pre‰s[a,b']$ \\
$Z'„‰s$&$„‰s\_gen\_semantic\_const$&$Z'„‰s[a,b]$ \\
$Z'˜‰s$&$˜‰s\_gen\_semantic\_const$&$Z'˜‰s[a,b]$ \\\hline
\end{tabular}

\subsection{Component-Indexed Families II}\label{lab2}

The third family comprise constants whose names are
derived from a two lists of names. These constants
tend to represent operations
on more than one schema, or operations on a schema which
involve the construction of a characteristic tuple from
a declaration, The two lists of names correspond
to the components of the schema(s) and/or the characteristic
tuple of a declaration. An example
of a constant in this group of families
is, $¬Z'±‰s[a,b][c,d]®$, which is the constant required
to represent a Z schema conjunction of two schemas
with components $a,b$ and $c,d$ respectively. This
constant is required when mapping a Z term e.g.,

$ñ[[a,b:X] ± [c,d:X]]®$.

The constant introduced is polymorphic with respect to the
components of the schemas as described in the previous
sub-section.

The table below illustrates the relationship between
names of semantic constants and the generator functions
for this, the most complicated of the semantic constant families.


\begin{tabular}{|l|l|l|}\hline
Name&Description&Example \\\hline
$Z'Dec‰s$&$dec‰s\_gen\_semantic\_const$&$Z'Dec‰s[a,b][']$ \\
$Z'±‰s$&$dyop‰s\_gen\_semantic\_const$&$Z'±‰s[a,b][c,d]$ \\
$Z'²‰s$&$dyop‰s\_gen\_semantic\_const$&$Z'²‰s[a,b][c,d]$ \\
$Z'´‰s$&$dyop‰s\_gen\_semantic\_const$&$Z'´‰s[a,b][c,d]$ \\
$Z'¤‰s$&$dyop‰s\_gen\_semantic\_const$&$Z'¤‰s[a,b][c,d]$ \\
$Z'ù‰s$&$ù‰s\_gen\_semantic\_const$&$Z'ù‰s[a,b][a]$ \\
$Z'Hide‰s$&$hide‰s\_gen\_semantic\_const$&$Z'Hide‰s[a,b][a]$ \\
$Z'µ‰s$&$quant‰s\_gen\_semantic\_const$&$Z'µ‰s[a][b]$ \\
$Z'¶‰s$&$quant‰s\_gen\_semantic\_const$&$Z'¶‰s[a][b]$ \\
$Z'¶‰1‰s$&$quant‰s\_gen\_semantic\_const$&$Z'¶‰1‰s[a][b]$ \\
$Z'»‰s$&$»‰s\_gen\_semantic\_const$&$Z'»[a,b][b',c]‰s$ \\
$Z'Rename‰s$&$rename‰s\_gen\_semantic\_const$&$Z'Rename‰s[a,b][x|a,y|b]$ \\\hline
\end{tabular}



\section{THE INTERFACES}

This section introduces the interfaces provided in
the structure $ZGeneratedConstants$.

=DOC
val Ûtuple_gen_semantic_constÝ : TERM -> THM;
val Ûseta_gen_semantic_constÝ : TERM -> THM;
val ÛÌ_gen_semantic_constÝ : TERM -> THM;
val Û¸_gen_semantic_constÝ : TERM -> THM;
val ÛÍ_gen_semantic_constÝ : TERM -> THM;
val Ûbinding_gen_semantic_constÝ : TERM -> THM;
val Û¶‰1_gen_semantic_constÝ : TERM -> THM;
val Ûschema_gen_semantic_constÝ : TERM -> THM;
val Ûpre‰s_gen_semantic_constÝ : TERM -> THM;
val Û„‰s_gen_semantic_constÝ : TERM -> THM;
val Û˜‰s_gen_semantic_constÝ : TERM -> THM;
val Ûdec‰s_gen_semantic_constÝ : TERM -> THM;
val Ûdyop‰s_gen_semantic_constÝ : TERM -> THM;
val Ûù‰s_gen_semantic_constÝ : TERM -> THM;
val Ûhide‰s_gen_semantic_constÝ : TERM -> THM;
val Ûquant‰s_gen_semantic_constÝ : TERM -> THM;
val Û»‰s_gen_semantic_constÝ : TERM -> THM;
val Ûrename‰s_gen_semantic_constÝ : TERM -> THM;
=DESCRIBE
These  functions define the dynamically
generated Z semantic constants.
The argument to each of these functions is a TERM
corresponding to some construct derived from the Z mapping.
Each term has the form $mk\_app(mk_const("NAME", ty), ...)$
where $NAME$ is the name of the constant which needs to be
introduced into the cache theory. By calling the constant
generator function with a term of this form, the constant
is introduced into the cache theory (if it is not already
there), and the function produces a definition which carries
the semantics of the constant - the defining
theorem. This is stored in the
cache theory, with any other defining theorems
required to carry the meaning for that constant.

Each of the interfaces should only be called with a term with a
corresponding constant.

e.g., $hide‰s\_gen\_semantic\_const$ $¬\$"Z'Hide‰s" ... ®$;

=USES
These functions must be called when the current theory is a
cache theory for Z, otherwise mapping will work incorrectly.
This should be arranged by calling the Kernel interface
function $do\_in\_theory$. e.g.,

$do\_in\_theory \ \ (force\_get\_cache\_theory())\ \ hide‰s\_gen\_semantic\_const \ \ tm$
=FAILURE
50001	?0 is an inappropriate argument to this constant generator function 
50002	Empty declarations are not supported in this version
50003	Design Error in generated semantic constant module (?0)
50004	An identifier to be hidden, ?0, is not a component of the schema in ?1
50005	A component of the binding schema, ?0, is not found in the 
	schema being bound, in ?1
50006	Name ?0 causes ?1 to be an inappropriate argument to this constant generator function
50007	Renaming problem: types ?0 and ?1 should be equal 
=ENDDOC

\section{EPILOGUE}
=SML
end (* of signature ZGeneratedConstants *);
=TEX

\section{CONST\_SPEC VERSUS SIMPLE\_NEW\_DEFINITION}

\subsection{Aim}
The aim of these experiments is to assess the relative merits of
using $const\_spec$ to introduce defining theorems for semantic constants, thus
increasing flexibility in the way that these theorems can be expressed, or using
$simple\_new\_definition$ which only permits definitions expressed as equations,
but performs faster than $const\_spec$.

\subsection{Method}

For the input, a definition of the form ¬f x = a® where ¬a® contains an occurrence of ¬x®,
is made using $const\_spec$. This is repeated several times, each definition varying
in the type of ¬x®. The total cpu time used, and the elapsed time are recorded
for these definitions.

The experiment is then repeated but the definitions of ¬f®
each take the form ¬Ì x · a®
where ¬a® contains an occurrence of ¬x®, and calling $simple\_new\_definition$.
The cpu and elapsed times for this are recorded and compared against those for
$const\_spec$.

\subsection{Input Data}


=GFT
push_pc "basic_hol";

open_theory"z_language";
delete_theory"performance" handle _ => ();
new_theory"performance";
=TEX
The input data is based upon the first 10 semantic constants for set abstraction.
The following constitutes the input data for calls to $simple\_new\_defn$.
=GFT SML Input
val def1_1 = ¬(Ì pack · {x |¶ a1
	· $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x})®;
val def1_2 = ¬(Ì pack · {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x})®;
val def1_3 = ¬(Ì pack · {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x})®;
val def1_4 = ¬(Ì pack · {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x})®;
val def1_5 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x})®;
val def1_6 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x})®;
val def1_7 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x})®;
val def1_8 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x})®;
val def1_9 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x})®;
val def1_10 = ¬(Ì pack · {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x})®;


val x1 = (["seta1"],"seta1",def1_1);
val x2 = (["seta2"],"seta2",def1_2);
val x3 = (["seta3"],"seta3",def1_3);
val x4 = (["seta4"],"seta4",def1_4);
val x5 = (["seta5"],"seta5",def1_5);
val x6 = (["seta6"],"seta6",def1_6);
val x7 = (["seta7"],"seta7",def1_7);
val x8 = (["seta8"],"seta8",def1_8);
val x9 = (["seta9"],"seta9",def1_9);
val x10 = (["seta10"],"seta10",def1_10);
=TEX
The following constitutes the input data for calls to $const\_spec$.
=GFT SML Input
val cs1_1 = ¬µ pack · seta1' pack = {x |¶ a1 · $"Z'S[d,p,v]d" (pack a1)
	± $"Z'S[d,p,v]p" (pack a1)
	± $"Z'S[d,p,v]v" (pack a1) = x}®;
val cs1_2 = ¬µ pack · seta2' pack = {x |¶ a1 a2
	· $"Z'S[d,p,v]d" (pack a1 a2)
	± $"Z'S[d,p,v]p" (pack a1 a2)
	± $"Z'S[d,p,v]v" (pack a1 a2) = x}®;
val cs1_3 = ¬µ pack · seta3' pack = {x |¶ a1 a2 a3
	· $"Z'S[d,p,v]d" (pack a1 a2 a3)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3) = x}®;
val cs1_4 = ¬µ pack · seta4' pack = {x |¶ a1 a2 a3 a4
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4) = x}®;
val cs1_5 = ¬µ pack · seta5' pack = {x |¶ a1 a2 a3 a4 a5
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5) = x}®;
val cs1_6 = ¬µ pack · seta6' pack = {x |¶ a1 a2 a3 a4 a5 a6
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6) = x}®;
val cs1_7 = ¬µ pack · seta7' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7) = x}®;
val cs1_8 = ¬µ pack · seta8' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8) = x}®;
val cs1_9 = ¬µ pack · seta9' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9) = x}®;
val cs1_10 = ¬µ pack · seta10' pack = {x |¶ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10
	· $"Z'S[d,p,v]d" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]p" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	± $"Z'S[d,p,v]v" (pack a1 a2 a3 a4 a5 a6 a7 a8 a9 a10) = x}®;

val y1 = (["seta1'"], frees cs1_1, cs1_1);
val y2 = (["seta2'"], frees cs1_2, cs1_2);
val y3 = (["seta3'"], frees cs1_3, cs1_3);
val y4 = (["seta4'"], frees cs1_4, cs1_4);
val y5 = (["seta5'"], frees cs1_5, cs1_5);
val y6 = (["seta6'"], frees cs1_6, cs1_6);
val y7 = (["seta7'"], frees cs1_7, cs1_7);
val y8 = (["seta8'"], frees cs1_8, cs1_8);
val y9 = (["seta9'"], frees cs1_9, cs1_9);
val y10 = (["seta10'"], frees cs1_10, cs1_10);
=TEX
The following Standard ML code maps the appropriate functions over the
test data and returns the results.
=GFT SML Input
"simple_new_defn ...";
PolyML.timing true;
val _ = map simple_new_defn [x1, x2, x3, x4, x5, x6, x7, x8, x9, x10];
PolyML.timing false;
"Const_spec ...";
PolyML.timing true;
val _ = map const_spec [y1, y2, y3, y4, y5, y6, y7, y8, y9, y10];
PolyML.timing false;
=TEX

\subsection{Results}


The results recorded for a Sun 3/60 (12Mb) are as follows:

\begin{tabular}{|l|l|}\hline
&elapsed time (s)\\\hline
simple\_new\_defn&12.1\\
&13.1 \\
&12.2 \\
&\\\hline
const\_spec&376.9 \\
&371.1 \\
\hline
\end{tabular}

=TEX
\subsection{Conclusion}

The results for $const\_spec$ are comparatively poor.
Due to the strong requirement for loose definitions
for some of the generated semantic constants, it is
recommended that improvements be made to $const\_spec$
to permit its use in the generated semantic constants
module.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}



